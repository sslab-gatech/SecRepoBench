// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// MagickCore/profile.c
// static void Sync8BimProfile(const Image *image,const StringInfo *profile)
// {
//   size_t
//     length;
// 
//   ssize_t
//     count;
// 
//   unsigned char
//     *p;
// 
//   unsigned short
//     id;
// 
//   length=GetStringInfoLength(profile);
//   p=GetStringInfoDatum(profile);
//   while (length != 0)
//   {
//     if (ReadProfileByte(&p,&length) != 0x38)
//       continue;
//     if (ReadProfileByte(&p,&length) != 0x42)
//       continue;
//     if (ReadProfileByte(&p,&length) != 0x49)
//       continue;
//     if (ReadProfileByte(&p,&length) != 0x4D)
//       continue;
//     if (length < 7)
//       return;
//     id=(unsigned short) ReadProfileMSBShort(&p,&length);
//     count=(ssize_t) ReadProfileByte(&p,&length);
//     if ((count >= (ssize_t) length) || (count < 0))
//       return;
//     p+=count;
//     length-=(size_t) count;
//     if ((*p & 0x01) == 0)
//       (void) ReadProfileByte(&p,&length);
//     count=(ssize_t) ReadProfileMSBLong(&p,&length);
//     if ((count > (ssize_t) length) || (count < 0))
//       return;
//     if ((id == 0x3ED) && (count == 16))
//       {
//         if (image->units == PixelsPerCentimeterResolution)
//           WriteProfileLong(MSBEndian,(unsigned int) CastDoubleToLong(
//             image->resolution.x*2.54*65536.0),p);
//         else
//           WriteProfileLong(MSBEndian,(unsigned int) CastDoubleToLong(
//             image->resolution.x*65536.0),p);
//         WriteProfileShort(MSBEndian,(unsigned short) image->units,p+4);
//         if (image->units == PixelsPerCentimeterResolution)
//           WriteProfileLong(MSBEndian,(unsigned int) CastDoubleToLong(
//             image->resolution.y*2.54*65536.0),p+8);
//         else
//           WriteProfileLong(MSBEndian,(unsigned int) CastDoubleToLong(
//             image->resolution.y*65536.0),p+8);
//         WriteProfileShort(MSBEndian,(unsigned short) image->units,p+12);
//       }
//     if (id == 0x0422)
//       SyncExifProfile(image,p,(size_t) count);
//     p+=count;
//     length-=(size_t) count;
//   }
//   return;
// }

// the below code fragment can be found in:
// coders/thumbnail.c
// static MagickBooleanType WriteTHUMBNAILImage(const ImageInfo *image_info,
//   Image *image,ExceptionInfo *exception)
// {
//   const char
//     *property;
// 
//   const MagickInfo
//     *magick_info;
// 
//   const StringInfo
//     *profile;
// 
//   Image
//     *thumbnail_image;
// 
//   ImageInfo
//     *write_info;
// 
//   MagickBooleanType
//     status;
// 
//   ssize_t
//     i;
// 
//   size_t
//     length;
// 
//   ssize_t
//     offset;
// 
//   unsigned char
//     *q;
// 
//   profile=GetImageProfile(image,"exif");
//   if (profile == (const StringInfo *) NULL)
//     ThrowWriterException(CoderError,"ImageDoesNotHaveAThumbnail");
//   property=GetImageProperty(image,"exif:JPEGInterchangeFormat",exception);
//   if (property == (const char *) NULL)
//     ThrowWriterException(CoderError,"ImageDoesNotHaveAThumbnail");
//   offset=(ssize_t) StringToLong(property);
//   if (offset < 0)
//     ThrowWriterException(CoderError,"ImageDoesNotHaveAThumbnail");
//   property=GetImageProperty(image,"exif:JPEGInterchangeFormatLength",exception);
//   if (property == (const char *) NULL)
//     ThrowWriterException(CoderError,"ImageDoesNotHaveAThumbnail");
//   length=(size_t) StringToLong(property);
//   q=GetStringInfoDatum(profile)+offset;
//   for (i=offset; i < (ssize_t) GetStringInfoLength(profile) - 3; i++)
//   {
//     if (memcmp(q,"\377\330\377",3) == 0)
//       break;
//     q++;
//   }
//   if ((q > (GetStringInfoDatum(profile)+GetStringInfoLength(profile))) ||
//       ((ssize_t) length > (GetStringInfoDatum(profile)+GetStringInfoLength(profile)-q)))
//     ThrowWriterException(CoderError,"ImageDoesNotHaveAThumbnail");
//   thumbnail_image=BlobToImage(image_info,q,length,exception);
//   if (thumbnail_image == (Image *) NULL)
//     return(MagickFalse);
//   (void) SetImageType(thumbnail_image,thumbnail_image->alpha_trait ==
//     UndefinedPixelTrait ? TrueColorType : TrueColorAlphaType,exception);
//   (void) CopyMagickString(thumbnail_image->filename,image->filename,
//     MagickPathExtent);
//   write_info=CloneImageInfo(image_info);
//   *write_info->magick='\0';
//   (void) SetImageInfo(write_info,1,exception);
//   magick_info=GetMagickInfo(write_info->magick,exception);
//   if ((magick_info == (const MagickInfo*) NULL) ||
//       (LocaleCompare(magick_info->magick_module,"THUMBNAIL") == 0))
//     (void) FormatLocaleString(thumbnail_image->filename,MagickPathExtent,
//       "miff:%s",write_info->filename);
//   status=WriteImage(write_info,thumbnail_image,exception);
//   thumbnail_image=DestroyImage(thumbnail_image);
//   write_info=DestroyImageInfo(write_info);
//   return(status);
// }

// the below code fragment can be found in:
// MagickCore/constitute.c
// MagickExport Image *ReadImage(const ImageInfo *image_info,
//   ExceptionInfo *exception)
// {
//   char
//     filename[MagickPathExtent],
//     magick[MagickPathExtent],
//     magick_filename[MagickPathExtent];
// 
//   ConstituteInfo
//     constitute_info;
// 
//   const DelegateInfo
//     *delegate_info;
// 
//   const MagickInfo
//     *magick_info;
// 
//   DecodeImageHandler
//     *decoder;
// 
//   ExceptionInfo
//     *sans_exception;
// 
//   Image
//     *image,
//     *next;
// 
//   ImageInfo
//     *read_info;
// 
//   MagickBooleanType
//     status;
// 
//   /*
//     Determine image type from filename prefix or suffix (e.g. image.jpg).
//   */
//   assert(image_info != (ImageInfo *) NULL);
//   assert(image_info->signature == MagickCoreSignature);
//   assert(image_info->filename != (char *) NULL);
//   if (IsEventLogging() != MagickFalse)
//     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",
//       image_info->filename);
//   assert(exception != (ExceptionInfo *) NULL);
//   read_info=CloneImageInfo(image_info);
//   (void) CopyMagickString(magick_filename,read_info->filename,MagickPathExtent);
//   (void) SetImageInfo(read_info,0,exception);
//   (void) CopyMagickString(filename,read_info->filename,MagickPathExtent);
//   (void) CopyMagickString(magick,read_info->magick,MagickPathExtent);
//   /*
//     Call appropriate image reader based on image type.
//   */
//   sans_exception=AcquireExceptionInfo();
//   magick_info=GetMagickInfo(read_info->magick,sans_exception);
//   if (sans_exception->severity == PolicyError)
//     InheritException(exception,sans_exception);
//   sans_exception=DestroyExceptionInfo(sans_exception);
//   if (magick_info != (const MagickInfo *) NULL)
//     {
//       if (GetMagickEndianSupport(magick_info) == MagickFalse)
//         read_info->endian=UndefinedEndian;
//       else
//         if ((image_info->endian == UndefinedEndian) &&
//             (GetMagickRawSupport(magick_info) != MagickFalse))
//           {
//             unsigned long
//               lsb_first;
// 
//             lsb_first=1;
//             read_info->endian=(*(char *) &lsb_first) == 1 ? LSBEndian :
//               MSBEndian;
//          }
//     }
//   if ((magick_info != (const MagickInfo *) NULL) &&
//       (GetMagickDecoderSeekableStream(magick_info) != MagickFalse))
//     {
//       image=AcquireImage(read_info,exception);
//       (void) CopyMagickString(image->filename,read_info->filename,
//         MagickPathExtent);
//       status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
//       if (status == MagickFalse)
//         {
//           read_info=DestroyImageInfo(read_info);
//           image=DestroyImage(image);
//           return((Image *) NULL);
//         }
//       if (IsBlobSeekable(image) == MagickFalse)
//         {
//           /*
//             Coder requires a seekable stream.
//           */
//           *read_info->filename='\0';
//           status=ImageToFile(image,read_info->filename,exception);
//           if (status == MagickFalse)
//             {
//               (void) CloseBlob(image);
//               read_info=DestroyImageInfo(read_info);
//               image=DestroyImage(image);
//               return((Image *) NULL);
//             }
//           read_info->temporary=MagickTrue;
//         }
//       (void) CloseBlob(image);
//       image=DestroyImage(image);
//     }
//   image=NewImageList();
//   decoder=GetImageDecoder(magick_info);
//   if (decoder == (DecodeImageHandler *) NULL)
//     {
//       delegate_info=GetDelegateInfo(read_info->magick,(char *) NULL,exception);
//       if (delegate_info == (const DelegateInfo *) NULL)
//         {
//           (void) SetImageInfo(read_info,0,exception);
//           (void) CopyMagickString(read_info->filename,filename,
//             MagickPathExtent);
//           magick_info=GetMagickInfo(read_info->magick,exception);
//           decoder=GetImageDecoder(magick_info);
//         }
//     }
//   if (decoder != (DecodeImageHandler *) NULL)
//     {
//       /*
//         Call appropriate image reader based on image type.
//       */
//       if ((magick_info != (const MagickInfo *) NULL) &&
//           (GetMagickDecoderThreadSupport(magick_info) == MagickFalse))
//         LockSemaphoreInfo(magick_info->semaphore);
//       status=IsCoderAuthorized(read_info->magick,ReadPolicyRights,exception);
//       image=(Image *) NULL;
//       if (status != MagickFalse)
//         image=decoder(read_info,exception);
//       if ((magick_info != (const MagickInfo *) NULL) &&
//           (GetMagickDecoderThreadSupport(magick_info) == MagickFalse))
//         UnlockSemaphoreInfo(magick_info->semaphore);
//     }
//   else
//     {
//       delegate_info=GetDelegateInfo(read_info->magick,(char *) NULL,exception);
//       if (delegate_info == (const DelegateInfo *) NULL)
//         {
//           (void) ThrowMagickException(exception,GetMagickModule(),
//             MissingDelegateError,"NoDecodeDelegateForThisImageFormat","`%s'",
//             read_info->magick);
//           if (read_info->temporary != MagickFalse)
//             (void) RelinquishUniqueFileResource(read_info->filename);
//           read_info=DestroyImageInfo(read_info);
//           return((Image *) NULL);
//         }
//       /*
//         Let our decoding delegate process the image.
//       */
//       image=AcquireImage(read_info,exception);
//       if (image == (Image *) NULL)
//         {
//           read_info=DestroyImageInfo(read_info);
//           return((Image *) NULL);
//         }
//       (void) CopyMagickString(image->filename,read_info->filename,
//         MagickPathExtent);
//       *read_info->filename='\0';
//       if (GetDelegateThreadSupport(delegate_info) == MagickFalse)
//         LockSemaphoreInfo(delegate_info->semaphore);
//       status=InvokeDelegate(read_info,image,read_info->magick,(char *) NULL,
//         exception);
//       if (GetDelegateThreadSupport(delegate_info) == MagickFalse)
//         UnlockSemaphoreInfo(delegate_info->semaphore);
//       image=DestroyImageList(image);
//       read_info->temporary=MagickTrue;
//       if (status != MagickFalse)
//         (void) SetImageInfo(read_info,0,exception);
//       magick_info=GetMagickInfo(read_info->magick,exception);
//       decoder=GetImageDecoder(magick_info);
//       if (decoder == (DecodeImageHandler *) NULL)
//         {
//           if (IsPathAccessible(read_info->filename) != MagickFalse)
//             (void) ThrowMagickException(exception,GetMagickModule(),
//               MissingDelegateError,"NoDecodeDelegateForThisImageFormat","`%s'",
//               read_info->magick);
//           else
//             ThrowFileException(exception,FileOpenError,"UnableToOpenFile",
//               read_info->filename);
//           read_info=DestroyImageInfo(read_info);
//           return((Image *) NULL);
//         }
//       /*
//         Call appropriate image reader based on image type.
//       */
//       if (GetMagickDecoderThreadSupport(magick_info) == MagickFalse)
//         LockSemaphoreInfo(magick_info->semaphore);
//       status=IsCoderAuthorized(read_info->magick,ReadPolicyRights,exception);
//       image=(Image *) NULL;
//       if (status != MagickFalse)
//         image=(decoder)(read_info,exception);
//       if (GetMagickDecoderThreadSupport(magick_info) == MagickFalse)
//         UnlockSemaphoreInfo(magick_info->semaphore);
//     }
//   if (read_info->temporary != MagickFalse)
//     {
//       (void) RelinquishUniqueFileResource(read_info->filename);
//       read_info->temporary=MagickFalse;
//       if (image != (Image *) NULL)
//         (void) CopyMagickString(image->filename,filename,MagickPathExtent);
//     }
//   if (image == (Image *) NULL)
//     {
//       read_info=DestroyImageInfo(read_info);
//       return(image);
//     }
//   if (exception->severity >= ErrorException)
//     (void) LogMagickEvent(ExceptionEvent,GetMagickModule(),
//       "Coder (%s) generated an image despite an error (%d), "
//       "notify the developers",image->magick,exception->severity);
//   if (IsBlobTemporary(image) != MagickFalse)
//     (void) RelinquishUniqueFileResource(read_info->filename);
//   if ((IsSceneGeometry(read_info->scenes,MagickFalse) != MagickFalse) &&
//       (GetImageListLength(image) != 1))
//     {
//       Image
//         *clones;
// 
//       clones=CloneImages(image,read_info->scenes,exception);
//       if (clones != (Image *) NULL)
//         {
//           image=DestroyImageList(image);
//           image=GetFirstImageInList(clones);
//         }
//     }
//   InitializeConstituteInfo(read_info,&constitute_info);
//   for (next=image; next != (Image *) NULL; next=GetNextImageInList(next))
//   {
//     char
//       magick_path[MagickPathExtent],
//       *property;
// 
//     const StringInfo
//       *profile;
// 
//     static const char
//       *source_date_epoch = (const char *) NULL;
// 
//     static MagickBooleanType
//       epoch_initialized = MagickFalse;
// 
//     next->taint=MagickFalse;
//     GetPathComponent(magick_filename,MagickPath,magick_path);
//     if ((*magick_path == '\0') && (*next->magick == '\0'))
//       (void) CopyMagickString(next->magick,magick,MagickPathExtent);
//     (void) CopyMagickString(next->magick_filename,magick_filename,
//       MagickPathExtent);
//     if (IsBlobTemporary(image) != MagickFalse)
//       (void) CopyMagickString(next->filename,filename,MagickPathExtent);
//     if (next->magick_columns == 0)
//       next->magick_columns=next->columns;
//     if (next->magick_rows == 0)
//       next->magick_rows=next->rows;
//     (void) GetImageProperty(next,"exif:*",exception);
//     (void) GetImageProperty(next,"icc:*",exception);
//     (void) GetImageProperty(next,"iptc:*",exception);
//     (void) GetImageProperty(next,"xmp:*",exception);
//     SyncOrientationFromProperties(next,&constitute_info,exception);
//     SyncResolutionFromProperties(next,&constitute_info,exception);
//     if (next->page.width == 0)
//       next->page.width=next->columns;
//     if (next->page.height == 0)
//       next->page.height=next->rows;
//     if (constitute_info.caption != (const char *) NULL)
//       {
//         property=InterpretImageProperties(read_info,next,
//           constitute_info.caption,exception);
//         (void) SetImageProperty(next,"caption",property,exception);
//         property=DestroyString(property);
//       }
//     if (constitute_info.comment != (const char *) NULL)
//       {
//         property=InterpretImageProperties(read_info,next,
//           constitute_info.comment,exception);
//         (void) SetImageProperty(next,"comment",property,exception);
//         property=DestroyString(property);
//       }
//     if (constitute_info.label != (const char *) NULL)
//       {
//         property=InterpretImageProperties(read_info,next,
//           constitute_info.label,exception);
//         (void) SetImageProperty(next,"label",property,exception);
//         property=DestroyString(property);
//       }
//     if (LocaleCompare(next->magick,"TEXT") == 0)
//       (void) ParseAbsoluteGeometry("0x0+0+0",&next->page);
//     if ((read_info->extract != (char *) NULL) &&
//         (read_info->stream == (StreamHandler) NULL))
//       {
//         RectangleInfo
//           geometry;
// 
//         MagickStatusType
//           flags;
// 
//         SetGeometry(next,&geometry);
//         flags=ParseAbsoluteGeometry(read_info->extract,&geometry);
//         if ((next->columns != geometry.width) ||
//             (next->rows != geometry.height))
//           {
//             if (((flags & XValue) != 0) || ((flags & YValue) != 0))
//               {
//                 Image
//                   *crop_image;
// 
//                 crop_image=CropImage(next,&geometry,exception);
//                 if (crop_image != (Image *) NULL)
//                   ReplaceImageInList(&next,crop_image);
//               }
//             else
//               if (((flags & WidthValue) != 0) || ((flags & HeightValue) != 0))
//                 {
//                   flags=ParseRegionGeometry(next,read_info->extract,&geometry,
//                     exception);
//                   if ((geometry.width != 0) && (geometry.height != 0))
//                     {
//                       Image *resize_image = ResizeImage(next,geometry.width,
//                         geometry.height,next->filter,exception);
//                       if (resize_image != (Image *) NULL)
//                         ReplaceImageInList(&next,resize_image);
//                     }
//                 }
//           }
//       }
//     profile=GetImageProfile(next,"icc");
//     if (profile == (const StringInfo *) NULL)
//       profile=GetImageProfile(next,"icm");
//     profile=GetImageProfile(next,"iptc");
//     if (profile == (const StringInfo *) NULL)
//       profile=GetImageProfile(next,"8bim");
//     if (epoch_initialized == MagickFalse)
//       {
//         source_date_epoch=getenv("SOURCE_DATE_EPOCH");
//         epoch_initialized=MagickTrue;
//       }
//     if (source_date_epoch == (const char *) NULL)
//       {
//         char
//           timestamp[MagickTimeExtent];
// 
//         (void) FormatMagickTime(next->timestamp,sizeof(timestamp),timestamp);
//         (void) SetImageProperty(next,"date:timestamp",timestamp,exception);
//         (void) FormatMagickTime((time_t) GetBlobProperties(next)->st_mtime,
//           sizeof(timestamp),timestamp);
//         (void) SetImageProperty(next,"date:modify",timestamp,exception);
//         (void) FormatMagickTime((time_t) GetBlobProperties(next)->st_ctime,
//           sizeof(timestamp),timestamp);
//         (void) SetImageProperty(next,"date:create",timestamp,exception);
//       }
//     if (constitute_info.delay_flags != NoValue)
//       {
//         if ((constitute_info.delay_flags & GreaterValue) != 0)
//           {
//             if (next->delay > constitute_info.delay)
//               next->delay=constitute_info.delay;
//           }
//         else
//           if ((constitute_info.delay_flags & LessValue) != 0)
//             {
//               if (next->delay < constitute_info.delay)
//                 next->delay=constitute_info.delay;
//             }
//           else
//             next->delay=constitute_info.delay;
//         if ((constitute_info.delay_flags & SigmaValue) != 0)
//           next->ticks_per_second=constitute_info.ticks_per_second;
//       }
//     if (constitute_info.dispose != (const char *) NULL)
//       {
//         ssize_t
//           option_type;
// 
//         option_type=ParseCommandOption(MagickDisposeOptions,MagickFalse,
//           constitute_info.dispose);
//         if (option_type >= 0)
//           next->dispose=(DisposeType) option_type;
//       }
//     if (read_info->verbose != MagickFalse)
//       (void) IdentifyImage(next,stderr,MagickFalse,exception);
//     image=next;
//   }
//   read_info=DestroyImageInfo(read_info);
//   if (GetBlobError(image) != MagickFalse)
//     ThrowReaderException(CorruptImageError,"UnableToReadImageData");
//   return(GetFirstImageInList(image));
// }

// the below code fragment can be found in:
// coders/jpeg.c
// static void SkipInputData(j_decompress_ptr compress_info,long number_bytes)
// {
//   SourceManager
//     *source;
// 
//   if (number_bytes <= 0)
//     return;
//   source=(SourceManager *) compress_info->src;
//   while (number_bytes > (long) source->manager.bytes_in_buffer)
//   {
//     number_bytes-=(long) source->manager.bytes_in_buffer;
//     (void) FillInputBuffer(compress_info);
//   }
//   source->manager.next_input_byte+=number_bytes;
//   source->manager.bytes_in_buffer-=(size_t) number_bytes;
// }

// the below code fragment can be found in:
// MagickCore/property.c
// static char *TracePSClippath(const unsigned char *blob,size_t length)
// {
//   char
//     *path,
//     *message;
// 
//   MagickBooleanType
//     in_subpath;
// 
//   PointInfo
//     first[3],
//     last[3],
//     point[3];
// 
//   ssize_t
//     i,
//     x;
// 
//   ssize_t
//     knot_count,
//     selector,
//     y;
// 
//   path=AcquireString((char *) NULL);
//   if (path == (char *) NULL)
//     return((char *) NULL);
//   message=AcquireString((char *) NULL);
//   (void) FormatLocaleString(message,MagickPathExtent,"/ClipImage\n");
//   (void) ConcatenateString(&path,message);
//   (void) FormatLocaleString(message,MagickPathExtent,"{\n");
//   (void) ConcatenateString(&path,message);
//   (void) FormatLocaleString(message,MagickPathExtent,
//     "  /c {curveto} bind def\n");
//   (void) ConcatenateString(&path,message);
//   (void) FormatLocaleString(message,MagickPathExtent,
//     "  /l {lineto} bind def\n");
//   (void) ConcatenateString(&path,message);
//   (void) FormatLocaleString(message,MagickPathExtent,
//     "  /m {moveto} bind def\n");
//   (void) ConcatenateString(&path,message);
//   (void) FormatLocaleString(message,MagickPathExtent,
//     "  /v {currentpoint 6 2 roll curveto} bind def\n");
//   (void) ConcatenateString(&path,message);
//   (void) FormatLocaleString(message,MagickPathExtent,
//     "  /y {2 copy curveto} bind def\n");
//   (void) ConcatenateString(&path,message);
//   (void) FormatLocaleString(message,MagickPathExtent,
//     "  /z {closepath} bind def\n");
//   (void) ConcatenateString(&path,message);
//   (void) FormatLocaleString(message,MagickPathExtent,"  newpath\n");
//   (void) ConcatenateString(&path,message);
//   /*
//     The clipping path format is defined in "Adobe Photoshop File Formats
//     Specification" version 6.0 downloadable from adobe.com.
//   */
//   (void) memset(point,0,sizeof(point));
//   (void) memset(first,0,sizeof(first));
//   (void) memset(last,0,sizeof(last));
//   knot_count=0;
//   in_subpath=MagickFalse;
//   while (length > 0)
//   {
//     selector=(ssize_t) ReadPropertyMSBShort(&blob,&length);
//     switch (selector)
//     {
//       case 0:
//       case 3:
//       {
//         if (knot_count != 0)
//           {
//             blob+=24;
//             length=(size_t) ((ssize_t) length-MagickMin(24,(ssize_t) length));
//             break;
//           }
//         /*
//           Expected subpath length record.
//         */
//         knot_count=(ssize_t) ReadPropertyMSBShort(&blob,&length);
//         blob+=22;
//         length=(size_t) ((ssize_t) length-MagickMin(22,(ssize_t) length));
//         break;
//       }
//       case 1:
//       case 2:
//       case 4:
//       case 5:
//       {
//         if (knot_count == 0)
//           {
//             /*
//               Unexpected subpath knot
//             */
//             blob+=24;
//             length=(size_t) ((ssize_t) length-MagickMin(24,(ssize_t) length));
//             break;
//           }
//         /*
//           Add sub-path knot
//         */
//         for (i=0; i < 3; i++)
//         {
//           y=(ssize_t) ReadPropertyMSBLong(&blob,&length);
//           x=(ssize_t) ReadPropertyMSBLong(&blob,&length);
//           point[i].x=(double) x/4096.0/4096.0;
//           point[i].y=1.0-(double) y/4096.0/4096.0;
//         }
//         if (in_subpath == MagickFalse)
//           {
//             (void) FormatLocaleString(message,MagickPathExtent,"  %g %g m\n",
//               point[1].x,point[1].y);
//             for (i=0; i < 3; i++)
//             {
//               first[i]=point[i];
//               last[i]=point[i];
//             }
//           }
//         else
//           {
//             /*
//               Handle special cases when Bezier curves are used to describe
//               corners and straight lines.
//             */
//             if ((last[1].x == last[2].x) && (last[1].y == last[2].y) &&
//                 (point[0].x == point[1].x) && (point[0].y == point[1].y))
//               (void) FormatLocaleString(message,MagickPathExtent,
//                 "  %g %g l\n",point[1].x,point[1].y);
//             else
//               if ((last[1].x == last[2].x) && (last[1].y == last[2].y))
//                 (void) FormatLocaleString(message,MagickPathExtent,
//                   "  %g %g %g %g v\n",point[0].x,point[0].y,
//                   point[1].x,point[1].y);
//               else
//                 if ((point[0].x == point[1].x) && (point[0].y == point[1].y))
//                   (void) FormatLocaleString(message,MagickPathExtent,
//                     "  %g %g %g %g y\n",last[2].x,last[2].y,
//                     point[1].x,point[1].y);
//                 else
//                   (void) FormatLocaleString(message,MagickPathExtent,
//                     "  %g %g %g %g %g %g c\n",last[2].x,
//                     last[2].y,point[0].x,point[0].y,point[1].x,point[1].y);
//             for (i=0; i < 3; i++)
//               last[i]=point[i];
//           }
//         (void) ConcatenateString(&path,message);
//         in_subpath=MagickTrue;
//         knot_count--;
//         /*
//           Close the subpath if there are no more knots.
//         */
//         if (knot_count == 0)
//           {
//             /*
//               Same special handling as above except we compare to the
//               first point in the path and close the path.
//             */
//             if ((last[1].x == last[2].x) && (last[1].y == last[2].y) &&
//                 (first[0].x == first[1].x) && (first[0].y == first[1].y))
//               (void) FormatLocaleString(message,MagickPathExtent,
//                 "  %g %g l z\n",first[1].x,first[1].y);
//             else
//               if ((last[1].x == last[2].x) && (last[1].y == last[2].y))
//                 (void) FormatLocaleString(message,MagickPathExtent,
//                   "  %g %g %g %g v z\n",first[0].x,first[0].y,
//                   first[1].x,first[1].y);
//               else
//                 if ((first[0].x == first[1].x) && (first[0].y == first[1].y))
//                   (void) FormatLocaleString(message,MagickPathExtent,
//                     "  %g %g %g %g y z\n",last[2].x,last[2].y,
//                     first[1].x,first[1].y);
//                 else
//                   (void) FormatLocaleString(message,MagickPathExtent,
//                     "  %g %g %g %g %g %g c z\n",last[2].x,
//                     last[2].y,first[0].x,first[0].y,first[1].x,first[1].y);
//             (void) ConcatenateString(&path,message);
//             in_subpath=MagickFalse;
//           }
//         break;
//       }
//       case 6:
//       case 7:
//       case 8:
//       default:
//       {
//         blob+=24;
//         length=(size_t) ((ssize_t) length-MagickMin(24,(ssize_t) length));
//         break;
//       }
//     }
//   }
//   /*
//     Returns an empty PS path if the path has no knots.
//   */
//   (void) FormatLocaleString(message,MagickPathExtent,"  eoclip\n");
//   (void) ConcatenateString(&path,message);
//   (void) FormatLocaleString(message,MagickPathExtent,"} bind def");
//   (void) ConcatenateString(&path,message);
//   message=DestroyString(message);
//   return(path);
// }

