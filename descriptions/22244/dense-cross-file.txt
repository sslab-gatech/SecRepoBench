// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/lib/protocols/openft.c
void ndpi_search_openft_tcp(struct ndpi_detection_module_struct
							  *ndpi_struct, struct ndpi_flow_struct *flow)
{
	struct ndpi_packet_struct *packet = &flow->packet;
	
	if (packet->payload_packet_len > 5 && memcmp(packet->payload, "GET /", 5) == 0) {
		NDPI_LOG_DBG2(ndpi_struct, "HTTP packet detected\n");
		ndpi_parse_packet_line_info(ndpi_struct, flow);
		if (packet->parsed_lines >= 2
			&& packet->line[1].len > 13 && memcmp(packet->line[1].ptr, "X-OpenftAlias:", 14) == 0) {
			NDPI_LOG_INFO(ndpi_struct, "found OpenFT\n");
			ndpi_int_openft_add_connection(ndpi_struct, flow);
			return;
		}
	}

	NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
}

// the below code fragment can be found in:
// src/lib/protocols/pptp.c
void ndpi_search_pptp(struct ndpi_detection_module_struct
						*ndpi_struct, struct ndpi_flow_struct *flow)
{
	struct ndpi_packet_struct *packet = &flow->packet;
	
	NDPI_LOG_DBG(ndpi_struct, "search pptp\n");

	if (packet->payload_packet_len >= 10 && get_u_int16_t(packet->payload, 0) == htons(packet->payload_packet_len)
		&& get_u_int16_t(packet->payload, 2) == htons(0x0001)	/* message type: control message */
		&&get_u_int32_t(packet->payload, 4) == htonl(0x1a2b3c4d)	/* cookie: correct */
		&&(get_u_int16_t(packet->payload, 8) == htons(0x0001)	/* control type: start-control-connection-request */
		)) {

		NDPI_LOG_INFO(ndpi_struct, "found pptp\n");
		ndpi_int_pptp_add_connection(ndpi_struct, flow);
		return;
	}

	NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
}

// the below code fragment can be found in:
// src/lib/protocols/ciscovpn.c
void ndpi_search_ciscovpn(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow)
{
  struct ndpi_packet_struct *packet = &flow->packet;
  u_int16_t udport = 0, usport = 0;
  u_int16_t tdport = 0, tsport = 0;


  NDPI_LOG_DBG(ndpi_struct, "search CISCOVPN\n");

  if(packet->tcp != NULL) {
    tsport = ntohs(packet->tcp->source), tdport = ntohs(packet->tcp->dest);
    NDPI_LOG_DBG2(ndpi_struct, "calculated CISCOVPN over tcp ports\n");
  }
  if(packet->udp != NULL) {
    usport = ntohs(packet->udp->source), udport = ntohs(packet->udp->dest);
    NDPI_LOG_DBG2(ndpi_struct, "calculated CISCOVPN over udp ports\n");
  }

  if((tdport == 10000 && tsport == 10000) ||
     ((tsport == 443 || tdport == 443) &&
      (packet->payload_packet_len >= 4) &&
      (packet->payload[0] == 0x17 &&
       packet->payload[1] == 0x01 &&
       packet->payload[2] == 0x00 &&
       packet->payload[3] == 0x00)
      )
     )

    {
      /* This is a good query  17010000*/
      NDPI_LOG_INFO(ndpi_struct, "found CISCOVPN\n");
      ndpi_int_ciscovpn_add_connection(ndpi_struct, flow);
      return;
    }
  else if(((tsport == 443 || tdport == 443) ||
          (tsport == 80 || tdport == 80)) &&
          (packet->payload_packet_len >= 5) &&
          ((packet->payload[0] == 0x17 &&
           packet->payload[1] == 0x03 &&
           packet->payload[2] == 0x03 &&
           packet->payload[3] == 0x00 &&
           packet->payload[4] == 0x3A)))
    {
      /* TLS signature of Cisco AnyConnect 0X170303003A */
      NDPI_LOG_INFO(ndpi_struct, "found CISCO Anyconnect VPN\n");
      ndpi_int_ciscovpn_add_connection(ndpi_struct, flow);
      return;
    }
  else if(((tsport == 8009 || tdport == 8009) ||
          (tsport == 8008 || tdport == 8008)) &&
          (packet->payload_packet_len >= 5) &&
          ((packet->payload[0] == 0x17 &&
           packet->payload[1] == 0x03 &&
           packet->payload[2] == 0x03 &&
           packet->payload[3] == 0x00 &&
           packet->payload[4] == 0x69)))
    {
      /* TCP signature of Cisco AnyConnect 0X1703030069 */
      NDPI_LOG_INFO(ndpi_struct, "found CISCO Anyconnect VPN\n");
      ndpi_int_ciscovpn_add_connection(ndpi_struct, flow);
      return;
    }
  else if(
	  (
	   (usport == 10000 && udport == 10000)
	   &&
	   (packet->payload_packet_len >= 4) &&
	   (packet->payload[0] == 0xfe &&
	    packet->payload[1] == 0x57 &&
	    packet->payload[2] == 0x7e &&
	    packet->payload[3] == 0x2b)
	   )
	  )
    {


      /* This is a good query  fe577e2b */
      NDPI_LOG_INFO(ndpi_struct, "found CISCOVPN\n");
      ndpi_int_ciscovpn_add_connection(ndpi_struct, flow);
    } 
  else if(
	  (
	   (usport == 443 || udport == 443)
	   &&
	   (packet->payload_packet_len >= 5) &&
	   (packet->payload[0] == 0x17 &&
	    packet->payload[1] == 0x01 &&
	    packet->payload[2] == 0x00 &&
	    packet->payload[3] == 0x00 &&
	    packet->payload[4] == 0x01)
	   )
	  )
    {
      NDPI_LOG_INFO(ndpi_struct, "found CISCOVPN\n");
      ndpi_int_ciscovpn_add_connection(ndpi_struct, flow);
      return;
    } 

}

// the below code fragment can be found in:
// src/lib/protocols/tls.c
static void ndpi_search_tls_wrapper(struct ndpi_detection_module_struct *ndpi_struct,
				    struct ndpi_flow_struct *flow) {
  struct ndpi_packet_struct *packet = &flow->packet;

#ifdef DEBUG_TLS
  printf("==>> %s() %u [len: %u][version: %u]\n",
	 __FUNCTION__,
	 flow->guessed_host_protocol_id,
	 packet->payload_packet_len,
	 flow->protos.stun_ssl.ssl.ssl_version);
#endif

  if(packet->udp != NULL)
    ndpi_search_tls_udp(ndpi_struct, flow);
  else
    ndpi_search_tls_tcp(ndpi_struct, flow);
}

// the below code fragment can be found in:
// src/lib/protocols/tls.c
static int ndpi_search_tls_udp(struct ndpi_detection_module_struct *ndpi_struct,
			       struct ndpi_flow_struct *flow) {
  struct ndpi_packet_struct *packet = &flow->packet;
  // u_int8_t handshake_type;
  u_int32_t handshake_len;
  u_int16_t p_len;
  const u_int8_t *p;

#ifdef DEBUG_TLS
  printf("[TLS] %s()\n", __FUNCTION__);
#endif

  /* Consider only specific SSL packets (handshake) */
  if((packet->payload_packet_len < 17)
     || (packet->payload[0]  != 0x16)
     || (packet->payload[1]  != 0xfe) /* We ignore old DTLS versions */
     || ((packet->payload[2] != 0xff) && (packet->payload[2] != 0xfd))
     || ((ntohs(*((u_int16_t*)&packet->payload[11]))+13) != packet->payload_packet_len)
    ) {
  no_dtls:

#ifdef DEBUG_TLS
    printf("[TLS] No DTLS found\n");
#endif

    NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
    return(0); /* Giveup */
  }

  // handshake_type = packet->payload[13];
  handshake_len  = (packet->payload[14] << 16) + (packet->payload[15] << 8) + packet->payload[16];

  if((handshake_len+25) != packet->payload_packet_len)
    goto no_dtls;

  /* Overwriting packet payload */
  p = packet->payload, p_len = packet->payload_packet_len; /* Backup */
  packet->payload = &packet->payload[13], packet->payload_packet_len -= 13;

  processTLSBlock(ndpi_struct, flow);

  packet->payload = p, packet->payload_packet_len = p_len; /* Restore */

  ndpi_int_tls_add_connection(ndpi_struct, flow, NDPI_PROTOCOL_TLS);

  return(1); /* Keep working */
}

