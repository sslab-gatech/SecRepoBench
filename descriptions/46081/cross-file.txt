// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// coders/fits.c
// static MagickBooleanType WriteFITSImage(const ImageInfo *image_info,
//   Image *image,ExceptionInfo *exception)
// {
//   char
//     *fits_info,
//     header[FITSBlocksize];
// 
//   const Quantum
//     *p;
// 
//   MagickBooleanType
//     is_gray,
//     status;
// 
//   QuantumInfo
//     *quantum_info;
// 
//   size_t
//     length;
// 
//   ssize_t
//     count,
//     offset,
//     y;
// 
//   unsigned char
//     *pixels;
// 
//   /*
//     Open output image file.
//   */
//   assert(image_info != (const ImageInfo *) NULL);
//   assert(image_info->signature == MagickCoreSignature);
//   assert(image != (Image *) NULL);
//   assert(image->signature == MagickCoreSignature);
//   if (image->debug != MagickFalse)
//     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
//   assert(exception != (ExceptionInfo *) NULL);
//   assert(exception->signature == MagickCoreSignature);
//   status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
//   if (status == MagickFalse)
//     return(status);
//   if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
//     (void) TransformImageColorspace(image,sRGBColorspace,exception);
//   /*
//     Allocate image memory.
//   */
//   fits_info=(char *) AcquireQuantumMemory(FITSBlocksize,sizeof(*fits_info));
//   if (fits_info == (char *) NULL)
//     ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
//   (void) memset(fits_info,' ',FITSBlocksize*sizeof(*fits_info));
//   /*
//     Initialize image header.
//   */
//   image->depth=GetImageQuantumDepth(image,MagickFalse);
//   image->endian=MSBEndian;
//   quantum_info=AcquireQuantumInfo(image_info,image);
//   if (quantum_info == (QuantumInfo *) NULL)
//     {
//       fits_info=DestroyString(fits_info);
//       ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
//     }
//   offset=0;
//   (void) FormatLocaleString(header,FITSBlocksize,
//     "SIMPLE  =                    T");
//   CopyFitsRecord(fits_info,header,offset);
//   offset+=80;
//   (void) FormatLocaleString(header,FITSBlocksize,"BITPIX  =           %10ld",
//     (long) ((quantum_info->format == FloatingPointQuantumFormat ? -1 : 1)*
//     image->depth));
//   CopyFitsRecord(fits_info,header,offset);
//   offset+=80;
//   is_gray=IdentifyImageCoderGray(image,exception);
//   (void) FormatLocaleString(header,FITSBlocksize,"NAXIS   =           %10lu",
//     (is_gray != MagickFalse) ? 2UL : 3UL);
//   CopyFitsRecord(fits_info,header,offset);
//   offset+=80;
//   (void) FormatLocaleString(header,FITSBlocksize,"NAXIS1  =           %10lu",
//     (unsigned long) image->columns);
//   CopyFitsRecord(fits_info,header,offset);
//   offset+=80;
//   (void) FormatLocaleString(header,FITSBlocksize,"NAXIS2  =           %10lu",
//     (unsigned long) image->rows);
//   CopyFitsRecord(fits_info,header,offset);
//   offset+=80;
//   if (is_gray == MagickFalse)
//     {
//       (void) FormatLocaleString(header,FITSBlocksize,
//         "NAXIS3  =           %10lu",3UL);
//       CopyFitsRecord(fits_info,header,offset);
//       offset+=80;
//     }
//   (void) FormatLocaleString(header,FITSBlocksize,"BSCALE  =         %E",1.0);
//   CopyFitsRecord(fits_info,header,offset);
//   offset+=80;
//   (void) FormatLocaleString(header,FITSBlocksize,"BZERO   =         %E",
//     image->depth > 8 ? (GetFITSPixelRange(image->depth)+1)/2.0 : 0.0);
//   CopyFitsRecord(fits_info,header,offset);
//   offset+=80;
//   (void) FormatLocaleString(header,FITSBlocksize,"DATAMAX =         %E",
//     1.0*((MagickOffsetType) GetQuantumRange(image->depth)));
//   CopyFitsRecord(fits_info,header,offset);
//   offset+=80;
//   (void) FormatLocaleString(header,FITSBlocksize,"DATAMIN =         %E",0.0);
//   CopyFitsRecord(fits_info,header,offset);
//   offset+=80;
//   if (image->endian == LSBEndian)
//     {
//       (void) FormatLocaleString(header,FITSBlocksize,"XENDIAN = 'SMALL'");
//       CopyFitsRecord(fits_info,header,offset);
//       offset+=80;
//     }
//   (void) FormatLocaleString(header,FITSBlocksize,"HISTORY %.72s",
//     MagickAuthoritativeURL);
//   CopyFitsRecord(fits_info,header,offset);
//   offset+=80;
//   (void) strncpy(header,"END",FITSBlocksize);
//   CopyFitsRecord(fits_info,header,offset);
//   offset+=80;
//   (void) WriteBlob(image,FITSBlocksize,(unsigned char *) fits_info);
//   /*
//     Convert image to fits scale PseudoColor class.
//   */
//   pixels=(unsigned char *) GetQuantumPixels(quantum_info);
//   if (is_gray != MagickFalse)
//     {
//       length=GetQuantumExtent(image,quantum_info,GrayQuantum);
//       for (y=(ssize_t) image->rows-1; y >= 0; y--)
//       {
//         p=GetVirtualPixels(image,0,y,image->columns,1,exception);
//         if (p == (const Quantum *) NULL)
//           break;
//         length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,
//           GrayQuantum,pixels,exception);
//         if (image->depth == 16)
//           SetFITSUnsignedPixels(image->columns,image->depth,image->endian,
//             pixels);
//         if (((image->depth == 32) || (image->depth == 64)) &&
//             (quantum_info->format != FloatingPointQuantumFormat))
//           SetFITSUnsignedPixels(image->columns,image->depth,image->endian,
//             pixels);
//         count=WriteBlob(image,length,pixels);
//         if (count != (ssize_t) length)
//           break;
//         status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
//           image->rows);
//         if (status == MagickFalse)
//           break;
//       }
//     }
//   else
//     {
//       length=GetQuantumExtent(image,quantum_info,RedQuantum);
//       for (y=(ssize_t) image->rows-1; y >= 0; y--)
//       {
//         p=GetVirtualPixels(image,0,y,image->columns,1,exception);
//         if (p == (const Quantum *) NULL)
//           break;
//         length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,
//           RedQuantum,pixels,exception);
//         if (image->depth == 16)
//           SetFITSUnsignedPixels(image->columns,image->depth,image->endian,
//             pixels);
//         if (((image->depth == 32) || (image->depth == 64)) &&
//             (quantum_info->format != FloatingPointQuantumFormat))
//           SetFITSUnsignedPixels(image->columns,image->depth,image->endian,
//             pixels);
//         count=WriteBlob(image,length,pixels);
//         if (count != (ssize_t) length)
//           break;
//         status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
//           image->rows);
//         if (status == MagickFalse)
//           break;
//       }
//       length=GetQuantumExtent(image,quantum_info,GreenQuantum);
//       for (y=(ssize_t) image->rows-1; y >= 0; y--)
//       {
//         p=GetVirtualPixels(image,0,y,image->columns,1,exception);
//         if (p == (const Quantum *) NULL)
//           break;
//         length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,
//           GreenQuantum,pixels,exception);
//         if (image->depth == 16)
//           SetFITSUnsignedPixels(image->columns,image->depth,image->endian,
//             pixels);
//         if (((image->depth == 32) || (image->depth == 64)) &&
//             (quantum_info->format != FloatingPointQuantumFormat))
//           SetFITSUnsignedPixels(image->columns,image->depth,image->endian,
//             pixels);
//         count=WriteBlob(image,length,pixels);
//         if (count != (ssize_t) length)
//           break;
//         status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
//           image->rows);
//         if (status == MagickFalse)
//           break;
//       }
//       length=GetQuantumExtent(image,quantum_info,BlueQuantum);
//       for (y=(ssize_t) image->rows-1; y >= 0; y--)
//       {
//         p=GetVirtualPixels(image,0,y,image->columns,1,exception);
//         if (p == (const Quantum *) NULL)
//           break;
//         length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,
//           BlueQuantum,pixels,exception);
//         if (image->depth == 16)
//           SetFITSUnsignedPixels(image->columns,image->depth,image->endian,
//             pixels);
//         if (((image->depth == 32) || (image->depth == 64)) &&
//             (quantum_info->format != FloatingPointQuantumFormat))
//           SetFITSUnsignedPixels(image->columns,image->depth,image->endian,
//             pixels);
//         count=WriteBlob(image,length,pixels);
//         if (count != (ssize_t) length)
//           break;
//         status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
//           image->rows);
//         if (status == MagickFalse)
//           break;
//       }
//     }
//   quantum_info=DestroyQuantumInfo(quantum_info);
//   length=(size_t) (FITSBlocksize-TellBlob(image) % FITSBlocksize);
//   if (length != 0)
//     {
//       (void) memset(fits_info,0,length*sizeof(*fits_info));
//       (void) WriteBlob(image,length,(unsigned char *) fits_info);
//     }
//   fits_info=DestroyString(fits_info);
//   (void) CloseBlob(image);
//   return(MagickTrue);
// }

// the below code fragment can be found in:
// coders/pnm.c
// static MagickBooleanType WritePNMImage(const ImageInfo *image_info,Image *image,
//   ExceptionInfo *exception)
// {
//   char
//     buffer[MagickPathExtent],
//     format,
//     magick[MagickPathExtent];
// 
//   const char
//     *value;
// 
//   MagickBooleanType
//     status;
// 
//   MagickOffsetType
//     scene;
// 
//   Quantum
//     index;
// 
//   QuantumAny
//     pixel;
// 
//   QuantumInfo
//     *quantum_info;
// 
//   QuantumType
//     quantum_type;
// 
//   unsigned char
//     *q;
// 
//   size_t
//     extent,
//     imageListLength,
//     packet_size;
// 
//   ssize_t
//     count,
//     y;
// 
//   /*
//     Open output image file.
//   */
//   assert(image_info != (const ImageInfo *) NULL);
//   assert(image_info->signature == MagickCoreSignature);
//   assert(image != (Image *) NULL);
//   assert(image->signature == MagickCoreSignature);
//   if (image->debug != MagickFalse)
//     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
//   assert(exception != (ExceptionInfo *) NULL);
//   assert(exception->signature == MagickCoreSignature);
//   status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
//   if (status == MagickFalse)
//     return(status);
//   scene=0;
//   imageListLength=GetImageListLength(image);
//   do
//   {
//     QuantumAny
//       max_value;
// 
//     /*
//       Write PNM file header.
//     */
//     packet_size=3;
//     quantum_type=RGBQuantum;
//     (void) CopyMagickString(magick,image_info->magick,MagickPathExtent);
//     max_value=GetQuantumRange(image->depth);
//     switch (magick[1])
//     {
//       case 'A':
//       case 'a':
//       {
//         format='7';
//         break;
//       }
//       case 'B':
//       case 'b':
//       {
//         format='4';
//         if (image_info->compression == NoCompression)
//           format='1';
//         break;
//       }
//       case 'F':
//       case 'f':
//       {
//         format='F';
//         if (image_info->type == TrueColorType)
//           break;
//         if (IdentifyImageCoderGray(image,exception) != MagickFalse)
//           format='f';
//         break;
//       }
//       case 'G':
//       case 'g':
//       {
//         format='5';
//         if (image_info->compression == NoCompression)
//           format='2';
//         break;
//       }
//       case 'H':
//       case 'h':
//       {
//         format='H';
//         if (image_info->type == TrueColorType)
//           break;
//         if (IdentifyImageCoderGray(image,exception) != MagickFalse)
//           format='h';
//         break;
//       }
//       case 'N':
//       case 'n':
//       {
//         ImageType
//           type;
// 
//         format='6';
//         if (image_info->type == TrueColorType)
//           break;
//         type=IdentifyImageCoderGrayType(image,exception);
//         if (IsGrayImageType(type) != MagickFalse)
//           {
//             format='5';
//             if (image_info->compression == NoCompression)
//               format='2';
//             if (type == BilevelType)
//               {
//                 format='4';
//                 if (image_info->compression == NoCompression)
//                   format='1';
//               }
//           }
//         break;
//       }
//       default:
//       {
//         format='6';
//         if (image_info->compression == NoCompression)
//           format='3';
//         break;
//       }
//     }
//     (void) FormatLocaleString(buffer,MagickPathExtent,"P%c\n",format);
//     (void) WriteBlobString(image,buffer);
//     value=GetImageProperty(image,"comment",exception);
//     if (value != (const char *) NULL)
//       {
//         const char
//           *p;
// 
//         /*
//           Write comments to file.
//         */
//         (void) WriteBlobByte(image,'#');
//         for (p=value; *p != '\0'; p++)
//         {
//           (void) WriteBlobByte(image,(unsigned char) *p);
//           if ((*p == '\n') || (*p == '\r'))
//             (void) WriteBlobByte(image,'#');
//         }
//         (void) WriteBlobByte(image,'\n');
//       }
//     if (format != '7')
//       {
//         (void) FormatLocaleString(buffer,MagickPathExtent,"%.20g %.20g\n",
//           (double) image->columns,(double) image->rows);
//         (void) WriteBlobString(image,buffer);
//       }
//     else
//       {
//         char
//           type[MagickPathExtent];
// 
//         /*
//           PAM header.
//         */
//         (void) FormatLocaleString(buffer,MagickPathExtent,
//           "WIDTH %.20g\nHEIGHT %.20g\n",(double) image->columns,(double)
//           image->rows);
//         (void) WriteBlobString(image,buffer);
//         quantum_type=GetQuantumType(image,exception);
//         switch (quantum_type)
//         {
//           case CMYKQuantum:
//           case CMYKAQuantum:
//           {
//             packet_size=4;
//             (void) CopyMagickString(type,"CMYK",MagickPathExtent);
//             break;
//           }
//           case GrayQuantum:
//           case GrayAlphaQuantum:
//           {
//             packet_size=1;
//             (void) CopyMagickString(type,"GRAYSCALE",MagickPathExtent);
//             if (IdentifyImageMonochrome(image,exception) != MagickFalse)
//               (void) CopyMagickString(type,"BLACKANDWHITE",MagickPathExtent);
//             break;
//           }
//           default:
//           {
//             quantum_type=RGBQuantum;
//             if (image->alpha_trait != UndefinedPixelTrait)
//               quantum_type=RGBAQuantum;
//             packet_size=3;
//             (void) CopyMagickString(type,"RGB",MagickPathExtent);
//             break;
//           }
//         }
//         if (image->alpha_trait != UndefinedPixelTrait)
//           {
//             packet_size++;
//             (void) ConcatenateMagickString(type,"_ALPHA",MagickPathExtent);
//           }
//         if (image->depth > 32)
//           image->depth=32;
//         (void) FormatLocaleString(buffer,MagickPathExtent,
//           "DEPTH %.20g\nMAXVAL %.20g\n",(double) packet_size,(double)
//           ((MagickOffsetType) GetQuantumRange(image->depth)));
//         (void) WriteBlobString(image,buffer);
//         (void) FormatLocaleString(buffer,MagickPathExtent,
//           "TUPLTYPE %s\nENDHDR\n",type);
//         (void) WriteBlobString(image,buffer);
//       }
//     /*
//       Convert runextent encoded to PNM raster pixels.
//     */
//     switch (format)
//     {
//       case '1':
//       {
//         unsigned char
//           pixels[2048];
// 
//         /*
//           Convert image to a PBM image.
//         */
//         (void) SetImageType(image,BilevelType,exception);
//         q=pixels;
//         for (y=0; y < (ssize_t) image->rows; y++)
//         {
//           const Quantum
//             *magick_restrict p;
// 
//           ssize_t
//             x;
// 
//           p=GetVirtualPixels(image,0,y,image->columns,1,exception);
//           if (p == (const Quantum *) NULL)
//             break;
//           for (x=0; x < (ssize_t) image->columns; x++)
//           {
//             *q++=(unsigned char) (GetPixelLuma(image,p) >= (QuantumRange/2.0) ?
//               '0' : '1');
//             if ((q-pixels+2) >= (ssize_t) sizeof(pixels))
//               {
//                 *q++='\n';
//                 (void) WriteBlob(image,q-pixels,pixels);
//                 q=pixels;
//               }
//             *q++=' ';
//             p+=GetPixelChannels(image);
//           }
//           *q++='\n';
//           (void) WriteBlob(image,q-pixels,pixels);
//           q=pixels;
//           if (image->previous == (Image *) NULL)
//             {
//               status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
//                 image->rows);
//               if (status == MagickFalse)
//                 break;
//             }
//         }
//         if (q != pixels)
//           {
//             *q++='\n';
//             (void) WriteBlob(image,q-pixels,pixels);
//           }
//         break;
//       }
//       case '2':
//       {
//         unsigned char
//           pixels[2048];
// 
//         /*
//           Convert image to a PGM image.
//         */
//         if (image->depth <= 8)
//           (void) WriteBlobString(image,"255\n");
//         else
//           if (image->depth <= 16)
//             (void) WriteBlobString(image,"65535\n");
//           else
//             (void) WriteBlobString(image,"4294967295\n");
//         q=pixels;
//         for (y=0; y < (ssize_t) image->rows; y++)
//         {
//           const Quantum
//             *magick_restrict p;
// 
//           ssize_t
//             x;
// 
//           p=GetVirtualPixels(image,0,y,image->columns,1,exception);
//           if (p == (const Quantum *) NULL)
//             break;
//           for (x=0; x < (ssize_t) image->columns; x++)
//           {
//             index=ClampToQuantum(GetPixelLuma(image,p));
//             if (image->depth <= 8)
//               count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,"%u ",
//                 ScaleQuantumToChar(index));
//             else
//               if (image->depth <= 16)
//                 count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,
//                   "%u ",ScaleQuantumToShort(index));
//               else
//                 count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,
//                   "%u ",ScaleQuantumToLong(index));
//             extent=(size_t) count;
//             if ((q-pixels+extent+1) >= sizeof(pixels))
//               {
//                 *q++='\n';
//                 (void) WriteBlob(image,q-pixels,pixels);
//                 q=pixels;
//               }
//             (void) memcpy((char *) q,buffer,extent);
//             q+=extent;
//             p+=GetPixelChannels(image);
//           }
//           *q++='\n';
//           (void) WriteBlob(image,q-pixels,pixels);
//           q=pixels;
//           if (image->previous == (Image *) NULL)
//             {
//               status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
//                 image->rows);
//               if (status == MagickFalse)
//                 break;
//             }
//         }
//         if (q != pixels)
//           {
//             *q++='\n';
//             (void) WriteBlob(image,q-pixels,pixels);
//           }
//         break;
//       }
//       case '3':
//       {
//         unsigned char
//           pixels[2048];
// 
//         /*
//           Convert image to a PNM image.
//         */
//         if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
//           (void) TransformImageColorspace(image,sRGBColorspace,exception);
//         if (image->depth <= 8)
//           (void) WriteBlobString(image,"255\n");
//         else
//           if (image->depth <= 16)
//             (void) WriteBlobString(image,"65535\n");
//           else
//             (void) WriteBlobString(image,"4294967295\n");
//         q=pixels;
//         for (y=0; y < (ssize_t) image->rows; y++)
//         {
//           const Quantum
//             *magick_restrict p;
// 
//           ssize_t
//             x;
// 
//           p=GetVirtualPixels(image,0,y,image->columns,1,exception);
//           if (p == (const Quantum *) NULL)
//             break;
//           for (x=0; x < (ssize_t) image->columns; x++)
//           {
//             if (image->depth <= 8)
//               count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,
//                 "%u %u %u ",ScaleQuantumToChar(GetPixelRed(image,p)),
//                 ScaleQuantumToChar(GetPixelGreen(image,p)),
//                 ScaleQuantumToChar(GetPixelBlue(image,p)));
//             else
//               if (image->depth <= 16)
//                 count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,
//                   "%u %u %u ",ScaleQuantumToShort(GetPixelRed(image,p)),
//                   ScaleQuantumToShort(GetPixelGreen(image,p)),
//                   ScaleQuantumToShort(GetPixelBlue(image,p)));
//               else
//                 count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,
//                   "%u %u %u ",ScaleQuantumToLong(GetPixelRed(image,p)),
//                   ScaleQuantumToLong(GetPixelGreen(image,p)),
//                   ScaleQuantumToLong(GetPixelBlue(image,p)));
//             extent=(size_t) count;
//             if ((q-pixels+extent+2) >= sizeof(pixels))
//               {
//                 *q++='\n';
//                 (void) WriteBlob(image,q-pixels,pixels);
//                 q=pixels;
//               }
//             (void) memcpy((char *) q,buffer,extent);
//             q+=extent;
//             p+=GetPixelChannels(image);
//           }
//           *q++='\n';
//           (void) WriteBlob(image,q-pixels,pixels);
//           q=pixels;
//           if (image->previous == (Image *) NULL)
//             {
//               status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
//                 image->rows);
//               if (status == MagickFalse)
//                 break;
//             }
//         }
//         if (q != pixels)
//           {
//             *q++='\n';
//             (void) WriteBlob(image,q-pixels,pixels);
//           }
//         break;
//       }
//       case '4':
//       {
//         unsigned char
//           *pixels;
// 
//         /*
//           Convert image to a PBM image.
//         */
//         (void) SetImageType(image,BilevelType,exception);
//         image->depth=1;
//         quantum_info=AcquireQuantumInfo(image_info,image);
//         if (quantum_info == (QuantumInfo *) NULL)
//           ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
//         SetQuantumMinIsWhite(quantum_info,MagickTrue);
//         (void) SetQuantumEndian(image,quantum_info,MSBEndian);
//         pixels=GetQuantumPixels(quantum_info);
//         for (y=0; y < (ssize_t) image->rows; y++)
//         {
//           const Quantum
//             *magick_restrict p;
// 
//           p=GetVirtualPixels(image,0,y,image->columns,1,exception);
//           if (p == (const Quantum *) NULL)
//             break;
//           extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,
//             GrayQuantum,pixels,exception);
//           count=WriteBlob(image,extent,pixels);
//           if (count != (ssize_t) extent)
//             break;
//           if (image->previous == (Image *) NULL)
//             {
//               status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
//                 image->rows);
//               if (status == MagickFalse)
//                 break;
//             }
//         }
//         quantum_info=DestroyQuantumInfo(quantum_info);
//         break;
//       }
//       case '5':
//       {
//         unsigned char
//           *pixels;
// 
//         /*
//           Convert image to a PGM image.
//         */
//         if (image->depth > 32)
//           image->depth=32;
//         (void) FormatLocaleString(buffer,MagickPathExtent,"%.20g\n",(double)
//           ((MagickOffsetType) GetQuantumRange(image->depth)));
//         (void) WriteBlobString(image,buffer);
//         quantum_info=AcquireQuantumInfo(image_info,image);
//         if (quantum_info == (QuantumInfo *) NULL)
//           ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
//         (void) SetQuantumEndian(image,quantum_info,MSBEndian);
//         pixels=GetQuantumPixels(quantum_info);
//         extent=GetQuantumExtent(image,quantum_info,GrayQuantum);
//         for (y=0; y < (ssize_t) image->rows; y++)
//         {
//           const Quantum
//             *magick_restrict p;
// 
//           ssize_t
//             x;
// 
//           p=GetVirtualPixels(image,0,y,image->columns,1,exception);
//           if (p == (const Quantum *) NULL)
//             break;
//           q=pixels;
//           switch (image->depth)
//           {
//             case 8:
//             case 16:
//             case 32:
//             {
//               extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,
//                 GrayQuantum,pixels,exception);
//               break;
//             }
//             default:
//             {
//               if (image->depth <= 8)
//                 {
//                   for (x=0; x < (ssize_t) image->columns; x++)
//                   {
//                     if (IsPixelGray(image,p) == MagickFalse)
//                       pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(
//                         image,p)),max_value);
//                     else
//                       {
//                         if (image->depth == 8)
//                           pixel=ScaleQuantumToChar(GetPixelRed(image,p));
//                         else
//                           pixel=ScaleQuantumToAny(GetPixelRed(image,p),
//                             max_value);
//                       }
//                     q=PopCharPixel((unsigned char) pixel,q);
//                     p+=GetPixelChannels(image);
//                   }
//                   extent=(size_t) (q-pixels);
//                   break;
//                 }
//               if (image->depth <= 16)
//                 {
//                   for (x=0; x < (ssize_t) image->columns; x++)
//                   {
//                     if (IsPixelGray(image,p) == MagickFalse)
//                       pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(image,
//                         p)),max_value);
//                     else
//                       {
//                         if (image->depth == 16)
//                           pixel=ScaleQuantumToShort(GetPixelRed(image,p));
//                         else
//                           pixel=ScaleQuantumToAny(GetPixelRed(image,p),
//                             max_value);
//                       }
//                     q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);
//                     p+=GetPixelChannels(image);
//                   }
//                   extent=(size_t) (q-pixels);
//                   break;
//                 }
//               for (x=0; x < (ssize_t) image->columns; x++)
//               {
//                 if (IsPixelGray(image,p) == MagickFalse)
//                   pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(image,p)),
//                     max_value);
//                 else
//                   {
//                     if (image->depth == 16)
//                       pixel=ScaleQuantumToLong(GetPixelRed(image,p));
//                     else
//                       pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);
//                   }
//                 q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);
//                 p+=GetPixelChannels(image);
//               }
//               extent=(size_t) (q-pixels);
//               break;
//             }
//           }
//           count=WriteBlob(image,extent,pixels);
//           if (count != (ssize_t) extent)
//             break;
//           if (image->previous == (Image *) NULL)
//             {
//               status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
//                 image->rows);
//               if (status == MagickFalse)
//                 break;
//             }
//         }
//         quantum_info=DestroyQuantumInfo(quantum_info);
//         break;
//       }
//       case '6':
//       {
//         unsigned char
//           *pixels;
// 
//         /*
//           Convert image to a PNM image.
//         */
//         if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
//           (void) TransformImageColorspace(image,sRGBColorspace,exception);
//         if (image->depth > 32)
//           image->depth=32;
//         (void) FormatLocaleString(buffer,MagickPathExtent,"%.20g\n",(double)
//           ((MagickOffsetType) GetQuantumRange(image->depth)));
//         (void) WriteBlobString(image,buffer);
//         quantum_info=AcquireQuantumInfo(image_info,image);
//         if (quantum_info == (QuantumInfo *) NULL)
//           ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
//         (void) SetQuantumEndian(image,quantum_info,MSBEndian);
//         pixels=GetQuantumPixels(quantum_info);
//         extent=GetQuantumExtent(image,quantum_info,quantum_type);
//         for (y=0; y < (ssize_t) image->rows; y++)
//         {
//           const Quantum
//             *magick_restrict p;
// 
//           ssize_t
//             x;
// 
//           p=GetVirtualPixels(image,0,y,image->columns,1,exception);
//           if (p == (const Quantum *) NULL)
//             break;
//           q=pixels;
//           switch (image->depth)
//           {
//             case 8:
//             case 16:
//             case 32:
//             {
//               extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,
//                 quantum_type,pixels,exception);
//               break;
//             }
//             default:
//             {
//               if (image->depth <= 8)
//                 {
//                   for (x=0; x < (ssize_t) image->columns; x++)
//                   {
//                     pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);
//                     q=PopCharPixel((unsigned char) pixel,q);
//                     pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);
//                     q=PopCharPixel((unsigned char) pixel,q);
//                     pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);
//                     q=PopCharPixel((unsigned char) pixel,q);
//                     p+=GetPixelChannels(image);
//                   }
//                   extent=(size_t) (q-pixels);
//                   break;
//                 }
//               if (image->depth <= 16)
//                 {
//                   for (x=0; x < (ssize_t) image->columns; x++)
//                   {
//                     pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);
//                     q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);
//                     pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);
//                     q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);
//                     pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);
//                     q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);
//                     p+=GetPixelChannels(image);
//                   }
//                   extent=(size_t) (q-pixels);
//                   break;
//                 }
//               for (x=0; x < (ssize_t) image->columns; x++)
//               {
//                 pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);
//                 q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);
//                 pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);
//                 q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);
//                 pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);
//                 q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);
//                 p+=GetPixelChannels(image);
//               }
//               extent=(size_t) (q-pixels);
//               break;
//             }
//           }
//           count=WriteBlob(image,extent,pixels);
//           if (count != (ssize_t) extent)
//             break;
//           if (image->previous == (Image *) NULL)
//             {
//               status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
//                 image->rows);
//               if (status == MagickFalse)
//                 break;
//             }
//         }
//         quantum_info=DestroyQuantumInfo(quantum_info);
//         break;
//       }
//       case '7':
//       {
//         unsigned char
//           *pixels;
// 
//         /*
//           Convert image to a PAM.
//         */
//         if (image->depth > 32)
//           image->depth=32;
//         quantum_info=AcquireQuantumInfo(image_info,image);
//         if (quantum_info == (QuantumInfo *) NULL)
//           ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
//         (void) SetQuantumEndian(image,quantum_info,MSBEndian);
//         pixels=GetQuantumPixels(quantum_info);
//         for (y=0; y < (ssize_t) image->rows; y++)
//         {
//           const Quantum
//             *magick_restrict p;
// 
//           ssize_t
//             x;
// 
//           p=GetVirtualPixels(image,0,y,image->columns,1,exception);
//           if (p == (const Quantum *) NULL)
//             break;
//           q=pixels;
//           switch (image->depth)
//           {
//             case 8:
//             case 16:
//             case 32:
//             {
//               extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,
//                 quantum_type,pixels,exception);
//               break;
//             }
//             default:
//             {
//               switch (quantum_type)
//               {
//                 case GrayQuantum:
//                 case GrayAlphaQuantum:
//                 {
//                   if (image->depth <= 8)
//                     {
//                       for (x=0; x < (ssize_t) image->columns; x++)
//                       {
//                         pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(
//                           image,p)),max_value);
//                         q=PopCharPixel((unsigned char) pixel,q);
//                         if (image->alpha_trait != UndefinedPixelTrait)
//                           {
//                             pixel=(unsigned char) ScaleQuantumToAny(
//                               GetPixelAlpha(image,p),max_value);
//                             q=PopCharPixel((unsigned char) pixel,q);
//                           }
//                         p+=GetPixelChannels(image);
//                       }
//                       break;
//                     }
//                   if (image->depth <= 16)
//                     {
//                       for (x=0; x < (ssize_t) image->columns; x++)
//                       {
//                         pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(
//                           image,p)),max_value);
//                         q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);
//                         if (image->alpha_trait != UndefinedPixelTrait)
//                           {
//                             pixel=(unsigned char) ScaleQuantumToAny(
//                               GetPixelAlpha(image,p),max_value);
//                             q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);
//                           }
//                         p+=GetPixelChannels(image);
//                       }
//                       break;
//                     }
//                   for (x=0; x < (ssize_t) image->columns; x++)
//                   {
//                     pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(image,
//                       p)),max_value);
//                     q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);
//                     if (image->alpha_trait != UndefinedPixelTrait)
//                       {
//                         pixel=(unsigned char) ScaleQuantumToAny(
//                           GetPixelAlpha(image,p),max_value);
//                         q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);
//                       }
//                     p+=GetPixelChannels(image);
//                   }
//                   break;
//                 }
//                 case CMYKQuantum:
//                 case CMYKAQuantum:
//                 {
//                   if (image->depth <= 8)
//                     {
//                       for (x=0; x < (ssize_t) image->columns; x++)
//                       {
//                         pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);
//                         q=PopCharPixel((unsigned char) pixel,q);
//                         pixel=ScaleQuantumToAny(GetPixelGreen(image,p),
//                           max_value);
//                         q=PopCharPixel((unsigned char) pixel,q);
//                         pixel=ScaleQuantumToAny(GetPixelBlue(image,p),
//                           max_value);
//                         q=PopCharPixel((unsigned char) pixel,q);
//                         pixel=ScaleQuantumToAny(GetPixelBlack(image,p),
//                           max_value);
//                         q=PopCharPixel((unsigned char) pixel,q);
//                         if (image->alpha_trait != UndefinedPixelTrait)
//                           {
//                             pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),
//                               max_value);
//                             q=PopCharPixel((unsigned char) pixel,q);
//                           }
//                         p+=GetPixelChannels(image);
//                       }
//                       break;
//                     }
//                   if (image->depth <= 16)
//                     {
//                       for (x=0; x < (ssize_t) image->columns; x++)
//                       {
//                         pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);
//                         q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);
//                         pixel=ScaleQuantumToAny(GetPixelGreen(image,p),
//                           max_value);
//                         q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);
//                         pixel=ScaleQuantumToAny(GetPixelBlue(image,p),
//                           max_value);
//                         q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);
//                         pixel=ScaleQuantumToAny(GetPixelBlack(image,p),
//                           max_value);
//                         q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);
//                         if (image->alpha_trait != UndefinedPixelTrait)
//                           {
//                             pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),
//                               max_value);
//                             q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);
//                           }
//                         p+=GetPixelChannels(image);
//                       }
//                       break;
//                     }
//                   for (x=0; x < (ssize_t) image->columns; x++)
//                   {
//                     pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);
//                     q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);
//                     pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);
//                     q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);
//                     pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);
//                     q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);
//                     pixel=ScaleQuantumToAny(GetPixelBlack(image,p),max_value);
//                     q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);
//                     if (image->alpha_trait != UndefinedPixelTrait)
//                       {
//                         pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),
//                           max_value);
//                         q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);
//                       }
//                     p+=GetPixelChannels(image);
//                   }
//                   break;
//                 }
//                 default:
//                 {
//                   if (image->depth <= 8)
//                     {
//                       for (x=0; x < (ssize_t) image->columns; x++)
//                       {
//                         pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);
//                         q=PopCharPixel((unsigned char) pixel,q);
//                         pixel=ScaleQuantumToAny(GetPixelGreen(image,p),
//                           max_value);
//                         q=PopCharPixel((unsigned char) pixel,q);
//                         pixel=ScaleQuantumToAny(GetPixelBlue(image,p),
//                           max_value);
//                         q=PopCharPixel((unsigned char) pixel,q);
//                         if (image->alpha_trait != UndefinedPixelTrait)
//                           {
//                             pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),
//                               max_value);
//                             q=PopCharPixel((unsigned char) pixel,q);
//                           }
//                         p+=GetPixelChannels(image);
//                       }
//                       break;
//                     }
//                   if (image->depth <= 16)
//                     {
//                       for (x=0; x < (ssize_t) image->columns; x++)
//                       {
//                         pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);
//                         q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);
//                         pixel=ScaleQuantumToAny(GetPixelGreen(image,p),
//                           max_value);
//                         q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);
//                         pixel=ScaleQuantumToAny(GetPixelBlue(image,p),
//                           max_value);
//                         q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);
//                         if (image->alpha_trait != UndefinedPixelTrait)
//                           {
//                             pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),
//                               max_value);
//                             q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);
//                           }
//                         p+=GetPixelChannels(image);
//                       }
//                       break;
//                     }
//                   for (x=0; x < (ssize_t) image->columns; x++)
//                   {
//                     pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);
//                     q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);
//                     pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);
//                     q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);
//                     pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);
//                     q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);
//                     if (image->alpha_trait != UndefinedPixelTrait)
//                       {
//                         pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),
//                           max_value);
//                         q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);
//                       }
//                     p+=GetPixelChannels(image);
//                   }
//                   break;
//                 }
//               }
//               extent=(size_t) (q-pixels);
//               break;
//             }
//           }
//           count=WriteBlob(image,extent,pixels);
//           if (count != (ssize_t) extent)
//             break;
//           if (image->previous == (Image *) NULL)
//             {
//               status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
//                 image->rows);
//               if (status == MagickFalse)
//                 break;
//             }
//         }
//         quantum_info=DestroyQuantumInfo(quantum_info);
//         break;
//       }
//       case 'F':
//       case 'f':
//       {
//         unsigned char
//           *pixels;
// 
//         (void) WriteBlobString(image,image->endian == LSBEndian ? "-1.0\n" :
//           "1.0\n");
//         image->depth=32;
//         quantum_type=format == 'f' ? GrayQuantum : RGBQuantum;
//         quantum_info=AcquireQuantumInfo(image_info,image);
//         if (quantum_info == (QuantumInfo *) NULL)
//           ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
//         status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);
//         if (status == MagickFalse)
//           ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
//         pixels=GetQuantumPixels(quantum_info);
//         for (y=(ssize_t) image->rows-1; y >= 0; y--)
//         {
//           const Quantum
//             *magick_restrict p;
// 
//           p=GetVirtualPixels(image,0,y,image->columns,1,exception);
//           if (p == (const Quantum *) NULL)
//             break;
//           extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,
//             quantum_type,pixels,exception);
//           (void) WriteBlob(image,extent,pixels);
//           if (image->previous == (Image *) NULL)
//             {
//               status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
//                 image->rows);
//               if (status == MagickFalse)
//                 break;
//             }
//         }
//         quantum_info=DestroyQuantumInfo(quantum_info);
//         break;
//       }
//       case 'H':
//       case 'h':
//       {
//         unsigned char
//           *pixels;
// 
//         (void) WriteBlobString(image,image->endian == LSBEndian ? "-1.0\n" :
//           "1.0\n");
//         image->depth=16;
//         quantum_type=format == 'h' ? GrayQuantum : RGBQuantum;
//         quantum_info=AcquireQuantumInfo(image_info,image);
//         if (quantum_info == (QuantumInfo *) NULL)
//           ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
//         status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);
//         if (status == MagickFalse)
//           ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
//         pixels=GetQuantumPixels(quantum_info);
//         for (y=(ssize_t) image->rows-1; y >= 0; y--)
//         {
//           const Quantum
//             *magick_restrict p;
// 
//           p=GetVirtualPixels(image,0,y,image->columns,1,exception);
//           if (p == (const Quantum *) NULL)
//             break;
//           extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,
//             quantum_type,pixels,exception);
//           (void) WriteBlob(image,extent,pixels);
//           if (image->previous == (Image *) NULL)
//             {
//               status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
//                 image->rows);
//               if (status == MagickFalse)
//                 break;
//             }
//         }
//         quantum_info=DestroyQuantumInfo(quantum_info);
//         break;
//       }
//       default:
//         break;
//     }
//     if (GetNextImageInList(image) == (Image *) NULL)
//       break;
//     image=SyncNextImageInList(image);
//     status=SetImageProgress(image,SaveImagesTag,scene++,imageListLength);
//     if (status == MagickFalse)
//       break;
//   } while (image_info->adjoin != MagickFalse);
//   (void) CloseBlob(image);
//   return(MagickTrue);
// }

// the below code fragment can be found in:
// coders/farbfeld.c
// static MagickBooleanType WriteFARBFELDImage(const ImageInfo *image_info,
//   Image *image,ExceptionInfo *exception)
// {
//   MagickBooleanType
//     status;
// 
//   QuantumInfo
//     *quantum_info;
// 
//   const Quantum
//     *p;
// 
//   size_t
//     extent;
// 
//   ssize_t
//     count,
//     y;
// 
//   unsigned char
//     *pixels;
// 
//   /*
//     Open output image file.
//   */
//   assert(image_info != (const ImageInfo *) NULL);
//   assert(image_info->signature == MagickCoreSignature);
//   assert(image != (Image *) NULL);
//   assert(image->signature == MagickCoreSignature);
//   if (image->debug != MagickFalse)
//     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
//   assert(exception != (ExceptionInfo *) NULL);
//   assert(exception->signature == MagickCoreSignature);
//   status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
//   if (status == MagickFalse)
//     return(status);
//   image->endian=MSBEndian;
//   (void) WriteBlobLongLong(image,MagickULLConstant(7377303431559867492));
//   (void) WriteBlobLong(image,(unsigned int) image->columns);
//   (void) WriteBlobLong(image,(unsigned int) image->rows);
//   image->depth=16;
//   quantum_info=AcquireQuantumInfo(image_info,image);
//   if (quantum_info == (QuantumInfo *) NULL)
//     ThrowWriterException(ImageError,"MemoryAllocationFailed");
//   status=SetQuantumFormat(image,quantum_info,UnsignedQuantumFormat);
//   pixels=(unsigned char *) GetQuantumPixels(quantum_info);
//   for (y=0; y < (ssize_t) image->rows; y++)
//   {
//     p=GetVirtualPixels(image,0,y,image->columns,1,exception);
//     if (p == (const Quantum *) NULL)
//       break;
//     extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,
//       RGBAQuantum,pixels,exception);
//     count=WriteBlob(image,extent,pixels);
//     if (count != (ssize_t) extent)
//       break;
//     status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
//       image->rows);
//     if (status == MagickFalse)
//       break;
//   }
//   quantum_info=DestroyQuantumInfo(quantum_info);
//   if (y < (ssize_t) image->rows)
//     ThrowWriterException(CorruptImageError,"UnableToWriteImageData");
//   (void) CloseBlob(image);
//   return(status);
// }

// the below code fragment can be found in:
// coders/ipl.c
// ModuleExport size_t RegisterIPLImage(void)
// {
//   MagickInfo
//     *entry;
//   
//   entry=AcquireMagickInfo("IPL","IPL","IPL Image Sequence");
//   entry->decoder=(DecodeImageHandler *) ReadIPLImage;
//   entry->encoder=(EncodeImageHandler *) WriteIPLImage;
//   entry->magick=(IsImageFormatHandler *) IsIPL;
//   entry->flags|=CoderDecoderSeekableStreamFlag;
//   entry->flags|=CoderEndianSupportFlag;
//   (void) RegisterMagickInfo(entry);
//   return(MagickImageCoderSignature);
// }

// the below code fragment can be found in:
// coders/fl32.c
// static MagickBooleanType WriteFL32Image(const ImageInfo *image_info,
//   Image *image,ExceptionInfo *exception)
// {
//   MagickBooleanType
//     status;
// 
//   QuantumInfo
//     *quantum_info;
// 
//   QuantumType
//     quantum_type;
// 
//   const Quantum
//     *p;
// 
//   size_t
//     extent;
// 
//   ssize_t
//     count,
//     y;
// 
//   unsigned char
//     *pixels;
// 
//   /*
//     Open output image file.
//   */
//   assert(image_info != (const ImageInfo *) NULL);
//   assert(image_info->signature == MagickCoreSignature);
//   assert(image != (Image *) NULL);
//   assert(image->signature == MagickCoreSignature);
//   if (image->debug != MagickFalse)
//     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
//   assert(exception != (ExceptionInfo *) NULL);
//   assert(exception->signature == MagickCoreSignature);
//   status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
//   if (status == MagickFalse)
//     return(status);
//   (void) WriteBlobLSBLong(image,842222662U);
//   (void) WriteBlobLSBLong(image,(unsigned int) image->rows);
//   (void) WriteBlobLSBLong(image,(unsigned int) image->columns);
//   (void) WriteBlobLSBLong(image,(unsigned int) image->number_channels);
//   image->endian=LSBEndian;
//   image->depth=32;
//   switch (image->number_channels)
//   {
//     case 1:
//     {
//       quantum_type=GrayQuantum;
//       break;
//     }
//     case 2:
//     {
//       quantum_type=GrayAlphaQuantum;
//       break;
//     }
//     case 3:
//     {
//       quantum_type=RGBQuantum;
//       break;
//     }
//     case 4:
//     {
//       quantum_type=RGBAQuantum;
//       break;
//     }
//     default:
//     {
//       quantum_type=RGBQuantum;
//       break;
//     }
//   }
//   quantum_info=AcquireQuantumInfo(image_info,image);
//   if (quantum_info == (QuantumInfo *) NULL)
//     ThrowWriterException(ImageError,"MemoryAllocationFailed");
//   status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);
//   pixels=(unsigned char *) GetQuantumPixels(quantum_info);
//   for (y=0; y < (ssize_t) image->rows; y++)
//   {
//     p=GetVirtualPixels(image,0,y,image->columns,1,exception);
//     if (p == (const Quantum *) NULL)
//       break;
//     extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,
//       quantum_type,pixels,exception);
//     count=WriteBlob(image,extent,pixels);
//     if (count != (ssize_t) extent)
//       break;
//     status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
//       image->rows);
//     if (status == MagickFalse)
//       break;
//   }
//   quantum_info=DestroyQuantumInfo(quantum_info);
//   if (y < (ssize_t) image->rows)
//     ThrowWriterException(CorruptImageError,"UnableToWriteImageData");
//   (void) CloseBlob(image);
//   return(status);
// }

