// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/softmagic.c
// private int
// handle_annotation(struct magic_set *ms, struct magic *m, int firstline)
// {
// 	if ((ms->flags & MAGIC_APPLE) && m->apple[0]) {
// 		if (print_sep(ms, firstline) == -1)
// 			return -1;
// 		if (file_printf(ms, "%.8s", m->apple) == -1)
// 			return -1;
// 		return 1;
// 	}
// 	if ((ms->flags & MAGIC_EXTENSION) && m->ext[0]) {
// 		if (print_sep(ms, firstline) == -1)
// 			return -1;
// 		if (file_printf(ms, "%s", m->ext) == -1)
// 			return -1;
// 		return 1;
// 	}
// 	if ((ms->flags & MAGIC_MIME_TYPE) && m->mimetype[0]) {
// 		char buf[1024];
// 		const char *p;
// 		if (print_sep(ms, firstline) == -1)
// 			return -1;
// 		if (varexpand(ms, buf, sizeof(buf), m->mimetype) == -1)
// 			p = m->mimetype;
// 		else
// 			p = buf;
// 		if (file_printf(ms, "%s", p) == -1)
// 			return -1;
// 		return 1;
// 	}
// 	return 0;
// }

// the below code fragment can be found in:
// src/softmagic.c
// private uint64_t
// file_strncmp(const char *s1, const char *s2, size_t len, size_t maxlen,
//     uint32_t flags)
// {
// 	/*
// 	 * Convert the source args to unsigned here so that (1) the
// 	 * compare will be unsigned as it is in strncmp() and (2) so
// 	 * the ctype functions will work correctly without extra
// 	 * casting.
// 	 */
// 	const unsigned char *a = RCAST(const unsigned char *, s1);
// 	const unsigned char *b = RCAST(const unsigned char *, s2);
// 	uint32_t ws = flags & (STRING_COMPACT_WHITESPACE |
// 	    STRING_COMPACT_OPTIONAL_WHITESPACE);
// 	const unsigned char *eb = b + (ws ? maxlen : len);
// 	uint64_t v;
// 
// 	/*
// 	 * What we want here is v = strncmp(s1, s2, len),
// 	 * but ignoring any nulls.
// 	 */
// 	v = 0;
// 	len++;
// 	if (0L == flags) { /* normal string: do it fast */
// 		while (--len > 0)
// 			if ((v = *b++ - *a++) != '\0')
// 				break;
// 	}
// 	else { /* combine the others */
// 		while (--len > 0) {
// 			if (b >= eb) {
// 				v = 1;
// 				break;
// 			}
// 			if ((flags & STRING_IGNORE_LOWERCASE) &&
// 			    islower(*a)) {
// 				if ((v = tolower(*b++) - *a++) != '\0')
// 					break;
// 			}
// 			else if ((flags & STRING_IGNORE_UPPERCASE) &&
// 			    isupper(*a)) {
// 				if ((v = toupper(*b++) - *a++) != '\0')
// 					break;
// 			}
// 			else if ((flags & STRING_COMPACT_WHITESPACE) &&
// 			    isspace(*a)) {
// 				a++;
// 				if (isspace(*b)) {
// 					b++;
// 					if (!isspace(*a))
// 						while (b < eb && isspace(*b))
// 							b++;
// 				}
// 				else {
// 					v = 1;
// 					break;
// 				}
// 			}
// 			else if ((flags & STRING_COMPACT_OPTIONAL_WHITESPACE) &&
// 			    isspace(*a)) {
// 				a++;
// 				while (b < eb && isspace(*b))
// 					b++;
// 			}
// 			else {
// 				if ((v = *b++ - *a++) != '\0')
// 					break;
// 			}
// 		}
// 		if (len == 0 && v == 0 && (flags & STRING_FULL_WORD)) {
// 			if (*b && !isspace(*b))
// 				v = 1;
// 		}
// 	}
// 	return v;
// }

// the below code fragment can be found in:
// src/softmagic.c
// private int
// check_fmt(struct magic_set *ms, const char *fmt)
// {
// 	file_regex_t rx;
// 	int rc, rv = -1;
//         const char* pat = "%[-0-9\\.]*s";
// 
// 	if (strchr(fmt, '%') == NULL)
// 		return 0;
// 
// 	rc = file_regcomp(ms, &rx, pat, REG_EXTENDED|REG_NOSUB);
// 	if (rc == 0) {
// 		rc = file_regexec(ms, &rx, fmt, 0, 0, 0);
// 		rv = !rc;
// 	}
// 	file_regfree(&rx);
// 	return rv;
// }

// the below code fragment can be found in:
// src/softmagic.c
// private int
// moffset(struct magic_set *ms, struct magic *m, const struct buffer *b,
//     int32_t *op)
// {
// 	size_t nbytes = b->flen;
// 	int32_t o;
// 
//   	switch (m->type) {
//   	case FILE_BYTE:
// 		o = CAST(int32_t, (ms->offset + sizeof(char)));
// 		break;
// 
//   	case FILE_SHORT:
//   	case FILE_BESHORT:
//   	case FILE_LESHORT:
// 	case FILE_MSDOSDATE:
// 	case FILE_LEMSDOSDATE:
// 	case FILE_BEMSDOSDATE:
// 	case FILE_MSDOSTIME:
// 	case FILE_LEMSDOSTIME:
// 	case FILE_BEMSDOSTIME:
// 		o = CAST(int32_t, (ms->offset + sizeof(short)));
// 		break;
// 
//   	case FILE_LONG:
//   	case FILE_BELONG:
//   	case FILE_LELONG:
//   	case FILE_MELONG:
// 		o = CAST(int32_t, (ms->offset + sizeof(int32_t)));
// 		break;
// 
//   	case FILE_QUAD:
//   	case FILE_BEQUAD:
//   	case FILE_LEQUAD:
// 		o = CAST(int32_t, (ms->offset + sizeof(int64_t)));
// 		break;
// 
//   	case FILE_STRING:
//   	case FILE_PSTRING:
//   	case FILE_BESTRING16:
//   	case FILE_LESTRING16:
// 	case FILE_OCTAL:
// 		if (m->reln == '=' || m->reln == '!') {
// 			o = ms->offset + m->vallen;
// 		} else {
// 			union VALUETYPE *p = &ms->ms_value;
// 
// 			if (*m->value.s == '\0')
// 				p->s[strcspn(p->s, "\r\n")] = '\0';
// 			o = CAST(uint32_t, (ms->offset + strlen(p->s)));
// 			if (m->type == FILE_PSTRING) {
// 				size_t l = file_pstring_length_size(ms, m);
// 				if (l == FILE_BADSIZE)
// 					return -1;
// 				o += CAST(uint32_t, l);
// 			}
// 		}
// 		break;
// 
// 	case FILE_DATE:
// 	case FILE_BEDATE:
// 	case FILE_LEDATE:
// 	case FILE_MEDATE:
// 		o = CAST(int32_t, (ms->offset + sizeof(uint32_t)));
// 		break;
// 
// 	case FILE_LDATE:
// 	case FILE_BELDATE:
// 	case FILE_LELDATE:
// 	case FILE_MELDATE:
// 		o = CAST(int32_t, (ms->offset + sizeof(uint32_t)));
// 		break;
// 
// 	case FILE_QDATE:
// 	case FILE_BEQDATE:
// 	case FILE_LEQDATE:
// 		o = CAST(int32_t, (ms->offset + sizeof(uint64_t)));
// 		break;
// 
// 	case FILE_QLDATE:
// 	case FILE_BEQLDATE:
// 	case FILE_LEQLDATE:
// 		o = CAST(int32_t, (ms->offset + sizeof(uint64_t)));
// 		break;
// 
//   	case FILE_FLOAT:
//   	case FILE_BEFLOAT:
//   	case FILE_LEFLOAT:
// 		o = CAST(int32_t, (ms->offset + sizeof(float)));
// 		break;
// 
//   	case FILE_DOUBLE:
//   	case FILE_BEDOUBLE:
//   	case FILE_LEDOUBLE:
// 		o = CAST(int32_t, (ms->offset + sizeof(double)));
// 		break;
// 
// 	case FILE_REGEX:
// 		if ((m->str_flags & REGEX_OFFSET_START) != 0)
// 			o = CAST(int32_t, ms->search.offset);
// 		else
// 			o = CAST(int32_t,
// 			    (ms->search.offset + ms->search.rm_len));
// 		break;
// 
// 	case FILE_SEARCH:
// 		if ((m->str_flags & REGEX_OFFSET_START) != 0)
// 			o = CAST(int32_t, ms->search.offset);
// 		else
// 			o = CAST(int32_t, (ms->search.offset + m->vallen));
// 		break;
// 
// 	case FILE_CLEAR:
// 	case FILE_DEFAULT:
// 	case FILE_INDIRECT:
// 	case FILE_OFFSET:
// 	case FILE_USE:
// 		o = ms->offset;
// 		break;
// 
// 	case FILE_DER:
// 		o = der_offs(ms, m, nbytes);
// 		if (o == -1 || CAST(size_t, o) > nbytes) {
// 			if ((ms->flags & MAGIC_DEBUG) != 0) {
// 				(void)fprintf(stderr,
// 				    "Bad DER offset %d nbytes=%"
// 				    SIZE_T_FORMAT "u", o, nbytes);
// 			}
// 			*op = 0;
// 			return 0;
// 		}
// 		break;
// 
// 	case FILE_GUID:
// 		o = CAST(int32_t, (ms->offset + 2 * sizeof(uint64_t)));
// 		break;
// 
// 	default:
// 		o = 0;
// 		break;
// 	}
// 
// 	if (CAST(size_t, o) > nbytes) {
// #if 0
// 		file_error(ms, 0, "Offset out of range %" SIZE_T_FORMAT
// 		    "u > %" SIZE_T_FORMAT "u", (size_t)o, nbytes);
// #endif
// 		return -1;
// 	}
// 	*op = o;
// 	return 1;
// }

// the below code fragment can be found in:
// src/softmagic.c
// private void
// mdebug(uint32_t offset, const char *str, size_t len)
// {
// 	(void) fprintf(stderr, "mget/%" SIZE_T_FORMAT "u @%d: ", len, offset);
// 	file_showstr(stderr, str, len);
// 	(void) fputc('\n', stderr);
// 	(void) fputc('\n', stderr);
// }

