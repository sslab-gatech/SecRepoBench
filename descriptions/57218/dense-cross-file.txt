// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// code/AssetLib/SMD/SMDLoader.cpp
void SMDImporter::ParseVertex(const char* szCurrent,
        const char** szCurrentOut, SMD::Vertex& vertex,
        bool bVASection /*= false*/) {
    if (SkipSpaces(&szCurrent) && IsLineEnd(*szCurrent)) {
        SkipSpacesAndLineEnd(szCurrent,&szCurrent);
        return ParseVertex(szCurrent,szCurrentOut,vertex,bVASection);
    }
    if(!ParseSignedInt(szCurrent,&szCurrent,(int&)vertex.iParentNode)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing vertex.parent");
        SMDI_PARSE_RETURN;
    }
    if(!ParseFloat(szCurrent,&szCurrent,(float&)vertex.pos.x)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing vertex.pos.x");
        SMDI_PARSE_RETURN;
    }
    if(!ParseFloat(szCurrent,&szCurrent,(float&)vertex.pos.y)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing vertex.pos.y");
        SMDI_PARSE_RETURN;
    }
    if(!ParseFloat(szCurrent,&szCurrent,(float&)vertex.pos.z)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing vertex.pos.z");
        SMDI_PARSE_RETURN;
    }
    if(!ParseFloat(szCurrent,&szCurrent,(float&)vertex.nor.x)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing vertex.nor.x");
        SMDI_PARSE_RETURN;
    }
    if(!ParseFloat(szCurrent,&szCurrent,(float&)vertex.nor.y)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing vertex.nor.y");
        SMDI_PARSE_RETURN;
    }
    if(!ParseFloat(szCurrent,&szCurrent,(float&)vertex.nor.z)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing vertex.nor.z");
        SMDI_PARSE_RETURN;
    }

    if (bVASection) {
        SMDI_PARSE_RETURN;
    }

    if(!ParseFloat(szCurrent,&szCurrent,(float&)vertex.uv.x)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing vertex.uv.x");
        SMDI_PARSE_RETURN;
    }
    if(!ParseFloat(szCurrent,&szCurrent,(float&)vertex.uv.y)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing vertex.uv.y");
        SMDI_PARSE_RETURN;
    }

    // now read the number of bones affecting this vertex
    // all elements from now are fully optional, we don't need them
    unsigned int iSize = 0;
    if(!ParseUnsignedInt(szCurrent,&szCurrent,iSize)) {
        SMDI_PARSE_RETURN;
    }
    vertex.aiBoneLinks.resize(iSize,std::pair<unsigned int, float>(0,0.0f));

    for (auto &aiBoneLink : vertex.aiBoneLinks) {
        if(!ParseUnsignedInt(szCurrent,&szCurrent,aiBoneLink.first)) {
            SMDI_PARSE_RETURN;
        }
        if(!ParseFloat(szCurrent,&szCurrent,aiBoneLink.second)) {
            SMDI_PARSE_RETURN;
        }
    }

    // go to the beginning of the next line
    SMDI_PARSE_RETURN;
}

// the below code fragment can be found in:
// code/AssetLib/SMD/SMDLoader.cpp
void SMDImporter::ParseNodesSection(const char* szCurrent, const char** szCurrentOut) {
    for ( ;; ) {
        // "end\n" - Ends the nodes section
        if (0 == ASSIMP_strincmp(szCurrent,"end",3) && IsSpaceOrNewLine(*(szCurrent+3))) {
            szCurrent += 4;
            break;
        }
        ParseNodeInfo(szCurrent,&szCurrent);
    }
    SkipSpacesAndLineEnd(szCurrent,&szCurrent);
    *szCurrentOut = szCurrent;
}

// the below code fragment can be found in:
// code/AssetLib/SMD/SMDLoader.cpp
void SMDImporter::ParseSkeletonElement(const char* szCurrent, const char** szCurrentOut,int iTime) {
    aiVector3D vPos;
    aiVector3D vRot;

    unsigned int iBone  = 0;
    if(!ParseUnsignedInt(szCurrent,&szCurrent,iBone)) {
        ASSIMP_LOG_ERROR("Unexpected EOF/EOL while parsing bone index");
        SMDI_PARSE_RETURN;
    }
    if (iBone >= asBones.size()) {
        LogErrorNoThrow("Bone index in skeleton section is out of range");
        SMDI_PARSE_RETURN;
    }
    SMD::Bone& bone = asBones[iBone];

    bone.sAnim.asKeys.emplace_back();
    SMD::Bone::Animation::MatrixKey& key = bone.sAnim.asKeys.back();

    key.dTime = (double)iTime;
    if(!ParseFloat(szCurrent,&szCurrent,(float&)vPos.x)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing bone.pos.x");
        SMDI_PARSE_RETURN;
    }
    if(!ParseFloat(szCurrent,&szCurrent,(float&)vPos.y)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing bone.pos.y");
        SMDI_PARSE_RETURN;
    }
    if(!ParseFloat(szCurrent,&szCurrent,(float&)vPos.z)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing bone.pos.z");
        SMDI_PARSE_RETURN;
    }
    if(!ParseFloat(szCurrent,&szCurrent,(float&)vRot.x)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing bone.rot.x");
        SMDI_PARSE_RETURN;
    }
    if(!ParseFloat(szCurrent,&szCurrent,(float&)vRot.y)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing bone.rot.y");
        SMDI_PARSE_RETURN;
    }
    if(!ParseFloat(szCurrent,&szCurrent,(float&)vRot.z)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing bone.rot.z");
        SMDI_PARSE_RETURN;
    }
    // build the transformation matrix of the key
    key.matrix.FromEulerAnglesXYZ(vRot.x,vRot.y,vRot.z); {
        aiMatrix4x4 mTemp;
        mTemp.a4 = vPos.x;
        mTemp.b4 = vPos.y;
        mTemp.c4 = vPos.z;
        key.matrix = mTemp * key.matrix;
    }
    key.vPos = vPos;
    key.vRot = vRot;
    // go to the beginning of the next line
    SMDI_PARSE_RETURN;
}

// the below code fragment can be found in:
// code/AssetLib/SMD/SMDLoader.cpp
void SMDImporter::ParseSkeletonSection(const char* szCurrent, const char** szCurrentOut) {
    int iTime = 0;
    for ( ;; ) {
        if (!SkipSpacesAndLineEnd(szCurrent,&szCurrent)) {
            break;
        }

        // "end\n" - Ends the skeleton section
        if (TokenMatch(szCurrent,"end",3)) {
            break;
        } else if (TokenMatch(szCurrent,"time",4)) {
        // "time <n>\n" - Specifies the current animation frame
            if(!ParseSignedInt(szCurrent,&szCurrent,iTime)) {
                break;
            }

            iSmallestFrame = std::min(iSmallestFrame,iTime);
            SkipLine(szCurrent,&szCurrent);
        } else {
            ParseSkeletonElement(szCurrent,&szCurrent,iTime);
        }
    }
    *szCurrentOut = szCurrent;
}

// the below code fragment can be found in:
// code/AssetLib/SMD/SMDLoader.cpp
void SMDImporter::ParseFile() {
    const char* szCurrent = &mBuffer[0];

    // read line per line ...
    for ( ;; ) {
        if(!SkipSpacesAndLineEnd(szCurrent,&szCurrent)) {
            break;
        }

        // "version <n> \n", <n> should be 1 for hl and hl2 SMD files
        if (TokenMatch(szCurrent,"version",7)) {
            if(!SkipSpaces(szCurrent,&szCurrent)) break;
            if (1 != strtoul10(szCurrent,&szCurrent)) {
                ASSIMP_LOG_WARN("SMD.version is not 1. This "
                    "file format is not known. Continuing happily ...");
            }
            continue;
        }
        // "nodes\n" - Starts the node section
        if (TokenMatch(szCurrent,"nodes",5)) {
            ParseNodesSection(szCurrent,&szCurrent);
            continue;
        }
        // "triangles\n" - Starts the triangle section
        if (TokenMatch(szCurrent,"triangles",9)) {
            ParseTrianglesSection(szCurrent,&szCurrent);
            continue;
        }
        // "vertexanimation\n" - Starts the vertex animation section
        if (TokenMatch(szCurrent,"vertexanimation",15)) {
            bHasUVs = false;
            ParseVASection(szCurrent,&szCurrent);
            continue;
        }
        // "skeleton\n" - Starts the skeleton section
        if (TokenMatch(szCurrent,"skeleton",8)) {
            ParseSkeletonSection(szCurrent,&szCurrent);
            continue;
        }
        SkipLine(szCurrent,&szCurrent);
    }
}

