// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// code/AssetLib/SMD/SMDLoader.cpp
void SMDImporter::ParseTriangle(const char* szCurrent, const char** szCurrentOut) {
    asTriangles.emplace_back();
    SMD::Face& face = asTriangles.back();

    if(!SkipSpaces(szCurrent,&szCurrent)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing a triangle");
        return;
    }

    // read the texture file name
    const char* szLast = szCurrent;
    while (!IsSpaceOrNewLine(*++szCurrent));

    // ... and get the index that belongs to this file name
    face.iTexture = GetTextureIndex(std::string(szLast,(uintptr_t)szCurrent-(uintptr_t)szLast));

    SkipSpacesAndLineEnd(szCurrent,&szCurrent);

    // load three vertices
    for (auto &avVertex : face.avVertices) {
        ParseVertex(szCurrent,&szCurrent, avVertex);
    }
    *szCurrentOut = szCurrent;
}

// the below code fragment can be found in:
// code/AssetLib/SMD/SMDLoader.cpp
void SMDImporter::ParseVertex(const char* szCurrent,
        const char** szCurrentOut, SMD::Vertex& vertex,
        bool bVASection /*= false*/) {
    if (SkipSpaces(&szCurrent) && IsLineEnd(*szCurrent)) {
        SkipSpacesAndLineEnd(szCurrent,&szCurrent);
        return ParseVertex(szCurrent,szCurrentOut,vertex,bVASection);
    }
    if(!ParseSignedInt(szCurrent,&szCurrent,(int&)vertex.iParentNode)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing vertex.parent");
        SMDI_PARSE_RETURN;
    }
    if(!ParseFloat(szCurrent,&szCurrent,(float&)vertex.pos.x)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing vertex.pos.x");
        SMDI_PARSE_RETURN;
    }
    if(!ParseFloat(szCurrent,&szCurrent,(float&)vertex.pos.y)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing vertex.pos.y");
        SMDI_PARSE_RETURN;
    }
    if(!ParseFloat(szCurrent,&szCurrent,(float&)vertex.pos.z)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing vertex.pos.z");
        SMDI_PARSE_RETURN;
    }
    if(!ParseFloat(szCurrent,&szCurrent,(float&)vertex.nor.x)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing vertex.nor.x");
        SMDI_PARSE_RETURN;
    }
    if(!ParseFloat(szCurrent,&szCurrent,(float&)vertex.nor.y)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing vertex.nor.y");
        SMDI_PARSE_RETURN;
    }
    if(!ParseFloat(szCurrent,&szCurrent,(float&)vertex.nor.z)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing vertex.nor.z");
        SMDI_PARSE_RETURN;
    }

    if (bVASection) {
        SMDI_PARSE_RETURN;
    }

    if(!ParseFloat(szCurrent,&szCurrent,(float&)vertex.uv.x)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing vertex.uv.x");
        SMDI_PARSE_RETURN;
    }
    if(!ParseFloat(szCurrent,&szCurrent,(float&)vertex.uv.y)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing vertex.uv.y");
        SMDI_PARSE_RETURN;
    }

    // now read the number of bones affecting this vertex
    // all elements from now are fully optional, we don't need them
    unsigned int iSize = 0;
    if(!ParseUnsignedInt(szCurrent,&szCurrent,iSize)) {
        SMDI_PARSE_RETURN;
    }
    vertex.aiBoneLinks.resize(iSize,std::pair<unsigned int, float>(0,0.0f));

    for (auto &aiBoneLink : vertex.aiBoneLinks) {
        if(!ParseUnsignedInt(szCurrent,&szCurrent,aiBoneLink.first)) {
            SMDI_PARSE_RETURN;
        }
        if(!ParseFloat(szCurrent,&szCurrent,aiBoneLink.second)) {
            SMDI_PARSE_RETURN;
        }
    }

    // go to the beginning of the next line
    SMDI_PARSE_RETURN;
}

// the below code fragment can be found in:
// code/AssetLib/LWO/LWOLoader.cpp
void LWOImporter::LoadLWOPoints(unsigned int length) {
    // --- this function is used for both LWO2 and LWOB but for
    // LWO2 we need to allocate 25% more storage - it could be we'll
    // need to duplicate some points later.
    const size_t vertexLen = 12;
    if ((length % vertexLen) != 0) {
        throw DeadlyImportError("LWO2: Points chunk length is not multiple of vertexLen (12)");
    }
    unsigned int regularSize = (unsigned int)mCurLayer->mTempPoints.size() + length / 12;
    if (mIsLWO2 || mIsLWO3) {
        mCurLayer->mTempPoints.reserve(regularSize + (regularSize >> 2u));
        mCurLayer->mTempPoints.resize(regularSize);

        // initialize all point referrers with the default values
        mCurLayer->mPointReferrers.reserve(regularSize + (regularSize >> 2u));
        mCurLayer->mPointReferrers.resize(regularSize, UINT_MAX);
    } else
        mCurLayer->mTempPoints.resize(regularSize);

        // perform endianness conversions
#ifndef AI_BUILD_BIG_ENDIAN
    for (unsigned int i = 0; i<length >> 2; ++i)
        ByteSwap::Swap4(mFileBuffer + (i << 2));
#endif
    ::memcpy(&mCurLayer->mTempPoints[0], mFileBuffer, length);
}

// the below code fragment can be found in:
// code/AssetLib/SMD/SMDLoader.cpp
bool SMDImporter::ParseFloat(const char* szCurrent, const char** szCurrentOut, float& out) {
    if(!SkipSpaces(&szCurrent)) {
        return false;
    }

    *szCurrentOut = fast_atoreal_move<float>(szCurrent,out);
    return true;
}

// the below code fragment can be found in:
// code/AssetLib/MDL/MDLLoader.cpp
MDL::IntBone_MDL7 **MDLImporter::LoadBones_3DGS_MDL7() {
    const MDL::Header_MDL7 *pcHeader = (const MDL::Header_MDL7 *)this->mBuffer;
    if (pcHeader->bones_num) {
        // validate the size of the bone data structure in the file
        if (AI_MDL7_BONE_STRUCT_SIZE__NAME_IS_20_CHARS != pcHeader->bone_stc_size &&
                AI_MDL7_BONE_STRUCT_SIZE__NAME_IS_32_CHARS != pcHeader->bone_stc_size &&
                AI_MDL7_BONE_STRUCT_SIZE__NAME_IS_NOT_THERE != pcHeader->bone_stc_size) {
            ASSIMP_LOG_WARN("Unknown size of bone data structure");
            return nullptr;
        }

        MDL::IntBone_MDL7 **apcBonesOut = new MDL::IntBone_MDL7 *[pcHeader->bones_num];
        for (uint32_t crank = 0; crank < pcHeader->bones_num; ++crank)
            apcBonesOut[crank] = new MDL::IntBone_MDL7();

        // and calculate absolute bone offset matrices ...
        CalcAbsBoneMatrices_3DGS_MDL7(apcBonesOut);
        return apcBonesOut;
    }
    return nullptr;
}

