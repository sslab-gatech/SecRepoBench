// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// code/AssetLib/SMD/SMDLoader.cpp
void SMDImporter::ParseTriangle(const char* szCurrent, const char** szCurrentOut) {
    asTriangles.emplace_back();
    SMD::Face& face = asTriangles.back();

    if(!SkipSpaces(szCurrent,&szCurrent)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing a triangle");
        return;
    }

    // read the texture file name
    const char* szLast = szCurrent;
    while (!IsSpaceOrNewLine(*++szCurrent));

    // ... and get the index that belongs to this file name
    face.iTexture = GetTextureIndex(std::string(szLast,(uintptr_t)szCurrent-(uintptr_t)szLast));

    SkipSpacesAndLineEnd(szCurrent,&szCurrent);

    // load three vertices
    for (auto &avVertex : face.avVertices) {
        ParseVertex(szCurrent,&szCurrent, avVertex);
    }
    *szCurrentOut = szCurrent;
}

// the below code fragment can be found in:
// code/AssetLib/SMD/SMDLoader.cpp
void SMDImporter::ParseVertex(const char* szCurrent,
        const char** szCurrentOut, SMD::Vertex& vertex,
        bool bVASection /*= false*/) {
    if (SkipSpaces(&szCurrent) && IsLineEnd(*szCurrent)) {
        SkipSpacesAndLineEnd(szCurrent,&szCurrent);
        return ParseVertex(szCurrent,szCurrentOut,vertex,bVASection);
    }
    if(!ParseSignedInt(szCurrent,&szCurrent,(int&)vertex.iParentNode)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing vertex.parent");
        SMDI_PARSE_RETURN;
    }
    if(!ParseFloat(szCurrent,&szCurrent,(float&)vertex.pos.x)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing vertex.pos.x");
        SMDI_PARSE_RETURN;
    }
    if(!ParseFloat(szCurrent,&szCurrent,(float&)vertex.pos.y)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing vertex.pos.y");
        SMDI_PARSE_RETURN;
    }
    if(!ParseFloat(szCurrent,&szCurrent,(float&)vertex.pos.z)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing vertex.pos.z");
        SMDI_PARSE_RETURN;
    }
    if(!ParseFloat(szCurrent,&szCurrent,(float&)vertex.nor.x)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing vertex.nor.x");
        SMDI_PARSE_RETURN;
    }
    if(!ParseFloat(szCurrent,&szCurrent,(float&)vertex.nor.y)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing vertex.nor.y");
        SMDI_PARSE_RETURN;
    }
    if(!ParseFloat(szCurrent,&szCurrent,(float&)vertex.nor.z)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing vertex.nor.z");
        SMDI_PARSE_RETURN;
    }

    if (bVASection) {
        SMDI_PARSE_RETURN;
    }

    if(!ParseFloat(szCurrent,&szCurrent,(float&)vertex.uv.x)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing vertex.uv.x");
        SMDI_PARSE_RETURN;
    }
    if(!ParseFloat(szCurrent,&szCurrent,(float&)vertex.uv.y)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing vertex.uv.y");
        SMDI_PARSE_RETURN;
    }

    // now read the number of bones affecting this vertex
    // all elements from now are fully optional, we don't need them
    unsigned int iSize = 0;
    if(!ParseUnsignedInt(szCurrent,&szCurrent,iSize)) {
        SMDI_PARSE_RETURN;
    }
    vertex.aiBoneLinks.resize(iSize,std::pair<unsigned int, float>(0,0.0f));

    for (auto &aiBoneLink : vertex.aiBoneLinks) {
        if(!ParseUnsignedInt(szCurrent,&szCurrent,aiBoneLink.first)) {
            SMDI_PARSE_RETURN;
        }
        if(!ParseFloat(szCurrent,&szCurrent,aiBoneLink.second)) {
            SMDI_PARSE_RETURN;
        }
    }

    // go to the beginning of the next line
    SMDI_PARSE_RETURN;
}

// the below code fragment can be found in:
// code/AssetLib/SMD/SMDLoader.cpp
bool SMDImporter::ParseFloat(const char* szCurrent, const char** szCurrentOut, float& out) {
    if(!SkipSpaces(&szCurrent)) {
        return false;
    }

    *szCurrentOut = fast_atoreal_move<float>(szCurrent,out);
    return true;
}

// the below code fragment can be found in:
// code/AssetLib/SMD/SMDLoader.cpp
void SMDImporter::AddBoneChildren(aiNode* pcNode, uint32_t iParent) {
    ai_assert( nullptr != pcNode );
    ai_assert( 0 == pcNode->mNumChildren );
    ai_assert( nullptr == pcNode->mChildren);

    // first count ...
    for (auto &bone : asBones) {
        if (bone.iParent == iParent) {
            ++pcNode->mNumChildren;
        }
    }

    // now allocate the output array
    pcNode->mChildren = new aiNode*[pcNode->mNumChildren];

    // and fill all subnodes
    unsigned int qq( 0 );
    for (unsigned int i = 0; i < asBones.size();++i) {
        SMD::Bone& bone = asBones[i];
        if (bone.iParent != iParent) {
            continue;
        }

        aiNode* pc = pcNode->mChildren[qq++] = new aiNode();
        pc->mName.Set(bone.mName);

        // store the local transformation matrix of the bind pose
        if (bone.sAnim.asKeys.size()) {
            pc->mTransformation = bone.sAnim.asKeys[0].matrix;
        }

        if (bone.iParent == static_cast<uint32_t>(-1)) {
            bone.mOffsetMatrix = pc->mTransformation;
        } else {
            bone.mOffsetMatrix = asBones[bone.iParent].mOffsetMatrix * pc->mTransformation;
        }

        pc->mParent = pcNode;

        // add children to this node, too
        AddBoneChildren(pc,i);
    }
}

// the below code fragment can be found in:
// code/AssetLib/SMD/SMDLoader.h
SMDImporter : public BaseImporter {
public:
    SMDImporter();
    ~SMDImporter() override;

    // -------------------------------------------------------------------
    /** Returns whether the class can handle the format of the given file.
     * See BaseImporter::CanRead() for details.
     */
    bool CanRead( const std::string& pFile, IOSystem* pIOHandler,
        bool checkSig) const override;

    // -------------------------------------------------------------------
    /** Called prior to ReadFile().
     * The function is a request to the importer to update its configuration
     * basing on the Importer's configuration property list.
     */
    void SetupProperties(const Importer* pImp) override;

protected:
    // -------------------------------------------------------------------
    /** Return importer meta information.
     * See #BaseImporter::GetInfo for the details
     */
    const aiImporterDesc* GetInfo () const override;

    // -------------------------------------------------------------------
    /** Imports the given file into the given scene structure.
    * See BaseImporter::InternReadFile() for details
    */
    void InternReadFile( const std::string& pFile, aiScene* pScene,
        IOSystem* pIOHandler) override;

    // -------------------------------------------------------------------
    /** Parse the SMD file and create the output scene
    */
    void ParseFile();
    void ReadSmd(const std::string &pFile, IOSystem* pIOHandler);

    // -------------------------------------------------------------------
    /** Parse the triangles section of the SMD file
     * \param szCurrent Current position in the file. Points to the first
     * data line of the section.
     * \param szCurrentOut Receives a pointer to the heading line of
     * the next section (or to EOF)
    */
    void ParseTrianglesSection(const char* szCurrent,
        const char** szCurrentOut);

    // -------------------------------------------------------------------
    /** Parse the vertex animation section in VTA files
     * \param szCurrent Current position in the file. Points to the first
     * data line of the section.
     * \param szCurrentOut Receives a pointer to the heading line of
     * the next section (or to EOF)
    */
    void ParseVASection(const char* szCurrent,
        const char** szCurrentOut);

    // -------------------------------------------------------------------
    /** Parse the nodes section of the SMD file
     * \param szCurrent Current position in the file. Points to the first
     * data line of the section.
     * \param szCurrentOut Receives a pointer to the heading line of
     * the next section (or to EOF)
    */
    void ParseNodesSection(const char* szCurrent,
        const char** szCurrentOut);

    // -------------------------------------------------------------------
    /** Parse the skeleton section of the SMD file
     * \param szCurrent Current position in the file. Points to the first
     * data line of the section.
     * \param szCurrentOut Receives a pointer to the heading line of
     * the next section (or to EOF)
    */
    void ParseSkeletonSection(const char* szCurrent,
        const char** szCurrentOut);

    // -------------------------------------------------------------------
    /** Parse a single triangle in the SMD file
     * \param szCurrent Current position in the file. Points to the first
     * data line of the section.
     * \param szCurrentOut Receives the output cursor position
    */
    void ParseTriangle(const char* szCurrent,
        const char** szCurrentOut);


    // -------------------------------------------------------------------
    /** Parse a single vertex in the SMD file
     * \param szCurrent Current position in the file. Points to the first
     * data line of the section.
     * \param szCurrentOut Receives the output cursor position
     * \param vertex Vertex to be filled
    */
    void ParseVertex(const char* szCurrent,
        const char** szCurrentOut, SMD::Vertex& vertex,
        bool bVASection = false);

    // -------------------------------------------------------------------
    /** Get  the index of a texture. If the texture was not yet known
     *  it will be added to the internal texture list.
     * \param filename Name of the texture
     * \return Value texture index
     */
    unsigned int GetTextureIndex(const std::string& filename);

    // -------------------------------------------------------------------
    /** Parse a line in the skeleton section
     */
    void ParseSkeletonElement(const char* szCurrent,
        const char** szCurrentOut,int iTime);

    // -------------------------------------------------------------------
    /** Parse a line in the nodes section
     */
    void ParseNodeInfo(const char* szCurrent,
        const char** szCurrentOut);


    // -------------------------------------------------------------------
    /** Parse a floating-point value
     */
    bool ParseFloat(const char* szCurrent,
        const char** szCurrentOut, float& out);

    // -------------------------------------------------------------------
    /** Parse an unsigned integer. There may be no sign!
     */
    bool ParseUnsignedInt(const char* szCurrent,
        const char** szCurrentOut, unsigned int& out);

    // -------------------------------------------------------------------
    /** Parse a signed integer. Signs (+,-) are handled.
     */
    bool ParseSignedInt(const char* szCurrent,
        const char** szCurrentOut, int& out);

    // -------------------------------------------------------------------
    /** Fix invalid time values in the file
     */
    void FixTimeValues();

    // -------------------------------------------------------------------
    /** Add all children of a bone as subnodes to a node
     * \param pcNode Parent node
     * \param iParent Parent bone index
     */
    void AddBoneChildren(aiNode* pcNode, uint32_t iParent);

    // -------------------------------------------------------------------
    /** Build output meshes/materials/nodes/animations
     */
    void CreateOutputMeshes();
    void CreateOutputNodes();
    void CreateOutputAnimations(const std::string &pFile, IOSystem* pIOHandler);
    void CreateOutputAnimation(int index, const std::string &name);
    void GetAnimationFileList(const std::string &pFile, IOSystem* pIOHandler, std::vector<std::tuple<std::string, std::string>>& outList);
    void CreateOutputMaterials();


    // -------------------------------------------------------------------
    /** Print a log message together with the current line number
     */
    void LogErrorNoThrow(const char* msg);
    void LogWarning(const char* msg);


    // -------------------------------------------------------------------
    inline bool SkipLine( const char* in, const char** out)
    {
        Assimp::SkipLine(in,out);
        ++iLineNumber;
        return true;
    }
    // -------------------------------------------------------------------
    inline bool SkipSpacesAndLineEnd( const char* in, const char** out)
    {
        ++iLineNumber;
        return Assimp::SkipSpacesAndLineEnd(in,out);
    }

private:

    /** Configuration option: frame to be loaded */
    unsigned int configFrameID;

    /** Buffer to hold the loaded file */
    std::vector<char> mBuffer;

    /** Output scene to be filled
    */
    aiScene* pScene;

    /** Size of the input file in bytes
     */
    unsigned int iFileSize;

    /** Array of textures found in the file
     */
    std::vector<std::string> aszTextures;

    /** Array of triangles found in the file
     */
    std::vector<SMD::Face> asTriangles;

    /** Array of bones found in the file
     */
    std::vector<SMD::Bone> asBones;

    /** Smallest frame index found in the skeleton
     */
    int iSmallestFrame;

    /** Length of the whole animation, in frames
     */
    double dLengthOfAnim;

    /** Do we have texture coordinates?
     */
    bool bHasUVs;

    /** Current line number
     */
    unsigned int iLineNumber;

    bool bLoadAnimationList = true;
    bool noSkeletonMesh = false;
}

