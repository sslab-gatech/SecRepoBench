// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/mat73.c
static int
Mat_H5ReadGroupInfo(mat_t *mat, matvar_t *matvar, hid_t dset_id)
{
    int fields_are_variables = 1;
    hsize_t nfields = 0, nelems;
    hid_t attr_id, field_id;
    matvar_t **fields;
    H5O_type_t obj_type;
    int err;

    err = Mat_H5ReadVarInfo(matvar, dset_id);
    if ( err ) {
        return err;
    }

    /* Check if the variable is sparse */
    if ( H5Aexists_by_name(dset_id, ".", "MATLAB_sparse", H5P_DEFAULT) ) {
        herr_t herr;
        hid_t sparse_dset_id;
        unsigned nrows = 0;

        attr_id = H5Aopen_by_name(dset_id, ".", "MATLAB_sparse", H5P_DEFAULT, H5P_DEFAULT);
        herr = H5Aread(attr_id, H5T_NATIVE_UINT, &nrows);
        H5Aclose(attr_id);
        if ( herr < 0 ) {
            return MATIO_E_GENERIC_READ_ERROR;
        }

        matvar->class_type = MAT_C_SPARSE;

        sparse_dset_id = H5Dopen(dset_id, "jc", H5P_DEFAULT);
        matvar->dims = Mat_H5ReadDims(sparse_dset_id, &nelems, &matvar->rank);
        H5Dclose(sparse_dset_id);
        if ( NULL != matvar->dims ) {
            if ( 1 == matvar->rank ) {
                size_t *dims = (size_t *)realloc(matvar->dims, 2 * sizeof(*matvar->dims));
                if ( NULL != dims ) {
                    matvar->rank = 2;
                    matvar->dims = dims;
                }
            }
            if ( 2 == matvar->rank ) {
                matvar->dims[1] = matvar->dims[0] - 1;
                matvar->dims[0] = nrows;
            }
        } else {
            return MATIO_E_UNKNOWN_ERROR;
        }

        /* Test if dataset type is compound and if so if it's complex */
        if ( H5Lexists(dset_id, "data", H5P_DEFAULT) ) {
            hid_t type_id;
            sparse_dset_id = H5Dopen(dset_id, "data", H5P_DEFAULT);
            type_id = H5Dget_type(sparse_dset_id);
            if ( H5T_COMPOUND == H5Tget_class(type_id) ) {
                /* FIXME: Any more checks? */
                matvar->isComplex = MAT_F_COMPLEX;
            }
            H5Tclose(type_id);
            H5Dclose(sparse_dset_id);
        }
        return MATIO_E_NO_ERROR;
    }

    if ( MAT_C_STRUCT != matvar->class_type ) {
        return MATIO_E_GENERIC_READ_ERROR;
    }

    /* Check if the structure defines its fields in MATLAB_fields */
    if ( H5Aexists_by_name(dset_id, ".", "MATLAB_fields", H5P_DEFAULT) ) {
        err = Mat_H5ReadFieldNames(matvar, dset_id, &nfields);
        if ( err ) {
            return err;
        }
    } else {
        herr_t herr;
        H5G_info_t group_info;
        matvar->internal->num_fields = 0;
        group_info.nlinks = 0;
        herr = H5Gget_info(dset_id, &group_info);
        if ( herr >= 0 && group_info.nlinks > 0 ) {
            struct ReadGroupInfoIterData group_data = {0, NULL};

            /* First iteration to retrieve number of relevant links */
            herr = H5Literate(dset_id, H5_INDEX_NAME, H5_ITER_NATIVE, NULL,
                              Mat_H5ReadGroupInfoIterate, (void *)&group_data);
            if ( herr > 0 && group_data.nfields > 0 ) {
                matvar->internal->fieldnames = (char **)calloc(
                    (size_t)(group_data.nfields), sizeof(*matvar->internal->fieldnames));
                group_data.nfields = 0;
                group_data.matvar = matvar;
                if ( matvar->internal->fieldnames != NULL ) {
                    /* Second iteration to fill fieldnames */
                    H5Literate(dset_id, H5_INDEX_NAME, H5_ITER_NATIVE, NULL,
                               Mat_H5ReadGroupInfoIterate, (void *)&group_data);
                }
                matvar->internal->num_fields = (unsigned)group_data.nfields;
                nfields = group_data.nfields;
            }
        }
    }

    if ( nfields > 0 ) {
        herr_t herr;
        H5O_INFO_T object_info;
        object_info.type = H5O_TYPE_UNKNOWN;
        herr = H5OGET_INFO_BY_NAME(dset_id, matvar->internal->fieldnames[0], &object_info,
                                   H5P_DEFAULT);
        if ( herr < 0 ) {
            return MATIO_E_GENERIC_READ_ERROR;
        }
        obj_type = object_info.type;
    } else {
        obj_type = H5O_TYPE_UNKNOWN;
    }
    if ( obj_type == H5O_TYPE_DATASET ) {
        hid_t field_type_id;
        field_id = H5Dopen(dset_id, matvar->internal->fieldnames[0], H5P_DEFAULT);
        if ( field_id < 0 ) {
            return MATIO_E_GENERIC_READ_ERROR;
        }
        field_type_id = H5Dget_type(field_id);
        if ( H5T_REFERENCE == H5Tget_class(field_type_id) ) {
            /* Check if the field has the MATLAB_class attribute. If so, it
             * means the structure is a scalar. Otherwise, the dimensions of
             * the field dataset is the dimensions of the structure
             */
            if ( H5Aexists_by_name(field_id, ".", "MATLAB_class", H5P_DEFAULT) ) {
                matvar->rank = 2;
                matvar->dims = (size_t *)malloc(2 * sizeof(*matvar->dims));
                if ( NULL != matvar->dims ) {
                    matvar->dims[0] = 1;
                    matvar->dims[1] = 1;
                    nelems = 1;
                } else {
                    H5Tclose(field_type_id);
                    H5Dclose(field_id);
                    Mat_Critical("Error allocating memory for matvar->dims");
                    return MATIO_E_OUT_OF_MEMORY;
                }
            } else {
                matvar->dims = Mat_H5ReadDims(field_id, &nelems, &matvar->rank);
                if ( NULL != matvar->dims ) {
                    fields_are_variables = 0;
                } else {
                    H5Tclose(field_type_id);
                    H5Dclose(field_id);
                    return MATIO_E_OUT_OF_MEMORY;
                }
            }
        } else {
            /* Structure should be a scalar */
            matvar->rank = 2;
            matvar->dims = (size_t *)malloc(2 * sizeof(*matvar->dims));
            if ( NULL != matvar->dims ) {
                matvar->dims[0] = 1;
                matvar->dims[1] = 1;
                nelems = 1;
            } else {
                H5Tclose(field_type_id);
                H5Dclose(field_id);
                Mat_Critical("Error allocating memory for matvar->dims");
                return MATIO_E_OUT_OF_MEMORY;
            }
        }
        H5Tclose(field_type_id);
        H5Dclose(field_id);
    } else {
        /* Structure should be a scalar */
        matvar->rank = 2;
        matvar->dims = (size_t *)malloc(2 * sizeof(*matvar->dims));
        if ( NULL != matvar->dims ) {
            matvar->dims[0] = 1;
            matvar->dims[1] = 1;
            nelems = 1;
        } else {
            Mat_Critical("Error allocating memory for matvar->dims");
            return MATIO_E_OUT_OF_MEMORY;
        }
    }

    if ( nelems < 1 || nfields < 1 )
        return err;

    matvar->data_size = sizeof(*fields);
    {
        size_t nelems_x_nfields;
        err = Mul(&nelems_x_nfields, nelems, nfields);
        err |= Mul(&matvar->nbytes, nelems_x_nfields, matvar->data_size);
        if ( err ) {
            Mat_Critical("Integer multiplication overflow");
            matvar->nbytes = 0;
            return err;
        }
    }
    fields = (matvar_t **)calloc(matvar->nbytes, 1);
    matvar->data = fields;
    if ( NULL != fields ) {
        hsize_t k;
        for ( k = 0; k < nfields; k++ ) {
            herr_t herr;
            H5O_INFO_T object_info;
            fields[k] = NULL;
            object_info.type = H5O_TYPE_UNKNOWN;
            herr = H5OGET_INFO_BY_NAME(dset_id, matvar->internal->fieldnames[k], &object_info,
                                       H5P_DEFAULT);
            if ( herr < 0 ) {
                err = MATIO_E_GENERIC_READ_ERROR;
                break;
            }
            if ( object_info.type == H5O_TYPE_DATASET ) {
                field_id = H5Dopen(dset_id, matvar->internal->fieldnames[k], H5P_DEFAULT);
                if ( !fields_are_variables ) {
                    hobj_ref_t *ref_ids = (hobj_ref_t *)calloc((size_t)nelems, sizeof(*ref_ids));
                    if ( ref_ids != NULL ) {
                        hsize_t l;
                        herr = H5Dread(field_id, H5T_STD_REF_OBJ, H5S_ALL, H5S_ALL, H5P_DEFAULT,
                                       ref_ids);
                        if ( herr < 0 ) {
                            err = MATIO_E_GENERIC_READ_ERROR;
                        } else {
                            for ( l = 0; l < nelems; l++ ) {
                                hid_t ref_id;
                                fields[l * nfields + k] = Mat_VarCalloc();
                                fields[l * nfields + k]->name =
                                    strdup(matvar->internal->fieldnames[k]);
                                fields[l * nfields + k]->internal->hdf5_ref = ref_ids[l];
                                /* Closing of ref_id is done in Mat_H5ReadNextReferenceInfo */
                                ref_id = H5RDEREFERENCE(field_id, H5R_OBJECT, ref_ids + l);
                                if ( ref_id < 0 ) {
                                    err = MATIO_E_GENERIC_READ_ERROR;
                                } else {
                                    fields[l * nfields + k]->internal->id = ref_id;
                                    err = Mat_H5ReadNextReferenceInfo(ref_id,
                                                                      fields[l * nfields + k], mat);
                                }
                                if ( err ) {
                                    break;
                                }
                            }
                        }
                        free(ref_ids);
                    } else {
                        err = MATIO_E_OUT_OF_MEMORY;
                    }
                    H5Dclose(field_id);
                } else {
                    fields[k] = Mat_VarCalloc();
                    fields[k]->name = strdup(matvar->internal->fieldnames[k]);
                    err = Mat_H5ReadDatasetInfo(mat, fields[k], field_id);
                }
            } else if ( object_info.type == H5O_TYPE_GROUP ) {
                field_id = H5Gopen(dset_id, matvar->internal->fieldnames[k], H5P_DEFAULT);
                if ( -1 < field_id ) {
                    fields[k] = Mat_VarCalloc();
                    fields[k]->name = strdup(matvar->internal->fieldnames[k]);
                    err = Mat_H5ReadGroupInfo(mat, fields[k], field_id);
                }
            }
            if ( err ) {
                break;
            }
        }
    } else {
        err = MATIO_E_OUT_OF_MEMORY;
    }

    return err;
}

// the below code fragment can be found in:
// src/mat73.c
static int
Mat_H5ReadNextReferenceData(matvar_t *matvar, mat_t *mat)
{
    int err = MATIO_E_NO_ERROR;
    size_t nelems = 1;

    if ( NULL == mat || NULL == matvar )
        return MATIO_E_BAD_ARGUMENT;
    if ( matvar->internal->id < 0 )
        return MATIO_E_FAIL_TO_IDENTIFY;

    /* If the datatype with references is a cell, we've already read info into
     * the variable data, so just loop over each cell element and call
     * Mat_H5ReadNextReferenceData on it.
     */
    if ( MAT_C_CELL == matvar->class_type ) {
        size_t i;
        matvar_t **cells;

        if ( NULL == matvar->data ) {
            return err;
        }
        err = Mat_MulDims(matvar, &nelems);
        if ( err ) {
            return err;
        }
        cells = (matvar_t **)matvar->data;
        for ( i = 0; i < nelems; i++ ) {
            if ( NULL != cells[i] ) {
                err = Mat_H5ReadNextReferenceData(cells[i], mat);
            }
            if ( err ) {
                break;
            }
        }
        return err;
    }

    switch ( H5Iget_type(matvar->internal->id) ) {
        case H5I_DATASET: {
            hid_t data_type_id;
            if ( MAT_C_CHAR == matvar->class_type ) {
                matvar->data_size = (int)Mat_SizeOf(matvar->data_type);
                data_type_id = DataType2H5T(matvar->data_type);
            } else if ( MAT_C_STRUCT == matvar->class_type ) {
                /* Empty structure array */
                break;
            } else {
                matvar->data_size = (int)Mat_SizeOfClass(matvar->class_type);
                data_type_id = ClassType2H5T(matvar->class_type);
            }

            err = Mat_MulDims(matvar, &nelems);
            err |= Mul(&matvar->nbytes, nelems, matvar->data_size);
            if ( err || matvar->nbytes < 1 ) {
                H5Dclose(matvar->internal->id);
                matvar->internal->id = H5I_INVALID_HID;
                break;
            }

            if ( !matvar->isComplex ) {
                matvar->data = malloc(matvar->nbytes);
            } else {
                matvar->data = ComplexMalloc(matvar->nbytes);
            }
            if ( NULL != matvar->data ) {
                err = Mat_H5ReadData(matvar->internal->id, data_type_id, H5S_ALL, H5S_ALL,
                                     matvar->isComplex, matvar->data);
            }
            break;
        }
        case H5I_GROUP: {
            if ( MAT_C_SPARSE == matvar->class_type ) {
                err = Mat_VarRead73(mat, matvar);
            } else {
                matvar_t **fields;
                size_t i;

                if ( !matvar->nbytes || !matvar->data_size || NULL == matvar->data )
                    break;
                nelems = matvar->nbytes / matvar->data_size;
                fields = (matvar_t **)matvar->data;
                for ( i = 0; i < nelems; i++ ) {
                    if ( NULL != fields[i] && 0 < fields[i]->internal->hdf5_ref &&
                         fields[i]->internal->id >= 0 ) {
                        /* Dataset of references */
                        err = Mat_H5ReadNextReferenceData(fields[i], mat);
                    } else {
                        err = Mat_VarRead73(mat, fields[i]);
                    }
                    if ( err ) {
                        break;
                    }
                }
            }
            break;
        }
        default:
            break;
    }

    return err;
}

// the below code fragment can be found in:
// src/mat73.c
static int
Mat_H5ReadVarInfo(matvar_t *matvar, hid_t dset_id)
{
    hid_t attr_id, type_id;
    int err = MATIO_E_NO_ERROR;
    char *class_str;

    matvar->internal->id = dset_id;
    attr_id = H5Aopen_by_name(dset_id, ".", "MATLAB_class", H5P_DEFAULT, H5P_DEFAULT);
    if ( attr_id < 1 )
        return MATIO_E_FAIL_TO_IDENTIFY;
    type_id = H5Aget_type(attr_id);
    class_str = (char *)calloc(H5Tget_size(type_id) + 1, 1);
    if ( NULL != class_str ) {
        herr_t herr = H5Aread(attr_id, type_id, class_str);
        if ( herr < 0 ) {
            free(class_str);
            H5Tclose(type_id);
            H5Aclose(attr_id);
            return MATIO_E_GENERIC_READ_ERROR;
        }
        matvar->class_type = ClassStr2ClassType(class_str);
        if ( MAT_C_EMPTY == matvar->class_type || MAT_C_CHAR == matvar->class_type ) {
            int int_decode = 0;
            if ( H5Aexists_by_name(dset_id, ".", "MATLAB_int_decode", H5P_DEFAULT) ) {
                hid_t attr_id2 =
                    H5Aopen_by_name(dset_id, ".", "MATLAB_int_decode", H5P_DEFAULT, H5P_DEFAULT);
                /* FIXME: Check that dataspace is scalar */
                herr = H5Aread(attr_id2, H5T_NATIVE_INT, &int_decode);
                H5Aclose(attr_id2);
                if ( herr < 0 ) {
                    free(class_str);
                    H5Tclose(type_id);
                    H5Aclose(attr_id);
                    return MATIO_E_GENERIC_READ_ERROR;
                }
            }
            switch ( int_decode ) {
                case 2:
                    matvar->data_type = MAT_T_UINT16;
                    break;
                case 1:
                    matvar->data_type = MAT_T_UINT8;
                    break;
                case 4:
                    matvar->data_type = MAT_T_UINT32;
                    break;
                default:
                    matvar->data_type = MAT_T_UNKNOWN;
                    break;
            }
            if ( MAT_C_EMPTY == matvar->class_type ) {
                /* Check if this is a logical variable */
                if ( 0 == strcmp(class_str, "logical") ) {
                    matvar->isLogical = MAT_F_LOGICAL;
                }
                matvar->class_type = DataType2ClassType(matvar->data_type);
            } else if ( MAT_T_UNKNOWN == matvar->data_type ) {
                matvar->data_type = MAT_T_UINT16;
            }
        } else {
            matvar->data_type = ClassType2DataType(matvar->class_type);
        }
        free(class_str);
    } else {
        err = MATIO_E_OUT_OF_MEMORY;
    }
    H5Tclose(type_id);
    H5Aclose(attr_id);

    if ( err ) {
        return err;
    }

    /* Check if the variable is global */
    if ( H5Aexists_by_name(dset_id, ".", "MATLAB_global", H5P_DEFAULT) ) {
        herr_t herr;
        attr_id = H5Aopen_by_name(dset_id, ".", "MATLAB_global", H5P_DEFAULT, H5P_DEFAULT);
        /* FIXME: Check that dataspace is scalar */
        herr = H5Aread(attr_id, H5T_NATIVE_INT, &matvar->isGlobal);
        H5Aclose(attr_id);
        if ( herr < 0 ) {
            return MATIO_E_GENERIC_READ_ERROR;
        }
    }

    return MATIO_E_NO_ERROR;
}

// the below code fragment can be found in:
// src/mat73.c
static int
Mat_VarWriteStruct73(hid_t id, matvar_t *matvar, const char *name, hid_t *refs_id, hsize_t *dims,
                     hsize_t *max_dims)
{
    int err;
    hsize_t nelems;

    {
        size_t tmp = 1;
        err = Mat_MulDims(matvar, &tmp);
        nelems = (hsize_t)tmp;
    }

    if ( err || 0 == nelems || NULL == matvar->data ) {
        err = Mat_VarWriteEmpty(id, matvar, name, ClassNames[matvar->class_type]);
    } else {
        hid_t struct_id = H5Gcreate(id, name, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
        if ( struct_id < 0 ) {
            Mat_Critical("Error creating group for struct %s", name);
            err = MATIO_E_OUTPUT_BAD_DATA;
        } else {
            hid_t attr_id, aspace_id;
            hid_t str_type_id;
            matvar_t **fields = (matvar_t **)matvar->data;
            hsize_t nfields = matvar->internal->num_fields, k;

            str_type_id = H5Tcopy(H5T_C_S1);
            H5Tset_size(str_type_id, 6);
            aspace_id = H5Screate(H5S_SCALAR);
            attr_id = H5Acreate(struct_id, "MATLAB_class", str_type_id, aspace_id, H5P_DEFAULT,
                                H5P_DEFAULT);
            if ( 0 > H5Awrite(attr_id, str_type_id, "struct") )
                err = MATIO_E_GENERIC_WRITE_ERROR;
            H5Aclose(attr_id);
            H5Sclose(aspace_id);

            /* Structure with no fields */
            if ( nfields == 0 ) {
                H5Gclose(struct_id);
                H5Tclose(str_type_id);
                return err;
            }

            if ( MATIO_E_NO_ERROR == err ) {
                hvl_t *fieldnames = (hvl_t *)malloc((size_t)nfields * sizeof(*fieldnames));
                if ( NULL != fieldnames ) {
                    hid_t fieldnames_id;
                    for ( k = 0; k < nfields; k++ ) {
                        fieldnames[k].len = strlen(matvar->internal->fieldnames[k]);
                        fieldnames[k].p = matvar->internal->fieldnames[k];
                    }
                    H5Tset_size(str_type_id, 1);
                    fieldnames_id = H5Tvlen_create(str_type_id);
                    aspace_id = H5Screate_simple(1, &nfields, NULL);
                    attr_id = H5Acreate(struct_id, "MATLAB_fields", fieldnames_id, aspace_id,
                                        H5P_DEFAULT, H5P_DEFAULT);
                    if ( 0 > H5Awrite(attr_id, fieldnames_id, fieldnames) )
                        err = MATIO_E_GENERIC_WRITE_ERROR;
                    H5Aclose(attr_id);
                    H5Sclose(aspace_id);
                    H5Tclose(fieldnames_id);
                    H5Tclose(str_type_id);
                    free(fieldnames);
                } else {
                    err = MATIO_E_OUT_OF_MEMORY;
                }
            }

            if ( MATIO_E_NO_ERROR == err ) {
                if ( 1 == nelems && NULL == max_dims ) {
                    for ( k = 0; k < nfields; k++ ) {
                        if ( NULL != fields[k] )
                            fields[k]->compression = matvar->compression;
                        err = Mat_VarWriteNext73(struct_id, fields[k],
                                                 matvar->internal->fieldnames[k], refs_id);
                    }
                } else {
                    if ( *refs_id < 0 ) {
                        if ( H5Lexists(id, "/#refs#", H5P_DEFAULT) ) {
                            *refs_id = H5Gopen(id, "/#refs#", H5P_DEFAULT);
                        } else {
                            *refs_id =
                                H5Gcreate(id, "/#refs#", H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
                        }
                    }
                    if ( *refs_id > -1 ) {
                        hid_t plist = H5P_DEFAULT;
                        hobj_ref_t **refs = (hobj_ref_t **)calloc((size_t)nfields, sizeof(*refs));
                        if ( NULL != refs ) {
                            hsize_t l;
                            for ( l = 0; l < nfields; l++ ) {
                                refs[l] = (hobj_ref_t *)calloc((size_t)nelems, sizeof(*refs[l]));
                                if ( NULL == refs[l] ) {
                                    err = MATIO_E_OUT_OF_MEMORY;
                                    break;
                                }
                            }

                            if ( MATIO_E_NO_ERROR == err ) {
                                for ( k = 0; k < nelems; k++ ) {
                                    for ( l = 0; l < nfields; l++ ) {
                                        err = Mat_VarWriteRef(id, fields[k * nfields + l],
                                                              matvar->compression, refs_id,
                                                              refs[l] + k);
                                        if ( err )
                                            break;
                                    }
                                    if ( err )
                                        break;
                                }
                            }

                            if ( MATIO_E_NO_ERROR == err ) {
                                if ( NULL != max_dims ) {
                                    plist = H5Pcreate(H5P_DATASET_CREATE);
                                    if ( MAX_RANK >= matvar->rank ) {
                                        hsize_t chunk_dims[MAX_RANK];
                                        Mat_H5GetChunkSize(matvar->rank, dims, chunk_dims);
                                        H5Pset_chunk(plist, matvar->rank, chunk_dims);
                                    } else {
                                        hsize_t *chunk_dims =
                                            (hsize_t *)malloc(matvar->rank * sizeof(hsize_t));
                                        if ( NULL != chunk_dims ) {
                                            Mat_H5GetChunkSize(matvar->rank, dims, chunk_dims);
                                            H5Pset_chunk(plist, matvar->rank, chunk_dims);
                                            free(chunk_dims);
                                        } else {
                                            H5Pclose(plist);
                                            plist = H5P_DEFAULT;
                                            err = MATIO_E_OUT_OF_MEMORY;
                                        }
                                    }
                                } else {
                                    plist = H5P_DEFAULT;
                                }
                            }

                            if ( MATIO_E_NO_ERROR == err ) {
                                hid_t mspace_id = H5Screate_simple(matvar->rank, dims, max_dims);
                                for ( l = 0; l < nfields; l++ ) {
                                    hid_t dset_id = H5Dcreate(
                                        struct_id, matvar->internal->fieldnames[l], H5T_STD_REF_OBJ,
                                        mspace_id, H5P_DEFAULT, plist, H5P_DEFAULT);
                                    err = Mat_H5WriteData(dset_id, H5T_STD_REF_OBJ, H5S_ALL,
                                                          H5S_ALL, 0, refs[l]);
                                    H5Dclose(dset_id);
                                    if ( err )
                                        break;
                                }
                                H5Sclose(mspace_id);
                            }
                            for ( l = 0; l < nfields; l++ )
                                free(refs[l]);
                            free(refs);
                        } else {
                            err = MATIO_E_OUT_OF_MEMORY;
                        }
                        if ( H5P_DEFAULT != plist )
                            H5Pclose(plist);
                    } else {
                        err = MATIO_E_OUTPUT_BAD_DATA;
                    }
                }
            }
            H5Gclose(struct_id);
        }
    }

    return err;
}

// the below code fragment can be found in:
// src/mat73.c
static int
Mat_H5ReadDatasetInfo(mat_t *mat, matvar_t *matvar, hid_t dset_id)
{
    int err;
    hsize_t nelems;

    err = Mat_H5ReadVarInfo(matvar, dset_id);
    if ( err ) {
        return err;
    }

    matvar->dims = Mat_H5ReadDims(dset_id, &nelems, &matvar->rank);
    if ( NULL == matvar->dims ) {
        return MATIO_E_UNKNOWN_ERROR;
    }

    /* Check for attribute that indicates an empty array */
    if ( H5Aexists_by_name(dset_id, ".", "MATLAB_empty", H5P_DEFAULT) ) {
        int empty = 0;
        herr_t herr;
        hid_t attr_id = H5Aopen_by_name(dset_id, ".", "MATLAB_empty", H5P_DEFAULT, H5P_DEFAULT);
        /* FIXME: Check that dataspace is scalar */
        herr = H5Aread(attr_id, H5T_NATIVE_INT, &empty);
        H5Aclose(attr_id);
        if ( herr < 0 ) {
            err = MATIO_E_GENERIC_READ_ERROR;
        } else if ( empty ) {
            matvar->rank = (int)matvar->dims[0];
            free(matvar->dims);
            matvar->dims = (size_t *)calloc(matvar->rank, sizeof(*matvar->dims));
            if ( matvar->dims == NULL ) {
                err = MATIO_E_OUT_OF_MEMORY;
            } else {
                herr =
                    H5Dread(dset_id, SizeType2H5T(), H5S_ALL, H5S_ALL, H5P_DEFAULT, matvar->dims);
                if ( herr < 0 ) {
                    err = MATIO_E_GENERIC_READ_ERROR;
                } else {
                    size_t tmp = 1;
                    err = Mat_MulDims(matvar, &tmp);
                    nelems = (hsize_t)tmp;
                }
            }
        }
        if ( err ) {
            return err;
        }
    }

    /* Test if dataset type is compound and if so if it's complex */
    {
        hid_t type_id = H5Dget_type(dset_id);
        if ( H5T_COMPOUND == H5Tget_class(type_id) ) {
            /* FIXME: Any more checks? */
            matvar->isComplex = MAT_F_COMPLEX;
        }
        H5Tclose(type_id);
    }

    /* Test if dataset is deflated */
    {
        hid_t plist_id = H5Dget_create_plist(dset_id);
        if ( plist_id > 0 ) {
            const int nFilters = H5Pget_nfilters(plist_id);
            int i;
            for ( i = 0; i < nFilters; i++ ) {
                const H5Z_filter_t filterType =
                    H5Pget_filter2(plist_id, i, NULL, NULL, 0, 0, NULL, NULL);
                if ( H5Z_FILTER_DEFLATE == filterType ) {
                    matvar->compression = MAT_COMPRESSION_ZLIB;
                    break;
                }
            }
            H5Pclose(plist_id);
        }
    }

    /* If the dataset is a cell array read the info of the cells */
    if ( MAT_C_CELL == matvar->class_type ) {
        matvar_t **cells;

        matvar->data_size = sizeof(matvar_t **);
        err = Mul(&matvar->nbytes, nelems, matvar->data_size);
        if ( err ) {
            Mat_Critical("Integer multiplication overflow");
            return err;
        }
        matvar->data = calloc(matvar->nbytes, 1);
        if ( NULL == matvar->data ) {
            Mat_Critical("Couldn't allocate memory for the data");
            return MATIO_E_OUT_OF_MEMORY;
        }
        cells = (matvar_t **)matvar->data;

        if ( nelems ) {
            hobj_ref_t *ref_ids = (hobj_ref_t *)calloc(nelems, sizeof(*ref_ids));
            if ( ref_ids != NULL ) {
                size_t i;
                herr_t herr =
                    H5Dread(dset_id, H5T_STD_REF_OBJ, H5S_ALL, H5S_ALL, H5P_DEFAULT, ref_ids);
                if ( herr < 0 ) {
                    free(ref_ids);
                    return MATIO_E_GENERIC_READ_ERROR;
                }
                for ( i = 0; i < nelems; i++ ) {
                    hid_t ref_id;
                    if ( matvar->internal->hdf5_ref == ref_ids[i] ) {
                        err = MATIO_E_GENERIC_READ_ERROR;
                        break;
                    }
                    cells[i] = Mat_VarCalloc();
                    cells[i]->internal->hdf5_ref = ref_ids[i];
                    /* Closing of ref_id is done in Mat_H5ReadNextReferenceInfo */
                    ref_id = H5RDEREFERENCE(dset_id, H5R_OBJECT, ref_ids + i);
                    if ( ref_id < 0 ) {
                        err = MATIO_E_GENERIC_READ_ERROR;
                    } else {
                        cells[i]->internal->id = ref_id;
                        err = Mat_H5ReadNextReferenceInfo(ref_id, cells[i], mat);
                    }
                    if ( err ) {
                        break;
                    }
                }
                free(ref_ids);
            } else {
                err = MATIO_E_OUT_OF_MEMORY;
            }
        }
    } else if ( MAT_C_STRUCT == matvar->class_type ) {
        /* Empty structures can be a dataset */

        /* Check if the structure defines its fields in MATLAB_fields */
        if ( H5Aexists_by_name(dset_id, ".", "MATLAB_fields", H5P_DEFAULT) ) {
            hsize_t nfields;
            err = Mat_H5ReadFieldNames(matvar, dset_id, &nfields);
        }
    }

    return err;
}

