PHP_METHOD(SplObjectStorage, unserialize)
{
	// Initialize an SplObjectStorage object and prepare for unserialization.
	// Parse function parameters to retrieve the serialized buffer and its length.
	// If the buffer is empty or parameter parsing fails, the function returns early.
	// Initialize variables for unserialization, including the storage, buffer pointers,
	// and data for unserialization.
	// Begin by verifying the serialized data format, ensuring it starts with specific
	// characters and retrieving the count of elements to unserialize.
	// For each element in the serialized data, verify the format and unserialize the
	// object entry and additional information if present.
	// Ensure the unserialized entry is an object, calculate a hash for the object,
	// and attempt to retrieve any existing element with the same hash in the storage.
	// If an element exists, manage resources for its associated data.
	// Attach the unserialized object and its info to the storage, replacing any existing
	// entry data with the new one. Handle resource management and cleanup for unserialized data.
	// <MASK>

	if (*p != ';') {
		goto outexcept;
	}
	++p;

	/* members */
	if (*p!= 'm' || *++p != ':') {
		goto outexcept;
	}
	++p;

	pmembers = var_tmp_var(&var_hash);
	if (!php_var_unserialize(pmembers, &p, s + buf_len, &var_hash) || Z_TYPE_P(pmembers) != IS_ARRAY) {
		goto outexcept;
	}

	/* copy members */
	object_properties_load(&intern->std, Z_ARRVAL_P(pmembers));

	PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
	return;

outexcept:
	PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
	zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0, "Error at offset %zd of %zd bytes", ((char*)p - buf), buf_len);
	RETURN_THROWS();

} /* }}} */