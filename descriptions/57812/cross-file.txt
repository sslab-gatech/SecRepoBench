// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// libavcodec/hevc_ps.c
// static inline int setup_pps(AVCodecContext *avctx, GetBitContext *gb,
//                             HEVCPPS *pps, HEVCSPS *sps)
// {
//     int log2_diff;
//     int pic_area_in_ctbs;
//     int i, j, x, y, ctb_addr_rs, tile_id;
// 
//     // Inferred parameters
//     pps->col_bd   = av_malloc_array(pps->num_tile_columns + 1, sizeof(*pps->col_bd));
//     pps->row_bd   = av_malloc_array(pps->num_tile_rows + 1,    sizeof(*pps->row_bd));
//     pps->col_idxX = av_malloc_array(sps->ctb_width,    sizeof(*pps->col_idxX));
//     if (!pps->col_bd || !pps->row_bd || !pps->col_idxX)
//         return AVERROR(ENOMEM);
// 
//     if (pps->uniform_spacing_flag) {
//         if (!pps->column_width) {
//             pps->column_width = av_malloc_array(pps->num_tile_columns, sizeof(*pps->column_width));
//             pps->row_height   = av_malloc_array(pps->num_tile_rows,    sizeof(*pps->row_height));
//         }
//         if (!pps->column_width || !pps->row_height)
//             return AVERROR(ENOMEM);
// 
//         for (i = 0; i < pps->num_tile_columns; i++) {
//             pps->column_width[i] = ((i + 1) * sps->ctb_width) / pps->num_tile_columns -
//                                    (i * sps->ctb_width) / pps->num_tile_columns;
//         }
// 
//         for (i = 0; i < pps->num_tile_rows; i++) {
//             pps->row_height[i] = ((i + 1) * sps->ctb_height) / pps->num_tile_rows -
//                                  (i * sps->ctb_height) / pps->num_tile_rows;
//         }
//     }
// 
//     pps->col_bd[0] = 0;
//     for (i = 0; i < pps->num_tile_columns; i++)
//         pps->col_bd[i + 1] = pps->col_bd[i] + pps->column_width[i];
// 
//     pps->row_bd[0] = 0;
//     for (i = 0; i < pps->num_tile_rows; i++)
//         pps->row_bd[i + 1] = pps->row_bd[i] + pps->row_height[i];
// 
//     for (i = 0, j = 0; i < sps->ctb_width; i++) {
//         if (i > pps->col_bd[j])
//             j++;
//         pps->col_idxX[i] = j;
//     }
// 
//     /**
//      * 6.5
//      */
//     pic_area_in_ctbs     = sps->ctb_width    * sps->ctb_height;
// 
//     pps->ctb_addr_rs_to_ts = av_malloc_array(pic_area_in_ctbs,    sizeof(*pps->ctb_addr_rs_to_ts));
//     pps->ctb_addr_ts_to_rs = av_malloc_array(pic_area_in_ctbs,    sizeof(*pps->ctb_addr_ts_to_rs));
//     pps->tile_id           = av_malloc_array(pic_area_in_ctbs,    sizeof(*pps->tile_id));
//     pps->min_tb_addr_zs_tab = av_malloc_array((sps->tb_mask+2) * (sps->tb_mask+2), sizeof(*pps->min_tb_addr_zs_tab));
//     if (!pps->ctb_addr_rs_to_ts || !pps->ctb_addr_ts_to_rs ||
//         !pps->tile_id || !pps->min_tb_addr_zs_tab) {
//         return AVERROR(ENOMEM);
//     }
// 
//     for (ctb_addr_rs = 0; ctb_addr_rs < pic_area_in_ctbs; ctb_addr_rs++) {
//         int tb_x   = ctb_addr_rs % sps->ctb_width;
//         int tb_y   = ctb_addr_rs / sps->ctb_width;
//         int tile_x = 0;
//         int tile_y = 0;
//         int val    = 0;
// 
//         for (i = 0; i < pps->num_tile_columns; i++) {
//             if (tb_x < pps->col_bd[i + 1]) {
//                 tile_x = i;
//                 break;
//             }
//         }
// 
//         for (i = 0; i < pps->num_tile_rows; i++) {
//             if (tb_y < pps->row_bd[i + 1]) {
//                 tile_y = i;
//                 break;
//             }
//         }
// 
//         for (i = 0; i < tile_x; i++)
//             val += pps->row_height[tile_y] * pps->column_width[i];
//         for (i = 0; i < tile_y; i++)
//             val += sps->ctb_width * pps->row_height[i];
// 
//         val += (tb_y - pps->row_bd[tile_y]) * pps->column_width[tile_x] +
//                tb_x - pps->col_bd[tile_x];
// 
//         pps->ctb_addr_rs_to_ts[ctb_addr_rs] = val;
//         pps->ctb_addr_ts_to_rs[val]         = ctb_addr_rs;
//     }
// 
//     for (j = 0, tile_id = 0; j < pps->num_tile_rows; j++)
//         for (i = 0; i < pps->num_tile_columns; i++, tile_id++)
//             for (y = pps->row_bd[j]; y < pps->row_bd[j + 1]; y++)
//                 for (x = pps->col_bd[i]; x < pps->col_bd[i + 1]; x++)
//                     pps->tile_id[pps->ctb_addr_rs_to_ts[y * sps->ctb_width + x]] = tile_id;
// 
//     pps->tile_pos_rs = av_malloc_array(tile_id, sizeof(*pps->tile_pos_rs));
//     if (!pps->tile_pos_rs)
//         return AVERROR(ENOMEM);
// 
//     for (j = 0; j < pps->num_tile_rows; j++)
//         for (i = 0; i < pps->num_tile_columns; i++)
//             pps->tile_pos_rs[j * pps->num_tile_columns + i] =
//                 pps->row_bd[j] * sps->ctb_width + pps->col_bd[i];
// 
//     log2_diff = sps->log2_ctb_size - sps->log2_min_tb_size;
//     pps->min_tb_addr_zs = &pps->min_tb_addr_zs_tab[1*(sps->tb_mask+2)+1];
//     for (y = 0; y < sps->tb_mask+2; y++) {
//         pps->min_tb_addr_zs_tab[y*(sps->tb_mask+2)] = -1;
//         pps->min_tb_addr_zs_tab[y]    = -1;
//     }
//     for (y = 0; y < sps->tb_mask+1; y++) {
//         for (x = 0; x < sps->tb_mask+1; x++) {
//             int tb_x = x >> log2_diff;
//             int tb_y = y >> log2_diff;
//             int rs   = sps->ctb_width * tb_y + tb_x;
//             int val  = pps->ctb_addr_rs_to_ts[rs] << (log2_diff * 2);
//             for (i = 0; i < log2_diff; i++) {
//                 int m = 1 << i;
//                 val += (m & x ? m * m : 0) + (m & y ? 2 * m * m : 0);
//             }
//             pps->min_tb_addr_zs[y * (sps->tb_mask+2) + x] = val;
//         }
//     }
// 
//     return 0;
// }

// the below code fragment can be found in:
// libavcodec/hevc_ps.c
// static int pps_scc_extension(GetBitContext *gb, AVCodecContext *avctx,
//                              HEVCPPS *pps, HEVCSPS *sps)
// {
//     int num_comps, ret;
// 
//     pps->pps_curr_pic_ref_enabled_flag = get_bits1(gb);
//     if (pps->residual_adaptive_colour_transform_enabled_flag = get_bits1(gb)) {
//         pps->pps_slice_act_qp_offsets_present_flag = get_bits1(gb);
//         pps->pps_act_y_qp_offset  = get_se_golomb_long(gb) - 5;
//         pps->pps_act_cb_qp_offset = get_se_golomb_long(gb) - 5;
//         pps->pps_act_cr_qp_offset = get_se_golomb_long(gb) - 3;
// 
// #define CHECK_QP_OFFSET(name) (pps->pps_act_ ## name ## _qp_offset <= -12 || \
//                                pps->pps_act_ ## name ## _qp_offset >= 12)
//         ret = CHECK_QP_OFFSET(y) || CHECK_QP_OFFSET(cb) || CHECK_QP_OFFSET(cr);
// #undef CHECK_QP_OFFSET
//         if (ret) {
//             av_log(avctx, AV_LOG_ERROR,
//                    "PpsActQpOffsetY/Cb/Cr shall be in the range of [-12, 12].\n");
//             return AVERROR_INVALIDDATA;
//         }
//     }
// 
//     if (pps->pps_palette_predictor_initializers_present_flag = get_bits1(gb)) {
//         if ((pps->pps_num_palette_predictor_initializers = get_ue_golomb_long(gb)) > 0) {
//             pps->monochrome_palette_flag = get_bits1(gb);
//             pps->luma_bit_depth_entry_minus8 = get_ue_golomb_long(gb);
//             if (!pps->monochrome_palette_flag)
//                 pps->chroma_bit_depth_entry_minus8 = get_ue_golomb_long(gb);
//             num_comps = pps->monochrome_palette_flag ? 1 : 3;
//             for (int comp = 0; comp < num_comps; comp++)
//                 for (int i = 0; i < pps->pps_num_palette_predictor_initializers; i++)
//                     pps->pps_palette_predictor_initializer[comp][i] =
//                         get_bits(gb, 8 + (!comp ? pps->luma_bit_depth_entry_minus8 :
//                                           pps->chroma_bit_depth_entry_minus8));
//         }
//     }
// 
//     return 0;
// }

// the below code fragment can be found in:
// libavcodec/hevc_ps.c
// void ff_hevc_ps_uninit(HEVCParamSets *ps)
// {
//     int i;
// 
//     for (i = 0; i < FF_ARRAY_ELEMS(ps->vps_list); i++)
//         av_buffer_unref(&ps->vps_list[i]);
//     for (i = 0; i < FF_ARRAY_ELEMS(ps->sps_list); i++)
//         av_buffer_unref(&ps->sps_list[i]);
//     for (i = 0; i < FF_ARRAY_ELEMS(ps->pps_list); i++)
//         av_buffer_unref(&ps->pps_list[i]);
// 
//     ps->sps = NULL;
//     ps->pps = NULL;
//     ps->vps = NULL;
// }

// the below code fragment can be found in:
// libavcodec/hevc_ps.c
// static int pps_range_extensions(GetBitContext *gb, AVCodecContext *avctx,
//                                 HEVCPPS *pps, HEVCSPS *sps)
// {
//     if (pps->transform_skip_enabled_flag) {
//         pps->log2_max_transform_skip_block_size = get_ue_golomb_long(gb) + 2;
//     }
//     pps->cross_component_prediction_enabled_flag = get_bits1(gb);
//     pps->chroma_qp_offset_list_enabled_flag = get_bits1(gb);
//     if (pps->chroma_qp_offset_list_enabled_flag) {
//         pps->diff_cu_chroma_qp_offset_depth = get_ue_golomb_long(gb);
//         pps->chroma_qp_offset_list_len_minus1 = get_ue_golomb_long(gb);
//         if (pps->chroma_qp_offset_list_len_minus1 > 5) {
//             av_log(avctx, AV_LOG_ERROR,
//                    "chroma_qp_offset_list_len_minus1 shall be in the range [0, 5].\n");
//             return AVERROR_INVALIDDATA;
//         }
//         for (int i = 0; i <= pps->chroma_qp_offset_list_len_minus1; i++) {
//             pps->cb_qp_offset_list[i] = get_se_golomb_long(gb);
//             if (pps->cb_qp_offset_list[i]) {
//                 av_log(avctx, AV_LOG_WARNING,
//                        "cb_qp_offset_list not tested yet.\n");
//             }
//             pps->cr_qp_offset_list[i] = get_se_golomb_long(gb);
//             if (pps->cr_qp_offset_list[i]) {
//                 av_log(avctx, AV_LOG_WARNING,
//                        "cb_qp_offset_list not tested yet.\n");
//             }
//         }
//     }
//     pps->log2_sao_offset_scale_luma = get_ue_golomb_long(gb);
//     pps->log2_sao_offset_scale_chroma = get_ue_golomb_long(gb);
// 
//     if (   pps->log2_sao_offset_scale_luma   > FFMAX(sps->bit_depth        - 10, 0)
//         || pps->log2_sao_offset_scale_chroma > FFMAX(sps->bit_depth_chroma - 10, 0)
//     )
//         return AVERROR_INVALIDDATA;
// 
//     return(0);
// }

// the below code fragment can be found in:
// libavcodec/hevc_ps.c
// static void delta_dlt(GetBitContext *gb, HEVCPPS *pps)
// {
//     unsigned int num_val_delta_dlt, max_diff = 0;
//     int min_diff_minus1 = -1;
//     unsigned int len;
// 
//     num_val_delta_dlt = get_bits(gb, pps->pps_bit_depth_for_depth_layers_minus8 + 8);
//     if (num_val_delta_dlt) {
//         if (num_val_delta_dlt > 1)
//             max_diff = get_bits(gb, pps->pps_bit_depth_for_depth_layers_minus8 + 8);
//         if (num_val_delta_dlt > 2 && max_diff) {
//             len = av_log2(max_diff) + 1;
//             min_diff_minus1 = get_bits(gb, len);
//         }
//         if (max_diff > (min_diff_minus1 + 1))
//             for (int k = 1; k < num_val_delta_dlt; k++) {
//                 len = av_log2(max_diff - (min_diff_minus1 + 1)) + 1;
//                 skip_bits(gb, len); // delta_val_diff_minus_min
//             }
//     }
// }

