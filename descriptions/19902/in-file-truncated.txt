/*
** string.c - String class
**
** See Copyright Notice in mruby.h
*/

#ifdef _MSC_VER
# define _CRT_NONSTDC_NO_DEPRECATE
#endif

#ifndef MRB_WITHOUT_FLOAT
#include <float.h>
#include <math.h>
#endif
#include <limits.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <mruby.h>
#include <mruby/array.h>
#include <mruby/class.h>
#include <mruby/range.h>
#include <mruby/string.h>
#include <mruby/numeric.h>

typedef struct mrb_shared_string {
  int refcnt;
  mrb_ssize capa;
  char *ptr;
} mrb_shared_string;

const char mrb_digitmap[] = "0123456789abcdefghijklmnopqrstuvwxyz";

#define mrb_obj_alloc_string(mrb) ((struct RString*)mrb_obj_alloc((mrb), MRB_TT_STRING, (mrb)->string_class))

static struct RString*
str_init_normal_capa(mrb_state *mrb, struct RString *s,
                     const char *p, size_t len, size_t capa)
{
  char *dst = (char *)mrb_malloc(mrb, capa + 1);
  if (p) memcpy(dst, p, len);
  dst[len] = '\0';
  s->as.heap.ptr = dst;
  s->as.heap.len = (mrb_ssize)len;
  s->as.heap.aux.capa = (mrb_ssize)capa;
  RSTR_UNSET_TYPE_

// --- CODE TRUNCATED HERE ---

double
mrb_str_len_to_dbl(mrb_state *mrb, const char *char_buffer, size_t len, mrb_bool badcheck)
{
  // Parse a string to a double value, handling various string formats.
  // 1. Trim leading whitespace from the input string.
  // 2. Check for and handle hexadecimal prefixes "0x" or "0X".
  // 3. Prepare a buffer to store cleaned input by removing underscores between digits.
  // 4. Iterate over the string, copying valid characters to the buffer.
  // 5. Handle null byte termination, and check for formatting errors when 'badcheck' is true.
  // 6. Convert the cleaned string in the buffer to a double using a library function.
  // 7. Return the parsed double value.
  // <MASK>
  *n = '\0';
  p = buf;
  pend = n;
nocopy:
  d = mrb_float_read(p, &end);
  if (p == end) {
    if (badcheck) {
bad:
      mrb_raisef(mrb, E_ARGUMENT_ERROR, "invalid string for float(%!s)", char_buffer);
      /* not reached */
    }
    return d;
  }
  if (badcheck) {
    if (!end || p == end) goto bad;
    while (end<pend && ISSPACE(*end)) end++;
    if (end<pend) goto bad;
  }
  return d;
}