// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/dwg.c
EXPORT int
dxf_read_file (const char *restrict filename, Dwg_Data *restrict dwg)
{
  int error;
  FILE *fp;
  struct_stat_t attrib;
  size_t size;
  Bit_Chain dat = { 0 };
  Dwg_Version_Type version;

  loglevel = dwg->opts & DWG_OPTS_LOGLEVEL;

  if (!filename || stat (filename, &attrib))
    {
      LOG_ERROR ("File not found: %s\n", filename ? filename : "(null)")
      return DWG_ERR_IOERROR;
    }
  if (!(S_ISREG (attrib.st_mode)
#  ifndef _WIN32
        || S_ISLNK (attrib.st_mode)
#  endif
            ))
    {
      LOG_ERROR ("Error: %s\n", filename)
      return DWG_ERR_IOERROR;
    }
  fp = fopen (filename, "rb");
  if (!fp)
    {
      LOG_ERROR ("Could not open file: %s\n", filename)
      return DWG_ERR_IOERROR;
    }

  /* Load whole file into memory
   */
  version = dwg->header.version;
  memset (dwg, 0, sizeof (Dwg_Data));
  dwg->opts = loglevel | DWG_OPTS_INDXF;
  dwg->header.version = version;

  memset (&dat, 0, sizeof (Bit_Chain));
#  ifdef HAVE_SYS_STAT_H
  dat.size = attrib.st_size;
#  endif
  dat.chain = (unsigned char *)calloc (1, dat.size + 2);
  if (!dat.chain)
    {
      LOG_ERROR ("Not enough memory.\n");
      fclose (fp);
      return DWG_ERR_OUTOFMEM;
    }
  dat.byte = 0;
  dat.bit = 0;
  dat.from_version = dwg->header.from_version;
  dat.version = dwg->header.version;
  dat.opts = dwg->opts;

  size = fread (dat.chain, sizeof (char), dat.size, fp);
  fclose (fp);
  if (size != dat.size)
    {
      LOG_ERROR ("Could not read the entire file (%" PRIuSIZE
                 " out of %" PRIuSIZE "): %s\n",
                 size, dat.size, filename)
      free (dat.chain);
      dat.chain = NULL;
      dat.size = 0;
      return DWG_ERR_IOERROR;
    }
  /*
0
SECTION
2
ENTITIES
0
ENDSEC
   */
  if (size < 31)
    {
      LOG_ERROR ("File %s too small, %" PRIuSIZE " byte.\n", filename, size)
      free (dat.chain);
      dat.chain = NULL;
      dat.size = 0;
      return DWG_ERR_IOERROR;
    }
  // properly end the buffer for strtol()/... readers
  if (dat.chain[size - 1] != '\n')
    {
      dat.chain[size] = '\n';
      dat.size++;
    }
  dat.chain[size] = '\0';

  /* Fail on DWG */
  if (!memcmp (dat.chain, "AC10", 4) || !memcmp (dat.chain, "AC1.", 4)
      || !memcmp (dat.chain, "AC2.10", 4) || !memcmp (dat.chain, "MC0.0", 4))
    {
      LOG_ERROR ("This is a DWG, not a DXF file: %s\n", filename)
      free (dat.chain);
      dat.chain = NULL;
      dat.size = 0;
      return DWG_ERR_INVALIDDWG;
    }
  /* See if binary or ascii */
  if (!memcmp (dat.chain, "AutoCAD Binary DXF",
               sizeof ("AutoCAD Binary DXF") - 1))
    {
      dat.byte = 22;
      error = dwg_read_dxfb (&dat, dwg);
    }
  else
    error = dwg_read_dxf (&dat, dwg);

  dwg->opts |= (DWG_OPTS_INDXF | loglevel);
  if (error >= DWG_ERR_CRITICAL)
    {
      LOG_ERROR ("Failed to decode DXF file: %s\n", filename)
      free (dat.chain);
      dat.chain = NULL;
      dat.size = 0;
      return error;
    }

  // TODO: does dwg hold any char* pointers to the dat or are they all copied?
  free (dat.chain);
  dat.chain = NULL;
  dat.size = 0;

  return 0;
}

// the below code fragment can be found in:
// src/decode_r11.c
{
    case SECTION_BLOCK:
      {
        SET_CONTROL (BLOCK);
        for (i = 0; i < tbl->number; i++)
          {
            NEW_OBJECT;
            error |= dwg_decode_BLOCK_HEADER (dat, obj);
            // PUSH_HV (_hdr, num_owned, entities, ref);
            ADD_CTRL_ENTRY;
            CHK_ENDPOS;
          }
      }
      break;

    case SECTION_LAYER:
      {
        SET_CONTROL (LAYER);
        for (i = 0; i < tbl->number; i++)
          {
            NEW_OBJECT;
            error |= dwg_decode_LAYER (dat, obj);
            ADD_CTRL_ENTRY;
            CHK_ENDPOS;
          }
      }
      break;

    // was a text STYLE table, became a STYLE object
    case SECTION_STYLE:
      {
        SET_CONTROL (STYLE);
        for (i = 0; i < tbl->number; i++)
          {
            NEW_OBJECT;
            error |= dwg_decode_STYLE (dat, obj);
            ADD_CTRL_ENTRY;
            CHK_ENDPOS;
          }
      }
      break;

    case SECTION_LTYPE:
      {
        SET_CONTROL (LTYPE);
        for (i = 0; i < tbl->number; i++)
          {
            NEW_OBJECT;
            error |= dwg_decode_LTYPE (dat, obj);
            ADD_CTRL_ENTRY;
            if (strEQc (tbl->name, "CONTINUOUS"))
              dwg->header_vars.LTYPE_CONTINUOUS = _ctrl->entries[i];
            CHK_ENDPOS;
          }
      }
      break;

    case SECTION_VIEW:
      {
        SET_CONTROL (VIEW);
        for (i = 0; i < tbl->number; i++)
          {
            NEW_OBJECT;
            error |= dwg_decode_VIEW (dat, obj);
            ADD_CTRL_ENTRY;
            CHK_ENDPOS;
          }
      }
      break;

    // SINCE R_11
    case SECTION_UCS:
      {
        SET_CONTROL (UCS);
        for (i = 0; i < tbl->number; i++)
          {
            NEW_OBJECT;
            error |= dwg_decode_UCS (dat, obj);
            ADD_CTRL_ENTRY;
            CHK_ENDPOS;
          }
      }
      break;

    // SINCE R_11
    case SECTION_VPORT:
      {
        SET_CONTROL (VPORT);
        for (i = 0; i < tbl->number; i++)
          {
            NEW_OBJECT;
            error |= dwg_decode_VPORT (dat, obj);
            ADD_CTRL_ENTRY;
            CHK_ENDPOS;
          }
      }
      break;

    // SINCE R_11
    case SECTION_APPID:
      {
        SET_CONTROL (APPID);
        for (i = 0; i < tbl->number; i++)
          {
            NEW_OBJECT;
            error |= dwg_decode_APPID (dat, obj);
            ADD_CTRL_ENTRY;
            CHK_ENDPOS;
          }
      }
      break;

    // SINCE R_11
    case SECTION_DIMSTYLE:
      {
        SET_CONTROL (DIMSTYLE);
        for (i = 0; i < tbl->number; i++)
          {
            NEW_OBJECT;
            error |= dwg_decode_DIMSTYLE (dat, obj);
            ADD_CTRL_ENTRY;
            CHK_ENDPOS;
          }
      }
      break;

    // SINCE R_11
    case SECTION_VX:
      {
        SET_CONTROL (VX);
        for (i = 0; i < tbl->number; i++)
          {
            NEW_OBJECT;
            error |= dwg_decode_VX_TABLE_RECORD (dat, obj);
            ADD_CTRL_ENTRY;
            CHK_ENDPOS;
          }
      }
      break;

    case SECTION_HEADER_R11:
    default:
      LOG_ERROR ("Invalid table id %d", id);
      tbl->number = 0;
      break;
    }

// the below code fragment can be found in:
// src/encode.c
static const char *
dxf_encode_alias (char *restrict name)
{
  if (strEQc (name, "DICTIONARYWDFLT"))
    return "ACDBDICTIONARYWDFLT";
  else if (strEQc (name, "SECTIONVIEWSTYLE"))
    return "ACDBSECTIONVIEWSTYLE";
  else if (strEQc (name, "PLACEHOLDER"))
    return "ACDBPLACEHOLDER";
  else if (strEQc (name, "DETAILVIEWSTYLE"))
    return "ACDBDETAILVIEWSTYLE";
  else if (strEQc (name, "ASSOCPERSSUBENTMANAGER"))
    return "ACDBASSOCPERSSUBENTMANAGER";
  else if (strEQc (name, "EVALUATION_GRAPH"))
    return "ACAD_EVALUATION_GRAPH";
  else if (strEQc (name, "ASSOCACTION"))
    return "ACDBASSOCACTION";
  else if (strEQc (name, "ASSOCALIGNEDDIMACTIONBODY"))
    return "ACDBASSOCALIGNEDDIMACTIONBODY";
  else if (strEQc (name, "ASSOCOSNAPPOINTREFACTIONPARAM"))
    return "ACDBASSOCOSNAPPOINTREFACTIONPARAM";
  else if (strEQc (name, "ASSOCVERTEXACTIONPARAM"))
    return "ACDBASSOCVERTEXACTIONPARAM";
  else if (strEQc (name, "ASSOCGEOMDEPENDENCY"))
    return "ACDBASSOCGEOMDEPENDENCY";
  else if (strEQc (name, "ASSOCDEPENDENCY"))
    return "ACDBASSOCDEPENDENCY";
  else if (strEQc (name, "TABLE"))
    return "ACAD_TABLE";
  else
    return NULL;
}

// the below code fragment can be found in:
// src/encode.c
AFL_GCC_POP

/* utf-8 string without lowercase letters, space or ! */
static BITCODE_T
fixup_invalid_tag (const Bit_Chain *restrict dat, char *restrict tag)
{
  size_t len;
  int changed = 0;
  BITCODE_TV newtag;
  BITCODE_TU wstr;
  if (!tag)
    return NULL;
  if (IS_FROM_TU (dat))
    wstr = (BITCODE_TU)tag;
  else
    wstr = bit_utf8_to_TU ((char*)tag, 0);
  len = bit_wcs2len (wstr);
  for (size_t i = 0; i < len; i++)
    {
      if (i > 256)
        {
          wstr[i] = 0;
          changed++;
          break;
        }
#ifdef HAVE_WCTYPE_H
      if (iswlower (wstr[i]))
        {
          wstr[i] = towupper (wstr[i]);
          changed++;
        }
#endif
      if (wstr[i] == L' ' || wstr[i] == L'!')
        {
          wstr[i] = L'_';
          changed++;
        }
    }
  if (changed && dat->version < R_2007)
    {
      newtag = bit_convert_TU (wstr);
      free (wstr);
      return newtag;
    }
  else
    return (BITCODE_T)tag;
}

// the below code fragment can be found in:
// src/decode.c
int
dwg_decode_unknown_bits (Bit_Chain *restrict dat, Dwg_Object *restrict obj)
{
  // bitsize does not include the handles size
  int num_bytes;
  size_t pos = bit_position (dat);
  long num_bits = ((8 * obj->size) - pos) & ULONG_MAX;
  if (num_bits < 0)
    return DWG_ERR_VALUEOUTOFBOUNDS;

  obj->num_unknown_bits = (BITCODE_RL)num_bits;
  num_bytes = num_bits / 8;
  if (num_bits % 8)
    num_bytes++;

  obj->unknown_bits = bit_read_bits (dat, num_bits);
  if (!obj->unknown_bits)
    {
      bit_set_position (dat, pos);
      return DWG_ERR_VALUEOUTOFBOUNDS;
    }
  // [num_bits (commonsize, hdlpos, strsize) num_bytes TF]
  LOG_TRACE ("unknown_bits [%ld (%" PRIuSIZE ",%ld,%d) %d TF]: ", num_bits,
             obj->common_size, (long)(obj->bitsize - obj->common_size),
             (int)obj->stringstream_size, num_bytes);
  LOG_TRACE_TF (obj->unknown_bits, num_bytes);
  LOG_TRACE ("\n");
  bit_set_position (dat, pos);
  return 0;
}

