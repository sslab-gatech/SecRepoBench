// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/encode.c
static BITCODE_RL
encode_preR13_entities (EntitySectionIndexR11 section, Bit_Chain *restrict dat,
                        Dwg_Data *restrict dwg, int *restrict error)
{
  BITCODE_RL numentities = 0;
  bool in_blocks = false;
  bool in_extras = false;
  LOG_INFO ("===========================\n"
            "%s from 0x%zx\n",
            section == ENTITIES_SECTION_INDEX ? "Entities"
            : section == BLOCKS_SECTION_INDEX ? "Blocks"
                                              : "Extras",
            dat->byte);
  for (unsigned index = 0; index < dwg->num_objects; index++)
    {
      Dwg_Object *obj = &dwg->object[index];
      size_t size_pos = 0UL;
      bool deleted = obj->type >= 128;
      // skip table objects or uninitialized entities
      if (obj->supertype != DWG_SUPERTYPE_ENTITY || !obj->tio.entity)
        {
          if (obj->index && obj->fixedtype)
            LOG_HANDLE ("Skip object %s, number: %d, Fixedtype: %d, Addr: %zx "
                        "(0x%zx)\n",
                        obj->name, obj->index, obj->fixedtype, obj->address,
                        dat->byte);
          continue;
        }
      // deleted, i.e. moved to a BLOCK
      if (obj->fixedtype == DWG_TYPE_UNUSED)
        {
          LOG_TRACE (
              "Deleted entity %s, number: %d, type: %d, Addr: %zx (0x%zx)\n",
              obj->name, obj->index, obj->type, obj->address, dat->byte);
        }
      // skip first 2 mspace block/endblk entities
      if (obj->type == DWG_TYPE_UNUSED_r11 && obj->index < 13)
        {
          LOG_HANDLE ("Unused entity %s, number: %d, Fixedtype: %d, Addr: %zx "
                      "(0x%zx)\n",
                      obj->name, obj->index, obj->fixedtype, obj->address,
                      dat->byte);
          continue;
        }
      // check if block/extras or entity member
      if (section == ENTITIES_SECTION_INDEX) // is entity
        {
          // but belongs to a block
          if (obj->fixedtype == DWG_TYPE_BLOCK)
            {
              Dwg_Object *next_endblk
                  = dwg_get_next_object (dwg, DWG_TYPE_ENDBLK, obj->index);
              if (next_endblk && next_endblk->index > obj->index)
                index += (next_endblk->index - obj->index);
              else
                in_blocks = true;
              continue;
            }
          if (dat->version >= R_2_0b && obj->tio.entity->entmode == 3)
            {
              LOG_TRACE ("Skip block %s in entities section, number: %d, "
                         "type: %d, Addr: %zx (0x%zx)\n",
                         obj->name, obj->index, obj->type, obj->address,
                         dat->byte);
              continue;
            }
          if (in_blocks)
            continue;
        }
      else if (section == BLOCKS_SECTION_INDEX)
        {
          // if (dat->version < R_2_0b || obj->tio.entity->entmode != 3)
          //   {
          //     LOG_TRACE ("Skip entity %s in block section, number: %d, "
          //                "type: %d, Addr: %zx (0x%zx)\n",
          //                obj->name, obj->index, obj->type, obj->address,
          //                dat->byte);
          //     continue;
          //   }
          if (obj->fixedtype == DWG_TYPE_BLOCK)
            in_blocks = true;
          if (!in_blocks)
            continue;
        }
      if (!in_extras && obj->fixedtype == DWG_TYPE_JUMP)
        in_extras = true; // jump into
      if (section == EXTRAS_SECTION_INDEX && !in_extras)
        continue;
      // jump back below

      while (dat->byte + obj->size >= dat->size)
        bit_chain_alloc (dat);
      numentities++;
      obj->address = dat->byte;
      LOG_INFO ("===========================\n"
                "Entity %s, number: %d, Addr: %" PRIuSIZE " (0x%zx)\n",
                obj->name, obj->index, obj->address, dat->byte);
      PRE (R_2_0b)
      {
        bit_write_RS (dat, obj->type);
        LOG_INFO ("type: %d [RS]\n", obj->type)
        if (obj->type > 64)
          LOG_INFO ("deleted\n")
      }
      LATER_VERSIONS
      {
        bit_write_RC (dat, obj->type);
        size_pos = dat->byte + 1; // past the flag
        LOG_INFO ("type: %d [RC]\n", obj->type)
      }

#define CASE_ENCODE_TYPE(ty)                                                  \
  case DWG_TYPE_##ty:                                                         \
    *error |= dwg_encode_##ty (dat, obj);                                     \
    break

      switch (obj->fixedtype)
        {
          CASE_ENCODE_TYPE (LINE);
          CASE_ENCODE_TYPE (POINT);
          CASE_ENCODE_TYPE (CIRCLE);
          CASE_ENCODE_TYPE (SHAPE);
          CASE_ENCODE_TYPE (REPEAT);
          CASE_ENCODE_TYPE (ENDREP);
          CASE_ENCODE_TYPE (TEXT);
          CASE_ENCODE_TYPE (ARC);
          CASE_ENCODE_TYPE (TRACE);
          CASE_ENCODE_TYPE (LOAD); /* convert from pre r2.0 */
          CASE_ENCODE_TYPE (SOLID);
          CASE_ENCODE_TYPE (BLOCK);
          CASE_ENCODE_TYPE (ENDBLK);
          CASE_ENCODE_TYPE (INSERT);
          CASE_ENCODE_TYPE (ATTDEF);
          CASE_ENCODE_TYPE (ATTRIB);
          CASE_ENCODE_TYPE (SEQEND);
          CASE_ENCODE_TYPE (JUMP);
          CASE_ENCODE_TYPE (POLYLINE_2D);
          CASE_ENCODE_TYPE (POLYLINE_3D);
          CASE_ENCODE_TYPE (POLYLINE_PFACE);
          CASE_ENCODE_TYPE (POLYLINE_MESH);
          CASE_ENCODE_TYPE (VERTEX_2D);
          CASE_ENCODE_TYPE (VERTEX_3D);
          CASE_ENCODE_TYPE (VERTEX_MESH);
          CASE_ENCODE_TYPE (VERTEX_PFACE);
          CASE_ENCODE_TYPE (VERTEX_PFACE_FACE);
          CASE_ENCODE_TYPE (_3DLINE);
          CASE_ENCODE_TYPE (_3DFACE);
          CASE_ENCODE_TYPE (DIMENSION_ORDINATE);
          CASE_ENCODE_TYPE (DIMENSION_LINEAR);
          CASE_ENCODE_TYPE (DIMENSION_ALIGNED);
          CASE_ENCODE_TYPE (DIMENSION_ANG3PT);
          CASE_ENCODE_TYPE (DIMENSION_ANG2LN);
          CASE_ENCODE_TYPE (DIMENSION_RADIUS);
          CASE_ENCODE_TYPE (DIMENSION_DIAMETER);
          CASE_ENCODE_TYPE (VIEWPORT);
        default:
          DEBUG_HERE;
          LOG_ERROR ("Unknown object type %d", obj->type)
          break;
        }

      if (in_blocks && obj->fixedtype == DWG_TYPE_ENDBLK)
        in_blocks = false;
      else if (!in_blocks && obj->fixedtype == DWG_TYPE_BLOCK)
        in_blocks = true;
      if (in_extras && obj->fixedtype == DWG_TYPE_JUMP)
        in_extras = false; // jump back

      SINCE (R_2_0)
      {
        // patchup size
        if (!obj->size)
          {
            size_t pos = dat->byte;
            obj->size = (dat->byte - obj->address) & 0xFFFFFFFF;
            SINCE (R_11)
            {
              obj->size += 2; // crc16
            }
            dat->byte = size_pos;
            bit_write_RS (dat, obj->size);
            LOG_TRACE ("-size: %u [RL] (@%" PRIuSIZE ".%u)\n", obj->size,
                       dat->byte, dat->bit)
            dat->byte = pos;
          }
        SINCE (R_11)
        {
          BITCODE_RS crc = bit_calc_CRC (0xC0C1, &dat->chain[obj->address],
                                         obj->size - 2);
          LOG_TRACE ("crc: %04X [RSx] from 0x%zx-0x%zx\n", crc, obj->address,
                     dat->byte);
          bit_write_RS (dat, crc);
        }
      }
    }
  return numentities;
}

// the below code fragment can be found in:
// src/decode_r11.c
int
decode_preR13 (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)
{
  BITCODE_RL num_entities;
  BITCODE_RL blocks_start = 0, blocks_end = 0, blocks_size = 0;
  BITCODE_RL extras_start = 0, extras_end = 0, extras_size = 0;
  BITCODE_RS rs2;
  Dwg_Object *obj = NULL;
  int error = 0;
  Bit_Chain dat_save = *dat;

  loglevel = dat->opts & DWG_OPTS_LOGLEVEL;
  {
    int i;
    Dwg_Header *_obj = (Dwg_Header *)&dwg->header;
    Bit_Chain *hdl_dat = dat;
    BITCODE_BL vcount;
    dat->byte = 0x06;
    // clang-format off
    #include "header.spec"
    // clang-format on
  }
  LOG_TRACE ("@0x%zx\n", dat->byte); // 0x14
  SINCE (R_2_0b)
  {
    // Block entities
    blocks_start = dwg->header.blocks_start;
    blocks_size = dwg->header.blocks_size;
    if (blocks_size > 0xffffff)
      {
        blocks_size &= 0xffffff;
        LOG_TRACE ("blocks_size => " FORMAT_RLx "\n", blocks_size);
      }
    blocks_end = blocks_start + blocks_size;
    // Extra entities
    extras_start = dwg->header.extras_start;
    extras_size = dwg->header.extras_size;
    if (extras_size > 0xffffff)
      {
        extras_size &= 0xffffff;
        LOG_TRACE ("extras_size => " FORMAT_RLx "\n", extras_size);
      }
    extras_end = extras_start + extras_size;
  }

  // setup all the new control objects
  error |= dwg_add_Document (dwg, 0);
  if (error >= DWG_ERR_CRITICAL)
    return error;

  SINCE (R_2_0b)
  {
    dwg->header.section[0].number = 0;
    dwg->header.section[0].type = (Dwg_Section_Type)SECTION_HEADER_R11;
    strcpy (dwg->header.section[0].name, "HEADER");

    // The 5 tables (num_sections always 5): 3 RS + 1 RL address
    LOG_INFO ("==========================================\n")
    dat_save = *dat;
    error |= decode_preR13_section_hdr ("BLOCK", SECTION_BLOCK, dat, dwg);
    if (error >= DWG_ERR_CRITICAL)
      return error;
    error |= decode_preR13_section_hdr ("LAYER", SECTION_LAYER, dat, dwg);
    if (error >= DWG_ERR_CRITICAL)
      return error;
    error |= decode_preR13_section_hdr ("STYLE", SECTION_STYLE, dat, dwg);
    if (error >= DWG_ERR_CRITICAL)
      return error;
    error |= decode_preR13_section_hdr ("LTYPE", SECTION_LTYPE, dat, dwg);
    if (error >= DWG_ERR_CRITICAL)
      return error;
    error |= decode_preR13_section_hdr ("VIEW", SECTION_VIEW, dat, dwg);
    if (error >= DWG_ERR_CRITICAL)
      return error;
  }
  LOG_TRACE ("@0x%zx\n", dat->byte); // 0x5e
  if (dat->size < 0x1f0)             // AC1.50 0x1f9 74 vars
    {
      LOG_ERROR ("DWG too small %" PRIuSIZE, (size_t)dat->size)
      return DWG_ERR_INVALIDDWG;
    }

  LOG_TRACE ("==========================================\n")
  error |= decode_preR13_header_variables (dat, dwg);
  LOG_TRACE ("@0x%zx\n", dat->byte);
  if (error >= DWG_ERR_CRITICAL)
    return error;
  if (dat->byte + 2 >= dat->size)
    {
      LOG_ERROR ("post HEADER overflow")
      return error | DWG_ERR_CRITICAL;
    }
  SINCE (R_11)
  {
    // crc16 + DWG_SENTINEL_R11_ENTITIES_BEGIN
    BITCODE_RS crc, crcc;
    crcc = bit_calc_CRC (0xC0C1, &dat->chain[0], dat->byte); // from 0 to now
    crc = bit_read_RS (dat);
    LOG_TRACE ("crc: %04X [RSx] from 0-0x%zx\n", crc, dat->byte - 2);
    if (crc != crcc)
      {
        LOG_ERROR ("Header CRC mismatch %04X <=> %04X", crc, crcc);
        error |= DWG_ERR_WRONGCRC;
      }
  }

  PRE (R_10)
  {
    num_entities = dwg->header_vars.numentities;
  }
  LATER_VERSIONS
  {
    num_entities = 0;
  }

// the below code fragment can be found in:
// src/decode.c
int
dwg_decode_add_object (Dwg_Data *restrict dwg, Bit_Chain *dat,
                       Bit_Chain *hdl_dat, size_t address)
{
  size_t objpos, restartpos;
  Bit_Chain abs_dat = { 0 };
  Dwg_Object *restrict obj;
  BITCODE_BL num = dwg->num_objects;
  int error = 0;
  int realloced = 0;

  /* Keep the previous full chain  */
  abs_dat = *dat;

  /* Use the indicated address for the object
   */
  dat->byte = address;
  dat->bit = 0;

  // DEBUG_HERE;
  /*
   * Reserve memory space for objects. A realloc violates all internal
   * pointers.
   */
  realloced = dwg_add_object (dwg);
  if (realloced > 0) // i.e. not realloced, but error
    {
      *dat = abs_dat;
      return realloced; // i.e. DWG_ERR_OUTOFMEM
    }
  obj = &dwg->object[num];
  LOG_INFO ("==========================================\n"
            "Object number: %lu/%lX",
            (unsigned long)num, (unsigned long)num)

  if (dat->byte >= dat->size)
    {
      LOG_ERROR ("MS size overflow @%" PRIuSIZE, dat->byte)
      dwg->num_objects--;
      return DWG_ERR_VALUEOUTOFBOUNDS;
    }
  obj->size = bit_read_MS (dat);
  LOG_INFO (", Size: %d [MS]", obj->size)
  SINCE (R_2010)
  {
    /* This is not counted in the object size */
    obj->handlestream_size = bit_read_UMC (dat);
    LOG_INFO (", Hdlsize: " FORMAT_UMC " [UMC] ", obj->handlestream_size);
    obj->bitsize = obj->size * 8 - obj->handlestream_size;
    // TODO boundscheck
  }

  objpos = bit_position (dat); // absolute
  obj->address = dat->byte;

  /* Until here dat is absolute. now restrict it */
  bit_reset_chain (dat);
  if (obj->size > dat->size || dat->size > abs_dat.size
      || &dat->chain[dat->size] < &dat->chain[0]
      || &abs_dat.chain[abs_dat.size] < &abs_dat.chain[0]
      || &dat->chain[dat->size] > &abs_dat.chain[abs_dat.size])
    {
      LOG_TRACE ("\n");
      LOG_WARN ("Invalid object size %u > %" PRIuSIZE ". Would overflow",
                obj->size, dat->size);
      dwg->num_objects--;
      error |= DWG_ERR_VALUEOUTOFBOUNDS;
#if 0
      obj->size = dat->size - 1;
#else
      *dat = abs_dat;
      return error;
#endif
    }
  dat->size = obj->size;

  SINCE (R_2010)
  {
    obj->type = bit_read_BOT (dat);
  }
  else
  {
    obj->type = bit_read_BS (dat);
  }
  LOG_INFO (", Type: %d [%s]", obj->type,
            dat->from_version >= R_2010 ? "BOT" : "BS");
  LOG_HANDLE (", Address: %" PRIuSIZE, obj->address);
  LOG_INFO ("\n");
  restartpos = bit_position (dat); // relative

  /* Check the type of the object
   */
  switch (obj->type)
    {
    case DWG_TYPE_TEXT:
      error = dwg_decode_TEXT (dat, obj);
      break;
    case DWG_TYPE_ATTRIB:
      error = dwg_decode_ATTRIB (dat, obj);
      break;
    case DWG_TYPE_ATTDEF:
      error = dwg_decode_ATTDEF (dat, obj);
      break;
    case DWG_TYPE_BLOCK:
      error = dwg_decode_BLOCK (dat, obj);
      break;
    case DWG_TYPE_ENDBLK:
      error = dwg_decode_ENDBLK (dat, obj);
      break;
    case DWG_TYPE_SEQEND:
      error = dwg_decode_SEQEND (dat, obj);
      if (dat->from_version >= R_13b1 && obj->tio.entity->ownerhandle)
        {
          Dwg_Object *restrict owner = dwg_resolve_handle (
              dwg, obj->tio.entity->ownerhandle->absolute_ref);
          if (!owner)
            {
              LOG_WARN ("no SEQEND.ownerhandle")
            }
          else if (owner->fixedtype == DWG_TYPE_INSERT
                   || owner->fixedtype == DWG_TYPE_MINSERT)
            {
              /* SEQEND handle for the owner needed in validate_INSERT */
              hash_set (dwg->object_map, obj->handle.value, (uint64_t)num);
              (void)dwg_validate_INSERT (owner);
            }
          else if (owner->fixedtype == DWG_TYPE_POLYLINE_2D
                   || owner->fixedtype == DWG_TYPE_POLYLINE_3D
                   || owner->fixedtype == DWG_TYPE_POLYLINE_PFACE
                   || owner->fixedtype == DWG_TYPE_POLYLINE_MESH)
            {
              Dwg_Entity_POLYLINE_2D *restrict _obj
                  = owner->tio.entity->tio.POLYLINE_2D;
              if (!_obj->seqend)
                /* SEQEND handle for the owner needed in validate_POLYLINE */
                hash_set (dwg->object_map, obj->handle.value, (uint64_t)num);
              (void)dwg_validate_POLYLINE (owner);
            }
        }
      break;
    case DWG_TYPE_INSERT:
      error = dwg_decode_INSERT (dat, obj);
      break;
    case DWG_TYPE_MINSERT:
      error = dwg_decode_MINSERT (dat, obj);
      break;
    case DWG_TYPE_VERTEX_2D:
      error = dwg_decode_VERTEX_2D (dat, obj);
      break;
    case DWG_TYPE_VERTEX_3D:
      error = dwg_decode_VERTEX_3D (dat, obj);
      break;
    case DWG_TYPE_VERTEX_MESH:
      error = dwg_decode_VERTEX_MESH (dat, obj);
      break;
    case DWG_TYPE_VERTEX_PFACE:
      error = dwg_decode_VERTEX_PFACE (dat, obj);
      break;
    case DWG_TYPE_VERTEX_PFACE_FACE:
      error = dwg_decode_VERTEX_PFACE_FACE (dat, obj);
      break;
    case DWG_TYPE_POLYLINE_2D:
      error = dwg_decode_POLYLINE_2D (dat, obj);
      if (dat->from_version >= R_2010 && error < DWG_ERR_CRITICAL)
        check_POLYLINE_handles (obj);
      break;
    case DWG_TYPE_POLYLINE_3D:
      error = dwg_decode_POLYLINE_3D (dat, obj);
      if (dat->from_version >= R_2010 && error < DWG_ERR_CRITICAL)
        check_POLYLINE_handles (obj);
      break;
    case DWG_TYPE_ARC:
      error = dwg_decode_ARC (dat, obj);
      break;
    case DWG_TYPE_CIRCLE:
      error = dwg_decode_CIRCLE (dat, obj);
      break;
    case DWG_TYPE_LINE:
      error = dwg_decode_LINE (dat, obj);
      break;
    case DWG_TYPE_DIMENSION_ORDINATE:
      error = dwg_decode_DIMENSION_ORDINATE (dat, obj);
      break;
    case DWG_TYPE_DIMENSION_LINEAR:
      error = dwg_decode_DIMENSION_LINEAR (dat, obj);
      break;
    case DWG_TYPE_DIMENSION_ALIGNED:
      error = dwg_decode_DIMENSION_ALIGNED (dat, obj);
      break;
    case DWG_TYPE_DIMENSION_ANG3PT:
      error = dwg_decode_DIMENSION_ANG3PT (dat, obj);
      break;
    case DWG_TYPE_DIMENSION_ANG2LN:
      error = dwg_decode_DIMENSION_ANG2LN (dat, obj);
      break;
    case DWG_TYPE_DIMENSION_RADIUS:
      error = dwg_decode_DIMENSION_RADIUS (dat, obj);
      break;
    case DWG_TYPE_DIMENSION_DIAMETER:
      error = dwg_decode_DIMENSION_DIAMETER (dat, obj);
      break;
    case DWG_TYPE_POINT:
      error = dwg_decode_POINT (dat, obj);
      break;
    case DWG_TYPE__3DFACE:
      error = dwg_decode__3DFACE (dat, obj);
      break;
    case DWG_TYPE_POLYLINE_PFACE:
      error = dwg_decode_POLYLINE_PFACE (dat, obj);
      if (dat->from_version >= R_2010 && error < DWG_ERR_CRITICAL)
        check_POLYLINE_handles (obj);
      break;
    case DWG_TYPE_POLYLINE_MESH:
      error = dwg_decode_POLYLINE_MESH (dat, obj);
      if (dat->from_version >= R_2010)
        check_POLYLINE_handles (obj);
      break;
    case DWG_TYPE_SOLID:
      error = dwg_decode_SOLID (dat, obj);
      break;
    case DWG_TYPE_TRACE:
      error = dwg_decode_TRACE (dat, obj);
      break;
    case DWG_TYPE_SHAPE:
      error = dwg_decode_SHAPE (dat, obj);
      break;
    case DWG_TYPE_VIEWPORT:
      error = dwg_decode_VIEWPORT (dat, obj);
      break;
    case DWG_TYPE_ELLIPSE:
      error = dwg_decode_ELLIPSE (dat, obj);
      break;
    case DWG_TYPE_SPLINE:
      error = dwg_decode_SPLINE (dat, obj);
      break;
    case DWG_TYPE_REGION:
      error = dwg_decode_REGION (dat, obj);
      break;
    case DWG_TYPE__3DSOLID:
      error = dwg_decode__3DSOLID (dat, obj);
      break;
    case DWG_TYPE_BODY:
      error = dwg_decode_BODY (dat, obj);
      break;
    case DWG_TYPE_RAY:
      error = dwg_decode_RAY (dat, obj);
      break;
    case DWG_TYPE_XLINE:
      error = dwg_decode_XLINE (dat, obj);
      break;
    case DWG_TYPE_DICTIONARY:
      error = dwg_decode_DICTIONARY (dat, obj);
      break;
    case DWG_TYPE_MTEXT:
      error = dwg_decode_MTEXT (dat, obj);
      break;
    case DWG_TYPE_LEADER:
      error = dwg_decode_LEADER (dat, obj);
      break;
    case DWG_TYPE_TOLERANCE:
      error = dwg_decode_TOLERANCE (dat, obj);
      break;
    case DWG_TYPE_MLINE:
      error = dwg_decode_MLINE (dat, obj);
      break;
    case DWG_TYPE_BLOCK_CONTROL:
      error = dwg_decode_BLOCK_CONTROL (dat, obj);
      if (!error && obj->tio.object->tio.BLOCK_CONTROL)
        {
          if (!dwg->block_control.parent) // only once
            dwg->block_control = *obj->tio.object->tio.BLOCK_CONTROL;
          else
            LOG_WARN ("Second BLOCK_CONTROL object ignored");
        }
      break;
    case DWG_TYPE_BLOCK_HEADER:
      error = dwg_decode_BLOCK_HEADER (dat, obj);
      /*
       * We cannot cache dwg->*space_block here as dwg->objects might get
       * realloc'ed. See dwg_model_space_object() and dwg_paper_space_object()
       * instead.
       */
      break;
    case DWG_TYPE_LAYER_CONTROL:
      error = dwg_decode_LAYER_CONTROL (dat, obj);
      break;
    case DWG_TYPE_LAYER:
      error = dwg_decode_LAYER (dat, obj);
      break;
    case DWG_TYPE_STYLE_CONTROL:
      error = dwg_decode_STYLE_CONTROL (dat, obj);
      break;
    case DWG_TYPE_STYLE:
      error = dwg_decode_STYLE (dat, obj);
      break;
    case DWG_TYPE_LTYPE_CONTROL:
      error = dwg_decode_LTYPE_CONTROL (dat, obj);
      break;
    case DWG_TYPE_LTYPE:
      error = dwg_decode_LTYPE (dat, obj);
      break;
    case DWG_TYPE_VIEW_CONTROL:
      error = dwg_decode_VIEW_CONTROL (dat, obj);
      break;
    case DWG_TYPE_VIEW:
      error = dwg_decode_VIEW (dat, obj);
      break;
    case DWG_TYPE_UCS_CONTROL:
      error = dwg_decode_UCS_CONTROL (dat, obj);
      break;
    case DWG_TYPE_UCS:
      error = dwg_decode_UCS (dat, obj);
      break;
    case DWG_TYPE_VPORT_CONTROL:
      error = dwg_decode_VPORT_CONTROL (dat, obj);
      break;
    case DWG_TYPE_VPORT:
      error = dwg_decode_VPORT (dat, obj);
      break;
    case DWG_TYPE_APPID_CONTROL:
      error = dwg_decode_APPID_CONTROL (dat, obj);
      break;
    case DWG_TYPE_APPID:
      error = dwg_decode_APPID (dat, obj);
      break;
    case DWG_TYPE_DIMSTYLE_CONTROL:
      error = dwg_decode_DIMSTYLE_CONTROL (dat, obj);
      break;
    case DWG_TYPE_DIMSTYLE:
      error = dwg_decode_DIMSTYLE (dat, obj);
      break;
    case DWG_TYPE_VX_CONTROL:
      error = dwg_decode_VX_CONTROL (dat, obj);
      break;
    case DWG_TYPE_VX_TABLE_RECORD:
      error = dwg_decode_VX_TABLE_RECORD (dat, obj);
      break;
    case DWG_TYPE_GROUP:
      error = dwg_decode_GROUP (dat, obj);
      break;
    case DWG_TYPE_MLINESTYLE:
      error = dwg_decode_MLINESTYLE (dat, obj);
      break;
    case DWG_TYPE_OLE2FRAME:
      error = dwg_decode_OLE2FRAME (dat, obj);
      break;
    case DWG_TYPE_DUMMY:
      error = dwg_decode_DUMMY (dat, obj);
      break;
    case DWG_TYPE_LONG_TRANSACTION:
      error = dwg_decode_LONG_TRANSACTION (dat, obj);
      break;
    case DWG_TYPE_LWPOLYLINE:
      error = dwg_decode_LWPOLYLINE (dat, obj);
      break;
    case DWG_TYPE_HATCH:
      error = dwg_decode_HATCH (dat, obj);
      break;
    case DWG_TYPE_XRECORD:
      error = dwg_decode_XRECORD (dat, obj);
      break;
    case DWG_TYPE_PLACEHOLDER:
      error = dwg_decode_PLACEHOLDER (dat, obj);
      break;
    case DWG_TYPE_OLEFRAME:
      error = dwg_decode_OLEFRAME (dat, obj);
      break;
    case DWG_TYPE_VBA_PROJECT:
      // LOG_ERROR ("Unhandled Object VBA_PROJECT. Has its own section");
      error = dwg_decode_VBA_PROJECT (dat, obj);
      // error = DWG_ERR_UNHANDLEDCLASS;
      break;
    case DWG_TYPE_LAYOUT:
      error = dwg_decode_LAYOUT (dat, obj);
      break;
    case DWG_TYPE_PROXY_ENTITY:
      error = dwg_decode_PROXY_ENTITY (dat, obj);
      break;
    case DWG_TYPE_PROXY_OBJECT:
      error = dwg_decode_PROXY_OBJECT (dat, obj);
      break;
    default:
      if (obj->type == dwg->layout_type)
        error = dwg_decode_LAYOUT (dat, obj);
      /* > 500 */
      else if ((error = dwg_decode_variable_type (dwg, dat, hdl_dat, obj))
               & DWG_ERR_UNHANDLEDCLASS)
        {
          int is_entity = 0;
          int i = obj->type - 500;
          Dwg_Class *klass = NULL;

          /* restart and read into the UNKNOWN_OBJ object */
          /* the relative offset from type after common_entity_data */
          // obj->common_size = bit_position(dat) - restartpos;
          // LOG_HANDLE("common_size: %" PRIuSIZE "\n", obj->common_size); //
          // needed for unknown
          bit_set_position (dat, restartpos);

          if (i >= 0 && i < (int)dwg->num_classes)
            {
              klass = &dwg->dwg_class[i];
              is_entity = dwg_class_is_entity (klass);
            }
          else
            {
              if (i < 0)
                LOG_ERROR ("Invalid class index %d < 0", i)
              else
                LOG_ERROR ("Invalid class index %d >= %d", i,
                           (int)dwg->num_classes)
              obj->type = 0;
              *dat = abs_dat;
              return error | DWG_ERR_VALUEOUTOFBOUNDS;
            }

          // properly dwg_decode_object/_entity for eed, reactors, xdic
          if (is_entity)
            {
              // obj->type = DWG_TYPE_UNKNOWN_ENT;
              error |= dwg_decode_UNKNOWN_ENT (dat, obj);
            }
          else
            {
              // obj->type = DWG_TYPE_UNKNOWN_OBJ;
              error |= dwg_decode_UNKNOWN_OBJ (dat, obj);
            }

          if (!dat)
            return error;
          if (error >= DWG_ERR_CRITICAL)
            *dat = abs_dat;
        }
    }

  if (obj->handle.value)
    { // empty only with UNKNOWN
      LOG_HANDLE (" object_map{" FORMAT_RLLx "} = %lu\n", obj->handle.value,
                  (unsigned long)num);
      hash_set (dwg->object_map, obj->handle.value, (uint64_t)num);
    }

  if (dat->byte > 8 * dat->size)
    {
      LOG_ERROR ("Invalid object address (overflow): %" PRIuSIZE
                 " > %" PRIuSIZE,
                 dat->byte, 8 * dat->size);
      *dat = abs_dat;
      return error | DWG_ERR_INVALIDDWG;
    }

  /* Restore the old absolute chain.
     CRC needs to be calculated from address, which is before our 0 position.
   */
  restartpos = bit_position (dat);
  *dat = abs_dat;
  bit_set_position (dat, objpos + restartpos);

  /* Now 1 padding bits until next byte, and then a RS CRC */
  if (dat->bit)
    {
      unsigned char r = 8 - dat->bit;
      LOG_HANDLE (" padding: %X/%X (%d bits)\n", dat->chain[dat->byte],
                  dat->chain[dat->byte] & ((1 << r) - 1), r);
      bit_advance_position (dat, r);
    }
  bit_set_position (dat, (obj->address + obj->size) * 8 - 2);
  if (!bit_check_CRC (dat, address, 0xC0C1))
    error |= DWG_ERR_WRONGCRC;

  /* Reset to previous addresses for return */
  *dat = abs_dat;

  return realloced ? -1 : error; // re-alloced or not
}

// the below code fragment can be found in:
// src/decode.c
int
dwg_fixup_BLOCKS_entities (Dwg_Data *restrict dwg)
{
  int changes = 0;
  int is_uni = 0;
  if (dwg->header.version > R_2000 || dwg->header.from_version <= R_2000)
    return 0;
  is_uni = dwg->header.version >= R_2007;
  loglevel = dwg->opts & DWG_OPTS_LOGLEVEL;
  LOG_TRACE ("\ndwg_fixup_BLOCKS_entities:\n");
  for (BITCODE_BL i = 0; i < dwg->num_objects; i++)
    {
      Dwg_Object *obj = &dwg->object[i];
      if (obj->fixedtype == DWG_TYPE_BLOCK_HEADER)
        {
          Dwg_Object_BLOCK_HEADER *_obj = obj->tio.object->tio.BLOCK_HEADER;
          char *_objname;
          if (!_obj)
            continue;
          _objname
              = is_uni ? bit_convert_TU ((BITCODE_TU)_obj->name) : _obj->name;
          LOG_TRACE ("BLOCK_HEADER %s: %u\n", _objname,
                     (unsigned)_obj->num_owned);
          if (!_obj->entities)
            {
              _obj->first_entity = dwg_add_handleref (dwg, 4, 0, NULL);
              _obj->last_entity = dwg_add_handleref (dwg, 4, 0, NULL);
              if (_obj->num_owned)
                LOG_ERROR ("BLOCK_HEADER %s: %u => 0 num_owned\n", _objname,
                           (unsigned)_obj->num_owned);
              _obj->num_owned = 0;
            }
          // link from first_entity to last_entity
          for (BITCODE_BL j = 0; j < _obj->num_owned; j++)
            {
              Dwg_Object_Ref *hdl = _obj->entities[j];
              Dwg_Object *o
                  = hdl ? dwg_ref_object (dwg, hdl) : NULL; // may fail!
              Dwg_Object_Entity *ent = o ? o->tio.entity : NULL;
              Dwg_Object_Ref *prev = j > 0 ? _obj->entities[j - 1] : NULL;
              Dwg_Object_Ref *next
                  = j + 1 < _obj->num_owned ? _obj->entities[j + 1] : NULL;
              BITCODE_RLL prev_ref = prev ? prev->absolute_ref : 0;
              BITCODE_RLL next_ref = next ? next->absolute_ref : 0;
              BITCODE_RLL cur_ref = hdl ? hdl->absolute_ref : 0;

              LOG_HANDLE ("entities[%u]: " FORMAT_REF " \n", j,
                          ARGS_REF (hdl));
              if (!o)
                continue;
              if (o->supertype != DWG_SUPERTYPE_ENTITY)
                {
                  LOG_ERROR ("Illegal BLOCK_HEADER %s.entities[%u] %s",
                             _objname, j, o->name);
                  changes++;
                  if (is_uni)
                    free (_objname);
                  continue;
                }
              // only log changes
              if (prev_ref == 0L && next_ref == 0L)
                {
                  if (!ent->nolinks)
                    {
                      LOG_TRACE ("nolinks: 1\n");
                      ent->nolinks = 1;
                      changes++;
                    }
                }
              else if (prev_ref && prev_ref == cur_ref - 1 && next_ref
                       && next_ref == cur_ref + 1)
                {
                  if (!ent->nolinks)
                    {
                      LOG_TRACE ("nolinks: 1\n");
                      ent->nolinks = 1;
                      changes++;
                    }
                }
              else if (prev_ref && next_ref && ent->nolinks)
                {
                  LOG_TRACE ("nolinks: 0\n");
                  ent->nolinks = 0;
                  changes++;
                }
              if (j == 0) // first: prev_entity must be NULL
                {
                  if (!_obj->first_entity)
                    {
                      LOG_TRACE ("first_entity: " FORMAT_RLLx "\n",
                                 hdl->absolute_ref);
                      _obj->first_entity
                          = dwg_add_handleref (dwg, 4, hdl->absolute_ref, o);
                    }
                  else if (_obj->first_entity->absolute_ref
                           != hdl->absolute_ref)
                    {
                      LOG_WARN ("Fixup wrong BLOCK_HEADER %s.first_entity "
                                "from " FORMAT_RLLx " to " FORMAT_RLLx,
                                _objname, _obj->first_entity->absolute_ref,
                                hdl->absolute_ref);
                      changes++;
                      _obj->first_entity
                          = dwg_add_handleref (dwg, 4, hdl->absolute_ref, o);
                    }
                }
              if (ent->prev_entity == NULL)
                {
                  if (!prev_ref)
                    {
                      LOG_TRACE ("nolinks: 0\n");
                      ent->nolinks = 0;
                    }
                  LOG_TRACE (" " FORMAT_RLLx ": prev_entity " FORMAT_RLLx ", ",
                             hdl->absolute_ref, prev_ref);
                  ent->prev_entity = dwg_add_handleref (dwg, 4, prev_ref, o);
                }
              else if (ent->prev_entity->absolute_ref != prev_ref)
                {
                  LOG_WARN ("Fixup wrong BLOCK_HEADER "
                            "%s.entities[%d].prev_entity from " FORMAT_RLLx
                            " to " FORMAT_RLLx,
                            _objname, j, ent->prev_entity->absolute_ref,
                            prev_ref);
                  changes++;
                  ent->prev_entity = dwg_add_handleref (dwg, 4, prev_ref, o);
                }
              if (ent->next_entity == NULL)
                {
                  LOG_TRACE (" next_entity " FORMAT_RLLx "\n", next_ref);
                  ent->next_entity = dwg_add_handleref (dwg, 4, next_ref, o);
                  if (!next_ref)
                    {
                      LOG_TRACE ("    nolinks: 0\n");
                      ent->nolinks = 0;
                    }
                }
              else if (ent->next_entity->absolute_ref != next_ref)
                {
                  LOG_WARN ("Fixup wrong BLOCK_HEADER "
                            "%s.entities[%d].next_entity from " FORMAT_RLLx
                            " to " FORMAT_RLLx,
                            _objname, j, ent->next_entity->absolute_ref,
                            next_ref);
                  changes++;
                  ent->next_entity = dwg_add_handleref (dwg, 4, next_ref, o);
                }
              if (j == _obj->num_owned - 1) // last: next_entity must be NULL
                {
                  if (!_obj->last_entity)
                    {
                      LOG_TRACE ("last_entity: " FORMAT_RLLx "\n",
                                 hdl->absolute_ref);
                      _obj->last_entity
                          = dwg_add_handleref (dwg, 4, hdl->absolute_ref, o);
                    }
                  else if (_obj->last_entity->absolute_ref
                           != hdl->absolute_ref)
                    {
                      LOG_WARN ("Fixup wrong BLOCK_HEADER %s.last_entity "
                                "from " FORMAT_RLLx " to " FORMAT_RLLx,
                                _objname, _obj->last_entity->absolute_ref,
                                hdl->absolute_ref);
                      changes++;
                      _obj->last_entity
                          = dwg_add_handleref (dwg, 4, hdl->absolute_ref, o);
                    }
                }
            }
          if (is_uni)
            free (_objname);
        }
    }
  LOG_TRACE ("\n");
  return changes;
}

// the below code fragment can be found in:
// src/decode_r11.c
static int
decode_preR13_section (Dwg_Section_Type_r11 id, Bit_Chain *restrict dat,
                       Dwg_Data *restrict dwg)
{
  Dwg_Section *tbl = &dwg->header.section[id];
  Bit_Chain *hdl_dat = dat;
  Dwg_Object *obj;
  int error = 0;
  BITCODE_RLd i;
  BITCODE_RL vcount;
  BITCODE_RL num = dwg->num_objects;
  size_t pos = tbl->address;
  size_t oldpos;
  size_t real_start = pos;
  BITCODE_TF name;
  BITCODE_RSd used = -1;
  BITCODE_RC flag;

  LOG_TRACE ("\ncontents table %-8s [%2d]: size:%-4u num:%-3ld (" FORMAT_RLL
             "-" FORMAT_RLL ")\n\n",
             tbl->name, id, tbl->size, (long)tbl->number, tbl->address,
             tbl->address + (tbl->number * tbl->size))

  // with sentinel in case of R11
  SINCE (R_11)
  {
    real_start -= 16; // the sentinel size
  }

  // report unknown data before table
  if (tbl->address && dat->byte != real_start)
    {
      LOG_WARN ("\n@0x%zx => start 0x%zx", dat->byte, real_start);
      if (dat->byte < real_start)
        {
          UNKNOWN_UNTIL (real_start);
        }
    }

  SINCE (R_11)
  {
#define DECODE_PRER13_SENTINEL(ID)                                            \
  error |= decode_preR13_sentinel (ID, #ID, dat, dwg);                        \
  if (error >= DWG_ERR_SECTIONNOTFOUND)                                       \
  return error

    switch (id)
      {
#define CASE_SENTINEL_BEGIN(id)                                               \
  case SECTION_##id:                                                          \
    DECODE_PRER13_SENTINEL (DWG_SENTINEL_R11_##id##_BEGIN);                   \
    break

        CASE_SENTINEL_BEGIN (BLOCK);
        CASE_SENTINEL_BEGIN (LAYER);
        CASE_SENTINEL_BEGIN (STYLE);
        CASE_SENTINEL_BEGIN (LTYPE);
        CASE_SENTINEL_BEGIN (VIEW);
        CASE_SENTINEL_BEGIN (UCS);
        CASE_SENTINEL_BEGIN (VPORT);
        CASE_SENTINEL_BEGIN (APPID);
        CASE_SENTINEL_BEGIN (DIMSTYLE);
        CASE_SENTINEL_BEGIN (VX);
#undef CASE_SENTINEL_BEGIN

      default:
        LOG_ERROR ("Internal error: Invalid section id %d", (int)id);
        return DWG_ERR_INTERNALERROR;
      }
  }

  oldpos = dat->byte;
  if (tbl->address)
    dat->byte = tbl->address;
  dat->bit = 0;
  if ((size_t)(tbl->number * tbl->size) > dat->size - dat->byte)
    {
      LOG_ERROR ("Overlarge table num_entries %ld or size %ld for %-8s [%2d]",
                 (long)tbl->number, (long)tbl->size, tbl->name, id);
      dat->byte = oldpos;
      return DWG_ERR_INVALIDDWG;
    }
  tbl->objid_r11 = num;
  if (dwg->num_alloced_objects < dwg->num_objects + tbl->number)
    {
      dwg->num_alloced_objects = dwg->num_objects + tbl->number;
      if (dwg->num_alloced_objects > dwg->num_objects + MAX_NUM)
        {
          LOG_ERROR ("Invalid num_alloced_objects " FORMAT_BL,
                     dwg->num_alloced_objects);
          return DWG_ERR_INVALIDDWG;
        }
      dwg->object = (Dwg_Object *)realloc (
          dwg->object, dwg->num_alloced_objects * sizeof (Dwg_Object));
      dwg->dirty_refs = 1;
    }

#define SET_CONTROL(token)                                                    \
  Dwg_Object *ctrl;                                                           \
  Dwg_Object_##token##_CONTROL *_ctrl = NULL;                                 \
  ctrl = dwg_get_first_object (dwg, DWG_TYPE_##token##_CONTROL);              \
  if (ctrl)                                                                   \
    {                                                                         \
      _ctrl = ctrl->tio.object->tio.token##_CONTROL;                          \
      ctrl->size = tbl->size;                                                 \
      if (tbl->number > _ctrl->num_entries)                                   \
        {                                                                     \
          if (_ctrl->entries)                                                 \
            {                                                                 \
              _ctrl->entries = (BITCODE_H *)realloc (                         \
                  _ctrl->entries, tbl->number * sizeof (BITCODE_H));          \
              memset (&_ctrl->entries[_ctrl->num_entries], 0,                 \
                      (tbl->number - _ctrl->num_entries)                      \
                          * sizeof (BITCODE_H));                              \
            }                                                                 \
          else                                                                \
            _ctrl->entries                                                    \
                = (BITCODE_H *)calloc (tbl->number, sizeof (BITCODE_H));      \
          _ctrl->num_entries = tbl->number;                                   \
          LOG_TRACE (#token "_CONTROL.num_entries = %u\n", tbl->number);      \
        }                                                                     \
    }

#define NEW_OBJECT                                                            \
  dwg_add_object (dwg);                                                       \
  if (dat->byte > dat->size)                                                  \
    return DWG_ERR_INVALIDDWG;                                                \
  obj = &dwg->object[num++];                                                  \
  obj->address = dat->byte;                                                   \
  obj->size = tbl->size;

#define ADD_CTRL_ENTRY                                                        \
  if (_ctrl)                                                                  \
    {                                                                         \
      BITCODE_H ref;                                                          \
      if (!obj->handle.value)                                                 \
        obj->handle.value = obj->index;                                       \
      ref = _ctrl->entries[i]                                                 \
          = dwg_add_handleref (dwg, 2, obj->handle.value, obj);               \
      ref->r11_idx = i;                                                       \
      LOG_TRACE ("%s.entries[%u] = " FORMAT_REF " [H 0]\n", ctrl->name, i,    \
                 ARGS_REF (ref));                                             \
    }                                                                         \
  else                                                                        \
    return error | DWG_ERR_INVALIDDWG

#define CHK_ENDPOS                                                            \
  SINCE (R_11)                                                                \
  {                                                                           \
    if (!bit_check_CRC (dat, obj->address, 0xC0C1))                           \
      error |= DWG_ERR_WRONGCRC;                                              \
  }                                                                           \
  pos = tbl->address + (long)((i + 1) * tbl->size);                           \
  if (pos != dat->byte)                                                       \
    {                                                                         \
      LOG_ERROR ("offset %ld", (long)(pos - dat->byte));                      \
      if (pos > dat->byte)                                                    \
        {                                                                     \
          BITCODE_RL offset = (BITCODE_RL)(pos - dat->byte);                  \
          obj->num_unknown_rest = 8 * offset;                                 \
          obj->unknown_rest = (BITCODE_TF)calloc (offset + 1, 1);             \
          if (obj->unknown_rest)                                              \
            {                                                                 \
              memcpy (obj->unknown_rest, &dat->chain[dat->byte], offset);     \
              LOG_TRACE_TF (obj->unknown_rest, offset);                       \
            }                                                                 \
          else                                                                \
            {                                                                 \
              LOG_ERROR ("Out of memory");                                    \
              obj->num_unknown_rest = 0;                                      \
            }                                                                 \
        }                                                                     \
      /* In the table header the size OR number can be wrong. */              \
      /* Here we catch the wrong number. */                                   \
      if (tbl->number > 0 && tbl->size < 33)                                  \
        return DWG_ERR_SECTIONNOTFOUND;                                       \
    }

