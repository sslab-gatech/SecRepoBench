static int blosc_d(
    struct thread_context* thread_context, int32_t bsize,
    int32_t leftoverblock, const uint8_t* src, int32_t srcsize, int32_t src_offset,
    uint8_t* dest, int32_t dest_offset, uint8_t* tmp, uint8_t* tmp2) {
  blosc2_context* context = thread_context->parent_context;
  uint8_t* filters = context->filters;
  uint8_t *tmp3 = thread_context->tmp4;
  int32_t compformat = (context->header_flags & 0xe0) >> 5;
  // Initialize variables and check if the block should be decompressed
  // by assessing context flags and the block maskout array. If the block
  // should not be decompressed, return the block size as the decompressed size.
  // Adjust the source pointer by the given source offset, and determine if
  // filters are to be applied, setting the appropriate destination buffer.
  // Determine the number of data streams for the block based on context flags
  // and the presence of leftover blocks or dictionary use.
  // For each stream, read and interpret the compressed byte size and proceed
  // to decompress the data using the appropriate decompression algorithm
  // based on the compression format. Handle special cases for runs
  // (indicating repeated values) and errors such as unsupported formats
  // or mismatch in expected decompressed size. Accumulate decompressed
  // data size and update pointers for subsequent streams.
  // <MASK>
 /* Closes j < nstreams */

  if (last_filter_index >= 0) {
    int errcode = pipeline_d(context, bsize, dest, dest_offset, tmp, tmp2, tmp3,
                             last_filter_index);
    if (errcode < 0)
      return errcode;
  }

  /* Return the number of uncompressed bytes */
  return (int)ntbytes;
}