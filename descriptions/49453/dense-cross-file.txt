// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// mrbgems/mruby-bigint/core/bigint.c
static int
uzero(mpz_t *x)
{
  for (size_t i=0; i < x->sz; i++)
    if (x->p[i] != 0)
      return 0;
  return 1;
}

// the below code fragment can be found in:
// mrbgems/mruby-bigint/core/bigint.c
static mrb_int
mpz_cmp(mrb_state *mrb, mpz_t *x, mpz_t *y)
{
  int abscmp;
  if (x->sn < 0 && y->sn > 0)
    return (-1);
  if (x->sn > 0 && y->sn < 0)
    return 1;
  abscmp=ucmp(x, y);
  if (x->sn >=0 && y->sn >=0)
    return abscmp;
  return (-abscmp);          // if (x->sn <=0 && y->sn <=0)
}

// the below code fragment can be found in:
// mrbgems/mruby-bigint/core/bigint.c
static int
mpz_get_int(mpz_t *y, mrb_int *v)
{
  if (uzero(y)) {
    *v = 0;
    return TRUE;
  }

  mp_limb2 i = 0;
  mp_limb *d = y->p + y->sz;

  while (d-- > y->p) {
    if (HIGH(i) != 0) {
      /* will overflow */
      return FALSE;
    }
    i = (i << DIG_SIZE) | *d;
  }
  if (i > MRB_INT_MAX) {
    /* overflow */
    return FALSE;
  }
  if (y->sn < 0) {
    *v = -(mrb_int)i;
  }
  else {
    *v = (mrb_int)i;
  }
  return TRUE;
}

// the below code fragment can be found in:
// mrbgems/mruby-bigint/core/bigint.c
static void
mpz_sub(mrb_state *mrb, mpz_t *z, mpz_t *x, mpz_t *y)
{
  mpz_t u;

  mpz_init(mrb, &u);
  mpz_set(mrb, &u, y);
  u.sn = -(u.sn);
  mpz_add(mrb, z, x, &u);
  mpz_clear(mrb, &u);
}

// the below code fragment can be found in:
// mrbgems/mruby-bigint/core/bigint.c
static int
lzb(mp_limb x)
{
#if (defined(__GNUC__) || __has_builtin(__builtin_clz))
  if (sizeof(mp_limb) == sizeof(int64_t))
    return __builtin_clzll(x);
  else if (sizeof(mp_limb) == sizeof(int32_t))
    return __builtin_clz(x);
#endif

  int j=0;

  for (mp_limb i = ((mp_limb)1 << (DIG_SIZE-1)); i && !(x&i) ; j++,i>>=1)
    ;
  return j;
}

