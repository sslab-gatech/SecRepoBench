// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// libavcodec/encode.c
// int attribute_align_arg avcodec_encode_video2(AVCodecContext *avctx,
//                                               AVPacket *avpkt,
//                                               const AVFrame *frame,
//                                               int *got_packet_ptr)
// {
//     int ret;
//     AVPacket user_pkt = *avpkt;
//     int needs_realloc = !user_pkt.data;
// 
//     *got_packet_ptr = 0;
// 
//     if (!avctx->codec->encode2) {
//         av_log(avctx, AV_LOG_ERROR, "This encoder requires using the avcodec_send_frame() API.\n");
//         return AVERROR(ENOSYS);
//     }
// 
//     if(CONFIG_FRAME_THREAD_ENCODER &&
//        avctx->internal->frame_thread_encoder && (avctx->active_thread_type&FF_THREAD_FRAME))
//         return ff_thread_video_encode_frame(avctx, avpkt, frame, got_packet_ptr);
// 
//     if ((avctx->flags&AV_CODEC_FLAG_PASS1) && avctx->stats_out)
//         avctx->stats_out[0] = '\0';
// 
//     if (!(avctx->codec->capabilities & AV_CODEC_CAP_DELAY) && !frame) {
//         av_packet_unref(avpkt);
//         return 0;
//     }
// 
//     if (av_image_check_size2(avctx->width, avctx->height, avctx->max_pixels, AV_PIX_FMT_NONE, 0, avctx))
//         return AVERROR(EINVAL);
// 
//     if (frame && frame->format == AV_PIX_FMT_NONE)
//         av_log(avctx, AV_LOG_WARNING, "AVFrame.format is not set\n");
//     if (frame && (frame->width == 0 || frame->height == 0))
//         av_log(avctx, AV_LOG_WARNING, "AVFrame.width or height is not set\n");
// 
//     av_assert0(avctx->codec->encode2);
// 
//     ret = avctx->codec->encode2(avctx, avpkt, frame, got_packet_ptr);
//     av_assert0(ret <= 0);
// 
//     emms_c();
// 
//     if (avpkt->data && avpkt->data == avctx->internal->byte_buffer) {
//         needs_realloc = 0;
//         if (user_pkt.data) {
//             if (user_pkt.size >= avpkt->size) {
//                 memcpy(user_pkt.data, avpkt->data, avpkt->size);
//             } else {
//                 av_log(avctx, AV_LOG_ERROR, "Provided packet is too small, needs to be %d\n", avpkt->size);
//                 avpkt->size = user_pkt.size;
//                 ret = -1;
//             }
//             avpkt->buf      = user_pkt.buf;
//             avpkt->data     = user_pkt.data;
//         } else if (!avpkt->buf) {
//             ret = av_packet_make_refcounted(avpkt);
//             if (ret < 0)
//                 return ret;
//         }
//     }
// 
//     if (!ret) {
//         if (!*got_packet_ptr)
//             avpkt->size = 0;
//         else if (!(avctx->codec->capabilities & AV_CODEC_CAP_DELAY))
//             avpkt->pts = avpkt->dts = frame->pts;
// 
//         if (needs_realloc && avpkt->data) {
//             ret = av_buffer_realloc(&avpkt->buf, avpkt->size + AV_INPUT_BUFFER_PADDING_SIZE);
//             if (ret >= 0)
//                 avpkt->data = avpkt->buf->data;
//         }
// 
//         if (frame)
//             avctx->frame_number++;
//     }
// 
//     if (ret < 0 || !*got_packet_ptr)
//         av_packet_unref(avpkt);
// 
//     return ret;
// }

// the below code fragment can be found in:
// libavcodec/frame_thread_encoder.c
// void ff_frame_thread_encoder_free(AVCodecContext *avctx){
//     int i;
//     ThreadContext *c= avctx->internal->frame_thread_encoder;
// 
//     pthread_mutex_lock(&c->task_fifo_mutex);
//     atomic_store(&c->exit, 1);
//     pthread_cond_broadcast(&c->task_fifo_cond);
//     pthread_mutex_unlock(&c->task_fifo_mutex);
// 
//     for (i=0; i<avctx->thread_count; i++) {
//          pthread_join(c->worker[i], NULL);
//     }
// 
//     while (av_fifo_size(c->task_fifo) > 0) {
//         Task task;
//         AVFrame *frame;
//         av_fifo_generic_read(c->task_fifo, &task, sizeof(task), NULL);
//         frame = task.indata;
//         av_frame_free(&frame);
//         task.indata = NULL;
//     }
// 
//     for (i=0; i<BUFFER_SIZE; i++) {
//         if (c->finished_tasks[i].outdata != NULL) {
//             AVPacket *pkt = c->finished_tasks[i].outdata;
//             av_packet_free(&pkt);
//             c->finished_tasks[i].outdata = NULL;
//         }
//     }
// 
//     pthread_mutex_destroy(&c->task_fifo_mutex);
//     pthread_mutex_destroy(&c->finished_task_mutex);
//     pthread_mutex_destroy(&c->buffer_mutex);
//     pthread_cond_destroy(&c->task_fifo_cond);
//     pthread_cond_destroy(&c->finished_task_cond);
//     av_fifo_freep(&c->task_fifo);
//     av_freep(&avctx->internal->frame_thread_encoder);
// }

// the below code fragment can be found in:
// libavcodec/decode.c
// static int decode_simple_receive_frame(AVCodecContext *avctx, AVFrame *frame)
// {
//     int ret;
// 
//     while (!frame->buf[0]) {
//         ret = decode_simple_internal(avctx, frame);
//         if (ret < 0)
//             return ret;
//     }
// 
//     return 0;
// }

// the below code fragment can be found in:
// libavcodec/encode.c
// int avcodec_encode_subtitle(AVCodecContext *avctx, uint8_t *buf, int buf_size,
//                             const AVSubtitle *sub)
// {
//     int ret;
//     if (sub->start_display_time) {
//         av_log(avctx, AV_LOG_ERROR, "start_display_time must be 0.\n");
//         return -1;
//     }
// 
//     ret = avctx->codec->encode_sub(avctx, buf, buf_size, sub);
//     avctx->frame_number++;
//     return ret;
// }

// the below code fragment can be found in:
// libavcodec/utils.c
// const char *avcodec_get_name(enum AVCodecID id)
// {
//     const AVCodecDescriptor *cd;
//     AVCodec *codec;
// 
//     if (id == AV_CODEC_ID_NONE)
//         return "none";
//     cd = avcodec_descriptor_get(id);
//     if (cd)
//         return cd->name;
//     av_log(NULL, AV_LOG_WARNING, "Codec 0x%x is not in the full list.\n", id);
//     codec = avcodec_find_decoder(id);
//     if (codec)
//         return codec->name;
//     codec = avcodec_find_encoder(id);
//     if (codec)
//         return codec->name;
//     return "unknown_codec";
// }

