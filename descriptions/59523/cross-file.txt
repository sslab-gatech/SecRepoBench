// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/dynapi.c
EXPORT bool
dwg_dynapi_header_set_value (Dwg_Data *restrict dwg,
                             const char *restrict fieldname,
                             const void *restrict value, const bool is_utf8)
{
#ifndef HAVE_NONNULL
  if (!dwg || !fieldname || !value) // cannot set NULL value
    return false;
#endif
  {
    Dwg_DYNAPI_field *f = (Dwg_DYNAPI_field *)bsearch (
        fieldname, _dwg_header_variables_fields,
        ARRAY_SIZE (_dwg_header_variables_fields) - 1, /* NULL terminated */
        sizeof (_dwg_header_variables_fields[0]), _name_struct_cmp);
    if (f)
      {
        void *old;
        // there are no malloc'd fields in the HEADER, so no need to free().
        const Dwg_Header_Variables *const _obj = &dwg->header_vars;
        // but there are several fixed-length malloced strings preR13
        static const Dwg_DYNAPI_field r11_fixed_strings[] = {
          { "MENU", "TFv", 16, OFF (struct _dwg_header_variables, MENU), 1,1,1, 1 },
          { "DIMBLK_T", "TFv", 33, OFF (struct _dwg_header_variables, DIMBLK_T), 1,1,1, 1 },
          { "DIMBLK1_T", "TFv", 33, OFF (struct _dwg_header_variables, DIMBLK1_T), 1,1,1, 1 },
          { "DIMBLK2_T", "TFv", 33, OFF (struct _dwg_header_variables, DIMBLK2_T), 1,1,1, 1 },
          { "DIMPOST", "TFv", 16, OFF (struct _dwg_header_variables, DIMPOST), 1,1,1, 1 },
          { "DIMAPOST", "TFv", 16, OFF (struct _dwg_header_variables, DIMAPOST), 1,1,1, 1 },
          { "unknown_string", "TFv", 33, OFF (struct _dwg_header_variables, unknown_string), 1,1,1, 1 },
          { "unit1_name", "TFv", 32, OFF (struct _dwg_header_variables, unit1_name), 1,1,1, 1 },
          { "unit2_name", "TFv", 32, OFF (struct _dwg_header_variables, unit2_name), 1,1,1, 1 },
          { "unit3_name", "TFv", 32, OFF (struct _dwg_header_variables, unit3_name), 1,1,1, 1 },
          { "unit4_name", "TFv", 32, OFF (struct _dwg_header_variables, unit4_name), 1,1,1, 1 },
          { 0 }
        };
        if (f->is_string && dwg->header.from_version < R_13b1)
          {
            //find_name (fieldname, r11_fixed_strings))
            for (Dwg_DYNAPI_field* f11 = (Dwg_DYNAPI_field*)&r11_fixed_strings[0]; f11->name; f11++)
              {
                if (strEQ (fieldname, f11->name))
                  {
                    f = f11;
                    break;
                  }
              }
          }
        old = &((char*)_obj)[f->offset];
        dynapi_set_helper (old, f, dwg->header.version, value, is_utf8);

        // Set also FLAGS
        if (strEQc (fieldname, "CELWEIGHT"))
          {
            dwg->header_vars.FLAGS &= ~0x1f; // delete old, and set new
            dwg->header_vars.FLAGS |= dxf_revcvt_lweight (dwg->header_vars.CELWEIGHT);
          }
        else if (strEQc (fieldname, "codepage"))
          {
            dwg->header.codepage = *(BITCODE_RS*)value;
          }
#define SET_HDR_FLAGS(name, bit, inverse)          \
        else if (strEQc (fieldname, #name))        \
          {                                        \
            if (dwg->header_vars.name && !inverse) \
              dwg->header_vars.FLAGS |= bit;       \
            else                                   \
              dwg->header_vars.FLAGS &= ~bit;      \
          }
        SET_HDR_FLAGS (ENDCAPS, 0x60, 0)
        SET_HDR_FLAGS (JOINSTYLE, 0x180, 0)
        SET_HDR_FLAGS (LWDISPLAY, 0x200, 1)
        SET_HDR_FLAGS (XEDIT, 0x400, 1)
        SET_HDR_FLAGS (EXTNAMES, 0x800, 0)
        SET_HDR_FLAGS (PSTYLEMODE, 0x2000, 0)
        SET_HDR_FLAGS (OLESTARTUP, 0x4000, 0)

        return true;
      }
    else
      {
        const int loglevel = dwg->opts & DWG_OPTS_LOGLEVEL;
        LOG_ERROR ("%s: Invalid header field %s", __FUNCTION__, fieldname);
        return false;
      }
  }
}

// the below code fragment can be found in:
// src/dynapi.c
EXPORT bool
dwg_dynapi_common_set_value (void *restrict _obj,
                             const char *restrict fieldname,
                             const void *restrict value, const bool is_utf8)
{
#ifndef HAVE_NONNULL
  if (!_obj || !fieldname || !value)
    return false;
#endif
  {
    Dwg_DYNAPI_field *f;
    int error;
    void *old;
    const Dwg_Object *obj = dwg_obj_generic_to_object (_obj, &error);
    Dwg_Data *dwg;
    if (!obj || error)
      {
        const int loglevel = DWG_LOGLEVEL_ERROR;
        LOG_ERROR ("%s: dwg_obj_generic_to_object failed", __FUNCTION__);
        return false;
      }
    dwg = obj->parent;
    if (obj->supertype == DWG_SUPERTYPE_ENTITY)
      {
        _obj = obj->tio.entity;
        f = (Dwg_DYNAPI_field *)bsearch (
            fieldname, _dwg_object_entity_fields,
            ARRAY_SIZE (_dwg_object_entity_fields) - 1, /* NULL terminated */
            sizeof (_dwg_object_entity_fields[0]), _name_struct_cmp);
      }
    else if (obj->supertype == DWG_SUPERTYPE_OBJECT)
      {
        _obj = obj->tio.object;
        f = (Dwg_DYNAPI_field *)bsearch (
            fieldname, _dwg_object_object_fields,
            ARRAY_SIZE (_dwg_object_object_fields) - 1, /* NULL terminated */
            sizeof (_dwg_object_object_fields[0]), _name_struct_cmp);
      }
    else
      {
        const int loglevel = DWG_LOGLEVEL_ERROR;
        LOG_ERROR ("%s: Unhandled %s.supertype ", __FUNCTION__, obj->name);
        return false;
      }

    if (!f)
      {
        const int loglevel = obj->parent->opts & DWG_OPTS_LOGLEVEL;
        LOG_ERROR ("%s: Invalid %s common field %s", __FUNCTION__, obj->name, fieldname);
        return false;
      }

    old = &((char*)_obj)[f->offset];
    if (f->dxf == 160 && strEQc (fieldname, "preview_size"))
      {
        int size = f->size;
        if (dwg && dwg->header.version < R_2010)
          size = 4;
        memcpy (old, value, size);
      }
    else
      dynapi_set_helper (old, f, dwg ? dwg->header.version : R_INVALID, value, is_utf8);

    if (dwg && obj->supertype == DWG_SUPERTYPE_ENTITY && strEQc (fieldname, "ltype"))
      { // set also isbylayerlt and ltype_flags
        BITCODE_H ltype = *(BITCODE_H*)value;
        Dwg_Object_Entity *ent = obj->tio.entity;
        if (!dwg->header_vars.LTYPE_BYLAYER || !ent->ltype)
          ;
        else if (ent->ltype->absolute_ref == dwg->header_vars.LTYPE_BYLAYER->absolute_ref)
          {
            ent->isbylayerlt = 1; // r13-r14 only
            ent->ltype_flags = 0;
          }
        else if (dwg->header_vars.LTYPE_BYBLOCK
                 && ent->ltype->absolute_ref == dwg->header_vars.LTYPE_BYBLOCK->absolute_ref)
          {
            ent->isbylayerlt = 0;
            ent->ltype_flags = 1;
          }
        else if (dwg->header_vars.LTYPE_CONTINUOUS
                 && ent->ltype->absolute_ref == dwg->header_vars.LTYPE_CONTINUOUS->absolute_ref)
          {
            ent->isbylayerlt = 0;
            ent->ltype_flags = 2;
          }
        else
          {
            ent->isbylayerlt = 0;
            ent->ltype_flags = 3;
          }
      }
    return true;
  }
}

// the below code fragment can be found in:
// src/dynapi.c
EXPORT bool
dwg_dynapi_subclass_value (const void *restrict ptr,
                           const char *restrict subclass,
                           const char *restrict fieldname,
                           void *restrict out, Dwg_DYNAPI_field *restrict fp)
{
  const Dwg_DYNAPI_field *f;
#ifndef HAVE_NONNULL
  if (!ptr || !subclass || !fieldname || !out)
    return false;
#endif
  f = dwg_dynapi_subclass_field (subclass, fieldname);
  if (!f) // TODO maybe search via dwg_dynapi_subclass_name ()
    return false;
  memcpy (out, &((char*)ptr)[f->offset], f->size);
  if (fp)
    memcpy (fp, f, sizeof(Dwg_DYNAPI_field));
  return true;
}

// the below code fragment can be found in:
// src/in_json.c
JSON_TOKENS_CHECK_OVERFLOW_ERR
          dwg_dynapi_field_set_value (dwg, _obj, f, &pt, 1);
        }
      else if (t->type == JSMN_ARRAY
               && (strEQc (f->type, "2BD") || strEQc (f->type, "2RD")
                   || strEQc (f->type, "2DPOINT")
                   || strEQc (f->type, "2BD_1")))
        {
          BITCODE_2DPOINT pt;
          json_2DPOINT (dat, tokens, name, key, f->type, &pt);
          JSON_TOKENS_CHECK_OVERFLOW_ERR
          dwg_dynapi_field_set_value (dwg, _obj, f, &pt, 1);
        }
      else if (strEQc (f->type, "TIMEBLL") || strEQc (f->type, "TIMERLL"))
        {
          static BITCODE_TIMEBLL date = { 0, 0, 0 };
          json_TIMEBLL (dat, tokens, key, &date);
          JSON_TOKENS_CHECK_OVERFLOW_ERR
          dwg_dynapi_field_set_value (dwg, _obj, f, &date, 1);
        }
      else if (strEQc (f->type, "CMC"))
        {
          BITCODE_CMC color = { 0, 0, 0, 0, 0, NULL, NULL, NULL, 0, 0, 0 };
          json_CMC (dat, dwg, tokens, name, key, &color);
          JSON_TOKENS_CHECK_OVERFLOW_ERR
          dwg_dynapi_field_set_value (dwg, _obj, f, &color, 1);
        }
      else if (t->type == JSMN_ARRAY && strEQc (f->type, "H"))
        {
          BITCODE_H hdl;
          hdl = json_HANDLE (dat, dwg, tokens, name, key, obj, -1);
          JSON_TOKENS_CHECK_OVERFLOW_ERR
          if (hdl)
            dwg_dynapi_field_set_value (dwg, _obj, f, &hdl, 1);
        }
      else if (t->type == JSMN_ARRAY && strEQc (f->type, "H*"))
        {
          BITCODE_BL size1 = t->size;
          BITCODE_H *hdls;
          if (memBEGINc (name, "DICTIONARY") && strEQc (key, "itemhandles"))
            {
              LOG_ERROR ("Illegal old json format");
              return DWG_ERR_INVALIDDWG;
            }
          hdls
              = size1 ? (BITCODE_H *)calloc (size1, sizeof (BITCODE_H)) : NULL;
          json_set_numfield (_obj, fields, key, (long)size1);
          tokens->index++;
          for (int k = 0; k < t->size; k++)
            {
              BITCODE_H hdl;
              JSON_TOKENS_CHECK_OVERFLOW_ERR
              hdl = json_HANDLE (dat, dwg, tokens, name, key, obj, k);
              if (k < (int)size1)
                {
                  if (hdl)
                    hdls[k] = hdl;
                  else
                    hdls[k] = dwg_add_handleref (dwg, 0, 0, NULL);
                }
              else
                LOG_WARN ("ignored");
            }
          if (!size1)
            LOG_TRACE ("%s.%s: [%s] empty\n", name, key, f->type);
          // memcpy (&((char *)_obj)[f->offset], &hdls, sizeof (hdls));
          dwg_dynapi_field_set_value (dwg, _obj, f, &hdls, 1);
        }
      else if (t->type == JSMN_ARRAY
               && (strEQc (f->type, "T*") || strEQc (f->type, "TV*")))
        {
          int skip = 0;
          BITCODE_BL size1 = t->size;
          BITCODE_T *elems;
          if (memBEGINc (name, "DICTIONARY") && strEQc (key, "texts"))
            {
              LOG_ERROR ("Illegal old json format");
              return DWG_ERR_INVALIDDWG;
            }
          elems
              = size1 ? (BITCODE_T *)calloc (size1, sizeof (BITCODE_T)) : NULL;
          json_set_numfield (_obj, fields, key, (long)size1);
          tokens->index++;
          for (int k = 0; k < t->size; k++)
            {
              JSON_TOKENS_CHECK_OVERFLOW_ERR
              if (k < (int)size1)
                {
                  elems[k] = json_string (dat, tokens);
                  LOG_TRACE ("%s.%s[%d]: \"%s\" [%s]\n", name, key, k,
                             elems[k], f->type);
                }
              else
                {
                  tokens->index++;
                  t = &tokens->tokens[tokens->index];
                  LOG_WARN ("%s.%s[%d]: \"%.*s\" [%s] ignored", name, key, k,
                            t->end - t->start, &dat->chain[t->start], f->type);
                }
            }
          if (!t->size)
            LOG_TRACE ("%s.%s: [%s] empty\n", name, key, f->type);
          dwg_dynapi_field_set_value (dwg, _obj, f, &elems, 1);
        }
      else if (t->type == JSMN_ARRAY
               && (strEQc (f->type, "3DPOINT*") || strEQc (f->type, "3BD*")))
        {
          int size1 = t->size;
          BITCODE_3DPOINT *pts
              = size1 ? (BITCODE_3BD *)calloc (size1, sizeof (BITCODE_3BD))
                      : NULL;
          json_set_numfield (_obj, fields, key, size1);
          tokens->index++;
          for (int k = 0; k < size1; k++)
            {
              JSON_TOKENS_CHECK_OVERFLOW_ERR;
              json_3DPOINT (dat, tokens, name, key, f->type, &pts[k]);
            }
          if (!size1)
            LOG_TRACE ("%s.%s: [%s] empty\n", name, key, f->type);
          dwg_dynapi_field_set_value (dwg, _obj, f, &pts, 1);
        }
      else if (t->type == JSMN_ARRAY && strEQc (f->type, "2RD*"))
        {
          const int size1 = t->size;
          BITCODE_2DPOINT *pts = size1 ? (BITCODE_2DPOINT *)calloc (
                                     size1, sizeof (BITCODE_2DPOINT))
                                       : NULL;
          json_set_numfield (_obj, fields, key, size1);
          tokens->index++;
          for (int k = 0; k < size1; k++)
            {
              JSON_TOKENS_CHECK_OVERFLOW_ERR;
              json_2DPOINT (dat, tokens, name, key, f->type, &pts[k]);
            }
          if (!size1)
            LOG_TRACE ("%s.%s: [%s] empty\n", name, key, f->type);
          dwg_dynapi_field_set_value (dwg, _obj, f, &pts, 1);
        }
      else if (t->type == JSMN_ARRAY
               && (strEQc (f->type, "BD*") || strEQc (f->type, "RD")))
        {
          const int size1 = t->size;
          const int max_k
              = !f->is_malloc ? (int)(f->size / sizeof (BITCODE_BD)) : size1;
          BITCODE_BD *nums;
          if (f->is_malloc)
            {
              nums = size1 ? (BITCODE_BD *)calloc (size1, sizeof (BITCODE_BD))
                           : NULL;
              json_set_numfield (_obj, fields, key, size1);
            }
          else
            nums = (BITCODE_BD *)calloc (f->size, 1);
          tokens->index++;
          for (int k = 0; k < size1; k++)
            {
              JSON_TOKENS_CHECK_OVERFLOW_ERR
              if (k < max_k)
                {
                  nums[k] = json_float (dat, tokens);
                  LOG_TRACE ("%s.%s[%d]: %f [%s]\n", name, key, k, nums[k],
                             f->type);
                }
            }
          if (!size1)
            {
              LOG_TRACE ("%s.%s: [%s] empty\n", name, key, f->type);
            }
          else
            {
              if (f->is_malloc) // BD*, just copy the pointer
                dwg_dynapi_field_set_value (dwg, _obj, f, &nums, 1);
              else
                { // copy all values
                  dwg_dynapi_field_set_value (dwg, _obj, f, nums, 1);
                  free (nums);
                }
            }
        }
      else if (t->type == JSMN_ARRAY
               && (strEQc (f->type, "BL*") || strEQc (f->type, "BLd")))
        {
          const int size1 = t->size;
          const int max_k
              = !f->is_malloc ? (int)(f->size / sizeof (BITCODE_BL)) : size1;
          BITCODE_BL *nums;
          if (f->is_malloc)
            {
              nums = size1 ? (BITCODE_BL *)calloc (size1, sizeof (BITCODE_BL))
                           : NULL;
              json_set_numfield (_obj, fields, key, size1);
            }
          else
            nums = (BITCODE_BL *)calloc (f->size, 1);
          tokens->index++;
          for (int k = 0; k < size1; k++)
            {
              JSON_TOKENS_CHECK_OVERFLOW_ERR
              if (k < max_k)
                {
                  nums[k] = (BITCODE_BL)json_long (dat, tokens);
                  if (strEQc (f->type, "BL*"))
                    {
                      LOG_TRACE ("%s.%s[%d]: " FORMAT_BL " [%s]\n", name, key,
                                 k, nums[k], f->type);
                    }
                  else
                    {
                      LOG_TRACE ("%s.%s[%d]: " FORMAT_BLd " [%s]\n", name, key,
                                 k, nums[k], f->type);
                    }
                }
              else
                {
                  tokens->index++;
                  LOG_TRACE ("%s.%s[%d]: [%s] ignored\n", name, key, k,
                             f->type);
                }
            }
          if (!size1)
            {
              LOG_TRACE ("%s.%s: [%s] empty\n", name, key, f->type);
            }
          else
            {
              if (f->is_malloc) // BL*
                dwg_dynapi_field_set_value (dwg, _obj, f, &nums, 1);
              else
                {
                  dwg_dynapi_field_set_value (dwg, _obj, f, nums, 1);
                  free (nums);
                }
            }
        }
      else if (t->type == JSMN_ARRAY
               && (strEQc (f->type, "BS") || strEQc (f->type, "BS*")
                   || strEQc (f->type, "RS")))
        {
          const int size1 = t->size;
          const int max_k
              = !f->is_malloc ? (int)(f->size / sizeof (BITCODE_BS)) : size1;
          BITCODE_BS *nums;
          if (f->is_malloc)
            {
              nums = size1 ? (BITCODE_BS *)calloc (size1, sizeof (BITCODE_BS))
                           : NULL;
              json_set_numfield (_obj, fields, key, size1);
            }
          else
            nums = (BITCODE_BS *)calloc (f->size, 1);
          tokens->index++;
          for (int k = 0; k < size1; k++)
            {
              JSON_TOKENS_CHECK_OVERFLOW_ERR
              if (k < max_k)
                {
                  nums[k] = (BITCODE_BS)json_long (dat, tokens);
                  LOG_TRACE ("%s.%s[%d]: " FORMAT_BS " [%s]\n", name, key, k,
                             nums[k], f->type);
                }
              else
                {
                  tokens->index++;
                  LOG_TRACE ("%s.%s[%d]: [%s] ignored\n", name, key, k,
                             f->type);
                }
            }
          if (!size1)
            {
              LOG_TRACE ("%s.%s: [%s] empty\n", name, key, f->type);
            }
          else
            {
              if (f->is_malloc) // BS*
                dwg_dynapi_field_set_value (dwg, _obj, f, &nums, 1);
              else
                {
                  dwg_dynapi_field_set_value (dwg, _obj, f, nums, 1);
                  free (nums);
                }
            }
        }
      else if (t->type == JSMN_ARRAY && strEQc (key, "xdata")
               && strEQc (name, "XRECORD"))
        {
          error |= json_xdata (dat, dwg, tokens, (Dwg_Object_XRECORD *)_obj);
          JSON_TOKENS_CHECK_OVERFLOW_ERR
        }
      else if (t->type == JSMN_ARRAY && strEQc (key, "acis_data")
               && strEQc (f->type, "RC*"))
        {
          error |= json_acis_data (dat, dwg, tokens, obj);
          JSON_TOKENS_CHECK_OVERFLOW_ERR;
        }
      else if (t->type == JSMN_ARRAY && strEQc (key, "encr_sat_data")
               && strEQc (f->type, "char **"))
        {
          BITCODE_BL num_blocks = t->size;
          BITCODE_BL *block_size
              = (BITCODE_BL *)calloc (num_blocks + 1, sizeof (BITCODE_BL));
          unsigned char **data = (unsigned char **)calloc (
              num_blocks + 1, sizeof (unsigned char *));
          tokens->index++;
          LOG_TRACE ("num_blocks: " FORMAT_BL " [BL]\n", num_blocks);
          for (BITCODE_BL k = 0; k < num_blocks; k++)
            {
              size_t len;
              JSON_TOKENS_CHECK_OVERFLOW_ERR
              data[k] = json_binary (dat, tokens, "encr_sat_data", &len);
              block_size[k] = (BITCODE_BL)len;
              LOG_TRACE ("block_size[%d]: %" PRIuSIZE " [BL]\n", k, len);
            }
          block_size[num_blocks] = 0;
          LOG_TRACE ("block_size[%d]: 0 [BL]\n", num_blocks);
          dwg_dynapi_entity_set_value (_obj, obj->name, "num_blocks",
                                       &num_blocks, true);
          dwg_dynapi_entity_set_value (_obj, obj->name, "block_size",
                                       &block_size, true);
          dwg_dynapi_field_set_value (dwg, _obj, f, &data, true);
        }
      // TFFx (binary)
      else if (t->type == JSMN_STRING && strEQc (key, "revision_bytes"))
        {
          size_t len;
          unsigned char *s = json_binary (dat, tokens, "revision_bytes", &len);
          JSON_TOKENS_CHECK_OVERFLOW_ERR
          f = dwg_dynapi_entity_field (name, "revision_bytes");
          if (f && len == 8)
            {
              LOG_TRACE ("%s.%s: [%s]\n", name, key, s);
              dwg_dynapi_field_set_value (dwg, _obj, f, s, true);
            }
          free (s);
        }
      // subclass arrays:
      else if (t->type == JSMN_ARRAY && memBEGINc (f->type, "Dwg_"))
        {
          int num_elems = t->size;
          int size_elem;
          char *elems;
          const Dwg_DYNAPI_field *sfields;
          // strip off Dwg_ and final *
          // e.g. 'Dwg_MLINESTYLE_line*' => 'MLINESTYLE_line'
          char *subclass = dwg_dynapi_subclass_name (f->type);
          if (!subclass)
            {
              LOG_ERROR ("Unknown subclass type %s", f->type);
              goto unknown_ent;
            }
          size_elem = dwg_dynapi_fields_size (subclass);
          sfields = dwg_dynapi_subclass_fields (subclass);
          if (!size_elem || !sfields)
            {
              LOG_ERROR ("Unknown subclass name %s", subclass);
              free (subclass);
              goto unknown_ent;
            }
          LOG_TRACE ("new subclass %s %s [%d elems with size %d]\n", name,
                     subclass, num_elems, size_elem);
          json_set_numfield (_obj, fields, key, num_elems);
          if (strEQc (subclass, "MLINE_line") && num_elems)
            {
              Dwg_Entity_MLINE *o = obj->tio.entity->tio.MLINE;
              o->num_lines = num_elems;
              LOG_TRACE ("MLINE.num_lines = %d\n", num_elems);
            }
          if (strEQc (subclass, "DIMASSOC_Ref") && num_elems != 4)
            {
              elems = (char *)calloc (MAX (4, num_elems), size_elem);
              LOG_TRACE ("DIMASSOC num_refs = 4\n");
            }
          else
            elems = num_elems ? (char *)calloc (num_elems, size_elem) : NULL;
          dwg_dynapi_field_set_value (dwg, _obj, f, &elems, 1);
          tokens->index++;
          // array of structs
          if (!num_elems)
            LOG_TRACE ("%s: [%s] empty\n", key, f->type);
          for (int k = 0; k < num_elems; k++)
            {
              int keys;
              JSON_TOKENS_CHECK_OVERFLOW_ERR
              t = &tokens->tokens[tokens->index];
              if (t->type != JSMN_OBJECT)
                {
                  LOG_ERROR ("Unexpected %s at %u of %ld tokens, expected "
                             "%s OBJECT. %s:%d",
                             t_typename[t->type], tokens->index,
                             tokens->num_tokens, subclass, __FUNCTION__,
                             __LINE__);
                  free (subclass);
                  json_advance_unknown (dat, tokens, t->type, 0);
                  JSON_TOKENS_CHECK_OVERFLOW_ERR
                  return DWG_ERR_INVALIDTYPE;
                }
              LOG_TRACE ("%s.%s[%d]:\n", name, key, k);
              keys = t->size;
              tokens->index++;
              for (int ki = 0; ki < keys; ki++)
                {
                  // separate subclass type loop
                  const Dwg_DYNAPI_field *f1;
                  char key1[80];
                  char *rest;
                  JSON_TOKENS_CHECK_OVERFLOW_ERR
                  json_fixed_key (key1, dat, tokens);
                  LOG_INSANE ("-search %s key: %s\n", subclass, key1);
                  f1 = dwg_dynapi_subclass_field (subclass, key1);
                  if (f1)
                    {
                      LOG_INSANE ("-found %s [%s]\n", f1->name, f1->type);
                      if (!_set_struct_field (dat, obj, tokens,
                                              &elems[k * size_elem], subclass,
                                              key1, sfields))
                        ++tokens->index;
                    }
                  else if ((rest = strchr (key1, '.'))) // embedded struct
                    {
                      *rest = '\0';
                      rest++;
                      f1 = dwg_dynapi_subclass_field (subclass, key1);
                      if (f1 && *rest)
                        {
                          char *sb1 = dwg_dynapi_subclass_name (f1->type);
                          const Dwg_DYNAPI_field *sfields1
                              = sb1 ? dwg_dynapi_subclass_fields (sb1) : NULL;
                          if (!sfields1
                              || !_set_struct_field (
                                  dat, obj, tokens,
                                  &elems[(k * size_elem) + f1->offset], sb1,
                                  rest, sfields1))
                            ++tokens->index;
                          free (sb1);
                        }
                    }
                  if (!f1 || !f1->name) // not found
                    {
                      LOG_ERROR ("Unknown subclass field %s.%s", subclass,
                                 key1);
                      ++tokens->index;
                    }
                }
            }
          if (dwg_dynapi_field_set_value (dwg, _obj, f, &elems, 1))
            LOG_TRACE ("subclass %s.%s done\n", name, key);
          free (subclass);
        }
      // subclass structs (embedded):
      else if (t->type == JSMN_OBJECT && memBEGINc (f->type, "Dwg_"))
        {
          int num_keys = t->size; // div by 2 really
          // int size_struct;
          const Dwg_DYNAPI_field *sfields;
          char *subclass = dwg_dynapi_subclass_name (f->type);
          if (!subclass)
            {
              LOG_ERROR ("Unknown subclass type %s", f->type);
              goto unknown_ent;
            }
          // size_struct = dwg_dynapi_fields_size (subclass);
          sfields = dwg_dynapi_subclass_fields (subclass);
          if (!sfields)
            {
              LOG_ERROR ("Unknown subclass name %s", subclass);
              free (subclass);
              goto unknown_ent;
            }
          LOG_TRACE ("embedded struct %s %s [%d keys]\n", subclass, key,
                     num_keys / 2);
          tokens->index++;
          // a single struct
          if (!num_keys)
            LOG_TRACE ("%s: [%s] empty\n", key, f->type);
          for (int k = 0; k < num_keys; k++)
            {
              const Dwg_DYNAPI_field *f1;
              char key1[80];
              char *rest;
              JSON_TOKENS_CHECK_OVERFLOW_ERR
              json_fixed_key (key1, dat, tokens);
              LOG_INSANE ("-search %s key %s\n", subclass, key1);
              f1 = dwg_dynapi_subclass_field (subclass, key1);
              if (f1)
                {
                  // subclass offset for _obj
                  void *off = &((char *)_obj)[f->offset + f1->offset];
                  if (!_set_struct_field (dat, obj, tokens, off, subclass,
                                          key1, sfields))
                    ++tokens->index;
                }
              else if ((rest = strchr (key1, '.'))) // embedded struct
                {
                  *rest = '\0';
                  rest++;
                  f1 = dwg_dynapi_subclass_field (subclass, key1);
                  if (f1 && *rest)
                    {
                      void *off = &((char *)_obj)[f->offset + f1->offset];
                      char *subclass1 = dwg_dynapi_subclass_name (f1->type);
                      const Dwg_DYNAPI_field *sfields1
                          = subclass1 ? dwg_dynapi_subclass_fields (subclass1)
                                      : NULL;
                      if (!sfields1
                          || !_set_struct_field (dat, obj, tokens, off,
                                                 subclass1, rest, sfields1))
                        ++tokens->index;
                      free (subclass1);
                    }
                }
              if (!f1 || !f1->name) // not found
                {
                  LOG_ERROR ("Unknown subclass field %s.%s", subclass, key1);
                  ++tokens->index;
                }
            }
          free (subclass);
        }
      else
        {
        unknown_ent:
          LOG_ERROR ("Unknown type for %s.%s %s with %s", name, key, f->type,
                     t_typename[t->type]);
          ++tokens->index;
          JSON_TOKENS_CHECK_OVERFLOW_ERR
        }
      return error | (f->name ? 1 : 0); // found or not
    }
  else // not found
    {  // maybe it's an embedded subclass. look for the dot(s)
      int found = 0;
      char *rest = strchr ((char *)key, '.');
      while (rest)
        {
          // Currently we have 3 known static arrays, and a few embedded
          // subclasses. Color e.g.
          const Dwg_DYNAPI_field *f1;
          const char *subclass = NULL;
          JSON_TOKENS_CHECK_OVERFLOW_ERR;
          *rest = '\0';
          rest++;
          f1 = dwg_dynapi_entity_field (name, key);
          if (f1 && *rest)
            {
              void *off = &((char *)_obj)[f1->offset];
              const char *subclass1 = dwg_dynapi_subclass_name (f1->type);
              const Dwg_DYNAPI_field *sfields1
                  = subclass1 ? dwg_dynapi_subclass_fields (subclass1) : NULL;
              if (!sfields1 && subclass1)
                sfields1 = dwg_dynapi_entity_fields (subclass1);
              if (!sfields1
                  || !_set_struct_field (dat, obj, tokens, off, subclass1,
                                         rest, sfields1))
                ++tokens->index;
              free ((char *)subclass1);
              return error | (f1->name ? 1 : 0); // found or not
            }
          f1 = dwg_dynapi_subclass_field (name, key);
          if (f1 && *rest)
            {
              void *off = &((char *)_obj)[f1->offset];
              const char *subclass1 = dwg_dynapi_subclass_name (f1->type);
              const Dwg_DYNAPI_field *sfields1
                  = subclass1 ? dwg_dynapi_subclass_fields (subclass1) : NULL;
              if (!sfields1 && subclass1)
                sfields1 = dwg_dynapi_entity_fields (subclass1);
              if (!sfields1
                  || !_set_struct_field (dat, obj, tokens, off, subclass1,
                                         rest, sfields1))
                ++tokens->index;
              free ((char *)subclass1);
              return error | (f1->name ? 1 : 0); // found or not
            }
          else
            {
              // failed_key.rest.nextfieldatteept
              *(rest - 1) = '.'; // unsuccessful search, set the dot back
              rest = strchr (rest, '.');
              if (rest)
                {
                  LOG_HANDLE ("Try next embedded struct with %s.%s\n", key,
                              rest);
                }
              else
                {
                  LOG_HANDLE ("No embedded struct with %s\n", key);
                }
            }
        }
    }
  return error;
}

/*
// check both texts[] and itemhandles[]
static void
in_postprocess_DICTIONARY (Dwg_Object *obj)
{
  Dwg_Object_DICTIONARY *_obj = obj->tio.object->tio.DICTIONARY;
  int do_free = 0;
  if (_obj->numitems == (BITCODE_BL)-1)
    {
      _obj->numitems = 0;
      do_free = 1;
      LOG_ERROR ("reset DICTIONARY, no numitems");
    }
  if ((_obj->numitems || do_free) && !_obj->texts)
    {
      LOG_ERROR ("reset DICTIONARY, no texts");
      // need to leave the handles, just free H*
      free (_obj->itemhandles);
      _obj->itemhandles = NULL;
      _obj->numitems = 0;
    }
  if ((_obj->numitems || do_free) && !_obj->itemhandles)
    {
      LOG_ERROR ("reset DICTIONARY, no itemhandles");
      for (BITCODE_BL i = 0; i < _obj->numitems; i++)
        free (_obj->texts[i]);
      free (_obj->texts);
      _obj->texts = NULL;
      _obj->numitems = 0;
    }
}
// check both texts[] and itemhandles[]
static void
in_postprocess_DICTIONARYWDFLT (Dwg_Object *obj)
{
  Dwg_Object_DICTIONARYWDFLT *_obj = obj->tio.object->tio.DICTIONARYWDFLT;
  int do_free = 0;
  if (_obj->numitems == (BITCODE_BL)-1)
    {
      _obj->numitems = 0;
      do_free = 1;
      LOG_ERROR ("reset DICTIONARYWDFLT, no numitems");
    }
  if ((_obj->numitems || do_free) && !_obj->texts)
    {
      LOG_ERROR ("reset DICTIONARYWDFLT, no texts");
      // need to leave the handles, just free H*
      free (_obj->itemhandles);
      _obj->itemhandles = NULL;
      _obj->numitems = 0;
    }
  if ((_obj->numitems || do_free) && !_obj->itemhandles)
    {
      LOG_ERROR ("reset DICTIONARYWDFLT, no itemhandles");
      for (BITCODE_BL i = 0; i < _obj->numitems; i++)
        free (_obj->texts[i]);
      free (_obj->texts);
      _obj->texts = NULL;
      _obj->numitems = 0;
    }
}
*/

static int
json_OBJECTS (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,
              jsmntokens_t *restrict tokens)
{
  const char *section = "OBJECTS";
  const jsmntok_t *t = &tokens->tokens[tokens->index];
  int i, size;
  if (t->type != JSMN_ARRAY || dwg->num_objects)
    {
      LOG_ERROR ("Unexpected %s at %u of %ld tokens, expected %s ARRAY",
                 t_typename[t->type], tokens->index, tokens->num_tokens,
                 section);
      json_advance_unknown (dat, tokens, t->type, 0);
      return DWG_ERR_INVALIDTYPE;
    }
  size = t->size;
  LOG_TRACE ("\n%s pos:%d [%d members]\n--------------------\n", section,
             tokens->index, size);
  tokens->index++;
  JSON_TOKENS_CHECK_OVERFLOW_ERR
  if (dwg->num_objects == 0)
    {
      // faster version of dwg_add_object()
      // round up to next REFS_PER_REALLOC
      int rounded = size;
      if (rounded % REFS_PER_REALLOC)
        rounded += REFS_PER_REALLOC - (rounded % REFS_PER_REALLOC);
      dwg->object = (Dwg_Object *)calloc (rounded, sizeof (Dwg_Object));
    }
  else
    dwg_add_object (dwg);
  if (!dwg->object)
    {
      LOG_ERROR ("Out of memory");
      return DWG_ERR_OUTOFMEM;
    }
  if (dwg->header.from_version < R_13b1)
    {
      dwg->header.section
          = (Dwg_Section *)calloc (SECTION_VX + 1, sizeof (Dwg_Section));
    }
  dwg->num_objects += size;
  for (i = 0; i < size; i++)
    {
      char name[80];
      int keys;
      int is_entity = 0;
      Dwg_Object *obj = &dwg->object[i];
      Dwg_Object_APPID *_obj = NULL;
      const Dwg_DYNAPI_field *fields = NULL, *cfields;
      const Dwg_DYNAPI_field *f;

      memset (name, 0, sizeof (name));
      JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
      if (i > 0)
        {
          Dwg_Object *oldobj = &dwg->object[i - 1];
          if (dwg->header.from_version >= R_13b1 && !oldobj->handle.value)
            {
              LOG_ERROR ("Required %s.handle missing, skipped", oldobj->name)
              dwg_free_object (oldobj);
              obj = oldobj;
              i--;
            }
          else if (!oldobj->type)
            {
              if (dwg->header.from_version >= R_13b1
                  || (oldobj->fixedtype != DWG_TYPE_BLOCK
                      && oldobj->fixedtype != DWG_TYPE_ENDBLK))
                LOG_ERROR ("Required %s.type missing, skipped", oldobj->name)
              if (!oldobj->parent)
                oldobj->parent = dwg;
              dwg_free_object (oldobj);
              obj = oldobj;
              i--;
              size--;
            }
          else if (oldobj->fixedtype == DWG_TYPE_UNUSED)
            {
              LOG_ERROR ("Required %s.fixedtype missing, skipped",
                         oldobj->name);
              if (!oldobj->parent)
                oldobj->parent = dwg;
              dwg_free_object (oldobj);
              obj = oldobj;
              i--;
            }
          if (oldobj->fixedtype == DWG_TYPE_SEQEND)
            {
              in_postprocess_SEQEND (oldobj, 0, NULL);
            }
          /*
          else if (oldobj->fixedtype == DWG_TYPE_DICTIONARY)
            {
              in_postprocess_DICTIONARY (oldobj);
            }
          else if (oldobj->fixedtype == DWG_TYPE_DICTIONARYWDFLT)
            {
              in_postprocess_DICTIONARYWDFLT (oldobj);
            }
          */
        }

      memset (obj, 0, sizeof (Dwg_Object));
      t = &tokens->tokens[tokens->index];
      if (t->type != JSMN_OBJECT)
        {
          LOG_ERROR (
              "Unexpected %s at %u of %ld tokens, expected %s OBJECT. %s:%d",
              t_typename[t->type], tokens->index, tokens->num_tokens, section,
              __FUNCTION__, __LINE__);
          json_advance_unknown (dat, tokens, t->type, 0);
          JSON_TOKENS_CHECK_OVERFLOW (goto typeerr)
        }
      keys = t->size;
      LOG_HANDLE ("\n-keys: %d, object %d of %d\n", keys, i, size);

      tokens->index++;
      for (int j = 0; j < keys; j++)
        {
          bool saw_dxfname = false;
          char key[80];
          memset (key, 0, sizeof (key));
          LOG_INSANE ("[%d] ", j);
          JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
          json_fixed_key (key, dat, tokens);
          JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
          t = &tokens->tokens[tokens->index];
          if (strEQc (key, "object") && t->type == JSMN_STRING
              && i < (int)dwg->num_objects && !dwg->object[i].type)
            {
              int len = t->end - t->start;
              int objsize = 16;
              obj->supertype = DWG_SUPERTYPE_OBJECT;
              obj->parent = dwg;
              obj->index = i;

              if (len >= 80)
                {
                  LOG_ERROR ("Illegal %s name %.*s", key, len,
                             &dat->chain[t->start])
                  obj->type = obj->fixedtype = DWG_TYPE_DUMMY;
                  // exhaust the rest
                  for (; j < keys; j++)
                    {
                      json_advance_unknown (dat, tokens, t->type, 0); // value
                      tokens->index++; // next key
                      JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
                    }
                  tokens->index--;
                  break;
                }
              memcpy (name, &dat->chain[t->start], len);
              name[len] = '\0';
              is_entity = 0;
              fields = dwg_dynapi_entity_fields (name);
              objsize = dwg_dynapi_fields_size (name);
              if (!fields || !objsize || !is_dwg_object (name))
                {
                  LOG_ERROR ("Unknown object %s (no fields)", name);
                  // skip_object:
                  obj->type = obj->fixedtype = DWG_TYPE_DUMMY;
                  // exhaust the rest
                  for (; j < keys; j++)
                    {
                      json_advance_unknown (dat, tokens, t->type, 0); // value
                      tokens->index++; // next key
                      JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
                    }
                  tokens->index--;
                  break;
                }
              // crashing acad import, but dxfin might be okay
              /*
              if (is_class_unstable (name) &&
                  (strEQc (name, "TABLEGEOMETRY") ||
                   strEQc (name, "WIPEOUT")))
                {
                  LOG_ERROR ("Unhandled object %s", name);
                  goto skip_object;
                }
              */
              LOG_TRACE ("\nnew object %s [%d] (size: %d)\n", name, i,
                         objsize);
              obj->tio.object = (Dwg_Object_Object *)calloc (
                  1, sizeof (Dwg_Object_Object));
              obj->tio.object->dwg = dwg;
              obj->tio.object->objid = i;
              // NEW_OBJECT (dwg, obj)
              // ADD_OBJECT loop?
              _obj = (Dwg_Object_APPID *)calloc (1, objsize);
              obj->tio.object->tio.APPID = _obj;
              obj->tio.object->tio.APPID->parent = obj->tio.object;
              free (obj->name);
              obj->name = strdup (name);
              // TODO alias
              free (obj->dxfname);
              obj->dxfname = strdup (name);
              tokens->index++;
              JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
            }
          else if (strEQc (key, "entity") && t->type == JSMN_STRING
                   && i < (int)dwg->num_objects && !dwg->object[i].type)
            {
              int len = t->end - t->start;
              int objsize;
              obj->supertype = DWG_SUPERTYPE_ENTITY;
              obj->parent = dwg;
              obj->index = i;

              if (len >= 80)
                {
                  LOG_ERROR ("Illegal %s name %.*s", key, len,
                             &dat->chain[t->start])
                  obj->type = obj->fixedtype = DWG_TYPE_DUMMY;
                  // exhaust the rest
                  for (; j < keys; j++)
                    {
                      json_advance_unknown (dat, tokens, t->type, 0); // value
                      tokens->index++; // next key
                      JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
                    }
                  tokens->index--;
                  break;
                }
              memcpy (name, &dat->chain[t->start], len);
              name[len] = '\0';
              is_entity = 1;
              fields = dwg_dynapi_entity_fields (name);
              objsize = dwg_dynapi_fields_size (name);
              if (!fields || !objsize || !is_dwg_entity (name))
                {
                  LOG_ERROR ("Unknown entity %s (no fields)", name);
                  obj->type = obj->fixedtype = DWG_TYPE_DUMMY;
                  // exhaust the rest
                  for (; j < keys; j++)
                    {
                      json_advance_unknown (dat, tokens, t->type, 0); // value
                      tokens->index++; // next key
                      JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
                    }
                  tokens->index--;
                  break;
                }
              LOG_TRACE ("\nnew entity %s [%d] (size: %d)\n", name, i,
                         objsize);
              obj->tio.entity = (Dwg_Object_Entity *)calloc (
                  1, sizeof (Dwg_Object_Entity));
              obj->tio.entity->dwg = dwg;
              obj->tio.entity->objid = i;
              // NEW_ENTITY (dwg, obj)
              // ADD_ENTITY loop?
              _obj = (Dwg_Object_APPID *)calloc (1, objsize);
              obj->tio.entity->tio.POINT = (Dwg_Entity_POINT *)_obj;
              obj->tio.entity->tio.POINT->parent = obj->tio.entity;
              free (obj->name);
              obj->name = strdup (name);
              // if different, the alias is done via extra dxfname key (below)
              free (obj->dxfname);
              obj->dxfname = strdup (name);
              tokens->index++;
              JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
            }
          else if (!obj || !fields)
            {
              LOG_ERROR ("Required object or entity key missing");
              json_advance_unknown (dat, tokens, t->type, 0);
              JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
            }
          else if (strEQc (key, "dxfname"))
            {
              free (obj->dxfname);
              saw_dxfname = true;
              obj->dxfname = json_string (dat, tokens);
              LOG_TRACE ("dxfname: %s\n", obj->dxfname)
              if (!obj->dxfname)
                obj->dxfname = strdup (name);

              // Some objects have various subtypes under one name.
              // TODO OBJECTCONTEXTDATA, ...
            }
          else if (strEQc (key, "index")
                   && strNE (name, "TableCellContent_Attr"))
            {
              BITCODE_RL index = (BITCODE_RL)json_long (dat, tokens);
              if (dat->from_version < R_13b1)
                {
                  if (index > 5)
                    index = obj->index; // we added 2 mspace blocks (type 0)
                                        // in-between
                }
              if (obj->index != index)
                LOG_WARN ("Ignore wrong %s.index %d, expected %d", name, index,
                          obj->index)
              LOG_TRACE ("index: %d\n", obj->index)
            }
          else if (strEQc (key, "type") && !obj->type)
            {
              int isent;
              const char *dxfname;
              obj->type = json_long (dat, tokens);
              JSON_TOKENS_CHECK_OVERFLOW (goto harderr)

              if (!dwg_object_name (name, &dxfname, &obj->fixedtype, &isent,
                                    NULL))
                {
                  LOG_ERROR ("Unknown object %s failed dwg_object_name()",
                             name);
                  // exhaust the rest
                  for (; j < keys; j++)
                    {
                      json_advance_unknown (dat, tokens, t->type, 0); // value
                      tokens->index++; // next key
                      JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
                    }
                  tokens->index--;
                  break;
                }
              else
                {
                  if (obj->dxfname && strNE (obj->dxfname, dxfname))
                    {
                      if (memBEGINc (dxfname, "UNKNOWN_") || !saw_dxfname)
                        LOG_TRACE ("Changed dxfname %s => %s\n", obj->dxfname,
                                   dxfname)
                      else
                        LOG_WARN ("Changed wrong dxfname %s => %s",
                                  obj->dxfname, dxfname)
                    }
                  free (obj->dxfname);
                  obj->dxfname = strdup (dxfname);
                  if (obj->type <= DWG_TYPE_LAYOUT
                      && obj->fixedtype != obj->type
                      && dwg->header.from_version >= R_13b1)
                    {
                      LOG_WARN ("Changed wrong type %d => %d", obj->type,
                                obj->fixedtype)
                      obj->type = obj->fixedtype;
                    }
                  if ((obj->supertype == DWG_SUPERTYPE_ENTITY && !isent)
                      || (obj->supertype == DWG_SUPERTYPE_OBJECT && isent))
                    {
                      LOG_ERROR ("Illegal object supertype for %s", name);
                      // exhaust the rest
                      for (; j < keys; j++)
                        {
                          json_advance_unknown (dat, tokens, t->type,
                                                0); // value
                          tokens->index++;          // next key
                          JSON_TOKENS_CHECK_OVERFLOW (goto harderr);
                        }
                      tokens->index--;
                      break;
                    }
                }
              LOG_TRACE ("type: %d,\tfixedtype: %d\n", obj->type,
                         obj->fixedtype);
              if (dwg->header.from_version < R_13b1 && dwg_obj_is_table (obj))
                {
                  Dwg_Section_Type_r11 id = SECTION_HEADER_R11;
                  switch (obj->fixedtype)
                    {
                    case DWG_TYPE_BLOCK_HEADER:
                      id = SECTION_BLOCK;
                      break;
                    case DWG_TYPE_LAYER:
                      id = SECTION_LAYER;
                      break;
                    case DWG_TYPE_STYLE:
                      id = SECTION_STYLE;
                      break;
                    case DWG_TYPE_LTYPE:
                      id = SECTION_LTYPE;
                      break;
                    case DWG_TYPE_VIEW:
                      id = SECTION_VIEW;
                      break;
                    case DWG_TYPE_VPORT:
                      id = SECTION_VPORT;
                      break;
                    case DWG_TYPE_APPID:
                      id = SECTION_APPID;
                      break;
                    case DWG_TYPE_DIMSTYLE:
                      id = SECTION_DIMSTYLE;
                      break;
                    case DWG_TYPE_VX_TABLE_RECORD:
                      id = SECTION_VX;
                      break;
                    default:
                      LOG_ERROR ("Invalid table type %s %u", obj->name,
                                 obj->fixedtype);
                      // assert (!obj->fixedtype);
                    }
                  if (id != SECTION_HEADER_R11)
                    {
                      // TODO: maybe add a missing CONTROL object here. GH #453
                      dwg->header.section[id].number++;
                    }
                }
            }
          // Note: also _obj->size
          else if (strEQc (key, "size") && !obj->size
                   && t->type == JSMN_PRIMITIVE)
            {
              obj->size = json_long (dat, tokens);
              JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
              if (dwg->header.from_version >= R_13b1 && !obj->handle.value)
                {
                  LOG_ERROR ("Required %s.handle missing", name);
                  goto harderr;
                }
              LOG_TRACE ("%s.size: %d\n", obj->name, obj->size)
            }
          else if (strEQc (key, "bitsize") && !obj->bitsize)
            {
              obj->bitsize = json_long (dat, tokens);
              LOG_TRACE ("%s.bitsize: %d\n", obj->name, obj->bitsize)
              JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
            }
          else if (strEQc (key, "address") && !obj->address)
            {
              obj->address = json_long (dat, tokens);
              LOG_TRACE ("%s.address: 0x%zx\n", obj->name, obj->address)
              JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
            }
          else if (strEQc (key, "handle") && !obj->handle.value)
            {
              BITCODE_H hdl
                  = json_HANDLE (dat, dwg, tokens, name, key, obj, -1);
              JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
              if (hdl)
                {
                  obj->handle.code = hdl->handleref.code;
                  obj->handle.size = hdl->handleref.size;
                  obj->handle.value = hdl->handleref.value;
                  if (!hdl->handleref.code)
                    {
                      hdl->obj = obj;
                      dwg_add_handle (&hdl->handleref, 0, hdl->handleref.value,
                                      obj);
                    }
                }
              if (!obj->type) // TODO: We could eventually relax this
                {
                  LOG_ERROR ("Required %s.type missing", name)
                  return DWG_ERR_INVALIDDWG;
                }
            }
          // ignore subclass markers
          else if (t->type == JSMN_STRING && strEQc (key, "_subclass"))
            {
              LOG_TRACE ("_subclass: %.*s\n", t->end - t->start,
                         &dat->chain[t->start]);
              tokens->index++;
              JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
            }
          else if (strEQc (key, "num_unknown_bits"))
            {
              obj->num_unknown_bits = json_long (dat, tokens);
              JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
              LOG_TRACE ("num_unknown_bits: %d\n", (int)obj->num_unknown_bits);
            }
          else if (strEQc (key, "unknown_bits"))
            {
              const int len = t->end - t->start;
              char *hex = json_string (dat, tokens);
              const unsigned blen = len / 2;
              unsigned read;
              BITCODE_TF buf = (BITCODE_TF)malloc (blen + 1);
              if ((read = in_hex2bin (buf, hex, blen) != blen))
                LOG_ERROR ("in_hex2bin with key %s at pos %u of %u", key, read,
                           blen);
              buf[blen] = '\0';
              free (hex);
              if (!obj->num_unknown_bits)
                obj->num_unknown_bits = blen * 8; // minus some padding bits
              if (obj->unknown_bits)
                free (obj->unknown_bits);
              obj->unknown_bits = buf;
              // LOG_TRACE ("%s: '%.*s' [%s] (binary)\n", key, blen, buf,
              //            f->type);
              LOG_TRACE ("unknown_bits: %.*s\n", t->end - t->start,
                         &dat->chain[t->start])
            }
          else if (strEQc (key, "num_unknown_rest"))
            {
              obj->num_unknown_rest = json_long (dat, tokens);
              JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
              LOG_TRACE ("num_unknown_rest: %d\n", (int)obj->num_unknown_rest);
            }
          else if (strEQc (key, "unknown_rest"))
            {
              const int len = t->end - t->start;
              char *hex = json_string (dat, tokens);
              const unsigned blen = len / 2;
              unsigned read;
              BITCODE_TF buf = (BITCODE_TF)malloc (blen + 1);
              if ((read = in_hex2bin (buf, hex, blen) != blen))
                LOG_ERROR ("in_hex2bin with key %s at pos %u of %u", key, read,
                           blen);
              buf[blen] = '\0';
              free (hex);
              if (!obj->num_unknown_rest)
                obj->num_unknown_rest = blen * 8; // minus some padding bits
              if (obj->unknown_rest)
                free (obj->unknown_rest);
              obj->unknown_rest = buf;
              // LOG_TRACE ("%s: '%.*s' [%s] (binary)\n", key, blen, buf,
              //            f->type);
              LOG_TRACE ("unknown_rest: %.*s\n", t->end - t->start,
                         &dat->chain[t->start])
            }
          else if (strEQc (key, "eed") && !obj->tio.object->num_eed
                   && t->type == JSMN_ARRAY)
            {
              json_eed (dat, dwg, tokens, obj->tio.object);
              JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
            }
          else
            // search_field:
            {
              if (t->type == JSMN_STRING && is_entity && strEQc (key, "tag"))
                {
                  int sz = t->end - t->start;
                  char *tag = (char *)malloc (sz + 1);
                  memcpy (tag, &dat->chain[t->start], sz);
                  tag[sz] = '\0';
                  if (sz <= 0 || !dwg_is_valid_tag (tag))
                    {
                      LOG_WARN ("Invalid %s.tag: %s\n", obj->name, tag);
                    }
                  free (tag);
                }
              if (_set_struct_field (dat, obj, tokens, _obj, name, key,
                                     fields))
                continue;
              if (is_entity)
                {
                  if (_set_struct_field (dat, obj, tokens, obj->tio.entity,
                                         name, key,
                                         dwg_dynapi_common_entity_fields ()))
                    continue;
                }
              else
                {
                  if (_set_struct_field (dat, obj, tokens, obj->tio.object,
                                         name, key,
                                         dwg_dynapi_common_object_fields ()))
                    continue;
                }

              // This should now be handled in _set_struct_field, recursively.
              // esp for TABLE's
              // first the MLEADER_AnnotContext union:
              if (strEQc (name, "MULTILEADER"))
                {
                  // assert (0);
                  // embedded structs
                  if (memBEGINc (key, "ctx.content.txt."))
                    {
                      Dwg_Entity_MULTILEADER *_o
                          = (Dwg_Entity_MULTILEADER *)_obj;
                      Dwg_MLEADER_Content *cnt = &_o->ctx.content;
                      const Dwg_DYNAPI_field *sf = dwg_dynapi_subclass_fields (
                          "MLEADER_Content_MText");
                      if (sf
                          && _set_struct_field (
                              dat, obj, tokens, cnt, "MLEADER_Content",
                              &key[strlen ("ctx.content.")], sf))
                        continue;
                    }
                  // the rest
                  else if (memBEGINc (key, "ctx."))
                    {
                      Dwg_Entity_MULTILEADER *_o
                          = (Dwg_Entity_MULTILEADER *)_obj;
                      Dwg_MLEADER_AnnotContext *ctx = &_o->ctx;
                      const Dwg_DYNAPI_field *sf = dwg_dynapi_subclass_fields (
                          "MLEADER_AnnotContext");
                      if (sf
                          && _set_struct_field (dat, obj, tokens, ctx,
                                                "MLEADER_AnnotContext",
                                                &key[4], sf))
                        continue;
                    }
                }
              else if (t->type == JSMN_OBJECT && memBEGINc (name, "DICTIONARY")
                       && strEQc (key, "items"))
                {
                  Dwg_Object_DICTIONARY *o = obj->tio.object->tio.DICTIONARY;
                  o->numitems = t->size;
                  o->texts = o->numitems ? (BITCODE_T *)calloc (
                                 o->numitems, sizeof (BITCODE_T))
                                         : NULL;
                  o->itemhandles = o->numitems ? (BITCODE_H *)calloc (
                                       o->numitems, sizeof (BITCODE_H))
                                               : NULL;
                  tokens->index++;
                  for (int k = 0; k < (int)o->numitems; k++)
                    {
                      JSON_TOKENS_CHECK_OVERFLOW (goto harderr);
                      t = &tokens->tokens[tokens->index];
                      /*SINCE (R_2007)
                        o->texts[k] = (BITCODE_T)json_wstring (dat, tokens);
                      else*/
                      o->texts[k] = json_string (dat, tokens);
                      LOG_TRACE ("texts[%d]: %.*s\t => ", k, t->end - t->start,
                                 &dat->chain[t->start]);
                      JSON_TOKENS_CHECK_OVERFLOW (goto harderr);
                      o->itemhandles[k] = json_HANDLE (dat, dwg, tokens, name,
                                                       "itemhandles", obj, k);
                    }
                  if (!o->numitems)
                    LOG_TRACE ("%s.%s empty\n", name, key);
                  continue;
                }
              LOG_ERROR ("Unknown %s.%s %.*s ignored", name, key,
                         t->end - t->start, &dat->chain[t->start]);
              json_advance_unknown (dat, tokens, t->type, 0);
              JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
            }
        }
    }
  LOG_TRACE ("End of %s\n", section)
  tokens->index--;
  return 0;
harderr:
  dwg->num_objects = i;
  LOG_TRACE ("End of %s (hard error)\n", section)
  tokens->index--;
  return DWG_ERR_INVALIDDWG;
typeerr:
  dwg->num_objects = i;
  LOG_TRACE ("End of %s (type error)\n", section)
  tokens->index--;
  return DWG_ERR_INVALIDTYPE;
}

static int
json_HANDLES (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,
              jsmntokens_t *restrict tokens)
{
  const char *section = "HANDLES";
  const jsmntok_t *t = &tokens->tokens[tokens->index];
  int size;
  if (t->type != JSMN_ARRAY)
    {
      LOG_ERROR ("Unexpected %s at %u of %ld tokens, expected %s OBJECT",
                 t_typename[t->type], tokens->index, tokens->num_tokens,
                 section);
      json_advance_unknown (dat, tokens, t->type, 0);
      return DWG_ERR_INVALIDTYPE;
    }
  size = t->size;
  LOG_TRACE ("\n%s pos:%d [%d members]\n--------------------\n", section,
             tokens->index, size);
  // Maybe create dwg->header.section[SECTION_HANDLES_R13] omap here.
  // struct { uint32_t hdloff; int32_t offset } *omap = calloc (size, 8);
  for (int i = 0; i < size; i++)
    {
      tokens->index++;
      JSON_TOKENS_CHECK_OVERFLOW_ERR
      for (int k = 0; k < 2; k++)
        {
          long hdloff = json_long (dat, tokens);
          long offset = json_long (dat, tokens);
          tokens->index++;
          JSON_TOKENS_CHECK_OVERFLOW_ERR
        }
    }
  return 0;
}

static int
json_THUMBNAILIMAGE (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,
                     jsmntokens_t *restrict tokens)
{
  const char *section = "THUMBNAILIMAGE";
  const jsmntok_t *restrict t = &tokens->tokens[tokens->index];
  Dwg_Chain *restrict _obj = &dwg->thumbnail;
  int size;
  long size1 = 0;
  if (t->type != JSMN_OBJECT)
    {
      LOG_ERROR ("Unexpected %s at %u of %ld tokens, expected %s OBJECT",
                 t_typename[t->type], tokens->index, tokens->num_tokens,
                 section);
      json_advance_unknown (dat, tokens, t->type, 0);
      return DWG_ERR_INVALIDTYPE;
    }
  size = t->size;
  LOG_TRACE ("\n%s pos:%d [%d keys]\n--------------------\n", section,
             tokens->index, size);
  tokens->index++;
  for (int i = 0; i < size; i++)
    {
      char key[80];
      JSON_TOKENS_CHECK_OVERFLOW_ERR
      json_fixed_key (key, dat, tokens);
      t = &tokens->tokens[tokens->index];
      if (strEQc (key, "size"))
        size1 = json_long (dat, tokens);
      else if (strEQc (key, "chain"))
        {
          size_t len;
          dwg->thumbnail.chain = json_binary (dat, tokens, key, &len);
          JSON_TOKENS_CHECK_OVERFLOW_ERR
          dwg->thumbnail.size = len;
          if (size1 > 0 && size1 != (long)len)
            LOG_WARN ("thumbnail size mismatch: binary len %" PRIuSIZE
                      " != size %ld",
                      len, size1);
          LOG_TRACE ("size: %" PRIuSIZE "\n", len);
        }
      else
        {
          LOG_TRACE ("%s\n", key)
          json_advance_unknown (dat, tokens, t->type, 0);
          JSON_TOKENS_CHECK_OVERFLOW_ERR
        }
    }

  LOG_TRACE ("End of %s\n", section)
  tokens->index--;
  return 0;
}

static int
json_R2007_Header (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,
                   jsmntokens_t *restrict tokens)
{
  const char *section = "R2007_Header";
  const jsmntok_t *t = &tokens->tokens[tokens->index];
  Dwg_R2007_Header *_obj = &dwg->r2007_file_header;
  int size;
  if (t->type != JSMN_OBJECT)
    {
      LOG_ERROR ("Unexpected %s at %u of %ld tokens, expected %s OBJECT",
                 t_typename[t->type], tokens->index, tokens->num_tokens,
                 section);
      json_advance_unknown (dat, tokens, t->type, 0);
      return DWG_ERR_INVALIDTYPE;
    }
  size = t->size;
  LOG_TRACE ("\n%s pos:%d [%d keys]\n--------------------\n", section,
             tokens->index, size);
  tokens->index++;
  for (int i = 0; i < size; i++)
    {
      char key[80];
      JSON_TOKENS_CHECK_OVERFLOW_ERR
      json_fixed_key (key, dat, tokens);
      t = &tokens->tokens[tokens->index];

      // clang-format off
      if (0) ;
      FIELD_RLL (header_size, 0)
      FIELD_RLL (file_size, 0)
      FIELD_RLL (pages_map_crc_compressed, 0)
      FIELD_RLL (pages_map_correction, 0)
      FIELD_RLL (pages_map_crc_seed, 0)
      FIELD_RLL (pages_map2_offset, 0)
      FIELD_RLL (pages_map2_id, 0)
      FIELD_RLL (pages_map_offset, 0)
      FIELD_RLL (pages_map_id, 0)
      FIELD_RLL (header2_offset, 0)
      FIELD_RLL (pages_map_size_comp, 0)
      FIELD_RLL (pages_map_size_uncomp, 0)
      FIELD_RLL (pages_amount, 0)
      FIELD_RLL (pages_maxid, 0)
      FIELD_RLL (unknown1, 0)
      FIELD_RLL (unknown2, 0)
      FIELD_RLL (pages_map_crc_uncomp, 0)
      FIELD_RLL (unknown3, 0)
      FIELD_RLL (unknown4, 0)
      FIELD_RLL (unknown5, 0)
      FIELD_RLL (num_sections, 0)
      FIELD_RLL (sections_map_crc_uncomp, 0)
      FIELD_RLL (sections_map_size_comp, 0)
      FIELD_RLL (sections_map2_id, 0)
      FIELD_RLL (sections_map_id, 0)
      FIELD_RLL (sections_map_size_uncomp, 0)
      FIELD_RLL (sections_map_crc_comp, 0)
      FIELD_RLL (sections_map_correction, 0)
      FIELD_RLL (sections_map_crc_seed, 0)
      FIELD_RLL (stream_version, 0)
      FIELD_RLL (crc_seed, 0)
      FIELD_RLL (crc_seed_encoded, 0)
      FIELD_RLL (random_seed, 0)
      FIELD_RLL (header_crc, 0)
      // clang-format on
      // end of encrypted header
      else
      {
        LOG_ERROR ("Unknown %s.%s ignored", section, key);
        tokens->index++;
      }
    }

  LOG_TRACE ("End of %s\n", section)
  tokens->index--;
  return 0;
}

static int
json_R2004_Header (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,
                   jsmntokens_t *restrict tokens)
{
  const char *section = "R2004_Header";
  const jsmntok_t *t = &tokens->tokens[tokens->index];
  Dwg_R2004_Header *_obj = &dwg->r2004_header;
  int size;
  if (t->type != JSMN_OBJECT)
    {
      LOG_ERROR ("Unexpected %s at %u of %ld tokens, expected %s OBJECT",
                 t_typename[t->type], tokens->index, tokens->num_tokens,
                 section);
      json_advance_unknown (dat, tokens, t->type, 0);
      return DWG_ERR_INVALIDTYPE;
    }
  size = t->size;
  LOG_TRACE ("\n%s pos:%d [%d keys]\n--------------------\n", section,
             tokens->index, size);
  tokens->index++;
  for (int i = 0; i < size; i++)
    {
      char key[80];
      JSON_TOKENS_CHECK_OVERFLOW_ERR
      json_fixed_key (key, dat, tokens);
      t = &tokens->tokens[tokens->index];

      // FIELD_TFFx (file_ID_string, 12, 0) //pre-allocated
      if (strEQc (key, "file_ID_string"))
        {
          char *s = json_fixed_string (dat, 11, tokens);
          JSON_TOKENS_CHECK_OVERFLOW_ERR
          if (s)
            memcpy (&_obj->file_ID_string, s, 12);
          else
            {
              LOG_ERROR ("Invalid R2004_Header.file_ID_string")
              memcpy (&_obj->file_ID_string, "AcFssFcAJMB\0", 12);
            }
          LOG_TRACE ("file_ID_string: \"%.*s\"\n", 12, _obj->file_ID_string)
          free (s);
        }
      else if (strEQc (key, "padding"))
        {
          // just zeros encrypted */
          LOG_TRACE ("padding: \"%.*s\" (ignored)\n", t->end - t->start,
                     &dat->chain[t->start])
          tokens->index++;
        }
      // clang-format off
      FIELD_RLx (header_address, 0)
      FIELD_RL (header_size, 0)
      FIELD_RL (x04, 0)
      FIELD_RLd (root_tree_node_gap, 0)
      FIELD_RLd (lowermost_left_tree_node_gap, 0)
      FIELD_RLd (lowermost_right_tree_node_gap, 0)
      FIELD_RL (unknown_long, 0)
      FIELD_RL (last_section_id, 0)
      FIELD_RLL (last_section_address, 0)
      FIELD_RLL (secondheader_address, 0)
      FIELD_RL (numgaps, 0)
      FIELD_RL (numsections, 0)
      FIELD_RL (x20, 0)
      FIELD_RL (x80, 0)
      FIELD_RL (x40, 0)
      FIELD_RL (section_map_id, 0)
      FIELD_RLL (section_map_address, 0)
      FIELD_RL (section_info_id, 0)
      FIELD_RL (section_array_size, 0)
      FIELD_RL (gap_array_size, 0)
      FIELD_RLx (crc32, 0)
          // clang-format on
          // end of encrypted 0x6c header
          else
      {
        LOG_ERROR ("Unknown %s.%s ignored", section, key);
        tokens->index++;
      }
    }

  LOG_TRACE ("End of %s\n", section)
  tokens->index--;
  return 0;
}

static int
json_AuxHeader (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,
                jsmntokens_t *restrict tokens)
{
  const char *section = "AuxHeader";
  const jsmntok_t *t = &tokens->tokens[tokens->index];
  Dwg_AuxHeader *_obj = &dwg->auxheader;
  int size;
  if (t->type != JSMN_OBJECT)
    {
      LOG_ERROR ("Unexpected %s at %u of %ld tokens, expected %s OBJECT",
                 t_typename[t->type], tokens->index, tokens->num_tokens,
                 section);
      json_advance_unknown (dat, tokens, t->type, 0);
      return DWG_ERR_INVALIDTYPE;
    }
  size = t->size;
  LOG_TRACE ("\n%s pos:%d [%d keys]\n--------------------\n", section,
             tokens->index, size);
  tokens->index++;
  for (int i = 0; i < size; i++)
    {
      char key[80];
      JSON_TOKENS_CHECK_OVERFLOW_ERR
      json_fixed_key (key, dat, tokens);
      t = &tokens->tokens[tokens->index];

      // clang-format off
      if (0) ; // else
      FIELD_VECTOR_INL (aux_intro, RC, 3, 0)
      FIELD_RSx (dwg_version, 0)
      FIELD_RL (maint_version, 0)
      FIELD_RL (numsaves, 0)
      FIELD_RL (minus_1, 0)
      FIELD_RS (numsaves_1, 0)
      FIELD_RS (numsaves_2, 0)
      FIELD_RL (zero, 0)
      FIELD_RSx (dwg_version_1, 0)
      FIELD_RL (maint_version_1, 0)
      FIELD_RSx (dwg_version_2, 0)
      FIELD_RL (maint_version_2, 0)
      FIELD_VECTOR_INL (unknown_6rs, RS, 6, 0)
      FIELD_VECTOR_INL (unknown_5rl, RL, 5, 0)
      FIELD_TIMERLL (TDCREATE, 0)
      FIELD_TIMERLL (TDUPDATE, 0)
      FIELD_RLx (HANDSEED, 0)
      FIELD_RL (plot_stamp, 0)
      FIELD_RS (zero_1, 0)
      FIELD_RS (numsaves_3, 0)
      FIELD_RL (zero_2, 0)
      FIELD_RL (zero_3, 0)
      FIELD_RL (zero_4, 0)
      FIELD_RL (numsaves_4, 0)
      FIELD_RL (zero_5, 0)
      FIELD_RL (zero_6, 0)
      FIELD_RL (zero_7, 0)
      FIELD_RL (zero_8, 0)
      FIELD_VECTOR_INL (zero_18, RS, 3, 0)
          // clang-format on
          else
      {
        LOG_ERROR ("Unknown %s.%s ignored", section, key);
        tokens->index++;
      }
    }

  LOG_TRACE ("End of %s\n", section)
  tokens->index--;
  return 0;
}

// the below code fragment can be found in:
// test/unit-testing/dxf_test.c
static int
test_dxf (const struct _unknown_dxf *dxf, const char *restrict name,
          const char *restrict dwgfile)
{
  int error = 0;
  static char prev_dwgfile[128];
  static Dwg_Data dwg;
  BITCODE_BL i;
  char *trace;
  int tracelevel = 0;

  trace = getenv ("LIBREDWG_TRACE");
  if (trace)
    tracelevel = atoi (trace);

  loglevel = is_make_silent () ? 0 : MAX (tracelevel, 2);
  LOG_TRACE ("%s %X %s\n", dxf->name, dxf->handle, dwgfile);
  num = passed = failed = 0;

  if (dwg.num_objects && strEQ (dwgfile, prev_dwgfile))
    ;
  else
    {
      if (dwg.num_objects && dwg.header.version > R_INVALID)
        dwg_free (&dwg);
      dwg.opts = tracelevel;
      if (dwg_read_file (dwgfile, &dwg) >= DWG_ERR_CRITICAL)
        {
          dwg_free (&dwg);
          return 1;
        }
    }
  strcpy (prev_dwgfile, dwgfile);

  // find the object
  for (i = 0; i < dwg.num_objects; i++)
    {
      if (dwg.object[i].handle.value == dxf->handle)
        {
          if (dwg.object[i].fixedtype >= DWG_TYPE_UNKNOWN_ENT)
            break;
          if (strNE (dwg.object[i].dxfname, dxf->name))
            LOG_WARN ("Invalid handle 0x%X for %s", dxf->handle, dxf->name)
          else
            error += test_object (&dwg, &dwg.object[i], dxf, name);
          break;
        }
    }
  /* This value is the return value for `main',
     so clamp it to either 0 or 1.  */
  return error ? 1 : 0;
}

