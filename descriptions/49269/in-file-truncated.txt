/**
** @file mruby/bigint.c - Multi-precision Integer
**
** See Copyright Notice in mruby.h
*/

#include <mruby.h>
#include <mruby/object.h>
#include <mruby/numeric.h>
#include <mruby/array.h>
#include <mruby/string.h>
#include <mruby/internal.h>
#include <string.h>
#include "bigint.h"

static void
mpz_init(mrb_state *mrb, mpz_t *s)
{
  s->p = NULL;
  s->sn=0;
  s->sz=0;
}

static void
mpz_init_set(mrb_state *mrb, mpz_t *s, mpz_t *t)
{
  s->p = (mp_limb*)mrb_malloc(mrb, sizeof(mp_limb)*t->sz);
  for (size_t i=0; i < t->sz; i++)
    (s->p)[i] = (t->p)[i];

  s->sn = t->sn;
  s->sz = t->sz;
}

static void
mpz_realloc(mrb_state *mrb, mpz_t *x, size_t size)
{
  if (x->sz < size) {
    x->p=(mp_limb*)mrb_realloc(mrb,x->p,size * sizeof(mp_limb));
    for (size_t i=x->sz; i<size; i++)
      (x->p)[i] = 0;
    x->sz = size;
  }
}

static void
mpz_set_int(mrb_state *mrb, mpz_t *y, mrb_int v)
{
  mp_limb u;
  size_t len;

  if (v == 0) {
    y->sn=0;
    u = 0;
  }
  else if (v > 0) {
    y->sn = 1;
    u = v;
  }
  if (v < 0) {
    y->sn = -1;
    if (v == MRB_INT_MIN) u = v;
    else u = -v;
  }
  if ((u & LC) == 0) len = 1;
  else len = 2;
  mpz_realloc(mrb, y, len);
  y->p[0] = u & LMAX;
  if (len > 1) y->p[1] = (u & LC) >> DIGITBITS;
}

static void
mpz_init_set_int(mrb_state *mrb, mpz_t *y, mrb_int v)
{
  mpz_init(mrb, y);
  mpz_set_int(mrb, y, v);
}

static void
mpz_clear(mrb_state *mrb, mpz_t *s)
{
  if (s->p)
    mrb_free(mrb, s->p);
  s->p=NULL;
  s->sn=0;


// --- CODE TRUNCATED HERE ---

static size_t
digits(mpz_t *number)
{
  // This function returns the number of significant digits in a multi-precision integer.
  // <MASK>
}