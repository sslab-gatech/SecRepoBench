// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// mrbgems/mruby-bigint/core/bigint.c
static int
mpz_sizeinbase(mpz_t *x, int base)
{
  int i,j;
  size_t bits = digits(x) * DIGITBITS;
  mrb_assert(2 <= base && base <= 36);
  for (j=0,i=1; i<=base; i*=2,j++)
    ;
  return (int)((bits)/(j-1)+1);
}

// the below code fragment can be found in:
// mrbgems/mruby-bigint/core/bigint.c
static int
lzb(mp_limb x)
{
#if (defined(__GNUC__) || __has_builtin(__builtin_clz))
  /* subtract 2 because DIGITBITS = LONGBITS-2 */
  if (sizeof(mp_limb) == sizeof(long long))
    return __builtin_clzll(x)-2;
  else if (sizeof(mp_limb) == sizeof(int))
    return __builtin_clz(x)-2;
#endif

  mp_limb i; int j=0;

  for (i = ((mp_limb)1 << (DIGITBITS-1)); i && !(x&i) ; j++,i>>=1)
    ;
  return j;
}

// the below code fragment can be found in:
// mrbgems/mruby-bigint/core/bigint.c
static int
uzero(mpz_t *x)
{
  for (size_t i=0; i < x->sz; i++)
    if ((x->p)[i] != 0)
      return 0;
  return 1;
}

// the below code fragment can be found in:
// mrbgems/mruby-bigint/core/bigint.c
static int
mpz_get_int(mpz_t *y, mrb_int *v)
{
  mp_limb i;
  size_t d;

  if (y->sn == 0) {
    i = 0;
  }
  else if ((d = digits(y)) > 2 || (d == 2 && y->p[1] > 1)) {
    return FALSE;
  }
  else if (d == 2) {
    i = (y->sn * (y->p[0] | (y->p[1] & 1) << DIGITBITS));
  }
  else {/* d == 1 */
    i = y->sn * y->p[0];
  }
  if (MRB_INT_MAX < i || i < MRB_INT_MIN) return FALSE;
  *v = i;
  return TRUE;
}

// the below code fragment can be found in:
// mrbgems/mruby-bigint/core/bigint.c
static char*
mpz_get_str(mrb_state *mrb, char *s, mrb_int sz, mrb_int base, mpz_t *x)
{
  mrb_assert(2 <= base && base <= 36);
  if (uzero(x)) {
    *s='0';
    *(s+1)='\0';
    return s;
  }

  char *ps = s;
  char *se = s+sz;
  int xlen = digits(x);
  mp_limb *t = (mp_limb*)mrb_malloc(mrb, xlen*sizeof(mp_limb));
  memcpy(t, x->p, xlen*sizeof(mp_limb));
  mp_limb b2 = base;
  const int blim = (sizeof(mp_limb)==sizeof(int))?(base<=10?4:3):(base<=10?9:5);
  for (int i=1; i<blim; i++) {
    b2 *= base;
  }

  for (;;) {
    mp_limb *d = t + xlen;
    mp_limb a = 0;
    while (--d >= t) {
      mp_limb d0 = *d, d1;
      a = (a<<HALFDIGITBITS) | HIGH(d0);
      d1 = (a / b2) << HALFDIGITBITS;
      a %= b2;
      a = (a<<HALFDIGITBITS) | LOW(d0);
      d1 |= a / b2;
      a %= b2;
      *d = d1;
    }

    // convert to character
    for (int i=0; i<blim; i++) {
      mp_limb a0 = a % base;
      if (a0 < 10) a0 += '0';
      else a0 += 'a' - 10;
      if (s == se) break;
      *s++ = (char)a0;
      a /= base;
    }

    // check if number is zero
    for (d = t; d < t + xlen; ++d) {
      if (*d != 0) break;
      while (ps<s && s[-1]=='0') s--;
      goto done;
    }
  }

 done:
  mrb_free(mrb, t);
  if (x->sn < 0) {
    *s++ = '-';
  }

  /* reverse string */
  for (char *u = ps, *v = s - 1; u < v; ++u, --v) {
    char temp = *u;
    *u = *v;
    *v = temp;
  }
  *s = '\0'; /* null termination */
  return ps;
}

