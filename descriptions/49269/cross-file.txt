// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// mrbgems/mruby-bigint/core/bigint.c
static int
mpz_init_set_str(mrb_state *mrb, mpz_t *x, const char *s, mrb_int len, mrb_int base)
{
  int retval = 0;
  mpz_t t,m,bb;
  short sn;
  unsigned int k;
  mpz_init(mrb,x);
  mpz_init_set_int(mrb,&m,1);
  mpz_init(mrb,&t);
  zero(x);
  if (*s == '-') {
    sn = -1; s++;
  }
  else if (base < 0) {          /* trick: negative if base < 0 */
    sn = -1; base = -base;
  }
  else
    sn = 1;
  mpz_init_set_int(mrb,&bb, base);
  for (mrb_int i = len-1; i>=0; i--) {
    if (s[i]=='_') continue;
    if (s[i] >= '0' && s[i] <= '9')
      k = (unsigned int)s[i] - (unsigned int)'0';
    else if (s[i] >= 'A' && s[i] <= 'Z')
      k = (unsigned int)s[i] - (unsigned int)'A'+10;
    else if (s[i] >= 'a' && s[i] <= 'z')
      k = (unsigned int)s[i] - (unsigned int)'a'+10;
    else {
      retval = (-1);
      break;
    }
    if (k >= base) {
      retval = (-1);
      break;
    }
    mpz_mul_int(mrb,&t,&m,(mrb_int)k);
    mpz_add(mrb,x,x,&t);
    mpz_mul(mrb,&m,&m,&bb);
  }
  if (x->sn)
    x->sn = sn;
  mpz_clear(mrb,&m);
  mpz_clear(mrb,&bb);
  mpz_clear(mrb,&t);
  return retval;
}

// the below code fragment can be found in:
// mrbgems/mruby-bigint/core/bigint.c
static void
uadd(mrb_state *mrb, mpz_t *z, mpz_t *x, mpz_t *y)
{
  mp_limb c;
  size_t i;
  mpz_t *t;

  if (y->sz < x->sz) {
    t=x; x=y; y=t;
  }

  /* now y->sz >= x->sz */

  mpz_realloc(mrb, z, (size_t)((y->sz)+1));

  c=0;
  for (i=0; i<x->sz; i++) {
    if ((z->p[i] = y->p[i] + x->p[i] + c) & CMASK) {
      c=1;
      (z->p[i]) &=LMAX;
    }
    else
      c=0;
  }
  for (;i<y->sz; i++) {
    if ((z->p[i] = (y->p[i] + c)) & CMASK)
      z->p[i]=0;
    else
      c=0;
  }
  (z->p)[y->sz]=c;
}

// the below code fragment can be found in:
// mrbgems/mruby-bigint/core/bigint.c
static void
mpz_add(mrb_state *mrb, mpz_t *zz, mpz_t *x, mpz_t *y)
{
  int mg;
  mpz_t z;
  if (x->sn == 0) {
    mpz_set(mrb, zz, y);
    return;
  }
  if (y->sn == 0) {
    mpz_set(mrb, zz, x);
    return;
  }
  mpz_init(mrb, &z);

  if (x->sn > 0 && y->sn > 0) {
    uadd(mrb, &z, x, y);
    z.sn = 1;
  }
  else if (x->sn < 0 && y->sn < 0) {
    uadd(mrb, &z, x, y);
    z.sn = -1;
  }
  else {
    /* signs differ */
    if ((mg = ucmp(x,y)) == 0) {
      zero(&z);
    }
    else if (mg > 0) {  /* abs(y) < abs(x) */
      usub(mrb, &z, x, y);
      z.sn = (x->sn > 0 && y->sn < 0) ? 1 : (-1);
    }
    else { /* abs(y) > abs(x) */
      usub(mrb, &z, y, x);
      z.sn = (x->sn < 0 && y->sn > 0) ? 1 : (-1);
    }
  }
  mpz_set(mrb,zz,&z);
  mpz_clear(mrb,&z);
}

// the below code fragment can be found in:
// mrbgems/mruby-bigint/core/bigint.c
static void
mpz_div_2exp(mrb_state *mrb, mpz_t *z, mpz_t *x, mrb_int e)
{
  short sn = x->sn;
  if (e==0)
    mpz_set(mrb,z,x);
  else {
    size_t i;
    mp_limb digs = (e / DIGITBITS);
    size_t bs = (e % (DIGITBITS));
    mpz_t y;

    mpz_init(mrb,&y);
    mpz_realloc(mrb,&y,(size_t)((x->sz) - digs));
    for (i=0; i < (x->sz - digs); i++)
      (y.p)[i] = (x->p)[i+digs];
    if (bs) {
      urshift(mrb,z,&y,bs);
    }
    else {
      mpz_set(mrb,z,&y);
    }
    if (uzero(z))
      z->sn = 0;
    else
      z->sn = sn;
    mpz_clear(mrb,&y);
  }
}

// the below code fragment can be found in:
// mrbgems/mruby-bigint/core/bigint.c
static void
zero(mpz_t *x)
{
  x->sn=0;
  for (size_t i=0;i<x->sz;i++)
    (x->p)[i] = 0;
}

