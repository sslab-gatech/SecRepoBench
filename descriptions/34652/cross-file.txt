// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// mrbgems/mruby-sprintf/src/sprintf.c
static void
check_next_arg(mrb_state *mrb, int posarg, int nextarg)
{
  switch (posarg) {
  case -1:
    mrb_raisef(mrb, E_ARGUMENT_ERROR, "unnumbered(%d) mixed with numbered", nextarg);
    break;
  case -2:
    mrb_raisef(mrb, E_ARGUMENT_ERROR, "unnumbered(%d) mixed with named", nextarg);
    break;
  default:
    break;
  }
}

// the below code fragment can be found in:
// mrbgems/mruby-sprintf/src/sprintf.c
void
mrb_mruby_sprintf_gem_init(mrb_state *mrb)
{
  struct RClass *krn = mrb->kernel_module;
  mrb_define_module_function(mrb, krn, "sprintf", mrb_f_sprintf, MRB_ARGS_ANY());
  mrb_define_module_function(mrb, krn, "format",  mrb_f_sprintf, MRB_ARGS_ANY());
}

// the below code fragment can be found in:
// src/fmt_fp.c
MRB_API mrb_value
mrb_float_to_str(mrb_state *mrb, mrb_value flo)
{
  char buf[25];
#ifdef MRB_USE_FLOAT32
  const int prec =  7;
#else
  const int prec =  15;
#endif

  mrb_format_float(mrb_float(flo), buf, sizeof(buf), 'g', prec, '\0');
  for (char *p = buf; *p; p++) {
    if (*p == '.') goto exit;
    if (*p == 'e') {
      memmove(p+2, p, strlen(p)+1);
      memcpy(p, ".0", 2);
      goto exit;
    }
  }
  strcat(buf, ".0");
 exit:
  return mrb_str_new_cstr(mrb, buf);
}

// the below code fragment can be found in:
// src/strtod.c
MRB_API double
mrb_float_read(const char *str, char **end)
{
  double d = 0.0;
  int sign;
  int n = 0;
  const char *p, *a;

  a = p = str;
  while (ISSPACE(*p))
    ++p;

  /* decimal part */
  sign = 1;
  if (*p == '-') {
    sign = -1;
    ++p;
  } else if (*p == '+')
    ++p;
  if (ISDIGIT(*p)) {
    d = (double)(*p++ - '0');
    while (*p && ISDIGIT(*p)) {
      d = d * 10.0 + (double)(*p - '0');
      ++p;
      ++n;
    }
    a = p;
  } else if (*p != '.')
    goto done;
  d *= sign;

  /* fraction part */
  if (*p == '.') {
    double f = 0.0;
    double base = 0.1;
    ++p;

    if (ISDIGIT(*p))
      {
        while (*p && ISDIGIT(*p)) {
          f += base * (*p - '0') ;
          base /= 10.0;
          ++p;
          ++n;
        }
      }
    d += f * sign;
    a = p;
  }

  /* exponential part */
  if ((*p == 'E') || (*p == 'e')) {
    int e = 0;
    ++p;

    sign = 1;
    if (*p == '-') {
      sign = -1;
      ++p;
    } else if (*p == '+')
      ++p;

    if (ISDIGIT(*p)) {
      while (*p == '0')
        ++p;
      if (*p == '\0') --p;
      e = (int)(*p++ - '0');
      for (; *p && ISDIGIT(*p); p++) {
        if (e < 10000)
          e = e * 10 + (*p - '0');
      }
      e *= sign;
    }
    else if (!ISDIGIT(*(a-1))) {
      a = str;
      goto done;
    }
    else if (*p == 0)
      goto done;
    d *= pow(10.0, (double) e);
    a = p;
  }
  else if (p > str && !ISDIGIT(*(p-1))) {
    a = str;
    goto done;
  }

done:
  if (end)
    *end = (char*)a;
  return d;
}

// the below code fragment can be found in:
// mrbgems/mruby-string-ext/src/string.c
static mrb_value
mrb_str_succ(mrb_state *mrb, mrb_value self)
{
  mrb_value str;

  str = mrb_str_dup(mrb, self);
  mrb_str_succ_bang(mrb, str);
  return str;
}

