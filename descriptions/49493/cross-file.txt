// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// mrbgems/mruby-bigint/core/bigint.c
// static size_t
// mpz_sizeinbase(mpz_t *x, mrb_int base)
// {
//   size_t i, j;
// 
//   size_t bits = digits(x) * DIG_SIZE;
//   mrb_assert(2 <= base && base <= 36);
// 
//   if (x->sz == 0) return 0;
//   for (j=0,i=1; i<=base; i*=2,j++)
//     ;
//   return bits/(j-1)+1;
// }

// the below code fragment can be found in:
// mrbgems/mruby-bigint/core/bigint.c
// static void
// mpz_sub(mrb_state *mrb, mpz_t *z, mpz_t *x, mpz_t *y)
// {
//   mpz_t u;
// 
//   mpz_init(mrb, &u);
//   mpz_set(mrb, &u, y);
//   u.sn = -(u.sn);
//   mpz_add(mrb, z, x, &u);
//   mpz_clear(mrb, &u);
// }

// the below code fragment can be found in:
// mrbgems/mruby-bigint/core/bigint.c
// static int
// lzb(mp_limb x)
// {
// #if (defined(__GNUC__) || __has_builtin(__builtin_clz))
//   if (sizeof(mp_limb) == sizeof(int64_t))
//     return __builtin_clzll(x);
//   else if (sizeof(mp_limb) == sizeof(int32_t))
//     return __builtin_clz(x);
// #endif
// 
//   int j=0;
// 
//   for (mp_limb i = ((mp_limb)1 << (DIG_SIZE-1)); i && !(x&i) ; j++,i>>=1)
//     ;
//   return j;
// }

// the below code fragment can be found in:
// mrbgems/mruby-bigint/core/bigint.c
// static mrb_int
// mpz_cmp(mrb_state *mrb, mpz_t *x, mpz_t *y)
// {
//   int abscmp;
//   if (x->sn < 0 && y->sn > 0)
//     return (-1);
//   if (x->sn > 0 && y->sn < 0)
//     return 1;
//   abscmp=ucmp(x, y);
//   if (x->sn >=0 && y->sn >=0)
//     return abscmp;
//   return (-abscmp);          // if (x->sn <=0 && y->sn <=0)
// }

// the below code fragment can be found in:
// mrbgems/mruby-bigint/core/bigint.c
// static void
// mpz_and(mrb_state *mrb, mpz_t *z, mpz_t *x, mpz_t *y) /* not the most efficient way to do this */
// {
//   size_t sz = imin(x->sz, y->sz);
// 
//   mpz_realloc(mrb, z, sz);
//   for (size_t i=0; i < sz; i++)
//     z->p[i] = x->p[i] & y->p[i];
//   if (x->sn < 0 && y->sn < 0)
//     z->sn = (-1);
//   else
//     z->sn = 1;
//   if (uzero(z))
//     z->sn = 0;
// }

