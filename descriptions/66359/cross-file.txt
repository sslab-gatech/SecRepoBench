// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/filters/reframe_mhas.c
// static Bool mhas_dmx_process_event(GF_Filter *filter, const GF_FilterEvent *evt)
// {
// 	u32 i;
// 	GF_FilterEvent fevt;
// 	GF_MHASDmxCtx *ctx = gf_filter_get_udta(filter);
// 
// 	if (evt->base.on_pid != ctx->opid) return GF_TRUE;
// 
// 	switch (evt->base.type) {
// 	case GF_FEVT_PLAY:
// 		if (!ctx->is_playing) {
// 			ctx->is_playing = GF_TRUE;
// 		}
// 		if (! ctx->is_file) {
// 			if (evt->play.start_range || ctx->initial_play_done) {
// 				ctx->mhas_buffer_size = 0;
// 				ctx->resume_from = 0;
// 			}
// 			ctx->initial_play_done = GF_TRUE;
// 			return GF_FALSE;
// 		}
// 		mhas_dmx_check_dur(filter, ctx);
// 
// 		ctx->start_range = evt->play.start_range;
// 		ctx->in_seek = GF_TRUE;
// 		ctx->file_pos = 0;
// 		if (ctx->start_range) {
// 			for (i=1; i<ctx->index_size; i++) {
// 				if (ctx->indexes[i].duration>ctx->start_range) {
// 					ctx->cts = (u64) (ctx->indexes[i-1].duration * ctx->sample_rate);
// 					ctx->file_pos = ctx->indexes[i-1].pos;
// 					break;
// 				}
// 			}
// 		}
// 		if (!ctx->initial_play_done) {
// 			ctx->initial_play_done = GF_TRUE;
// 			//seek will not change the current source state, don't send a seek
// 			if (!ctx->file_pos)
// 				return GF_TRUE;
// 		}
// 		ctx->mhas_buffer_size = 0;
// 		ctx->resume_from = 0;
// 		//post a seek
// 		GF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, ctx->ipid);
// 		fevt.seek.start_offset = ctx->file_pos;
// 		gf_filter_pid_send_event(ctx->ipid, &fevt);
// 
// 		//cancel event
// 		return GF_TRUE;
// 
// 	case GF_FEVT_STOP:
// 		ctx->is_playing = GF_FALSE;
// 		if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);
// 		ctx->src_pck = NULL;
// 		ctx->cts = 0;
// 		//don't cancel event
// 		return GF_FALSE;
// 
// 	case GF_FEVT_SET_SPEED:
// 		//cancel event
// 		return GF_TRUE;
// 	default:
// 		break;
// 	}
// 	//by default don't cancel event - to rework once we have downloading in place
// 	return GF_FALSE;
// }

// the below code fragment can be found in:
// src/filters/reframe_nalu.c
// static Bool naludmx_process_event(GF_Filter *filter, const GF_FilterEvent *evt)
// {
// 	u32 i;
// 	u64 file_pos = 0;
// 	GF_FilterEvent fevt;
// 	GF_NALUDmxCtx *ctx = gf_filter_get_udta(filter);
// 
// 	switch (evt->base.type) {
// 	case GF_FEVT_PLAY:
// 		if (!ctx->is_playing) {
// 			ctx->is_playing = GF_TRUE;
// 			ctx->cts = ctx->dts = 0;
// 		}
// 		if (! ctx->is_file) {
// 			if (!ctx->initial_play_done) {
// 				ctx->initial_play_done = GF_TRUE;
// 				if (evt->play.start_range<0.1)
// 					return GF_FALSE;
// 			}
// 			ctx->resume_from = 0;
// 			ctx->nal_store_size = 0;
// 			return GF_FALSE;
// 		}
// 		if (ctx->start_range && (ctx->index<0)) {
// 			ctx->index = -ctx->index;
// 			ctx->file_loaded = GF_FALSE;
// 			ctx->duration.den = ctx->duration.num = 0;
// 			GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, ("[%s] Play request from %d, building index\n", ctx->log_name, ctx->start_range));
// 			naludmx_check_dur(filter, ctx);
// 		}
// 		ctx->start_range = evt->play.start_range;
// 		ctx->in_seek = GF_TRUE;
// 
// 		if (ctx->start_range) {
// 			ctx->nb_nalus = ctx->nb_i = ctx->nb_p = ctx->nb_b = ctx->nb_sp = ctx->nb_si = ctx->nb_sei = ctx->nb_idr = ctx->nb_cra = 0;
// 			for (i=1; i<ctx->index_size; i++) {
// 				if (ctx->indexes[i].duration>ctx->start_range) {
// 					ctx->cts = (u64) (ctx->indexes[i-1].duration * ctx->cur_fps.num);
// 					ctx->dts = ctx->dts_last_IDR = ctx->cts;
// 					file_pos = ctx->indexes[i-1].pos;
// 					ctx->seek_gdr_count = ctx->indexes[i-1].roll_count;
// 					if (ctx->seek_gdr_count) ctx->first_gdr = GF_TRUE;
// 					break;
// 				}
// 			}
// 		}
// 		if (!ctx->initial_play_done) {
// 			ctx->initial_play_done = GF_TRUE;
// 			//seek will not change the current source state, don't send a seek
// 			if (!file_pos) {
// 				//very short streams, input is done before we get notified for play and everything stored in memory: flush
// 				if (gf_filter_pid_is_eos(ctx->ipid) && (ctx->nal_store_size)) {
// 					gf_filter_post_process_task(filter);
// 				}
// 				return GF_TRUE;
// 			}
// 		}
// 		ctx->nb_frames = 0;
// 		ctx->nb_nalus = 0;
// 		ctx->resume_from = 0;
// 		ctx->nal_store_size = 0;
// 
// 		//post a seek
// 		GF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, ctx->ipid);
// 		fevt.seek.start_offset = file_pos;
// 		gf_filter_pid_send_event(ctx->ipid, &fevt);
// 
// 		//cancel event
// 		return GF_TRUE;
// 
// 	case GF_FEVT_STOP:
// 		//don't cancel event
// 		ctx->is_playing = GF_FALSE;
// 		ctx->nal_store_size = 0;
// 		ctx->resume_from = 0;
// 		ctx->cts = 0;
// 		return GF_FALSE;
// 
// 	case GF_FEVT_SET_SPEED:
// 		//cancel event
// 		return GF_TRUE;
// 	default:
// 		break;
// 	}
// 	//by default don't cancel event - to rework once we have downloading in place
// 	return GF_FALSE;
// }

// the below code fragment can be found in:
// src/filters/reframe_av1.c
// GF_Err av1dmx_parse_ivf(GF_Filter *filter, GF_AV1DmxCtx *ctx)
// {
// 	GF_Err e;
// 	u32 pck_size;
// 	u64 frame_size = 0, pts = GF_FILTER_NO_TS;
// 	GF_FilterPacket *pck;
// 	u64 pos=0, pos_ivf_hdr=0;
// 	u8 *output;
// 
// 	if (ctx->bsmode==IVF) {
// 		pos_ivf_hdr = gf_bs_get_position(ctx->bs);
// 		e = gf_media_parse_ivf_frame_header(ctx->bs, &frame_size, &pts);
// 		if (e) return e;
// 
// 		pos = gf_bs_get_position(ctx->bs);
// 		if (gf_bs_available(ctx->bs) < frame_size) {
// 			gf_bs_seek(ctx->bs, pos_ivf_hdr);
// 			return GF_EOS;
// 		}
// 		if (ctx->pts_from_file) {
// 			pts *= ctx->cur_fps.den;
// 			pts += ctx->cumulated_dur;
// 			if (ctx->last_pts && (ctx->last_pts>pts)) {
// 				pts -= ctx->cumulated_dur;
// 				GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, ("[IVF/AV1] Corrupted timestamp "LLU" less than previous timestamp "LLU", assuming concatenation\n", pts, ctx->last_pts));
// 				ctx->cumulated_dur = ctx->last_pts + ctx->cur_fps.den;
// 				ctx->cumulated_dur -= pts;
// 				pts = ctx->cumulated_dur;
// 			}
// 			ctx->last_pts = pts;
// 		}
// 	} else {
// 		//raw framed input, each packet is a frame
// 		pts = ctx->src_pck ? gf_filter_pck_get_cts(ctx->src_pck) : 0;
// 		pos = 0;
// 		frame_size = gf_bs_available(ctx->bs);
// 	}
// 
// 	//check pid state
// 	av1dmx_check_pid(filter, ctx);
// 
// 	if (!ctx->opid) {
// 		return GF_OK;
// 	}
// 
// 	if (!ctx->is_playing) {
// 		gf_bs_seek(ctx->bs, pos_ivf_hdr);
// 		return GF_EOS;
// 	}
// 
// 	pck_size = (u32)frame_size;
// 	pck = gf_filter_pck_new_alloc(ctx->opid, pck_size, &output);
// 	if (!pck) {
// 		gf_bs_seek(ctx->bs, pos_ivf_hdr);
// 		return GF_OUT_OF_MEM;
// 	}
// 	if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, pck);
// 
// 	if (ctx->pts_from_file) {
// 		gf_filter_pck_set_cts(pck, pts);
// 	} else {
// 		gf_filter_pck_set_cts(pck, ctx->cts);
// 	}
// 
// 	gf_bs_seek(ctx->bs, pos);
// 	gf_bs_read_data(ctx->bs, output, pck_size);
// 
// 	if (output[0] & 0x80)
// 		gf_filter_pck_set_sap(pck, GF_FILTER_SAP_1);
// 	else
// 		gf_filter_pck_set_sap(pck, GF_FILTER_SAP_NONE);
// 
// 	gf_filter_pck_send(pck);
// 
// 	av1dmx_update_cts(ctx);
// 	return GF_OK;
// }

// the below code fragment can be found in:
// src/filters/reframe_prores.c
// GF_Err proresdmx_process_buffer(GF_Filter *filter, GF_ProResDmxCtx *ctx, const u8 *data, u32 data_size, Bool is_copy)
// {
// 	u32 last_frame_end = 0;
// 	GF_Err e = GF_OK;
// 
// 	if (!ctx->bs) ctx->bs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);
// 	else gf_bs_reassign_buffer(ctx->bs, data, data_size);
// 
// 	while (gf_bs_available(ctx->bs)) {
// 		u8 *output;
// 		GF_FilterPacket *pck;
// 		GF_ProResFrameInfo finfo;
// 		e = gf_media_prores_parse_bs(ctx->bs, &finfo);
// 
// 		if (e) {
// 			break;
// 		}
// 		proresdmx_check_pid(filter, ctx, &finfo);
// 
// 		if (!ctx->is_playing && ctx->opid)
// 			break;
// 
// 		if (gf_bs_available(ctx->bs)<finfo.frame_size)
// 			break;
// 
// 		pck = gf_filter_pck_new_alloc(ctx->opid, finfo.frame_size, &output);
// 		if (!pck) break;
// 		gf_bs_read_data(ctx->bs, output, finfo.frame_size);
// 
// 		if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, pck);
// 
// 		gf_filter_pck_set_dts(pck, ctx->cts);
// 		gf_filter_pck_set_cts(pck, ctx->cts);
// 		gf_filter_pck_set_sap(pck, GF_FILTER_SAP_1);
// 		gf_filter_pck_set_byte_offset(pck, ctx->file_pos);
// 
// 		gf_filter_pck_send(pck);
// 		proresdmx_update_cts(ctx);
// 		last_frame_end = (u32) gf_bs_get_position(ctx->bs);
// 
// 		if (ctx->rewind) {
// 			ctx->buf_size = 0;
// 			last_frame_end = 0;
// 			if (ctx->cur_frame) ctx->cur_frame--;
// 			if (!ctx->cur_frame) {
// 				if (ctx->opid)
// 					gf_filter_pid_set_eos(ctx->opid);
// 			} else {
// 				GF_FilterEvent fevt;
// 				ctx->file_pos -= ctx->frame_sizes[ctx->cur_frame];
// 				//post a seek
// 				GF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, ctx->ipid);
// 				fevt.seek.start_offset = ctx->file_pos;
// 				gf_filter_pid_send_event(ctx->ipid, &fevt);
// 			}
// 			break;
// 		} else {
// 			ctx->file_pos += finfo.frame_size;
// 		}
// 	}
// 
// 	if (is_copy && last_frame_end) {
// 		gf_assert(ctx->buf_size >= last_frame_end);
// 		memmove(ctx->buffer, ctx->buffer+last_frame_end, sizeof(char) * (ctx->buf_size-last_frame_end));
// 		ctx->buf_size -= last_frame_end;
// 	}
// 	if (e==GF_EOS) return GF_OK;
// 	if (e==GF_BUFFER_TOO_SMALL) return GF_OK;
// 	return e;
// }

// the below code fragment can be found in:
// src/filters/reframe_flac.c
// static Bool flac_dmx_process_event(GF_Filter *filter, const GF_FilterEvent *evt)
// {
// 	u32 i;
// 	GF_FilterEvent fevt;
// 	GF_FLACDmxCtx *ctx = gf_filter_get_udta(filter);
// 
// 	if (evt->base.on_pid != ctx->opid) return GF_TRUE;
// 
// 	switch (evt->base.type) {
// 	case GF_FEVT_PLAY:
// 		if (!ctx->is_playing) {
// 			ctx->is_playing = GF_TRUE;
// 		}
// 		if (! ctx->is_file) {
// 			if (evt->play.start_range || ctx->initial_play_done) {
// 				ctx->flac_buffer_size = 0;
// 				ctx->resume_from = 0;
// 			}
// 			ctx->initial_play_done = GF_TRUE;
// 			return GF_FALSE;
// 		}
// 		flac_dmx_check_dur(filter, ctx);
// 
// 		ctx->start_range = evt->play.start_range;
// 		ctx->in_seek = GF_TRUE;
// 		ctx->file_pos = 0;
// 		if (ctx->start_range) {
// 			for (i=1; i<ctx->index_size; i++) {
// 				if (ctx->indexes[i].duration>ctx->start_range) {
// 					ctx->cts = (u64) (ctx->indexes[i-1].duration * ctx->sample_rate);
// 					ctx->file_pos = ctx->indexes[i-1].pos;
// 					break;
// 				}
// 			}
// 		}
// 		if (!ctx->initial_play_done) {
// 			ctx->initial_play_done = GF_TRUE;
// 			//seek will not change the current source state, don't send a seek
// 			if (!ctx->file_pos)
// 				return GF_TRUE;
// 		}
// 		ctx->flac_buffer_size = 0;
// 		ctx->resume_from = 0;
// 		//post a seek
// 		GF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, ctx->ipid);
// 		fevt.seek.start_offset = ctx->file_pos;
// 		gf_filter_pid_send_event(ctx->ipid, &fevt);
// 
// 		//cancel event
// 		return GF_TRUE;
// 
// 	case GF_FEVT_STOP:
// 		ctx->is_playing = GF_FALSE;
// 		if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);
// 		ctx->src_pck = NULL;
// 		ctx->cts = 0;
// 		//don't cancel event
// 		return GF_FALSE;
// 
// 	case GF_FEVT_SET_SPEED:
// 		//cancel event
// 		return GF_TRUE;
// 	default:
// 		break;
// 	}
// 	//by default don't cancel event - to rework once we have downloading in place
// 	return GF_FALSE;
// }

