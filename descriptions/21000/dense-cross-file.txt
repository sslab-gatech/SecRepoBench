// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/lib/protocols/capwap.c
void ndpi_search_capwap(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow)
{
  struct ndpi_packet_struct *packet = &flow->packet;

  if(packet->udp && (packet->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN))
    ndpi_search_setup_capwap(ndpi_struct, flow);
}

// the below code fragment can be found in:
// src/lib/protocols/capwap.c
static void ndpi_int_capwap_add_connection(struct ndpi_detection_module_struct *ndpi_struct,
					   struct ndpi_flow_struct *flow) {
  ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_CAPWAP, NDPI_PROTOCOL_UNKNOWN);
}

// the below code fragment can be found in:
// src/lib/protocols/capwap.c
void init_capwap_dissector(struct ndpi_detection_module_struct *ndpi_struct,
			   u_int32_t *id, NDPI_PROTOCOL_BITMASK *detection_bitmask)
{
  ndpi_set_bitmask_protocol_detection("CAPWAP", ndpi_struct, detection_bitmask, *id,
				      NDPI_PROTOCOL_CAPWAP,
				      ndpi_search_capwap,
				      NDPI_SELECTION_BITMASK_PROTOCOL_UDP_WITH_PAYLOAD,
				      SAVE_DETECTION_BITMASK_AS_UNKNOWN,
				      ADD_TO_DETECTION_BITMASK);

  *id += 1;
}

// the below code fragment can be found in:
// src/lib/protocols/coap.c
void ndpi_search_coap (struct ndpi_detection_module_struct *ndpi_struct,
		       struct ndpi_flow_struct *flow)
{
  struct ndpi_packet_struct *packet = &flow->packet;
  struct ndpi_coap_hdr * h = (struct ndpi_coap_hdr*) packet->payload;

  if(packet->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN) {
    return;
  }

  // search for udp packet
  if(packet->udp != NULL) {
    u_int16_t s_port = ntohs(flow->packet.udp->source);
    u_int16_t d_port = ntohs(flow->packet.udp->dest);

    if((!isCoAPport(s_port) && !isCoAPport(d_port))
       || (packet->payload_packet_len < 4) ) {   // header too short
      NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
      return;
    }

    NDPI_LOG_DBG2(ndpi_struct, "calculating coap over udp\n");

    // check values in header
    if(h->version == 1) {
      if(h->type == CON || h->type == NO_CON || h->type == ACK || h->type == RST ) {
	if(h->tkl < 8) {
	  if((/* h->code >= 0 && */ h->code <= 5) || (h->code >= 65 && h->code <= 69) ||
	     (h->code >= 128  && h->code <= 134) || (h->code >= 140 && h->code <= 143) ||
	     (h->code >= 160 && h->code <= 165)) {

	    NDPI_LOG_INFO(ndpi_struct, "found Coap\n");
	    ndpi_int_coap_add_connection(ndpi_struct,flow);
	    return;
	  }
	}
      }
    }
  }

  NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
  return;
}

// the below code fragment can be found in:
// src/lib/protocols/rdp.c
void ndpi_search_rdp(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow)
{
  struct ndpi_packet_struct *packet = &flow->packet;
	
  NDPI_LOG_DBG(ndpi_struct, "search RDP\n");

  if (packet->payload_packet_len > 10
      && get_u_int8_t(packet->payload, 0) > 0
      && get_u_int8_t(packet->payload, 0) < 4 && get_u_int16_t(packet->payload, 2) == ntohs(packet->payload_packet_len)
      && get_u_int8_t(packet->payload, 4) == packet->payload_packet_len - 5
      && get_u_int8_t(packet->payload, 5) == 0xe0
      && get_u_int16_t(packet->payload, 6) == 0 && get_u_int16_t(packet->payload, 8) == 0 && get_u_int8_t(packet->payload, 10) == 0) {
    NDPI_LOG_INFO(ndpi_struct, "found RDP\n");
    ndpi_int_rdp_add_connection(ndpi_struct, flow);
    return;
  }

  NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
}

