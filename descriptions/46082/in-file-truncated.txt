/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*  Fluent Bit
 *  ==========
 *  Copyright (C) 2015-2022 The Fluent Bit Authors
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

#include <fluent-bit/flb_info.h>
#include <fluent-bit/flb_log.h>
#include <fluent-bit/flb_sds.h>
#include <fluent-bit/flb_mem.h>
#include <fluent-bit/flb_regex.h>
#include <fluent-bit/flb_ra_key.h>
#include <fluent-bit/record_accessor/flb_ra_parser.h>
#include <msgpack.h>
#include <limits.h>

/* Map msgpack object into flb_ra_value representation */
static int msgpack_object_to_ra_value(msgpack_object object,
                                      struct flb_ra_value *result)
{
    result->o = object;

    /* Compose result with found value */
    if (object.type == MSGPACK_OBJECT_BOOLEAN) {
        result->type = FLB_RA_BOOL;
        result->val.boolean = object.via.boolean;
        return 0;
    }
    else if (object.type == MSGPACK_OBJECT_POSITIVE_INTEGER ||
             object.type == MSGPACK_OBJECT_NEGATIVE_INTEGER) {
        result->type = FLB_RA_INT;
        result->val.i64 = object.via.i64;
        return 0;
    }
    else if (object.type == MSGPACK_OBJECT_FLOAT32 ||
             object.type == MSGPACK_OBJECT_FLOAT) {
        result->type = FLB_RA_FLOAT;
        result->val.f64 = object.via.f64;
        return 0;
    }
    else if 
    // Handle cases where the msgpack object is a string by setting the result type to FLB_RA_STRING
    // and creating a dynamic string copy of the msgpack string data.
    // If the msgpack object is a map, set the result type to FLB_RA_BOOL with a true value,
    // indicating the presence of the key.
    // If the msgpack object is nil, set the result type to FLB_RA_NULL to represent a null value.
    // <MASK>

    return -1;
}

/* Return the entry position of key/val in the map */
static int ra_key_val_id(flb_sds_t ckey, msgpack_object map)
{
    int i;
    int map_size;
    msgpack_object key;

// --- CODE TRUNCATED HERE ---

