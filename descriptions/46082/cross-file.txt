// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/stream_processor/flb_sp_key.c
static int subkey_to_value(msgpack_object *map, struct mk_list *subkeys,
                           struct flb_sp_value *result)
{
    int i = 0;
    int ret;
    int levels;
    int matched = 0;
    msgpack_object *key_found = NULL;
    msgpack_object key;
    msgpack_object val;
    msgpack_object cur_map;
    struct mk_list *head;
    struct flb_slist_entry *entry;

    /* Expected number of map levels in the map */
    levels = mk_list_size(subkeys);

    cur_map = *map;

    mk_list_foreach(head, subkeys) {
        /* Key expected key entry */
        entry = mk_list_entry(head, struct flb_slist_entry, _head);

        if (cur_map.type != MSGPACK_OBJECT_MAP) {
            break;
        }

        /* Get map entry that matches entry name */
        for (i = 0; i < cur_map.via.map.size; i++) {
            key = cur_map.via.map.ptr[i].key;
            val = cur_map.via.map.ptr[i].val;

            /* A bit obvious, but it's better to validate data type */
            if (key.type != MSGPACK_OBJECT_STR) {
                continue;
            }

            /* Compare strings by length and content */
            if (flb_sds_cmp(entry->str,
                            (char *) key.via.str.ptr,
                            key.via.str.size) != 0) {
                key_found = NULL;
                continue;
            }

            key_found = &key;
            cur_map = val;
            matched++;
            break;
        }

        if (levels == matched) {
            break;
        }
    }

    /* No matches */
    if (!key_found || (matched > 0 && levels != matched)) {
        return -1;
    }

    ret = msgpack_object_to_sp_value(val, result);
    if (ret == -1) {
        //flb_error("[sp key] cannot process key value");
        return -1;
    }

    return 0;
}

// the below code fragment can be found in:
// src/stream_processor/flb_sp.c
static bool value_to_bool(struct flb_exp_val *val) {
    bool result = FLB_FALSE;

    switch (val->type) {
    case FLB_EXP_BOOL:
        result = val->val.boolean;
        break;
    case FLB_EXP_INT:
        result = val->val.i64 > 0;
        break;
    case FLB_EXP_FLOAT:
        result = val->val.f64 > 0;
        break;
    case FLB_EXP_STRING:
        result = true;
        break;
    }

    return result;
}

// the below code fragment can be found in:
// src/flb_ra_key.c
int flb_ra_key_value_get(flb_sds_t ckey, msgpack_object map,
                         struct mk_list *subkeys,
                         msgpack_object **start_key,
                         msgpack_object **out_key, msgpack_object **out_val)
{
    int i;
    int ret;
    msgpack_object val;
    msgpack_object *o_key;
    msgpack_object *o_val;

    /* Get the key position in the map */
    i = ra_key_val_id(ckey, map);
    if (i == -1) {
        return -1;
    }

    /* Reference entries */
    *start_key = &map.via.map.ptr[i].key;
    val = map.via.map.ptr[i].val;

    if ((val.type == MSGPACK_OBJECT_MAP || val.type == MSGPACK_OBJECT_ARRAY)
        && subkeys != NULL && mk_list_size(subkeys) > 0) {
        ret = subkey_to_object(&val, subkeys, &o_key, &o_val);
        if (ret == 0) {
            *out_key = o_key;
            *out_val = o_val;
            return 0;
        }
    }
    else {
        *out_key = &map.via.map.ptr[i].key;
        *out_val = &map.via.map.ptr[i].val;
        return 0;
    }

    return -1;
}

// the below code fragment can be found in:
// src/stream_processor/flb_sp.c
int sp_process_data(const char *tag, int tag_len,
                    const char *buf_data, size_t buf_size,
                    char **out_buf, size_t *out_size,
                    struct flb_sp_task *task,
                    struct flb_sp *sp)
{
    int i;
    int ok;
    int ret;
    int map_size;
    int map_entries;
    int records;
    uint8_t h;
    off_t map_off;
    off_t no_data;
    size_t off;
    size_t off_copy;
    size_t snapshot_out_size;
    char *tmp;
    char *snapshot_out_buffer;
    msgpack_object root;
    msgpack_object *obj;
    msgpack_object key;
    msgpack_object val;
    msgpack_unpacked result;
    msgpack_sbuffer mp_sbuf;
    msgpack_packer mp_pck;
    msgpack_object map;
    struct flb_time tms;
    struct mk_list *head;
    struct flb_sp_cmd *cmd;
    struct flb_sp_cmd_key *cmd_key;
    struct flb_exp_val *condition;
    struct flb_sp_value *sval;

    /* Vars initialization */
    off = 0;
    off_copy = off;
    records = 0;
    cmd = task->cmd;
    ok = MSGPACK_UNPACK_SUCCESS;
    msgpack_unpacked_init(&result);
    msgpack_sbuffer_init(&mp_sbuf);
    msgpack_packer_init(&mp_pck, &mp_sbuf, msgpack_sbuffer_write);

    snapshot_out_size = 0;
    snapshot_out_buffer = NULL;

    /* Iterate incoming records */
    while (msgpack_unpack_next(&result, buf_data, buf_size, &off) == ok) {
        root = result.data;

        /* extract timestamp */
        flb_time_pop_from_msgpack(&tms, &result, &obj);

        /* Store the buffer if the stream is a snapshot */
        if (cmd->type == FLB_SP_CREATE_SNAPSHOT) {
            flb_sp_snapshot_update(task, buf_data + off_copy, off - off_copy, &tms);
            off_copy = off;
            continue;
        }

        /* get the map data and it size (number of items) */
        map   = root.via.array.ptr[1];
        map_size = map.via.map.size;

        /* Evaluate condition */
        if (cmd->condition) {
            condition = reduce_expression(cmd->condition,
                                          tag, tag_len, &tms, &map);
            if (!condition) {
                continue;
            }
            else if (!condition->val.boolean) {
                flb_free(condition);
                continue;
            }
            else {
                flb_free(condition);
            }
        }

        records++;

        /* Flush the snapshot if condition holds */
        if (cmd->type == FLB_SP_FLUSH_SNAPSHOT) {
            if (flb_sp_snapshot_flush(sp, task, &snapshot_out_buffer,
                                      &snapshot_out_size) == -1) {
                msgpack_unpacked_destroy(&result);
                msgpack_sbuffer_destroy(&mp_sbuf);
                return -1;
            }
            continue;
        }


        /*
         * If for some reason the Task keys did not insert any data, we will
         * need to discard any changes and reset the buffer position, let's
         * keep the memory size for that purpose.
         */
        no_data = mp_sbuf.size;

        /* Pack main array */
        msgpack_pack_array(&mp_pck, 2);
        msgpack_pack_object(&mp_pck, root.via.array.ptr[0]);

        /*
         * Save the current size/position of the buffer since this is
         * where the Map header will be stored.
         */
        map_off = mp_sbuf.size;

        /*
         * In the new record register the same number of items, if due to
         * fields selection the number is lower, we perform an adjustment
         */
        msgpack_pack_map(&mp_pck, map_size);

        /* Counter for new entries added to the outgoing map */
        map_entries = 0;

        /* Iterate key selection */
        mk_list_foreach(head, &cmd->keys) {
            cmd_key = mk_list_entry(head, struct flb_sp_cmd_key, _head);
            if (cmd_key->time_func > 0) {
                /* Process time function */
                ret = flb_sp_func_time(&mp_pck, cmd_key);
                if (ret > 0) {
                    map_entries += ret;
                }
                continue;
            }
            else if (cmd_key->record_func > 0) {
                ret = flb_sp_func_record(tag, tag_len, &tms, &mp_pck, cmd_key);
                if (ret > 0) {
                    map_entries += ret;
                }
                continue;
            }

            /* Lookup selection key in the incoming map */
            for (i = 0; i < map_size; i++) {
                key = map.via.map.ptr[i].key;
                val = map.via.map.ptr[i].val;

                if (key.type != MSGPACK_OBJECT_STR) {
                    continue;
                }

                /* Wildcard selection: * */
                if (cmd_key->name == NULL) {
                    msgpack_pack_object(&mp_pck, key);
                    msgpack_pack_object(&mp_pck, val);
                    map_entries++;
                    continue;
                }

                /* Compare lengths */
                if (flb_sds_cmp(cmd_key->name,
                                key.via.str.ptr, key.via.str.size) != 0) {
                    continue;
                }

                /*
                 * Package key name:
                 *
                 * Check if the command ask for an alias 'key AS abc'
                 */
                if (cmd_key->alias) {
                    msgpack_pack_str(&mp_pck,
                                     flb_sds_len(cmd_key->alias));
                    msgpack_pack_str_body(&mp_pck,
                                          cmd_key->alias,
                                          flb_sds_len(cmd_key->alias));
                }
                else {
                    msgpack_pack_object(&mp_pck, key);
                }

                /* Package value */
                sval = flb_sp_key_to_value(cmd_key->name, map,
                                           cmd_key->subkeys);
                if (sval) {
                    msgpack_pack_object(&mp_pck, sval->o);
                    flb_sp_key_value_destroy(sval);
                }

                map_entries++;
            }
        }

        /* Final Map size adjustment */
        if (map_entries == 0) {
            mp_sbuf.size = no_data;
        }
        else {
            /*
             * The fields were packed, now we need to adjust the map size
             * to set the proper number of fields appended to the record.
             */
            tmp = mp_sbuf.data + map_off;
            h = tmp[0];
            if (h >> 4 == 0x8) {
                *tmp = (uint8_t) 0x8 << 4 | ((uint8_t) map_entries);
            }
            else if (h == 0xde) {
                tmp++;
                pack_uint16(tmp, map_entries);
            }
            else if (h == 0xdf) {
                tmp++;
                pack_uint32(tmp, map_entries);
            }
        }
    }

    msgpack_unpacked_destroy(&result);

    if (records == 0) {
        msgpack_sbuffer_destroy(&mp_sbuf);
        return 0;
    }

    /* Use snapshot out buffer if it is flush stream */
    if (cmd->type == FLB_SP_FLUSH_SNAPSHOT) {
        if (snapshot_out_size == 0) {
            msgpack_sbuffer_destroy(&mp_sbuf);
            flb_free(snapshot_out_buffer);
            return 0;
        }
        else {
            *out_buf = snapshot_out_buffer;
            *out_size = snapshot_out_size;
            return records;
        }
    }

    /* set outgoing results */
    *out_buf = mp_sbuf.data;
    *out_size = mp_sbuf.size;

    return records;
}

// the below code fragment can be found in:
// src/stream_processor/flb_sp.c
void package_results(const char *tag, int tag_len,
                     char **out_buf, size_t *out_size,
                     struct flb_sp_task *task)
{
    int i;
    int len;
    int map_entries;
    msgpack_sbuffer mp_sbuf;
    msgpack_packer mp_pck;
    struct aggregate_num *num;
    struct flb_time tm;
    struct flb_sp_cmd_key *ckey;
    struct flb_sp_cmd *cmd = task->cmd;
    struct mk_list *head;
    struct aggregate_node *aggr_node;
    struct flb_sp_cmd_gb_key *gb_key = NULL;

    map_entries = mk_list_size(&cmd->keys);

    msgpack_sbuffer_init(&mp_sbuf);
    msgpack_packer_init(&mp_pck, &mp_sbuf, msgpack_sbuffer_write);

    mk_list_foreach(head, &task->window.aggregate_list) {
        aggr_node = mk_list_entry(head, struct aggregate_node, _head);

        /* set outgoing array + map and it fixed size */
        msgpack_pack_array(&mp_pck, 2);

        flb_time_get(&tm);
        flb_time_append_to_msgpack(&tm, &mp_pck, 0);
        msgpack_pack_map(&mp_pck, map_entries);

        /* Packaging results */
        ckey = mk_list_entry_first(&cmd->keys, struct flb_sp_cmd_key, _head);
        for (i = 0; i < map_entries; i++) {
            num = &aggr_node->nums[i];

            /* Check if there is a defined function */
            if (ckey->time_func > 0) {
                flb_sp_func_time(&mp_pck, ckey);
                goto next;
            }
            else if (ckey->record_func > 0) {
                flb_sp_func_record(tag, tag_len, &tm, &mp_pck, ckey);
                goto next;
            }

            /* Pack key */
            if (ckey->alias) {
                msgpack_pack_str(&mp_pck, flb_sds_len(ckey->alias));
                msgpack_pack_str_body(&mp_pck,
                                      ckey->alias,
                                      flb_sds_len(ckey->alias));
            }
            else {
                len = 0;
                char *c_name;
                if (!ckey->name) {
                    c_name = "*";
                }
                else {
                    c_name = ckey->name;
                }

                msgpack_pack_str(&mp_pck, len);
                msgpack_pack_str_body(&mp_pck, c_name, len);
            }

            /*
             * If a group_by key is mapped as a source of this key,
             * change the 'num' reference to obtain the proper information
             * for the grouped key value.
             */
            if (ckey->gb_key != NULL) {
                gb_key = ckey->gb_key;
                if (aggr_node->groupby_keys > 0) {
                    num = &aggr_node->groupby_nums[gb_key->id];
                }
            }

            /* Pack value */
            switch (ckey->aggr_func) {
            case FLB_SP_NOP:
                if (num->type == FLB_SP_NUM_I64) {
                    msgpack_pack_int64(&mp_pck, num->i64);
                }
                else if (num->type == FLB_SP_NUM_F64) {
                    msgpack_pack_float(&mp_pck, num->f64);
                }
                else if (num->type == FLB_SP_STRING) {
                    msgpack_pack_str(&mp_pck,
                                     flb_sds_len(num->string));
                    msgpack_pack_str_body(&mp_pck,
                                          num->string,
                                          flb_sds_len(num->string));
                }
                else if (num->type == FLB_SP_BOOLEAN) {
                    if (num->boolean) {
                        msgpack_pack_true(&mp_pck);
                    }
                    else {
                        msgpack_pack_false(&mp_pck);
                    }
                }
                break;
            default:
                aggregate_func_calc[ckey->aggr_func - 1](aggr_node, ckey, &mp_pck, i);
                break;
            }

next:
            ckey = mk_list_entry_next(&ckey->_head, struct flb_sp_cmd_key,
                                      _head, &cmd->keys);
        }
    }

    *out_buf = mp_sbuf.data;
    *out_size = mp_sbuf.size;
}

