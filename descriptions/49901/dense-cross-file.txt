// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/lib/protocols/softether.c
static size_t dissect_softether_tuples(u_int8_t const *payload, u_int16_t payload_len,
                                       struct softether_value *first_value,
                                       struct softether_value *second_value) {
  enum softether_value_type first_tuple_type;
  enum softether_value_type second_tuple_type;
  size_t value_siz;
  size_t const tuple_type_len = 8;

  if(payload_len < tuple_type_len)
    return 0;

  if(softether_type_to_enum(ntohl(get_u_int32_t(payload, 0)), &first_tuple_type) != 0 ||
     softether_type_to_enum(ntohl(get_u_int32_t(payload, 4)), &second_tuple_type) != 0)
    return 0;

  payload += tuple_type_len;
  payload_len -= tuple_type_len;

  value_siz = dissect_softether_type(first_tuple_type, first_value, payload, payload_len);

  payload += value_siz;
  payload_len -= value_siz;

  value_siz += dissect_softether_type(second_tuple_type, second_value, payload, payload_len);

  return value_siz + tuple_type_len;
}

// the below code fragment can be found in:
// src/lib/protocols/softether.c
static int dissect_softether_host_fqdn(struct ndpi_flow_struct *flow,
                                       struct ndpi_packet_struct const *packet) {
  u_int8_t const *payload = packet->payload;
  u_int16_t payload_len = packet->payload_packet_len;
  u_int32_t tuple_count;
  size_t value_siz;
  struct softether_value val1, val2;
  uint8_t got_hostname = 0, got_fqdn = 0;

  if(payload_len < 4)
    return 1;

  tuple_count = ntohl(get_u_int32_t(payload, 0));
  if(tuple_count == 0 || tuple_count * 8 > payload_len)
    return 1;

  payload += 4;
  payload_len -= 4;

  value_siz = dissect_softether_type(VALUE_DATA, &val1, payload, payload_len);
  if(value_siz == 0)
    return 1;

  payload += value_siz;
  payload_len -= value_siz;

  if(strncmp(val1.value.ptr.value_str, "host_name", value_siz) == 0)
    got_hostname = 1;

  for (; tuple_count > 0; --tuple_count) {
    value_siz = dissect_softether_tuples(payload, payload_len, &val1, &val2);
    if(value_siz == 0)
      break;

    if(got_hostname == 1) {
      if(val1.type == VALUE_STR && val1.value_size > 0) {
	size_t len = ndpi_min(val1.value_size, sizeof(flow->protos.softether.hostname) - 1);
	      
	strncpy(flow->protos.softether.hostname, val1.value.ptr.value_str, len);
	flow->protos.softether.hostname[len] = '\0';
      }
	  
      got_hostname = 0;
    }
    if(got_fqdn == 1) {
      if(val1.type == VALUE_STR && val1.value_size > 0)  {
	size_t len = ndpi_min(val1.value_size, sizeof(flow->protos.softether.fqdn) - 1);
	      
	strncpy(flow->protos.softether.fqdn, val1.value.ptr.value_str, len);
	flow->protos.softether.fqdn[len] = '\0';
      }
	  
      got_fqdn = 0;
    }

    if(val2.type == VALUE_DATA && val2.value_size > 0 &&
       strncmp(val2.value.ptr.value_str, "ddns_fqdn", val2.value_size) == 0)	{
      got_fqdn = 1;
    }

    payload += value_siz;
    payload_len -= value_siz;
  }

  if(payload_len != 0 || tuple_count != 0)
    return 1;

  return 0;
}

// the below code fragment can be found in:
// src/lib/protocols/softether.c
static int softether_type_to_enum(u_int32_t type, enum softether_value_type *result) {
  switch (type)
    {
    case VALUE_INT:
    case VALUE_DATA:
    case VALUE_STR:
    case VALUE_UNISTR:
    case VALUE_INT64:
      *result = (enum softether_value_type)type;
      return 0;
    }

  return 1;
}

// the below code fragment can be found in:
// src/lib/protocols/softether.c
static int dissect_softether_ip_port(struct ndpi_flow_struct *flow,
                                     struct ndpi_packet_struct const *packet) {
  char * ip_port_separator;
  size_t ip_len, port_len;

  if(packet->payload_packet_len < NDPI_STATICSTRING_LEN("IP=") +
     NDPI_STATICSTRING_LEN(",PORT="))
    return 1;    

  if(strncmp((char *)&packet->payload[0], "IP=", NDPI_STATICSTRING_LEN("IP=")) != 0)    
    return 1;    

  ip_port_separator = ndpi_strnstr((char const *)packet->payload + NDPI_STATICSTRING_LEN("IP="),
                                   ",PORT=",
                                   packet->payload_packet_len - NDPI_STATICSTRING_LEN("IP="));
  if(ip_port_separator == NULL)    
    return 1;    

  ip_len = ndpi_min(sizeof(flow->protos.softether.ip) - 1,
                    ip_port_separator - (char const *)packet->payload -
                    NDPI_STATICSTRING_LEN("IP="));

  strncpy(flow->protos.softether.ip,
	  (char const *)packet->payload + NDPI_STATICSTRING_LEN("IP="),
          ip_len);
  flow->protos.softether.ip[ip_len] = '\0';

  if (packet->payload_packet_len < (ip_port_separator - (char const *)packet->payload) +
                                   NDPI_STATICSTRING_LEN(",PORT="))
    return 1;

  port_len = ndpi_min(sizeof(flow->protos.softether.port) - 1,
                      packet->payload_packet_len - (ip_port_separator - (char const *)packet->payload) -
                      NDPI_STATICSTRING_LEN(",PORT="));
  strncpy(flow->protos.softether.port, ip_port_separator + NDPI_STATICSTRING_LEN(",PORT="),
          port_len);
  
  flow->protos.softether.port[port_len] = '\0';

  return 0;
}

// the below code fragment can be found in:
// src/lib/protocols/softether.c
static int ndpi_search_softether_again(struct ndpi_detection_module_struct *ndpi_struct,
				       struct ndpi_flow_struct *flow) {
  if((dissect_softether_ip_port(flow, &ndpi_struct->packet) == 0)
     || (dissect_softether_host_fqdn(flow, &ndpi_struct->packet) == 0)) {
    if((flow->protos.softether.ip[0] != '\0')
       && (flow->protos.softether.port[0] != '\0')
       && (flow->protos.softether.hostname[0] != '\0')
       && (flow->protos.softether.fqdn[0] != '\0')) {
      flow->extra_packets_func = NULL;

      return 0;
    }
  }

  return 1;
}

