// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/hb-ot-cff-common.hh
static unsigned int calculate_serialized_size (unsigned int &offSize_ /* OUT */,
						 const hb_vector_t<DICTVAL> &fontDicts,
						 unsigned int fdCount,
						 const remap_t &fdmap,
						 OP_SERIALIZER& opszr)
  {
    unsigned int dictsSize = 0;
    for (unsigned int i = 0; i < fontDicts.len; i++)
      if (fdmap.includes (i))
	dictsSize += FontDict::calculate_serialized_size (fontDicts[i], opszr);

    offSize_ = calcOffSize (dictsSize);
    return CFFIndex<COUNT>::calculate_serialized_size (offSize_, fdCount, dictsSize);
  }

// the below code fragment can be found in:
// src/hb-ot-cff-common.hh
bool sanitize (hb_sanitize_context_t *c, unsigned int fdcount) const
  {
    TRACE_SANITIZE (this);
    if (unlikely (!(c->check_struct (this))))
      return_trace (false);
    for (unsigned int i = 0; i < c->get_num_glyphs (); i++)
      if (unlikely (!fds[i].sanitize (c)))
	return_trace (false);

    return_trace (true);
  }

// the below code fragment can be found in:
// src/hb-ot-cff-common.hh
static unsigned int calculate_serialized_size (const DICTVAL &dictval,
						 OP_SERIALIZER& opszr,
						 PARAM& param)
  {
    unsigned int size = 0;
    for (unsigned int i = 0; i < dictval.get_count (); i++)
      size += opszr.calculate_serialized_size (dictval[i], param);
    return size;
  }

// the below code fragment can be found in:
// src/hb-ot-cff-common.hh
static unsigned int calculate_serialized_size (unsigned int &offSize_ /* OUT */,
						 const DATA *dataArray,
						 unsigned int dataArrayLen,
						 hb_vector_t<unsigned int> &dataSizeArray, /* OUT */
						 const PARAM &param)
  {
    /* determine offset size */
    unsigned int  totalDataSize = 0;
    for (unsigned int i = 0; i < dataArrayLen; i++)
    {
      unsigned int dataSize = TYPE::calculate_serialized_size (dataArray[i], param);
      dataSizeArray[i] = dataSize;
      totalDataSize += dataSize;
    }
    offSize_ = calcOffSize (totalDataSize);

    return CFFIndex<COUNT>::calculate_serialized_size (offSize_, dataArrayLen, totalDataSize);
  }

// the below code fragment can be found in:
// src/hb-open-type.hh
bool sanitize (hb_sanitize_context_t *c) const
  {
    TRACE_SANITIZE (this);
    if (unlikely (!sanitize_shallow (c))) return_trace (false);

    /* Note: for structs that do not reference other structs,
     * we do not need to call their sanitize() as we already did
     * a bound check on the aggregate array size.  We just include
     * a small unreachable expression to make sure the structs
     * pointed to do have a simple sanitize(), ie. they do not
     * reference other structs via offsets.
     */
    (void) (false && arrayZ[0].sanitize (c));

    return_trace (true);
  }

