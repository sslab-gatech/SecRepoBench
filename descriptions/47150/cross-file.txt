// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/lib/libdwarf/dwarf_line.c
static int
create_fullest_file_path(Dwarf_Debug dbg,
    Dwarf_File_Entry fe,
    Dwarf_Line_Context line_context,
    char ** name_ptr_out,
    Dwarf_Error *error)
{
    Dwarf_Unsigned dirno = 0;
    char *full_name = 0;
    char *file_name = 0;
    /*  Large enough that almost never will any malloc
        be needed by dwarfstring.  Arbitrary size. */
    static char targbuf[300];
    static char nbuf[300];
    dwarfstring targ;
    dwarfstring nxt;
    unsigned linetab_version = line_context->lc_version_number;

    file_name = (char *) fe->fi_file_name;
    if (!file_name) {
        _dwarf_error(dbg, error, DW_DLE_NO_FILE_NAME);
        return DW_DLV_ERROR;
    }
    if (_dwarf_file_name_is_full_path((Dwarf_Small *)file_name)) {
        char *tmp = 0;
        char * mstr = 0;
        unsigned long mlen = 0;

        dwarfstring_constructor_static(&targ,
            targbuf,sizeof(targbuf));
        dwarfstring_constructor_static(&nxt,
            nbuf,sizeof(nbuf));

        dwarfstring_append(&nxt,file_name);
        _dwarf_pathjoinl(&targ,&nxt);
        mstr= dwarfstring_string(&targ);
        mlen = dwarfstring_strlen(&targ) +1;
        tmp = (char *) _dwarf_get_alloc(dbg, DW_DLA_STRING,
            mlen);
        if (tmp) {
            _dwarf_safe_strcpy(tmp,mlen, mstr,mlen-1);
            *name_ptr_out = tmp;
            dwarfstring_destructor(&targ);
            dwarfstring_destructor(&nxt);
            return DW_DLV_OK;
        }
        dwarfstring_destructor(&targ);
        dwarfstring_destructor(&nxt);
        _dwarf_error(dbg,error,DW_DLE_ALLOC_FAIL);
        return DW_DLV_ERROR;
    }
    {
        int need_dir = FALSE;
        unsigned include_dir_offset = 1;
        static char compdirbuf[300];
        static char incdirbuf[300];
        static char filenamebuf[300];
        dwarfstring compdir;
        dwarfstring incdir;
        dwarfstring filename;

        dwarfstring_constructor_static(&targ,
            targbuf,sizeof(targbuf));
        dwarfstring_constructor_static(&compdir,
            compdirbuf,sizeof(compdirbuf));
        dwarfstring_constructor_static(&incdir,
            incdirbuf,sizeof(incdirbuf));
        dwarfstring_constructor_static(&filename,
            filenamebuf,sizeof(filenamebuf));
        if (line_context->lc_compilation_directory) {
            char * comp_dir_name =
                (char *)line_context->lc_compilation_directory;
            dwarfstring_append(&compdir,comp_dir_name);
        }
        need_dir = FALSE;
        dirno = fe->fi_dir_index;
        include_dir_offset = 0;
        if (linetab_version == DW_LINE_VERSION5) {
            /* DWARF5 */
            need_dir = TRUE;
            include_dir_offset = 0;
        } else {
            /* EXPERIMENTAL_LINE_TABLES_VERSION or 2,3, or 4 */
            if (dirno) {
                need_dir = TRUE;
                include_dir_offset = 1;
            }/* else, no dirno, need_dir = FALSE
                Take directory from DW_AT_name */
        }

        if (dirno > line_context->lc_include_directories_count) {
            /*  This is quite corrupted. */
            dwarfstring_destructor(&targ);
            dwarfstring_destructor(&incdir);
            dwarfstring_destructor(&compdir);
            dwarfstring_destructor(&filename);
            dwarfstring_append_printf_u(&incdir,
                "DW_DLE_INCL_DIR_NUM_BAD: "
                "corrupt include directory index %u"
                " unusable,", dirno);
            dwarfstring_append_printf_u(&incdir,
                " only %u directories present.",
                line_context->lc_include_directories_count);
            _dwarf_error_string(dbg, error, DW_DLE_INCL_DIR_NUM_BAD,
                dwarfstring_string(&incdir));
            dwarfstring_destructor(&incdir);
            return DW_DLV_ERROR;
        }
        if (need_dir ) {
            if ((dirno - include_dir_offset) >=
                line_context->lc_include_directories_count) {

                /* Corrupted data. We try to continue. */
                dwarfstring_append_printf_u(&incdir,
                    "/ERROR<corrupt include directory index %u"
                    " unusable,",
                    dirno);
                dwarfstring_append_printf_u(&incdir,
                    " only %u directories present>",
                    line_context->lc_include_directories_count);
            } else {
                char *inc_dir_name =
                    (char *)line_context->lc_include_directories[
                    dirno - include_dir_offset];
                if (!inc_dir_name) {
                    /*  This should never ever happen except in case
                        of a corrupted object file. */
                    inc_dir_name =
                        "/ERROR<erroneous NULL include dir pointer>";
                }
                dwarfstring_append(&incdir,inc_dir_name);
            }
        }
        dwarfstring_append(&filename,file_name);
        if (dwarfstring_strlen(&incdir) > 0 &&
            _dwarf_file_name_is_full_path(
            (Dwarf_Small*)dwarfstring_string(&incdir))) {

            /* incdir is full path,Ignore DW_AT_comp_dir */
            _dwarf_pathjoinl(&targ,&incdir);
            _dwarf_pathjoinl(&targ,&filename);
        } else {
            /* Join all three strings, ignoring empty ones. */
            if (dwarfstring_strlen(&compdir) > 0) {
                _dwarf_pathjoinl(&targ,&compdir);
            }
            if (dwarfstring_strlen(&incdir) > 0) {
                _dwarf_pathjoinl(&targ,&incdir);
            }
            _dwarf_pathjoinl(&targ,&filename);
        }
        {
            char *mname = dwarfstring_string(&targ);
            unsigned long mlen = dwarfstring_strlen(&targ)+1;
            full_name = (char *) _dwarf_get_alloc(dbg, DW_DLA_STRING,
                mlen);
            if (!full_name) {
                dwarfstring_destructor(&targ);
                dwarfstring_destructor(&incdir);
                dwarfstring_destructor(&compdir);
                dwarfstring_destructor(&filename);
                _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);
                return DW_DLV_ERROR;
            }
            _dwarf_safe_strcpy(full_name,mlen,mname,mlen-1);
        }
        *name_ptr_out = full_name;
        dwarfstring_destructor(&targ);
        dwarfstring_destructor(&incdir);
        dwarfstring_destructor(&compdir);
        dwarfstring_destructor(&filename);
    }
    return DW_DLV_OK;
}

// the below code fragment can be found in:
// test/test_errmsglist.c
int
main(int argc, char **argv)
{
    unsigned     i       = 0;
    char        *path    = 0;
    char        *errpath = 0;
    unsigned     len     = 0;
    const char  *libpath="/src/lib/libdwarf/libdwarf.h";
    const char  *srchdr="/src/lib/libdwarf/dwarf_errmsg_list.h";
    int argn = 0;

    pathbuf[0] = 0;
    if (argc > 1) {
        for( argn = 1; argn < argc; ++argn){
            if (!strcmp(argv[1],"-f")) {
                argn += 1;
                if (argn >= argc) {
                    printf("test_errmsglist: -f missing file path");
                    exit(1);
                }
                path=argv[argn];
            } else {
                printf("Expected -f \n");
                exit(1);
            }
        }
    } else {
        /* env var should be set with base path of code */
        path = getenv("DWTOPSRCDIR");
        if (!path) {
            printf("Expected environment variable "
                " DWTOPSRCDIR with path of "
                "base directory (usually called 'code')\n");
            exit(1);
        }
    }
    len = strlen(path);
    local_safe_strcpy(pathbuf,path,sizeof(pathbuf),len);
    local_safe_strcpy(pathbuf+len,(char *)libpath,
        sizeof(pathbuf) -len -1,
        (unsigned)strlen(libpath));

    local_safe_strcpy(pathbuferrm,path,sizeof(pathbuferrm),len);
    local_safe_strcpy(pathbuferrm+len,(char *)srchdr,
        sizeof(pathbuferrm) -len -1,
        (unsigned)strlen(srchdr));
    path = pathbuf;
    errpath = pathbuferrm;
    check_dle_list(path);
    for ( i = 0; i <= DW_DLE_LAST; ++i) {
        if (check_errnum_mismatches(i)) {
            printf("mismatch value %d is: %s\n",i,_dwarf_errmsgs[i]);
            exit(1);
        }
    }
    check_msg_lengths(errpath);
    /* OK. */
    return 0;
}

// the below code fragment can be found in:
// src/bin/buildopstab/buildopscounttab.c
int main(int argc, char**argv)
{
    struct ops_table_s *op = 0;
    const char *headpath = "/src/lib/libdwarf/dwarf.h";
    char  *path  = 0;
    int inindex  = 0;
    int outindex = 0;
    int f        = 0;
    int l        = 0;
    int c        = 0;
    int res      = 0;
    int lastop   = 0;
    unsigned len = 0;

    if (argc > 1) {
        if (argc != 3) {
            printf("Expected -f <filename> of base code path\n");
            exit(1);
        }
        if (strcmp(argv[1],"-f")) {
            printf("Expected -f\n");
            exit(1);
        }
        path=argv[2];
    } else {
        /* env var should be set with base path of code */
        path = getenv("DWTOPSRCDIR");
        if (!path) {
            printf("Expected environment variable "
                " DWTOPSRCDIR with path of "
                "base directory (usually called 'code')\n");
            exit(1);
        }
    }
    len = strlen(path);
    safe_strcpy(pathbuf,path,sizeof(pathbuf),len);
    safe_strcpy(pathbuf+len,(char *)headpath,
        sizeof(pathbuf) -len -1,
        (unsigned)strlen(headpath));
    input_name = pathbuf;

    check_if_optabsource_complete(input_name);

    printf("/*  Generated expression ops table, "
        "do not edit. */\n");
    printf("#include \"dd_opscounttab.h\"\n");
    printf("\n");
    printf("struct dwarf_opscounttab_s _dwarf_opscounttab[] = {\n");
    for ( ;  ; ++inindex) {
        const char *opn = 0;
        int sc = 0;

        op = &optabsource[inindex];
        f = op->ot_first;
        if (!f) {
            break;
        }
        if (lastop && f < lastop) {
            printf("FAILED buildopscounttab on OP,out of sequence"
                " f=0x%x lastop=0x%x\n",
                (unsigned)f,(unsigned)lastop);
            return 1; /* effectively exit(1) */
        }
        if (f == lastop) {
            /*  A duplicate, ignore here. */
            continue;
        }
        l = op->ot_last;
        c = op->ot_opcount;
        sc = op->ot_stackchange;

        while (f > outindex) {
            printf("{/* %-26s 0x%02x*/ %d, 0},\n","unused",
                outindex,-1);
            ++outindex;
        }
        if (!l) {
            res = dwarf_get_OP_name(f,&opn);
            if (res != DW_DLV_OK) {
                printf("FAILED buildopscounttab on OP 0x%x\n",
                    f);
                return 1; /* effectively exit(1) */
            }
            lastop = f;

            printf("{/* %-26s 0x%02x*/ %d, %d},\n",opn,f,c,sc);
            {
                char *dup = 0;
                if (havedup(f,&dup)) {
                    printf("    /* above has alt spelling %s */",
                        dup);
                    printf("\n");
                }
            }
            ++outindex;
        } else {
            int j = f;
            for ( ; j <= l; ++j) {
                res = dwarf_get_OP_name(j,&opn);
                if (res != DW_DLV_OK) {
                    printf("FAILED buildopscounttab on OP 0x%x\n",
                        f);
                    return 1; /* effectively exit(1); */
                }
                printf("{/* %-26s 0x%2x*/ %d, %d}",opn,j,c,sc);
                printf(",\n");
                {
                    /*  Should NOT happen, dups should
                        be singleton entries */
                    char *dup = 0;
                    if (havedup(j,&dup)) {
                        printf("    /* above has alt spelling %s */",
                            dup);
                        printf("\n");
                        fprintf(stderr," FAIL an entry "
                            " in a list has dup. Fix table");
                        exit(1);
                    }
                }
                ++outindex;
                lastop = j;
            }
        }
    }
    while (outindex < DWOPS_ARRAY_SIZE) {
        printf("{/* %-26s 0x%02x*/ %d, 0},\n","unused",outindex,-1);
        ++outindex;
    }
    printf("};\n");
    return 0;
}

// the below code fragment can be found in:
// src/bin/dwarfexample/dwdebuglink.c
static void free_paths(void)
{
    unsigned i = 0;
    if (!gl_pathcount) {
        return;
    }
    for (i = 0; i < gl_pathcount; ++i) {
        free(gl_pathnames[i]);
        gl_pathnames[i] = 0;
    }
    free(gl_pathnames);
    gl_pathnames = 0;
}

// the below code fragment can be found in:
// src/lib/libdwarf/dwarf_generic_init.c
int
dwarf_init_b(int fd,
    unsigned        group_number,
    Dwarf_Handler   errhand,
    Dwarf_Ptr       errarg,
    Dwarf_Debug *   ret_dbg,
    Dwarf_Error *   error)
{
    unsigned ftype = 0;
    unsigned endian = 0;
    unsigned offsetsize = 0;
    Dwarf_Unsigned   filesize = 0;
    int res = 0;
    int errcode = 0;

    if (!ret_dbg) {
        DWARF_DBG_ERROR(NULL,DW_DLE_DWARF_INIT_DBG_NULL,DW_DLV_ERROR);
    }
    /*  Non-null *ret_dbg will cause problems dealing with
        DW_DLV_ERROR */
    *ret_dbg = 0;
    res = dwarf_object_detector_fd(fd, &ftype,
        &endian,&offsetsize,&filesize,&errcode);
    if (res == DW_DLV_NO_ENTRY) {
        return res;
    }
    if (res == DW_DLV_ERROR) {
        /* This macro does a return. */
        DWARF_DBG_ERROR(NULL, DW_DLE_FILE_WRONG_TYPE, DW_DLV_ERROR);
    }
    switch(ftype) {
    case DW_FTYPE_ELF: {
        int res2 = 0;

        res2 = _dwarf_elf_nlsetup(fd,"",
            ftype,endian,offsetsize,filesize,
            group_number,errhand,errarg,ret_dbg,error);
        if (res2 != DW_DLV_OK) {
            return res2;
        }
        set_global_paths_init(*ret_dbg,error);
        return res2;
        }
    case DW_FTYPE_MACH_O: {
        int resm = 0;

        resm = _dwarf_macho_setup(fd,"",
            ftype,endian,offsetsize,filesize,
            group_number,errhand,errarg,ret_dbg,error);
        if (resm != DW_DLV_OK) {
            return resm;
        }
        set_global_paths_init(*ret_dbg,error);
        return resm;
        }

    case DW_FTYPE_PE: {
        int resp = 0;

        resp = _dwarf_pe_setup(fd,
            "",
            ftype,endian,offsetsize,filesize,
            group_number,errhand,errarg,ret_dbg,error);
        if (resp != DW_DLV_OK) {
            return resp;
        }
        set_global_paths_init(*ret_dbg,error);
        return resp;
        }
    default: break;
    }
    DWARF_DBG_ERROR(NULL, DW_DLE_FILE_WRONG_TYPE, DW_DLV_ERROR);
    return res;
}

