// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// code/Common/FileSystemFilter.h
// namespace Assimp    {
// 
// inline bool IsHex(char s) {
//     return (s>='0' && s<='9') || (s>='a' && s<='f') || (s>='A' && s<='F');
// }
// 
// // ---------------------------------------------------------------------------
// /** File system filter
//  */
// class FileSystemFilter : public IOSystem
// {
// public:
//     /** Constructor. */
//     FileSystemFilter(const std::string& file, IOSystem* old)
//     : mWrapped  (old)
//     , mSrc_file(file)
//     , mSep(mWrapped->getOsSeparator()) {
//         ai_assert(nullptr != mWrapped);
// 
//         // Determine base directory
//         mBase = mSrc_file;
//         std::string::size_type ss2;
//         if (std::string::npos != (ss2 = mBase.find_last_of("\\/")))  {
//             mBase.erase(ss2,mBase.length()-ss2);
//         } else {
//             mBase = std::string();
//         }
// 
//         // make sure the directory is terminated properly
//         char s;
// 
//         if ( mBase.empty() ) {
//             mBase = ".";
//             mBase += getOsSeparator();
//         } else if ((s = *(mBase.end()-1)) != '\\' && s != '/') {
//             mBase += getOsSeparator();
//         }
// 
//         DefaultLogger::get()->info("Import root directory is \'", mBase, "\'");
//     }
// 
//     /** Destructor. */
//     ~FileSystemFilter() {
//         // empty
//     }
// 
//     // -------------------------------------------------------------------
//     /** Tests for the existence of a file at the given path. */
//     bool Exists( const char* pFile) const {
//         ai_assert( nullptr != mWrapped );
// 
//         std::string tmp = pFile;
// 
//         // Currently this IOSystem is also used to open THE ONE FILE.
//         if (tmp != mSrc_file)    {
//             BuildPath(tmp);
//             Cleanup(tmp);
//         }
// 
//         return mWrapped->Exists(tmp);
//     }
// 
//     // -------------------------------------------------------------------
//     /** Returns the directory separator. */
//     char getOsSeparator() const {
//         return mSep;
//     }
// 
//     // -------------------------------------------------------------------
//     /** Open a new file with a given path. */
//     IOStream* Open( const char* pFile, const char* pMode = "rb") {
//         ai_assert( nullptr != mWrapped );
//         if ( nullptr == pFile || nullptr == pMode ) {
//             return nullptr;
//         }
// 
//         ai_assert( nullptr != pFile );
//         ai_assert( nullptr != pMode );
// 
//         // First try the unchanged path
//         IOStream* s = mWrapped->Open(pFile,pMode);
// 
//         if (nullptr == s) {
//             std::string tmp = pFile;
// 
//             // Try to convert between absolute and relative paths
//             BuildPath(tmp);
//             s = mWrapped->Open(tmp,pMode);
// 
//             if (nullptr == s) {
//                 // Finally, look for typical issues with paths
//                 // and try to correct them. This is our last
//                 // resort.
//                 tmp = pFile;
//                 Cleanup(tmp);
//                 BuildPath(tmp);
//                 s = mWrapped->Open(tmp,pMode);
//             }
//         }
// 
//         return s;
//     }
// 
//     // -------------------------------------------------------------------
//     /** Closes the given file and releases all resources associated with it. */
//     void Close( IOStream* pFile) {
//         ai_assert( nullptr != mWrapped );
//         return mWrapped->Close(pFile);
//     }
// 
//     // -------------------------------------------------------------------
//     /** Compare two paths */
//     bool ComparePaths (const char* one, const char* second) const {
//         ai_assert( nullptr != mWrapped );
//         return mWrapped->ComparePaths (one,second);
//     }
// 
//     // -------------------------------------------------------------------
//     /** Pushes a new directory onto the directory stack. */
//     bool PushDirectory(const std::string &path ) {
//         ai_assert( nullptr != mWrapped );
//         return mWrapped->PushDirectory(path);
//     }
// 
//     // -------------------------------------------------------------------
//     /** Returns the top directory from the stack. */
//     const std::string &CurrentDirectory() const {
//         ai_assert( nullptr != mWrapped );
//         return mWrapped->CurrentDirectory();
//     }
// 
//     // -------------------------------------------------------------------
//     /** Returns the number of directories stored on the stack. */
//     size_t StackSize() const {
//         ai_assert( nullptr != mWrapped );
//         return mWrapped->StackSize();
//     }
// 
//     // -------------------------------------------------------------------
//     /** Pops the top directory from the stack. */
//     bool PopDirectory() {
//         ai_assert( nullptr != mWrapped );
//         return mWrapped->PopDirectory();
//     }
// 
//     // -------------------------------------------------------------------
//     /** Creates an new directory at the given path. */
//     bool CreateDirectory(const std::string &path) {
//         ai_assert( nullptr != mWrapped );
//         return mWrapped->CreateDirectory(path);
//     }
// 
//     // -------------------------------------------------------------------
//     /** Will change the current directory to the given path. */
//     bool ChangeDirectory(const std::string &path) {
//         ai_assert( nullptr != mWrapped );
//         return mWrapped->ChangeDirectory(path);
//     }
// 
//     // -------------------------------------------------------------------
//     /** Delete file. */
//     bool DeleteFile(const std::string &file) {
//         ai_assert( nullptr != mWrapped );
//         return mWrapped->DeleteFile(file);
//     }
// 
// private:
//     // -------------------------------------------------------------------
//     /** Build a valid path from a given relative or absolute path.
//      */
//     void BuildPath (std::string& in) const {
//         ai_assert( nullptr != mWrapped );
//         // if we can already access the file, great.
//         if (in.length() < 3 || mWrapped->Exists(in)) {
//             return;
//         }
// 
//         // Determine whether this is a relative path (Windows-specific - most assets are packaged on Windows).
//         if (in[1] != ':') {
// 
//             // append base path and try
//             const std::string tmp = mBase + in;
//             if (mWrapped->Exists(tmp)) {
//                 in = tmp;
//                 return;
//             }
//         }
// 
//         // Chop of the file name and look in the model directory, if
//         // this fails try all sub paths of the given path, i.e.
//         // if the given path is foo/bar/something.lwo, try
//         // <base>/something.lwo
//         // <base>/bar/something.lwo
//         // <base>/foo/bar/something.lwo
//         std::string::size_type pos = in.rfind('/');
//         if (std::string::npos == pos) {
//             pos = in.rfind('\\');
//         }
// 
//         if (std::string::npos != pos)   {
//             std::string tmp;
//             std::string::size_type last_dirsep = std::string::npos;
// 
//             while(true) {
//                 tmp = mBase;
//                 tmp += mSep;
// 
//                 std::string::size_type dirsep = in.rfind('/', last_dirsep);
//                 if (std::string::npos == dirsep) {
//                     dirsep = in.rfind('\\', last_dirsep);
//                 }
// 
//                 if (std::string::npos == dirsep || dirsep == 0) {
//                     // we did try this already.
//                     break;
//                 }
// 
//                 last_dirsep = dirsep-1;
// 
//                 tmp += in.substr(dirsep+1, in.length()-pos);
//                 if (mWrapped->Exists(tmp)) {
//                     in = tmp;
//                     return;
//                 }
//             }
//         }
// 
//         // hopefully the underlying file system has another few tricks to access this file ...
//     }
// 
//     // -------------------------------------------------------------------
//     /** Cleanup the given path
//      */
//     void Cleanup (std::string& in) const {
//         if(in.empty()) {
//             return;
//         }
// 
//         // Remove a very common issue when we're parsing file names: spaces at the
//         // beginning of the path.
//         char last = 0;
//         std::string::iterator it = in.begin();
//         while (IsSpaceOrNewLine( *it ))++it;
//         if (it != in.begin()) {
//             in.erase(in.begin(),it+1);
//         }
// 
//         const char separator = getOsSeparator();
//         for (it = in.begin(); it != in.end(); ++it) {
//             int remaining = std::distance(in.end(), it);
//             // Exclude :// and \\, which remain untouched.
//             // https://sourceforge.net/tracker/?func=detail&aid=3031725&group_id=226462&atid=1067632
//             if (remaining >= 3 && !strncmp(&*it, "://", 3 )) {
//                 it += 3;
//                 continue;
//             }
//             if (it == in.begin() && remaining >= 2 && !strncmp(&*it, "\\\\", 2)) {
//                 it += 2;
//                 continue;
//             }
// 
//             // Cleanup path delimiters
//             if (*it == '/' || (*it) == '\\') {
//                 *it = separator;
// 
//                 // And we're removing double delimiters, frequent issue with
//                 // incorrectly composited paths ...
//                 if (last == *it) {
//                     it = in.erase(it);
//                     --it;
//                 }
//             } else if (*it == '%' && in.end() - it > 2) {
//                 // Hex sequence in URIs
//                 if( IsHex((&*it)[0]) && IsHex((&*it)[1]) ) {
//                     *it = HexOctetToDecimal(&*it);
//                     it = in.erase(it+1,it+2);
//                     --it;
//                 }
//             }
// 
//             last = *it;
//         }
//     }
// 
// private:
//     IOSystem *mWrapped;
//     std::string mSrc_file, mBase;
//     char mSep;
// }

// the below code fragment can be found in:
// code/AssetLib/XGL/XGLLoader.h
// std::string GetElementName();

// the below code fragment can be found in:
// code/AssetLib/X3D/X3DExporter.cpp
// X3DExporter::X3DExporter(const char *pFileName, IOSystem *pIOSystem, const aiScene *pScene, const ExportProperties * /*pProperties*/) :
//         mScene(pScene) {
//     list<SAttribute> attr_list;
// 
//     mOutFile = pIOSystem->Open(pFileName, "wt");
//     if (mOutFile == nullptr) throw DeadlyExportError("Could not open output .x3d file: " + string(pFileName));
// 
//     // Begin document
//     XML_Write("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
//     XML_Write("<!DOCTYPE X3D PUBLIC \"ISO//Web3D//DTD X3D 3.3//EN\" \"http://www.web3d.org/specifications/x3d-3.3.dtd\">\n");
//     // Root node
//     attr_list.push_back({ "profile", "Interchange" });
//     attr_list.push_back({ "version", "3.3" });
//     attr_list.push_back({ "xmlns:xsd", "http://www.w3.org/2001/XMLSchema-instance" });
//     attr_list.push_back({ "xsd:noNamespaceSchemaLocation", "http://www.web3d.org/specifications/x3d-3.3.xsd" });
//     NodeHelper_OpenNode("X3D", 0, false, attr_list);
//     attr_list.clear();
//     // <head>: meta data.
//     NodeHelper_OpenNode("head", 1);
//     XML_Write(mIndentationString + "<!-- All \"meta\" from this section tou will found in <Scene> node as MetadataString nodes. -->\n");
//     NodeHelper_CloseNode("head", 1);
//     // Scene node.
//     NodeHelper_OpenNode("Scene", 1);
//     Export_Node(mScene->mRootNode, 2);
//     NodeHelper_CloseNode("Scene", 1);
//     // Close Root node.
//     NodeHelper_CloseNode("X3D", 0);
//     // Cleanup
//     pIOSystem->Close(mOutFile);
//     mOutFile = nullptr;
// }

// the below code fragment can be found in:
// code/AssetLib/X3D/X3DImporter.hpp
// inline void Throw_TagCountIncorrect(const std::string &pNode) {
//     throw DeadlyImportError("Count of open and close tags for node <" + pNode + "> are not equivalent. Seems file is corrupt.");
// }

// the below code fragment can be found in:
// code/AssetLib/AMF/AMFImporter.cpp
// void AMFImporter::Throw_ID_NotFound(const std::string &pID) const {
//     throw DeadlyImportError("Not found node with name \"", pID, "\".");
// }

