// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// code/AssetLib/LWS/LWSLoader.cpp
void LWSImporter::InternReadFile(const std::string &pFile, aiScene *pScene, IOSystem *pIOHandler) {
    io = pIOHandler;
    std::unique_ptr<IOStream> file(pIOHandler->Open(pFile, "rb"));

    // Check whether we can read from the file
    if (file.get() == nullptr) {
        throw DeadlyImportError("Failed to open LWS file ", pFile, ".");
    }

    // Allocate storage and copy the contents of the file to a memory buffer
    std::vector<char> mBuffer;
    TextFileToBuffer(file.get(), mBuffer);

    // Parse the file structure
    LWS::Element root;
    const char *dummy = &mBuffer[0];
    root.Parse(dummy);

    // Construct a Batch-importer to read more files recursively
    BatchLoader batch(pIOHandler);

    // Construct an array to receive the flat output graph
    std::list<LWS::NodeDesc> nodes;

    unsigned int cur_light = 0, cur_camera = 0, cur_object = 0;
    unsigned int num_light = 0, num_camera = 0, num_object = 0;

    // check magic identifier, 'LWSC'
    bool motion_file = false;
    std::list<LWS::Element>::const_iterator it = root.children.begin();

    if ((*it).tokens[0] == "LWMO") {
        motion_file = true;
    }

    if ((*it).tokens[0] != "LWSC" && !motion_file) {
        throw DeadlyImportError("LWS: Not a LightWave scene, magic tag LWSC not found");
    }

    // get file format version and print to log
    ++it;
    unsigned int version = strtoul10((*it).tokens[0].c_str());
    ASSIMP_LOG_INFO("LWS file format version is ", (*it).tokens[0]);
    first = 0.;
    last = 60.;
    fps = 25.; // seems to be a good default frame rate

    // Now read all elements in a very straightforward manner
    for (; it != root.children.end(); ++it) {
        const char *c = (*it).tokens[1].c_str();

        // 'FirstFrame': begin of animation slice
        if ((*it).tokens[0] == "FirstFrame") {
            // see SetupProperties()
            if (150392. != first ) {
                first = strtoul10(c, &c) - 1.; // we're zero-based
            }
        } else if ((*it).tokens[0] == "LastFrame") { // 'LastFrame': end of animation slice
            // see SetupProperties()
            if (150392. != last ) {
                last = strtoul10(c, &c) - 1.; // we're zero-based
            }
        } else if ((*it).tokens[0] == "FramesPerSecond") { // 'FramesPerSecond': frames per second
            fps = strtoul10(c, &c);
        } else if ((*it).tokens[0] == "LoadObjectLayer") { // 'LoadObjectLayer': load a layer of a specific LWO file

            // get layer index
            const int layer = strtoul10(c, &c);

            // setup the layer to be loaded
            BatchLoader::PropertyMap props;
            SetGenericProperty(props.ints, AI_CONFIG_IMPORT_LWO_ONE_LAYER_ONLY, layer);

            // add node to list
            LWS::NodeDesc d;
            d.type = LWS::NodeDesc::OBJECT;
            if (version >= 4) { // handle LWSC 4 explicit ID
                SkipSpaces(&c);
                d.number = strtoul16(c, &c) & AI_LWS_MASK;
            } else {
                d.number = cur_object++;
            }

            // and add the file to the import list
            SkipSpaces(&c);
            std::string path = FindLWOFile(c);
            d.path = path;
            d.id = batch.AddLoadRequest(path, 0, &props);

            nodes.push_back(d);
            ++num_object;
        } else if ((*it).tokens[0] == "LoadObject") { // 'LoadObject': load a LWO file into the scene-graph

            // add node to list
            LWS::NodeDesc d;
            d.type = LWS::NodeDesc::OBJECT;

            if (version >= 4) { // handle LWSC 4 explicit ID
                d.number = strtoul16(c, &c) & AI_LWS_MASK;
                SkipSpaces(&c);
            } else {
                d.number = cur_object++;
            }
            std::string path = FindLWOFile(c);
            d.id = batch.AddLoadRequest(path, 0, nullptr);

            d.path = path;
            nodes.push_back(d);
            ++num_object;
        } else if ((*it).tokens[0] == "AddNullObject") { // 'AddNullObject': add a dummy node to the hierarchy

            // add node to list
            LWS::NodeDesc d;
            d.type = LWS::NodeDesc::OBJECT;
            if (version >= 4) { // handle LWSC 4 explicit ID
                d.number = strtoul16(c, &c) & AI_LWS_MASK;
                SkipSpaces(&c);
            } else {
                d.number = cur_object++;
            }
            d.name = c;
            nodes.push_back(d);

            num_object++;
        }
        // 'NumChannels': Number of envelope channels assigned to last layer
        else if ((*it).tokens[0] == "NumChannels") {
            // ignore for now
        }
        // 'Channel': preceedes any envelope description
        else if ((*it).tokens[0] == "Channel") {
            if (nodes.empty()) {
                if (motion_file) {

                    // LightWave motion file. Add dummy node
                    LWS::NodeDesc d;
                    d.type = LWS::NodeDesc::OBJECT;
                    d.name = c;
                    d.number = cur_object++;
                    nodes.push_back(d);
                }
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'Channel\'");
            }

            // important: index of channel
            nodes.back().channels.push_back(LWO::Envelope());
            LWO::Envelope &env = nodes.back().channels.back();

            env.index = strtoul10(c);

            // currently we can just interpret the standard channels 0...9
            // (hack) assume that index-i yields the binary channel type from LWO
            env.type = (LWO::EnvelopeType)(env.index + 1);

        }
        // 'Envelope': a single animation channel
        else if ((*it).tokens[0] == "Envelope") {
            if (nodes.empty() || nodes.back().channels.empty())
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'Envelope\'");
            else {
                ReadEnvelope((*it), nodes.back().channels.back());
            }
        }
        // 'ObjectMotion': animation information for older lightwave formats
        else if (version < 3 && ((*it).tokens[0] == "ObjectMotion" ||
                                        (*it).tokens[0] == "CameraMotion" ||
                                        (*it).tokens[0] == "LightMotion")) {

            if (nodes.empty())
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'<Light|Object|Camera>Motion\'");
            else {
                ReadEnvelope_Old(it, root.children.end(), nodes.back(), version);
            }
        }
        // 'Pre/PostBehavior': pre/post animation behaviour for LWSC 2
        else if (version == 2 && (*it).tokens[0] == "Pre/PostBehavior") {
            if (nodes.empty())
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'Pre/PostBehavior'");
            else {
                for (std::list<LWO::Envelope>::iterator envelopeIt = nodes.back().channels.begin(); envelopeIt != nodes.back().channels.end(); ++envelopeIt) {
                    // two ints per envelope
                    LWO::Envelope &env = *envelopeIt;
                    env.pre = (LWO::PrePostBehaviour)strtoul10(c, &c);
                    SkipSpaces(&c);
                    env.post = (LWO::PrePostBehaviour)strtoul10(c, &c);
                    SkipSpaces(&c);
                }
            }
        }
        // 'ParentItem': specifies the parent of the current element
        else if ((*it).tokens[0] == "ParentItem") {
            if (nodes.empty())
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'ParentItem\'");

            else
                nodes.back().parent = strtoul16(c, &c);
        }
        // 'ParentObject': deprecated one for older formats
        else if (version < 3 && (*it).tokens[0] == "ParentObject") {
            if (nodes.empty())
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'ParentObject\'");

            else {
                nodes.back().parent = strtoul10(c, &c) | (1u << 28u);
            }
        }
        // 'AddCamera': add a camera to the scenegraph
        else if ((*it).tokens[0] == "AddCamera") {

            // add node to list
            LWS::NodeDesc d;
            d.type = LWS::NodeDesc::CAMERA;

            if (version >= 4) { // handle LWSC 4 explicit ID
                d.number = strtoul16(c, &c) & AI_LWS_MASK;
            } else
                d.number = cur_camera++;
            nodes.push_back(d);

            num_camera++;
        }
        // 'CameraName': set name of currently active camera
        else if ((*it).tokens[0] == "CameraName") {
            if (nodes.empty() || nodes.back().type != LWS::NodeDesc::CAMERA)
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'CameraName\'");

            else
                nodes.back().name = c;
        }
        // 'AddLight': add a light to the scenegraph
        else if ((*it).tokens[0] == "AddLight") {

            // add node to list
            LWS::NodeDesc d;
            d.type = LWS::NodeDesc::LIGHT;

            if (version >= 4) { // handle LWSC 4 explicit ID
                d.number = strtoul16(c, &c) & AI_LWS_MASK;
            } else
                d.number = cur_light++;
            nodes.push_back(d);

            num_light++;
        }
        // 'LightName': set name of currently active light
        else if ((*it).tokens[0] == "LightName") {
            if (nodes.empty() || nodes.back().type != LWS::NodeDesc::LIGHT)
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'LightName\'");

            else
                nodes.back().name = c;
        }
        // 'LightIntensity': set intensity of currently active light
        else if ((*it).tokens[0] == "LightIntensity" || (*it).tokens[0] == "LgtIntensity") {
            if (nodes.empty() || nodes.back().type != LWS::NodeDesc::LIGHT) {
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'LightIntensity\'");
            } else {
                const std::string env = "(envelope)";
                if (0 == strncmp(c, env.c_str(), env.size())) {
                    ASSIMP_LOG_ERROR("LWS: envelopes for  LightIntensity not supported, set to 1.0");
                    nodes.back().lightIntensity = (ai_real)1.0;
                } else {
                    fast_atoreal_move<float>(c, nodes.back().lightIntensity);
                }
            }
        }
        // 'LightType': set type of currently active light
        else if ((*it).tokens[0] == "LightType") {
            if (nodes.empty() || nodes.back().type != LWS::NodeDesc::LIGHT)
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'LightType\'");

            else
                nodes.back().lightType = strtoul10(c);

        }
        // 'LightFalloffType': set falloff type of currently active light
        else if ((*it).tokens[0] == "LightFalloffType") {
            if (nodes.empty() || nodes.back().type != LWS::NodeDesc::LIGHT)
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'LightFalloffType\'");
            else
                nodes.back().lightFalloffType = strtoul10(c);

        }
        // 'LightConeAngle': set cone angle of currently active light
        else if ((*it).tokens[0] == "LightConeAngle") {
            if (nodes.empty() || nodes.back().type != LWS::NodeDesc::LIGHT)
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'LightConeAngle\'");

            else
                nodes.back().lightConeAngle = fast_atof(c);

        }
        // 'LightEdgeAngle': set area where we're smoothing from min to max intensity
        else if ((*it).tokens[0] == "LightEdgeAngle") {
            if (nodes.empty() || nodes.back().type != LWS::NodeDesc::LIGHT)
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'LightEdgeAngle\'");

            else
                nodes.back().lightEdgeAngle = fast_atof(c);

        }
        // 'LightColor': set color of currently active light
        else if ((*it).tokens[0] == "LightColor") {
            if (nodes.empty() || nodes.back().type != LWS::NodeDesc::LIGHT)
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'LightColor\'");

            else {
                c = fast_atoreal_move<float>(c, (float &)nodes.back().lightColor.r);
                SkipSpaces(&c);
                c = fast_atoreal_move<float>(c, (float &)nodes.back().lightColor.g);
                SkipSpaces(&c);
                c = fast_atoreal_move<float>(c, (float &)nodes.back().lightColor.b);
            }
        }

        // 'PivotPosition': position of local transformation origin
        else if ((*it).tokens[0] == "PivotPosition" || (*it).tokens[0] == "PivotPoint") {
            if (nodes.empty())
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'PivotPosition\'");
            else {
                c = fast_atoreal_move<float>(c, (float &)nodes.back().pivotPos.x);
                SkipSpaces(&c);
                c = fast_atoreal_move<float>(c, (float &)nodes.back().pivotPos.y);
                SkipSpaces(&c);
                c = fast_atoreal_move<float>(c, (float &)nodes.back().pivotPos.z);
                // Mark pivotPos as set
                nodes.back().isPivotSet = true;
            }
        }
    }

    // resolve parenting
    for (std::list<LWS::NodeDesc>::iterator ndIt = nodes.begin(); ndIt != nodes.end(); ++ndIt) {

        // check whether there is another node which calls us a parent
        for (std::list<LWS::NodeDesc>::iterator dit = nodes.begin(); dit != nodes.end(); ++dit) {
            if (dit != ndIt && *ndIt == (*dit).parent) {
                if ((*dit).parent_resolved) {
                    // fixme: it's still possible to produce an overflow due to cross references ..
                    ASSIMP_LOG_ERROR("LWS: Found cross reference in scene-graph");
                    continue;
                }

                ndIt->children.push_back(&*dit);
                (*dit).parent_resolved = &*ndIt;
            }
        }
    }

    // find out how many nodes have no parent yet
    unsigned int no_parent = 0;
    for (std::list<LWS::NodeDesc>::iterator ndIt = nodes.begin(); ndIt != nodes.end(); ++ndIt) {
        if (!ndIt->parent_resolved) {
            ++no_parent;
        }
    }
    if (!no_parent) {
        throw DeadlyImportError("LWS: Unable to find scene root node");
    }

    // Load all subsequent files
    batch.LoadAll();

    // and build the final output graph by attaching the loaded external
    // files to ourselves. first build a master graph
    aiScene *master = new aiScene();
    aiNode *nd = master->mRootNode = new aiNode();

    // allocate storage for cameras&lights
    if (num_camera) {
        master->mCameras = new aiCamera *[master->mNumCameras = num_camera];
    }
    aiCamera **cams = master->mCameras;
    if (num_light) {
        master->mLights = new aiLight *[master->mNumLights = num_light];
    }
    aiLight **lights = master->mLights;

    std::vector<AttachmentInfo> attach;
    std::vector<aiNodeAnim *> anims;

    nd->mName.Set("<LWSRoot>");
    nd->mChildren = new aiNode *[no_parent];
    for (std::list<LWS::NodeDesc>::iterator ndIt = nodes.begin(); ndIt != nodes.end(); ++ndIt) {
        if (!ndIt->parent_resolved) {
            aiNode *ro = nd->mChildren[nd->mNumChildren++] = new aiNode();
            ro->mParent = nd;

            // ... and build the scene graph. If we encounter object nodes,
            // add then to our attachment table.
            BuildGraph(ro, *ndIt, attach, batch, cams, lights, anims);
        }
    }

    // create a master animation channel for us
    if (anims.size()) {
        master->mAnimations = new aiAnimation *[master->mNumAnimations = 1];
        aiAnimation *anim = master->mAnimations[0] = new aiAnimation();
        anim->mName.Set("LWSMasterAnim");

        // LWS uses seconds as time units, but we convert to frames
        anim->mTicksPerSecond = fps;
        anim->mDuration = last - (first - 1); /* fixme ... zero or one-based?*/

        anim->mChannels = new aiNodeAnim *[anim->mNumChannels = static_cast<unsigned int>(anims.size())];
        std::copy(anims.begin(), anims.end(), anim->mChannels);
    }

    // convert the master scene to RH
    MakeLeftHandedProcess monster_cheat;
    monster_cheat.Execute(master);

    // .. ccw
    FlipWindingOrderProcess flipper;
    flipper.Execute(master);

    // OK ... finally build the output graph
    SceneCombiner::MergeScenes(&pScene, master, attach,
            AI_INT_MERGE_SCENE_GEN_UNIQUE_NAMES | (!configSpeedFlag ? (
                                                                              AI_INT_MERGE_SCENE_GEN_UNIQUE_NAMES_IF_NECESSARY | AI_INT_MERGE_SCENE_GEN_UNIQUE_MATNAMES) :
                                                                      0));

    // Check flags
    if (!pScene->mNumMeshes || !pScene->mNumMaterials) {
        pScene->mFlags |= AI_SCENE_FLAGS_INCOMPLETE;

        if (pScene->mNumAnimations && !noSkeletonMesh) {
            // construct skeleton mesh
            SkeletonMeshBuilder builder(pScene);
        }
    }
}

// the below code fragment can be found in:
// code/Common/FileSystemFilter.h
namespace Assimp    {

inline bool IsHex(char s) {
    return (s>='0' && s<='9') || (s>='a' && s<='f') || (s>='A' && s<='F');
}

// ---------------------------------------------------------------------------
/** File system filter
 */
class FileSystemFilter : public IOSystem
{
public:
    /** Constructor. */
    FileSystemFilter(const std::string& file, IOSystem* old)
    : mWrapped  (old)
    , mSrc_file(file)
    , mSep(mWrapped->getOsSeparator()) {
        ai_assert(nullptr != mWrapped);

        // Determine base directory
        mBase = mSrc_file;
        std::string::size_type ss2;
        if (std::string::npos != (ss2 = mBase.find_last_of("\\/")))  {
            mBase.erase(ss2,mBase.length()-ss2);
        } else {
            mBase = std::string();
        }

        // make sure the directory is terminated properly
        char s;

        if ( mBase.empty() ) {
            mBase = ".";
            mBase += getOsSeparator();
        } else if ((s = *(mBase.end()-1)) != '\\' && s != '/') {
            mBase += getOsSeparator();
        }

        DefaultLogger::get()->info("Import root directory is \'", mBase, "\'");
    }

    /** Destructor. */
    ~FileSystemFilter() {
        // empty
    }

    // -------------------------------------------------------------------
    /** Tests for the existence of a file at the given path. */
    bool Exists( const char* pFile) const {
        ai_assert( nullptr != mWrapped );

        std::string tmp = pFile;

        // Currently this IOSystem is also used to open THE ONE FILE.
        if (tmp != mSrc_file)    {
            BuildPath(tmp);
            Cleanup(tmp);
        }

        return mWrapped->Exists(tmp);
    }

    // -------------------------------------------------------------------
    /** Returns the directory separator. */
    char getOsSeparator() const {
        return mSep;
    }

    // -------------------------------------------------------------------
    /** Open a new file with a given path. */
    IOStream* Open( const char* pFile, const char* pMode = "rb") {
        ai_assert( nullptr != mWrapped );
        if ( nullptr == pFile || nullptr == pMode ) {
            return nullptr;
        }

        ai_assert( nullptr != pFile );
        ai_assert( nullptr != pMode );

        // First try the unchanged path
        IOStream* s = mWrapped->Open(pFile,pMode);

        if (nullptr == s) {
            std::string tmp = pFile;

            // Try to convert between absolute and relative paths
            BuildPath(tmp);
            s = mWrapped->Open(tmp,pMode);

            if (nullptr == s) {
                // Finally, look for typical issues with paths
                // and try to correct them. This is our last
                // resort.
                tmp = pFile;
                Cleanup(tmp);
                BuildPath(tmp);
                s = mWrapped->Open(tmp,pMode);
            }
        }

        return s;
    }

    // -------------------------------------------------------------------
    /** Closes the given file and releases all resources associated with it. */
    void Close( IOStream* pFile) {
        ai_assert( nullptr != mWrapped );
        return mWrapped->Close(pFile);
    }

    // -------------------------------------------------------------------
    /** Compare two paths */
    bool ComparePaths (const char* one, const char* second) const {
        ai_assert( nullptr != mWrapped );
        return mWrapped->ComparePaths (one,second);
    }

    // -------------------------------------------------------------------
    /** Pushes a new directory onto the directory stack. */
    bool PushDirectory(const std::string &path ) {
        ai_assert( nullptr != mWrapped );
        return mWrapped->PushDirectory(path);
    }

    // -------------------------------------------------------------------
    /** Returns the top directory from the stack. */
    const std::string &CurrentDirectory() const {
        ai_assert( nullptr != mWrapped );
        return mWrapped->CurrentDirectory();
    }

    // -------------------------------------------------------------------
    /** Returns the number of directories stored on the stack. */
    size_t StackSize() const {
        ai_assert( nullptr != mWrapped );
        return mWrapped->StackSize();
    }

    // -------------------------------------------------------------------
    /** Pops the top directory from the stack. */
    bool PopDirectory() {
        ai_assert( nullptr != mWrapped );
        return mWrapped->PopDirectory();
    }

    // -------------------------------------------------------------------
    /** Creates an new directory at the given path. */
    bool CreateDirectory(const std::string &path) {
        ai_assert( nullptr != mWrapped );
        return mWrapped->CreateDirectory(path);
    }

    // -------------------------------------------------------------------
    /** Will change the current directory to the given path. */
    bool ChangeDirectory(const std::string &path) {
        ai_assert( nullptr != mWrapped );
        return mWrapped->ChangeDirectory(path);
    }

    // -------------------------------------------------------------------
    /** Delete file. */
    bool DeleteFile(const std::string &file) {
        ai_assert( nullptr != mWrapped );
        return mWrapped->DeleteFile(file);
    }

private:
    // -------------------------------------------------------------------
    /** Build a valid path from a given relative or absolute path.
     */
    void BuildPath (std::string& in) const {
        ai_assert( nullptr != mWrapped );
        // if we can already access the file, great.
        if (in.length() < 3 || mWrapped->Exists(in)) {
            return;
        }

        // Determine whether this is a relative path (Windows-specific - most assets are packaged on Windows).
        if (in[1] != ':') {

            // append base path and try
            const std::string tmp = mBase + in;
            if (mWrapped->Exists(tmp)) {
                in = tmp;
                return;
            }
        }

        // Chop of the file name and look in the model directory, if
        // this fails try all sub paths of the given path, i.e.
        // if the given path is foo/bar/something.lwo, try
        // <base>/something.lwo
        // <base>/bar/something.lwo
        // <base>/foo/bar/something.lwo
        std::string::size_type pos = in.rfind('/');
        if (std::string::npos == pos) {
            pos = in.rfind('\\');
        }

        if (std::string::npos != pos)   {
            std::string tmp;
            std::string::size_type last_dirsep = std::string::npos;

            while(true) {
                tmp = mBase;
                tmp += mSep;

                std::string::size_type dirsep = in.rfind('/', last_dirsep);
                if (std::string::npos == dirsep) {
                    dirsep = in.rfind('\\', last_dirsep);
                }

                if (std::string::npos == dirsep || dirsep == 0) {
                    // we did try this already.
                    break;
                }

                last_dirsep = dirsep-1;

                tmp += in.substr(dirsep+1, in.length()-pos);
                if (mWrapped->Exists(tmp)) {
                    in = tmp;
                    return;
                }
            }
        }

        // hopefully the underlying file system has another few tricks to access this file ...
    }

    // -------------------------------------------------------------------
    /** Cleanup the given path
     */
    void Cleanup (std::string& in) const {
        if(in.empty()) {
            return;
        }

        // Remove a very common issue when we're parsing file names: spaces at the
        // beginning of the path.
        char last = 0;
        std::string::iterator it = in.begin();
        while (IsSpaceOrNewLine( *it ))++it;
        if (it != in.begin()) {
            in.erase(in.begin(),it+1);
        }

        const char separator = getOsSeparator();
        for (it = in.begin(); it != in.end(); ++it) {
            int remaining = std::distance(in.end(), it);
            // Exclude :// and \\, which remain untouched.
            // https://sourceforge.net/tracker/?func=detail&aid=3031725&group_id=226462&atid=1067632
            if (remaining >= 3 && !strncmp(&*it, "://", 3 )) {
                it += 3;
                continue;
            }
            if (it == in.begin() && remaining >= 2 && !strncmp(&*it, "\\\\", 2)) {
                it += 2;
                continue;
            }

            // Cleanup path delimiters
            if (*it == '/' || (*it) == '\\') {
                *it = separator;

                // And we're removing double delimiters, frequent issue with
                // incorrectly composited paths ...
                if (last == *it) {
                    it = in.erase(it);
                    --it;
                }
            } else if (*it == '%' && in.end() - it > 2) {
                // Hex sequence in URIs
                if( IsHex((&*it)[0]) && IsHex((&*it)[1]) ) {
                    *it = HexOctetToDecimal(&*it);
                    it = in.erase(it+1,it+2);
                    --it;
                }
            }

            last = *it;
        }
    }

private:
    IOSystem *mWrapped;
    std::string mSrc_file, mBase;
    char mSep;
}

// the below code fragment can be found in:
// contrib/Open3DGC/o3dgcTriangleFans.cpp
O3DGCErrorCode    LoadIntACEGC(Vector<long> & data,
                                   const unsigned long M,
                                   const BinaryStream & bstream,
                                   unsigned long & iterator) 
    {
        unsigned long sizeSize = bstream.ReadUInt32Bin(iterator) - 12;
        unsigned long size     = bstream.ReadUInt32Bin(iterator);
        if (size == 0)
        {
            return O3DGC_OK;
        }
        long minValue   = bstream.ReadUInt32Bin(iterator) - O3DGC_MAX_LONG;
        unsigned char * buffer = 0;
        bstream.GetBuffer(iterator, buffer);
        iterator += sizeSize;
        data.Allocate(size);
        Arithmetic_Codec acd;
        acd.set_buffer(sizeSize, buffer);
        acd.start_decoder();
        Adaptive_Data_Model mModelValues(M+2);
        Static_Bit_Model bModel0;
        Adaptive_Bit_Model bModel1;
        unsigned long value;

#ifdef DEBUG_VERBOSE
        printf("-----------\nsize %i\n", size);
        fprintf(g_fileDebugTF, "size %i\n", size);
#endif //DEBUG_VERBOSE
        for(unsigned long i = 0; i < size; ++i)
        {
            value = acd.decode(mModelValues);
            if ( value == M)
            {
                value += acd.ExpGolombDecode(0, bModel0, bModel1);
            }
            data.PushBack(value + minValue);
#ifdef DEBUG_VERBOSE
            printf("%i\t%i\n", i, data[i]);
            fprintf(g_fileDebugTF, "%i\t%i\n", i, data[i]);
#endif //DEBUG_VERBOSE
        }
#ifdef DEBUG_VERBOSE
        fflush(g_fileDebugTF);
#endif //DEBUG_VERBOSE
        return O3DGC_OK;
    }

// the below code fragment can be found in:
// contrib/Open3DGC/o3dgcTriangleFans.cpp
O3DGCErrorCode    CompressedTriangleFans::SaveIntACEGC(const Vector<long> & data,
                                                            const unsigned long M,
                                                            BinaryStream & bstream) 
    {
        unsigned long start = bstream.GetSize();
        const unsigned int NMAX = data.GetSize() * 8 + 100;
        const unsigned long size       = data.GetSize();
        long minValue = 0;
        bstream.WriteUInt32Bin(0);
        bstream.WriteUInt32Bin(size);
        if (size > 0)
        {
#ifdef DEBUG_VERBOSE
            printf("-----------\nsize %i, start %i\n", size, start);
            fprintf(g_fileDebugTF, "-----------\nsize %i, start %i\n", size, start);
#endif //DEBUG_VERBOSE
            for(unsigned long i = 0; i < size; ++i)
            {
                if (minValue > data[i]) 
                {
                    minValue = data[i];
                }
#ifdef DEBUG_VERBOSE
                printf("%i\t%i\n", i, data[i]);
                fprintf(g_fileDebugTF, "%i\t%i\n", i, data[i]);
#endif //DEBUG_VERBOSE
            }
            bstream.WriteUInt32Bin(minValue + O3DGC_MAX_LONG);
            if ( m_sizeBufferAC < NMAX )
            {
                delete [] m_bufferAC;
                m_sizeBufferAC = NMAX;
                m_bufferAC     = new unsigned char [m_sizeBufferAC];
            }
            Arithmetic_Codec ace;
            ace.set_buffer(NMAX, m_bufferAC);
            ace.start_encoder();
            Adaptive_Data_Model mModelValues(M+2);
            Static_Bit_Model bModel0;
            Adaptive_Bit_Model bModel1;
            unsigned long value;
            for(unsigned long i = 0; i < size; ++i)
            {
                value = data[i]-minValue;
                if (value < M) 
                {
                    ace.encode(value, mModelValues);
                }
                else 
                {
                    ace.encode(M, mModelValues);
                    ace.ExpGolombEncode(value-M, 0, bModel0, bModel1);
                }
            }
            unsigned long encodedBytes = ace.stop_encoder();
            for(unsigned long i = 0; i < encodedBytes; ++i)
            {
                bstream.WriteUChar8Bin(m_bufferAC[i]);
            }
        }
        bstream.WriteUInt32Bin(start, bstream.GetSize() - start);
        return O3DGC_OK;
    }

// the below code fragment can be found in:
// contrib/Open3DGC/o3dgcTriangleFans.cpp
O3DGCErrorCode    CompressedTriangleFans::Load(const BinaryStream & bstream,
                                                   unsigned long & iterator, 
                                                   bool decodeTrianglesOrder,
                                                   O3DGCStreamType streamType) 
    {
#ifdef DEBUG_VERBOSE
        g_fileDebugTF = fopen("Load_new.txt", "w");
#endif //DEBUG_VERBOSE
        if (streamType == O3DGC_STREAM_TYPE_ASCII)
        {
            LoadUIntData(m_numTFANs  , bstream, iterator);
            LoadUIntData(m_degrees   , bstream, iterator);
            LoadUIntData(m_configs   , bstream, iterator);
            LoadBinData (m_operations, bstream, iterator);
            LoadIntData (m_indices   , bstream, iterator);
            if (decodeTrianglesOrder)
            {
                LoadUIntData(m_trianglesOrder , bstream, iterator);
            }
        }
        else
        {
            LoadIntACEGC(m_numTFANs  , 4 , bstream, iterator);
            LoadIntACEGC(m_degrees   , 16, bstream, iterator);
            LoadUIntAC  (m_configs   , 10, bstream, iterator);
            LoadBinAC   (m_operations,     bstream, iterator);
            LoadIntACEGC(m_indices   , 8 , bstream, iterator);
            if (decodeTrianglesOrder)
            {
                LoadIntACEGC(m_trianglesOrder , 16, bstream, iterator);
            }
        }

#ifdef DEBUG_VERBOSE
        fclose(g_fileDebugTF);
#endif //DEBUG_VERBOSE
        return O3DGC_OK;
    }

