// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// code/AssetLib/LWO/LWOAnimation.cpp
// void AnimResolver::ClearAnimRangeSetup() {
//     for (std::list<LWO::Envelope>::iterator it = envelopes.begin(); it != envelopes.end(); ++it) {
// 
//         (*it).keys.erase((*it).keys.begin(), (*it).keys.begin() + (*it).old_first);
//         (*it).keys.erase((*it).keys.begin() + (*it).old_last + 1, (*it).keys.end());
//     }
// }

// the below code fragment can be found in:
// code/AssetLib/LWO/LWOAnimation.h
// namespace Assimp {
// namespace LWO {
// 
// // ---------------------------------------------------------------------------
// /** \brief List of recognized LWO envelopes
//  */
// enum EnvelopeType
// {
//     EnvelopeType_Position_X = 0x1,
//     EnvelopeType_Position_Y = 0x2,
//     EnvelopeType_Position_Z = 0x3,
// 
//     EnvelopeType_Rotation_Heading = 0x4,
//     EnvelopeType_Rotation_Pitch = 0x5,
//     EnvelopeType_Rotation_Bank = 0x6,
// 
//     EnvelopeType_Scaling_X = 0x7,
//     EnvelopeType_Scaling_Y = 0x8,
//     EnvelopeType_Scaling_Z = 0x9,
// 
//     // -- currently not yet handled
//     EnvelopeType_Color_R = 0xa,
//     EnvelopeType_Color_G = 0xb,
//     EnvelopeType_Color_B = 0xc,
// 
//     EnvelopeType_Falloff_X = 0xd,
//     EnvelopeType_Falloff_Y = 0xe,
//     EnvelopeType_Falloff_Z = 0xf,
// 
//     EnvelopeType_Unknown
// };
// 
// // ---------------------------------------------------------------------------
// /** \brief List of recognized LWO interpolation modes
//  */
// enum InterpolationType
// {
//     IT_STEP, IT_LINE, IT_TCB, IT_HERM, IT_BEZI, IT_BEZ2
// };
// 
// 
// // ---------------------------------------------------------------------------
// /** \brief List of recognized LWO pre or post range behaviours
//  */
// enum PrePostBehaviour
// {
//     PrePostBehaviour_Reset        = 0x0,
//     PrePostBehaviour_Constant     = 0x1,
//     PrePostBehaviour_Repeat       = 0x2,
//     PrePostBehaviour_Oscillate    = 0x3,
//     PrePostBehaviour_OffsetRepeat = 0x4,
//     PrePostBehaviour_Linear       = 0x5
// };
// 
// // ---------------------------------------------------------------------------
// /** \brief Data structure for a LWO animation keyframe
//  */
// struct Key {
//     Key() AI_NO_EXCEPT
//     : time()
//     , value()
//     , inter(IT_LINE)
//     , params() {
//         // empty
//     }
// 
//     //! Current time
//     double time;
// 
//     //! Current value
//     float value;
// 
//     //! How to interpolate this key with previous key?
//     InterpolationType inter;
// 
//     //! Interpolation parameters
//     float params[5];
// 
// 
//     // for std::find()
//     operator double () {
//         return time;
//     }
// };
// 
// // ---------------------------------------------------------------------------
// /** \brief Data structure for a LWO animation envelope
//  */
// struct Envelope {
//     Envelope() AI_NO_EXCEPT
//     : index()
//     , type(EnvelopeType_Unknown)
//     , pre(PrePostBehaviour_Constant)
//     , post(PrePostBehaviour_Constant)
//     , old_first(0)
//     , old_last(0) {
//         // empty
//     }
// 
//     //! Index of this envelope
//     unsigned int index;
// 
//     //! Type of envelope
//     EnvelopeType type;
// 
//     //! Pre- and post-behavior
//     PrePostBehaviour pre,post;
// 
//     //! Keyframes for this envelope
//     std::vector<Key> keys;
// 
//     // temporary data for AnimResolver
//     size_t old_first,old_last;
// };
// 
// // ---------------------------------------------------------------------------
// //! @def AI_LWO_ANIM_FLAG_SAMPLE_ANIMS
// //! Flag for AnimResolver, subsamples the input data with the rate specified
// //! by AnimResolver::SetSampleRate().
// #define AI_LWO_ANIM_FLAG_SAMPLE_ANIMS 0x1
// 
// 
// // ---------------------------------------------------------------------------
// //! @def AI_LWO_ANIM_FLAG_START_AT_ZERO
// //! Flag for AnimResolver, ensures that the animations starts at zero.
// #define AI_LWO_ANIM_FLAG_START_AT_ZERO 0x2
// 
// // ---------------------------------------------------------------------------
// /** @brief Utility class to build Assimp animations from LWO envelopes.
//  *
//  *  Used for both LWO and LWS (MOT also).
//  */
// class AnimResolver
// {
// public:
// 
//     // ------------------------------------------------------------------
//     /** @brief Construct an AnimResolver from a given list of envelopes
//      *  @param envelopes Input envelopes. May be empty.
//      *  @param Output tick rate, per second
//      *  @note The input envelopes are possibly modified.
//      */
//     AnimResolver(std::list<Envelope>& envelopes, double tick);
// 
// public:
// 
//     // ------------------------------------------------------------------
//     /** @brief Extract the bind-pose transformation matrix.
//      *  @param out Receives bind-pose transformation matrix
//      */
//     void ExtractBindPose(aiMatrix4x4& out);
// 
//     // ------------------------------------------------------------------
//     /** @brief Extract a node animation channel
//      *  @param out Receives a pointer to a newly allocated node anim.
//      *    If there's just one keyframe defined, *out is set to nullptr and
//      *    no animation channel is computed.
//      *  @param flags Any combination of the AI_LWO_ANIM_FLAG_XXX flags.
//      */
//     void ExtractAnimChannel(aiNodeAnim** out, unsigned int flags = 0);
// 
// 
//     // ------------------------------------------------------------------
//     /** @brief Set the sampling rate for ExtractAnimChannel().
//      *
//      *  Non-linear interpolations are subsampled with this rate (keys
//      *  per second). Closer sampling positions, if existent, are kept.
//      *  The sampling rate defaults to 0, if this value is not changed and
//      *  AI_LWO_ANIM_FLAG_SAMPLE_ANIMS is specified for ExtractAnimChannel(),
//      *  the class finds a suitable sample rate by itself.
//      */
//     void SetSampleRate(double sr) {
//         sample_rate = sr;
//     }
// 
//     // ------------------------------------------------------------------
//     /** @brief Getter for SetSampleRate()
//      */
//     double GetSampleRate() const {
//         return sample_rate;
//     }
// 
//     // ------------------------------------------------------------------
//     /** @brief Set the animation time range
//      *
//      *  @param first Time where the animation starts, in ticks
//      *  @param last  Time where the animation ends, in ticks
//      */
//     void SetAnimationRange(double _first, double _last) {
//         first = _first;
//         last  = _last;
// 
//         ClearAnimRangeSetup();
//         UpdateAnimRangeSetup();
//     }
// 
// protected:
// 
//     // ------------------------------------------------------------------
//     /** @brief Build linearly subsampled keys from 3 single envelopes
//      *  @param out Receives output keys
//      *  @param envl_x X-component envelope
//      *  @param envl_y Y-component envelope
//      *  @param envl_z Z-component envelope
//      *  @param flags Any combination of the AI_LWO_ANIM_FLAG_XXX flags.
//      *  @note Up to two input envelopes may be nullptr
//      */
//     void GetKeys(std::vector<aiVectorKey>& out,
//         LWO::Envelope* envl_x,
//         LWO::Envelope* envl_y,
//         LWO::Envelope* envl_z,
//         unsigned int flags);
// 
//     // ------------------------------------------------------------------
//     /** @brief Resolve a single animation key by applying the right
//      *  interpolation to it.
//      *  @param cur Current key
//      *  @param envl Envelope working on
//      *  @param time time to be interpolated
//      *  @param fill Receives the interpolated output value.
//      */
//     void DoInterpolation(std::vector<LWO::Key>::const_iterator cur,
//         LWO::Envelope* envl,double time, float& fill);
// 
//     // ------------------------------------------------------------------
//     /** @brief Almost the same, except we won't handle pre/post
//      *  conditions here.
//      *  @see DoInterpolation
//      */
//     void DoInterpolation2(std::vector<LWO::Key>::const_iterator beg,
//         std::vector<LWO::Key>::const_iterator end,double time, float& fill);
// 
//     // ------------------------------------------------------------------
//     /** @brief Interpolate 2 tracks if one is given
//      *
//      *  @param out Receives extra output keys
//      *  @param key_out Primary output key
//      *  @param time Time to interpolate for
//      */
//     void InterpolateTrack(std::vector<aiVectorKey>& out,
//         aiVectorKey& key_out,double time);
// 
//     // ------------------------------------------------------------------
//     /** @brief Subsample an animation track by a given sampling rate
//      *
//      *  @param out Receives output keys. Last key at input defines the
//      *    time where subsampling starts.
//      *  @param time Time to end subsampling at
//      *  @param sample_delta Time delta between two samples
//      */
//     void SubsampleAnimTrack(std::vector<aiVectorKey>& out,
//         double time,double sample_delta);
// 
//     // ------------------------------------------------------------------
//     /** @brief Delete all keys which we inserted to match anim setup
//      */
//     void ClearAnimRangeSetup();
// 
//     // ------------------------------------------------------------------
//     /** @brief Insert extra keys to match LWO's pre and post behaviours
//      *  in a given time range [first...last]
//      */
//     void UpdateAnimRangeSetup();
// 
// private:
//     std::list<Envelope>& envelopes;
//     double sample_rate;
// 
//     LWO::Envelope* trans_x, *trans_y, *trans_z;
//     LWO::Envelope* rotat_x, *rotat_y, *rotat_z;
//     LWO::Envelope* scale_x, *scale_y, *scale_z;
// 
//     double first, last;
//     bool need_to_setup;
// 
//     // temporary storage
//     LWO::Envelope* envl_x, * envl_y, * envl_z;
//     std::vector<LWO::Key>::const_iterator cur_x,cur_y,cur_z;
//     bool end_x, end_y, end_z;
// 
//     unsigned int flags;
//     double sample_delta;
// };
// 
// } // end namespace LWO
// }

// the below code fragment can be found in:
// code/AssetLib/LWS/LWSLoader.cpp
// void LWSImporter::ReadEnvelope_Old(
//         std::list<LWS::Element>::const_iterator &it,
//         const std::list<LWS::Element>::const_iterator &end,
//         LWS::NodeDesc &nodes,
//         unsigned int /*version*/) {
//     unsigned int num, sub_num;
//     if (++it == end) goto unexpected_end;
// 
//     num = strtoul10((*it).tokens[0].c_str());
//     for (unsigned int i = 0; i < num; ++i) {
// 
//         nodes.channels.emplace_back();
//         LWO::Envelope &envl = nodes.channels.back();
// 
//         envl.index = i;
//         envl.type = (LWO::EnvelopeType)(i + 1);
// 
//         if (++it == end) {
//             goto unexpected_end;
//         }
//         sub_num = strtoul10((*it).tokens[0].c_str());
// 
//         for (unsigned int n = 0; n < sub_num; ++n) {
// 
//             if (++it == end) goto unexpected_end;
// 
//             // parse value and time, skip the rest for the moment.
//             LWO::Key key;
//             const char *c = fast_atoreal_move<float>((*it).tokens[0].c_str(), key.value);
//             SkipSpaces(&c);
//             float f;
//             fast_atoreal_move<float>((*it).tokens[0].c_str(), f);
//             key.time = f;
// 
//             envl.keys.push_back(key);
//         }
//     }
//     return;
// 
// unexpected_end:
//     ASSIMP_LOG_ERROR("LWS: Encountered unexpected end of file while parsing object motion");
// }

// the below code fragment can be found in:
// code/AssetLib/LWO/LWOAnimation.cpp
// void AnimResolver::ExtractBindPose(aiMatrix4x4 &out) {
//     // If we have no envelopes, return identity
//     if (envelopes.empty()) {
//         out = aiMatrix4x4();
//         return;
//     }
//     aiVector3D angles, scaling(1.f, 1.f, 1.f), translation;
// 
//     if (trans_x) translation.x = trans_x->keys[0].value;
//     if (trans_y) translation.y = trans_y->keys[0].value;
//     if (trans_z) translation.z = trans_z->keys[0].value;
// 
//     if (rotat_x) angles.x = rotat_x->keys[0].value;
//     if (rotat_y) angles.y = rotat_y->keys[0].value;
//     if (rotat_z) angles.z = rotat_z->keys[0].value;
// 
//     if (scale_x) scaling.x = scale_x->keys[0].value;
//     if (scale_y) scaling.y = scale_y->keys[0].value;
//     if (scale_z) scaling.z = scale_z->keys[0].value;
// 
//     // build the final matrix
//     aiMatrix4x4 s, rx, ry, rz, t;
//     aiMatrix4x4::RotationZ(angles.z, rz);
//     aiMatrix4x4::RotationX(angles.y, rx);
//     aiMatrix4x4::RotationY(angles.x, ry);
//     aiMatrix4x4::Translation(translation, t);
//     aiMatrix4x4::Scaling(scaling, s);
//     out = t * ry * rx * rz * s;
// }

// the below code fragment can be found in:
// code/AssetLib/LWO/LWOAnimation.cpp
// void AnimResolver::DoInterpolation2(std::vector<LWO::Key>::const_iterator beg,
//         std::vector<LWO::Key>::const_iterator end, double time, float &fill) {
//     switch ((*end).inter) {
// 
//     case LWO::IT_STEP:
//         // no interpolation at all - take the value of the last key
//         fill = (*beg).value;
//         return;
//     default:
// 
//         // silence compiler warning
//         break;
//     }
//     // linear interpolation - default
//     double duration = (*end).time - (*beg).time;
//     if (duration > 0.0) {
//         fill = (*beg).value + ((*end).value - (*beg).value) * (float)(((time - (*beg).time) / duration));
//     } else {
//         fill = (*beg).value;
//     }
// }

