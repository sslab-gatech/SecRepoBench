// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// libavformat/flvdec.c
// static int amf_get_string(AVIOContext *ioc, char *buffer, int buffsize)
// {
//     int ret;
//     int length = avio_rb16(ioc);
//     if (length >= buffsize) {
//         avio_skip(ioc, length);
//         return -1;
//     }
// 
//     ret = avio_read(ioc, buffer, length);
//     if (ret < 0)
//         return ret;
//     if (ret < length)
//         return AVERROR_INVALIDDATA;
// 
//     buffer[length] = '\0';
// 
//     return length;
// }

// the below code fragment can be found in:
// libavformat/flvdec.c
// static void flv_set_audio_codec(AVFormatContext *s, AVStream *astream,
//                                 AVCodecParameters *apar, int flv_codecid)
// {
//     switch (flv_codecid) {
//     // no distinction between S16 and S8 PCM codec flags
//     case FLV_CODECID_PCM:
//         apar->codec_id = apar->bits_per_coded_sample == 8
//                            ? AV_CODEC_ID_PCM_U8
// #if HAVE_BIGENDIAN
//                            : AV_CODEC_ID_PCM_S16BE;
// #else
//                            : AV_CODEC_ID_PCM_S16LE;
// #endif
//         break;
//     case FLV_CODECID_PCM_LE:
//         apar->codec_id = apar->bits_per_coded_sample == 8
//                            ? AV_CODEC_ID_PCM_U8
//                            : AV_CODEC_ID_PCM_S16LE;
//         break;
//     case FLV_CODECID_AAC:
//         apar->codec_id = AV_CODEC_ID_AAC;
//         break;
//     case FLV_CODECID_ADPCM:
//         apar->codec_id = AV_CODEC_ID_ADPCM_SWF;
//         break;
//     case FLV_CODECID_SPEEX:
//         apar->codec_id    = AV_CODEC_ID_SPEEX;
//         apar->sample_rate = 16000;
//         break;
//     case FLV_CODECID_MP3:
//         apar->codec_id      = AV_CODEC_ID_MP3;
//         ffstream(astream)->need_parsing = AVSTREAM_PARSE_FULL;
//         break;
//     case FLV_CODECID_NELLYMOSER_8KHZ_MONO:
//         // in case metadata does not otherwise declare samplerate
//         apar->sample_rate = 8000;
//         apar->codec_id    = AV_CODEC_ID_NELLYMOSER;
//         break;
//     case FLV_CODECID_NELLYMOSER_16KHZ_MONO:
//         apar->sample_rate = 16000;
//         apar->codec_id    = AV_CODEC_ID_NELLYMOSER;
//         break;
//     case FLV_CODECID_NELLYMOSER:
//         apar->codec_id = AV_CODEC_ID_NELLYMOSER;
//         break;
//     case FLV_CODECID_PCM_MULAW:
//         apar->sample_rate = 8000;
//         apar->codec_id    = AV_CODEC_ID_PCM_MULAW;
//         break;
//     case FLV_CODECID_PCM_ALAW:
//         apar->sample_rate = 8000;
//         apar->codec_id    = AV_CODEC_ID_PCM_ALAW;
//         break;
//     default:
//         avpriv_request_sample(s, "Audio codec (%x)",
//                flv_codecid >> FLV_AUDIO_CODECID_OFFSET);
//         apar->codec_tag = flv_codecid >> FLV_AUDIO_CODECID_OFFSET;
//     }
// }

// the below code fragment can be found in:
// libavformat/flvdec.c
// static int flv_set_video_codec(AVFormatContext *s, AVStream *vstream,
//                                uint32_t flv_codecid, int read)
// {
//     FFStream *const vstreami = ffstream(vstream);
//     int ret = 0;
//     AVCodecParameters *par = vstream->codecpar;
//     enum AVCodecID old_codec_id = vstream->codecpar->codec_id;
// 
//     switch (flv_codecid) {
//     case MKBETAG('h', 'v', 'c', '1'):
//         par->codec_id = AV_CODEC_ID_HEVC;
//         vstreami->need_parsing = AVSTREAM_PARSE_HEADERS;
//         break;
//     case MKBETAG('a', 'v', '0', '1'):
//         par->codec_id = AV_CODEC_ID_AV1;
//         vstreami->need_parsing = AVSTREAM_PARSE_HEADERS;
//         break;
//     case MKBETAG('v', 'p', '0', '9'):
//         par->codec_id = AV_CODEC_ID_VP9;
//         vstreami->need_parsing = AVSTREAM_PARSE_HEADERS;
//         break;
//     case FLV_CODECID_H263:
//         par->codec_id = AV_CODEC_ID_FLV1;
//         break;
//     case FLV_CODECID_REALH263:
//         par->codec_id = AV_CODEC_ID_H263;
//         break; // Really mean it this time
//     case FLV_CODECID_SCREEN:
//         par->codec_id = AV_CODEC_ID_FLASHSV;
//         break;
//     case FLV_CODECID_SCREEN2:
//         par->codec_id = AV_CODEC_ID_FLASHSV2;
//         break;
//     case FLV_CODECID_VP6:
//         par->codec_id = AV_CODEC_ID_VP6F;
//     case FLV_CODECID_VP6A:
//         if (flv_codecid == FLV_CODECID_VP6A)
//             par->codec_id = AV_CODEC_ID_VP6A;
//         if (read) {
//             if (par->extradata_size != 1) {
//                 ff_alloc_extradata(par, 1);
//             }
//             if (par->extradata)
//                 par->extradata[0] = avio_r8(s->pb);
//             else
//                 avio_skip(s->pb, 1);
//         }
//         ret = 1;     // 1 byte body size adjustment for flv_read_packet()
//         break;
//     case FLV_CODECID_H264:
//         par->codec_id = AV_CODEC_ID_H264;
//         vstreami->need_parsing = AVSTREAM_PARSE_HEADERS;
//         break;
//     case FLV_CODECID_MPEG4:
//         par->codec_id = AV_CODEC_ID_MPEG4;
//         break;
//     default:
//         avpriv_request_sample(s, "Video codec (%x)", flv_codecid);
//         par->codec_tag = flv_codecid;
//     }
// 
//     if (!vstreami->need_context_update && par->codec_id != old_codec_id) {
//         avpriv_request_sample(s, "Changing the codec id midstream");
//         return AVERROR_PATCHWELCOME;
//     }
// 
//     return ret;
// }

// the below code fragment can be found in:
// libavformat/flvdec.c
// static int flv_read_metabody(AVFormatContext *s, int64_t next_pos)
// {
//     FLVContext *flv = s->priv_data;
//     AMFDataType type;
//     AVStream *stream, *astream, *vstream;
//     AVStream av_unused *dstream;
//     AVIOContext *ioc;
//     int i;
//     char buffer[32];
// 
//     astream = NULL;
//     vstream = NULL;
//     dstream = NULL;
//     ioc     = s->pb;
// 
//     // first object needs to be "onMetaData" string
//     type = avio_r8(ioc);
//     if (type != AMF_DATA_TYPE_STRING ||
//         amf_get_string(ioc, buffer, sizeof(buffer)) < 0)
//         return TYPE_UNKNOWN;
// 
//     if (!strcmp(buffer, "onTextData"))
//         return TYPE_ONTEXTDATA;
// 
//     if (!strcmp(buffer, "onCaption"))
//         return TYPE_ONCAPTION;
// 
//     if (!strcmp(buffer, "onCaptionInfo"))
//         return TYPE_ONCAPTIONINFO;
// 
//     if (strcmp(buffer, "onMetaData") && strcmp(buffer, "onCuePoint") && strcmp(buffer, "|RtmpSampleAccess")) {
//         av_log(s, AV_LOG_DEBUG, "Unknown type %s\n", buffer);
//         return TYPE_UNKNOWN;
//     }
// 
//     // find the streams now so that amf_parse_object doesn't need to do
//     // the lookup every time it is called.
//     for (i = 0; i < s->nb_streams; i++) {
//         stream = s->streams[i];
//         if (stream->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {
//             vstream = stream;
//             flv->last_keyframe_stream_index = i;
//         } else if (stream->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {
//             astream = stream;
//             if (flv->last_keyframe_stream_index == -1)
//                 flv->last_keyframe_stream_index = i;
//         } else if (stream->codecpar->codec_type == AVMEDIA_TYPE_SUBTITLE)
//             dstream = stream;
//     }
// 
//     // parse the second object (we want a mixed array)
//     if (amf_parse_object(s, astream, vstream, buffer, next_pos, 0) < 0)
//         return -1;
// 
//     return 0;
// }

// the below code fragment can be found in:
// libavformat/argo_brp.c
// static int argo_brp_read_header(AVFormatContext *s)
// {
//     int64_t ret;
//     AVIOContext *pb = s->pb;
//     ArgoBRPDemuxContext *brp = s->priv_data;
//     uint8_t buf[FFMAX(BRP_MIN_BUFFER_SIZE, ASF_MIN_BUFFER_SIZE)];
// 
//     if ((ret = avio_read(pb, buf, BRP_FILE_HEADER_SIZE)) < 0)
//         return ret;
//     else if (ret != BRP_FILE_HEADER_SIZE)
//         return AVERROR(EIO);
// 
//     brp->fhdr.magic       = AV_RL32(buf + 0);
//     brp->fhdr.num_streams = AV_RL32(buf + 4);
//     brp->fhdr.byte_rate   = AV_RL32(buf + 8);
// 
//     if (brp->fhdr.magic != BRP_TAG)
//         return AVERROR_INVALIDDATA;
// 
//     if (brp->fhdr.num_streams > BRP_MAX_STREAMS) {
//         avpriv_request_sample(s, ">%d streams", BRP_MAX_STREAMS);
//         return AVERROR_PATCHWELCOME;
//     }
// 
//     /* Build the stream info. */
//     brp->basf.index = -1;
//     for (uint32_t i = 0; i < brp->fhdr.num_streams; i++) {
//         ArgoBRPStreamHeader *hdr = brp->streams + i;
//         AVStream *st;
// 
//         if (!(st = avformat_new_stream(s, NULL)))
//             return AVERROR(ENOMEM);
// 
//         if ((ret = avio_read(pb, buf, BRP_STREAM_HEADER_SIZE)) < 0)
//             return ret;
//         else if (ret != BRP_STREAM_HEADER_SIZE)
//             return AVERROR(EIO);
// 
//         hdr->codec_id       = AV_RL32(buf + 0);
//         hdr->id             = AV_RL32(buf + 4);
//         hdr->duration_ms    = AV_RL32(buf + 8);
//         hdr->byte_rate      = AV_RL32(buf + 12);
//         hdr->extradata_size = AV_RL32(buf + 16);
// 
//         /* This should always be the case. */
//         if (hdr->id != i)
//             return AVERROR_INVALIDDATA;
// 
//         /* Timestamps are in milliseconds. */
//         avpriv_set_pts_info(st, 64, 1, 1000);
//         st->duration           = hdr->duration_ms;
//         st->codecpar->bit_rate = hdr->byte_rate * 8;
// 
//         if ((ret = read_extradata(s, hdr, buf, sizeof(buf))) < 0) {
//             return ret;
//         } else if (ret > 0) {
//             st->codecpar->codec_type = AVMEDIA_TYPE_UNKNOWN;
//             continue;
//         }
// 
//         if (hdr->codec_id == BRP_CODEC_ID_BVID) {
//             ArgoBVIDHeader *bvid = &hdr->extradata.bvid;
// 
//             st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;
//             st->codecpar->codec_id   = AV_CODEC_ID_ARGO;
// 
//             bvid->num_frames = AV_RL32(buf +  0);
//             bvid->width      = AV_RL32(buf +  4);
//             bvid->height     = AV_RL32(buf +  8);
//             bvid->depth      = AV_RL32(buf + 12);
// 
//             if (bvid->num_frames == 0)
//                 return AVERROR_INVALIDDATA;
// 
//             /* These are from 1990's games, sanity check this. */
//             if (bvid->width >= 65536 || bvid->height >= 65536 ||
//                 bvid->depth > 24     || bvid->depth % 8 != 0) {
//                 return AVERROR_INVALIDDATA;
//             }
// 
//             st->codecpar->width  = bvid->width;
//             st->codecpar->height = bvid->height;
//             st->nb_frames = bvid->num_frames;
//             st->codecpar->bits_per_coded_sample = bvid->depth;
//         } else if (hdr->codec_id == BRP_CODEC_ID_BASF) {
//             /*
//              * It would make the demuxer significantly more complicated
//              * to support multiple BASF streams. I've never seen a file
//              * with more than one.
//              */
//             if (brp->basf.index >= 0) {
//                 avpriv_request_sample(s, "Multiple BASF streams");
//                 return AVERROR_PATCHWELCOME;
//             }
// 
//             st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;
//             st->codecpar->codec_id   = AV_CODEC_ID_ADPCM_ARGO;
//             brp->basf.index          = i;
//             ff_argo_asf_parse_file_header(&hdr->extradata.basf, buf);
// 
//             if ((ret = ff_argo_asf_validate_file_header(s, &hdr->extradata.basf)) < 0)
//                 return ret;
// 
//             st->nb_frames = hdr->extradata.basf.num_chunks;
//         } else if (hdr->codec_id == BRP_CODEC_ID_MASK) {
//             ArgoMASKHeader *mask = &hdr->extradata.mask;
// 
//             st->codecpar->codec_type = AVMEDIA_TYPE_DATA;
// 
//             mask->num_frames = AV_RL32(buf + 0);
//             mask->width      = AV_RL32(buf + 4);
//             mask->height     = AV_RL32(buf + 8);
// 
//             st->nb_frames    = mask->num_frames;
//         } else {
//             av_assert0(0); /* Caught above, should never happen. */
//         }
//     }
// 
//     /* Try to find the first BASF chunk. */
//     if (brp->basf.index >= 0) {
//         AVStream *st = s->streams[brp->basf.index];
//         ArgoBRPStreamHeader *hdr = brp->streams + brp->basf.index;
//         ArgoBRPBlockHeader blk;
//         int64_t offset;
//         int i;
// 
//         av_assert0(st->codecpar->codec_id == AV_CODEC_ID_ADPCM_ARGO);
//         av_assert0(brp->streams[brp->basf.index].extradata_size == ASF_FILE_HEADER_SIZE);
// 
//         if ((ret = avio_tell(s->pb)) < 0)
//             return ret;
// 
//         offset = ret;
// 
//         av_log(s, AV_LOG_TRACE, "Searching %d blocks for BASF...", BRP_BASF_LOOKAHEAD);
// 
//         for (i = 0; i < BRP_BASF_LOOKAHEAD; i++) {
//             if ((ret = avio_read(pb, buf, BRP_BLOCK_HEADER_SIZE)) < 0)
//                 return ret;
//             else if (ret != BRP_BLOCK_HEADER_SIZE)
//                 return AVERROR(EIO);
// 
//             blk.stream_id = AV_RL32(buf + 0);
//             blk.start_ms  = AV_RL32(buf + 4);
//             blk.size      = AV_RL32(buf + 8);
// 
//             if (blk.stream_id == brp->basf.index || blk.stream_id == -1)
//                 break;
// 
//             if ((ret = avio_skip(pb, blk.size)) < 0)
//                 return ret;
//         }
// 
//         if (i == BRP_BASF_LOOKAHEAD || blk.stream_id == -1) {
//             /* Don't error here, as there may still be a valid video stream. */
//             av_log(s, AV_LOG_TRACE, "not found\n");
//             goto done;
//         }
// 
//         av_log(s, AV_LOG_TRACE, "found at index %d\n", i);
// 
//         if (blk.size < ASF_CHUNK_HEADER_SIZE)
//             return AVERROR_INVALIDDATA;
// 
//         if ((ret = avio_read(pb, buf, ASF_CHUNK_HEADER_SIZE)) < 0)
//             return ret;
//         else if (ret != ASF_CHUNK_HEADER_SIZE)
//             return AVERROR(EIO);
// 
//         ff_argo_asf_parse_chunk_header(&brp->basf.ckhdr, buf);
// 
//         /*
//          * Special Case Hack. It seems that in files where the BASF block isn't first,
//          * v1.1 streams are allowed to be non-22050...
//          * Bump the version to 1.2 so ff_argo_asf_fill_stream() doesn't "correct" it.
//          *
//          * Found in Alien Odyssey games files in:
//          * ./GRAPHICS/COMMBUNK/{{COMADD1,COMM2_{1,2,3E},COMM3_{2,3,4,5,6}},FADE{1,2}}.BRP
//          *
//          * Either this format really inconsistent, or FX Fighter and Croc just ignored the
//          * sample rate field...
//          */
//         if (i != 0 && hdr->extradata.basf.version_major == 1 && hdr->extradata.basf.version_minor == 1)
//             hdr->extradata.basf.version_minor = 2;
// 
//         if ((ret = ff_argo_asf_fill_stream(s, st, &hdr->extradata.basf, &brp->basf.ckhdr)) < 0)
//             return ret;
// 
//         /* Convert ms to samples. */
//         st->start_time = av_rescale_rnd(blk.start_ms, st->codecpar->sample_rate, 1000, AV_ROUND_UP);
//         st->duration   = av_rescale_rnd(hdr->duration_ms, st->codecpar->sample_rate, 1000, AV_ROUND_UP);
// 
// done:
//         if ((ret = avio_seek(s->pb, offset, SEEK_SET)) < 0)
//             return ret;
//     }
//     return 0;
// }

