// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/mat73.c
static herr_t
Mat_H5ReadGroupInfoIterate(hid_t dset_id, const char *name, const H5L_info_t *info, void *op_data)
{
    matvar_t  *matvar;
    H5O_INFO_T object_info;
    struct ReadGroupInfoIterData *group_data;

    /* FIXME: follow symlinks, datatypes? */

    object_info.type = H5O_TYPE_UNKNOWN;
    H5OGET_INFO_BY_NAME(dset_id, name, &object_info, H5P_DEFAULT);
    if ( H5O_TYPE_DATASET != object_info.type && H5O_TYPE_GROUP != object_info.type )
        return 0;

    group_data = (struct ReadGroupInfoIterData *)op_data;
    if ( group_data == NULL )
        return -1;
    matvar = group_data->matvar;

    switch ( object_info.type ) {
        case H5O_TYPE_GROUP:
            /* Check that this is not the /#refs# group */
            if ( 0 == strcmp(name,"#refs#") )
                return 0;
            /* Fall through */
        case H5O_TYPE_DATASET:
            if ( matvar != NULL ) {
                matvar->internal->fieldnames[group_data->nfields] = strdup(name);
            }
            group_data->nfields++;
            break;
        default:
            /* Not possible to get here */
            break;
    }

    return 1;
}

// the below code fragment can be found in:
// src/mat73.c
int
Mat_VarReadData73(mat_t *mat,matvar_t *matvar,void *data,
          int *start,int *stride,int *edge)
{
    int err = MATIO_E_NO_ERROR, k;
    hid_t fid,dset_id,ref_id,dset_space,mem_space;
    hsize_t *dset_start_stride_edge;
    hsize_t *dset_start, *dset_stride, *dset_edge;

    if ( NULL == mat || NULL == matvar || NULL == data || NULL == start ||
         NULL == stride || NULL == edge )
         return MATIO_E_BAD_ARGUMENT;
    else if ( NULL == matvar->internal->hdf5_name && 0 > matvar->internal->id )
        return MATIO_E_FAIL_TO_IDENTIFY;

    fid = *(hid_t*)mat->fp;

    dset_start_stride_edge = (hsize_t*)malloc(matvar->rank*3*sizeof(hsize_t));
    if ( NULL == dset_start_stride_edge ) {
        return MATIO_E_OUT_OF_MEMORY;
    }
    dset_start  = &dset_start_stride_edge[0];
    dset_stride = &dset_start_stride_edge[matvar->rank];
    dset_edge   = &dset_start_stride_edge[2*matvar->rank];

    for ( k = 0; k < matvar->rank; k++ ) {
        dset_start[k]  = start[matvar->rank-k-1];
        dset_stride[k] = stride[matvar->rank-k-1];
        dset_edge[k]   = edge[matvar->rank-k-1];
    }
    mem_space = H5Screate_simple(matvar->rank, dset_edge, NULL);

    switch ( matvar->class_type ) {
        case MAT_C_DOUBLE:
        case MAT_C_SINGLE:
        case MAT_C_INT64:
        case MAT_C_UINT64:
        case MAT_C_INT32:
        case MAT_C_UINT32:
        case MAT_C_INT16:
        case MAT_C_UINT16:
        case MAT_C_INT8:
        case MAT_C_UINT8:
            if ( NULL != matvar->internal->hdf5_name ) {
                ref_id = H5Dopen(fid,matvar->internal->hdf5_name,H5P_DEFAULT);
            } else {
                ref_id = matvar->internal->id;
                H5Iinc_ref(ref_id);
            }
            if ( 0 < matvar->internal->hdf5_ref ) {
                dset_id = H5RDEREFERENCE(ref_id,H5R_OBJECT,&matvar->internal->hdf5_ref);
            } else {
                dset_id = ref_id;
                H5Iinc_ref(dset_id);
            }

            dset_space = H5Dget_space(dset_id);
            H5Sselect_hyperslab(dset_space, H5S_SELECT_SET, dset_start,
                                dset_stride, dset_edge, NULL);
            Mat_H5ReadData(dset_id, ClassType2H5T(matvar->class_type), mem_space,
                dset_space, matvar->isComplex, data);
            H5Sclose(dset_space);
            H5Dclose(dset_id);
            H5Dclose(ref_id);
            break;
        default:
            err = MATIO_E_FAIL_TO_IDENTIFY;
            break;
    }
    H5Sclose(mem_space);
    free(dset_start_stride_edge);

    return err;
}

// the below code fragment can be found in:
// src/mat73.c
static void
Mat_H5ReadNextReferenceInfo(hid_t ref_id,matvar_t *matvar,mat_t *mat)
{
    if ( ref_id < 0 || matvar == NULL )
        return;

    switch ( H5Iget_type(ref_id) ) {
        case H5I_DATASET:
            Mat_H5ReadDatasetInfo(mat,matvar,ref_id);
            if ( matvar->internal->id != ref_id ) {
                /* Close dataset and increment count */
                H5Dclose(ref_id);
            }

            /*H5Dclose(ref_id);*/
            break;

        case H5I_GROUP:
            Mat_H5ReadGroupInfo(mat,matvar,ref_id);
            break;

        default:
            break;
    }

    return;
}

// the below code fragment can be found in:
// src/mat73.c
static size_t*
Mat_H5ReadDims(hid_t dset_id, hsize_t *nelems, int *rank)
{
    hid_t space_id;
    size_t* perm_dims;

    *nelems = 0;
    space_id = H5Dget_space(dset_id);
    *rank = H5Sget_simple_extent_ndims(space_id);
    if ( 0 > *rank ) {
        *rank = 0;
        H5Sclose(space_id);
        return NULL;
    }
    perm_dims = (size_t*)malloc(*rank*sizeof(*perm_dims));
    if ( NULL != perm_dims ) {
        int err = 0;
        if ( MAX_RANK >= *rank ) {
            hsize_t dims[MAX_RANK];
            int k;
            size_t tmp = 1;
            (void)H5Sget_simple_extent_dims(space_id,dims,NULL);
            /* Permute dimensions */
            for ( k = 0; k < *rank; k++ ) {
                perm_dims[k] = (size_t)dims[*rank - k - 1];
                err |= Mul(&tmp, tmp, perm_dims[k]);
            }
            if ( err ) {
                Mat_Critical("Integer multiplication overflow");
                free(perm_dims);
                perm_dims = NULL;
                *rank = 0;
            }
            *nelems = (hsize_t)tmp;
            H5Sclose(space_id);
        } else {
            hsize_t* dims = (hsize_t*)malloc(*rank*sizeof(hsize_t));
            if ( NULL != dims ) {
                int k;
                size_t tmp = 1;
                (void)H5Sget_simple_extent_dims(space_id,dims,NULL);
                /* Permute dimensions */
                for ( k = 0; k < *rank; k++ ) {
                    perm_dims[k] = (size_t)dims[*rank - k - 1];
                    err |= Mul(&tmp, tmp, perm_dims[k]);
                }
                if ( err ) {
                    Mat_Critical("Integer multiplication overflow");
                    free(perm_dims);
                    perm_dims = NULL;
                    *rank = 0;
                }
                *nelems = (hsize_t)tmp;
                free(dims);
                H5Sclose(space_id);
            } else {
                free(perm_dims);
                perm_dims = NULL;
                *rank = 0;
                H5Sclose(space_id);
                Mat_Critical("Error allocating memory for dims");
            }
        }
    } else {
        *rank = 0;
        H5Sclose(space_id);
        Mat_Critical("Error allocating memory for matvar->dims");
    }

    return perm_dims;
}

// the below code fragment can be found in:
// src/mat73.c
static int
Mat_VarWriteCell73(hid_t id,matvar_t *matvar,const char *name,hid_t *refs_id,hsize_t *dims)
{
    int        k;
    hsize_t    nelems = 1, l;
    matvar_t **cells;
    int        err = MATIO_E_NO_ERROR;

    cells = (matvar_t**)matvar->data;
    for ( k = 0; k < matvar->rank; k++ )
        nelems *= dims[k];

    if ( 0 == nelems || NULL == matvar->data ) {
        err = Mat_VarWriteEmpty(id, matvar, name, ClassNames[matvar->class_type]);
    } else {
        if ( *refs_id < 0 ) {
            if ( H5Lexists(id,"/#refs#",H5P_DEFAULT) ) {
                *refs_id = H5Gopen(id,"/#refs#",H5P_DEFAULT);
            } else {
                *refs_id = H5Gcreate(id,"/#refs#",H5P_DEFAULT,
                                     H5P_DEFAULT,H5P_DEFAULT);
            }
        }
        if ( *refs_id > -1 ) {
            hobj_ref_t *refs = (hobj_ref_t*)malloc((size_t)nelems*sizeof(*refs));
            if ( NULL != refs ) {
                hid_t mspace_id = H5Screate_simple(matvar->rank,dims,NULL);
                hid_t dset_id = H5Dcreate(id,name,H5T_STD_REF_OBJ,mspace_id,
                                    H5P_DEFAULT,H5P_DEFAULT,H5P_DEFAULT);

                for ( l = 0; l < nelems; l++ ) {
                    err = Mat_VarWriteRef(id, cells[l], matvar->compression,
                                           refs_id, refs+l);
                    if ( err )
                        break;
                }
                if ( MATIO_E_NO_ERROR == err ) {
                    err = Mat_H5WriteData(dset_id, H5T_STD_REF_OBJ, H5S_ALL, H5S_ALL,
                                           0, refs);

                    if (  MATIO_E_NO_ERROR == err ) {
                        hid_t attr_id,aspace_id;
                        hid_t str_type_id = H5Tcopy(H5T_C_S1);
                        H5Tset_size(str_type_id,4);
                        aspace_id = H5Screate(H5S_SCALAR);
                        attr_id = H5Acreate(dset_id,"MATLAB_class",str_type_id,
                                            aspace_id,H5P_DEFAULT,H5P_DEFAULT);
                        if ( 0 > H5Awrite(attr_id,str_type_id,"cell") )
                            err = MATIO_E_GENERIC_WRITE_ERROR;
                        H5Aclose(attr_id);
                        H5Sclose(aspace_id);
                        H5Tclose(str_type_id);
                    }
                }
                H5Dclose(dset_id);
                free(refs);
                H5Sclose(mspace_id);
            } else {
                err = MATIO_E_OUT_OF_MEMORY;
            }
        } else {
            err = MATIO_E_OUTPUT_BAD_DATA;
        }
    }

    return err;
}

