// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/filters/load_bt_xmt.c
static const char *ctxload_probe_data(const u8 *probe_data, u32 size, GF_FilterProbeScore *score)
{
	const char *mime_type = NULL;
	char *dst = NULL;
	GF_Err e;
	u32 probe_size=size;
	char *res=NULL;

	/* check gzip magic header */
	if ((size>2) && (probe_data[0] == 0x1f) && (probe_data[1] == 0x8b)) {
		*score = GF_FPROBE_EXT_MATCH;
		return "btz|bt.gz|xmt.gz|xmtz|wrl.gz|x3dv.gz|x3dvz|x3d.gz|x3dz";
	}

	e = gf_utf_get_string_from_bom(probe_data, size, &dst, &res, &probe_size);
	if (e) return NULL;
	probe_data = res;

	//strip all spaces and \r\n
	while (probe_size && probe_data[0] && strchr("\n\r\t ", (char) probe_data[0])) {
		probe_data ++;
		probe_size--;
	}

	//for XML, strip doctype, <?xml and comments
	while (1) {
		char *search=NULL;
		if (!strncmp(probe_data, "<!DOCTYPE", 9)) {
			search = ">";
		}
		//for XML, strip xml header
		else if (!strncmp(probe_data, "<?xml", 5)) {
			search = "?>";
		}
		else if (!strncmp(probe_data, "<!--", 4)) {
			search = "-->";
		} else {
			break;
		}
		const char *res = gf_strmemstr(probe_data, probe_size, search);
		if (!res) goto exit;
		res += strlen(search);
		probe_size -= (u32) (res - (char*)probe_data);
		probe_data = res;
		while (probe_size && probe_data[0] && strchr("\n\r\t ", (char) probe_data[0])) {
			probe_data ++;
			probe_size--;
		}
	}
	//probe_data is now the first element of the document, if XML
	//we should refine by getting the xmlns attribute value rather than searching for its value...

	if (gf_strmemstr(probe_data, probe_size, "http://www.w3.org/1999/XSL/Transform")
	) {
	} else if (!strncmp(probe_data, "<XMT-A", strlen("<XMT-A"))
		|| gf_strmemstr(probe_data, probe_size, "urn:mpeg:mpeg4:xmta:schema:2002")
	) {
		mime_type = "application/x-xmt";
	} else if (gf_strmemstr(probe_data, probe_size, "<X3D")
		|| gf_strmemstr(probe_data, probe_size, "http://www.web3d.org/specifications/x3d-3.0.xsd")
	) {
		mime_type = "model/x3d+xml";
	} else if (gf_strmemstr(probe_data, probe_size, "<saf")
		|| gf_strmemstr(probe_data, probe_size, "urn:mpeg:mpeg4:SAF:2005")
		|| gf_strmemstr(probe_data, probe_size, "urn:mpeg:mpeg4:LASeR:2005")
	) {
		mime_type = "application/x-LASeR+xml";
	} else if (!strncmp(probe_data, "<DIMSStream", strlen("<DIMSStream") ) ) {
		mime_type = "application/dims";
	} else if (!strncmp(probe_data, "<svg", 4) || gf_strmemstr(probe_data, probe_size, "http://www.w3.org/2000/svg") ) {
		mime_type = "image/svg+xml";
	} else if (!strncmp(probe_data, "<widget", strlen("<widget") ) ) {
		mime_type = "application/widget";
	} else if (!strncmp(probe_data, "<NHNTStream", strlen("<NHNTStream") ) ) {
		mime_type = "application/x-nhml";
	} else if (!strncmp(probe_data, "<TextStream", strlen("<TextStream") ) ) {
		mime_type = "text/ttxt";
	} else if (!strncmp(probe_data, "<text3GTrack", strlen("<text3GTrack") ) ) {
		mime_type = "quicktime/text";
	}
	//BT/VRML with no doc header
	else {
		//get first keyword
		while (1) {
			//strip all spaces and \r\n
			while (probe_size && probe_data[0] && strchr("\n\r\t ", (char) probe_data[0])) {
				probe_data ++;
				probe_size--;
			}
			if (!probe_size) goto exit;

			//VRML / XRDV files
			if (!strncmp(probe_data, "#VRML V2.0", strlen("#VRML V2.0"))) {
				mime_type = "model/vrml";
				goto exit;
			}
			if (!strncmp(probe_data, "#X3D V3.0", strlen("#X3D V3.0"))) {
				mime_type = "model/x3d+vrml";
				goto exit;
			}

			//skip comment lines and some specific X3D keyword (we want to fetch a group
			if ((probe_data[0] != '#')
				&& strncmp(probe_data, "PROFILE", strlen("PROFILE"))
				&& strncmp(probe_data, "COMPONENT", strlen("COMPONENT"))
				&& strncmp(probe_data, "META", strlen("META"))
				&& strncmp(probe_data, "IMPORT", strlen("IMPORT"))
				&& strncmp(probe_data, "EXPORT", strlen("EXPORT"))
			) {
				break;
			}
			//skip line and go one
			const char *next = gf_strmemstr(probe_data, probe_size, "\n");
			if (!next) goto exit;
			probe_size -= (u32) (next - (char*)probe_data);
			probe_data = next;
		}

		if (!strncmp(probe_data, "InitialObjectDescriptor", strlen("InitialObjectDescriptor"))
			|| !strncmp(probe_data, "EXTERNPROTO", strlen("EXTERNPROTO"))
			|| !strncmp(probe_data, "PROTO", strlen("PROTO"))
			|| !strncmp(probe_data, "Group", strlen("Group"))
			|| !strncmp(probe_data, "OrderedGroup", strlen("OrderedGroup"))
			|| !strncmp(probe_data, "Layer2D", strlen("Layer2D"))
			|| !strncmp(probe_data, "Layer3D", strlen("Layer3D"))
		) {
			if (gf_strmemstr(probe_data, probe_size, "children"))
				mime_type = "application/x-bt";
		}
	}

exit:

	if (dst) gf_free(dst);
	if (mime_type) {
		*score = GF_FPROBE_MAYBE_SUPPORTED;
		return mime_type;
	}

	*score = GF_FPROBE_NOT_SUPPORTED;
	return NULL;
}

// the below code fragment can be found in:
// src/filters/dmx_gsf.c
static const char *gsfdmx_probe_data(const u8 *data, u32 data_size, GF_FilterProbeScore *score)
{
	u32 avail = data_size;
	if (data_size < 10) return NULL;
	char *buf = (char *) data;
	while (buf) {
		char *start_sig = memchr(buf, 'G', avail);
		if (!start_sig) return NULL;
		buf = start_sig;
		avail = data_size - (u32) ( buf - (char *) data);
		if (avail<5) return NULL;
		//signature found and version is 2
		if (!strncmp(start_sig, "GS5F", 4) && (start_sig[4] == GF_GSF_VERSION)) {
			*score = GF_FPROBE_SUPPORTED;
			return "application/x-gpac-sf";
		}
		buf ++;
		avail --;
	}
	return NULL;
}

// the below code fragment can be found in:
// src/filters/ff_dmx.c
static const char *ffdmx_probe_data(const u8 *data, u32 size, GF_FilterProbeScore *score)
{
	int ffscore;
	const AVInputFormat *probe_fmt;
	AVProbeData pb;

#if (LIBAVFORMAT_VERSION_MAJOR < 59)
	av_register_all();
#endif

	memset(&pb, 0, sizeof(AVProbeData));
	ff_probe_mode=GF_TRUE;
	//not setting this crashes some probers in ffmpeg
	pb.filename = "";
	if (size <= AVPROBE_PADDING_SIZE) {
		pb.buf = gf_malloc(sizeof(char) * (size+AVPROBE_PADDING_SIZE) );
		memcpy(pb.buf, data, sizeof(char)*size);
		memset(pb.buf+size, 0, sizeof(char)*AVPROBE_PADDING_SIZE);
		pb.buf_size = size;
		probe_fmt = av_probe_input_format3(&pb, GF_TRUE, &ffscore);
		if (ffscore<=AVPROBE_SCORE_RETRY/2) probe_fmt=NULL;
		if (!probe_fmt) probe_fmt = av_probe_input_format3(&pb, GF_FALSE, &ffscore);
		if (ffscore<=AVPROBE_SCORE_RETRY/2) probe_fmt=NULL;
		gf_free(pb.buf);
	} else {
		pb.buf =  (char *) data;
		pb.buf_size = size - AVPROBE_PADDING_SIZE;
		probe_fmt = av_probe_input_format3(&pb, GF_TRUE, &ffscore);
		if (ffscore<=AVPROBE_SCORE_RETRY/2) probe_fmt=NULL;
		if (!probe_fmt) probe_fmt = av_probe_input_format3(&pb, GF_FALSE, &ffscore);
		if (ffscore<=AVPROBE_SCORE_RETRY/2) probe_fmt=NULL;
	}
	ff_probe_mode=GF_FALSE;

	if (!probe_fmt) return NULL;
	if (probe_fmt->mime_type) {
		//TODO try to refine based on ffprobe score
		*score = GF_FPROBE_MAYBE_SUPPORTED;
		return probe_fmt->mime_type;
	}
	*score = (ffscore==AVPROBE_SCORE_MAX) ? GF_FPROBE_MAYBE_SUPPORTED : GF_FPROBE_MAYBE_NOT_SUPPORTED;
	return "video/x-ffmpeg";
}

// the below code fragment can be found in:
// src/filters/reframe_mpgvid.c
static const char * mpgvdmx_probe_data(const u8 *data, u32 size, GF_FilterProbeScore *score)
{
	GF_M4VParser *parser;
	u8 ftype;
	u32 tinc, nb_frames, o_start=0;
	u64 fsize, start;
	Bool is_coded;
	GF_Err e;
	GF_M4VDecSpecInfo dsi;

	memset(&dsi, 0, sizeof(GF_M4VDecSpecInfo));
	parser = gf_m4v_parser_new((char*)data, size, GF_FALSE);
	nb_frames = 0;
	while (1) {
		u32 otype;
		ftype = 0;
		is_coded = GF_FALSE;
		e = gf_m4v_parse_frame(parser, &dsi, &ftype, &tinc, &fsize, &start, &is_coded);
		if (!nb_frames && start) o_start = (u32) start;

		otype = gf_m4v_parser_get_obj_type(parser);
		switch (otype) {
		case M4V_VOL_START_CODE:
		case M4V_VOP_START_CODE:
		case M4V_VISOBJ_START_CODE:
		case M4V_VOS_START_CODE:
		case M4V_GOV_START_CODE:
		case M4V_UDTA_START_CODE:
			break;
		default:
			otype = 0;
		}

		//if start is more than 4 (start-code size), we have garbage at the beginning, do not parse
		//except if we have a valid object VOS
		if (!nb_frames && (start>4) && !otype) {
			break;
		}
		if (is_coded) nb_frames++;
		if (e==GF_EOS) {
			e = GF_OK;
			//special case if the only frame we have is not coded
			if (otype == M4V_VOP_START_CODE) {
				if (!nb_frames) nb_frames++;
				is_coded = 1;
			}

			if (is_coded) nb_frames++;
			break;
		}
		if (ftype>2) break;
		if (e) break;
		nb_frames++;
	}
	gf_m4v_parser_del(parser);
	if ((e==GF_OK) && (nb_frames>1)) {
		*score = o_start ? GF_FPROBE_MAYBE_NOT_SUPPORTED : GF_FPROBE_MAYBE_SUPPORTED;
		return "video/mp4v-es";
	}

	memset(&dsi, 0, sizeof(GF_M4VDecSpecInfo));
	parser = gf_m4v_parser_new((char*)data, size, GF_TRUE);
	nb_frames = 0;
	while (1) {
		ftype = 0;
		is_coded = GF_FALSE;
		e = gf_m4v_parse_frame(parser, &dsi, &ftype, &tinc, &fsize, &start, &is_coded);

		//if start is more than 4 (start-code size), we have garbage at the beginning, do not parse
		if (!nb_frames && (start>4) ) {
			break;
		}
		if (is_coded) nb_frames++;
		if (e==GF_EOS) {
			if (is_coded) nb_frames++;
			e = GF_OK;
			break;
		}
		if (ftype>2) break;
		if (e) break;
		nb_frames++;
	}
	gf_m4v_parser_del(parser);
	if ((e==GF_OK) && (nb_frames>1)) {
		*score = o_start ? GF_FPROBE_MAYBE_NOT_SUPPORTED : GF_FPROBE_MAYBE_SUPPORTED;
		return "video/mpgv-es";
	}
	return NULL;
}

// the below code fragment can be found in:
// src/filters/reframe_mp3.c
static const char *mp3_dmx_probe_data(const u8 *data, u32 size, GF_FilterProbeScore *score)
{
	u32 nb_frames=0;
	u32 pos=0;
	u32 prev_pos=0;
	s32 prev_sr_idx=-1;
	s32 prev_ch=-1;
	s32 prev_layer=-1;
	s32 init_pos = -1;
	Bool has_id3 = GF_FALSE;

	/* Check for ID3 */
	if (size>= 10) {
		if (data[0] == 'I' && data[1] == 'D' && data[2] == '3') {
			u32 tag_size = ((data[9] & 0x7f) + ((data[8] & 0x7f) << 7) + ((data[7] & 0x7f) << 14) + ((data[6] & 0x7f) << 21));

			if (tag_size+10>size) {
				GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, ("ID3 tag detected size %d but probe data only %d bytes, will rely on file extension (try increasing probe size using --block_size)\n", tag_size+10, size));
				*score = GF_FPROBE_EXT_MATCH;
				return "mp3|mp2|mp1";
			}
			data += tag_size+10;
			size -= tag_size+10;
			has_id3 = GF_TRUE;
		}
	}

	while (1) {
		u32 hdr = gf_mp3_get_next_header_mem(data, size, &pos);
		if (!hdr) break;

		if (init_pos<0) init_pos = pos;

		if (gf_mp3_version(hdr) > 3)
			break;
		//check sample rate
		u8 val = (hdr >> 10) & 0x3;
		if (val>2)
			break;
		u32 fsize = gf_mp3_frame_size(hdr);
		if (prev_pos && pos) {
			nb_frames=0;
			break;
		}

		if (prev_sr_idx>=0) {
			if ((u8) prev_sr_idx != val) {
				nb_frames=0;
				break;
			}
		}
		prev_sr_idx = val;

		val = gf_mp3_num_channels(hdr);
		if (prev_ch>=0) {
			if ((u8) prev_ch != val) {
				nb_frames=0;
				break;
			}
		}
		prev_ch = val;

		val = gf_mp3_layer(hdr);
		if (prev_layer>=0) {
			if ((u8) prev_layer != val) {
				nb_frames=0;
				break;
			}
		}
		prev_layer = val;

		if (fsize + pos > size) {
			nb_frames++;
			break;
		}

		prev_pos = pos;
		nb_frames++;
		if (nb_frames>4) break;
		if (size < fsize + pos) break;
		size -= fsize + pos;
		data += fsize + pos;
	}

	if (nb_frames>=2) {
		*score = (init_pos==0) ? GF_FPROBE_SUPPORTED : GF_FPROBE_MAYBE_NOT_SUPPORTED;
		return "audio/mp3";
	}
	if (nb_frames && has_id3) {
		*score = GF_FPROBE_MAYBE_SUPPORTED;
		return "audio/mp3";
	}
	return NULL;
}

