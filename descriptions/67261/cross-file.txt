// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/filters/load_bt_xmt.c
const GF_FilterRegister *btplay_register(GF_FilterSession *session)
{
#if !defined(GPAC_DISABLE_VRML) && !defined(GPAC_DISABLE_SCENEGRAPH) && !defined(GPAC_DISABLE_COMPOSITOR)  && !defined(GPAC_DISABLE_SMGR)
	return &CTXLoadRegister;
#else
	return NULL;
#endif
}

// the below code fragment can be found in:
// src/filters/decrypt_cenc_isma.c
static GF_Err cenc_dec_set_hls_key(GF_CENCDecCtx *ctx, GF_CENCDecStream *cstr, char *key_url, u8 *key_IV)
{
	cstr->is_hls = GF_TRUE;

	//copy IV
	memcpy(cstr->hls_IV, key_IV, sizeof(bin128));
	//switch key if needed IV
	if (cstr->hls_key_url && key_url && !strcmp(cstr->hls_key_url, key_url)) {
		if (cstr->crypt_init)
			gf_crypt_set_IV(cstr->crypts[0].crypt, cstr->hls_IV, 16);
		return GF_OK;
	}

	if (cstr->hls_key_url) gf_free(cstr->hls_key_url);

	if (!key_url) {
		cstr->hls_key_url = NULL;
		return GF_OK;
	}
	cstr->hls_key_url = gf_strdup(key_url);
	if (!cstr->hls_key_url) {
		return GF_OUT_OF_MEM;
	}
	GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[CENC/HLS] Switching key to %s\n", key_url))

	if (ctx->hls_cenc_patch_iv)
		cstr->force_hls_iv = GF_TRUE;

	cstr->KID_count = 1;
	cstr->keys = (bin128 *)gf_realloc(cstr->keys, cstr->KID_count*sizeof(bin128));

	if (!strncmp(key_url, "urn:gpac:keys:value:", 20)) {
		u32 i;
		u8 *key_data = (u8 *) cstr->keys[0];
		key_url += 20;
		if (!strncmp(key_url, "0x", 2)) key_url += 2;
		i = (u32) strlen(key_url);
		if (i != 32) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[CENC/HLS] key %s not found\n", key_url))
			return GF_BAD_PARAM;
		}
		for (i=0; i<16; i++) {
			char szV[3];
			u32 v;
			szV[0] = key_url[2*i];
			szV[1] = key_url[2*i + 1];
			szV[2] = 0;
			sscanf(szV, "%X", &v);
			key_data[i] = v;
		}
	}
	//key is local, activate right away
	else if (gf_url_is_local(key_url)) {
		FILE *fkey = gf_fopen(key_url, "rb");
		if (!fkey) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[CENC/HLS] key %s not found\n", key_url))
			return GF_URL_ERROR;
		} else {
			u32 read = (u32) gf_fread(cstr->keys[0], 16, fkey);
			if (read != 16) {
				GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[CENC/HLS] key %s too short, expecting 16 bytes got %d\n", key_url, read))
				return GF_BAD_PARAM;
			}
			gf_fclose(fkey);
		}
	}
	//load key
	else {
		GF_Err e = GF_SERVICE_ERROR;
#ifdef GPAC_USE_DOWNLOADER
		GF_DownloadManager *dm = gf_filter_get_download_manager(ctx->filter);
		GF_DownloadSession *sess = gf_dm_sess_new(dm, key_url, GF_NETIO_SESSION_NOT_CACHED, hls_kms_io, cstr, &e);
		if (e) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[CENC/HLS] Failed to setup download session for key %s: %s\n", key_url, gf_error_to_string(e)))
			return e;
		}
		ctx->pending_keys++;
		return gf_dm_sess_process(sess);
#else
		e = GF_NOT_SUPPORTED;
#endif
	}

	if (!cstr->crypts) {
		cstr->crypts = gf_malloc(sizeof(CENCDecKey));
		memset(cstr->crypts, 0, sizeof(CENCDecKey));
	}
	memcpy(cstr->crypts[0].key, cstr->keys[0], sizeof(bin128));
	cstr->crypts[0].key_valid = 1;

	return GF_OK;
}

// the below code fragment can be found in:
// src/filters/decrypt_cenc_isma.c
static GF_Err cenc_dec_set_clearkey(GF_CENCDecCtx *ctx, GF_CENCDecStream *cstr, char *ck_url, u8 *ck_kid)
{
	GF_Err e;
	char data64[32];
	u32 i, cklen, res = gf_base64_encode(ck_kid, 16, data64, 32);
	data64[res]=0;
	for (i=0; i<res; i++) {
		if (data64[i]=='+') data64[i] = '-';
		else if (data64[i]=='/') data64[i] = '_';
	}
	while (data64[res-1]=='=') {
		data64[res-1]=0;
		res--;
		if (!res) break;
	}
	if (cstr->body) gf_free(cstr->body);
	cstr->body = NULL;
	gf_dynstrcat(&cstr->body, "{\"kids\": [\"", NULL);
	gf_dynstrcat(&cstr->body, data64, NULL);
	gf_dynstrcat(&cstr->body, "\"], \"type\":\"temporary\"}", NULL);

	cklen = (u32) strlen(cstr->body);
	u32 crc = gf_crc_32(cstr->body, cklen);
	if (cstr->clearkey_crc == crc) return GF_OK;

#ifdef GPAC_USE_DOWNLOADER
	GF_DownloadManager *dm = gf_filter_get_download_manager(ctx->filter);
	cstr->sess = gf_dm_sess_new(dm, ck_url, 0, ck_http_io, cstr, &e);
	if (e) return e;
	ctx->pending_keys++;
	return gf_dm_sess_process(cstr->sess);
#else
	return GF_NOT_SUPPORTED;
#endif
}

// the below code fragment can be found in:
// src/filters/reframe_rawvid.c
const GF_FilterRegister *rfrawvid_register(GF_FilterSession *session)
{
	RawVidReframeArgs[1].min_max_enum = gf_pixel_fmt_all_names();
	RawVidReframeCaps[1].val.value.string = (char *) gf_pixel_fmt_all_shortnames();
	return &RawVidReframeRegister;
}

// the below code fragment can be found in:
// src/filters/reframe_av1.c
const GF_FilterRegister *rfav1_register(GF_FilterSession *session)
{
	return &AV1DmxRegister;
}

