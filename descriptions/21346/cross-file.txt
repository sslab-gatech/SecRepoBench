// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/lib/protocols/yahoo.c
void ndpi_search_yahoo(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow)
{
  struct ndpi_packet_struct *packet = &flow->packet;

  NDPI_LOG_DBG(ndpi_struct, "search yahoo\n");
  
  if(packet->payload_packet_len > 0 && flow->yahoo_detection_finished == 0) {

    /* search over TCP */
    if(packet->tcp != NULL && packet->tcp_retransmission == 0) {

      if(packet->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN
	 || packet->detected_protocol_stack[0] == NDPI_PROTOCOL_HTTP
	 || packet->detected_protocol_stack[0] == NDPI_PROTOCOL_TLS) {
        /* search over TCP */
	ndpi_search_yahoo_tcp(ndpi_struct, flow);
      }
    }
    /* search over UDP */
    else if(packet->udp != NULL) {
      if ( flow->src == NULL || 
	   NDPI_COMPARE_PROTOCOL_TO_BITMASK(flow->src->detected_protocol_bitmask, NDPI_PROTOCOL_YAHOO) == 0) {
	NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
      }
      return;
    }
  }

  if(packet->payload_packet_len > 0 && flow->yahoo_detection_finished == 2) {
    if(packet->tcp != NULL && packet->tcp_retransmission == 0) {
      /* search over TCP */
      ndpi_search_yahoo_tcp(ndpi_struct, flow);
      return;
    }
  }
}

// the below code fragment can be found in:
// src/lib/protocols/thunder.c
void ndpi_search_thunder(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow)
{
  struct ndpi_packet_struct *packet = &flow->packet;
  //
  //struct ndpi_id_struct *src = flow->src;
  //struct ndpi_id_struct *dst = flow->dst;

  if (packet->tcp != NULL) {
    ndpi_int_search_thunder_http(ndpi_struct, flow);
    ndpi_int_search_thunder_tcp(ndpi_struct, flow);
  } else if (packet->udp != NULL) {
    ndpi_int_search_thunder_udp(ndpi_struct, flow);
  }
}

// the below code fragment can be found in:
// src/lib/protocols/gnutella.c
void init_gnutella_dissector(struct ndpi_detection_module_struct *ndpi_struct, u_int32_t *id, NDPI_PROTOCOL_BITMASK *detection_bitmask)
{
  ndpi_set_bitmask_protocol_detection("Gnutella", ndpi_struct, detection_bitmask, *id,
				      NDPI_PROTOCOL_GNUTELLA,
				      ndpi_search_gnutella,
				      NDPI_SELECTION_BITMASK_PROTOCOL_V4_V6_TCP_OR_UDP_WITH_PAYLOAD_WITHOUT_RETRANSMISSION,
				      SAVE_DETECTION_BITMASK_AS_UNKNOWN,
				      ADD_TO_DETECTION_BITMASK);

  *id += 1;
}

// the below code fragment can be found in:
// src/lib/protocols/http.c
static void ndpi_search_http_tcp(struct ndpi_detection_module_struct *ndpi_struct,
				 struct ndpi_flow_struct *flow) {
  /* Break after 20 packets. */
  if(flow->packet_counter > 20) {
    NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
    http_bitmask_exclude_other(flow);
    return;
  }

  NDPI_LOG_DBG(ndpi_struct, "search HTTP\n");
  ndpi_check_http_tcp(ndpi_struct, flow);
}

// the below code fragment can be found in:
// src/lib/protocols/msn.c
static void ndpi_search_msn_udp_misc(struct ndpi_detection_module_struct
				     *ndpi_struct, struct ndpi_flow_struct *flow)
{
  struct ndpi_packet_struct *packet = &flow->packet;

  struct ndpi_id_struct *src = flow->src;
  struct ndpi_id_struct *dst = flow->dst;


  /* do we have an msn login ? */
  if ((src == NULL || NDPI_COMPARE_PROTOCOL_TO_BITMASK(src->detected_protocol_bitmask, NDPI_PROTOCOL_MSN) == 0)
      && (dst == NULL
	  || NDPI_COMPARE_PROTOCOL_TO_BITMASK(dst->detected_protocol_bitmask, NDPI_PROTOCOL_MSN) == 0)) {
    NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
    return;
  }

  /* asymmetric ft detection works */
  if (packet->payload_packet_len == 20
      && get_u_int32_t(packet->payload, 4) == 0 && packet->payload[9] == 0
      && get_u_int16_t(packet->payload, 10) == htons(0x0100)) {
    NDPI_LOG_INFO(ndpi_struct, "found MSN udp misc data connection\n");
    ndpi_int_msn_add_connection(ndpi_struct, flow);
  }

  /* asymmetric detection working. */
  return;
  //}
}

