// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/hunspell/affentry.cxx
struct hentry* SfxEntry::checkword(const std::string& word,
                                   int start,
                                   int len,
                                   int optflags,
                                   PfxEntry* ppfx,
                                   const FLAG cclass,
                                   const FLAG needflag,
                                   const FLAG badflag) {
  struct hentry* he;  // hash entry pointer
  PfxEntry* ep = ppfx;

  // if this suffix is being cross checked with a prefix
  // but it does not support cross products skip it

  if (((optflags & aeXPRODUCT) != 0) && ((opts & aeXPRODUCT) == 0))
    return NULL;

  // upon entry suffix is 0 length or already matches the end of the word.
  // So if the remaining root word has positive length
  // and if there are enough chars in root word and added back strip chars
  // to meet the number of characters conditions, then test it

  int tmpl = len - appnd.size(); // length of tmpword
  // the second condition is not enough for UTF-8 strings
  // it checked in test_condition()

  if ((tmpl > 0 || (tmpl == 0 && pmyMgr->get_fullstrip())) &&
      (tmpl + strip.size() >= numconds)) {
    // generate new root word by removing suffix and adding
    // back any characters that would have been stripped or
    // or null terminating the shorter string

    std::string tmpstring(word, start, tmpl);
    if (strip.size()) {
      tmpstring.append(strip);
    }

    const char* tmpword = tmpstring.c_str();
    const char* endword = tmpword + tmpstring.size();

    // now make sure all of the conditions on characters
    // are met.  Please see the appendix at the end of
    // this file for more info on exactly what is being
    // tested

    // if all conditions are met then check if resulting
    // root word in the dictionary

    if (test_condition(endword, tmpword)) {
#ifdef SZOSZABLYA_POSSIBLE_ROOTS
      fprintf(stdout, "%s %s %c\n", word.c_str() + start, tmpword, aflag);
#endif
      if ((he = pmyMgr->lookup(tmpword)) != NULL) {
        do {
          // check conditional suffix (enabled by prefix)
          if ((TESTAFF(he->astr, aflag, he->alen) ||
               (ep && ep->getCont() &&
                TESTAFF(ep->getCont(), aflag, ep->getContLen()))) &&
              (((optflags & aeXPRODUCT) == 0) ||
               (ep && TESTAFF(he->astr, ep->getFlag(), he->alen)) ||
               // enabled by prefix
               ((contclass) &&
                (ep && TESTAFF(contclass, ep->getFlag(), contclasslen)))) &&
              // handle cont. class
              ((!cclass) ||
               ((contclass) && TESTAFF(contclass, cclass, contclasslen))) &&
              // check only in compound homonyms (bad flags)
              (!badflag || !TESTAFF(he->astr, badflag, he->alen)) &&
              // handle required flag
              ((!needflag) ||
               (TESTAFF(he->astr, needflag, he->alen) ||
                ((contclass) && TESTAFF(contclass, needflag, contclasslen)))))
            return he;
          he = he->next_homonym;  // check homonyms
        } while (he);
      }
    }
  }
  return NULL;
}

// the below code fragment can be found in:
// src/hunspell/affixmgr.cxx
int AffixMgr::encodeit(AffEntry& entry, const std::string& cs) {
  if (cs.compare(".") != 0) {
    entry.numconds = (char)condlen(cs);
    const size_t cslen = cs.size();
    const size_t short_part = std::min<size_t>(MAXCONDLEN, cslen);
    memcpy(entry.c.conds, cs.data(), short_part);
    if (short_part < MAXCONDLEN) {
      //blank out the remaining space
      memset(entry.c.conds + short_part, 0, MAXCONDLEN - short_part);
    } else if (cs[MAXCONDLEN]) {
      //there is more conditions than fit in fixed space, so its
      //a long condition
      entry.opts |= aeLONGCOND;
      size_t remaining = cs.size() - MAXCONDLEN_1;
      entry.c.l.conds2 = new char[1 + remaining];
      memcpy(entry.c.l.conds2, cs.data() + MAXCONDLEN_1, remaining);
      entry.c.l.conds2[remaining] = 0;
    }
  } else {
    entry.numconds = 0;
    entry.c.conds[0] = '\0';
  }
  return 0;
}

// the below code fragment can be found in:
// src/hunspell/suggestmgr.cxx
std::string SuggestMgr::suggest_gen(const std::vector<std::string>& desc, const std::string& in_pattern) {
  if (desc.empty() || !pAMgr)
    return std::string();

  const char* pattern = in_pattern.c_str();
  std::string result2;
  std::string newpattern;
  struct hentry* rv = NULL;

  // search affixed forms with and without derivational suffixes
  while (1) {
    for (size_t k = 0; k < desc.size(); ++k) {
      std::string result;

      // add compound word parts (except the last one)
      const char* s = desc[k].c_str();
      const char* part = strstr(s, MORPH_PART);
      if (part) {
        const char* nextpart = strstr(part + 1, MORPH_PART);
        while (nextpart) {
          std::string field;
          copy_field(field, part, MORPH_PART);
          result.append(field);
          part = nextpart;
          nextpart = strstr(part + 1, MORPH_PART);
        }
        s = part;
      }

      std::string tok(s);
      size_t pos = tok.find(" | ");
      while (pos != std::string::npos) {
        tok[pos + 1] = MSEP_ALT;
        pos = tok.find(" | ", pos);
      }
      std::vector<std::string> pl = line_tok(tok, MSEP_ALT);
      for (size_t i = 0; i < pl.size(); ++i) {
        // remove inflectional and terminal suffixes
        size_t is = pl[i].find(MORPH_INFL_SFX);
        if (is != std::string::npos)
          pl[i].resize(is);
        size_t ts = pl[i].find(MORPH_TERM_SFX);
        while (ts != std::string::npos) {
          pl[i][ts] = '_';
          ts = pl[i].find(MORPH_TERM_SFX);
        }
        const char* st = strstr(s, MORPH_STEM);
        if (st) {
          copy_field(tok, st, MORPH_STEM);
          rv = pAMgr->lookup(tok.c_str());
          while (rv) {
            std::string newpat(pl[i]);
            newpat.append(pattern);
            std::string sg = suggest_hentry_gen(rv, newpat.c_str());
            if (sg.empty())
              sg = suggest_hentry_gen(rv, pattern);
            if (!sg.empty()) {
              std::vector<std::string> gen = line_tok(sg, MSEP_REC);
              for (size_t j = 0; j < gen.size(); ++j) {
                result2.push_back(MSEP_REC);
                result2.append(result);
                if (pl[i].find(MORPH_SURF_PFX) != std::string::npos) {
                  std::string field;
                  copy_field(field, pl[i], MORPH_SURF_PFX);
                  result2.append(field);
                }
                result2.append(gen[j]);
              }
            }
            rv = rv->next_homonym;
          }
        }
      }
    }

    if (!result2.empty() || !strstr(pattern, MORPH_DERI_SFX))
      break;

    newpattern.assign(pattern);
    mystrrep(newpattern, MORPH_DERI_SFX, MORPH_TERM_SFX);
    pattern = newpattern.c_str();
  }
  return result2;
}

// the below code fragment can be found in:
// src/hunspell/hunspell.cxx
std::vector<std::string> HunspellImpl::generate(const std::string& word, const std::vector<std::string>& pl) {
  std::vector<std::string> slst;
  if (!pSMgr || pl.empty())
    return slst;
  std::vector<std::string> pl2 = analyze(word);
  int captype = NOCAP;
  int abbv = 0;
  std::string cw;
  cleanword(cw, word, &captype, &abbv);
  std::string result;

  for (size_t i = 0; i < pl.size(); ++i) {
    cat_result(result, pSMgr->suggest_gen(pl2, pl[i]));
  }

  if (!result.empty()) {
    // allcap
    if (captype == ALLCAP)
      mkallcap(result);

    // line split
    slst = line_tok(result, MSEP_REC);

    // capitalize
    if (captype == INITCAP || captype == HUHINITCAP) {
      for (size_t j = 0; j < slst.size(); ++j) {
        mkinitcap(slst[j]);
      }
    }

    // temporary filtering of prefix related errors (eg.
    // generate("undrinkable", "eats") --> "undrinkables" and "*undrinks")
    std::vector<std::string>::iterator it = slst.begin();
    while (it != slst.end()) {
      if (!spell(*it)) {
        it = slst.erase(it);
      } else  {
        ++it;
      }
    }
  }
  return slst;
}

// the below code fragment can be found in:
// src/hunspell/affentry.cxx
struct hentry* PfxEntry::checkword(const std::string& word,
                                   int start,
                                   int len,
                                   char in_compound,
                                   const FLAG needflag) {
  struct hentry* he;  // hash entry of root word or NULL

  // on entry prefix is 0 length or already matches the beginning of the word.
  // So if the remaining root word has positive length
  // and if there are enough chars in root word and added back strip chars
  // to meet the number of characters conditions, then test it

  int tmpl = len - appnd.size(); // length of tmpword

  if (tmpl > 0 || (tmpl == 0 && pmyMgr->get_fullstrip())) {
    // generate new root word by removing prefix and adding
    // back any characters that would have been stripped

    std::string tmpword(strip);
    tmpword.append(word, start + appnd.size(), tmpl);

    // now make sure all of the conditions on characters
    // are met.  Please see the appendix at the end of
    // this file for more info on exactly what is being
    // tested

    // if all conditions are met then check if resulting
    // root word in the dictionary

    if (test_condition(tmpword)) {
      tmpl += strip.size();
      if ((he = pmyMgr->lookup(tmpword.c_str())) != NULL) {
        do {
          if (TESTAFF(he->astr, aflag, he->alen) &&
              // forbid single prefixes with needaffix flag
              !TESTAFF(contclass, pmyMgr->get_needaffix(), contclasslen) &&
              // needflag
              ((!needflag) || TESTAFF(he->astr, needflag, he->alen) ||
               (contclass && TESTAFF(contclass, needflag, contclasslen))))
            return he;
          he = he->next_homonym;  // check homonyms
        } while (he);
      }

      // prefix matched but no root word was found
      // if aeXPRODUCT is allowed, try again but now
      // ross checked combined with a suffix

      // if ((opts & aeXPRODUCT) && in_compound) {
      if ((opts & aeXPRODUCT)) {
        he = pmyMgr->suffix_check(tmpword, 0, tmpl, aeXPRODUCT, this,
                                  FLAG_NULL, needflag, in_compound);
        if (he)
          return he;
      }
    }
  }
  return NULL;
}

