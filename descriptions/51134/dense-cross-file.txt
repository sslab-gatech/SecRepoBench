// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/hunspell/affentry.cxx
inline int SfxEntry::test_condition(const char* st, const char* beg) {
  const char* pos = NULL;  // group with pos input position
  bool neg = false;        // complementer
  bool ingroup = false;    // character in the group
  if (numconds == 0)
    return 1;
  char* p = c.conds;
  st--;
  int i = 1;
  while (1) {
    switch (*p) {
      case '\0':
        return 1;
      case '[':
        p = nextchar(p);
        pos = st;
        break;
      case '^':
        p = nextchar(p);
        neg = true;
        break;
      case ']':
        if (!neg && !ingroup)
          return 0;
        i++;
        // skip the next character
        if (!ingroup) {
          for (; (opts & aeUTF8) && (st >= beg) && (*st & 0xc0) == 0x80; st--)
            ;
          st--;
        }
        pos = NULL;
        neg = false;
        ingroup = false;
        p = nextchar(p);
        if (st < beg && p)
          return 0;  // word <= condition
        break;
      case '.':
        if (!pos) {
          // dots are not metacharacters in groups: [.]
          p = nextchar(p);
          // skip the next character
          for (st--; (opts & aeUTF8) && (st >= beg) && (*st & 0xc0) == 0x80;
               st--)
            ;
          if (st < beg) {  // word <= condition
            if (p)
              return 0;
            else
              return 1;
          }
          if ((opts & aeUTF8) && (*st & 0x80)) {  // head of the UTF-8 character
            st--;
            if (st < beg) {  // word <= condition
              if (p)
                return 0;
              else
                return 1;
            }
          }
          break;
        }
      /* FALLTHROUGH */
      default: {
        if (*st == *p) {
          p = nextchar(p);
          if ((opts & aeUTF8) && (*st & 0x80)) {
            st--;
            while (p && (st >= beg)) {
              if (*p != *st) {
                if (!pos)
                  return 0;
                st = pos;
                break;
              }
              // first byte of the UTF-8 multibyte character
              if ((*p & 0xc0) != 0x80)
                break;
              p = nextchar(p);
              st--;
            }
            if (pos && st != pos) {
              if (neg)
                return 0;
              else if (i == numconds)
                return 1;
              ingroup = true;
              while (p && *p != ']' && ((p = nextchar(p)) != NULL)) {
              }
              st--;
            }
            if (p && *p != ']')
              p = nextchar(p);
          } else if (pos) {
            if (neg)
              return 0;
            else if (i == numconds)
              return 1;
            ingroup = true;
            while (p && *p != ']' && ((p = nextchar(p)) != NULL)) {
            }
            //			if (p && *p != ']') p = nextchar(p);
            st--;
          }
          if (!pos) {
            i++;
            st--;
          }
          if (st < beg && p && *p != ']')
            return 0;      // word <= condition
        } else if (pos) {  // group
          p = nextchar(p);
        } else
          return 0;
      }
    }
    if (!p)
      return 1;
  }
}

// the below code fragment can be found in:
// src/hunspell/affixmgr.cxx
int AffixMgr::redundant_condition(char ft,
                                  const std::string& strip,
                                  const std::string& cond,
                                  int linenum) {
  int stripl = strip.size(), condl = cond.size();
  int i, j;
  int neg;
  int in;
  if (ft == 'P') {  // prefix
    if (strip.compare(0, condl, cond) == 0)
      return 1;
    if (utf8) {
    } else {
      for (i = 0, j = 0; (i < stripl) && (j < condl); i++, j++) {
        if (cond[j] != '[') {
          if (cond[j] != strip[i]) {
            HUNSPELL_WARNING(stderr,
                             "warning: line %d: incompatible stripping "
                             "characters and condition\n",
                             linenum);
            return 0;
          }
        } else {
          neg = (cond[j + 1] == '^') ? 1 : 0;
          in = 0;
          do {
            j++;
            if (strip[i] == cond[j])
              in = 1;
          } while ((j < (condl - 1)) && (cond[j] != ']'));
          if (j == (condl - 1) && (cond[j] != ']')) {
            HUNSPELL_WARNING(stderr,
                             "error: line %d: missing ] in condition:\n%s\n",
                             linenum, cond.c_str());
            return 0;
          }
          if ((!neg && !in) || (neg && in)) {
            HUNSPELL_WARNING(stderr,
                             "warning: line %d: incompatible stripping "
                             "characters and condition\n",
                             linenum);
            return 0;
          }
        }
      }
      if (j >= condl)
        return 1;
    }
  } else {  // suffix
    if ((stripl >= condl) && strip.compare(stripl - condl, std::string::npos, cond) == 0)
      return 1;
    if (utf8) {
    } else {
      for (i = stripl - 1, j = condl - 1; (i >= 0) && (j >= 0); i--, j--) {
        if (cond[j] != ']') {
          if (cond[j] != strip[i]) {
            HUNSPELL_WARNING(stderr,
                             "warning: line %d: incompatible stripping "
                             "characters and condition\n",
                             linenum);
            return 0;
          }
        } else if (j > 0) {
          in = 0;
          do {
            j--;
            if (strip[i] == cond[j])
              in = 1;
          } while ((j > 0) && (cond[j] != '['));
          if ((j == 0) && (cond[j] != '[')) {
            HUNSPELL_WARNING(stderr,
                             "error: line: %d: missing ] in condition:\n%s\n",
                             linenum, cond.c_str());
            return 0;
          }
          neg = (cond[j + 1] == '^') ? 1 : 0;
          if ((!neg && !in) || (neg && in)) {
            HUNSPELL_WARNING(stderr,
                             "warning: line %d: incompatible stripping "
                             "characters and condition\n",
                             linenum);
            return 0;
          }
        }
      }
      if (j < 0)
        return 1;
    }
  }
  return 0;
}

// the below code fragment can be found in:
// src/hunspell/affentry.cxx
std::string PfxEntry::check_morph(const std::string& word,
                                  int start,
                                  int len,
                                  char in_compound,
                                  const FLAG needflag) {
  std::string result;

  // on entry prefix is 0 length or already matches the beginning of the word.
  // So if the remaining root word has positive length
  // and if there are enough chars in root word and added back strip chars
  // to meet the number of characters conditions, then test it

  int tmpl = len - appnd.size(); // length of tmpword

  if ((tmpl > 0 || (tmpl == 0 && pmyMgr->get_fullstrip())) &&
      (tmpl + strip.size() >= numconds)) {
    // generate new root word by removing prefix and adding
    // back any characters that would have been stripped

    std::string tmpword(strip);
    tmpword.append(word, start + appnd.size());

    // now make sure all of the conditions on characters
    // are met.  Please see the appendix at the end of
    // this file for more info on exactly what is being
    // tested

    // if all conditions are met then check if resulting
    // root word in the dictionary

    if (test_condition(tmpword)) {
      tmpl += strip.size();
      struct hentry* he;  // hash entry of root word or NULL
      if ((he = pmyMgr->lookup(tmpword.c_str())) != NULL) {
        do {
          if (TESTAFF(he->astr, aflag, he->alen) &&
              // forbid single prefixes with needaffix flag
              !TESTAFF(contclass, pmyMgr->get_needaffix(), contclasslen) &&
              // needflag
              ((!needflag) || TESTAFF(he->astr, needflag, he->alen) ||
               (contclass && TESTAFF(contclass, needflag, contclasslen)))) {
            if (morphcode) {
              result.push_back(MSEP_FLD);
              result.append(morphcode);
            } else
              result.append(getKey());
            if (!HENTRY_FIND(he, MORPH_STEM)) {
              result.push_back(MSEP_FLD);
              result.append(MORPH_STEM);
              result.append(HENTRY_WORD(he));
            }
            // store the pointer of the hash entry
            if (HENTRY_DATA(he)) {
              result.push_back(MSEP_FLD);
              result.append(HENTRY_DATA2(he));
            } else {
              // return with debug information
              std::string flag = pmyMgr->encode_flag(getFlag());
              result.push_back(MSEP_FLD);
              result.append(MORPH_FLAG);
              result.append(flag);
            }
            result.push_back(MSEP_REC);
          }
          he = he->next_homonym;
        } while (he);
      }

      // prefix matched but no root word was found
      // if aeXPRODUCT is allowed, try again but now
      // ross checked combined with a suffix

      if ((opts & aeXPRODUCT) && (in_compound != IN_CPD_BEGIN)) {
        std::string st = pmyMgr->suffix_check_morph(tmpword, 0, tmpl, aeXPRODUCT, this,
                                                    FLAG_NULL, needflag);
        if (!st.empty()) {
          result.append(st);
        }
      }
    }
  }

  return result;
}

// the below code fragment can be found in:
// src/hunspell/affentry.cxx
std::string PfxEntry::check_twosfx_morph(const std::string& word,
                                         int start,
                                         int len,
                                         char in_compound,
                                         const FLAG needflag) {
  std::string result;
  // on entry prefix is 0 length or already matches the beginning of the word.
  // So if the remaining root word has positive length
  // and if there are enough chars in root word and added back strip chars
  // to meet the number of characters conditions, then test it
  int tmpl = len - appnd.size(); // length of tmpword

  if ((tmpl > 0 || (tmpl == 0 && pmyMgr->get_fullstrip())) &&
      (tmpl + strip.size() >= numconds)) {
    // generate new root word by removing prefix and adding
    // back any characters that would have been stripped

    std::string tmpword(strip);
    tmpword.append(word, start + appnd.size());

    // now make sure all of the conditions on characters
    // are met.  Please see the appendix at the end of
    // this file for more info on exactly what is being
    // tested

    // if all conditions are met then check if resulting
    // root word in the dictionary

    if (test_condition(tmpword)) {
      tmpl += strip.size();

      // prefix matched but no root word was found
      // if aeXPRODUCT is allowed, try again but now
      // ross checked combined with a suffix

      if ((opts & aeXPRODUCT) && (in_compound != IN_CPD_BEGIN)) {
        result = pmyMgr->suffix_check_twosfx_morph(tmpword, 0, tmpl,
                                                   aeXPRODUCT,
                                                   this, needflag);
      }
    }
  }
  return result;
}

// the below code fragment can be found in:
// src/hunspell/affentry.cxx
struct hentry* PfxEntry::checkword(const std::string& word,
                                   int start,
                                   int len,
                                   char in_compound,
                                   const FLAG needflag) {
  struct hentry* he;  // hash entry of root word or NULL

  // on entry prefix is 0 length or already matches the beginning of the word.
  // So if the remaining root word has positive length
  // and if there are enough chars in root word and added back strip chars
  // to meet the number of characters conditions, then test it

  int tmpl = len - appnd.size(); // length of tmpword

  if (tmpl > 0 || (tmpl == 0 && pmyMgr->get_fullstrip())) {
    // generate new root word by removing prefix and adding
    // back any characters that would have been stripped

    std::string tmpword(strip);
    tmpword.append(word, start + appnd.size(), tmpl);

    // now make sure all of the conditions on characters
    // are met.  Please see the appendix at the end of
    // this file for more info on exactly what is being
    // tested

    // if all conditions are met then check if resulting
    // root word in the dictionary

    if (test_condition(tmpword)) {
      tmpl += strip.size();
      if ((he = pmyMgr->lookup(tmpword.c_str())) != NULL) {
        do {
          if (TESTAFF(he->astr, aflag, he->alen) &&
              // forbid single prefixes with needaffix flag
              !TESTAFF(contclass, pmyMgr->get_needaffix(), contclasslen) &&
              // needflag
              ((!needflag) || TESTAFF(he->astr, needflag, he->alen) ||
               (contclass && TESTAFF(contclass, needflag, contclasslen))))
            return he;
          he = he->next_homonym;  // check homonyms
        } while (he);
      }

      // prefix matched but no root word was found
      // if aeXPRODUCT is allowed, try again but now
      // ross checked combined with a suffix

      // if ((opts & aeXPRODUCT) && in_compound) {
      if ((opts & aeXPRODUCT)) {
        he = pmyMgr->suffix_check(tmpword, 0, tmpl, aeXPRODUCT, this,
                                  FLAG_NULL, needflag, in_compound);
        if (he)
          return he;
      }
    }
  }
  return NULL;
}

