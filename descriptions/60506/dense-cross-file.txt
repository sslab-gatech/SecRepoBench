// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/lib/libdwarf/dwarf_line_table_reader_common.h
static int
read_line_table_program(Dwarf_Debug dbg,
    Dwarf_Small *line_ptr,
    Dwarf_Small *line_ptr_end,
    Dwarf_Small *orig_line_ptr,
    Dwarf_Small *section_start,
    Dwarf_Line_Context line_context,
    Dwarf_Half address_size,
    Dwarf_Bool doaddrs, /* Only true if SGI IRIX rqs calling. */
    Dwarf_Bool dolines,
    Dwarf_Bool is_single_table,
    Dwarf_Bool is_actuals_table,
    Dwarf_Error *error,
    int *err_count_out)
{
    Dwarf_Unsigned i = 0;
    Dwarf_File_Entry cur_file_entry = 0;
    Dwarf_Line *logicals = line_context->lc_linebuf_logicals;
    Dwarf_Unsigned logicals_count =
        line_context->lc_linecount_logicals;

    struct Dwarf_Line_Registers_s regs;

    /*  This is a pointer to the current line being added to the line
        matrix. */
    Dwarf_Line curr_line = 0;

    /*  These variables are used to decode leb128 numbers. Leb128_num
        holds the decoded number, and leb128_length is its length in
        bytes. */
    Dwarf_Unsigned leb128_num = 0;
    Dwarf_Signed advance_line = 0;

    /*  This is the operand of the latest fixed_advance_pc extended
        opcode. */
    Dwarf_Half fixed_advance_pc = 0;

    /*  Counts the number of lines in the line matrix. */
    Dwarf_Unsigned line_count = 0;

    /*  This is the length of an extended opcode instr.  */
    Dwarf_Unsigned instr_length = 0;

    /*  Used to chain together pointers to line table entries that are
        later used to create a block of Dwarf_Line entries. */
    Dwarf_Chain chain_line = NULL;
    Dwarf_Chain head_chain = NULL;
    Dwarf_Chain curr_chain = NULL;

    /*  This points to a block of Dwarf_Lines, a pointer to which is
        returned in linebuf. */
    Dwarf_Line *block_line = 0;

    /*  Mark a line record as being DW_LNS_set_address */
    Dwarf_Bool is_addr_set = false;

    (void)orig_line_ptr;
    (void)err_count_out;
    /*  Initialize the one state machine variable that depends on the
        prefix.  */
    _dwarf_set_line_table_regs_default_values(&regs,
        line_context->lc_version_number,
        line_context->lc_default_is_stmt);

    /* Start of statement program.  */
    while (line_ptr < line_ptr_end) {
        int type = 0;
        Dwarf_Small opcode = 0;

#ifdef PRINTING_DETAILS
        {
        dwarfstring m9a;
        dwarfstring_constructor(&m9a);
        dwarfstring_append_printf_u(&m9a,
            " [0x%06" DW_PR_DSx "] ",
            /*  ptrdiff_t generated but not named */
            (line_ptr - section_start));
        _dwarf_printf(dbg,dwarfstring_string(&m9a));
        dwarfstring_destructor(&m9a);
        }
#endif /* PRINTING_DETAILS */
        opcode = *(Dwarf_Small *) line_ptr;
        line_ptr++;
        /* 'type' is the output */
        WHAT_IS_OPCODE(type, opcode, line_context->lc_opcode_base,
            line_context->lc_opcode_length_table, line_ptr,
            line_context->lc_std_op_count);

        if (type == LOP_DISCARD) {
            int oc = 0;
            int opcnt = line_context->lc_opcode_length_table[opcode];
#ifdef PRINTING_DETAILS
            {
            dwarfstring m9b;
            dwarfstring_constructor(&m9b);
            dwarfstring_append_printf_i(&m9b,
                "*** DWARF CHECK: DISCARD standard opcode %d ",
                opcode);
            dwarfstring_append_printf_i(&m9b,
                "with %d operands: not understood.", opcnt);
            _dwarf_printf(dbg,dwarfstring_string(&m9b));
            *err_count_out += 1;
            dwarfstring_destructor(&m9b);
            }
#endif /* PRINTING_DETAILS */
            for (oc = 0; oc < opcnt; oc++) {
                int ocres = 0;
                /*  Read and discard operands we don't
                    understand.
                    arbitrary choice of unsigned read.
                    signed read would work as well.    */
                Dwarf_Unsigned utmp2 = 0;

                (void) utmp2;
                ocres =  read_uword_de( &line_ptr,&utmp2,
                    dbg,error,line_ptr_end);
                if (ocres == DW_DLV_ERROR) {
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                        curr_line = 0;
                    }
                    return DW_DLV_ERROR;
                }

#ifdef PRINTING_DETAILS
                {
                dwarfstring m9e;
                dwarfstring_constructor(&m9e);
                dwarfstring_append_printf_u(&m9e,
                    " %" DW_PR_DUu,
                    utmp2);
                dwarfstring_append_printf_u(&m9e,
                    " (0x%" DW_PR_XZEROS DW_PR_DUx ")",
                    utmp2);
                _dwarf_printf(dbg,dwarfstring_string(&m9e));
                dwarfstring_destructor(&m9e);
                }
#endif /* PRINTING_DETAILS */
            }
#ifdef PRINTING_DETAILS
            _dwarf_printf(dbg,"***\n");
#endif /* PRINTING_DETAILS */
        } else if (type == LOP_SPECIAL) {
            /*  This op code is a special op in the object, no matter
                that it might fall into the standard op range in this
                compile. That is, these are special opcodes between
                opcode_base and MAX_LINE_OP_CODE.  (including
                opcode_base and MAX_LINE_OP_CODE) */
#ifdef PRINTING_DETAILS
            unsigned origop = opcode;
#endif /* PRINTING_DETAILS */
            Dwarf_Unsigned operation_advance = 0;

            opcode = opcode - line_context->lc_opcode_base;
            operation_advance =
                (opcode / line_context->lc_line_range);

            if (line_context->lc_maximum_ops_per_instruction < 2) {
                regs.lr_address = regs.lr_address +
                    (operation_advance *
                    line_context->lc_minimum_instruction_length);
            } else {
                regs.lr_address = regs.lr_address +
                    (line_context->lc_minimum_instruction_length *
                    ((regs.lr_op_index + operation_advance)/
                    line_context->lc_maximum_ops_per_instruction));
                regs.lr_op_index =
                    (regs.lr_op_index +operation_advance)%
                    line_context->lc_maximum_ops_per_instruction;
            }

            regs.lr_line = regs.lr_line + line_context->lc_line_base +
                opcode % line_context->lc_line_range;
            if ((Dwarf_Signed)regs.lr_line < 0) {
                /* Something is badly wrong */
                dwarfstring m;

                dwarfstring_constructor(&m);
                dwarfstring_append_printf_i(&m,
                    "\nERROR: DW_DLE_LINE_TABLE_LINENO_ERROR "
                    "The line number computes as %d "
                    "and negative line numbers "
                    "are not correct.",(Dwarf_Signed)regs.lr_line);
                _dwarf_error_string(dbg, error,
                    DW_DLE_LINE_TABLE_LINENO_ERROR,
                    dwarfstring_string(&m));
                dwarfstring_destructor(&m);
                regs.lr_line = 0;
                _dwarf_free_chain_entries(dbg,head_chain,
                    line_count);
                if (curr_line) {
                    dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    curr_line = 0;
                }
                return DW_DLV_ERROR;
            }
#ifdef PRINTING_DETAILS
            {
            dwarfstring ma;
            dwarfstring mb;

            dwarfstring_constructor(&ma);
            dwarfstring_constructor(&mb);
            dwarfstring_append_printf_u(&mb,"Specialop %3u", origop);
            _dwarf_printf(dbg,dwarfstring_string(&ma));
            dwarfstring_destructor(&ma);
            print_line_detail(dbg,dwarfstring_string(&mb),
                opcode,line_count+1, &regs,is_single_table,
                is_actuals_table);
            dwarfstring_destructor(&mb);
            dwarfstring_destructor(&ma);
            }
#endif /* PRINTING_DETAILS */

            if (dolines) {
                curr_line =
                    (Dwarf_Line) _dwarf_get_alloc(dbg,DW_DLA_LINE,1);
                if (curr_line == NULL) {
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);
                    return DW_DLV_ERROR;
                }

                /* Mark a line record as being DW_LNS_set_address */
                curr_line->li_l_data.li_is_addr_set =
                    is_addr_set;
                is_addr_set = false;
                curr_line->li_address = regs.lr_address;
                curr_line->li_l_data.li_file =
                    (Dwarf_Signed) regs.lr_file;
                curr_line->li_l_data.li_line =
                    (Dwarf_Signed) regs.lr_line;
                curr_line->li_l_data.li_column =
                    (Dwarf_Half) regs.lr_column;
                curr_line->li_l_data.li_is_stmt =
                    regs.lr_is_stmt;
                curr_line->li_l_data.li_basic_block =
                    regs.lr_basic_block;
                curr_line->li_l_data.li_end_sequence =
                    curr_line->li_l_data.
                    li_epilogue_begin = regs.lr_epilogue_begin;
                curr_line->li_l_data.li_prologue_end =
                    regs.lr_prologue_end;
                curr_line->li_l_data.li_isa =
                    regs.lr_isa;
                curr_line->li_l_data.li_discriminator =
                    regs.lr_discriminator;
                curr_line->li_l_data.li_call_context =
                    regs.lr_call_context;
                curr_line->li_l_data.li_subprogram =
                    regs.lr_subprogram;
                curr_line->li_context = line_context;
                curr_line->li_is_actuals_table = is_actuals_table;
                line_count++;

                chain_line = (Dwarf_Chain)
                    _dwarf_get_alloc(dbg, DW_DLA_CHAIN, 1);
                if (chain_line == NULL) {
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    }
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);
                    return DW_DLV_ERROR;
                }
                chain_line->ch_itemtype = DW_DLA_LINE;
                chain_line->ch_item = curr_line;
                _dwarf_update_chain_list(chain_line,&head_chain,
                    &curr_chain);
                curr_line = 0;
            }

            regs.lr_basic_block = false;
            regs.lr_prologue_end = false;
            regs.lr_epilogue_begin = false;
            regs.lr_discriminator = 0;
#ifdef PRINTING_DETAILS
#endif /* PRINTING_DETAILS */
        } else if (type == LOP_STANDARD) {
#ifdef PRINTING_DETAILS
            dwarfstring mb;
#endif /* PRINTING_DETAILS */

            switch (opcode) {
            case DW_LNS_copy:{

#ifdef PRINTING_DETAILS
                print_line_detail(dbg,"DW_LNS_copy",
                    opcode,line_count+1, &regs,is_single_table,
                    is_actuals_table);
#endif /* PRINTING_DETAILS */
                if (dolines) {
                    curr_line = (Dwarf_Line) _dwarf_get_alloc(dbg,
                        DW_DLA_LINE, 1);
                    if (curr_line == NULL) {
                        _dwarf_free_chain_entries(dbg,head_chain,
                            line_count);
                        _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);
                        return DW_DLV_ERROR;
                    }

                    /* Mark a line record as DW_LNS_set_address */
                    curr_line->li_l_data.li_is_addr_set =
                        is_addr_set;
                    is_addr_set = false;

                    curr_line->li_address = regs.lr_address;
                    curr_line->li_l_data.li_file =
                        (Dwarf_Signed) regs.lr_file;
                    curr_line->li_l_data.li_line =
                        (Dwarf_Signed) regs.lr_line;
                    curr_line->li_l_data.li_column =
                        (Dwarf_Half) regs.lr_column;
                    curr_line->li_l_data.li_is_stmt =
                        regs.lr_is_stmt;
                    curr_line->li_l_data.
                        li_basic_block = regs.lr_basic_block;
                    curr_line->li_l_data.
                        li_end_sequence = regs.lr_end_sequence;
                    curr_line->li_context = line_context;
                    curr_line->li_is_actuals_table = is_actuals_table;
                    curr_line->li_l_data.
                        li_epilogue_begin = regs.lr_epilogue_begin;
                    curr_line->li_l_data.
                        li_prologue_end = regs.lr_prologue_end;
                    curr_line->li_l_data.li_isa =
                        regs.lr_isa;
                    curr_line->li_l_data.li_discriminator
                        = regs.lr_discriminator;
                    curr_line->li_l_data.li_call_context
                        = regs.lr_call_context;
                    curr_line->li_l_data.li_subprogram =
                        regs.lr_subprogram;
                    line_count++;

                    chain_line = (Dwarf_Chain)
                        _dwarf_get_alloc(dbg, DW_DLA_CHAIN, 1);
                    if (chain_line == NULL) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                        _dwarf_free_chain_entries(dbg,head_chain,
                            line_count);
                        _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);
                        return DW_DLV_ERROR;
                    }
                    chain_line->ch_itemtype = DW_DLA_LINE;
                    chain_line->ch_item = curr_line;
                    _dwarf_update_chain_list(chain_line,&head_chain,
                        &curr_chain);
                    curr_line = 0;
                }

                regs.lr_basic_block = false;
                regs.lr_prologue_end = false;
                regs.lr_epilogue_begin = false;
                regs.lr_discriminator = 0;
                }
                break;
            case DW_LNS_advance_pc:{
                Dwarf_Unsigned utmp2 = 0;
                int advres = 0;

                advres =  read_uword_de( &line_ptr,&utmp2,
                    dbg,error,line_ptr_end);
                if (advres == DW_DLV_ERROR) {
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    }
                    return DW_DLV_ERROR;
                }

#ifdef PRINTING_DETAILS
                dwarfstring_constructor(&mb);
                dwarfstring_append_printf_i(&mb,
                    "DW_LNS_advance_pc val %" DW_PR_DSd,
                    utmp2);
                dwarfstring_append_printf_u(&mb,
                    " 0x%" DW_PR_XZEROS DW_PR_DUx "\n",
                    utmp2);
                _dwarf_printf(dbg,dwarfstring_string(&mb));
                dwarfstring_destructor(&mb);
#endif /* PRINTING_DETAILS */
                leb128_num = utmp2;
                regs.lr_address = regs.lr_address +
                    line_context->lc_minimum_instruction_length *
                    leb128_num;
                }
                break;
            case DW_LNS_advance_line:{
                Dwarf_Signed stmp = 0;
                int alres = 0;

                alres =  read_sword_de( &line_ptr,&stmp,
                    dbg,error,line_ptr_end);
                if (alres == DW_DLV_ERROR) {
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    }
                    return DW_DLV_ERROR;
                }
                advance_line = (Dwarf_Signed) stmp;

#ifdef PRINTING_DETAILS
                dwarfstring_constructor(&mb);
                dwarfstring_append_printf_i(&mb,
                    "DW_LNS_advance_line val %" DW_PR_DSd,
                    advance_line);
                dwarfstring_append_printf_u(&mb,
                    " 0x%" DW_PR_XZEROS DW_PR_DSx "\n",
                    advance_line);
                _dwarf_printf(dbg,dwarfstring_string(&mb));
                dwarfstring_destructor(&mb);
#endif /* PRINTING_DETAILS */
                regs.lr_line = regs.lr_line + advance_line;
                if ((Dwarf_Signed)regs.lr_line < 0) {
                    dwarfstring m;

                    dwarfstring_constructor(&m);
                    dwarfstring_append_printf_i(&m,
                        "\nERROR: DW_DLE_LINE_TABLE_LINENO_ERROR"
                        " The line number is %d "
                        "and negative line numbers after "
                        "DW_LNS_ADVANCE_LINE ",
                        (Dwarf_Signed)regs.lr_line);
                    dwarfstring_append_printf_i(&m,
                        " of %d "
                        "are not correct.",stmp);
                    _dwarf_error_string(dbg, error,
                        DW_DLE_LINE_TABLE_LINENO_ERROR,
                        dwarfstring_string(&m));
                    dwarfstring_destructor(&m);
                    regs.lr_line = 0;
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    }
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    return DW_DLV_ERROR;
                }
                }
                break;
            case DW_LNS_set_file:{
                Dwarf_Unsigned utmp2 = 0;
                int sfres = 0;

                sfres =  read_uword_de( &line_ptr,&utmp2,
                    dbg,error,line_ptr_end);
                if (sfres == DW_DLV_ERROR) {
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    }
                    return DW_DLV_ERROR;
                }
                {
                    Dwarf_Signed fno = (Dwarf_Signed)utmp2;
                    if (fno < 0) {
                        _dwarf_free_chain_entries(dbg,head_chain,
                            line_count);
                        if (curr_line) {
                            dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                        }
                        _dwarf_error_string(dbg,error,
                            DW_DLE_LINE_INDEX_WRONG,
                            "DW_DLE_LINE_INDEX_WRONG "
                            "A DW_LNS_set_file has an "
                            "Impossible "
                            "file number ");
                        return DW_DLV_ERROR;
                    }
                }

                regs.lr_file = utmp2;
#ifdef PRINTING_DETAILS
                dwarfstring_constructor(&mb);
                dwarfstring_append_printf_i(&mb,
                    "DW_LNS_set_file  %ld\n",
                    regs.lr_file);
                _dwarf_printf(dbg,dwarfstring_string(&mb));
                dwarfstring_destructor(&mb);
#endif /* PRINTING_DETAILS */
                }
                break;
            case DW_LNS_set_column:{
                Dwarf_Unsigned utmp2 = 0;
                int scres = 0;

                scres =  read_uword_de( &line_ptr,&utmp2,
                    dbg,error,line_ptr_end);
                if (scres == DW_DLV_ERROR) {
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    }
                    return DW_DLV_ERROR;
                }
                {
                    Dwarf_Signed cno = (Dwarf_Signed)utmp2;
                    if (cno < 0) {
                        _dwarf_free_chain_entries(dbg,head_chain,
                            line_count);
                        if (curr_line) {
                            dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                        }
                        _dwarf_error_string(dbg,error,
                            DW_DLE_LINE_INDEX_WRONG,
                            "DW_DLE_LINE_INDEX_WRONG "
                            "A DW_LNS_set_column has an "
                            "impossible "
                            "column number ");
                        return DW_DLV_ERROR;
                    }
                }

                regs.lr_column = utmp2;
#ifdef PRINTING_DETAILS
                dwarfstring_constructor(&mb);

                dwarfstring_append_printf_i(&mb,
                    "DW_LNS_set_column val %" DW_PR_DSd ,
                    regs.lr_column);
                dwarfstring_append_printf_u(&mb,
                    " 0x%" DW_PR_XZEROS DW_PR_DSx "\n",
                    regs.lr_column);
                _dwarf_printf(dbg,dwarfstring_string(&mb));
                dwarfstring_destructor(&mb);
#endif /* PRINTING_DETAILS */
                }
                break;
            case DW_LNS_negate_stmt:{
                regs.lr_is_stmt = !regs.lr_is_stmt;
#ifdef PRINTING_DETAILS
                _dwarf_printf(dbg, "DW_LNS_negate_stmt\n");
#endif /* PRINTING_DETAILS */
                }
                break;
            case DW_LNS_set_basic_block:{
                regs.lr_basic_block = true;
#ifdef PRINTING_DETAILS
                _dwarf_printf(dbg,
                    "DW_LNS_set_basic_block\n");
#endif /* PRINTING_DETAILS */
                }
                break;

            case DW_LNS_const_add_pc:{
                opcode = MAX_LINE_OP_CODE -
                    line_context->lc_opcode_base;
                if (line_context->lc_maximum_ops_per_instruction < 2){
                    Dwarf_Unsigned operation_advance =
                        (opcode / line_context->lc_line_range);
                    regs.lr_address = regs.lr_address +
                        line_context->lc_minimum_instruction_length *
                            operation_advance;
                } else {
                    Dwarf_Unsigned operation_advance =
                        (opcode / line_context->lc_line_range);
                    regs.lr_address = regs.lr_address +
                        line_context->lc_minimum_instruction_length *
                        ((regs.lr_op_index + operation_advance)/
                        line_context->lc_maximum_ops_per_instruction);
                    regs.lr_op_index =
                        (regs.lr_op_index +operation_advance)%
                        line_context->lc_maximum_ops_per_instruction;
                }
#ifdef PRINTING_DETAILS
                dwarfstring_constructor(&mb);
                dwarfstring_append_printf_u(&mb,
                    "DW_LNS_const_add_pc new address 0x%"
                    DW_PR_XZEROS DW_PR_DSx "\n",
                    regs.lr_address);
                _dwarf_printf(dbg,dwarfstring_string(&mb));
                dwarfstring_destructor(&mb);
#endif /* PRINTING_DETAILS */
                }
                break;
            case DW_LNS_fixed_advance_pc:{
                Dwarf_Unsigned fpc = 0;
                int apres = 0;
                /*READ_UNALIGNED_CK(dbg, fixed_advance_pc,
                    Dwarf_Half, line_ptr,
                    DWARF_HALF_SIZE,error,line_ptr_end); */
                apres = _dwarf_read_unaligned_ck_wrapper(dbg,
                    &fpc,line_ptr,DWARF_HALF_SIZE,line_ptr_end,
                    error);
                fixed_advance_pc = fpc;
                if (apres == DW_DLV_ERROR) {
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    }
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    return apres;
                }
                line_ptr += DWARF_HALF_SIZE;
                if (line_ptr > line_ptr_end) {
                    dwarfstring g;
                    /*  ptrdiff_t is generated but not named */
                    Dwarf_Unsigned localoff =
                        (line_ptr >= section_start)?
                        (line_ptr - section_start):0xfffffff;

                    dwarfstring_constructor(&g);
                    dwarfstring_append_printf_u(&g,
                        "DW_DLE_LINE_TABLE_BAD reading "
                        "DW_LNS_fixed_advance_pc we are "
                        "off this line table at section "
                        "offset. 0x%x .",
                        localoff);
                    _dwarf_error_string(dbg, error,
                        DW_DLE_LINE_TABLE_BAD,
                        dwarfstring_string(&g));
                    dwarfstring_destructor(&g);
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    }
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    return DW_DLV_ERROR;
                }
                regs.lr_address = regs.lr_address + fixed_advance_pc;
                regs.lr_op_index = 0;
#ifdef PRINTING_DETAILS
                dwarfstring_constructor(&mb);
                dwarfstring_append_printf_i(&mb,
                    "DW_LNS_fixed_advance_pc val %"
                    DW_PR_DSd, fixed_advance_pc);
                dwarfstring_append_printf_u(&mb,
                    " 0x%" DW_PR_XZEROS DW_PR_DSx,
                    fixed_advance_pc);
                dwarfstring_append_printf_u(&mb,
                    " new address 0x%"
                    DW_PR_XZEROS DW_PR_DSx "\n",
                    regs.lr_address);
                _dwarf_printf(dbg,
                    dwarfstring_string(&mb));
                dwarfstring_destructor(&mb);
#endif /* PRINTING_DETAILS */
                }
                break;

                /* New in DWARF3 */
            case DW_LNS_set_prologue_end:{
                regs.lr_prologue_end = true;
                }
                break;
                /* New in DWARF3 */
            case DW_LNS_set_epilogue_begin:{
                regs.lr_epilogue_begin = true;
#ifdef PRINTING_DETAILS
                _dwarf_printf(dbg,
                    "DW_LNS_set_prologue_end set true.\n");
#endif /* PRINTING_DETAILS */
                }
                break;

                /* New in DWARF3 */
            case DW_LNS_set_isa:{
                Dwarf_Unsigned utmp2 = 0;
                int sires = 0;

                sires =  read_uword_de( &line_ptr,&utmp2,
                    dbg,error,line_ptr_end);
                if (sires == DW_DLV_ERROR) {
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    }
                    return DW_DLV_ERROR;
                }

                regs.lr_isa = utmp2;

#ifdef PRINTING_DETAILS
                dwarfstring_constructor(&mb);
                dwarfstring_append_printf_u(&mb,
                    "DW_LNS_set_isa new value 0x%"
                    DW_PR_XZEROS DW_PR_DUx ".\n",
                    utmp2);
                _dwarf_printf(dbg,dwarfstring_string(&mb));
                dwarfstring_destructor(&mb);
#endif /* PRINTING_DETAILS */
                if (regs.lr_isa != utmp2) {
                    /*  The value of the isa did
                        not fit in our
                        local so we record it wrong.
                        declare an error. */
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    }
                    _dwarf_free_chain_entries(dbg,
                        head_chain,line_count);
                    _dwarf_error(dbg, error,
                        DW_DLE_LINE_NUM_OPERANDS_BAD);
                    return DW_DLV_ERROR;
                }
                }
                break;

                /*  Experimental two-level line tables */
                /*  DW_LNS_set_address_from_logical and
                    DW_LNS_set_subprogram
                    share the same opcode. Disambiguate by checking
                    is_actuals_table. */
            case DW_LNS_set_subprogram:

                if (is_actuals_table) {
                    /* DW_LNS_set_address_from_logical */
                    Dwarf_Signed stmp = 0;
                    int atres = 0;

                    atres =  read_sword_de( &line_ptr,&stmp,
                        dbg,error,line_ptr_end);
                    if (atres == DW_DLV_ERROR) {
                        _dwarf_free_chain_entries(dbg,head_chain,
                            line_count);
                        if (curr_line) {
                            dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                        }
                        return DW_DLV_ERROR;
                    }
                    advance_line = (Dwarf_Signed) stmp;
                    regs.lr_line = regs.lr_line + advance_line;
                    if ((Dwarf_Signed)regs.lr_line < 0) {
                        dwarfstring m;

                        dwarfstring_constructor(&m);
                        dwarfstring_append_printf_i(&m,
                            "\nERROR: DW_DLE_LINE_TABLE_LINENO_ERROR"
                            " The line number is %d "
                            "and negative line numbers after "
                            "DW_LNS_set_subprogram ",
                            (Dwarf_Signed)regs.lr_line);
                        dwarfstring_append_printf_i(&m,
                            " of %d applied "
                            "are not correct.",stmp);
                        _dwarf_error_string(dbg, error,
                            DW_DLE_LINE_TABLE_LINENO_ERROR,
                            dwarfstring_string(&m));
                        dwarfstring_destructor(&m);
                        regs.lr_line = 0;
                        _dwarf_free_chain_entries(dbg,
                            head_chain,line_count);
                        if (curr_line) {
                            dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                        }
                        return DW_DLV_ERROR;

                    }
                    if (regs.lr_line >= 1 &&
                        regs.lr_line - 1 < logicals_count) {
                        regs.lr_address =
                            logicals[regs.lr_line - 1]->li_address;
                        regs.lr_op_index = 0;
#ifdef PRINTING_DETAILS /* block 1 print */
                        dwarfstring_constructor(&mb);
                        dwarfstring_append_printf_i(&mb,
                            "DW_LNS_set_address_from"
                            "_logical "
                            "%" DW_PR_DSd,
                            stmp);
                        dwarfstring_append_printf_u(&mb,
                            " 0x%" DW_PR_XZEROS DW_PR_DSx,
                            stmp);
                        dwarfstring_append_printf_u(&mb,
                            "  newaddr="
                            " 0x%" DW_PR_XZEROS DW_PR_DUx ".\n",
                            regs.lr_address);
                        _dwarf_printf(dbg,
                            dwarfstring_string(&mb));
                        dwarfstring_destructor(&mb);
#endif /* PRINTING_DETAILS */
                    } else {
#ifdef PRINTING_DETAILS /* block 2 print */
                        dwarfstring_constructor(&mb);
                        dwarfstring_append_printf_i(&mb,
                            "DW_LNS_set_address_from_logical line"
                            " is %" DW_PR_DSd ,
                            regs.lr_line);
                        dwarfstring_append_printf_u(&mb,
                            " 0x%" DW_PR_XZEROS DW_PR_DSx ".\n",
                            regs.lr_line);
                        _dwarf_printf(dbg,
                            dwarfstring_string(&mb));
                        dwarfstring_destructor(&mb);
#endif /* PRINTING_DETAILS */
                    }
                } else {
                    /*  DW_LNS_set_subprogram,
                        building logicals table.  */
                    Dwarf_Unsigned utmp2 = 0;
                    int spres = 0;

                    regs.lr_call_context = 0;
                    spres =  read_uword_de( &line_ptr,&utmp2,
                        dbg,error,line_ptr_end);
                    if (spres == DW_DLV_ERROR) {
                        _dwarf_free_chain_entries(dbg,head_chain,
                            line_count);
                        if (curr_line) {
                            dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                        }
                        return DW_DLV_ERROR;
                    }
                    regs.lr_subprogram = utmp2;
#ifdef PRINTING_DETAILS /* block 3 print */
                    dwarfstring_constructor(&mb);
                    dwarfstring_append_printf_i(&mb,
                        "DW_LNS_set_subprogram "
                        "%" DW_PR_DSd,
                        utmp2);
                    dwarfstring_append_printf_u(&mb,
                        " 0x%" DW_PR_XZEROS DW_PR_DSx "\n",
                        utmp2);
                    _dwarf_printf(dbg,
                        dwarfstring_string(&mb));
                    dwarfstring_destructor(&mb);
#endif /* PRINTING_DETAILS */
                }
                break;
                /* Experimental two-level line tables */
            case DW_LNS_inlined_call: {
                Dwarf_Signed stmp = 0;
                Dwarf_Unsigned ilcuw = 0;
                int icres  = 0;

                icres =  read_sword_de( &line_ptr,&stmp,
                    dbg,error,line_ptr_end);
                if (icres == DW_DLV_ERROR) {
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    }
                    return DW_DLV_ERROR;
                }
                regs.lr_call_context = line_count + stmp;
                icres =  read_uword_de(&line_ptr,&ilcuw,
                    dbg,error,line_ptr_end);
                regs.lr_subprogram = ilcuw;
                if (icres == DW_DLV_ERROR) {
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    }
                    return DW_DLV_ERROR;
                }

#ifdef PRINTING_DETAILS
                dwarfstring_constructor(&mb);
                dwarfstring_append_printf_i(&mb,
                    "DW_LNS_inlined_call "
                    "%" DW_PR_DSd ,stmp);
                dwarfstring_append_printf_u(&mb,
                    " (0x%" DW_PR_XZEROS DW_PR_DSx "),",
                    stmp);
                dwarfstring_append_printf_i(&mb,
                    "%" DW_PR_DSd,
                    regs.lr_subprogram);
                dwarfstring_append_printf_u(&mb,
                    " (0x%" DW_PR_XZEROS DW_PR_DSx ")",
                    regs.lr_subprogram);
                dwarfstring_append_printf_i(&mb,
                    "  callcontext=" "%" DW_PR_DSd ,
                    regs.lr_call_context);
                dwarfstring_append_printf_u(&mb,
                    " (0x%" DW_PR_XZEROS DW_PR_DSx ")\n",
                    regs.lr_call_context);
                _dwarf_printf(dbg,
                    dwarfstring_string(&mb));
                dwarfstring_destructor(&mb);
#endif /* PRINTING_DETAILS */
                }
                break;

                /* Experimental two-level line tables */
            case DW_LNS_pop_context: {
                Dwarf_Unsigned logical_num = regs.lr_call_context;
                Dwarf_Chain logical_chain = head_chain;
                Dwarf_Line logical_line = 0;

                if (logical_num > 0 && logical_num <= line_count) {
                    for (i = 1; i < logical_num; i++) {
                        logical_chain = logical_chain->ch_next;
                    }
                    logical_line =
                        (Dwarf_Line) logical_chain->ch_item;
                    regs.lr_file =
                        logical_line->li_l_data.li_file;
                    regs.lr_line =
                        logical_line->li_l_data.li_line;
                    regs.lr_column =
                        logical_line->
                            li_l_data.li_column;
                    regs.lr_discriminator =
                        logical_line->
                            li_l_data.li_discriminator;
                    regs.lr_is_stmt =
                        logical_line->
                            li_l_data.li_is_stmt;
                    regs.lr_call_context =
                        logical_line->
                            li_l_data.li_call_context;
                    regs.lr_subprogram =
                        logical_line->
                            li_l_data.li_subprogram;
#ifdef PRINTING_DETAILS
                    {
                    dwarfstring pcon;
                    dwarfstring_constructor(&pcon);
                    dwarfstring_append_printf_u(&pcon,
                        "DW_LNS_pop_context set"
                        " from logical "
                        "%" DW_PR_DUu ,logical_num);
                    dwarfstring_append_printf_u(&pcon,
                        " (0x%" DW_PR_XZEROS DW_PR_DUx ")\n",
                        logical_num);
                    _dwarf_printf(dbg,
                        dwarfstring_string(&pcon));
                    dwarfstring_destructor(&pcon);
                    }
                } else {
                    dwarfstring pcon;
                    dwarfstring_constructor(&pcon);
                    dwarfstring_append_printf_u(&pcon,
                        "DW_LNS_pop_context does nothing, logical"
                        "%" DW_PR_DUu ,
                        logical_num);
                    dwarfstring_append_printf_u(&pcon,
                        " (0x%" DW_PR_XZEROS DW_PR_DUx ")\n",
                        logical_num);
                    _dwarf_printf(dbg,
                        dwarfstring_string(&pcon));
                    dwarfstring_destructor(&pcon);
#endif /* PRINTING_DETAILS */
                }
                }
                break;
            default:
                _dwarf_error_string(dbg, error,
                    DW_DLE_LINE_TABLE_BAD,
                    "DW_DLE_LINE_TABLE_BAD: "
                    "Impossible standard line table operator");
                return DW_DLV_ERROR;
            } /* End switch (opcode) */
        } else if (type == LOP_EXTENDED) {
            Dwarf_Unsigned utmp3 = 0;
            Dwarf_Small ext_opcode = 0;
            int leres = 0;

            leres =  read_uword_de( &line_ptr,&utmp3,
                dbg,error,line_ptr_end);
            if (leres == DW_DLV_ERROR) {
                _dwarf_free_chain_entries(dbg,head_chain,
                    line_count);
                if (curr_line) {
                    dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                }
                return DW_DLV_ERROR;
            }

            instr_length =  utmp3;
            /*  Dwarf_Small is a ubyte and the extended opcode is a
                ubyte, though not stated as clearly in the
                2.0.0 spec as one might hope. */
            if (line_ptr >= line_ptr_end) {
                dwarfstring g;
                /*  ptrdiff_t is generated but not named */
                Dwarf_Unsigned localoffset =
                    (line_ptr >= section_start)?
                    (line_ptr - section_start) : 0;

                dwarfstring_constructor(&g);
                dwarfstring_append_printf_u(&g,
                    "DW_DLE_LINE_TABLE_BAD reading "
                    "extended op we are "
                    "off this line table at section "
                    "offset 0x%x .",
                    localoffset);
                _dwarf_error_string(dbg, error,
                    DW_DLE_LINE_TABLE_BAD,
                    dwarfstring_string(&g));
                dwarfstring_destructor(&g);
                if (curr_line) {
                    dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                }
                _dwarf_free_chain_entries(dbg,head_chain,line_count);
                return DW_DLV_ERROR;
            }
            ext_opcode = *(Dwarf_Small *) line_ptr;
            line_ptr++;
            if (line_ptr > line_ptr_end) {
                dwarfstring g;
                /*  ptrdiff_t is generated but not named */
                Dwarf_Unsigned localoff =
                    (line_ptr >= section_start)?
                    (line_ptr - section_start):0xfffffff;

                dwarfstring_constructor(&g);
                dwarfstring_append_printf_u(&g,
                    "DW_DLE_LINE_TABLE_BAD reading "
                    "extended op opcode we are "
                    "off this line table at section "
                    "

// --- CODE TRUNCATED HERE ---

// the below code fragment can be found in:
// src/bin/dwarfdump/print_lines.c
static int
process_line_table(Dwarf_Debug dbg,
    const char *sec_name,
    Dwarf_Line *linebuf,
    Dwarf_Signed linecount,
    Dwarf_Bool is_logicals_table,
    Dwarf_Bool is_actuals_table,
    Dwarf_Error *lt_err)
{
    char *padding = 0;
    Dwarf_Signed i = 0;
    Dwarf_Addr pc = 0;
    Dwarf_Unsigned lineno = 0;
    Dwarf_Unsigned logicalno = 0;
    Dwarf_Unsigned column = 0;
    Dwarf_Unsigned call_context = 0;
    char* subprog_name = 0;
    char* subprog_filename = 0;
    Dwarf_Unsigned subprog_line = 0;

    Dwarf_Bool newstatement = 0;
    Dwarf_Bool lineendsequence = 0;
    Dwarf_Bool new_basic_block = 0;
    int sres = 0;
    int ares = 0;
    int lires = 0;
    int cores = 0;
    char lastsrc_tmp[ESB_FIXED_ALLOC_SIZE];
    struct esb_s lastsrc;
    Dwarf_Addr elf_max_address = 0;
    Dwarf_Bool SkipRecord = FALSE;

    esb_constructor_fixed(&lastsrc,lastsrc_tmp,sizeof(lastsrc_tmp));
    glflags.current_section_id = DEBUG_LINE;
    /* line_flag is TRUE */
    get_address_size_and_max(dbg,0,&elf_max_address,lt_err);
    /* Padding for a nice layout */
    padding = glflags.gf_line_print_pc ? "            " : "";
    if (glflags.gf_do_print_dwarf) {
        /* Check if print of <pc> address is needed. */
        printf("\n");
        if (is_logicals_table) {
            printf("Logicals Table:\n");
            printf("%sNS new statement, PE prologue end, "
                "EB epilogue begin\n",padding);
            printf("%sDI=val discriminator value\n",
                padding);
            printf("%sCC=val context, SB=val subprogram\n",
                padding);
        } else if (is_actuals_table) {
            printf("Actuals Table:\n");
            printf("%sBB new basic block, ET end of text sequence\n"
                "%sIS=val ISA number\n",padding,padding);

        } else {
            /* Standard DWARF line table. */
            printf("%sNS new statement, BB new basic block, "
                "ET end of text sequence\n",padding);
            printf("%sPE prologue end, EB epilogue begin\n",padding);
            printf("%sIS=val ISA number, "
                "DI=val discriminator value\n",
                padding);
        }
        if (is_logicals_table || is_actuals_table) {
            printf("[ row]  ");
        }
        if (glflags.gf_line_print_pc) {
            printf("<pc>        ");
        }
        if (is_logicals_table) {
            printf("[lno,col] NS PE EB DI= CC= SB= uri:"
                " \"filepath\"\n");
        } else if (is_actuals_table) {
            printf("[logical] BB ET IS=\n");
        } else {
            printf("[lno,col] NS BB ET PE EB IS= DI= uri:"
                " \"filepath\"\n");
        }
    }
    for (i = 0; i < linecount; i++) {
        Dwarf_Line line = linebuf[i];
        char* lsrc_filename = 0;
        int nsres = 0;
        Dwarf_Bool found_line_error = FALSE;
        Dwarf_Bool has_is_addr_set = FALSE;
        char *where = NULL;

        if (glflags.gf_check_decl_file && checking_this_compiler()) {
            /* A line record with addr=0 was detected */
            if (SkipRecord) {
                /* Skip records that do not have is_addr_set */
                ares = dwarf_line_is_addr_set(line,
                    &has_is_addr_set, lt_err);
                if (ares == DW_DLV_OK && has_is_addr_set) {
                    SkipRecord = FALSE;
                }
                else {
                    /*  Keep ignoring records until we have
                        one with 'is_addr_set' */
                    continue;
                }
            }
        }

        if (glflags.gf_check_lines && checking_this_compiler()) {
            DWARF_CHECK_COUNT(lines_result,1);
        }

        /*  NO. lsrc_filename is a DW_DLA_STRING, do not assign
            a static string.
            lsrc_filename = "<unknown>";
        */
        if (!is_actuals_table) {
            Dwarf_Error aterr = 0;

            sres = dwarf_linesrc(line, &lsrc_filename, &aterr);
            if (sres == DW_DLV_ERROR) {
                /* Do not terminate processing  */
                if (glflags.gf_do_check_dwarf &&
                    checking_this_compiler()) {
                    where = "dwarf_linesrc()";
                    print_common_line_error(where,aterr);
                    found_line_error = TRUE;
                }
                DROP_ERROR_INSTANCE(dbg,sres,aterr);
            }
        }

        pc = 0;
        ares = dwarf_lineaddr(line, &pc, lt_err);

        if (ares == DW_DLV_ERROR) {
            /* Do not terminate processing */
            if (glflags.gf_do_check_dwarf &&
                checking_this_compiler()) {
                where = "dwarf_lineaddr()";
                print_common_line_error(where,*lt_err);
                found_line_error = TRUE;
            }
            pc = 0;
            DROP_ERROR_INSTANCE(dbg,ares,*lt_err);
        }
        if (ares == DW_DLV_NO_ENTRY) {
            pc = 0;
        }

        if (is_actuals_table) {
            lires = dwarf_linelogical(line, &logicalno, lt_err);
            if (lires == DW_DLV_ERROR) {
                /* Do not terminate processing */
                if (glflags.gf_do_check_dwarf &&
                    checking_this_compiler()) {
                    where = "dwarf_linelogical()";
                    print_common_line_error(where,*lt_err);
                    found_line_error = TRUE;
                }
                DROP_ERROR_INSTANCE(dbg,lires,*lt_err);
            }
            if (lires == DW_DLV_NO_ENTRY) {
                logicalno = 0;
            }
            column = 0;
        } else {
            lires = dwarf_lineno(line, &lineno, lt_err);
            if (lires == DW_DLV_ERROR) {
                /* Do not terminate processing */
                where = "dwarf_lineno()";
                print_common_line_error(where,*lt_err);
                found_line_error = TRUE;
                DROP_ERROR_INSTANCE(dbg,lires,*lt_err);
            }
            if (lires == DW_DLV_NO_ENTRY) {
                lineno = 0;
            }
            cores = dwarf_lineoff_b(line, &column, lt_err);
            if (cores == DW_DLV_ERROR) {
                /* Do not terminate processing */
                if (glflags.gf_do_check_dwarf &&
                    checking_this_compiler()) {
                    where = "dwarf_lineoff()";
                    print_common_line_error(where,*lt_err);
                    found_line_error = TRUE;
                }
                DROP_ERROR_INSTANCE(dbg,cores,*lt_err);
            }
            if (cores == DW_DLV_NO_ENTRY) {
                /*  Zero was always the correct default, meaning
                    the left edge. DWARF2/3/4 spec sec 6.2.2 */
                column = 0;
            }
        }

        /*  Process any possible error condition, though
            we won't be at the first such error. */
        if ((glflags.gf_check_decl_file ||
            glflags.gf_check_lines) &&
            checking_this_compiler()) {
            DWARF_CHECK_COUNT(decl_file_result,1);
            if (found_line_error) {
                /* DWARF_CHECK already issued. */
#if 0
                DWARF_CHECK_ERROR2(decl_file_result,where,
                    dwarf_errmsg(lt_err);
#endif

            } else if (glflags.gf_do_check_dwarf) {
                /*  Check the address lies with a
                    valid [lowPC:highPC]
                    in the .text section*/
                if (IsValidInBucketGroup(glflags.pRangesInfo,pc)) {
                    /* Valid values; do nothing */
                } else {
                    /*  At this point may be we are dealing with
                        a linkonce symbol. The problem we have here
                        is we have consumed the .debug_info section
                        and we are dealing just with the records
                        from the .debug_line, so no PU_name is
                        available and no high_pc.
                        Traverse the linkonce table if try to
                        match the pc value with one of those ranges.
                    */
                    if (glflags.gf_check_lines &&
                        checking_this_compiler()) {
                        DWARF_CHECK_COUNT(lines_result,1);
                    }
                    if (FindAddressInBucketGroup(
                        glflags.pLinkonceInfo,pc)){
                        /* Valid values; do nothing */
                    } else {
                        /*  The SN Systems Linker generates
                            line records
                            with addr=0, when dealing with linkonce
                            symbols and no stripping */
                        if (pc) {
                            if (glflags.gf_check_lines &&
                                checking_this_compiler()) {
                                char abuf[50];
                                struct esb_s atm;

                                esb_constructor_fixed(&atm,
                                    abuf,sizeof(abuf));
                                esb_append_printf_s(&atm,
                                    "%s: Address",
                                    sanitized(sec_name));
                                esb_append_printf_u(&atm,
                                    " 0x%" DW_PR_XZEROS DW_PR_DUx
                                    " outside a valid .text range",
                                    pc);
                                DWARF_CHECK_ERROR(lines_result,
                                    esb_get_string(&atm));
                                esb_destructor(&atm);
                            }
                        } else {
                            SkipRecord = TRUE;
                        }
                    }
                } /* end not in bucket group */
                /*  Check the last record for the .debug_line,
                    the one created by DW_LNE_end_sequence,
                    is the same as the high_pc
                    address for the last known user program
                    unit (PU).
                    There is no real reason */
                if ((i + 1 == linecount) &&
                    glflags.seen_PU_high_address &&
                    !is_logicals_table) {
                    check_last_line_of_table(pc,
                        elf_max_address,sec_name);
                }/* end seen_PU_high_address */
            }
        }

        /* Display the error information */
        if (found_line_error || glflags.gf_record_dwarf_error) {
            if (glflags.gf_check_verbose_mode && PRINTING_UNIQUE) {
                /*  Print the record number for better
                    error description */
                printf("Record = %"  DW_PR_DUu
                    " Addr = 0x%" DW_PR_XZEROS DW_PR_DUx
                    " [%4" DW_PR_DUu ",%2" DW_PR_DUu "] '%s'\n",
                    i, pc,lineno,column,
                    lsrc_filename?sanitized(lsrc_filename):"");
                /* The compilation unit was already printed */
                if (!glflags.gf_check_decl_file) {
                    PRINT_CU_INFO();
                }
            }
            glflags.gf_record_dwarf_error = FALSE;
            /* Due to a fatal error, skip current record */
            if (found_line_error) {
                dwarf_dealloc(dbg, lsrc_filename, DW_DLA_STRING);
                lsrc_filename = 0;
                continue;
            }
        }
        if (glflags.gf_do_print_dwarf) {
            if (is_logicals_table || is_actuals_table) {
                printf("[%4" DW_PR_DUu "]  ", i + 1);
            }
            /* Check if print of <pc> address is needed. */
            if (glflags.gf_line_print_pc) {
                printf("0x%" DW_PR_XZEROS DW_PR_DUx "  ", pc);
            }
            if (is_actuals_table) {
                printf("[%7" DW_PR_DUu "]", logicalno);
            } else {
                printf("[%4" DW_PR_DUu ",%2" DW_PR_DUu "]",
                    lineno, column);
            }
        }

        if (!is_actuals_table) {
            nsres = dwarf_linebeginstatement(line,
                &newstatement, lt_err);
            if (nsres == DW_DLV_OK) {
                if (newstatement && glflags.gf_do_print_dwarf) {
                    printf(" %s","NS");
                }
            } else if (nsres == DW_DLV_ERROR) {
                struct esb_s m;
                esb_constructor(&m);
                esb_append_printf_u(&m,
                    "\nERROR: dwarf_linebeginstatement failed"
                    " on linebuf index %u ",i);
                esb_append_printf_u(&m,
                    "of %u line records in the linebuf.",
                    linecount);
                simple_err_return_action(nsres,
                    esb_get_string(&m));
                esb_destructor(&m);
                dwarf_dealloc(dbg, lsrc_filename, DW_DLA_STRING);
                lsrc_filename = 0;
                return nsres;
            }
        }

        if (!is_logicals_table) {
            nsres = dwarf_lineblock(line,
                &new_basic_block, lt_err);
            if (nsres == DW_DLV_OK) {
                if (new_basic_block && glflags.gf_do_print_dwarf) {
                    printf(" %s","BB");
                }
            } else if (nsres == DW_DLV_ERROR) {
                struct esb_s m;
                esb_constructor(&m);
                esb_append_printf_u(&m,
                    "\nERROR: dwarf_lineblock failed"
                    " on linebuf index %u ",i);
                esb_append_printf_u(&m,
                    "of %u line records in the linebuf.",
                    linecount);
                simple_err_return_action(nsres,
                    esb_get_string(&m));
                esb_destructor(&m);
                dwarf_dealloc(dbg, lsrc_filename, DW_DLA_STRING);
                lsrc_filename = 0;
                return nsres;
            }
            nsres = dwarf_lineendsequence(line,
                &lineendsequence, lt_err);
            if (nsres == DW_DLV_OK) {
                if (lineendsequence &&
                    glflags.gf_do_print_dwarf) {
                    printf(" %s", "ET");
                }
            } else if (nsres == DW_DLV_ERROR) {
                struct esb_s m;
                esb_constructor(&m);
                esb_append_printf_u(&m,
                    "\nERROR: dwarf_lineendsequence failed"
                    " on linebuf index %u ",i);
                esb_append_printf_u(&m,
                    "of %u line records in the linebuf.",
                    linecount);
                simple_err_return_action(nsres,
                    esb_get_string(&m));
                esb_destructor(&m);
                dwarf_dealloc(dbg, lsrc_filename, DW_DLA_STRING);
                lsrc_filename = 0;
                return nsres;
            }
        }

        if (glflags.gf_do_print_dwarf) {
            Dwarf_Bool prologue_end = 0;
            Dwarf_Bool epilogue_begin = 0;
            Dwarf_Unsigned isa = 0;
            Dwarf_Unsigned discriminator = 0;
            int disres = dwarf_prologue_end_etc(line,
                &prologue_end,&epilogue_begin,
                &isa,&discriminator,lt_err);
            if (disres == DW_DLV_ERROR) {
                struct esb_s m;
                esb_constructor(&m);
                esb_append_printf_u(&m,
                    "\nERROR: dwarf_prologue_end_etc() failed"
                    " on linebuf index %u ",i);
                esb_append_printf_u(&m,
                    "of %u line records in the linebuf.",
                    linecount);
                simple_err_return_action(nsres,
                    esb_get_string(&m));
                esb_destructor(&m);
                dwarf_dealloc(dbg, lsrc_filename, DW_DLA_STRING);
                lsrc_filename = 0;
                return disres;
            }
            if (prologue_end && !is_actuals_table) {
                printf(" PE");
            }
            if (epilogue_begin && !is_actuals_table) {
                printf(" EB");
            }
            if (isa && !is_logicals_table) {
                printf(" IS=0x%" DW_PR_DUx, isa);
            }
            if (discriminator && !is_actuals_table) {
                printf(" DI=0x%" DW_PR_DUx, discriminator);
            }
            if (is_logicals_table) {
                call_context = 0;
                disres = dwarf_linecontext(line,
                    &call_context, lt_err);
                if (disres == DW_DLV_ERROR) {
                    struct esb_s m;
                    esb_constructor(&m);
                    esb_append_printf_u(&m,
                        "\nERROR: dwarf_linecontext() failed"
                        " on linebuf index %u ",i);
                    esb_append_printf_u(&m,
                        "of %u line records in the linebuf.",
                        linecount);
                        simple_err_return_action(nsres,
                        esb_get_string(&m));
                    esb_destructor(&m);
                    dwarf_dealloc(dbg, lsrc_filename, DW_DLA_STRING);
                    lsrc_filename = 0;
                    return disres;
                }
                if (call_context) {
                    printf(" CC=%" DW_PR_DUu, call_context);
                }
                {
                    Dwarf_Unsigned subprogno = 0;
                    disres = dwarf_line_subprogno(line,
                        &subprogno,0);
                    if (disres == DW_DLV_OK) {
                        /*  The validity of subprogno
                            is actually used&checked in
                            dwarf_line_subprog()
                            (called next)
                            so we need not check it here.  */
                    } else {
                        printf("ERROR: dwarf_line_subprogno()"
                            " impossibly! "
                            "fails. with result %d\n",disres);
                        glflags.gf_count_major_errors++;
                    }
                }
                subprog_name = 0;
                disres = dwarf_line_subprog(line,
                    &subprog_name,
                    &subprog_filename,
                    &subprog_line, lt_err);
                if (disres == DW_DLV_ERROR) {
                    struct esb_s m;
                    esb_constructor(&m);
                    esb_append_printf_u(&m,
                        "\nERROR: dwarf_line_subprog() failed"
                        " on linebuf index %u ",i);
                    esb_append_printf_u(&m,
                        "of %u line records in the linebuf.",
                        linecount);
                    simple_err_return_action(nsres,
                        esb_get_string(&m));
                    esb_destructor(&m);
                    dwarf_dealloc(dbg, lsrc_filename, DW_DLA_STRING);
                    lsrc_filename = 0;
                    return disres;
                }
                if (subprog_name && strlen(subprog_name)) {
                    /*  We do not print an empty name.
                        Clutters things up. */
                    printf(" SB=\"%s\"", sanitized(subprog_name));
                }
                dwarf_dealloc(dbg,subprog_filename, DW_DLA_STRING);
                subprog_filename = 0;
            }
        }

        if (!is_actuals_table) {
            if (i == 0  ||  glflags.verbose > 2 ||
                strcmp(lsrc_filename?lsrc_filename:"",
                    esb_get_string(&lastsrc))) {
                struct esb_s urs;
                char atmp2[ESB_FIXED_ALLOC_SIZE];

                esb_constructor_fixed(&urs,atmp2,sizeof(atmp2));
                esb_append(&urs, " uri: \"");
                translate_to_uri(lsrc_filename?
                    lsrc_filename:"",
                    &urs);
                esb_append(&urs,"\"");
                if (glflags.gf_do_print_dwarf) {
                    printf("%s",esb_get_string(&urs));
                }
                esb_destructor(&urs);
                esb_empty_string(&lastsrc);
                esb_append(&lastsrc,
                    lsrc_filename?lsrc_filename:"");
            } else {
                /*  Do not print name, it is the same
                    as the last name printed. */
            }
        }
        if (glflags.gf_do_print_dwarf) {
            printf("\n");
        }
        dwarf_dealloc(dbg,lsrc_filename, DW_DLA_STRING);
        lsrc_filename = 0;
    }
    esb_destructor(&lastsrc);
    return DW_DLV_OK;
}

// the below code fragment can be found in:
// src/bin/dwarfdump/print_lines.c
static int
print_line_context_record(Dwarf_Line_Context line_context,
    Dwarf_Error *err)
{
    int vres = 0;
    Dwarf_Unsigned lsecoff = 0;
    Dwarf_Unsigned version = 0;
    Dwarf_Signed dir_count = 0;
    Dwarf_Signed baseindex = 0;
    Dwarf_Signed file_count = 0;
    Dwarf_Signed endindex = 0;
    Dwarf_Signed i = 0;
    Dwarf_Signed subprog_count = 0;
    const char *name = 0;
    Dwarf_Small table_count = 0;
    struct esb_s bufr;
    int include_dir_base = 1; /* DWARF2.3,4 */
    int include_dir_limit = 0; /* set below */
    char bufr_tmp[ESB_FIXED_ALLOC_SIZE];

    esb_constructor_fixed(&bufr,bufr_tmp,sizeof(bufr_tmp));
    printf("Line Context data\n");
    vres = dwarf_srclines_table_offset(line_context,&lsecoff,
        err);
    if (vres != DW_DLV_OK) {
        simple_err_return_action(vres,
            "\nERROR: dwarf_srclines_table_offset() failed"
            ". Something broken");
        return vres;
    }
    printf(" Line Section Offset 0x%"
        DW_PR_XZEROS DW_PR_DUx "\n", lsecoff);
    vres = dwarf_srclines_version(line_context,&version,
        &table_count, err);
    if (vres != DW_DLV_OK) {
        simple_err_return_action(vres,
            "\nERROR: dwarf_srclines_version() failed"
            ". Something broken");
        return vres;
    }
    printf(" version number      0x%" DW_PR_DUx
        " %" DW_PR_DUu "\n",
        version,version);
    printf(" number of line tables  %d.\n", table_count);
    vres = dwarf_srclines_comp_dir(line_context,&name,err);
    if (vres != DW_DLV_OK) {
        simple_err_return_action(vres,
            "\nERROR: dwarf_srclines_comp_dir() failed"
            ". Something broken");
        return vres;
    }
    if (name) {
        printf(" Compilation directory: %s\n",name);
    } else {
        printf(" Compilation directory: <unknown"
            " no DW_AT_comp_dir>\n");
    }

    vres = dwarf_srclines_include_dir_count(line_context,
        &dir_count,err);
    if (vres != DW_DLV_OK) {
        simple_err_return_action(vres,
            "\nERROR: dwarf_srclines_comp_dir() failed"
            ". Something broken");
        return vres;
    }
    printf(" include directory count 0x%"
        DW_PR_DUx " %" DW_PR_DSd "\n",
        (Dwarf_Unsigned)dir_count,dir_count);
    if (version == DW_LINE_VERSION5) {
        include_dir_base = 0;
        include_dir_limit = dir_count;
    } else {
        include_dir_base = 1;
        include_dir_limit = dir_count+1;
    }
    for (i = include_dir_base; i < include_dir_limit; ++i) {
        vres = dwarf_srclines_include_dir_data(line_context,i,
            &name,err);
        if (vres != DW_DLV_OK) {
            struct esb_s m;

            esb_constructor(&m);
            esb_append_printf_i(&m,
                "\nERROR: Error accessing include directory "
                "  %d ",i);
            esb_append_printf_i(&m,
                "(max allowed index is %d).",dir_count);
            simple_err_return_action(vres,
                esb_get_string(&m));
            esb_destructor(&m);
            return vres;
        }
        printf("  [%2" DW_PR_DSd "]  \"%s\"\n",i,name);
    }

    vres = dwarf_srclines_files_indexes(line_context,
        &baseindex,&file_count,&endindex,err);
    if (vres != DW_DLV_OK) {
        simple_err_return_action(vres,
            "\nERROR: Error accessing files indexes");
        return vres;
    }
    printf( " files count 0x%"
        DW_PR_DUx " %" DW_PR_DUu "\n",
        file_count,file_count);
    /*  Set up so just one loop control needed
        for all versions of line tables. */
    for (i = baseindex; i < endindex; ++i) {
        Dwarf_Unsigned dirindex = 0;
        Dwarf_Unsigned modtime = 0;
        Dwarf_Unsigned flength = 0;
        Dwarf_Form_Data16 *md5data = 0;

        vres = dwarf_srclines_files_data_b(line_context,i,
            &name,&dirindex, &modtime,&flength,
            &md5data,err);
        if (vres != DW_DLV_OK) {
            struct esb_s m;

            esb_constructor(&m);
            esb_append_printf_i(&m,
                "\nERROR: Error accessing line_context "
                " calling  dwarf_srclines_files_data_b() "
                "with index %d ",i);
            esb_append_printf_i(&m,
                "(end index is %d).",endindex);
            simple_err_return_action(vres,
                esb_get_string(&m));
            esb_destructor(&m);
            return vres;
        }
        esb_empty_string(&bufr);
        if (name) {
            esb_empty_string(&bufr);
            esb_append(&bufr,"\"");
            esb_append(&bufr,name);
            esb_append(&bufr,"\"");
        } else {
            esb_append(&bufr,"<ERROR:NULL name in files list>");
        }
        printf("  [%2" DW_PR_DSd "]  %-24s ,",
            i,esb_get_string(&bufr));
        printf(" directory index  %2" DW_PR_DUu ,dirindex);
        printf(",  file length %2" DW_PR_DUu ,flength);
        if (md5data) {
            char *c = (char *)md5data;
            char *end = c+sizeof(*md5data);
            printf(", file md5 value 0x");
            while(c < end) {
                printf("%02x",0xff&*c);
                ++c;
            }
            printf(" ");
        }
        if (modtime) {
            time_t tt3 = (time_t)modtime;

            /* ctime supplies newline */
            printf( "file mod time 0x%lx %s", (unsigned long)tt3,
                ctime(&tt3));
        } else {
            printf("  file mod time 0\n");
        }
    }
    esb_destructor(&bufr);

    vres = dwarf_srclines_subprog_count(line_context,&subprog_count,
        err);
    if (vres != DW_DLV_OK) {
        simple_err_return_msg_either_action(vres,
            "ERROR: dwarf_srclines_subprog_count() on a "
            "line_context fails");
        return vres;
    }
    if (subprog_count == 0) {
        return DW_DLV_OK;
    }
    /*  The following is for the experimental table
        which is only DWARF4 so far, so no need for
        a dwarf_srclines_subprog_indexes() function. Yet. */
    printf(" subprograms count (experimental) 0x%"
        DW_PR_DUx " %" DW_PR_DUu "\n",
        subprog_count,subprog_count);
    for (i = 1; i <= subprog_count; ++i) {
        Dwarf_Unsigned decl_file = 0;
        Dwarf_Unsigned decl_line = 0;
        vres = dwarf_srclines_subprog_data(line_context,i,
            &name,&decl_file, &decl_line,err);
        if (vres != DW_DLV_OK) {
            struct esb_s m;

            esb_constructor(&m);
            esb_append_printf_i(&m,
                "\nERROR: Error accessing line_context "
                " calling  dwarf_srclines_subprog_data() "
                "with index %d ",i);
            esb_append_printf_i(&m,
                "(end index is %d).",subprog_count);
            simple_err_return_action(vres,
                esb_get_string(&m));
            esb_destructor(&m);
            return vres;
        }
        printf("  [%2" DW_PR_DSd "]  \"%s\""
            ", fileindex %2" DW_PR_DUu
            ", lineindex  %2" DW_PR_DUu
            "\n",
            i,name,decl_file,decl_line);
    }
    return DW_DLV_OK;
}

// the below code fragment can be found in:
// src/bin/dwarfexample/findfuncbypc.c
static int
read_line_data(Dwarf_Debug dbg,
    struct target_data_s *td,
    Dwarf_Error *errp)
{
    int res = 0;
    Dwarf_Unsigned line_version = 0;
    Dwarf_Small table_type = 0;
    Dwarf_Line_Context line_context = 0;
    Dwarf_Signed i = 0;
    Dwarf_Signed baseindex  = 0;
    Dwarf_Signed endindex  = 0;
    Dwarf_Signed file_count  = 0;
    Dwarf_Unsigned dirindex  = 0;

    (void)dbg;
    res = dwarf_srclines_b(td->td_cu_die,&line_version,
        &table_type,&line_context,errp);
    if (res != DW_DLV_OK) {
        return res;
    }
    if (td->td_print_details) {
        printf(" Srclines: linetable version %" DW_PR_DUu
            " table count %d\n",line_version,table_type);
    }
    if (table_type == 0) {
        /* There are no lines here, just table header and names. */
        int sres = 0;

        sres = dwarf_srclines_files_indexes(line_context,
            &baseindex,&file_count,&endindex,errp);
        if (sres != DW_DLV_OK) {
            dwarf_srclines_dealloc_b(line_context);
            line_context = 0;
            return sres;
        }
        if (td->td_print_details) {
            printf("  Filenames base index %" DW_PR_DSd
                " file count %" DW_PR_DSd
                " endindex %" DW_PR_DSd "\n",
                baseindex,file_count,endindex);
        }
        for (i = baseindex; i < endindex; i++) {
            Dwarf_Unsigned modtime = 0;
            Dwarf_Unsigned flength = 0;
            Dwarf_Form_Data16 *md5data = 0;
            int vres = 0;
            const char *name = 0;

            vres = dwarf_srclines_files_data_b(line_context,i,
                &name,&dirindex, &modtime,&flength,
                &md5data,errp);
            if (vres != DW_DLV_OK) {
                dwarf_srclines_dealloc_b(line_context);
                line_context = 0;
                /* something very wrong. */
                return vres;
            }
            if (td->td_print_details) {
                printf("  [%" DW_PR_DSd "] "
                    " directory index %" DW_PR_DUu
                    " %s \n",i,dirindex,name);
            }
        }
        dwarf_srclines_dealloc_b(line_context);
        return DW_DLV_OK;
    } else if (table_type == 1) {
        const char * dir_name = 0;
        int sres = 0;
        Dwarf_Line *linebuf = 0;
        Dwarf_Signed linecount = 0;
        Dwarf_Signed dir_count = 0;
        Dwarf_Addr prev_lineaddr = 0;
        Dwarf_Unsigned prev_lineno = 0;
        char * prev_linesrcfile = 0;

        sres = dwarf_srclines_files_indexes(line_context,
            &baseindex,&file_count,&endindex,errp);
        if (sres != DW_DLV_OK) {
            dwarf_srclines_dealloc_b(line_context);
            line_context = 0;
            return sres;
        }
        if (td->td_print_details) {
            printf("  Filenames base index %" DW_PR_DSd
                " file count %" DW_PR_DSd
                " endindex %" DW_PR_DSd "\n",
                baseindex,file_count,endindex);
        }
        for (i = baseindex; i < endindex; i++) {
            Dwarf_Unsigned dirindexb = 0;
            Dwarf_Unsigned modtime = 0;
            Dwarf_Unsigned flength = 0;
            Dwarf_Form_Data16 *md5data = 0;
            int vres = 0;
            const char *name = 0;

            vres = dwarf_srclines_files_data_b(line_context,i,
                &name,&dirindexb, &modtime,&flength,
                &md5data,errp);
            if (vres != DW_DLV_OK) {
                dwarf_srclines_dealloc_b(line_context);
                line_context = 0;
                /* something very wrong. */
                return vres;
            }
            if (td->td_print_details) {
                printf("  [%" DW_PR_DSd "] "
                    " directory index %" DW_PR_DUu
                    " file: %s \n",i,dirindexb,name);
            }
        }
        sres = dwarf_srclines_include_dir_count(line_context,
            &dir_count,errp);
        if (sres != DW_DLV_OK) {
            dwarf_srclines_dealloc_b(line_context);
            line_context = 0;
            return sres;
        }
        if (td->td_print_details) {
            printf("  Directories count: %" DW_PR_DSd "\n",
                dir_count);
        }

        for (i =1; i <= dir_count; ++i) {
            dir_name = 0;
            sres = dwarf_srclines_include_dir_data(line_context,
                i,&dir_name,errp);
            if (sres == DW_DLV_ERROR) {
                dwarf_srclines_dealloc_b(line_context);
                line_context = 0;
                return sres;
            }
            if (sres == DW_DLV_NO_ENTRY) {
                printf("Something wrong in dir tables line %d %s\n",
                    __LINE__,__FILE__);
                break;
            }
            if (td->td_print_details) {
                printf("  [%" DW_PR_DSd "] directory: "
                    " %s \n",i,dir_name);
            }
        }

        /*  For this case where we have a line table we will likely
            wish to get the line details: */
        sres = dwarf_srclines_from_linecontext(line_context,
            &linebuf,&linecount,
            errp);
        if (sres != DW_DLV_OK) {
            dwarf_srclines_dealloc_b(line_context);
            line_context = 0;
            return sres;
        }
        /* The lines are normal line table lines. */
        for (i = 0; i < linecount; ++i) {
            Dwarf_Addr lineaddr = 0;
            Dwarf_Unsigned filenum = 0;
            Dwarf_Unsigned lineno = 0;
            char * linesrcfile = 0;

            sres = dwarf_lineno(linebuf[i],&lineno,errp);
            if (sres == DW_DLV_ERROR) {
                if (prev_linesrcfile) {
                    dwarf_dealloc(dbg,prev_linesrcfile,DW_DLA_STRING);
                }
                return sres;
            }
            sres = dwarf_line_srcfileno(linebuf[i],&filenum,errp);
            if (sres == DW_DLV_ERROR) {
                if (prev_linesrcfile) {
                    dwarf_dealloc(dbg,prev_linesrcfile,DW_DLA_STRING);
                }
                return sres;
            }
            if (filenum) {
                filenum -= 1;
            }
            sres = dwarf_lineaddr(linebuf[i],&lineaddr,errp);
            if (sres == DW_DLV_ERROR) {
                if (prev_linesrcfile) {
                    dwarf_dealloc(dbg,prev_linesrcfile,DW_DLA_STRING);
                }
                return sres;
            }
            sres = dwarf_linesrc(linebuf[i],&linesrcfile,errp);
            if (sres == DW_DLV_ERROR) {
                if (prev_linesrcfile) {
                    dwarf_dealloc(dbg,prev_linesrcfile,DW_DLA_STRING);
                }
                return sres;
            }
            if (td->td_print_details) {
                printf("  [%" DW_PR_DSd "] "
                    " address 0x%" DW_PR_DUx
                    " filenum %" DW_PR_DUu
                    " lineno %" DW_PR_DUu
                    " %s \n",i,lineaddr,filenum,lineno,linesrcfile);
            }
            if (lineaddr > td->td_target_pc) {
                /* Here we detect the right source and line */
                td->td_subprog_lineaddr = prev_lineaddr;
                td->td_subprog_lineno = prev_lineno;
                td->td_subprog_srcfile = prev_linesrcfile;
                dwarf_dealloc(dbg,linesrcfile,DW_DLA_STRING);
                return DW_DLV_OK;
            }
            prev_lineaddr = lineaddr;
            prev_lineno = lineno;
            if (prev_linesrcfile) {
                dwarf_dealloc(dbg,prev_linesrcfile,DW_DLA_STRING);
            }
            prev_linesrcfile = linesrcfile;
        }
        /*  Here we detect the right source and line (last such
            in this subprogram) */
        td->td_subprog_lineaddr = prev_lineaddr;
        td->td_subprog_lineno = prev_lineno;
        td->td_subprog_srcfile = prev_linesrcfile;
        dwarf_srclines_dealloc_b(line_context);
        return DW_DLV_OK;
    }
    return DW_DLV_ERROR;
#if 0
    /* ASSERT: table_type == 2,
    Experimental two-level line table. Version 0xf006
    We do not define the meaning of this non-standard
    set of tables here. */
    /*  For something C (two-level line tables)
        one codes something like this
        Note that we do not define the meaning
        or use of two-level li
        tables as these are experimental,
        not standard DWARF. */
    sres = dwarf_srclines_two_level_from_linecontext(line_context,
        &linebuf,&linecount,
        &linebuf_actuals,&linecount_actuals,
        &err);
    if (sres == DW_DLV_OK) {
        for (i = 0; i < linecount; ++i) {
            /*  use linebuf[i], these are
                the logicals entries. */
        }
        for (i = 0; i < linecount_actuals; ++i) {
            /*  use linebuf_actuals[i],
                these are the actuals entries */
        }
        dwarf_srclines_dealloc_b(line_context);
        line_context = 0;
        linebuf = 0;
        linecount = 0;
        linebuf_actuals = 0;
        linecount_actuals = 0;
    } else if (sres == DW_DLV_NO_ENTRY) {
        dwarf_srclines_dealloc_b(line_context);
        line_context = 0;
        linebuf = 0;
        linecount = 0;
        linebuf_actuals = 0;
        linecount_actuals = 0;
        return sres;
    } else { /*DW_DLV_ERROR */
        return sres;
    }
#endif /* 0 */
}

// the below code fragment can be found in:
// src/lib/libdwarfp/dwarf_pro_section.c
static int
_dwarf_pro_generate_debugline(Dwarf_P_Debug dbg,
    Dwarf_Unsigned * nbufs,
    Dwarf_Error * error)
{
    Dwarf_P_F_Entry curdir = 0;
    Dwarf_P_F_Entry curentry = 0;
    Dwarf_P_Line curline = 0;
    Dwarf_P_Line prevline = 0;
    struct Dwarf_P_Line_Inits_s *inits = 0;

    /* all data named cur* are used to loop thru linked lists */

    int sum_bytes = 0;
    unsigned prolog_size = 0;
    unsigned char *data = 0;    /* holds disk form data */
    int elfsectno = 0;
    unsigned char *start_line_sec = 0;  /* pointer to the buffer at
        section start */
    /* temps for memcpy */
    Dwarf_Unsigned du = 0;
    Dwarf_Ubyte db = 0;
    Dwarf_Half dh = 0;
    int res = 0;
    Dwarf_Half version = dbg->de_output_version;
    int offset_size = dbg->de_dwarf_offset_size;
    Dwarf_Ubyte extension_size = dbg->de_64bit_extension ? 4 : 0;
    Dwarf_Ubyte address_size = dbg->de_pointer_size;

    sum_bytes = 0;

    elfsectno = dbg->de_elf_sects[DEBUG_LINE];

    inits = &dbg->de_line_inits;
    if (version < 5) {
        res  = calculate_size_of_line_header4(dbg,inits,&prolog_size,
            error);
    } else if (version == 5) {
        res  = calculate_size_of_line_header5(dbg,inits,&prolog_size,
            error);
    } else {
        _dwarf_p_error(dbg, error,DW_DLE_VERSION_STAMP_ERROR );
        return DW_DLV_ERROR;
    }
    if (res != DW_DLV_OK) {
        return res;
    }
    /* Allocate a chunk, put address in 'data' */
    GET_CHUNK_ERR(dbg, elfsectno, data, prolog_size, error);

    start_line_sec = data;

    /* Copy the prologue data into 'data' */
    /* total_length */
    du = 0;
    if (extension_size) {
        DISTINGUISHED_VALUE_ARRAY(v4);

        WRITE_UNALIGNED(dbg, (void *) data, (const void *) &v4[0],
        SIZEOFT32, extension_size);
        data += extension_size;
    }

    /*  We will adjust this later, we do not know the full length
        of the line_section content for this cu  yet. */
    WRITE_UNALIGNED(dbg, (void *) data, (const void *) &du,
        sizeof(du), offset_size);
    data += offset_size;

    dh =  inits->pi_linetable_version;
    WRITE_UNALIGNED(dbg, (void *) data, (const void *) &dh,
        sizeof(dh), DWARF_HALF_SIZE);
    data +=  DWARF_HALF_SIZE;
    if (version == 5 ) {
        /* address size, seg sel size now */
        db = inits->pi_address_size;
        WRITE_UNALIGNED(dbg, (void *) data, (const void *) &db,
            sizeof(db), sizeof(db));
        data += sizeof(db);
        db = inits->pi_segment_size; /* segment selector size */
        WRITE_UNALIGNED(dbg, (void *) data, (const void *) &db,
            sizeof(db), sizeof(db));
        data += sizeof(db);
    }

    {
        /*  header length (called prolog length in DWARF2)
            This we do know, we calculated the prolog length
            already and it is prolog_size so just
            */
        Dwarf_Unsigned sofar = data  - start_line_sec;

        du = prolog_size - sofar - offset_size;
        WRITE_UNALIGNED(dbg, (void *) data, (const void *) &du,
            sizeof(du), offset_size);
        data += offset_size;
    }
    db =  inits->pi_minimum_instruction_length;
    WRITE_UNALIGNED(dbg, (void *) data, (const void *) &db,
        sizeof(db), sizeof(Dwarf_Ubyte));
    data += sizeof(Dwarf_Ubyte);

    if (inits->pi_linetable_version == 4 ||
        inits->pi_linetable_version == 5) {
        db =  inits->pi_maximum_operations_per_instruction;
        WRITE_UNALIGNED(dbg, (void *) data, (const void *) &db,
            sizeof(db), sizeof(Dwarf_Ubyte));
        data += sizeof(Dwarf_Ubyte);
    }

    db =  inits->pi_default_is_stmt;
    WRITE_UNALIGNED(dbg, (void *) data, (const void *) &db,
        sizeof(db), sizeof(Dwarf_Ubyte));
    data += sizeof(Dwarf_Ubyte);
    db =  inits->pi_line_base;
    WRITE_UNALIGNED(dbg, (void *) data, (const void *) &db,
        sizeof(db), sizeof(Dwarf_Ubyte));
    data += sizeof(Dwarf_Ubyte);
    db =  inits->pi_line_range;
    WRITE_UNALIGNED(dbg, (void *) data, (const void *) &db,
        sizeof(db), sizeof(Dwarf_Ubyte));
    data += sizeof(Dwarf_Ubyte);
    db =  inits->pi_opcode_base;
    WRITE_UNALIGNED(dbg, (void *) data, (const void *) &db,
        sizeof(db), sizeof(Dwarf_Ubyte));
    data += sizeof(Dwarf_Ubyte);
    /* stream of single bytes. No endian issues. */
    memcpy((void *) data, (const void *) std_opcode_len,
        inits->pi_opcode_base-1);
    data += inits->pi_opcode_base-1;

    if (version < 5) {
        /* copy over include directories */
        curdir = dbg->de_inc_dirs;
        while (curdir) {
            strcpy((char *) data, curdir->dfe_name);
            data += strlen(curdir->dfe_name) + 1;
            curdir = curdir->dfe_next;
        }
        *data = '\0';               /* last null */
        data++;

        /* copy file entries */
        curentry = dbg->de_file_entries;
        while (curentry) {
            strcpy((char *) data, curentry->dfe_name);
            data += strlen(curentry->dfe_name) + 1;
            /* copies of leb numbers, no endian issues */
            memcpy((void *) data,
                (const void *) curentry->dfe_args,
                curentry->dfe_nbytes);
            data += curentry->dfe_nbytes;
            curentry = curentry->dfe_next;
        }
        *data = '\0';
        data++;
    } else if (version == 5) {
        {
            unsigned fsize = 0;
            res = determine_form_size(dbg,
                inits->pi_directory_entry_format_count,
                inits->pi_incformats,
                &fsize,
                TRUE,data,
                error);
            if (res != DW_DLV_OK) {
                return res;
            }
            data += fsize;
        }
        {
            unsigned dir_count_len = 0;
            res = determine_file_content_size(dbg,
                dbg->de_inc_dirs,
                inits->pi_directory_entry_format_count,
                inits->pi_incformats,
                &dir_count_len,
                TRUE,data,
                error);
            if (res != DW_DLV_OK) {
                return res;
            }
            data += dir_count_len;
        }
        {
            unsigned fsize = 0;
            res = determine_form_size(dbg,
                inits->pi_file_entry_format_count,
                inits->pi_fileformats,
                &fsize,
                TRUE,data,
                error);
            if (res != DW_DLV_OK) {
                return res;
            }
            data += fsize;
        }
        {
            unsigned file_count_len = 0;
            res = determine_file_content_size(dbg,
                dbg->de_file_entries,
                dbg->de_line_inits.pi_file_entry_format_count,
                dbg->de_line_inits.pi_fileformats,
                &file_count_len,
                TRUE,data,
                error);
            if (res != DW_DLV_OK) {
                return res;
            }
            data += file_count_len;
        }
    }

    {
        Dwarf_Unsigned sofar = data - start_line_sec;
        if (sofar != prolog_size) {
            /* We miscalculated something. */
            _dwarf_p_error(dbg, error,
                DW_DLE_LINE_HEADER_LENGTH_BOTCH);
            return DW_DLV_ERROR;
        }
        sum_bytes += prolog_size;
    }

    curline = dbg->de_lines;
    prevline = (Dwarf_P_Line)
        _dwarf_p_get_alloc(dbg, sizeof(struct Dwarf_P_Line_s));
    if (prevline == NULL) {
        DWARF_P_DBG_ERROR(dbg, DW_DLE_LINE_ALLOC, DW_DLV_ERROR);
    }
    _dwarf_pro_reg_init(dbg,prevline);
    /* generate opcodes for line numbers */
    while (curline) {
        int opc = 0;
        int no_lns_copy = 0; /* if lns copy opcode does not need to be
            generated, if special opcode or end
            sequence */
        Dwarf_Unsigned addr_adv = 0;
        int line_adv = 0; /* supposed to be a reasonably small
            number, so the size should not be a
            problem. ? */

        no_lns_copy = 0;
        if (curline->dpl_opc != 0) {
            int inst_bytes = 0; /* no of bytes in extended opcode */
            unsigned writelen = 0;

            switch (curline->dpl_opc) {
            case DW_LNE_end_sequence:
                /* Advance pc to end of text section. */
                addr_adv = curline->dpl_address -
                    prevline->dpl_address;
                if (addr_adv > 0) {
                    res = write_opcode_uval(DW_LNS_advance_pc,dbg,
                        elfsectno,
                        addr_adv/inits->pi_minimum_instruction_length,
                        &writelen,
                        error);
                    if (res != DW_DLV_OK) {
                        return res;
                    }
                    sum_bytes += writelen;
                    prevline->dpl_address = curline->dpl_address;
                }

                /* first null byte */
                db = 0;
                res = write_ubyte(db,dbg,elfsectno,
                    &writelen,error);
                if (res != DW_DLV_OK) {
                    return res;
                }
                sum_bytes += writelen;

                /* write length of extended opcode */
                inst_bytes = sizeof(Dwarf_Ubyte);
                res = write_uval(inst_bytes,dbg,elfsectno,
                    &writelen,error);
                if (res != DW_DLV_OK) {
                    return res;
                }
                sum_bytes += writelen;

                /* write extended opcode */
                res = write_ubyte(DW_LNE_end_sequence,dbg,elfsectno,
                    &writelen,error);
                if (res != DW_DLV_OK) {
                    return res;
                }
                sum_bytes += writelen;

                /* reset value to original values */
                _dwarf_pro_reg_init(dbg,prevline);
                no_lns_copy = 1;
                /*  this is set only for end_sequence, so that a
                    dw_lns_copy is not generated */
                break;

            case DW_LNE_set_address:

                /* first null byte */
                db = 0;
                res = write_ubyte(db,dbg,elfsectno,
                    &writelen,error);
                if (res != DW_DLV_OK) {
                    return res;
                }
                sum_bytes += writelen;

                /* write length of extended opcode */
                inst_bytes = sizeof(Dwarf_Ubyte) + address_size;
                res = write_uval(inst_bytes,dbg,elfsectno,
                    &writelen,error);
                if (res != DW_DLV_OK) {
                    return res;
                }
                sum_bytes += writelen;

                /* write extended opcode */
                res = write_ubyte(DW_LNE_set_address,dbg,elfsectno,
                    &writelen,error);
                if (res != DW_DLV_OK) {
                    return res;
                }
                sum_bytes += writelen;

                /* reloc for address */
                res = dbg->de_relocate_by_name_symbol(dbg,
                    DEBUG_LINE,
                    sum_bytes,  /* r_offset  */
                    curline->dpl_r_symidx,
                    dwarf_drt_data_reloc,
                    offset_size);
                if (res != DW_DLV_OK) {
                    DWARF_P_DBG_ERROR(dbg, DW_DLE_CHUNK_ALLOC,
                        DW_DLV_ERROR);
                }

                /* write offset (address) */
                du = curline->dpl_address;
                res = write_fixed_size(du,dbg,elfsectno,
                    address_size,&writelen,error);
                if (res != DW_DLV_OK) {
                    return res;
                }
                sum_bytes += writelen;
                prevline->dpl_address = curline->dpl_address;
                no_lns_copy = 1;
                break;
            case DW_LNE_define_file:
                /*  Not supported, all add-file entries
                    are added via dbg  -> de_file_entries,
                    which adds to the line table header.  */
                no_lns_copy = 1;
                break;
            case DW_LNE_set_discriminator: {/* DWARF4 */
                unsigned val_len = 0;
                /* first null byte */
                db = 0;
                res = write_ubyte(db,dbg,elfsectno,&writelen,error);
                if (res != DW_DLV_OK) {
                    return res;
                }
                sum_bytes += writelen;

                /* Write len of opcode + value here. */
                res = pretend_write_uval(curline->dpl_discriminator,
                    dbg, &val_len,error);
                if (res != DW_DLV_OK) {
                    return res;
                }
                val_len++;

                res = write_uval(val_len +1,dbg,elfsectno,
                    &writelen,error);
                if (res != DW_DLV_OK) {
                    return res;
                }
                sum_bytes += writelen;

                /* Write opcode */
                res = write_ubyte(DW_LNE_set_discriminator,
                    dbg,elfsectno,
                    &writelen,error);
                if (res != DW_DLV_OK) {
                    return res;
                }
                sum_bytes += writelen;

                /* Write the value itself. */
                res = write_uval(curline->dpl_discriminator,
                    dbg,elfsectno,&writelen,error);
                if (res != DW_DLV_OK) {
                    return res;
                }
                sum_bytes += writelen;
                no_lns_copy = 1;
                }
                break;
            }
        } else {
            unsigned writelen = 0;
            if (inits->pi_opcode_base >12) {
                /*  We have the newer standard opcodes
                    DW_LNS_set_prologue_end, DW_LNS_set_epilogue_end,
                    DW_LNS_set_isa, we do not write them if not
                    in the table. DWARF3 and DWARF4 */
                /*  Should we check if a change?
                    These reset automatically
                    in the line processing/reading engine,
                    so I think no check of prevline is wanted. */
                if (curline->dpl_epilogue_begin) {
                    res = write_ubyte(DW_LNS_set_epilogue_begin,dbg,
                        elfsectno,&writelen, error);
                    if (res != DW_DLV_OK) {
                        return res;
                    }
                    sum_bytes += writelen;
                }
                if (curline->dpl_prologue_end) {
                    res = write_ubyte(DW_LNS_set_prologue_end,dbg,
                        elfsectno, &writelen,error);
                    if (res != DW_DLV_OK) {
                        return res;
                    }
                    sum_bytes += writelen;
                }
                if (curline->dpl_isa != prevline->dpl_isa) {
                    res = write_opcode_uval(DW_LNS_set_isa,dbg,
                        elfsectno, curline->dpl_isa,
                        &writelen ,error);
                    if (res != DW_DLV_OK) {
                        return res;
                    }
                    sum_bytes += writelen;
                }
            }
            if (curline->dpl_file != prevline->dpl_file) {
                db = DW_LNS_set_file;
                res = write_opcode_uval(db,dbg,
                    elfsectno,
                        curline->dpl_file,&writelen ,error);
                if (res != DW_DLV_OK) {
                    return res;
                }
                sum_bytes += writelen;

                prevline->dpl_file = curline->dpl_file;
            }
            if (curline->dpl_column != prevline->dpl_column) {
                db = DW_LNS_set_column;
                res = write_opcode_uval(db,dbg,
                    elfsectno, curline->dpl_column , &writelen,error);
                if (res != DW_DLV_OK) {
                    return res;
                }
                sum_bytes += writelen;
                prevline->dpl_column = curline->dpl_column;
            }
            if (curline->dpl_is_stmt != prevline->dpl_is_stmt) {
                res = write_ubyte(DW_LNS_negate_stmt,dbg,elfsectno,
                    &writelen,error);
                if (res != DW_DLV_OK) {
                    return res;
                }
                sum_bytes += writelen;
                prevline->dpl_is_stmt = curline->dpl_is_stmt;
            }
            if (curline->dpl_basic_block == TRUE &&
                prevline->dpl_basic_block == FALSE) {
                res = write_ubyte(DW_LNS_set_basic_block,dbg,
                    elfsectno,&writelen,error);
                if (res != DW_DLV_OK) {
                    return res;
                }
                sum_bytes += writelen;
                prevline->dpl_basic_block = curline->dpl_basic_block;
            }
            if (curline->dpl_discriminator) {
                /*  This is dwarf4, but because it is an extended op
                    not a standard op,
                    we allow it without testing version.
                    GNU seems to set this from time to time. */
                unsigned val_len = 0;
                /* first null byte */
                db = 0;
                res = write_ubyte(db,dbg,elfsectno,&writelen,error);
                if (res != DW_DLV_OK) {
                    return res;
                }
                sum_bytes += writelen;

                /* Write len of opcode + value here. */
                res = pretend_write_uval(curline->dpl_discriminator,
                    dbg, &val_len,error);
                if (res != DW_DLV_OK) {
                    return res;
                }
                val_len ++;
                res = write_uval(val_len +1,dbg,elfsectno,
                    &writelen,error);
                if (res != DW_DLV_OK) {
                    return res;
                }
                sum_bytes += writelen;

                /* Write opcode */
                res = write_ubyte(DW_LNE_set_discriminator,
                    dbg,elfsectno,&writelen,error);
                if (res != DW_DLV_OK) {
                    return res;
                }
                sum_bytes += writelen;

                /* Write the value itself. */
                res = write_uval(curline->dpl_discriminator,
                    dbg,elfsectno,&writelen,error);
                if (res != DW_DLV_OK) {
                    return res;
                }
                sum_bytes += writelen;
            }

            addr_adv = curline->dpl_address - prevline->dpl_address;

            line_adv = (int) (curline->dpl_line - prevline->dpl_line);
            if ((addr_adv % MIN_INST_LENGTH) != 0) {
                DWARF_P_DBG_ERROR(dbg, DW_DLE_WRONG_ADDRESS,
                    DW_DLV_ERROR);
            }
            opc = _dwarf_pro_get_opc(inits,addr_adv, line_adv);
            if (opc > 0) {
                /* Use special opcode. */
                no_lns_copy = 1;
                res = write_ubyte(opc,dbg,elfsectno,&writelen,error);
                if (res != DW_DLV_OK) {
                    return res;
                }
                sum_bytes += writelen;
                prevline->dpl_basic_block = FALSE;
                prevline->dpl_address = curline->dpl_address;
                prevline->dpl_line = curline->dpl_line;
            } else {
                /*  opc says use standard opcodes. */
                if (addr_adv > 0) {
                    db = DW_LNS_advance_pc;
                    res = write_opcode_uval(db,dbg,
                        elfsectno,
                        addr_adv/inits->pi_minimum_instruction_length,
                        &writelen,
                        error);
                    if (res != DW_DLV_OK) {
                        return res;
                    }
                    sum_bytes += writelen;
                    prevline->dpl_basic_block = FALSE;
                    prevline->dpl_address = curline->dpl_address;
                }
                if (line_adv != 0) {
                    db = DW_LNS_advance_line;
                    res = write_ubyte(db,dbg,
                        elfsectno,
                        &writelen,
                        error);
                    if (res != DW_DLV_OK) {
                        return res;
                    }
                    sum_bytes += writelen;
                    res = write_sval(line_adv,dbg,
                        elfsectno,
                        &writelen,
                        error);
                    if (res != DW_DLV_OK) {
                        return res;
                    }
                    sum_bytes += writelen;
                    prevline->dpl_basic_block = FALSE;
                    prevline->dpl_line = curline->dpl_line;
                }
            }
        }   /* ends else for opc <= 0 */
        if (no_lns_copy == 0) { /* if not a special or dw_lne_end_seq
            generate a matrix line */
            unsigned writelen = 0;
            res = write_ubyte(DW_LNS_copy,dbg,elfsectno,
                &writelen,error);
            if (res != DW_DLV_OK) {
                return res;
            }
            sum_bytes += writelen;
            prevline->dpl_basic_block = FALSE;
        }
        curline = curline->dpl_next;
    }

    /* write total length field */
    du = sum_bytes - OFFSET_PLUS_EXTENSION_SIZE;
    {
        start_line_sec += extension_size;
        WRITE_UNALIGNED(dbg, (void *) start_line_sec,
            (const void *) &du, sizeof(du), offset_size);
    }

    *nbufs = dbg->de_n_debug_sect;
    return DW_DLV_OK;
}

