// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/lib/libdwarf/dwarf_print_lines.c
static void
do_line_print_now(Dwarf_Debug dbg,
    int line_version,
    Dwarf_Small *comp_dir,
    Dwarf_Line_Context line_context)
{
    dwarfstring m7;
    Dwarf_Unsigned i = 0;

    dwarfstring_constructor(&m7);
    dwarfstring_append_printf_i(&m7,
        "total line info length %ld bytes,",
        line_context->lc_total_length);

    dwarfstring_append_printf_u(&m7,
        " line offset 0x%" DW_PR_XZEROS DW_PR_DUx,
        line_context->lc_section_offset);

    dwarfstring_append_printf_u(&m7,
        " %" DW_PR_DUu "\n",
        line_context->lc_section_offset);

    if (line_version <= DW_LINE_VERSION5) {
        dwarfstring_append_printf_i(&m7,
            "  line table version     %d\n",
        (int) line_context->lc_version_number);
    } else {
        dwarfstring_append_printf_u(&m7,
            "  line table version 0x%x\n",
            (int) line_context->lc_version_number);
    }
    if (line_version == DW_LINE_VERSION5) {
        dwarfstring_append_printf_i(&m7,
            "  address size          %d\n",
            line_context->lc_address_size);
        dwarfstring_append_printf_i(&m7,
            "  segment selector size %d\n",
            line_context->lc_segment_selector_size);
    }
    _dwarf_printf(dbg,dwarfstring_string(&m7));
    dwarfstring_reset(&m7);
    dwarfstring_append_printf_i(&m7,
        "  line table length field length %d\n",
        line_context->lc_length_field_length);
    dwarfstring_append_printf_i(&m7,
        "  prologue length       %d\n",
        line_context->lc_prologue_length);
    dwarfstring_append_printf_s(&m7,
        "  compilation_directory %s\n",
        comp_dir ? ((char *) comp_dir) : "");

    dwarfstring_append_printf_i(&m7,
        "  min instruction length %d\n",
        line_context->lc_minimum_instruction_length);
    _dwarf_printf(dbg,dwarfstring_string(&m7));
    dwarfstring_reset(&m7);
    if (line_version == DW_LINE_VERSION5 ||
        line_version == DW_LINE_VERSION4 ||
        line_version == EXPERIMENTAL_LINE_TABLES_VERSION) {
        dwarfstring_append_printf_u(&m7,
            "  maximum ops per instruction %u\n",
            line_context->lc_maximum_ops_per_instruction);
        _dwarf_printf(dbg,dwarfstring_string(&m7));
        dwarfstring_reset(&m7);
    }
    if (line_version == EXPERIMENTAL_LINE_TABLES_VERSION) {
        dwarfstring_append_printf_u(&m7, "  actuals table offset "
            "0x%" DW_PR_XZEROS DW_PR_DUx "\n",
            line_context->lc_actuals_table_offset);
        dwarfstring_append_printf_u(&m7,"  logicals table offset "
            "0x%" DW_PR_XZEROS DW_PR_DUx "\n",
            line_context->lc_logicals_table_offset);
        _dwarf_printf(dbg,dwarfstring_string(&m7));
        dwarfstring_reset(&m7);
    }
    dwarfstring_append_printf_i(&m7,
        "  default is stmt        %d\n",
        (int)line_context->lc_default_is_stmt);
    dwarfstring_append_printf_i(&m7,
        "  line base              %d\n",
        (int)line_context->lc_line_base);
    dwarfstring_append_printf_i(&m7,
        "  line_range             %d\n",
        (int)line_context->lc_line_range);
    dwarfstring_append_printf_i(&m7,
        "  opcode base            %d\n",
        (int)line_context->lc_opcode_base);
    dwarfstring_append_printf_i(&m7,
        "  standard opcode count  %d\n",
        (int)line_context->lc_std_op_count);
    _dwarf_printf(dbg,dwarfstring_string(&m7));
    dwarfstring_reset(&m7);

    for (i = 1; i < line_context->lc_opcode_base; i++) {
        dwarfstring_append_printf_i(&m7,
            "  opcode[%2d] length", (int) i);
        dwarfstring_append_printf_i(&m7,
            "  %d\n",
            (int) line_context->lc_opcode_length_table[i - 1]);
        _dwarf_printf(dbg,dwarfstring_string(&m7));
        dwarfstring_reset(&m7);
    }
    dwarfstring_destructor(&m7);
}

// the below code fragment can be found in:
// src/lib/libdwarf/dwarf_line.c
int
dwarf_get_ranges_section_name(Dwarf_Debug dbg,
    const char **section_name_out,
    Dwarf_Error * error)
{
    struct Dwarf_Section_s *sec = 0;
    if (error != NULL) {
        *error = NULL;
    }
    sec = &dbg->de_debug_ranges;
    if (sec->dss_size == 0) {
        /* We don't have such a  section at all. */
        return DW_DLV_NO_ENTRY;
    }
    *section_name_out = sec->dss_name;
    return DW_DLV_OK;
}

// the below code fragment can be found in:
// src/lib/libdwarf/dwarf_print_lines.c
int
dwarf_print_lines(Dwarf_Die die,
    Dwarf_Error * error,
    int *error_count)
{
    int only_line_header = 0;
    int res = _dwarf_internal_printlines(die,
        error_count,
        only_line_header,error);
    return res;
}

// the below code fragment can be found in:
// src/bin/dwarfdump/print_lines.c
int
print_line_numbers_this_cu(Dwarf_Debug dbg, Dwarf_Die cu_die,
    char **srcfiles,
    Dwarf_Signed srcf_count,
    Dwarf_Error *err)
{
    Dwarf_Unsigned lineversion = 0;
    Dwarf_Signed linecount = 0;
    Dwarf_Line *linebuf = NULL;
    Dwarf_Signed linecount_actuals = 0;
    Dwarf_Line *linebuf_actuals = NULL;
    Dwarf_Small  table_count = 0;
    int lres = 0;
    int line_errs = 0;
    Dwarf_Line_Context line_context = 0;
    const char *sec_name = 0;
    Dwarf_Off cudie_local_offset = 0;
    Dwarf_Off dieprint_cu_goffset = 0;
    int atres = 0;

    glflags.current_section_id = DEBUG_LINE;

    /* line_flag is TRUE */

    lres = dwarf_get_line_section_name_from_die(cu_die,
        &sec_name,err);
    if (lres != DW_DLV_OK || !sec_name || !strlen(sec_name)) {
        sec_name = ".debug_line";
    }
    DROP_ERROR_INSTANCE(dbg,lres,*err);

    /* The offsets will be zero if it fails. Let it pass. */
    atres = dwarf_die_offsets(cu_die,&dieprint_cu_goffset,
        &cudie_local_offset,err);
    DROP_ERROR_INSTANCE(dbg,atres,*err);

    if (glflags.gf_do_print_dwarf) {
        struct esb_s truename;
        char buf[ESB_FIXED_ALLOC_SIZE];

        esb_constructor_fixed(&truename,buf,sizeof(buf));
        get_true_section_name(dbg,".debug_line",
            &truename,FALSE); /* Ignore the COMPRESSED flags */
        printf("\n%s: line number info for a single cu\n",
            sanitized(esb_get_string(&truename)));
        esb_destructor(&truename);
    } else {
        /* We are checking, not printing. */
        Dwarf_Half tag = 0;
        int tres = dwarf_tag(cu_die, &tag, err);
        if (tres != DW_DLV_OK) {
            /*  Something broken here. */
            struct esb_s m;
            esb_constructor(&m);
            esb_append(&m,
                "\nERROR: Unable to get CU DIE dwarf tag "
                "attempting to print line numbers for a CU ");
            if (tres == DW_DLV_ERROR) {
                esb_append(&m,dwarf_errmsg(*err));
            }
            simple_err_return_msg_either_action(tres,
                esb_get_string(&m));
            esb_destructor(&m);
            return tres;
        } else if (tag == DW_TAG_type_unit) {
            /*  Not checking since type units missing
                address or range in CU header. */
            return DW_DLV_NO_ENTRY;
        }
    }

    if (glflags.verbose > 1) {
        int errcount = 0;
        Dwarf_Bool attr_dup = FALSE;
        int lresv = 0;
        print_source_intro(dbg,cu_die);
        lresv = print_one_die(dbg, cu_die,
            dieprint_cu_goffset,
            /* print_information= */ 1,
            /* indent level */0,
            srcfiles,srcf_count,
            &attr_dup,
            /* ignore_die_stack= */TRUE,
            err);
        if (lresv == DW_DLV_ERROR) {
            return lresv;
        }
        DWARF_CHECK_COUNT(lines_result,1);
        lresv = dwarf_print_lines(cu_die, err,&errcount);
        if (errcount > 0) {
            DWARF_ERROR_COUNT(lines_result,errcount);
            DWARF_CHECK_COUNT(lines_result,(errcount-1));
        }
        if (lresv == DW_DLV_ERROR) {
            print_error_and_continue("Failed to print CU lines",
                lresv, *err);
        }
        return lresv;
    }

    if (glflags.gf_check_lines && checking_this_compiler()) {
        int lres2 = 0;

        DWARF_CHECK_COUNT(lines_result,1);
        lres2 = dwarf_check_lineheader_b(cu_die,&line_errs,
            err);
        if (lres2 == DW_DLV_ERROR) {
            print_error_and_continue(
                "dwarf_check_lineheader_b found a serious error",
                lres2, *err);
            dwarf_dealloc(dbg,*err,DW_DLA_ERROR);
            *err = 0;
        }
        if (line_errs > 0) {
            /* does glflags.check_error++; */
            /* sets glflags.gf_record_dwarf_error = TRUE; */
            DWARF_CHECK_ERROR_PRINT_CU();
            DWARF_ERROR_COUNT(lines_result,line_errs);
            DWARF_CHECK_COUNT(lines_result,(line_errs-1));
        }
    }
    /*  The following is complicated by a desire to test
        various line table interface functions.  Hence
        we test line_flag_selection.

        Normal code should pick an interface
        (for most  the best choice is what we here call
        glflags.gf_line_flag_selection ==  singledw5)
        and use just that interface set.

        Sorry about the length of the code that
        results from having so many interfaces.  */
    if (glflags.gf_line_flag_selection ==  singledw5) {
        lres = dwarf_srclines_b(cu_die,&lineversion,
            &table_count,&line_context,
            err);
        if (lres == DW_DLV_OK) {
            lres = dwarf_srclines_from_linecontext(line_context,
                &linebuf, &linecount,err);
        }
    } else {
        lres = dwarf_srclines_b(cu_die,&lineversion,
            &table_count,&line_context,
            err);
        if (lres == DW_DLV_OK) {
            lres = dwarf_srclines_two_level_from_linecontext(
                line_context,
                &linebuf, &linecount,
                &linebuf_actuals, &linecount_actuals,
                err);
        }
    }
    if (lres == DW_DLV_ERROR) {
        /* Do not terminate processing */
        if (glflags.gf_check_decl_file ||
            glflags.gf_check_lines) {
            DWARF_CHECK_COUNT(decl_file_result,1);
            DWARF_CHECK_ERROR2(decl_file_result,"dwarf_srclines",
                dwarf_errmsg(*err));
            /* Clear error condition */
            glflags.gf_record_dwarf_error = FALSE;
        } else {
            print_error_and_continue("dwarf_srclines",
                lres, *err);
        }
        DROP_ERROR_INSTANCE(dbg,lres,*err);
        return DW_DLV_OK;
    } else if (lres == DW_DLV_NO_ENTRY) {
        /* no line information is included */
    } else if (table_count > 0) {
        /* lres DW_DLV_OK */
        if (glflags.gf_do_print_dwarf) {
            if (line_context && glflags.verbose) {
                lres = print_line_context_record(line_context,err);
                if (lres != DW_DLV_OK){
                    /*  Should we issue message
                        about this call? */
                    dwarf_srclines_dealloc_b(line_context);
                    return lres;
                }
            }
            print_source_intro(dbg,cu_die);
            if (glflags.verbose) {
                int dres = 0;
                Dwarf_Bool attr_dup = FALSE;
                /* FIXME */
                dres = print_one_die(dbg, cu_die,
                    dieprint_cu_goffset,
                    /* print_information= */ TRUE,
                    /* indent_level= */ 0,
                    /* srcfiles= */ 0, /* cnt= */ 0,

                    &attr_dup,
                    /* ignore_die_stack= */TRUE,err);
                if (dres == DW_DLV_ERROR) {
                    dwarf_srclines_dealloc_b(line_context);
                    return dres;
                }
            }
        }
        if (glflags.gf_line_flag_selection ==  singledw5 ||
            glflags.gf_line_flag_selection == s2l) {
            /*  This now *all* cases possible when
                the table_count > 0. */
            int ltres = 0;

            if (table_count == 0 || table_count == 1) {
                /* ASSERT: is_single_table == true */
                Dwarf_Bool is_logicals = FALSE;
                Dwarf_Bool is_actuals = FALSE;

                ltres = process_line_table(dbg,sec_name,
                    linebuf, linecount,
                    is_logicals,is_actuals,err);
                if (ltres == DW_DLV_ERROR) {
                    /* what if NO_ENTRY? */
                    dwarf_srclines_dealloc_b(line_context);
                    return ltres;
                }
            } else {
                Dwarf_Bool is_logicals = TRUE;
                Dwarf_Bool is_actuals = FALSE;

                ltres = process_line_table(dbg,sec_name,
                    linebuf, linecount,
                    is_logicals, is_actuals,err);
                if (ltres != DW_DLV_OK) {
                    dwarf_srclines_dealloc_b(line_context);
                    return ltres;
                }
                ltres = process_line_table(dbg,sec_name,
                    linebuf_actuals,
                    linecount_actuals,
                    !is_logicals, !is_actuals,err);
                if (ltres != DW_DLV_OK) {
                    dwarf_srclines_dealloc_b(line_context);
                    return ltres;
                }
            }
            dwarf_srclines_dealloc_b(line_context);
            line_context = 0;
            linebuf = 0;
        }
        /* end, table_count > 0 */
    } else { /* table_count == 0 */
        /* lres DW_DLV_OK */
        /*  table_count == 0. no lines in table.
            Just a line table header. */
        if (glflags.gf_do_print_dwarf) {
            int ores = 0;
            Dwarf_Unsigned off = 0;

            print_source_intro(dbg,cu_die);
            if (glflags.verbose) {
                int dpres = 0;
                Dwarf_Bool attr_dup = FALSE;

                /* FIXME */
                dpres = print_one_die(dbg, cu_die,
                    dieprint_cu_goffset,
                    /* print_information= */ TRUE,
                    /* indent_level= */ 0,
                    /* srcfiles= */ 0, /* cnt= */ 0,
                    &attr_dup,
                    /* ignore_die_stack= */TRUE,
                    err);
                if (dpres == DW_DLV_ERROR) {
                    dwarf_srclines_dealloc_b(line_context);
                    return dpres;
                }
            }
            if (line_context) {
                if (glflags.verbose > 2) {
                    ores = print_line_context_record(
                        line_context,err);
                    if (ores != DW_DLV_OK) {
                        simple_err_return_msg_either_action(
                            ores,
                            "ERROR: line context record "
                            " where table count is 0 has a"
                            " problem");
                        dwarf_srclines_dealloc_b(line_context);
                        return ores;
                    }
                }
                ores = dwarf_srclines_table_offset(
                    line_context,
                    &off,err);
                if (ores != DW_DLV_OK) {
                    simple_err_return_msg_either_action(
                        ores,
                        "ERROR: line context table_offset "
                        " where table count is 0 has a"
                        " problem");
                    dwarf_srclines_dealloc_b(line_context);
                    return ores;
                } else {
                    printf(" Line table is present (offset 0x%"
                        DW_PR_XZEROS DW_PR_DUx
                        ") but no lines present\n", off);
                }
            } else {
                printf(" Line table is present but"
                    " no lines present\n");
            }
        }
        if (glflags.gf_line_flag_selection ==  singledw5 ||
            glflags.gf_line_flag_selection == s2l) {
            /*  Now this is all cases...
                also deletes the linebuf... */
            dwarf_srclines_dealloc_b(line_context);
            line_context = 0;
            linebuf = 0;
        }
        /* end, linecounttotal == 0 */
    }
    if (line_context) {
        /* also deletes the linebuf... */
        dwarf_srclines_dealloc_b(line_context);
        line_context = 0;
        linebuf = 0;
    }
    return DW_DLV_OK;
}

// the below code fragment can be found in:
// src/lib/libdwarf/dwarf_line_table_reader_common.h
static int
read_line_table_program(Dwarf_Debug dbg,
    Dwarf_Small *line_ptr,
    Dwarf_Small *line_ptr_end,
    Dwarf_Small *orig_line_ptr,
    Dwarf_Small *section_start,
    Dwarf_Line_Context line_context,
    Dwarf_Half address_size,
    Dwarf_Bool doaddrs, /* Only true if SGI IRIX rqs calling. */
    Dwarf_Bool dolines,
    Dwarf_Bool is_single_table,
    Dwarf_Bool is_actuals_table,
    Dwarf_Error *error,
    int *err_count_out)
{
    Dwarf_Unsigned i = 0;
    Dwarf_File_Entry cur_file_entry = 0;
    Dwarf_Line *logicals = line_context->lc_linebuf_logicals;
    Dwarf_Unsigned logicals_count =
        line_context->lc_linecount_logicals;

    struct Dwarf_Line_Registers_s regs;

    /*  This is a pointer to the current line being added to the line
        matrix. */
    Dwarf_Line curr_line = 0;

    /*  These variables are used to decode leb128 numbers. Leb128_num
        holds the decoded number, and leb128_length is its length in
        bytes. */
    Dwarf_Unsigned leb128_num = 0;
    Dwarf_Signed advance_line = 0;

    /*  This is the operand of the latest fixed_advance_pc extended
        opcode. */
    Dwarf_Half fixed_advance_pc = 0;

    /*  Counts the number of lines in the line matrix. */
    Dwarf_Unsigned line_count = 0;

    /*  This is the length of an extended opcode instr.  */
    Dwarf_Unsigned instr_length = 0;

    /*  Used to chain together pointers to line table entries that are
        later used to create a block of Dwarf_Line entries. */
    Dwarf_Chain chain_line = NULL;
    Dwarf_Chain head_chain = NULL;
    Dwarf_Chain curr_chain = NULL;

    /*  This points to a block of Dwarf_Lines, a pointer to which is
        returned in linebuf. */
    Dwarf_Line *block_line = 0;

    /*  Mark a line record as being DW_LNS_set_address */
    Dwarf_Bool is_addr_set = false;

    (void)orig_line_ptr;
    (void)err_count_out;
    /*  Initialize the one state machine variable that depends on the
        prefix.  */
    _dwarf_set_line_table_regs_default_values(&regs,
        line_context->lc_version_number,
        line_context->lc_default_is_stmt);

    /* Start of statement program.  */
    while (line_ptr < line_ptr_end) {
        int type = 0;
        Dwarf_Small opcode = 0;

#ifdef PRINTING_DETAILS
        {
        dwarfstring m9a;
        dwarfstring_constructor(&m9a);
        dwarfstring_append_printf_u(&m9a,
            " [0x%06" DW_PR_DSx "] ",
            /*  ptrdiff_t generated but not named */
            (line_ptr - section_start));
        _dwarf_printf(dbg,dwarfstring_string(&m9a));
        dwarfstring_destructor(&m9a);
        }
#endif /* PRINTING_DETAILS */
        opcode = *(Dwarf_Small *) line_ptr;
        line_ptr++;
        /* 'type' is the output */
        WHAT_IS_OPCODE(type, opcode, line_context->lc_opcode_base,
            line_context->lc_opcode_length_table, line_ptr,
            line_context->lc_std_op_count);

        if (type == LOP_DISCARD) {
            int oc = 0;
            int opcnt = line_context->lc_opcode_length_table[opcode];
#ifdef PRINTING_DETAILS
            {
            dwarfstring m9b;
            dwarfstring_constructor(&m9b);
            dwarfstring_append_printf_i(&m9b,
                "*** DWARF CHECK: DISCARD standard opcode %d ",
                opcode);
            dwarfstring_append_printf_i(&m9b,
                "with %d operands: not understood.", opcnt);
            _dwarf_printf(dbg,dwarfstring_string(&m9b));
            *err_count_out += 1;
            dwarfstring_destructor(&m9b);
            }
#endif /* PRINTING_DETAILS */
            for (oc = 0; oc < opcnt; oc++) {
                int ocres = 0;
                /*  Read and discard operands we don't
                    understand.
                    arbitrary choice of unsigned read.
                    signed read would work as well.    */
                Dwarf_Unsigned utmp2 = 0;

                (void) utmp2;
                ocres =  read_uword_de( &line_ptr,&utmp2,
                    dbg,error,line_ptr_end);
                if (ocres == DW_DLV_ERROR) {
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                        curr_line = 0;
                    }
                    return DW_DLV_ERROR;
                }

#ifdef PRINTING_DETAILS
                {
                dwarfstring m9e;
                dwarfstring_constructor(&m9e);
                dwarfstring_append_printf_u(&m9e,
                    " %" DW_PR_DUu,
                    utmp2);
                dwarfstring_append_printf_u(&m9e,
                    " (0x%" DW_PR_XZEROS DW_PR_DUx ")",
                    utmp2);
                _dwarf_printf(dbg,dwarfstring_string(&m9e));
                dwarfstring_destructor(&m9e);
                }
#endif /* PRINTING_DETAILS */
            }
#ifdef PRINTING_DETAILS
            _dwarf_printf(dbg,"***\n");
#endif /* PRINTING_DETAILS */
        } else if (type == LOP_SPECIAL) {
            /*  This op code is a special op in the object, no matter
                that it might fall into the standard op range in this
                compile. That is, these are special opcodes between
                opcode_base and MAX_LINE_OP_CODE.  (including
                opcode_base and MAX_LINE_OP_CODE) */
#ifdef PRINTING_DETAILS
            unsigned origop = opcode;
#endif /* PRINTING_DETAILS */
            Dwarf_Unsigned operation_advance = 0;

            opcode = opcode - line_context->lc_opcode_base;
            operation_advance =
                (opcode / line_context->lc_line_range);

            if (line_context->lc_maximum_ops_per_instruction < 2) {
                regs.lr_address = regs.lr_address +
                    (operation_advance *
                    line_context->lc_minimum_instruction_length);
            } else {
                regs.lr_address = regs.lr_address +
                    (line_context->lc_minimum_instruction_length *
                    ((regs.lr_op_index + operation_advance)/
                    line_context->lc_maximum_ops_per_instruction));
                regs.lr_op_index =
                    (regs.lr_op_index +operation_advance)%
                    line_context->lc_maximum_ops_per_instruction;
            }

            regs.lr_line = regs.lr_line + line_context->lc_line_base +
                opcode % line_context->lc_line_range;
            if ((Dwarf_Signed)regs.lr_line < 0) {
                /* Something is badly wrong */
                dwarfstring m;

                dwarfstring_constructor(&m);
                dwarfstring_append_printf_i(&m,
                    "\nERROR: DW_DLE_LINE_TABLE_LINENO_ERROR "
                    "The line number computes as %d "
                    "and negative line numbers "
                    "are not correct.",(Dwarf_Signed)regs.lr_line);
                _dwarf_error_string(dbg, error,
                    DW_DLE_LINE_TABLE_LINENO_ERROR,
                    dwarfstring_string(&m));
                dwarfstring_destructor(&m);
                regs.lr_line = 0;
                _dwarf_free_chain_entries(dbg,head_chain,
                    line_count);
                if (curr_line) {
                    dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    curr_line = 0;
                }
                return DW_DLV_ERROR;
            }
#ifdef PRINTING_DETAILS
            {
            dwarfstring ma;
            dwarfstring mb;

            dwarfstring_constructor(&ma);
            dwarfstring_constructor(&mb);
            dwarfstring_append_printf_u(&mb,"Specialop %3u", origop);
            _dwarf_printf(dbg,dwarfstring_string(&ma));
            dwarfstring_destructor(&ma);
            print_line_detail(dbg,dwarfstring_string(&mb),
                opcode,line_count+1, &regs,is_single_table,
                is_actuals_table);
            dwarfstring_destructor(&mb);
            dwarfstring_destructor(&ma);
            }
#endif /* PRINTING_DETAILS */

            if (dolines) {
                curr_line =
                    (Dwarf_Line) _dwarf_get_alloc(dbg,DW_DLA_LINE,1);
                if (curr_line == NULL) {
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);
                    return DW_DLV_ERROR;
                }

                /* Mark a line record as being DW_LNS_set_address */
                curr_line->li_l_data.li_is_addr_set =
                    is_addr_set;
                is_addr_set = false;
                curr_line->li_address = regs.lr_address;
                curr_line->li_l_data.li_file =
                    (Dwarf_Signed) regs.lr_file;
                curr_line->li_l_data.li_line =
                    (Dwarf_Signed) regs.lr_line;
                curr_line->li_l_data.li_column =
                    (Dwarf_Half) regs.lr_column;
                curr_line->li_l_data.li_is_stmt =
                    regs.lr_is_stmt;
                curr_line->li_l_data.li_basic_block =
                    regs.lr_basic_block;
                curr_line->li_l_data.li_end_sequence =
                    curr_line->li_l_data.
                    li_epilogue_begin = regs.lr_epilogue_begin;
                curr_line->li_l_data.li_prologue_end =
                    regs.lr_prologue_end;
                curr_line->li_l_data.li_isa =
                    regs.lr_isa;
                curr_line->li_l_data.li_discriminator =
                    regs.lr_discriminator;
                curr_line->li_l_data.li_call_context =
                    regs.lr_call_context;
                curr_line->li_l_data.li_subprogram =
                    regs.lr_subprogram;
                curr_line->li_context = line_context;
                curr_line->li_is_actuals_table = is_actuals_table;
                line_count++;

                chain_line = (Dwarf_Chain)
                    _dwarf_get_alloc(dbg, DW_DLA_CHAIN, 1);
                if (chain_line == NULL) {
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    }
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);
                    return DW_DLV_ERROR;
                }
                chain_line->ch_itemtype = DW_DLA_LINE;
                chain_line->ch_item = curr_line;
                _dwarf_update_chain_list(chain_line,&head_chain,
                    &curr_chain);
                curr_line = 0;
            }

            regs.lr_basic_block = false;
            regs.lr_prologue_end = false;
            regs.lr_epilogue_begin = false;
            regs.lr_discriminator = 0;
#ifdef PRINTING_DETAILS
#endif /* PRINTING_DETAILS */
        } else if (type == LOP_STANDARD) {
#ifdef PRINTING_DETAILS
            dwarfstring mb;
#endif /* PRINTING_DETAILS */

            switch (opcode) {
            case DW_LNS_copy:{

#ifdef PRINTING_DETAILS
                print_line_detail(dbg,"DW_LNS_copy",
                    opcode,line_count+1, &regs,is_single_table,
                    is_actuals_table);
#endif /* PRINTING_DETAILS */
                if (dolines) {
                    curr_line = (Dwarf_Line) _dwarf_get_alloc(dbg,
                        DW_DLA_LINE, 1);
                    if (curr_line == NULL) {
                        _dwarf_free_chain_entries(dbg,head_chain,
                            line_count);
                        _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);
                        return DW_DLV_ERROR;
                    }

                    /* Mark a line record as DW_LNS_set_address */
                    curr_line->li_l_data.li_is_addr_set =
                        is_addr_set;
                    is_addr_set = false;

                    curr_line->li_address = regs.lr_address;
                    curr_line->li_l_data.li_file =
                        (Dwarf_Signed) regs.lr_file;
                    curr_line->li_l_data.li_line =
                        (Dwarf_Signed) regs.lr_line;
                    curr_line->li_l_data.li_column =
                        (Dwarf_Half) regs.lr_column;
                    curr_line->li_l_data.li_is_stmt =
                        regs.lr_is_stmt;
                    curr_line->li_l_data.
                        li_basic_block = regs.lr_basic_block;
                    curr_line->li_l_data.
                        li_end_sequence = regs.lr_end_sequence;
                    curr_line->li_context = line_context;
                    curr_line->li_is_actuals_table = is_actuals_table;
                    curr_line->li_l_data.
                        li_epilogue_begin = regs.lr_epilogue_begin;
                    curr_line->li_l_data.
                        li_prologue_end = regs.lr_prologue_end;
                    curr_line->li_l_data.li_isa =
                        regs.lr_isa;
                    curr_line->li_l_data.li_discriminator
                        = regs.lr_discriminator;
                    curr_line->li_l_data.li_call_context
                        = regs.lr_call_context;
                    curr_line->li_l_data.li_subprogram =
                        regs.lr_subprogram;
                    line_count++;

                    chain_line = (Dwarf_Chain)
                        _dwarf_get_alloc(dbg, DW_DLA_CHAIN, 1);
                    if (chain_line == NULL) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                        _dwarf_free_chain_entries(dbg,head_chain,
                            line_count);
                        _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);
                        return DW_DLV_ERROR;
                    }
                    chain_line->ch_itemtype = DW_DLA_LINE;
                    chain_line->ch_item = curr_line;
                    _dwarf_update_chain_list(chain_line,&head_chain,
                        &curr_chain);
                    curr_line = 0;
                }

                regs.lr_basic_block = false;
                regs.lr_prologue_end = false;
                regs.lr_epilogue_begin = false;
                regs.lr_discriminator = 0;
                }
                break;
            case DW_LNS_advance_pc:{
                Dwarf_Unsigned utmp2 = 0;
                int advres = 0;

                advres =  read_uword_de( &line_ptr,&utmp2,
                    dbg,error,line_ptr_end);
                if (advres == DW_DLV_ERROR) {
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    }
                    return DW_DLV_ERROR;
                }

#ifdef PRINTING_DETAILS
                dwarfstring_constructor(&mb);
                dwarfstring_append_printf_i(&mb,
                    "DW_LNS_advance_pc val %" DW_PR_DSd,
                    utmp2);
                dwarfstring_append_printf_u(&mb,
                    " 0x%" DW_PR_XZEROS DW_PR_DUx "\n",
                    utmp2);
                _dwarf_printf(dbg,dwarfstring_string(&mb));
                dwarfstring_destructor(&mb);
#endif /* PRINTING_DETAILS */
                leb128_num = utmp2;
                regs.lr_address = regs.lr_address +
                    line_context->lc_minimum_instruction_length *
                    leb128_num;
                }
                break;
            case DW_LNS_advance_line:{
                Dwarf_Signed stmp = 0;
                int alres = 0;

                alres =  read_sword_de( &line_ptr,&stmp,
                    dbg,error,line_ptr_end);
                if (alres == DW_DLV_ERROR) {
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    }
                    return DW_DLV_ERROR;
                }
                advance_line = (Dwarf_Signed) stmp;

#ifdef PRINTING_DETAILS
                dwarfstring_constructor(&mb);
                dwarfstring_append_printf_i(&mb,
                    "DW_LNS_advance_line val %" DW_PR_DSd,
                    advance_line);
                dwarfstring_append_printf_u(&mb,
                    " 0x%" DW_PR_XZEROS DW_PR_DSx "\n",
                    advance_line);
                _dwarf_printf(dbg,dwarfstring_string(&mb));
                dwarfstring_destructor(&mb);
#endif /* PRINTING_DETAILS */
                regs.lr_line = regs.lr_line + advance_line;
                if ((Dwarf_Signed)regs.lr_line < 0) {
                    dwarfstring m;

                    dwarfstring_constructor(&m);
                    dwarfstring_append_printf_i(&m,
                        "\nERROR: DW_DLE_LINE_TABLE_LINENO_ERROR"
                        " The line number is %d "
                        "and negative line numbers after "
                        "DW_LNS_ADVANCE_LINE ",
                        (Dwarf_Signed)regs.lr_line);
                    dwarfstring_append_printf_i(&m,
                        " of %d "
                        "are not correct.",stmp);
                    _dwarf_error_string(dbg, error,
                        DW_DLE_LINE_TABLE_LINENO_ERROR,
                        dwarfstring_string(&m));
                    dwarfstring_destructor(&m);
                    regs.lr_line = 0;
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    }
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    return DW_DLV_ERROR;
                }
                }
                break;
            case DW_LNS_set_file:{
                Dwarf_Unsigned utmp2 = 0;
                int sfres = 0;

                sfres =  read_uword_de( &line_ptr,&utmp2,
                    dbg,error,line_ptr_end);
                if (sfres == DW_DLV_ERROR) {
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    }
                    return DW_DLV_ERROR;
                }
                {
                    Dwarf_Signed fno = (Dwarf_Signed)utmp2;
                    if (fno < 0) {
                        _dwarf_free_chain_entries(dbg,head_chain,
                            line_count);
                        if (curr_line) {
                            dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                        }
                        _dwarf_error_string(dbg,error,
                            DW_DLE_LINE_INDEX_WRONG,
                            "DW_DLE_LINE_INDEX_WRONG "
                            "A DW_LNS_set_file has an "
                            "Impossible "
                            "file number ");
                        return DW_DLV_ERROR;
                    }
                }

                regs.lr_file = utmp2;
#ifdef PRINTING_DETAILS
                dwarfstring_constructor(&mb);
                dwarfstring_append_printf_i(&mb,
                    "DW_LNS_set_file  %ld\n",
                    regs.lr_file);
                _dwarf_printf(dbg,dwarfstring_string(&mb));
                dwarfstring_destructor(&mb);
#endif /* PRINTING_DETAILS */
                }
                break;
            case DW_LNS_set_column:{
                Dwarf_Unsigned utmp2 = 0;
                int scres = 0;

                scres =  read_uword_de( &line_ptr,&utmp2,
                    dbg,error,line_ptr_end);
                if (scres == DW_DLV_ERROR) {
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    }
                    return DW_DLV_ERROR;
                }
                {
                    Dwarf_Signed cno = (Dwarf_Signed)utmp2;
                    if (cno < 0) {
                        _dwarf_free_chain_entries(dbg,head_chain,
                            line_count);
                        if (curr_line) {
                            dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                        }
                        _dwarf_error_string(dbg,error,
                            DW_DLE_LINE_INDEX_WRONG,
                            "DW_DLE_LINE_INDEX_WRONG "
                            "A DW_LNS_set_column has an "
                            "impossible "
                            "column number ");
                        return DW_DLV_ERROR;
                    }
                }

                regs.lr_column = utmp2;
#ifdef PRINTING_DETAILS
                dwarfstring_constructor(&mb);

                dwarfstring_append_printf_i(&mb,
                    "DW_LNS_set_column val %" DW_PR_DSd ,
                    regs.lr_column);
                dwarfstring_append_printf_u(&mb,
                    " 0x%" DW_PR_XZEROS DW_PR_DSx "\n",
                    regs.lr_column);
                _dwarf_printf(dbg,dwarfstring_string(&mb));
                dwarfstring_destructor(&mb);
#endif /* PRINTING_DETAILS */
                }
                break;
            case DW_LNS_negate_stmt:{
                regs.lr_is_stmt = !regs.lr_is_stmt;
#ifdef PRINTING_DETAILS
                _dwarf_printf(dbg, "DW_LNS_negate_stmt\n");
#endif /* PRINTING_DETAILS */
                }
                break;
            case DW_LNS_set_basic_block:{
                regs.lr_basic_block = true;
#ifdef PRINTING_DETAILS
                _dwarf_printf(dbg,
                    "DW_LNS_set_basic_block\n");
#endif /* PRINTING_DETAILS */
                }
                break;

            case DW_LNS_const_add_pc:{
                opcode = MAX_LINE_OP_CODE -
                    line_context->lc_opcode_base;
                if (line_context->lc_maximum_ops_per_instruction < 2){
                    Dwarf_Unsigned operation_advance =
                        (opcode / line_context->lc_line_range);
                    regs.lr_address = regs.lr_address +
                        line_context->lc_minimum_instruction_length *
                            operation_advance;
                } else {
                    Dwarf_Unsigned operation_advance =
                        (opcode / line_context->lc_line_range);
                    regs.lr_address = regs.lr_address +
                        line_context->lc_minimum_instruction_length *
                        ((regs.lr_op_index + operation_advance)/
                        line_context->lc_maximum_ops_per_instruction);
                    regs.lr_op_index =
                        (regs.lr_op_index +operation_advance)%
                        line_context->lc_maximum_ops_per_instruction;
                }
#ifdef PRINTING_DETAILS
                dwarfstring_constructor(&mb);
                dwarfstring_append_printf_u(&mb,
                    "DW_LNS_const_add_pc new address 0x%"
                    DW_PR_XZEROS DW_PR_DSx "\n",
                    regs.lr_address);
                _dwarf_printf(dbg,dwarfstring_string(&mb));
                dwarfstring_destructor(&mb);
#endif /* PRINTING_DETAILS */
                }
                break;
            case DW_LNS_fixed_advance_pc:{
                Dwarf_Unsigned fpc = 0;
                int apres = 0;
                /*READ_UNALIGNED_CK(dbg, fixed_advance_pc,
                    Dwarf_Half, line_ptr,
                    DWARF_HALF_SIZE,error,line_ptr_end); */
                apres = _dwarf_read_unaligned_ck_wrapper(dbg,
                    &fpc,line_ptr,DWARF_HALF_SIZE,line_ptr_end,
                    error);
                fixed_advance_pc = fpc;
                if (apres == DW_DLV_ERROR) {
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    }
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    return apres;
                }
                line_ptr += DWARF_HALF_SIZE;
                if (line_ptr > line_ptr_end) {
                    dwarfstring g;
                    /*  ptrdiff_t is generated but not named */
                    Dwarf_Unsigned localoff =
                        (line_ptr >= section_start)?
                        (line_ptr - section_start):0xfffffff;

                    dwarfstring_constructor(&g);
                    dwarfstring_append_printf_u(&g,
                        "DW_DLE_LINE_TABLE_BAD reading "
                        "DW_LNS_fixed_advance_pc we are "
                        "off this line table at section "
                        "offset. 0x%x .",
                        localoff);
                    _dwarf_error_string(dbg, error,
                        DW_DLE_LINE_TABLE_BAD,
                        dwarfstring_string(&g));
                    dwarfstring_destructor(&g);
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    }
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    return DW_DLV_ERROR;
                }
                regs.lr_address = regs.lr_address + fixed_advance_pc;
                regs.lr_op_index = 0;
#ifdef PRINTING_DETAILS
                dwarfstring_constructor(&mb);
                dwarfstring_append_printf_i(&mb,
                    "DW_LNS_fixed_advance_pc val %"
                    DW_PR_DSd, fixed_advance_pc);
                dwarfstring_append_printf_u(&mb,
                    " 0x%" DW_PR_XZEROS DW_PR_DSx,
                    fixed_advance_pc);
                dwarfstring_append_printf_u(&mb,
                    " new address 0x%"
                    DW_PR_XZEROS DW_PR_DSx "\n",
                    regs.lr_address);
                _dwarf_printf(dbg,
                    dwarfstring_string(&mb));
                dwarfstring_destructor(&mb);
#endif /* PRINTING_DETAILS */
                }
                break;

                /* New in DWARF3 */
            case DW_LNS_set_prologue_end:{
                regs.lr_prologue_end = true;
                }
                break;
                /* New in DWARF3 */
            case DW_LNS_set_epilogue_begin:{
                regs.lr_epilogue_begin = true;
#ifdef PRINTING_DETAILS
                _dwarf_printf(dbg,
                    "DW_LNS_set_prologue_end set true.\n");
#endif /* PRINTING_DETAILS */
                }
                break;

                /* New in DWARF3 */
            case DW_LNS_set_isa:{
                Dwarf_Unsigned utmp2 = 0;
                int sires = 0;

                sires =  read_uword_de( &line_ptr,&utmp2,
                    dbg,error,line_ptr_end);
                if (sires == DW_DLV_ERROR) {
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    }
                    return DW_DLV_ERROR;
                }

                regs.lr_isa = utmp2;

#ifdef PRINTING_DETAILS
                dwarfstring_constructor(&mb);
                dwarfstring_append_printf_u(&mb,
                    "DW_LNS_set_isa new value 0x%"
                    DW_PR_XZEROS DW_PR_DUx ".\n",
                    utmp2);
                _dwarf_printf(dbg,dwarfstring_string(&mb));
                dwarfstring_destructor(&mb);
#endif /* PRINTING_DETAILS */
                if (regs.lr_isa != utmp2) {
                    /*  The value of the isa did
                        not fit in our
                        local so we record it wrong.
                        declare an error. */
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    }
                    _dwarf_free_chain_entries(dbg,
                        head_chain,line_count);
                    _dwarf_error(dbg, error,
                        DW_DLE_LINE_NUM_OPERANDS_BAD);
                    return DW_DLV_ERROR;
                }
                }
                break;

                /*  Experimental two-level line tables */
                /*  DW_LNS_set_address_from_logical and
                    DW_LNS_set_subprogram
                    share the same opcode. Disambiguate by checking
                    is_actuals_table. */
            case DW_LNS_set_subprogram:

                if (is_actuals_table) {
                    /* DW_LNS_set_address_from_logical */
                    Dwarf_Signed stmp = 0;
                    int atres = 0;

                    atres =  read_sword_de( &line_ptr,&stmp,
                        dbg,error,line_ptr_end);
                    if (atres == DW_DLV_ERROR) {
                        _dwarf_free_chain_entries(dbg,head_chain,
                            line_count);
                        if (curr_line) {
                            dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                        }
                        return DW_DLV_ERROR;
                    }
                    advance_line = (Dwarf_Signed) stmp;
                    regs.lr_line = regs.lr_line + advance_line;
                    if ((Dwarf_Signed)regs.lr_line < 0) {
                        dwarfstring m;

                        dwarfstring_constructor(&m);
                        dwarfstring_append_printf_i(&m,
                            "\nERROR: DW_DLE_LINE_TABLE_LINENO_ERROR"
                            " The line number is %d "
                            "and negative line numbers after "
                            "DW_LNS_set_subprogram ",
                            (Dwarf_Signed)regs.lr_line);
                        dwarfstring_append_printf_i(&m,
                            " of %d applied "
                            "are not correct.",stmp);
                        _dwarf_error_string(dbg, error,
                            DW_DLE_LINE_TABLE_LINENO_ERROR,
                            dwarfstring_string(&m));
                        dwarfstring_destructor(&m);
                        regs.lr_line = 0;
                        _dwarf_free_chain_entries(dbg,
                            head_chain,line_count);
                        if (curr_line) {
                            dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                        }
                        return DW_DLV_ERROR;

                    }
                    if (regs.lr_line >= 1 &&
                        regs.lr_line - 1 < logicals_count) {
                        regs.lr_address =
                            logicals[regs.lr_line - 1]->li_address;
                        regs.lr_op_index = 0;
#ifdef PRINTING_DETAILS /* block 1 print */
                        dwarfstring_constructor(&mb);
                        dwarfstring_append_printf_i(&mb,
                            "DW_LNS_set_address_from"
                            "_logical "
                            "%" DW_PR_DSd,
                            stmp);
                        dwarfstring_append_printf_u(&mb,
                            " 0x%" DW_PR_XZEROS DW_PR_DSx,
                            stmp);
                        dwarfstring_append_printf_u(&mb,
                            "  newaddr="
                            " 0x%" DW_PR_XZEROS DW_PR_DUx ".\n",
                            regs.lr_address);
                        _dwarf_printf(dbg,
                            dwarfstring_string(&mb));
                        dwarfstring_destructor(&mb);
#endif /* PRINTING_DETAILS */
                    } else {
#ifdef PRINTING_DETAILS /* block 2 print */
                        dwarfstring_constructor(&mb);
                        dwarfstring_append_printf_i(&mb,
                            "DW_LNS_set_address_from_logical line"
                            " is %" DW_PR_DSd ,
                            regs.lr_line);
                        dwarfstring_append_printf_u(&mb,
                            " 0x%" DW_PR_XZEROS DW_PR_DSx ".\n",
                            regs.lr_line);
                        _dwarf_printf(dbg,
                            dwarfstring_string(&mb));
                        dwarfstring_destructor(&mb);
#endif /* PRINTING_DETAILS */
                    }
                } else {
                    /*  DW_LNS_set_subprogram,
                        building logicals table.  */
                    Dwarf_Unsigned utmp2 = 0;
                    int spres = 0;

                    regs.lr_call_context = 0;
                    spres =  read_uword_de( &line_ptr,&utmp2,
                        dbg,error,line_ptr_end);
                    if (spres == DW_DLV_ERROR) {
                        _dwarf_free_chain_entries(dbg,head_chain,
                            line_count);
                        if (curr_line) {
                            dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                        }
                        return DW_DLV_ERROR;
                    }
                    regs.lr_subprogram = utmp2;
#ifdef PRINTING_DETAILS /* block 3 print */
                    dwarfstring_constructor(&mb);
                    dwarfstring_append_printf_i(&mb,
                        "DW_LNS_set_subprogram "
                        "%" DW_PR_DSd,
                        utmp2);
                    dwarfstring_append_printf_u(&mb,
                        " 0x%" DW_PR_XZEROS DW_PR_DSx "\n",
                        utmp2);
                    _dwarf_printf(dbg,
                        dwarfstring_string(&mb));
                    dwarfstring_destructor(&mb);
#endif /* PRINTING_DETAILS */
                }
                break;
                /* Experimental two-level line tables */
            case DW_LNS_inlined_call: {
                Dwarf_Signed stmp = 0;
                Dwarf_Unsigned ilcuw = 0;
                int icres  = 0;

                icres =  read_sword_de( &line_ptr,&stmp,
                    dbg,error,line_ptr_end);
                if (icres == DW_DLV_ERROR) {
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    }
                    return DW_DLV_ERROR;
                }
                regs.lr_call_context = line_count + stmp;
                icres =  read_uword_de(&line_ptr,&ilcuw,
                    dbg,error,line_ptr_end);
                regs.lr_subprogram = ilcuw;
                if (icres == DW_DLV_ERROR) {
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    }
                    return DW_DLV_ERROR;
                }

#ifdef PRINTING_DETAILS
                dwarfstring_constructor(&mb);
                dwarfstring_append_printf_i(&mb,
                    "DW_LNS_inlined_call "
                    "%" DW_PR_DSd ,stmp);
                dwarfstring_append_printf_u(&mb,
                    " (0x%" DW_PR_XZEROS DW_PR_DSx "),",
                    stmp);
                dwarfstring_append_printf_i(&mb,
                    "%" DW_PR_DSd,
                    regs.lr_subprogram);
                dwarfstring_append_printf_u(&mb,
                    " (0x%" DW_PR_XZEROS DW_PR_DSx ")",
                    regs.lr_subprogram);
                dwarfstring_append_printf_i(&mb,
                    "  callcontext=" "%" DW_PR_DSd ,
                    regs.lr_call_context);
                dwarfstring_append_printf_u(&mb,
                    " (0x%" DW_PR_XZEROS DW_PR_DSx ")\n",
                    regs.lr_call_context);
                _dwarf_printf(dbg,
                    dwarfstring_string(&mb));
                dwarfstring_destructor(&mb);
#endif /* PRINTING_DETAILS */
                }
                break;

                /* Experimental two-level line tables */
            case DW_LNS_pop_context: {
                Dwarf_Unsigned logical_num = regs.lr_call_context;
                Dwarf_Chain logical_chain = head_chain;
                Dwarf_Line logical_line = 0;

                if (logical_num > 0 && logical_num <= line_count) {
                    for (i = 1; i < logical_num; i++) {
                        logical_chain = logical_chain->ch_next;
                    }
                    logical_line =
                        (Dwarf_Line) logical_chain->ch_item;
                    regs.lr_file =
                        logical_line->li_l_data.li_file;
                    regs.lr_line =
                        logical_line->li_l_data.li_line;
                    regs.lr_column =
                        logical_line->
                            li_l_data.li_column;
                    regs.lr_discriminator =
                        logical_line->
                            li_l_data.li_discriminator;
                    regs.lr_is_stmt =
                        logical_line->
                            li_l_data.li_is_stmt;
                    regs.lr_call_context =
                        logical_line->
                            li_l_data.li_call_context;
                    regs.lr_subprogram =
                        logical_line->
                            li_l_data.li_subprogram;
#ifdef PRINTING_DETAILS
                    {
                    dwarfstring pcon;
                    dwarfstring_constructor(&pcon);
                    dwarfstring_append_printf_u(&pcon,
                        "DW_LNS_pop_context set"
                        " from logical "
                        "%" DW_PR_DUu ,logical_num);
                    dwarfstring_append_printf_u(&pcon,
                        " (0x%" DW_PR_XZEROS DW_PR_DUx ")\n",
                        logical_num);
                    _dwarf_printf(dbg,
                        dwarfstring_string(&pcon));
                    dwarfstring_destructor(&pcon);
                    }
                } else {
                    dwarfstring pcon;
                    dwarfstring_constructor(&pcon);
                    dwarfstring_append_printf_u(&pcon,
                        "DW_LNS_pop_context does nothing, logical"
                        "%" DW_PR_DUu ,
                        logical_num);
                    dwarfstring_append_printf_u(&pcon,
                        " (0x%" DW_PR_XZEROS DW_PR_DUx ")\n",
                        logical_num);
                    _dwarf_printf(dbg,
                        dwarfstring_string(&pcon));
                    dwarfstring_destructor(&pcon);
#endif /* PRINTING_DETAILS */
                }
                }
                break;
            default:
                _dwarf_error_string(dbg, error,
                    DW_DLE_LINE_TABLE_BAD,
                    "DW_DLE_LINE_TABLE_BAD: "
                    "Impossible standard line table operator");
                return DW_DLV_ERROR;
            } /* End switch (opcode) */
        } else if (type == LOP_EXTENDED) {
            Dwarf_Unsigned utmp3 = 0;
            Dwarf_Small ext_opcode = 0;
            int leres = 0;

            leres =  read_uword_de( &line_ptr,&utmp3,
                dbg,error,line_ptr_end);
            if (leres == DW_DLV_ERROR) {
                _dwarf_free_chain_entries(dbg,head_chain,
                    line_count);
                if (curr_line) {
                    dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                }
                return DW_DLV_ERROR;
            }

            instr_length =  utmp3;
            /*  Dwarf_Small is a ubyte and the extended opcode is a
                ubyte, though not stated as clearly in the
                2.0.0 spec as one might hope. */
            if (line_ptr >= line_ptr_end) {
                dwarfstring g;
                /*  ptrdiff_t is generated but not named */
                Dwarf_Unsigned localoffset =
                    (line_ptr >= section_start)?
                    (line_ptr - section_start) : 0;

                dwarfstring_constructor(&g);
                dwarfstring_append_printf_u(&g,
                    "DW_DLE_LINE_TABLE_BAD reading "
                    "extended op we are "
                    "off this line table at section "
                    "offset 0x%x .",
                    localoffset);
                _dwarf_error_string(dbg, error,
                    DW_DLE_LINE_TABLE_BAD,
                    dwarfstring_string(&g));
                dwarfstring_destructor(&g);
                if (curr_line) {
                    dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                }
                _dwarf_free_chain_entries(dbg,head_chain,line_count);
                return DW_DLV_ERROR;
            }
            ext_opcode = *(Dwarf_Small *) line_ptr;
            line_ptr++;
            if (line_ptr > line_ptr_end) {
                dwarfstring g;
                /*  ptrdiff_t is generated but not named */
                Dwarf_Unsigned localoff =
                    (line_ptr >= section_start)?
                    (line_ptr - section_start):0xfffffff;

                dwarfstring_constructor(&g);
                dwarfstring_append_printf_u(&g,
                    "DW_DLE_LINE_TABLE_BAD reading "
                    "extended op opcode we are "
                    "off this line table at section "
                    "offset 0x%x .",
                    localoff);
                _dwarf_error_string(dbg, error,
                    DW_DLE_LINE_TABLE_BAD,
                    dwarfstring_string(&g));
                dwarfstring_destructor(&g);
                _dwarf_free_chain_entries(dbg,head_chain,line_count);
                if (curr_line) {
                    dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                }
                return DW_DLV_ERROR;
            }
            switch (ext_opcode) {

            case DW_LNE_end_sequence:{
                regs.lr_end_sequence = true;
                if (dolines) {
                    curr_line = (Dwarf_Line)
                        _dwarf_get_alloc(dbg, DW_DLA_LINE, 1);
                    if (!curr_line) {
                        _dwarf_free_chain_entries(dbg,head_chain,
                            line_count);
                        _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);
                        return DW_DLV_ERROR;
                    }

#ifdef PRINTING_DETAILS
                    print_line_detail(dbg,
                        "DW_LNE_end_sequence extended",
                        ext_opcode, line_count+1,&regs,
                        is_single_table, is_actuals_table);
#endif /* PRINTING_DETAILS */
                    curr_line->li_address = regs.lr_address;
                    curr_line->li_l_data.li_file =
                        (Dwarf_Signed) regs.lr_file;
                    curr_line->li_l_data.li_line =
                        (Dwarf_Signed) regs.lr_line;
                    curr_line->li_l_data.li_column =
                        (Dwarf_Half) regs.lr_column;
                    curr_line->li_l_data.li_is_stmt =
                        regs.lr_is_stmt;
                    curr_line->li_l_data.
                        li_basic_block = regs.lr_basic_block;
                    curr_line->li_l_data.
                        li_end_sequence = regs.lr_end_sequence;
                    curr_line->li_context = line_context;
                    curr_line->li_is_actuals_table = is_actuals_table;
                    curr_line->li_l_data.
                        li_epilogue_begin = regs.lr_epilogue_begin;
                    curr_line->li_l_data.
                        li_prologue_end = regs.lr_prologue_end;
                    curr_line->li_l_data.li_isa =
                        regs.lr_isa;
                    curr_line->li_l_data.li_discriminator
                        = regs.lr_discriminator;
                    curr_line->li_l_data.li_call_context
                        = regs.lr_call_context;
                    curr_line->li_l_data.li_subprogram =
                        regs.lr_subprogram;
                    line_count++;
                    chain_line = (Dwarf_Chain)
                        _dwarf_get_alloc(dbg, DW_DLA_CHAIN, 1);
                    if (chain_line == NULL) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                        _dwarf_free_chain_entries(dbg,head_chain,
                            line_count);
                        _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);
                        return DW_DLV_ERROR;
                    }
                    chain_line->ch_itemtype = DW_DLA_LINE;
                    chain_line->ch_item = curr_line;
                    _dwarf_update_chain_list(chain_line,
                        &head_chain,&curr_chain);
                    curr_line = 0;
                }
                _dwarf_set_line_table_regs_default_values(&regs,
                    line_context->lc_version_number,
                    line_context->lc_default_is_stmt);
                }
                break;

            case DW_LNE_set_address:{
                int sares = 0;
                /*  READ_UNALIGNED_CK(dbg, regs.lr_address,
                    Dwarf_Addr,
                    line_ptr, address_size,error,line_ptr_end); */
                sares = _dwarf_read_unaligned_ck_wrapper(dbg,
                    &regs.lr_address,line_ptr,
                    address_size,line_ptr_end,
                    error);
                if (sares == DW_DLV_ERROR) {
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    }
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    return sares;
                }

                /* Mark a line record as being DW_LNS_set_address */
                is_addr_set = true;
#ifdef PRINTING_DETAILS
                {
                dwarfstring sadd;
                dwarfstring_constructor(&sadd);
                dwarfstring_append_printf_u(&sadd,
                    "DW_LNE_set_address address 0x%"
                    DW_PR_XZEROS DW_PR_DUx "\n",
                    regs.lr_address);
                _dwarf_printf(dbg,dwarfstring_string(&sadd));
                dwarfstring_destructor(&sadd);
                }
#endif /* PRINTING_DETAILS */
                if (doaddrs) {
                    /* SGI IRIX rqs processing only. */
                    curr_line = (Dwarf_Line) _dwarf_get_alloc(dbg,
                        DW_DLA_LINE, 1);
                    if (!curr_line) {
                        _dwarf_free_chain_entries(dbg,head_chain,
                            line_count);
                        _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);
                        return DW_DLV_ERROR;
                    }
                    /*  Mark a line record as being
                        DW_LNS_set_address */
                    curr_line->li_l_data.li_is_addr_set
                        = is_addr_set;
                    is_addr_set = false;
                    curr_line->li_address = regs.lr_address;
#ifdef __sgi /* SGI IRIX ONLY */
                    /*  ptrdiff_t is generated but not named */
                    curr_line->li_offset =
                        line_ptr - dbg->de_debug_line.dss_data;
#endif /* __sgi */
                    line_count++;
                    chain_line = (Dwarf_Chain)
                        _dwarf_get_alloc(dbg, DW_DLA_CHAIN, 1);
                    if (chain_line == NULL) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                        _dwarf_free_chain_entries(dbg,head_chain,
                            line_count);
                        _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);
                        return DW_DLV_ERROR;
                    }
                    chain_line->ch_itemtype = DW_DLA_LINE;
                    chain_line->ch_item = curr_line;
                    _dwarf_update_chain_list(chain_line,
                        &head_chain,&curr_chain);
                    curr_line = 0;
                }
                regs.lr_op_index = 0;
                line_ptr += address_size;
                if (line_ptr > line_ptr_end) {
                    dwarfstring g;
                    /*  ptrdiff_t is generated but not named */
                    Dwarf_Unsigned localoff =
                        (line_ptr >= section_start)?
                        (line_ptr - section_start):0xfffffff;

                    dwarfstring_constructor(&g);
                    dwarfstring_append_printf_u(&g,
                        "DW_DLE_LINE_TABLE_BAD reading "
                        "DW_LNE_set_address we are "
                        "off this line table at section "
                        "offset 0x%x .",
                        localoff);
                    _dwarf_error_string(dbg, error,
                        DW_DLE_LINE_TABLE_BAD,
                        dwarfstring_string(&g));
                    dwarfstring_destructor(&g);
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    }
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    return DW_DLV_ERROR;
                }
                }
                break;

            case DW_LNE_define_file:
                if (dolines) {
                    int dlres = 0;
                    Dwarf_Unsigned value = 0;

                    cur_file_entry = (Dwarf_File_Entry)
                        malloc(sizeof(struct Dwarf_File_Entry_s));
                    if (cur_file_entry == NULL) {
                        _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);
                        if (curr_line) {
                            dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                        }
                        _dwarf_free_chain_entries(dbg,head_chain,
                            line_count);
                        return DW_DLV_ERROR;
                    }
                    memset(cur_file_entry,0,
                        sizeof(struct Dwarf_File_Entry_s));
                    _dwarf_add_to_files_list(line_context,
                        cur_file_entry);
                    cur_file_entry->fi_file_name =
                        (Dwarf_Small *) line_ptr;
                    dlres = _dwarf_check_string_valid(dbg,
                        line_ptr,line_ptr,line_ptr_end,
                        DW_DLE_DEFINE_FILE_STRING_BAD,error);
                    if (dlres != DW_DLV_OK) {
                        _dwarf_free_chain_entries(dbg,head_chain,
                            line_count);
                        if (curr_line) {
                            dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                        }
                        return dlres;
                    }
                    line_ptr = line_ptr + strlen((char *) line_ptr)
                        + 1;
                    dlres =  read_uword_de( &line_ptr,&value,
                        dbg,error,line_ptr_end);
                    if (dlres == DW_DLV_ERROR) {
                        _dwarf_free_chain_entries(dbg,head_chain,
                            line_count);
                        if (curr_line) {
                            dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                        }
                        return DW_DLV_ERROR;
                    }
                    cur_file_entry->fi_dir_index =
                        (Dwarf_Signed)value;
                    cur_file_entry->fi_dir_index_present = TRUE;
                    dlres =  read_uword_de( &line_ptr,&value,
                        dbg,error,line_ptr_end);
                    if (dlres == DW_DLV_ERROR) {
                        _dwarf_free_chain_entries(dbg,head_chain,
                            line_count);
                        if (curr_line) {
                            dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                        }
                        return DW_DLV_ERROR;
                    }
                    cur_file_entry->fi_time_last_mod = value;
                    dlres =  read_uword_de( &line_ptr,&value,
                        dbg,error,line_ptr_end);
                    if (dlres == DW_DLV_ERROR) {
                        _dwarf_free_chain_entries(dbg,head_chain,
                            line_count);
                        if (curr_line) {
                            dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                        }
                        return DW_DLV_ERROR;
                    }
                    cur_file_entry->fi_file_length = value;
                    cur_file_entry->fi_dir_index_present = TRUE;
                    cur_file_entry->fi_time_last_mod_present = TRUE;
                    cur_file_entry->fi_file_length_present = TRUE;
#ifdef PRINTING_DETAILS
                    {
                    dwarfstring m9c;
                    dwarfstring_constructor(&m9c);
                    dwarfstring_append_printf_s(&m9c,
                        "DW_LNE_define_file %s \n",
                        (char *)cur_file_entry->fi_file_name);
                    dwarfstring_append_printf_i(&m9c,
                        "    dir index %d\n",
                        (int) cur_file_entry->fi_dir_index);

                    {
                        time_t tt3 = (time_t) cur_file_entry->
                            fi_time_last_mod;

                        /* ctime supplies newline */
                        dwarfstring_append_printf_u(&m9c,
                            "    last time 0x%x ",
                            (Dwarf_Unsigned)tt3);
                        dwarfstring_append_printf_s(&m9c,
                            "%s",
                            ctime(&tt3));
                    }
                    dwarfstring_append_printf_i(&m9c,
                        "    file length %ld ",
                        cur_file_entry->fi_file_length);
                    dwarfstring_append_printf_u(&m9c,
                        "0x%lx\n",
                        cur_file_entry->fi_file_length);
                    _dwarf_printf(dbg,dwarfstring_string(&m9c));
                    dwarfstring_destructor(&m9c);
                    }
#endif /* PRINTING_DETAILS */
                }
                break;
            case DW_LNE_set_discriminator:{
                /* New in DWARF4 */
                int sdres = 0;
                Dwarf_Unsigned utmp2 = 0;

                sdres =  read_uword_de( &line_ptr,&utmp2,
                    dbg,error,line_ptr_end);
                if (sdres == DW_DLV_ERROR) {
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    }
                    return DW_DLV_ERROR;
                }
                regs.lr_discriminator = utmp2;

#ifdef PRINTING_DETAILS
                {
                dwarfstring mk;
                dwarfstring_constructor(&mk);
                dwarfstring_append_printf_u(&mk,
                    "DW_LNE_set_discriminator 0x%"
                    DW_PR_XZEROS DW_PR_DUx "\n",
                    utmp2);
                _dwarf_printf(dbg,dwarfstring_string(&mk));
                dwarfstring_destructor(&mk);
                }
#endif /* PRINTING_DETAILS */
                }
                break;
            default:{
                /*  This is an extended op code we do not know about,
                    other than we know now many bytes it is
                    and the op code and the bytes of operand. */
                Dwarf_Unsigned remaining_bytes = instr_length -1;
                /*  ptrdiff_t is generated but not named */
                Dwarf_Unsigned space_left =
                    (line_ptr <= line_ptr_end)?
                    (line_ptr_end - line_ptr):0xfffffff;

                /*  By catching this here instead of PRINTING_DETAILS
                    we avoid reading off of our data of interest*/
                if (instr_length < 1 ||
                    space_left < remaining_bytes ||
                    remaining_bytes > DW_LNE_LEN_MAX) {
                    dwarfstring g;
                    /*  ptrdiff_t is generated but not named */
                    Dwarf_Unsigned localoff =
                        (line_ptr >= section_start)?
                        (line_ptr - section_start):0xfffffff;

                    dwarfstring_constructor(&g);
                    dwarfstring_append_printf_u(&g,
                        "DW_DLE_LINE_TABLE_BAD reading "
                        "unknown DW_LNE_extended op opcode 0x%x ",
                        ext_opcode);
                    dwarfstring_append_printf_u(&g,
                        "we are "
                        "off this line table at section "
                        "offset 0x%x and ",
                        localoff);
                    dwarfstring_append_printf_u(&g,
                        "instruction length "
                        "%u.",instr_length);
                    _dwarf_error_string(dbg, error,
                        DW_DLE_LINE_TABLE_BAD,
                        dwarfstring_string(&g));
                    dwarfstring_destructor(&g);
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    }
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    return DW_DLV_ERROR;
                }

#ifdef PRINTING_DETAILS
                {
                dwarfstring m9d;
                dwarfstring_constructor(&m9d);
                dwarfstring_append_printf_u(&m9d,
                    "DW_LNE extended op 0x%x ",
                    ext_opcode);
                dwarfstring_append_printf_u(&m9d,
                    "Bytecount: %" DW_PR_DUu ,
                    (Dwarf_Unsigned)instr_length);
                if (remaining_bytes > 0) {
                    /*  If remaining bytes > distance to end
                        we will have an error. */
                    dwarfstring_append(&m9d," linedata: 0x");
                    while (remaining_bytes > 0) {
                        dwarfstring_append_printf_u(&m9d,
                            "%02x",
                            (unsigned char)(*(line_ptr)));
                        line_ptr++;
#if 0
                        /*  A test above (see space_left above)
                            proves we will not run off the end here.
                            The following test is too late anyway,
                            we might have read off the end just
                            before line_ptr incremented! */
                        if (line_ptr >= line_ptr_end) {
                            dwarfstring g;
                            /*  ptrdiff_t generated but not named */
                            Dwarf_Unsigned localoff =
                                (line_ptr >= section_start)?
                                (line_ptr - section_start):0xfffffff;

                            dwarfstring_constructor(&g);
                            dwarfstring_append_printf_u(&g,
                                "DW_DLE_LINE_TABLE_BAD reading "
                                "DW_LNE extended op remaining bytes "
                                "we are "
                                "off this line table at section "
                                "offset 0x%x .",
                                localoff);
                            _dwarf_error_string(dbg, error,
                                DW_DLE_LINE_TABLE_BAD,
                                dwarfstring_string(&g));
                            dwarfstring_destructor(&g);
                            dwarfstring_destructor(&m9d);
                            if (curr_line) {
                                dwarf_dealloc(dbg,curr_line,
                                    DW_DLA_LINE);
                            }
                            _dwarf_free_chain_entries(dbg,
                                head_chain,line_count);
                            return DW_DLV_ERROR;
                        }
#endif
                        remaining_bytes--;
                    }
                }
                _dwarf_printf(dbg,dwarfstring_string(&m9d));
                dwarfstring_destructor(&m9d);
                }
#else /* ! PRINTING_DETAILS */
                line_ptr += remaining_bytes;
                if (line_ptr > line_ptr_end) {
                    dwarfstring g;
                    /*  ptrdiff_t generated but not named */
                    Dwarf_Unsigned localoff =
                        (line_ptr >= section_start)?
                        (line_ptr - section_start):0xfffffff;

                    dwarfstring_constructor(&g);
                    dwarfstring_append_printf_u(&g,
                        "DW_DLE_LINE_TABLE_BAD reading "
                        "DW_LNE extended op remaining bytes "
                        "we are "
                        "off this line table at section "
                        "offset 0x%x .",
                        localoff);
                    _dwarf_error_string(dbg, error,
                        DW_DLE_LINE_TABLE_BAD,
                        dwarfstring_string(&g));
                    dwarfstring_destructor(&g);
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    }
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    return DW_DLV_ERROR;
                }
#endif /* PRINTING_DETAILS */
                _dwarf_printf(dbg,"\n");
                }
                break;
            } /* End switch. */
        } else {
            /* ASSERT: impossible, see the macro definition */
            _dwarf_free_chain_entries(dbg,head_chain,
                line_count);
            _dwarf_error_string(dbg,error,
                DW_DLE_LINE_TABLE_BAD,
                "DW_DLE_LINE_TABLE_BAD: Actually is "
                "an impossible type from WHAT_IS_CODE");
            return DW_DLV_ERROR;
        }
    }
    block_line = (Dwarf_Line *)
        _dwarf_get_alloc(dbg, DW_DLA_LIST, line_count);
    if (block_line == NULL) {
        curr_chain = head_chain;
        _dwarf_free_chain_entries(dbg,head_chain,line_count);
        if (curr_line) {
            dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
            curr_line = 0;
        }
        _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);
        return DW_DLV_ERROR;
    }

    curr_chain = head_chain;
    for (i = 0; i < line_count; i++) {
        Dwarf_Chain t = 0;
        *(block_line + i) = curr_chain->ch_item;
        curr_chain->ch_item = 0;
        curr_chain->ch_itemtype = 0;
        t = curr_chain;
        curr_chain = curr_chain->ch_next;
        dwarf_dealloc(dbg, t, DW_DLA_CHAIN);
    }

    if (is_single_table || !is_actuals_table) {
        line_context->lc_linebuf_logicals = block_line;
        line_context->lc_linecount_logicals = line_count;
    } else {
        line_context->lc_linebuf_actuals = block_line;
        line_context->lc_linecount_actuals = line_count;
    }
#ifdef PRINTING_DETAILS
    {
    dwarfstring mc;
    dwarfstring_constructor(&mc);
    if (is_single_table) {
        if (!line_count) {
            dwarfstring_append_printf_u(&mc,
                " Line table is present (offset 0x%"
                DW_PR_XZEROS DW_PR_DUx
                ") but no lines present\n",
                line_context->lc_section_offset);
        }
    } else if (is_actuals_table) {
        if (!line_count) {
            dwarfstring_append_printf_u(&mc,
                " Line table present (offset 0x%"
                DW_PR_XZEROS DW_PR_DUx
                ") but no actuals lines present\n",
                line_context->lc_section_offset);
        }
    } else {
        if (!line_count) {
            dwarfstring_append_printf_u(&mc,
                " Line table present (offset 0x%"
                DW_PR_XZEROS DW_PR_DUx
                ") but no logicals lines present\n",
                line_context->lc_section_offset);
        }
    }
    if (dwarfstring_strlen(&mc)) {
        _dwarf_printf(dbg,dwarfstring_string(&mc));
    }
    dwarfstring_destructor(&mc);
    }
#endif /* PRINTING_DETAILS */
    return DW_DLV_OK;
}

