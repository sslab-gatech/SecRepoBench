// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/lib/protocols/softether.c
static int ndpi_search_softether_again(struct ndpi_detection_module_struct *ndpi_struct,
                                       struct ndpi_flow_struct *flow)
{
  if (dissect_softether_ip_port(flow, &ndpi_struct->packet) == 0 ||
      dissect_softether_host_fqdn(flow, &ndpi_struct->packet) == 0)
  {
    if (flow->protos.softether.ip[0] != '\0' && flow->protos.softether.port[0] != '\0' &&
        flow->protos.softether.hostname[0] != '\0' && flow->protos.softether.fqdn[0] != '\0')
    {
      flow->check_extra_packets = 0;
      flow->max_extra_packets_to_check = 0;
      flow->extra_packets_func = NULL;

      return 0;
    }
  }

  return 1;
}

// the below code fragment can be found in:
// src/lib/protocols/softether.c
static int dissect_softether_host_fqdn(struct ndpi_flow_struct *flow,
                                       struct ndpi_packet_struct const *packet)
{
  u_int8_t const *payload = packet->payload;
  u_int16_t payload_len = packet->payload_packet_len;
  u_int32_t tuple_count;
  size_t value_siz;
  struct softether_value val1, val2;
  uint8_t got_hostname = 0, got_fqdn = 0;

  if (payload_len < 4)
  {
    return 1;
  }

  tuple_count = ntohl(get_u_int32_t(payload, 0));
  if (tuple_count == 0 || tuple_count * 8 > payload_len)
  {
    return 1;
  }

  payload += 4;
  payload_len -= 4;

  value_siz = dissect_softether_type(VALUE_DATA, &val1, payload, payload_len);
  if (value_siz == 0)
  {
    return 1;
  }

  payload += value_siz;
  payload_len -= value_siz;

  if (strncmp(val1.value.ptr.value_str, "host_name", value_siz) == 0)
  {
    got_hostname = 1;
  }

  for (; tuple_count > 0; --tuple_count)
  {
    value_siz = dissect_softether_tuples(payload, payload_len, &val1, &val2);
    if (value_siz == 0)
    {
      break;
    }

    if (got_hostname == 1)
    {
      if (val1.type == VALUE_STR && val1.value_size > 0)
      {
        size_t len = ndpi_min(val1.value_size, sizeof(flow->protos.softether.hostname) - 1);
        strncpy(flow->protos.softether.hostname, val1.value.ptr.value_str, len);
        flow->protos.softether.hostname[len] = '\0';
      }
      got_hostname = 0;
    }
    if (got_fqdn == 1)
    {
      if (val1.type == VALUE_STR && val1.value_size > 0)
      {
        size_t len = ndpi_min(val1.value_size, sizeof(flow->protos.softether.fqdn) - 1);
        strncpy(flow->protos.softether.fqdn, val1.value.ptr.value_str, len);
        flow->protos.softether.fqdn[len] = '\0';
      }
      got_fqdn = 0;
    }

    if (val2.type == VALUE_DATA && val2.value_size > 0 &&
        strncmp(val2.value.ptr.value_str, "ddns_fqdn", val2.value_size) == 0)
    {
      got_fqdn = 1;
    }

    payload += value_siz;
    payload_len -= value_siz;
  }

  if (payload_len != 0 || tuple_count != 0)
  {
    return 1;
  }

  return 0;
}

// the below code fragment can be found in:
// src/lib/protocols/softether.c
void ndpi_search_softether(struct ndpi_detection_module_struct *ndpi_struct,
                           struct ndpi_flow_struct *flow)
{
  struct ndpi_packet_struct const * const packet = &ndpi_struct->packet;

  NDPI_LOG_DBG(ndpi_struct, "search softether\n");

  if (packet->payload_packet_len == 1)
  {
    if (packet->payload[0] != 0x41 ||
        flow->packet_counter > 2)
    {
      NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
    }

    return;
  }

  if (packet->payload_packet_len > 9 && packet->payload_packet_len < 30)
  {
    if (dissect_softether_ip_port(flow, packet) == 0)
    {
      ndpi_int_softether_add_connection(ndpi_struct, flow);
      return;
    }
  }

  if (packet->payload_packet_len >= 99)
  {
    if (dissect_softether_host_fqdn(flow, packet) == 0)
    {
      ndpi_int_softether_add_connection(ndpi_struct, flow);
      return;
    }
  }

  NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
}

// the below code fragment can be found in:
// src/lib/protocols/ftp_data.c
static int ndpi_match_ftp_data_port(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow) {
  struct ndpi_packet_struct *packet = &ndpi_struct->packet;

  /* Check connection over TCP */
  if(packet->tcp) {
    if(packet->tcp->dest == htons(20) || packet->tcp->source == htons(20)) {
      return 1;
    }
  }
  return 0;
}

// the below code fragment can be found in:
// src/lib/ndpi_main.c
u_int8_t ndpi_extra_dissection_possible(struct ndpi_detection_module_struct *ndpi_str,
					struct ndpi_flow_struct *flow) {
  u_int16_t proto =
    flow->detected_protocol_stack[1] ? flow->detected_protocol_stack[1] : flow->detected_protocol_stack[0];

#if 0
  printf("[DEBUG] %s(%u.%u): %u\n", __FUNCTION__,
	 flow->detected_protocol_stack[0],
	 flow->detected_protocol_stack[1],
	 proto);
#endif

  if(!flow->extra_packets_func)
    return(0);

  switch(proto) {
  case NDPI_PROTOCOL_TLS:
  case NDPI_PROTOCOL_DTLS:
  case NDPI_PROTOCOL_MAIL_POPS:
  case NDPI_PROTOCOL_MAIL_IMAPS:
  case NDPI_PROTOCOL_MAIL_SMTPS:
  case NDPI_PROTOCOL_HTTP:
  case NDPI_PROTOCOL_HTTP_PROXY:
  case NDPI_PROTOCOL_HTTP_CONNECT:
  case NDPI_PROTOCOL_DNS:
  case NDPI_PROTOCOL_MDNS:
  case NDPI_PROTOCOL_FTP_CONTROL:
  case NDPI_PROTOCOL_MAIL_POP:
  case NDPI_PROTOCOL_MAIL_IMAP:
  case NDPI_PROTOCOL_MAIL_SMTP:
  case NDPI_PROTOCOL_SSH:
  case NDPI_PROTOCOL_TELNET:
  case NDPI_PROTOCOL_SKYPE_TEAMS:
  case NDPI_PROTOCOL_QUIC:
  case NDPI_PROTOCOL_KERBEROS:
  case NDPI_PROTOCOL_SNMP:
  case NDPI_PROTOCOL_BITTORRENT:
      return(1);
    break;

  case NDPI_PROTOCOL_SOFTETHER:
    return(1);
  }

  return(0);
}

