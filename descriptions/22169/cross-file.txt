// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/lib/ndpi_main.c
u_int16_t ndpi_check_for_email_address(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,
                                       u_int16_t counter) {
  struct ndpi_packet_struct *packet = &flow->packet;

  NDPI_LOG_DBG2(ndpi_str, "called ndpi_check_for_email_address\n");

  if(packet->payload_packet_len > counter && ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') ||
					      (packet->payload[counter] >= 'A' && packet->payload[counter] <= 'Z') ||
					      (packet->payload[counter] >= '0' && packet->payload[counter] <= '9') ||
					      packet->payload[counter] == '-' || packet->payload[counter] == '_')) {
    NDPI_LOG_DBG2(ndpi_str, "first letter\n");
    counter++;
    while (packet->payload_packet_len > counter &&
	   ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') ||
	    (packet->payload[counter] >= 'A' && packet->payload[counter] <= 'Z') ||
	    (packet->payload[counter] >= '0' && packet->payload[counter] <= '9') ||
	    packet->payload[counter] == '-' || packet->payload[counter] == '_' ||
	    packet->payload[counter] == '.')) {
      NDPI_LOG_DBG2(ndpi_str, "further letter\n");
      counter++;
      if(packet->payload_packet_len > counter && packet->payload[counter] == '@') {
	NDPI_LOG_DBG2(ndpi_str, "@\n");
	counter++;
	while (packet->payload_packet_len > counter &&
	       ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') ||
		(packet->payload[counter] >= 'A' && packet->payload[counter] <= 'Z') ||
		(packet->payload[counter] >= '0' && packet->payload[counter] <= '9') ||
		packet->payload[counter] == '-' || packet->payload[counter] == '_')) {
	  NDPI_LOG_DBG2(ndpi_str, "letter\n");
	  counter++;
	  if(packet->payload_packet_len > counter && packet->payload[counter] == '.') {
	    NDPI_LOG_DBG2(ndpi_str, ".\n");
	    counter++;
	    if(packet->payload_packet_len > counter + 1 &&
	       ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') &&
		(packet->payload[counter + 1] >= 'a' && packet->payload[counter + 1] <= 'z'))) {
	      NDPI_LOG_DBG2(ndpi_str, "two letters\n");
	      counter += 2;
	      if(packet->payload_packet_len > counter &&
		 (packet->payload[counter] == ' ' || packet->payload[counter] == ';')) {
		NDPI_LOG_DBG2(ndpi_str, "whitespace1\n");
		return(counter);
	      } else if(packet->payload_packet_len > counter && packet->payload[counter] >= 'a' &&
			packet->payload[counter] <= 'z') {
		NDPI_LOG_DBG2(ndpi_str, "one letter\n");
		counter++;
		if(packet->payload_packet_len > counter &&
		   (packet->payload[counter] == ' ' || packet->payload[counter] == ';')) {
		  NDPI_LOG_DBG2(ndpi_str, "whitespace2\n");
		  return(counter);
		} else if(packet->payload_packet_len > counter && packet->payload[counter] >= 'a' &&
			  packet->payload[counter] <= 'z') {
		  counter++;
		  if(packet->payload_packet_len > counter &&
		     (packet->payload[counter] == ' ' || packet->payload[counter] == ';')) {
		    NDPI_LOG_DBG2(ndpi_str, "whitespace3\n");
		    return(counter);
		  } else {
		    return(0);
		  }
		} else {
		  return(0);
		}
	      } else {
		return(0);
	      }
	    } else {
	      return(0);
	    }
	  }
	}
	return(0);
      }
    }
  }
  return(0);
}

// the below code fragment can be found in:
// src/lib/protocols/bittorrent.c
static void ndpi_int_search_bittorrent_tcp(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow)
{
  struct ndpi_packet_struct *packet = &flow->packet;

  if(packet->payload_packet_len == 0) {
    return;
  }

  if(flow->bittorrent_stage == 0 && packet->payload_packet_len != 0) {
    /* exclude stage 0 detection from next run */
    flow->bittorrent_stage = 1;
    if(ndpi_int_search_bittorrent_tcp_zero(ndpi_struct, flow) != 0) {
      NDPI_LOG_DBG2(ndpi_struct, "stage 0 has detected something, returning\n");
      return;
    }

    NDPI_LOG_DBG2(ndpi_struct, "stage 0 has no direct detection, fall through\n");
  }
  return;
}

// the below code fragment can be found in:
// src/lib/protocols/thunder.c
void ndpi_search_thunder(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow)
{
  struct ndpi_packet_struct *packet = &flow->packet;
  //
  //struct ndpi_id_struct *src = flow->src;
  //struct ndpi_id_struct *dst = flow->dst;

  if (packet->tcp != NULL) {
    ndpi_int_search_thunder_http(ndpi_struct, flow);
    ndpi_int_search_thunder_tcp(ndpi_struct, flow);
  } else if (packet->udp != NULL) {
    ndpi_int_search_thunder_udp(ndpi_struct, flow);
  }
}

// the below code fragment can be found in:
// src/lib/protocols/yahoo.c
void ndpi_search_yahoo(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow)
{
  struct ndpi_packet_struct *packet = &flow->packet;

  NDPI_LOG_DBG(ndpi_struct, "search yahoo\n");
  
  if(packet->payload_packet_len > 0 && flow->yahoo_detection_finished == 0) {

    /* search over TCP */
    if(packet->tcp != NULL && packet->tcp_retransmission == 0) {

      if(packet->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN
	 || packet->detected_protocol_stack[0] == NDPI_PROTOCOL_HTTP
	 || packet->detected_protocol_stack[0] == NDPI_PROTOCOL_TLS) {
        /* search over TCP */
	ndpi_search_yahoo_tcp(ndpi_struct, flow);
      }
    }
    /* search over UDP */
    else if(packet->udp != NULL) {
      if ( flow->src == NULL || 
	   NDPI_COMPARE_PROTOCOL_TO_BITMASK(flow->src->detected_protocol_bitmask, NDPI_PROTOCOL_YAHOO) == 0) {
	NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
      }
      return;
    }
  }

  if(packet->payload_packet_len > 0 && flow->yahoo_detection_finished == 2) {
    if(packet->tcp != NULL && packet->tcp_retransmission == 0) {
      /* search over TCP */
      ndpi_search_yahoo_tcp(ndpi_struct, flow);
      return;
    }
  }
}

// the below code fragment can be found in:
// src/lib/protocols/mail_smtp.c
int ndpi_extra_search_mail_smtp_tcp(struct ndpi_detection_module_struct *ndpi_struct,
				    struct ndpi_flow_struct *flow) {
  int rc;
  
  ndpi_search_mail_smtp_tcp(ndpi_struct, flow);

  rc = (flow->protos.ftp_imap_pop_smtp.password[0] == '\0') ? 1 : 0;
  
#ifdef SMTP_DEBUG
  printf("**** %s() [rc: %d]\n", __FUNCTION__, rc);
#endif  

  return(rc);
}

