// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/flb_oauth2.c
int flb_oauth2_token_len(struct flb_oauth2 *ctx)
{
    if (!ctx->access_token) {
        return -1;
    }

    return flb_sds_len(ctx->access_token);
}

// the below code fragment can be found in:
// src/aws/flb_aws_util.c
void flb_aws_print_xml_error(char *response, size_t response_len,
                             char *api, struct flb_output_instance *ins)
{
    flb_sds_t error;
    flb_sds_t message;

    error = flb_xml_get_val(response, response_len, "<Code>");
    if (!error) {
        flb_plg_error(ins, "%s: Could not parse response", api);
        return;
    }

    message = flb_xml_get_val(response, response_len, "<Message>");
    if (!message) {
        /* just print the error */
        flb_plg_error(ins, "%s API responded with error='%s'", api, error);
    }
    else {
        flb_plg_error(ins, "%s API responded with error='%s', message='%s'",
                      api, error, message);
        flb_sds_destroy(message);
    }

    flb_sds_destroy(error);
}

// the below code fragment can be found in:
// src/flb_http_client.c
int flb_http_client_proxy_connect(struct flb_upstream_conn *u_conn)
{
    struct flb_upstream *u = u_conn->u;
    struct flb_http_client *c;
    size_t b_sent;
    int ret = -1;

    /* Don't pass proxy when using FLB_HTTP_CONNECT */
    flb_debug("[upstream] establishing http tunneling to proxy: host %s port %d", u->tcp_host, u->tcp_port);
    c = flb_http_client(u_conn, FLB_HTTP_CONNECT, "", NULL,
                        0, u->proxied_host, u->proxied_port, NULL, 0);

    /* Setup proxy's username and password */
    if (u->proxy_username && u->proxy_password) {
        flb_debug("[upstream] proxy uses username %s password %s", u->proxy_username, u->proxy_password);
        flb_http_proxy_auth(c, u->proxy_username, u->proxy_password);
    }

    flb_http_buffer_size(c, 4192);

    flb_http_add_header(c, "User-Agent", 10, "Fluent-Bit", 10);

    /* Send HTTP request */
    ret = flb_http_do(c, &b_sent);

    /* Validate HTTP response */
    if (ret != 0) {
        flb_error("[upstream] error in flb_establish_proxy: %d", ret);
        ret = -1;
    }
    else {
        /* The request was issued successfully, validate the 'error' field */
        flb_debug("[upstream] proxy returned %d", c->resp.status);
        if (c->resp.status == 200) {
            ret = 0;
        }
        else {
            flb_error("flb_establish_proxy error: %s", c->resp.payload);
            ret = -1;
        }
    }

    /* Cleanup */
    flb_http_client_destroy(c);

    return ret;
}

// the below code fragment can be found in:
// src/flb_http_client.c
void flb_http_client_destroy(struct flb_http_client *c)
{
    http_headers_destroy(c);
    flb_free(c->resp.data);
    flb_free(c->header_buf);
    flb_free((void *)c->proxy.host);
    flb_free(c);
}

// the below code fragment can be found in:
// src/flb_http_client.c
int flb_http_buffer_size(struct flb_http_client *c, size_t size)
{
    if (size < c->resp.data_size_max && size != 0) {
        flb_error("[http] requested buffer size %lu (bytes) needs to be greater than "
                  "minimum size allowed %lu (bytes)",
                  size, c->resp.data_size_max);
        return -1;
    }

    c->resp.data_size_max = size;
    return 0;
}

