// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/lib/libdwarf/dwarf_locationop_read.c
static int
read_encoded_addr(Dwarf_Small *loc_ptr,
    Dwarf_Debug dbg,
    Dwarf_Small *section_end_ptr,
    Dwarf_Half address_size,
    Dwarf_Unsigned * val_out,
    int * len_out,
    Dwarf_Error *error)
{
    int len = 0;
    Dwarf_Small op = *loc_ptr;
    Dwarf_Unsigned operand = 0;
    len++;
    if (!op) {
        op = address_size;
    }
    switch (op) {
    case 1:
        *val_out = *loc_ptr;
        len++;
        break;

    case 2:
        READ_UNALIGNED_CK(dbg, operand, Dwarf_Unsigned, loc_ptr, 2,
            error,section_end_ptr);
        *val_out = operand;
        len +=2;
        break;
    case 4:
        READ_UNALIGNED_CK(dbg, operand, Dwarf_Unsigned, loc_ptr, 4,
            error,section_end_ptr);
        *val_out = operand;
        len +=4;
        break;
    case 8:
        READ_UNALIGNED_CK(dbg, operand, Dwarf_Unsigned, loc_ptr, 8,
            error,section_end_ptr);
        *val_out = operand;
        len +=8;
        break;
    default:
        /* We do not know how much to read. */
        _dwarf_error(dbg, error, DW_DLE_GNU_OPCODE_ERROR);
        return DW_DLV_ERROR;
    };
    *len_out = len;
    return DW_DLV_OK;
}

// the below code fragment can be found in:
// src/lib/libdwarf/dwarf_macro5.c
static void
dump_bytes_x(Dwarf_Small * start, long len)
{
    Dwarf_Small *end = start + len;
    Dwarf_Small *cur = start;
    unsigned pos = 0;

    printf("dump %ld bytes, start at 0x%lx\n",
        len,(unsigned long)start);
    printf("0x");
    for (; cur < end;pos++, cur++) {
        if (!(pos %4)) {
            printf(" ");
        }
        printf("%02x",*cur);
    }
    printf("\n");
}

// the below code fragment can be found in:
// src/lib/libdwarf/dwarf_form.c
int
_dwarf_get_addr_index_itself(int theform,
    Dwarf_Small *info_ptr,
    Dwarf_Debug dbg,
    Dwarf_CU_Context cu_context,
    Dwarf_Unsigned *val_out,
    Dwarf_Error * error)
{
    Dwarf_Unsigned index = 0;
    Dwarf_Byte_Ptr section_end = 0;

    section_end =
        _dwarf_calculate_info_section_end_ptr(cu_context);
    switch(theform){
    case DW_FORM_LLVM_addrx_offset: {
        Dwarf_Unsigned tmp = 0;
        Dwarf_Unsigned tmp2 = 0;
        DECODE_LEB128_UWORD_CK(info_ptr,tmp,
            dbg,error,section_end);
        READ_UNALIGNED_CK(dbg, tmp2, Dwarf_Unsigned,
            info_ptr, SIZEOFT32,
            error,section_end);
        index = (tmp<<32) | tmp2;
        break;
    }
    case DW_FORM_GNU_addr_index:
    case DW_FORM_addrx:
        DECODE_LEB128_UWORD_CK(info_ptr,index,
            dbg,error,section_end);
        break;
    case DW_FORM_addrx1:
        READ_UNALIGNED_CK(dbg, index, Dwarf_Unsigned,
            info_ptr, 1,
            error,section_end);
        break;
    case DW_FORM_addrx2:
        READ_UNALIGNED_CK(dbg, index, Dwarf_Unsigned,
            info_ptr, 2,
            error,section_end);
        break;
    case DW_FORM_addrx3:
        READ_UNALIGNED_CK(dbg, index, Dwarf_Unsigned,
            info_ptr, 3,
            error,section_end);
        break;
    case DW_FORM_addrx4:
        READ_UNALIGNED_CK(dbg, index, Dwarf_Unsigned,
            info_ptr, 4,
            error,section_end);
        break;
    default:
        _dwarf_error(dbg, error, DW_DLE_ATTR_FORM_NOT_ADDR_INDEX);
        return DW_DLV_ERROR;
    }
    /*  At this point we do not know for sure
        if the index refers
        to a local .debug_addr or a tied file .debug_addr
        so lets be cautious. */
#if 0
    if (!dbg->de_tied_data.td_tied_object &&
        index > dbg->de_filesize) {
        _dwarf_error_string(dbg,error,DW_DLE_ATTR_FORM_OFFSET_BAD,
            "DW_DLE_ATTR_FORM_OFFSET_BAD "
            "reading an indexed form addr the index "
            "read is impossibly large (no tied file "
            "available). Corrupt Dwarf.");
        return DW_DLV_ERROR;
    }
#endif
    *val_out = index;
    return DW_DLV_OK;
}

// the below code fragment can be found in:
// src/lib/libdwarf/dwarf_loc.c
int
dwarf_get_loclist_head_kind(Dwarf_Loc_Head_c ll_header,
    unsigned int * kind,
    Dwarf_Error  * error)
{
    if (!ll_header) {
        _dwarf_error_string(NULL, error,DW_DLE_DBG_NULL,
            "DW_DLE_DBG_NULL: "
            "NULL Dwarf_Loc_Head_c "
            "argument passed to "
            "dwarf_get_loclist_head_kind()");
        return DW_DLV_ERROR;
    }
    *kind = ll_header->ll_kind;
    return DW_DLV_OK;
}

// the below code fragment can be found in:
// src/lib/libdwarf/dwarf_form.c
static int
_dwarf_formsig8_internal(Dwarf_Attribute attr,
    int formexpected,
    Dwarf_Sig8 * returned_sig_bytes,
    Dwarf_Error*     error)
{
    Dwarf_Debug dbg = 0;
    Dwarf_CU_Context cu_context = 0;
    Dwarf_Byte_Ptr  field_end = 0;
    Dwarf_Byte_Ptr  section_end = 0;

    int res  = get_attr_dbg(&dbg,&cu_context,attr,error);
    if (res != DW_DLV_OK) {
        return res;
    }

    if (attr->ar_attribute_form != formexpected) {
        return DW_DLV_NO_ENTRY;
    }
    section_end =
        _dwarf_calculate_info_section_end_ptr(cu_context);
    field_end = attr->ar_debug_ptr + sizeof(Dwarf_Sig8);
    if (field_end > section_end) {
        _dwarf_error(dbg, error, DW_DLE_ATTR_FORM_OFFSET_BAD);
        return DW_DLV_ERROR;
    }

    memcpy(returned_sig_bytes, attr->ar_debug_ptr,
        sizeof(*returned_sig_bytes));
    return DW_DLV_OK;
}

