// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/numeric.c
static mrb_value
int_to_i(mrb_state *mrb, mrb_value num)
{
  return num;
}

// the below code fragment can be found in:
// mrbgems/mruby-string-ext/src/string.c
static mrb_value
mrb_int_chr(mrb_state *mrb, mrb_value num)
{
  mrb_value enc;
  mrb_bool enc_given;

  mrb_get_args(mrb, "|S?", &enc, &enc_given);
  if (!enc_given ||
      ENC_COMP_P(enc, ENC_ASCII_8BIT) ||
      ENC_COMP_P(enc, ENC_BINARY)) {
    return int_chr_binary(mrb, num);
  }
#ifdef MRB_UTF8_STRING
  else if (ENC_COMP_P(enc, ENC_UTF8)) {
    return int_chr_utf8(mrb, num);
  }
#endif
  else {
    mrb_raisef(mrb, E_ARGUMENT_ERROR, "unknown encoding name - %v", enc);
  }
  /* not reached */
  return mrb_nil_value();
}

// the below code fragment can be found in:
// src/numeric.c
static mrb_value
flo_to_f(mrb_state *mrb, mrb_value num)
{
  return num;
}

// the below code fragment can be found in:
// src/readnum.c
MRB_API mrb_int
mrb_int_read(const char *p, const char *e, char **endp)
{
  mrb_int n;

  if (!mrb_read_int(p, e, endp, &n)) {
    if (endp) *endp = NULL;
    errno = ERANGE;
    return MRB_INT_MAX;
  }
  if (endp) *endp = (char*)p;
  return n;
}

// the below code fragment can be found in:
// src/string.c
MRB_API mrb_value
mrb_ptr_to_str(mrb_state *mrb, void *p)
{
  struct RString *p_str;
  char *p1;
  char *p2;
  uintptr_t n = (uintptr_t)p;

  p_str = str_new(mrb, NULL, 2 + sizeof(uintptr_t) * CHAR_BIT / 4);
  p1 = RSTR_PTR(p_str);
  *p1++ = '0';
  *p1++ = 'x';
  p2 = p1;

  do {
    *p2++ = mrb_digitmap[n % 16];
    n /= 16;
  } while (n > 0);
  *p2 = '\0';
  RSTR_SET_LEN(p_str, (mrb_int)(p2 - RSTR_PTR(p_str)));

  while (p1 < p2) {
    const char  c = *p1;
    *p1++ = *--p2;
    *p2 = c;
  }

  return mrb_obj_value(p_str);
}

