// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/is_json.c
// static int
// json_parse_number(const unsigned char **ucp, const unsigned char *ue)
// {
// 	const unsigned char *uc = *ucp;
// 	int got = 0;
// 
// 	DPRINTF("Parse number: ", uc, *ucp);
// 	if (uc == ue)
// 		return 0;
// 	if (*uc == '-')
// 		uc++;
// 
// 	for (; uc < ue; uc++) {
// 		if (!json_isdigit(*uc))
// 			break;
// 		got = 1;
// 	}
// 	if (*uc == '.')
// 		uc++;
// 	for (; uc < ue; uc++) {
// 		if (!json_isdigit(*uc))
// 			break;
// 		got = 1;
// 	}
// 	if (got && (*uc == 'e' || *uc == 'E')) {
// 		uc++;
// 		got = 0;
// 		if (*uc == '+' || *uc == '-')
// 			uc++;
// 		for (; uc < ue; uc++) {
// 			if (!json_isdigit(*uc))
// 				break;
// 			got = 1;
// 		}
// 	}
// 	ue = *ucp;
// 	if (!got || uc == ue)
// 		DPRINTF("Bad number: ", uc, *ucp);
// 	else
// 		DPRINTF("Good number: ", uc, *ucp);
// 	*ucp = uc;
// 	return uc != ue && got;
// }

// the below code fragment can be found in:
// src/is_json.c
// int
// file_is_json(struct magic_set *ms, const struct buffer *b)
// {
// 	const unsigned char *uc = b->fbuf;
// 	const unsigned char *ue = uc + b->flen;
// 	size_t st[JSON_MAX];
// 	int mime = ms->flags & MAGIC_MIME;
// 
// 
// 	if ((ms->flags & (MAGIC_APPLE|MAGIC_EXTENSION)) != 0)
// 		return 0;
// 
// 	memset(st, 0, sizeof(st));
// 
// 	if (!json_parse(&uc, ue, st, 0))
// 		return 0;
// 
// 	if (mime == MAGIC_MIME_ENCODING)
// 		return 1;
// 	if (mime) {
// 		if (file_printf(ms, "application/json") == -1)
// 			return -1;
// 		return 1;
// 	}
// 	if (file_printf(ms, "JSON data") == -1)
// 		return -1;
// #if JSON_COUNT
// #define P(n) st[n], st[n] > 1 ? "s" : ""
// 	if (file_printf(ms, " (%zu object%s, %zu array%s, %zu string%s, "
// 	    "%zu constant%s, %zu number%s)", P(JSON_OBJECT), P(JSON_ARRAY), 
// 	    P(JSON_STRING), P(JSON_CONSTANT), P(JSON_NUMBER)) == -1)
// 		return -1;
// #endif
// 	return 1;
// }

// the below code fragment can be found in:
// src/is_json.c
// static int
// json_parse_array(const unsigned char **ucp, const unsigned char *ue, 
// 	size_t *st, size_t lvl)
// {
// 	const unsigned char *uc = *ucp;
// 
// 	DPRINTF("Parse array: ", uc, *ucp);
// 	while (uc < ue) {
// 		if (!json_parse(&uc, ue, st, lvl + 1))
// 			goto out;
// 		switch (*uc) {
// 		case ',':
// 			uc++;
// 			continue;
// 		case ']':
// 			*ucp = uc + 1;
// 			return 1;
// 		default:
// 			goto out;
// 		}
// 	}
// out:
// 	DPRINTF("Bad array: ", uc,  *ucp);
// 	*ucp = uc;
// 	return 0;
// }

// the below code fragment can be found in:
// src/is_json.c
// static int
// json_parse_const(const unsigned char **ucp, const unsigned char *ue,
//     const char *str, size_t len)
// {
// 	const unsigned char *uc = *ucp;
// 
// 	DPRINTF("Parse const: ", uc, *ucp);
// 	for (len--; uc < ue && --len;) {
// 		if (*uc++ == *++str)
// 			continue;
// 	}
// 	if (len)
// 		DPRINTF("Bad const: ", uc, *ucp);
// 	*ucp = uc;
// 	return len == 0;
// }

// the below code fragment can be found in:
// src/is_json.c
// static int
// json_parse(const unsigned char **ucp, const unsigned char *ue, 
//     size_t *st, size_t lvl)
// {
// 	const unsigned char *uc;
// 	int rv = 0;
// 	int t;
// 
// 	uc = json_skip_space(*ucp, ue);
// 	if (uc == ue)
// 		goto out;
// 
// 	// Avoid recursion 
// 	if (lvl > 20)
// 		return 0;
// #if JSON_COUNT
// 	/* bail quickly if not counting */
// 	if (lvl > 1 && (st[JSON_OBJECT] || st[JSON_ARRAY]))
// 		return 1;
// #endif
// 
// 	DPRINTF("Parse general: ", uc, *ucp);
// 	switch (*uc++) {
// 	case '"':
// 		rv = json_parse_string(&uc, ue);
// 		t = JSON_STRING;
// 		break;
// 	case '[':
// 		rv = json_parse_array(&uc, ue, st, lvl + 1);
// 		t = JSON_ARRAY;
// 		break;
// 	case '{': /* '}' */
// 		rv = json_parse_object(&uc, ue, st, lvl + 1);
// 		t = JSON_OBJECT;
// 		break;
// 	case 't':
// 		rv = json_parse_const(&uc, ue, "true", sizeof("true"));
// 		t = JSON_CONSTANT;
// 		break;
// 	case 'f':
// 		rv = json_parse_const(&uc, ue, "false", sizeof("false"));
// 		t = JSON_CONSTANT;
// 		break;
// 	case 'n':
// 		rv = json_parse_const(&uc, ue, "null", sizeof("null"));
// 		t = JSON_CONSTANT;
// 		break;
// 	default:
// 		--uc;
// 		rv = json_parse_number(&uc, ue);
// 		t = JSON_NUMBER;
// 		break;
// 	}
// 	if (rv)
// 		st[t]++;
// 	uc = json_skip_space(uc, ue);
// out:
// 	*ucp = uc;
// 	DPRINTF("End general: ", uc, *ucp);
// 	if (lvl == 0)
// 		return rv && (st[JSON_ARRAY] || st[JSON_OBJECT]);
// 	return rv;
// }

