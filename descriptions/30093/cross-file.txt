// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/flb_record_accessor.c
int flb_ra_is_static(struct flb_record_accessor *ra)
{
    struct mk_list *head;
    struct flb_ra_parser *rp;

    mk_list_foreach(head, &ra->list) {
        rp = mk_list_entry(head, struct flb_ra_parser, _head);
        if (rp->type == FLB_RA_PARSER_STRING) {
            continue;
        }
        else if (rp->type == FLB_RA_PARSER_KEYMAP) {
            return FLB_FALSE;
        }
        else if (rp->type == FLB_RA_PARSER_REGEX_ID) {
            return FLB_FALSE;
        }
        else if (rp->type == FLB_RA_PARSER_TAG) {
            continue;
        }
        else if (rp->type == FLB_RA_PARSER_TAG_PART) {
            continue;
        }
    }

    return FLB_TRUE;
}

// the below code fragment can be found in:
// src/flb_record_accessor.c
struct flb_ra_value *flb_ra_get_value_object(struct flb_record_accessor *ra,
                                             msgpack_object map)
{
    struct flb_ra_parser *rp;

    if (mk_list_size(&ra->list) == 0) {
        return NULL;
    }

    rp = mk_list_entry_first(&ra->list, struct flb_ra_parser, _head);
    if (!rp->key) {
        return NULL;
    }

    return flb_ra_key_to_value(rp->key->name, map, rp->key->subkeys);
}

// the below code fragment can be found in:
// src/flb_record_accessor.c
flb_sds_t flb_ra_translate(struct flb_record_accessor *ra,
                           char *tag, int tag_len,
                           msgpack_object map, struct flb_regex_search *result)
{
    int found;
    flb_sds_t tmp = NULL;
    flb_sds_t buf;
    struct mk_list *head;
    struct flb_ra_parser *rp;

    buf = flb_sds_create_size(ra->size_hint);
    if (!buf) {
        flb_error("[record accessor] cannot create outgoing buffer");
        return NULL;
    }

    mk_list_foreach(head, &ra->list) {
        rp = mk_list_entry(head, struct flb_ra_parser, _head);
        if (rp->type == FLB_RA_PARSER_STRING) {
            tmp = ra_translate_string(rp, buf);
        }
        else if (rp->type == FLB_RA_PARSER_KEYMAP) {
            tmp = ra_translate_keymap(rp, buf, map, &found);
        }
        else if (rp->type == FLB_RA_PARSER_REGEX_ID && result) {
            tmp = ra_translate_regex_id(rp, result, buf);
        }
        else if (rp->type == FLB_RA_PARSER_TAG && tag) {
            tmp = ra_translate_tag(rp, buf, tag, tag_len);
        }
        else if (rp->type == FLB_RA_PARSER_TAG_PART && tag) {
            tmp = ra_translate_tag_part(rp, buf, tag, tag_len);
        }
        else {

        }

        //else if (rp->type == FLB_RA_PARSER_FUNC) {
            //tmp = ra_translate_func(rp, buf, tag, tag_len);
        //}

        if (!tmp) {
            flb_error("[record accessor] translation failed");
            flb_sds_destroy(buf);
            return NULL;
        }
        if (tmp != buf) {
            buf = tmp;
        }
    }

    return buf;
}

// the below code fragment can be found in:
// src/flb_record_accessor.c
int flb_ra_regex_match(struct flb_record_accessor *ra, msgpack_object map,
                       struct flb_regex *regex, struct flb_regex_search *result)
{
    struct flb_ra_parser *rp;

    rp = mk_list_entry_first(&ra->list, struct flb_ra_parser, _head);
    return flb_ra_key_regex_match(rp->key->name, map, rp->key->subkeys,
                                  regex, result);
}

// the below code fragment can be found in:
// src/record_accessor/flb_ra_parser.c
void flb_ra_parser_destroy(struct flb_ra_parser *rp)
{
    struct flb_ra_key *key;

    key = rp->key;
    if (key) {
        flb_sds_destroy(key->name);
        if (key->subkeys) {
            ra_parser_subentry_destroy_all(key->subkeys);
            flb_free(key->subkeys);
        }
        flb_free(rp->key);
    }
    if (rp->slist) {
        ra_parser_subentry_destroy_all(rp->slist);
        flb_free(rp->slist);
    }
    flb_free(rp);
}

