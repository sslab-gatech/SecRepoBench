// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// libavcodec/eatgq.c
static int tgq_decode_frame(AVCodecContext *avctx, AVFrame *frame,
                            int *got_frame, AVPacket *avpkt)
{
    const uint8_t *buf = avpkt->data;
    int buf_size       = avpkt->size;
    TgqContext *s      = avctx->priv_data;
    int x, y, ret;
    int big_endian;

    if (buf_size < 16) {
        av_log(avctx, AV_LOG_WARNING, "truncated header\n");
        return AVERROR_INVALIDDATA;
    }
    big_endian = AV_RL32(&buf[4]) > 0x000FFFFF;
    bytestream2_init(&s->gb, buf + 8, buf_size - 8);
    if (big_endian) {
        s->width  = bytestream2_get_be16u(&s->gb);
        s->height = bytestream2_get_be16u(&s->gb);
    } else {
        s->width  = bytestream2_get_le16u(&s->gb);
        s->height = bytestream2_get_le16u(&s->gb);
    }

    ret = ff_set_dimensions(s->avctx, s->width, s->height);
    if (ret < 0)
        return ret;

    tgq_calculate_qtable(s, bytestream2_get_byteu(&s->gb));
    bytestream2_skip(&s->gb, 3);

    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)
        return ret;
    frame->key_frame = 1;
    frame->pict_type = AV_PICTURE_TYPE_I;

    for (y = 0; y < FFALIGN(avctx->height, 16) >> 4; y++)
        for (x = 0; x < FFALIGN(avctx->width, 16) >> 4; x++)
            if (tgq_decode_mb(s, frame, y, x) < 0)
                return AVERROR_INVALIDDATA;

    *got_frame = 1;

    return avpkt->size;
}

// the below code fragment can be found in:
// libavcodec/eacmv.c
static av_cold int cmv_decode_end(AVCodecContext *avctx){
    CmvContext *s = avctx->priv_data;

    av_frame_free(&s->last_frame);
    av_frame_free(&s->last2_frame);

    return 0;
}

// the below code fragment can be found in:
// libavcodec/idcinvideo.c
static int idcin_decode_frame(AVCodecContext *avctx, AVFrame *frame,
                              int *got_frame, AVPacket *avpkt)
{
    const uint8_t *buf = avpkt->data;
    int buf_size = avpkt->size;
    IdcinContext *s = avctx->priv_data;
    int ret;

    s->buf = buf;
    s->size = buf_size;

    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)
        return ret;

    if (idcin_decode_vlcs(s, frame))
        return AVERROR_INVALIDDATA;

    frame->palette_has_changed = ff_copy_palette(s->pal, avpkt, avctx);
    /* make the palette available on the way out */
    memcpy(frame->data[1], s->pal, AVPALETTE_SIZE);

    *got_frame = 1;

    /* report that the buffer was completely consumed */
    return buf_size;
}

// the below code fragment can be found in:
// libavcodec/aasc.c
static av_cold int aasc_decode_end(AVCodecContext *avctx)
{
    AascContext *s = avctx->priv_data;

    av_frame_free(&s->frame);

    return 0;
}

// the below code fragment can be found in:
// libavcodec/dvdec.c
static int dvvideo_decode_frame(AVCodecContext *avctx, AVFrame *frame,
                                int *got_frame, AVPacket *avpkt)
{
    uint8_t *buf = avpkt->data;
    int buf_size = avpkt->size;
    DVVideoContext *s = avctx->priv_data;
    const uint8_t *vsc_pack;
    int apt, is16_9, ret;
    const AVDVProfile *sys;

    sys = ff_dv_frame_profile(avctx, s->sys, buf, buf_size);
    if (!sys || buf_size < sys->frame_size) {
        av_log(avctx, AV_LOG_ERROR, "could not find dv frame profile\n");
        return -1; /* NOTE: we only accept several full frames */
    }

    if (sys != s->sys) {
        ret = ff_dv_init_dynamic_tables(s, sys);
        if (ret < 0) {
            av_log(avctx, AV_LOG_ERROR, "Error initializing the work tables.\n");
            return ret;
        }
        dv_init_weight_tables(s, sys);
        s->sys = sys;
    }

    s->frame            = frame;
    frame->key_frame    = 1;
    frame->pict_type    = AV_PICTURE_TYPE_I;
    avctx->pix_fmt      = s->sys->pix_fmt;
    avctx->framerate    = av_inv_q(s->sys->time_base);

    ret = ff_set_dimensions(avctx, s->sys->width, s->sys->height);
    if (ret < 0)
        return ret;

    /* Determine the codec's sample_aspect ratio from the packet */
    vsc_pack = buf + 80 * 5 + 48 + 5;
    if (*vsc_pack == dv_video_control) {
        apt    = buf[4] & 0x07;
        is16_9 = (vsc_pack[2] & 0x07) == 0x02 ||
                 (!apt && (vsc_pack[2] & 0x07) == 0x07);
        ff_set_sar(avctx, s->sys->sar[is16_9]);
    }

    if ((ret = ff_thread_get_buffer(avctx, frame, 0)) < 0)
        return ret;

    /* Determine the codec's field order from the packet */
    if ( *vsc_pack == dv_video_control ) {
        if (avctx->height == 720) {
            frame->interlaced_frame = 0;
            frame->top_field_first = 0;
        } else if (avctx->height == 1080) {
            frame->interlaced_frame = 1;
            frame->top_field_first = (vsc_pack[3] & 0x40) == 0x40;
        } else {
            frame->interlaced_frame = (vsc_pack[3] & 0x10) == 0x10;
            frame->top_field_first = !(vsc_pack[3] & 0x40);
        }
    }

    s->buf = buf;
    avctx->execute(avctx, dv_decode_video_segment, s->work_chunks, NULL,
                   dv_work_pool_size(s->sys), sizeof(DVwork_chunk));

    emms_c();

    /* return image */
    *got_frame = 1;

    return s->sys->frame_size;
}

