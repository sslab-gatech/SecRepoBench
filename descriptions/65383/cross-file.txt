// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// cram/cram_decode.c
// static int cram_decode_slice_xref(cram_slice *s, int required_fields) {
//     int rec;
// 
//     if (!(required_fields & (SAM_RNEXT | SAM_PNEXT | SAM_TLEN))) {
//         for (rec = 0; rec < s->hdr->num_records; rec++) {
//             cram_record *cr = &s->crecs[rec];
// 
//             cr->tlen = 0;
//             cr->mate_pos = 0;
//             cr->mate_ref_id = -1;
//         }
// 
//         return 0;
//     }
// 
//     for (rec = 0; rec < s->hdr->num_records; rec++) {
//         cram_record *cr = &s->crecs[rec];
// 
//         if (cr->mate_line >= 0) {
//             if (cr->mate_line < s->hdr->num_records) {
//                 /*
//                  * On the first read, loop through computing lengths.
//                  * It's not perfect as we have one slice per reference so we
//                  * cannot detect when TLEN should be zero due to seqs that
//                  * map to multiple references.
//                  *
//                  * We also cannot set tlen correct when it spans a slice for
//                  * other reasons. This may make tlen too small. Should we
//                  * fix this by forcing TLEN to be stored verbatim in such cases?
//                  *
//                  * Or do we just admit defeat and output 0 for tlen? It's the
//                  * safe option...
//                  */
//                 if (cr->tlen == INT64_MIN) {
//                     int id1 = rec, id2 = rec;
//                     int64_t aleft = cr->apos, aright = cr->aend;
//                     int64_t tlen;
//                     int ref = cr->ref_id;
// 
//                     // number of segments starting at the same point.
//                     int left_cnt = 0;
// 
//                     do {
//                         if (aleft > s->crecs[id2].apos)
//                             aleft = s->crecs[id2].apos, left_cnt = 1;
//                         else if (aleft == s->crecs[id2].apos)
//                             left_cnt++;
//                         if (aright < s->crecs[id2].aend)
//                             aright = s->crecs[id2].aend;
//                         if (s->crecs[id2].mate_line == -1) {
//                             s->crecs[id2].mate_line = rec;
//                             break;
//                         }
//                         if (s->crecs[id2].mate_line <= id2 ||
//                             s->crecs[id2].mate_line >= s->hdr->num_records)
//                             return -1;
//                         id2 = s->crecs[id2].mate_line;
// 
//                         if (s->crecs[id2].ref_id != ref)
//                             ref = -1;
//                     } while (id2 != id1);
// 
//                     if (ref != -1) {
//                         tlen = aright - aleft + 1;
//                         id1 = id2 = rec;
// 
//                         /*
//                          * When we have two seqs with identical start and
//                          * end coordinates, set +/- tlen based on 1st/last
//                          * bit flags instead, as a tie breaker.
//                          */
//                         if (s->crecs[id2].apos == aleft) {
//                             if (left_cnt == 1 ||
//                                 (s->crecs[id2].flags & BAM_FREAD1))
//                                 s->crecs[id2].tlen = tlen;
//                             else
//                                 s->crecs[id2].tlen = -tlen;
//                         } else {
//                             s->crecs[id2].tlen = -tlen;
//                         }
// 
//                         id2 = s->crecs[id2].mate_line;
//                         while (id2 != id1) {
//                             if (s->crecs[id2].apos == aleft) {
//                                 if (left_cnt == 1 ||
//                                     (s->crecs[id2].flags & BAM_FREAD1))
//                                     s->crecs[id2].tlen = tlen;
//                                 else
//                                     s->crecs[id2].tlen = -tlen;
//                             } else {
//                                 s->crecs[id2].tlen = -tlen;
//                             }
//                             id2 = s->crecs[id2].mate_line;
//                         }
//                     } else {
//                         id1 = id2 = rec;
// 
//                         s->crecs[id2].tlen = 0;
//                         id2 = s->crecs[id2].mate_line;
//                         while (id2 != id1) {
//                             s->crecs[id2].tlen = 0;
//                             id2 = s->crecs[id2].mate_line;
//                         }
//                     }
//                 }
// 
//                 cr->mate_pos = s->crecs[cr->mate_line].apos;
//                 cr->mate_ref_id = s->crecs[cr->mate_line].ref_id;
// 
//                 // paired
//                 cr->flags |= BAM_FPAIRED;
// 
//                 // set mate unmapped if needed
//                 if (s->crecs[cr->mate_line].flags & BAM_FUNMAP) {
//                     cr->flags |= BAM_FMUNMAP;
//                     cr->tlen = 0;
//                 }
//                 if (cr->flags & BAM_FUNMAP) {
//                     cr->tlen = 0;
//                 }
// 
//                 // set mate reversed if needed
//                 if (s->crecs[cr->mate_line].flags & BAM_FREVERSE)
//                     cr->flags |= BAM_FMREVERSE;
//             } else {
//                 hts_log_error("Mate line out of bounds: %d vs [0, %d]",
//                               cr->mate_line, s->hdr->num_records-1);
//             }
// 
//             /* FIXME: construct read names here too if needed */
//         } else {
//             if (cr->mate_flags & CRAM_M_REVERSE) {
//                 cr->flags |= BAM_FPAIRED | BAM_FMREVERSE;
//             }
//             if (cr->mate_flags & CRAM_M_UNMAP) {
//                 cr->flags |= BAM_FMUNMAP;
//                 //cr->mate_ref_id = -1;
//             }
//             if (!(cr->flags & BAM_FPAIRED))
//                 cr->mate_ref_id = -1;
//         }
// 
//         if (cr->tlen == INT64_MIN)
//             cr->tlen = 0; // Just incase
//     }
// 
//     for (rec = 0; rec < s->hdr->num_records; rec++) {
//         cram_record *cr = &s->crecs[rec];
//         if (cr->explicit_tlen != INT64_MIN)
//             cr->tlen = cr->explicit_tlen;
//     }
// 
//     return 0;
// }

// the below code fragment can be found in:
// cram/cram_encode.c
// static int cram_add_feature(cram_container *c, cram_slice *s,
//                             cram_record *r, cram_feature *f) {
//     if (s->nfeatures >= s->afeatures) {
//         s->afeatures = s->afeatures ? s->afeatures*2 : 1024;
//         s->features = realloc(s->features, s->afeatures*sizeof(*s->features));
//         if (!s->features)
//             return -1;
//     }
// 
//     if (!r->nfeature++) {
//         r->feature = s->nfeatures;
//         if (cram_stats_add(c->stats[DS_FP], f->X.pos) < 0)
//             return -1;
//     } else {
//         if (cram_stats_add(c->stats[DS_FP],
//                            f->X.pos - s->features[r->feature + r->nfeature-2].X.pos) < 0)
//             return -1;
// 
//     }
//     if (cram_stats_add(c->stats[DS_FC], f->X.code) < 0)
//         return -1;
// 
//     s->features[s->nfeatures++] = *f;
// 
//     return 0;
// }

// the below code fragment can be found in:
// cram/cram_encode.c
// static int expected_template_count(bam_seq_t *b) {
//     int expected = bam_flag(b) & BAM_FPAIRED ? 2 : 1;
// 
//     uint8_t *TC = (uint8_t *)bam_aux_get(b, "TC");
//     if (TC) {
//         int n = bam_aux2i_end(TC, (uint8_t *)bam_data_end(b));
//         if (expected < n)
//             expected = n;
//     }
// 
//     if (!TC && bam_aux_get(b, "SA")) {
//         // We could count the semicolons, but we'd have to do this for
//         // read1, read2 and read(not-1-or-2) combining the results
//         // together.  This is a cheap and safe alternative for now.
//         expected = INT_MAX;
//     }
// 
//     return expected;
// }

// the below code fragment can be found in:
// cram/cram_decode.c
// static int cram_decode_aux(cram_fd *fd,
//                            cram_container *c, cram_slice *s,
//                            cram_block *blk, cram_record *cr,
//                            int *has_MD, int *has_NM) {
//     int i, r = 0, out_sz = 1;
//     int32_t TL = 0;
//     unsigned char *TN;
//     uint32_t ds = s->data_series;
// 
//     if (!(ds & (CRAM_TL|CRAM_aux))) {
//         cr->aux = 0;
//         cr->aux_size = 0;
//         return 0;
//     }
// 
//     if (!c->comp_hdr->codecs[DS_TL]) return -1;
//     r |= c->comp_hdr->codecs[DS_TL]->decode(s, c->comp_hdr->codecs[DS_TL], blk,
//                                             (char *)&TL, &out_sz);
//     if (r || TL < 0 || TL >= c->comp_hdr->nTL)
//         return -1;
// 
//     TN = c->comp_hdr->TL[TL];
//     cr->ntags = strlen((char *)TN)/3; // optimise to remove strlen
// 
//     //printf("TC=%d\n", cr->ntags);
//     cr->aux_size = 0;
//     cr->aux = BLOCK_SIZE(s->aux_blk);
// 
//     if (!(ds & CRAM_aux))
//         return 0;
// 
//     for (i = 0; i < cr->ntags; i++) {
//         int32_t id, out_sz = 1;
//         unsigned char tag_data[7];
//         cram_map *m;
// 
//         if (TN[0] == 'M' && TN[1] == 'D' && has_MD)
//             *has_MD = (BLOCK_SIZE(s->aux_blk)+3) * (TN[2] == '*' ? -1 : 1);
//         if (TN[0] == 'N' && TN[1] == 'M' && has_NM)
//             *has_NM = (BLOCK_SIZE(s->aux_blk)+3) * (TN[2] == '*' ? -1 : 1);;
// 
//         //printf("Tag %d/%d\n", i+1, cr->ntags);
//         tag_data[0] = TN[0];
//         tag_data[1] = TN[1];
//         tag_data[2] = TN[2];
//         id = (tag_data[0]<<16) | (tag_data[1]<<8) | tag_data[2];
// 
//         if (CRAM_MAJOR_VERS(fd->version) >= 4 && TN[2] == '*') {
//             // Place holder, fill out contents later.
//             int tag_data_size;
//             if (TN[0] == 'N' && TN[1] == 'M') {
//                 // Use a fixed size, so we can allocate room for it now.
//                 memcpy(&tag_data[2], "I\0\0\0\0", 5);
//                 tag_data_size = 7;
//             } else if (TN[0] == 'R' && TN[1] == 'G') {
//                 // RG is variable size, but known already.  Insert now
//                 TN += 3;
//                 // Equiv to fd->header->hrecs->rg[cr->rg], but this is the
//                 // new header API equivalent.
//                 const char *rg = sam_hdr_line_name(fd->header, "RG", cr->rg);
//                 if (!rg)
//                     continue;
// 
//                 size_t rg_len = strlen(rg);
//                 tag_data[2] = 'Z';
//                 BLOCK_APPEND(s->aux_blk, (char *)tag_data, 3);
//                 BLOCK_APPEND(s->aux_blk, rg, rg_len);
//                 BLOCK_APPEND_CHAR(s->aux_blk, '\0');
//                 cr->aux_size += 3 + rg_len + 1;
//                 cr->rg = -1; // prevents auto-add later
//                 continue;
//             } else {
//                 // Unknown size.  We'll insert MD into stream later.
//                 tag_data[2] = 'Z';
//                 tag_data_size = 3;
//             }
//             BLOCK_APPEND(s->aux_blk, (char *)tag_data, tag_data_size);
//             cr->aux_size += tag_data_size;
//             TN += 3;
//         } else {
//             TN += 3;
//             m = map_find(c->comp_hdr->tag_encoding_map, tag_data, id);
//             if (!m)
//                 return -1;
// 
//             BLOCK_APPEND(s->aux_blk, (char *)tag_data, 3);
// 
//             if (!m->codec) return -1;
//             r |= m->codec->decode(s, m->codec, blk, (char *)s->aux_blk, &out_sz);
//             if (r) break;
//             cr->aux_size += out_sz + 3;
// 
//             // cF CRAM flags.
//             if (TN[-3]=='c' && TN[-2]=='F' && TN[-1]=='C' && out_sz == 1) {
//                 // Remove cF tag
//                 uint8_t cF = BLOCK_END(s->aux_blk)[-1];
//                 BLOCK_SIZE(s->aux_blk) -= out_sz+3;
//                 cr->aux_size -= out_sz+3;
// 
//                 // bit 1 => don't auto-decode MD.
//                 // Pretend MD is present verbatim, so we don't auto-generate
//                 if ((cF & 1) && has_MD && *has_MD == 0)
//                     *has_MD = 1;
// 
//                 // bit 1 => don't auto-decode NM
//                 if ((cF & 2) && has_NM && *has_NM == 0)
//                     *has_NM = 1;
//             }
//         }
// 
//         // We could go to 2^32 fine, but we shouldn't be hitting this anyway,
//         // and it's protecting against memory hogs too.
//         if (BLOCK_SIZE(s->aux_blk) > (1u<<31)) {
//             hts_log_error("CRAM->BAM aux block size overflow");
//             goto block_err;
//         }
//     }
// 
//     return r;
// 
//  block_err:
//     return -1;
// }

// the below code fragment can be found in:
// cram/cram_decode.c
// static cram_container *cram_first_slice(cram_fd *fd) {
//     cram_container *c;
// 
//     do {
//         if (fd->ctr)
//             cram_free_container(fd->ctr);
// 
//         if (!(c = fd->ctr = cram_read_container(fd)))
//             return NULL;
//         c->curr_slice_mt = c->curr_slice;
//     } while (c->length == 0);
// 
//     /*
//      * The first container may be a result of a sub-range query.
//      * In which case it may still not be the optimal starting point
//      * due to skipped containers/slices in the index.
//      */
//     // No need for locks here as we're in the main thread.
//     if (fd->range.refid != -2) {
//         while (c->ref_seq_id != -2 &&
//                (c->ref_seq_id < fd->range.refid ||
//                 (fd->range.refid >= 0 && c->ref_seq_id == fd->range.refid
//                  && c->ref_seq_start + c->ref_seq_span-1 < fd->range.start))) {
//             if (0 != cram_seek(fd, c->length, SEEK_CUR))
//                 return NULL;
//             cram_free_container(fd->ctr);
//             do {
//                 if (!(c = fd->ctr = cram_read_container(fd)))
//                     return NULL;
//             } while (c->length == 0);
//         }
// 
//         if (c->ref_seq_id != -2 && c->ref_seq_id != fd->range.refid) {
//             fd->eof = 1;
//             return NULL;
//         }
//     }
// 
//     if (!(c->comp_hdr_block = cram_read_block(fd)))
//         return NULL;
//     if (c->comp_hdr_block->content_type != COMPRESSION_HEADER)
//         return NULL;
// 
//     c->comp_hdr = cram_decode_compression_header(fd, c->comp_hdr_block);
//     if (!c->comp_hdr)
//         return NULL;
//     if (!c->comp_hdr->AP_delta &&
//         sam_hrecs_sort_order(fd->header->hrecs) != ORDER_COORD) {
//         pthread_mutex_lock(&fd->ref_lock);
//         fd->unsorted = 1;
//         pthread_mutex_unlock(&fd->ref_lock);
//     }
// 
//     return c;
// }

