#ifndef OT_GLYF_GLYF_HH
#define OT_GLYF_GLYF_HH


#include "../../hb-open-type.hh"
#include "../../hb-ot-head-table.hh"
#include "../../hb-ot-hmtx-table.hh"
#include "../../hb-ot-var-gvar-table.hh"
#include "../../hb-draw.hh"
#include "../../hb-paint.hh"

#include "glyf-helpers.hh"
#include "Glyph.hh"
#include "SubsetGlyph.hh"
#include "loca.hh"
#include "path-builder.hh"


namespace OT {


/*
 * glyf -- TrueType Glyph Data
 * https://docs.microsoft.com/en-us/typography/opentype/spec/glyf
 */
#define HB_OT_TAG_glyf HB_TAG('g','l','y','f')

struct glyf
{
  friend struct glyf_accelerator_t;

  static constexpr hb_tag_t tableTag = HB_OT_TAG_glyf;

  static bool has_valid_glyf_format(const hb_face_t* face)
  {
    const OT::head &head = *face->table.head;
    return head.indexToLocFormat <= 1 && head.glyphDataFormat <= 1;
  }

  bool sanitize (hb_sanitize_context_t *c HB_UNUSED) const
  {
    TRACE_SANITIZE (this);
    /* Runtime checks as eager sanitizing each glyph is costy */
    return_trace (true);
  }

  /* requires source of SubsetGlyph complains the identifier isn't declared */
  template <typename Iterator>
  bool serialize (hb_serialize_context_t *c,
		  Iterator it,
                  bool use_short_loc

// --- CODE TRUNCATED HERE ---

bool subset (hb_subset_context_t *context) const
  {
    TRACE_SUBSET (this);

    if (!has_valid_glyf_format (context->plan->source)) {
      // glyf format is unknown don't attempt to subset it.
      DEBUG_MSG (SUBSET, nullptr,
                 "unkown glyf format, dropping from subset.");
      return_trace (false);
    }

    hb_font_t *font = nullptr;
    if (context->plan->normalized_coords)
    {
      font = _create_font_for_instancing (context->plan);
      if (unlikely (!font))
	return_trace (false);
    }

    // Generate a subset of glyphs based on the provided plan and font.
    // Populate a list of subset glyphs, checking for failure in the process.
    // Destroy the font if it was created for instancing, after using it.
    // Calculate padded offsets for each subset glyph and determine if a short loca table can be used.
    // Initialize a new glyf object for serialization.
    // Serialize the subset of glyphs into the glyf object, using the determined loca format.
    // Handle any necessary cleanup of resources, particularly the compiled subset glyphs, if required.
    // Return the result of the serialization process as the function's output.
    // <MASK>

    return result;
  }