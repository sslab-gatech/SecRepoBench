// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/OT/glyf/glyf.hh
inline hb_font_t *
glyf::_create_font_for_instancing (const hb_subset_plan_t *plan) const
{
  hb_font_t *font = hb_font_create (plan->source);
  if (unlikely (font == hb_font_get_empty ())) return nullptr;

  hb_vector_t<hb_variation_t> vars;
  if (unlikely (!vars.alloc (plan->user_axes_location.get_population (), true)))
  {
    hb_font_destroy (font);
    return nullptr;
  }

  for (auto _ : plan->user_axes_location)
  {
    hb_variation_t var;
    var.tag = _.first;
    var.value = _.second.middle;
    vars.push (var);
  }

#ifndef HB_NO_VAR
  hb_font_set_variations (font, vars.arrayZ, plan->user_axes_location.get_population ());
#endif
  return font;
}

// the below code fragment can be found in:
// src/hb-subset.cc
static bool
_is_table_present (hb_face_t *source, hb_tag_t tag)
{

  if (!hb_face_get_table_tags (source, 0, nullptr, nullptr)) {
    // If face has 0 tables associated with it, assume that it was built from
    // hb_face_create_tables and thus is unable to list its tables. Fallback to
    // checking if the blob associated with tag is empty.
    return !_table_is_empty (source, tag);
  }

  hb_tag_t table_tags[32];
  unsigned offset = 0, num_tables = ARRAY_LENGTH (table_tags);
  while (((void) hb_face_get_table_tags (source, offset, &num_tables, table_tags), num_tables))
  {
    for (unsigned i = 0; i < num_tables; ++i)
      if (table_tags[i] == tag)
	return true;
    offset += num_tables;
  }
  return false;
}

// the below code fragment can be found in:
// src/hb-ot-post-table.hh
bool subset (hb_subset_context_t *c) const
  {
    TRACE_SUBSET (this);
    post *post_prime = c->serializer->start_embed<post> ();
    if (unlikely (!post_prime)) return_trace (false);

    bool glyph_names = c->plan->flags & HB_SUBSET_FLAGS_GLYPH_NAMES;
    if (!serialize (c->serializer, glyph_names))
      return_trace (false);

#ifndef HB_NO_VAR
    if (c->plan->normalized_coords)
    {
      auto &MVAR = *c->plan->source->table.MVAR;
      auto *table = post_prime;

      HB_ADD_MVAR_VAR (HB_OT_METRICS_TAG_UNDERLINE_SIZE,   underlineThickness);
      HB_ADD_MVAR_VAR (HB_OT_METRICS_TAG_UNDERLINE_OFFSET, underlinePosition);
    }
#endif

    if (c->plan->user_axes_location.has (HB_TAG ('s','l','n','t')) &&
        !c->plan->pinned_at_default)
    {
      float italic_angle = c->plan->user_axes_location.get (HB_TAG ('s','l','n','t')).middle;
      italic_angle = hb_max (-90.f, hb_min (italic_angle, 90.f));
      post_prime->italicAngle.set_float (italic_angle);
    }

    if (glyph_names && version.major == 2)
      return_trace (v2X.subset (c));

    return_trace (true);
  }

// the below code fragment can be found in:
// src/OT/glyf/SubsetGlyph.hh
void free_compiled_bytes ()
  {
    if (likely (allocated)) {
      allocated = false;
      dest_start.fini ();
      dest_end.fini ();
    }
  }

// the below code fragment can be found in:
// src/hb-ot-head-table.hh
bool is_bold () const      { return macStyle & BOLD; }

