// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// code/AssetLib/FBX/FBXParser.cpp
// Element::~Element()
// {
//     if (compound) {
//         delete_Scope(compound);
//     }
// 
//      // no need to delete tokens, they are owned by the parser
// }

// the below code fragment can be found in:
// code/AssetLib/FBX/FBXParser.h
// namespace FBX {
// 
// class Scope;
// class Parser;
// class Element;
// 
// // XXX should use C++11's unique_ptr - but assimp's need to keep working with 03
// using ScopeList = std::vector<Scope*>;
// using ElementMap = std::fbx_unordered_multimap< std::string, Element*>;
// using ElementCollection = std::pair<ElementMap::const_iterator,ElementMap::const_iterator>;
// 
// #define new_Scope new (allocator.Allocate(sizeof(Scope))) Scope
// #define new_Element new (allocator.Allocate(sizeof(Element))) Element
// #define delete_Scope(_p) (_p)->~Scope()
// #define delete_Element(_p) (_p)->~Element()
// 
// /** FBX data entity that consists of a key:value tuple.
//  *
//  *  Example:
//  *  @verbatim
//  *    AnimationCurve: 23, "AnimCurve::", "" {
//  *        [..]
//  *    }
//  *  @endverbatim
//  *
//  *  As can be seen in this sample, elements can contain nested #Scope
//  *  as their trailing member.  
// **/
// class Element
// {
// public:
//     Element(const Token& key_token, Parser& parser);
//     ~Element();
// 
//     const Scope* Compound() const {
//         return compound;
//     }
// 
//     const Token& KeyToken() const {
//         return key_token;
//     }
// 
//     const TokenList& Tokens() const {
//         return tokens;
//     }
// 
// private:
//     const Token& key_token;
//     TokenList tokens;
//     Scope* compound;
// };
// 
// /** FBX data entity that consists of a 'scope', a collection
//  *  of not necessarily unique #Element instances.
//  *
//  *  Example:
//  *  @verbatim
//  *    GlobalSettings:  {
//  *        Version: 1000
//  *        Properties70:
//  *        [...]
//  *    }
//  *  @endverbatim  */
// class Scope
// {
// public:
//     Scope(Parser& parser, bool topLevel = false);
//     ~Scope();
// 
//     const Element* operator[] (const std::string& index) const {
//         ElementMap::const_iterator it = elements.find(index);
//         return it == elements.end() ? nullptr : (*it).second;
//     }
// 
// 	const Element* FindElementCaseInsensitive(const std::string& elementName) const {
// 		const char* elementNameCStr = elementName.c_str();
// 		for (auto element = elements.begin(); element != elements.end(); ++element)
// 		{
// 			if (!ASSIMP_strincmp(element->first.c_str(), elementNameCStr, MAXLEN)) {
// 				return element->second;
// 			}
// 		}
//         return nullptr;
// 	}
// 
//     ElementCollection GetCollection(const std::string& index) const {
//         return elements.equal_range(index);
//     }
// 
//     const ElementMap& Elements() const  {
//         return elements;
//     }
// 
// private:
//     ElementMap elements;
// };
// 
// /** FBX parsing class, takes a list of input tokens and generates a hierarchy
//  *  of nested #Scope instances, representing the fbx DOM.*/
// class Parser
// {
// public:
//     /** Parse given a token list. Does not take ownership of the tokens -
//      *  the objects must persist during the entire parser lifetime */
//     Parser(const TokenList &tokens, StackAllocator &allocator, bool is_binary);
//     ~Parser();
// 
//     const Scope& GetRootScope() const {
//         return *root;
//     }
// 
//     bool IsBinary() const {
//         return is_binary;
//     }
// 
//     StackAllocator &GetAllocator() {
//         return allocator;
//     }
// 
// private:
//     friend class Scope;
//     friend class Element;
// 
//     TokenPtr AdvanceToNextToken();
//     TokenPtr LastToken() const;
//     TokenPtr CurrentToken() const;
// 
// private:
//     const TokenList& tokens;
//     StackAllocator &allocator;
//     TokenPtr last, current;
//     TokenList::const_iterator cursor;
//     Scope *root;
// 
//     const bool is_binary;
// };
// 
// 
// /* token parsing - this happens when building the DOM out of the parse-tree*/
// uint64_t ParseTokenAsID(const Token& t, const char*& err_out);
// size_t ParseTokenAsDim(const Token& t, const char*& err_out);
// 
// float ParseTokenAsFloat(const Token& t, const char*& err_out);
// int ParseTokenAsInt(const Token& t, const char*& err_out);
// int64_t ParseTokenAsInt64(const Token& t, const char*& err_out);
// std::string ParseTokenAsString(const Token& t, const char*& err_out);
// 
// /* wrapper around ParseTokenAsXXX() with DOMError handling */
// uint64_t ParseTokenAsID(const Token& t);
// size_t ParseTokenAsDim(const Token& t);
// float ParseTokenAsFloat(const Token& t);
// int ParseTokenAsInt(const Token& t);
// int64_t ParseTokenAsInt64(const Token& t);
// std::string ParseTokenAsString(const Token& t);
// 
// /* read data arrays */
// void ParseVectorDataArray(std::vector<aiVector3D>& out, const Element& el);
// void ParseVectorDataArray(std::vector<aiColor4D>& out, const Element& el);
// void ParseVectorDataArray(std::vector<aiVector2D>& out, const Element& el);
// void ParseVectorDataArray(std::vector<int>& out, const Element& el);
// void ParseVectorDataArray(std::vector<float>& out, const Element& el);
// void ParseVectorDataArray(std::vector<unsigned int>& out, const Element& el);
// void ParseVectorDataArray(std::vector<uint64_t>& out, const Element& e);
// void ParseVectorDataArray(std::vector<int64_t>& out, const Element& el);
// 
// bool HasElement( const Scope& sc, const std::string& index );
// 
// // extract a required element from a scope, abort if the element cannot be found
// const Element &GetRequiredElement(const Scope &sc, const std::string &index, const Element *element = nullptr);
// 
// // extract required compound scope
// const Scope& GetRequiredScope(const Element& el);
// // get token at a particular index
// const Token& GetRequiredToken(const Element& el, unsigned int index);
// 
// // read a 4x4 matrix from an array of 16 floats
// aiMatrix4x4 ReadMatrix(const Element& element);
// 
// } // ! FBX
// }

// the below code fragment can be found in:
// code/AssetLib/FBX/FBXParser.cpp
// T SafeParse(const char* data, const char* end) {
//         // Actual size validation happens during Tokenization so
//         // this is valid as an assertion.
//         (void)(end);
//         ai_assert(static_cast<size_t>(end - data) >= sizeof(T));
//         T result = static_cast<T>(0);
//         ::memcpy(&result, data, sizeof(T));
//         return result;
//     }

// the below code fragment can be found in:
// code/AssetLib/FBX/FBXDocument.cpp
// void Document::ReadPropertyTemplates() {
//     const Scope& sc = parser.GetRootScope();
//     // read property templates from "Definitions" section
//     const Element* const edefs = sc["Definitions"];
//     if(!edefs || !edefs->Compound()) {
//         DOMWarning("no Definitions dictionary found");
//         return;
//     }
// 
//     const Scope& sdefs = *edefs->Compound();
//     const ElementCollection otypes = sdefs.GetCollection("ObjectType");
//     for(ElementMap::const_iterator it = otypes.first; it != otypes.second; ++it) {
//         const Element& el = *(*it).second;
//         const Scope* curSc = el.Compound();
//         if (!curSc) {
//             DOMWarning("expected nested scope in ObjectType, ignoring",&el);
//             continue;
//         }
// 
//         const TokenList& tok = el.Tokens();
//         if(tok.empty()) {
//             DOMWarning("expected name for ObjectType element, ignoring",&el);
//             continue;
//         }
// 
//         const std::string& oname = ParseTokenAsString(*tok[0]);
// 
//         const ElementCollection templs = curSc->GetCollection("PropertyTemplate");
//         for (ElementMap::const_iterator elemIt = templs.first; elemIt != templs.second; ++elemIt) {
//             const Element &innerEl = *(*elemIt).second;
//             const Scope *innerSc = innerEl.Compound();
//             if (!innerSc) {
//                 DOMWarning("expected nested scope in PropertyTemplate, ignoring",&el);
//                 continue;
//             }
// 
//             const TokenList &curTok = innerEl.Tokens();
//             if (curTok.empty()) {
//                 DOMWarning("expected name for PropertyTemplate element, ignoring",&el);
//                 continue;
//             }
// 
//             const std::string &pname = ParseTokenAsString(*curTok[0]);
// 
//             const Element *Properties70 = (*innerSc)["Properties70"];
//             if(Properties70) {
//                 std::shared_ptr<const PropertyTable> props = std::make_shared<const PropertyTable>(
//                         *Properties70, std::shared_ptr<const PropertyTable>(static_cast<const PropertyTable *>(nullptr))
//                 );
// 
//                 templates[oname+"."+pname] = props;
//             }
//         }
//     }
// }

// the below code fragment can be found in:
// code/AssetLib/FBX/FBXParser.cpp
// void ParseVectorDataArray(std::vector<aiColor4D>& out, const Element& el)
// {
//     out.resize( 0 );
//     const TokenList& tok = el.Tokens();
//     if(tok.empty()) {
//         ParseError("unexpected empty element",&el);
//     }
// 
//     if(tok[0]->IsBinary()) {
//         const char* data = tok[0]->begin(), *end = tok[0]->end();
// 
//         char type;
//         uint32_t count;
//         ReadBinaryDataArrayHead(data, end, type, count, el);
// 
//         if(count % 4 != 0) {
//             ParseError("number of floats is not a multiple of four (4) (binary)",&el);
//         }
// 
//         if(!count) {
//             return;
//         }
// 
//         if (type != 'd' && type != 'f') {
//             ParseError("expected float or double array (binary)",&el);
//         }
// 
//         std::vector<char> buff;
//         ReadBinaryDataArray(type, count, data, end, buff, el);
// 
//         ai_assert(data == end);
//         uint64_t dataToRead = static_cast<uint64_t>(count) * (type == 'd' ? 8 : 4);
//         if (dataToRead != buff.size()) {
//             ParseError("Invalid read size (binary)",&el);
//         }
// 
//         const uint32_t count4 = count / 4;
//         out.reserve(count4);
// 
//         if (type == 'd') {
//             const double* d = reinterpret_cast<const double*>(&buff[0]);
//             for (unsigned int i = 0; i < count4; ++i, d += 4) {
//                 out.emplace_back(static_cast<float>(d[0]),
//                     static_cast<float>(d[1]),
//                     static_cast<float>(d[2]),
//                     static_cast<float>(d[3]));
//             }
//         }
//         else if (type == 'f') {
//             const float* f = reinterpret_cast<const float*>(&buff[0]);
//             for (unsigned int i = 0; i < count4; ++i, f += 4) {
//                 out.emplace_back(f[0],f[1],f[2],f[3]);
//             }
//         }
//         return;
//     }
// 
//     const size_t dim = ParseTokenAsDim(*tok[0]);
// 
//     //  see notes in ParseVectorDataArray() above
//     out.reserve(dim);
// 
//     const Scope& scope = GetRequiredScope(el);
//     const Element& a = GetRequiredElement(scope,"a",&el);
// 
//     if (a.Tokens().size() % 4 != 0) {
//         ParseError("number of floats is not a multiple of four (4)",&el);
//     }
//     for (TokenList::const_iterator it = a.Tokens().begin(), end = a.Tokens().end(); it != end; ) {
//         aiColor4D v;
//         v.r = ParseTokenAsFloat(**it++);
//         v.g = ParseTokenAsFloat(**it++);
//         v.b = ParseTokenAsFloat(**it++);
//         v.a = ParseTokenAsFloat(**it++);
// 
//         out.push_back(v);
//     }
// }

