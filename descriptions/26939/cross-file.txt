// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// MagickCore/profile.c
// MagickExport MagickBooleanType SetImageProfile(Image *image,const char *name,
//   const StringInfo *profile,ExceptionInfo *exception)
// {
//   return(SetImageProfileInternal(image,name,profile,MagickFalse,exception));
// }

// the below code fragment can be found in:
// coders/heic.c
// static struct heif_error heif_write_func(struct heif_context *context,
//   const void* data,size_t size,void* userdata)
// {
//   Image
//     *image;
// 
//   struct heif_error
//     error_ok;
// 
//   (void) context;
//   image=(Image*) userdata;
//   (void) WriteBlob(image,size,(const unsigned char *) data);
//   error_ok.code=heif_error_Ok;
//   error_ok.subcode=heif_suberror_Unspecified;
//   error_ok.message="ok";
//   return(error_ok);
// }

// the below code fragment can be found in:
// MagickCore/profile.c
// MagickExport char *GetNextImageProfile(const Image *image)
// {
//   assert(image != (Image *) NULL);
//   assert(image->signature == MagickCoreSignature);
//   if (image->debug != MagickFalse)
//     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
//   if (image->profiles == (SplayTreeInfo *) NULL)
//     return((char *) NULL);
//   return((char *) GetNextKeyInSplayTree((SplayTreeInfo *) image->profiles));
// }

// the below code fragment can be found in:
// coders/tiff.c
// static void TIFFSetProperties(TIFF *tiff,const MagickBooleanType adjoin,
//   Image *image,ExceptionInfo *exception)
// {
//   const char
//     *value;
// 
//   value=GetImageArtifact(image,"tiff:document");
//   if (value != (const char *) NULL)
//     (void) TIFFSetField(tiff,TIFFTAG_DOCUMENTNAME,value);
//   value=GetImageArtifact(image,"tiff:hostcomputer");
//   if (value != (const char *) NULL)
//     (void) TIFFSetField(tiff,TIFFTAG_HOSTCOMPUTER,value);
//   value=GetImageArtifact(image,"tiff:artist");
//   if (value != (const char *) NULL)
//     (void) TIFFSetField(tiff,TIFFTAG_ARTIST,value);
//   value=GetImageArtifact(image,"tiff:timestamp");
//   if (value != (const char *) NULL)
//     (void) TIFFSetField(tiff,TIFFTAG_DATETIME,value);
//   value=GetImageArtifact(image,"tiff:make");
//   if (value != (const char *) NULL)
//     (void) TIFFSetField(tiff,TIFFTAG_MAKE,value);
//   value=GetImageArtifact(image,"tiff:model");
//   if (value != (const char *) NULL)
//     (void) TIFFSetField(tiff,TIFFTAG_MODEL,value);
//   value=GetImageArtifact(image,"tiff:software");
//   if (value != (const char *) NULL)
//     (void) TIFFSetField(tiff,TIFFTAG_SOFTWARE,value);
//   value=GetImageArtifact(image,"tiff:copyright");
//   if (value != (const char *) NULL)
//     (void) TIFFSetField(tiff,TIFFTAG_COPYRIGHT,value);
//   value=GetImageArtifact(image,"kodak-33423");
//   if (value != (const char *) NULL)
//     (void) TIFFSetField(tiff,33423,value);
//   value=GetImageArtifact(image,"kodak-36867");
//   if (value != (const char *) NULL)
//     (void) TIFFSetField(tiff,36867,value);
//   value=GetImageProperty(image,"label",exception);
//   if (value != (const char *) NULL)
//     (void) TIFFSetField(tiff,TIFFTAG_PAGENAME,value);
//   value=GetImageProperty(image,"comment",exception);
//   if (value != (const char *) NULL)
//     (void) TIFFSetField(tiff,TIFFTAG_IMAGEDESCRIPTION,value);
//   value=GetImageArtifact(image,"tiff:subfiletype");
//   if (value != (const char *) NULL)
//     {
//       if (LocaleCompare(value,"REDUCEDIMAGE") == 0)
//         (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_REDUCEDIMAGE);
//       else
//         if (LocaleCompare(value,"PAGE") == 0)
//           (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);
//         else
//           if (LocaleCompare(value,"MASK") == 0)
//             (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_MASK);
//     }
//   else
//     {
//       uint16
//         page,
//         pages;
// 
//       page=(uint16) image->scene;
//       pages=(uint16) GetImageListLength(image);
//       if ((adjoin != MagickFalse) && (pages > 1))
//         (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);
//       (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,page,pages);
//     }
// }

// the below code fragment can be found in:
// MagickWand/magick-property.c
// WandExport char **MagickGetImageProfiles(MagickWand *wand,const char *pattern,
//   size_t *number_profiles)
// {
//   char
//     **profiles;
// 
//   const char
//     *property;
// 
//   register ssize_t
//     i;
// 
//   size_t
//     length;
// 
//   assert(wand != (MagickWand *) NULL);
//   assert(wand->signature == MagickWandSignature);
//   if (wand->debug != MagickFalse)
//     (void) LogMagickEvent(WandEvent,GetMagickModule(),"%s",wand->name);
//   if (wand->images == (Image *) NULL)
//     {
//       (void) ThrowMagickException(wand->exception,GetMagickModule(),WandError,
//         "ContainsNoImages","`%s'",wand->name);
//       return((char **) NULL);
//     }
//   (void) GetImageProfile(wand->images,"exif:*");
//   length=1024;
//   profiles=(char **) AcquireQuantumMemory(length,sizeof(*profiles));
//   if (profiles == (char **) NULL)
//     return((char **) NULL);
//   ResetImageProfileIterator(wand->images);
//   property=GetNextImageProfile(wand->images);
//   for (i=0; property != (const char *) NULL; )
//   {
//     if ((*property != '[') &&
//         (GlobExpression(property,pattern,MagickFalse) != MagickFalse))
//       {
//         if ((i+1) >= (ssize_t) length)
//           {
//             length<<=1;
//             profiles=(char **) ResizeQuantumMemory(profiles,length,
//               sizeof(*profiles));
//             if (profiles == (char **) NULL)
//               {
//                 (void) ThrowMagickException(wand->exception,GetMagickModule(),
//                   ResourceLimitError,"MemoryAllocationFailed","`%s'",
//                   wand->name);
//                 return((char **) NULL);
//               }
//           }
//         profiles[i]=ConstantString(property);
//         i++;
//       }
//     property=GetNextImageProfile(wand->images);
//   }
//   profiles[i]=(char *) NULL;
//   *number_profiles=(size_t) i;
//   return(profiles);
// }

