<｜begin▁of▁sentence｜>/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%                                 FFFFF  X   X                                %
%                                 F       X X                                 %
%                                 FFF      X                                  %
%                                 F       X X                                 %
%                                 F      X   X                                %
%                                                                             %
%                                                                             %
%                   MagickCore Image Special Effects Methods                  %
%                                                                             %
%                               Software Design                               %
%                             snibgo (Alan Gibson)                            %
%                                 January 2022                                %
%                                                                             %
%                                                                             %
%                                                                             %
%  Copyright 1999-2022 ImageMagick Studio LLC, a non-profit organization      %
%  dedicated to making software imaging solutions freely available.           %
%                                                                             %
%  You may not use this file except in compliance with the License.  You may  %
%  obtain a copy of the License at                                            %
%                                                                             %
%    https://imagemagick.org/script/license.php                               %
%                                                                             %
%  Unless required by applicable law or agreed to in writing, software        %
%  distributed under the License is distributed on an "AS IS" BASIS,          %
%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %
%  See the License for the specific language governing permissions and        %
%  limitations under the License.                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
%
*/

/*
  Include declarations.
*/
#include "MagickCore/studio.h"
#include "MagickCore/accelerate-private.h"
#include "MagickCore/annotate.h"
#include "MagickCore/artifact.h"
#include "MagickCore/attribute.h"
#include "MagickCore/cache.h"
#include "MagickCore/cache-view.h"
#include "MagickCore/channel.h"
#include "MagickCore/color.h"
#include "MagickCore/color-private.h"
#include "MagickCore/colorspace-private.h"
#include "MagickCore/composite.h"
#include "MagickCore/decorate.h"
#include "MagickCore/distort.h"
#include "MagickCore/draw.h"
#include "MagickCore/effect.h"
#include "MagickCore/enhance.h"
#include "MagickCore/exception.h"
#include "MagickCore/exception-private.h"
#include "MagickCore/fx.h"
#include "MagickCore/fx-private.h"
#include "MagickCore/gem.h"
#include "MagickCore/gem-private.h"
#include "MagickCore/geometry.h"
#include "MagickCore/layer.h"
#include "MagickCore/list.h"
#include "MagickCore/log.h"
#include "MagickCore/image.h"
#include "MagickCore/image-private.h"
#include "MagickCore/magick.h"
#include "MagickCore/memory_.h"
#include "MagickCore/memory-private.h"
#include "MagickCore/monitor.h"
#include "MagickCore/monitor-private.h"
#include "MagickCore/option.h"
#include "MagickCore/pixel.h"
#include "MagickCore/pixel-accessor.h"
#include "MagickCore/property.h"
#include "MagickCore/quantum.h"
#include "MagickCore/quantum-private.h"
#include "MagickCore/random_.h"
#include "MagickCore/random-private.h"
#include "MagickCore/resample.h"
#include "MagickCore/resample-private.h"
#include "MagickCore/resize.h"
#include "MagickCore/resource_.h"
#include "MagickCore/splay-tree.h"
#include "MagickCore/statistic.h"
#include "MagickCore/string_.h"
#include "MagickCore/thread-private.h"
#include "MagickCore/threshold.h"
#include "MagickCore/token.h"
#include "MagickCore/transform.h"
#include "MagickCore/transform-private.h"
#include "MagickCore/utility.h"


#define MaxTokenLen 100
#define RpnInit 100
#define TableExtend 0.1
#define InitNumOprStack 50
#define MinValStackSize 100
#define InitNumUserSymbols 50

typedef long double fxFltType;

typedef enum {
  oAddEq,
  oSubtractEq,
  oMultiplyEq,
  oDivideEq,
  oPlusPlus,
  oSubSub,
  oAdd,
  oSubtract,
  oMultiply,
  oDivide,
  oModulus,
  oUnaryPlus,
  oUnaryMinus,
  oLshift,
  oRshift,
  oEq,
  oNotEq,
  oLtEq,
  oGtEq,
  oLt,
  oGt,
  oLogAnd,
  oLogOr,
  oLogNot,
  oBitAnd,
  oBitOr,
  oBitNot,
  oPow,
  oQuery,
  oColon,
  oOpenParen,
  oCloseParen,
  oOpenBracket,
  oCloseBracket,
  oOpenBrace,
  oCloseBrace,
  oAssign,
  oNull
} OperatorE;

typedef struct {
  OperatorE op;
  const char * str;
  int precedence; /* Higher number is higher precedence */
  int nArgs;
} OperatorT;

static const OperatorT Operators[] = {
  {oAddEq,       "+=",    12, 1},
  {oSubtractEq,  "-=",    12, 1},
  {oMultiplyEq,  "*=",    13, 1},
  {oDivideEq,    "/=",    13, 1},
  {oPlusPlus,    "++",    12, 0},
  {oSubSub,      "--",    12, 0},
  {oAdd,         "+",     12, 2},
  {oSubtract,    "-",     12, 2},
  {oMultiply,    "*",     13, 2},
  {oDivide,      "/",     13, 2},
  {oModulus,     "%",     13, 2},
  {oUnaryPlus,   "+",     14, 1},
  {oUnaryMinus,  "-",     14, 1},
  {oLshift,      "<<",    11, 2},
  {oRshift,      ">>",    11, 2},
  {oEq,          "==",     9, 2},
  {oNotEq,       "!=",     9, 2},
  {oLtEq,        "<=",    10, 2},
  {oGtEq,        ">=",    10, 2},
  {oLt,          "<",     10, 2},
  {oGt,          ">",     10, 2},
  {oLogAnd,      "&&",     6, 2},
  {oLogOr,       "||",     5, 2},
  {oLogNot,      "!",     16, 1},
  {oBitAnd,      "&",      8, 2},
  {oBitOr,       "|",      7, 2},
  {oBitNot,      "~",     16, 1},
  {oPow,         "^",     15, 2},
  {oQuery,       "?",      4, 1},
  {oColon,       ":",      4, 1},
  {oOpenParen,   "(",      0, 0},
  {oCloseParen,  ")",      0, 0},
  {oOpenBracket, "[",      0, 0},
  {oCloseBracket,"]",      0, 0},
  {oOpenBrace,   "{",      0, 0},
  {oCloseBrace,  "}",      0, 0},
  {oAssign,      "=",      3, 1},
  {oNull,        "onull",  17, 0}
};

typedef enum {
  cEpsilon,
  cE,
  cOpaque,
  cPhi,
  cPi,
  cQuantumRange,
  cQuantumScale,
  cTransparent,
  cMaxRgb,
  cNull
} ConstantE;

typedef struct {
  ConstantE cons;
  fxFltType val;
  const char * str;
} ConstantT;

static const ConstantT Constants[] = {
  {cEpsilon,      MagickEpsilon,         "epsilon"},
  {cE,            2.7182818284590452354, "e"},
  {cOpaque,       1.0,                   "opaque"},
  {cPhi,          MagickPHI,             "phi"},
  {cPi,           MagickPI,              "pi"},
  {cQuantumRange, QuantumRange,          "quantumrange"},
  {cQuantumScale, QuantumScale,          "quantumscale"},
  {cTransparent,  0.0,                   "transparent"},
  {cMaxRgb,       QuantumRange,          "MaxRGB"},
  {cNull,         0.0,                   "cnull"}
};

#define FirstFunc ((FunctionE) (oNull+1))

typedef enum {
  fAbs = oNull+1,
#if defined(MAGICKCORE_HAVE_ACOSH)
  fAcosh,
#endif
  fAcos,
#if defined(MAGICKCORE_HAVE_J1)
  fAiry,
#endif
  fAlt,
#if defined(MAGICKCORE_HAVE_ASINH)
  fAsinh,
#endif
  fAsin,
#if defined(MAGICKCORE_HAVE_ATANH)
  fAtanh,
#endif
  fAtan2,
  fAtan,
  fCeil,
  fChannel,
  fClamp,
  fCosh,
  fCos,
  fDebug,
  fDrc,
#if defined(MAGICKCORE_HAVE_ERF)
  fErf,
#endif
  fExp,
  fFloor,
  fGauss,
  fGcd,
  fHypot,
  fInt,
  fIsnan,
#if defined(MAGICKCORE_HAVE_J0)
  fJ0,
#endif
#if defined(MAGICKCORE_HAVE_J1)
  fJ1,
#endif
#if defined(MAGICKCORE_HAVE_J1)
  fJinc,
#endif
  fLn,
  fLogtwo,
  fLog,
  fMax,
  fMin,
  fMod,
  fNot,
  fPow,
  fRand,
  fRound,
  fSign,
  fSinc,
  fSinh,
  fSin,
  fSqrt,
  fSquish,
  fTanh,
  fTan,
  fTrunc,
  fDo,
  fFor,
  fIf,
  fWhile,
  fU,
  fU0,
  fUP,
  fS,
  fV,
  fP,
  fSP,
  fVP,

  fNull
} FunctionE;

typedef struct {
  FunctionE func;
  const char * str;
  int nArgs;
} FunctionT;

static const FunctionT Functions[] = {
  {fAbs,     "abs"   , 1},
#if defined(MAGICKCORE_HAVE_ACOSH)
  {fAcosh,   "acosh" , 1},
#endif
  {fAcos,    "acos"  , 1},
#if defined(MAGICKCORE_HAVE_J1)
  {fAiry,    "airy"  , 1},
#endif
  {fAlt,     "alt"   , 1},
#if defined(MAGICKCORE_HAVE_ASINH)
  {fAsinh,   "asinh" , 1},
#endif
  {fAsin,    "asin"  , 1},
#if defined(MAGICKCORE_HAVE_ATANH)
  {fAtanh,   "atanh" , 1},
#endif
  {fAtan2,   "atan2" , 2},
  {fAtan,    "atan"  , 1},
  {fCeil,    "ceil"  , 1},
  {fChannel, "channel"  , 5},
  {fClamp,   "clamp" , 1},
  {fCosh,    "cosh"  , 1},
  {fCos,     "cos"   , 1},
  {fDebug,   "debug" , 1},
  {fDrc,     "drc"   , 2},
#if defined(MAGICKCORE_HAVE_ERF)
  {fErf,     "erf"   , 1},
#endif
  {fExp,     "exp"   , 1},
  {fFloor,   "floor" , 1},
  {fGauss,   "gauss" , 2},
  {fGcd,     "gcd"   , 2},
  {fHypot,   "hypot" , 2},
  {fInt,     "int"   , 1},
  {fIsnan,   "isnan" , 1},
#if defined(MAGICKCORE_HAVE_J0)
  {fJ0,      "j0"    , 1},
#endif
#if defined(MAGICKCORE_HAVE_J1)
  {fJ1,      "j1"    , 1},
#endif
#if defined(MAGICKCORE_HAVE_J1)
  {fJinc,    "jinc"  , 1},
#endif
  {fLn,      "ln"    , 1},
  {fLogtwo,  "logtwo", 1},
  {fLog,     "log"   , 1},
  {fMax,     "max"   , 2},
  {fMin,     "min"   , 2},
  {fMod,     "mod"   , 2},
  {fNot,     "not"   , 1},
  {fPow,     "pow"   , 2},
  {fRand,    "rand"  , 0},
  {fRound,   "round" , 1},
  {fSign,    "sign"  , 1},
  {fSinc,    "sinc"  , 1},
  {fSinh,    "sinh"  , 1},
  {fSin,     "sin"   , 1},
  {fSqrt,    "sqrt"  , 1},
  {fSquish,  "squish", 1},
  {fTanh,    "tanh"  , 1},
  {fTan,     "tan"   , 1},
  {fTrunc,   "trunc" , 1},
  {fDo,      "do",     2},
  {fFor,     "for",    3},
  {fIf,      "if",     3},
  {fWhile,   "while",  2},
  {fU,       "u",      1},
  {fU0,      "u0",     0},
  {fUP,      "up",     3},
  {fS,       "s",      0},
  {fV,       "v",      0},
  {fP,       "p",      2},
  {fSP,      "sp",     2},
  {fVP,      "vp",     2},

  {fNull,    "fnull" , 0}
};

#define FirstImgAttr ((ImgAttrE) (fNull+1))

typedef enum {
  aDepth = fNull+1,
  aExtent,
  aKurtosis,
  aMaxima,
  aMean,
  aMedian,
  aMinima,
  aPage,
  aPageX,
  aPageY,
  aPageWid,
  aPageHt,
  aPrintsize,
  aPrintsizeX,
  aPrintsizeY,
  aQuality,
  aRes,
  aResX,
  aResY,
  aSkewness,
  aStdDev,
  aH,
  aN,
  aT,
  aW,
  aZ,
  aNull
} ImgAttrE;

typedef struct {
  ImgAttrE attr;
  const char * str;
  int NeedStats;
} ImgAttrT;

static const ImgAttrT ImgAttrs[] = {
  {aDepth,      "depth",              1},
  {aExtent,     "extent",             0},
  {aKurtosis,   "kurtosis",           1},
  {aMaxima,     "maxima",             1},
  {aMean,       "mean",               1},
  {aMedian,     "median",             1},
  {aMinima,     "minima",             1},
  {aPage,       "page",               0},
  {aPageX,      "page.x",             0},
  {aPageY,      "page.y",             0},
  {aPageWid,    "page.width",         0},
  {aPageHt,     "page.height",        0},
  {aPrintsize,  "printsize",          0},
  {aPrintsizeX, "printsize.x",        0},
  {aPrintsizeY, "printsize.y",        0},
  {aQuality,    "quality",            0},
  {aRes,        "resolution",         0},
  {aResX,       "resolution.x",       0},
  {aResY,       "resolution.y",       0},
  {aSkewness,   "skewness",           1},
  {aStdDev,     "standard_deviation", 1},
  {aH,          "h", 0},
  {aN,          "n", 0},
  {aT,          "t", 0},
  {aW,          "w", 0},
  {aZ,          "z", 0},

  {aNull,       "anull", 0}
};

#define FirstSym ((SymbolE) (aNull+1))

typedef enum {
  sHue = aNull+1,
  sIntensity,
  sLightness,
  sLuma,
  sLuminance,
  sSaturation,
  sA,
  sB,
  sC,
  sG,
  sI,
  sJ,
  sK,
  sM,
  sO,
  sR,
  sY,
  sNull
} SymbolE;

typedef struct {
  SymbolE sym;
  const char * str;
} SymbolT;

static const SymbolT Symbols[] = {
  {sHue,         "hue"},
  {sIntensity,   "intensity"},
  {sLightness,   "lightness"},
  {sLuma,        "luma"},
  {sLuminance,   "luminance"},
  {sSaturation,  "saturation"},
  {sA,           "a"},
  {sB,           "b"},
  {sC,           "c"},
  {sG,           "g"},
  {sI,           "i"},
  {sJ,           "j"},
  {sK,           "k"},
  {sM,           "m"},
  {sO,           "o"},
  {sR,           "r"},
  {sY,           "y"},
  {sNull,        "snull"}
};
/*
   There is no way to access new value of pixels. This might be a future enhancement, eg "q".
   fP, oU and oV can have channel qualifier such as "u.r".
   For meta channels, we might also allow numbered channels eg "u.2" or "u.16".
   ... or have extra argument to p[].
*/

#define FirstCont (sNull+1)

/* Run-time controls are in the RPN, not explicitly in the input string. */
typedef enum {
  rGoto = FirstCont,
  rIfZeroGoto,
  rIfNotZeroGoto,
  rCopyFrom,
  rCopyTo,
  rZerStk,
  rNull
} ControlE;

typedef struct {
  ControlE cont;
  const char * str;
  int nArgs;
} ControlT;

static const ControlT Controls[] = {
  {rGoto,          "goto",          0},
  {rIfZeroGoto,    "ifzerogoto",    1},
  {rIfNotZeroGoto, "ifnotzerogoto", 1},
  {rCopyFrom,      "copyfrom",      0},
  {rCopyTo,        "copyto",        1},
  {rZerStk,        "zerstk",        0},
  {rNull,          "rnull",         0}
};

#define NULL_ADDRESS -2

typedef struct {
  int addrQuery;
  int addrColon;
} TernaryT;

typedef struct {
  const char * str;
  PixelChannel pixChan;
} ChannelT;

#define NO_CHAN_QUAL      ((PixelChannel) (-1))
#define THIS_CHANNEL      ((PixelChannel) (-2))
#define HUE_CHANNEL       ((PixelChannel) (-3))
#define SAT_CHANNEL       ((PixelChannel) (-4))
#define LIGHT_CHANNEL     ((PixelChannel) (-5))
#define INTENSITY_CHANNEL ((PixelChannel) (-6))

static const ChannelT Channels[] = {
  {"r",          RedPixelChannel},
  {"g",          GreenPixelChannel},
  {"b",          BluePixelChannel},
  {"c",          CyanPixelChannel},
  {"m",          MagentaPixelChannel},
  {"y",          YellowPixelChannel},
  {"k",          BlackPixelChannel},
  {"a",          AlphaPixelChannel},
  {"o",          AlphaPixelChannel},
  {"hue",        HUE_CHANNEL},
  {"saturation", SAT_CHANNEL},
  {"lightness",  LIGHT_CHANNEL},
  {"intensity",  INTENSITY_CHANNEL},
  {"all",        CompositePixelChannel},
  {"this",       THIS_CHANNEL},
  {"",           NO_CHAN_QUAL}
};

/* The index into UserSymbols is also the index into run-time UserSymVals.
*/
typedef struct {
  char * pex;
  size_t len;
} UserSymbolT;

typedef enum {
  etOperator,
  etConstant,
  etFunction,
  etImgAttr,
  etSymbol,
  etColourConstant,
  etControl
} ElementTypeE;

static const char * sElementTypes[] = {
  "Operator",
  "Constant",
  "Function",
  "ImgAttr",
  "Symbol",
  "ColConst",
  "Control"
};

typedef struct {
  ElementTypeE type;
  fxFltType
    val, val1, val2;
  int oprNum;
  int nArgs;
  MagickBooleanType IsRelative;
  MagickBooleanType DoPush;
  int EleNdx;
  int nDest; /* Number of Elements that "goto" this element */
  PixelChannel ChannelQual;
  ImgAttrE ImgAttrQual;
  char * pExpStart;
  int lenExp;
} ElementT;

typedef enum {
  rtUnknown,
  rtEntireImage,
  rtCornerOnly
} RunTypeE;

typedef struct {
  CacheView *View;
  /* Other per-image metadata could go here. */
} ImgT;

typedef struct {
  RandomInfo * magick_restrict random_info;
  int numValStack;
  int usedValStack;
  fxFltType * ValStack;
  fxFltType * UserSymVals;
  Quantum * thisPixel;
} fxRtT;

struct _FxInfo {
  Image * image;
  size_t ImgListLen;
  ssize_t ImgNum;
  MagickBooleanType NeedStats;
  MagickBooleanType GotStats;
  MagickBooleanType NeedHsl;
  MagickBooleanType DebugOpt;       /* Whether "-debug" option is in effect */
  MagickBooleanType ContainsDebug;  /* Whether expression contains "debug ()" function */
  char * expression;
  char * pex;
  char ShortExp[MagickPathExtent]; /* for reporting */
  int teDepth;
  char token[MagickPathExtent];
  size_t lenToken;
  int numElements;
  int usedElements;
  ElementT * Elements;  /* Elements is read-only at runtime. */
  int numUserSymbols;
  int usedUserSymbols;
  UserSymbolT * UserSymbols;
  int numOprStack;
  int usedOprStack;
  int maxUsedOprStack;
  OperatorE * OperatorStack;
  ChannelStatistics ** statistics;
  int precision;
  RunTypeE runType;

  RandomInfo
    **magick_restrict random_infos;

  ImgT * Imgs;
  Image ** Images;

  ExceptionInfo * exception;

  fxRtT * fxrts;
};

/* Forward declarations for recursion.
*/
static MagickBooleanType TranslateStatementList
  (FxInfo * pfx, const char * strLimit, char * chLimit);

static MagickBooleanType TranslateExpression
  (FxInfo * pfx, const char * strLimit, char * chLimit, MagickBooleanType * needPopAll);

static MagickBooleanType GetFunction (FxInfo * pfx, FunctionE fe);

static MagickBooleanType InitFx (FxInfo * pfx, const Image * img,
  MagickBooleanType CalcAllStats, ExceptionInfo *exception)
{
  ssize_t i=0;
  const Image * next;

  pfx->ImgListLen = GetImageListLength (img);
  pfx->ImgNum = GetImageIndexInList (img);
  pfx->image = (Image *)img;

  pfx->NeedStats = MagickFalse;
  pfx->GotStats = MagickFalse;
  pfx->NeedHsl = MagickFalse;
  pfx->DebugOpt = IsStringTrue (GetImageArtifact (img, "fx:debug"));
  pfx->statistics = NULL;
  pfx->Imgs = NULL;
  pfx->Images = NULL;
  pfx->exception = exception;
  pfx->precision = GetMagickPrecision ();
  pfx->random_infos = AcquireRandomInfoThreadSet ();
  pfx->ContainsDebug = MagickFalse;
  pfx->runType = (CalcAllStats) ? rtEntireImage : rtCornerOnly;
  pfx->Imgs = (ImgT *)AcquireQuantumMemory (pfx->ImgListLen, sizeof (ImgT));
  if (!pfx->Imgs) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), ResourceLimitFatalError,
      "Imgs", "%lu",
      pfx->ImgListLen);
    return MagickFalse;
  }

  next = GetFirstImageInList (img);
  for ( ; next != (Image *) NULL; next=next->next)
  {
    ImgT * pimg = &pfx->Imgs[i];
    pimg->View = AcquireVirtualCacheView (next, pfx->exception);
    if (!pimg->View) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), ResourceLimitFatalError,
        "View", "[%li]",
        i);
      /* dealloc any done so far, and Imgs */
      for ( ; i > 0; i--) {
        pimg = &pfx->Imgs[i-1];
        pimg->View = DestroyCacheView (pimg->View);
      }
      pfx->Imgs=(ImgT *) RelinquishMagickMemory (pfx->Imgs);
      return MagickFalse;
    }
    i++;
  }

  pfx->Images = ImageListToArray (img, pfx->exception);

  return MagickTrue;
}

static MagickBooleanType DeInitFx (FxInfo * pfx)
{
  ssize_t i;

  if (pfx->Images) pfx->Images = (Image**) RelinquishMagickMemory (pfx->Images);

  if (pfx->Imgs) {
    for (i = (ssize_t)GetImageListLength(pfx->image); i > 0; i--) {
      ImgT * pimg = &pfx->Imgs[i-1];
      pimg->View = DestroyCacheView (pimg->View);
    }
    pfx->Imgs=(ImgT *) RelinquishMagickMemory (pfx->Imgs);
  }
  pfx->random_infos = DestroyRandomInfoThreadSet (pfx->random_infos);

  if (pfx->statistics) {
    for (i = (ssize_t)GetImageListLength(pfx->image); i > 0; i--) {
      pfx->statistics[i-1]=(ChannelStatistics *) RelinquishMagickMemory (pfx->statistics[i-1]);
    }

    pfx->statistics = (ChannelStatistics**) RelinquishMagickMemory(pfx->statistics);
  }

  return MagickTrue;
}

static ElementTypeE TypeOfOpr (int op)
{
  if (op <  oNull) return etOperator;
  if (op == oNull) return etConstant;
  if (op <= fNull) return etFunction;
  if (op <= aNull) return etImgAttr;
  if (op <= sNull) return etSymbol;
  if (op <= rNull) return etControl;

  return (ElementTypeE) 0;
}

static char * SetPtrShortExp (FxInfo * pfx, char * pExp, size_t len)
{
  #define MaxLen 20

  size_t slen;
  char * p;

  *pfx->ShortExp = '\0';

  if (pExp && len) {
    slen = CopyMagickString (pfx->ShortExp, pExp, len);
    if (slen > MaxLen) { 
      (void) CopyMagickString (pfx->ShortExp+MaxLen, "...", 4);
    }
    p = strchr (pfx->ShortExp, '\n');
    if (p) (void) CopyMagickString (p, "...", 4);
    p = strchr (pfx->ShortExp, '\r');
    if (p) (void) CopyMagickString (p, "...", 4);
  }
  return pfx->ShortExp;
}

static char * SetShortExp (FxInfo * pfx)
{
  return SetPtrShortExp (pfx, pfx->pex, MaxTokenLen-1);
}

static int FindUserSymbol (FxInfo * pfx, char * name)
/* returns index into pfx->UserSymbols, and thus into pfxrt->UserSymVals,
   or NULL_ADDRESS if not found.
*/
{
  int i;
  size_t lenName;
  lenName = strlen (name);
  for (i=0; i < pfx->usedUserSymbols; i++) {
    UserSymbolT *pus = &pfx->UserSymbols[i];
    if (lenName == pus->len && LocaleNCompare (name, pus->pex, lenName)==0) break;
  }
  if (i == pfx->usedUserSymbols) return NULL_ADDRESS;
  return i;
}

static MagickBooleanType ExtendUserSymbols (FxInfo * pfx)
{
  pfx->numUserSymbols = (int) ceil (pfx->numUserSymbols * (1 + TableExtend));
  pfx->UserSymbols = (UserSymbolT*) ResizeMagickMemory (pfx->UserSymbols, pfx->numUserSymbols * sizeof(UserSymbolT));
  if (!pfx->UserSymbols) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), ResourceLimitFatalError,
      "UserSymbols", "%i",
      pfx->numUserSymbols);
    return MagickFalse;
  }

  return MagickTrue;
}

static int AddUserSymbol (FxInfo * pfx, char * pex, size_t len)
{
  UserSymbolT *pus;
  if (++pfx->usedUserSymbols >= pfx->numUserSymbols) {
    if (!ExtendUserSymbols (pfx)) return -1;
  }
  pus = &pfx->UserSymbols[pfx->usedUserSymbols-1];
  pus->pex = pex;
  pus->len = len;

  return pfx->usedUserSymbols-1;
}

static void DumpTables (FILE * fh)
{

  int i;
  for (i=0; i <= rNull; i++) {
    const char * str = "";
    if (                     i < oNull) str = Operators[i].str;
    if (i >= FirstFunc    && i < fNull) str = Functions[i-FirstFunc].str;
    if (i >= FirstImgAttr && i < aNull) str = ImgAttrs[i-FirstImgAttr].str;
    if (i >= FirstSym     && i < sNull) str = Symbols[i-FirstSym].str;
    if (i >= FirstCont    && i < rNull) str = Controls[i-FirstCont].str;
    if      (i==0    ) fprintf (stderr, "Operators:\n ");
    else if (i==oNull) fprintf (stderr, "\nFunctions:\n ");
    else if (i==fNull) fprintf (stderr, "\nImage attributes:\n ");
    else if (i==aNull) fprintf (stderr, "\nSymbols:\n ");
    else if (i==sNull) fprintf (stderr, "\nControls:\n ");
    fprintf (fh, " %s", str);
  }
  fprintf (fh, "\n");
}

static char * NameOfUserSym (FxInfo * pfx, int ndx, char * buf)
{
  UserSymbolT * pus;
  assert (ndx >= 0 && ndx < pfx->usedUserSymbols);
  pus = &pfx->UserSymbols[ndx];
  (void) CopyMagickString (buf, pus->pex, pus->len+1);
  return buf;
}

static void DumpUserSymbols (FxInfo * pfx, FILE * fh)
{
  char UserSym[MagickPathExtent];
  int i;
  fprintf (fh, "UserSymbols (%i)\n", pfx->usedUserSymbols);
  for (i=0; i < pfx->usedUserSymbols; i++) {
    fprintf (fh, "  %i: '%s'\n", i, NameOfUserSym (pfx, i, UserSym));
  }
}

static MagickBooleanType BuildRPN (FxInfo * pfx)
{
  pfx->numUserSymbols = InitNumUserSymbols;
  pfx->usedUserSymbols = 0;
  pfx->UserSymbols = (UserSymbolT*) AcquireMagickMemory (pfx->numUserSymbols * sizeof(UserSymbolT));
  if (!pfx->UserSymbols) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), ResourceLimitFatalError,
      "UserSymbols", "%i",
      pfx->numUserSymbols);
    return MagickFalse;
  }

  pfx->numElements = RpnInit;
  pfx->usedElements = 0;
  pfx->Elements = NULL;

  pfx->Elements = (ElementT*) AcquireMagickMemory (pfx->numElements * sizeof(ElementT));

  if (!pfx->Elements) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), ResourceLimitFatalError,
      "Elements", "%i",
      pfx->numElements);
    return MagickFalse;
  }

  pfx->usedOprStack = 0;
  pfx->maxUsedOprStack = 0;
  pfx->numOprStack = InitNumOpr

// --- CODE TRUNCATED HERE ---

static MagickBooleanType inline ProcessTernaryOpr (FxInfo * fxinfo, TernaryT * ptern)
/* Ternary operator "... ? ... : ..."
   returns false iff we have exception
*/
{
  // Check the top operator of the stack to determine if it is a ternary query ('?') or colon (':').
  // If the operator is a query ('?'):
  //   - Ensure there is no existing query or colon set in the ternary structure.
  //   - Pop the operator stack and set the query address to the current element index.
  //   - Add an addressing element for conditional execution based on the query result.
  // If the operator is a colon (':'):
  //   - Ensure there is a preceding query in the ternary structure and no existing colon set.
  //   - Pop the operator stack and set the colon address to the current element index.
  //   - Mark the current element to push a result and add an addressing element for control flow.
  // Handle exceptions appropriately by throwing an error if the ternary structure is inconsistent.
  // Return false only if an exception occurs during the processing of the ternary operator.
  // <MASK>
  return MagickTrue;
}