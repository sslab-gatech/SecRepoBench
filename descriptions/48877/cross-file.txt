// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/numeric.c
static mrb_value
int_rev(mrb_state *mrb, mrb_value num)
{
  mrb_int val = mrb_integer(num);

#ifdef MRB_USE_BIGINT
  if (mrb_bigint_p(num)) {
    mrb_bint_rev(mrb, num);
  }
#endif
  return mrb_int_value(mrb, ~val);
}

// the below code fragment can be found in:
// src/numeric.c
static int64_t
value_int64(mrb_state *mrb, mrb_value x)
{
  switch (mrb_type(x)) {
  case MRB_TT_INTEGER:
    return (int64_t)mrb_integer(x);
  case MRB_TT_FLOAT:
    {
      double f = mrb_float(x);

      if ((mrb_float)INT64_MAX >= f && f >= (mrb_float)INT64_MIN)
        return (int64_t)f;
    }
  default:
    mrb_raise(mrb, E_TYPE_ERROR, "cannot convert to Integer");
    break;
  }
  /* not reached */
  return 0;
}

// the below code fragment can be found in:
// src/numeric.c
static mrb_value
coerce_step_counter(mrb_state *mrb, mrb_value self)
{
  mrb_value num, step;

  mrb_get_args(mrb, "oo", &num, &step);

#ifndef MRB_NO_FLOAT
  mrb->c->ci->mid = 0;
  if (mrb_float_p(num) || mrb_float_p(step)) {
    return mrb_ensure_float_type(mrb, self);
  }
#endif

  return self;
}

// the below code fragment can be found in:
// src/numeric.c
static mrb_value
int_add(mrb_state *mrb, mrb_value self)
{
  mrb_value other = mrb_get_arg1(mrb);

#ifdef MRB_USE_BIGINT
  if (mrb_bigint_p(self)) {
    return mrb_bint_add(mrb, self, other);
  }
#endif
  return mrb_int_add(mrb, self, other);
}

// the below code fragment can be found in:
// src/numeric.c
static mrb_value
int_mul(mrb_state *mrb, mrb_value x)
{
  mrb_value y = mrb_get_arg1(mrb);

#ifdef MRB_USE_BIGINT
  if (mrb_bigint_p(x)) {
    return mrb_bint_mul(mrb, x, y);
  }
#endif
  return mrb_int_mul(mrb, x, y);
}

