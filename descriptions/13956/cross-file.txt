// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// libyara/mem.c
int yr_heap_alloc(void)
{
  return ERROR_SUCCESS;
}

// the below code fragment can be found in:
// tests/util.c
static int capture_matches(
    int message,
    void* message_data,
    void* user_data)
{
  if (message == CALLBACK_MSG_RULE_MATCHING)
  {
    find_string_t* f = (find_string_t*) user_data;

    YR_RULE* rule = (YR_RULE*) message_data;
    YR_STRING* string;

    yr_rule_strings_foreach(rule, string)
    {
      YR_MATCH* match;

      yr_string_matches_foreach(string, match)
      {
        if (strlen(f->expected) == match->data_length &&
            strncmp(f->expected, (char*)(match->data), match->data_length) == 0)
        {
          f->found++;
        }
      }
    }
  }

  return CALLBACK_CONTINUE;
}

// the below code fragment can be found in:
// libyara/mem.c
char* yr_strndup(const char *str, size_t n)
{
  size_t len = strnlen(str, n);
  char *dup = (char*) yr_malloc(len + 1);

  if (dup == NULL)
    return NULL;

  memcpy(dup, str, len);
  dup[len] = '\0';

  return (char *) dup;
}

// the below code fragment can be found in:
// libyara/object.c
YR_OBJECT* yr_object_get_root(
    YR_OBJECT* object)
{
  YR_OBJECT* o = object;

  while (o->parent != NULL)
    o = o->parent;

  return o;
}

// the below code fragment can be found in:
// libyara/modules/dex.c
dex_header_t* dex_get_header(
    const uint8_t* data,
    size_t data_size)
{
  dex_header_t* dex_header;

  if (data_size < sizeof(dex_header_t))
    return NULL;

  // Check if we have a valid DEX file
  dex_header = (dex_header_t*) data;

  if (memcmp(dex_header->magic, DEX_FILE_MAGIC_035, 8) != 0 &&
      memcmp(dex_header->magic, DEX_FILE_MAGIC_036, 8) != 0 &&
      memcmp(dex_header->magic, DEX_FILE_MAGIC_037, 8) != 0 &&
      memcmp(dex_header->magic, DEX_FILE_MAGIC_038, 8) != 0)
  {
    return NULL;
  }

  return dex_header;
}

