// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/ALAC/alac_encoder.c
// static int32_t
// EncodeStereoFast (ALAC_ENCODER *p, struct BitBuffer * bitstream, const int32_t * inputBuffer, uint32_t stride, uint32_t channelIndex, uint32_t numSamples)
// {
// 	BitBuffer		startBits = *bitstream ;			// squirrel away current bit position in case we decide to use escape hatch
// 	AGParamRec		agParams ;
// 	uint32_t		bits1, bits2 ;
// 	int32_t			mixBits, mixRes ;
// 	uint32_t		minBits, minBits1, minBits2 ;
// 	uint32_t		numU, numV ;
// 	uint32_t		mode ;
// 	uint32_t		pbFactor ;
// 	uint32_t		chanBits ;
// 	uint8_t			bytesShifted ;
// 	SearchCoefs		coefsU ;
// 	SearchCoefs		coefsV ;
// 	uint32_t		indx ;
// 	uint8_t			partialFrame ;
// 	uint32_t		escapeBits ;
// 	bool			doEscape ;
// 	int32_t			status ;
// 
// 	// make sure we handle this bit-depth before we get going
// 	RequireAction ((p->mBitDepth == 16) || (p->mBitDepth == 20) || (p->mBitDepth == 24) || (p->mBitDepth == 32), return kALAC_ParamError ;) ;
// 
// 	// reload coefs pointers for this channel pair
// 	// - note that, while you might think they should be re-initialized per block, retaining state across blocks
// 	//	 actually results in better overall compression
// 	// - strangely, re-using the same coefs for the different passes of the "mixRes" search loop instead of using
// 	//	 different coefs for the different passes of "mixRes" results in even better compression
// 	coefsU = (SearchCoefs) p->mCoefsU [channelIndex] ;
// 	coefsV = (SearchCoefs) p->mCoefsV [channelIndex] ;
// 
// 	// matrix encoding adds an extra bit but 32-bit inputs cannot be matrixed b/c 33 is too many
// 	// so enable 16-bit "shift off" and encode in 17-bit mode
// 	// - in addition, 24-bit mode really improves with one byte shifted off
// 	if (p->mBitDepth == 32)
// 		bytesShifted = 2 ;
// 	else if (p->mBitDepth >= 24)
// 		bytesShifted = 1 ;
// 	else
// 		bytesShifted = 0 ;
// 
// 	chanBits = p->mBitDepth - (bytesShifted * 8) + 1 ;
// 
// 	// flag whether or not this is a partial frame
// 	partialFrame = (numSamples == p->mFrameSize) ? 0 : 1 ;
// 
// 	// set up default encoding parameters for "fast" mode
// 	mixBits		= kDefaultMixBits ;
// 	mixRes		= kDefaultMixRes ;
// 	numU = numV = kDefaultNumUV ;
// 	mode		= 0 ;
// 	pbFactor	= 4 ;
// 
// 	minBits	= minBits1 = minBits2 = 1ul << 31 ;
// 
// 	// mix the stereo inputs with default mixBits/mixRes
// 	switch (p->mBitDepth)
// 	{
// 		case 16:
// 			mix16 (inputBuffer, stride, p->mMixBufferU, p->mMixBufferV, numSamples, mixBits, mixRes) ;
// 			break ;
// 		case 20:
// 			mix20 (inputBuffer, stride, p->mMixBufferU, p->mMixBufferV, numSamples, mixBits, mixRes) ;
// 			break ;
// 		case 24:
// 			// also extracts the shifted off bytes into the shift buffers
// 			mix24 (inputBuffer, stride, p->mMixBufferU, p->mMixBufferV, numSamples,
// 					mixBits, mixRes, p->mShiftBufferUV, bytesShifted) ;
// 			break ;
// 		case 32:
// 			// also extracts the shifted off bytes into the shift buffers
// 			mix32 (inputBuffer, stride, p->mMixBufferU, p->mMixBufferV, numSamples,
// 					mixBits, mixRes, p->mShiftBufferUV, bytesShifted) ;
// 			break ;
// 	}
// 
// 	/* speculatively write the bitstream assuming the compressed version will be smaller */
// 
// 	// write bitstream header and coefs
// 	BitBufferWrite (bitstream, 0, 12) ;
// 	BitBufferWrite (bitstream, (partialFrame << 3) | (bytesShifted << 1), 4) ;
// 	if (partialFrame)
// 		BitBufferWrite (bitstream, numSamples, 32) ;
// 	BitBufferWrite (bitstream, mixBits, 8) ;
// 	BitBufferWrite (bitstream, mixRes, 8) ;
// 
// 	//Assert ((mode < 16) && (DENSHIFT_DEFAULT < 16)) ;
// 	//Assert ((pbFactor < 8) && (numU < 32)) ;
// 	//Assert ((pbFactor < 8) && (numV < 32)) ;
// 
// 	BitBufferWrite (bitstream, (mode << 4) | DENSHIFT_DEFAULT, 8) ;
// 	BitBufferWrite (bitstream, (pbFactor << 5) | numU, 8) ;
// 	for (indx = 0 ; indx < numU ; indx++)
// 		BitBufferWrite (bitstream, coefsU [numU - 1][indx], 16) ;
// 
// 	BitBufferWrite (bitstream, (mode << 4) | DENSHIFT_DEFAULT, 8) ;
// 	BitBufferWrite (bitstream, (pbFactor << 5) | numV, 8) ;
// 	for (indx = 0 ; indx < numV ; indx++)
// 		BitBufferWrite (bitstream, coefsV [numV - 1][indx], 16) ;
// 
// 	// if shift active, write the interleaved shift buffers
// 	if (bytesShifted != 0)
// 	{
// 		uint32_t		bitShift = bytesShifted * 8 ;
// 
// 		//Assert (bitShift <= 16) ;
// 
// 		for (indx = 0 ; indx < (numSamples * 2) ; indx += 2)
// 		{
// 			uint32_t			shiftedVal ;
// 
// 			shiftedVal = ((uint32_t) p->mShiftBufferUV [indx + 0] << bitShift) | (uint32_t) p->mShiftBufferUV [indx + 1] ;
// 			BitBufferWrite (bitstream, shiftedVal, bitShift * 2) ;
// 		}
// 	}
// 
// 	// run the dynamic predictor and lossless compression for the "left" channel
// 	// - note: we always use mode 0 in the "fast" path so we don't need the code for mode != 0
// 	pc_block (p->mMixBufferU, p->mPredictorU, numSamples, coefsU [numU - 1], numU, chanBits, DENSHIFT_DEFAULT) ;
// 
// 	set_ag_params (&agParams, MB0, (pbFactor * PB0) / 4, KB0, numSamples, numSamples, MAX_RUN_DEFAULT) ;
// 	status = dyn_comp (&agParams, p->mPredictorU, bitstream, numSamples, chanBits, &bits1) ;
// 	RequireNoErr (status, goto Exit ;) ;
// 
// 	// run the dynamic predictor and lossless compression for the "right" channel
// 	pc_block (p->mMixBufferV, p->mPredictorV, numSamples, coefsV [numV - 1], numV, chanBits, DENSHIFT_DEFAULT) ;
// 
// 	set_ag_params (&agParams, MB0, (pbFactor * PB0) / 4, KB0, numSamples, numSamples, MAX_RUN_DEFAULT) ;
// 	status = dyn_comp (&agParams, p->mPredictorV, bitstream, numSamples, chanBits, &bits2) ;
// 	RequireNoErr (status, goto Exit ;) ;
// 
// 	// do bit requirement calculations
// 	minBits1 = bits1 + (numU * sizeof (int16_t) * 8) ;
// 	minBits2 = bits2 + (numV * sizeof (int16_t) * 8) ;
// 
// 	// test for escape hatch if best calculated compressed size turns out to be more than the input size
// 	minBits = minBits1 + minBits2 + (8 /* mixRes/maxRes/etc. */ * 8) + ((partialFrame == true) ? 32 : 0) ;
// 	if (bytesShifted != 0)
// 		minBits += (numSamples * (bytesShifted * 8) * 2) ;
// 
// 	escapeBits = (numSamples * p->mBitDepth * 2) + ((partialFrame == true) ? 32 : 0) + (2 * 8) ;	/* 2 common header bytes */
// 
// 	doEscape = (minBits >= escapeBits) ? true : false ;
// 
// 	if (doEscape == false)
// 	{
// 		/*	if we happened to create a compressed packet that was actually bigger than an escape packet would be,
// 			chuck it and do an escape packet
// 		*/
// 		minBits = BitBufferGetPosition (bitstream) - BitBufferGetPosition (&startBits) ;
// 		if (minBits >= escapeBits)
// 		{
// 			doEscape = true ;
// 			printf ("compressed frame too big: %u vs. %u\n", minBits, escapeBits) ;
// 		}
// 
// 	}
// 
// 	if (doEscape == true)
// 	{
// 		/* escape */
// 
// 		// reset bitstream position since we speculatively wrote the compressed version
// 		*bitstream = startBits ;
// 
// 		// write escape frame
// 		status = EncodeStereoEscape (p, bitstream, inputBuffer, stride, numSamples) ;
// 
// #if VERBOSE_DEBUG
// 		DebugMsg ("escape!: %u vs %u\n", minBits, (numSamples * p->mBitDepth * 2)) ;
// #endif
// 	}
// 
// Exit:
// 	return status ;
// }

// the below code fragment can be found in:
// src/ALAC/alac_encoder.c
// static int32_t
// EncodeStereoEscape (ALAC_ENCODER *p, struct BitBuffer * bitstream, const int32_t * inputBuffer, uint32_t stride, uint32_t numSamples)
// {
// 	uint8_t			partialFrame ;
// 	uint32_t		indx ;
// 
// 	// flag whether or not this is a partial frame
// 	partialFrame = (numSamples == p->mFrameSize) ? 0 : 1 ;
// 
// 	// write bitstream header
// 	BitBufferWrite (bitstream, 0, 12) ;
// 	BitBufferWrite (bitstream, (partialFrame << 3) | 1, 4) ;	// LSB = 1 means "frame not compressed"
// 	if (partialFrame)
// 		BitBufferWrite (bitstream, numSamples, 32) ;
// 
// 	// just copy the input data to the output buffer
// 	switch (p->mBitDepth)
// 	{
// 		case 16:
// 			for (indx = 0 ; indx < (numSamples * stride) ; indx += stride)
// 			{
// 				BitBufferWrite (bitstream, inputBuffer [indx + 0] >> 16, 16) ;
// 				BitBufferWrite (bitstream, inputBuffer [indx + 1] >> 16, 16) ;
// 			}
// 			break ;
// 		case 20:
// 			for (indx = 0 ; indx < (numSamples * stride) ; indx += stride)
// 			{
// 				BitBufferWrite (bitstream, inputBuffer [indx + 0] >> 12, 16) ;
// 				BitBufferWrite (bitstream, inputBuffer [indx + 1] >> 12, 16) ;
// 			}
// 			break ;
// 		case 24:
// 			// mix24 () with mixres param = 0 means de-interleave so use it to simplify things
// 			mix24 (inputBuffer, stride, p->mMixBufferU, p->mMixBufferV, numSamples, 0, 0, p->mShiftBufferUV, 0) ;
// 			for (indx = 0 ; indx < numSamples ; indx++)
// 			{
// 				BitBufferWrite (bitstream, p->mMixBufferU [indx] >> 8, 24) ;
// 				BitBufferWrite (bitstream, p->mMixBufferV [indx] >> 8, 24) ;
// 			}
// 			break ;
// 		case 32:
// 			for (indx = 0 ; indx < (numSamples * stride) ; indx += stride)
// 			{
// 				BitBufferWrite (bitstream, inputBuffer [indx + 0], 32) ;
// 				BitBufferWrite (bitstream, inputBuffer [indx + 1], 32) ;
// 			}
// 			break ;
// 	}
// 
// 	return ALAC_noErr ;
// }

// the below code fragment can be found in:
// src/ALAC/alac_encoder.c
// int32_t
// alac_encode (ALAC_ENCODER *p, uint32_t numSamples,
// 			const int32_t * theReadBuffer, unsigned char * theWriteBuffer, uint32_t * ioNumBytes)
// {
// 	uint32_t		outputSize ;
// 	BitBuffer		bitstream ;
// 	int32_t			status ;
// 	uint32_t 		numChannels = p->mNumChannels ;
// 
// 	// make sure we handle this bit-depth before we get going
// 	RequireAction ((p->mBitDepth == 16) || (p->mBitDepth == 20) || (p->mBitDepth == 24) || (p->mBitDepth == 32), return kALAC_ParamError ;) ;
// 
// 	// create a bit buffer structure pointing to our output buffer
// 	BitBufferInit (&bitstream, theWriteBuffer, p->mMaxOutputBytes) ;
// 
// 	if (numChannels == 2)
// 	{
// 		// add 3-bit frame start tag ID_CPE = channel pair & 4-bit element instance tag = 0
// 		BitBufferWrite (&bitstream, ID_CPE, 3) ;
// 		BitBufferWrite (&bitstream, 0, 4) ;
// 
// 		// encode stereo input buffer
// 		if (p->mFastMode == false)
// 			status = EncodeStereo (p, &bitstream, theReadBuffer, 2, 0, numSamples) ;
// 		else
// 			status = EncodeStereoFast (p, &bitstream, theReadBuffer, 2, 0, numSamples) ;
// 		RequireNoErr (status, goto Exit ;) ;
// 	}
// 	else if (numChannels == 1)
// 	{
// 		// add 3-bit frame start tag ID_SCE = mono channel & 4-bit element instance tag = 0
// 		BitBufferWrite (&bitstream, ID_SCE, 3) ;
// 		BitBufferWrite (&bitstream, 0, 4) ;
// 
// 		// encode mono input buffer
// 		status = EncodeMono (p, &bitstream, theReadBuffer, 1, 0, numSamples) ;
// 		RequireNoErr (status, goto Exit ;) ;
// 	}
// 	else
// 	{
// 		const int32_t *		inputBuffer ;
// 		uint32_t			tag ;
// 		uint32_t			channelIndex ;
// 		uint8_t				stereoElementTag ;
// 		uint8_t				monoElementTag ;
// 		uint8_t				lfeElementTag ;
// 
// 		inputBuffer		= theReadBuffer ;
// 
// 		stereoElementTag	= 0 ;
// 		monoElementTag		= 0 ;
// 		lfeElementTag		= 0 ;
// 
// 		for (channelIndex = 0 ; channelIndex < numChannels ;)
// 		{
// 			tag = (sChannelMaps [numChannels - 1] & (0x7ul << (channelIndex * 3))) >> (channelIndex * 3) ;
// 
// 			BitBufferWrite (&bitstream, tag, 3) ;
// 			switch (tag)
// 			{
// 				case ID_SCE:
// 					// mono
// 					BitBufferWrite (&bitstream, monoElementTag, 4) ;
// 
// 					status = EncodeMono (p, &bitstream, inputBuffer, numChannels, channelIndex, numSamples) ;
// 
// 					inputBuffer += 1 ;
// 					channelIndex++ ;
// 					monoElementTag++ ;
// 					break ;
// 
// 				case ID_CPE:
// 					// stereo
// 					BitBufferWrite (&bitstream, stereoElementTag, 4) ;
// 
// 					status = EncodeStereo (p, &bitstream, inputBuffer, numChannels, channelIndex, numSamples) ;
// 
// 					inputBuffer += 2 ;
// 					channelIndex += 2 ;
// 					stereoElementTag++ ;
// 					break ;
// 
// 				case ID_LFE:
// 					// LFE channel (subwoofer)
// 					BitBufferWrite (&bitstream, lfeElementTag, 4) ;
// 
// 					status = EncodeMono (p, &bitstream, inputBuffer, numChannels, channelIndex, numSamples) ;
// 
// 					inputBuffer += 1 ;
// 					channelIndex++ ;
// 					lfeElementTag++ ;
// 					break ;
// 
// 				default:
// 					printf ("That ain't right! (%u)\n", tag) ;
// 					status = kALAC_ParamError ;
// 					goto Exit ;
// 			}
// 
// 			RequireNoErr (status, goto Exit ;) ;
// 		}
// 	}
// 
// #if VERBOSE_DEBUG
// {
// 	// if there is room left in the output buffer, add some random fill data to test decoder
// 	int32_t			bitsLeft ;
// 	int32_t			bytesLeft ;
// 
// 	bitsLeft = BitBufferGetPosition (&bitstream) - 3 ;	// - 3 for ID_END tag
// 	bytesLeft = bitstream.byteSize - ((bitsLeft + 7) / 8) ;
// 
// 	if ((bytesLeft > 20) && ((bytesLeft & 0x4u) != 0))
// 		AddFiller (&bitstream, bytesLeft) ;
// }
// #endif
// 
// 	// add 3-bit frame end tag: ID_END
// 	BitBufferWrite (&bitstream, ID_END, 3) ;
// 
// 	// byte-align the output data
// 	BitBufferByteAlign (&bitstream, true) ;
// 
// 	outputSize = BitBufferGetPosition (&bitstream) / 8 ;
// 	//Assert (outputSize <= mMaxOutputBytes) ;
// 
// 
// 	// all good, let iTunes know what happened and remember the total number of input sample frames
// 	*ioNumBytes = outputSize ;
// 	//mEncodedFrames		   	   += encodeMsg->numInputSamples ;
// 
// 	// gather encoding stats
// 	p->mTotalBytesGenerated += outputSize ;
// 	p->mMaxFrameBytes = MAX (p->mMaxFrameBytes, outputSize) ;
// 
// 	status = ALAC_noErr ;
// 
// Exit:
// 	return status ;
// }

// the below code fragment can be found in:
// src/ALAC/alac_encoder.c
// void
// GetConfig (ALAC_ENCODER *p, ALACSpecificConfig * config)
// {
// 	config->frameLength			= Swap32NtoB (p->mFrameSize) ;
// 	config->compatibleVersion	= (uint8_t) kALACCompatibleVersion ;
// 	config->bitDepth			= (uint8_t) p->mBitDepth ;
// 	config->pb					= (uint8_t) PB0 ;
// 	config->kb					= (uint8_t) KB0 ;
// 	config->mb					= (uint8_t) MB0 ;
// 	config->numChannels			= (uint8_t) p->mNumChannels ;
// 	config->maxRun				= Swap16NtoB ((uint16_t) MAX_RUN_DEFAULT) ;
// 	config->maxFrameBytes		= Swap32NtoB (p->mMaxFrameBytes) ;
// 	config->avgBitRate			= Swap32NtoB (p->mAvgBitRate) ;
// 	config->sampleRate			= Swap32NtoB (p->mOutputSampleRate) ;
// }

// the below code fragment can be found in:
// src/ALAC/alac_encoder.c
// static int32_t
// EncodeMono (ALAC_ENCODER *p, struct BitBuffer * bitstream, const int32_t * inputBuffer, uint32_t stride, uint32_t channelIndex, uint32_t numSamples)
// {
// 	BitBuffer		startBits = *bitstream ;			// squirrel away copy of current state in case we need to go back and do an escape packet
// 	AGParamRec		agParams ;
// 	uint32_t		bits1 ;
// 	uint32_t		numU ;
// 	SearchCoefs		coefsU ;
// 	uint32_t		dilate ;
// 	uint32_t		minBits, bestU ;
// 	uint32_t		minU, maxU ;
// 	uint32_t		indx, indx2 ;
// 	uint8_t			bytesShifted ;
// 	uint32_t		shift ;
// 	uint32_t		mask ;
// 	uint32_t		chanBits ;
// 	uint8_t			pbFactor ;
// 	uint8_t			partialFrame ;
// 	uint32_t		escapeBits ;
// 	bool			doEscape ;
// 	int32_t			status = ALAC_noErr ;
// 
// 
// 	// make sure we handle this bit-depth before we get going
// 	RequireAction ((p->mBitDepth == 16) || (p->mBitDepth == 20) || (p->mBitDepth == 24) || (p->mBitDepth == 32), return kALAC_ParamError ;) ;
// 
// 	// reload coefs array from previous frame
// 	coefsU = (SearchCoefs) p->mCoefsU [channelIndex] ;
// 
// 	// pick bit depth for actual encoding
// 	// - we lop off the lower byte (s) for 24-/32-bit encodings
// 	if (p->mBitDepth == 32)
// 		bytesShifted = 2 ;
// 	else if (p->mBitDepth >= 24)
// 		bytesShifted = 1 ;
// 	else
// 		bytesShifted = 0 ;
// 
// 	shift = bytesShifted * 8 ;
// 	mask = (1ul << shift) - 1 ;
// 	chanBits = p->mBitDepth - (bytesShifted * 8) ;
// 
// 	// flag whether or not this is a partial frame
// 	partialFrame = (numSamples == p->mFrameSize) ? 0 : 1 ;
// 
// 	// convert N-bit data to 32-bit for predictor
// 	switch (p->mBitDepth)
// 	{
// 		case 16:
// 			// convert 16-bit data to 32-bit for predictor
// 			for (indx = 0, indx2 = 0 ; indx < numSamples ; indx++, indx2 += stride)
// 				p->mMixBufferU [indx] = inputBuffer [indx2] >> 16 ;
// 			break ;
// 
// 		case 20:
// 			// convert 20-bit data to 32-bit for predictor
// 			for (indx = 0, indx2 = 0 ; indx < numSamples ; indx++, indx2 += stride)
// 				p->mMixBufferU [indx] = inputBuffer [indx2] >> 12 ;
// 			break ;
// 		case 24:
// 			// convert 24-bit data to 32-bit for the predictor and extract the shifted off byte (s)
// 			for (indx = 0, indx2 = 0 ; indx < numSamples ; indx++, indx2 += stride)
// 			{
// 				p->mMixBufferU [indx] = inputBuffer [indx2] >> 8 ;
// 				p->mShiftBufferUV [indx] = (uint16_t) (p->mMixBufferU [indx] & mask) ;
// 				p->mMixBufferU [indx] >>= shift ;
// 			}
// 
// 			break ;
// 		case 32:
// 			// just copy the 32-bit input data for the predictor and extract the shifted off byte (s)
// 			for (indx = 0, indx2 = 0 ; indx < numSamples ; indx++, indx2 += stride)
// 			{
// 				p->mShiftBufferUV [indx] = (uint16_t) (inputBuffer [indx2] & mask) ;
// 				p->mMixBufferU [indx] = inputBuffer [indx2] >> shift ;
// 			}
// 			break ;
// 	}
// 
// 	// brute-force encode optimization loop (implied "encode depth" of 0 if comparing to cmd line tool)
// 	// - run over variations of the encoding params to find the best choice
// 	minU		= 4 ;
// 	maxU		= 8 ;
// 	minBits		= 1ul << 31 ;
// 	pbFactor	= 4 ;
// 
// 	bestU	= minU ;
// 
// 	for (numU = minU ; numU <= maxU ; numU += 4)
// 	{
// 		BitBuffer		workBits ;
// 		uint32_t		numBits ;
// 
// 		BitBufferInit (&workBits, p->mWorkBuffer, p->mMaxOutputBytes) ;
// 
// 		dilate = 32 ;
// 		for (uint32_t converge = 0 ; converge < 7 ; converge++)
// 			pc_block (p->mMixBufferU, p->mPredictorU, numSamples / dilate, coefsU [numU - 1], numU, chanBits, DENSHIFT_DEFAULT) ;
// 
// 		dilate = 8 ;
// 		pc_block (p->mMixBufferU, p->mPredictorU, numSamples / dilate, coefsU [numU - 1], numU, chanBits, DENSHIFT_DEFAULT) ;
// 
// 		set_ag_params (&agParams, MB0, (pbFactor * PB0) / 4, KB0, numSamples / dilate, numSamples / dilate, MAX_RUN_DEFAULT) ;
// 		status = dyn_comp (&agParams, p->mPredictorU, &workBits, numSamples / dilate, chanBits, &bits1) ;
// 		RequireNoErr (status, goto Exit ;) ;
// 
// 		numBits = (dilate * bits1) + (16 * numU) ;
// 		if (numBits < minBits)
// 		{
// 			bestU	= numU ;
// 			minBits = numBits ;
// 		}
// 	}
// 
// 	// test for escape hatch if best calculated compressed size turns out to be more than the input size
// 	// - first, add bits for the header bytes mixRes/maxRes/shiftU/filterU
// 	minBits += (4 /* mixRes/maxRes/etc. */ * 8) + ((partialFrame == true) ? 32 : 0) ;
// 	if (bytesShifted != 0)
// 		minBits += (numSamples * (bytesShifted * 8)) ;
// 
// 	escapeBits = (numSamples * p->mBitDepth) + ((partialFrame == true) ? 32 : 0) + (2 * 8) ;	/* 2 common header bytes */
// 
// 	doEscape = (minBits >= escapeBits) ? true : false ;
// 
// 	if (doEscape == false)
// 	{
// 		// write bitstream header
// 		BitBufferWrite (bitstream, 0, 12) ;
// 		BitBufferWrite (bitstream, (partialFrame << 3) | (bytesShifted << 1), 4) ;
// 		if (partialFrame)
// 			BitBufferWrite (bitstream, numSamples, 32) ;
// 		BitBufferWrite (bitstream, 0, 16) ;								// mixBits = mixRes = 0
// 
// 		// write the params and predictor coefs
// 		numU = bestU ;
// 		BitBufferWrite (bitstream, (0 << 4) | DENSHIFT_DEFAULT, 8) ;	// modeU = 0
// 		BitBufferWrite (bitstream, (pbFactor << 5) | numU, 8) ;
// 		for (indx = 0 ; indx < numU ; indx++)
// 			BitBufferWrite (bitstream, coefsU [numU-1][indx], 16) ;
// 
// 		// if shift active, write the interleaved shift buffers
// 		if (bytesShifted != 0)
// 		{
// 			for (indx = 0 ; indx < numSamples ; indx++)
// 				BitBufferWrite (bitstream, p->mShiftBufferUV [indx], shift) ;
// 		}
// 
// 		// run the dynamic predictor with the best result
// 		pc_block (p->mMixBufferU, p->mPredictorU, numSamples, coefsU [numU-1], numU, chanBits, DENSHIFT_DEFAULT) ;
// 
// 		// do lossless compression
// 		set_standard_ag_params (&agParams, numSamples, numSamples) ;
// 		status = dyn_comp (&agParams, p->mPredictorU, bitstream, numSamples, chanBits, &bits1) ;
// 		//AssertNoErr (status) ;
// 
// 
// 		/*	if we happened to create a compressed packet that was actually bigger than an escape packet would be,
// 			chuck it and do an escape packet
// 		*/
// 		minBits = BitBufferGetPosition (bitstream) - BitBufferGetPosition (&startBits) ;
// 		if (minBits >= escapeBits)
// 		{
// 			*bitstream = startBits ;		// reset bitstream state
// 			doEscape = true ;
// 			printf ("compressed frame too big: %u vs. %u\n", minBits, escapeBits) ;
// 		}
// 	}
// 
// 	if (doEscape == true)
// 	{
// 		// write bitstream header and coefs
// 		BitBufferWrite (bitstream, 0, 12) ;
// 		BitBufferWrite (bitstream, (partialFrame << 3) | 1, 4) ;	// LSB = 1 means "frame not compressed"
// 		if (partialFrame)
// 			BitBufferWrite (bitstream, numSamples, 32) ;
// 
// 		// just copy the input data to the output buffer
// 		switch (p->mBitDepth)
// 		{
// 			case 16:
// 				for (indx = 0 ; indx < (numSamples * stride) ; indx += stride)
// 					BitBufferWrite (bitstream, inputBuffer [indx] >> 16, 16) ;
// 				break ;
// 			case 20:
// 				// convert 20-bit data to 32-bit for simplicity
// 				for (indx = 0 ; indx < (numSamples * stride) ; indx += stride)
// 					BitBufferWrite (bitstream, inputBuffer [indx] >> 12, 20) ;
// 				break ;
// 			case 24:
// 				// convert 24-bit data to 32-bit for simplicity
// 				for (indx = 0, indx2 = 0 ; indx < numSamples ; indx++, indx2 += stride)
// 				{
// 					p->mMixBufferU [indx] = inputBuffer [indx2] >> 8 ;
// 					BitBufferWrite (bitstream, p->mMixBufferU [indx], 24) ;
// 				}
// 				break ;
// 			case 32:
// 				for (indx = 0 ; indx < (numSamples * stride) ; indx += stride)
// 					BitBufferWrite (bitstream, inputBuffer [indx], 32) ;
// 				break ;
// 		}
// #if VERBOSE_DEBUG
// 		DebugMsg ("escape!: %u vs %u\n", minBits, (numSamples * p->mBitDepth)) ;
// #endif
// 	}
// 
// Exit:
// 	return status ;
// }

