// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/ALAC/alac_encoder.c
int32_t
alac_encode (ALAC_ENCODER *p, uint32_t numSamples,
			const int32_t * theReadBuffer, unsigned char * theWriteBuffer, uint32_t * ioNumBytes)
{
	uint32_t		outputSize ;
	BitBuffer		bitstream ;
	int32_t			status ;
	uint32_t 		numChannels = p->mNumChannels ;

	// make sure we handle this bit-depth before we get going
	RequireAction ((p->mBitDepth == 16) || (p->mBitDepth == 20) || (p->mBitDepth == 24) || (p->mBitDepth == 32), return kALAC_ParamError ;) ;

	// create a bit buffer structure pointing to our output buffer
	BitBufferInit (&bitstream, theWriteBuffer, p->mMaxOutputBytes) ;

	if (numChannels == 2)
	{
		// add 3-bit frame start tag ID_CPE = channel pair & 4-bit element instance tag = 0
		BitBufferWrite (&bitstream, ID_CPE, 3) ;
		BitBufferWrite (&bitstream, 0, 4) ;

		// encode stereo input buffer
		if (p->mFastMode == false)
			status = EncodeStereo (p, &bitstream, theReadBuffer, 2, 0, numSamples) ;
		else
			status = EncodeStereoFast (p, &bitstream, theReadBuffer, 2, 0, numSamples) ;
		RequireNoErr (status, goto Exit ;) ;
	}
	else if (numChannels == 1)
	{
		// add 3-bit frame start tag ID_SCE = mono channel & 4-bit element instance tag = 0
		BitBufferWrite (&bitstream, ID_SCE, 3) ;
		BitBufferWrite (&bitstream, 0, 4) ;

		// encode mono input buffer
		status = EncodeMono (p, &bitstream, theReadBuffer, 1, 0, numSamples) ;
		RequireNoErr (status, goto Exit ;) ;
	}
	else
	{
		const int32_t *		inputBuffer ;
		uint32_t			tag ;
		uint32_t			channelIndex ;
		uint8_t				stereoElementTag ;
		uint8_t				monoElementTag ;
		uint8_t				lfeElementTag ;

		inputBuffer		= theReadBuffer ;

		stereoElementTag	= 0 ;
		monoElementTag		= 0 ;
		lfeElementTag		= 0 ;

		for (channelIndex = 0 ; channelIndex < numChannels ;)
		{
			tag = (sChannelMaps [numChannels - 1] & (0x7ul << (channelIndex * 3))) >> (channelIndex * 3) ;

			BitBufferWrite (&bitstream, tag, 3) ;
			switch (tag)
			{
				case ID_SCE:
					// mono
					BitBufferWrite (&bitstream, monoElementTag, 4) ;

					status = EncodeMono (p, &bitstream, inputBuffer, numChannels, channelIndex, numSamples) ;

					inputBuffer += 1 ;
					channelIndex++ ;
					monoElementTag++ ;
					break ;

				case ID_CPE:
					// stereo
					BitBufferWrite (&bitstream, stereoElementTag, 4) ;

					status = EncodeStereo (p, &bitstream, inputBuffer, numChannels, channelIndex, numSamples) ;

					inputBuffer += 2 ;
					channelIndex += 2 ;
					stereoElementTag++ ;
					break ;

				case ID_LFE:
					// LFE channel (subwoofer)
					BitBufferWrite (&bitstream, lfeElementTag, 4) ;

					status = EncodeMono (p, &bitstream, inputBuffer, numChannels, channelIndex, numSamples) ;

					inputBuffer += 1 ;
					channelIndex++ ;
					lfeElementTag++ ;
					break ;

				default:
					printf ("That ain't right! (%u)\n", tag) ;
					status = kALAC_ParamError ;
					goto Exit ;
			}

			RequireNoErr (status, goto Exit ;) ;
		}
	}

#if VERBOSE_DEBUG
{
	// if there is room left in the output buffer, add some random fill data to test decoder
	int32_t			bitsLeft ;
	int32_t			bytesLeft ;

	bitsLeft = BitBufferGetPosition (&bitstream) - 3 ;	// - 3 for ID_END tag
	bytesLeft = bitstream.byteSize - ((bitsLeft + 7) / 8) ;

	if ((bytesLeft > 20) && ((bytesLeft & 0x4u) != 0))
		AddFiller (&bitstream, bytesLeft) ;
}
#endif

	// add 3-bit frame end tag: ID_END
	BitBufferWrite (&bitstream, ID_END, 3) ;

	// byte-align the output data
	BitBufferByteAlign (&bitstream, true) ;

	outputSize = BitBufferGetPosition (&bitstream) / 8 ;
	//Assert (outputSize <= mMaxOutputBytes) ;


	// all good, let iTunes know what happened and remember the total number of input sample frames
	*ioNumBytes = outputSize ;
	//mEncodedFrames		   	   += encodeMsg->numInputSamples ;

	// gather encoding stats
	p->mTotalBytesGenerated += outputSize ;
	p->mMaxFrameBytes = MAX (p->mMaxFrameBytes, outputSize) ;

	status = ALAC_noErr ;

Exit:
	return status ;
}

// the below code fragment can be found in:
// src/ALAC/ALACDecoder.h
class ALACDecoder
{
	public:
		ALACDecoder () ;
		~ALACDecoder () ;

		int32_t	Init (void * inMagicCookie, uint32_t inMagicCookieSize) ;
		int32_t	Decode (struct BitBuffer * bits, uint8_t * sampleBuffer, uint32_t numSamples, uint32_t numChannels, uint32_t * outNumSamples) ;

	public:
		// decoding parameters (public for use in the analyzer)
		ALACSpecificConfig		mConfig ;

	protected:
		int32_t	FillElement (struct BitBuffer * bits) ;
		int32_t	DataStreamElement (struct BitBuffer * bits) ;

		uint16_t			mActiveElements ;

		// decoding buffers
		int32_t *			mMixBufferU ;
		int32_t *			mMixBufferV ;
		int32_t *			mPredictor ;
		uint16_t *			mShiftBuffer ;	// note: this points to mPredictor's memory but different
											//		 variable for clarity and type difference
}

// the below code fragment can be found in:
// src/ALAC/alac_decoder.c
int32_t
alac_decoder_init (ALAC_DECODER *p, void * inMagicCookie, uint32_t inMagicCookieSize)
{
	int32_t		status = ALAC_noErr ;
	ALACSpecificConfig theConfig ;
	uint8_t * theActualCookie = (uint8_t *) inMagicCookie ;
	uint32_t theCookieBytesRemaining = inMagicCookieSize ;

	// For historical reasons the decoder needs to be resilient to magic cookies vended by older encoders.
	// As specified in the ALACMagicCookieDescription.txt document, there may be additional data encapsulating
	// the ALACSpecificConfig. This would consist of format ('frma') and 'alac' atoms which precede the
	// ALACSpecificConfig.
	// See ALACMagicCookieDescription.txt for additional documentation concerning the 'magic cookie'

	// skip format ('frma') atom if present
	if (theActualCookie [4] == 'f' && theActualCookie [5] == 'r' && theActualCookie [6] == 'm' && theActualCookie [7] == 'a')
	{
		theActualCookie += 12 ;
		theCookieBytesRemaining -= 12 ;
	}

	// skip 'alac' atom header if present
	if (theActualCookie [4] == 'a' && theActualCookie [5] == 'l' && theActualCookie [6] == 'a' && theActualCookie [7] == 'c')
	{
		theActualCookie += 12 ;
		theCookieBytesRemaining -= 12 ;
	}

	// read the ALACSpecificConfig
	if (theCookieBytesRemaining >= sizeof (ALACSpecificConfig))
	{
		theConfig.frameLength = psf_get_be32 (theActualCookie, offsetof (ALACSpecificConfig, frameLength)) ;

		if (theConfig.frameLength > ALAC_FRAME_LENGTH)
			return fALAC_FrameLengthError ;

		theConfig.compatibleVersion = theActualCookie [offsetof (ALACSpecificConfig, compatibleVersion)] ;
		theConfig.bitDepth = theActualCookie [offsetof (ALACSpecificConfig, bitDepth)] ;
		theConfig.pb = theActualCookie [offsetof (ALACSpecificConfig, pb)] ;
		theConfig.mb = theActualCookie [offsetof (ALACSpecificConfig, mb)] ;
		theConfig.kb = theActualCookie [offsetof (ALACSpecificConfig, kb)] ;
		theConfig.numChannels = theActualCookie [offsetof (ALACSpecificConfig, numChannels)] ;
		theConfig.maxRun = psf_get_be16 (theActualCookie, offsetof (ALACSpecificConfig, maxRun)) ;
		theConfig.maxFrameBytes = psf_get_be32 (theActualCookie, offsetof (ALACSpecificConfig, maxFrameBytes)) ;
		theConfig.avgBitRate = psf_get_be32 (theActualCookie, offsetof (ALACSpecificConfig, avgBitRate)) ;
		theConfig.sampleRate = psf_get_be32 (theActualCookie, offsetof (ALACSpecificConfig, sampleRate)) ;

		p->mConfig = theConfig ;
		p->mNumChannels = theConfig.numChannels ;

		RequireAction (p->mConfig.compatibleVersion <= kALACVersion, return kALAC_IncompatibleVersion ;) ;
		RequireAction ((p->mConfig.bitDepth >= 8 && p->mConfig.bitDepth <= 32), return kALAC_BadBitWidth ;) ;
		RequireAction ((p->mMixBufferU != NULL) && (p->mMixBufferV != NULL) && (p->u.mPredictor != NULL),
						status = kALAC_MemFullError ; goto Exit ;) ;
	}
	else
	{
		status = kALAC_BadSpecificConfigSize ;
	}

	// skip to Channel Layout Info
	// theActualCookie += sizeof (ALACSpecificConfig) ;

	// Currently, the Channel Layout Info portion of the magic cookie (as defined in the
	// ALACMagicCookieDescription.txt document) is unused by the decoder.

Exit:
	return status ;
}

// the below code fragment can be found in:
// src/ALAC/alac_encoder.c
int32_t
alac_encoder_init (ALAC_ENCODER *p, uint32_t samplerate, uint32_t channels, uint32_t format_flags, uint32_t frameSize)
{
	int32_t			status ;

	p->mFrameSize = (frameSize > 0 && frameSize <= ALAC_FRAME_LENGTH) ? frameSize : ALAC_FRAME_LENGTH ;

	p->mOutputSampleRate = samplerate ;
	p->mNumChannels = channels ;
	switch (format_flags)
	{
		case 1:
			p->mBitDepth = 16 ;
			break ;
		case 2:
			p->mBitDepth = 20 ;
			break ;
		case 3:
			p->mBitDepth = 24 ;
			break ;
		case 4:
			p->mBitDepth = 32 ;
			break ;
		default:
			break ;
	}

	// set up default encoding parameters and state
	// - note: mFrameSize is set in the constructor or via alac_set_frame_size () which must be called before this routine
	for (uint32_t indx = 0 ; indx < kALACMaxChannels ; indx++)
		p->mLastMixRes [indx] = kDefaultMixRes ;

	// the maximum output frame size can be no bigger than (samplesPerBlock * numChannels * ((10 + sampleSize)/8) + 1)
	// but note that this can be bigger than the input size!
	// - since we don't yet know what our input format will be, use our max allowed sample size in the calculation
	p->mMaxOutputBytes = p->mFrameSize * p->mNumChannels * ((10 + kMaxSampleSize) / 8) + 1 ;

	status = ALAC_noErr ;

	// initialize coefs arrays once b/c retaining state across blocks actually improves the encode ratio
	for (int32_t channel = 0 ; channel < (int32_t) p->mNumChannels ; channel++)
	{
		for (int32_t search = 0 ; search < kALACMaxSearches ; search++)
		{
			init_coefs (p->mCoefsU [channel][search], DENSHIFT_DEFAULT, kALACMaxCoefs) ;
			init_coefs (p->mCoefsV [channel][search], DENSHIFT_DEFAULT, kALACMaxCoefs) ;
		}
	}

	return status ;
}

// the below code fragment can be found in:
// src/ALAC/alac_decoder.c
static int32_t
alac_data_stream_element (struct BitBuffer * bits)
{
	int32_t		data_byte_align_flag ;
	uint16_t		count ;

	// the tag associates this data stream element with a given audio element

	/* element_instance_tag = */ BitBufferReadSmall (bits, 4) ;

	data_byte_align_flag = BitBufferReadOne (bits) ;

	// 8-bit count or (8-bit + 8-bit count) if 8-bit count == 255
	count = BitBufferReadSmall (bits, 8) ;
	if (count == 255)
		count += BitBufferReadSmall (bits, 8) ;

	// the align flag means the bitstream should be byte-aligned before reading the following data bytes
	if (data_byte_align_flag)
		BitBufferByteAlign (bits, false) ;

	// skip the data bytes
	BitBufferAdvance (bits, count * 8) ;

	RequireAction (bits->cur <= bits->end, return kALAC_ParamError ;) ;

	return ALAC_noErr ;
}

