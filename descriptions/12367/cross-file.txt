// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// libavcodec/asvdec.c
static av_cold int decode_init(AVCodecContext *avctx)
{
    ASV1Context *const a = avctx->priv_data;
    const int scale      = avctx->codec_id == AV_CODEC_ID_ASV1 ? 1 : 2;
    int i;

    if (avctx->extradata_size < 1) {
        av_log(avctx, AV_LOG_WARNING, "No extradata provided\n");
    }

    ff_asv_common_init(avctx);
    ff_blockdsp_init(&a->bdsp, avctx);
    ff_idctdsp_init(&a->idsp, avctx);
    init_vlcs(a);
    ff_init_scantable(a->idsp.idct_permutation, &a->scantable, ff_asv_scantab);
    avctx->pix_fmt = AV_PIX_FMT_YUV420P;

    if (avctx->extradata_size < 1 || (a->inv_qscale = avctx->extradata[0]) == 0) {
        av_log(avctx, AV_LOG_ERROR, "illegal qscale 0\n");
        if (avctx->codec_id == AV_CODEC_ID_ASV1)
            a->inv_qscale = 6;
        else
            a->inv_qscale = 10;
    }

    for (i = 0; i < 64; i++) {
        int index = ff_asv_scantab[i];

        a->intra_matrix[i] = 64 * scale * ff_mpeg1_default_intra_matrix[index] /
                             a->inv_qscale;
    }

    return 0;
}

// the below code fragment can be found in:
// libavcodec/aic.c
static av_cold int aic_decode_init(AVCodecContext *avctx)
{
    AICContext *ctx = avctx->priv_data;
    int i;
    uint8_t scan[64];

    ctx->avctx = avctx;

    avctx->pix_fmt = AV_PIX_FMT_YUV420P;

    ff_idctdsp_init(&ctx->idsp, avctx);

    for (i = 0; i < 64; i++)
        scan[i] = i;
    ff_init_scantable(ctx->idsp.idct_permutation, &ctx->scantable, scan);
    for (i = 0; i < 64; i++)
        ctx->quant_matrix[ctx->idsp.idct_permutation[i]] = aic_quant_matrix[i];

    ctx->mb_width  = FFALIGN(avctx->width,  16) >> 4;
    ctx->mb_height = FFALIGN(avctx->height, 16) >> 4;

    ctx->num_x_slices = (ctx->mb_width + 15) >> 4;
    ctx->slice_width  = 16;
    for (i = 1; i < ctx->mb_width; i++) {
        if (!(ctx->mb_width % i) && (ctx->mb_width / i <= 32)) {
            ctx->slice_width  = ctx->mb_width / i;
            ctx->num_x_slices = i;
            break;
        }
    }

    ctx->slice_data = av_malloc_array(ctx->slice_width, AIC_BAND_COEFFS
                                * sizeof(*ctx->slice_data));
    if (!ctx->slice_data) {
        av_log(avctx, AV_LOG_ERROR, "Error allocating slice buffer\n");

        return AVERROR(ENOMEM);
    }

    for (i = 0; i < NUM_BANDS; i++)
        ctx->data_ptr[i] = ctx->slice_data + ctx->slice_width
                                             * aic_band_off[i];

    return 0;
}

// the below code fragment can be found in:
// libavcodec/magicyuv.c
static int magy_init_thread_copy(AVCodecContext *avctx)
{
    MagicYUVContext *s = avctx->priv_data;
    int i;

    for (i = 0; i < FF_ARRAY_ELEMS(s->slices); i++) {
        s->slices[i] = NULL;
        s->slices_size[i] = 0;
    }

    return 0;
}

// the below code fragment can be found in:
// libavcodec/mdec.c
static av_cold int decode_init(AVCodecContext *avctx)
{
    MDECContext * const a = avctx->priv_data;
    int i;

    a->mb_width  = (avctx->coded_width  + 15) / 16;
    a->mb_height = (avctx->coded_height + 15) / 16;

    a->avctx           = avctx;

    ff_blockdsp_init(&a->bdsp, avctx);
    ff_bswapdsp_init(&a->bbdsp);
    ff_idctdsp_init(&a->idsp, avctx);
    ff_mpeg12_init_vlcs();
    ff_init_scantable(a->idsp.idct_permutation, &a->scantable,
                      ff_zigzag_direct);

    avctx->pix_fmt  = AV_PIX_FMT_YUVJ420P;
    avctx->color_range = AVCOL_RANGE_JPEG;

    /* init q matrix */
    for (i = 0; i < 64; i++) {
        int j = a->idsp.idct_permutation[i];

        a->quant_matrix[j] = ff_mpeg1_default_intra_matrix[i];
    }

    return 0;
}

// the below code fragment can be found in:
// libavcodec/4xm.c
static int decode_frame(AVCodecContext *avctx, void *data,
                        int *got_frame, AVPacket *avpkt)
{
    const uint8_t *buf    = avpkt->data;
    int buf_size          = avpkt->size;
    FourXContext *const f = avctx->priv_data;
    AVFrame *picture      = data;
    int i, frame_4cc, frame_size, ret;

    if (buf_size < 20)
        return AVERROR_INVALIDDATA;

    av_assert0(avctx->width % 16 == 0 && avctx->height % 16 == 0);

    if (buf_size < AV_RL32(buf + 4) + 8) {
        av_log(f->avctx, AV_LOG_ERROR, "size mismatch %d %"PRIu32"\n",
               buf_size, AV_RL32(buf + 4));
        return AVERROR_INVALIDDATA;
    }

    frame_4cc = AV_RL32(buf);

    if (frame_4cc == AV_RL32("cfrm")) {
        int free_index       = -1;
        int id, whole_size;
        const int data_size  = buf_size - 20;
        CFrameBuffer *cfrm;

        if (f->version <= 1) {
            av_log(f->avctx, AV_LOG_ERROR, "cfrm in version %d\n", f->version);
            return AVERROR_INVALIDDATA;
        }

        id         = AV_RL32(buf + 12);
        whole_size = AV_RL32(buf + 16);

        if (data_size < 0 || whole_size < 0) {
            av_log(f->avctx, AV_LOG_ERROR, "sizes invalid\n");
            return AVERROR_INVALIDDATA;
        }

        for (i = 0; i < CFRAME_BUFFER_COUNT; i++)
            if (f->cfrm[i].id && f->cfrm[i].id < avctx->frame_number)
                av_log(f->avctx, AV_LOG_ERROR, "lost c frame %d\n",
                       f->cfrm[i].id);

        for (i = 0; i < CFRAME_BUFFER_COUNT; i++) {
            if (f->cfrm[i].id == id)
                break;
            if (f->cfrm[i].size == 0)
                free_index = i;
        }

        if (i >= CFRAME_BUFFER_COUNT) {
            i             = free_index;
            f->cfrm[i].id = id;
        }
        cfrm = &f->cfrm[i];

        if (data_size > UINT_MAX -  cfrm->size - AV_INPUT_BUFFER_PADDING_SIZE)
            return AVERROR_INVALIDDATA;

        cfrm->data = av_fast_realloc(cfrm->data, &cfrm->allocated_size,
                                     cfrm->size + data_size + AV_INPUT_BUFFER_PADDING_SIZE);
        // explicit check needed as memcpy below might not catch a NULL
        if (!cfrm->data) {
            av_log(f->avctx, AV_LOG_ERROR, "realloc failure\n");
            return AVERROR(ENOMEM);
        }

        memcpy(cfrm->data + cfrm->size, buf + 20, data_size);
        cfrm->size += data_size;

        if (cfrm->size >= whole_size) {
            buf        = cfrm->data;
            frame_size = cfrm->size;

            if (id != avctx->frame_number)
                av_log(f->avctx, AV_LOG_ERROR, "cframe id mismatch %d %d\n",
                       id, avctx->frame_number);

            if (f->version <= 1)
                return AVERROR_INVALIDDATA;

            cfrm->size = cfrm->id = 0;
            frame_4cc  = AV_RL32("pfrm");
        } else
            return buf_size;
    } else {
        buf        = buf      + 12;
        frame_size = buf_size - 12;
    }

    if ((ret = ff_get_buffer(avctx, picture, 0)) < 0)
        return ret;

    if (frame_4cc == AV_RL32("ifr2")) {
        picture->pict_type = AV_PICTURE_TYPE_I;
        if ((ret = decode_i2_frame(f, buf - 4, frame_size + 4)) < 0) {
            av_log(f->avctx, AV_LOG_ERROR, "decode i2 frame failed\n");
            return ret;
        }
    } else if (frame_4cc == AV_RL32("ifrm")) {
        picture->pict_type = AV_PICTURE_TYPE_I;
        if ((ret = decode_i_frame(f, buf, frame_size)) < 0) {
            av_log(f->avctx, AV_LOG_ERROR, "decode i frame failed\n");
            return ret;
        }
    } else if (frame_4cc == AV_RL32("pfrm") || frame_4cc == AV_RL32("pfr2")) {
        picture->pict_type = AV_PICTURE_TYPE_P;
        if ((ret = decode_p_frame(f, buf, frame_size)) < 0) {
            av_log(f->avctx, AV_LOG_ERROR, "decode p frame failed\n");
            return ret;
        }
    } else if (frame_4cc == AV_RL32("snd_")) {
        av_log(avctx, AV_LOG_ERROR, "ignoring snd_ chunk length:%d\n",
               buf_size);
    } else {
        av_log(avctx, AV_LOG_ERROR, "ignoring unknown chunk length:%d\n",
               buf_size);
    }

    picture->key_frame = picture->pict_type == AV_PICTURE_TYPE_I;

    av_image_copy_plane(picture->data[0], picture->linesize[0],
                        (const uint8_t*)f->frame_buffer,  avctx->width * 2,
                        avctx->width * 2, avctx->height);
    FFSWAP(uint16_t *, f->frame_buffer, f->last_frame_buffer);

    *got_frame = 1;

    emms_c();

    return buf_size;
}

