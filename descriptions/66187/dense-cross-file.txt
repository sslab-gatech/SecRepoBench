// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/filters/load_text.c
static GF_Err parse_srt_line(GF_TXTIn *ctx, char *szLine, u32 *char_l, Bool *set_start_c, Bool *set_end_c)
{
	u32 i, char_line, j, rem_styles, len;
	Bool rem_color;
	char *ptr = szLine;
	unsigned short uniLine[5000], uniText[5000], *sptr;
	char szText[2048];

	len = gf_utf8_mbstowcs(uniLine, 5000, (const char **) &ptr);
	if (len == GF_UTF8_FAIL) {
		GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[TXTIn] Invalid UTF data (line %d)\n", ctx->curLine));
		ctx->state = 0;
		return GF_NON_COMPLIANT_BITSTREAM;
	}

	i=j=0;
	rem_styles = 0;
	rem_color = 0;
	while (i<len) {
		u32 font_style = 0;
		u32 style_nb_chars = 0;
		u32 style_def_type = 0;

		if ( (uniLine[i]=='<') && (uniLine[i+2]=='>')) {
			style_nb_chars = 3;
			style_def_type = 1;
		}
		else if ( (uniLine[i]=='<') && (uniLine[i+1]=='/') && (uniLine[i+3]=='>')) {
			style_def_type = 2;
			style_nb_chars = 4;
		}
		else if (uniLine[i]=='<')  {
			const unsigned short* src = uniLine + i;
			u32 alen = gf_utf8_wcstombs(szLine, 2048, (const unsigned short**) & src);
			if (alen == GF_UTF8_FAIL) alen = 0;
			szLine[alen] = 0;
			strlwr(szLine);
			if (!strncmp(szLine, "<font ", 6) ) {
				char *a_sep = strstr(szLine, "color");
				if (a_sep) a_sep = strstr(szLine, "=");
				if (a_sep) a_sep++;
				while (a_sep && a_sep[0]) {
					if (a_sep[0]!=' ') break;
					a_sep++;
				}
				if (a_sep) {
					char *e_sep;
					if ((a_sep[0]=='"') || ((a_sep[0]=='\''))) {
						e_sep = strchr(a_sep+1, a_sep[0]);
						a_sep++;
					} else {
						e_sep=a_sep;
						while (e_sep[0]) {
							if (e_sep[0]==' ') break;
							if (e_sep[0]=='>') break;
							e_sep++;
						}
					}

					if (e_sep) {
						char c_sep = e_sep[0];
						e_sep[0] = 0;
						font_style = gf_color_parse(a_sep);
						e_sep[0] = c_sep;
						if (c_sep!='>')
							e_sep = strchr(e_sep+1, '>');
						if (e_sep) {
							style_nb_chars = (u32) (1 + e_sep - szLine);
							style_def_type = 1;
						}
					}
				}
			}
			else if (!strncmp(szLine, "</font>", 7) ) {
				style_nb_chars = 7;
				style_def_type = 2;
				font_style = 0xFFFFFFFF;
			}


			else if (!strncmp(szLine, "<strike>", 8) ) {
				style_nb_chars = 8;
				style_def_type = 1;
			}
			else if (!strncmp(szLine, "</strike>", 9) ) {
				style_nb_chars = 9;
				style_def_type = 2;
				font_style = 0xFFFFFFFF;
			}
			//skip unknown
			else {
				char *a_sep = strstr(szLine, ">");
				if (a_sep) {
					style_nb_chars = (u32) (1 + a_sep - szLine);
					i += style_nb_chars;
					continue;
				}
			}

		}

		/*start of new style*/
		if (style_def_type==1)  {
			/*store prev style*/
			if (*set_end_c) {
				gf_assert(*set_start_c);
				gf_isom_text_add_style(ctx->samp, &ctx->style);
				*set_end_c = *set_start_c = GF_FALSE;
				ctx->style.style_flags &= ~rem_styles;
				rem_styles = 0;
				if (rem_color) {
					ctx->style.text_color = ctx->default_color;
					rem_color = 0;
				}
			}
			if (*set_start_c && (ctx->style.startCharOffset != j)) {
				ctx->style.endCharOffset = *char_l + j;
				if (ctx->style.style_flags) gf_isom_text_add_style(ctx->samp, &ctx->style);
			}
			switch (uniLine[i+1]) {
			case 'b':
			case 'B':
				ctx->style.style_flags |= GF_TXT_STYLE_BOLD;
				*set_start_c = GF_TRUE;
				ctx->style.startCharOffset = *char_l + j;
				break;
			case 'i':
			case 'I':
				ctx->style.style_flags |= GF_TXT_STYLE_ITALIC;
				*set_start_c = GF_TRUE;
				ctx->style.startCharOffset = *char_l + j;
				break;
			case 'u':
			case 'U':
				ctx->style.style_flags |= GF_TXT_STYLE_UNDERLINED;
				*set_start_c = GF_TRUE;
				ctx->style.startCharOffset = *char_l + j;
				break;
			case 's':
			case 'S':
				ctx->style.style_flags |= GF_TXT_STYLE_STRIKETHROUGH;
				*set_start_c = GF_TRUE;
				ctx->style.startCharOffset = *char_l + j;
				break;
			case 'f':
			case 'F':
				if (font_style) {
					ctx->style.text_color = font_style;
					*set_start_c = GF_TRUE;
					ctx->style.startCharOffset = *char_l + j;
				}
				break;
			}
			i += style_nb_chars;
			continue;
		}

		/*end of prev style*/
		if (style_def_type==2)  {
			switch (uniLine[i+2]) {
			case 'b':
			case 'B':
				rem_styles |= GF_TXT_STYLE_BOLD;
				*set_end_c = GF_TRUE;
				ctx->style.endCharOffset = *char_l + j;
				break;
			case 'i':
			case 'I':
				rem_styles |= GF_TXT_STYLE_ITALIC;
				*set_end_c = GF_TRUE;
				ctx->style.endCharOffset = *char_l + j;
				break;
			case 'u':
			case 'U':
				rem_styles |= GF_TXT_STYLE_UNDERLINED;
				*set_end_c = GF_TRUE;
				ctx->style.endCharOffset = *char_l + j;
				break;
			case 's':
			case 'S':
				rem_styles |= GF_TXT_STYLE_STRIKETHROUGH;
				*set_end_c = GF_TRUE;
				ctx->style.endCharOffset = *char_l + j;
				break;
			case 'f':
			case 'F':
				if (font_style) {
					rem_color = 1;
					*set_end_c = GF_TRUE;
					ctx->style.endCharOffset = *char_l + j;
				}
			}
			i+=style_nb_chars;
			continue;
		}
		/*store style*/
		if (*set_end_c) {
			gf_isom_text_add_style(ctx->samp, &ctx->style);
			*set_end_c = GF_FALSE;
			*set_start_c = GF_TRUE;
			ctx->style.startCharOffset = *char_l + j;
			ctx->style.style_flags &= ~rem_styles;
			rem_styles = 0;
			ctx->style.text_color = ctx->default_color;
			rem_color = 0;
		}

		uniText[j] = uniLine[i];
		j++;
		i++;
	}
	/*store last style*/
	if (*set_end_c) {
		gf_isom_text_add_style(ctx->samp, &ctx->style);
		*set_end_c = GF_FALSE;
		*set_start_c = GF_TRUE;
		ctx->style.startCharOffset = *char_l + j;
		ctx->style.style_flags &= ~rem_styles;
	}

	char_line = j;
	uniText[j] = 0;

	sptr = (u16 *) uniText;
	len = gf_utf8_wcstombs(szText, 5000, (const u16 **) &sptr);
	if (len == GF_UTF8_FAIL) len = 0;

	gf_isom_text_add_text(ctx->samp, szText, len);
	if (ctx->forced_sub) gf_isom_text_set_forced(ctx->samp, GF_TRUE);
	*char_l += char_line;
	return GF_OK;
}

// the below code fragment can be found in:
// src/filters/load_text.c
s32 gf_text_get_utf_type(GF_TXTIn *ctx, FILE *in_src)
{
	u32 read;
	unsigned char BOM[5];
	read = (u32) gf_fread(BOM, 5, in_src);
	if ((s32) read < 1)
		return -1;

	if ((BOM[0]==0xFF) && (BOM[1]==0xFE)) {
		/*UTF32 not supported*/
		if (!BOM[2] && !BOM[3])
			return -1;
		gf_fseek(in_src, 2, SEEK_SET);
		return 3;
	}
	if ((BOM[0]==0xFE) && (BOM[1]==0xFF)) {
		/*UTF32 not supported*/
		if (!BOM[2] && !BOM[3])
			return -1;
		gf_fseek(in_src, 2, SEEK_SET);
		return 2;
	} else if ((BOM[0]==0xEF) && (BOM[1]==0xBB) && (BOM[2]==0xBF)) {
		gf_fseek(in_src, 3, SEEK_SET);
		return 1;
	}
	gf_fseek(in_src, 0, SEEK_SET);

	if (BOM[0]<0x80) {
		return 0;
	}
	//check if ad-hoc charset is set
	const char *opt = gf_opts_get_key("core", "charset");
	if (ctx->ipid) {
		const GF_PropertyValue *p = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_CHARSET);
		if (p && p->value.string) opt = p->value.string;
	}
	if (opt) {
		if (!stricmp(opt, "utf8") || !stricmp(opt, "utf-8")) return 1;
		if (!stricmp(opt, "utf16") || !stricmp(opt, "utf-16")) return 2;
		if (!stricmp(opt, "utf16be") || !stricmp(opt, "utf-16be") || !stricmp(opt, "utf-16-be") || !stricmp(opt, "utf16-be")) return 3;
		return 0;
	}
	//otherwise if we have legal UTF8, assume utf8
	if (gf_utf8_is_legal(BOM, 2) || gf_utf8_is_legal(BOM, 3) || gf_utf8_is_legal(BOM, 4) ) {
		return 0;
	}
	GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[TXTIn] Unknown text encoding for PID %s, defaulting to passthrough - use `-charset` to override\n", gf_filter_pid_get_name(ctx->ipid)));
	return 0;
}

// the below code fragment can be found in:
// src/filters/load_text.c
static GF_Err gf_text_guess_format(GF_TXTIn *ctx, const char *filename, u32 *fmt)
{
	char szLine[2048], *line;
	u32 val;
	s32 uni_type;
	FILE *test = gf_fopen(filename, "rb");
	if (!test) return GF_URL_ERROR;
	uni_type = gf_text_get_utf_type(ctx, test);

	if (uni_type>1) {
		const u16 *sptr;
		char szUTF[1024];
		u32 read = (u32) gf_fread(szUTF, 1023, test);
		if ((s32) read < 0) {
			gf_fclose(test);
			return GF_IO_ERR;
		}
		szUTF[read]=0;
		sptr = (u16*)szUTF;
		/*read = (u32) */gf_utf8_wcstombs(szLine, read, &sptr);
	} else {
		val = (u32) gf_fread(szLine, 1024, test);
		if ((s32) val<0) return GF_IO_ERR;

		szLine[val]=0;
	}
	REM_TRAIL_MARKS(szLine, "\r\n\t ")

	//strip all spaces and \r\n\t
	line = szLine;
	while (line[0] && strchr("\n\r\t ", (char) line[0]))
		line ++;


	*fmt = GF_TXTIN_MODE_NONE;
	if ((line[0]=='{') && strstr(line, "}{")) *fmt = GF_TXTIN_MODE_SUB;
	else if (line[0] == '<') {
		char *ext = gf_file_ext_start(filename);
		if (ext && !strnicmp(ext, ".ttxt", 5)) *fmt = GF_TXTIN_MODE_TTXT;
		else if (ext && !strnicmp(ext, ".ttml", 5)) *fmt = GF_TXTIN_MODE_TTML;
		ext = strstr(line, "?>");
		if (ext) ext += 2;
		if (ext && !ext[0]) {
			if (!gf_fgets(szLine, 2048, test))
				szLine[0] = '\0';
		}
		if (strstr(szLine, "x-quicktime-tx3g") || strstr(szLine, "text3GTrack")) *fmt = GF_TXTIN_MODE_TEXML;
		else if (strstr(szLine, "TextStream")) *fmt = GF_TXTIN_MODE_TTXT;
		else if (strstr(szLine, "<tt ") || strstr(szLine, ":tt ")) *fmt = GF_TXTIN_MODE_TTML;
	}
	else if (strstr(line, "WEBVTT") )
		*fmt = GF_TXTIN_MODE_WEBVTT;
	else if (strstr(line, " --> ") )
		*fmt = GF_TXTIN_MODE_SRT; /* might want to change the default to WebVTT */

	else if (!strncmp(line, "FWS", 3) || !strncmp(line, "CWS", 3))
		*fmt = GF_TXTIN_MODE_SWF_SVG;
	else if (!strncmp(line, "[Script Info]", 13) )
		*fmt = GF_TXTIN_MODE_SSA;

	gf_fclose(test);
	return GF_OK;
}

// the below code fragment can be found in:
// src/filters/load_text.c
static GF_Err gf_text_process_ssa(GF_Filter *filter, GF_TXTIn *ctx, GF_FilterPacket *ipck)
{
	u32 i, j, len, line;
	GF_TextSample *samp;
	char szLine[2048], szText[2048];

	//same setup as for srt
	if (!ctx->is_setup) {
		ctx->is_setup = GF_TRUE;
		GF_Err e = txtin_setup_srt(filter, ctx, GF_FALSE);
		if (e || !ctx->unframed) return e;
	}
	if (!ctx->opid) return GF_NOT_SUPPORTED;
	if (!ctx->unframed) {
		if (!ctx->playstate) return GF_OK;
		else if (ctx->playstate==2) return GF_EOS;
	}

	if (ctx->seek_state==1) {
		ctx->seek_state = 2;
		gf_fseek(ctx->src, 0, SEEK_SET);
	}

	line = 0;

	while (1) {
		char *start_p, *end_p;
		u32 eh, em, es, ems, nb_c;
		char *sOK = gf_text_get_utf8_line(szLine, 2048, ctx->src, ctx->unicode_type);
		if (!sOK) break;

		REM_TRAIL_MARKS(szLine, "\r\n\t ")

		line++;
		len = (u32) strlen(szLine);
		if (!len) continue;

		if (!ctx->unframed) {
			if (strncmp(szLine, "Dialogue: ", 10)) continue;

			start_p = strchr(szLine+10, ',');
			if (!start_p) continue;
			end_p = strchr(start_p+1, ',');
			if (!end_p) continue;
			end_p[0] = 0;
			start_p++;
			if (sscanf(start_p, "%u:%u:%u.%u", &eh, &em, &es, &ems) != 4) {
				eh = 0;
				if (sscanf(start_p, "%u:%u.%u", &em, &es, &ems) != 3) {
					continue;
				}
			}
			ctx->start = (3600*eh + 60*em + es)*1000 + ems;

			start_p = end_p+1;
			end_p = strchr(start_p, ',');
			if (!end_p) continue;
			end_p[0] = 0;

			if (sscanf(start_p, "%u:%u:%u.%u", &eh, &em, &es, &ems) != 4) {
				eh = 0;
				if (sscanf(start_p, "%u:%u.%u", &em, &es, &ems) != 3) {
					continue;
				}
			}
			ctx->end = (3600*eh + 60*em + es)*1000 + ems;
			//skip 6 commas
			start_p = end_p+1;
			nb_c=6;
		} else {
			start_p = szLine;
			nb_c=8;
		}

		while (nb_c) {
			end_p = strchr(start_p, ',');
			if (!end_p) break;
			start_p = end_p+1;
			nb_c--;
		}
		if (nb_c) continue;

		if (ctx->start > ctx->end) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[TXTIn] corrupted SSA frame (line %d) - ends (at %u ms) before start of current frame (%u ms) - skipping\n", line, ctx->end, ctx->start));
			continue;
		}

		/*make stream start at 0 by inserting a fake AU*/
		if (ctx->first_samp && (ctx->start > 0)) {
			txtin_process_send_text_sample(ctx, ctx->samp, 0, (u32) ctx->start, GF_TRUE);
			ctx->first_samp = GF_FALSE;
		}
		else if (ctx->prev_end && (ctx->start != ctx->prev_end) && (ctx->state<=2)) {
			GF_TextSample * empty_samp = gf_isom_new_text_sample();
			txtin_process_send_text_sample(ctx, empty_samp, ctx->prev_end, (u32) (ctx->start - ctx->prev_end), GF_TRUE );
			gf_isom_delete_text_sample(empty_samp);
		}

		u32 char_len=0;
		Bool set_start_char=GF_FALSE, set_end_char=GF_FALSE;
		ctx->style.startCharOffset = ctx->style.endCharOffset = 0;
		gf_isom_text_reset(ctx->samp);

		memset(szText, 0, 2048);
		i=j=0;
		while (1) {
			char c = start_p[i];
			if (c == 0) {
				szText[j] = 0;
				break;
			}
			if (c=='\\') {
				if ((start_p[i+1] == 'N') || (start_p[i+1] == 'n')) {
					szText[j] = 0;
					parse_srt_line(ctx, szText, &char_len, &set_start_char, &set_end_char);

					j=0;
					i+=2;
					memset(szText, 0, 2048);
					gf_isom_text_add_text(ctx->samp, "\n", 1);
					char_len += 1;
					continue;
				}
			} else if (c=='{') {
				if (start_p[i+1] == '\\') {
					u32 style = 0;
					u32 color=0;
					Bool is_end = 0;
					if (start_p[i+2] == 'i') style = 1;
					else if (start_p[i+2] == 'b') style = 2;
					else if (start_p[i+2] == 'u') style = 3;
					else if (start_p[i+2] == 'c') {
						if ((start_p[i+3] == '&') && (strlen(start_p+i+4)>8)) {
							char *col_p = start_p + i+5;
							style = 4;
							char szT[3];
							u32 r, g, b;
							szT[2]=0;
							szT[0]=col_p[0];
							szT[1]=col_p[1];
							sscanf(szT, "%x", &g);
							szT[0]=col_p[2];
							szT[1]=col_p[3];
							sscanf(szT, "%x", &b);
							szT[0]=col_p[4];
							szT[1]=col_p[5];
							sscanf(szT, "%x", &r);
							color = GF_COL_ARGB(0xFF, r, g, b);
						}
						else if (start_p[i+3] == '}') {
							is_end=GF_TRUE;
							style = 4;
						}
					}
					else if (start_p[i+2] == 's') style = 5;

					if (start_p[i+3] == '0') is_end=GF_TRUE;
					while (start_p[i] && (start_p[i]!='}')) i++;
					i++;

					if (style==1) {
						if (is_end) {strcat(szText, "</i>"); j+=4;}
						else {strcat(szText, "<i>"); j+=3;}
					} else if (style==2) {
						if (is_end) {strcat(szText, "</b>"); j+=4;}
						else {strcat(szText, "<b>"); j+=3;}
					} else if (style==3) {
						if (is_end) {strcat(szText, "</u>"); j+=4;}
						else {strcat(szText, "<u>"); j+=3;}
					} else if (style==4) {
						if (is_end) {strcat(szText, "</font>"); j+=7;}
						else {
							char szFont[100];
							sprintf(szFont, "<font color=\"0x%X\">", color);
							strcat(szText, szFont);
							j+=(u32) strlen(szFont);
						}
					} else if (style==5) {
						if (is_end) {strcat(szText, "</strike>"); j+=9;}
						else {strcat(szText, "<strike>"); j+=8;}
					}
					continue;
				}
			}
			szText[j] = c;
			j++;
			i++;
		}
		if (szText[0])
			parse_srt_line(ctx, szText, &char_len, &set_start_char, &set_end_char);

		txtin_process_send_text_sample(ctx, ctx->samp,  ctx->start, (u32) (ctx->end -  ctx->start), GF_TRUE);
		ctx->prev_end = ctx->end;

		gf_filter_pid_set_info(ctx->opid, GF_PROP_PID_DOWN_BYTES, &PROP_LONGUINT( gf_ftell(ctx->src)) );

		if (gf_filter_pid_would_block(ctx->opid))
			return GF_OK;
	}
	/*final flush*/
	if (ctx->end && !ctx->noflush) {
		samp = gf_isom_new_text_sample();
		txtin_process_send_text_sample(ctx, samp, ctx->end, 0, GF_TRUE);
		gf_isom_delete_text_sample(samp);
	}

	gf_filter_pid_set_info_str( ctx->opid, "ttxt:last_dur", &PROP_UINT(0) );

	return GF_EOS;
}

// the below code fragment can be found in:
// src/filters/load_text.c
static GF_Err gf_text_process_sub(GF_Filter *filter, GF_TXTIn *ctx, GF_FilterPacket *ipck)
{
	u32 i, j, len, line;
	GF_TextSample *samp;
	Double ts_scale;
	char szLine[2048], szTime[41], szText[2048];

	if (ctx->playstate==2)
		return GF_EOS;

	//same setup as for srt
	if (!ctx->is_setup) {
		ctx->is_setup = GF_TRUE;
		return txtin_setup_srt(filter, ctx, GF_FALSE);
	}
	if (!ctx->opid) return GF_NOT_SUPPORTED;
	if (!ctx->playstate) return GF_OK;
	else if (ctx->playstate==2) return GF_EOS;

	if (ctx->seek_state==1) {
		ctx->seek_state = 2;
		gf_fseek(ctx->src, 0, SEEK_SET);
	}

	if (ctx->fps.den && ctx->fps.num) {
		ts_scale = ((Double) ctx->fps.num) / ctx->fps.den;
	} else {
		ts_scale = 25;
	}

	line = 0;

	while (1) {
		char *sOK = gf_text_get_utf8_line(szLine, 2048, ctx->src, ctx->unicode_type);
		if (!sOK) break;

		REM_TRAIL_MARKS(szLine, "\r\n\t ")

		line++;
		len = (u32) strlen(szLine);
		if (!len) continue;

		i=0;
		if (szLine[i] != '{') {
			GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[TXTIn] Bad SUB file (line %d): expecting \"{\" got \"%c\"\n", line, szLine[i]));
			continue;
		}
		while (szLine[i+1] && szLine[i+1]!='}') {
			szTime[i] = szLine[i+1];
			i++;
			if (i>=40) break;
		}
		szTime[i] = 0;
		ctx->start = atoi(szTime);
		if (ctx->start < ctx->end) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[TXTIn] corrupted SUB frame (line %d) - starts (at %d ms) before end of previous one (%d ms) - adjusting time stamps\n", line, ctx->start, ctx->end));
			ctx->start = ctx->end;
		}
		j=i+2;
		i=0;
		if (szLine[i+j] != '{') {
			GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[TXTIn] Bad SUB file - expecting \"{\" got \"%c\"\n", szLine[i]));
			continue;
		}
		while (szLine[i+1+j] && szLine[i+1+j]!='}') {
			szTime[i] = szLine[i+1+j];
			i++;
			if (i>=40) break;
		}
		szTime[i] = 0;
		ctx->end = atoi(szTime);
		j+=i+2;

		if (ctx->start > ctx->end) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[TXTIn] corrupted SUB frame (line %d) - ends (at %d ms) before start of current frame (%d ms) - skipping\n", line, ctx->end, ctx->start));
			continue;
		}

		if (ctx->start && ctx->first_samp) {
			samp = gf_isom_new_text_sample();
			txtin_process_send_text_sample(ctx, samp, 0, (u32) (ts_scale*ctx->start), GF_TRUE);
			ctx->first_samp = GF_FALSE;
			gf_isom_delete_text_sample(samp);
		}

		for (i=j; i<len; i++) {
			if (szLine[i]=='|') {
				szText[i-j] = '\n';
			} else {
				szText[i-j] = szLine[i];
			}
		}
		szText[i-j] = 0;

		if (ctx->prev_end) {
			samp = gf_isom_new_text_sample();
			txtin_process_send_text_sample(ctx, samp, (u64) (ts_scale*(s64)ctx->prev_end), (u32) (ts_scale*(ctx->start - ctx->prev_end)), GF_TRUE);
			gf_isom_delete_text_sample(samp);
		}

		samp = gf_isom_new_text_sample();
		gf_isom_text_add_text(samp, szText, (u32) strlen(szText) );
		txtin_process_send_text_sample(ctx, samp, (u64) (ts_scale*(s64)ctx->start), (u32) (ts_scale*(ctx->end - ctx->start)), GF_TRUE);
		gf_isom_delete_text_sample(samp);

		ctx->prev_end = ctx->end;

		gf_filter_pid_set_info(ctx->opid, GF_PROP_PID_DOWN_BYTES, &PROP_LONGUINT( gf_ftell(ctx->src )) );

		if (gf_filter_pid_would_block(ctx->opid))
			return GF_OK;
	}
	/*final flush*/
	if (ctx->end && !ctx->noflush) {
		samp = gf_isom_new_text_sample();
		txtin_process_send_text_sample(ctx, samp, (u64) (ts_scale*(s64)ctx->end), 0, GF_TRUE);
		gf_isom_delete_text_sample(samp);
	}

	gf_filter_pid_set_info_str( ctx->opid, "ttxt:last_dur", &PROP_UINT(0) );

	return GF_EOS;
}

