// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/filters/load_text.c
static GF_Err gf_text_process_ssa(GF_Filter *filter, GF_TXTIn *ctx, GF_FilterPacket *ipck)
{
	u32 i, j, len, line;
	GF_TextSample *samp;
	char szLine[2048], szText[2048];

	//same setup as for srt
	if (!ctx->is_setup) {
		ctx->is_setup = GF_TRUE;
		GF_Err e = txtin_setup_srt(filter, ctx, GF_FALSE);
		if (e || !ctx->unframed) return e;
	}
	if (!ctx->opid) return GF_NOT_SUPPORTED;
	if (!ctx->unframed) {
		if (!ctx->playstate) return GF_OK;
		else if (ctx->playstate==2) return GF_EOS;
	}

	if (ctx->seek_state==1) {
		ctx->seek_state = 2;
		gf_fseek(ctx->src, 0, SEEK_SET);
	}

	line = 0;

	while (1) {
		char *start_p, *end_p;
		u32 eh, em, es, ems, nb_c;
		char *sOK = gf_text_get_utf8_line(szLine, 2048, ctx->src, ctx->unicode_type);
		if (!sOK) break;

		REM_TRAIL_MARKS(szLine, "\r\n\t ")

		line++;
		len = (u32) strlen(szLine);
		if (!len) continue;

		if (!ctx->unframed) {
			if (strncmp(szLine, "Dialogue: ", 10)) continue;

			start_p = strchr(szLine+10, ',');
			if (!start_p) continue;
			end_p = strchr(start_p+1, ',');
			if (!end_p) continue;
			end_p[0] = 0;
			start_p++;
			if (sscanf(start_p, "%u:%u:%u.%u", &eh, &em, &es, &ems) != 4) {
				eh = 0;
				if (sscanf(start_p, "%u:%u.%u", &em, &es, &ems) != 3) {
					continue;
				}
			}
			ctx->start = (3600*eh + 60*em + es)*1000 + ems;

			start_p = end_p+1;
			end_p = strchr(start_p, ',');
			if (!end_p) continue;
			end_p[0] = 0;

			if (sscanf(start_p, "%u:%u:%u.%u", &eh, &em, &es, &ems) != 4) {
				eh = 0;
				if (sscanf(start_p, "%u:%u.%u", &em, &es, &ems) != 3) {
					continue;
				}
			}
			ctx->end = (3600*eh + 60*em + es)*1000 + ems;
			//skip 6 commas
			start_p = end_p+1;
			nb_c=6;
		} else {
			start_p = szLine;
			nb_c=8;
		}

		while (nb_c) {
			end_p = strchr(start_p, ',');
			if (!end_p) break;
			start_p = end_p+1;
			nb_c--;
		}
		if (nb_c) continue;

		if (ctx->start > ctx->end) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[TXTIn] corrupted SSA frame (line %d) - ends (at %u ms) before start of current frame (%u ms) - skipping\n", line, ctx->end, ctx->start));
			continue;
		}

		/*make stream start at 0 by inserting a fake AU*/
		if (ctx->first_samp && (ctx->start > 0)) {
			txtin_process_send_text_sample(ctx, ctx->samp, 0, (u32) ctx->start, GF_TRUE);
			ctx->first_samp = GF_FALSE;
		}
		else if (ctx->prev_end && (ctx->start != ctx->prev_end) && (ctx->state<=2)) {
			GF_TextSample * empty_samp = gf_isom_new_text_sample();
			txtin_process_send_text_sample(ctx, empty_samp, ctx->prev_end, (u32) (ctx->start - ctx->prev_end), GF_TRUE );
			gf_isom_delete_text_sample(empty_samp);
		}

		u32 char_len=0;
		Bool set_start_char=GF_FALSE, set_end_char=GF_FALSE;
		ctx->style.startCharOffset = ctx->style.endCharOffset = 0;
		gf_isom_text_reset(ctx->samp);

		memset(szText, 0, 2048);
		i=j=0;
		while (1) {
			char c = start_p[i];
			if (c == 0) {
				szText[j] = 0;
				break;
			}
			if (c=='\\') {
				if ((start_p[i+1] == 'N') || (start_p[i+1] == 'n')) {
					szText[j] = 0;
					parse_srt_line(ctx, szText, &char_len, &set_start_char, &set_end_char);

					j=0;
					i+=2;
					memset(szText, 0, 2048);
					gf_isom_text_add_text(ctx->samp, "\n", 1);
					char_len += 1;
					continue;
				}
			} else if (c=='{') {
				if (start_p[i+1] == '\\') {
					u32 style = 0;
					u32 color=0;
					Bool is_end = 0;
					if (start_p[i+2] == 'i') style = 1;
					else if (start_p[i+2] == 'b') style = 2;
					else if (start_p[i+2] == 'u') style = 3;
					else if (start_p[i+2] == 'c') {
						if ((start_p[i+3] == '&') && (strlen(start_p+i+4)>8)) {
							char *col_p = start_p + i+5;
							style = 4;
							char szT[3];
							u32 r, g, b;
							szT[2]=0;
							szT[0]=col_p[0];
							szT[1]=col_p[1];
							sscanf(szT, "%x", &g);
							szT[0]=col_p[2];
							szT[1]=col_p[3];
							sscanf(szT, "%x", &b);
							szT[0]=col_p[4];
							szT[1]=col_p[5];
							sscanf(szT, "%x", &r);
							color = GF_COL_ARGB(0xFF, r, g, b);
						}
						else if (start_p[i+3] == '}') {
							is_end=GF_TRUE;
							style = 4;
						}
					}
					else if (start_p[i+2] == 's') style = 5;

					if (start_p[i+3] == '0') is_end=GF_TRUE;
					while (start_p[i] && (start_p[i]!='}')) i++;
					i++;

					if (style==1) {
						if (is_end) {strcat(szText, "</i>"); j+=4;}
						else {strcat(szText, "<i>"); j+=3;}
					} else if (style==2) {
						if (is_end) {strcat(szText, "</b>"); j+=4;}
						else {strcat(szText, "<b>"); j+=3;}
					} else if (style==3) {
						if (is_end) {strcat(szText, "</u>"); j+=4;}
						else {strcat(szText, "<u>"); j+=3;}
					} else if (style==4) {
						if (is_end) {strcat(szText, "</font>"); j+=7;}
						else {
							char szFont[100];
							sprintf(szFont, "<font color=\"0x%X\">", color);
							strcat(szText, szFont);
							j+=(u32) strlen(szFont);
						}
					} else if (style==5) {
						if (is_end) {strcat(szText, "</strike>"); j+=9;}
						else {strcat(szText, "<strike>"); j+=8;}
					}
					continue;
				}
			}
			szText[j] = c;
			j++;
			i++;
		}
		if (szText[0])
			parse_srt_line(ctx, szText, &char_len, &set_start_char, &set_end_char);

		txtin_process_send_text_sample(ctx, ctx->samp,  ctx->start, (u32) (ctx->end -  ctx->start), GF_TRUE);
		ctx->prev_end = ctx->end;

		gf_filter_pid_set_info(ctx->opid, GF_PROP_PID_DOWN_BYTES, &PROP_LONGUINT( gf_ftell(ctx->src)) );

		if (gf_filter_pid_would_block(ctx->opid))
			return GF_OK;
	}
	/*final flush*/
	if (ctx->end && !ctx->noflush) {
		samp = gf_isom_new_text_sample();
		txtin_process_send_text_sample(ctx, samp, ctx->end, 0, GF_TRUE);
		gf_isom_delete_text_sample(samp);
	}

	gf_filter_pid_set_info_str( ctx->opid, "ttxt:last_dur", &PROP_UINT(0) );

	return GF_EOS;
}

// the below code fragment can be found in:
// src/filters/load_text.c
static u32 ttxt_get_color(char *val)
{
	u32 r, g, b, a, res;
	r = g = b = a = 0;
	if (sscanf(val, "%x %x %x %x", &r, &g, &b, &a) != 4) {
		GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[TXTIn] Warning: color badly formatted %s\n", val));
	}
	res = (a&0xFF);
	res<<=8;
	res |= (r&0xFF);
	res<<=8;
	res |= (g&0xFF);
	res<<=8;
	res |= (b&0xFF);
	return res;
}

// the below code fragment can be found in:
// src/filters/load_text.c
static GF_Err txtin_process_srt(GF_Filter *filter, GF_TXTIn *ctx, GF_FilterPacket *ipck)
{
	u32 sh, sm, ss, sms, eh, em, es, ems, txt_line, char_len;
	Bool set_start_char, set_end_char;
	u32 line;
	char szLine[2048];

	if (ctx->playstate==2)
		return GF_EOS;

	if (!ctx->is_setup) {
		ctx->is_setup = GF_TRUE;
		GF_Err e = txtin_setup_srt(filter, ctx, GF_FALSE);
		if (e || !ctx->unframed) return e;
	}
	if (!ctx->opid) return GF_NOT_SUPPORTED;

	if (!ctx->unframed) {
		if (!ctx->playstate) return GF_OK;
		else if (ctx->playstate==2) return GF_EOS;
	}

	txt_line = 0;
	set_start_char = set_end_char = GF_FALSE;
	char_len = 0;

	if (ctx->seek_state == 1) {
		ctx->seek_state = 2;
		gf_fseek(ctx->src, 0, SEEK_SET);
	}

	while (1) {
		Bool is_empty = GF_FALSE;
		char *sOK = gf_text_get_utf8_line(szLine, 2048, ctx->src, ctx->unicode_type);

		if (sOK) {
			REM_TRAIL_MARKS(szLine, "\r\n\t ")

			if (ctx->unicode_type<=1) is_empty = strlen(szLine) ? GF_FALSE : GF_TRUE;
			else is_empty =  (!szLine[0] && !szLine[1]) ? GF_TRUE : GF_FALSE;
		}

		if (!sOK || is_empty) {
			u32 utf_inc = (ctx->unicode_type<=1) ? 1 : 2;
			u32 nb_empty = utf_inc;
			u32 pos = (u32) gf_ftell(ctx->src);
			if (ctx->state) {
				while (!gf_feof(ctx->src)) {
					sOK = gf_text_get_utf8_line(szLine+nb_empty, 2048-nb_empty, ctx->src, ctx->unicode_type);
					if (sOK) REM_TRAIL_MARKS((szLine+nb_empty), "\r\n\t ")

					if (!sOK) {
						gf_fseek(ctx->src, pos, SEEK_SET);
						break;
					} else if (!strlen(szLine+nb_empty)) {
						nb_empty+=utf_inc;
						continue;
					} else if (	sscanf(szLine+nb_empty, "%u", &line) == 1) {
						gf_fseek(ctx->src, pos, SEEK_SET);
						break;
					} else {
						u32 k;
						for (k=0; k<nb_empty; k++) szLine[k] = '\n';
						goto force_line;
					}
				}
			}
			ctx->style.style_flags = 0;
			ctx->style.text_color = 0xFFFFFFFF;
			ctx->style.startCharOffset = ctx->style.endCharOffset = 0;
			if (txt_line) {
				if (ctx->prev_end && (ctx->start != ctx->prev_end) && (ctx->state<=2)) {
					GF_TextSample * empty_samp = gf_isom_new_text_sample();
					txtin_process_send_text_sample(ctx, empty_samp, ctx->prev_end, (u32) (ctx->start - ctx->prev_end), GF_TRUE );
					gf_isom_delete_text_sample(empty_samp);
				}

				if (ctx->state<=2) {
					txtin_process_send_text_sample(ctx, ctx->samp,  ctx->start, (u32) (ctx->end -  ctx->start), GF_TRUE);
					ctx->prev_end = ctx->end;
				}
				txt_line = 0;
				char_len = 0;
				set_start_char = set_end_char = GF_FALSE;
				ctx->style.startCharOffset = ctx->style.endCharOffset = 0;
				gf_isom_text_reset(ctx->samp);

				if (!ctx->unframed)
					gf_filter_pid_set_info(ctx->opid, GF_PROP_PID_DOWN_BYTES, &PROP_LONGUINT( gf_ftell(ctx->src )) );
			}
			ctx->state = 0;
			if (!sOK) break;
			continue;
		}

force_line:
		switch (ctx->state) {
		case 0:
			if (sscanf(szLine, "%u", &line) != 1) {
				GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[TXTIn] Bad SRT formatting - expecting number got \"%s\"\n", szLine));
				break;
			}
			if (line != ctx->curLine + 1) {
				GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[TXTIn] Corrupted SRT frame %d after frame %d\n", line, ctx->curLine));
			}
			ctx->curLine = line;
			ctx->state = 1;
			break;
		case 1:
			if (sscanf(szLine, "%u:%u:%u,%u --> %u:%u:%u,%u", &sh, &sm, &ss, &sms, &eh, &em, &es, &ems) != 8) {
				if (sscanf(szLine, "%u:%u:%u.%u --> %u:%u:%u.%u", &sh, &sm, &ss, &sms, &eh, &em, &es, &ems) != 8) {
					sh = eh = 0;
					if (sscanf(szLine, "%u:%u,%u --> %u:%u,%u", &sm, &ss, &sms, &em, &es, &ems) != 6) {
						if (sscanf(szLine, "%u:%u.%u --> %u:%u.%u", &sm, &ss, &sms, &em, &es, &ems) != 6) {
							GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[TXTIn] Error scanning SRT frame %d timing\n", ctx->curLine));
				    		ctx->state = 0;
							break;
						}
					}
				}
			}
			ctx->start = (3600*sh + 60*sm + ss)*1000 + sms;
			if (ctx->start < ctx->end) {
				GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[TXTIn] Overlapping SRT frame %d - starts "LLD" ms is before end of previous one "LLD" ms - adjusting time stamps\n", ctx->curLine, ctx->start, ctx->end));
				ctx->start = ctx->end;
			}

			ctx->end = (3600*eh + 60*em + es)*1000 + ems;
			/*make stream start at 0 by inserting a fake AU*/
			if (ctx->first_samp && (ctx->start > 0)) {
				txtin_process_send_text_sample(ctx, ctx->samp, 0, (u32) ctx->start, GF_TRUE);
			}
			ctx->style.style_flags = 0;
			ctx->state = 2;
			if (ctx->end <= ctx->prev_end) {
				GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[TXTIn] Overlapping SRT frame %d end "LLD" is at or before previous end "LLD" - removing\n", ctx->curLine, ctx->end, ctx->prev_end));
				ctx->start = ctx->end;
				ctx->state = 3;
			}
			ctx->forced_sub = (strstr(szLine, "!!!")) ? GF_TRUE : GF_FALSE;
			if (ctx->forced_sub) ctx->has_forced |= 1;
			else ctx->has_forced &= ~2;
			break;

		default:
			/*reset only when text is present*/
			ctx->first_samp = GF_FALSE;

			/*go to line*/
			if (txt_line) {
				gf_isom_text_add_text(ctx->samp, "\n", 1);
				char_len += 1;
			}

			parse_srt_line(ctx, szLine, &char_len, &set_start_char, &set_end_char);
			txt_line ++;
			break;
		}

		if (!ctx->unframed && gf_filter_pid_would_block(ctx->opid))
			return GF_OK;
	}

	/*final flush*/
	if (!ctx->unframed && ctx->end && ! ctx->noflush) {
		gf_isom_text_reset(ctx->samp);
		txtin_process_send_text_sample(ctx, ctx->samp, ctx->end, 0, GF_TRUE);
		ctx->end = 0;
	}
	gf_isom_text_reset(ctx->samp);

	return GF_EOS;
}

// the below code fragment can be found in:
// src/filter_core/filter_props.c
GF_EXPORT
const GF_BuiltInProperty *gf_props_get_description(u32 prop_idx)
{
	if (prop_idx>=gf_num_props) return NULL;
	return &GF_BuiltInProps[prop_idx];
}

// the below code fragment can be found in:
// src/compositor/svg_font.c
static GF_Glyph *svg_font_load_glyph(void *udta, u32 glyph_name)
{
	GF_ChildNodeItem *child = ((GF_ParentNode *) udta)->children;

	while (child) {
		if (gf_node_get_tag(child->node)==TAG_SVG_glyph) {
			SVG_GlyphStack *st = gf_node_get_private(child->node);
			if (st->glyph.ID==glyph_name) {
				return &st->glyph;
			}
		}
		child = child->next;
	}

	return NULL;
}

