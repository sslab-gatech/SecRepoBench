// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// blosc/blosc2.c
int blosc_compress(int clevel, int doshuffle, size_t typesize, size_t nbytes,
                   const void* src, void* dest, size_t destsize) {
  return blosc2_compress(clevel, doshuffle, (int32_t)typesize, src, (int32_t)nbytes, dest, (int32_t)destsize);
}

// the below code fragment can be found in:
// blosc/blosc2.c
static uint8_t get_filter_flags(const uint8_t header_flags,
                                const int32_t typesize) {
  uint8_t flags = 0;

  if ((header_flags & BLOSC_DOSHUFFLE) && (typesize > 1)) {
    flags |= BLOSC_DOSHUFFLE;
  }
  if (header_flags & BLOSC_DOBITSHUFFLE) {
    flags |= BLOSC_DOBITSHUFFLE;
  }
  if (header_flags & BLOSC_DODELTA) {
    flags |= BLOSC_DODELTA;
  }
  if (header_flags & BLOSC_MEMCPYED) {
    flags |= BLOSC_MEMCPYED;
  }
  return flags;
}

// the below code fragment can be found in:
// bench/sum_openmp.c
int main(void) {
  static DTYPE udata[N];
  DTYPE chunk_buf[CHUNKSIZE];
  size_t isize = CHUNKSIZE * sizeof(DTYPE);
  DTYPE sum, compressed_sum;
  int64_t nbytes, cbytes;
  blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
  blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
  blosc2_schunk* schunk;
  int i, j, nchunk;
  blosc_timestamp_t last, current;
  double ttotal, itotal;
  char* envvar = NULL;

  printf("Blosc version info: %s (%s)\n",
         BLOSC_VERSION_STRING, BLOSC_VERSION_DATE);

  // Fill the buffer for a chunk
  if (SYNTHETIC) {
    for (j = 0; j < CHUNKSIZE; j++) {
      chunk_buf[j] = j;
    }
  }
  else {
    struct stat info;
    const char *filegrid = "rainfall-grid-150x150.bin";
    if (stat(filegrid, &info) != 0) {
      printf("Grid file %s not found!", filegrid);
      exit(1);
    }
    char *cdata = malloc(info.st_size);

    FILE *f = fopen(filegrid, "rb");
    size_t blocks_read = fread(cdata, info.st_size, 1, f);
    assert(blocks_read == 1);
    fclose(f);

    int dsize = blosc_getitem(cdata, 0, CHUNKSIZE, chunk_buf);
    if (dsize < 0) {
      printf("blosc_getitem() error.  Error code: %d\n.  Probaly reading too much data?", dsize);
      exit(1);
    }
    free(cdata);
  }

  // Fill the uncompressed dataset with data chunks
  for (i = 0; i < N / CHUNKSIZE; i++) {
    for (j = 0; j < CHUNKSIZE; j++) {
      udata[i * CHUNKSIZE + j] = chunk_buf[j];
    }
  }

  // Reduce uncompressed dataset
  ttotal = 1e10;
  sum = 0;
  for (int n = 0; n < NITER; n++) {
    sum = 0;
    blosc_set_timestamp(&last);
#pragma omp parallel for reduction (+:sum)
    for (i = 0; i < N; i++) {
      sum += udata[i];
    }
    blosc_set_timestamp(&current);
    itotal = blosc_elapsed_secs(last, current);
    if (itotal < ttotal) ttotal = itotal;
  }
  printf("Sum for uncompressed data: %10.0f\n", (double)sum);
  printf("Sum time for uncompressed data: %.3g s, %.1f MB/s\n",
         ttotal, (isize * NCHUNKS) / (ttotal * (double)MB));

  // Create a super-chunk container for the compressed container
  long codec = CODEC;
  envvar = getenv("SUM_COMPRESSOR");
  if (envvar != NULL) {
    codec = blosc_compname_to_compcode(envvar);
    if (codec < 0) {
      printf("Unknown compresssor: %s\n", envvar);
      return 1;
    }
  }
  cparams.compcode = (uint8_t)codec;

  long clevel = CLEVEL;
  envvar = getenv("SUM_CLEVEL");
  if (envvar != NULL) {
    clevel = strtol(envvar, NULL, 10);
  }
  cparams.clevel = (uint8_t)clevel;

  cparams.typesize = sizeof(DTYPE);
  cparams.nthreads = 1;
  dparams.nthreads = 1;
  blosc_set_timestamp(&last);
  schunk = blosc2_new_schunk(cparams, dparams, NULL);
  for (nchunk = 0; nchunk < NCHUNKS; nchunk++) {
    for (i = 0; i < CHUNKSIZE; i++) {
      chunk_buf[i] = udata[i + nchunk * CHUNKSIZE];
    }
    blosc2_schunk_append_buffer(schunk, chunk_buf, isize);
  }
  blosc_set_timestamp(&current);
  ttotal = blosc_elapsed_secs(last, current);
  nbytes = schunk->nbytes;
  cbytes = schunk->cbytes;
  printf("Compression ratio: %.1f MB -> %.1f MB (%.1fx)\n",
         nbytes / MB, cbytes / MB, (1. * nbytes) / cbytes);
  printf("Compression time: %.3g s, %.1f MB/s\n",
         ttotal, nbytes / (ttotal * MB));

  int nthreads = NTHREADS;
  envvar = getenv("OMP_NUM_THREADS");
  if (envvar != NULL) {
    long value;
    value = strtol(envvar, NULL, 10);
    if ((value != EINVAL) && (value >= 0)) {
      nthreads = (int)value;
    }
  }
  // Build buffers and contexts for computations
  int nchunks_thread = NCHUNKS / nthreads;
  int remaining_chunks = NCHUNKS - nchunks_thread * nthreads;
  blosc2_context **dctx = malloc(nthreads * sizeof(void*));
  DTYPE** chunk = malloc(nthreads * sizeof(void*));
  for (j = 0; j < nthreads; j++) {
    chunk[j] = malloc(CHUNKSIZE * sizeof(DTYPE));
  }

  // Reduce uncompressed dataset
  blosc_set_timestamp(&last);
  ttotal = 1e10;
  compressed_sum = 0;
  for (int n = 0; n < NITER; n++) {
    compressed_sum = 0;
    #pragma omp parallel for private(nchunk) reduction (+:compressed_sum)
    for (j = 0; j < nthreads; j++) {
      dctx[j] = blosc2_create_dctx(dparams);
      for (nchunk = 0; nchunk < nchunks_thread; nchunk++) {
        blosc2_decompress_ctx(dctx[j], schunk->data[j * nchunks_thread + nchunk], INT32_MAX, 
                              (void*)(chunk[j]), isize);
        for (i = 0; i < CHUNKSIZE; i++) {
          compressed_sum += chunk[j][i];
          //compressed_sum += i + (j * nchunks_thread + nchunk) * CHUNKSIZE;
        }
      }
    }
    for (nchunk = NCHUNKS - remaining_chunks; nchunk < NCHUNKS; nchunk++) {
      blosc2_decompress_ctx(dctx[0], schunk->data[nchunk], INT32_MAX, (void*)(chunk[0]), isize);
      for (i = 0; i < CHUNKSIZE; i++) {
        compressed_sum += chunk[0][i];
        //compressed_sum += i + nchunk * CHUNKSIZE;
      }
    }
    blosc_set_timestamp(&current);
    itotal = blosc_elapsed_secs(last, current);
    if (itotal < ttotal) ttotal = itotal;
  }
  printf("Sum for *compressed* data: %10.0f\n", (double)compressed_sum);
  printf("Sum time for *compressed* data: %.3g s, %.1f MB/s\n",
         ttotal, nbytes / (ttotal * MB));
  //printf("sum, csum: %f, %f\n", sum, compressed_sum);
  if (SYNTHETIC) {
    // difficult to fulfill for single precision
    assert(sum == compressed_sum);
  }
  /* Free resources */
  blosc2_free_schunk(schunk);

  return 0;
}

// the below code fragment can be found in:
// blosc/blosc2.c
int blosc_decompress(const void* src, void* dest, size_t destsize) {
  return blosc2_decompress(src, INT32_MAX, dest, (int32_t)destsize);
}

// the below code fragment can be found in:
// blosc/schunk.c
blosc2_schunk *blosc2_new_schunk(blosc2_cparams cparams, blosc2_dparams dparams,
                                 blosc2_frame* frame) {
  blosc2_schunk* schunk = calloc(1, sizeof(blosc2_schunk));

  schunk->version = 0;     /* pre-first version */
  for (int i = 0; i < BLOSC2_MAX_FILTERS; i++) {
    schunk->filters[i] = cparams.filters[i];
    schunk->filters_meta[i] = cparams.filters_meta[i];
  }
  schunk->compcode = cparams.compcode;
  schunk->clevel = cparams.clevel;
  schunk->typesize = cparams.typesize;
  schunk->blocksize = cparams.blocksize;

  /* The compression context */
  cparams.schunk = schunk;
  schunk->cctx = blosc2_create_cctx(cparams);

  /* The decompression context */
  dparams.schunk = schunk;
  schunk->dctx = blosc2_create_dctx(dparams);

  schunk->frame = frame;
  if (frame != NULL) {
    if (frame->len == 0) {
      // Initialize frame (basically, encode the header)
      int64_t frame_len = blosc2_schunk_to_frame(schunk, frame);
      if (frame_len < 0) {
        fprintf(stderr, "Error during the conversion of schunk to frame\n");
      }
    }
  }

  return schunk;
}

