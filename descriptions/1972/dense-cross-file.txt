// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// valid.c
void
xmlSprintfElementContent(char *buf ATTRIBUTE_UNUSED,
	                 xmlElementContentPtr content ATTRIBUTE_UNUSED,
			 int englob ATTRIBUTE_UNUSED) {
}

// the below code fragment can be found in:
// valid.c
static void
xmlSnprintfElements(char *buf, int size, xmlNodePtr node, int glob) {
    xmlNodePtr cur;
    int len;

    if (node == NULL) return;
    if (glob) strcat(buf, "(");
    cur = node;
    while (cur != NULL) {
	len = strlen(buf);
	if (size - len < 50) {
	    if ((size - len > 4) && (buf[len - 1] != '.'))
		strcat(buf, " ...");
	    return;
	}
        switch (cur->type) {
            case XML_ELEMENT_NODE:
		if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {
		    if (size - len < xmlStrlen(cur->ns->prefix) + 10) {
			if ((size - len > 4) && (buf[len - 1] != '.'))
			    strcat(buf, " ...");
			return;
		    }
		    strcat(buf, (char *) cur->ns->prefix);
		    strcat(buf, ":");
		}
                if (size - len < xmlStrlen(cur->name) + 10) {
		    if ((size - len > 4) && (buf[len - 1] != '.'))
			strcat(buf, " ...");
		    return;
		}
	        strcat(buf, (char *) cur->name);
		if (cur->next != NULL)
		    strcat(buf, " ");
		break;
            case XML_TEXT_NODE:
		if (xmlIsBlankNode(cur))
		    break;
            case XML_CDATA_SECTION_NODE:
            case XML_ENTITY_REF_NODE:
	        strcat(buf, "CDATA");
		if (cur->next != NULL)
		    strcat(buf, " ");
		break;
            case XML_ATTRIBUTE_NODE:
            case XML_DOCUMENT_NODE:
#ifdef LIBXML_DOCB_ENABLED
	    case XML_DOCB_DOCUMENT_NODE:
#endif
	    case XML_HTML_DOCUMENT_NODE:
            case XML_DOCUMENT_TYPE_NODE:
            case XML_DOCUMENT_FRAG_NODE:
            case XML_NOTATION_NODE:
	    case XML_NAMESPACE_DECL:
	        strcat(buf, "???");
		if (cur->next != NULL)
		    strcat(buf, " ");
		break;
            case XML_ENTITY_NODE:
            case XML_PI_NODE:
            case XML_DTD_NODE:
            case XML_COMMENT_NODE:
	    case XML_ELEMENT_DECL:
	    case XML_ATTRIBUTE_DECL:
	    case XML_ENTITY_DECL:
	    case XML_XINCLUDE_START:
	    case XML_XINCLUDE_END:
		break;
	}
	cur = cur->next;
    }
    if (glob) strcat(buf, ")");
}

// the below code fragment can be found in:
// testapi.c
static int
test_xmlSnprintfElementContent(void) {
    int test_ret = 0;

    int mem_base;
    char * buf; /* an output buffer */
    int n_buf;
    int size; /* the buffer size */
    int n_size;
    xmlElementContentPtr content; /* An element table */
    int n_content;
    int englob; /* 1 if one must print the englobing parenthesis, 0 otherwise */
    int n_englob;

    for (n_buf = 0;n_buf < gen_nb_char_ptr;n_buf++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    for (n_content = 0;n_content < gen_nb_xmlElementContentPtr;n_content++) {
    for (n_englob = 0;n_englob < gen_nb_int;n_englob++) {
        mem_base = xmlMemBlocks();
        buf = gen_char_ptr(n_buf, 0);
        size = gen_int(n_size, 1);
        content = gen_xmlElementContentPtr(n_content, 2);
        englob = gen_int(n_englob, 3);

        xmlSnprintfElementContent(buf, size, content, englob);
        call_tests++;
        des_char_ptr(n_buf, buf, 0);
        des_int(n_size, size, 1);
        des_xmlElementContentPtr(n_content, content, 2);
        des_int(n_englob, englob, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSnprintfElementContent",
	           xmlMemBlocks() - mem_base);
	    test_ret++;
            printf(" %d", n_buf);
            printf(" %d", n_size);
            printf(" %d", n_content);
            printf(" %d", n_englob);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}

// the below code fragment can be found in:
// valid.c
static void
xmlDumpElementContent(xmlBufferPtr buf, xmlElementContentPtr content, int glob) {
    if (content == NULL) return;

    if (glob) xmlBufferWriteChar(buf, "(");
    switch (content->type) {
        case XML_ELEMENT_CONTENT_PCDATA:
            xmlBufferWriteChar(buf, "#PCDATA");
	    break;
	case XML_ELEMENT_CONTENT_ELEMENT:
	    if (content->prefix != NULL) {
		xmlBufferWriteCHAR(buf, content->prefix);
		xmlBufferWriteChar(buf, ":");
	    }
	    xmlBufferWriteCHAR(buf, content->name);
	    break;
	case XML_ELEMENT_CONTENT_SEQ:
	    if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||
	        (content->c1->type == XML_ELEMENT_CONTENT_SEQ))
		xmlDumpElementContent(buf, content->c1, 1);
	    else
		xmlDumpElementContent(buf, content->c1, 0);
            xmlBufferWriteChar(buf, " , ");
	    if ((content->c2->type == XML_ELEMENT_CONTENT_OR) ||
	        ((content->c2->type == XML_ELEMENT_CONTENT_SEQ) &&
		 (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)))
		xmlDumpElementContent(buf, content->c2, 1);
	    else
		xmlDumpElementContent(buf, content->c2, 0);
	    break;
	case XML_ELEMENT_CONTENT_OR:
	    if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||
	        (content->c1->type == XML_ELEMENT_CONTENT_SEQ))
		xmlDumpElementContent(buf, content->c1, 1);
	    else
		xmlDumpElementContent(buf, content->c1, 0);
            xmlBufferWriteChar(buf, " | ");
	    if ((content->c2->type == XML_ELEMENT_CONTENT_SEQ) ||
	        ((content->c2->type == XML_ELEMENT_CONTENT_OR) &&
		 (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)))
		xmlDumpElementContent(buf, content->c2, 1);
	    else
		xmlDumpElementContent(buf, content->c2, 0);
	    break;
	default:
	    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
		    "Internal: ELEMENT content corrupted invalid type\n",
		    NULL);
    }
    if (glob)
        xmlBufferWriteChar(buf, ")");
    switch (content->ocur) {
        case XML_ELEMENT_CONTENT_ONCE:
	    break;
        case XML_ELEMENT_CONTENT_OPT:
	    xmlBufferWriteChar(buf, "?");
	    break;
        case XML_ELEMENT_CONTENT_MULT:
	    xmlBufferWriteChar(buf, "*");
	    break;
        case XML_ELEMENT_CONTENT_PLUS:
	    xmlBufferWriteChar(buf, "+");
	    break;
    }
}

// the below code fragment can be found in:
// testapi.c
static int
test_xmlSprintfElementContent(void) {
    int test_ret = 0;

#if defined(LIBXML_OUTPUT_ENABLED)
#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    char * buf; /* an output buffer */
    int n_buf;
    xmlElementContentPtr content; /* An element table */
    int n_content;
    int englob; /* 1 if one must print the englobing parenthesis, 0 otherwise */
    int n_englob;

    for (n_buf = 0;n_buf < gen_nb_char_ptr;n_buf++) {
    for (n_content = 0;n_content < gen_nb_xmlElementContentPtr;n_content++) {
    for (n_englob = 0;n_englob < gen_nb_int;n_englob++) {
        mem_base = xmlMemBlocks();
        buf = gen_char_ptr(n_buf, 0);
        content = gen_xmlElementContentPtr(n_content, 1);
        englob = gen_int(n_englob, 2);

        xmlSprintfElementContent(buf, content, englob);
        call_tests++;
        des_char_ptr(n_buf, buf, 0);
        des_xmlElementContentPtr(n_content, content, 1);
        des_int(n_englob, englob, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSprintfElementContent",
	           xmlMemBlocks() - mem_base);
	    test_ret++;
            printf(" %d", n_buf);
            printf(" %d", n_content);
            printf(" %d", n_englob);
            printf("\n");
        }
    }
    }
    }
    function_tests++;
#endif
#endif

    return(test_ret);
}

