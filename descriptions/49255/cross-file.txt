// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// mrbgems/mruby-bigint/core/bigint.c
static void
mpz_powm(mrb_state *mrb, mpz_t *zz, mpz_t *x, mrb_int ex, mpz_t *n)
{
  mpz_t t, e;
  struct is *stack = NULL;
  int k,i;

  if (ex == 0) {
    mpz_set_int(mrb,zz,1);
    return;
  }

  if (ex < 0) {
    return;
  }
  mpz_init_set_int(mrb,&e, ex);
  mpz_init(mrb,&t);

  for (k=0;!uzero(&e);k++,mpz_div_2exp(mrb,&e,&e,1))
    push(mrb,lowdigit(&e) & 1,&stack);
  k--;
  i=pop(mrb,&stack);

  mpz_mod(mrb,&t,x,n);  /* t=x%n */

  for (i=k-1;i>=0;i--) {
    mpz_mul(mrb,&t,&t,&t);
    mpz_mod(mrb,&t,&t,n);
    if (pop(mrb,&stack)) {
      mpz_mul(mrb,&t,&t,x);
      mpz_mod(mrb,&t,&t,n);
    }
  }
  mpz_set(mrb,zz,&t);
  mpz_clear(mrb,&t);
  mpz_clear(mrb,&e);
}

// the below code fragment can be found in:
// mrbgems/mruby-bigint/core/bigint.c
static void
mpz_mul_2exp(mrb_state *mrb, mpz_t *z, mpz_t *x, mrb_int e)
{
  short sn = x->sn;
  if (e==0)
    mpz_set(mrb,z,x);
  else {
    size_t i;
    mp_limb digs = (e / DIGITBITS);
    size_t bs = (e % (DIGITBITS));
    mpz_t y;

    mpz_init(mrb, &y);
    mpz_realloc(mrb, &y,(size_t)((x->sz)+digs));
    for (i=digs;i<((x->sz)+digs);i++)
      (y.p)[i] = (x->p)[i - digs];
    if (bs) {
      ulshift(mrb,z,&y,bs);
    }
    else {
      mpz_set(mrb,z,&y);
    }
    z->sn = sn;
    mpz_clear(mrb,&y);
  }
}

// the below code fragment can be found in:
// mrbgems/mruby-bigint/core/bigint.c
static void
mpz_mul_int(mrb_state *mrb, mpz_t *x, mpz_t *y, mrb_int n)
{
  mpz_t z;
  mpz_init_set_int(mrb,&z,n);
  mpz_mul(mrb,x,y,&z);
  mpz_clear(mrb,&z);
}

// the below code fragment can be found in:
// mrbgems/mruby-array-ext/src/array.c
static mrb_value
mrb_ary_at(mrb_state *mrb, mrb_value ary)
{
  mrb_int pos;
  mrb_get_args(mrb, "i", &pos);

  return mrb_ary_entry(ary, pos);
}

// the below code fragment can be found in:
// mrbgems/mruby-array-ext/src/array.c
static mrb_value
mrb_ary_rassoc(mrb_state *mrb, mrb_value ary)
{
  mrb_int i;
  mrb_value v;
  mrb_value value = mrb_get_arg1(mrb);

  for (i = 0; i < RARRAY_LEN(ary); ++i) {
    v = RARRAY_PTR(ary)[i];
    if (mrb_array_p(v) &&
        RARRAY_LEN(v) > 1 &&
        mrb_equal(mrb, RARRAY_PTR(v)[1], value))
      return v;
  }
  return mrb_nil_value();
}

