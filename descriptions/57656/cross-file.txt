// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// code/Common/DefaultIOSystem.cpp
void DefaultIOSystem::Close(IOStream *pFile) {
    delete pFile;
}

// the below code fragment can be found in:
// code/CApi/CInterfaceIOWrapper.cpp
char CIOSystemWrapper::getOsSeparator() const {
#ifndef _WIN32
    return '/';
#else
    return '\\';
#endif
}

// the below code fragment can be found in:
// code/AssetLib/Q3BSP/Q3BSPFileParser.cpp
bool Q3BSPFileParser::parseFile() {
    if ( m_Data.empty() ) {
        return false;
    }

    if ( !validateFormat() )
    {
        return false;
    }

    // Imports the dictionary of the level
    getLumps();

    // Count data and prepare model data
    countLumps();

    // Read in Vertices
    getVertices();

    // Read in Indices
    getIndices();

    // Read Faces
    getFaces();

    // Read Textures
    getTextures();

    // Read Lightmaps
    getLightMaps();

    // Load the entities
    getEntities();

    return true;
}

// the below code fragment can be found in:
// code/AssetLib/IQM/IQMImporter.cpp
const aiImporterDesc *IQMImporter::GetInfo() const {
    return &desc;
}

// the below code fragment can be found in:
// code/PostProcessing/EmbedTexturesProcess.cpp
bool EmbedTexturesProcess::addTexture(aiScene *pScene, const std::string &path) const {
    std::streampos imageSize = 0;
    std::string    imagePath = path;

    // Test path directly
    if (!mIOHandler->Exists(imagePath)) {
        ASSIMP_LOG_WARN("EmbedTexturesProcess: Cannot find image: ", imagePath, ". Will try to find it in root folder.");

        // Test path in root path
        imagePath = mRootPath + path;
        if (!mIOHandler->Exists(imagePath)) {
            // Test path basename in root path
            imagePath = mRootPath + path.substr(path.find_last_of("\\/") + 1u);
            if (!mIOHandler->Exists(imagePath)) {
                ASSIMP_LOG_ERROR("EmbedTexturesProcess: Unable to embed texture: ", path, ".");
                return false;
            }
        }
    }
    IOStream* pFile = mIOHandler->Open(imagePath);
    if (pFile == nullptr) {
        ASSIMP_LOG_ERROR("EmbedTexturesProcess: Unable to embed texture: ", path, ".");
        return false;
    }
    imageSize = pFile->FileSize();

    aiTexel* imageContent = new aiTexel[ 1ul + static_cast<unsigned long>( imageSize ) / sizeof(aiTexel)];
    pFile->Seek(0, aiOrigin_SET);
    pFile->Read(reinterpret_cast<char*>(imageContent), static_cast<size_t>(imageSize), 1);
    mIOHandler->Close(pFile);

    // Enlarging the textures table
    unsigned int textureId = pScene->mNumTextures++;
    auto oldTextures = pScene->mTextures;
    pScene->mTextures = new aiTexture*[pScene->mNumTextures];
    ::memmove(pScene->mTextures, oldTextures, sizeof(aiTexture*) * (pScene->mNumTextures - 1u));
    delete [] oldTextures;

    // Add the new texture
    auto pTexture = new aiTexture;
    pTexture->mHeight = 0; // Means that this is still compressed
    pTexture->mWidth = static_cast<uint32_t>(imageSize);
    pTexture->pcData = imageContent;

    auto extension = path.substr(path.find_last_of('.') + 1u);
    extension = ai_tolower(extension);
    if (extension == "jpeg") {
        extension = "jpg";
    }

    size_t len = extension.size();
    if (len > HINTMAXTEXTURELEN -1 ) {
        len = HINTMAXTEXTURELEN - 1;
    }
    ::strncpy(pTexture->achFormatHint, extension.c_str(), len);
    pScene->mTextures[textureId] = pTexture;

    return true;
}

