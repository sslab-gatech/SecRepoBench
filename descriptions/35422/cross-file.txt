// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// MagickCore/string.c
// MagickExport void SetStringInfoName(StringInfo *string_info,const char *name)
// {
//   assert(string_info != (StringInfo *) NULL);
//   assert(string_info->signature == MagickCoreSignature);
//   assert(name != (const char *) NULL);
//   string_info->name=ConstantString(name);
// }

// the below code fragment can be found in:
// MagickCore/string.c
// MagickExport void SetStringInfoDatum(StringInfo *string_info,
//   const unsigned char *source)
// {
//   assert(string_info != (StringInfo *) NULL);
//   assert(string_info->signature == MagickCoreSignature);
//   if (string_info->length != 0)
//     (void) memcpy(string_info->datum,source,string_info->length);
// }

// the below code fragment can be found in:
// MagickCore/string.c
// MagickExport char *CloneString(char **destination,const char *source)
// {
//   size_t
//     length;
// 
//   assert(destination != (char **) NULL);
//   if (source == (const char *) NULL)
//     {
//       if (*destination != (char *) NULL)
//         *destination=DestroyString(*destination);
//       return(*destination);
//     }
//   if (*destination == (char *) NULL)
//     {
//       *destination=AcquireString(source);
//       return(*destination);
//     }
//   length=strlen(source);
//   if (~length < MagickPathExtent)
//     ThrowFatalException(ResourceLimitFatalError,"UnableToAcquireString");
//   *destination=(char *) ResizeQuantumMemory(*destination,length+
//     MagickPathExtent,sizeof(**destination));
//   if (*destination == (char *) NULL)
//     ThrowFatalException(ResourceLimitFatalError,"UnableToAcquireString");
//   if (length != 0)
//     (void) memcpy(*destination,source,length*sizeof(**destination));
//   (*destination)[length]='\0';
//   return(*destination);
// }

// the below code fragment can be found in:
// MagickCore/string.c
// MagickExport void SetStringInfoLength(StringInfo *string_info,
//   const size_t length)
// {
//   assert(string_info != (StringInfo *) NULL);
//   assert(string_info->signature == MagickCoreSignature);
//   if (string_info->length == length)
//     return;
//   if (~length < MagickPathExtent)
//     ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
//   string_info->length=length;
//   if (string_info->datum == (unsigned char *) NULL)
//     string_info->datum=(unsigned char *) AcquireQuantumMemory(length+
//       MagickPathExtent,sizeof(*string_info->datum));
//   else
//     string_info->datum=(unsigned char *) ResizeQuantumMemory(string_info->datum,
//       length+MagickPathExtent,sizeof(*string_info->datum));
//   if (string_info->datum == (unsigned char *) NULL)
//     ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
// }

// the below code fragment can be found in:
// MagickCore/string.c
// MagickExport StringInfo *BlobToStringInfo(const void *blob,const size_t length)
// {
//   StringInfo
//     *string_info;
// 
//   if (~length < MagickPathExtent)
//     ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
//   string_info=AcquireStringInfoContainer();
//   string_info->length=length;
//   string_info->datum=(unsigned char *) AcquireQuantumMemory(length+
//     MagickPathExtent,sizeof(*string_info->datum));
//   if (string_info->datum == (unsigned char *) NULL)
//     {
//       string_info=DestroyStringInfo(string_info);
//       return((StringInfo *) NULL);
//     }
//   if (blob != (const void *) NULL)
//     (void) memcpy(string_info->datum,blob,length);
//   else
//     (void) memset(string_info->datum,0,length*sizeof(*string_info->datum));
//   (void) memset(string_info->datum+length,0,MagickPathExtent*
//     sizeof(*string_info->datum));
//   return(string_info);
// }

