// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/cmsps2.c
// static
// cmsFloat64Number* GetPtrToMatrix(const cmsStage* mpe)
// {
//     _cmsStageMatrixData* Data = (_cmsStageMatrixData*) mpe ->Data;
// 
//     return Data -> Double;
// }

// the below code fragment can be found in:
// src/cmsps2.c
// static
// cmsUInt32Number GenerateCSA(cmsContext ContextID,
//                             cmsHPROFILE hProfile,
//                             cmsUInt32Number Intent,
//                             cmsUInt32Number dwFlags,
//                             cmsIOHANDLER* mem)
// {
//     cmsUInt32Number dwBytesUsed;
//     cmsPipeline* lut = NULL;
//     cmsStage* Matrix, *Shaper;
// 
// 
//     // Is a named color profile?
//     if (cmsGetDeviceClass(hProfile) == cmsSigNamedColorClass) {
// 
//         if (!WriteNamedColorCSA(mem, hProfile, Intent)) goto Error;
//     }
//     else {
// 
// 
//         // Any profile class are allowed (including devicelink), but
//         // output (PCS) colorspace must be XYZ or Lab
//         cmsColorSpaceSignature ColorSpace = cmsGetPCS(hProfile);
// 
//         if (ColorSpace != cmsSigXYZData &&
//             ColorSpace != cmsSigLabData) {
// 
//                 cmsSignalError(ContextID, cmsERROR_COLORSPACE_CHECK, "Invalid output color space");
//                 goto Error;
//         }
// 
// 
//         // Read the lut with all necessary conversion stages
//         lut = _cmsReadInputLUT(hProfile, Intent);
//         if (lut == NULL) goto Error;
// 
// 
//         // Tone curves + matrix can be implemented without any LUT
//         if (cmsPipelineCheckAndRetreiveStages(lut, 2, cmsSigCurveSetElemType, cmsSigMatrixElemType, &Shaper, &Matrix)) {
// 
//             if (!WriteInputMatrixShaper(mem, hProfile, Matrix, Shaper)) goto Error;
// 
//         }
//         else {
//            // We need a LUT for the rest
//            if (!WriteInputLUT(mem, hProfile, Intent, dwFlags)) goto Error;
//         }
//     }
// 
// 
//     // Done, keep memory usage
//     dwBytesUsed = mem ->UsedSpace;
// 
//     // Get rid of LUT
//     if (lut != NULL) cmsPipelineFree(lut);
// 
//     // Finally, return used byte count
//     return dwBytesUsed;
// 
// Error:
//     if (lut != NULL) cmsPipelineFree(lut);
//     return 0;
// }

// the below code fragment can be found in:
// src/cmsps2.c
// static
// cmsUInt32Number  GenerateCRD(cmsContext ContextID,
//                              cmsHPROFILE hProfile,
//                              cmsUInt32Number Intent, cmsUInt32Number dwFlags,
//                              cmsIOHANDLER* mem)
// {
//     cmsUInt32Number dwBytesUsed;
// 
//     if (!(dwFlags & cmsFLAGS_NODEFAULTRESOURCEDEF)) {
// 
//         EmitHeader(mem, "Color Rendering Dictionary (CRD)", hProfile);
//     }
// 
// 
//     // Is a named color profile?
//     if (cmsGetDeviceClass(hProfile) == cmsSigNamedColorClass) {
// 
//         if (!WriteNamedColorCRD(mem, hProfile, Intent, dwFlags)) {
//             return 0;
//         }
//     }
//     else {
// 
//         // CRD are always implemented as LUT
// 
//         if (!WriteOutputLUT(mem, hProfile, Intent, dwFlags)) {
//             return 0;
//         }
//     }
// 
//     if (!(dwFlags & cmsFLAGS_NODEFAULTRESOURCEDEF)) {
// 
//         _cmsIOPrintf(mem, "%%%%EndResource\n");
//         _cmsIOPrintf(mem, "\n%% CRD End\n");
//     }
// 
//     // Done, keep memory usage
//     dwBytesUsed = mem ->UsedSpace;
// 
//     // Finally, return used byte count
//     return dwBytesUsed;
// 
//     cmsUNUSED_PARAMETER(ContextID);
// }

// the below code fragment can be found in:
// src/cmsps2.c
// static
// int WriteNamedColorCSA(cmsIOHANDLER* m, cmsHPROFILE hNamedColor, cmsUInt32Number Intent)
// {
//     cmsHTRANSFORM xform;
//     cmsHPROFILE   hLab;
//     cmsUInt32Number i, nColors;
//     char ColorName[cmsMAX_PATH];
//     cmsNAMEDCOLORLIST* NamedColorList;
// 
//     hLab  = cmsCreateLab4ProfileTHR(m ->ContextID, NULL);
//     xform = cmsCreateTransform(hNamedColor, TYPE_NAMED_COLOR_INDEX, hLab, TYPE_Lab_DBL, Intent, 0);
//     cmsCloseProfile(hLab);
// 
//     if (xform == NULL) return 0;
// 
//     NamedColorList = cmsGetNamedColorList(xform);
//     if (NamedColorList == NULL) {
//         cmsDeleteTransform(xform);
//         return 0;
//     }
// 
//     _cmsIOPrintf(m, "<<\n");
//     _cmsIOPrintf(m, "(colorlistcomment) (%s)\n", "Named color CSA");
//     _cmsIOPrintf(m, "(Prefix) [ (Pantone ) (PANTONE ) ]\n");
//     _cmsIOPrintf(m, "(Suffix) [ ( CV) ( CVC) ( C) ]\n");
// 
//     nColors   = cmsNamedColorCount(NamedColorList);
// 
//     for (i=0; i < nColors; i++) {
// 
//         cmsUInt16Number In[1];
//         cmsCIELab Lab;
// 
//         In[0] = (cmsUInt16Number) i;
// 
//         if (!cmsNamedColorInfo(NamedColorList, i, ColorName, NULL, NULL, NULL, NULL))
//                 continue;
// 
//         cmsDoTransform(xform, In, &Lab, 1);
//         _cmsIOPrintf(m, "  (%s) [ %.3f %.3f %.3f ]\n", ColorName, Lab.L, Lab.a, Lab.b);
//     }
// 
//     _cmsIOPrintf(m, ">>\n");
// 
//     cmsDeleteTransform(xform);
//     return 1;
// }

// the below code fragment can be found in:
// src/cmsps2.c
// static
// cmsToneCurve* ExtractGray2Y(cmsContext ContextID, cmsHPROFILE hProfile, cmsUInt32Number Intent)
// {
//     cmsToneCurve* Out = cmsBuildTabulatedToneCurve16(ContextID, 256, NULL);
//     cmsHPROFILE hXYZ  = cmsCreateXYZProfile();
//     cmsHTRANSFORM xform = cmsCreateTransformTHR(ContextID, hProfile, TYPE_GRAY_8, hXYZ, TYPE_XYZ_DBL, Intent, cmsFLAGS_NOOPTIMIZE);
//     int i;
// 
//     if (Out != NULL && xform != NULL) {
//         for (i=0; i < 256; i++) {
// 
//             cmsUInt8Number Gray = (cmsUInt8Number) i;
//             cmsCIEXYZ XYZ;
// 
//             cmsDoTransform(xform, &Gray, &XYZ, 1);
// 
//             Out ->Table16[i] =_cmsQuickSaturateWord(XYZ.Y * 65535.0);
//         }
//     }
// 
//     if (xform) cmsDeleteTransform(xform);
//     if (hXYZ) cmsCloseProfile(hXYZ);
//     return Out;
// }

