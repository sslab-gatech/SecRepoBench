// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// libavcodec/hevc_refs.c
// int ff_hevc_frame_nb_refs(HEVCContext *s)
// {
//     int ret = 0;
//     int i;
//     const ShortTermRPS *rps = s->sh.short_term_rps;
//     LongTermRPS *long_rps   = &s->sh.long_term_rps;
// 
//     if (rps) {
//         for (i = 0; i < rps->num_negative_pics; i++)
//             ret += !!rps->used[i];
//         for (; i < rps->num_delta_pocs; i++)
//             ret += !!rps->used[i];
//     }
// 
//     if (long_rps) {
//         for (i = 0; i < long_rps->nb_refs; i++)
//             ret += !!long_rps->used[i];
//     }
//     return ret;
// }

// the below code fragment can be found in:
// libavcodec/hevc_refs.c
// static HEVCFrame *find_ref_idx(HEVCContext *s, int poc)
// {
//     int i;
//     int LtMask = (1 << s->ps.sps->log2_max_poc_lsb) - 1;
// 
//     for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {
//         HEVCFrame *ref = &s->DPB[i];
//         if (ref->frame->buf[0] && (ref->sequence == s->seq_decode)) {
//             if ((ref->poc & LtMask) == poc)
//                 return ref;
//         }
//     }
// 
//     for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {
//         HEVCFrame *ref = &s->DPB[i];
//         if (ref->frame->buf[0] && ref->sequence == s->seq_decode) {
//             if (ref->poc == poc || (ref->poc & LtMask) == poc)
//                 return ref;
//         }
//     }
// 
//     if (s->nal_unit_type != HEVC_NAL_CRA_NUT && !IS_BLA(s))
//         av_log(s->avctx, AV_LOG_ERROR,
//                "Could not find ref with POC %d\n", poc);
//     return NULL;
// }

// the below code fragment can be found in:
// libavcodec/hevc_mvs.c
// static int mv_mp_mode_mx(HEVCContext *s, int x, int y, int pred_flag_index,
//                          Mv *mv, int ref_idx_curr, int ref_idx)
// {
//     MvField *tab_mvf = s->ref->tab_mvf;
//     int min_pu_width = s->ps.sps->min_pu_width;
// 
//     RefPicList *refPicList = s->ref->refPicList;
// 
//     if (((TAB_MVF(x, y).pred_flag) & (1 << pred_flag_index)) &&
//         refPicList[pred_flag_index].list[TAB_MVF(x, y).ref_idx[pred_flag_index]] == refPicList[ref_idx_curr].list[ref_idx]) {
//         *mv = TAB_MVF(x, y).mv[pred_flag_index];
//         return 1;
//     }
//     return 0;
// }

// the below code fragment can be found in:
// libavcodec/h264_refs.c
// int ff_h264_decode_ref_pic_list_reordering(H264SliceContext *sl, void *logctx)
// {
//     int list, index;
// 
//     sl->nb_ref_modifications[0] = 0;
//     sl->nb_ref_modifications[1] = 0;
// 
//     for (list = 0; list < sl->list_count; list++) {
//         if (!get_bits1(&sl->gb))    // ref_pic_list_modification_flag_l[01]
//             continue;
// 
//         for (index = 0; ; index++) {
//             unsigned int op = get_ue_golomb_31(&sl->gb);
// 
//             if (op == 3)
//                 break;
// 
//             if (index >= sl->ref_count[list]) {
//                 av_log(logctx, AV_LOG_ERROR, "reference count overflow\n");
//                 return AVERROR_INVALIDDATA;
//             } else if (op > 2) {
//                 av_log(logctx, AV_LOG_ERROR,
//                        "illegal modification_of_pic_nums_idc %u\n",
//                        op);
//                 return AVERROR_INVALIDDATA;
//             }
//             sl->ref_modifications[list][index].val = get_ue_golomb_long(&sl->gb);
//             sl->ref_modifications[list][index].op  = op;
//             sl->nb_ref_modifications[list]++;
//         }
//     }
// 
//     return 0;
// }

// the below code fragment can be found in:
// libavcodec/hevc_mvs.c
// static int temporal_luma_motion_vector(HEVCContext *s, int x0, int y0,
//                                        int nPbW, int nPbH, int refIdxLx,
//                                        Mv *mvLXCol, int X)
// {
//     MvField *tab_mvf;
//     MvField temp_col;
//     int x, y, x_pu, y_pu;
//     int min_pu_width = s->ps.sps->min_pu_width;
//     int availableFlagLXCol = 0;
//     int colPic;
// 
//     HEVCFrame *ref = s->ref->collocated_ref;
// 
//     if (!ref) {
//         memset(mvLXCol, 0, sizeof(*mvLXCol));
//         return 0;
//     }
// 
//     tab_mvf = ref->tab_mvf;
//     colPic  = ref->poc;
// 
//     //bottom right collocated motion vector
//     x = x0 + nPbW;
//     y = y0 + nPbH;
// 
//     if (tab_mvf &&
//         (y0 >> s->ps.sps->log2_ctb_size) == (y >> s->ps.sps->log2_ctb_size) &&
//         y < s->ps.sps->height &&
//         x < s->ps.sps->width) {
//         x                 &= ~15;
//         y                 &= ~15;
//         if (s->threads_type == FF_THREAD_FRAME)
//             ff_thread_await_progress(&ref->tf, y, 0);
//         x_pu               = x >> s->ps.sps->log2_min_pu_size;
//         y_pu               = y >> s->ps.sps->log2_min_pu_size;
//         temp_col           = TAB_MVF(x_pu, y_pu);
//         availableFlagLXCol = DERIVE_TEMPORAL_COLOCATED_MVS;
//     }
// 
//     // derive center collocated motion vector
//     if (tab_mvf && !availableFlagLXCol) {
//         x                  = x0 + (nPbW >> 1);
//         y                  = y0 + (nPbH >> 1);
//         x                 &= ~15;
//         y                 &= ~15;
//         if (s->threads_type == FF_THREAD_FRAME)
//             ff_thread_await_progress(&ref->tf, y, 0);
//         x_pu               = x >> s->ps.sps->log2_min_pu_size;
//         y_pu               = y >> s->ps.sps->log2_min_pu_size;
//         temp_col           = TAB_MVF(x_pu, y_pu);
//         availableFlagLXCol = DERIVE_TEMPORAL_COLOCATED_MVS;
//     }
//     return availableFlagLXCol;
// }

