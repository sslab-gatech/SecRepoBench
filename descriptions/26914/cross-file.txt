// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// MagickCore/token.c
// MagickExport int Tokenizer(TokenInfo *token_info,const unsigned flag,
//   char *token,const size_t max_token_length,const char *line,const char *white,
//   const char *break_set,const char *quote,const char escape,char *breaker,
//   int *next,char *quoted)
// {
//   int
//     c;
// 
//   register ssize_t
//     i;
// 
//   *breaker='\0';
//   *quoted='\0';
//   if (line[*next] == '\0')
//     return(1);
//   token_info->state=IN_WHITE;
//   token_info->quote=(char) MagickFalse;
//   token_info->flag=flag;
//   for (token_info->offset=0; (int) line[*next] != 0; (*next)++)
//   {
//     c=(int) line[*next];
//     i=sindex(c,break_set);
//     if (i >= 0)
//       {
//         switch (token_info->state)
//         {
//           case IN_WHITE:
//           case IN_TOKEN:
//           case IN_OZONE:
//           {
//             (*next)++;
//             *breaker=break_set[i];
//             token[token_info->offset]='\0';
//             return(0);
//           }
//           case IN_QUOTE:
//           {
//             StoreToken(token_info,token,max_token_length,c);
//             break;
//           }
//         }
//         continue;
//       }
//     i=sindex(c,quote);
//     if (i >= 0)
//       {
//         switch (token_info->state)
//         {
//           case IN_WHITE:
//           {
//             token_info->state=IN_QUOTE;
//             token_info->quote=quote[i];
//             *quoted=(char) MagickTrue;
//             break;
//           }
//           case IN_QUOTE:
//           {
//             if (quote[i] != token_info->quote)
//               StoreToken(token_info,token,max_token_length,c);
//             else
//               {
//                 token_info->state=IN_OZONE;
//                 token_info->quote='\0';
//               }
//             break;
//           }
//           case IN_TOKEN:
//           case IN_OZONE:
//           {
//             *breaker=(char) c;
//             token[token_info->offset]='\0';
//             return(0);
//           }
//         }
//         continue;
//       }
//     i=sindex(c,white);
//     if (i >= 0)
//       {
//         switch (token_info->state)
//         {
//           case IN_WHITE:
//           case IN_OZONE:
//             break;
//           case IN_TOKEN:
//           {
//             token_info->state=IN_OZONE;
//             break;
//           }
//           case IN_QUOTE:
//           {
//             StoreToken(token_info,token,max_token_length,c);
//             break;
//           }
//         }
//         continue;
//       }
//     if (c == (int) escape)
//       {
//         if (line[(*next)+1] == '\0')
//           {
//             *breaker='\0';
//             StoreToken(token_info,token,max_token_length,c);
//             (*next)++;
//             token[token_info->offset]='\0';
//             return(0);
//           }
//         switch (token_info->state)
//         {
//           case IN_WHITE:
//           {
//             (*next)--;
//             token_info->state=IN_TOKEN;
//             break;
//           }
//           case IN_TOKEN:
//           case IN_QUOTE:
//           {
//             (*next)++;
//             c=(int) line[*next];
//             StoreToken(token_info,token,max_token_length,c);
//             break;
//           }
//           case IN_OZONE:
//           {
//             token[token_info->offset]='\0';
//             return(0);
//           }
//         }
//         continue;
//       }
//     switch (token_info->state)
//     {
//       case IN_WHITE:
//       {
//         token_info->state=IN_TOKEN;
//         StoreToken(token_info,token,max_token_length,c);
//         break;
//       }
//       case IN_TOKEN:
//       case IN_QUOTE:
//       {
//         StoreToken(token_info,token,max_token_length,c);
//         break;
//       }
//       case IN_OZONE:
//       {
//         token[token_info->offset]='\0';
//         return(0);
//       }
//     }
//   }
//   token[token_info->offset]='\0';
//   return(0);
// }

// the below code fragment can be found in:
// MagickCore/locale.c
// MagickExport void LocaleLower(char *string)
// {
//   register char
//     *q;
// 
//   assert(string != (char *) NULL);
//   for (q=string; *q != '\0'; q++)
//     *q=(char) LocaleLowercase((int) *q);
// }

// the below code fragment can be found in:
// MagickCore/locale.c
// MagickExport void LocaleUpper(char *string)
// {
//   register char
//     *q;
// 
//   assert(string != (char *) NULL);
//   for (q=string; *q != '\0'; q++)
//     *q=(char) LocaleUppercase((int) *q);
// }

// the below code fragment can be found in:
// MagickCore/locale.c
// LocaleComponentGenesis(void)
// {
//   if (locale_semaphore == (SemaphoreInfo *) NULL)
//     locale_semaphore=AcquireSemaphoreInfo();
// #if defined(MAGICKCORE_LOCALE_SUPPORT)
//   (void) AcquireCLocale();
// #endif
//   return(MagickTrue);
// }

// the below code fragment can be found in:
// MagickCore/xwindow.c
// MagickExport XrmDatabase XGetResourceDatabase(Display *display,
//   const char *client_name)
// {
//   char
//     filename[MagickPathExtent];
// 
//   int
//     c;
// 
//   register const char
//     *p;
// 
//   XrmDatabase
//     resource_database,
//     server_database;
// 
//   if (display == (Display *) NULL)
//     return((XrmDatabase) NULL);
//   assert(client_name != (char *) NULL);
//   /*
//     Initialize resource database.
//   */
//   XrmInitialize();
//   (void) XGetDefault(display,(char *) client_name,"dummy");
//   resource_database=XrmGetDatabase(display);
//   /*
//     Combine application database.
//   */
//   p=client_name+(strlen(client_name)-1);
//   while ((p > client_name) && (*p != '/'))
//     p--;
//   if (*p == '/')
//     client_name=p+1;
//   c=(int) (*client_name);
//   if ((c >= XK_a) && (c <= XK_z))
//     c-=(XK_a-XK_A);
//   else
//     if ((c >= XK_agrave) && (c <= XK_odiaeresis))
//       c-=(XK_agrave-XK_Agrave);
//     else
//       if ((c >= XK_oslash) && (c <= XK_thorn))
//         c-=(XK_oslash-XK_Ooblique);
// #if defined(X11_APPLICATION_PATH)
//   (void) FormatLocaleString(filename,MagickPathExtent,"%s%c%s",
//     X11_APPLICATION_PATH,c,client_name+1);
//   (void) XrmCombineFileDatabase(filename,&resource_database,MagickFalse);
// #endif
//   if (XResourceManagerString(display) != (char *) NULL)
//     {
//       /*
//         Combine server database.
//       */
//       server_database=XrmGetStringDatabase(XResourceManagerString(display));
//       XrmCombineDatabase(server_database,&resource_database,MagickFalse);
//     }
//   /*
//     Merge user preferences database.
//   */
// #if defined(X11_PREFERENCES_PATH)
//   (void) FormatLocaleString(filename,MagickPathExtent,"%s%src",
//     X11_PREFERENCES_PATH,client_name);
//   ExpandFilename(filename);
//   (void) XrmCombineFileDatabase(filename,&resource_database,MagickFalse);
// #endif
//   return(resource_database);
// }

