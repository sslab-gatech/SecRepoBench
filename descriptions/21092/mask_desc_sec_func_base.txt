int map (int value, unsigned int from_offset = 0, unsigned int to_offset = 1) const
  {
#define fromCoord coords[from_offset]
#define toCoord coords[to_offset]
    /* The following special-cases are not part of OpenType, which requires
     * that at least -1, 0, and +1 must be mapped. But we include these as
     * part of a better error recovery scheme. */
    if (len < 2)
    {
      if (!len)
	return value;
      else /* len == 1*/
	return value - arrayZ[0].fromCoord + arrayZ[0].toCoord;
    }

    // Determine the position of the input value in relation to the 'fromCoord' values
    // in the arrayZ structure. If the value is less than or equal to the first
    // 'fromCoord', adjust the value by mapping it using the first 'fromCoord' and
    // 'toCoord' pair. Otherwise, iterate through the arrayZ structure to find the
    // appropriate segment where the value fits, and return a mapped result based
    // on that segment's 'fromCoord' and 'toCoord' values. The loop identifies the
    // appropriate segment by comparing the input value with the 'fromCoord' values
    // of the segments in sequence.
    // <MASK>

    if (unlikely (arrayZ[i-1].fromCoord == arrayZ[i].fromCoord))
      return arrayZ[i-1].toCoord;

    int denom = arrayZ[i].fromCoord - arrayZ[i-1].fromCoord;
    return arrayZ[i-1].toCoord +
	   ((arrayZ[i].toCoord - arrayZ[i-1].toCoord) *
	    (value - arrayZ[i-1].fromCoord) + denom/2) / denom;
#undef toCoord
#undef fromCoord
  }