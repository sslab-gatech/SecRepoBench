// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/cmscgats.c
static
const char *GetDataFormat(cmsIT8* it8, int n)
{
    TABLE* t = GetTable(it8);

    if (t->DataFormat)
        return t->DataFormat[n];

    return NULL;
}

// the below code fragment can be found in:
// src/cmscgats.c
static
cmsBool SetData(cmsIT8* it8, int nSet, int nField, const char *Val)
{
    TABLE* t = GetTable(it8);

    if (!t->Data) {
        if (!AllocateDataSet(it8)) return FALSE;
    }

    if (!t->Data) return FALSE;

    if (nSet > t -> nPatches || nSet < 0) {

            return SynError(it8, "Patch %d out of range, there are %d patches", nSet, t -> nPatches);
    }

    if (nField > t ->nSamples || nField < 0) {
            return SynError(it8, "Sample %d out of range, there are %d samples", nField, t ->nSamples);

    }

    t->Data [nSet * t -> nSamples + nField] = AllocString(it8, Val);
    return TRUE;
}

// the below code fragment can be found in:
// src/cmscgats.c
static
int LocateSample(cmsIT8* it8, const char* cSample)
{
    int i;
    const char *fld;
    TABLE* t = GetTable(it8);

    for (i=0; i < t->nSamples; i++) {

        fld = GetDataFormat(it8, i);
        if (fld != NULL) {
            if (cmsstrcasecmp(fld, cSample) == 0)
                return i;
        }
    }

    return -1;

}

// the below code fragment can be found in:
// src/cmscgats.c
static
cmsBool DataSection (cmsIT8* it8)
{
    int  iField = 0;
    int  iSet   = 0;
    char Buffer[256];
    TABLE* t = GetTable(it8);

    InSymbol(it8);   // Eats "BEGIN_DATA"
    CheckEOLN(it8);

    if (!t->Data) {
        if (!AllocateDataSet(it8)) return FALSE;
    }

    while (it8->sy != SEND_DATA && it8->sy != SEOF)
    {
        if (iField >= t -> nSamples) {
            iField = 0;
            iSet++;

        }

        if (it8->sy != SEND_DATA && it8->sy != SEOF) {

            switch (it8->sy)
            {

            // To keep very long data
            case SIDENT:  
                if (!SetData(it8, iSet, iField, StringPtr(it8->id)))
                    return FALSE;
                break;

            case SSTRING:
                if (!SetData(it8, iSet, iField, StringPtr(it8->str)))
                    return FALSE;
                break;

            default:

            if (!GetVal(it8, Buffer, 255, "Sample data expected"))
                return FALSE;

            if (!SetData(it8, iSet, iField, Buffer))
                return FALSE;
            }

            iField++;

            InSymbol(it8);
            SkipEOLN(it8);
        }
    }

    SkipEOLN(it8);
    Skip(it8, SEND_DATA);
    SkipEOLN(it8);

    // Check for data completion.

    if ((iSet+1) != t -> nPatches)
        return SynError(it8, "Count mismatch. NUMBER_OF_SETS was %d, found %d\n", t ->nPatches, iSet+1);

    return TRUE;
}

// the below code fragment can be found in:
// src/cmscgats.c
static
void CookPointers(cmsIT8* it8)
{
    int idField, i;
    char* Fld;
    cmsUInt32Number j;
    cmsUInt32Number nOldTable = it8->nTable;

    for (j = 0; j < it8->TablesCount; j++) {

        TABLE* t = it8->Tab + j;

        t->SampleID = 0;
        it8->nTable = j;

        for (idField = 0; idField < t->nSamples; idField++)
        {
            if (t->DataFormat == NULL) {
                SynError(it8, "Undefined DATA_FORMAT");
                return;
            }

            Fld = t->DataFormat[idField];
            if (!Fld) continue;


            if (cmsstrcasecmp(Fld, "SAMPLE_ID") == 0) {

                t->SampleID = idField;
            }

            // "LABEL" is an extension. It keeps references to forward tables

            if ((cmsstrcasecmp(Fld, "LABEL") == 0) || Fld[0] == '$') {

                // Search for table references...
                for (i = 0; i < t->nPatches; i++) {

                    char* Label = GetData(it8, i, idField);

                    if (Label) {

                        cmsUInt32Number k;

                        // This is the label, search for a table containing
                        // this property

                        for (k = 0; k < it8->TablesCount; k++) {

                            TABLE* Table = it8->Tab + k;
                            KEYVALUE* p;

                            if (IsAvailableOnList(Table->HeaderList, Label, NULL, &p)) {

                                // Available, keep type and table
                                char Buffer[256];

                                char* Type = p->Value;
                                int  nTable = (int)k;

                                snprintf(Buffer, 255, "%s %d %s", Label, nTable, Type);

                                SetData(it8, i, idField, Buffer);
                            }
                        }
                    }
                }
            }
        }
    }

    it8->nTable = nOldTable;
}

