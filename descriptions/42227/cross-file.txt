// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/cmscgats.c
// static
// cmsBool CheckEOLN(cmsIT8* it8)
// {
//         if (!Check(it8, SEOLN, "Expected separator")) return FALSE;
//         while (it8 -> sy == SEOLN)
//                         InSymbol(it8);
//         return TRUE;
// 
// }

// the below code fragment can be found in:
// src/cmscgats.c
// static
// cmsBool ParseIT8(cmsIT8* it8, cmsBool nosheet)
// {
//     char* SheetTypePtr = it8 ->Tab[0].SheetType;
// 
//     if (nosheet == 0) {
//         ReadType(it8, SheetTypePtr);
//     }
// 
//     InSymbol(it8);
// 
//     SkipEOLN(it8);
// 
//     while (it8-> sy != SEOF &&
//            it8-> sy != SSYNERROR) {
// 
//             switch (it8 -> sy) {
// 
//             case SBEGIN_DATA_FORMAT:
//                     if (!DataFormatSection(it8)) return FALSE;
//                     break;
// 
//             case SBEGIN_DATA:
// 
//                     if (!DataSection(it8)) return FALSE;
// 
//                     if (it8 -> sy != SEOF) {
// 
//                             AllocTable(it8);
//                             it8 ->nTable = it8 ->TablesCount - 1;
// 
//                             // Read sheet type if present. We only support identifier and string.
//                             // <ident> <eoln> is a type string
//                             // anything else, is not a type string
//                             if (nosheet == 0) {
// 
//                                 if (it8 ->sy == SIDENT) {
// 
//                                     // May be a type sheet or may be a prop value statement. We cannot use insymbol in
//                                     // this special case...
//                                      while (isseparator(it8->ch))
//                                          NextCh(it8);
// 
//                                      // If a newline is found, then this is a type string
//                                     if (it8 ->ch == '\n' || it8->ch == '\r') {
// 
//                                          cmsIT8SetSheetType(it8, StringPtr(it8 ->id));
//                                          InSymbol(it8);
//                                     }
//                                     else
//                                     {
//                                         // It is not. Just continue
//                                         cmsIT8SetSheetType(it8, "");
//                                     }
//                                 }
//                                 else
//                                     // Validate quoted strings
//                                     if (it8 ->sy == SSTRING) {
//                                         cmsIT8SetSheetType(it8, StringPtr(it8 ->str));
//                                         InSymbol(it8);
//                                     }
//                            }
// 
//                     }
//                     break;
// 
//             case SEOLN:
//                     SkipEOLN(it8);
//                     break;
// 
//             default:
//                     if (!HeaderSection(it8)) return FALSE;
//            }
// 
//     }
// 
//     return (it8 -> sy != SSYNERROR);
// }

// the below code fragment can be found in:
// src/cmscgats.c
// static
// cmsFloat64Number ParseFloatNumber(const char *Buffer)
// {
//     cmsFloat64Number dnum = 0.0;
//     int sign = 1;
// 
//     // keep safe
//     if (Buffer == NULL) return 0.0;
// 
//     if (*Buffer == '-' || *Buffer == '+') {
// 
//         sign = (*Buffer == '-') ? -1 : 1;
//         Buffer++;
//     }
// 
// 
//     while (*Buffer && isdigit((int)*Buffer)) {
// 
//         dnum = dnum * 10.0 + (*Buffer - '0');
//         if (*Buffer) Buffer++;
//     }
// 
//     if (*Buffer == '.') {
// 
//         cmsFloat64Number frac = 0.0;      // fraction
//         int prec = 0;                     // precision
// 
//         if (*Buffer) Buffer++;
// 
//         while (*Buffer && isdigit((int)*Buffer)) {
// 
//             frac = frac * 10.0 + (*Buffer - '0');
//             prec++;
//             if (*Buffer) Buffer++;
//         }
// 
//         dnum = dnum + (frac / xpow10(prec));
//     }
// 
//     // Exponent, example 34.00E+20
//     if (*Buffer && toupper(*Buffer) == 'E') {
// 
//         int e;
//         int sgn;
// 
//         if (*Buffer) Buffer++;
//         sgn = 1;
// 
//         if (*Buffer == '-') {
// 
//             sgn = -1;
//             if (*Buffer) Buffer++;
//         }
//         else
//             if (*Buffer == '+') {
// 
//                 sgn = +1;
//                 if (*Buffer) Buffer++;
//             }
// 
//         e = 0;
//         while (*Buffer && isdigit((int)*Buffer)) {
// 
//             cmsInt32Number digit = (*Buffer - '0');
// 
//             if ((cmsFloat64Number)e * 10.0 + digit < (cmsFloat64Number)+2147483647.0)
//                 e = e * 10 + digit;
// 
//             if (*Buffer) Buffer++;
//         }
// 
//         e = sgn*e;
//         dnum = dnum * xpow10(e);
//     }
// 
//     return sign * dnum;
// }

// the below code fragment can be found in:
// src/cmscgats.c
// static
// SYMBOL BinSrchKey(const char *id)
// {
//     int l = 1;
//     int r = NUMKEYS;
//     int x, res;
// 
//     while (r >= l)
//     {
//         x = (l+r)/2;
//         res = cmsstrcasecmp(id, TabKeys[x-1].id);
//         if (res == 0) return TabKeys[x-1].sy;
//         if (res < 0) r = x - 1;
//         else l = x + 1;
//     }
// 
//     return SUNDEFINED;
// }

// the below code fragment can be found in:
// src/cmscgats.c
// static
// void CookPointers(cmsIT8* it8)
// {
//     int idField, i;
//     char* Fld;
//     cmsUInt32Number j;
//     cmsUInt32Number nOldTable = it8 ->nTable;
// 
//     for (j=0; j < it8 ->TablesCount; j++) {
// 
//     TABLE* t = it8 ->Tab + j;
// 
//     t -> SampleID = 0;
//     it8 ->nTable = j;
// 
//     for (idField = 0; idField < t -> nSamples; idField++)
//     {
//         if (t ->DataFormat == NULL){
//             SynError(it8, "Undefined DATA_FORMAT");
//             return;
//         }
// 
//         Fld = t->DataFormat[idField];
//         if (!Fld) continue;
// 
// 
//         if (cmsstrcasecmp(Fld, "SAMPLE_ID") == 0) {
// 
//             t -> SampleID = idField;            
//         }
// 
//         // "LABEL" is an extension. It keeps references to forward tables
// 
//         if ((cmsstrcasecmp(Fld, "LABEL") == 0) || Fld[0] == '$') {
// 
//             // Search for table references...
//             for (i = 0; i < t->nPatches; i++) {
// 
//                 char* Label = GetData(it8, i, idField);
// 
//                 if (Label) {
// 
//                     cmsUInt32Number k;
// 
//                     // This is the label, search for a table containing
//                     // this property
// 
//                     for (k = 0; k < it8->TablesCount; k++) {
// 
//                         TABLE* Table = it8->Tab + k;
//                         KEYVALUE* p;
// 
//                         if (IsAvailableOnList(Table->HeaderList, Label, NULL, &p)) {
// 
//                             // Available, keep type and table
//                             char Buffer[256];
// 
//                             char* Type = p->Value;
//                             int  nTable = (int)k;
// 
//                             snprintf(Buffer, 255, "%s %d %s", Label, nTable, Type);
// 
//                             SetData(it8, i, idField, Buffer);
//                         }
//                     }
// 
// 
//                 }
// 
//             }
// 
// 
//         }
// 
//     }
//     }
// 
//     it8 ->nTable = nOldTable;
// }

