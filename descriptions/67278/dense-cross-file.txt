// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/filters/reframe_mhas.c
static const char *mhas_dmx_probe_data(const u8 *data, u32 size, GF_FilterProbeScore *score)
{
	s32 sync_pos = -1;
	GF_BitStream *bs;
	u32 nb_mhas_cfg = 0;
	u32 nb_mhas_frames = 0;
	u32 nb_mhas_unknown = 0;
	const u8 *ptr = data;
	while (ptr) {
		u32 pos = (u32) (ptr - data);
		const u8 *sync_start = memchr(ptr, 0xC0, size - pos);
		if (!sync_start) return NULL;
		u32 remain = size - (u32) (sync_start-data);
		if (remain<2) return NULL;
		if ((sync_start[1]== 0x01) && (sync_start[2]==0xA5)) {
			sync_pos = pos;
			break;
		}
		ptr = sync_start+1;
	}
	if (sync_pos<0) return NULL;
	bs = gf_bs_new(data, size, GF_BITSTREAM_READ);
	gf_bs_skip_bytes(bs, sync_pos);

	while (gf_bs_available(bs)) {
		u32 type = (u32) gf_mpegh_escaped_value(bs, 3, 8, 8);
		/*u64 label = */gf_mpegh_escaped_value(bs, 2, 8, 32);
		u64 mh_size = gf_mpegh_escaped_value(bs, 11, 24, 24);
		if (mh_size > gf_bs_available(bs))
			break;
		//MHAS config
		if (type==1) nb_mhas_cfg++;
		else if (type==2) nb_mhas_frames++;
		else if (type>18) nb_mhas_unknown++;
		gf_bs_skip_bytes(bs, mh_size);
	}
	gf_bs_del(bs);
	if (!nb_mhas_unknown && nb_mhas_cfg && nb_mhas_frames) {
		*score = GF_FPROBE_SUPPORTED;
		return "audio/mpegh";
	}
	return NULL;
}

// the below code fragment can be found in:
// src/filters/reframe_adts.c
static const char *adts_dmx_probe_data(const u8 *data, u32 size, GF_FilterProbeScore *score)
{
	u32 nb_frames=0, next_pos=0, max_consecutive_frames=0;
	ADTSHeader prev_hdr;
	GF_BitStream *bs;
	Bool has_id3=GF_FALSE;
	Bool has_broken_data=GF_FALSE;

	/*check for id3*/
	if (size>= 10) {
		if (data[0] == 'I' && data[1] == 'D' && data[2] == '3') {
			u32 tag_size = ((data[9] & 0x7f) + ((data[8] & 0x7f) << 7) + ((data[7] & 0x7f) << 14) + ((data[6] & 0x7f) << 21));

			if (tag_size+10 > size) {
				GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, ("ID3 tag detected size %d but probe data only %d bytes, will rely on file extension (try increasing probe size using --block_size)\n", tag_size+10, size));
				*score = GF_FPROBE_EXT_MATCH;
				return "aac|adts";
			}
			data += tag_size+10;
			size -= tag_size+10;
			has_id3 = GF_TRUE;
		}
	}

	bs = gf_bs_new(data, size, GF_BITSTREAM_READ);
	memset(&prev_hdr, 0, sizeof(ADTSHeader));
	while (gf_bs_available(bs)) {
		ADTSHeader hdr;
		u32 pos;
		hdr.frame_size = 0;
		if (!adts_dmx_sync_frame_bs(bs, &hdr)) {
			if (hdr.frame_size) {
				//nb_frames++;
				max_consecutive_frames++;
			}
			break;
		}
		if ((hdr.hdr_size!=7) && (hdr.hdr_size!=9)) continue;
//		if (!hdr.nb_ch) continue;
		pos = (u32) gf_bs_get_position(bs);

		if (!nb_frames) {
			nb_frames = 1;
		} else if ((next_pos + hdr.hdr_size == pos) && (hdr.sr_idx==prev_hdr.sr_idx) && (hdr.nb_ch==prev_hdr.nb_ch) ) {
			nb_frames++;
			if (max_consecutive_frames<nb_frames) max_consecutive_frames = nb_frames;
			if (max_consecutive_frames>5)
				break;
		} else {
			nb_frames=1;
			has_broken_data=GF_TRUE;
		}
		prev_hdr = hdr;
		gf_bs_skip_bytes(bs, hdr.frame_size);
		next_pos = (u32) gf_bs_get_position(bs);
	}
	gf_bs_del(bs);
	if (max_consecutive_frames>=4) {
		*score = has_broken_data ? GF_FPROBE_MAYBE_NOT_SUPPORTED : GF_FPROBE_SUPPORTED;
		return "audio/aac";
	}
	if (has_id3 && max_consecutive_frames) {
		*score = GF_FPROBE_MAYBE_SUPPORTED;
		return "audio/aac";
	}
	return NULL;
}

// the below code fragment can be found in:
// src/filters/reframe_flac.c
static const char *flac_dmx_probe_data(const u8 *data, u32 size, GF_FilterProbeScore *score)
{
	if ((size>4) && !strncmp(data, "fLaC", 4)) {
		*score = GF_FPROBE_SUPPORTED;
		return "audio/flac";
	}
	return NULL;
}

// the below code fragment can be found in:
// src/filters/dmx_m2ts.c
static const char *m2tsdmx_probe_data(const u8 *data, u32 size, GF_FilterProbeScore *score)
{
	if (gf_m2ts_probe_data(data, size)) {
		*score = GF_FPROBE_SUPPORTED;
		return "video/mp2t";
	}
	return NULL;
}

// the below code fragment can be found in:
// src/filters/reframe_ac3.c
static const char *ac3dmx_probe_data(const u8 *_data, u32 _size, GF_FilterProbeScore *score)
{
	GF_AC3Config ahdr;
	u32 i, nb_frames=0;
	Bool has_broken_frames = GF_FALSE;
	u32 pos=0;
	const u8 *data = _data;
	u32 size = _size;
	u32 nb_ac3_frames=0;

	//check AC3
	while (1) {
		ahdr.sample_rate = 0;
		if (! gf_ac3_parser((u8 *) data, size, &pos, &ahdr, GF_FALSE) ) {
			if (ahdr.sample_rate) nb_frames++;
		 	break;
		}
		u32 fsize = ahdr.framesize;
		if (pos) {
			nb_frames=0;
			has_broken_frames = GF_TRUE;
			//what is before is bigger than max ac3 frame size (1920 words), this is packaged ac3 (mkv) at best
			if (pos > 4000)
				break;
		}
		nb_frames++;
		if (fsize > size+pos) {
			if (!pos && (nb_frames==1)) nb_frames++;
			break;
		}
		if (nb_frames>4) break;
		if (size < fsize+pos) break;
		size -= fsize+pos;
		data += fsize+pos;
	}
	nb_ac3_frames = nb_frames;

	//check EAC3
	pos=0;
	data = _data;
	size = _size;
	nb_frames = 0;
	GF_BitStream *bs = gf_bs_new(data, size, GF_BITSTREAM_READ);
	while (gf_bs_available(bs)) {
		ahdr.sample_rate = 0;
		if (!gf_eac3_parser_bs(bs, &ahdr, GF_FALSE)) {
			if (ahdr.sample_rate) nb_frames++;
			break;
		}

		if (pos != (u32) gf_bs_get_position(bs))
			has_broken_frames = GF_TRUE;
		nb_frames += ahdr.nb_streams;
		for (i=0; i<ahdr.nb_streams; i++)
			nb_frames += ahdr.streams[i].nb_dep_sub ? 1 : 0;
		gf_bs_skip_bytes(bs, ahdr.framesize);
		if (!pos && (nb_frames==1) && !gf_bs_available(bs)) nb_frames++;
		pos+=ahdr.framesize;
		if (nb_frames>4) break;
	}
	gf_bs_del(bs);

	if (nb_frames<nb_ac3_frames) {
		nb_frames = 0;
	}
	if (nb_ac3_frames>=2) {
		*score = has_broken_frames ? GF_FPROBE_MAYBE_NOT_SUPPORTED : GF_FPROBE_SUPPORTED;
		return "audio/ac3";
	}

	if (nb_frames>=2) {
		*score = has_broken_frames ? GF_FPROBE_MAYBE_NOT_SUPPORTED : GF_FPROBE_SUPPORTED;
		return "audio/eac3";
	}

	return NULL;
}

