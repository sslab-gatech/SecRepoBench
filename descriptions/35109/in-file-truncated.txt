/*
** sprintf.c - Kernel.#sprintf
**
** See Copyright Notice in mruby.h
*/

#include <mruby.h>
#include <limits.h>
#include <string.h>
#include <mruby/string.h>
#include <mruby/hash.h>
#include <mruby/numeric.h>
#include <mruby/presym.h>
#ifndef MRB_NO_FLOAT
#include <math.h>
#endif
#include <ctype.h>

#define BIT_DIGITS(N)   (((N)*146)/485 + 1)  /* log2(10) =~ 146/485 */
#define BITSPERDIG MRB_INT_BIT
#define EXTENDSIGN(n, l) (((~0U << (n)) >> (((n)*(l)) % BITSPERDIG)) & ~(~0U << (n)))

mrb_value mrb_str_format(mrb_state *, mrb_int, const mrb_value *, mrb_value);

static char*
remove_sign_bits(char *str, int base)
{
  char *t;

  t = str;
  if (base == 16) {
    while (*t == 'f') {
      t++;
    }
  }
  else if (base == 8) {
    *t |= EXTENDSIGN(3, strlen(t));
    while (*t == '7') {
      t++;
    }
  }
  else if (base == 2) {
    while (*t == '1') {
      t++;
    }
  }

  return t;
}

static char
sign_bits(int base, const char *p)
{
  char c;

  switch (base) {
  case 16:
    if (*p == 'X') c = 'F';
    else c = 'f';
    break;
  case 8:
    c = '7'; break;
  case 2:
    c = '1'; break;
  default:
    c = '.'; break;
  }
  return c;
}

static char *
mrb_uint_to_cstr(char *buf, size_t len, mrb_int num, int base)
{
  char *b = buf + len - 1;
  const int mask = base-1;
  int shift;
  mrb_uint val = (uint64_t)num;
  char d;

  if (num == 0) {
    buf[0] = '0'; buf[1] = '\0';
    return buf;
  }
  switch (base) {
  case 16: d = 'f'; shift = 4; break;
  case

// --- CODE TRUNCATED HERE ---

static const char *
get_num(mrb_state *mrb, const char *p, const char *end, int *valp)
{
  mrb_int nextnumber = (int)*valp;
  // This code parses a sequence of digits from a format string to compute an integer value.
  // It iterates over the characters in the string as long as they are digits and attempts to 
  // accumulate these digits into the next number integer.
  // After parsing the digits, check for a malformed format string, and raise an 
  // error if so.
  // <MASK>
  *valp = (int)nextnumber;
  return p;
}