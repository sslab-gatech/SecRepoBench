/*
 ** pack.c - Array#pack, String#unpack
 */

#include <mruby.h>
#include "mruby/error.h"
#include "mruby/array.h"
#include "mruby/class.h"
#include "mruby/numeric.h"
#include "mruby/string.h"
#include "mruby/variable.h"
#include "mruby/endian.h"

#include <ctype.h>
#include <string.h>

#define INT_OVERFLOW_P(n)  ((n) < MRB_INT_MIN || (n) > MRB_INT_MAX)
#define UINT_OVERFLOW_P(n) ((n) > MRB_INT_MAX)

#ifndef EOF
# define EOF (-1) /* for MRB_NO_STDIO */
#endif

struct tmpl {
  mrb_value str;
  int idx;
};

enum pack_dir {
  PACK_DIR_CHAR,      /* C */
  PACK_DIR_SHORT,     /* S */
  PACK_DIR_LONG,      /* L */
  PACK_DIR_QUAD,      /* Q */
  //PACK_DIR_INT,     /* i */
  //PACK_DIR_VAX,
  PACK_DIR_BER,       /* w */
  PACK_DIR_UTF8,      /* U */
  PACK_DIR_DOUBLE,    /* E */
  PACK_DIR_FLOAT,     /* f */
  PACK_DIR_STR,       /* A */
  PACK_DIR_HEX,       /* h */
  PACK_DIR_BSTR,      /* b */
  PACK_DIR_BASE64,    /* m */
  PACK_DIR_QENC,      /* M */
  PACK_DIR_NUL,       /* x */
  PACK_DIR_BACK,      /* X */
  PACK_DIR_ABS,       /* @ */
  PACK_DIR_NONE,      /* - */
};

enum pack_type {
  PACK_TYPE_INTEGER,
  PACK_TYPE_FLOAT,
  PACK_TYPE_STRING,
  PACK_

// --- CODE TRUNCATED HERE ---

static int
unpack_bstr(mrb_state *mrbstate, const void *src, int slen, mrb_value ary, int count, unsigned int flags)
{
  // Unpack the binary data from the source into a string representation of bits.
  // The binary data is read from the source pointer, `src`, and the number of bits to unpack is determined by `count`.
  // If `count` is not specified, it defaults to the length of the source data multiplied by 8.
  // Create a new string `dst` to hold the unpacked bit representation with a length of `count`.
  // Iterate over each bit in the specified range and convert it to a character '0' or '1' based on the value of each bit.
  // Handle the conversion based on the specified `flags`, where `PACK_FLAG_LSB` indicates whether to read the least significant or most significant bits first.
  // Append the resulting string to the array `ary` and return the number of bytes read from the source.
  // <MASK>
  dst = mrb_str_resize(mrbstate, dst, (mrb_int)(dptr - dptr0));
  mrb_ary_push(mrbstate, ary, dst);
  return (int)(sptr - sptr0);
}