// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// code/AssetLib/Raw/RawLoader.cpp
void RAWImporter::InternReadFile(const std::string &pFile,
        aiScene *pScene, IOSystem *pIOHandler) {
    std::unique_ptr<IOStream> file(pIOHandler->Open(pFile, "rb"));

    // Check whether we can read from the file
    if (file == nullptr) {
        throw DeadlyImportError("Failed to open RAW file ", pFile, ".");
    }

    // allocate storage and copy the contents of the file to a memory buffer
    // (terminate it with zero)
    std::vector<char> mBuffer2;
    TextFileToBuffer(file.get(), mBuffer2);
    const char *buffer = &mBuffer2[0];

    // list of groups loaded from the file
    std::vector<GroupInformation> outGroups(1, GroupInformation("<default>"));
    std::vector<GroupInformation>::iterator curGroup = outGroups.begin();

    // now read all lines
    char line[4096];
    while (GetNextLine(buffer, line)) {
        // if the line starts with a non-numeric identifier, it marks
        // the beginning of a new group
        const char *sz = line;
        SkipSpaces(&sz);
        if (IsLineEnd(*sz)) continue;
        if (!IsNumeric(*sz)) {
            const char *sz2 = sz;
            while (!IsSpaceOrNewLine(*sz2))
                ++sz2;
            const unsigned int length = (unsigned int)(sz2 - sz);

            // find an existing group with this name
            for (std::vector<GroupInformation>::iterator it = outGroups.begin(), end = outGroups.end();
                    it != end; ++it) {
                if (length == (*it).name.length() && !::strcmp(sz, (*it).name.c_str())) {
                    curGroup = it;
                    sz2 = nullptr;
                    break;
                }
            }
            if (sz2) {
                outGroups.emplace_back(std::string(sz, length));
                curGroup = outGroups.end() - 1;
            }
        } else {
            // there can be maximally 12 floats plus an extra texture file name
            float data[12];
            unsigned int num;
            for (num = 0; num < 12; ++num) {
                if (!SkipSpaces(&sz) || !IsNumeric(*sz)) break;
                sz = fast_atoreal_move<float>(sz, data[num]);
            }
            if (num != 12 && num != 9) {
                ASSIMP_LOG_ERROR("A line may have either 9 or 12 floats and an optional texture");
                continue;
            }

            MeshInformation *output = nullptr;

            const char *sz2 = sz;
            unsigned int length;
            if (!IsLineEnd(*sz)) {
                while (!IsSpaceOrNewLine(*sz2))
                    ++sz2;
                length = (unsigned int)(sz2 - sz);
            } else if (9 == num) {
                sz = "%default%";
                length = 9;
            } else {
                sz = "";
                length = 0;
            }

            // search in the list of meshes whether we have one with this texture
            for (auto &mesh : (*curGroup).meshes) {
                if (length == mesh.name.length() && (length ? !::strcmp(sz, mesh.name.c_str()) : true)) {
                    output = &mesh;
                    break;
                }
            }
            // if we don't have the mesh, create it
            if (!output) {
                (*curGroup).meshes.emplace_back(std::string(sz, length));
                output = &((*curGroup).meshes.back());
            }
            if (12 == num) {
                aiColor4D v(data[0], data[1], data[2], 1.0f);
                output->colors.push_back(v);
                output->colors.push_back(v);
                output->colors.push_back(v);

                output->vertices.emplace_back(data[3], data[4], data[5]);
                output->vertices.emplace_back(data[6], data[7], data[8]);
                output->vertices.emplace_back(data[9], data[10], data[11]);
            } else {
                output->vertices.emplace_back(data[0], data[1], data[2]);
                output->vertices.emplace_back(data[3], data[4], data[5]);
                output->vertices.emplace_back(data[6], data[7], data[8]);
            }
        }
    }

    pScene->mRootNode = new aiNode();
    pScene->mRootNode->mName.Set("<RawRoot>");

    // count the number of valid groups
    // (meshes can't be empty)
    for (auto &outGroup : outGroups) {
        if (!outGroup.meshes.empty()) {
            ++pScene->mRootNode->mNumChildren;
            pScene->mNumMeshes += (unsigned int)outGroup.meshes.size();
        }
    }

    if (!pScene->mNumMeshes) {
        throw DeadlyImportError("RAW: No meshes loaded. The file seems to be corrupt or empty.");
    }

    pScene->mMeshes = new aiMesh *[pScene->mNumMeshes];
    aiNode **cc;
    if (1 == pScene->mRootNode->mNumChildren) {
        cc = &pScene->mRootNode;
        pScene->mRootNode->mNumChildren = 0;
    } else {
        cc = new aiNode *[pScene->mRootNode->mNumChildren];
        memset(cc, 0, sizeof(aiNode *) * pScene->mRootNode->mNumChildren);
        pScene->mRootNode->mChildren = cc;
    }

    pScene->mNumMaterials = pScene->mNumMeshes;
    aiMaterial **mats = pScene->mMaterials = new aiMaterial *[pScene->mNumMaterials];

    unsigned int meshIdx = 0;
    for (auto &outGroup : outGroups) {
        if (outGroup.meshes.empty()) continue;

        aiNode *node;
        if (pScene->mRootNode->mNumChildren) {
            node = *cc = new aiNode();
            node->mParent = pScene->mRootNode;
        } else
            node = *cc;
        node->mName.Set(outGroup.name);

        // add all meshes
        node->mNumMeshes = (unsigned int)outGroup.meshes.size();
        unsigned int *pi = node->mMeshes = new unsigned int[node->mNumMeshes];
        for (std::vector<MeshInformation>::iterator it2 = outGroup.meshes.begin(),
                                                    end2 = outGroup.meshes.end();
                it2 != end2; ++it2) {
            ai_assert(!(*it2).vertices.empty());

            // allocate the mesh
            *pi++ = meshIdx;
            aiMesh *mesh = pScene->mMeshes[meshIdx] = new aiMesh();
            mesh->mMaterialIndex = meshIdx++;

            mesh->mPrimitiveTypes = aiPrimitiveType_TRIANGLE;

            // allocate storage for the vertex components and copy them
            mesh->mNumVertices = (unsigned int)(*it2).vertices.size();
            mesh->mVertices = new aiVector3D[mesh->mNumVertices];
            ::memcpy(mesh->mVertices, &(*it2).vertices[0], sizeof(aiVector3D) * mesh->mNumVertices);

            if ((*it2).colors.size()) {
                ai_assert((*it2).colors.size() == mesh->mNumVertices);

                mesh->mColors[0] = new aiColor4D[mesh->mNumVertices];
                ::memcpy(mesh->mColors[0], &(*it2).colors[0], sizeof(aiColor4D) * mesh->mNumVertices);
            }

            // generate triangles
            ai_assert(0 == mesh->mNumVertices % 3);
            aiFace *fc = mesh->mFaces = new aiFace[mesh->mNumFaces = mesh->mNumVertices / 3];
            aiFace *const fcEnd = fc + mesh->mNumFaces;
            unsigned int n = 0;
            while (fc != fcEnd) {
                aiFace &f = *fc++;
                f.mIndices = new unsigned int[f.mNumIndices = 3];
                for (unsigned int m = 0; m < 3; ++m)
                    f.mIndices[m] = n++;
            }

            // generate a material for the mesh
            aiMaterial *mat = new aiMaterial();

            aiColor4D clr(1.0f, 1.0f, 1.0f, 1.0f);
            if ("%default%" == (*it2).name) // a gray default material
            {
                clr.r = clr.g = clr.b = 0.6f;
            } else if ((*it2).name.length() > 0) // a texture
            {
                aiString s;
                s.Set((*it2).name);
                mat->AddProperty(&s, AI_MATKEY_TEXTURE_DIFFUSE(0));
            }
            mat->AddProperty<aiColor4D>(&clr, 1, AI_MATKEY_COLOR_DIFFUSE);
            *mats++ = mat;
        }
    }
}

// the below code fragment can be found in:
// code/AssetLib/Irr/IRRMeshLoader.cpp
void IRRMeshImporter::InternReadFile(const std::string &pFile,
		aiScene *pScene, IOSystem *pIOHandler) {
	std::unique_ptr<IOStream> file(pIOHandler->Open(pFile));

	// Check whether we can read from the file
	if (file == nullptr)
		throw DeadlyImportError("Failed to open IRRMESH file ", pFile);

	// Construct the irrXML parser
	XmlParser parser;
	if (!parser.parse( file.get() )) {
		throw DeadlyImportError("XML parse error while loading IRRMESH file ", pFile);
	}
	XmlNode root = parser.getRootNode();

	// final data
	std::vector<aiMaterial *> materials;
	std::vector<aiMesh *> meshes;
	materials.reserve(5);
	meshes.reserve(5);

	// temporary data - current mesh buffer
	aiMaterial *curMat = nullptr;
	aiMesh *curMesh = nullptr;
	unsigned int curMatFlags = 0;

	std::vector<aiVector3D> curVertices, curNormals, curTangents, curBitangents;
	std::vector<aiColor4D> curColors;
	std::vector<aiVector3D> curUVs, curUV2s;

	// some temporary variables
	int textMeaning = 0;
	int vertexFormat = 0; // 0 = normal; 1 = 2 tcoords, 2 = tangents
	bool useColors = false;

	// Parse the XML file
	for (pugi::xml_node child : root.children()) {
		if (child.type() == pugi::node_element) {
			if (!ASSIMP_stricmp(child.name(), "buffer") && (curMat || curMesh)) {
				// end of previous buffer. A material and a mesh should be there
				if (!curMat || !curMesh) {
					ASSIMP_LOG_ERROR("IRRMESH: A buffer must contain a mesh and a material");
					releaseMaterial(&curMat);
					releaseMesh(&curMesh);
				} else {
					materials.push_back(curMat);
					meshes.push_back(curMesh);
				}
				curMat = nullptr;
				curMesh = nullptr;

				curVertices.clear();
				curColors.clear();
				curNormals.clear();
				curUV2s.clear();
				curUVs.clear();
				curTangents.clear();
				curBitangents.clear();
			}

			if (!ASSIMP_stricmp(child.name(), "material")) {
				if (curMat) {
					ASSIMP_LOG_WARN("IRRMESH: Only one material description per buffer, please");
					releaseMaterial(&curMat);
				}
				curMat = ParseMaterial(curMatFlags);
			}
			/* no else here! */ if (!ASSIMP_stricmp(child.name(), "vertices")) {
				pugi::xml_attribute attr = child.attribute("vertexCount");
				int num = attr.as_int();
                //int num = reader->getAttributeValueAsInt("vertexCount");

				if (!num) {
					// This is possible ... remove the mesh from the list and skip further reading
					ASSIMP_LOG_WARN("IRRMESH: Found mesh with zero vertices");

					releaseMaterial(&curMat);
					releaseMesh(&curMesh);
					textMeaning = 0;
					continue;
				}

				curVertices.reserve(num);
				curNormals.reserve(num);
				curColors.reserve(num);
				curUVs.reserve(num);

				// Determine the file format
				//const char *t = reader->getAttributeValueSafe("type");
                pugi::xml_attribute t = child.attribute("type");
				if (!ASSIMP_stricmp("2tcoords", t.name())) {
					curUV2s.reserve(num);
					vertexFormat = 1;

					if (curMatFlags & AI_IRRMESH_EXTRA_2ND_TEXTURE) {
						// *********************************************************
						// We have a second texture! So use this UV channel
						// for it. The 2nd texture can be either a normal
						// texture (solid_2layer or lightmap_xxx) or a normal
						// map (normal_..., parallax_...)
						// *********************************************************
						int idx = 1;
						aiMaterial *mat = (aiMaterial *)curMat;

						if (curMatFlags & AI_IRRMESH_MAT_lightmap) {
							mat->AddProperty(&idx, 1, AI_MATKEY_UVWSRC_LIGHTMAP(0));
						} else if (curMatFlags & AI_IRRMESH_MAT_normalmap_solid) {
							mat->AddProperty(&idx, 1, AI_MATKEY_UVWSRC_NORMALS(0));
						} else if (curMatFlags & AI_IRRMESH_MAT_solid_2layer) {
							mat->AddProperty(&idx, 1, AI_MATKEY_UVWSRC_DIFFUSE(1));
						}
					}
				} else if (!ASSIMP_stricmp("tangents", t.name())) {
					curTangents.reserve(num);
					curBitangents.reserve(num);
					vertexFormat = 2;
				} else if (ASSIMP_stricmp("standard", t.name())) {
					releaseMaterial(&curMat);
					ASSIMP_LOG_WARN("IRRMESH: Unknown vertex format");
				} else
					vertexFormat = 0;
				textMeaning = 1;
			} else if (!ASSIMP_stricmp(child.name(), "indices")) {
				if (curVertices.empty() && curMat) {
					releaseMaterial(&curMat);
					throw DeadlyImportError("IRRMESH: indices must come after vertices");
				}

				textMeaning = 2;

				// start a new mesh
				curMesh = new aiMesh();

				// allocate storage for all faces
				pugi::xml_attribute attr = child.attribute("indexCount");
				curMesh->mNumVertices = attr.as_int();
				if (!curMesh->mNumVertices) {
					// This is possible ... remove the mesh from the list and skip further reading
					ASSIMP_LOG_WARN("IRRMESH: Found mesh with zero indices");

					// mesh - away
					releaseMesh(&curMesh);

					// material - away
					releaseMaterial(&curMat);

					textMeaning = 0;
					continue;
				}

				if (curMesh->mNumVertices % 3) {
					ASSIMP_LOG_WARN("IRRMESH: Number if indices isn't divisible by 3");
				}

				curMesh->mNumFaces = curMesh->mNumVertices / 3;
				curMesh->mFaces = new aiFace[curMesh->mNumFaces];

				// setup some members
				curMesh->mMaterialIndex = (unsigned int)materials.size();
				curMesh->mPrimitiveTypes = aiPrimitiveType_TRIANGLE;

				// allocate storage for all vertices
				curMesh->mVertices = new aiVector3D[curMesh->mNumVertices];

				if (curNormals.size() == curVertices.size()) {
					curMesh->mNormals = new aiVector3D[curMesh->mNumVertices];
				}
				if (curTangents.size() == curVertices.size()) {
					curMesh->mTangents = new aiVector3D[curMesh->mNumVertices];
				}
				if (curBitangents.size() == curVertices.size()) {
					curMesh->mBitangents = new aiVector3D[curMesh->mNumVertices];
				}
				if (curColors.size() == curVertices.size() && useColors) {
					curMesh->mColors[0] = new aiColor4D[curMesh->mNumVertices];
				}
				if (curUVs.size() == curVertices.size()) {
					curMesh->mTextureCoords[0] = new aiVector3D[curMesh->mNumVertices];
				}
				if (curUV2s.size() == curVertices.size()) {
					curMesh->mTextureCoords[1] = new aiVector3D[curMesh->mNumVertices];
				}
			}
			//break;

			//case EXN_TEXT: {
			const char *sz = child.child_value();
			if (textMeaning == 1) {
				textMeaning = 0;

				// read vertices
				do {
					SkipSpacesAndLineEnd(&sz);
					aiVector3D temp;
					aiColor4D c;

					// Read the vertex position
					sz = fast_atoreal_move<float>(sz, (float &)temp.x);
					SkipSpaces(&sz);

					sz = fast_atoreal_move<float>(sz, (float &)temp.y);
					SkipSpaces(&sz);

					sz = fast_atoreal_move<float>(sz, (float &)temp.z);
					SkipSpaces(&sz);
					curVertices.push_back(temp);

					// Read the vertex normals
					sz = fast_atoreal_move<float>(sz, (float &)temp.x);
					SkipSpaces(&sz);

					sz = fast_atoreal_move<float>(sz, (float &)temp.y);
					SkipSpaces(&sz);

					sz = fast_atoreal_move<float>(sz, (float &)temp.z);
					SkipSpaces(&sz);
					curNormals.push_back(temp);

					// read the vertex colors
					uint32_t clr = strtoul16(sz, &sz);
					ColorFromARGBPacked(clr, c);

					if (!curColors.empty() && c != *(curColors.end() - 1))
						useColors = true;

					curColors.push_back(c);
					SkipSpaces(&sz);

					// read the first UV coordinate set
					sz = fast_atoreal_move<float>(sz, (float &)temp.x);
					SkipSpaces(&sz);

					sz = fast_atoreal_move<float>(sz, (float &)temp.y);
					SkipSpaces(&sz);
					temp.z = 0.f;
					temp.y = 1.f - temp.y; // DX to OGL
					curUVs.push_back(temp);

					// read the (optional) second UV coordinate set
					if (vertexFormat == 1) {
						sz = fast_atoreal_move<float>(sz, (float &)temp.x);
						SkipSpaces(&sz);

						sz = fast_atoreal_move<float>(sz, (float &)temp.y);
						temp.y = 1.f - temp.y; // DX to OGL
						curUV2s.push_back(temp);
					}
					// read optional tangent and bitangent vectors
					else if (vertexFormat == 2) {
						// tangents
						sz = fast_atoreal_move<float>(sz, (float &)temp.x);
						SkipSpaces(&sz);

						sz = fast_atoreal_move<float>(sz, (float &)temp.z);
						SkipSpaces(&sz);

						sz = fast_atoreal_move<float>(sz, (float &)temp.y);
						SkipSpaces(&sz);
						temp.y *= -1.0f;
						curTangents.push_back(temp);

						// bitangents
						sz = fast_atoreal_move<float>(sz, (float &)temp.x);
						SkipSpaces(&sz);

						sz = fast_atoreal_move<float>(sz, (float &)temp.z);
						SkipSpaces(&sz);

						sz = fast_atoreal_move<float>(sz, (float &)temp.y);
						SkipSpaces(&sz);
						temp.y *= -1.0f;
						curBitangents.push_back(temp);
					}
				}

				/* IMPORTANT: We assume that each vertex is specified in one
                line. So we can skip the rest of the line - unknown vertex
                elements are ignored.
                */

				while (SkipLine(&sz));
			} else if (textMeaning == 2) {
				textMeaning = 0;

				// read indices
				aiFace *curFace = curMesh->mFaces;
				aiFace *const faceEnd = curMesh->mFaces + curMesh->mNumFaces;

				aiVector3D *pcV = curMesh->mVertices;
				aiVector3D *pcN = curMesh->mNormals;
				aiVector3D *pcT = curMesh->mTangents;
				aiVector3D *pcB = curMesh->mBitangents;
				aiColor4D *pcC0 = curMesh->mColors[0];
				aiVector3D *pcT0 = curMesh->mTextureCoords[0];
				aiVector3D *pcT1 = curMesh->mTextureCoords[1];

				unsigned int curIdx = 0;
				unsigned int total = 0;
				while (SkipSpacesAndLineEnd(&sz)) {
					if (curFace >= faceEnd) {
						ASSIMP_LOG_ERROR("IRRMESH: Too many indices");
						break;
					}
					if (!curIdx) {
						curFace->mNumIndices = 3;
						curFace->mIndices = new unsigned int[3];
					}

					unsigned int idx = strtoul10(sz, &sz);
					if (idx >= curVertices.size()) {
						ASSIMP_LOG_ERROR("IRRMESH: Index out of range");
						idx = 0;
					}

					curFace->mIndices[curIdx] = total++;

					*pcV++ = curVertices[idx];
					if (pcN) *pcN++ = curNormals[idx];
					if (pcT) *pcT++ = curTangents[idx];
					if (pcB) *pcB++ = curBitangents[idx];
					if (pcC0) *pcC0++ = curColors[idx];
					if (pcT0) *pcT0++ = curUVs[idx];
					if (pcT1) *pcT1++ = curUV2s[idx];

					if (++curIdx == 3) {
						++curFace;
						curIdx = 0;
					}
				}

				if (curFace != faceEnd)
					ASSIMP_LOG_ERROR("IRRMESH: Not enough indices");

				// Finish processing the mesh - do some small material workarounds
				if (curMatFlags & AI_IRRMESH_MAT_trans_vertex_alpha && !useColors) {
					// Take the opacity value of the current material
					// from the common vertex color alpha
					aiMaterial *mat = (aiMaterial *)curMat;
					mat->AddProperty(&curColors[0].a, 1, AI_MATKEY_OPACITY);
				}
			}
		}
	}

	// End of the last buffer. A material and a mesh should be there
	if (curMat || curMesh) {
		if (!curMat || !curMesh) {
			ASSIMP_LOG_ERROR("IRRMESH: A buffer must contain a mesh and a material");
			releaseMaterial(&curMat);
			releaseMesh(&curMesh);
		} else {
			materials.push_back(curMat);
			meshes.push_back(curMesh);
		}
	}

	if (materials.empty()) {
		throw DeadlyImportError("IRRMESH: Unable to read a mesh from this file");
	}

	// now generate the output scene
	pScene->mNumMeshes = (unsigned int)meshes.size();
	pScene->mMeshes = new aiMesh *[pScene->mNumMeshes];
	for (unsigned int i = 0; i < pScene->mNumMeshes; ++i) {
		pScene->mMeshes[i] = meshes[i];

		// clean this value ...
		pScene->mMeshes[i]->mNumUVComponents[3] = 0;
	}

	pScene->mNumMaterials = (unsigned int)materials.size();
	pScene->mMaterials = new aiMaterial *[pScene->mNumMaterials];
	::memcpy(pScene->mMaterials, &materials[0], sizeof(void *) * pScene->mNumMaterials);

	pScene->mRootNode = new aiNode();
	pScene->mRootNode->mName.Set("<IRRMesh>");
	pScene->mRootNode->mNumMeshes = pScene->mNumMeshes;
	pScene->mRootNode->mMeshes = new unsigned int[pScene->mNumMeshes];

	for (unsigned int i = 0; i < pScene->mNumMeshes; ++i) {
		pScene->mRootNode->mMeshes[i] = i;
	}
}

// the below code fragment can be found in:
// code/AssetLib/AC/ACLoader.cpp
void AC3DImporter::InternReadFile(const std::string &pFile,
        aiScene *pScene, IOSystem *pIOHandler) {
    std::unique_ptr<IOStream> file(pIOHandler->Open(pFile, "rb"));

    // Check whether we can read from the file
    if (file == nullptr) {
        throw DeadlyImportError("Failed to open AC3D file ", pFile, ".");
    }

    // allocate storage and copy the contents of the file to a memory buffer
    std::vector<char> mBuffer2;
    TextFileToBuffer(file.get(), mBuffer2);

    buffer = &mBuffer2[0];
    mNumMeshes = 0;

    mLightsCounter = mPolysCounter = mWorldsCounter = mGroupsCounter = 0;

    if (::strncmp(buffer, "AC3D", 4)) {
        throw DeadlyImportError("AC3D: No valid AC3D file, magic sequence not found");
    }

    // print the file format version to the console
    unsigned int version = HexDigitToDecimal(buffer[4]);
    char msg[3];
    ASSIMP_itoa10(msg, 3, version);
    ASSIMP_LOG_INFO("AC3D file format version: ", msg);

    std::vector<Material> materials;
    materials.reserve(5);

    std::vector<Object> rootObjects;
    rootObjects.reserve(5);

    std::vector<aiLight *> lights;
    mLights = &lights;

    while (GetNextLine()) {
        if (TokenMatch(buffer, "MATERIAL", 8)) {
            materials.emplace_back();
            Material &mat = materials.back();

            // manually parse the material ... sscanf would use the buldin atof ...
            // Format: (name) rgb %f %f %f  amb %f %f %f  emis %f %f %f  spec %f %f %f  shi %d  trans %f

            buffer = AcSkipToNextToken(buffer);
            if ('\"' == *buffer) {
                buffer = AcGetString(buffer, mat.name);
                buffer = AcSkipToNextToken(buffer);
            }

            buffer = TAcCheckedLoadFloatArray(buffer, "rgb", 3, 3, &mat.rgb);
            buffer = TAcCheckedLoadFloatArray(buffer, "amb", 3, 3, &mat.amb);
            buffer = TAcCheckedLoadFloatArray(buffer, "emis", 4, 3, &mat.emis);
            buffer = TAcCheckedLoadFloatArray(buffer, "spec", 4, 3, &mat.spec);
            buffer = TAcCheckedLoadFloatArray(buffer, "shi", 3, 1, &mat.shin);
            buffer = TAcCheckedLoadFloatArray(buffer, "trans", 5, 1, &mat.trans);
        }
        LoadObjectSection(rootObjects);
    }

    if (rootObjects.empty() || !mNumMeshes) {
        throw DeadlyImportError("AC3D: No meshes have been loaded");
    }
    if (materials.empty()) {
        ASSIMP_LOG_WARN("AC3D: No material has been found");
        materials.emplace_back();
    }

    mNumMeshes += (mNumMeshes >> 2u) + 1;
    std::vector<aiMesh *> meshes;
    meshes.reserve(mNumMeshes);

    std::vector<aiMaterial *> omaterials;
    materials.reserve(mNumMeshes);

    // generate a dummy root if there are multiple objects on the top layer
    Object *root;
    if (1 == rootObjects.size())
        root = &rootObjects[0];
    else {
        root = new Object();
    }

    // now convert the imported stuff to our output data structure
    pScene->mRootNode = ConvertObjectSection(*root, meshes, omaterials, materials);
    if (1 != rootObjects.size()) {
        delete root;
    }

    if (!::strncmp(pScene->mRootNode->mName.data, "Node", 4)) {
        pScene->mRootNode->mName.Set("<AC3DWorld>");
    }

    // copy meshes
    if (meshes.empty()) {
        throw DeadlyImportError("An unknown error occurred during converting");
    }
    pScene->mNumMeshes = (unsigned int)meshes.size();
    pScene->mMeshes = new aiMesh *[pScene->mNumMeshes];
    ::memcpy(pScene->mMeshes, &meshes[0], pScene->mNumMeshes * sizeof(void *));

    // copy materials
    pScene->mNumMaterials = (unsigned int)omaterials.size();
    pScene->mMaterials = new aiMaterial *[pScene->mNumMaterials];
    ::memcpy(pScene->mMaterials, &omaterials[0], pScene->mNumMaterials * sizeof(void *));

    // copy lights
    pScene->mNumLights = (unsigned int)lights.size();
    if (lights.size()) {
        pScene->mLights = new aiLight *[lights.size()];
        ::memcpy(pScene->mLights, &lights[0], lights.size() * sizeof(void *));
    }
}

// the below code fragment can be found in:
// code/AssetLib/NDO/NDOLoader.cpp
void NDOImporter::InternReadFile( const std::string& pFile,
    aiScene* pScene, IOSystem* pIOHandler)
{

    auto file = pIOHandler->Open( pFile, "rb");
    if (!file) {
        throw DeadlyImportError("Nendo: Could not open ", pFile);
    }

    StreamReaderBE reader(file);

    // first 9 bytes are nendo file format ("nendo 1.n")
    const char* head = (const char*)reader.GetPtr();
    reader.IncPtr(9);

    if (strncmp("nendo ",head,6)) {
        throw DeadlyImportError("Not a Nendo file; magic signature missing");
    }
    // check if this is a supported version. if not, continue, too -- users,
    // please don't complain if it doesn't work then ...
    unsigned int file_format = 12;
    if (!strncmp("1.0",head+6,3)) {
        file_format = 10;
        ASSIMP_LOG_INFO("NDO file format is 1.0");
    }
    else if (!strncmp("1.1",head+6,3)) {
        file_format = 11;
        ASSIMP_LOG_INFO("NDO file format is 1.1");
    }
    else if (!strncmp("1.2",head+6,3)) {
        file_format = 12;
        ASSIMP_LOG_INFO("NDO file format is 1.2");
    }
    else {
        char buff[4] = {0};
        memcpy(buff, head+6, 3);
        ASSIMP_LOG_WARN( "Unrecognized nendo file format version, continuing happily ... :", buff);
    }

    reader.IncPtr(2); /* skip flags */
    if (file_format >= 12) {
        reader.IncPtr(2);
    }
    unsigned int temp = reader.GetU1();

    std::vector<Object> objects(temp); /* buffer to store all the loaded objects in */

    // read all objects
    for (unsigned int o = 0; o < objects.size(); ++o) {

//      if (file_format < 12) {
            if (!reader.GetI1()) {
                continue; /* skip over empty object */
            }
        //  reader.GetI2();
//      }
        Object& obj = objects[o];

        temp = file_format >= 12 ? reader.GetU4() : reader.GetU2();
        head = (const char*)reader.GetPtr();
        reader.IncPtr(temp + 76); /* skip unknown stuff */

        obj.name = std::string(head, temp);

        // read edge table
        temp = file_format >= 12 ? reader.GetU4() : reader.GetU2();
        obj.edges.reserve(temp);
        for (unsigned int e = 0; e < temp; ++e) {

            obj.edges.emplace_back();
            Edge& edge = obj.edges.back();

            for (unsigned int i = 0; i< 8; ++i) {
                edge.edge[i] = file_format >= 12 ? reader.GetU4() : reader.GetU2();
            }
            edge.hard =  file_format >= 11 ? reader.GetU1() : 0;
            for (unsigned int i = 0; i< 8; ++i) {
                edge.color[i] = reader.GetU1();
            }
        }

        // read face table
        temp = file_format >= 12 ? reader.GetU4() : reader.GetU2();
        obj.faces.reserve(temp);
        for (unsigned int e = 0; e < temp; ++e) {

            obj.faces.emplace_back();
            Face& face = obj.faces.back();

            face.elem = file_format >= 12 ? reader.GetU4() : reader.GetU2();
        }

        // read vertex table
        temp = file_format >= 12 ? reader.GetU4() : reader.GetU2();
        obj.vertices.reserve(temp);
        for (unsigned int e = 0; e < temp; ++e) {

            obj.vertices.emplace_back();
            Vertex& v = obj.vertices.back();

            v.num = file_format >= 12 ? reader.GetU4() : reader.GetU2();
            v.val.x = reader.GetF4();
            v.val.y = reader.GetF4();
            v.val.z = reader.GetF4();
        }

        // read UVs
        temp = file_format >= 12 ? reader.GetU4() : reader.GetU2();
        for (unsigned int e = 0; e < temp; ++e) {
             file_format >= 12 ? reader.GetU4() : reader.GetU2();
        }

        temp = file_format >= 12 ? reader.GetU4() : reader.GetU2();
        for (unsigned int e = 0; e < temp; ++e) {
             file_format >= 12 ? reader.GetU4() : reader.GetU2();
        }

        if (reader.GetU1()) {
            const unsigned int x = reader.GetU2(), y = reader.GetU2();
            temp = 0;
            while (temp < x*y)  {
                unsigned int repeat = reader.GetU1();
                reader.GetU1();
                reader.GetU1();
                reader.GetU1();
                temp += repeat;
            }
        }
    }

    // construct a dummy node graph and add all named objects as child nodes
    aiNode* root = pScene->mRootNode = new aiNode("$NDODummyRoot");
    aiNode** cc = root->mChildren = new aiNode* [ root->mNumChildren = static_cast<unsigned int>( objects.size()) ] ();
    pScene->mMeshes = new aiMesh* [ root->mNumChildren] ();

    std::vector<aiVector3D> vertices;
    std::vector<unsigned int> indices;

    for(const Object& obj : objects) {
        aiNode* nd = *cc++ = new aiNode(obj.name);
        nd->mParent = root;

        // translated from a python dict() - a vector might be sufficient as well
        typedef std::map<unsigned int, unsigned int>  FaceTable;
        FaceTable face_table;

        unsigned int n = 0;
        for(const Edge& edge : obj.edges) {

            face_table[edge.edge[2]] = n;
            face_table[edge.edge[3]] = n;

            ++n;
        }

        aiMesh* mesh = new aiMesh();
        mesh->mNumFaces=static_cast<unsigned int>(face_table.size());
        aiFace* faces = mesh->mFaces = new aiFace[mesh->mNumFaces];

        vertices.clear();
        vertices.reserve(4 * face_table.size()); // arbitrarily chosen
        for(FaceTable::value_type& v : face_table) {
            indices.clear();

            aiFace& f = *faces++;

            const unsigned int key = v.first;
            unsigned int cur_edge = v.second;
            while (true) {
                unsigned int next_edge, next_vert;
                if (key == obj.edges[cur_edge].edge[3]) {
                    next_edge = obj.edges[cur_edge].edge[5];
                    next_vert = obj.edges[cur_edge].edge[1];
                }
                else {
                    next_edge = obj.edges[cur_edge].edge[4];
                    next_vert = obj.edges[cur_edge].edge[0];
                }
                indices.push_back( static_cast<unsigned int>(vertices.size()) );
                vertices.push_back(obj.vertices[ next_vert ].val);

                cur_edge = next_edge;
                if (cur_edge == v.second) {
                    break;
                }
            }

            f.mIndices = new unsigned int[f.mNumIndices = static_cast<unsigned int>(indices.size())];
            std::copy(indices.begin(),indices.end(),f.mIndices);
        }

        mesh->mVertices = new aiVector3D[mesh->mNumVertices = static_cast<unsigned int>(vertices.size())];
        std::copy(vertices.begin(),vertices.end(),mesh->mVertices);

        if (mesh->mNumVertices) {
            pScene->mMeshes[pScene->mNumMeshes] = mesh;

            (nd->mMeshes = new unsigned int[nd->mNumMeshes=1])[0]=pScene->mNumMeshes++;
        }else
            delete mesh;
    }
}

// the below code fragment can be found in:
// code/AssetLib/Q3D/Q3DLoader.cpp
void Q3DImporter::InternReadFile(const std::string &pFile,
        aiScene *pScene, IOSystem *pIOHandler) {

    auto file = pIOHandler->Open(pFile, "rb");
    if (!file)
        throw DeadlyImportError("Quick3D: Could not open ", pFile);

    StreamReaderLE stream(file);

    // The header is 22 bytes large
    if (stream.GetRemainingSize() < 22)
        throw DeadlyImportError("File is either empty or corrupt: ", pFile);

    // Check the file's signature
    if (ASSIMP_strincmp((const char *)stream.GetPtr(), "quick3Do", 8) &&
            ASSIMP_strincmp((const char *)stream.GetPtr(), "quick3Ds", 8)) {
        throw DeadlyImportError("Not a Quick3D file. Signature string is: ", ai_str_toprintable((const char *)stream.GetPtr(), 8));
    }

    // Print the file format version
    ASSIMP_LOG_INFO("Quick3D File format version: ",
            std::string(&((const char *)stream.GetPtr())[8], 2));

    // ... an store it
    char major = ((const char *)stream.GetPtr())[8];
    char minor = ((const char *)stream.GetPtr())[9];

    stream.IncPtr(10);
    unsigned int numMeshes = (unsigned int)stream.GetI4();
    unsigned int numMats = (unsigned int)stream.GetI4();
    unsigned int numTextures = (unsigned int)stream.GetI4();

    std::vector<Material> materials;
    try {
        materials.reserve(numMats);
    } catch(const std::bad_alloc&) {
        ASSIMP_LOG_ERROR("Invalid alloc for materials.");
        throw DeadlyImportError("Invalid Quick3D-file, material allocation failed.");
    }

    std::vector<Mesh> meshes;
    try {
        meshes.reserve(numMeshes);
    } catch(const std::bad_alloc&) {
        ASSIMP_LOG_ERROR("Invalid alloc for meshes.");
        throw DeadlyImportError("Invalid Quick3D-file, mesh allocation failed.");
    }

    // Allocate the scene root node
    pScene->mRootNode = new aiNode();

    aiColor3D fgColor(0.6f, 0.6f, 0.6f);

    // Now read all file chunks
    while (true) {
        if (stream.GetRemainingSize() < 1) break;
        char c = stream.GetI1();
        switch (c) {
            // Meshes chunk
        case 'm': {
            for (unsigned int quak = 0; quak < numMeshes; ++quak) {
                meshes.emplace_back();
                Mesh &mesh = meshes.back();

                // read all vertices
                unsigned int numVerts = (unsigned int)stream.GetI4();
                if (!numVerts)
                    throw DeadlyImportError("Quick3D: Found mesh with zero vertices");

                std::vector<aiVector3D> &verts = mesh.verts;
                verts.resize(numVerts);

                for (unsigned int i = 0; i < numVerts; ++i) {
                    verts[i].x = stream.GetF4();
                    verts[i].y = stream.GetF4();
                    verts[i].z = stream.GetF4();
                }

                // read all faces
                numVerts = (unsigned int)stream.GetI4();
                if (!numVerts)
                    throw DeadlyImportError("Quick3D: Found mesh with zero faces");

                std::vector<Face> &faces = mesh.faces;
                faces.reserve(numVerts);

                // number of indices
                for (unsigned int i = 0; i < numVerts; ++i) {
                    faces.emplace_back(stream.GetI2());
                    if (faces.back().indices.empty())
                        throw DeadlyImportError("Quick3D: Found face with zero indices");
                }

                // indices
                for (unsigned int i = 0; i < numVerts; ++i) {
                    Face &vec = faces[i];
                    for (unsigned int a = 0; a < (unsigned int)vec.indices.size(); ++a)
                        vec.indices[a] = stream.GetI4();
                }

                // material indices
                for (unsigned int i = 0; i < numVerts; ++i) {
                    faces[i].mat = (unsigned int)stream.GetI4();
                }

                // read all normals
                numVerts = (unsigned int)stream.GetI4();
                std::vector<aiVector3D> &normals = mesh.normals;
                normals.resize(numVerts);

                for (unsigned int i = 0; i < numVerts; ++i) {
                    normals[i].x = stream.GetF4();
                    normals[i].y = stream.GetF4();
                    normals[i].z = stream.GetF4();
                }

                numVerts = (unsigned int)stream.GetI4();
                if (numTextures && numVerts) {
                    // read all texture coordinates
                    std::vector<aiVector3D> &uv = mesh.uv;
                    uv.resize(numVerts);

                    for (unsigned int i = 0; i < numVerts; ++i) {
                        uv[i].x = stream.GetF4();
                        uv[i].y = stream.GetF4();
                    }

                    // UV indices
                    for (unsigned int i = 0; i < (unsigned int)faces.size(); ++i) {
                        Face &vec = faces[i];
                        for (unsigned int a = 0; a < (unsigned int)vec.indices.size(); ++a) {
                            vec.uvindices[a] = stream.GetI4();
                            if (!i && !a)
                                mesh.prevUVIdx = vec.uvindices[a];
                            else if (vec.uvindices[a] != mesh.prevUVIdx)
                                mesh.prevUVIdx = UINT_MAX;
                        }
                    }
                }

                // we don't need the rest, but we need to get to the next chunk
                stream.IncPtr(36);
                if (minor > '0' && major == '3')
                    stream.IncPtr(mesh.faces.size());
            }
            // stream.IncPtr(4); // unknown value here
        } break;

            // materials chunk
        case 'c':

            for (unsigned int i = 0; i < numMats; ++i) {
                materials.emplace_back();
                Material &mat = materials.back();

                // read the material name
                c = stream.GetI1();
                while (c) {
                    mat.name.data[mat.name.length++] = c;
                    c = stream.GetI1();
                }

                // add the terminal character
                mat.name.data[mat.name.length] = '\0';

                // read the ambient color
                mat.ambient.r = stream.GetF4();
                mat.ambient.g = stream.GetF4();
                mat.ambient.b = stream.GetF4();

                // read the diffuse color
                mat.diffuse.r = stream.GetF4();
                mat.diffuse.g = stream.GetF4();
                mat.diffuse.b = stream.GetF4();

                // read the ambient color
                mat.specular.r = stream.GetF4();
                mat.specular.g = stream.GetF4();
                mat.specular.b = stream.GetF4();

                // read the transparency
                mat.transparency = stream.GetF4();

                // unknown value here
                // stream.IncPtr(4);
                // FIX: it could be the texture index ...
                mat.texIdx = (unsigned int)stream.GetI4();
            }

            break;

            // texture chunk
        case 't':

            pScene->mNumTextures = numTextures;
            if (!numTextures) {
                break;
            }
            pScene->mTextures = new aiTexture *[pScene->mNumTextures];
            // to make sure we won't crash if we leave through an exception
            ::memset(pScene->mTextures, 0, sizeof(void *) * pScene->mNumTextures);
            for (unsigned int i = 0; i < pScene->mNumTextures; ++i) {
                aiTexture *tex = pScene->mTextures[i] = new aiTexture;

                // skip the texture name
                while (stream.GetI1())
                    ;

                // read texture width and height
                tex->mWidth = (unsigned int)stream.GetI4();
                tex->mHeight = (unsigned int)stream.GetI4();

                if (!tex->mWidth || !tex->mHeight) {
                    throw DeadlyImportError("Quick3D: Invalid texture. Width or height is zero");
                }

                unsigned int mul = tex->mWidth * tex->mHeight;
                aiTexel *begin = tex->pcData = new aiTexel[mul];
                aiTexel *const end = &begin[mul - 1] + 1;

                for (; begin != end; ++begin) {
                    begin->r = stream.GetI1();
                    begin->g = stream.GetI1();
                    begin->b = stream.GetI1();
                    begin->a = 0xff;
                }
            }

            break;

            // scene chunk
        case 's': {
            // skip position and rotation
            stream.IncPtr(12);

            for (unsigned int i = 0; i < 4; ++i)
                for (unsigned int a = 0; a < 4; ++a)
                    pScene->mRootNode->mTransformation[i][a] = stream.GetF4();

            stream.IncPtr(16);

            // now setup a single camera
            pScene->mNumCameras = 1;
            pScene->mCameras = new aiCamera *[1];
            aiCamera *cam = pScene->mCameras[0] = new aiCamera();
            cam->mPosition.x = stream.GetF4();
            cam->mPosition.y = stream.GetF4();
            cam->mPosition.z = stream.GetF4();
            cam->mName.Set("Q3DCamera");

            // skip eye rotation for the moment
            stream.IncPtr(12);

            // read the default material color
            fgColor.r = stream.GetF4();
            fgColor.g = stream.GetF4();
            fgColor.b = stream.GetF4();

            // skip some unimportant properties
            stream.IncPtr(29);

            // setup a single point light with no attenuation
            pScene->mNumLights = 1;
            pScene->mLights = new aiLight *[1];
            aiLight *light = pScene->mLights[0] = new aiLight();
            light->mName.Set("Q3DLight");
            light->mType = aiLightSource_POINT;

            light->mAttenuationConstant = 1;
            light->mAttenuationLinear = 0;
            light->mAttenuationQuadratic = 0;

            light->mColorDiffuse.r = stream.GetF4();
            light->mColorDiffuse.g = stream.GetF4();
            light->mColorDiffuse.b = stream.GetF4();

            light->mColorSpecular = light->mColorDiffuse;

            // We don't need the rest, but we need to know where this chunk ends.
            unsigned int temp = (unsigned int)(stream.GetI4() * stream.GetI4());

            // skip the background file name
            while (stream.GetI1())
                ;

            // skip background texture data + the remaining fields
            stream.IncPtr(temp * 3 + 20); // 4 bytes of unknown data here

            // TODO
            goto outer;
        }

        default:
            throw DeadlyImportError("Quick3D: Unknown chunk");
        };
    }
outer:

    // If we have no mesh loaded - break here
    if (meshes.empty())
        throw DeadlyImportError("Quick3D: No meshes loaded");

    // If we have no materials loaded - generate a default mat
    if (materials.empty()) {
        ASSIMP_LOG_INFO("Quick3D: No material found, generating one");
        materials.emplace_back();
        materials.back().diffuse = fgColor;
    }

    // find out which materials we'll need
    typedef std::pair<unsigned int, unsigned int> FaceIdx;
    typedef std::vector<FaceIdx> FaceIdxArray;
    FaceIdxArray *fidx = new FaceIdxArray[materials.size()];

    unsigned int p = 0;
    for (std::vector<Mesh>::iterator it = meshes.begin(), end = meshes.end();
            it != end; ++it, ++p) {
        unsigned int q = 0;
        for (std::vector<Face>::iterator fit = (*it).faces.begin(), fend = (*it).faces.end();
                fit != fend; ++fit, ++q) {
            if ((*fit).mat >= materials.size()) {
                ASSIMP_LOG_WARN("Quick3D: Material index overflow");
                (*fit).mat = 0;
            }
            if (fidx[(*fit).mat].empty()) ++pScene->mNumMeshes;
            fidx[(*fit).mat].emplace_back(p, q);
        }
    }
    pScene->mNumMaterials = pScene->mNumMeshes;
    pScene->mMaterials = new aiMaterial *[pScene->mNumMaterials];
    pScene->mMeshes = new aiMesh *[pScene->mNumMaterials];

    for (unsigned int i = 0, real = 0; i < (unsigned int)materials.size(); ++i) {
        if (fidx[i].empty()) continue;

        // Allocate a mesh and a material
        aiMesh *mesh = pScene->mMeshes[real] = new aiMesh();
        aiMaterial *mat = new aiMaterial();
        pScene->mMaterials[real] = mat;

        mesh->mMaterialIndex = real;

        // Build the output material
        Material &srcMat = materials[i];
        mat->AddProperty(&srcMat.diffuse, 1, AI_MATKEY_COLOR_DIFFUSE);
        mat->AddProperty(&srcMat.specular, 1, AI_MATKEY_COLOR_SPECULAR);
        mat->AddProperty(&srcMat.ambient, 1, AI_MATKEY_COLOR_AMBIENT);

        // NOTE: Ignore transparency for the moment - it seems
        // unclear how to interpret the data
#if 0
        if (!(minor > '0' && major == '3'))
            srcMat.transparency = 1.0f - srcMat.transparency;
        mat->AddProperty(&srcMat.transparency, 1, AI_MATKEY_OPACITY);
#endif

        // add shininess - Quick3D seems to use it ins its viewer
        srcMat.transparency = 16.f;
        mat->AddProperty(&srcMat.transparency, 1, AI_MATKEY_SHININESS);

        int m = (int)aiShadingMode_Phong;
        mat->AddProperty(&m, 1, AI_MATKEY_SHADING_MODEL);

        if (srcMat.name.length)
            mat->AddProperty(&srcMat.name, AI_MATKEY_NAME);

        // Add a texture
        if (srcMat.texIdx < pScene->mNumTextures || real < pScene->mNumTextures) {
            srcMat.name.data[0] = '*';
            srcMat.name.length = ASSIMP_itoa10(&srcMat.name.data[1], 1000,
                    (srcMat.texIdx < pScene->mNumTextures ? srcMat.texIdx : real));
            mat->AddProperty(&srcMat.name, AI_MATKEY_TEXTURE_DIFFUSE(0));
        }

        mesh->mNumFaces = (unsigned int)fidx[i].size();
        aiFace *faces = mesh->mFaces = new aiFace[mesh->mNumFaces];

        // Now build the output mesh. First find out how many
        // vertices we'll need
        for (FaceIdxArray::const_iterator it = fidx[i].begin(), end = fidx[i].end();
                it != end; ++it) {
            mesh->mNumVertices += (unsigned int)meshes[(*it).first].faces[(*it).second].indices.size();
        }

        aiVector3D *verts = mesh->mVertices = new aiVector3D[mesh->mNumVertices];
        aiVector3D *norms = mesh->mNormals = new aiVector3D[mesh->mNumVertices];
        aiVector3D *uv = nullptr;
        if (real < pScene->mNumTextures) {
            uv = mesh->mTextureCoords[0] = new aiVector3D[mesh->mNumVertices];
            mesh->mNumUVComponents[0] = 2;
        }

        // Build the final array
        unsigned int cnt = 0;
        for (FaceIdxArray::const_iterator it = fidx[i].begin(), end = fidx[i].end();
                it != end; ++it, ++faces) {
            Mesh &curMesh = meshes[(*it).first];
            Face &face = curMesh.faces[(*it).second];
            faces->mNumIndices = (unsigned int)face.indices.size();
            faces->mIndices = new unsigned int[faces->mNumIndices];

            aiVector3D faceNormal;
            bool fnOK = false;

            for (unsigned int n = 0; n < faces->mNumIndices; ++n, ++cnt, ++norms, ++verts) {
                if (face.indices[n] >= curMesh.verts.size()) {
                    ASSIMP_LOG_WARN("Quick3D: Vertex index overflow");
                    face.indices[n] = 0;
                }

                // copy vertices
                *verts = curMesh.verts[face.indices[n]];

                if (face.indices[n] >= curMesh.normals.size() && faces->mNumIndices >= 3) {
                    // we have no normal here - assign the face normal
                    if (!fnOK) {
                        const aiVector3D &pV1 = curMesh.verts[face.indices[0]];
                        const aiVector3D &pV2 = curMesh.verts[face.indices[1]];
                        const aiVector3D &pV3 = curMesh.verts[face.indices.size() - 1];
                        faceNormal = (pV2 - pV1) ^ (pV3 - pV1).Normalize();
                        fnOK = true;
                    }
                    *norms = faceNormal;
                } else {
                    *norms = curMesh.normals[face.indices[n]];
                }

                // copy texture coordinates
                if (uv && curMesh.uv.size()) {
                    if (curMesh.prevUVIdx != 0xffffffff && curMesh.uv.size() >= curMesh.verts.size()) // workaround
                    {
                        *uv = curMesh.uv[face.indices[n]];
                    } else {
                        if (face.uvindices[n] >= curMesh.uv.size()) {
                            ASSIMP_LOG_WARN("Quick3D: Texture coordinate index overflow");
                            face.uvindices[n] = 0;
                        }
                        *uv = curMesh.uv[face.uvindices[n]];
                    }
                    uv->y = 1.f - uv->y;
                    ++uv;
                }

                // setup the new vertex index
                faces->mIndices[n] = cnt;
            }
        }
        ++real;
    }

    // Delete our nice helper array
    delete[] fidx;

    // Now we need to attach the meshes to the root node of the scene
    pScene->mRootNode->mNumMeshes = pScene->mNumMeshes;
    pScene->mRootNode->mMeshes = new unsigned int[pScene->mNumMeshes];
    for (unsigned int i = 0; i < pScene->mNumMeshes; ++i)
        pScene->mRootNode->mMeshes[i] = i;

    /*pScene->mRootNode->mTransformation *= aiMatrix4x4(
        1.f, 0.f, 0.f, 0.f,
        0.f, -1.f,0.f, 0.f,
        0.f, 0.f, 1.f, 0.f,
        0.f, 0.f, 0.f, 1.f);*/

    // Add cameras and light sources to the scene root node
    pScene->mRootNode->mNumChildren = pScene->mNumLights + pScene->mNumCameras;
    if (pScene->mRootNode->mNumChildren) {
        pScene->mRootNode->mChildren = new aiNode *[pScene->mRootNode->mNumChildren];

        // the light source
        aiNode *nd = pScene->mRootNode->mChildren[0] = new aiNode();
        nd->mParent = pScene->mRootNode;
        nd->mName.Set("Q3DLight");
        nd->mTransformation = pScene->mRootNode->mTransformation;
        nd->mTransformation.Inverse();

        // camera
        nd = pScene->mRootNode->mChildren[1] = new aiNode();
        nd->mParent = pScene->mRootNode;
        nd->mName.Set("Q3DCamera");
        nd->mTransformation = pScene->mRootNode->mChildren[0]->mTransformation;
    }
}

