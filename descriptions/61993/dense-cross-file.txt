// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// ext/standard/file.c
PHP_FUNCTION(fgetcsv)
{
	char delimiter = ',';	/* allow this to be set as parameter */
	char enclosure = '"';	/* allow this to be set as parameter */
	int escape = (unsigned char) '\\';

	zend_long len = 0;
	size_t buf_len;
	char *buf;
	php_stream *stream;

	{
		zval *fd;
		bool len_is_null = 1;
		char *delimiter_str = NULL;
		size_t delimiter_str_len = 0;
		char *enclosure_str = NULL;
		size_t enclosure_str_len = 0;
		char *escape_str = NULL;
		size_t escape_str_len = 0;

		ZEND_PARSE_PARAMETERS_START(1, 5)
			Z_PARAM_RESOURCE(fd)
			Z_PARAM_OPTIONAL
			Z_PARAM_LONG_OR_NULL(len, len_is_null)
			Z_PARAM_STRING(delimiter_str, delimiter_str_len)
			Z_PARAM_STRING(enclosure_str, enclosure_str_len)
			Z_PARAM_STRING(escape_str, escape_str_len)
		ZEND_PARSE_PARAMETERS_END();

		if (delimiter_str != NULL) {
			/* Make sure that there is at least one character in string */
			if (delimiter_str_len != 1) {
				zend_argument_value_error(3, "must be a single character");
				RETURN_THROWS();
			}

			/* use first character from string */
			delimiter = delimiter_str[0];
		}

		if (enclosure_str != NULL) {
			if (enclosure_str_len != 1) {
				zend_argument_value_error(4, "must be a single character");
				RETURN_THROWS();
			}

			/* use first character from string */
			enclosure = enclosure_str[0];
		}

		if (escape_str != NULL) {
			if (escape_str_len > 1) {
				zend_argument_value_error(5, "must be empty or a single character");
				RETURN_THROWS();
			}

			if (escape_str_len < 1) {
				escape = PHP_CSV_NO_ESCAPE;
			} else {
				escape = (unsigned char) escape_str[0];
			}
		}

		if (len_is_null || len == 0) {
			len = -1;
		} else if (len < 0) {
			zend_argument_value_error(2, "must be a greater than or equal to 0");
			RETURN_THROWS();
		}

		PHP_STREAM_FROM_ZVAL(stream, fd);
	}

	if (len < 0) {
		if ((buf = php_stream_get_line(stream, NULL, 0, &buf_len)) == NULL) {
			RETURN_FALSE;
		}
	} else {
		buf = emalloc(len + 1);
		if (php_stream_get_line(stream, buf, len + 1, &buf_len) == NULL) {
			efree(buf);
			RETURN_FALSE;
		}
	}

	HashTable *values = php_fgetcsv(stream, delimiter, enclosure, escape, buf_len, buf);
	if (values == NULL) {
		values = php_bc_fgetcsv_empty_line();
	}
	RETURN_ARR(values);
}

// the below code fragment can be found in:
// ext/standard/string.c
PHP_FUNCTION(str_getcsv)
{
	zend_string *str;
	char delim = ',', enc = '"';
	int esc = (unsigned char) '\\';
	char *delim_str = NULL, *enc_str = NULL, *esc_str = NULL;
	size_t delim_len = 0, enc_len = 0, esc_len = 0;

	ZEND_PARSE_PARAMETERS_START(1, 4)
		Z_PARAM_STR(str)
		Z_PARAM_OPTIONAL
		Z_PARAM_STRING(delim_str, delim_len)
		Z_PARAM_STRING(enc_str, enc_len)
		Z_PARAM_STRING(esc_str, esc_len)
	ZEND_PARSE_PARAMETERS_END();

	delim = delim_len ? delim_str[0] : delim;
	enc = enc_len ? enc_str[0] : enc;
	if (esc_str != NULL) {
		esc = esc_len ? (unsigned char) esc_str[0] : PHP_CSV_NO_ESCAPE;
	}

	HashTable *values = php_fgetcsv(NULL, delim, enc, esc, ZSTR_LEN(str), ZSTR_VAL(str));
	if (values == NULL) {
		values = php_bc_fgetcsv_empty_line();
	}
	RETURN_ARR(values);
}

// the below code fragment can be found in:
// ext/standard/file.c
PHPAPI ssize_t php_fputcsv(php_stream *stream, zval *fields, char delimiter, char enclosure, int escape_char, zend_string *eol_str)
{
	uint32_t count, i = 0;
	size_t ret;
	zval *field_tmp;
	smart_str csvline = {0};

	ZEND_ASSERT((escape_char >= 0 && escape_char <= UCHAR_MAX) || escape_char == PHP_CSV_NO_ESCAPE);
	count = zend_hash_num_elements(Z_ARRVAL_P(fields));
	ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(fields), field_tmp) {
		zend_string *tmp_field_str;
		zend_string *field_str = zval_get_tmp_string(field_tmp, &tmp_field_str);

		/* enclose a field that contains a delimiter, an enclosure character, or a newline */
		if (FPUTCSV_FLD_CHK(delimiter) ||
			FPUTCSV_FLD_CHK(enclosure) ||
			(escape_char != PHP_CSV_NO_ESCAPE && FPUTCSV_FLD_CHK(escape_char)) ||
			FPUTCSV_FLD_CHK('\n') ||
			FPUTCSV_FLD_CHK('\r') ||
			FPUTCSV_FLD_CHK('\t') ||
			FPUTCSV_FLD_CHK(' ')
		) {
			char *ch = ZSTR_VAL(field_str);
			char *end = ch + ZSTR_LEN(field_str);
			int escaped = 0;

			smart_str_appendc(&csvline, enclosure);
			while (ch < end) {
				if (escape_char != PHP_CSV_NO_ESCAPE && *ch == escape_char) {
					escaped = 1;
				} else if (!escaped && *ch == enclosure) {
					smart_str_appendc(&csvline, enclosure);
				} else {
					escaped = 0;
				}
				smart_str_appendc(&csvline, *ch);
				ch++;
			}
			smart_str_appendc(&csvline, enclosure);
		} else {
			smart_str_append(&csvline, field_str);
		}

		if (++i != count) {
			smart_str_appendl(&csvline, &delimiter, 1);
		}
		zend_tmp_string_release(tmp_field_str);
	} ZEND_HASH_FOREACH_END();

	if (eol_str) {
		smart_str_append(&csvline, eol_str);
	} else {
		smart_str_appendc(&csvline, '\n');
	}
	smart_str_0(&csvline);

	ret = php_stream_write(stream, ZSTR_VAL(csvline.s), ZSTR_LEN(csvline.s));

	smart_str_free(&csvline);

	return ret;
}

// the below code fragment can be found in:
// ext/standard/file.c
PHP_FUNCTION(fputcsv)
{
	char delimiter = ',';					/* allow this to be set as parameter */
	char enclosure = '"';					/* allow this to be set as parameter */
	int escape_char = (unsigned char) '\\';	/* allow this to be set as parameter */
	php_stream *stream;
	zval *fp = NULL, *fields = NULL;
	ssize_t ret;
	char *delimiter_str = NULL, *enclosure_str = NULL, *escape_str = NULL;
	size_t delimiter_str_len = 0, enclosure_str_len = 0, escape_str_len = 0;
	zend_string *eol_str = NULL;

	ZEND_PARSE_PARAMETERS_START(2, 6)
		Z_PARAM_RESOURCE(fp)
		Z_PARAM_ARRAY(fields)
		Z_PARAM_OPTIONAL
		Z_PARAM_STRING(delimiter_str, delimiter_str_len)
		Z_PARAM_STRING(enclosure_str, enclosure_str_len)
		Z_PARAM_STRING(escape_str, escape_str_len)
		Z_PARAM_STR_OR_NULL(eol_str)
	ZEND_PARSE_PARAMETERS_END();

	if (delimiter_str != NULL) {
		/* Make sure that there is at least one character in string */
		if (delimiter_str_len != 1) {
			zend_argument_value_error(3, "must be a single character");
			RETURN_THROWS();
		}

		/* use first character from string */
		delimiter = *delimiter_str;
	}

// the below code fragment can be found in:
// ext/standard/file.c
PHPAPI HashTable *php_bc_fgetcsv_empty_line(void)
{
	HashTable *values = zend_new_array(1);
	zval tmp;
	ZVAL_NULL(&tmp);
	zend_hash_next_index_insert(values, &tmp);
	return values;
}

