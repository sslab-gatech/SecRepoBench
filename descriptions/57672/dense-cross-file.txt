// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/class.c
MRB_API mrb_bool
mrb_block_given_p(mrb_state *mrb)
{
  mrb_callinfo *ci = mrb->c->ci;
  mrb_value b = ci->stack[mrb_ci_bidx(ci)];

  return !mrb_nil_p(b);
}

// the below code fragment can be found in:
// src/gc.c
MRB_API mrb_bool
mrb_object_dead_p(mrb_state *mrb, struct RBasic *object)
{
  mrb_gc *gc = &mrb->gc;
  if (!heap_p(gc, object)) return TRUE;
  return is_dead(gc, object);
}

// the below code fragment can be found in:
// mrbgems/mruby-binding/src/binding.c
mrb_bool
mrb_binding_p(mrb_state *mrb, mrb_value obj)
{
  if (!mrb_obj_is_kind_of(mrb, obj, mrb_class_get_id(mrb, MRB_SYM(Binding)))) return FALSE;
  if (mrb_type(obj) != MRB_TT_OBJECT) return FALSE;
  if (!mrb_obj_iv_defined(mrb, mrb_obj_ptr(obj), MRB_SYM(proc))) return FALSE;
  if (!mrb_obj_iv_defined(mrb, mrb_obj_ptr(obj), MRB_SYM(recv))) return FALSE;
  if (!mrb_obj_iv_defined(mrb, mrb_obj_ptr(obj), MRB_SYM(env))) return FALSE;
  return TRUE;
}

// the below code fragment can be found in:
// src/kernel.c
static mrb_value
mrb_f_block_given_p_m(mrb_state *mrb, mrb_value self)
{
  mrb_callinfo *ci = &mrb->c->ci[-1];
  mrb_callinfo *cibase = mrb->c->cibase;
  mrb_value *bp;
  int bidx;
  struct REnv *e = NULL;
  const struct RProc *p;

  if (ci <= cibase) {
    /* toplevel does not have block */
    return mrb_false_value();
  }
  p = ci->proc;
  /* search method/class/module proc */
  while (p) {
    if (MRB_PROC_SCOPE_P(p)) break;
    e = MRB_PROC_ENV(p);
    p = p->upper;
  }
  if (p == NULL) return mrb_false_value();
  if (e) {
    bidx = env_bidx(e);
    if (bidx < 0) return mrb_false_value();
    bp = &e->stack[bidx];
    goto block_given;
  }
  /* search ci corresponding to proc */
  while (cibase < ci) {
    if (ci->proc == p) break;
    ci--;
  }
  if (ci == cibase) {
    /* proc is closure */
    if (!MRB_PROC_ENV_P(p)) return mrb_false_value();
    e = MRB_PROC_ENV(p);
    bidx = env_bidx(e);
    if (bidx < 0) return mrb_false_value();
    bp = &e->stack[bidx];
  }
  else if ((e = mrb_vm_ci_env(ci)) != NULL) {
    /* top-level does not have block slot (always false) */
    if (e->stack == mrb->c->stbase) return mrb_false_value();
    bidx = env_bidx(e);
    /* bidx may be useless (e.g. define_method) */
    if (bidx < 0) return mrb_false_value();
    bp = &e->stack[bidx];
  }
  else {
    uint8_t n = ci->n == 15 ? 1 : ci->n;
    uint8_t k = ci->nk == 15 ? 1 : ci->nk*2;
    bidx = n + k + 1;      /* self + args + kargs => bidx */
    bp = &ci->stack[bidx];
  }
 block_given:
  if (mrb_nil_p(*bp))
    return mrb_false_value();
  return mrb_true_value();
}

// the below code fragment can be found in:
// src/class.c
MRB_API mrb_bool
mrb_obj_respond_to(mrb_state *mrb, struct RClass* c, mrb_sym mid)
{
  mrb_method_t m;

  m = mrb_method_search_vm(mrb, &c, mid);
  if (MRB_METHOD_UNDEF_P(m)) {
    return FALSE;
  }
  return TRUE;
}

