/*
** vm.c - virtual machine for mruby
**
** See Copyright Notice in mruby.h
*/

#include <mruby.h>
#include <mruby/array.h>
#include <mruby/class.h>
#include <mruby/hash.h>
#include <mruby/irep.h>
#include <mruby/numeric.h>
#include <mruby/proc.h>
#include <mruby/range.h>
#include <mruby/string.h>
#include <mruby/variable.h>
#include <mruby/error.h>
#include <mruby/opcode.h>
#include "value_array.h"
#include <mruby/throw.h>
#include <mruby/dump.h>
#include <mruby/internal.h>
#include <mruby/presym.h>

#ifdef MRB_NO_STDIO
#if defined(__cplusplus)
extern "C" {
#endif
void abort(void);
#if defined(__cplusplus)
}  /* extern "C" */
#endif
#endif

#define STACK_INIT_SIZE 128
#define CALLINFO_INIT_SIZE 32

/* Define amount of linear stack growth. */
#ifndef MRB_STACK_GROWTH
#define MRB_STACK_GROWTH 128
#endif

/* Maximum recursive depth. Should be set lower on memory constrained systems. */
#ifndef MRB_CALL_LEVEL_MAX
#define MRB_CALL_LEVEL_MAX 512
#endif

/* Maximum stack depth. Should be set lower on memory

// --- CODE TRUNCATED HERE ---

mrb_bool
mrb_env_unshare(mrb_state *mrb_state, struct REnv *e, mrb_bool noraise)
{
  if (e == NULL) return TRUE;
  if (!MRB_ENV_ONSTACK_P(e)) return TRUE;
  if (e->cxt != mrb_state->c) return TRUE;
  if (e == CI_ENV(mrb_state->c->cibase)) return TRUE; /* for mirb */

  size_t len = (size_t)MRB_ENV_LEN(e);
  if (len == 0) {
    e->stack = NULL;
    MRB_ENV_CLOSE(e);
    return TRUE;
  }

  size_t live = mrb_state->gc.live;
  mrb_value *p = (mrb_value*)mrb_malloc_simple(mrb_state, sizeof(mrb_value)*len);
  if (live != mrb_state->gc.live && mrb_object_dead_p(mrb_state, (struct RBasic*)e)) {
    // The e object is now subject to GC inside mrb_malloc_simple().
    // Moreover, if NULL is returned due to mrb_malloc_simple() failure, simply ignore it.
    mrb_free(mrb_state, p);
    return TRUE;
  }
  else if (p) 
  // This section handles the case where an environment is on the stack and needs to be "unshared."
  // It allocates memory for a new stack with the given length and copies the existing stack contents to it.
  // The new stack is then assigned to the environment, and the environment is marked as closed.
  // The function returns `TRUE` to indicate the stack has been successfully unshared.
  // <MASK>
}