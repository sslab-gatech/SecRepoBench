// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/proc.c
// RProc*
// mrb_closure_new_cfunc(mrb_state *mrb, mrb_func_t func, int nlocals)
// {
//   return mrb_proc_new_cfunc_with_env(mrb, func, nlocals, NULL);
// }

// the below code fragment can be found in:
// mrbgems/mruby-binding/src/binding.c
// static size_t
// binding_proc_upper_count(const struct RProc *proc)
// {
//   size_t count = 0;
//   for (; proc && !MRB_PROC_CFUNC_P(proc); proc = proc->upper) {
//     count++;
//     if (MRB_PROC_SCOPE_P(proc)) break;
//   }
//   return count;
// }

// the below code fragment can be found in:
// src/proc.c
// void
// mrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b)
// {
//   if (a->body.irep) {
//     /* already initialized proc */
//     return;
//   }
//   if (!MRB_PROC_CFUNC_P(b) && b->body.irep) {
//     mrb_irep_incref(mrb, (mrb_irep*)b->body.irep);
//   }
//   a->flags = b->flags;
//   a->body = b->body;
//   a->upper = b->upper;
//   a->e.env = b->e.env;
//   /* a->e.target_class = a->e.target_class; */
// }

// the below code fragment can be found in:
// src/vm.c
// static void
// stack_extend_alloc(mrb_state *mrb, mrb_int room)
// {
//   mrb_value *oldbase = mrb->c->stbase;
//   mrb_value *newstack;
//   size_t oldsize = mrb->c->stend - mrb->c->stbase;
//   size_t size = oldsize;
//   size_t off = mrb->c->ci->stack ? mrb->c->stend - mrb->c->ci->stack : 0;
// 
//   if (off > size) size = off;
// #ifdef MRB_STACK_EXTEND_DOUBLING
//   if ((size_t)room <= size)
//     size *= 2;
//   else
//     size += room;
// #else
//   /* Use linear stack growth.
//      It is slightly slower than doubling the stack space,
//      but it saves memory on small devices. */
//   if (room <= MRB_STACK_GROWTH)
//     size += MRB_STACK_GROWTH;
//   else
//     size += room;
// #endif
// 
//   newstack = (mrb_value*)mrb_realloc(mrb, mrb->c->stbase, sizeof(mrb_value) * size);
//   stack_clear(&(newstack[oldsize]), size - oldsize);
//   envadjust(mrb, oldbase, newstack, oldsize);
//   mrb->c->stbase = newstack;
//   mrb->c->stend = mrb->c->stbase + size;
// 
//   /* Raise an exception if the new stack size will be too large,
//      to prevent infinite recursion. However, do this only after resizing the stack, so mrb_raise has stack space to work with. */
//   if (size > MRB_STACK_MAX) {
//     mrb_exc_raise(mrb, mrb_obj_value(mrb->stack_err));
//   }
// }

// the below code fragment can be found in:
// src/kernel.c
// static mrb_value
// mrb_obj_class_m(mrb_state *mrb, mrb_value self)
// {
//   return mrb_obj_value(mrb_obj_class(mrb, self));
// }

