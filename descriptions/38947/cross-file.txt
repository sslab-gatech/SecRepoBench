// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// code/AssetLib/LWS/LWSLoader.cpp
void LWSImporter::SetupNodeName(aiNode *nd, LWS::NodeDesc &src) {
    const unsigned int combined = src.number | ((unsigned int)src.type) << 28u;

    // the name depends on the type. We break LWS's strange naming convention
    // and return human-readable, but still machine-parsable and unique, strings.
    if (src.type == LWS::NodeDesc::OBJECT) {

        if (src.path.length()) {
            std::string::size_type s = src.path.find_last_of("\\/");
            if (s == std::string::npos) {
                s = 0;
            } else {
                ++s;
            }
            std::string::size_type t = src.path.substr(s).find_last_of('.');

            nd->mName.length = ::ai_snprintf(nd->mName.data, MAXLEN, "%s_(%08X)", src.path.substr(s).substr(0, t).c_str(), combined);
            return;
        }
    }
    nd->mName.length = ::ai_snprintf(nd->mName.data, MAXLEN, "%s_(%08X)", src.name, combined);
}

// the below code fragment can be found in:
// code/AssetLib/LWS/LWSLoader.h
namespace LWS {

// ---------------------------------------------------------------------------
/** Represents an element in a LWS file.
 *
 *  This can either be a single data line - <name> <value> or a data
 *  group - { name <data_line0> ... n }
 */
class Element {
public:
    Element() {}

    // first: name, second: rest
    std::string tokens[2];
    std::list<Element> children;

    //! Recursive parsing function
    void Parse(const char *&buffer);
};

#define AI_LWS_MASK (0xffffffff >> 4u)

// ---------------------------------------------------------------------------
/** Represents a LWS scenegraph element
 */
struct NodeDesc {
    NodeDesc() :
            type(),
            id(),
            number(0),
            parent(0),
            name(),
            isPivotSet(false),
            lightColor(1.f, 1.f, 1.f),
            lightIntensity(1.f),
            lightType(0),
            lightFalloffType(0),
            lightConeAngle(45.f),
            lightEdgeAngle(),
            parent_resolved(nullptr) {}

    enum {

        OBJECT = 1,
        LIGHT = 2,
        CAMERA = 3,
        BONE = 4
    } type; // type of node

    // if object: path
    std::string path;
    unsigned int id;

    // number of object
    unsigned int number;

    // index of parent index
    unsigned int parent;

    // lights & cameras & dummies: name
    const char *name;

    // animation channels
    std::list<LWO::Envelope> channels;

    // position of pivot point
    aiVector3D pivotPos;
    bool isPivotSet;

    // color of light source
    aiColor3D lightColor;

    // intensity of light source
    float lightIntensity;

    // type of light source
    unsigned int lightType;

    // falloff type of light source
    unsigned int lightFalloffType;

    // cone angle of (spot) light source
    float lightConeAngle;

    // soft cone angle of (spot) light source
    float lightEdgeAngle;

    // list of resolved children
    std::list<NodeDesc *> children;

    // resolved parent node
    NodeDesc *parent_resolved;

    // for std::find()
    bool operator==(unsigned int num) const {
        if (!num)
            return false;
        unsigned int _type = num >> 28u;

        return _type == static_cast<unsigned int>(type) && (num & AI_LWS_MASK) == number;
    }
};

} // end namespace LWS

// ---------------------------------------------------------------------------
/** LWS (LightWave Scene Format) importer class.
 *
 *  This class does heavily depend on the LWO importer class. LWS files
 *  contain mainly descriptions how LWO objects are composed together
 *  in a scene.
*/
class LWSImporter : public BaseImporter {
public:
    LWSImporter();
    ~LWSImporter() override;

    // -------------------------------------------------------------------
    // Check whether we can read a specific file
    bool CanRead(const std::string &pFile, IOSystem *pIOHandler,
            bool checkSig) const override;

protected:
    // -------------------------------------------------------------------
    // Get list of supported extensions
    const aiImporterDesc *GetInfo() const override;

    // -------------------------------------------------------------------
    // Import file into given scene data structure
    void InternReadFile(const std::string &pFile, aiScene *pScene,
            IOSystem *pIOHandler) override;

    // -------------------------------------------------------------------
    // Setup import properties
    void SetupProperties(const Importer *pImp) override;

private:
    // -------------------------------------------------------------------
    // Read an envelope description
    void ReadEnvelope(const LWS::Element &dad, LWO::Envelope &out);

    // -------------------------------------------------------------------
    // Read an envelope description for the older LW file format
    void ReadEnvelope_Old(std::list<LWS::Element>::const_iterator &it,
            const std::list<LWS::Element>::const_iterator &end,
            LWS::NodeDesc &nodes,
            unsigned int version);

    // -------------------------------------------------------------------
    // Setup a nice name for a node
    void SetupNodeName(aiNode *nd, LWS::NodeDesc &src);

    // -------------------------------------------------------------------
    // Recursively build the scenegraph
    void BuildGraph(aiNode *nd,
            LWS::NodeDesc &src,
            std::vector<AttachmentInfo> &attach,
            BatchLoader &batch,
            aiCamera **&camOut,
            aiLight **&lightOut,
            std::vector<aiNodeAnim *> &animOut);

    // -------------------------------------------------------------------
    // Try several dirs until we find the right location of a LWS file.
    std::string FindLWOFile(const std::string &in);

private:
    bool configSpeedFlag;
    IOSystem *io;
    double first, last, fps;
    bool noSkeletonMesh;
};

}

// the below code fragment can be found in:
// code/AssetLib/LWS/LWSLoader.cpp
void LWSImporter::ReadEnvelope_Old(
        std::list<LWS::Element>::const_iterator &it,
        const std::list<LWS::Element>::const_iterator &end,
        LWS::NodeDesc &nodes,
        unsigned int /*version*/) {
    unsigned int num, sub_num;
    if (++it == end) goto unexpected_end;

    num = strtoul10((*it).tokens[0].c_str());
    for (unsigned int i = 0; i < num; ++i) {

        nodes.channels.push_back(LWO::Envelope());
        LWO::Envelope &envl = nodes.channels.back();

        envl.index = i;
        envl.type = (LWO::EnvelopeType)(i + 1);

        if (++it == end) {
            goto unexpected_end;
        }
        sub_num = strtoul10((*it).tokens[0].c_str());

        for (unsigned int n = 0; n < sub_num; ++n) {

            if (++it == end) goto unexpected_end;

            // parse value and time, skip the rest for the moment.
            LWO::Key key;
            const char *c = fast_atoreal_move<float>((*it).tokens[0].c_str(), key.value);
            SkipSpaces(&c);
            float f;
            fast_atoreal_move<float>((*it).tokens[0].c_str(), f);
            key.time = f;

            envl.keys.push_back(key);
        }
    }
    return;

unexpected_end:
    ASSIMP_LOG_ERROR("LWS: Encountered unexpected end of file while parsing object motion");
}

// the below code fragment can be found in:
// code/AssetLib/LWS/LWSLoader.cpp
std::string LWSImporter::FindLWOFile(const std::string &in) {
    // insert missing directory separator if necessary
    std::string tmp(in);
    if (in.length() > 3 && in[1] == ':' && in[2] != '\\' && in[2] != '/') {
        tmp = in[0] + (std::string(":\\") + in.substr(2));
    }

    if (io->Exists(tmp)) {
        return in;
    }

    // file is not accessible for us ... maybe it's packed by
    // LightWave's 'Package Scene' command?

    // Relevant for us are the following two directories:
    // <folder>\Objects\<hh>\<*>.lwo
    // <folder>\Scenes\<hh>\<*>.lws
    // where <hh> is optional.

    std::string test = std::string("..") + (io->getOsSeparator() + tmp);
    if (io->Exists(test)) {
        return test;
    }

    test = std::string("..") + (io->getOsSeparator() + test);
    if (io->Exists(test)) {
        return test;
    }

    // return original path, maybe the IOsystem knows better
    return tmp;
}

// the below code fragment can be found in:
// code/AssetLib/LWS/LWSLoader.cpp
LWSImporter::LWSImporter() :
        configSpeedFlag(),
        io(),
        first(),
        last(),
        fps(),
        noSkeletonMesh() {
    // nothing to do here
}

