// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/lib/protocols/mail_pop.c
void ndpi_search_mail_pop_tcp(struct ndpi_detection_module_struct
			      *ndpi_struct, struct ndpi_flow_struct *flow)
{
  struct ndpi_packet_struct *packet = &flow->packet;
  u_int8_t a = 0;
  u_int8_t bit_count = 0;

  NDPI_LOG_DBG(ndpi_struct, "search mail_pop\n");

  if((packet->payload_packet_len > 3
       && (packet->payload[0] == '+' && (packet->payload[1] == 'O' || packet->payload[1] == 'o')
	   && (packet->payload[2] == 'K' || packet->payload[2] == 'k')))
      || (packet->payload_packet_len > 4
	  && (packet->payload[0] == '-' && (packet->payload[1] == 'E' || packet->payload[1] == 'e')
	      && (packet->payload[2] == 'R' || packet->payload[2] == 'r')
	      && (packet->payload[3] == 'R' || packet->payload[3] == 'r')))) {
    // +OK or -ERR seen
    flow->l4.tcp.mail_pop_stage += 1;
  } else if(!ndpi_int_mail_pop_check_for_client_commands(ndpi_struct, flow)) {
    goto maybe_split_pop;
  }

  if(packet->payload_packet_len > 2 && ntohs(get_u_int16_t(packet->payload, packet->payload_packet_len - 2)) == 0x0d0a) {
    // count the bits set in the bitmask
    if(flow->l4.tcp.pop_command_bitmask != 0) {
      for (a = 0; a < 16; a++) {
	bit_count += (flow->l4.tcp.pop_command_bitmask >> a) & 0x01;
      }
    }

    NDPI_LOG_DBG2(ndpi_struct,
		  "mail_pop +OK/-ERR responses: %u, unique commands: %u\n",
		  flow->l4.tcp.mail_pop_stage, bit_count);

    if((bit_count + flow->l4.tcp.mail_pop_stage) >= 3) {
      if(flow->l4.tcp.mail_pop_stage > 0) {
	NDPI_LOG_INFO(ndpi_struct, "mail_pop identified\n");
	
	if((flow->protos.ftp_imap_pop_smtp.password[0] != '\0')
	   || (flow->l4.tcp.mail_pop_stage > 3)) {
	  ndpi_int_mail_pop_add_connection(ndpi_struct, flow);
	  popInitExtraPacketProcessing(flow);
	}
      }
      
      return;      
    } else
      return;    
  } else {
    // first part of a split packet
    NDPI_LOG_DBG2(ndpi_struct,
		  "mail_pop command without line ending -> skip\n");
    return;
  }


 maybe_split_pop:

  if(((packet->payload_packet_len > 2 && ntohs(get_u_int16_t(packet->payload, packet->payload_packet_len - 2)) == 0x0d0a)
       || flow->l4.tcp.pop_command_bitmask != 0 || flow->l4.tcp.mail_pop_stage != 0) && flow->packet_counter < 12) {
    // maybe part of a split pop packet
    NDPI_LOG_DBG2(ndpi_struct,
		  "maybe part of split mail_pop packet -> skip\n");
    return;
  }

  NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
}

// the below code fragment can be found in:
// src/lib/protocols/mail_pop.c
int ndpi_extra_search_mail_pop_tcp(struct ndpi_detection_module_struct *ndpi_struct,
				    struct ndpi_flow_struct *flow) {
  int rc;
  
  ndpi_search_mail_pop_tcp(ndpi_struct, flow);

  rc = (flow->protos.ftp_imap_pop_smtp.password[0] == '\0') ? 1 : 0;
  
#ifdef POP_DEBUG
  printf("**** %s() [rc: %d]\n", __FUNCTION__, rc);
#endif  

  return(rc);
}

// the below code fragment can be found in:
// src/lib/protocols/tls.c
static int processTLSBlock(struct ndpi_detection_module_struct *ndpi_struct,
			   struct ndpi_flow_struct *flow) {
  struct ndpi_packet_struct *packet = &flow->packet;

  switch(packet->payload[0] /* block type */) {
  case 0x01: /* Client Hello */
  case 0x02: /* Server Hello */
    processClientServerHello(ndpi_struct, flow);
    flow->l4.tcp.tls.hello_processed = 1;
    ndpi_int_tls_add_connection(ndpi_struct, flow, NDPI_PROTOCOL_TLS);
    break;

  case 0x0b: /* Certificate */
    /* Important: populate the tls union fields only after
     * ndpi_int_tls_add_connection has been called */
    if(flow->l4.tcp.tls.hello_processed) {
      processCertificate(ndpi_struct, flow);
      flow->l4.tcp.tls.certificate_processed = 1;
    }
    break;

  default:
    return(-1);
  }

  return(0);
}

// the below code fragment can be found in:
// src/lib/protocols/postgres.c
void init_postgres_dissector(struct ndpi_detection_module_struct *ndpi_struct, u_int32_t *id, NDPI_PROTOCOL_BITMASK *detection_bitmask)
{
  ndpi_set_bitmask_protocol_detection("PostgreSQL", ndpi_struct, detection_bitmask, *id,
				      NDPI_PROTOCOL_POSTGRES,
				      ndpi_search_postgres_tcp,
				      NDPI_SELECTION_BITMASK_PROTOCOL_V4_V6_TCP_WITH_PAYLOAD_WITHOUT_RETRANSMISSION,
				      SAVE_DETECTION_BITMASK_AS_UNKNOWN,
				      ADD_TO_DETECTION_BITMASK);

  *id += 1;
}

// the below code fragment can be found in:
// src/lib/protocols/fiesta.c
void init_fiesta_dissector(struct ndpi_detection_module_struct *ndpi_struct, u_int32_t *id, NDPI_PROTOCOL_BITMASK *detection_bitmask)
{
  ndpi_set_bitmask_protocol_detection("Fiesta", ndpi_struct, detection_bitmask, *id,
				      NDPI_PROTOCOL_FIESTA,
				      ndpi_search_fiesta,
				      NDPI_SELECTION_BITMASK_PROTOCOL_V4_V6_TCP_WITH_PAYLOAD_WITHOUT_RETRANSMISSION,
				      SAVE_DETECTION_BITMASK_AS_UNKNOWN,
				      ADD_TO_DETECTION_BITMASK);

  *id += 1;
}

