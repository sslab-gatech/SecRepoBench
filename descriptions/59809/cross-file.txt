// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// Packet++/header/TLVData.h
TLVRecordType getTLVRecord(uint32_t recordType, uint8_t* tlvDataBasePtr, size_t tlvDataLen) const
		{
			TLVRecordType curRec = getFirstTLVRecord(tlvDataBasePtr, tlvDataLen);
			while (!curRec.isNull())
			{
				if (curRec.getType() == recordType)
				{
					return curRec;
				}

				curRec = getNextTLVRecord(curRec, tlvDataBasePtr, tlvDataLen);
			}

			curRec.assign(NULL);
			return curRec; // for NRVO optimization
		}

// the below code fragment can be found in:
// Packet++/header/TLVData.h
size_t getTLVRecordCount(uint8_t* tlvDataBasePtr, size_t tlvDataLen) const
		{
			if (m_RecordCount != (size_t)-1)
				return m_RecordCount;

			m_RecordCount = 0;
			TLVRecordType curRec = getFirstTLVRecord(tlvDataBasePtr, tlvDataLen);
			while (!curRec.isNull())
			{
				m_RecordCount++;
				curRec = getNextTLVRecord(curRec, tlvDataBasePtr, tlvDataLen);
			}

			return m_RecordCount;
		}

// the below code fragment can be found in:
// Packet++/header/TLVData.h
void changeTLVRecordCount(int changedBy) { if (m_RecordCount != (size_t)-1) m_RecordCount += changedBy; }

// the below code fragment can be found in:
// Packet++/header/TLVData.h
{
	private:
		mutable size_t m_RecordCount;

	public:

		/**
		 * A default c'tor for this class
		 */
		TLVRecordReader() { m_RecordCount = (size_t)-1; }

		/**
		 * A default copy c'tor for this class
		 */
		TLVRecordReader(const TLVRecordReader& other)
		{
			m_RecordCount = other.m_RecordCount;
		}

// the below code fragment can be found in:
// Packet++/header/IPv6Extensions.h
class IPv6RoutingHeader : public IPv6Extension
	{
		friend class IPv6Layer;

	public:

		/**
		 * @struct ipv6_routing_header
		 * A struct representing the fixed part of the IPv6 routing extension header
		 */
		struct ipv6_routing_header
		{
			/** Next header type */
			uint8_t nextHeader;
			/** The length of this header, in multiples of 8 octets, not including the first 8 octets */
			uint8_t headerLen;
			/** A value representing the routing type */
			uint8_t routingType;
			/** Number of nodes this packet still has to visit before reaching its final destination */
			uint8_t segmentsLeft;
		};

		/**
		 * A c'tor for creating a new IPv6 routing extension object not bounded to a packet. Useful for adding new extensions to an
		 * IPv6 layer with IPv6Layer#addExtension()
		 * @param[in] routingType Routing type value (will be written to ipv6_routing_header#routingType field)
		 * @param[in] segmentsLeft Segments left value (will be written to ipv6_routing_header#segmentsLeft field)
		 * @param[in] additionalRoutingData A pointer to a buffer containing the additional routing data for this extension. Notice this
		 * buffer is read-only and its content isn't modified
		 * @param[in] additionalRoutingDataLen The length of the additional routing data buffer
		 */
		IPv6RoutingHeader(uint8_t routingType, uint8_t segmentsLeft, const uint8_t* additionalRoutingData, size_t additionalRoutingDataLen);

		/**
		 * Get a pointer to the fixed part of the routing header. Notice the return pointer points directly to the data, so every change will modify
		 * the actual packet data
		 * @return A pointer to the @ref ipv6_routing_header
		 */
		ipv6_routing_header* getRoutingHeader() const { return (ipv6_routing_header*)getDataPtr(); }

		/**
		 * @return A pointer to the buffer containing the additional routing data for this extension. Notice that any change in this buffer
		 * will lead to a change in the extension data
		 */
		uint8_t* getRoutingAdditionalData() const;

		/**
		 * @return The length of the additional routing parameters buffer
		 */
		size_t getRoutingAdditionalDataLength() const;

		/**
		 * In many cases the additional routing data is actually IPv6 address(es). This method converts the raw buffer data into an IPv6 address
		 * @param[in] offset An offset in the additional routing buffer pointing to where the IPv6 address begins. In some cases there are
		 * multiple IPv6 addresses in the additional routing data buffer so this offset points to where the request IPv6 address begins. Also,
		 * even if there is only one IPv6 address in this buffer, sometimes it isn't written in the beginning of the buffer, so the offset points
		 * to where the IPv6 address begins. This is an optional parameter and the default offset is 0
		 * @return The IPv6 address stored in the additional routing data buffer from the offset defined by the user. If offset is out-of-bounds
		 * of the extension of doesn't have 16 bytes (== the length of IPv6 address) until the end of the buffer - IPv6Address#Zero is returned
		 */
		IPv6Address getRoutingAdditionalDataAsIPv6Address(size_t offset = 0) const;

	private:

		IPv6RoutingHeader(IDataContainer* dataContainer, size_t offset) : IPv6Extension(dataContainer, offset) { m_ExtType = IPv6Routing; }

	}

