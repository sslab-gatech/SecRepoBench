// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/filter_core/filter.c
GF_EXPORT
const char *gf_filter_probe_data(GF_Filter *filter, u8 *data, u32 size, GF_FilterProbeScore *pscore)
{
	u32 i, count;
	GF_FilterProbeScore score, max_score = GF_FPROBE_NOT_SUPPORTED;
	const char *probe_mime = NULL;
	if (pscore) *pscore = GF_FPROBE_NOT_SUPPORTED;
	if (!size) return NULL;
	gf_mx_p(filter->session->filters_mx);
	count = gf_list_count(filter->session->registry);
	for (i=0; i<count; i++) {
		const char *a_mime;
		const GF_FilterRegister *freg = gf_list_get(filter->session->registry, i);
		if (!freg || !freg->probe_data) continue;
		score = GF_FPROBE_NOT_SUPPORTED;
		a_mime = freg->probe_data(data, size, &score);
		if (score==GF_FPROBE_NOT_SUPPORTED) {
		} else if (score==GF_FPROBE_EXT_MATCH) {
//			probe_mime = NULL;
		} else {
			if (a_mime && (score > max_score)) {
				probe_mime = a_mime;
				max_score = score;
			}
		}
	}
	gf_mx_v(filter->session->filters_mx);
	if (pscore) *pscore = max_score;
	return probe_mime;
}

// the below code fragment can be found in:
// src/filter_core/filter.c
static Bool gf_filter_get_arg_internal(GF_Filter *filter, const char *arg_name, GF_PropertyValue *prop, const char **min_max_enum)
{
	u32 i=0;
	if (!filter || !arg_name) return GF_FALSE;

	while (1) {
		GF_PropertyValue p;
		const GF_FilterArgs *arg = &filter->freg->args[i];
		if (!arg || !arg->arg_name) break;
		i++;

		if (strcmp(arg->arg_name, arg_name)) continue;
		if (arg->offset_in_private < 0) continue;

		p.type = arg->arg_type;
		switch (arg->arg_type) {
		case GF_PROP_BOOL:
			p.value.boolean = * (Bool *) ((char *)filter->filter_udta + arg->offset_in_private);
			break;
		case GF_PROP_UINT:
		case GF_PROP_4CC:
			p.value.uint = * (u32 *) ((char *)filter->filter_udta + arg->offset_in_private);
			break;
		case GF_PROP_SINT:
			p.value.sint = * (s32 *) ((char *)filter->filter_udta + arg->offset_in_private);
			break;
		case GF_PROP_LUINT:
			p.value.longuint = * (u64 *) ((char *)filter->filter_udta + arg->offset_in_private);
			break;
		case GF_PROP_LSINT:
			p.value.longsint = * (s64 *) ((char *)filter->filter_udta + arg->offset_in_private);
			break;
		case GF_PROP_FLOAT:
			p.value.fnumber = * (Fixed *) ((char *)filter->filter_udta + arg->offset_in_private);
			break;
		case GF_PROP_DOUBLE:
			p.value.number = * (Double *) ((char *)filter->filter_udta + arg->offset_in_private);
			break;
		case GF_PROP_VEC2I:
			p.value.vec2i = * (GF_PropVec2i *) ((char *)filter->filter_udta + arg->offset_in_private);
			break;
		case GF_PROP_VEC2:
			p.value.vec2 = * (GF_PropVec2 *) ((char *)filter->filter_udta + arg->offset_in_private);
			break;
		case GF_PROP_VEC3I:
			p.value.vec3i = * (GF_PropVec3i *) ((char *)filter->filter_udta + arg->offset_in_private);
			break;
		case GF_PROP_VEC4I:
			p.value.vec4i = * (GF_PropVec4i *) ((char *)filter->filter_udta + arg->offset_in_private);
			break;
		case GF_PROP_FRACTION:
			p.value.frac = * (GF_Fraction *) ((char *)filter->filter_udta + arg->offset_in_private);
			break;
		case GF_PROP_FRACTION64:
			p.value.lfrac = * (GF_Fraction64 *) ((char *)filter->filter_udta + arg->offset_in_private);
			break;
		case GF_PROP_DATA:
		case GF_PROP_DATA_NO_COPY:
		case GF_PROP_CONST_DATA:
			p.value.data = * (GF_PropData *) ((char *)filter->filter_udta + arg->offset_in_private);
			break;
		case GF_PROP_POINTER:
			p.value.ptr = * (void **) ((char *)filter->filter_udta + arg->offset_in_private);
			break;
		case GF_PROP_STRING_NO_COPY:
		case GF_PROP_STRING:
		case GF_PROP_NAME:
			p.value.ptr = * (char **) ((char *)filter->filter_udta + arg->offset_in_private);
			break;
		//use uint_list as base type for lists
		case GF_PROP_STRING_LIST:
		case GF_PROP_UINT_LIST:
		case GF_PROP_4CC_LIST:
		case GF_PROP_SINT_LIST:
		case GF_PROP_VEC2I_LIST:
			p.value.uint_list = * (GF_PropUIntList *) ((char *)filter->filter_udta + arg->offset_in_private);
			break;
		default:
			if (gf_props_type_is_enum(arg->arg_type)) {
				p.value.uint = * (u32 *) ((char *)filter->filter_udta + arg->offset_in_private);
				break;
			}
			return GF_FALSE;
		}
		if (min_max_enum) *min_max_enum = arg->min_max_enum;
		*prop = p;
		return GF_TRUE;
	}
	return GF_FALSE;
}

// the below code fragment can be found in:
// src/filters/reframe_rawpcm.c
static const char *pcmreframe_probe_data(const u8 *data, u32 size, GF_FilterProbeScore *score)
{
	if (size<20) return NULL;

	GF_BitStream *bs = gf_bs_new(data, size, GF_BITSTREAM_READ);
	u32 code = gf_bs_read_u32(bs);
	if (code == GF_4CC('R', 'I', 'F', 'F')) {
		gf_bs_read_u32(bs);
		code = gf_bs_read_u32(bs);
		if (code == GF_4CC('W', 'A', 'V', 'E')) {
			*score = GF_FPROBE_SUPPORTED;
			gf_bs_del(bs);
			return "audio/wav";
		}
	}
	gf_bs_del(bs);
	*score = GF_FPROBE_EXT_MATCH;
	return gf_audio_fmt_all_shortnames();
}

// the below code fragment can be found in:
// src/filters/reframe_rawpcm.c
const GF_FilterRegister *rfpcm_register(GF_FilterSession *session)
{
	PCMReframeArgs[1].min_max_enum = gf_audio_fmt_all_names();
	PCMReframeCaps[1].val.value.string = (char *) gf_audio_fmt_all_shortnames();
	return &PCMReframeRegister;
}

// the below code fragment can be found in:
// src/filters/load_text.c
const GF_FilterRegister *txtin_register(GF_FilterSession *session)
{
	return &TXTInRegister;
}

