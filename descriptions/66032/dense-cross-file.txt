// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/filters/load_text.c
static const char *txtin_probe_data(const u8 *data, u32 data_size, GF_FilterProbeScore *score)
{
	char *dst = NULL;
	char *res=NULL;
	GF_Err e = gf_utf_get_string_from_bom((char *)data, data_size, &dst, &res, NULL);
	if (e) return NULL;

	data = res;
	//strip all spaces and \r\n\t
	while (data[0] && strchr("\n\r\t ", (char) data[0]))
		data ++;

#define PROBE_OK(_score, _mime) \
		*score = _score;\
		if (dst) gf_free(dst);\
		return _mime; \


	if (!strncmp(data, "WEBVTT", 6)) {
		PROBE_OK(GF_FPROBE_SUPPORTED, "subtitle/vtt")
	}
	if (strstr(data, " --> ")) {
		PROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, "subtitle/srt")
	}
	if (!strncmp(data, "FWS", 3) || !strncmp(data, "CWS", 3)) {
		PROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, "application/x-shockwave-flash")
	}
	if (!strncmp(data, "[Script Info", 12)) {
		PROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, "subtitle/ssa")
	}

	if ((data[0]=='{') && strstr(data, "}{")) {
		PROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, "subtitle/sub")

	}
	/*XML formats*/
	if (!strstr(data, "?>") ) {
		if (dst) gf_free(dst);
		return NULL;
	}

	if (strstr(data, "<x-quicktime-tx3g") || strstr(data, "<text3GTrack")) {
		PROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, "quicktime/text")
	}
	if (strstr(data, "TextStream")) {
		PROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, "subtitle/ttxt")
	}
	if (strstr(data, "<tt ") || strstr(data, ":tt ")) {
		PROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, "subtitle/ttml")
	}

	if (dst) gf_free(dst);
	return NULL;
}

// the below code fragment can be found in:
// src/filters/filelist.c
static const char *filelist_probe_data(const u8 *data, u32 size, GF_FilterProbeScore *score)
{
	u32 nb_lines = 0;
	if (!gf_utf8_is_legal(data, size)) {
		return NULL;
	}
	//we only deal with no-BOM files
	if ((data[0] == 0xFF) || (data[0] == 0xFE) || (data[0] == 0xEF)) return NULL;

	while (data && size) {
		u32 i, line_size;
		Bool is_cr = GF_FALSE;
		char *nl;
		nl = memchr(data, '\r', size);
		if (!nl)
			nl = memchr(data, '\n', size);
		else
			is_cr = GF_TRUE;

		if (nl)
			line_size = (u32) (nl - (char *) data);
		else
			line_size = size-1;

		//line is comment
		if (data[0] != '#') {
			Bool line_empty = GF_TRUE;
			for (i=0;i<line_size; i++) {
				char c = (char) data[i];
				if (!c) return NULL;
				if ( isalnum(c)) continue;
				//valid URL chars plus backslash for win path
				if (strchr("-._~:/?#[]@!$&'()*+,;%=\\", c)) {
					line_empty = GF_FALSE;
					continue;
				}
				//not a valid URL
				return NULL;
			}
			if (!line_empty)
				nb_lines++;
		}
		if (!nl) break;
		size -= (u32) (nl+1 - (char *) data);
		data = nl+1;
		if (is_cr && (data[0]=='\n')) {
			size --;
			data++;
		}
	}
	if (!nb_lines) return NULL;
	*score = GF_FPROBE_MAYBE_SUPPORTED;
	return "application/x-gpac-playlist";
}

// the below code fragment can be found in:
// src/filters/reframe_mpgvid.c
static const char * mpgvdmx_probe_data(const u8 *data, u32 size, GF_FilterProbeScore *score)
{
	GF_M4VParser *parser;
	u8 ftype;
	u32 tinc, nb_frames, o_start=0;
	u64 fsize, start;
	Bool is_coded;
	GF_Err e;
	GF_M4VDecSpecInfo dsi;

	memset(&dsi, 0, sizeof(GF_M4VDecSpecInfo));
	parser = gf_m4v_parser_new((char*)data, size, GF_FALSE);
	nb_frames = 0;
	while (1) {
		u32 otype;
		ftype = 0;
		is_coded = GF_FALSE;
		e = gf_m4v_parse_frame(parser, &dsi, &ftype, &tinc, &fsize, &start, &is_coded);
		if (!nb_frames && start) o_start = (u32) start;

		otype = gf_m4v_parser_get_obj_type(parser);
		switch (otype) {
		case M4V_VOL_START_CODE:
		case M4V_VOP_START_CODE:
		case M4V_VISOBJ_START_CODE:
		case M4V_VOS_START_CODE:
		case M4V_GOV_START_CODE:
		case M4V_UDTA_START_CODE:
			break;
		default:
			otype = 0;
		}

		//if start is more than 4 (start-code size), we have garbage at the beginning, do not parse
		//except if we have a valid object VOS
		if (!nb_frames && (start>4) && !otype) {
			break;
		}
		if (is_coded) nb_frames++;
		if (e==GF_EOS) {
			e = GF_OK;
			//special case if the only frame we have is not coded
			if (otype == M4V_VOP_START_CODE) {
				if (!nb_frames) nb_frames++;
				is_coded = 1;
			}

			if (is_coded) nb_frames++;
			break;
		}
		if (ftype>2) break;
		if (e) break;
		nb_frames++;
	}
	gf_m4v_parser_del(parser);
	if ((e==GF_OK) && (nb_frames>1)) {
		*score = o_start ? GF_FPROBE_MAYBE_NOT_SUPPORTED : GF_FPROBE_MAYBE_SUPPORTED;
		return "video/mp4v-es";
	}

	memset(&dsi, 0, sizeof(GF_M4VDecSpecInfo));
	parser = gf_m4v_parser_new((char*)data, size, GF_TRUE);
	nb_frames = 0;
	while (1) {
		ftype = 0;
		is_coded = GF_FALSE;
		e = gf_m4v_parse_frame(parser, &dsi, &ftype, &tinc, &fsize, &start, &is_coded);

		//if start is more than 4 (start-code size), we have garbage at the beginning, do not parse
		if (!nb_frames && (start>4) ) {
			break;
		}
		if (is_coded) nb_frames++;
		if (e==GF_EOS) {
			if (is_coded) nb_frames++;
			e = GF_OK;
			break;
		}
		if (ftype>2) break;
		if (e) break;
		nb_frames++;
	}
	gf_m4v_parser_del(parser);
	if ((e==GF_OK) && (nb_frames>1)) {
		*score = o_start ? GF_FPROBE_MAYBE_NOT_SUPPORTED : GF_FPROBE_MAYBE_SUPPORTED;
		return "video/mpgv-es";
	}
	return NULL;
}

// the below code fragment can be found in:
// src/filters/reframe_mp3.c
static const char *mp3_dmx_probe_data(const u8 *data, u32 size, GF_FilterProbeScore *score)
{
	u32 nb_frames=0;
	u32 pos=0;
	u32 prev_pos=0;
	s32 prev_sr_idx=-1;
	s32 prev_ch=-1;
	s32 prev_layer=-1;
	s32 init_pos = -1;
	Bool has_id3 = GF_FALSE;

	/* Check for ID3 */
	if (size>= 10) {
		if (data[0] == 'I' && data[1] == 'D' && data[2] == '3') {
			u32 tag_size = ((data[9] & 0x7f) + ((data[8] & 0x7f) << 7) + ((data[7] & 0x7f) << 14) + ((data[6] & 0x7f) << 21));

			if (tag_size+10>size) {
				GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, ("ID3 tag detected size %d but probe data only %d bytes, will rely on file extension (try increasing probe size using --block_size)\n", tag_size+10, size));
				*score = GF_FPROBE_EXT_MATCH;
				return "mp3|mp2|mp1";
			}
			data += tag_size+10;
			size -= tag_size+10;
			has_id3 = GF_TRUE;
		}
	}

	while (1) {
		u32 hdr = gf_mp3_get_next_header_mem(data, size, &pos);
		if (!hdr) break;

		if (init_pos<0) init_pos = pos;

		if (gf_mp3_version(hdr) > 3)
			break;
		//check sample rate
		u8 val = (hdr >> 10) & 0x3;
		if (val>2)
			break;
		u32 fsize = gf_mp3_frame_size(hdr);
		if (prev_pos && pos) {
			nb_frames=0;
			break;
		}

		if (prev_sr_idx>=0) {
			if ((u8) prev_sr_idx != val) {
				nb_frames=0;
				break;
			}
		}
		prev_sr_idx = val;

		val = gf_mp3_num_channels(hdr);
		if (prev_ch>=0) {
			if ((u8) prev_ch != val) {
				nb_frames=0;
				break;
			}
		}
		prev_ch = val;

		val = gf_mp3_layer(hdr);
		if (prev_layer>=0) {
			if ((u8) prev_layer != val) {
				nb_frames=0;
				break;
			}
		}
		prev_layer = val;

		if (fsize + pos > size) {
			nb_frames++;
			break;
		}

		prev_pos = pos;
		nb_frames++;
		if (nb_frames>4) break;
		if (size < fsize + pos) break;
		size -= fsize + pos;
		data += fsize + pos;
	}

	if (nb_frames>=2) {
		*score = (init_pos==0) ? GF_FPROBE_SUPPORTED : GF_FPROBE_MAYBE_NOT_SUPPORTED;
		return "audio/mp3";
	}
	if (nb_frames && has_id3) {
		*score = GF_FPROBE_MAYBE_SUPPORTED;
		return "audio/mp3";
	}
	return NULL;
}

// the below code fragment can be found in:
// src/filters/dmx_dash.c
static const char *dashdmx_probe_data(const u8 *data, u32 size, GF_FilterProbeScore *score)
{
	char *d = (char *)data;
	char *res_ghix, *res_dash, *res_m3u, *res_smooth;
	char last_c = d[size-1];
	d[size-1] = 0;
	res_ghix = strstr(data, "<GHIX ");
	res_dash = strstr(data, "<MPD ");
	if (!res_dash) res_dash = strstr(data, "<Period ");
	res_m3u = strstr(data, "#EXTM3U");
	res_smooth = strstr(data, "<SmoothStreamingMedia");
	d[size-1] = last_c;

	if (res_ghix) {
		*score = GF_FPROBE_SUPPORTED;
		return "application/x-gpac-ghix";
	}
	if (res_dash) {
		*score = GF_FPROBE_SUPPORTED;
		return "application/dash+xml";
	}
	if (res_m3u) {
		*score = GF_FPROBE_SUPPORTED;
		//we don't use x-mpegURL to avoid complaints from HLS mediastreamvalidator
		return "application/vnd.apple.mpegURL";
	}
	if (res_smooth) {
		*score = GF_FPROBE_SUPPORTED;
		return "application/vnd.ms-sstr+xml";
	}
	return NULL;
}

