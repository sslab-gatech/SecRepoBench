// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/lib/ndpi_serializer.c
int ndpi_serialize_string_string_len(ndpi_serializer *_serializer,
				     const char *key,
				     const char *value, u_int16_t value_len) {
  ndpi_private_serializer *serializer = (ndpi_private_serializer*)_serializer;

#ifdef OPTIMIZE_CSV_SERIALIZATION
  if(serializer->fmt == ndpi_serialization_format_csv) {
    /* Key is ignored */
    u_int32_t buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;
    u_int16_t needed = value_len + 1 /* CVS separator */;

    if(buff_diff < needed) {
      if(ndpi_extend_serializer_buffer(&serializer->buffer, needed - buff_diff) < 0)
	return(-1);
      else
	buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;
    }

    if(!(serializer->status.flags & NDPI_SERIALIZER_STATUS_HDR_DONE)) {
      if(ndpi_serializer_header_string(serializer, key, strlen(key)) < 0)
	return(-1);
    }

    ndpi_serialize_csv_pre(serializer);
    needed--;
    memcpy(&serializer->buffer.data[serializer->status.buffer.size_used], value, needed);
    serializer->status.buffer.size_used += needed;
    return(0);
  } else
#endif
  return(ndpi_serialize_binary_binary(_serializer, key, strlen(key),
				      value, value_len));
}

// the below code fragment can be found in:
// src/lib/ndpi_serializer.c
int ndpi_serialize_binary_int32(ndpi_serializer *_serializer,
			        const char *key, u_int16_t klen,
			        int32_t value) {
  ndpi_private_serializer *serializer = (ndpi_private_serializer*)_serializer;
  u_int32_t buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;
  u_int32_t needed;
  int rc;

#ifdef OPTIMIZE_NUMERIC_KEYS
  if(ndpi_is_number(key, klen))
    return(ndpi_serialize_uint32_int32(_serializer, atoi(key), value));
#endif

  needed =
    sizeof(u_int8_t) /* type */ +
    sizeof(u_int16_t) /* key len */ +
    klen /* key */ +
    sizeof(u_int32_t);

  if(serializer->fmt == ndpi_serialization_format_json)
    needed += 16 + klen;

  if(buff_diff < needed) {
    if(ndpi_extend_serializer_buffer(&serializer->buffer, needed - buff_diff) < 0)
      return(-1);
    buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;
  }

  if(serializer->fmt == ndpi_serialization_format_json) {
    ndpi_serialize_json_pre(_serializer);
    buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;

    if (!(serializer->status.flags & NDPI_SERIALIZER_STATUS_LIST)) {
      serializer->status.buffer.size_used += ndpi_json_string_escape(key, klen,
        (char *) &serializer->buffer.data[serializer->status.buffer.size_used], buff_diff);
      serializer->buffer.data[serializer->status.buffer.size_used] = ':';
      serializer->status.buffer.size_used++;
      buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;
    }

    rc = ndpi_snprintf((char *)
      &serializer->buffer.data[serializer->status.buffer.size_used], buff_diff, "%d", value);
    if(rc < 0 || (u_int)rc >= buff_diff)
      return(-1);
    serializer->status.buffer.size_used += rc;

    if(ndpi_serialize_json_post(_serializer) != 0)
      return(-1);
  } else if(serializer->fmt == ndpi_serialization_format_csv) {
    if (ndpi_serializer_header_string(serializer, key, klen) < 0) return(-1);
    ndpi_serialize_csv_pre(serializer);
    buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;
    rc = ndpi_snprintf((char *)
      &serializer->buffer.data[serializer->status.buffer.size_used], buff_diff,
      "%d", value);
    if(rc < 0 || (u_int)rc >= buff_diff)
      return(-1);
    serializer->status.buffer.size_used += rc;
  } else {
    if(value <= 127 && value >= -128) {
      serializer->buffer.data[serializer->status.buffer.size_used++] = (ndpi_serialization_string << 4) | ndpi_serialization_int8;
      ndpi_serialize_single_string(serializer, key, klen);
      ndpi_serialize_single_uint8(serializer, value);
    } else if(value <= 32767 && value >= -32768) {
      serializer->buffer.data[serializer->status.buffer.size_used++] = (ndpi_serialization_string << 4) | ndpi_serialization_int16;
      ndpi_serialize_single_string(serializer, key, klen);
      ndpi_serialize_single_uint16(serializer, value);
    } else {
      serializer->buffer.data[serializer->status.buffer.size_used++] = (ndpi_serialization_string << 4) | ndpi_serialization_int32;
      ndpi_serialize_single_string(serializer, key, klen);
      ndpi_serialize_single_uint32(serializer, value);
    }
  }

  serializer->status.flags |= NDPI_SERIALIZER_STATUS_NOT_EMPTY;

  return(0);
}

// the below code fragment can be found in:
// src/lib/ndpi_serializer.c
int ndpi_serialize_string_uint32(ndpi_serializer *_serializer,
				 const char *key, u_int32_t value) {
  return(ndpi_serialize_binary_uint32(_serializer, key, strlen(key), value));
}

// the below code fragment can be found in:
// src/lib/ndpi_serializer.c
int ndpi_serialize_string_int64(ndpi_serializer *_serializer,
				const char *key, int64_t value) {
  return(ndpi_serialize_binary_int64(_serializer, key, strlen(key), value));
}

// the below code fragment can be found in:
// src/lib/ndpi_serializer.c
int ndpi_serialize_binary_int64(ndpi_serializer *_serializer,
				const char *key, u_int16_t klen,
				int64_t value) {
  ndpi_private_serializer *serializer = (ndpi_private_serializer*)_serializer;
  u_int32_t buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;
  u_int32_t needed;
  int rc;

#ifdef OPTIMIZE_NUMERIC_KEYS
  if(ndpi_is_number(key, klen))
    return(ndpi_serialize_uint32_int64(_serializer, atoi(key), value));
#endif

  needed =
    sizeof(u_int8_t) /* type */ +
    sizeof(u_int16_t) /* key len */ +
    klen /* key */ +
    sizeof(u_int64_t);

  if(serializer->fmt == ndpi_serialization_format_json)
    needed += 16 + klen;

  if(buff_diff < needed) {
    if(ndpi_extend_serializer_buffer(&serializer->buffer, needed - buff_diff) < 0)
      return(-1);
    buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;
  }

  if(serializer->fmt == ndpi_serialization_format_json) {
    ndpi_serialize_json_pre(_serializer);
    buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;

    if (!(serializer->status.flags & NDPI_SERIALIZER_STATUS_LIST)) {
      serializer->status.buffer.size_used += ndpi_json_string_escape(key, klen,
        (char *) &serializer->buffer.data[serializer->status.buffer.size_used], buff_diff);
      buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;
      serializer->buffer.data[serializer->status.buffer.size_used] = ':';
      serializer->status.buffer.size_used++;
      buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;
    }

    rc = ndpi_snprintf((char *)
      &serializer->buffer.data[serializer->status.buffer.size_used], buff_diff,
      NDPI_I64_FORMAT, (long long int)value);
    if(rc < 0 || (u_int)rc >= buff_diff)
      return(-1);
    serializer->status.buffer.size_used += rc;

    if(ndpi_serialize_json_post(_serializer) != 0)
      return(-1);
  } else if(serializer->fmt == ndpi_serialization_format_csv) {
    if (ndpi_serializer_header_string(serializer, key, klen) < 0) return(-1);
    ndpi_serialize_csv_pre(serializer);
    buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;
    rc = ndpi_snprintf((char *) &serializer->buffer.data[serializer->status.buffer.size_used], buff_diff,
      NDPI_I64_FORMAT, (long long int)value);
    if(rc < 0 || (u_int)rc >= buff_diff)
      return(-1);
    serializer->status.buffer.size_used += rc;
  } else {
    if ((value & 0xFFFFFFFF) == value) {
      return(ndpi_serialize_string_int32(_serializer, key, value));
    } else {
      serializer->buffer.data[serializer->status.buffer.size_used++] = (ndpi_serialization_string << 4) | ndpi_serialization_int64;
      ndpi_serialize_single_string(serializer, key, klen);
      ndpi_serialize_single_uint64(serializer, value);
    }
  }

  serializer->status.flags |= NDPI_SERIALIZER_STATUS_NOT_EMPTY;
  return(0);
}

