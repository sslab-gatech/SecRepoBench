<｜begin▁of▁sentence｜>/*
 * ndpi_serializer.c
 *
 * Copyright (C) 2011-23 - ntop.org and contributors
 *
 * nDPI is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * nDPI is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with nDPI.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include <stdlib.h>
#include <errno.h>
#include <inttypes.h>
#include <sys/types.h>

#include "ndpi_api.h"
#include "ndpi_config.h"

#include <time.h>
#ifndef WIN32
#include <unistd.h>
#endif

#if defined __FreeBSD__ || defined __NetBSD__ || defined __OpenBSD__
#include <sys/endian.h>
#endif

#ifdef WIN32
#define NDPI_I64_FORMAT "%I64d"
#define NDPI_U64_FORMAT "%I64u"
#else
#define NDPI_I64_FORMAT "%lld"
#define NDPI_U64_FORMAT "%llu"
#endif

#define OPTIMIZE_NUMERIC_KEYS      /* Convert numeric string keys into int keys */
#define OPTIMIZE_CSV_SERIALIZATION /* Optimize serialization speed in case of CSV */

/* ********************************** */

u_int64_t ndpi_htonll(u_int64_t v) {
  union { u_int32_t lv[2]; u_int64_t llv; } u;

  u.lv[0] = htonl(v >> 32);
  u.lv[1] = htonl(v & 0xFFFFFFFFULL);

  return(u.llv);
}

/* ********************************** */

u_int64_t ndpi_ntohll(u_int64_t v) {
  union { u_int32_t lv[2]; u_int64_t llv; } u;

  u.llv = v;

  return((u_int64_t)ntohl(u.lv[0]) << 32) | (u_int64_t)ntohl(u.lv[1]);
}

/* ********************************** */

#ifdef OPTIMIZE_NUMERIC_KEYS
static int ndpi_is_number(const char *str, u_int32_t str_len) {
  unsigned int i;

  for(i = 0; i < str_len; i++)
    if(!isdigit((int)str[i])) return(0);

  return(1);
}
#endif

/* ********************************** */

/*
 * Escapes a string to be suitable for a JSON value, adding double quotes, and terminating the string with a null byte.
 * It is recommended to provide a destination buffer (dst) which is as large as double the source buffer (src) at least.
 * Upon successful return, these functions return the number of characters printed (excluding the null byte used to terminate the string).
 */
int ndpi_json_string_escape(const char *src, int src_len, char *dst, int dst_max_len) {
  char c = 0;
  int i, j = 0;

  dst[j++] = '"';

  for(i = 0; i < src_len && j < dst_max_len; i++) {

    c = src[i];

    switch (c) {
    case '\\':
    case '"':
    case '/':
      dst[j++] = '\\';
      dst[j++] = c;
      break;
    case '\b':
      dst[j++] = '\\';
      dst[j++] = 'b';
      break;
    case '\t':
      dst[j++] = '\\';
      dst[j++] = 't';
      break;
    case '\n':
      dst[j++] = '\\';
      dst[j++] = 'n';
      break;
    case '\f':
      dst[j++] = '\\';
      dst[j++] = 'f';
      break;
    case '\r':
      dst[j++] = '\\';
      dst[j++] = 'r';
      break;
    default:
      if(c < ' ')
	; /* non printable */
      else
	dst[j++] = c;
    }
  }

  dst[j++] = '"';
  dst[j+1] = '\0';

  return(j);
}

/* ********************************** */

#if UNUSED
/*
 * Similar to ndpi_snprintf, this returns the number of bytes actually written
 * in any case (unlike ndpi_snprintf which returns, if the output is truncated,
 * the number of bytes which *would have been* written, and a negative
 * value on failures)
 */
static inline int ndpi_snappend(char *buf, size_t size, const char *fmt, ...) {
  int wlen;
  va_list va;

  va_start(va, fmt);
  wlen = ndpi_snprintf(buf, size, fmt, va);
  va_end(va);

  if (wlen < 0)
    wlen = 0;
  else if (wlen >= size)
    wlen = size-1;

  return(wlen);
}
#endif

/* ********************************** */

void ndpi_reset_serializer(ndpi_serializer *_serializer) {
  ndpi_private_serializer *serializer = (ndpi_private_serializer*)_serializer;

  serializer->status.flags = 0;

  if(serializer->fmt == ndpi_serialization_format_json) {
    u_int32_t buff_diff;

    serializer->status.buffer.size_used = 0;
    buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;

    if (serializer->multiline_json_array) {
      serializer->status.buffer.size_used += ndpi_snprintf((char *) &serializer->buffer.data[serializer->status.buffer.size_used], buff_diff, "{}");
    } else {
      /* Note: please keep a space at the beginning as it is used for arrays when an end-of-record is used */
      serializer->status.buffer.size_used += ndpi_snprintf((char *) &serializer->buffer.data[serializer->status.buffer.size_used], buff_diff, " {}");
    }
  } else if(serializer->fmt == ndpi_serialization_format_csv) {
    serializer->status.header.size_used = 0;
    serializer->status.buffer.size_used = 0;
  } else { /* ndpi_serialization_format_tlv */
    serializer->status.buffer.size_used = 2 * sizeof(u_int8_t);
  }
}

/* ********************************** */

void ndpi_serializer_skip_header(ndpi_serializer *_serializer) {
  ndpi_private_serializer *serializer = (ndpi_private_serializer*)_serializer;

  serializer->status.flags |= NDPI_SERIALIZER_STATUS_HDR_DONE;
}

/* ********************************** */

static int ndpi_init_serializer_buffer(ndpi_private_serializer_buffer *buffer, u_int32_t buffer_size) {
  buffer->initial_size = buffer->size = buffer_size;
  buffer->data = (u_int8_t *)ndpi_calloc(buffer->size, sizeof(u_int8_t));
  if(buffer->data == NULL)
    return(-1);

  return(0);
}

/* ********************************** */

int ndpi_init_serializer_ll(ndpi_serializer *_serializer,
			    ndpi_serialization_format fmt,
			    u_int32_t buffer_size) {
  ndpi_private_serializer *serializer = (ndpi_private_serializer*)_serializer;

  memset(serializer, 0, sizeof(ndpi_private_serializer));

  if (fmt == ndpi_serialization_format_multiline_json) {
    fmt = ndpi_serialization_format_json;
    serializer->multiline_json_array = 1;
  }

  serializer->fmt = fmt;

  if (buffer_size < 3 ||
      ndpi_init_serializer_buffer(&serializer->buffer, buffer_size) != 0)
    return(-1);

  if(serializer->fmt == ndpi_serialization_format_json) {
    /* nothing to do */

  } else if (fmt == ndpi_serialization_format_csv) {
    if (ndpi_init_serializer_buffer(&serializer->header, NDPI_SERIALIZER_DEFAULT_HEADER_SIZE) != 0) {
      ndpi_term_serializer(_serializer);
      return(-1);
    }

  } else /* ndpi_serialization_format_tlv */ {
    serializer->buffer.data[0]   = 1; /* version */
    serializer->buffer.data[1]   = (u_int8_t) fmt;
  }

  serializer->csv_separator[0] = ',';
  serializer->csv_separator[1] = '\0';

  ndpi_reset_serializer(_serializer);

  return(0);
}

/* ********************************** */

int ndpi_init_serializer(ndpi_serializer *_serializer,
			 ndpi_serialization_format fmt) {
  return(ndpi_init_serializer_ll(_serializer, fmt, NDPI_SERIALIZER_DEFAULT_BUFFER_SIZE));
}

/* ********************************** */

static inline int ndpi_extend_serializer_buffer(ndpi_private_serializer_buffer *buffer, u_int32_t min_len) {
  u_int32_t new_size;
  void *r;

  if(min_len < NDPI_SERIALIZER_DEFAULT_BUFFER_INCR) {
    if(buffer->initial_size < NDPI_SERIALIZER_DEFAULT_BUFFER_INCR) {
      if(min_len < buffer->initial_size)
        min_len = buffer->initial_size;
    } else {
      min_len = NDPI_SERIALIZER_DEFAULT_BUFFER_INCR;
    }
  }

  new_size = buffer->size + min_len;
  new_size = ((new_size / 4) + 1) * 4; /* required by zmq encryption */

  r = ndpi_realloc((void *) buffer->data, buffer->size, new_size);

  if(r == NULL)
    return(-1);

  buffer->data = r;
  buffer->size = new_size;

  return(0);
}

/* ********************************** */

static inline int ndpi_serializer_check_header_room(ndpi_private_serializer *serializer, u_int32_t needed) {
  u_int32_t buff_diff = serializer->header.size - serializer->status.header.size_used;

  if (buff_diff < needed)
    if (ndpi_extend_serializer_buffer(&serializer->header, needed - buff_diff) < 0)
      return(-1);

  buff_diff = serializer->header.size - serializer->status.header.size_used;

  return(buff_diff);
}

/* ********************************** */

static inline int ndpi_serializer_header_uint32(ndpi_private_serializer *serializer, u_int32_t key) {
  int room;

  if (serializer->status.flags & NDPI_SERIALIZER_STATUS_HDR_DONE)
    return(0);

  room = ndpi_serializer_check_header_room(serializer, 12);

  if (room < 0)
    return(-1);

  serializer->status.header.size_used += ndpi_snprintf((char *) &serializer->header.data[serializer->status.header.size_used],
    room, "%s%u", (serializer->status.header.size_used > 0) ? serializer->csv_separator : "", key);

  return(0);
}

/* ********************************** */

static inline int ndpi_serializer_header_string(ndpi_private_serializer *serializer, const char *key, u_int16_t klen) {
  int room;

  if (serializer->status.flags & NDPI_SERIALIZER_STATUS_HDR_DONE)
    return(0);

  room = ndpi_serializer_check_header_room(serializer, klen + 4);

  if (room < 0)
    return(-1);

  if (serializer->status.header.size_used > 0) {
    int slen = strlen(serializer->csv_separator);
    memcpy(&serializer->header.data[serializer->status.header.size_used], serializer->csv_separator, slen);
    serializer->status.header.size_used += slen;
  }

  if (klen > 0) {
    memcpy(&serializer->header.data[serializer->status.header.size_used], key, klen);
    serializer->status.header.size_used += klen;
  }

  serializer->header.data[serializer->status.header.size_used] = '\0';

  return(0);
}

/* ********************************** */

char* ndpi_serializer_get_buffer(ndpi_serializer *_serializer, u_int32_t *buffer_len) {
  ndpi_private_serializer *serializer = (ndpi_private_serializer*)_serializer;
  char *buf = (char*)serializer->buffer.data;

  /* NULL terminate the buffer */
  if(serializer->buffer.size > serializer->status.buffer.size_used) /* safety check */
    serializer->buffer.data[serializer->status.buffer.size_used] = '\0';

  *buffer_len = serializer->status.buffer.size_used;

  if(serializer->fmt == ndpi_serialization_format_json) {
    while((buf[0] == '\0') || (buf[0] == ' '))
      buf++, *buffer_len = *buffer_len - 1;
  }

  return(buf);
}

/* ********************************** */

u_int32_t ndpi_serializer_get_buffer_len(ndpi_serializer *_serializer) {
  return(((ndpi_private_serializer*)_serializer)->status.buffer.size_used);
}

/* ********************************** */

u_int32_t ndpi_serializer_get_internal_buffer_size(ndpi_serializer *_serializer) {
  return(((ndpi_private_serializer*)_serializer)->buffer.size);
}

/* ********************************** */

int ndpi_serializer_set_buffer_len(ndpi_serializer *_serializer, u_int32_t l) {
  ndpi_private_serializer *p = (ndpi_private_serializer*)_serializer;

  if(p) {
    if(p->buffer.size <= l)
      return(-1); /* Invalid size */

    p->status.buffer.size_used = l;
    return(0);
  }

  return(-2);
}

/* ********************************** */

/* Return the header automatically built from keys (CSV only) */
char* ndpi_serializer_get_header(ndpi_serializer *_serializer, u_int32_t *buffer_len) {
  ndpi_private_serializer *serializer = (ndpi_private_serializer*)_serializer;
  char *buf = (char*)serializer->header.data;

  if(buf == NULL) {
    *buffer_len = 0;
    return("");
  }

  /* NULL terminate the buffer */
  if(serializer->header.size > serializer->status.header.size_used) /* safety check */
    serializer->header.data[serializer->status.header.size_used] = '\0';

  *buffer_len = serializer->status.header.size_used;

  return(buf);
}

/* ********************************** */

ndpi_serialization_format ndpi_serializer_get_format(ndpi_serializer *_serializer) {
  ndpi_private_serializer *serializer = (ndpi_private_serializer*)_serializer;

  return(serializer->fmt);
}

/* ********************************** */

void ndpi_serializer_set_csv_separator(ndpi_serializer *_serializer, char separator) {
  ndpi_private_serializer *serializer = (ndpi_private_serializer*)_serializer;

  serializer->csv_separator[0] = separator;
}

/* ********************************** */

void ndpi_term_serializer(ndpi_serializer *_serializer) {
  ndpi_private_serializer *serializer = (ndpi_private_serializer*)_serializer;

  if(serializer->buffer.data) {
    ndpi_free(serializer->buffer.data);
    serializer->buffer.size = 0;
    serializer->buffer.data = NULL;
  }

  if(serializer->header.data) {
    ndpi_free(serializer->header.data);
    serializer->header.size = 0;
    serializer->header.data = NULL;
  }
}

/* ********************************** */

static inline void ndpi_serialize_single_uint8(ndpi_private_serializer *serializer,
					       u_int8_t s) {
  u_int8_t v = s;

  memcpy(&serializer->buffer.data[serializer->status.buffer.size_used], &v, sizeof(u_int8_t));
  serializer->status.buffer.size_used += sizeof(u_int8_t);
}

/* ********************************** */

static inline void ndpi_serialize_single_uint16(ndpi_private_serializer *serializer,
						u_int16_t s) {
  u_int16_t v = htons(s);

  memcpy(&serializer->buffer.data[serializer->status.buffer.size_used], &v, sizeof(u_int16_t));
  serializer->status.buffer.size_used += sizeof(u_int16_t);
}

/* ********************************** */

static inline void ndpi_serialize_single_uint32(ndpi_private_serializer *serializer,
						u_int32_t s) {
  u_int32_t v = htonl(s);

  memcpy(&serializer->buffer.data[serializer->status.buffer.size_used], &v, sizeof(u_int32_t));
  serializer->status.buffer.size_used += sizeof(u_int32_t);
}

/* ********************************** */

static inline void ndpi_serialize_single_uint64(ndpi_private_serializer *serializer,
						u_int64_t s) {
  u_int64_t v = ndpi_htonll(s);

  memcpy(&serializer->buffer.data[serializer->status.buffer.size_used], &v, sizeof(u_int64_t));
  serializer->status.buffer.size_used += sizeof(u_int64_t);
}

/* ********************************** */

/* TODO: fix portability across platforms */
static inline void ndpi_serialize_single_float(ndpi_private_serializer *serializer,
					       float s) {
  memcpy(&serializer->buffer.data[serializer->status.buffer.size_used], &s, sizeof(s));
  serializer->status.buffer.size_used += sizeof(float);
}

/* ********************************** */

/* TODO: fix portability across platforms */
static inline void ndpi_serialize_single_double(ndpi_private_serializer *serializer,
                           double s) {
  memcpy(&serializer->buffer.data[serializer->status.buffer.size_used], &s, sizeof(s));
  serializer->status.buffer.size_used += sizeof(double);
}

/* ********************************** */

static inline void ndpi_serialize_single_string(ndpi_private_serializer *serializer,
						const char *s, u_int16_t slen) {
  u_int16_t l = htons(slen);

  memcpy(&serializer->buffer.data[serializer->status.buffer.size_used], &l, sizeof(u_int16_t));
  serializer->status.buffer.size_used += sizeof(u_int16_t);

  if(slen > 0)
    memcpy(&serializer->buffer.data[serializer->status.buffer.size_used], s, slen);

  serializer->status.buffer.size_used += slen;
}

/* ********************************** */

static inline void ndpi_deserialize_single_uint8(ndpi_private_deserializer *deserializer,
						 u_int32_t offset, u_int8_t *s) {
  *s = (*((u_int8_t *) &deserializer->buffer.data[offset]));
}

/* ********************************** */

static inline void ndpi_deserialize_single_uint16(ndpi_private_deserializer *deserializer,
						  u_int32_t offset, u_int16_t *s) {
  *s = ntohs(*((u_int16_t *) &deserializer->buffer.data[offset]));
}

/* ********************************** */

static inline void ndpi_deserialize_single_uint32(ndpi_private_deserializer *deserializer,
						  u_int32_t offset, u_int32_t *s) {
  *s = ntohl(*((u_int32_t *) &deserializer->buffer.data[offset]));
}

/* ********************************** */

static inline void ndpi_deserialize_single_int8(ndpi_private_deserializer *deserializer,
						u_int32_t offset, int8_t *s) {
  *s = (*((int8_t *) &deserializer->buffer.data[offset]));
}

/* ********************************** */

static inline void ndpi_deserialize_single_int16(ndpi_private_deserializer *deserializer,
						 u_int32_t offset, int16_t *s) {
  *s = ntohs(*((int16_t *) &deserializer->buffer.data[offset]));
}

/* ********************************** */

static inline void ndpi_deserialize_single_int32(ndpi_private_deserializer *deserializer,
						 u_int32_t offset, int32_t *s) {
  *s = ntohl(*((int32_t *) &deserializer->buffer.data[offset]));
}

/* ********************************** */

static inline void ndpi_deserialize_single_uint64(ndpi_private_deserializer *deserializer,
						  u_int32_t offset, u_int64_t *s) {
  *s = ndpi_ntohll(*(u_int64_t*)&deserializer->buffer.data[offset]);
}

/* ********************************** */

static inline void ndpi_deserialize_single_int64(ndpi_private_deserializer *deserializer,
						 u_int32_t offset, int64_t *s) {
  *s = ndpi_ntohll(*(int64_t*)&deserializer->buffer.data[offset]);
}

/* ********************************** */

/* TODO: fix portability across platforms */
static inline void ndpi_deserialize_single_float(ndpi_private_deserializer *deserializer,
						 u_int32_t offset, float *s) {
  *s = *(float*)&deserializer->buffer.data[offset];
}

/* ********************************** */

/* TODO: fix portability across platforms */
static inline void ndpi_deserialize_single_double(ndpi_private_deserializer *deserializer,
                         u_int32_t offset, double *s) {
  *s = *(double*)&deserializer->buffer.data[offset];
}

/* ********************************** */

static inline void ndpi_deserialize_single_string(ndpi_private_deserializer *deserializer,
						  u_int32_t offset, ndpi_string *v) {
  v->str_len = ntohs(*((u_int16_t *) &deserializer->buffer.data[offset]));
  v->str = (char *) &deserializer->buffer.data[offset + sizeof(u_int16_t)];
}

/* ********************************** */

/*
  This function helps extending the existing serializer by adding a new
  element in the array. This element is handled as raw without any
  further check whatsoever
*/
int ndpi_serialize_raw_record(ndpi_serializer *_serializer,
			      u_char *record, u_int32_t record_len) {
  ndpi_private_serializer *serializer = (ndpi_private_serializer*)_serializer;
  u_int32_t buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;
  u_int16_t needed = record_len;
  u_int8_t add_comma = 0;

  if(serializer->fmt == ndpi_serialization_format_json) {
    needed += 1;

    if (serializer->multiline_json_array) {
      if(serializer->status.buffer.size_used == 2) /* Empty buffer {} */
        serializer->status.buffer.size_used = 0; /* Remove {} */
      else
        needed += 2;

    } else {
      if(serializer->status.buffer.size_used == 3) /* Empty buffer [{} */
        serializer->status.buffer.size_used = 2; /* Remove {} */
      else
        needed += 2, add_comma = 1;
    }
  }

  if(buff_diff < needed) {
    if(ndpi_extend_serializer_buffer(&serializer->buffer, needed - buff_diff) < 0)
      return(-1);

    buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;
  }

  if(serializer->fmt == ndpi_serialization_format_json) {
    if (!serializer->multiline_json_array) {
      if (add_comma)
        serializer->buffer.data[serializer->status.buffer.size_used-1] = ',';
      else
        serializer->status.buffer.size_used--;
    }
  }

  memcpy(&serializer->buffer.data[serializer->status.buffer.size_used], record, record_len);
  serializer->status.buffer.size_used += record_len;

  if(serializer->fmt == ndpi_serialization_format_json) {
    if (!serializer->multiline_json_array) {
      serializer->buffer.data[serializer->status.buffer.size_used] = ']';
      if(add_comma) serializer->status.buffer.size_used++;
    }
  }

  ndpi_serialize_end_of_record(_serializer);

  return(0);
}

/* ********************************** */

int ndpi_serialize_end_of_record(ndpi_serializer *_serializer) {
  ndpi_private_serializer *serializer = (ndpi_private_serializer*)_serializer;
  u_int32_t buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;
  u_int16_t needed = sizeof(u_int8_t) /* type */;

  if(serializer->fmt == ndpi_serialization_format_json ||
     serializer->fmt == ndpi_serialization_format_csv)
    needed += 1;

  if(buff_diff < needed) {
    if(ndpi_extend_serializer_buffer(&serializer->buffer, needed - buff_diff) < 0)
      return(-1);
    buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;
  }

  if(serializer->fmt == ndpi_serialization_format_csv) {
    serializer->buffer.data[serializer->status.buffer.size_used++] = '\n';
    serializer->buffer.data[serializer->status.buffer.size_used] = '\0';
    serializer->status.flags |= NDPI_SERIALIZER_STATUS_HDR_DONE;
    serializer->status.flags |= NDPI_SERIALIZER_STATUS_EOR;

  } else if(serializer->fmt == ndpi_serialization_format_json) {

    if(serializer->multiline_json_array) {
      serializer->buffer.data[serializer->status.buffer.size_used++] = '\n';
      serializer->buffer.data[serializer->status.buffer.size_used] = '\0';

    } else {
      if(!(serializer->status.flags & NDPI_SERIALIZER_STATUS_ARRAY)) {
        serializer->buffer.data[0] = '[';
        serializer->status.buffer.size_used += ndpi_snprintf((char *) &serializer->buffer.data[serializer->status.buffer.size_used], buff_diff, "]");
      }
    }
    serializer->status.flags |= NDPI_SERIALIZER_STATUS_ARRAY | NDPI_SERIALIZER_STATUS_EOR;
    serializer->status.flags &= ~NDPI_SERIALIZER_STATUS_COMMA;

  } else /* ndpi_serialization_format_tlv */ {
    serializer->buffer.data[serializer->status.buffer.size_used++] = ndpi_serialization_end_of_record;
  }

  serializer->status.flags &= ~NDPI_SERIALIZER_STATUS_NOT_EMPTY;

  return(0);
}

/* ********************************** */

static inline void ndpi_serialize_csv_pre(ndpi_private_serializer *serializer) {
  if(serializer->status.flags & NDPI_SERIALIZER_STATUS_EOR) {
    serializer->status.flags &= ~NDPI_SERIALIZER_STATUS_EOR;
  } else if (serializer->status.buffer.size_used == 0) {
    /* nothing to do */
  } else {
    if(serializer->buffer.size > serializer->status.buffer.size_used) {
      serializer->buffer.data[serializer->status.buffer.size_used] = serializer->csv_separator[0];
      serializer->status.buffer.size_used++;
    }
  }
}

/* ********************************** */

static inline void ndpi_serialize_json_pre(ndpi_serializer *_serializer) {
  ndpi_private_serializer *serializer = (ndpi_private_serializer*)_serializer;

  if(serializer->status.flags & NDPI_SERIALIZER_STATUS_EOR) {
    serializer->status.flags &= ~NDPI_SERIALIZER_STATUS_EOR;
    if(serializer->multiline_json_array) {
      serializer->buffer.data[serializer->status.buffer.size_used++] = '\n';
    } else {
      serializer->status.buffer.size_used--; /* Remove ']' */
      serializer->buffer.data[serializer->status.buffer.size_used++] = ',';
    }
    serializer->buffer.data[serializer->status.buffer.size_used++] = '{';

  } else {
    if(!serializer->multiline_json_array) {
      if(serializer->status.flags & NDPI_SERIALIZER_STATUS_ARRAY)
        serializer->status.buffer.size_used--; /* Remove ']' */
    }

    serializer->status.buffer.size_used--; /* Remove '}' */

    if(serializer->status.flags & NDPI_SERIALIZER_STATUS_LIST) {
      if(!serializer->multiline_json_array)
        serializer->status.buffer.size_used--; /* Remove ']' */
      if(serializer->status.flags & NDPI_SERIALIZER_STATUS_SOL)
        serializer->status.flags &= ~NDPI_SERIALIZER_STATUS_SOL;
      else
        serializer->buffer.data[serializer->status.buffer.size_used++] = ',';
    } else {
      if(serializer->status.flags & NDPI_SERIALIZER_STATUS_SOB)
        serializer->status.flags &= ~NDPI_SERIALIZER_STATUS_SOB;
      else if(serializer->status.flags & NDPI_SERIALIZER_STATUS_COMMA)
        serializer->buffer.data[serializer->status.buffer.size_used++] = ',';
    }
  }
}

/* ********************************** */

static inline int ndpi_serialize_json_post(ndpi_serializer *_serializer) {
  ndpi_private_serializer *serializer = (ndpi_private_serializer*)_serializer;

  if (!serializer->multiline_json_array) {
    if(serializer->status.flags & NDPI_SERIALIZER_STATUS_LIST) {
      if(serializer->status.buffer.size_used >= serializer->buffer.size)
        return -1;
      serializer->buffer.data[serializer->status.buffer.size_used++] = ']';
    }
  }

  if(serializer->status.buffer.size_used >= serializer->buffer.size)
    return -1;
  serializer->buffer.data[serializer->status.buffer.size_used++] = '}';

  if (!serializer->multiline_json_array) {
    if(serializer->status.flags & NDPI_SERIALIZER_STATUS_ARRAY) {
      if(serializer->status.buffer.size_used >= serializer->buffer.size)
        return -1;
      serializer->buffer.data[serializer->status.buffer.size_used++] = ']';
    }
  }

  serializer->status.flags |= NDPI_SERIALIZER_STATUS_COMMA;
  return 0;
}

/* ********************************** */

static inline ndpi_serialization_type ndpi_serialize_key_uint32(ndpi_private_serializer *serializer, u_int32_t key) {
  ndpi_serialization_type kt;

  if(key <= 0xff) {
    ndpi_serialize_single_uint8(serializer, key);
    kt = ndpi_serialization_uint8;
  } else if(key <= 0xffff) {
    ndpi_serialize_single_uint16(serializer, key);
    kt = ndpi_serialization_uint16;
  } else {
    ndpi_serialize_single_uint32(serializer, key);
    kt = ndpi_serialization_

// --- CODE TRUNCATED HERE ---

int ndpi_serialize_string_int32(ndpi_serializer *_serializer,
				const char *key, int32_t value) {
#ifdef OPTIMIZE_CSV_SERIALIZATION
  ndpi_private_serializer *serializer = (ndpi_private_serializer*)_serializer;

  if(serializer->fmt == ndpi_serialization_format_csv) {
    /* Key is ignored */
    u_int32_t remainingspace = serializer->buffer.size - serializer->status.buffer.size_used;
    // Serialize the integer value into a CSV format string and store it in the buffer.
    // Ensure that the buffer has sufficient space, extending it if necessary.
    // Prepend a header string if the header has not already been written.
    // Adjust the buffer usage count to reflect the serialized data.
    // <MASK>

    if(rc < 0 || (u_int)rc >= remainingspace)
      return(-1);
    
    serializer->status.buffer.size_used += rc;
    
    return(0);
  } else
#endif
  return(ndpi_serialize_binary_int32(_serializer, key, strlen(key), value));
}