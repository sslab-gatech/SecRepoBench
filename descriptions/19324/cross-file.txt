// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/lib/ndpi_main.c
void ndpi_free_flow(struct ndpi_flow_struct *flow) {
  if(flow) {
  if(flow->http.url)              ndpi_free(flow->http.url);
    if(flow->http.content_type)   ndpi_free(flow->http.content_type);
    if(flow->http.user_agent)     ndpi_free(flow->http.user_agent);
    if(flow->kerberos_buf.pktbuf) ndpi_free(flow->kerberos_buf.pktbuf);

    if(flow_is_proto(flow, NDPI_PROTOCOL_TLS)) {
      if(flow->protos.stun_ssl.ssl.server_names)
	ndpi_free(flow->protos.stun_ssl.ssl.server_names);

      if(flow->l4.tcp.tls.srv_cert_fingerprint_ctx)
	ndpi_free(flow->l4.tcp.tls.srv_cert_fingerprint_ctx);
    }

    if(flow->l4_proto == IPPROTO_TCP) {
      if(flow->l4.tcp.tls.message.buffer)
	ndpi_free(flow->l4.tcp.tls.message.buffer);
    }

    ndpi_free(flow);
  }
}

// the below code fragment can be found in:
// src/lib/ndpi_main.c
static int hyperscanCustomEventHandler(unsigned int id,
				       unsigned long long from,
				       unsigned long long to,
				       unsigned int flags, void *ctx) {
  *((unsigned long  *)ctx) = (unsigned long)id;

#ifdef DEBUG
  printf("[HS] Found category %u\n", id);
#endif

  return(HS_SCAN_TERMINATED);
}

// the below code fragment can be found in:
// src/lib/protocols/netbios.c
void init_netbios_dissector(struct ndpi_detection_module_struct *ndpi_struct, u_int32_t *id, NDPI_PROTOCOL_BITMASK *detection_bitmask)
{
  ndpi_set_bitmask_protocol_detection("NETBIOS", ndpi_struct, detection_bitmask, *id,
				      NDPI_PROTOCOL_NETBIOS,
				      ndpi_search_netbios,
				      NDPI_SELECTION_BITMASK_PROTOCOL_TCP_OR_UDP_WITH_PAYLOAD_WITHOUT_RETRANSMISSION,
				      SAVE_DETECTION_BITMASK_AS_UNKNOWN,
				      ADD_TO_DETECTION_BITMASK);

  *id += 1;
}

// the below code fragment can be found in:
// src/lib/ndpi_main.c
static int hyperscanEventHandler(unsigned int id, unsigned long long from,
				 unsigned long long to, unsigned int flags, void *ctx) {
  *((int *)ctx) = (int)id;

  NDPI_LOG_DBG2(ndpi_str, "[NDPI] Match with: %d [from: %llu][to: %llu]\n", id, from, to);

  /* return HS_SCAN_TERMINATED; */
  return(0); /* keep searching */
}

// the below code fragment can be found in:
// src/lib/ndpi_main.c
int ndpi_match_string_id(void *_automa, char *string_to_match, u_int match_len, unsigned long *id) {
  AC_TEXT_t ac_input_text;
  AC_AUTOMATA_t *automa = (AC_AUTOMATA_t*)_automa;
  AC_REP_t match = { NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NDPI_PROTOCOL_UNRATED };
  int rc;

  *id = -1;
  if((automa == NULL)
     || (string_to_match == NULL)
     || (string_to_match[0] == '\0'))
    return(-2);

  ac_input_text.astring = string_to_match, ac_input_text.length = match_len;
  rc = ac_automata_search(automa, &ac_input_text, &match);

  /*
    As ac_automata_search can detect partial matches and continue the search process
    in case rc == 0 (i.e. no match), we need to check if there is a partial match
    and in this case return it
  */
  if((rc == 0) && (match.number != 0)) rc = 1;

  *id = rc ? match.number : NDPI_PROTOCOL_UNKNOWN;

  return(*id != NDPI_PROTOCOL_UNKNOWN ? 0 : -1);
}

