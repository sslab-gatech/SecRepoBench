// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// libavutil/aes.c
// static void init_multbl2(uint32_t tbl[][256], const int c[4],
//                          const uint8_t *log8, const uint8_t *alog8,
//                          const uint8_t *sbox)
// {
//     int i;
// 
//     for (i = 0; i < 256; i++) {
//         int x = sbox[i];
//         if (x) {
//             int k, l, m, n;
//             x = log8[x];
//             k = alog8[x + log8[c[0]]];
//             l = alog8[x + log8[c[1]]];
//             m = alog8[x + log8[c[2]]];
//             n = alog8[x + log8[c[3]]];
//             tbl[0][i] = AV_NE(MKBETAG(k, l, m, n), MKTAG(k, l, m, n));
// #if !CONFIG_SMALL
//             tbl[1][i] = ROT(tbl[0][i], 8);
//             tbl[2][i] = ROT(tbl[0][i], 16);
//             tbl[3][i] = ROT(tbl[0][i], 24);
// #endif
//         }
//     }
// }

// the below code fragment can be found in:
// libavutil/rc4.c
// void av_rc4_crypt(AVRC4 *r, uint8_t *dst, const uint8_t *src, int count, uint8_t *iv, int decrypt) {
//     uint8_t x = r->x, y = r->y;
//     uint8_t *state = r->state;
//     while (count-- > 0) {
//         uint8_t sum = state[x] + state[y];
//         FFSWAP(uint8_t, state[x], state[y]);
//         *dst++ = src ? *src++ ^ state[sum] : state[sum];
//         x++;
//         y += state[x];
//     }
//     r->x = x; r->y = y;
// }

// the below code fragment can be found in:
// libavcodec/cbs_jpeg_syntax_template.c
// static int FUNC(dht)(CodedBitstreamContext *ctx, RWContext *rw,
//                      JPEGRawHuffmanTableSpecification *current)
// {
//     int err, i, j, n;
// 
//     HEADER("Huffman Tables");
// 
//     u(16, Lh, 2, 2 + 8 * (1 + 16 + 256));
// 
//     n = 2;
//     for (i = 0; n < current->Lh; i++) {
//         if (i >= 8)
//             return AVERROR_INVALIDDATA;
// 
//         CHECK(FUNC(huffman_table)(ctx, rw, &current->table[i]));
// 
//         ++n;
//         for (j = 0; j < 16; j++)
//             n += 1 + current->table[i].L[j];
//     }
// 
//     return 0;
// }

// the below code fragment can be found in:
// libavutil/tests/cast5.c
// int main(int argc, char** argv)
// {
// 
//     static const uint8_t Key[3][16] = {
//         {0x01, 0x23, 0x45, 0x67, 0x12, 0x34, 0x56, 0x78, 0x23, 0x45, 0x67, 0x89, 0x34, 0x56, 0x78, 0x9a},
//         {0x01, 0x23, 0x45, 0x67, 0x12, 0x34, 0x56, 0x78, 0x23, 0x45},
//         {0x01, 0x23, 0x45, 0x67, 0x12}
//     };
//     static const uint8_t rpt[8] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef};
//     static const uint8_t rct[3][8] = {
//         {0x23, 0x8b, 0x4f, 0xe5, 0x84, 0x7e, 0x44, 0xb2},
//         {0xeb, 0x6a, 0x71, 0x1a, 0x2c, 0x02, 0x27, 0x1b},
//         {0x7a, 0xc8, 0x16, 0xd1, 0x6e, 0x9b, 0x30, 0x2e}
//     };
//     static const uint8_t rct2[2][16] = {
//         {0xee, 0xa9, 0xd0, 0xa2, 0x49, 0xfd, 0x3b, 0xa6, 0xb3, 0x43, 0x6f, 0xb8, 0x9d, 0x6d, 0xca, 0x92},
//         {0xb2, 0xc9, 0x5e, 0xb0, 0x0c, 0x31, 0xad, 0x71, 0x80, 0xac, 0x05, 0xb8, 0xe8, 0x3d, 0x69, 0x6e}
//     };
//     static const uint8_t iv[8] = {0xee, 0xa9, 0xd0, 0xa2, 0x49, 0xfd, 0x3b, 0xa6};
//     static uint8_t rpt2[2][16];
//     int i, j, err = 0;
//     static const int key_bits[3] = {128, 80, 40};
//     uint8_t temp[8];
//     struct AVCAST5 *cs;
//     cs = av_cast5_alloc();
//     if (!cs)
//         return 1;
//     for (j = 0; j < 3; j++){
// 
//         av_cast5_init(cs, Key[j], key_bits[j]);
//         av_cast5_crypt(cs, temp, rpt, 1, 0);
//         for (i = 0;i < 8; i++){
//             if (rct[j][i] != temp[i]){
//                 av_log(NULL, AV_LOG_ERROR, "%d %02x %02x\n", i, rct[j][i], temp[i]);
//                 err = 1;
//             }
//         }
// 
//         av_cast5_crypt(cs, temp, rct[j], 1, 1);
//         for (i =0; i < 8; i++) {
//             if (rpt[i] != temp[i]) {
//                 av_log(NULL, AV_LOG_ERROR, "%d %02x %02x\n", i, rpt[i], temp[i]);
//                 err = 1;
//             }
//         }
//     }
//     memcpy(rpt2[0], Key[0], 16);
//     memcpy(rpt2[1], Key[0], 16);
//     for (i = 0; i < 1000000; i++){
//         av_cast5_init(cs, rpt2[1], 128);
//         av_cast5_crypt(cs, rpt2[0], rpt2[0], 2, 0);
//         av_cast5_init(cs, rpt2[0], 128);
//         av_cast5_crypt(cs, rpt2[1], rpt2[1], 2, 0);
//     }
//     for (j = 0; j < 2; j++) {
//         for (i = 0; i < 16; i++) {
//             if (rct2[j][i] != rpt2[j][i]) {
//                 av_log(NULL, AV_LOG_ERROR, "%d %02x %02x\n", i, rct2[j][i], rpt2[j][i]);
//                 err = 1;
//             }
//         }
//     }
//     for (j = 0; j < 3; j++) {
// 
//         av_cast5_init(cs, Key[j], key_bits[j]);
//         memcpy(temp, iv, 8);
//         av_cast5_crypt2(cs, rpt2[0], rct2[0], 2, temp, 0);
//         memcpy(temp, iv, 8);
//         av_cast5_crypt2(cs, rpt2[0], rpt2[0], 2, temp, 1);
//         for (i = 0; i < 16; i++) {
//             if (rct2[0][i] != rpt2[0][i]) {
//                 av_log(NULL, AV_LOG_ERROR, "%d %02x %02x\n", i, rct2[0][i], rpt2[0][i]);
//                 err = 1;
//             }
//         }
//     }
//     av_free(cs);
//     return err;
// }

// the below code fragment can be found in:
// libavcodec/4xm.c
// static int mix(int c0, int c1)
// {
//     int blue  =  2 * (c0 & 0x001F) + (c1 & 0x001F);
//     int green = (2 * (c0 & 0x03E0) + (c1 & 0x03E0)) >> 5;
//     int red   =  2 * (c0 >> 10)    + (c1 >> 10);
//     return red / 3 * 1024 + green / 3 * 32 + blue / 3;
// }

