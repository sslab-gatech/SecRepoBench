// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/core/SkTDArray.cpp
// void* SkTDStorage::insert(int index, size_t sizeOfT) {
//     return this->insert(index, nullptr, /*count=*/1, sizeOfT);
// }

// the below code fragment can be found in:
// src/core/SkTDArray.cpp
// int SkTDStorage::calculateSizeDeltaOrDie(int delta) const {
//     // Check that count will not go negative.
//     SkASSERT_RELEASE(-fCount <= delta);
// 
//     // We take care to avoid overflow here.
//     // Because fCount and delta are both signed 32-bit ints, the sum of fCount and delta is at
//     // most 4294967294, which fits fine in uint32_t. Proof follows in assert.
//     static_assert(UINT32_MAX >= (uint32_t)INT_MAX + (uint32_t)INT_MAX);
//     uint32_t count = (uint32_t)this->size() + (uint32_t)delta;
//     SkASSERT_RELEASE(SkTFitsIn<int>(count));
//     return SkToInt(count);
// }

// the below code fragment can be found in:
// src/core/SkTDArray.cpp
// void* SkTDStorage::removeShuffle(int index, size_t sizeOfT) {
//     SkASSERT(0 <= index && index < fCount);
//     // Check that the new count is valid.
//     int newCount = this->calculateSizeDeltaOrDie(-1);
// 
//     const size_t indexOffset = offset(index, sizeOfT);
//     const size_t lastElementOffset = offset(newCount, sizeOfT);
// 
//     // Fill the index if not the last element.
//     if (index < newCount) {
//         memmove(fStorage + indexOffset, fStorage + lastElementOffset, sizeOfT);
//     }
//     this->resize(newCount, sizeOfT);
//     return fStorage + lastElementOffset;
// }

// the below code fragment can be found in:
// src/core/SkTDArray.cpp
// void* SkTDStorage::insert(int index, const void* src, int count, size_t sizeOfT) {
//     SkASSERT(0 <= index && index <= fCount);
//     SkASSERT(count >= 0);
//     const size_t indexOffset = offset(index, sizeOfT);
// 
//     if (count > 0) {
//         const int oldCount = fCount;
// 
//         size_t oldCountOffset = this->size_bytes(sizeOfT);
// 
//         const int newCount = this->calculateSizeDeltaOrDie(count);
//         this->resize(newCount, sizeOfT);
// 
//         // Shift memory to make space.
//         if (index < oldCount) {
//             // Safe because index <= oldCount and oldCount + count is safe.
//             size_t shiftOffset = offset(index + count, sizeOfT);
// 
//             // Move the tail of data from index to oldCount.
//             memmove(fStorage + shiftOffset, fStorage + indexOffset, oldCountOffset - indexOffset);
//         }
// 
//         if (src != nullptr) {
//             memcpy(fStorage + indexOffset, src, mem_size(count, sizeOfT));
//         }
//     }
// 
//     return fStorage + indexOffset;
// }

// the below code fragment can be found in:
// src/core/SkTDArray.cpp
// void* SkTDStorage::prepend(size_t sizeOfT) {
//     return this->insert(/*index=*/0, sizeOfT);
// }

