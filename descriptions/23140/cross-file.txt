// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// Zend/zend_attributes.c
static void attr_free(zval *v)
{
	free_attribute((zend_attribute *) Z_PTR_P(v), 0);
}

// the below code fragment can be found in:
// Zend/zend_attributes.c
static zend_attribute *get_attribute_str(HashTable *attributes, const char *str, size_t len, uint32_t offset)
{
	if (attributes) {
		zend_attribute *attr;

		ZEND_HASH_FOREACH_PTR(attributes, attr) {
			if (attr->offset == offset && ZSTR_LEN(attr->lcname) == len) {
				if (0 == memcmp(ZSTR_VAL(attr->lcname), str, len)) {
					return attr;
				}
			}
		} ZEND_HASH_FOREACH_END();
	}

	return NULL;
}

// the below code fragment can be found in:
// Zend/zend_attributes.c
ZEND_API zend_attribute *zend_get_attribute(HashTable *attributes, zend_string *lcname)
{
	return get_attribute(attributes, lcname, 0);
}

// the below code fragment can be found in:
// Zend/zend_compile.c
void zend_compile_params(zend_ast *ast, zend_ast *return_type_ast, uint32_t fallback_return_type) /* {{{ */
{
	zend_ast_list *list = zend_ast_get_list(ast);
	uint32_t i;
	zend_op_array *op_array = CG(active_op_array);
	zend_arg_info *arg_infos;
	zend_string *optional_param = NULL;

	if (return_type_ast || fallback_return_type) {
		/* Use op_array->arg_info[-1] for return type */
		arg_infos = safe_emalloc(sizeof(zend_arg_info), list->children + 1, 0);
		arg_infos->name = NULL;
		if (return_type_ast) {
			arg_infos->type = zend_compile_typename(
				return_type_ast, /* force_allow_null */ 0, /* use_arena */ 0);
			ZEND_TYPE_FULL_MASK(arg_infos->type) |= _ZEND_ARG_INFO_FLAGS(
				(op_array->fn_flags & ZEND_ACC_RETURN_REFERENCE) != 0, /* is_variadic */ 0);
		} else {
			arg_infos->type = (zend_type) ZEND_TYPE_INIT_CODE(fallback_return_type, 0, 0);
		}
		arg_infos++;
		op_array->fn_flags |= ZEND_ACC_HAS_RETURN_TYPE;
	} else {
		if (list->children == 0) {
			return;
		}
		arg_infos = safe_emalloc(sizeof(zend_arg_info), list->children, 0);
	}

	for (i = 0; i < list->children; ++i) {
		zend_ast *param_ast = list->child[i];
		zend_ast *type_ast = param_ast->child[0];
		zend_ast *var_ast = param_ast->child[1];
		zend_ast *default_ast = param_ast->child[2];
		zend_ast *attributes_ast = param_ast->child[3];
		zend_ast *doc_comment_ast = param_ast->child[4];
		zend_string *name = zval_make_interned_string(zend_ast_get_zval(var_ast));
		zend_bool is_ref = (param_ast->attr & ZEND_PARAM_REF) != 0;
		zend_bool is_variadic = (param_ast->attr & ZEND_PARAM_VARIADIC) != 0;
		uint32_t visibility =
			param_ast->attr & (ZEND_ACC_PUBLIC|ZEND_ACC_PROTECTED|ZEND_ACC_PRIVATE);

		znode var_node, default_node;
		zend_uchar opcode;
		zend_op *opline;
		zend_arg_info *arg_info;

		if (zend_is_auto_global(name)) {
			zend_error_noreturn(E_COMPILE_ERROR, "Cannot re-assign auto-global variable %s",
				ZSTR_VAL(name));
		}

		var_node.op_type = IS_CV;
		var_node.u.op.var = lookup_cv(name);

		if (EX_VAR_TO_NUM(var_node.u.op.var) != i) {
			zend_error_noreturn(E_COMPILE_ERROR, "Redefinition of parameter $%s",
				ZSTR_VAL(name));
		} else if (zend_string_equals_literal(name, "this")) {
			zend_error_noreturn(E_COMPILE_ERROR, "Cannot use $this as parameter");
		}

		if (op_array->fn_flags & ZEND_ACC_VARIADIC) {
			zend_error_noreturn(E_COMPILE_ERROR, "Only the last parameter can be variadic");
		}

		if (is_variadic) {
			opcode = ZEND_RECV_VARIADIC;
			default_node.op_type = IS_UNUSED;
			op_array->fn_flags |= ZEND_ACC_VARIADIC;

			if (default_ast) {
				zend_error_noreturn(E_COMPILE_ERROR,
					"Variadic parameter cannot have a default value");
			}
		} else if (default_ast) {
			/* we cannot substitute constants here or it will break ReflectionParameter::getDefaultValueConstantName() and ReflectionParameter::isDefaultValueConstant() */
			uint32_t cops = CG(compiler_options);
			CG(compiler_options) |= ZEND_COMPILE_NO_CONSTANT_SUBSTITUTION | ZEND_COMPILE_NO_PERSISTENT_CONSTANT_SUBSTITUTION;
			opcode = ZEND_RECV_INIT;
			default_node.op_type = IS_CONST;
			zend_const_expr_to_zval(&default_node.u.constant, default_ast);
			CG(compiler_options) = cops;

			if (!optional_param) {
				/* Ignore parameters of the form "Type $param = null".
				 * This is the PHP 5 style way of writing "?Type $param", so allow it for now. */
				zend_bool is_implicit_nullable =
					type_ast && Z_TYPE(default_node.u.constant) == IS_NULL;
				if (!is_implicit_nullable) {
					optional_param = name;
				}
			}
		} else {
			opcode = ZEND_RECV;
			default_node.op_type = IS_UNUSED;
			op_array->required_num_args = i + 1;
			if (optional_param) {
				zend_error(E_DEPRECATED, "Required parameter $%s follows optional parameter $%s",
					ZSTR_VAL(name), ZSTR_VAL(optional_param));
			}
		}

		arg_info = &arg_infos[i];
		arg_info->name = zend_string_copy(name);
		arg_info->type = (zend_type) ZEND_TYPE_INIT_NONE(0);

		if (attributes_ast) {
			zend_compile_attributes(&op_array->attributes, attributes_ast, i + 1, ZEND_ATTRIBUTE_TARGET_PARAMETER);
		}

		if (type_ast) {
			uint32_t default_type = default_ast ? Z_TYPE(default_node.u.constant) : IS_UNDEF;
			zend_bool force_nullable = default_type == IS_NULL && !visibility;

			op_array->fn_flags |= ZEND_ACC_HAS_TYPE_HINTS;
			arg_info->type = zend_compile_typename(type_ast, force_nullable, /* use_arena */ 0);

			if (ZEND_TYPE_FULL_MASK(arg_info->type) & MAY_BE_VOID) {
				zend_error_noreturn(E_COMPILE_ERROR, "void cannot be used as a parameter type");
			}

			if (default_type != IS_UNDEF && default_type != IS_CONSTANT_AST && !force_nullable
					&& !zend_is_valid_default_value(arg_info->type, &default_node.u.constant)) {
				zend_string *type_str = zend_type_to_string(arg_info->type);
				zend_error_noreturn(E_COMPILE_ERROR,
					"Cannot use %s as default value for parameter $%s of type %s",
					zend_get_type_by_const(default_type),
					ZSTR_VAL(name), ZSTR_VAL(type_str));
			}
		}

		opline = zend_emit_op(NULL, opcode, NULL, &default_node);
		SET_NODE(opline->result, &var_node);
		opline->op1.num = i + 1;

		if (type_ast) {
			/* Allocate cache slot to speed-up run-time class resolution */
			opline->extended_value =
				zend_alloc_cache_slots(zend_type_get_num_classes(arg_info->type));
		}

		uint32_t arg_info_flags = _ZEND_ARG_INFO_FLAGS(is_ref, is_variadic)
			| (visibility ? _ZEND_IS_PROMOTED_BIT : 0);
		ZEND_TYPE_FULL_MASK(arg_info->type) |= arg_info_flags;
		if (opcode == ZEND_RECV) {
			opline->op2.num = type_ast ?
				ZEND_TYPE_FULL_MASK(arg_info->type) : MAY_BE_ANY;
		}

		if (visibility) {
			zend_op_array *op_array = CG(active_op_array);
			zend_class_entry *scope = op_array->scope;
			zend_bool is_ctor =
				scope && zend_string_equals_literal_ci(op_array->function_name, "__construct");
			if (!is_ctor) {
				zend_error_noreturn(E_COMPILE_ERROR,
					"Cannot declare promoted property outside a constructor");
			}
			if ((op_array->fn_flags & ZEND_ACC_ABSTRACT)
					|| (scope->ce_flags & ZEND_ACC_INTERFACE)) {
				zend_error_noreturn(E_COMPILE_ERROR,
					"Cannot declare promoted property in an abstract constructor");
			}
			if (is_variadic) {
				zend_error_noreturn(E_COMPILE_ERROR,
					"Cannot declare variadic promoted property");
			}
			if (zend_hash_exists(&scope->properties_info, name)) {
				zend_error_noreturn(E_COMPILE_ERROR, "Cannot redeclare %s::$%s",
					ZSTR_VAL(scope->name), ZSTR_VAL(name));
			}
			if (ZEND_TYPE_FULL_MASK(arg_info->type) & MAY_BE_CALLABLE) {
				zend_string *str = zend_type_to_string(arg_info->type);
				zend_error_noreturn(E_COMPILE_ERROR,
					"Property %s::$%s cannot have type %s",
					ZSTR_VAL(scope->name), ZSTR_VAL(name), ZSTR_VAL(str));
			}

			/* Always use uninitialized as the default. */
			zval default_value;
			ZVAL_UNDEF(&default_value);

			/* Recompile the type, as it has different memory management requirements. */
			zend_type type = ZEND_TYPE_INIT_NONE(0);
			if (type_ast) {
				type = zend_compile_typename(type_ast, /* force_allow_null */ 0, /* use_arena */ 1);
			}

			zend_string *doc_comment =
				doc_comment_ast ? zend_string_copy(zend_ast_get_str(doc_comment_ast)) : NULL;
			zend_property_info *prop = zend_declare_typed_property(
				scope, name, &default_value, visibility | ZEND_ACC_PROMOTED, doc_comment, type);
			if (attributes_ast) {
				zend_compile_attributes(
					&prop->attributes, attributes_ast, 0, ZEND_ATTRIBUTE_TARGET_PROPERTY);
			}
		}
	}

	/* These are assigned at the end to avoid uninitialized memory in case of an error */
	op_array->num_args = list->children;
	op_array->arg_info = arg_infos;

	/* Don't count the variadic argument */
	if (op_array->fn_flags & ZEND_ACC_VARIADIC) {
		op_array->num_args--;
	}
	zend_set_function_arg_flags((zend_function*)op_array);

	for (i = 0; i < list->children; i++) {
		zend_ast *param_ast = list->child[i];
		zend_bool is_ref = (param_ast->attr & ZEND_PARAM_REF) != 0;
		uint32_t visibility =
			param_ast->attr & (ZEND_ACC_PUBLIC|ZEND_ACC_PROTECTED|ZEND_ACC_PRIVATE);
		if (!visibility) {
			continue;
		}

		/* Emit $this->prop = $prop for promoted properties. */
		zend_string *name = zend_ast_get_str(param_ast->child[1]);
		znode name_node, value_node;
		name_node.op_type = IS_CONST;
		ZVAL_STR_COPY(&name_node.u.constant, name);
		value_node.op_type = IS_CV;
		value_node.u.op.var = lookup_cv(name);

		zend_op *opline = zend_emit_op(NULL,
			is_ref ? ZEND_ASSIGN_OBJ_REF : ZEND_ASSIGN_OBJ, NULL, &name_node);
		opline->extended_value = zend_alloc_cache_slots(3);
		zend_emit_op_data(&value_node);
	}
}

// the below code fragment can be found in:
// Zend/zend_attributes.h
static zend_always_inline zend_attribute *zend_add_property_attribute(zend_class_entry *ce, zend_property_info *info, zend_string *name, uint32_t argc)
{
	return zend_add_attribute(&info->attributes, ce->type != ZEND_USER_CLASS, 0, name, argc);
}

