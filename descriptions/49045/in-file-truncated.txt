/*
** numeric.c - Numeric, Integer, Float class
**
** See Copyright Notice in mruby.h
*/

#include <mruby.h>
#include <mruby/array.h>
#include <mruby/numeric.h>
#include <mruby/string.h>
#include <mruby/class.h>
#include <mruby/internal.h>
#include <mruby/presym.h>
#include <string.h>

#ifndef MRB_NO_FLOAT
#ifdef MRB_USE_FLOAT32
#define trunc(f) truncf(f)
#define fmod(x,y) fmodf(x,y)
#else
#endif
#endif

mrb_noreturn void
mrb_int_overflow(mrb_state *mrb, const char *reason)
{
  mrb_raisef(mrb, E_RANGE_ERROR, "integer overflow in %s", reason);
}

mrb_noreturn void
mrb_int_zerodiv(mrb_state *mrb)
{
  mrb_raise(mrb, E_ZERODIV_ERROR, "divided by 0");
}

static mrb_noreturn void
mrb_int_noconv(mrb_state *mrb, mrb_value y)
{
  mrb_raisef(mrb, E_TYPE_ERROR, "can't convert %Y into Integer", y);
}

/*
 * call-seq:
 *
 *  num ** other  ->  num
 *
 * Raises <code>num</code> the <code>other</code> power.
 *
 *    2.0**3      #=> 8.0
 */
mrb_value
mrb_int_pow(mrb_state *mrb, mrb_value x)
{
#ifdef MRB_USE_BIGINT
  if (mrb_bigint_p(x)) {
    mrb_value y = mrb_get_arg1(mrb);

#ifndef MRB_NO_FLOAT
    if (mrb_float_p(y)) {
      return mrb_float_value(mrb, pow(mrb_bint_as_float(mrb, x), mrb_float(y)));
    }
#endif
    return mrb_bint_pow(mrb, x, y);
  }
#endif
  mrb_int base = mrb_integer(x);
  mrb_int result = 1;
  mrb_int exp;

#ifndef MRB_NO_FLOAT
  mrb_value y = mrb_get_arg1(mrb);

  if (mrb_float_p(y)) {
    return mrb_float_value(mrb, pow((double)base, mrb_float(y)));
  }
  else if (mrb_integer_p(y)) {
    exp = mrb_integer(y);
  }
  else
#endif
  {
    mrb_get_args(mrb, "i", &exp);
  }
  if (exp < 0) {
#ifndef MRB_NO_FLOAT
    return mrb

// --- CODE TRUNCATED HERE ---

static mrb_value
int_to_s(mrb_state *mrb, mrb_value obj)
{
  // Converts an integer value to its string representation with an optional base.
  // The default base is 10 if no base is provided.
  // <MASK>
}