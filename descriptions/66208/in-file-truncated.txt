/*
** string.c - String class
**
** See Copyright Notice in mruby.h
*/

#ifdef _MSC_VER
# define _CRT_NONSTDC_NO_DEPRECATE
#endif

#include <mruby.h>
#include <mruby/array.h>
#include <mruby/class.h>
#include <mruby/range.h>
#include <mruby/string.h>
#include <mruby/numeric.h>
#include <mruby/internal.h>
#include <mruby/presym.h>
#include <string.h>

typedef struct mrb_shared_string {
  int refcnt;
  mrb_int capa;
  char *ptr;
} mrb_shared_string;

const char mrb_digitmap[] = "0123456789abcdefghijklmnopqrstuvwxyz";

#define mrb_obj_alloc_string(mrb) MRB_OBJ_ALLOC((mrb), MRB_TT_STRING, (mrb)->string_class)

#ifndef MRB_STR_LENGTH_MAX
#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__) || defined(__OpenBSD__)
#define MRB_STR_LENGTH_MAX 0
#else
#define MRB_STR_LENGTH_MAX 1048576
#endif
#endif

static void
str_check_length(mrb_state *mrb, mrb_int len)
{
  if (len < 0) {
    mrb_raise(mrb, E_ARGUMENT_ERROR, "negative (or overflowed) string size");
  }
#if MRB_STR_LENGTH_MAX != 0
  if (len > MRB_STR_LENGTH_MAX-1) {
    mrb_raisef(mrb, E_ARGUMENT_ERROR, "string too long (len=%i max=" MRB_STRINGIZE(MRB_STR_LENGTH_MAX) ")", len);
  }
#endif
}

static struct RString*
str_init_normal_capa(mrb_state *mrb, struct RString *s,
                     const char *p, mrb_int len, mrb_int capa)
{
  str_check_length(mrb, capa);
  char *dst = (char*)mrb_malloc(mrb, capa + 1);
  if (p) memcpy(dst, p, len);
  dst[len] = '\0';
  s->as.heap.ptr = dst;
  s->as.heap.len = len;
  s->as.heap.aux.capa = capa;
  RSTR_UNSET_TYPE_FLAG(s);
  return s;
}

static struct RString*
str_init_normal(mrb_state *mrb, struct RString *s, const char *p, mrb_int len)
{
  return str_init_normal_capa(mrb, s, p, len, len);
}

static struct RString*
str_init_embed(struct RString *s, const char *p, mrb_int len)
{
  mrb_assert(len >= 0);
  if (p) memcpy(RSTR_EMBED_PTR(s), p, len);
  RSTR_EMBED_PTR(s)[len] = '\0';
  RSTR_SET_TYPE_FLAG(s, EMBED);
  RSTR_SET_EMBED_LEN(s, len);
  return s;
}

static struct RString*
str_init_nofree(struct RString *s, const char *p, mrb_int len)
{
  s->as.heap.ptr = (char*)p;
  s->as.heap.len = len;
  s->as.heap.aux.capa = 0;             /* nofree */
  RSTR_SET_TYPE_FLAG(s, NOFREE);
  return s;
}

static struct RString*
str_init_shared(mrb_state *mrb, const struct RString *orig, struct RString *s, mrb_shared_string *shared)
{
  if (shared) {
    shared->refcnt++;
  }
  else {
    shared = (mrb_shared_string*)mrb_malloc(mrb, sizeof(mrb_shared_string));
    shared->refcnt = 1;
    shared->ptr = orig->as.heap.ptr;
    shared->capa = orig->as.heap.aux.capa;
  }
  s->as.heap.ptr = orig->as.heap.ptr;
  s->as.heap.len = orig->as.heap.len;
  s->as.heap.aux.shared = shared;
  RSTR_SET_TYPE_FLAG(s, SHARED);
  return s;
}

static struct RString*
str_init_fshared(const struct RString *orig, struct RString *s, struct RString *fshared)
{
  s->as.heap.ptr = orig->as.heap.ptr;
  s->as.heap.len = orig->as.heap.len;
  s->as.heap.aux.fshared = fshared;
  RSTR_SET_TYPE_FLAG(s, FSHARED);
  return s;
}

static struct RString*
str_init_modifiable(mrb_state *mrb, struct RString *s, const char *p, mrb_int len)
{
  if (RSTR_EMBEDDABLE_P(len)) {
    return str_init_embed(s, p, len);
  }
  return str_init_normal(mrb, s, p, len);
}

static struct RString*
str_new_static(mrb_state *mrb, const char *p, mrb_int len)
{
  if (RSTR_EMBEDDABLE_P(len)) {
    return str_init_embed(mrb_obj_alloc_string(mrb), p, len);
  }
  return str_init_nofree(mrb_obj_alloc_string(mrb), p, len);
}

static struct RString*
str_new(mrb_state *mrb, const char *p, mrb_int len)
{
  str_check_length(mrb, len);
  if (RSTR_EMBEDDABLE_P(len)) {
    return str_init_embed(mrb_obj_alloc_string(mrb), p, len);
  }
  if (p && mrb_ro_data_p(p)) {
    return str_init_nofree(mrb_obj_alloc_string(mrb), p, len);
  }
  return str_init_normal(mrb, mrb_obj_alloc_string(mrb), p, len);
}

MRB_API mrb_value
mrb_str_new_capa(mrb_state *mrb, mrb_int capa)
{
  struct RString *s = mrb_obj_alloc_string(mrb);

  if (RSTR_EMBEDDABLE_P(capa)) {
    s = str_init_embed(s, NULL, 0);
  }
  else {
    s = str_init_normal_capa(mrb, s, NULL, 0, capa);
  }
  return mrb_obj_value(s);
}

static void
resize_capa(mrb_state *mrb, struct RString *s, mrb_int capacity)
{
  if (RSTR_EMBED_P(s)) {
    if (!RSTR_EMBEDDABLE_P(capacity)) {
      str_init_normal_capa(mrb, s, RSTR_EMBED_PTR(s), RSTR_EMBED_LEN(s), capacity);
    }
  }
  else {
    str_check_length(mrb, capacity);
    s->as.heap.ptr = (char*)mrb_realloc(mrb, RSTR_PTR(s), capacity+1);
    s->as.heap.aux.capa = (mrb_ssize)capacity;
  }
}

MRB_API mrb_value
mrb_str_new(mrb_state *mrb, const char *p, mrb_int len)
{
  return mrb_obj_value(str_new(mrb, p, len));
}

MRB_API mrb_value
mrb_str_new_cstr(mrb_state *mrb, const char *p)
{
  struct RString *s;
  mrb_int len;

  if (p) {
    len = strlen(p);
  }
  else {
    len = 0;
  }

  s = str_new(mrb, p, len);

  return mrb_obj_value(s);
}

MRB_API mrb_value
mrb_str_new_static(mrb_state *mrb, const char *p, mrb_int len)
{
  struct RString *s = str_new_static(mrb, p, len);
  return mrb_obj_value(s);
}

static void
str_decref(mrb_state *mrb, mrb_shared_string *shared)
{
  shared->refcnt--;
  if (shared->refcnt == 0) {
    mrb_free(mrb, shared->ptr);
    mrb_free(mrb, shared);
  }
}

static void
str_modify_keep_ascii(mrb_state *mrb, struct RString *s)
{
  if (RSTR_SHARED_P(s)) {
    mrb_shared_string *shared = s->as.heap.aux.shared;

    if (shared->refcnt == 1 && s->as.heap.ptr == shared->ptr) {
      s->as.heap.aux.capa = shared->capa;
      s->as.heap.ptr[s->as.heap.len] = '\0';
      RSTR_UNSET_SHARED_FLAG(s);
      mrb_free(mrb, shared);
    }
    else {
      str_init_modifiable(mrb, s, s->as.heap.ptr, s->as.heap.len);
      str_decref(mrb, shared);
    }
  }
  else if (RSTR_NOFREE_P(s) || RSTR_FSHARED_P(s)) {
    str_init_modifiable(mrb, s, s->as.heap.ptr, s->as.heap.len);
  }
}

static void
check_null_byte(mrb_state *mrb, struct RString *str)
{
  const char *p = RSTR_PTR(str);
  if (p && memchr(p, '\0', RSTR_LEN(str))) {
    mrb_raise(mrb, E_ARGUMENT_ERROR, "string contains null byte");
  }
}

void
mrb_gc_free_str(mrb_state *mrb, struct RString *str)
{
  if (RSTR_EMBED_P(str))
    /* no code */;
  else if (RSTR_SHARED_P(str))
    str_decref(mrb, str->as.heap.aux.shared);
  else if (!RSTR_NOFREE_P(str) && !RSTR_FSHARED_P(str))
    mrb_free(mrb, str->as.heap.ptr);
}

#if defined(__i386) || defined(__i386__) || defined(_M_IX86) || \
     defined(__x86_64) || defined(__x86_64__) || defined(_M_AMD64) || \
     defined(__powerpc64__) || defined(__POWERPC__) || defined(__aarch64__) || \
     defined(__mc68020__)
# define ALIGNED_WORD_ACCESS 0
#else
# define ALIGNED_WORD_ACCESS 1
#endif

#ifdef MRB_UTF8_STRING

#define NOASCII(c) ((c) & 0x80)

#ifdef SIMPLE_SEARCH_NONASCII
/* the naive implementation. define SIMPLE_SEARCH_NONASCII, */
/* if you need it for any constraint (e.g. code size).      */
static const char*
search_nonascii(const char* p, const char *e)
{
  for (; p < e; ++p) {
    if (NOASCII(*p)) return p;
  }
  return e;
}

#elif defined(__SSE2__)
# include <emmintrin.h>

static inline const char *
search_nonascii(const char *p, const char *e)
{
  if (sizeof(__m128i) < (size_t)(e - p)) {
    if (!_mm_movemask_epi8(_mm_loadu_si128((__m128i const*)p))) {
      const intptr_t lowbits = sizeof(__m128i) - 1;
      const __m128i *s, *t;
      s = (const __m128i*)(~lowbits & ((intptr_t)p + lowbits));
      t = (const __m128i*)(~lowbits & (intptr_t)e);
      for (; s < t; ++s) {
        if (_mm_movemask_epi8(_mm_load_si128(s))) break;
      }
      p = (const char *)s;
    }
  }
  switch (e - p) {
  default:
  case 15: if (NOASCII(*p)) return p; ++p;
  case 14: if (NOASCII(*p)) return p; ++p;
  case 13: if (NOASCII(*p)) return p; ++p;
  case 12: if (NOASCII(*p)) return p; ++p;
  case 11: if (NOASCII(*p)) return p; ++p;
  case 10: if (NOASCII(*p)) return p; ++p;
  case 9:  if (NOASCII(*p)) return p; ++p;
  case 8:  if (NOASCII(*p)) return p; ++p;
  case 7:  if (NOASCII(*p)) return p; ++p;
  case 6:  if (NOASCII(*p)) return p; ++p;
  case 5:  if (NOASCII(*p)) return p; ++p;
  case 4:  if (NOASCII(*p)) return p; ++p;
  case 3:  if (NOASCII(*p)) return p; ++p;
  case 2:  if (NOASCII(*p)) return p; ++p;
  case 1:  if (NOASCII(*p)) return p; ++p;
           if (NOASCII(*p)) return p;
  }
  return e;
}

#else

#ifdef MRB_64BIT
# define NONASCII_MASK 0x8080808080808080ULL
#else /* MRB_32BIT */
# define NONASCII_MASK 0x80808080UL
#endif

static const char*
search_nonascii(const char *p, const char *e)
{
  if (e - p >= sizeof(void*)) {
#if ALIGNED_WORD_ACCESS
    if ((uintptr_t)p % sizeof(void*)) {
      int l = sizeof(void*) - (uintptr_t)p % sizeof(void*);
      p += l;
      switch (l) {
#ifdef MRB_64BIT
      case 7: if (p[-7]&0x80) return p-7;
      case 6: if (p[-6]&0x80) return p-6;
      case 5: if (p[-5]&0x80) return p-5;
      case 4: if (p[-4]&0x80) return p-4;
#endif
      case 3: if (p[-3]&0x80) return p-3;
      case 2: if (p[-2]&0x80) return p-2;
      case 1: if (p[-1]&0x80) return p-1;
      case 0: break;
      }
    }
#endif

    const uintptr_t *s = (uintptr_t*)p;
    const uintptr_t *t = (uintptr_t*)(e - (sizeof(void*)-1));

    for (;s < t; s++) {
      if (*s & NONASCII_MASK) {
        p = (const char*)s;
        if (NOASCII(p[0])) return p+0;
        if (NOASCII(p[1])) return p+1;
        if (NOASCII(p[2])) return p+2;
        if (NOASCII(p[3])) return p+3;
#ifdef MRB_64BIT
        if (NOASCII(p[4])) return p+4;
        if (NOASCII(p[5])) return p+5;
        if (NOASCII(p[6])) return p+6;
        if (NOASCII(p[7])) return p+7;
#endif
      }
    }
  }
  switch (e - p) {
  default:
#ifdef MRB_64BIT
  case 7: if (e[-7]&0x80) return e-7;
  case 6: if (e[-6]&0x80) return e-6;
  case 5: if (e[-5]&0x80) return e-5;
  case 4: if (e[-4]&0x80) return e-4;
#endif
  case 3: if (e[-3]&0x80) return e-3;
  case 2: if (e[-2]&0x80) return e-2;
  case 1: if (e[-1]&0x80) return e-1;
  }
  return e;
}

#endif  /* SIMPLE_SEARCH_NONASCII */

#define utf8_islead(c) ((unsigned char)((c)&0xc0) != 0x80)

extern const char mrb_utf8len_table[];
const char mrb_utf8len_table[] = {
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 3, 3, 4, 0
};

mrb_int
mrb_utf8len(const char* p, const char* e)
{
  mrb_int len = mrb_utf8len_table[(unsigned char)p[0] >> 3];
  if (len > e - p) return 1;
  switch (len) {
  case 0:
    return 1;
  case 4:
    if (utf8_islead(p[3])) return 1;
  case 3:
    if (utf8_islead(p[2])) return 1;
  case 2:
    if (utf8_islead(p[1])) return 1;
  }
  return len;
}

mrb_int
mrb_utf8_strlen(const char *str, mrb_int byte_len)
{
  mrb_int len = 0;
  const char *p = str;
  const char *e = p + byte_len;
  while (p < e) {
    if (utf8_islead(*p)) len++;
    p++;
  }
  return len;
}

static mrb_int
utf8_strlen(mrb_value str)
{
  struct RString *s = mrb_str_ptr(str);
  mrb_int byte_len = RSTR_LEN(s);

  if (RSTR_SINGLE_BYTE_P(s)) {
    return byte_len;
  }
  else {
    mrb_int utf8_len = mrb_utf8_strlen(RSTR_PTR(s), byte_len);
    if (byte_len == utf8_len) RSTR_SET_SINGLE_BYTE_FLAG(s);
    return utf8_len;
  }
}

#define RSTRING_CHAR_LEN(s) utf8_strlen(s)

/* map character index to byte offset index */
static mrb_int
chars2bytes(mrb_value s, mrb_int off, mrb_int idx)
{
  if (RSTR_SINGLE_BYTE_P(mrb_str_ptr(s))) {
    return idx;
  }

  const char *p0 = RSTRING_PTR(s) + off;
  const char *p = p0;
  const char *e = RSTRING_END(s);
  mrb_int i = 0;

  while (p<e && i<idx) {
    if ((*p & 0x80) == 0) {
      const char *np = search_nonascii(p, e);
      ptrdiff_t alen = np - p;
      if (idx < i+alen) {
        p += idx-i;
        i=idx;
      }
      else {
        p = np;
        i += alen;
      }
    }
    else {
      p += mrb_utf8len(p, e);
      i++;
    }
  }

  mrb_int len = (mrb_int)(p-p0);
  if (i<idx) len++;
  return len;
}

/* map byte offset to character index */
static mrb_int
bytes2chars(mrb_value s, mrb_int bi)
{
  if (RSTR_SINGLE_BYTE_P(mrb_str_ptr(s))) {
    return bi;
  }

  const char *p = RSTRING_PTR(s);
  const char *pivot = p + bi;
  mrb_int i = 0;

  if (RSTRING_END(s) < pivot) return -1;
  while (p < pivot) {
    if ((*p & 0x80) == 0) {
      const char *np = search_nonascii(p, pivot);
      i += np - p;
      p = np;
    }
    else {
      p += mrb_utf8len(p, pivot);
      i++;
    }
  }
  if (p != pivot) return -1;
  return i;
}

static const char*
char_adjust(const char *beg, const char *end, const char *ptr)
{
  ptrdiff_t len = end - ptr;
  if (len < 1 || utf8_islead(ptr[0])) return ptr;
  if (len > 1 && utf8_islead(ptr[1])) return ptr+1;
  if (len > 2 && utf8_islead(ptr[2])) return ptr+2;
  if (len > 3 && utf8_islead(ptr[3])) return ptr+3;
  return ptr;
}

static const char*
char_backtrack(const char *ptr, const char *end)
{
  ptrdiff_t len = end - ptr;
  if (len < 1 || utf8_islead(end[-1])) return end-1;
  if (len > 1 && utf8_islead(end[-2])) return end-2;
  if (len > 2 && utf8_islead(end[-3])) return end-3;
  if (len > 3 && utf8_islead(end[-4])) return end-4;
  return end - 1;
}

static mrb_int
str_index_str_by_char(mrb_state *mrb, mrb_value str, mrb_value sub, mrb_int pos)
{
  const char *ptr = RSTRING_PTR(sub);
  mrb_int len = RSTRING_LEN(sub);

  if (pos > 0) {
    pos = chars2bytes(str, 0, pos);
  }

  pos = mrb_str_index(mrb, str, ptr, len, pos);

  if (pos > 0) {
    pos = bytes2chars(str, pos);
  }
  return pos;
}

#else
#define RSTRING_CHAR_LEN(s) RSTRING_LEN(s)
#define chars2bytes(s, off, ci) (ci)
#define bytes2chars(s, bi) (bi)
#define char_adjust(beg, end, ptr) (ptr)
#define char_backtrack(ptr, end) ((end) - 1)
#define str_index_str_by_char(mrb, str, sub, pos) str_index_str((mrb), (str), (sub), (pos))
#endif

/* The function is taken from http://0x80.pl/articles/simd-strfind.html */
/* The original source code is under 2-clause BSD license; see LEGAL file.    */
/* The modifications:
   * port from C++ to C
   * takes unsigned char*
   * returns mrb_int
   * alignment adjustment added
   * support bigendian CPU
   * fixed potential buffer overflow
*/
static inline mrb_int
mrb_memsearch_ss(const unsigned char *xs, long m, const unsigned char *ys, long lengthy)
{
#ifdef MRB_64BIT
#define bitint uint64_t
#define MASK1 0x0101010101010101ull
#define MASK2 0x7f7f7f7f7f7f7f7full
#define MASK3 0x8080808080808080ull
#else
#define bitint uint32_t
#define MASK1 0x01010101ul
#define MASK2 0x7f7f7f7ful
#define MASK3 0x80808080ul
#endif
#if defined(MRB_ENDIAN_BIG)
#ifdef MRB_64BIT
#define MASK4 0x8000000000000000ull
#else
#define MASK4 0x80000000ul
#endif
#else
#define MASK4 0x80
#endif

// This function performs a substring search using a bit manipulation technique.
// It returns the byte index of the first occurrence of `xs` in `ys`.
// <MASK>

  return -1;
}<｜begin▁of▁sentence｜>

static mrb_int
mrb_memsearch(const char *x0, mrb_int m, const char *y0, mrb_int n)
{
  const unsigned char *x = (const unsigned char*)x0, *y = (const unsigned char*)y0;

  if (m > n) return -1;
  else if (m == n) {
    return memcmp(x0, y0, m) == 0 ? 0 : -1;
  }
  else if (m < 1) {
    return 0;
  }
  else if (m == 1) {
    const unsigned char *p = (const unsigned char*)memchr(y, *x, n);

    if (p) return (mrb_int)(p - y);
    return -1;
  }
  return mrb_memsearch_ss((const unsigned char*)x0, m, (const unsigned char*)y0, n);
}

static void
str_share(mrb_state *mrb, struct RString *orig, struct RString *s)
{
  size_t len = (size_t)orig->as.heap.len;

  mrb_assert(!RSTR_EMBED_P(orig));
  if (RSTR_NOFREE_P(orig)) {
    str_init_nofree(s, orig->as.heap.ptr, len);
  }
  else if (RSTR_SHARED_P(orig)) {
    str_init_shared(mrb, orig, s, orig->as.heap.aux.shared);
  }
  else if (RSTR_FSHARED_P(orig)) {
    str_init_fshared(orig, s, orig->as.heap.aux.fshared);
  }
  else {
    if (orig->as.heap.aux.capa > orig->as.heap.len) {
      orig->as.heap.ptr = (char*)mrb_realloc(mrb, orig->as.heap.ptr, len+1);
      orig->as.heap.aux.capa = (mrb_ssize)len;
    }
    str_init_shared(mrb, orig, s, NULL);
    str_init_shared(mrb, orig, orig, s->as.heap.aux.shared);
  }
}

mrb_value
mrb_str_byte_subseq(mrb_state *mrb, mrb_value str, mrb_int beg, mrb_int len)
{
  struct RString *orig, *s;

  orig = mrb_str_ptr(str);
  s = mrb_obj_alloc_string(mrb);
  if (RSTR_EMBEDDABLE_P(len)) {
    str_init_embed(s, RSTR_PTR(orig)+beg, len);
  }
  else {
    str_share(mrb, orig, s);
    s->as.heap.ptr += (mrb_ssize)beg;
    s->as.heap.len = (mrb_ssize)len;
  }
  RSTR_COPY_SINGLE_BYTE_FLAG(s, orig);
  return mrb_obj_value(s);
}

#ifdef MRB_UTF8_STRING
static inline mrb_value
str_subseq(mrb_state *mrb, mrb_value str, mrb_int beg, mrb_int len)
{
  beg = chars2bytes(str, 0, beg);
  len = chars2bytes(str, beg, len);
  return mrb_str_byte_subseq(mrb, str, beg, len);
}
#else
#define str_subseq(mrb, str, beg, len) mrb_str_byte_subseq(mrb, str, beg, len)
#endif

mrb_bool
mrb_str_beg_len(mrb_int str_len, mrb_int *begp, mrb_int *lenp)
{
  if (str_len < *begp || *lenp < 0) return FALSE;
  if (*begp < 0) {
    *begp += str_len;
    if (*begp < 0) return FALSE;
  }
  if (*lenp > str_len - *begp)
    *lenp = str_len - *begp;
  if (*lenp <= 0) {
    *lenp = 0;
  }
  return TRUE;
}

static mrb_value
str_substr(mrb_state *mrb, mrb_value str, mrb_int beg, mrb_int len)
{
  return mrb_str_beg_len(RSTRING_CHAR_LEN(str), &beg, &len) ?
    str_subseq(mrb, str, beg, len) : mrb_nil_value();
}

MRB_API mrb_int
mrb_str_index(mrb_state *mrb, mrb_value str, const char *sptr, mrb_int slen, mrb_int offset)
{
  mrb_int pos;
  char *s;
  mrb_int len;

  len = RSTRING_LEN(str);
  if (offset < 0) {
    offset += len;
    if (offset < 0) return -1;
  }
  if (len - offset < slen) return -1;
  s = RSTRING_PTR(str);
  if (offset) {
    s += offset;
  }
  if (slen == 0) return offset;
  /* need proceed one character at a time */
  len = RSTRING_LEN(str) - offset;
  pos = mrb_memsearch(sptr, slen, s, len);
  if (pos < 0) return pos;
  return pos + offset;
}

static mrb_int
str_index_str(mrb_state *mrb, mrb_value str, mrb_value str2, mrb_int offset)
{
  const char *ptr;
  mrb_int len;

  ptr = RSTRING_PTR(str2);
  len = RSTRING_LEN(str2);

  return mrb_str_index(mrb, str, ptr, len, offset);
}

static mrb_value
str_replace(mrb_state *mrb, struct RString *s1, struct RString *s2)
{
  size_t len;

  mrb_check_frozen(mrb, s1);
  if (s1 == s2) return mrb_obj_value(s1);
  RSTR_COPY_SINGLE_BYTE_FLAG(s1, s2);
  if (RSTR_SHARED_P(s1)) {
    str_decref(mrb, s1->as.heap.aux.shared);
  }
  else if (!RSTR_EMBED_P(s1) && !RSTR_NOFREE_P(s1) && !RSTR_FSHARED_P(s1)
           && s1->as.heap.ptr) {
    mrb_free(mrb, s1->as.heap.ptr);
  }

  len = (size_t)RSTR_LEN(s2);
  if (RSTR_EMBEDDABLE_P(len)) {
    str_init_embed(s1, RSTR_PTR(s2), len);
  }
  else {
    str_share(mrb, s2, s1);
  }

  return mrb_obj_value(s1);
}

static mrb_int
str_rindex(mrb_state *mrb, mrb_value str, mrb_value sub, mrb_int pos)
{
  const char *s, *sbeg, *send, *t;
  struct RString *ps = mrb_str_ptr(str);
  mrb_int len = RSTRING_LEN(sub);
  mrb_int slen = RSTR_LEN(ps);

  /* substring longer than string */
  if (slen < len) return -1;
  if (slen - pos < len) {
    pos = slen - len;
  }
  sbeg = RSTR_PTR(ps);
  send = sbeg + slen;
  s = sbeg + pos;
  t = RSTRING_PTR(sub);
  if (len) {
    s = char_adjust(sbeg, send, s);
    while (sbeg <= s) {
      if ((mrb_int)(send - s) >= len && memcmp(s, t, len) == 0) {
        return (mrb_int)(s - sbeg);
      }
      s = char_backtrack(sbeg, s);
    }
    return -1;
  }
  else {
    return pos;
  }
}

#ifdef _WIN32
#include <windows.h>

char*
mrb_utf8_from_locale(const char *str, int len)
{
  wchar_t* wcsp;
  char* mbsp;
  int mbssize, wcssize;

  if (len == 0)
    return strdup("");
  if (len == -1)
    len = (int)strlen(str);
  wcssize = MultiByteToWideChar(GetACP(), 0, str, len,  NULL, 0);
  wcsp = (wchar_t*) malloc((wcssize + 1) * sizeof(wchar_t));
  if (!wcsp)
    return NULL;
  wcssize = MultiByteToWideChar(GetACP(), 0, str, len, wcsp, wcssize + 1);
  wcsp[wcssize] = 0;

  mbssize = WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR) wcsp, -1, NULL, 0, NULL, NULL);
  mbsp = (char*) malloc((mbssize + 1));
  if (!mbsp) {
    free(wcsp);
    return NULL;
  }
  mbssize = WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR) wcsp, -1, mbsp, mbssize, NULL, NULL);
  mbsp[mbssize] = 0;
  free(wcsp);
  return mbsp;
}

char*
mrb_locale_from_utf8(const char *utf8, int len)
{
  wchar_t* wcsp;
  char* mbsp;
  int mbssize, wcssize;

  if (len == 0)
    return strdup("");
  if (len == -1)
    len = (int)strlen(utf8);
  wcssize = MultiByteToWideChar(CP_UTF8, 0, utf8, len,  NULL, 0);
  wcsp = (wchar_t*) malloc((wcssize + 1) * sizeof(wchar_t));
  if (!wcsp)
    return NULL;
  wcssize = MultiByteToWideChar(CP_UTF8, 0, utf8, len, wcsp, wcssize + 1);
  wcsp[wcssize] = 0;
  mbssize = WideCharToMultiByte(GetACP(), 0, (LPCWSTR) wcsp, -1, NULL, 0, NULL, NULL);
  mbsp = (char*) malloc((mbssize + 1));
  if (!mbsp) {
    free(wcsp);
    return NULL;
  }
  mbssize = WideCharToMultiByte(GetACP(), 0,

// --- CODE TRUNCATED HERE ---

