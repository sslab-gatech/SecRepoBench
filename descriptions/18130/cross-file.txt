// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// MagickCore/transform.c
// static inline ssize_t PixelRoundOffset(double x)
// {
//   /*
//     Round the fraction to nearest integer.
//   */
//   if ((x-floor(x)) < (ceil(x)-x))
//     return((ssize_t) floor(ConstrainPixelOffset(x)));
//   return((ssize_t) ceil(ConstrainPixelOffset(x)));
// }

// the below code fragment can be found in:
// MagickCore/pixel.c
// static inline void SplineWeights(const double x,double (*weights)[4])
// {
//   double
//     alpha,
//     beta;
// 
//   /*
//     Nicolas Robidoux' 12 flops (6* + 5- + 1+) refactoring of the computation
//     of the standard four 1D cubic B-spline smoothing weights. The sampling
//     location is assumed between the second and third input pixel locations,
//     and x is the position relative to the second input pixel location.
//   */
//   alpha=(double) 1.0-x;
//   (*weights)[3]=(double) (1.0/6.0)*x*x*x;
//   (*weights)[0]=(double) (1.0/6.0)*alpha*alpha*alpha;
//   beta=(*weights)[3]-(*weights)[0];
//   (*weights)[1]=alpha-(*weights)[0]+beta;
//   (*weights)[2]=x-(*weights)[3]-beta;
// }

// the below code fragment can be found in:
// MagickCore/statistic.c
// static int IntensityCompare(const void *x,const void *y)
// {
//   const PixelChannels
//     *color_1,
//     *color_2;
// 
//   double
//     distance;
// 
//   register ssize_t
//     i;
// 
//   color_1=(const PixelChannels *) x;
//   color_2=(const PixelChannels *) y;
//   distance=0.0;
//   for (i=0; i < MaxPixelChannels; i++)
//     distance+=color_1->channel[i]-(double) color_2->channel[i];
//   return(distance < 0 ? -1 : distance > 0 ? 1 : 0);
// }

// the below code fragment can be found in:
// MagickCore/quantize.c
// MagickExport MagickBooleanType PosterizeImage(Image *image,const size_t levels,
//   const DitherMethod dither_method,ExceptionInfo *exception)
// {
// #define PosterizeImageTag  "Posterize/Image"
// #define PosterizePixel(pixel) ClampToQuantum((MagickRealType) QuantumRange*( \
//   MagickRound(QuantumScale*pixel*(levels-1)))/MagickMax((ssize_t) levels-1,1))
// 
//   CacheView
//     *image_view;
// 
//   MagickBooleanType
//     status;
// 
//   MagickOffsetType
//     progress;
// 
//   QuantizeInfo
//     *quantize_info;
// 
//   register ssize_t
//     i;
// 
//   ssize_t
//     y;
// 
//   assert(image != (Image *) NULL);
//   assert(image->signature == MagickCoreSignature);
//   if (image->debug != MagickFalse)
//     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
//   assert(exception != (ExceptionInfo *) NULL);
//   assert(exception->signature == MagickCoreSignature);
//   if (image->storage_class == PseudoClass)
// #if defined(MAGICKCORE_OPENMP_SUPPORT)
//     #pragma omp parallel for schedule(static) shared(progress,status) \
//       magick_number_threads(image,image,image->colors,1)
// #endif
//     for (i=0; i < (ssize_t) image->colors; i++)
//     {
//       /*
//         Posterize colormap.
//       */
//       if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)
//         image->colormap[i].red=(double)
//           PosterizePixel(image->colormap[i].red);
//       if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)
//         image->colormap[i].green=(double)
//           PosterizePixel(image->colormap[i].green);
//       if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)
//         image->colormap[i].blue=(double)
//           PosterizePixel(image->colormap[i].blue);
//       if ((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0)
//         image->colormap[i].alpha=(double)
//           PosterizePixel(image->colormap[i].alpha);
//     }
//   /*
//     Posterize image.
//   */
//   status=MagickTrue;
//   progress=0;
//   image_view=AcquireAuthenticCacheView(image,exception);
// #if defined(MAGICKCORE_OPENMP_SUPPORT)
//   #pragma omp parallel for schedule(static) shared(progress,status) \
//     magick_number_threads(image,image,image->rows,1)
// #endif
//   for (y=0; y < (ssize_t) image->rows; y++)
//   {
//     register Quantum
//       *magick_restrict q;
// 
//     register ssize_t
//       x;
// 
//     if (status == MagickFalse)
//       continue;
//     q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);
//     if (q == (Quantum *) NULL)
//       {
//         status=MagickFalse;
//         continue;
//       }
//     for (x=0; x < (ssize_t) image->columns; x++)
//     {
//       if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)
//         SetPixelRed(image,PosterizePixel(GetPixelRed(image,q)),q);
//       if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)
//         SetPixelGreen(image,PosterizePixel(GetPixelGreen(image,q)),q);
//       if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)
//         SetPixelBlue(image,PosterizePixel(GetPixelBlue(image,q)),q);
//       if (((GetPixelBlackTraits(image) & UpdatePixelTrait) != 0) &&
//           (image->colorspace == CMYKColorspace))
//         SetPixelBlack(image,PosterizePixel(GetPixelBlack(image,q)),q);
//       if (((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0) &&
//           (image->alpha_trait == BlendPixelTrait))
//         SetPixelAlpha(image,PosterizePixel(GetPixelAlpha(image,q)),q);
//       q+=GetPixelChannels(image);
//     }
//     if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)
//       status=MagickFalse;
//     if (image->progress_monitor != (MagickProgressMonitor) NULL)
//       {
//         MagickBooleanType
//           proceed;
// 
// #if defined(MAGICKCORE_OPENMP_SUPPORT)
//         #pragma omp atomic
// #endif
//         progress++;
//         proceed=SetImageProgress(image,PosterizeImageTag,progress,image->rows);
//         if (proceed == MagickFalse)
//           status=MagickFalse;
//       }
//   }
//   image_view=DestroyCacheView(image_view);
//   quantize_info=AcquireQuantizeInfo((ImageInfo *) NULL);
//   quantize_info->number_colors=(size_t) MagickMin((ssize_t) levels*levels*
//     levels,MaxColormapSize+1);
//   quantize_info->dither_method=dither_method;
//   quantize_info->tree_depth=MaxTreeDepth;
//   status=QuantizeImage(quantize_info,image,exception);
//   quantize_info=DestroyQuantizeInfo(quantize_info);
//   return(status);
// }

// the below code fragment can be found in:
// MagickCore/feature.c
// static Image *RenderHoughLines(const ImageInfo *image_info,const size_t columns,
//   const size_t rows,ExceptionInfo *exception)
// {
// #define BoundingBox  "viewbox"
// 
//   DrawInfo
//     *draw_info;
// 
//   Image
//     *image;
// 
//   MagickBooleanType
//     status;
// 
//   /*
//     Open image.
//   */
//   image=AcquireImage(image_info,exception);
//   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
//   if (status == MagickFalse)
//     {
//       image=DestroyImageList(image);
//       return((Image *) NULL);
//     }
//   image->columns=columns;
//   image->rows=rows;
//   draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);
//   draw_info->affine.sx=image->resolution.x == 0.0 ? 1.0 : image->resolution.x/
//     DefaultResolution;
//   draw_info->affine.sy=image->resolution.y == 0.0 ? 1.0 : image->resolution.y/
//     DefaultResolution;
//   image->columns=(size_t) (draw_info->affine.sx*image->columns);
//   image->rows=(size_t) (draw_info->affine.sy*image->rows);
//   status=SetImageExtent(image,image->columns,image->rows,exception);
//   if (status == MagickFalse)
//     return(DestroyImageList(image));
//   if (SetImageBackgroundColor(image,exception) == MagickFalse)
//     {
//       image=DestroyImageList(image);
//       return((Image *) NULL);
//     }
//   /*
//     Render drawing.
//   */
//   if (GetBlobStreamData(image) == (unsigned char *) NULL)
//     draw_info->primitive=FileToString(image->filename,~0UL,exception);
//   else
//     {
//       draw_info->primitive=(char *) AcquireMagickMemory((size_t)
//         GetBlobSize(image)+1);
//       if (draw_info->primitive != (char *) NULL)
//         {
//           (void) memcpy(draw_info->primitive,GetBlobStreamData(image),
//             (size_t) GetBlobSize(image));
//           draw_info->primitive[GetBlobSize(image)]='\0';
//         }
//      }
//   (void) DrawImage(image,draw_info,exception);
//   draw_info=DestroyDrawInfo(draw_info);
//   (void) CloseBlob(image);
//   return(GetFirstImageInList(image));
// }

