// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// wolfcrypt/src/tfm.c
int mp_read_radix(mp_int *a, const char *str, int radix)
{
    return fp_read_radix(a, str, radix);
}

// the below code fragment can be found in:
// wolfcrypt/src/integer.c
int mp_radix_size (mp_int *a, int radix, int *size)
{
    int     res, digs;
    mp_int  t;
    mp_digit d;

    *size = 0;

    /* special case for binary */
    if (radix == MP_RADIX_BIN) {
        *size = mp_count_bits (a) + (a->sign == MP_NEG ? 1 : 0) + 1;
        return MP_OKAY;
    }

    /* make sure the radix is in range */
    if (radix < MP_RADIX_BIN || radix > MP_RADIX_MAX) {
        return MP_VAL;
    }

    if (mp_iszero(a) == MP_YES) {
        *size = 2;
        return MP_OKAY;
    }

    /* digs is the digit count */
    digs = 0;

    /* init a copy of the input */
    if ((res = mp_init_copy (&t, a)) != MP_OKAY) {
        return res;
    }

    /* force temp to positive */
    t.sign = MP_ZPOS;

    /* fetch out all of the digits */
    while (mp_iszero (&t) == MP_NO) {
        if ((res = mp_div_d (&t, (mp_digit) radix, &t, &d)) != MP_OKAY) {
            mp_clear (&t);
            return res;
        }
        ++digs;
    }
    mp_clear (&t);

#ifndef WC_DISABLE_RADIX_ZERO_PAD
    /* For hexadecimal output, add zero padding when number of digits is odd */
    if ((digs & 1) && (radix == 16)) {
        ++digs;
    }
#endif

    /* if it's negative add one for the sign */
    if (a->sign == MP_NEG) {
        ++digs;
    }

    /* return digs + 1, the 1 is for the NULL byte that would be required. */
    *size = digs + 1;
    return MP_OKAY;
}

// the below code fragment can be found in:
// wolfcrypt/src/sp_int.c
int sp_cmp(sp_int* a, sp_int* b)
{
    int ret = MP_EQ;
    int i;

    if (a->used > b->used)
        ret = MP_GT;
    else if (a->used < b->used)
        ret = MP_LT;
    else {
        for (i = a->used - 1; i >= 0; i--) {
            if (a->dp[i] > b->dp[i]) {
                ret = MP_GT;
                break;
            }
            else if (a->dp[i] < b->dp[i]) {
                ret = MP_LT;
                break;
            }
        }
    }
    return ret;
}

// the below code fragment can be found in:
// wolfcrypt/src/tfm.c
void mp_dump(const char* desc, mp_int* a, byte verbose)
{
  char buffer[FP_SIZE * sizeof(fp_digit) * 2];
  int size;

#if defined(ALT_ECC_SIZE) || defined(HAVE_WOLF_BIGINT)
  size = a->size;
#else
  size = FP_SIZE;
#endif

  printf("%s: ptr=%p, used=%d, sign=%d, size=%d, fpd=%d\n",
    desc, a, a->used, a->sign, size, (int)sizeof(fp_digit));

  mp_tohex(a, buffer);
  printf("  %s\n  ", buffer);

  if (verbose) {
    int i;
    for(i=0; i<size * (int)sizeof(fp_digit); i++) {
      printf("%x ", *(((byte*)a->dp) + i));
    }
    printf("\n");
  }
}

// the below code fragment can be found in:
// wolfcrypt/src/tfm.c
void fp_div_2(fp_int * a, fp_int * b)
{
  int     x, oldused;

  oldused = b->used;
  b->used = a->used;
  {
    fp_digit r, rr, *tmpa, *tmpb;

    /* source alias */
    tmpa = a->dp + b->used - 1;

    /* dest alias */
    tmpb = b->dp + b->used - 1;

    /* carry */
    r = 0;
    for (x = b->used - 1; x >= 0; x--) {
      /* get the carry for the next iteration */
      rr = *tmpa & 1;

      /* shift the current digit, add in carry and store */
      *tmpb-- = (*tmpa-- >> 1) | (r << (DIGIT_BIT - 1));

      /* forward carry to next iteration */
      r = rr;
    }

    /* zero any excess digits on the destination that we didn't write to */
    tmpb = b->dp + b->used;
    for (x = b->used; x < oldused; x++) {
      *tmpb++ = 0;
    }
  }
  b->sign = a->sign;
  fp_clamp (b);
}

