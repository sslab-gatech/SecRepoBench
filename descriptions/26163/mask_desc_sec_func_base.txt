static int fp_read_radix_16(fp_int *a, const char *str)
{
  int     i, j, k, neg;
  char    ch;

  /* if the leading digit is a
   * minus set the sign to negative.
   */
  if (*str == '-') {
    ++str;
    neg = FP_NEG;
  } else {
    neg = FP_ZPOS;
  }

  j = 0;
  k = 0;
  for (i = (int)(XSTRLEN(str) - 1); i >= 0; i--) {
      ch = str[i];
      if (ch >= '0' && ch <= '9')
          ch -= (char)'0';
      else if (ch >= 'A' && ch <= 'F')
          ch -= (char)'A' - 10;
      else if (ch >= 'a' && ch <= 'f')
          ch -= (char)'a' - 10;
      else
          return FP_VAL;

      // Convert the hexadecimal digit character to its numeric value and incorporate it
      // into the multi-precision integer representation by updating the appropriate
      // position in the digit array. Adjust the bit position and array index as necessary.
      // Return an error if the size exceeds the maximum allowed digits.
      // <MASK>
  }

  a->used = k + 1;
  fp_clamp(a);
  /* set the sign only if a != 0 */
  if (fp_iszero(a) != FP_YES) {
     a->sign = neg;
  }
  return FP_OKAY;
}