// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/softmagic.c
private uint32_t
cvt_id3(struct magic_set *ms, uint32_t v)
{
	v = ((((v >>  0) & 0x7f) <<  0) |
	     (((v >>  8) & 0x7f) <<  7) |
	     (((v >> 16) & 0x7f) << 14) |
	     (((v >> 24) & 0x7f) << 21));
	if ((ms->flags & MAGIC_DEBUG) != 0)
		fprintf(stderr, "id3 offs=%u\n", v);
	return v;
}

// the below code fragment can be found in:
// src/softmagic.c
private uint64_t
file_strncmp(const char *s1, const char *s2, size_t len, uint32_t flags)
{
	/*
	 * Convert the source args to unsigned here so that (1) the
	 * compare will be unsigned as it is in strncmp() and (2) so
	 * the ctype functions will work correctly without extra
	 * casting.
	 */
	const unsigned char *a = (const unsigned char *)s1;
	const unsigned char *b = (const unsigned char *)s2;
	const unsigned char *eb = b + len;
	uint64_t v;

	/*
	 * What we want here is v = strncmp(s1, s2, len),
	 * but ignoring any nulls.
	 */
	v = 0;
	if (0L == flags) { /* normal string: do it fast */
		while (len-- > 0)
			if ((v = *b++ - *a++) != '\0')
				break;
	}
	else { /* combine the others */
		while (len-- > 0) {
			if (b >= eb) {
				v = 1;
				break;
			}
			if ((flags & STRING_IGNORE_LOWERCASE) &&
			    islower(*a)) {
				if ((v = tolower(*b++) - *a++) != '\0')
					break;
			}
			else if ((flags & STRING_IGNORE_UPPERCASE) &&
			    isupper(*a)) {
				if ((v = toupper(*b++) - *a++) != '\0')
					break;
			}
			else if ((flags & STRING_COMPACT_WHITESPACE) &&
			    isspace(*a)) {
				a++;
				if (isspace(*b++)) {
					if (!isspace(*a))
						while (b < eb && isspace(*b))
							b++;
				}
				else {
					v = 1;
					break;
				}
			}
			else if ((flags & STRING_COMPACT_OPTIONAL_WHITESPACE) &&
			    isspace(*a)) {
				a++;
				while (b < eb && isspace(*b))
					b++;
			}
			else {
				if ((v = *b++ - *a++) != '\0')
					break;
			}
		}
	}
	return v;
}

// the below code fragment can be found in:
// src/der.c
int
der_cmp(struct magic_set *ms, struct magic *m)
{
	const uint8_t *b = RCAST(const uint8_t *, ms->search.s);
	const char *s = m->value.s;
	size_t offs = 0, len = ms->search.s_len;
	uint32_t tag, tlen;
	char buf[128];

	tag = gettag(b, &offs, len);
	if (tag == DER_BAD)
		return -1;

	tlen = getlength(b, &offs, len);
	if (tlen == DER_BAD)
		return -1;

	der_tag(buf, sizeof(buf), tag);
	if ((ms->flags & MAGIC_DEBUG) != 0)
		fprintf(stderr, "%s: tag %p got=%s exp=%s\n", __func__, b,
		    buf, s);
	size_t slen = strlen(buf);

	if (strncmp(buf, s, slen) != 0)
		return 0;

	s += slen;

again:
	switch (*s) {
	case '\0':
		return 1;
	case '=':
		s++;
		goto val;
	default:
		if (!isdigit((unsigned char)*s))
			return 0;

		slen = 0;
		do
			slen = slen * 10 + *s - '0';
		while (isdigit((unsigned char)*++s));
		if ((ms->flags & MAGIC_DEBUG) != 0)
			fprintf(stderr, "%s: len %zu %u\n", __func__,
			    slen, tlen);
		if (tlen != slen)
			return 0;
		goto again;
	}
val:
	DPRINTF(("%s: before data %zu %u\n", __func__, offs, tlen));
	der_data(buf, sizeof(buf), tag, b + offs, tlen);
	if ((ms->flags & MAGIC_DEBUG) != 0)
		fprintf(stderr, "%s: data %s %s\n", __func__, buf, s);
	if (strcmp(buf, s) != 0 && strcmp("x", s) != 0)
		return 0;
	strlcpy(ms->ms_value.s, buf, sizeof(ms->ms_value.s));
	return 1;
}

// the below code fragment can be found in:
// src/softmagic.c
private int
moffset(struct magic_set *ms, struct magic *m, size_t nbytes, int32_t *op)
{
	int32_t o;

  	switch (m->type) {
  	case FILE_BYTE:
		o = CAST(int32_t, (ms->offset + sizeof(char)));
		break;

  	case FILE_SHORT:
  	case FILE_BESHORT:
  	case FILE_LESHORT:
		o = CAST(int32_t, (ms->offset + sizeof(short)));
		break;

  	case FILE_LONG:
  	case FILE_BELONG:
  	case FILE_LELONG:
  	case FILE_MELONG:
		o = CAST(int32_t, (ms->offset + sizeof(int32_t)));
		break;

  	case FILE_QUAD:
  	case FILE_BEQUAD:
  	case FILE_LEQUAD:
		o = CAST(int32_t, (ms->offset + sizeof(int64_t)));
		break;

  	case FILE_STRING:
  	case FILE_PSTRING:
  	case FILE_BESTRING16:
  	case FILE_LESTRING16:
		if (m->reln == '=' || m->reln == '!') {
			o = ms->offset + m->vallen;
		} else {
			union VALUETYPE *p = &ms->ms_value;

			if (*m->value.s == '\0')
				p->s[strcspn(p->s, "\r\n")] = '\0';
			o = CAST(uint32_t, (ms->offset + strlen(p->s)));
			if (m->type == FILE_PSTRING)
				o += (uint32_t)file_pstring_length_size(m);
		}
		break;

	case FILE_DATE:
	case FILE_BEDATE:
	case FILE_LEDATE:
	case FILE_MEDATE:
		o = CAST(int32_t, (ms->offset + sizeof(uint32_t)));
		break;

	case FILE_LDATE:
	case FILE_BELDATE:
	case FILE_LELDATE:
	case FILE_MELDATE:
		o = CAST(int32_t, (ms->offset + sizeof(uint32_t)));
		break;

	case FILE_QDATE:
	case FILE_BEQDATE:
	case FILE_LEQDATE:
		o = CAST(int32_t, (ms->offset + sizeof(uint64_t)));
		break;

	case FILE_QLDATE:
	case FILE_BEQLDATE:
	case FILE_LEQLDATE:
		o = CAST(int32_t, (ms->offset + sizeof(uint64_t)));
		break;

  	case FILE_FLOAT:
  	case FILE_BEFLOAT:
  	case FILE_LEFLOAT:
		o = CAST(int32_t, (ms->offset + sizeof(float)));
		break;

  	case FILE_DOUBLE:
  	case FILE_BEDOUBLE:
  	case FILE_LEDOUBLE:
		o = CAST(int32_t, (ms->offset + sizeof(double)));
		break;

	case FILE_REGEX:
		if ((m->str_flags & REGEX_OFFSET_START) != 0)
			o = CAST(int32_t, ms->search.offset);
		else
			o = CAST(int32_t,
			    (ms->search.offset + ms->search.rm_len));
		break;

	case FILE_SEARCH:
		if ((m->str_flags & REGEX_OFFSET_START) != 0)
			o = CAST(int32_t, ms->search.offset);
		else
			o = CAST(int32_t, (ms->search.offset + m->vallen));
		break;

	case FILE_CLEAR:
	case FILE_DEFAULT:
	case FILE_INDIRECT:
		o = ms->offset;
		break;

	case FILE_DER:
		{
			o = der_offs(ms, m, nbytes);
			if (o == -1 || (size_t)o > nbytes) {
				if ((ms->flags & MAGIC_DEBUG) != 0) {
					(void)fprintf(stderr,
					    "Bad DER offset %d nbytes=%zu",
					    o, nbytes);
				}
				*op = 0;
				return 0;
			}
			break;
		}

	default:
		o = 0;
		break;
	}

	if ((size_t)o > nbytes) {
#if 0
		file_error(ms, 0, "Offset out of range %zu > %zu",
		    (size_t)o, nbytes);
#endif
		return -1;
	}
	*op = o;
	return 1;
}

// the below code fragment can be found in:
// src/softmagic.c
private int
handle_annotation(struct magic_set *ms, struct magic *m, int firstline)
{
	if ((ms->flags & MAGIC_APPLE) && m->apple[0]) {
		if (!firstline && file_printf(ms, "\n- ") == -1)
			return -1;
		if (file_printf(ms, "%.8s", m->apple) == -1)
			return -1;
		return 1;
	}
	if ((ms->flags & MAGIC_EXTENSION) && m->ext[0]) {
		if (!firstline && file_printf(ms, "\n- ") == -1)
			return -1;
		if (file_printf(ms, "%s", m->ext) == -1)
			return -1;
		return 1;
	}
	if ((ms->flags & MAGIC_MIME_TYPE) && m->mimetype[0]) {
		if (!firstline && file_printf(ms, "\n- ") == -1)
			return -1;
		if (file_printf(ms, "%s", m->mimetype) == -1)
			return -1;
		return 1;
	}
	return 0;
}

