// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/tools/unmunch.cxx
void pfx_add(const char* word, int len, struct affent* ep, int num) {
  struct affent* aent;
  int cond;
  unsigned char* cp;
  int i;

  for (aent = ep, i = num; i > 0; aent++, i--) {
    /* now make sure all conditions match */
    if ((len + fullstrip > aent->stripl) && (len >= aent->numconds) &&
        ((aent->stripl == 0) ||
         (strncmp(aent->strip, word, aent->stripl) == 0))) {
      cp = (unsigned char*)word;
      for (cond = 0; cond < aent->numconds; cond++) {
        if ((aent->conds[*cp++] & (1 << cond)) == 0)
          break;
      }
      if (cond >= aent->numconds) {
        std::string tword;
        /* we have a match so add prefix */
        if (aent->appndl) {
          tword.append(aent->appnd);
        }
        tword.append(word + aent->stripl);

        if (numwords < MAX_WORDS) {
          wlist[numwords].word = mystrdup(tword.c_str());
          wlist[numwords].pallow = 0;
          numwords++;
        }
      }
    }
  }
}

// the below code fragment can be found in:
// src/tools/munch.cxx
void pfx_add(const char* word, int len, struct affent* ep, int num) {
  struct affent* aent;
  int cond;
  unsigned char* cp;
  int i;
  char* pp;
  char tword[MAX_WD_LEN];

  for (aent = ep, i = num; i > 0; aent++, i--) {
    /* now make sure all conditions match */
    if ((len > aent->stripl) && (len >= aent->numconds)) {
      cp = (unsigned char*)word;
      for (cond = 0; cond < aent->numconds; cond++) {
        if ((aent->conds[*cp++] & (1 << cond)) == 0)
          break;
      }
      if (cond >= aent->numconds) {
        /* we have a match so add prefix */
        int tlen = 0;
        if (aent->appndl) {
          strncpy(tword, aent->appnd, MAX_WD_LEN - 1);
          tword[MAX_WD_LEN - 1] = '\0';
          tlen += aent->appndl;
        }
        pp = tword + tlen;
        strcpy(pp, (word + aent->stripl));

        if (numwords < MAX_WORDS) {
          wlist[numwords].word = mystrdup(tword);
          wlist[numwords].pallow = 0;
          numwords++;
        }
      }
    }
  }
}

// the below code fragment can be found in:
// src/hunspell/affixmgr.cxx
inline int AffixMgr::candidate_check(const std::string& word) {

  struct hentry* rv = lookup(word.c_str(), word.size());
  if (rv)
    return 1;

  //  rv = prefix_check(word,0,len,1);
  //  if (rv) return 1;

  rv = affix_check(word, 0, word.size());
  if (rv)
    return 1;
  return 0;
}

// the below code fragment can be found in:
// src/hunspell/hashmgr.cxx
int HashMgr::add_with_affix(const std::string& word, const std::string& example) {
  // detect captype and modify word length for UTF-8 encoding
  struct hentry* dp = lookup(example.c_str(), example.size());
  remove_forbidden_flag(word);
  if (dp && dp->astr) {
    int captype;
    int wcl = get_clen_and_captype(word, &captype);
    if (!aliasf.empty()) {
      add_word(word, wcl, dp->astr, dp->alen, NULL, false, captype);
    } else {
      auto flags = new unsigned short[dp->alen];
      memcpy(flags, dp->astr, dp->alen * sizeof(unsigned short));
      add_word(word, wcl, flags, dp->alen, NULL, false, captype);
    }
    return add_hidden_capitalized_word(word, wcl, dp->astr,
                                       dp->alen, NULL, captype);
  }
  return 1;
}

// the below code fragment can be found in:
// src/tools/unmunch.cxx
void suf_add(const char* word, int len, struct affent* ep, int num) {
  struct affent* aent;
  int cond;
  unsigned char* cp;
  int i;

  for (aent = ep, i = num; i > 0; aent++, i--) {
    /* if conditions hold on root word
     * then strip off strip string and add suffix
     */

    if ((len + fullstrip > aent->stripl) && (len >= aent->numconds) &&
        ((aent->stripl == 0) ||
         (strcmp(aent->strip, word + len - aent->stripl) == 0))) {
      cp = (unsigned char*)(word + len);
      for (cond = aent->numconds; --cond >= 0;) {
        if ((aent->conds[*--cp] & (1 << cond)) == 0)
          break;
      }
      if (cond < 0) {
        /* we have a matching condition */
        std::string tword(word);
        tword.resize(len - aent->stripl);
        tword.append(aent->appnd);

        if (numwords < MAX_WORDS) {
          wlist[numwords].word = mystrdup(tword.c_str());
          wlist[numwords].pallow = (aent->xpflg & XPRODUCT);
          numwords++;
        }
      }
    }
  }
}

