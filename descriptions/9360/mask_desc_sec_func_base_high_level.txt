static SplayTreeInfo *GetMVGMacros(const char *primitive)
{
  char
    *token;

  const char
    *q;

  size_t
    extent;

  SplayTreeInfo
    *macros;

  /*
    Scan graphic primitives for definitions and classes.
  */
  if (primitive == (const char *) NULL)
    return((SplayTreeInfo *) NULL);
  macros=NewSplayTree(CompareSplayTreeString,RelinquishMagickMemory,
    RelinquishMagickMemory);
  token=AcquireString(primitive);
  extent=strlen(token)+MagickPathExtent;
  for (q=primitive; *q != '\0'; )
  {
    GetNextToken(q,&q,extent,token);
    if (*token == '\0')
      break;
    if (*token == '#')
      {
        /*
          Skip comment.
        */
        while ((*q != '\n') && (*q != '\0'))
          q++;
        continue;
      }
    if (LocaleCompare("push",token) == 0)
      {
        register const char
          *end,
          *start;

        GetNextToken(q,&q,extent,token);
        if (*q == '"')
          {
            char
              name[MagickPathExtent];

            const char
              *p;

            ssize_t
             n;

            /*
              Named macro (e.g. push graphic-context "wheel").
            */
            GetNextToken(q,&q,extent,token);
            start=q;
            // Extract a named macro definition from the string starting at 'start' and
            // ending at 'end', and add it to the 'macros' splay tree with the macro name
            // as the key. The extraction loop processes tokens between the initial "push"
            // and a corresponding "pop", skipping comments and counting nested "push"
            // and "pop" commands to handle nested structures correctly. Once a matching
            // "pop" is found and the nesting level falls below zero, the macro is extracted
            // and stored in the tree.
            // <MASK>
          }
      }
  }
  token=DestroyString(token);
  return(macros);
}