// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/flb_config_map.c
struct mk_list *flb_config_map_create(struct flb_config *config,
                                      struct flb_config_map *map)
{
    int ret;
    flb_sds_t env;
    struct mk_list *tmp;
    struct mk_list *list;
    struct flb_config_map *new = NULL;
    struct flb_config_map *m;

    list = flb_malloc(sizeof(struct mk_list));
    if (!list) {
        flb_errno();
        return NULL;
    }
    mk_list_init(list);

    /*
     * Read every property defined in the config map and create a new dynamic list
     * with the same content.
     *
     * As an additional step, it populate the 'value' field using the given default
     * value if any. Note that default values are strings so they are processed
     * to fit into the proper data type of 'value'.
     */
    m = map;
    while (m && m->name) {
        /* Allocate map node */
        new = flb_calloc(1, sizeof(struct flb_config_map));
        if (!new) {
            flb_errno();
            flb_config_map_destroy(list);
            return NULL;
        }

        new->type = m->type;
        new->name = flb_sds_create(m->name);

        /* Translate default value */
        if (m->def_value) {
            /*
             * Before to translate any value, make sure to disable the warning
             * about unused variables. This might happen if a default value is an
             * environment variable and the user is not using it (which is ok for
             * that specific use case).
             */
            flb_env_warn_unused(config->env, FLB_FALSE);

            /* Translate the value */
            env = flb_env_var_translate(config->env, m->def_value);
            new->def_value = env;
            flb_env_warn_unused(config->env, FLB_TRUE);
        }

        new->flags = m->flags;
        new->set_property = m->set_property;
        new->offset = m->offset;
        new->value.mult = NULL;
        mk_list_add(&new->_head, list);

        if (new->set_property == FLB_FALSE) {
            m++;
            continue;
        }

        /* If this is a multiple type of entries, initialize the main list */
        if (new->flags & FLB_CONFIG_MAP_MULT) {
            tmp = flb_malloc(sizeof(struct mk_list));
            if (!tmp) {
                flb_errno();
                flb_config_map_destroy(list);
                return NULL;
            }
            mk_list_init(tmp);
            new->value.mult = tmp;
        }

        /*
         * If there is no default value or the entry will not be set,  just
         * continue with the next map entry
         */
        if (!m->def_value) {
            m++;
            continue;
        }

        /* Assign value based on data type and multiple mode if set */
        ret = translate_default_value(new, new->def_value);
        if (ret == -1) {
            flb_config_map_destroy(list);
            return NULL;
        }
        m++;
    }

    return list;
}

// the below code fragment can be found in:
// src/flb_config_map.c
int flb_config_map_properties_check(char *context_name,
                                    struct mk_list *in_properties,
                                    struct mk_list *map)
{
    int len;
    int found;
    int count = 0;
    int ret;
    flb_sds_t helper;
    struct flb_kv *kv;
    struct mk_list *head;
    struct mk_list *m_head;
    struct flb_config_map *m;

    /* Iterate all incoming property list */
    mk_list_foreach(head, in_properties) {
        kv = mk_list_entry(head, struct flb_kv, _head);
        found = FLB_FALSE;


        ret = is_internal_debug_property(kv->key);
        if (ret == FLB_TRUE) {
            /* Skip the config map */
            continue;
        }

        /* Lookup the key into the provided map */
        mk_list_foreach(m_head, map) {
            m = mk_list_entry(m_head, struct flb_config_map, _head);

            len = flb_sds_len(m->name);
            if (m->type != FLB_CONFIG_MAP_STR_PREFIX) {
                if (len != flb_sds_len(kv->key)) {
                    continue;
                }
            }

            if (strncasecmp(kv->key, m->name, len) == 0) {
                if (m->type == FLB_CONFIG_MAP_STR_PREFIX) {
                    if (flb_sds_len(kv->key) <= len) {
                        flb_error("[config] incomplete prefixed key '%s'", kv->key);
                        found = FLB_FALSE;
                        break;
                    }
                }
                found = FLB_TRUE;
                break;
            }
        }

        if (found == FLB_FALSE) {
            helper = helper_map_options(map);
            if (!helper) {
                flb_error("[config] %s: unknown configuration property '%s'",
                          context_name, kv->key);
            }
            else {
                flb_error("[config] %s: unknown configuration property '%s'. %s",
                          context_name, kv->key, helper);
                flb_sds_destroy(helper);
            }

            return -1;
        }

        /* Validate number of times the property is set */
        count = property_count(kv->key, flb_sds_len(kv->key), in_properties);
        if ((m->flags & FLB_CONFIG_MAP_MULT) == 0) {
            if (count > 1) {
                flb_error("[config] %s: configuration property '%s' is set %i times",
                          context_name, kv->key, count);
                return -1;
            }
        }
    }

    return 0;
}

// the below code fragment can be found in:
// src/flb_config_map.c
static int translate_default_value(struct flb_config_map *map, char *val)
{
    int ret;
    struct flb_config_map_val *entry = NULL;
    struct mk_list *list = NULL;

    /* Prepare contexts if the map allows multiple entries */
    if (map->flags & FLB_CONFIG_MAP_MULT) {
        entry = flb_calloc(1, sizeof(struct flb_config_map_val));
        if (!entry) {
            flb_errno();
            /*
             * do not worry about 'list' allocation, it will be destroyed by the caller
             * when it catches this error
             */
            return -1;
        }
    }
    else {
        entry = &map->value;
    }

    /* Based on specific data types, populate 'value' */
    if (map->type == FLB_CONFIG_MAP_STR) {
        /* Duplicate string as a flb_sds_t */
        entry->val.str = flb_sds_create(val);

        /* Validate new memory allocation */
        if (!entry->val.str) {
            goto error;
        }
    }
    else if (map->type == FLB_CONFIG_MAP_STR_PREFIX) {
        /*
         * For prefixed string types we don't process them, just validate
         * that no default value has been set.
         */
        if (val) {
            flb_error("[config map] invalid default value for prefixed string '%s'",
                      map->name);
            goto error;
        }
    }
    else if (map->type == FLB_CONFIG_MAP_BOOL) {
        ret = flb_utils_bool(val);
        if (ret == -1) {
            flb_error("[config map] invalid default value for boolean '%s=%s'",
                      map->name, val);
            goto error;
        }
        entry->val.boolean = flb_utils_bool(val);
    }
    else if (map->type == FLB_CONFIG_MAP_INT) {
        entry->val.i_num = atoi(val);
    }
    else if (map->type == FLB_CONFIG_MAP_DOUBLE) {
        entry->val.d_num = atof(val);
    }
    else if (map->type == FLB_CONFIG_MAP_SIZE) {
        entry->val.s_num = flb_utils_size_to_bytes(val);
    }
    else if (map->type == FLB_CONFIG_MAP_TIME) {
        entry->val.i_num = flb_utils_time_to_seconds(val);
    }
    else if (map->type >= FLB_CONFIG_MAP_CLIST &&
             map->type <= FLB_CONFIG_MAP_SLIST_4) {

        list = parse_string_map_to_list(map, val);
        if (!list) {
            flb_error("[config map] cannot parse list of values '%s'", val);
            goto error;
        }

        entry->val.list = list;
        list = NULL;
    }

    if (map->flags & FLB_CONFIG_MAP_MULT) {
        mk_list_add(&entry->_head, map->value.mult);
    }

    return 0;

 error:
    if (map->flags & FLB_CONFIG_MAP_MULT) {
        flb_free(entry);
    }
    return -1;
}

// the below code fragment can be found in:
// src/flb_config_map.c
void flb_config_map_destroy(struct mk_list *list)
{
    struct mk_list *tmp;
    struct mk_list *head;
    struct mk_list *v_head;
    struct mk_list *v_tmp;
    struct flb_config_map *map;
    struct flb_config_map_val *entry;

    mk_list_foreach_safe(head, tmp, list) {
        map = mk_list_entry(head, struct flb_config_map, _head);
        mk_list_del(&map->_head);

        if (map->flags & FLB_CONFIG_MAP_MULT && map->value.mult) {
            mk_list_foreach_safe(v_head, v_tmp, map->value.mult) {
                entry = mk_list_entry(v_head, struct flb_config_map_val, _head);
                mk_list_del(&entry->_head);
                destroy_map_val(map->type, entry);
                flb_free(entry);
            }
            flb_free(map->value.mult);
        }
        else {
            destroy_map_val(map->type, &map->value);
        }
        if (map->def_value) {
            flb_sds_destroy(map->def_value);
        }
        flb_sds_destroy(map->name);
        flb_free(map);
    }
    flb_free(list);
}

// the below code fragment can be found in:
// src/flb_config_map.c
static int properties_override_default(struct mk_list *properties, char *name)
{
    int len;
    struct mk_list *head;
    struct flb_kv *kv;

    len = strlen(name);

    mk_list_foreach(head, properties) {
        kv = mk_list_entry(head, struct flb_kv, _head);
        if (flb_sds_len(kv->key) != len) {
            continue;
        }

        if (strcasecmp(kv->key, name) == 0) {
            return FLB_TRUE;
        }
    }

    return FLB_FALSE;
}

