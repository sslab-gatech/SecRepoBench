// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/cmstypes.c
// static
// void *Type_LUT8_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)
// {
//     cmsUInt8Number InputChannels, OutputChannels, CLUTpoints;
//     cmsUInt8Number* Temp = NULL;
//     cmsPipeline* NewLUT = NULL;
//     cmsUInt32Number nTabSize, i;
//     cmsFloat64Number Matrix[3*3];
// 
//     *nItems = 0;
// 
//     if (!_cmsReadUInt8Number(io, &InputChannels)) goto Error;
//     if (!_cmsReadUInt8Number(io, &OutputChannels)) goto Error;
//     if (!_cmsReadUInt8Number(io, &CLUTpoints)) goto Error;
// 
//      if (CLUTpoints == 1) goto Error; // Impossible value, 0 for no CLUT and then 2 at least
// 
//     // Padding
//     if (!_cmsReadUInt8Number(io, NULL)) goto Error;
// 
//     // Do some checking
//     if (InputChannels == 0 || InputChannels > cmsMAXCHANNELS)  goto Error;
//     if (OutputChannels == 0 || OutputChannels > cmsMAXCHANNELS) goto Error;
// 
//    // Allocates an empty Pipeline
//     NewLUT = cmsPipelineAlloc(self ->ContextID, InputChannels, OutputChannels);
//     if (NewLUT == NULL) goto Error;
// 
//     // Read the Matrix
//     if (!_cmsRead15Fixed16Number(io,  &Matrix[0])) goto Error;
//     if (!_cmsRead15Fixed16Number(io,  &Matrix[1])) goto Error;
//     if (!_cmsRead15Fixed16Number(io,  &Matrix[2])) goto Error;
//     if (!_cmsRead15Fixed16Number(io,  &Matrix[3])) goto Error;
//     if (!_cmsRead15Fixed16Number(io,  &Matrix[4])) goto Error;
//     if (!_cmsRead15Fixed16Number(io,  &Matrix[5])) goto Error;
//     if (!_cmsRead15Fixed16Number(io,  &Matrix[6])) goto Error;
//     if (!_cmsRead15Fixed16Number(io,  &Matrix[7])) goto Error;
//     if (!_cmsRead15Fixed16Number(io,  &Matrix[8])) goto Error;
// 
// 
//     // Only operates if not identity...
//     if ((InputChannels == 3) && !_cmsMAT3isIdentity((cmsMAT3*) Matrix)) {
// 
//         if (!cmsPipelineInsertStage(NewLUT, cmsAT_BEGIN, cmsStageAllocMatrix(self ->ContextID, 3, 3, Matrix, NULL)))
//             goto Error;
//     }
// 
//     // Get input tables
//     if (!Read8bitTables(self ->ContextID, io,  NewLUT, InputChannels)) goto Error;
// 
//     // Get 3D CLUT. Check the overflow....
//     nTabSize = uipow(OutputChannels, CLUTpoints, InputChannels);
//     if (nTabSize == (cmsUInt32Number) -1) goto Error;
//     if (nTabSize > 0) {
// 
//         cmsUInt16Number *PtrW, *T;
//        
//         PtrW = T  = (cmsUInt16Number*) _cmsCalloc(self ->ContextID, nTabSize, sizeof(cmsUInt16Number));
//         if (T  == NULL) goto Error;
// 
//         Temp = (cmsUInt8Number*) _cmsMalloc(self ->ContextID, nTabSize);
//         if (Temp == NULL) {
//             _cmsFree(self ->ContextID, T);
//             goto Error;
//         }
// 
//         if (io ->Read(io, Temp, nTabSize, 1) != 1) {
//             _cmsFree(self ->ContextID, T);
//             _cmsFree(self ->ContextID, Temp);
//             goto Error;
//         }
// 
//         for (i = 0; i < nTabSize; i++) {
// 
//             *PtrW++ = FROM_8_TO_16(Temp[i]);
//         }
//         _cmsFree(self ->ContextID, Temp);
//         Temp = NULL;
// 
//         if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, cmsStageAllocCLut16bit(self ->ContextID, CLUTpoints, InputChannels, OutputChannels, T))) {
//             _cmsFree(self ->ContextID, T);
//             goto Error;
//         }
//         _cmsFree(self ->ContextID, T);
//     }
// 
// 
//     // Get output tables
//     if (!Read8bitTables(self ->ContextID, io,  NewLUT, OutputChannels)) goto Error;
// 
//     *nItems = 1;
//     return NewLUT;
// 
// Error:
//     if (NewLUT != NULL) cmsPipelineFree(NewLUT);
//     return NULL;
// 
//     cmsUNUSED_PARAMETER(SizeOfTag);
// }

// the below code fragment can be found in:
// src/cmsalpha.c
// static
// cmsFormatterAlphaFn _cmsGetFormatterAlpha(cmsContext id, cmsUInt32Number in, cmsUInt32Number out)
// {
// static cmsFormatterAlphaFn FormattersAlpha[6][6] = {
// 
//        /* from 8 */  { copy8,       from8to16,   from8to16SE,   from8toHLF,   from8toFLT,    from8toDBL    },
//        /* from 16*/  { from16to8,   copy16,      from16to16,    from16toHLF,  from16toFLT,   from16toDBL   },
//        /* from 16SE*/{ from16SEto8, from16to16,  copy16,        from16SEtoHLF,from16SEtoFLT, from16SEtoDBL },
//        /* from HLF*/ { fromHLFto8,  fromHLFto16, fromHLFto16SE, copy16,       fromHLFtoFLT,  fromHLFtoDBL  },
//        /* from FLT*/ { fromFLTto8,  fromFLTto16, fromFLTto16SE, fromFLTtoHLF, copy32,        fromFLTtoDBL  },
//        /* from DBL*/ { fromDBLto8,  fromDBLto16, fromDBLto16SE, fromDBLtoHLF, fromDBLtoFLT,  copy64 }};
// 
//         int in_n  = FormatterPos(in);
//         int out_n = FormatterPos(out);
// 
//         if (in_n < 0 || out_n < 0 || in_n > 5 || out_n > 5) {
// 
//                cmsSignalError(id, cmsERROR_UNKNOWN_EXTENSION, "Unrecognized alpha channel width");
//                return NULL;
//         }
// 
//         return FormattersAlpha[in_n][out_n];
// }

// the below code fragment can be found in:
// src/cmscgats.c
// static
// const char* satob(const char* v)
// {
//     cmsUInt32Number x;
//     static char buf[33];
//     char *s = buf + 33;
//     
//     if (v == NULL) return "0";
//     
//     x = atoi(v);
//     *--s = 0;
//     if (!x) *--s = '0';
//     for (; x; x /= 2) *--s = '0' + x%2;
//     
//     return s;
// }

// the below code fragment can be found in:
// testbed/testcms2.c
// static
// cmsInt32Number OneTrivialLab(cmsHPROFILE hLab1, cmsHPROFILE hLab2, const char* txt)
// {
//     cmsHTRANSFORM xform;
//     cmsInt32Number rc;
// 
//     SubTest(txt);
//     xform = cmsCreateTransformTHR(DbgThread(), hLab1, TYPE_Lab_DBL, hLab2, TYPE_Lab_DBL, INTENT_RELATIVE_COLORIMETRIC, 0);
//     cmsCloseProfile(hLab1); cmsCloseProfile(hLab2);
// 
//     rc = CheckSeveralLab(xform);
//     cmsDeleteTransform(xform);
//     return rc;
// }

// the below code fragment can be found in:
// testbed/testcms2.c
// static
// int Check_sRGB_Rountrips(void)
// {
//     cmsUInt16Number rgb[3], seed[3];
//     cmsCIELab Lab;
//     int i, r, g, b;
//     double err, maxErr;
//     cmsHPROFILE hsRGB = cmsCreate_sRGBProfile();
//     cmsHPROFILE hLab = cmsCreateLab4Profile(NULL);
// 
//     cmsHTRANSFORM hBack = cmsCreateTransform(hLab, TYPE_Lab_DBL, hsRGB, TYPE_RGB_16, INTENT_RELATIVE_COLORIMETRIC, 0);
//     cmsHTRANSFORM hForth = cmsCreateTransform(hsRGB, TYPE_RGB_16, hLab, TYPE_Lab_DBL, INTENT_RELATIVE_COLORIMETRIC, 0);
// 
//     cmsCloseProfile(hLab);
//     cmsCloseProfile(hsRGB);
// 
//     maxErr = 0.0;
//     for (r = 0; r <= 255; r += 16)
//         for (g = 0; g <= 255; g += 16)
//             for (b = 0; b <= 255; b += 16)
//             {
//                 seed[0] = rgb[0] = (cmsUInt16Number) ((r << 8) | r);
//                 seed[1] = rgb[1] = (cmsUInt16Number) ((g << 8) | g);
//                 seed[2] = rgb[2] = (cmsUInt16Number) ((b << 8) | b);
// 
//                 for (i = 0; i < 50; i++)
//                 {
//                     cmsDoTransform(hForth, rgb, &Lab, 1);
//                     cmsDoTransform(hBack, &Lab, rgb, 1);
//                 }
// 
//                 err = distance(seed, rgb);
// 
//                 if (err > maxErr)
//                     maxErr = err;
//             }
// 
// 
//     cmsDeleteTransform(hBack);
//     cmsDeleteTransform(hForth);
// 
//     if (maxErr > 20.0)
//     {
//         printf("Maximum sRGB roundtrip error %f!\n", maxErr);
//         return 0;
//     }
//     
//     return 1;
// }

