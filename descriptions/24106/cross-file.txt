// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// coders/svg.c
// static MagickBooleanType WriteSVGImage(const ImageInfo *image_info,Image *image,
//   ExceptionInfo *exception)
// {
// #define BezierQuantum  200
// 
//   AffineMatrix
//     affine;
// 
//   char
//     keyword[MagickPathExtent],
//     message[MagickPathExtent],
//     name[MagickPathExtent],
//     *next_token,
//     *token,
//     type[MagickPathExtent];
// 
//   const char
//     *p,
//     *q,
//     *value;
// 
//   int
//     n;
// 
//   ssize_t
//     j;
// 
//   MagickBooleanType
//     active,
//     status;
// 
//   PointInfo
//     point;
// 
//   PrimitiveInfo
//     *primitive_info;
// 
//   PrimitiveType
//     primitive_type;
// 
//   register ssize_t
//     x;
// 
//   register ssize_t
//     i;
// 
//   size_t
//     extent,
//     length,
//     number_points;
// 
//   SVGInfo
//     svg_info;
// 
//   /*
//     Open output image file.
//   */
//   assert(image_info != (const ImageInfo *) NULL);
//   assert(image_info->signature == MagickCoreSignature);
//   assert(image != (Image *) NULL);
//   assert(image->signature == MagickCoreSignature);
//   if (image->debug != MagickFalse)
//     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
//   assert(exception != (ExceptionInfo *) NULL);
//   assert(exception->signature == MagickCoreSignature);
//   status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
//   if (status == MagickFalse)
//     return(status);
//   value=GetImageArtifact(image,"SVG");
//   if (value != (char *) NULL)
//     {
//       (void) WriteBlobString(image,value);
//       (void) CloseBlob(image);
//       return(MagickTrue);
//     }
//   value=GetImageArtifact(image,"mvg:vector-graphics");
//   if (value == (char *) NULL)
//     return(TraceSVGImage(image,exception));
//   /*
//     Write SVG header.
//   */
//   (void) WriteBlobString(image,"<?xml version=\"1.0\" standalone=\"no\"?>\n");
//   (void) WriteBlobString(image,
//     "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 20010904//EN\"\n");
//   (void) WriteBlobString(image,
//     "  \"http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd\">\n");
//   (void) FormatLocaleString(message,MagickPathExtent,
//     "<svg width=\"%.20g\" height=\"%.20g\">\n",(double) image->columns,(double)
//     image->rows);
//   (void) WriteBlobString(image,message);
//   /*
//     Allocate primitive info memory.
//   */
//   number_points=2047;
//   primitive_info=(PrimitiveInfo *) AcquireQuantumMemory(number_points,
//     sizeof(*primitive_info));
//   if (primitive_info == (PrimitiveInfo *) NULL)
//     ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
//   GetAffineMatrix(&affine);
//   token=AcquireString(value);
//   extent=strlen(token)+MagickPathExtent;
//   active=MagickFalse;
//   n=0;
//   status=MagickTrue;
//   for (q=(const char *) value; *q != '\0'; )
//   {
//     /*
//       Interpret graphic primitive.
//     */
//     (void) GetNextToken(q,&q,MagickPathExtent,keyword);
//     if (*keyword == '\0')
//       break;
//     if (*keyword == '#')
//       {
//         /*
//           Comment.
//         */
//         if (active != MagickFalse)
//           {
//             AffineToTransform(image,&affine);
//             active=MagickFalse;
//           }
//         (void) WriteBlobString(image,"<desc>");
//         (void) WriteBlobString(image,keyword+1);
//         for ( ; (*q != '\n') && (*q != '\0'); q++)
//           switch (*q)
//           {
//             case '<': (void) WriteBlobString(image,"&lt;"); break;
//             case '>': (void) WriteBlobString(image,"&gt;"); break;
//             case '&': (void) WriteBlobString(image,"&amp;"); break;
//             default: (void) WriteBlobByte(image,(unsigned char) *q); break;
//           }
//         (void) WriteBlobString(image,"</desc>\n");
//         continue;
//       }
//     primitive_type=UndefinedPrimitive;
//     switch (*keyword)
//     {
//       case ';':
//         break;
//       case 'a':
//       case 'A':
//       {
//         if (LocaleCompare("affine",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             affine.sx=StringToDouble(token,&next_token);
//             (void) GetNextToken(q,&q,extent,token);
//             if (*token == ',')
//               (void) GetNextToken(q,&q,extent,token);
//             affine.rx=StringToDouble(token,&next_token);
//             (void) GetNextToken(q,&q,extent,token);
//             if (*token == ',')
//               (void) GetNextToken(q,&q,extent,token);
//             affine.ry=StringToDouble(token,&next_token);
//             (void) GetNextToken(q,&q,extent,token);
//             if (*token == ',')
//               (void) GetNextToken(q,&q,extent,token);
//             affine.sy=StringToDouble(token,&next_token);
//             (void) GetNextToken(q,&q,extent,token);
//             if (*token == ',')
//               (void) GetNextToken(q,&q,extent,token);
//             affine.tx=StringToDouble(token,&next_token);
//             (void) GetNextToken(q,&q,extent,token);
//             if (*token == ',')
//               (void) GetNextToken(q,&q,extent,token);
//             affine.ty=StringToDouble(token,&next_token);
//             break;
//           }
//         if (LocaleCompare("alpha",keyword) == 0)
//           {
//             primitive_type=AlphaPrimitive;
//             break;
//           }
//         if (LocaleCompare("angle",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             affine.rx=StringToDouble(token,&next_token);
//             affine.ry=StringToDouble(token,&next_token);
//             break;
//           }
//         if (LocaleCompare("arc",keyword) == 0)
//           {
//             primitive_type=ArcPrimitive;
//             break;
//           }
//         status=MagickFalse;
//         break;
//       }
//       case 'b':
//       case 'B':
//       {
//         if (LocaleCompare("bezier",keyword) == 0)
//           {
//             primitive_type=BezierPrimitive;
//             break;
//           }
//         status=MagickFalse;
//         break;
//       }
//       case 'c':
//       case 'C':
//       {
//         if (LocaleCompare("clip-path",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             (void) FormatLocaleString(message,MagickPathExtent,
//               "clip-path:url(#%s);",token);
//             (void) WriteBlobString(image,message);
//             break;
//           }
//         if (LocaleCompare("clip-rule",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             (void) FormatLocaleString(message,MagickPathExtent,"clip-rule:%s;",
//               token);
//             (void) WriteBlobString(image,message);
//             break;
//           }
//         if (LocaleCompare("clip-units",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             (void) FormatLocaleString(message,MagickPathExtent,
//               "clipPathUnits=%s;",token);
//             (void) WriteBlobString(image,message);
//             break;
//           }
//         if (LocaleCompare("circle",keyword) == 0)
//           {
//             primitive_type=CirclePrimitive;
//             break;
//           }
//         if (LocaleCompare("color",keyword) == 0)
//           {
//             primitive_type=ColorPrimitive;
//             break;
//           }
//         if (LocaleCompare("compliance",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             break;
//           }
//         status=MagickFalse;
//         break;
//       }
//       case 'd':
//       case 'D':
//       {
//         if (LocaleCompare("decorate",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             (void) FormatLocaleString(message,MagickPathExtent,
//               "text-decoration:%s;",token);
//             (void) WriteBlobString(image,message);
//             break;
//           }
//         status=MagickFalse;
//         break;
//       }
//       case 'e':
//       case 'E':
//       {
//         if (LocaleCompare("ellipse",keyword) == 0)
//           {
//             primitive_type=EllipsePrimitive;
//             break;
//           }
//         status=MagickFalse;
//         break;
//       }
//       case 'f':
//       case 'F':
//       {
//         if (LocaleCompare("fill",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             (void) FormatLocaleString(message,MagickPathExtent,"fill:%s;",
//               token);
//             (void) WriteBlobString(image,message);
//             break;
//           }
//         if (LocaleCompare("fill-rule",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             (void) FormatLocaleString(message,MagickPathExtent,
//               "fill-rule:%s;",token);
//             (void) WriteBlobString(image,message);
//             break;
//           }
//         if (LocaleCompare("fill-opacity",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             (void) FormatLocaleString(message,MagickPathExtent,
//               "fill-opacity:%s;",token);
//             (void) WriteBlobString(image,message);
//             break;
//           }
//         if (LocaleCompare("font-family",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             (void) FormatLocaleString(message,MagickPathExtent,
//               "font-family:%s;",token);
//             (void) WriteBlobString(image,message);
//             break;
//           }
//         if (LocaleCompare("font-stretch",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             (void) FormatLocaleString(message,MagickPathExtent,
//               "font-stretch:%s;",token);
//             (void) WriteBlobString(image,message);
//             break;
//           }
//         if (LocaleCompare("font-style",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             (void) FormatLocaleString(message,MagickPathExtent,
//               "font-style:%s;",token);
//             (void) WriteBlobString(image,message);
//             break;
//           }
//         if (LocaleCompare("font-size",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             (void) FormatLocaleString(message,MagickPathExtent,
//               "font-size:%s;",token);
//             (void) WriteBlobString(image,message);
//             break;
//           }
//         if (LocaleCompare("font-weight",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             (void) FormatLocaleString(message,MagickPathExtent,
//               "font-weight:%s;",token);
//             (void) WriteBlobString(image,message);
//             break;
//           }
//         status=MagickFalse;
//         break;
//       }
//       case 'g':
//       case 'G':
//       {
//         if (LocaleCompare("gradient-units",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             break;
//           }
//         if (LocaleCompare("text-align",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             (void) FormatLocaleString(message,MagickPathExtent,
//               "text-align %s ",token);
//             (void) WriteBlobString(image,message);
//             break;
//           }
//         if (LocaleCompare("text-anchor",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             (void) FormatLocaleString(message,MagickPathExtent,
//               "text-anchor %s ",token);
//             (void) WriteBlobString(image,message);
//             break;
//           }
//         status=MagickFalse;
//         break;
//       }
//       case 'i':
//       case 'I':
//       {
//         if (LocaleCompare("image",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             primitive_type=ImagePrimitive;
//             break;
//           }
//         status=MagickFalse;
//         break;
//       }
//       case 'k':
//       case 'K':
//       {
//         if (LocaleCompare("kerning",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             (void) FormatLocaleString(message,MagickPathExtent,"kerning:%s;",
//               token);
//             (void) WriteBlobString(image,message);
//           }
//         break;
//       }
//       case 'l':
//       case 'L':
//       {
//         if (LocaleCompare("letter-spacing",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             (void) FormatLocaleString(message,MagickPathExtent,
//               "letter-spacing:%s;",token);
//             (void) WriteBlobString(image,message);
//             break;
//           }
//         if (LocaleCompare("line",keyword) == 0)
//           {
//             primitive_type=LinePrimitive;
//             break;
//           }
//         status=MagickFalse;
//         break;
//       }
//       case 'o':
//       case 'O':
//       {
//         if (LocaleCompare("opacity",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             (void) FormatLocaleString(message,MagickPathExtent,"opacity %s ",
//               token);
//             (void) WriteBlobString(image,message);
//             break;
//           }
//         status=MagickFalse;
//         break;
//       }
//       case 'p':
//       case 'P':
//       {
//         if (LocaleCompare("path",keyword) == 0)
//           {
//             primitive_type=PathPrimitive;
//             break;
//           }
//         if (LocaleCompare("point",keyword) == 0)
//           {
//             primitive_type=PointPrimitive;
//             break;
//           }
//         if (LocaleCompare("polyline",keyword) == 0)
//           {
//             primitive_type=PolylinePrimitive;
//             break;
//           }
//         if (LocaleCompare("polygon",keyword) == 0)
//           {
//             primitive_type=PolygonPrimitive;
//             break;
//           }
//         if (LocaleCompare("pop",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             if (LocaleCompare("clip-path",token) == 0)
//               {
//                 (void) WriteBlobString(image,"</clipPath>\n");
//                 break;
//               }
//             if (LocaleCompare("defs",token) == 0)
//               {
//                 (void) WriteBlobString(image,"</defs>\n");
//                 break;
//               }
//             if (LocaleCompare("gradient",token) == 0)
//               {
//                 (void) FormatLocaleString(message,MagickPathExtent,
//                   "</%sGradient>\n",type);
//                 (void) WriteBlobString(image,message);
//                 break;
//               }
//             if (LocaleCompare("graphic-context",token) == 0)
//               {
//                 n--;
//                 if (n < 0)
//                   ThrowWriterException(DrawError,
//                     "UnbalancedGraphicContextPushPop");
//                 (void) WriteBlobString(image,"</g>\n");
//               }
//             if (LocaleCompare("pattern",token) == 0)
//               {
//                 (void) WriteBlobString(image,"</pattern>\n");
//                 break;
//               }
//             if (LocaleCompare("symbol",token) == 0)
//               {
//                 (void) WriteBlobString(image,"</symbol>\n");
//                 break;
//               }
//             if ((LocaleCompare("defs",token) == 0) ||
//                 (LocaleCompare("symbol",token) == 0))
//               (void) WriteBlobString(image,"</g>\n");
//             break;
//           }
//         if (LocaleCompare("push",keyword) == 0)
//           {
//             *name='\0';
//             (void) GetNextToken(q,&q,extent,token);
//             if (*q == '"')
//               (void) GetNextToken(q,&q,extent,name);
//             if (LocaleCompare("clip-path",token) == 0)
//               {
//                 (void) GetNextToken(q,&q,extent,token);
//                 (void) FormatLocaleString(message,MagickPathExtent,
//                   "<clipPath id=\"%s\">\n",token);
//                 (void) WriteBlobString(image,message);
//                 break;
//               }
//             if (LocaleCompare("defs",token) == 0)
//               {
//                 (void) WriteBlobString(image,"<defs>\n");
//                 break;
//               }
//             if (LocaleCompare("gradient",token) == 0)
//               {
//                 (void) GetNextToken(q,&q,extent,token);
//                 (void) CopyMagickString(name,token,MagickPathExtent);
//                 (void) GetNextToken(q,&q,extent,token);
//                 (void) CopyMagickString(type,token,MagickPathExtent);
//                 (void) GetNextToken(q,&q,extent,token);
//                 svg_info.segment.x1=StringToDouble(token,&next_token);
//                 svg_info.element.cx=StringToDouble(token,&next_token);
//                 (void) GetNextToken(q,&q,extent,token);
//                 if (*token == ',')
//                   (void) GetNextToken(q,&q,extent,token);
//                 svg_info.segment.y1=StringToDouble(token,&next_token);
//                 svg_info.element.cy=StringToDouble(token,&next_token);
//                 (void) GetNextToken(q,&q,extent,token);
//                 if (*token == ',')
//                   (void) GetNextToken(q,&q,extent,token);
//                 svg_info.segment.x2=StringToDouble(token,&next_token);
//                 svg_info.element.major=StringToDouble(token,
//                   (char **) NULL);
//                 (void) GetNextToken(q,&q,extent,token);
//                 if (*token == ',')
//                   (void) GetNextToken(q,&q,extent,token);
//                 svg_info.segment.y2=StringToDouble(token,&next_token);
//                 svg_info.element.minor=StringToDouble(token,
//                   (char **) NULL);
//                 (void) FormatLocaleString(message,MagickPathExtent,
//                   "<%sGradient id=\"%s\" x1=\"%g\" y1=\"%g\" x2=\"%g\" "
//                   "y2=\"%g\">\n",type,name,svg_info.segment.x1,
//                   svg_info.segment.y1,svg_info.segment.x2,svg_info.segment.y2);
//                 if (LocaleCompare(type,"radial") == 0)
//                   {
//                     (void) GetNextToken(q,&q,extent,token);
//                     if (*token == ',')
//                       (void) GetNextToken(q,&q,extent,token);
//                     svg_info.element.angle=StringToDouble(token,
//                       (char **) NULL);
//                     (void) FormatLocaleString(message,MagickPathExtent,
//                       "<%sGradient id=\"%s\" cx=\"%g\" cy=\"%g\" r=\"%g\" "
//                       "fx=\"%g\" fy=\"%g\">\n",type,name,
//                       svg_info.element.cx,svg_info.element.cy,
//                       svg_info.element.angle,svg_info.element.major,
//                       svg_info.element.minor);
//                   }
//                 (void) WriteBlobString(image,message);
//                 break;
//               }
//             if (LocaleCompare("graphic-context",token) == 0)
//               {
//                 n++;
//                 if (active)
//                   {
//                     AffineToTransform(image,&affine);
//                     active=MagickFalse;
//                   }
//                 (void) WriteBlobString(image,"<g style=\"");
//                 active=MagickTrue;
//               }
//             if (LocaleCompare("pattern",token) == 0)
//               {
//                 (void) GetNextToken(q,&q,extent,token);
//                 (void) CopyMagickString(name,token,MagickPathExtent);
//                 (void) GetNextToken(q,&q,extent,token);
//                 svg_info.bounds.x=StringToDouble(token,&next_token);
//                 (void) GetNextToken(q,&q,extent,token);
//                 if (*token == ',')
//                   (void) GetNextToken(q,&q,extent,token);
//                 svg_info.bounds.y=StringToDouble(token,&next_token);
//                 (void) GetNextToken(q,&q,extent,token);
//                 if (*token == ',')
//                   (void) GetNextToken(q,&q,extent,token);
//                 svg_info.bounds.width=StringToDouble(token,
//                   (char **) NULL);
//                 (void) GetNextToken(q,&q,extent,token);
//                 if (*token == ',')
//                   (void) GetNextToken(q,&q,extent,token);
//                 svg_info.bounds.height=StringToDouble(token,(char **) NULL);
//                 (void) FormatLocaleString(message,MagickPathExtent,
//                   "<pattern id=\"%s\" x=\"%g\" y=\"%g\" width=\"%g\" "
//                   "height=\"%g\">\n",name,svg_info.bounds.x,svg_info.bounds.y,
//                   svg_info.bounds.width,svg_info.bounds.height);
//                 (void) WriteBlobString(image,message);
//                 break;
//               }
//             if (LocaleCompare("symbol",token) == 0)
//               {
//                 (void) WriteBlobString(image,"<symbol>\n");
//                 break;
//               }
//             break;
//           }
//         status=MagickFalse;
//         break;
//       }
//       case 'r':
//       case 'R':
//       {
//         if (LocaleCompare("rectangle",keyword) == 0)
//           {
//             primitive_type=RectanglePrimitive;
//             break;
//           }
//         if (LocaleCompare("roundRectangle",keyword) == 0)
//           {
//             primitive_type=RoundRectanglePrimitive;
//             break;
//           }
//         if (LocaleCompare("rotate",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             (void) FormatLocaleString(message,MagickPathExtent,"rotate(%s) ",
//               token);
//             (void) WriteBlobString(image,message);
//             break;
//           }
//         status=MagickFalse;
//         break;
//       }
//       case 's':
//       case 'S':
//       {
//         if (LocaleCompare("scale",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             affine.sx=StringToDouble(token,&next_token);
//             (void) GetNextToken(q,&q,extent,token);
//             if (*token == ',')
//               (void) GetNextToken(q,&q,extent,token);
//             affine.sy=StringToDouble(token,&next_token);
//             break;
//           }
//         if (LocaleCompare("skewX",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             (void) FormatLocaleString(message,MagickPathExtent,"skewX(%s) ",
//               token);
//             (void) WriteBlobString(image,message);
//             break;
//           }
//         if (LocaleCompare("skewY",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             (void) FormatLocaleString(message,MagickPathExtent,"skewY(%s) ",
//               token);
//             (void) WriteBlobString(image,message);
//             break;
//           }
//         if (LocaleCompare("stop-color",keyword) == 0)
//           {
//             char
//               color[MagickPathExtent];
// 
//             (void) GetNextToken(q,&q,extent,token);
//             (void) CopyMagickString(color,token,MagickPathExtent);
//             (void) GetNextToken(q,&q,extent,token);
//             (void) FormatLocaleString(message,MagickPathExtent,
//               "  <stop offset=\"%s\" stop-color=\"%s\" />\n",token,color);
//             (void) WriteBlobString(image,message);
//             break;
//           }
//         if (LocaleCompare("stroke",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             (void) FormatLocaleString(message,MagickPathExtent,"stroke:%s;",
//               token);
//             (void) WriteBlobString(image,message);
//             break;
//           }
//         if (LocaleCompare("stroke-antialias",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             (void) FormatLocaleString(message,MagickPathExtent,
//               "stroke-antialias:%s;",token);
//             (void) WriteBlobString(image,message);
//             break;
//           }
//         if (LocaleCompare("stroke-dasharray",keyword) == 0)
//           {
//             if (IsPoint(q))
//               {
//                 ssize_t
//                   k;
// 
//                 p=q;
//                 (void) GetNextToken(p,&p,extent,token);
//                 for (k=0; IsPoint(token); k++)
//                   (void) GetNextToken(p,&p,extent,token);
//                 (void) WriteBlobString(image,"stroke-dasharray:");
//                 for (j=0; j < k; j++)
//                 {
//                   (void) GetNextToken(q,&q,extent,token);
//                   (void) FormatLocaleString(message,MagickPathExtent,"%s ",
//                     token);
//                   (void) WriteBlobString(image,message);
//                 }
//                 (void) WriteBlobString(image,";");
//                 break;
//               }
//             (void) GetNextToken(q,&q,extent,token);
//             (void) FormatLocaleString(message,MagickPathExtent,
//               "stroke-dasharray:%s;",token);
//             (void) WriteBlobString(image,message);
//             break;
//           }
//         if (LocaleCompare("stroke-dashoffset",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             (void) FormatLocaleString(message,MagickPathExtent,
//               "stroke-dashoffset:%s;",token);
//             (void) WriteBlobString(image,message);
//             break;
//           }
//         if (LocaleCompare("stroke-linecap",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             (void) FormatLocaleString(message,MagickPathExtent,
//               "stroke-linecap:%s;",token);
//             (void) WriteBlobString(image,message);
//             break;
//           }
//         if (LocaleCompare("stroke-linejoin",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             (void) FormatLocaleString(message,MagickPathExtent,
//               "stroke-linejoin:%s;",token);
//             (void) WriteBlobString(image,message);
//             break;
//           }
//         if (LocaleCompare("stroke-miterlimit",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             (void) FormatLocaleString(message,MagickPathExtent,
//               "stroke-miterlimit:%s;",token);
//             (void) WriteBlobString(image,message);
//             break;
//           }
//         if (LocaleCompare("stroke-opacity",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             (void) FormatLocaleString(message,MagickPathExtent,
//               "stroke-opacity:%s;",token);
//             (void) WriteBlobString(image,message);
//             break;
//           }
//         if (LocaleCompare("stroke-width",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             (void) FormatLocaleString(message,MagickPathExtent,
//               "stroke-width:%s;",token);
//             (void) WriteBlobString(image,message);
//             continue;
//           }
//         status=MagickFalse;
//         break;
//       }
//       case 't':
//       case 'T':
//       {
//         if (LocaleCompare("text",keyword) == 0)
//           {
//             primitive_type=TextPrimitive;
//             break;
//           }
//         if (LocaleCompare("text-antialias",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             (void) FormatLocaleString(message,MagickPathExtent,
//               "text-antialias:%s;",token);
//             (void) WriteBlobString(image,message);
//             break;
//           }
//         if (LocaleCompare("tspan",keyword) == 0)
//           {
//             primitive_type=TextPrimitive;
//             break;
//           }
//         if (LocaleCompare("translate",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             affine.tx=StringToDouble(token,&next_token);
//             (void) GetNextToken(q,&q,extent,token);
//             if (*token == ',')
//               (void) GetNextToken(q,&q,extent,token);
//             affine.ty=StringToDouble(token,&next_token);
//             break;
//           }
//         status=MagickFalse;
//         break;
//       }
//       case 'v':
//       case 'V':
//       {
//         if (LocaleCompare("viewbox",keyword) == 0)
//           {
//             (void) GetNextToken(q,&q,extent,token);
//             if (*token == ',')
//               (void) GetNextToken(q,&q,extent,token);
//             (void) GetNextToken(q,&q,extent,token);
//             if (*token == ',')
//               (void) GetNextToken(q,&q,extent,token);
//             (void) GetNextToken(q,&q,extent,token);
//             if (*token == ',')
//               (void) GetNextToken(q,&q,extent,token);
//             (void) GetNextToken(q,&q,extent,token);
//             break;
//           }
//         status=MagickFalse;
//         break;
//       }
//       default:
//       {
//         status=MagickFalse;
//         break;
//       }
//     }
//     if (status == MagickFalse)
//       break;
//     if (primitive_type == UndefinedPrimitive)
//       continue;
//     /*
//       Parse the primitive attributes.
//     */
//     i=0;
//     j=0;
//     for (x=0; *q != '\0'; x++)
//     {
//       /*
//         Define points.
//       */
//       if (IsPoint(q) == MagickFalse)
//         break;
//       (void) GetNextToken(q,&q,extent,token);
//       point.x=StringToDouble(token,&next_token);
//       (void) GetNextToken(q,&q,extent,token);
//       if (*token == ',')
//         (void) GetNextToken(q,&q,extent,token);
//       point.y=StringToDouble(token,&next_token);
//       (void) GetNextToken(q,(const char **) NULL,extent,token);
//       if (*token == ',')
//         (void) GetNextToken(q,&q,extent,token);
//       primitive_info[i].primitive=primitive_type;
//       primitive_info[i].point=point;
//       primitive_info[i].coordinates=0;
//       primitive_info[i].method=FloodfillMethod;
//       i++;
//       if (i < (ssize_t) (number_points-6*BezierQuantum-360))
//         continue;
//       number_points+=6*BezierQuantum+360;
//       primitive_info=(PrimitiveInfo *) ResizeQuantumMemory(primitive_info,
//         number_points,sizeof(*primitive_info));
//       if (primitive_info == (PrimitiveInfo *) NULL)
//         {
//           (void) ThrowMagickException(exception,GetMagickModule(),
//             ResourceLimitError,"MemoryAllocationFailed","`%s'",image->filename);
//           break;
//         }
//     }
//     primitive_info[j].primitive=primitive_type;
//     primitive_info[j].coordinates=(size_t) x;
//     primitive_info[j].method=FloodfillMethod;
//     primitive_info[j].text=(char *) NULL;
//     if (active)
//       {
//         AffineToTransform(image,&affine);
//         active=MagickFalse;
//       }
//     active=MagickFalse;
//     switch (primitive_type)
//     {
//       case PointPrimitive:
//       default:
//       {
//         if (primitive_info[j].coordinates != 1)
//           {
//             status=MagickFalse;
//             break;
//           }
//         break;
//       }
//       case LinePrimitive:
//       {
//         if (primitive_info[j].coordinates != 2)
//           {
//             status=MagickFalse;
//             break;
//           }
//           (void) FormatLocaleString(message,MagickPathExtent,
//           "  <line x1=\"%g\" y1=\"%g\" x2=\"%g\" y2=\"%g\"/>\n",
//           primitive_info[j].point.x,primitive_info[j].point.y,
//           primitive_info[j+1].point.x,primitive_info[j+1].point.y);
//         (void) WriteBlobString(image,message);
//         break;
//       }
//       case RectanglePrimitive:
//       {
//         if (primitive_info[j].coordinates != 2)
//           {
//             status=MagickFalse;
//             break;
//           }
//           (void) FormatLocaleString(message,MagickPathExtent,
//           "  <rect x=\"%g\" y=\"%g\" width=\"%g\" height=\"%g\"/>\n",
//           primitive_info[j].point.x,primitive_info[j].point.y,
//           primitive_info[j+1].point.x-primitive_info[j].point.x,
//           primitive_info[j+1].point.y-primitive_info[j].point.y);
//         (void) WriteBlobString(image,message);
//         break;
//       }
//       case RoundRectanglePrimitive:
//       {
//         if (primitive_info[j].coordinates != 3)
//           {
//             status=MagickFalse;
//             break;
//           }
//         (void) FormatLocaleString(message,MagickPathExtent,
//           "  <rect x=\"%g\" y=\"%g\" width=\"%g\" height=\"%g\" rx=\"%g\" "
//           "ry=\"%g\"/>\n",primitive_info[j].point.x,
//           primitive_info[j].point.y,primitive_info[j+1].point.x-
//           primitive_info[j].point.x,primitive_info[j+1].point.y-
//           primitive_info[j].point.y,primitive_info[j+2].point.x,
//           primitive_info[j+2].point.y);
//         (void) WriteBlobString(image,message);
//         break;
//       }
//       case ArcPrimitive:
//       {
//         if (primitive_info[j].coordinates != 3)
//           {
//             status=MagickFalse;
//             break;
//           }
//         break;
//       }
//       case EllipsePrimitive:
//       {
//         if (primitive_info[j].coordinates != 3)
//           {
//             status=MagickFalse;
//             break;
//           }
//           (void) FormatLocaleString(message,MagickPathExtent,
//           "  <ellipse cx=\"%g\" cy=\"%g\" rx=\"%g\" ry=\"%g\"/>\n",
//           primitive_info[j].point.x,primitive_info[j].point.y,
//           primitive_info[j+1].point.x,primitive_info[j+1].point.y);
//         (void) WriteBlobString(image,message);
//         break;
//       }
//       case CirclePrimitive:
//       {
//         double
//           alpha,
//           beta;
// 
//         if (primitive_info[j].coordinates != 2)
//           {
//             status=MagickFalse;
//             break;
//           }
//         alpha=primitive_info[j+1].point.x-primitive_info[j].point.x;
//         beta=primitive_info[j+1].point.y-primitive_info[j].point.y;
//         (void) FormatLocaleString(message,MagickPathExtent,
//           "  <circle cx=\"%g\" cy=\"%g\" r=\"%g\"/>\n",
//           primitive_info[j].point.x,primitive_info[j].point.y,
//           hypot(alpha,beta));
//         (void) WriteBlobString(image,message);
//         break;
//       }
//       case PolylinePrimitive:
//       {
//         if (primitive_info[j].coordinates < 2)
//           {
//             status=MagickFalse;
//             break;
//           }
//         (void) CopyMagickString(message,"  <polyline points=\"",
//            MagickPathExtent);
//         (void) WriteBlobString(image,message);
//         length=strlen(message);
//         for ( ; j < i; j++)
//         {
//           (void) FormatLocaleString(message,MagickPathExtent,"%g,%g ",
//             primitive_info[j].point.x,primitive_info[j].point.y);
//           length+=strlen(message);
//           if (length >= 80)
//             {
//               (void) WriteBlobString(image,"\n    ");
//               length=strlen(message)+5;
//             }
//           (void) WriteBlobString(image,message);
//         }
//         (void) WriteBlobString(image,"\"/>\n");
//         break;
//       }
//       case PolygonPrimitive:
//       {
//         if (primitive_info[j].coordinates < 3)
//           {
//             status=MagickFalse;
//             break;
//           }
//         primitive_info[i]=primitive_info[j];
//         primitive_info[i].coordinates=0;
//         primitive_info[j].coordinates++;
//         i++;
//         (void) CopyMagickString(message,"  <polygon points=\"",
//           MagickPathExtent);
//         (void) WriteBlobString(image,message);
//         length=strlen(message);
//         for ( ; j < i; j++)
//         {
//           (void) FormatLocaleString(message,MagickPathExtent,"%g,%g ",
//             primitive_info[j].point.x,primitive_info[j].point.y);
//           length+=strlen(message);
//           if (length >= 80)
//             {
//               (void) WriteBlobString(image,"\n    ");
//               length=strlen(message)+5;
//             }
//           (void) WriteBlobString(image,message);
//         }
//         (void) WriteBlobString(image,"\"/>\n");
//         break;
//       }
//       case BezierPrimitive:
//       {
//         if (primitive_info[j].coordinates < 3)
//           {
//             status=MagickFalse;
//             break;
//           }
//         break;
//       }
//       case PathPrimitive:
//       {
//         int
//           number_attributes;
// 
//         (void) GetNextToken(q,&q,extent,token);
//         number_attributes=1;
//         for (p=token; *p != '\0'; p++)
//           if (isalpha((int) ((unsigned char) *p)) != 0)
//             number_attributes++;
//         if (i > (ssize_t) (number_points-6*BezierQuantum*number_attributes-1))
//           {
//             number_points+=6*BezierQuantum*number_attributes;
//             primitive_info=(PrimitiveInfo *) ResizeQuantumMemory(primitive_info,
//               number_points,sizeof(*primitive_info));
//             if (primitive_info == (PrimitiveInfo *) NULL)
//               {
//                 (void) ThrowMagickException(exception,GetMagickModule(),
//                   ResourceLimitError,"MemoryAllocationFailed","`%s'",
//                   image->filename);
//                 break;
//               }
//           }
//         (void) WriteBlobString(image,"  <path d=\"");
//         (void) WriteBlobString(image,token);
//         (void) WriteBlobString(image,"\"/>\n");
//         break;
//       }
//       case AlphaPrimitive:
//       case ColorPrimitive:
//       {
//         if (primitive_info[j].coordinates != 1)
//           {
//             status=MagickFalse;
//             break;
//           }
//         (void) GetNextToken(q,&q,extent,token);
//         if (LocaleCompare("point",token) == 0)
//           primitive_info[j].method=PointMethod;
//         if (LocaleCompare("replace",token) == 0)
//           primitive_info[j].method=ReplaceMethod;
//         if (LocaleCompare("floodfill",token) == 0)
//           primitive_info[j].method=FloodfillMethod;
//         if (LocaleCompare("filltoborder",token) == 0)
//           primitive_info[j].method=FillToBorderMethod;
//         if (LocaleCompare("reset",token) == 0)
//           primitive_info[j].method=ResetMethod;
//         break;
//       }
//       case TextPrimitive:
//       {
//         register char
//           *p;
// 
//         if (primitive_info[j].coordinates != 1)
//           {
//             status=MagickFalse;
//             break;
//           }
//         (void) GetNextToken(q,&q,extent,token);
//         (void) FormatLocaleString(message,MagickPathExtent,
//           "  <text x=\"%g\" y=\"%g\">",primitive_info[j].point.x,
//           primitive_info[j].point.y);
//         (void) WriteBlobString(image,message);
//         for (p=token; *p != '\0'; p++)
//           switch (*p)
//           {
//             case '<': (void) WriteBlobString(image,"&lt;"); break;
//             case '>': (void) WriteBlobString(image,"&gt;"); break;
//             case '&': (void) WriteBlobString(image,"&amp;"); break;
//             default: (void) WriteBlobByte(image,(unsigned char) *p); break;
//           }
//         (void) WriteBlobString(image,"</text>\n");
//         break;
//       }
//       case ImagePrimitive:
//       {
//         if (primitive_info[j].coordinates != 2)
//           {
//             status=MagickFalse;
//             break;
//           }
//         (void) GetNextToken(q,&q,extent,token);
//         (void) FormatLocaleString(message,MagickPathExtent,
//           "  <image x=\"%g\" y=\"%g\" width=\"%g\" height=\"%g\" "
//           "href=\"%s\"/>\n",primitive_info[j].point.x,
//           primitive_info[j].point.y,primitive_info[j+1].point.x,
//           primitive_info[j+1].point.y,token);
//         (void) WriteBlobString(image,message);
//         break;
//       }
//     }
//     if (primitive_info == (PrimitiveInfo *) NULL)
//       break;
//     primitive_info[i].primitive=UndefinedPrimitive;
//     if (status == MagickFalse)
//       break;
//   }
//   (void) WriteBlobString(image,"</svg>\n");
//   /*
//     Relinquish resources.
//   */
//   token=DestroyString(token);
//   if (primitive_info != (PrimitiveInfo *) NULL)
//     primitive_info=(PrimitiveInfo *) RelinquishMagickMemory(primitive_info);
//   (void) CloseBlob(image);
//   return(status);
// }

// the below code fragment can be found in:
// MagickCore/draw.c
// static MagickBooleanType TraceRectangle(PrimitiveInfo *primitive_info,
//   const PointInfo start,const PointInfo end)
// {
//   PointInfo
//     point;
// 
//   register PrimitiveInfo
//     *p;
// 
//   register ssize_t
//     i;
// 
//   p=primitive_info;
//   if (TracePoint(p,start) == MagickFalse)
//     return(MagickFalse);
//   p+=p->coordinates;
//   point.x=start.x;
//   point.y=end.y;
//   if (TracePoint(p,point) == MagickFalse)
//     return(MagickFalse);
//   p+=p->coordinates;
//   if (TracePoint(p,end) == MagickFalse)
//     return(MagickFalse);
//   p+=p->coordinates;
//   point.x=end.x;
//   point.y=start.y;
//   if (TracePoint(p,point) == MagickFalse)
//     return(MagickFalse);
//   p+=p->coordinates;
//   if (TracePoint(p,start) == MagickFalse)
//     return(MagickFalse);
//   p+=p->coordinates;
//   primitive_info->coordinates=(size_t) (p-primitive_info);
//   primitive_info->closed_subpath=MagickTrue;
//   for (i=0; i < (ssize_t) primitive_info->coordinates; i++)
//   {
//     p->primitive=primitive_info->primitive;
//     p--;
//   }
//   return(MagickTrue);
// }

// the below code fragment can be found in:
// coders/svg.c
// static void SVGEndElement(void *context,const xmlChar *name)
// {
//   SVGInfo
//     *svg_info;
// 
//   /*
//     Called when the end of an element has been detected.
//   */
//   (void) LogMagickEvent(CoderEvent,GetMagickModule(),
//     "  SAX.endElement(%s)",name);
//   svg_info=(SVGInfo *) context;
//   if (strchr((char *) name,':') != (char *) NULL)
//     {
//       /*
//         Skip over namespace.
//       */
//       for ( ; *name != ':'; name++) ;
//       name++;
//     }
//   switch (*name)
//   {
//     case 'C':
//     case 'c':
//     {
//       if (LocaleCompare((const char *) name,"circle") == 0)
//         {
//           (void) FormatLocaleFile(svg_info->file,"class \"circle\"\n");
//           (void) FormatLocaleFile(svg_info->file,"circle %g,%g %g,%g\n",
//             svg_info->element.cx,svg_info->element.cy,svg_info->element.cx,
//             svg_info->element.cy+svg_info->element.minor);
//           (void) FormatLocaleFile(svg_info->file,"pop graphic-context\n");
//           break;
//         }
//       if (LocaleCompare((const char *) name,"clipPath") == 0)
//         {
//           (void) FormatLocaleFile(svg_info->file,"pop clip-path\n");
//           break;
//         }
//       break;
//     }
//     case 'D':
//     case 'd':
//     {
//       if (LocaleCompare((const char *) name,"defs") == 0)
//         {
//           (void) FormatLocaleFile(svg_info->file,"pop defs\n");
//           break;
//         }
//       if (LocaleCompare((const char *) name,"desc") == 0)
//         {
//           register char
//             *p;
// 
//           if (*svg_info->text == '\0')
//             break;
//           (void) fputc('#',svg_info->file);
//           for (p=svg_info->text; *p != '\0'; p++)
//           {
//             (void) fputc(*p,svg_info->file);
//             if (*p == '\n')
//               (void) fputc('#',svg_info->file);
//           }
//           (void) fputc('\n',svg_info->file);
//           *svg_info->text='\0';
//           break;
//         }
//       break;
//     }
//     case 'E':
//     case 'e':
//     {
//       if (LocaleCompare((const char *) name,"ellipse") == 0)
//         {
//           double
//             angle;
// 
//           (void) FormatLocaleFile(svg_info->file,"class \"ellipse\"\n");
//           angle=svg_info->element.angle;
//           (void) FormatLocaleFile(svg_info->file,"ellipse %g,%g %g,%g 0,360\n",
//             svg_info->element.cx,svg_info->element.cy,
//             angle == 0.0 ? svg_info->element.major : svg_info->element.minor,
//             angle == 0.0 ? svg_info->element.minor : svg_info->element.major);
//           (void) FormatLocaleFile(svg_info->file,"pop graphic-context\n");
//           break;
//         }
//       break;
//     }
//     case 'F':
//     case 'f':
//     {
//       if (LocaleCompare((const char *) name,"foreignObject") == 0)
//         {
//           (void) FormatLocaleFile(svg_info->file,"pop graphic-context\n");
//           break;
//         }
//       break;
//     }
//     case 'G':
//     case 'g':
//     {
//       if (LocaleCompare((const char *) name,"g") == 0)
//         {
//           (void) FormatLocaleFile(svg_info->file,"pop graphic-context\n");
//           break;
//         }
//       break;
//     }
//     case 'I':
//     case 'i':
//     {
//       if (LocaleCompare((const char *) name,"image") == 0)
//         {
//           (void) FormatLocaleFile(svg_info->file,
//             "image Over %g,%g %g,%g \"%s\"\n",svg_info->bounds.x,
//             svg_info->bounds.y,svg_info->bounds.width,svg_info->bounds.height,
//             svg_info->url);
//           (void) FormatLocaleFile(svg_info->file,"pop graphic-context\n");
//           break;
//         }
//       break;
//     }
//     case 'L':
//     case 'l':
//     {
//       if (LocaleCompare((const char *) name,"line") == 0)
//         {
//           (void) FormatLocaleFile(svg_info->file,"class \"line\"\n");
//           (void) FormatLocaleFile(svg_info->file,"line %g,%g %g,%g\n",
//             svg_info->segment.x1,svg_info->segment.y1,svg_info->segment.x2,
//             svg_info->segment.y2);
//           (void) FormatLocaleFile(svg_info->file,"pop graphic-context\n");
//           break;
//         }
//       if (LocaleCompare((const char *) name,"linearGradient") == 0)
//         {
//           (void) FormatLocaleFile(svg_info->file,"pop gradient\n");
//           break;
//         }
//       break;
//     }
//     case 'M':
//     case 'm':
//     {
//       if (LocaleCompare((const char *) name,"mask") == 0)
//         {
//           (void) FormatLocaleFile(svg_info->file,"pop mask\n");
//           break;
//         }
//       break;
//     }
//     case 'P':
//     case 'p':
//     {
//       if (LocaleCompare((const char *) name,"pattern") == 0)
//         {
//           (void) FormatLocaleFile(svg_info->file,"pop pattern\n");
//           break;
//         }
//       if (LocaleCompare((const char *) name,"path") == 0)
//         {
//           (void) FormatLocaleFile(svg_info->file,"class \"path\"\n");
//           (void) FormatLocaleFile(svg_info->file,"path \"%s\"\n",
//             svg_info->vertices);
//           (void) FormatLocaleFile(svg_info->file,"pop graphic-context\n");
//           break;
//         }
//       if (LocaleCompare((const char *) name,"polygon") == 0)
//         {
//           (void) FormatLocaleFile(svg_info->file,"class \"polygon\"\n");
//           (void) FormatLocaleFile(svg_info->file,"polygon %s\n",
//             svg_info->vertices);
//           (void) FormatLocaleFile(svg_info->file,"pop graphic-context\n");
//           break;
//         }
//       if (LocaleCompare((const char *) name,"polyline") == 0)
//         {
//           (void) FormatLocaleFile(svg_info->file,"class \"polyline\"\n");
//           (void) FormatLocaleFile(svg_info->file,"polyline %s\n",
//             svg_info->vertices);
//           (void) FormatLocaleFile(svg_info->file,"pop graphic-context\n");
//           break;
//         }
//       break;
//     }
//     case 'R':
//     case 'r':
//     {
//       if (LocaleCompare((const char *) name,"radialGradient") == 0)
//         {
//           (void) FormatLocaleFile(svg_info->file,"pop gradient\n");
//           break;
//         }
//       if (LocaleCompare((const char *) name,"rect") == 0)
//         {
//           if ((svg_info->radius.x == 0.0) && (svg_info->radius.y == 0.0))
//             {
//               (void) FormatLocaleFile(svg_info->file,"class \"rect\"\n");
//               if ((fabs(svg_info->bounds.width-1.0) < MagickEpsilon) &&
//                   (fabs(svg_info->bounds.height-1.0) < MagickEpsilon))
//                 (void) FormatLocaleFile(svg_info->file,"point %g,%g\n",
//                   svg_info->bounds.x,svg_info->bounds.y);
//               else
//                 (void) FormatLocaleFile(svg_info->file,
//                   "rectangle %g,%g %g,%g\n",svg_info->bounds.x,
//                   svg_info->bounds.y,svg_info->bounds.x+svg_info->bounds.width,
//                   svg_info->bounds.y+svg_info->bounds.height);
//               (void) FormatLocaleFile(svg_info->file,"pop graphic-context\n");
//               break;
//             }
//           if (svg_info->radius.x == 0.0)
//             svg_info->radius.x=svg_info->radius.y;
//           if (svg_info->radius.y == 0.0)
//             svg_info->radius.y=svg_info->radius.x;
//           (void) FormatLocaleFile(svg_info->file,
//             "roundRectangle %g,%g %g,%g %g,%g\n",
//             svg_info->bounds.x,svg_info->bounds.y,svg_info->bounds.x+
//             svg_info->bounds.width,svg_info->bounds.y+svg_info->bounds.height,
//             svg_info->radius.x,svg_info->radius.y);
//           svg_info->radius.x=0.0;
//           svg_info->radius.y=0.0;
//           (void) FormatLocaleFile(svg_info->file,"pop graphic-context\n");
//           break;
//         }
//       break;
//     }
//     case 'S':
//     case 's':
//     {
//       if (LocaleCompare((const char *) name,"stop") == 0)
//         {
//           (void) FormatLocaleFile(svg_info->file,"stop-color \"%s\" %s\n",
//             svg_info->stop_color,svg_info->offset == (char *) NULL ? "100%" : 
//             svg_info->offset);
//           break;
//         }
//       if (LocaleCompare((char *) name,"style") == 0)
//         {
//           char
//             *keyword,
//             **tokens,
//             *value;
// 
//           register ssize_t
//             j;
// 
//           size_t
//             number_tokens;
// 
//           /*
//             Find style definitions in svg_info->text.
//           */
//           tokens=SVGKeyValuePairs(context,'{','}',svg_info->text,
//             &number_tokens);
//           if (tokens == (char **) NULL)
//             break;
//           for (j=0; j < (ssize_t) (number_tokens-1); j+=2)
//           {
//             keyword=(char *) tokens[j];
//             value=(char *) tokens[j+1];
//             (void) FormatLocaleFile(svg_info->file,"push class \"%s\"\n",
//               *keyword == '.' ? keyword+1 : keyword);
//             SVGProcessStyleElement(context,name,value);
//             (void) FormatLocaleFile(svg_info->file,"pop class\n");
//           }
//           for (j=0; tokens[j] != (char *) NULL; j++)
//             tokens[j]=DestroyString(tokens[j]);
//           tokens=(char **) RelinquishMagickMemory(tokens);
//           break;
//         }
//       if (LocaleCompare((const char *) name,"svg") == 0)
//         {
//           (void) FormatLocaleFile(svg_info->file,"pop graphic-context\n");
//           svg_info->svgDepth--;
//           break;
//         }
//       if (LocaleCompare((const char *) name,"symbol") == 0)
//         {
//           (void) FormatLocaleFile(svg_info->file,"pop symbol\n");
//           break;
//         }
//       break;
//     }
//     case 'T':
//     case 't':
//     {
//       if (LocaleCompare((const char *) name,"text") == 0)
//         {
//           if (*svg_info->text != '\0')
//             {
//               char
//                 *text;
// 
//               SVGStripString(MagickTrue,svg_info->text);
//               text=EscapeString(svg_info->text,'\"');
//               (void) FormatLocaleFile(svg_info->file,"text %g,%g \"%s\"\n",
//                 svg_info->text_offset.x,svg_info->text_offset.y,text);
//               text=DestroyString(text);
//               *svg_info->text='\0';
//             }
//           (void) FormatLocaleFile(svg_info->file,"pop graphic-context\n");
//           break;
//         }
//       if (LocaleCompare((const char *) name,"tspan") == 0)
//         {
//           if (*svg_info->text != '\0')
//             {
//               char
//                 *text;
// 
//               (void) FormatLocaleFile(svg_info->file,"class \"tspan\"\n");
//               text=EscapeString(svg_info->text,'\"');
//               (void) FormatLocaleFile(svg_info->file,"text %g,%g \"%s\"\n",
//                 svg_info->bounds.x,svg_info->bounds.y,text);
//               text=DestroyString(text);
//               *svg_info->text='\0';
//             }
//           (void) FormatLocaleFile(svg_info->file,"pop graphic-context\n");
//           break;
//         }
//       if (LocaleCompare((const char *) name,"title") == 0)
//         {
//           if (*svg_info->text == '\0')
//             break;
//           (void) CloneString(&svg_info->title,svg_info->text);
//           *svg_info->text='\0';
//           break;
//         }
//       break;
//     }
//     case 'U':
//     case 'u':
//     {
//       if (LocaleCompare((char *) name,"use") == 0)
//         {
//           if ((svg_info->bounds.x != 0.0) || (svg_info->bounds.y != 0.0))
//             (void) FormatLocaleFile(svg_info->file,"translate %g,%g\n",
//               svg_info->bounds.x,svg_info->bounds.y);
//           (void) FormatLocaleFile(svg_info->file,"use \"url(%s)\"\n",
//             svg_info->url);
//           (void) FormatLocaleFile(svg_info->file,"pop graphic-context\n");
//           break;
//         }
//       break;
//     }
//     default:
//       break;
//   }
//   *svg_info->text='\0';
//   (void) memset(&svg_info->element,0,sizeof(svg_info->element));
//   (void) memset(&svg_info->segment,0,sizeof(svg_info->segment));
//   svg_info->n--;
// }

// the below code fragment can be found in:
// MagickCore/color.c
// MagickExport MagickBooleanType QueryColorCompliance(const char *name,
//   const ComplianceType compliance,PixelInfo *color,ExceptionInfo *exception)
// {
//   GeometryInfo
//     geometry_info;
// 
//   double
//     scale;
// 
//   MagickStatusType
//     flags;
// 
//   register const ColorInfo
//     *p;
// 
//   register ssize_t
//     i;
// 
//   ssize_t
//     type;
// 
//   /*
//     Initialize color return value.
//   */
//   assert(name != (const char *) NULL);
//   (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",name);
//   assert(color != (PixelInfo *) NULL);
//   if ((name == (char *) NULL) || (*name == '\0'))
//     name=BackgroundColor;
//   while (isspace((int) ((unsigned char) *name)) != 0)
//     name++;
//   GetPixelInfo((Image *) NULL,color);
//   if (*name == '#')
//     {
//       char
//         c;
// 
//       PixelPacket
//         pixel;
// 
//       QuantumAny
//         range;
// 
//       size_t
//         depth,
//         n;
// 
//       /*
//         Parse hex color.
//       */
//       (void) memset(&pixel,0,sizeof(pixel));
//       name++;
//       for (n=0; isxdigit((int) ((unsigned char) name[n])) != 0; n++) ;
//       if ((n == 3) || (n == 6) || (n == 9) || (n == 12) || (n == 24) ||
//           (n == 48))
//         {
//           do
//           {
//             pixel.red=pixel.green;
//             pixel.green=pixel.blue;
//             pixel.blue=0;
//             for (i=(ssize_t) (n/3-1); i >= 0; i--)
//             {
//               c=(*name++);
//               pixel.blue<<=4;
//               if ((c >= '0') && (c <= '9'))
//                 pixel.blue|=(int) (c-'0');
//               else
//                 if ((c >= 'A') && (c <= 'F'))
//                   pixel.blue|=(int) c-((int) 'A'-10);
//                 else
//                   if ((c >= 'a') && (c <= 'f'))
//                     pixel.blue|=(int) c-((int) 'a'-10);
//                   else
//                     return(MagickFalse);
//             }
//           } while (isxdigit((int) ((unsigned char) *name)) != 0);
//           depth=4*(n/3);
//         }
//       else
//         {
//           if ((n != 4) && (n != 8) && (n != 16) && (n != 32) && (n != 64))
//             {
//               (void) ThrowMagickException(exception,GetMagickModule(),
//                 OptionWarning,"UnrecognizedColor","`%s'",name);
//               return(MagickFalse);
//             }
//           do
//           {
//             pixel.red=pixel.green;
//             pixel.green=pixel.blue;
//             pixel.blue=pixel.alpha;
//             pixel.alpha=0;
//             for (i=(ssize_t) (n/4-1); i >= 0; i--)
//             {
//               c=(*name++);
//               pixel.alpha<<=4;
//               if ((c >= '0') && (c <= '9'))
//                 pixel.alpha|=(int) (c-'0');
//               else
//                 if ((c >= 'A') && (c <= 'F'))
//                   pixel.alpha|=(int) c-((int) 'A'-10);
//                 else
//                   if ((c >= 'a') && (c <= 'f'))
//                     pixel.alpha|=(int) c-((int) 'a'-10);
//                   else
//                     return(MagickFalse);
//             }
//           } while (isxdigit((int) ((unsigned char) *name)) != 0);
//           depth=4*(n/4);
//         }
//       color->colorspace=sRGBColorspace;
//       color->depth=depth;
//       color->alpha_trait=UndefinedPixelTrait;
//       range=GetQuantumRange(depth);
//       color->red=(double) ScaleAnyToQuantum(pixel.red,range);
//       color->green=(double) ScaleAnyToQuantum(pixel.green,range);
//       color->blue=(double) ScaleAnyToQuantum(pixel.blue,range);
//       color->alpha=(double) OpaqueAlpha;
//       if ((n % 3) != 0)
//         {
//           color->alpha_trait=BlendPixelTrait;
//           color->alpha=(double) ScaleAnyToQuantum(pixel.alpha,range);
//         }
//       color->black=0.0;
//       return(MagickTrue);
//     }
//   if (strchr(name,'(') != (char *) NULL)
//     {
//       char
//         colorspace[2*MagickPathExtent];
// 
//       MagickBooleanType
//         icc_color;
// 
//       /*
//         Parse color of the form rgb(100,255,0).
//       */
//       (void) memset(colorspace,0,sizeof(colorspace));
//       (void) CopyMagickString(colorspace,name,MagickPathExtent);
//       for (i=0; colorspace[i] != '\0'; i++)
//         if (colorspace[i] == '(')
//           break;
//       colorspace[i--]='\0';
//       scale=(double) ScaleCharToQuantum(1);
//       icc_color=MagickFalse;
//       if (LocaleNCompare(colorspace,"device-",7) == 0)
//         {
//           (void) CopyMagickString(colorspace,colorspace+7,MagickPathExtent);
//           scale=(double) QuantumRange;
//           icc_color=MagickTrue;
//         }
//       if (LocaleCompare(colorspace,"icc-color") == 0)
//         {
//           register ssize_t
//             j;
// 
//           (void) CopyMagickString(colorspace,name+i+2,MagickPathExtent);
//           for (j=0; colorspace[j] != '\0'; j++)
//             if (colorspace[j] == ',')
//               break;
//           colorspace[j--]='\0';
//           i+=j+3;
//           scale=(double) QuantumRange;
//           icc_color=MagickTrue;
//         }
//       LocaleLower(colorspace);
//       color->alpha_trait=UndefinedPixelTrait;
//       if ((i > 0) && (colorspace[i] == 'a'))
//         {
//           colorspace[i]='\0';
//           color->alpha_trait=BlendPixelTrait;
//         }
//       type=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace);
//       if (type < 0)
//         {
//           (void) ThrowMagickException(exception,GetMagickModule(),
//             OptionWarning,"UnrecognizedColor","`%s'",name);
//           return(MagickFalse);
//         }
//       color->colorspace=(ColorspaceType) type;
//       if ((icc_color == MagickFalse) && (color->colorspace == RGBColorspace))
//         {
//           color->colorspace=sRGBColorspace;  /* as required by SVG standard */
//           color->depth=8;
//         }
//       SetGeometryInfo(&geometry_info);
//       if (i >= (ssize_t) strlen(name))
//         flags=ParseGeometry(name,&geometry_info);
//       else
//         flags=ParseGeometry(name+i+1,&geometry_info);
//       if (flags == 0)
//         {
//           char
//             *colorname;
// 
//           ColorspaceType
//             colorspaceType;
// 
//           MagickBooleanType
//             status;
// 
//           colorspaceType=color->colorspace;
//           if (i >= (ssize_t) strlen(name))
//             colorname=AcquireString(name);
//           else
//             colorname=AcquireString(name+i+1);
//           (void) SubstituteString(&colorname,"(","");
//           (void) SubstituteString(&colorname,")","");
//           status=MagickFalse;
//           if (LocaleCompare(name,colorname) != 0)
//             status=QueryColorCompliance(colorname,AllCompliance,color,
//               exception);
//           color->colorspace=colorspaceType;
//           if (*colorname == '\0')
//             {
//               (void) ThrowMagickException(exception,GetMagickModule(),
//                 OptionWarning,"UnrecognizedColor","`%s'",name);
//               status=MagickFalse;
//             }
//           colorname=DestroyString(colorname);
//           return(status);
//         }
//       if ((flags & PercentValue) != 0)
//         scale=(double) (QuantumRange/100.0);
//       if ((flags & RhoValue) != 0)
//         color->red=(double) ClampToQuantum((MagickRealType) (scale*
//           geometry_info.rho));
//       if ((flags & SigmaValue) != 0)
//         color->green=(double) ClampToQuantum((MagickRealType) (scale*
//           geometry_info.sigma));
//       if ((flags & XiValue) != 0)
//         color->blue=(double) ClampToQuantum((MagickRealType) (scale*
//           geometry_info.xi));
//       color->alpha=(double) OpaqueAlpha;
//       if ((flags & PsiValue) != 0)
//         {
//           if (color->colorspace == CMYKColorspace)
//             color->black=(double) ClampToQuantum((MagickRealType) (scale*
//               geometry_info.psi));
//           else
//             if (color->alpha_trait != UndefinedPixelTrait)
//               color->alpha=(double) ClampToQuantum(QuantumRange*
//                 geometry_info.psi);
//         }
//       if (((flags & ChiValue) != 0) &&
//           (color->alpha_trait != UndefinedPixelTrait))
//         color->alpha=(double) ClampToQuantum(QuantumRange*geometry_info.chi);
//       if (color->colorspace == LabColorspace)
//         {
//           color->red=(MagickRealType) ClampToQuantum((MagickRealType)
//             (QuantumRange*geometry_info.rho/100.0));
//           if ((flags & SigmaValue) != 0)
//             color->green=(MagickRealType) ClampToQuantum((MagickRealType)
//               (scale*geometry_info.sigma+(QuantumRange+1)/2.0));
//           if ((flags & XiValue) != 0)
//             color->blue=(MagickRealType) ClampToQuantum((MagickRealType)
//               (scale*geometry_info.xi+(QuantumRange+1)/2.0));
//         }
//       if ((LocaleCompare(colorspace,"gray") == 0) ||
//           (LocaleCompare(colorspace,"lineargray") == 0))
//         {
//           color->green=color->red;
//           color->blue=color->red;
//           if (((flags & SigmaValue) != 0) &&
//               (color->alpha_trait != UndefinedPixelTrait))
//             color->alpha=(double) ClampToQuantum(QuantumRange*
//               geometry_info.sigma);
//         }
//       if ((LocaleCompare(colorspace,"HCL") == 0) ||
//           (LocaleCompare(colorspace,"HSB") == 0) ||
//           (LocaleCompare(colorspace,"HSL") == 0) ||
//           (LocaleCompare(colorspace,"HSV") == 0) ||
//           (LocaleCompare(colorspace,"HWB") == 0))
//         {
//           double
//             blue,
//             green,
//             red;
// 
//           scale=1.0/255.0;
//           if ((flags & PercentValue) != 0)
//             scale=1.0/100.0;
//           geometry_info.sigma*=scale;
//           geometry_info.xi*=scale;
//           red=0.0;
//           green=0.0;
//           blue=0.0;
//           switch (color->colorspace)
//           {
//             case HCLColorspace:
//             {
//               ConvertHCLToRGB(fmod(fmod(geometry_info.rho,360.0)+360.0,360.0)/
//                 360.0,geometry_info.sigma,geometry_info.xi,&red,&green,&blue);
//               break;
//             }
//             case HSBColorspace:
//             {
//               ConvertHSBToRGB(fmod(fmod(geometry_info.rho,360.0)+360.0,360.0)/
//                 360.0,geometry_info.sigma,geometry_info.xi,&red,&green,&blue);
//               break;
//             }
//             case HSLColorspace:
//             {
//               ConvertHSLToRGB(fmod(fmod(geometry_info.rho,360.0)+360.0,360.0)/
//                 360.0,geometry_info.sigma,geometry_info.xi,&red,&green,&blue);
//               break;
//             }
//             case HSVColorspace:
//             {
//               ConvertHSVToRGB(fmod(fmod(geometry_info.rho,360.0)+360.0,360.0)/
//                 360.0,geometry_info.sigma,geometry_info.xi,&red,&green,&blue);
//               break;
//             }
//             case HWBColorspace:
//             {
//               ConvertHWBToRGB(fmod(fmod(geometry_info.rho,360.0)+360.0,360.0)/
//                 360.0,geometry_info.sigma,geometry_info.xi,&red,&green,&blue);
//               break;
//             }
//             default:
//               break;
//           }
//           color->colorspace=sRGBColorspace;
//           color->red=(MagickRealType) red;
//           color->green=(MagickRealType) green;
//           color->blue=(MagickRealType) blue;
//         }
//       return(MagickTrue);
//     }
//   /*
//     Parse named color.
//   */
//   p=GetColorCompliance(name,compliance,exception);
//   if (p == (const ColorInfo *) NULL)
//     return(MagickFalse);
//   color->colorspace=sRGBColorspace;
//   if ((LocaleNCompare(name,"gray",4) == 0) ||
//       (LocaleNCompare(name,"grey",4) == 0))
//     color->colorspace=GRAYColorspace;
//   color->depth=8;
//   color->alpha_trait=p->color.alpha != OpaqueAlpha ? BlendPixelTrait :
//     UndefinedPixelTrait;
//   color->red=(double) p->color.red;
//   color->green=(double) p->color.green;
//   color->blue=(double) p->color.blue;
//   color->alpha=(double) p->color.alpha;
//   color->black=0.0;
//   return(MagickTrue);
// }

// the below code fragment can be found in:
// MagickCore/policy.c
// PolicyComponentGenesis(void)
// {
//   if (policy_semaphore == (SemaphoreInfo *) NULL)
//     policy_semaphore=AcquireSemaphoreInfo();
//   return(MagickTrue);
// }

