int yr_re_ast_split_at_chaining_point(
    RE_AST* re_ast,
    RE_AST** result_re_ast,
    RE_AST** remainder_re_ast,
    int32_t* min_gap,
    int32_t* max_gap)
{
  RE_NODE* child;
  RE_NODE* concat;

  int result;

  *result_re_ast = re_ast;
  *remainder_re_ast = NULL;
  *min_gap = 0;
  *max_gap = 0;

  if (re_ast->root_node->type != RE_NODE_CONCAT)
    return ERROR_SUCCESS;

  child = re_ast->root_node->children_head;

  while (child != NULL)
  {
    if 
    // Check if the current child node is non-greedy and has the type RE_NODE_RANGE_ANY,
    // with start or end values exceeding a specified threshold. If so, create a new
    // RE_AST for the remainder, and a new concatenation node to represent the part of
    // the tree up to the current node. Update pointers to split the original tree
    // at the current node, setting the min_gap and max_gap to the child's start and
    // end values, respectively. Destroy the current node after the split, and return
    // an appropriate success or error code.
    // <MASK>

    child = child->next_sibling;
  }

  return ERROR_SUCCESS;
}