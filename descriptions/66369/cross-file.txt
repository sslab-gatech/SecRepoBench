// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// cram/cram_decode.c
// static int cram_decode_slice_xref(cram_slice *s, int required_fields) {
//     int rec;
// 
//     if (!(required_fields & (SAM_RNEXT | SAM_PNEXT | SAM_TLEN))) {
//         for (rec = 0; rec < s->hdr->num_records; rec++) {
//             cram_record *cr = &s->crecs[rec];
// 
//             cr->tlen = 0;
//             cr->mate_pos = 0;
//             cr->mate_ref_id = -1;
//         }
// 
//         return 0;
//     }
// 
//     for (rec = 0; rec < s->hdr->num_records; rec++) {
//         cram_record *cr = &s->crecs[rec];
// 
//         if (cr->mate_line >= 0) {
//             if (cr->mate_line < s->hdr->num_records) {
//                 /*
//                  * On the first read, loop through computing lengths.
//                  * It's not perfect as we have one slice per reference so we
//                  * cannot detect when TLEN should be zero due to seqs that
//                  * map to multiple references.
//                  *
//                  * We also cannot set tlen correct when it spans a slice for
//                  * other reasons. This may make tlen too small. Should we
//                  * fix this by forcing TLEN to be stored verbatim in such cases?
//                  *
//                  * Or do we just admit defeat and output 0 for tlen? It's the
//                  * safe option...
//                  */
//                 if (cr->tlen == INT64_MIN) {
//                     int id1 = rec, id2 = rec;
//                     int64_t aleft = cr->apos, aright = cr->aend;
//                     int64_t tlen;
//                     int ref = cr->ref_id;
// 
//                     // number of segments starting at the same point.
//                     int left_cnt = 0;
// 
//                     do {
//                         if (aleft > s->crecs[id2].apos)
//                             aleft = s->crecs[id2].apos, left_cnt = 1;
//                         else if (aleft == s->crecs[id2].apos)
//                             left_cnt++;
//                         if (aright < s->crecs[id2].aend)
//                             aright = s->crecs[id2].aend;
//                         if (s->crecs[id2].mate_line == -1) {
//                             s->crecs[id2].mate_line = rec;
//                             break;
//                         }
//                         if (s->crecs[id2].mate_line <= id2 ||
//                             s->crecs[id2].mate_line >= s->hdr->num_records)
//                             return -1;
//                         id2 = s->crecs[id2].mate_line;
// 
//                         if (s->crecs[id2].ref_id != ref)
//                             ref = -1;
//                     } while (id2 != id1);
// 
//                     if (ref != -1) {
//                         tlen = aright - aleft + 1;
//                         id1 = id2 = rec;
// 
//                         /*
//                          * When we have two seqs with identical start and
//                          * end coordinates, set +/- tlen based on 1st/last
//                          * bit flags instead, as a tie breaker.
//                          */
//                         if (s->crecs[id2].apos == aleft) {
//                             if (left_cnt == 1 ||
//                                 (s->crecs[id2].flags & BAM_FREAD1))
//                                 s->crecs[id2].tlen = tlen;
//                             else
//                                 s->crecs[id2].tlen = -tlen;
//                         } else {
//                             s->crecs[id2].tlen = -tlen;
//                         }
// 
//                         id2 = s->crecs[id2].mate_line;
//                         while (id2 != id1) {
//                             if (s->crecs[id2].apos == aleft) {
//                                 if (left_cnt == 1 ||
//                                     (s->crecs[id2].flags & BAM_FREAD1))
//                                     s->crecs[id2].tlen = tlen;
//                                 else
//                                     s->crecs[id2].tlen = -tlen;
//                             } else {
//                                 s->crecs[id2].tlen = -tlen;
//                             }
//                             id2 = s->crecs[id2].mate_line;
//                         }
//                     } else {
//                         id1 = id2 = rec;
// 
//                         s->crecs[id2].tlen = 0;
//                         id2 = s->crecs[id2].mate_line;
//                         while (id2 != id1) {
//                             s->crecs[id2].tlen = 0;
//                             id2 = s->crecs[id2].mate_line;
//                         }
//                     }
//                 }
// 
//                 cr->mate_pos = s->crecs[cr->mate_line].apos;
//                 cr->mate_ref_id = s->crecs[cr->mate_line].ref_id;
// 
//                 // paired
//                 cr->flags |= BAM_FPAIRED;
// 
//                 // set mate unmapped if needed
//                 if (s->crecs[cr->mate_line].flags & BAM_FUNMAP) {
//                     cr->flags |= BAM_FMUNMAP;
//                     cr->tlen = 0;
//                 }
//                 if (cr->flags & BAM_FUNMAP) {
//                     cr->tlen = 0;
//                 }
// 
//                 // set mate reversed if needed
//                 if (s->crecs[cr->mate_line].flags & BAM_FREVERSE)
//                     cr->flags |= BAM_FMREVERSE;
//             } else {
//                 hts_log_error("Mate line out of bounds: %d vs [0, %d]",
//                               cr->mate_line, s->hdr->num_records-1);
//             }
// 
//             /* FIXME: construct read names here too if needed */
//         } else {
//             if (cr->mate_flags & CRAM_M_REVERSE) {
//                 cr->flags |= BAM_FPAIRED | BAM_FMREVERSE;
//             }
//             if (cr->mate_flags & CRAM_M_UNMAP) {
//                 cr->flags |= BAM_FMUNMAP;
//                 //cr->mate_ref_id = -1;
//             }
//             if (!(cr->flags & BAM_FPAIRED))
//                 cr->mate_ref_id = -1;
//         }
// 
//         if (cr->tlen == INT64_MIN)
//             cr->tlen = 0; // Just incase
//     }
// 
//     for (rec = 0; rec < s->hdr->num_records; rec++) {
//         cram_record *cr = &s->crecs[rec];
//         if (cr->explicit_tlen != INT64_MIN)
//             cr->tlen = cr->explicit_tlen;
//     }
// 
//     return 0;
// }

// the below code fragment can be found in:
// cram/cram_decode.c
// static int cram_decode_aux(cram_fd *fd,
//                            cram_container *c, cram_slice *s,
//                            cram_block *blk, cram_record *cr,
//                            int *has_MD, int *has_NM) {
//     int i, r = 0, out_sz = 1;
//     int32_t TL = 0;
//     unsigned char *TN;
//     uint32_t ds = s->data_series;
// 
//     if (!(ds & (CRAM_TL|CRAM_aux))) {
//         cr->aux = 0;
//         cr->aux_size = 0;
//         return 0;
//     }
// 
//     if (!c->comp_hdr->codecs[DS_TL]) return -1;
//     r |= c->comp_hdr->codecs[DS_TL]->decode(s, c->comp_hdr->codecs[DS_TL], blk,
//                                             (char *)&TL, &out_sz);
//     if (r || TL < 0 || TL >= c->comp_hdr->nTL)
//         return -1;
// 
//     TN = c->comp_hdr->TL[TL];
//     cr->ntags = strlen((char *)TN)/3; // optimise to remove strlen
// 
//     //printf("TC=%d\n", cr->ntags);
//     cr->aux_size = 0;
//     cr->aux = BLOCK_SIZE(s->aux_blk);
// 
//     if (!(ds & CRAM_aux))
//         return 0;
// 
//     for (i = 0; i < cr->ntags; i++) {
//         int32_t id, out_sz = 1;
//         unsigned char tag_data[7];
//         cram_map *m;
// 
//         if (TN[0] == 'M' && TN[1] == 'D' && has_MD)
//             *has_MD = (BLOCK_SIZE(s->aux_blk)+3) * (TN[2] == '*' ? -1 : 1);
//         if (TN[0] == 'N' && TN[1] == 'M' && has_NM)
//             *has_NM = (BLOCK_SIZE(s->aux_blk)+3) * (TN[2] == '*' ? -1 : 1);;
// 
//         //printf("Tag %d/%d\n", i+1, cr->ntags);
//         tag_data[0] = TN[0];
//         tag_data[1] = TN[1];
//         tag_data[2] = TN[2];
//         id = (tag_data[0]<<16) | (tag_data[1]<<8) | tag_data[2];
// 
//         if (CRAM_MAJOR_VERS(fd->version) >= 4 && TN[2] == '*') {
//             // Place holder, fill out contents later.
//             int tag_data_size;
//             if (TN[0] == 'N' && TN[1] == 'M') {
//                 // Use a fixed size, so we can allocate room for it now.
//                 memcpy(&tag_data[2], "I\0\0\0\0", 5);
//                 tag_data_size = 7;
//             } else if (TN[0] == 'R' && TN[1] == 'G') {
//                 // RG is variable size, but known already.  Insert now
//                 TN += 3;
//                 // Equiv to fd->header->hrecs->rg[cr->rg], but this is the
//                 // new header API equivalent.
//                 const char *rg = sam_hdr_line_name(fd->header, "RG", cr->rg);
//                 if (!rg)
//                     continue;
// 
//                 size_t rg_len = strlen(rg);
//                 tag_data[2] = 'Z';
//                 BLOCK_APPEND(s->aux_blk, (char *)tag_data, 3);
//                 BLOCK_APPEND(s->aux_blk, rg, rg_len);
//                 BLOCK_APPEND_CHAR(s->aux_blk, '\0');
//                 cr->aux_size += 3 + rg_len + 1;
//                 cr->rg = -1; // prevents auto-add later
//                 continue;
//             } else {
//                 // Unknown size.  We'll insert MD into stream later.
//                 tag_data[2] = 'Z';
//                 tag_data_size = 3;
//             }
//             BLOCK_APPEND(s->aux_blk, (char *)tag_data, tag_data_size);
//             cr->aux_size += tag_data_size;
//             TN += 3;
//         } else {
//             TN += 3;
//             m = map_find(c->comp_hdr->tag_encoding_map, tag_data, id);
//             if (!m)
//                 return -1;
// 
//             BLOCK_APPEND(s->aux_blk, (char *)tag_data, 3);
// 
//             if (!m->codec) return -1;
//             r |= m->codec->decode(s, m->codec, blk, (char *)s->aux_blk, &out_sz);
//             if (r) break;
//             cr->aux_size += out_sz + 3;
// 
//             // cF CRAM flags.
//             if (TN[-3]=='c' && TN[-2]=='F' && TN[-1]=='C' && out_sz == 1) {
//                 // Remove cF tag
//                 uint8_t cF = BLOCK_END(s->aux_blk)[-1];
//                 BLOCK_SIZE(s->aux_blk) -= out_sz+3;
//                 cr->aux_size -= out_sz+3;
// 
//                 // bit 1 => don't auto-decode MD.
//                 // Pretend MD is present verbatim, so we don't auto-generate
//                 if ((cF & 1) && has_MD && *has_MD == 0)
//                     *has_MD = 1;
// 
//                 // bit 1 => don't auto-decode NM
//                 if ((cF & 2) && has_NM && *has_NM == 0)
//                     *has_NM = 1;
//             }
//         }
// 
//         // We could go to 2^32 fine, but we shouldn't be hitting this anyway,
//         // and it's protecting against memory hogs too.
//         if (BLOCK_SIZE(s->aux_blk) > (1u<<31)) {
//             hts_log_error("CRAM->BAM aux block size overflow");
//             goto block_err;
//         }
//     }
// 
//     return r;
// 
//  block_err:
//     return -1;
// }

// the below code fragment can be found in:
// cram/cram_decode.c
// static cram_container *cram_first_slice(cram_fd *fd) {
//     cram_container *c;
// 
//     do {
//         if (fd->ctr)
//             cram_free_container(fd->ctr);
// 
//         if (!(c = fd->ctr = cram_read_container(fd)))
//             return NULL;
//         c->curr_slice_mt = c->curr_slice;
//     } while (c->length == 0);
// 
//     /*
//      * The first container may be a result of a sub-range query.
//      * In which case it may still not be the optimal starting point
//      * due to skipped containers/slices in the index.
//      */
//     // No need for locks here as we're in the main thread.
//     if (fd->range.refid != -2) {
//         while (c->ref_seq_id != -2 &&
//                (c->ref_seq_id < fd->range.refid ||
//                 (fd->range.refid >= 0 && c->ref_seq_id == fd->range.refid
//                  && c->ref_seq_start + c->ref_seq_span-1 < fd->range.start))) {
//             if (0 != cram_seek(fd, c->length, SEEK_CUR))
//                 return NULL;
//             cram_free_container(fd->ctr);
//             do {
//                 if (!(c = fd->ctr = cram_read_container(fd)))
//                     return NULL;
//             } while (c->length == 0);
//         }
// 
//         if (c->ref_seq_id != -2 && c->ref_seq_id != fd->range.refid) {
//             fd->eof = 1;
//             return NULL;
//         }
//     }
// 
//     if (!(c->comp_hdr_block = cram_read_block(fd)))
//         return NULL;
//     if (c->comp_hdr_block->content_type != COMPRESSION_HEADER)
//         return NULL;
// 
//     c->comp_hdr = cram_decode_compression_header(fd, c->comp_hdr_block);
//     if (!c->comp_hdr)
//         return NULL;
//     if (!c->comp_hdr->AP_delta &&
//         sam_hrecs_sort_order(fd->header->hrecs) != ORDER_COORD) {
//         pthread_mutex_lock(&fd->ref_lock);
//         fd->unsorted = 1;
//         pthread_mutex_unlock(&fd->ref_lock);
//     }
// 
//     return c;
// }

// the below code fragment can be found in:
// cram/cram_encode.c
// int cram_put_bam_seq(cram_fd *fd, bam_seq_t *b) {
//     cram_container *c;
// 
//     if (!fd->ctr) {
//         fd->ctr = cram_new_container(fd->seqs_per_slice,
//                                      fd->slices_per_container);
//         if (!fd->ctr)
//             return -1;
//         fd->ctr->record_counter = fd->record_counter;
// 
//         pthread_mutex_lock(&fd->ref_lock);
//         fd->ctr->no_ref = fd->no_ref;
//         fd->ctr->embed_ref = fd->embed_ref;
//         pthread_mutex_unlock(&fd->ref_lock);
//     }
//     c = fd->ctr;
// 
//     int embed_ref = c->embed_ref;
// 
//     if (!c->slice || c->curr_rec == c->max_rec ||
//         (bam_ref(b) != c->curr_ref && c->curr_ref >= -1) ||
//         (c->s_num_bases + c->s_aux_bytes >= fd->bases_per_slice)) {
//         int slice_rec, curr_rec, multi_seq = fd->multi_seq == 1;
//         int curr_ref = c->slice ? c->curr_ref : bam_ref(b);
// 
//         /*
//          * Start packing slices when we routinely have under 1/4tr full.
//          *
//          * This option isn't available if we choose to embed references
//          * since we can only have one per slice.
//          *
//          * The multi_seq var here refers to our intention for the next slice.
//          * This slice has already been encoded so we output as-is.
//          */
//         if (fd->multi_seq == -1 && c->curr_rec < c->max_rec/4+10 &&
//             fd->last_slice && fd->last_slice < c->max_rec/4+10 &&
//             embed_ref<=0) {
//             if (!c->multi_seq)
//                 hts_log_info("Multi-ref enabled for next container");
//             multi_seq = 1;
//         } else if (fd->multi_seq == 1) {
//             pthread_mutex_lock(&fd->metrics_lock);
//             if (fd->last_RI_count <= c->max_slice && fd->multi_seq_user != 1) {
//                 multi_seq = 0;
//                 hts_log_info("Multi-ref disabled for next container");
//             }
//             pthread_mutex_unlock(&fd->metrics_lock);
//         }
// 
//         slice_rec = c->slice_rec;
//         curr_rec  = c->curr_rec;
// 
//         if (CRAM_MAJOR_VERS(fd->version) == 1 ||
//             c->curr_rec == c->max_rec || fd->multi_seq != 1 || !c->slice ||
//             c->s_num_bases + c->s_aux_bytes >= fd->bases_per_slice) {
//             if (NULL == (c = cram_next_container(fd, b))) {
//                 if (fd->ctr) {
//                     // prevent cram_close attempting to flush
//                     fd->ctr_mt = fd->ctr; // delay free when threading
//                     fd->ctr = NULL;
//                 }
//                 return -1;
//             }
//         }
// 
//         /*
//          * Due to our processing order, some things we've already done we
//          * cannot easily undo. So when we first notice we should be packing
//          * multiple sequences per container we emit the small partial
//          * container as-is and then start a fresh one in a different mode.
//          */
//         if (multi_seq == 0 && fd->multi_seq == 1 && fd->multi_seq_user == -1) {
//             // User selected auto-mode, we're currently using multi-seq, but
//             // have detected we don't need to.  Switch back to auto.
//             fd->multi_seq = -1;
//         } else if (multi_seq) {
//             // We detected we need multi-seq
//             fd->multi_seq = 1;
//             c->multi_seq = 1;
//             c->pos_sorted = 0;
// 
//             // Cram_next_container may end up flushing an existing one and
//             // triggering fd->embed_ref=2 if no reference is found.
//             // Embedded refs are incompatible with multi-seq, so we bail
//             // out and switch to no_ref in this scenario.  We do this
//             // within the container only, as multi_seq may be temporary
//             // and we switch back away from it again.
//             pthread_mutex_lock(&fd->ref_lock);
//             if (fd->embed_ref > 0 && c->curr_rec == 0 && c->curr_slice == 0) {
//                 hts_log_warning("Changing from embed_ref to no_ref mode");
//                 // Should we update fd->embed_ref and no_ref here too?
//                 // Doing so means if we go into multi-seq and back out
//                 // again, eg due a cluster of tiny refs in the middle of
//                 // much larger ones, then we bake in no-ref mode.
//                 //
//                 // However for unsorted data we're realistically not
//                 // going to switch back.
//                 c->embed_ref = fd->embed_ref = 0; // or -1 for auto?
//                 c->no_ref = fd->no_ref = 1;
//             }
//             pthread_mutex_unlock(&fd->ref_lock);
// 
//             if (!c->refs_used) {
//                 pthread_mutex_lock(&fd->ref_lock);
//                 c->refs_used = calloc(fd->refs->nref, sizeof(int));
//                 pthread_mutex_unlock(&fd->ref_lock);
//                 if (!c->refs_used)
//                     return -1;
//             }
//         }
// 
//         fd->last_slice = curr_rec - slice_rec;
//         c->slice_rec = c->curr_rec;
// 
//         // Have we seen this reference before?
//         if (bam_ref(b) >= 0 && curr_ref >= 0 && bam_ref(b) != curr_ref &&
//             embed_ref<=0 && !fd->unsorted && multi_seq) {
// 
//             if (!c->refs_used) {
//                 pthread_mutex_lock(&fd->ref_lock);
//                 c->refs_used = calloc(fd->refs->nref, sizeof(int));
//                 pthread_mutex_unlock(&fd->ref_lock);
//                 if (!c->refs_used)
//                     return -1;
//             } else if (c->refs_used && c->refs_used[bam_ref(b)]) {
//                 pthread_mutex_lock(&fd->ref_lock);
//                 fd->unsorted = 1;
//                 fd->multi_seq = 1;
//                 pthread_mutex_unlock(&fd->ref_lock);
//             }
//         }
// 
//         c->curr_ref = bam_ref(b);
//         if (c->refs_used && c->curr_ref >= 0) c->refs_used[c->curr_ref]++;
//     }
// 
//     if (!c->bams) {
//         /* First time through, allocate a set of bam pointers */
//         pthread_mutex_lock(&fd->bam_list_lock);
//         if (fd->bl) {
//             spare_bams *spare = fd->bl;
//             c->bams = spare->bams;
//             fd->bl = spare->next;
//             free(spare);
//         } else {
//             c->bams = calloc(c->max_c_rec, sizeof(bam_seq_t *));
//             if (!c->bams) {
//                 pthread_mutex_unlock(&fd->bam_list_lock);
//                 return -1;
//             }
//         }
//         pthread_mutex_unlock(&fd->bam_list_lock);
//     }
// 
//     /* Copy or alloc+copy the bam record, for later encoding */
//     if (c->bams[c->curr_c_rec]) {
//         if (bam_copy1(c->bams[c->curr_c_rec], b) == NULL)
//             return -1;
//     } else {
//         c->bams[c->curr_c_rec] = bam_dup1(b);
//         if (c->bams[c->curr_c_rec] == NULL)
//             return -1;
//     }
//     if (bam_seq_len(b)) {
//         c->s_num_bases += bam_seq_len(b);
//     } else {
//         // No sequence in BAM record.  CRAM doesn't directly support this
//         // case, it ends up being stored as a string of N's for each query
//         // consuming CIGAR operation.  As this can become very inefficient
//         // in time and memory, data where the query length is excessively
//         // long are rejected.
//         hts_pos_t qlen = bam_cigar2qlen(b->core.n_cigar, bam_get_cigar(b));
//         if (qlen > 100000000) {
//             hts_log_error("CIGAR query length %"PRIhts_pos
//                           " for read \"%s\" is too long",
//                           qlen, bam_get_qname(b));
//             return -1;
//         }
//         c->s_num_bases += qlen;
//     }
//     c->curr_rec++;
//     c->curr_c_rec++;
//     c->s_aux_bytes += bam_get_l_aux(b);
//     c->n_mapped += (bam_flag(b) & BAM_FUNMAP) ? 0 : 1;
//     fd->record_counter++;
// 
//     return 0;
// }

// the below code fragment can be found in:
// cram/cram_decode.c
// void *cram_decode_slice_thread(void *arg) {
//     cram_decode_job *j = (cram_decode_job *)arg;
// 
//     j->exit_code = cram_decode_slice(j->fd, j->c, j->s, j->h);
// 
//     return j;
// }

