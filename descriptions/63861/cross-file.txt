// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/cmstypes.c
// static
// cmsBool Type_Text_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)
// {
//     cmsMLU* mlu = (cmsMLU*) Ptr;
//     cmsUInt32Number size;
//     cmsBool  rc;
//     char* Text;
// 
//     // Get the size of the string. Note there is an extra "\0" at the end
//     size = cmsMLUgetASCII(mlu, cmsNoLanguage, cmsNoCountry, NULL, 0);
//     if (size == 0) return FALSE;       // Cannot be zero!
// 
//     // Create memory
//     Text = (char*) _cmsMalloc(self ->ContextID, size);
//     if (Text == NULL) return FALSE;
// 
//     cmsMLUgetASCII(mlu, cmsNoLanguage, cmsNoCountry, Text, size);
// 
//     // Write it, including separator
//     rc = io ->Write(io, size, Text);
// 
//     _cmsFree(self ->ContextID, Text);
//     return rc;
// 
//     cmsUNUSED_PARAMETER(nItems);
// }

// the below code fragment can be found in:
// src/cmstypes.c
// static
// cmsBool  WriteCountAndString(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsMLU* mlu, const char* Section)
// {
//  cmsUInt32Number TextSize;
//  char* Text;
// 
//     TextSize = cmsMLUgetASCII(mlu, "PS", Section, NULL, 0);
//     Text     = (char*) _cmsMalloc(self ->ContextID, TextSize);
// 
//     if (!_cmsWriteUInt32Number(io, TextSize)) return FALSE;
// 
//     if (cmsMLUgetASCII(mlu, "PS", Section, Text, TextSize) == 0) return FALSE;
// 
//     if (!io ->Write(io, TextSize, Text)) return FALSE;
//     _cmsFree(self ->ContextID, Text);
// 
//     return TRUE;
// }

// the below code fragment can be found in:
// src/cmstypes.c
// static
// void* Type_Text_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)
// {
//     return (void*) cmsMLUdup((cmsMLU*) Ptr);
// 
//     cmsUNUSED_PARAMETER(n);
//     cmsUNUSED_PARAMETER(self);
// }

// the below code fragment can be found in:
// src/cmstypes.c
// static
// void* Type_Text_Description_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)
// {
//     return (void*) cmsMLUdup((cmsMLU*) Ptr);
// 
//     cmsUNUSED_PARAMETER(n);
//     cmsUNUSED_PARAMETER(self);
// }

// the below code fragment can be found in:
// src/cmstypes.c
// static
// cmsBool  Type_MLU_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)
// {
//     cmsMLU* mlu =(cmsMLU*) Ptr;
//     cmsUInt32Number HeaderSize;
//     cmsUInt32Number  Len, Offset;
//     cmsUInt32Number i;
// 
//     if (Ptr == NULL) {
// 
//           // Empty placeholder
//           if (!_cmsWriteUInt32Number(io, 0)) return FALSE;
//           if (!_cmsWriteUInt32Number(io, 12)) return FALSE;
//           return TRUE;
//     }
// 
//     if (!_cmsWriteUInt32Number(io, mlu ->UsedEntries)) return FALSE;
//     if (!_cmsWriteUInt32Number(io, 12)) return FALSE;
// 
//     HeaderSize = 12 * mlu ->UsedEntries + sizeof(_cmsTagBase);
// 
//     for (i=0; i < mlu ->UsedEntries; i++) {
// 
//         Len    =  mlu ->Entries[i].Len;
//         Offset =  mlu ->Entries[i].StrW;
// 
//         Len    = (Len * sizeof(cmsUInt16Number)) / sizeof(wchar_t);
//         Offset = (Offset * sizeof(cmsUInt16Number)) / sizeof(wchar_t) + HeaderSize + 8;
// 
//         if (!_cmsWriteUInt16Number(io, mlu ->Entries[i].Language)) return FALSE;
//         if (!_cmsWriteUInt16Number(io, mlu ->Entries[i].Country))  return FALSE;
//         if (!_cmsWriteUInt32Number(io, Len)) return FALSE;
//         if (!_cmsWriteUInt32Number(io, Offset)) return FALSE;
//     }
// 
//     if (!_cmsWriteWCharArray(io, mlu ->PoolUsed / sizeof(wchar_t), (wchar_t*)  mlu ->MemPool)) return FALSE;
// 
//     return TRUE;
// 
//     cmsUNUSED_PARAMETER(nItems);
//     cmsUNUSED_PARAMETER(self);
// }

