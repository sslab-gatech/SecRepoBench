// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// mrbgems/mruby-string-ext/src/string.c
// static mrb_value
// str_ascii_only_p(mrb_state *mrb, mrb_value str)
// {
//   struct RString *s = mrb_str_ptr(str);
//   const char *p = RSTR_PTR(s);
//   const char *e = p + RSTR_LEN(s);
// 
//   while (p < e) {
//     if (*p & 0x80) return mrb_false_value();
//     p++;
//   }
//   RSTR_SET_SINGLE_BYTE_FLAG(mrb_str_ptr(str));
//   return mrb_true_value();
// }

// the below code fragment can be found in:
// mrbgems/mruby-io/src/file_test.c
// static mrb_value
// mrb_filetest_s_socket_p(mrb_state *mrb, mrb_value klass)
// {
// #if defined(_WIN32) || defined(_WIN64)
//   mrb_raise(mrb, E_NOTIMP_ERROR, "socket is not supported on this platform");
// #else
// #ifndef S_ISSOCK
// #  ifdef _S_ISSOCK
// #    define S_ISSOCK(m) _S_ISSOCK(m)
// #  else
// #    ifdef _S_IFSOCK
// #      define S_ISSOCK(m) (((m) & S_IFMT) == _S_IFSOCK)
// #    else
// #      ifdef S_IFSOCK
// #        define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)
// #      endif
// #    endif
// #  endif
// #endif
// 
// #ifdef S_ISSOCK
//   struct stat st;
//   mrb_value obj = mrb_get_arg1(mrb);
// 
//   if (mrb_stat(mrb, obj, &st) < 0)
//     return mrb_false_value();
//   if (S_ISSOCK(st.st_mode))
//     return mrb_true_value();
// #endif
// 
//   return mrb_false_value();
// #endif
// }

// the below code fragment can be found in:
// mrbgems/mruby-io/src/file_test.c
// static mrb_value
// mrb_filetest_s_exist_p(mrb_state *mrb, mrb_value klass)
// {
//   struct stat st;
//   mrb_value obj = mrb_get_arg1(mrb);
// 
//   if (mrb_stat(mrb, obj, &st) < 0)
//     return mrb_false_value();
// 
//   return mrb_true_value();
// }

// the below code fragment can be found in:
// src/string.c
// static void
// str_share(mrb_state *mrb, struct RString *orig, struct RString *s)
// {
//   size_t len = (size_t)orig->as.heap.len;
// 
//   mrb_assert(!RSTR_EMBED_P(orig));
//   if (RSTR_NOFREE_P(orig)) {
//     str_init_nofree(s, orig->as.heap.ptr, len);
//   }
//   else if (RSTR_SHARED_P(orig)) {
//     str_init_shared(mrb, orig, s, orig->as.heap.aux.shared);
//   }
//   else if (RSTR_FSHARED_P(orig)) {
//     str_init_fshared(orig, s, orig->as.heap.aux.fshared);
//   }
//   else {
//     if (orig->as.heap.aux.capa > orig->as.heap.len) {
//       orig->as.heap.ptr = (char*)mrb_realloc(mrb, orig->as.heap.ptr, len+1);
//       orig->as.heap.aux.capa = (mrb_ssize)len;
//     }
//     str_init_shared(mrb, orig, s, NULL);
//     str_init_shared(mrb, orig, orig, s->as.heap.aux.shared);
//   }
// }

// the below code fragment can be found in:
// mrbgems/mruby-struct/src/struct.c
// static mrb_value
// mrb_struct_set_m(mrb_state *mrb, mrb_value obj)
// {
//   mrb_int i = mrb_integer(mrb_proc_cfunc_env_get(mrb, 0));
//   mrb_value val = mrb_get_arg1(mrb);
// 
//   mrb_ary_set(mrb, obj, i, val);
//   return val;
// }

