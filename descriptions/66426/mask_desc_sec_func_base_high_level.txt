static inline mrb_int
memsearch_swar(const char *xs, long m, const char *ys, long n)
{
#ifdef MRB_64BIT
#define bitint uint64_t
#define MASK1 0x0101010101010101ull
#define MASK2 0x7f7f7f7f7f7f7f7full
#define MASK3 0x8080808080808080ull
#else
#define bitint uint32_t
#define MASK1 0x01010101ul
#define MASK2 0x7f7f7f7ful
#define MASK3 0x80808080ul
#endif
#if defined(MRB_ENDIAN_BIG)
#ifdef MRB_64BIT
#define MASK4 0x8000000000000000ull
#else
#define MASK4 0x80000000ul
#endif
#else
#define MASK4 0x80
#endif

  // Implement a search mechanism that utilizes SIMD-like operations to
  // efficiently find a substring within a larger string. The code block
  // should calculate potential starting points by comparing the first
  // and last characters of the substring against segments of the main
  // string using bitwise operations. Once potential matches are identified,
  // verify these matches by comparing the remaining characters of the
  // substring. If a match is found, return the index of its occurrence in
  // the main string. If no match is found in these segments, continue to
  // search by incrementing through the main string, ensuring the entire
  // main string is scanned before returning a result.
  // <MASK>

  if (i+m < n) {
    const char *p = s0;
    const char *e = ys + n;
    for (;p<e;) {
      size_t len = e-p;
      p = (const char*)memchr(p, *xs, len);
      if (p == NULL || len < m) break;
      if (memcmp(p+1, xs+1, m-1) == 0) return (mrb_int)(p - ys);
      p++;
    }
  }

  return -1;
}