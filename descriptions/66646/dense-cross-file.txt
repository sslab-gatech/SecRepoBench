// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/lib/libdwarf/dwarf_form.c
int
dwarf_convert_to_global_offset(Dwarf_Attribute attr,
    Dwarf_Off offset,
    Dwarf_Off * ret_offset,
    Dwarf_Error * error)
{
    Dwarf_Debug dbg = 0;
    Dwarf_CU_Context cu_context = 0;
    int res = 0;

    res  = get_attr_dbg(&dbg,&cu_context,attr,error);
    if (res != DW_DLV_OK) {
        return res;
    }
    switch (attr->ar_attribute_form) {
    case DW_FORM_ref1:
    case DW_FORM_ref2:
    case DW_FORM_ref4:
    case DW_FORM_ref8:
    case DW_FORM_ref_udata:
        /*  It is a cu-local offset. Convert to section-global. */
        /*  It would be nice to put some code to check
            legality of the offset */
        /*  cc_debug_offset always has any DWP Package File
            offset included (when the cu_context created)
            so there is no extra work for DWP.
            Globalize the offset */
        offset += cu_context->cc_debug_offset;

        break;

    case DW_FORM_ref_addr:
        /*  This offset is defined to be debug_info global already, so
            use this value unaltered.

            Since a DWP package file is not relocated there
            is no way that this reference offset to an address in
            any other CU can be correct for a DWP Package File offset
            */
        break;
    default: {
        dwarfstring m;

        dwarfstring_constructor(&m);
        dwarfstring_append_printf_u(&m,
            "DW_DLE_BAD_REF_FORM. The form "
            "code is 0x%x which cannot be converted to a global "
            " offset by "
            "dwarf_convert_to_global_offset()",
            attr->ar_attribute_form);
        _dwarf_error_string(dbg, error, DW_DLE_BAD_REF_FORM,
            dwarfstring_string(&m));
        dwarfstring_destructor(&m);
        return DW_DLV_ERROR;
        }
    }

    *ret_offset = (offset);
    return DW_DLV_OK;
}

// the below code fragment can be found in:
// src/lib/libdwarf/dwarf_form.c
int
dwarf_formref(Dwarf_Attribute attr,
    Dwarf_Off * ret_offset,
    Dwarf_Bool * ret_is_info,
    Dwarf_Error * error)
{
    Dwarf_Debug dbg = 0;
    Dwarf_Unsigned offset = 0;
    Dwarf_CU_Context cu_context = 0;
    Dwarf_Unsigned maximumoffset = 0;
    int res = DW_DLV_ERROR;
    Dwarf_Byte_Ptr section_end = 0;
    Dwarf_Bool is_info = TRUE;

    *ret_offset = 0;
    res  = get_attr_dbg(&dbg,&cu_context,attr,error);
    if (res != DW_DLV_OK) {
        return res;
    }
    section_end =
        _dwarf_calculate_info_section_end_ptr(cu_context);
    is_info = cu_context->cc_is_info;

    switch (attr->ar_attribute_form) {

    case DW_FORM_ref1:
        offset = *(Dwarf_Small *) attr->ar_debug_ptr;
        break;

    case DW_FORM_ref2:
        READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,
            attr->ar_debug_ptr, DWARF_HALF_SIZE,
            error,section_end);
        break;

    case DW_FORM_ref4:
        READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,
            attr->ar_debug_ptr, DWARF_32BIT_SIZE,
            error,section_end);
        break;

    case DW_FORM_ref8:
        READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,
            attr->ar_debug_ptr, DWARF_64BIT_SIZE,
            error,section_end);
        break;

    case DW_FORM_ref_udata: {
        Dwarf_Byte_Ptr ptr = attr->ar_debug_ptr;
        Dwarf_Unsigned localoffset = 0;

        DECODE_LEB128_UWORD_CK(ptr,localoffset,
            dbg,error,section_end);
        offset = localoffset;
        break;
    }
    case DW_FORM_ref_sig8: {
        /*  We need to look for a local reference here.
            The function we are in is only CU_local
            offsets returned. */
#if 0  /* check for a local sig8 reference unimplemented. */
        Dwarf_Sig8 sig8;
        memcpy(&sig8,ptr,sizeof(Dwarf_Sig8));
        res = dwarf_find_die_given_sig8(dbg,
            &sig8, ...
        We could look, then determine if
        resulting offset is actually local.
#endif /*0*/

        /*  We cannot handle this here.
            The reference could be to .debug_types
            or another CU!
            not a .debug_info CU local offset. */
        _dwarf_error(dbg, error, DW_DLE_REF_SIG8_NOT_HANDLED);
        return DW_DLV_ERROR;
    }
    default: {
        dwarfstring m;
        const char * fname = 0;
        const char * aname = 0;

        dwarf_get_FORM_name(attr->ar_attribute_form,&fname);
        dwarf_get_AT_name(attr->ar_attribute,&aname);
        dwarfstring_constructor(&m);
        dwarfstring_append_printf_u(&m,
            "DW_DLE_BAD_REF_FORM. The form "
            "code is 0x%x ",
            attr->ar_attribute_form);
        dwarfstring_append(&m,(char *)fname);
        dwarfstring_append_printf_s(&m," on attribute %s, "
            "which does not have an offset"
            " for dwarf_formref() to return.",(char *)aname);
        _dwarf_error_string(dbg, error, DW_DLE_BAD_REF_FORM,
            dwarfstring_string(&m));
        dwarfstring_destructor(&m);
        return DW_DLV_ERROR;
        }
    }

    /*  Check that offset is within current
        cu portion of .debug_info. */

    maximumoffset = cu_context->cc_length +
        cu_context->cc_length_size +
        cu_context->cc_extension_size;
    if (offset >= maximumoffset) {
        /*  For the DW_TAG_compile_unit is legal to have the
            DW_AT_sibling attribute outside the current cu portion of
            .debug_info.
            In other words, sibling points to the end of the CU.
            It is used for precompiled headers.
            The valid condition will be: 'offset == maximumoffset'. */
        Dwarf_Half tag = 0;
        int tres = dwarf_tag(attr->ar_die,&tag,error);
        if (tres != DW_DLV_OK) {
            if (tres == DW_DLV_NO_ENTRY) {
                _dwarf_error(dbg, error, DW_DLE_NO_TAG_FOR_DIE);
                return DW_DLV_ERROR;
            }
            return DW_DLV_ERROR;
        }

        if (DW_TAG_compile_unit != tag &&
            DW_AT_sibling != attr->ar_attribute &&
            offset > maximumoffset) {
            _dwarf_error(dbg, error, DW_DLE_ATTR_FORM_OFFSET_BAD);
            /*  Return the incorrect offset for better
                error reporting */
            *ret_offset = (offset);
            return DW_DLV_ERROR;
        }
    }
    *ret_is_info = is_info;
    *ret_offset = (offset);
    return DW_DLV_OK;
}

static int
_dwarf_formsig8_internal(Dwarf_Attribute attr,
    int formexpected,
    Dwarf_Sig8 * returned_sig_bytes,
    Dwarf_Error*     error)
{
    Dwarf_Debug dbg = 0;
    Dwarf_CU_Context cu_context = 0;
    Dwarf_Byte_Ptr  field_end = 0;
    Dwarf_Byte_Ptr  section_end = 0;

    int res  = get_attr_dbg(&dbg,&cu_context,attr,error);
    if (res != DW_DLV_OK) {
        return res;
    }

    if (attr->ar_attribute_form != formexpected) {
        return DW_DLV_NO_ENTRY;
    }
    section_end =
        _dwarf_calculate_info_section_end_ptr(cu_context);
    field_end = attr->ar_debug_ptr + sizeof(Dwarf_Sig8);
    if (field_end > section_end) {
        _dwarf_error(dbg, error, DW_DLE_ATTR_FORM_OFFSET_BAD);
        return DW_DLV_ERROR;
    }

    memcpy(returned_sig_bytes, attr->ar_debug_ptr,
        sizeof(*returned_sig_bytes));
    return DW_DLV_OK;
}

int
dwarf_formsig8_const(Dwarf_Attribute attr,
    Dwarf_Sig8 * returned_sig_bytes,
    Dwarf_Error* error)
{
    int res  =_dwarf_formsig8_internal(attr, DW_FORM_data8,
        returned_sig_bytes,error);
    return res;
}

/*  dwarf_formsig8 returns in the caller-provided 8 byte area
    the 8 bytes of a DW_FORM_ref_sig8 (copying the bytes
    directly to the caller).  Not a string, an 8 byte
    MD5 hash or a signature.
    This function is new in DWARF4 libdwarf and used in
    more places in DWARF5.
*/
int
dwarf_formsig8(Dwarf_Attribute attr,
    Dwarf_Sig8 * returned_sig_bytes,
    Dwarf_Error* error)
{
    int res  = _dwarf_formsig8_internal(attr, DW_FORM_ref_sig8,
        returned_sig_bytes,error);
    return res;
}

/*  This finds a target via a sig8 and if
    DWARF4 is likely finding a reference from .debug_info
    to .debug_types.  So the offset may or may not be
    in the same section if DWARF4.
    context_level prevents infinite loop
    during CU_Context creation */
static int
find_sig8_target_as_global_offset(Dwarf_Attribute attr,
    int context_level,
    Dwarf_Sig8  *sig8,
    Dwarf_Bool  *is_info,
    Dwarf_Off   *targoffset,
    Dwarf_Error *error)
{
    Dwarf_Die  targdie = 0;
    Dwarf_Bool targ_is_info = 0;
    Dwarf_Off  localoff = 0;
    int        res = 0;
    int        resb = 0;

    targ_is_info = attr->ar_cu_context->cc_is_info;
    memcpy(sig8,attr->ar_debug_ptr,sizeof(*sig8));
    res = _dwarf_internal_find_die_given_sig8(attr->ar_dbg,
        context_level,
        sig8,&targdie,&targ_is_info,error);
    if (res != DW_DLV_OK) {
        return res;
    }
    resb = dwarf_die_offsets(targdie,targoffset,&localoff,error);
    if (resb != DW_DLV_OK) {
        dwarf_dealloc_die(targdie);
        return resb;
    }
    *is_info = targdie->di_cu_context->cc_is_info;
    dwarf_dealloc_die(targdie);
    return DW_DLV_OK;
}

/*  Since this returns section-relative debug_info offsets,
    this can represent all REFERENCE forms correctly
    and allows all applicable forms.

    DW_FORM_ref_addr has a value which was documented in
    DWARF2 as address-size but which was always an offset
    so should have always been offset size (wording
    corrected in DWARF3).
        gcc and Go and libdwarf producer code
    define the length of the value of DW_FORM_ref_addr
    per the version. So for V2 it is address-size and V3 and later
    it is offset-size.

    See the DWARF4 document for the 3 cases fitting
    reference forms.  The caller must determine which section the
    reference 'points' to.  The function added in November 2009,
    dwarf_get_form_class(), helps in this regard.

    unlike dwarf_formref(), this allows references to
    sections other than just .debug_info/.debug_types.
    See case DW_FORM_sec_offset:
    case DW_FORM_GNU_ref_alt:   2013 GNU extension
    case DW_FORM_GNU_strp_alt:  2013 GNU extension
    case DW_FORM_strp_sup:      DWARF5, sup string section
    case DW_FORM_line_strp:     DWARF5, .debug_line_str section
*/

/*  This follows DW_FORM_ref_sig8 so could got
    to any CU and from debug_info to debug_types
    (or vice versa?)
    dwarf_global_formref_b is aimed at for DIE references.
    Only the DW_FORM_ref_sig8 form can change
    from a cu_context in .debug_info
    to one in .debug_types (DWARF4 only).
    For references to other sections it is simpler
    to call the original: dwarf_global_formref.
*/
int
dwarf_global_formref(Dwarf_Attribute attr,
    Dwarf_Off * ret_offset,
    Dwarf_Error * error)
{
    Dwarf_Bool is_info = 0;
    int res = 0;

    res = dwarf_global_formref_b(attr,ret_offset,
        &is_info,error);
    return res;
}

/* If context_level is 0, normal call
    But if non-zero will avoid creating CU Context. */
int
dwarf_global_formref_b(Dwarf_Attribute attr,
    Dwarf_Off * ret_offset,
    Dwarf_Bool * offset_is_info,
    Dwarf_Error * error)
{
    int res = 0;
    res = _dwarf_internal_global_formref_b( attr,
        0,
        ret_offset,
        offset_is_info,
        error);
    return res;
}

/*  Part of DebugFission.  So a consumer can get the index when
    the object with the actual debug_addr  is
    elsewhere.  New May 2014*/

int
_dwarf_get_addr_index_itself(int theform,
    Dwarf_Small *info_ptr,
    Dwarf_Debug dbg,
    Dwarf_CU_Context cu_context,
    Dwarf_Unsigned *val_out,
    Dwarf_Error * error)
{
    Dwarf_Unsigned index = 0;
    Dwarf_Byte_Ptr section_end = 0;

    section_end =
        _dwarf_calculate_info_section_end_ptr(cu_context);
    switch(theform){
    case DW_FORM_LLVM_addrx_offset: {
        Dwarf_Unsigned tmp = 0;
        Dwarf_Unsigned tmp2 = 0;
        DECODE_LEB128_UWORD_CK(info_ptr,tmp,
            dbg,error,section_end);
        READ_UNALIGNED_CK(dbg, tmp2, Dwarf_Unsigned,
            info_ptr, SIZEOFT32,
            error,section_end);
        index = (tmp<<32) | tmp2;
        break;
    }
    case DW_FORM_GNU_addr_index:
    case DW_FORM_addrx:
        DECODE_LEB128_UWORD_CK(info_ptr,index,
            dbg,error,section_end);
        break;
    case DW_FORM_addrx1:
        READ_UNALIGNED_CK(dbg, index, Dwarf_Unsigned,
            info_ptr, 1,
            error,section_end);
        break;
    case DW_FORM_addrx2:
        READ_UNALIGNED_CK(dbg, index, Dwarf_Unsigned,
            info_ptr, 2,
            error,section_end);
        break;
    case DW_FORM_addrx3:
        READ_UNALIGNED_CK(dbg, index, Dwarf_Unsigned,
            info_ptr, 3,
            error,section_end);
        break;
    case DW_FORM_addrx4:
        READ_UNALIGNED_CK(dbg, index, Dwarf_Unsigned,
            info_ptr, 4,
            error,section_end);
        break;
    default:
        _dwarf_error(dbg, error, DW_DLE_ATTR_FORM_NOT_ADDR_INDEX);
        return DW_DLV_ERROR;
    }
    /*  At this point we do not know for sure
        if the index refers
        to a local .debug_addr or a tied file .debug_addr
        so lets be cautious. */
#if 0 /* Attempted check for index uncertain, unwise. Ignore. */
    if (!dbg->de_tied_data.td_tied_object &&
        index > dbg->de_filesize) {
        _dwarf_error_string(dbg,error,DW_DLE_ATTR_FORM_OFFSET_BAD,
            "DW_DLE_ATTR_FORM_OFFSET_BAD "
            "reading an indexed form addr the index "
            "read is impossibly large (no tied file "
            "available). Corrupt Dwarf.");
        return DW_DLV_ERROR;
    }
#endif
    *val_out = index;
    return DW_DLV_OK;
}

int
dwarf_get_debug_addr_index(Dwarf_Attribute attr,
    Dwarf_Unsigned * return_index,
    Dwarf_Error * error)
{
    int theform = 0;
    Dwarf_CU_Context cu_context = 0;
    Dwarf_Debug dbg = 0;

    int res  = get_attr_dbg(&dbg,&cu_context,attr,error);
    if (res != DW_DLV_OK) {
        return res;
    }
    theform = attr->ar_attribute_form;
    if (dwarf_addr_form_is_indexed(theform)) {
        Dwarf_Unsigned index = 0;

        res = _dwarf_get_addr_index_itself(theform,
            attr->ar_debug_ptr,dbg,cu_context,&index,error);
        *return_index = index;
        return res;
    }

    _dwarf_error(dbg, error, DW_DLE_ATTR_FORM_NOT_ADDR_INDEX);
    return DW_DLV_ERROR;
}

/*  The index value here is the value of the
    attribute with this form.
    FORMs passed in are always strx forms. */
static int
dw_read_str_index_val_itself(Dwarf_Debug dbg,
    unsigned theform,
    Dwarf_Small *info_ptr,
    Dwarf_Small *section_end,
    Dwarf_Unsigned *return_index,
    Dwarf_Error *error)
{
    Dwarf_Unsigned index = 0;

    switch(theform) {
    case DW_FORM_strx:
    case DW_FORM_GNU_str_index:
        DECODE_LEB128_UWORD_CK(info_ptr,index,
            dbg,error,section_end);
        break;
    case DW_FORM_strx1:
        READ_UNALIGNED_CK(dbg, index, Dwarf_Unsigned,
            info_ptr, 1,
            error,section_end);
        break;
    case DW_FORM_strx2:
        READ_UNALIGNED_CK(dbg, index, Dwarf_Unsigned,
            info_ptr, 2,
            error,section_end);
        break;
    case DW_FORM_strx3:
        READ_UNALIGNED_CK(dbg, index, Dwarf_Unsigned,
            info_ptr, 3,
            error,section_end);
        break;
    case DW_FORM_strx4:
        READ_UNALIGNED_CK(dbg, index, Dwarf_Unsigned,
            info_ptr, 4,
            error,section_end);
        break;
    default:
        _dwarf_error(dbg, error, DW_DLE_ATTR_FORM_NOT_STR_INDEX);
        return DW_DLV_ERROR;
    }
    *return_index = index;
    return DW_DLV_OK;
}

/*  Part of DebugFission.  So a dwarf dumper application
    can get the index and print it for the user.
    A convenience function.  New May 2014
    Also used with DWARF5 forms.  */
int
dwarf_get_debug_str_index(Dwarf_Attribute attr,
    Dwarf_Unsigned *return_index,
    Dwarf_Error *error)
{
    int theform = attr->ar_attribute_form;
    Dwarf_CU_Context cu_context = 0;
    Dwarf_Debug dbg = 0;
    int res  = 0;
    Dwarf_Byte_Ptr section_end =  0;
    Dwarf_Unsigned index = 0;
    Dwarf_Small *info_ptr = 0;
    int indxres = 0;
    Dwarf_Unsigned length_size = 0;
    Dwarf_Unsigned sectionlen = 0;

    res = get_attr_dbg(&dbg,&cu_context,attr,error);
    if (res != DW_DLV_OK) {
        return res;
    }
    section_end =
        _dwarf_calculate_info_section_end_ptr(cu_context);
    info_ptr = attr->ar_debug_ptr;

    indxres = dw_read_str_index_val_itself(dbg, theform, info_ptr,
        section_end, &index,error);
    if (indxres == DW_DLV_OK) {
        *return_index = index;
        return indxres;
    }
    length_size = cu_context->cc_length_size;
    sectionlen = dbg->de_debug_str_offsets.dss_size;
    if (index > sectionlen ||
        (index *length_size) > sectionlen) {
        _dwarf_error_string(dbg, error,
            DW_DLE_ATTR_FORM_SIZE_BAD,
            "DW_DLE_ATTR_FORM_SIZE_BAD: "
            "An Attribute Value (index  into "
            ".debug_str_offsets) is Impossibly "
            "large. Corrupt Dwarf.");
        return DW_DLV_ERROR;
    }
    return indxres;
}

int
_dwarf_extract_data16(Dwarf_Debug dbg,
    Dwarf_Small *data,
    Dwarf_Small *section_start,
    Dwarf_Small *section_end,
    Dwarf_Form_Data16  * returned_val,
    Dwarf_Error *error)
{
    Dwarf_Small *data16end = 0;

    data16end = data + sizeof(Dwarf_Form_Data16);
    if (data  < section_start ||
        section_end < data16end) {
        _dwarf_error(dbg, error,DW_DLE_DATA16_OUTSIDE_SECTION);
        return DW_DLV_ERROR;
    }
    memcpy(returned_val, data, sizeof(*returned_val));
    return DW_DLV_OK;

}

int
dwarf_formdata16(Dwarf_Attribute attr,
    Dwarf_Form_Data16  * returned_val,
    Dwarf_Error*     error)
{
    Dwarf_Half attrform = 0;
    Dwarf_CU_Context cu_context = 0;
    Dwarf_Debug dbg = 0;
    int res  = 0;
    Dwarf_Small *section_end = 0;
    Dwarf_Unsigned section_length = 0;
    Dwarf_Small *section_start = 0;

    if (!attr) {
        _dwarf_error(NULL, error, DW_DLE_ATTR_NULL);
        return DW_DLV_ERROR;
    }
    if (!returned_val ) {
        _dwarf_error(NULL, error, DW_DLE_ATTR_NULL);
        return DW_DLV_ERROR;
    }
    res  = get_attr_dbg(&dbg,&cu_context,attr,error);
    if (res != DW_DLV_OK) {
        return res;
    }
    attrform = attr->ar_attribute_form;
    if (attrform != DW_FORM_data16) {
        generate_form_error(dbg,error,attrform,
            DW_DLE_ATTR_FORM_BAD,
            "DW_DLE_ATTR_FORM_BAD",
            "dwarf_formdata16");
        return DW_DLV_ERROR;
    }
    section_start = _dwarf_calculate_info_section_start_ptr(
        cu_context,&section_length);
    section_end = section_start + section_length;

    res = _dwarf_extract_data16(dbg, attr->ar_debug_ptr,
        section_start, section_end,
        returned_val,  error);
    return res;
}

/*  The *addrx are DWARF5 standard.
    The GNU form is non-standard gcc DWARF4
    The LLVM form is the newest. */
Dwarf_Bool
dwarf_addr_form_is_indexed(int form)
{
    switch(form) {
    case DW_FORM_addrx:
    case DW_FORM_addrx1:
    case DW_FORM_addrx2:
    case DW_FORM_addrx3:
    case DW_FORM_addrx4:
    case DW_FORM_GNU_addr_index:
    case DW_FORM_LLVM_addrx_offset:
        return TRUE;
    default: break;
    }
    return FALSE;
}

int
dwarf_formaddr(Dwarf_Attribute attr,
    Dwarf_Addr * return_addr, Dwarf_Error * error)
{
    Dwarf_Debug dbg = 0;
    Dwarf_Addr ret_addr = 0;
    Dwarf_CU_Context cu_context = 0;
    Dwarf_Half attrform = 0;
    int res = 0;

    res  = get_attr_dbg(&dbg,&cu_context,attr,error);
    if (res != DW_DLV_OK) {
        return res;
    }
    attrform = attr->ar_attribute_form;
    if (dwarf_addr_form_is_indexed(attrform)) {
        res = _dwarf_look_in_local_and_tied(
            attrform,
            cu_context,
            attr->ar_debug_ptr,
            return_addr,
            error);
        return res;
    }
    if (attrform == DW_FORM_addr ||
        (cu_context->cc_producer == CC_PROD_METROWERKS &&
        attrform == DW_FORM_ref_addr) 
            /* Allowance of
            DW_FORM_ref_addr was a mistake. The value returned in that
            case is NOT an address it is a global debug_info
            offset (ie, not CU-relative offset within the CU
            in debug_info).
            A Metrowerks old C generates ref_adder!
            The DWARF2 document refers to it as an address
            (misleadingly) in sec 6.5.4 where it describes
            the reference form. It is
            address-sized so that the linker can easily update it, but
            it is a reference inside the debug_info section. No longer
            allowed. */
        ) {
        Dwarf_Small *section_end =
            _dwarf_calculate_info_section_end_ptr(cu_context);

        READ_UNALIGNED_CK(dbg, ret_addr, Dwarf_Addr,
            attr->ar_debug_ptr,
            cu_context->cc_address_size,
            error,section_end);
        *return_addr = ret_addr;
        return DW_DLV_OK;
    }
    generate_form_error(dbg,error,attrform,
        DW_DLE_ATTR_FORM_BAD,
        "DW_DLE_ATTR_FORM_BAD",
        "dwarf_formaddr");
    return DW_DLV_ERROR;
}

int
dwarf_formflag(Dwarf_Attribute attr,
    Dwarf_Bool * ret_bool, Dwarf_Error * error)
{
    Dwarf_CU_Context cu_context = 0;
    Dwarf_Debug dbg = 0;

    if (!attr) {
        _dwarf_error(NULL, error, DW_DLE_ATTR_NULL);
        return DW_DLV_ERROR;
    }
    cu_context = attr->ar_cu_context;
    if (!cu_context) {
        _dwarf_error(NULL, error, DW_DLE_ATTR_NO_CU_CONTEXT);
        return DW_DLV_ERROR;
    }
    dbg = cu_context->cc_dbg;
    if (IS_INVALID_DBG(dbg)) {
        _dwarf_error_string(NULL, error, DW_DLE_ATTR_DBG_NULL,
            "DW_DLE_ATTR_DBG_NULL: dwarf_formflag() attribute"
            " passed in has NULL or stale Dwarf_Debug pointer");
        return DW_DLV_ERROR;
    }
    if (dbg != attr->ar_dbg) {
        _dwarf_error_string(NULL, error, DW_DLE_ATTR_DBG_NULL,
            "DW_DLE_ATTR_DBG_NULL: an attribute and its "
            "cu_context do not have the same Dwarf_Debug" );
        return DW_DLV_ERROR;
    }
    if (attr->ar_attribute_form == DW_FORM_flag_present) {
        /*  Implicit means we don't read any data at all. Just
            the existence of the Form does it. DWARF4. */
        *ret_bool = 1;
        return DW_DLV_OK;
    }

    if (attr->ar_attribute_form == DW_FORM_flag) {
        *ret_bool = *(Dwarf_Small *)(attr->ar_debug_ptr);
        return DW_DLV_OK;
    }
    generate_form_error(dbg,error,attr->ar_attribute_form,
        DW_DLE_ATTR_FORM_BAD,
        "DW_DLE_ATTR_FORM_BAD",
        "dwarf_formflat");
    return DW_DLV_ERROR;
}

Dwarf_Bool
_dwarf_allow_formudata(unsigned form)
{
    switch(form) {
    case DW_FORM_data1:
    case DW_FORM_data2:
    case DW_FORM_data4:
    case DW_FORM_data8:
    case DW_FORM_udata:
    case DW_FORM_loclistx:
    case DW_FORM_rnglistx:
        return TRUE;
    default:
        break;
    }
    return FALSE;
}
/*  If the form is DW_FORM_constx and the .debug_addr section
    is missing, this returns DW_DLV_ERROR and the error number
    in the Dwarf_Error is  DW_DLE_MISSING_NEEDED_DEBUG_ADDR_SECTION.
    When that arises, a consumer should call
    dwarf_get_debug_addr_index() and use that on the appropriate
    .debug_addr section in the executable or another object.

    Since this accept some signed values, callers
    must not assume a DW_DLV_OK means
    the value is unsigned. The form is the first clue here.
    If DW_FORM_sdata, then signed. Else unknown sign or
    is unsigned.
*/

int
_dwarf_formudata_internal(Dwarf_Debug dbg,
    Dwarf_Attribute attr,
    unsigned form,
    Dwarf_Byte_Ptr data,
    Dwarf_Byte_Ptr section_end,
    Dwarf_Unsigned *return_uval,
    Dwarf_Unsigned *bytes_read,
    Dwarf_Error *error)
{
    Dwarf_Unsigned ret_value = 0;

    switch (form) {
    case DW_FORM_data1:
        READ_UNALIGNED_CK(dbg, ret_value, Dwarf_Unsigned,
            data, sizeof(Dwarf_Small),
            error,section_end);
        *return_uval = ret_value;
        *bytes_read = 1;
        return DW_DLV_OK;

    /*  READ_UNALIGNED does the right thing as it reads
        the right number bits and generates host order.
        So we can just assign to *return_uval. */
    case DW_FORM_data2:{
        READ_UNALIGNED_CK(dbg, ret_value, Dwarf_Unsigned,
            data, DWARF_HALF_SIZE,
            error,section_end);
        *return_uval = ret_value;
        *bytes_read = DWARF_HALF_SIZE;
        return DW_DLV_OK;
        }

    case DW_FORM_data4:{
        READ_UNALIGNED_CK(dbg, ret_value, Dwarf_Unsigned,
            data,
            DWARF_32BIT_SIZE,
            error,section_end);
        *return_uval = ret_value;
        *bytes_read = DWARF_32BIT_SIZE;;
        return DW_DLV_OK;
        }

    case DW_FORM_data8:{
        READ_UNALIGNED_CK(dbg, ret_value, Dwarf_Unsigned,
            data,
            DWARF_64BIT_SIZE,
            error,section_end);
        *return_uval = ret_value;
        *bytes_read = DWARF_64BIT_SIZE;
        return DW_D

// --- CODE TRUNCATED HERE ---

// the below code fragment can be found in:
// src/lib/libdwarf/dwarf_util.c
int
_dwarf_get_size_of_val(Dwarf_Debug dbg,
    Dwarf_Unsigned form,
    Dwarf_Half cu_version,
    Dwarf_Half address_size,
    Dwarf_Small * val_ptr,
    int v_length_size,
    Dwarf_Unsigned *size_out,
    Dwarf_Small *section_end_ptr,
    Dwarf_Error*error)
{
    Dwarf_Unsigned length = 0;
    Dwarf_Unsigned leb128_length = 0;
    Dwarf_Unsigned form_indirect = 0;
    Dwarf_Unsigned ret_value = 0;

    switch (form) {
    case 0:  return DW_DLV_OK;

    case DW_FORM_GNU_ref_alt:
    case DW_FORM_GNU_strp_alt:
    case DW_FORM_strp_sup:
        *size_out = v_length_size;
        return DW_DLV_OK;

    case DW_FORM_addr:
        if (address_size) {
            *size_out = address_size;
        } else {
            /*  This should never happen,
                address_size should be set. */
            *size_out = dbg->de_pointer_size;
        }
        return DW_DLV_OK;
    case DW_FORM_ref_sig8:
        *size_out = 8;
        /* sizeof Dwarf_Sig8 */
        return DW_DLV_OK;

    /*  DWARF2 was wrong on the size of the attribute for
        DW_FORM_ref_addr.  We assume compilers are using the
        corrected DWARF3 text (for 32bit pointer target
        objects pointer and
        offsets are the same size anyway).
        It is clear (as of 2014) that for 64bit folks used
        the V2 spec in the way V2 was
        written, so the ref_addr has to account for that.*/
    case DW_FORM_ref_addr:
        if (cu_version == DW_CU_VERSION2) {
            *size_out = address_size;
        } else {
            *size_out = v_length_size;
        }
        return DW_DLV_OK;

    case DW_FORM_block1: {
        Dwarf_Unsigned space_left = 0;

        if (val_ptr >= section_end_ptr) {
            _dwarf_error_string(dbg,error,
                DW_DLE_FORM_BLOCK_LENGTH_ERROR,
                "DW_DLE_FORM_BLOCK_LENGTH_ERROR: DW_FORM_block1"
                " itself is off the end of the section."
                " Corrupt Dwarf.");
            return DW_DLV_ERROR;
        }
        ret_value =  *(Dwarf_Small *) val_ptr;
        /*  ptrdiff_t is generated but not named */
        space_left = (section_end_ptr >= val_ptr)?
            (section_end_ptr - val_ptr):0;
        if (ret_value > space_left)  {
            _dwarf_error_string(dbg,error,
                DW_DLE_FORM_BLOCK_LENGTH_ERROR,
                "DW_DLE_FORM_BLOCK_LENGTH_ERROR: DW_FORM_block1"
                " runs off the end of the section."
                " Corrupt Dwarf.");
            return DW_DLV_ERROR;
        }
        *size_out = ret_value +1;
        }
        return DW_DLV_OK;

    case DW_FORM_block2: {
        Dwarf_Unsigned space_left = 0;

        READ_UNALIGNED_CK(dbg, ret_value, Dwarf_Unsigned,
            val_ptr, DWARF_HALF_SIZE,error,section_end_ptr);
        /*  ptrdiff_t is generated but not named */
        space_left = (section_end_ptr >= val_ptr)?
            (section_end_ptr - val_ptr):0;
        if (ret_value > space_left)  {
            _dwarf_error_string(dbg,error,
                DW_DLE_FORM_BLOCK_LENGTH_ERROR,
                "DW_DLE_FORM_BLOCK_LENGTH_ERROR: DW_FORM_block2"
                " runs off the end of the section."
                " Corrupt Dwarf.");
            return DW_DLV_ERROR;
        }
        *size_out = ret_value + DWARF_HALF_SIZE;
        }
        return DW_DLV_OK;

    case DW_FORM_block4: {
        Dwarf_Unsigned space_left = 0;

        READ_UNALIGNED_CK(dbg, ret_value, Dwarf_Unsigned,
            val_ptr, DWARF_32BIT_SIZE,
            error,section_end_ptr);
        /*  ptrdiff_t is generated but not named */
        space_left = (section_end_ptr >= val_ptr)?
            (section_end_ptr - val_ptr):0;
        if (ret_value > space_left)  {
            _dwarf_error_string(dbg,error,
                DW_DLE_FORM_BLOCK_LENGTH_ERROR,
                "DW_DLE_FORM_BLOCK_LENGTH_ERROR: DW_FORM_block4"
                " runs off the end of the section."
                " Corrupt Dwarf.");
            return DW_DLV_ERROR;
        }
        *size_out = ret_value + DWARF_32BIT_SIZE;
        }
        return DW_DLV_OK;

    case DW_FORM_data1:
        *size_out = 1;
        return DW_DLV_OK;

    case DW_FORM_data2:
        *size_out = 2;
        return DW_DLV_OK;

    case DW_FORM_data4:
        *size_out = 4;
        return DW_DLV_OK;

    case DW_FORM_data8:
        *size_out = 8;
        return DW_DLV_OK;

    case DW_FORM_data16:
        *size_out = 16;
        return DW_DLV_OK;

    case DW_FORM_string: {
        int res = 0;
        res = _dwarf_check_string_valid(dbg,val_ptr,
            val_ptr,
            section_end_ptr,
            DW_DLE_FORM_STRING_BAD_STRING,
            error);
        if ( res != DW_DLV_OK) {
            return res;
        }
        }
        *size_out = strlen((char *) val_ptr) + 1;
        return DW_DLV_OK;

    case DW_FORM_block:
    case DW_FORM_exprloc: {
        DECODE_LEB128_UWORD_LEN_CK(val_ptr,length,leb128_length,
            dbg,error,section_end_ptr);
        *size_out = length + leb128_length;
        return DW_DLV_OK;;
    }

    case DW_FORM_flag_present:
        *size_out = 0;
        return DW_DLV_OK;

    case DW_FORM_flag:
        *size_out = 1;
        return DW_DLV_OK;

    case DW_FORM_sec_offset:
        /* If 32bit dwarf, is 4. Else is 64bit dwarf and is 8. */
        *size_out = v_length_size;
        return DW_DLV_OK;

    case DW_FORM_ref_udata: {
        /*  Discard the decoded value, we just want the length
            of the value. */
        SKIP_LEB128_LEN_CK(val_ptr,leb128_length,
            dbg,error,section_end_ptr);
        *size_out = leb128_length;
        return DW_DLV_OK;;
    }

    case DW_FORM_indirect:
        {
            Dwarf_Unsigned indir_len = 0;
            int res = 0;
            Dwarf_Unsigned info_data_len = 0;

            DECODE_LEB128_UWORD_LEN_CK(val_ptr,form_indirect,
                indir_len,
                dbg,error,section_end_ptr);
            if (form_indirect == DW_FORM_indirect) {
                /* We are in big trouble: The true form
                    of DW_FORM_indirect is
                    DW_FORM_indirect? Nonsense. Should
                    never happen. */
                _dwarf_error(dbg,error,
                    DW_DLE_NESTED_FORM_INDIRECT_ERROR);
                return DW_DLV_ERROR;
            }
            /*  If form_indirect  is DW_FORM_implicit_const then
                the following call will set info_data_len 0 */
            res = _dwarf_get_size_of_val(dbg,
                form_indirect,
                cu_version,
                address_size,
                val_ptr + indir_len,
                v_length_size,
                &info_data_len,
                section_end_ptr,
                error);
            if (res != DW_DLV_OK) {
                return res;
            }
            *size_out = indir_len + info_data_len;
            return DW_DLV_OK;
        }

    case DW_FORM_ref1:
        *size_out = 1;
        return DW_DLV_OK;

    case DW_FORM_ref2:
        *size_out = 2;
        return DW_DLV_OK;

    case DW_FORM_ref4:
        *size_out = 4;
        return DW_DLV_OK;

    case DW_FORM_ref8:
        *size_out = 8;
        return DW_DLV_OK;

    /*  DW_FORM_implicit_const  is a value in the
        abbreviations, not in the DIEs and this
        functions measures DIE size. */
    case DW_FORM_implicit_const:
        *size_out = 0;
        return DW_DLV_OK;

    case DW_FORM_sdata: {
        /*  Discard the decoded value, we just want the length
            of the value. */
        SKIP_LEB128_LEN_CK(val_ptr,leb128_length,
            dbg,error,section_end_ptr);
        *size_out = leb128_length;
        return DW_DLV_OK;
    }
    case DW_FORM_ref_sup4:
        *size_out = 4;
        return DW_DLV_OK;
    case DW_FORM_ref_sup8:
        *size_out = 8;
        return DW_DLV_OK;
    case DW_FORM_addrx1:
        *size_out = 1;
        return DW_DLV_OK;
    case DW_FORM_addrx2:
        *size_out = 2;
        return DW_DLV_OK;
    case DW_FORM_addrx3:
        *size_out = 3;
        return DW_DLV_OK;
    case DW_FORM_addrx4:
        *size_out = 4;
        return DW_DLV_OK;
    case DW_FORM_strx1:
        *size_out = 1;
        return DW_DLV_OK;
    case DW_FORM_strx2:
        *size_out = 2;
        return DW_DLV_OK;
    case DW_FORM_strx3:
        *size_out = 3;
        return DW_DLV_OK;
    case DW_FORM_strx4:
        *size_out = 4;
        return DW_DLV_OK;

    case DW_FORM_loclistx:
    case DW_FORM_rnglistx:
    case DW_FORM_addrx:
    case DW_FORM_GNU_addr_index:
    case DW_FORM_strx:
    case DW_FORM_GNU_str_index: {
        SKIP_LEB128_LEN_CK(val_ptr,leb128_length,
            dbg,error,section_end_ptr);
        *size_out = leb128_length;
        return DW_DLV_OK;
    }

    case DW_FORM_line_strp:
    case DW_FORM_strp:
        *size_out = v_length_size;
        return DW_DLV_OK;

    case DW_FORM_LLVM_addrx_offset:
        SKIP_LEB128_LEN_CK(val_ptr,leb128_length,
            dbg,error,section_end_ptr);
        *size_out = leb128_length + SIZEOFT32;
        return DW_DLV_OK;
    case DW_FORM_udata: {
        /*  Discard the decoded value, we just want the length
            of the value. */
        SKIP_LEB128_LEN_CK(val_ptr,leb128_length,
            dbg,error,section_end_ptr);
        *size_out = leb128_length;
        return DW_DLV_OK;
    }
    default: break;
    }
    /*  When we encounter a FORM here that
        we know about but forgot to enter here,
        we had better not just continue.
        Usually means we forgot to update this function
        when implementing form handling of a new FORM.
        Disaster results from using a bogus value,
        so generate error. */
    {
        dwarfstring m;
        dwarfstring_constructor(&m);

        dwarfstring_append_printf_u(&m,
            "DW_DLE_DEBUG_FORM_HANDLING_INCOMPLETE: "
            "DW_FORM 0x%x"
            " is not being handled!",
            form);

        _dwarf_error_string(dbg,error,
            DW_DLE_DEBUG_FORM_HANDLING_INCOMPLETE,
            dwarfstring_string(&m));
        dwarfstring_destructor(&m);
    }
    return DW_DLV_ERROR;
}

// the below code fragment can be found in:
// src/lib/libdwarf/dwarf_die_deliv.c
static int
find_cu_die_base_fields(Dwarf_Debug dbg,
    Dwarf_CU_Context cucon,
    Dwarf_Die cudie,
    Dwarf_Bool *bad_pc_form,
    Dwarf_Error*    error)
{
    Dwarf_CU_Context  cu_context = 0;
    Dwarf_Attribute * alist = 0;
    Dwarf_Signed      atcount = 0;
    unsigned          version_stamp = 2;
    int               alres = 0;
    Dwarf_Signed      i = 0;
    Dwarf_Signed low_pc_attrnum = -1;
    Dwarf_Signed entry_pc_attrnum = -1;
    Dwarf_Signed at_addr_base_attrnum = -1;

    cu_context = cudie->di_cu_context;
    version_stamp = cu_context->cc_version_stamp;

    alres = dwarf_attrlist(cudie, &alist,
        &atcount,error);
    if (alres != DW_DLV_OK) {
        /* Something is badly wrong. No attrlist! */
        return alres;
    }
    /*  DW_AT_dwo_id and/or DW_AT_GNU_dwo_id
        are only found  in some
        experimental DWARF4.
        Even DWARF3,4 use DW_AT_low_pc as base address
        DWARF5 changed CU header contents
        to make this attribute unnecessary.
        DW_AT_GNU_odr_signature is the same format,
        but is in a different namespace so not
        appropriate here..
    */
    for (i = 0;  i < atcount; ++i) {
        Dwarf_Half attrnum = 0;
        Dwarf_Half form = 0;
        int ares = 0;
        int ares2 = 0;
        Dwarf_Attribute attr = alist[i];

        ares = dwarf_whatattr(attr,&attrnum,error);
        if (ares == DW_DLV_ERROR && error) {
            dwarf_dealloc_error(dbg,*error);
            *error = 0;
        }
        ares2 = dwarf_whatform(attr,&form,error);
        if (ares2 == DW_DLV_ERROR && error) {
            dwarf_dealloc_error(dbg,*error);
            *error = 0;
        }
        /*  We are not returning on DW_DLV_NO_ENTRY
            or DW_DLV_ERROR here. Such will be
            caught later. Lets finish a CU die
            scan and finish the cu_context  */
        if (ares == DW_DLV_OK && ares2 == DW_DLV_OK) {
            switch(form) {
            case DW_FORM_strx:
            case DW_FORM_strx1:
            case DW_FORM_strx2:
            case DW_FORM_strx3:
            case DW_FORM_strx4:
                cucon->cc_at_strx_present = TRUE;
                break;
            default:
                break;
            }
            switch(attrnum) {
            case DW_AT_producer: 
                 set_producer_type(cudie,cu_context);
                 break;
            case DW_AT_dwo_id:
            case DW_AT_GNU_dwo_id: {
                Dwarf_Sig8 signature;
                /*  This is for DWARF4 with an early
                    non-standard version
                    of split dwarf. Not DWARF5. */
                int sres = 0;
                if (version_stamp != DW_CU_VERSION4 ) {
                    /* Not supposed to happen. */
                    local_attrlist_dealloc(dbg,atcount,alist);
                    _dwarf_error(dbg,error,
                        DW_DLE_IMPROPER_DWO_ID);
                    return DW_DLV_ERROR;
                }
                signature = dwarfsig8zero;
                sres = dwarf_formsig8_const(attr,
                    &signature,error);
                if (sres == DW_DLV_OK) {
                    if (!cucon->cc_signature_present) {
                        cucon->cc_signature = signature;
                        cucon->cc_signature_present = TRUE;
                    } else {
                        /*  Something wrong. Two styles of sig?
                            Can happen with DWARF4
                            debug-fission extension DWO_id.
                        */
                        if (memcmp(&signature,&cucon->cc_signature,
                            sizeof(signature))) {
                            /*  The two sigs do not match! */
                            const char *m="DW_DLE_SIGNATURE_MISMATCH"
                                "DWARF4 extension fission signature"
                                " and DW_AT_GNU_dwo_id do not match"
                                " ignoring DW_AT[_GNU]_dwo_id";
                            dwarf_insert_harmless_error(dbg,
                                (char*)m);
                        }
                    }
                } else {
                    /* Something is badly wrong. */
                    local_attrlist_dealloc(dbg,atcount,alist);
                    return sres;
                }
                    /* Something is badly wrong. */
                break;
            }
            /*  If, in .debug_rnglists for a CU the
                applicable range has no base address
                this attribute provides a base address.
                If this is indexed doing this now would
                lead to an infinite recursion.
                So wait till all the other fields seen.
            */
            case DW_AT_low_pc: {
                low_pc_attrnum = i;
                break;
            }
            /*  DW_AT_producer 4.2.1 (Based on Apple Inc. build 5658)
                (LLVM build 2336.1.00) uses DW_AT_entry_pc as the
                base address (DW_AT_entry_pc
                first appears in DWARF3).
                So we allow that as an extension,
                as a 'low_pc' if there is DW_AT_entry_pc with
                no DW_AT_low_pc. 19 May 2022.
            */
            case DW_AT_entry_pc: {
                entry_pc_attrnum = i;
                break;
            }

            /*  The offset is of the first offset in
                .debug_str_offsets that is the string table
                offset array for this CU. */
            case DW_AT_str_offsets_base:{
                int udres = 0;
                Dwarf_Bool is_info = cucon->cc_is_info;

                udres = _dwarf_internal_global_formref_b(attr,
                    /* avoid recurse creating context */ 1,
                    &cucon->cc_str_offsets_array_offset,
                    &is_info,
                    error);
                if (udres == DW_DLV_OK) {
                    cucon->cc_str_offsets_array_offset_present = TRUE;
                } else {
                    local_attrlist_dealloc(dbg,atcount,alist);
                    /* Something is badly wrong. */
                    return udres;
                }
                break;
            }
            /*  offset in .debug_loclists  of the offsets table
                applicable to this CU. */
            case DW_AT_loclists_base: {
                int udres = 0;
                Dwarf_Bool is_info = cucon->cc_is_info;

                udres = _dwarf_internal_global_formref_b(attr,
                    /* avoid recurse creating context */ 1,
                    &cucon->cc_loclists_base,
                    &is_info,
                    error);
                if (udres == DW_DLV_OK) {
                    cucon->cc_loclists_base_present = TRUE;
                } else {
                    local_attrlist_dealloc(dbg,atcount,alist);
                    /* Something is badly wrong. */
                    return udres;
                }
                break;
                }
            /*  Base offset  in .debug_addr of the addr table
                for this CU. DWARF5 (and possibly GNU DWARF4)
                So we really want to look in only
                this section, not an offset referring
                to another (DWARF5 debug_info vs debug_types) */
            case DW_AT_addr_base:
            case DW_AT_GNU_addr_base: {
                int udres = 0;
                Dwarf_Bool is_info = cucon->cc_is_info;

                at_addr_base_attrnum = i;

                udres = _dwarf_internal_global_formref_b(attr,
                    /* avoid recurse creating context */ 1,
                    &cucon->cc_addr_base,
                    &is_info,
                    error);
                if (udres == DW_DLV_OK) {
                    if (is_info == cucon->cc_is_info) {
                        /*  Only accept if same .debug section,
                            which is relevant for DWARF4 */
                        cucon->cc_addr_base_present = TRUE;
                    }
                } else {
                    local_attrlist_dealloc(dbg,atcount,alist);
                    /* Something is badly wrong. */
                    return udres;
                }
                break;
            }
            case DW_AT_GNU_ranges_base: {
            /*  The DW4 ranges base was never used in GNU
                but did get emitted in skeletons.
                http://llvm.1065342.n5.nabble.com/
                DebugInfo-DW-AT-GNU-ranges-base-in-
                non-fission-td64194.html
                But we accept it anyway. */
            /*  offset in .debug_rnglists  of the offsets table
                applicable to this CU.
                Note that this base applies when
                referencing from the dwp, but NOT
                when referencing from the a.out */
                int udres = 0;
                Dwarf_Bool is_info = cucon->cc_is_info;

                udres = _dwarf_internal_global_formref_b(attr,
                    /* avoid recurse creating context */ 1,
                    &cucon->cc_ranges_base,
                    &is_info,
                    error);
                if (udres == DW_DLV_OK) {
                    cucon->cc_ranges_base_present = TRUE;
                } else {
                    local_attrlist_dealloc(dbg,atcount,alist);
                    /* Something is badly wrong. */
                    return udres;
                }
                break;
                }
            case  DW_AT_rnglists_base: {
                int udres = 0;
                Dwarf_Bool is_info = cucon->cc_is_info;

                udres = _dwarf_internal_global_formref_b(attr,
                    /* avoid recurse creating context */ 1,
                    &cucon->cc_rnglists_base,
                    &is_info,
                    error);
                if (udres == DW_DLV_OK) {
                    cucon->cc_rnglists_base_present = TRUE;
                } else {
                    local_attrlist_dealloc(dbg,atcount,alist);
                    /* Something is badly wrong. */
                    return udres;
                }
                break;
                }
            /*  A signature, found in a DWARF5 skeleton
                compilation unit. */
            case DW_AT_GNU_dwo_name:
            case DW_AT_dwo_name: {
                int dnres = 0;

                dnres = dwarf_formstring(attr,
                    &cucon->cc_dwo_name,error);
                if (dnres != DW_DLV_OK) {
                    local_attrlist_dealloc(dbg,atcount,alist);
                    return dnres;
                }
                cucon->cc_dwo_name_present = TRUE;
                break;
                }
            default: /* do nothing, not an attribute
                we need to deal with here. */
                break;
            }
        }
    }
    if (low_pc_attrnum >= 0 ){
        int battr = 0;

        /* Prefer DW_AT_low_pc */
        Dwarf_Attribute attr = alist[low_pc_attrnum];
        battr = _dwarf_setup_base_address(dbg,"DW_AT_low_pc",
            attr,at_addr_base_attrnum, cucon,
            bad_pc_form,error);
        if (battr != DW_DLV_OK) {
            local_attrlist_dealloc(dbg,atcount,alist);
            /*  Something is wrong, possibly
                erroneous Macrowerks compiler. */
            _dwarf_set_children_flag(cucon,cudie);
            return battr;
        }
    } else if (entry_pc_attrnum >= 0) {
        int battr = 0;

        /*  Pretending that DW_AT_entry_pc with no
            DW_AT_low_pc is a valid base address for
            loccation lists.
            DW_AT_producer 4.2.1 (Based on Apple Inc. build 5658)
            (LLVM build 2336.1.00) uses DW_AT_entry_pc as the
            base address (DW_AT_entry_pc first appears in DWARF3).
            So we allow that as an extension,
            as a 'low_pc' if there is DW_AT_entry_pc with
            no DW_AT_low_pc. 19 May 2022. */
        Dwarf_Attribute attr = alist[entry_pc_attrnum];
        battr = _dwarf_setup_base_address(dbg,"DW_AT_entry_pc",
            attr,at_addr_base_attrnum, cucon,
            bad_pc_form,error);
        if (battr != DW_DLV_OK) {
            local_attrlist_dealloc(dbg,atcount,alist);
            /* Something is wrong */
            _dwarf_set_children_flag(cucon,cudie);
            return battr;
        }
    }
    local_attrlist_dealloc(dbg,atcount,alist);
    alist = 0;
    atcount = 0;
    _dwarf_set_children_flag(cucon,cudie);
    return DW_DLV_OK;
}

// the below code fragment can be found in:
// src/lib/libdwarf/dwarf_query.c
int
_dwarf_look_in_local_and_tied(Dwarf_Half attr_form,
    Dwarf_CU_Context context,
    Dwarf_Small     *info_ptr,
    Dwarf_Addr      *return_addr,
    Dwarf_Error     *error)
{
    int res2 = 0;
    Dwarf_Unsigned index_to_addr = 0;
    Dwarf_Debug dbg = 0;

    /*  We get the index. It might apply here
        or in tied object. Checking that next. */
    dbg = context->cc_dbg;
    res2 = _dwarf_get_addr_index_itself(attr_form,
        info_ptr,dbg,context, &index_to_addr,error);
    if (res2 != DW_DLV_OK) {
        return res2;
    }
#if 0 /* An error check that is probably incorect. */
    Dwarf_Unsigned addrtabsize = 0;
    addrtabsize = dbg->de_debug_addr.dss_size;
    If there is  no .debug_addr the error here should
    not be reported as will report that
    via _dwarf_look_in_local_and_tied_by_index
    if (!dbg->de_tied_data.td_tied_object &&
        (index_to_addr > dbg->de_filesize ||
        index_to_addr > addrtabsize ||
        (index_to_addr*context->cc_address_size) > addrtabsize)) {
        _dwarf_error_string(dbg,error,DW_DLE_ATTR_FORM_OFFSET_BAD,
            "DW_DLE_ATTR_FORM_OFFSET_BAD "
            "Looking for an index from an addr FORM "
            "we find an impossibly large value. Corrupt DWARF");
        return DW_DLV_ERROR;
    }
#endif
    /* error is returned on dbg, not tieddbg. */
    res2 = _dwarf_look_in_local_and_tied_by_index(
        dbg,context,index_to_addr,return_addr,error);
    return res2;

}
