// Serialize the integer value into a CSV format string and store it in the buffer.
// Ensure that the buffer has sufficient space, extending it if necessary.
// Prepend a header string if the header has not already been written.
// Adjust the buffer usage count to reflect the serialized data.
u_int32_t needed = sizeof(u_int8_t) /* type */ + sizeof(u_int16_t) /* key len */;
if(serializer->fmt == ndpi_serialization_format_csv) {
  needed += strlen(key);
}

if(buff_diff < needed) {
  if(ndpi_extend_serializer_buffer(&serializer->buffer, needed - buff_diff) < 0)
    return(-1);
  buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;
}

if(serializer->fmt == ndpi_serialization_format_csv) {
  serializer->status.buffer.size_used += ndpi_serializer_header_string(serializer, key, strlen(key));
  buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;
  rc = ndpi_snprintf((char *) &serializer->buffer.data[serializer->status.buffer.size_used], buff_diff,
    NDPI_I32_FORMAT, (long long int)value);
  if(rc < 0 || (u_int)rc >= buff_diff)
    return(-1);
  serializer->status.buffer.size_used += rc;
} else {
  serializer->buffer.data[serializer->status.buffer.size_used++] = (ndpi_serialization_string << 4) | ndpi_serialization_int32;
  ndpi_serialize_single_string(serializer, key, strlen(key));
  rc = ndpi_snprintf((char *) &serializer->buffer.data[serializer->status.buffer.size_used], buff_diff,
    NDPI_I32_FORMAT, (long long int)value);
  if(rc < 0 || (u_int)rc >= buff_diff)
    return(-1);
  serializer->status.buffer.size_used += rc;
}

serializer->status.flags |= NDPI_SERIALIZER_STATUS_NOT_EMPTY;
return(0);