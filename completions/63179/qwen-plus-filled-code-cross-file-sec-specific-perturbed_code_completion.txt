u_int32_t needed;
char header_written = serializer->status.flags & NDPI_SERIALIZER_STATUS_HEADER_WRITTEN;

/* Calculate the space required to serialize the integer */
needed = ndpi_snprintf(NULL, 0, "%d", value) + 1; /* +1 for null terminator */

if (!header_written) {
  /* If header has not been written, prepend it and account for its size */
  u_int32_t header_len = strlen(key);
  needed += header_len + 2; /* +2 for comma and null terminator */

  if (remainingspace < needed) {
    if (ndpi_extend_serializer_buffer(&serializer->buffer, needed - remainingspace) < 0)
      return(-1);
    remainingspace = serializer->buffer.size - serializer->status.buffer.size_used;
  }

  rc = ndpi_snprintf((char *)&serializer->buffer.data[serializer->status.buffer.size_used], remainingspace,
                     "%s,", key);
  if (rc < 0 || (u_int)rc >= remainingspace)
    return(-1);

  serializer->status.buffer.size_used += rc;
  serializer->status.flags |= NDPI_SERIALIZER_STATUS_HEADER_WRITTEN;
}

/* Serialize the integer value */
remainingspace = serializer->buffer.size - serializer->status.buffer.size_used;

if (remainingspace < needed) {
  if (ndpi_extend_serializer_buffer(&serializer->buffer, needed - remainingspace) < 0)
    return(-1);
  remainingspace = serializer->buffer.size - serializer->status.buffer.size_used;
}

rc = ndpi_snprintf((char *)&serializer->buffer.data[serializer->status.buffer.size_used], remainingspace,
                   "%d", value);