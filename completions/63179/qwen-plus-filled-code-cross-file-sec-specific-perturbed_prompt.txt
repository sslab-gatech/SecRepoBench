Below is the content of a C/C++ function where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
int ndpi_serialize_string_int32(ndpi_serializer *_serializer,
				const char *key, int32_t value) {
#ifdef OPTIMIZE_CSV_SERIALIZATION
  ndpi_private_serializer *serializer = (ndpi_private_serializer*)_serializer;

  if(serializer->fmt == ndpi_serialization_format_csv) {
    /* Key is ignored */
    u_int32_t remainingspace = serializer->buffer.size - serializer->status.buffer.size_used;
    // Serialize the integer value into a CSV format string and store it in the buffer.
    // Ensure that the buffer has sufficient space, extending it if necessary.
    // Prepend a header string if the header has not already been written.
    // Adjust the buffer usage count to reflect the serialized data.
    // <MASK>

    if(rc < 0 || (u_int)rc >= remainingspace)
      return(-1);
    
    serializer->status.buffer.size_used += rc;
    
    return(0);
  } else
#endif
  return(ndpi_serialize_binary_int32(_serializer, key, strlen(key), value));
}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/lib/ndpi_serializer.c
int ndpi_serialize_string_string(ndpi_serializer *_serializer,
				 const char *key, const char *_value) {
  const char *value = _value ? _value : "";
  
  return(ndpi_serialize_string_string_len(_serializer, key, value, strlen(value)));
}

// the below code fragment can be found in:
// src/lib/ndpi_serializer.c
int ndpi_serialize_string_uint32(ndpi_serializer *_serializer,
				 const char *key, u_int32_t value) {
  return(ndpi_serialize_binary_uint32(_serializer, key, strlen(key), value));
}

// the below code fragment can be found in:
// src/lib/ndpi_serializer.c
int ndpi_serialize_string_boolean(ndpi_serializer *_serializer,
				  const char *key, u_int8_t value) {
  return(ndpi_serialize_binary_boolean(_serializer, key, strlen(key), value));
}

// the below code fragment can be found in:
// src/lib/ndpi_serializer.c
int ndpi_serialize_string_int64(ndpi_serializer *_serializer,
				const char *key, int64_t value) {
  return(ndpi_serialize_binary_int64(_serializer, key, strlen(key), value));
}

// the below code fragment can be found in:
// src/lib/ndpi_serializer.c
int ndpi_serialize_binary_int64(ndpi_serializer *_serializer,
				const char *key, u_int16_t klen,
				int64_t value) {
  ndpi_private_serializer *serializer = (ndpi_private_serializer*)_serializer;
  u_int32_t buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;
  u_int32_t needed;
  int rc;

#ifdef OPTIMIZE_NUMERIC_KEYS
  if(ndpi_is_number(key, klen))
    return(ndpi_serialize_uint32_int64(_serializer, atoi(key), value));
#endif

  needed =
    sizeof(u_int8_t) /* type */ +
    sizeof(u_int16_t) /* key len */ +
    klen /* key */ +
    sizeof(u_int64_t);

  if(serializer->fmt == ndpi_serialization_format_json)
    needed += 16 + klen;

  if(buff_diff < needed) {
    if(ndpi_extend_serializer_buffer(&serializer->buffer, needed - buff_diff) < 0)
      return(-1);
    buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;
  }

  if(serializer->fmt == ndpi_serialization_format_json) {
    ndpi_serialize_json_pre(_serializer);
    buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;

    if (!(serializer->status.flags & NDPI_SERIALIZER_STATUS_LIST)) {
      serializer->status.buffer.size_used += ndpi_json_string_escape(key, klen,
        (char *) &serializer->buffer.data[serializer->status.buffer.size_used], buff_diff);
      buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;
      serializer->buffer.data[serializer->status.buffer.size_used] = ':';
      serializer->status.buffer.size_used++;
      buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;
    }

    rc = ndpi_snprintf((char *)
      &serializer->buffer.data[serializer->status.buffer.size_used], buff_diff,
      NDPI_I64_FORMAT, (long long int)value);
    if(rc < 0 || (u_int)rc >= buff_diff)
      return(-1);
    serializer->status.buffer.size_used += rc;

    if(ndpi_serialize_json_post(_serializer) != 0)
      return(-1);
  } else if(serializer->fmt == ndpi_serialization_format_csv) {
    if (ndpi_serializer_header_string(serializer, key, klen) < 0) return(-1);
    ndpi_serialize_csv_pre(serializer);
    buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;
    rc = ndpi_snprintf((char *) &serializer->buffer.data[serializer->status.buffer.size_used], buff_diff,
      NDPI_I64_FORMAT, (long long int)value);
    if(rc < 0 || (u_int)rc >= buff_diff)
      return(-1);
    serializer->status.buffer.size_used += rc;
  } else {
    if ((value & 0xFFFFFFFF) == value) {
      return(ndpi_serialize_string_int32(_serializer, key, value));
    } else {
      serializer->buffer.data[serializer->status.buffer.size_used++] = (ndpi_serialization_string << 4) | ndpi_serialization_int64;
      ndpi_serialize_single_string(serializer, key, klen);
      ndpi_serialize_single_uint64(serializer, value);
    }
  }

  serializer->status.flags |= NDPI_SERIALIZER_STATUS_NOT_EMPTY;
  return(0);
}
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).