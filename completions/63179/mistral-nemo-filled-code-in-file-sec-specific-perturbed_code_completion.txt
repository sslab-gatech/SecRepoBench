/* ********************************** */

int ndpi_serialize_binary_binary(ndpi_serializer *_serializer,
				 const char *key, u_int16_t klen,
				 const char *value, u_int16_t vlen) {
  ndpi_private_serializer *serializer = (ndpi_private_serializer*)_serializer;
  u_int32_t buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;
  u_int32_t needed;
  int rc;

  needed =
    sizeof(u_int8_t) /* type */ +
    sizeof(u_int16_t) /* key len */ +
    klen /* key */ +
    sizeof(u_int16_t) /* len */ +
    vlen;

  if(serializer->fmt == ndpi_serialization_format_json)
    needed += 16 + klen + vlen;

  if(buff_diff < needed) {
    if(ndpi_extend_serializer_buffer(&serializer->buffer, needed - buff_diff) < 0)
      return(-1);
    buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;
  }

  if(serializer->fmt == ndpi_serialization_format_json) {
    ndpi_serialize_json_pre(_serializer);
    buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;

    serializer->status.buffer.size_used += ndpi_json_string_escape(key, klen,
      (char *) &serializer->buffer.data[serializer->status.buffer.size_used], buff_diff);
    buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;
    serializer->buffer.data[serializer->status.buffer.size_used] = ':';
    serializer->status.buffer.size_used++;
    buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;

    serializer->status.buffer.size_used += ndpi_json_string_escape(value, vlen,
      (char *) &serializer->buffer.data[serializer->status.buffer.size_used], buff_diff);
    buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;

    if(ndpi_serialize_json_post(_serializer) != 0)
      return(-1);
  } else if(serializer->fmt == ndpi_serialization_format_csv) {
    if (ndpi_serializer_header_string(serializer, key, klen) < 0) return(-1);
    ndpi_serialize_csv_pre(serializer);
    buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;
    rc = ndpi_snprintf((char *) &serializer->buffer.data[serializer->status.buffer.size_used], buff_diff,
      "%.*s", vlen, value);
    if(rc < 0 || (u_int)rc >= buff_diff)
      return(-1);
    serializer->status.buffer.size_used += rc;
  } else {
    serializer->buffer.data[serializer->status.buffer.size_used++] = (ndpi_serialization_string << 4) | ndpi_serialization_string;
    ndpi_serialize_single_string(serializer, key, klen);
    ndpi_serialize_single_string(serializer, value, vlen);
  }

  serializer->status.flags |= NDPI_SERIALIZER_STATUS_NOT_EMPTY;
  return(0);
}

/* ********************************** */

int ndpi_serialize_string_binary(ndpi_serializer *_serializer,
				 const char *key, const char *value, u_int16_t vlen) {
  return(ndpi_serialize_binary_binary(_serializer, key, strlen(key), value, vlen));
}

/* ********************************** */

int ndpi_deserialize_binary_binary(ndpi_deserializer *_deserializer,
				 const char **key, u_int16_t *klen,
				 const char **value, u_int16_t *vlen) {
  ndpi_private_deserializer *deserializer = (ndpi_private_deserializer*)_deserializer;
  ndpi_serialization_type kt, et;
  u_int32_t buff_diff = deserializer->buffer.size - deserializer->status.buffer.size_used;
  u_int16_t expected;
  int size;

  expected = sizeof(u_int8_t) /* type */;

  if(buff_diff < expected) return(-2);

  kt = ndpi_deserialize_get_key_subtype(deserializer);

  size = ndpi_deserialize_get_single_size(deserializer, kt, deserializer->status.buffer.size_used + expected);
  if(size < 0) return(-2);

  expected += size;

  et = ndpi_deserialize_get_value_subtype(deserializer);
  size = ndpi_deserialize_get_single_size(deserializer, et, deserializer->status.buffer.size_used + expected);
  if(size < 0) return(-2);

  if(et != ndpi_serialization_string)
    return(-1);

  expected += size;

  if(buff_diff < expected) return(-2);

  *klen = ntohs(*((u_int16_t *) &deserializer->buffer.data[deserializer->status.buffer.size_used + size]));
  *vlen = ntohs(*((u_int16_t *) &deserializer->buffer.data[deserializer->status.buffer.size_used + size + sizeof(u_int16_t)]));

  if(*klen > (deserializer->buffer.size - deserializer->status.buffer.size_used - sizeof(u_int16_t)))
    return(-2);

  *key = (const char *) &deserializer->buffer.data[deserializer->status.buffer.size_used + size + sizeof(u_int16_t) * 2];
  *value = (const char *) &deserializer->buffer.data[deserializer->status.buffer.size_used + size + sizeof(u_int16_t) * 2 + *klen];

  deserializer->status.buffer.size_used += expected;

  return(0);
}

/* ********************************** */

int ndpi_deserialize_string_binary(ndpi_deserializer *_deserializer,
				 const char **key, u_int16_t *klen,
				 const char **value, u_int16_t *vlen) {
  return(ndpi_deserialize_binary_binary(_deserializer, key, klen, value, vlen));
}