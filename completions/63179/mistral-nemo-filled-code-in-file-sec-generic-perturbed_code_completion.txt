/* ********************************** */

int ndpi_serialize_binary_binary(ndpi_serializer *_serializer,
				 const char *key, u_int16_t klen,
				 const char *_value, u_int16_t vlen) {
  ndpi_private_serializer *serializer = (ndpi_private_serializer*)_serializer;
  u_int32_t buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;
  u_int32_t needed;
  int rc;

#ifdef OPTIMIZE_NUMERIC_KEYS
  if(ndpi_is_number(key, klen))
    return(ndpi_serialize_uint32_binary(_serializer, atoi(key), _value, vlen));
#endif

  needed =
    sizeof(u_int8_t) /* type */ +
    sizeof(u_int16_t) /* key len */ +
    klen /* key */ +
    sizeof(u_int16_t) /* len */ +
    vlen;

  if(serializer->fmt == ndpi_serialization_format_json)
    needed += 16 + klen + vlen;

  if(buff_diff < needed) {
    if(ndpi_extend_serializer_buffer(&serializer->buffer, needed - buff_diff) < 0)
      return(-1);
    buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;
  }

  if(serializer->fmt == ndpi_serialization_format_json) {
    ndpi_serialize_json_pre(_serializer);
    buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;

    serializer->status.buffer.size_used += ndpi_json_string_escape(key, klen,
      (char *) &serializer->buffer.data[serializer->status.buffer.size_used], buff_diff);
    buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;
    serializer->buffer.data[serializer->status.buffer.size_used] = ':';
    serializer->status.buffer.size_used++;
    buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;

    serializer->status.buffer.size_used += ndpi_json_string_escape(_value, vlen,
      (char *) &serializer->buffer.data[serializer->status.buffer.size_used], buff_diff);
    buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;

    if(ndpi_serialize_json_post(_serializer) != 0)
      return(-1);
  } else if(serializer->fmt == ndpi_serialization_format_csv) {
    if (ndpi_serializer_header_string(serializer, key, klen) < 0) return(-1);
    ndpi_serialize_csv_pre(serializer);
    buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;
    rc = ndpi_snprintf((char *) &serializer->buffer.data[serializer->status.buffer.size_used], buff_diff,
      "%.*s", vlen, _value);
    if(rc < 0 || (u_int)rc >= buff_diff)
      return(-1);
    serializer->status.buffer.size_used += rc;
  } else {
    serializer->buffer.data[serializer->status.buffer.size_used++] = (ndpi_serialization_string << 4) | ndpi_serialization_string;

    ndpi_serialize_single_string(serializer, key, klen);
    ndpi_serialize_single_string(serializer, _value, vlen);
  }

  serializer->status.flags |= NDPI_SERIALIZER_STATUS_NOT_EMPTY;
  return(0);
}

/* ********************************** */

int ndpi_serialize_string_binary(ndpi_serializer *_serializer,
				 const char *key, const char *_value, u_int16_t vlen) {
  return(ndpi_serialize_binary_binary(_serializer, key, strlen(key),
				      _value, vlen));
}

/* ********************************** */