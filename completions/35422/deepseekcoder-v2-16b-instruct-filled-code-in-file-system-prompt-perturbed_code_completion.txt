%  StringToArgv() converts a string to an argument vector.
%
%  The format of the StringToArgv method is:
%
%      char **StringToArgv(const char *string,const size_t length,
%        size_t *number_parameters)
%
%  A description of each parameter follows:
%
%    o string: the string.
%
%    o length: the length of the string.
%
%    o number_parameters: the number of parameters.
%
*/
MagickExport char **StringToArgv(const char *string,const size_t length,
  size_t *number_parameters)
{
  char
    **argv;

  const char
    *p;

  size_t
    i,
    j,
    count;

  assert(string != (const char *) NULL);
  assert(number_parameters != (size_t *) NULL);
  *number_parameters=0;
  p=string;
  for (i=0; i < length; i++)
  {
    if (p[i] == ' ')
      continue;
    (*number_parameters)++;
    while ((i < length) && (p[i] != ' '))
      i++;
  }
  argv=(char **) AcquireQuantumMemory((*number_parameters+1)*sizeof(*argv),
    sizeof(**argv));
  if (argv == (char **) NULL)
    return((char **) NULL);
  for (i=0, j=0; i < length; i++)
  {
    if (string[i] == ' ')
      continue;
    count=0;
    while ((i+count < length) && (string[i+count] != ' '))
      count++;
    argv[j]=(char *) AcquireQuantumMemory(count+1,sizeof(**argv));
    if (argv[j] == (char *) NULL)
      return((char **) NULL);
    (void) memcpy(argv[j],string+i,count);
    argv[j][count]='\0';
    i+=count;
    j++;
  }
  argv[*number_parameters]=(char *) NULL;
  return(argv);
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   T o L o w e r S t r i n g                                               %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  ToLowerString() returns a lower case version of the string.
%
%  The format of the ToLowerString method is:
%
%      char *ToLowerString(const char *source)
%
%  A description of each parameter follows:
%
%    o source: A character string.
%
*/
MagickExport char *ToLowerString(const char *source)
{
  char
    *destination;

  size_t
    length;

  size_t
    i;

  assert(source != (const char *) NULL);
  length=strlen(source);
  destination=(char *) AcquireQuantumMemory(length+MagickPathExtent,
    sizeof(*destination));
  if (destination == (char *) NULL)
    ThrowFatalException(ResourceLimitFatalError,"UnableToAcquireString");
  for (i=0; i < length; i++)
    destination[i]=tolower((int) ((unsigned char) source[i]));
  destination[length]='\0';
  return(destination);
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   T o U p p e r S t r i n g                                               %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  ToUpperString() returns a upper case version of the string.
%
%  The format of the ToUpperString method is:
%
%      char *ToUpperString(const char *source)
%
%  A description of each parameter follows:
%
%    o source: A character string.
%
*/
MagickExport char *ToUpperString(const char *source)
{
  char
    *destination;

  size_t
    length;

  size_t
    i;

  assert(source != (const char *) NULL);
  length=strlen(source);
  destination=(char *) AcquireQuantumMemory(length+MagickPathExtent,
    sizeof(*destination));
  if (destination == (char *) NULL)
    ThrowFatalException(ResourceLimitFatalError,"UnableToAcquireString");
  for (i=0; i < length; i++)
    destination[i]=toupper((int) ((unsigned char) source[i]));
  destination[length]='\0';
  return(destination);
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   U n e s c a p e S t r i n g                                             %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  UnescapeString() allocates memory for a backslash-unescaped version of a
%  source text string, copies the unescaped version of the text to that
%  memory location while removing backslash characters, and returns the
%  unescaped string.
%
%  The format of the UnescapeString method is:
%
%      char *UnescapeString(const char *source,const char escape)
%
%  A description of each parameter follows:
%
%    o source: A character string.
%
%    o escape: the quoted string termination character to escape (e.g. '"').
%
*/
MagickExport char *UnescapeString(const char *source,const char escape)
{
  char
    *destination;

  char
    *q;

  const char
    *p;

  size_t
    length;

  assert(source != (const char *) NULL);
  length=strlen(source);
  destination=(char *) AcquireQuantumMemory(length+MagickPathExtent,
    sizeof(*destination));
  if (destination == (char *) NULL)
    ThrowFatalException(ResourceLimitFatalError,"UnableToUnescapeString");
  *destination='\0';
  q=destination;
  p=source;
  while (*p != '\0')
  {
    if ((*p == '\\') && (*(p+1) != '\0'))
      {
        p++;
        if (*p == escape)
          *q++=escape;
        else
          *q++=(*p);
      }
    else
      *q++=(*p);
    p++;
  }
  *q='\0';
  return(destination);
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   W r i t e S t r i n g I n f o                                           %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  WriteStringInfo() writes the string to a file.
%
%  The format of the WriteStringInfo method is:
%
%      MagickBooleanType WriteStringInfo(FILE *file,const StringInfo *string_info)
%
%  A description of each parameter follows:
%
%    o file: the file, typically stdout.
%
%    o string_info: the string info.
%
*/
MagickExport MagickBooleanType WriteStringInfo(FILE *file,
  const StringInfo *string_info)
{
  assert(file != (FILE *) NULL);
  assert(string_info != (StringInfo *) NULL);
  assert(string_info->signature == MagickCoreSignature);
  if (fwrite(string_info->datum,sizeof(*string_info->datum),
      string_info->length,file) != string_info->length)
    return(MagickFalse);
  return(MagickTrue);
}

/*
  The following function is used to map a file into memory.
*/
static void *MapBlob(int file,const char *mode,const MagickOffsetType offset,
  const size_t length)
{
  void
    *map;

  map=(void *) mmap(NULL,length,PROT_READ,MAP_PRIVATE,file,offset);
  if (map == MAP_FAILED)
    return((void *) NULL);
  return(map);
}

/*
  The following function is used to unmap a file from memory.
*/
static MagickBooleanType UnmapBlob(void *map,const size_t length)
{
  if (munmap(map,length) == -1)
    return(MagickFalse);
  return(MagickTrue);
}

/*
  The following function is used to open a file.
*/
static int open_utf8(const char *filename,int flags,mode_t mode)
{
  int
    file;

  file=open(filename,flags,mode);
  if (file == -1)
    return(-1);
  if (setlocale(LC_ALL,"") == (char *) NULL)
    (void) setlocale(LC_ALL,"C");
  return(file);
}

/*
  The following function is used to close a file.
*/
static int close_utf8(int file)
{
  if (close(file) == -1)
    return(-1);
  return(0);
}

/*
  The following function is used to read a file.
*/
static void *ReadBlob(int file,const size_t length)
{
  void
    *blob;

  blob=(void *) malloc(length);
  if (blob == (void *) NULL)
    return((void *) NULL);
  if (read(file,(char *) blob,length) != (ssize_t) length)
    {
      blob=(void *) free(blob);
      return((void *) NULL);
    }
  return(blob);
}

/*
  The following function is used to write a file.
*/
static MagickBooleanType WriteBlob(int file,const void *blob,const size_t length)
{
  if (write(file,(char *) blob,length) != (ssize_t) length)
    return(MagickFalse);
  return(MagickTrue);
}

/*
  The following function is used to resize memory.
*/
static void *ResizeBlob(void *blob,const size_t new_length)
{
  void
    *new_blob;

  new_blob=(void *) realloc(blob,new_length);
  if (new_blob == (void *) NULL)
    {
      blob=(void *) free(blob);
      return((void *) NULL);
    }
  return(new_blob);
}

/*
  The following function is used to acquire memory.
*/
static void *AcquireBlob(const size_t length)
{
  void
    *blob;

  blob=(void *) malloc(length);
  if (blob == (void *) NULL)
    ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
  return(blob);
}

/*
  The following function is used to relinquish memory.
*/
static void *RelinquishBlob(void *blob)
{
  return((void *) free(blob));
}

/*
  The following function is used to acquire critical memory.
*/
static void *AcquireCriticalMemory(const size_t length)
{
  void
    *blob;

  blob=(void *) AcquireBlob(length);
  (void) memset(blob,0,length);
  return(blob);
}

/*
  The following function is used to resize quantum memory.
*/
static void *ResizeQuantumMemory(void *memory,const size_t new_quantity,
  const size_t element_size)
{
  void
    *new_memory;

  size_t
    new_length;

  if (memory == (void *) NULL)
    return(AcquireBlob(new_quantity*element_size));
  new_length=new_quantity*element_size;
  new_memory=(void *) realloc(memory,new_length);
  if (new_memory == (void *) NULL)
    {
      memory=RelinquishBlob(memory);
      ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
    }
  return(new_memory);
}

/*
  The following function is used to acquire quantum memory.
*/
static void *AcquireQuantumMemory(const size_t quantity,const size_t element_size)
{
  return(ResizeQuantumMemory((void *) NULL,quantity,element_size));
}

/*
  The following function is used to relinquish quantum memory.
*/
static