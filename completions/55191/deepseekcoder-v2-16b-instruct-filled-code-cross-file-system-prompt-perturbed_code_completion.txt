// Validate if the current segment of the word is acceptable for compounding.
// This involves checking various conditions such as prefix status, compound flags,
// and specific rules for Hungarian language. Additionally, ensure that the segment
// does not violate any compound pattern conditions or contain prohibited triple
// letters or case issues. The validation relies on attributes of the current
// dictionary entry, compound flags, and predefined patterns.
if ((rv) && !hu_mov_rule &&
    ((pfx && pfx->getCont() &&
      TESTAFF(pfx->getCont(), compoundforbidflag, pfx->getContLen())) ||
     (sfx && sfx->getCont() &&
      TESTAFF(sfx->getCont(), compoundforbidflag, sfx->getContLen())))) {
  rv = NULL;
}

// check compoundend flag in suffix and prefix
if ((rv) && !checked_prefix && compoundend && !hu_mov_rule &&
    ((pfx && pfx->getCont() &&
      TESTAFF(pfx->getCont(), compoundend, pfx->getContLen())) ||
     (sfx && sfx->getCont() &&
      TESTAFF(sfx->getCont(), compoundend, sfx->getContLen())))) {
  rv = NULL;
}

// check compoundmiddle flag in suffix and prefix
if ((rv) && !checked_prefix && (wordnum == 0) && compoundmiddle &&
    !hu_mov_rule &&
    ((pfx && pfx->getCont() &&
      TESTAFF(pfx->getCont(), compoundmiddle, pfx->getContLen())) ||
     (sfx && sfx->getCont() &&
      TESTAFF(sfx->getCont(), compoundmiddle, sfx->getContLen())))) {
  rv = NULL;
}

// check forbiddenwords
if ((rv) && (rv->astr) &&
    (TESTAFF(rv->astr, forbiddenword, rv->alen) ||
     TESTAFF(rv->astr, ONLYUPCASEFLAG, rv->alen) ||
     (is_sug && nosuggest && TESTAFF(rv->astr, nosuggest, rv->alen)))) {
  return NULL;
}

// increment word number, if the second root has a compoundroot flag
if ((rv) && compoundroot &&
    (TESTAFF(rv->astr, compoundroot, rv->alen))) {
  wordnum++;
}

// first word is acceptable in compound words?
if ((
    // LANG_hu section: spec. Hungarian rule
    (langnum == LANG_hu && hu_mov_rule &&
     (rv = affix_check(st, 0, char_index)) &&
     (sfx && sfx->getCont() &&
      (  // XXX hardwired Hungarian dic. codes
          TESTAFF(sfx->getCont(), (unsigned short)'x',
                  sfx->getContLen()) ||
          TESTAFF(
              sfx->getCont(), (unsigned short)'%',
              sfx->getContLen())))) ||
    // END of LANG_hu section
    (rv) && (langnum == LANG_hu) && hu_mov_rule &&
    (rv = affix_check(st, 0, char_index)) &&
    (sfx && sfx->getCont() &&
     (  // XXX hardwired Hungarian dic. codes
         TESTAFF(sfx->getCont(), (unsigned short)'x',
                 sfx->getContLen()) ||
         TESTAFF(
             sfx->getCont(), (unsigned short)'%',
             sfx->getContLen())))) {  // first word is ok condition

  // LANG_hu section: spec. Hungarian rule
  if (langnum == LANG_hu) {
    // calculate syllable number of the word
    numsyllable += get_syllable(st.substr(0, char_index));
    // + 1 word, if syllable number of the prefix > 1 (hungarian
    // convention)
    if (pfx && (get_syllable(pfx->getKey()) > 1))
      wordnum++;
  }
  // END of LANG_hu section

  // NEXT WORD(S)
  rv_first = rv;
  st[char_index] = ch;

  do {  // striple loop

    // check simplifiedtriple
    if (simplifiedtriple) {
      if (striple) {
        checkedstriple = 1;
        char_index--;  // check "fahrt" instead of "ahrt" in "Schiffahrt"
      } else if (char_index > 2 && char_index <= word.size() && word[char_index - 1] == word[char_index - 2])
        striple = 1;
    }

    rv = lookup(st.c_str() + char_index, st.size() - char_index);  // perhaps without prefix

    // search homonym with compound flag
    while ((rv) &&
           ((needaffix && TESTAFF(rv->astr, needaffix, rv->alen)) ||
            !((compoundflag && !words &&
               TESTAFF(rv->astr, compoundflag, rv->alen)) ||
              (compoundend && !words &&
               TESTAFF(rv->astr, compoundend, rv->alen)) ||
              (!defcpdtable.empty() && words &&
               defcpd_check(&words, wnum + 1, rv, NULL, 1))) ||
            (scpd != 0 && checkcpdtable[scpd - 1].cond2 != FLAG_NULL &&
             !TESTAFF(rv->astr, checkcpdtable[scpd - 1].cond2,
                      rv->alen)))) {
      rv = rv->next_homonym;
    }

    // check FORCEUCASE
    if (rv && forceucase &&
        (TESTAFF(rv->astr, forceucase, rv->alen)) &&
        !(info && *info & SPELL_ORIGCAP))
      rv = NULL;

    if (rv && words && words[wnum + 1])
      return rv_first;

    oldnumsyllable2 = numsyllable;
    oldwordnum2 = wordnum;

    // LANG_hu section: spec. Hungarian rule, XXX hardwired dictionary
    // code
    if ((rv) && (langnum == LANG_hu) &&
        (TESTAFF(rv->astr, 'I', rv->alen)) &&
        !(TESTAFF(rv->astr, 'J', rv->alen))) {
      numsyllable--;
    }
    // END of LANG_hu section

    // increment word number, if the second root has a compoundroot flag
    if ((rv) && (compoundroot) &&
        (TESTAFF(rv->astr, compoundroot, rv->alen))) {
      wordnum++;
    }

    // check forbiddenwords
    if ((rv) && (rv->astr) &&
        (TESTAFF(rv->astr, forbiddenword, rv->alen) ||
         TESTAFF(rv->astr, ONLYUPCASEFLAG, rv->alen) ||
         (is_sug && nosuggest &&
          TESTAFF(rv->astr, nosuggest, rv->alen))))
      return NULL;

    // second word is acceptable, as a root?
    // hungarian conventions: compounding is acceptable,
    // when compound forms consist of 2 words, or if more,
    // then the syllable number of root words must be 6, or lesser.

    if ((rv) &&
        ((compoundflag && TESTAFF(rv->astr, compoundflag, rv->alen)) ||
         (compoundend && TESTAFF(rv->astr, compoundend, rv->alen))) &&
        (((cpdwordmax == -1) || (wordnum + 1 < cpdwordmax)) ||
         ((cpdmaxsyllable != 0) &&
          (numsyllable + get_syllable(std::string(HENTRY_WORD(rv), rv->blen)) <=
           cpdmaxsyllable))) &&
        (
            // test CHECKCOMPOUNDPATTERN
            checkcpdtable.empty() || scpd != 0 ||
            (char_index < word.size() && !cpdpat_check(word, char_index, rv_first, rv, 0))) &&
            ((!checkcompounddup || (rv != rv_first)))
            // test CHECKCOMPOUNDPATTERN conditions
            &&
            (scpd == 0 || checkcpdtable[scpd - 1].cond2 == FLAG_NULL ||
             TESTAFF(rv->astr, checkcpdtable[scpd - 1].cond2, rv->alen))) {
      // forbid compound word, if it is a non-compound word with typical
      // fault
      if ((checkcompoundrep && cpdrep_check(word, len)) ||
          cpdwordpair_check(word, len))
        return NULL;
      return rv_first;
    }

    numsyllable = oldnumsyllable2;
    wordnum = oldwordnum2;

    // perhaps second word has prefix or/and suffix
    sfx = NULL;
    sfxflag = FLAG_NULL;
    rv = (compoundflag && !onlycpdrule && char_index < word.size())
             ? affix_check(word, char_index, word.size() - char_index, compoundflag,
                           IN_CPD_END)
             : NULL;
    if (!rv && compoundend && !onlycpdrule) {
      sfx = NULL;
      pfx = NULL;
      if (char_index < word.size())
        rv = affix_check(word, char_index, word.size() - char_index, compoundend, IN_CPD_END);
    }

    if (!rv && !defcpdtable.empty() && words) {
      if (char_index < word.size())
        rv = affix_check(word, char_index, word.size() - char_index, 0, IN_CPD_END);
      if (rv && defcpd_check(&words, wnum + 1, rv, NULL, 1))
        return rv_first;
      rv = NULL;
    }

    // test CHECKCOMPOUNDPATTERN conditions (allowed forms)
    if (rv &&
        !(scpd == 0 || checkcpdtable[scpd - 1].cond2 == FLAG_NULL ||
          TESTAFF(rv->astr, checkcpdtable[scpd - 1].cond2, rv->alen)))
      rv = NULL;

    // test CHECKCOMPOUNDPATTERN conditions (forbidden compounds)
    if (rv && !checkcpdtable.empty() && scpd == 0 &&
        cpdpat_check(word, char_index, rv_first, rv, affixed))
      rv = NULL;

    // check non_compound flag in suffix and prefix
    if ((rv) && ((pfx && pfx->getCont() &&
                  TESTAFF(pfx->getCont(), compoundforbidflag, pfx->getContLen())) ||
                 (sfx && sfx->getCont() &&
                  TESTAFF(sfx->getCont(), compoundforbidflag, sfx->getContLen())))) {
      rv = NULL;
    }

    // check FORCEUCASE
    if (rv && forceucase &&
        (TESTAFF(rv->astr, forceucase, rv->alen)) &&
        !(info && *info & SPELL_ORIGCAP))
      rv = NULL;

    // check forbiddenwords
    if ((rv) && (rv->astr) &&
        (TESTAFF(rv->astr, forbiddenword, rv->alen) ||
         TESTAFF(rv->astr, ONLYUPCASEFLAG, rv->alen) ||
         (is_sug && nosuggest &&
          TESTAFF(rv->astr, nosuggest, rv->alen))))
      return NULL;

    // pfxappnd = prefix of word+i, or NULL
    // calculate syllable number of prefix.
    // hungarian convention: when syllable number of prefix is more,
    // than 1, the prefix+word counts as two words.

    if (langnum == LANG_hu) {
      if (char_index < word.size()) {
        // calculate syllable number of the word
        numsyllable += get_syllable(word.substr(char_index));
      }

      // - affix syllable num.
      // XXX only second suffix (inflections, not derivations)
      if (sfxappnd) {
        std::string tmp(sfxappnd);
        reverseword(tmp);
        numsyllable -= short(get_syllable(tmp) + sfxextra);
      } else {
        numsyllable -= short(sfxextra);
      }

      // + 1 word, if syllable number of the prefix > 1 (hungarian
      /