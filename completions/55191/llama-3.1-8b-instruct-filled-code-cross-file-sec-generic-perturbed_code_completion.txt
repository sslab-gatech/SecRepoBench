// Validate if the current segment of the word is acceptable for compounding.
// This involves checking various conditions such as prefix status, compound flags,
// and specific rules for Hungarian language. Additionally, ensure that the segment
// does not violate any compound pattern conditions or contain prohibited triple
// letters or case issues. The validation relies on attributes of the current
// dictionary entry, compound flags, and predefined patterns.
if (
    // Validate prefix status
    (rv && pfx && pfx->getCont() && TESTAFF(pfx->getCont(), compoundforbidflag, pfx->getContLen())) ||
    // Validate compound flags
    ((rv && compoundflag && TESTAFF(rv->astr, compoundflag, rv->alen)) ||
     (rv && compoundend && TESTAFF(rv->astr, compoundend, rv->alen)) ||
     (rv && compoundmiddle && TESTAFF(rv->astr, compoundmiddle, rv->alen))) ||
    // Validate specific rules for Hungarian language
    ((langnum == LANG_hu) && hu_mov_rule && (rv = affix_check(st, 0, char_index)) &&
     (sfx && sfx->getCont() && (TESTAFF(sfx->getCont(), (unsigned short)'x', sfx->getContLen()) ||
                              TESTAFF(sfx->getCont(), (unsigned short)'%', sfx->getContLen()))))) {
  // first word is ok condition
  // LANG_hu section: spec. Hungarian rule
  if (langnum == LANG_hu) {
    // calculate syllable number of the word
    numsyllable += get_syllable(st.substr(0, char_index));
    // + 1 word, if syllable number of the prefix > 1 (hungarian
    // convention)
    if (pfx && (get_syllable(pfx->getKey()) > 1))
      wordnum++;
  }
  // END of LANG_hu section

  // NEXT WORD(S)
  rv_first = rv;
  st[char_index] = ch;

  do {  // striple loop

    // check simplifiedtriple
    if (simplifiedtriple) {
      if (striple) {
        checkedstriple = 1;
        char_index--;  // check "fahrt" instead of "ahrt" in "Schiffahrt"
      } else if (char_index > 2 && char_index <= word.size() && word[char_index - 1] == word[char_index - 2])
        striple = 1;
    }

    rv = lookup(st.c_str() + char_index, st.size() - char_index);  // perhaps without prefix

    // search homonym with compound flag
    while ((rv) &&
           ((needaffix && TESTAFF(rv->astr, needaffix, rv->alen)) ||
           !((compoundflag &&!words &&
               TESTAFF(rv->astr, compoundflag, rv->alen)) ||
              (compoundend &&!words &&
               TESTAFF(rv->astr, compoundend, rv->alen)) ||
              (!defcpdtable.empty() && words &&
               defcpd_check(&words, wnum + 1, rv, NULL, 1))) ||
            (scpd!= 0 && checkcpdtable[scpd - 1].cond2!= FLAG_NULL &&
            !TESTAFF(rv->astr, checkcpdtable[scpd - 1].cond2,
                      rv->alen)))) {
      rv = rv->next_homonym;
    }

    // check FORCEUCASE
    if (rv && forceucase &&
        (TESTAFF(rv->astr, forceucase, rv->alen)) &&
       !(info && *info & SPELL_ORIGCAP))
      rv = NULL;

    if (rv && words && words[wnum + 1])
      return rv_first;

    oldnumsyllable2 = numsyllable;
    oldwordnum2 = wordnum;

    // LANG_hu section: spec. Hungarian rule, XXX hardwired dictionary
    // code
    if ((rv) && (langnum == LANG_hu) &&
        (TESTAFF(rv->astr, 'I', rv->alen)) &&
       !(TESTAFF(rv->astr, 'J', rv->alen))) {
      numsyllable--;
    }
    // END of LANG_hu section

    // increment word number, if the second root has a compoundroot flag
    if ((rv) && (compoundroot) &&
        (TESTAFF(rv->astr, compoundroot, rv->alen))) {
      wordnum++;
    }

    // check forbiddenwords
    if ((rv) && (rv->astr) &&
        (TESTAFF(rv->astr, forbiddenword, rv->alen) ||
         TESTAFF(rv->astr, ONLYUPCASEFLAG, rv->alen) ||
         (is_sug && nosuggest &&
          TESTAFF(rv->astr, nosuggest, rv->alen))))
      return NULL;

    // second word is acceptable, as a root?
    // hungarian conventions: compounding is acceptable,
    // when compound forms consist of 2 words, or if more,
    // then the syllable number of root words must be 6, or lesser.

    if ((rv) &&
        ((compoundflag && TESTAFF(rv->astr, compoundflag, rv->alen)) ||
         (compoundend && TESTAFF(rv->astr, compoundend, rv->alen))) &&
        (((cpdwordmax == -1) || (wordnum + 1 < cpdwordmax)) ||
         ((cpdmaxsyllable!= 0) &&
          (numsyllable + get_syllable(std::string(HENTRY_WORD(rv), rv->blen)) <=
           cpdmaxsyllable))) &&
        (
            // test CHECKCOMPOUNDPATTERN
            checkcpdtable.empty() || scpd!= 0 ||
            (char_index < word.size() &&!cpdpat_check(word, char_index, rv_first, rv, 0))) &&
        ((!checkcompounddup || (rv!= rv_first)))
        // test CHECKCOMPOUNDPATTERN conditions
        &&
        (scpd == 0 || checkcpdtable[scpd - 1].cond2 == FLAG_NULL ||
         TESTAFF(rv->astr, checkcpdtable[scpd - 1].cond2, rv->alen))) {
      // forbid compound word, if it is a non-compound word with typical
      // fault
      if ((checkcompoundrep && cpdrep_check(word, len)) ||
              cpdwordpair_check(word, len))
        return NULL;
      return rv_first;
    }

    numsyllable = oldnumsyllable2;
    wordnum = oldwordnum2;

    // perhaps second word has prefix or/and suffix
    sfx = NULL;
    sfxflag = FLAG_NULL;
    rv = (compoundflag &&!onlycpdrule && char_index < word.size())
            ? affix_check(word, char_index, word.size() - char_index, compoundflag,
                           IN_CPD_END)
             : NULL;
    if (!rv && compoundend &&!onlycpdrule) {
      sfx = NULL;
      pfx = NULL;
      if (char_index < word.size())
        rv = affix_check(word, char_index, word.size() - char_index, compoundend, IN_CPD_END);
    }

    if (!rv &&!defcpdtable.empty() && words) {
      if (char_index < word.size())
        rv = affix_check(word, char_index, word.size() - char_index, 0, IN_CPD_END);
      if (rv && defcpd_check(&words, wnum + 1, rv, NULL, 1))
        return rv_first;
      rv = NULL;
    }

    // test CHECKCOMPOUNDPATTERN conditions (allowed forms)
    if (rv &&
       !(scpd == 0 || checkcpdtable[scpd - 1].cond2 == FLAG_NULL ||
          TESTAFF(rv->astr, checkcpdtable[scpd - 1].cond2, rv->alen)))
      rv = NULL;

    // test CHECKCOMPOUNDPATTERN conditions (forbidden compounds)
    if (rv &&!checkcpdtable.empty() && scpd == 0 &&
        cpdpat_check(word, char_index, rv_first, rv, affixed))
      rv = NULL;

    // check non_compound flag in suffix and prefix
    if ((rv) && ((pfx && pfx->getCont() &&
                  TESTAFF(pfx->getCont(), compoundforbidflag,
                          pfx->getContLen())) ||
                 (sfx && sfx->getCont() &&
                  TESTAFF(sfx->getCont(), compoundforbidflag,
                          sfx->getContLen())))) {
      rv = NULL;
    }

    // check FORCEUCASE
    if (rv && forceucase &&
        (TESTAFF(rv->astr, forceucase, rv->alen)) &&
       !(info && *info & SPELL_ORIGCAP))
      rv = NULL;

    // check forbiddenwords
    if ((rv) && (rv->astr) &&
        (TESTAFF(rv->astr, forbiddenword, rv->alen) ||
         TESTAFF(rv->astr, ONLYUPCASEFLAG, rv->alen) ||
         (is_sug && nosuggest &&
          TESTAFF(rv->astr, nosuggest, rv->alen))))
      return NULL;

    // pfxappnd = prefix of word+i, or NULL
    // calculate syllable number of prefix.
    // hungarian convention: when syllable number of prefix is more,
    // than 1, the prefix+word counts as two words.

    if (langnum == LANG_hu) {
      if (char_index < word.size()) {
        // calculate syllable number of the word
        numsyllable += get_syllable(word.substr(char_index));
      }

      // - affix syllable num.
      // XXX only second suffix (inflections, not derivations)
      if (sfxappnd) {
        std::string tmp(sfxappnd);
        reverseword(tmp);
        numsyllable -= short(get_syllable(tmp) + sfxextra);
      } else {
        numsyllable -= short(sfxextra);
      }

      // + 1 word, if syllable number of the prefix > 1 (hungarian
      // convention)
      if (pfx && (get_syllable(pfx->getKey()) > 1))
        wordnum++;

      // increment syllable num, if last word has a SYLLABLENUM flag
      // and the suffix is beginning `s`

      if (!cpdsyllablenum.empty()) {
        switch (sfxflag) {
          case 'c': {
            numsyllable += 2;
            break;
          }
          case 'J': {
            numsyllable += 1;
            break;
          }
          case 'I': {
            if (rv && TESTAFF(rv->astr, 'J', rv->alen))
              numsyllable += 1;
            break;
          }
        }
      }
    }

    // increment word number, if the second word has a compoundroot flag
    if ((rv) && (compoundroot) &&
        (TESTAFF(rv->astr, compoundroot, rv->alen))) {
      wordnum++;
    }
    // second word is acceptable, as a word with prefix or/and suffix?
    // hungarian conventions: compounding is acceptable,
    // when compound forms consist 2 word, otherwise
    // the syllable number of root words is 6, or lesser.
    if ((rv) &&
        (((cpdwordmax == -1) || (wordnum + 1 < cpdwordmax)) ||
         ((cpdmaxsyllable!= 0) && (numsyllable <= cpdmaxsyllable))) &&
        ((!checkcompounddup || (rv!= rv_first)))) {
      // forbid compound word, if it is a non-compound word with typical
      // fault
      if ((checkcompoundrep && cpdrep_check(word, len)) ||
              cpdwordpair_check(word, len))
        return NULL;
      return rv_first;
    }

    numsyllable = oldnumsyllable2;
    wordnum = oldwordnum2;

    // perhaps second word is a compound word (recursive call)
    // (only if SPELL_COMPOUND_2 is not set and maxwordnum is not exceeded)
    if ((!info ||!(*info & SPELL_COMPOUND_2)) && wordnum + 2 < maxwordnum) {
      rv = compound_check(st.substr(char_index), wordnum + 1,
                          numsyllable, maxwordnum, wnum + 1, words, rwords, 0,
                          is_sug, info);

      if (rv &&!checkcpdtable.empty() && char_index < word.size() &&
          ((scpd == 0 &&
            cpdpat_check(word, char_index, rv_first, rv, affixed)) ||
           (scpd!= 0 &&
           !cpdpat_check(word, char_index, rv_first, rv, affixed))))
        rv = NULL;
    } else {
      rv = NULL;
    }
    if (rv) {
      // forbid compound word, if it is a non-compound word with typical
      // fault, or a dictionary word pair

      if (cpdwordpair_check(word, len))
          return NULL;

      if (checkcompoundrep || forbiddenword) {

        if (checkcompoundrep && cpdrep_check(word, len))
          return NULL;

        // check first part
        if (char_index < word.size() && word.compare(char_index, rv->blen, rv->word, rv->blen) == 0) {
          char r = st[char_index + rv->blen];
          st[char_index + rv->blen] = '\0';

          if ((checkcompoundrep && cpdrep_check(st, char_index + rv->blen)) ||
                  cpdwordpair_check(st, char_index + rv->blen)) {
            st[ + char_index + rv->blen] = r;
            continue;
          }

          if (forbiddenword) {
            struct hentry* rv2 = lookup(word.c_str(), word.size());
            if (!rv2 && len <= word.size())
              rv2 = affix_check(word, 0