// check first word is acceptable in compound words?
// hu_mov_rule = spec. Hungarian rule (XXX)
if (((rv) &&
     (checked_prefix || (words && words[wnum]) ||
      (compoundflag && TESTAFF(rv->astr, compoundflag, rv->alen)) ||
      ((oldwordnum == 0) && compoundbegin &&
       TESTAFF(rv->astr, compoundbegin, rv->alen)) ||
      ((oldwordnum > 0) && compoundmiddle &&
       TESTAFF(rv->astr, compoundmiddle, rv->alen))
      // LANG_hu section: spec. Hungarian rule
      || ((langnum == LANG_hu) &&  // hu_mov_rule
          hu_mov_rule && (TESTAFF(rv->astr, 'F', rv->alen) ||
                          TESTAFF(rv->astr, 'G', rv->alen) ||
                          TESTAFF(rv->astr, 'H', rv->alen)))
      // END of LANG_hu section
      ) &&
    !((checkcompoundtriple &&!words &&  // test triple letters
        (word[i - 1] == word[i]) &&
        (((i > 1) && (word[i - 1] == word[i - 2])) ||
         ((word[i - 1] == word[i + 1]))  // may be word[i+1] == '\0'
         )) ||
       (
           // test CHECKCOMPOUNDPATTERN
          !checkcpdtable.empty() &&!words &&
           cpdpat_check(word, i, rv, NULL, affixed)) ||
       (checkcompoundcase &&!words && cpdcase_check(word, i))))
    // LANG_hu section: spec. Hungarian rule
    ||
    ((!rv) && (langnum == LANG_hu) && hu_mov_rule &&
     (rv = affix_check(st, 0, i)) &&
     (sfx && sfx->getCont() &&
      (TESTAFF(sfx->getCont(), (unsigned short)'x',
               sfx->getContLen()) ||
       TESTAFF(sfx->getCont(), (unsigned short)'%',
               sfx->getContLen()))))
    // END of LANG_hu section
    ) {
  // LANG_hu section: spec. Hungarian rule
  if (langnum == LANG_hu) {
    // calculate syllable number of the word
    numsyllable += get_syllable(st.substr(0, i));

    // + 1 word, if syllable number of the prefix > 1 (hungarian
    // convention)
    if (pfx && (get_syllable(pfx->getKey()) > 1))
      wordnum++;
  }
  // END of LANG_hu section

  // NEXT WORD(S)
  rv_first = rv;
  rv = lookup(word.c_str() + i, word.size() - i);  // perhaps without prefix

  // search homonym with compound flag
  while ((rv) && ((needaffix && TESTAFF(rv->astr, needaffix, rv->alen)) ||
                 !((compoundflag &&!words &&
                     TESTAFF(rv->astr, compoundflag, rv->alen)) ||
                    (compoundend &&!words &&
                     TESTAFF(rv->astr, compoundend, rv->alen)) ||
                    (!defcpdtable.empty() && words &&
                     defcpd_check(&words, wnum + 1, rv, NULL, 1))))) {
    rv = rv->next_homonym;
  }

  if (rv && words && words[wnum + 1]) {
    result.append(presult);
    result.push_back(MSEP_FLD);
    result.append(MORPH_PART);
    result.append(word, i, word.size());
    if (complexprefixes && HENTRY_DATA(rv))
      result.append(HENTRY_DATA2(rv));
    if (!HENTRY_FIND(rv, MORPH_STEM)) {
      result.push_back(MSEP_FLD);
      result.append(MORPH_STEM);
      result.append(HENTRY_WORD(rv));
    }
    // store the pointer of the hash entry
    if (!complexprefixes && HENTRY_DATA(rv)) {
      result.push_back(MSEP_FLD);
      result.append(HENTRY_DATA2(rv));
    }
    result.push_back(MSEP_REC);
    return 0;
  }

  oldnumsyllable2 = numsyllable;
  oldwordnum2 = wordnum;

  // LANG_hu section: spec. Hungarian rule
  if ((rv) && (langnum == LANG_hu) &&
      (TESTAFF(rv->astr, 'I', rv->alen)) &&
     !(TESTAFF(rv->astr, 'J', rv->alen))) {
    numsyllable--;
  }
  // END of LANG_hu section
  // increment word number, if the second root has a compoundroot flag
  if ((rv) && (compoundroot) &&
      (TESTAFF(rv->astr, compoundroot, rv->alen))) {
    wordnum++;
  }

  // check forbiddenwords
  if ((rv) && (rv->astr) &&
      (TESTAFF(rv->astr, forbiddenword, rv->alen) ||
       TESTAFF(rv->astr, ONLYUPCASEFLAG, rv->alen)))
    continue;

  // second word is acceptable, as a root?
  // hungarian conventions: compounding is acceptable,
  // when compound forms consist of 2 words, or if more,
  // then the syllable number of root words must be 6, or lesser.
  if ((rv) &&
      ((compoundflag && TESTAFF(rv->astr, compoundflag, rv->alen)) ||
       (compoundend && TESTAFF(rv->astr, compoundend, rv->alen))) &&
      (((cpdwordmax == -1) || (wordnum + 1 < cpdwordmax)) ||
       ((cpdmaxsyllable!= 0) &&
        (numsyllable + get_syllable(std::string(HENTRY_WORD(rv), rv->blen)) <=
         cpdmaxsyllable))) &&
      (!checkcompounddup || (rv!= rv_first)))) {
    // bad compound word
    result.append(presult);
    result.push_back(MSEP_FLD);
    result.append(MORPH_PART);
    result.append(word, i, word.size());

    if (HENTRY_DATA(rv)) {
      if (complexprefixes)
        result.append(HENTRY_DATA2(rv));
      if (!HENTRY_FIND(rv, MORPH_STEM)) {
        result.push_back(MSEP_FLD);
        result.append(MORPH_STEM);
        result.append(HENTRY_WORD(rv));
      }
      // store the pointer of the hash entry
      if (!complexprefixes) {
        result.push_back(MSEP_FLD);
        result.append(HENTRY_DATA2(rv));
      }
    }
    result.push_back(MSEP_REC);
    ok = 1;
  }

  numsyllable = oldnumsyllable2;
  wordnum = oldwordnum2;

  // perhaps second word has prefix or/and suffix
  sfx = NULL;
  sfxflag = FLAG_NULL;

  if (compoundflag &&!onlycpdrule)
    rv = affix_check(word, i, word.size() - i, compoundflag);
  else
    rv = NULL;

  if (!rv && compoundend &&!onlycpdrule) {
    sfx = NULL;
    pfx = NULL;
    rv = affix_check(word, i, word.size() - i, compoundend);
  }

  if (!rv &&!defcpdtable.empty() && words) {
    rv = affix_check(word, i, word.size() - i, 0, IN_CPD_END);
    if (rv && words && defcpd_check(&words, wnum + 1, rv, NULL, 1)) {
      std::string m;
      if (compoundflag)
        m = affix_check_morph(word, i, word.size() - i, compoundflag);
      if (m.empty() && compoundend) {
        m = affix_check_morph(word, i, word.size() - i, compoundend);
      }
      result.append(presult);
      if (!m.empty()) {
        result.push_back(MSEP_FLD);
        result.append(MORPH_PART);
        result.append(word, i, word.size());
        line_uniq_app(m, MSEP_REC);
        result.append(m);
      }
      result.push_back(MSEP_REC);
      ok = 1;
    }
  }

  // check non_compound flag in suffix and prefix
  if ((rv) &&
      ((pfx && pfx->getCont() &&
        TESTAFF(pfx->getCont(), compoundforbidflag, pfx->getContLen())) ||
       (sfx && sfx->getCont() &&
        TESTAFF(sfx->getCont(), compoundforbidflag, sfx->getContLen())))) {
    rv = NULL;
  }

  // check forbiddenwords
  if ((rv) && (rv->astr) &&
      (TESTAFF(rv->astr, forbiddenword, rv->alen) ||
       TESTAFF(rv->astr, ONLYUPCASEFLAG, rv->alen)) &&
      (!TESTAFF(rv->astr, needaffix, rv->alen))) {
    st[i] = ch;
    continue;
  }

  if (langnum == LANG_hu) {
    // calculate syllable number of the word
    numsyllable += get_syllable(word.c_str() + i);

    // - affix syllable num.
    // XXX only second suffix (inflections, not derivations)
    if (sfxappnd) {
      std::string tmp(sfxappnd);
      reverseword(tmp);
      numsyllable -= short(get_syllable(tmp) + sfxextra);
    } else {
      numsyllable -= short(sfxextra);
    }

    // + 1 word, if syllable number of the prefix > 1 (hungarian
    // convention)
    if (pfx && (get_syllable(pfx->getKey()) > 1))
      wordnum++;

    // increment syllable num, if last word has a SYLLABLENUM flag
    // and the suffix is beginning `s'

    if (!cpdsyllablenum.empty()) {
      switch (sfxflag) {
        case 'c': {
          numsyllable += 2;
          break;
        }
        case 'J': {
          numsyllable += 1;
          break;
        }
        case 'I': {
          if (rv && TESTAFF(rv->astr, 'J', rv->alen))
            numsyllable += 1;
          break;
        }
      }
    }
  }

  // increment word number, if the second word has a compoundroot flag
  if ((rv) && (compoundroot) &&
      (TESTAFF(rv->astr, compoundroot, rv->alen))) {
    wordnum++;
  }
  // second word is acceptable, as a word with prefix or/and suffix?
  // hungarian conventions: compounding is acceptable,
  // when compound forms consist 2 word, otherwise
  // the syllable number of root words is 6, or lesser.
  if ((rv) &&
      (((cpdwordmax == -1) || (wordnum + 1 < cpdwordmax)) ||
       ((cpdmaxsyllable!= 0) && (numsyllable <= cpdmaxsyllable))) &&
      (!checkcompounddup || (rv!= rv_first)))) {
    std::string m;
    if (compoundflag)
      m = affix_check_morph(word, i, word.size() - i, compoundflag);
    if (m.empty() && compoundend) {
      m = affix_check_morph(word, i, word.size() - i, compoundend);
    }
    result.append(presult);
    if (!m.empty()) {
      result.push_back(MSEP_FLD);
      result.append(MORPH_PART);
      result.append(word, i, word.size());
      line_uniq_app(m, MSEP_REC);
      result.append(m);
    }
    result.push_back(MSEP_REC);
    ok = 1;
  }

  numsyllable = oldnumsyllable2;
  wordnum = oldwordnum2;

  // perhaps second word is a compound word (recursive call)
  if ((wordnum + 2 < maxwordnum) && (ok == 0)) {
    compound_check_morph(word.substr(i), wordnum + 1,
                         numsyllable, maxwordnum, wnum + 1, words, rwords, 0,
                         result, &presult);
  } else {
    rv = NULL;
  }
}