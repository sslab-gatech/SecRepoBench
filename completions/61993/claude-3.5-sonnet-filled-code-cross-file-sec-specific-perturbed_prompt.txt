Below is the content of a C/C++ function where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
PHPAPI HashTable *php_fgetcsv(php_stream *csv_stream, char delimiter, char enclosure, int escape_char, size_t buf_len, char *buf) /* {{{ */
{
	char *temp, *bptr, *line_end, *limit;
	size_t temp_len, line_end_len;
	int inc_len;
	bool first_field = true;

	ZEND_ASSERT((escape_char >= 0 && escape_char <= UCHAR_MAX) || escape_char == PHP_CSV_NO_ESCAPE);

	/* initialize internal state */
	php_mb_reset();

	/* Now into new section that parses buf for delimiter/enclosure fields */

	/* Strip trailing space from buf, saving end of line in case required for enclosure field */

	bptr = buf;
	line_end = limit = (char *)php_fgetcsv_lookup_trailing_spaces(buf, buf_len);
	line_end_len = buf_len - (size_t)(limit - buf);

	/* reserve workspace for building each individual field */
	temp_len = buf_len;
	temp = emalloc(temp_len + line_end_len + 1);

	/* Initialize values HashTable */
	HashTable *values = zend_new_array(0);

	/* Main loop to read CSV fields */
	/* NB this routine will return NULL for a blank line */
	do {
		char *comp_end, *hunk_begin;
		char *tptr = temp;

		inc_len = (bptr < limit ? (*bptr == '\0' ? 1 : php_mblen(bptr, limit - bptr)): 0);
		if (inc_len == 1) {
			char *tmp = bptr;
			while ((*tmp != delimiter) && isspace((int)*(unsigned char *)tmp)) {
				tmp++;
			}
			if (*tmp == enclosure && tmp < limit) {
				bptr = tmp;
			}
		}

		if (first_field && bptr == line_end) {
			zend_array_destroy(values);
			values = NULL;
			break;
		}
		first_field = false;
		/* 2. Read field, leaving bptr pointing at start of next field */
		if (inc_len != 0 && *bptr == enclosure) {
			int state = 0;

			bptr++;	/* move on to first character in field */
			hunk_begin = bptr;

			/* 2A. handle enclosure delimited field */
			for (;;) {
				switch (inc_len) {
					case 0:
						switch (state) {
							case 2:
								memcpy(tptr, hunk_begin, bptr - hunk_begin - 1);
								tptr += (bptr - hunk_begin - 1);
								hunk_begin = bptr;
								goto quit_loop_2;

							case 1:
								memcpy(tptr, hunk_begin, bptr - hunk_begin);
								tptr += (bptr - hunk_begin);
								hunk_begin = bptr;
								ZEND_FALLTHROUGH;

							case 0: {
								if (hunk_begin != line_end) {
									memcpy(tptr, hunk_begin, bptr - hunk_begin);
									tptr += (bptr - hunk_begin);
									hunk_begin = bptr;
								}

								/* add the embedded line end to the field */
								memcpy(tptr, line_end, line_end_len);
								tptr += line_end_len;

								/* nothing can be fetched if stream is NULL (e.g. str_getcsv()) */
								// Check if the stream is NULL. If so, handle the case of an unterminated enclosure,
								// potentially adjusting the position pointer to exclude the null character if needed,
								// and then exit the loop. Otherwise, read the next line from the stream.
								// If reading fails, handle the unterminated enclosure similarly and exit the loop.
								// If reading succeeds, update the buffer and related state variables for the new line.
								// <MASK>

								temp_len += new_len;
								char *new_temp = erealloc(temp, temp_len);
								tptr = new_temp + (size_t)(tptr - temp);
								temp = new_temp;

								efree(buf);
								buf_len = new_len;
								bptr = buf = new_buf;
								hunk_begin = buf;

								line_end = limit = (char *)php_fgetcsv_lookup_trailing_spaces(buf, buf_len);
								line_end_len = buf_len - (size_t)(limit - buf);

								state = 0;
							} break;
						}
						break;

					case -2:
					case -1:
						php_mb_reset();
						ZEND_FALLTHROUGH;
					case 1:
						/* we need to determine if the enclosure is
						 * 'real' or is it escaped */
						switch (state) {
							case 1: /* escaped */
								bptr++;
								state = 0;
								break;
							case 2: /* embedded enclosure ? let's check it */
								if (*bptr != enclosure) {
									/* real enclosure */
									memcpy(tptr, hunk_begin, bptr - hunk_begin - 1);
									tptr += (bptr - hunk_begin - 1);
									hunk_begin = bptr;
									goto quit_loop_2;
								}
								memcpy(tptr, hunk_begin, bptr - hunk_begin);
								tptr += (bptr - hunk_begin);
								bptr++;
								hunk_begin = bptr;
								state = 0;
								break;
							default:
								if (*bptr == enclosure) {
									state = 2;
								} else if (escape_char != PHP_CSV_NO_ESCAPE && *bptr == escape_char) {
									state = 1;
								}
								bptr++;
								break;
						}
						break;

					default:
						switch (state) {
							case 2:
								/* real enclosure */
								memcpy(tptr, hunk_begin, bptr - hunk_begin - 1);
								tptr += (bptr - hunk_begin - 1);
								hunk_begin = bptr;
								goto quit_loop_2;
							case 1:
								bptr += inc_len;
								memcpy(tptr, hunk_begin, bptr - hunk_begin);
								tptr += (bptr - hunk_begin);
								hunk_begin = bptr;
								state = 0;
								break;
							default:
								bptr += inc_len;
								break;
						}
						break;
				}
				inc_len = (bptr < limit ? (*bptr == '\0' ? 1 : php_mblen(bptr, limit - bptr)): 0);
			}

		quit_loop_2:
			/* look up for a delimiter */
			for (;;) {
				switch (inc_len) {
					case 0:
						goto quit_loop_3;

					case -2:
					case -1:
						inc_len = 1;
						php_mb_reset();
						ZEND_FALLTHROUGH;
					case 1:
						if (*bptr == delimiter) {
							goto quit_loop_3;
						}
						break;
					default:
						break;
				}
				bptr += inc_len;
				inc_len = (bptr < limit ? (*bptr == '\0' ? 1 : php_mblen(bptr, limit - bptr)): 0);
			}

		quit_loop_3:
			memcpy(tptr, hunk_begin, bptr - hunk_begin);
			tptr += (bptr - hunk_begin);
			bptr += inc_len;
			comp_end = tptr;
		} else {
			/* 2B. Handle non-enclosure field */

			hunk_begin = bptr;

			for (;;) {
				switch (inc_len) {
					case 0:
						goto quit_loop_4;
					case -2:
					case -1:
						inc_len = 1;
						php_mb_reset();
						ZEND_FALLTHROUGH;
					case 1:
						if (*bptr == delimiter) {
							goto quit_loop_4;
						}
						break;
					default:
						break;
				}
				bptr += inc_len;
				inc_len = (bptr < limit ? (*bptr == '\0' ? 1 : php_mblen(bptr, limit - bptr)): 0);
			}
		quit_loop_4:
			memcpy(tptr, hunk_begin, bptr - hunk_begin);
			tptr += (bptr - hunk_begin);

			comp_end = (char *)php_fgetcsv_lookup_trailing_spaces(temp, tptr - temp);
			if (*bptr == delimiter) {
				bptr++;
			}
		}

		/* 3. Now pass our field back to php */
		*comp_end = '\0';

		zval z_tmp;
		ZVAL_STRINGL(&z_tmp, temp, comp_end - temp);
		zend_hash_next_index_insert(values, &z_tmp);
	} while (inc_len > 0);

	efree(temp);
	if (csv_stream) {
		efree(buf);
	}

	return values;
}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// ext/standard/file.c
PHP_FUNCTION(fputcsv)
{
	char delimiter = ',';					/* allow this to be set as parameter */
	char enclosure = '"';					/* allow this to be set as parameter */
	int escape_char = (unsigned char) '\\';	/* allow this to be set as parameter */
	php_stream *stream;
	zval *fp = NULL, *fields = NULL;
	ssize_t ret;
	char *delimiter_str = NULL, *enclosure_str = NULL, *escape_str = NULL;
	size_t delimiter_str_len = 0, enclosure_str_len = 0, escape_str_len = 0;
	zend_string *eol_str = NULL;

	ZEND_PARSE_PARAMETERS_START(2, 6)
		Z_PARAM_RESOURCE(fp)
		Z_PARAM_ARRAY(fields)
		Z_PARAM_OPTIONAL
		Z_PARAM_STRING(delimiter_str, delimiter_str_len)
		Z_PARAM_STRING(enclosure_str, enclosure_str_len)
		Z_PARAM_STRING(escape_str, escape_str_len)
		Z_PARAM_STR_OR_NULL(eol_str)
	ZEND_PARSE_PARAMETERS_END();

	if (delimiter_str != NULL) {
		/* Make sure that there is at least one character in string */
		if (delimiter_str_len != 1) {
			zend_argument_value_error(3, "must be a single character");
			RETURN_THROWS();
		}

		/* use first character from string */
		delimiter = *delimiter_str;
	}

// the below code fragment can be found in:
// ext/standard/string.c
PHP_FUNCTION(basename)
{
	char *string, *suffix = NULL;
	size_t   string_len, suffix_len = 0;

	ZEND_PARSE_PARAMETERS_START(1, 2)
		Z_PARAM_STRING(string, string_len)
		Z_PARAM_OPTIONAL
		Z_PARAM_STRING(suffix, suffix_len)
	ZEND_PARSE_PARAMETERS_END();

	RETURN_STR(php_basename(string, string_len, suffix, suffix_len));
}

// the below code fragment can be found in:
// ext/standard/file.c
PHP_FUNCTION(fgetcsv)
{
	char delimiter = ',';	/* allow this to be set as parameter */
	char enclosure = '"';	/* allow this to be set as parameter */
	int escape = (unsigned char) '\\';

	zend_long len = 0;
	size_t buf_len;
	char *buf;
	php_stream *stream;

	{
		zval *fd;
		bool len_is_null = 1;
		char *delimiter_str = NULL;
		size_t delimiter_str_len = 0;
		char *enclosure_str = NULL;
		size_t enclosure_str_len = 0;
		char *escape_str = NULL;
		size_t escape_str_len = 0;

		ZEND_PARSE_PARAMETERS_START(1, 5)
			Z_PARAM_RESOURCE(fd)
			Z_PARAM_OPTIONAL
			Z_PARAM_LONG_OR_NULL(len, len_is_null)
			Z_PARAM_STRING(delimiter_str, delimiter_str_len)
			Z_PARAM_STRING(enclosure_str, enclosure_str_len)
			Z_PARAM_STRING(escape_str, escape_str_len)
		ZEND_PARSE_PARAMETERS_END();

		if (delimiter_str != NULL) {
			/* Make sure that there is at least one character in string */
			if (delimiter_str_len != 1) {
				zend_argument_value_error(3, "must be a single character");
				RETURN_THROWS();
			}

			/* use first character from string */
			delimiter = delimiter_str[0];
		}

		if (enclosure_str != NULL) {
			if (enclosure_str_len != 1) {
				zend_argument_value_error(4, "must be a single character");
				RETURN_THROWS();
			}

			/* use first character from string */
			enclosure = enclosure_str[0];
		}

		if (escape_str != NULL) {
			if (escape_str_len > 1) {
				zend_argument_value_error(5, "must be empty or a single character");
				RETURN_THROWS();
			}

			if (escape_str_len < 1) {
				escape = PHP_CSV_NO_ESCAPE;
			} else {
				escape = (unsigned char) escape_str[0];
			}
		}

		if (len_is_null || len == 0) {
			len = -1;
		} else if (len < 0) {
			zend_argument_value_error(2, "must be a greater than or equal to 0");
			RETURN_THROWS();
		}

		PHP_STREAM_FROM_ZVAL(stream, fd);
	}

	if (len < 0) {
		if ((buf = php_stream_get_line(stream, NULL, 0, &buf_len)) == NULL) {
			RETURN_FALSE;
		}
	} else {
		buf = emalloc(len + 1);
		if (php_stream_get_line(stream, buf, len + 1, &buf_len) == NULL) {
			efree(buf);
			RETURN_FALSE;
		}
	}

	HashTable *values = php_fgetcsv(stream, delimiter, enclosure, escape, buf_len, buf);
	if (values == NULL) {
		values = php_bc_fgetcsv_empty_line();
	}
	RETURN_ARR(values);
}

// the below code fragment can be found in:
// ext/standard/file.c
PHPAPI HashTable *php_bc_fgetcsv_empty_line(void)
{
	HashTable *values = zend_new_array(1);
	zval tmp;
	ZVAL_NULL(&tmp);
	zend_hash_next_index_insert(values, &tmp);
	return values;
}

// the below code fragment can be found in:
// ext/standard/string.c
PHP_FUNCTION(str_getcsv)
{
	zend_string *str;
	char delim = ',', enc = '"';
	int esc = (unsigned char) '\\';
	char *delim_str = NULL, *enc_str = NULL, *esc_str = NULL;
	size_t delim_len = 0, enc_len = 0, esc_len = 0;

	ZEND_PARSE_PARAMETERS_START(1, 4)
		Z_PARAM_STR(str)
		Z_PARAM_OPTIONAL
		Z_PARAM_STRING(delim_str, delim_len)
		Z_PARAM_STRING(enc_str, enc_len)
		Z_PARAM_STRING(esc_str, esc_len)
	ZEND_PARSE_PARAMETERS_END();

	delim = delim_len ? delim_str[0] : delim;
	enc = enc_len ? enc_str[0] : enc;
	if (esc_str != NULL) {
		esc = esc_len ? (unsigned char) esc_str[0] : PHP_CSV_NO_ESCAPE;
	}

	HashTable *values = php_fgetcsv(NULL, delim, enc, esc, ZSTR_LEN(str), ZSTR_VAL(str));
	if (values == NULL) {
		values = php_bc_fgetcsv_empty_line();
	}
	RETURN_ARR(values);
}
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).