// Check if the stream is NULL. If so, handle the case of an unterminated enclosure,
// potentially adjusting the position pointer to exclude the null character if needed,
// and then exit the loop. Otherwise, read the next line from the stream.
// If reading fails, handle the unterminated enclosure similarly and exit the loop.
// If reading succeeds, update the buffer and related state variables for the new line.
if (csv_stream == NULL) {
    // Handle unterminated enclosure for str_getcsv()
    if (hunk_begin != line_end) {
        memcpy(tptr, hunk_begin, bptr - hunk_begin);
        tptr += (bptr - hunk_begin);
    }
    break;
}

size_t new_len = php_stream_get_line(csv_stream, &buf, buf_len, NULL);
if (new_len == 0) {
    // Handle unterminated enclosure
    if (hunk_begin != line_end) {
        memcpy(tptr, hunk_begin, bptr - hunk_begin);
        tptr += (bptr - hunk_begin);
    }
    break;
}

temp_len += new_len;
char *new_temp = erealloc(temp, temp_len);
tptr = new_temp + (size_t)(tptr - temp);
temp = new_temp;

efree(buf);
buf_len = new_len;
bptr = buf = new_buf;
hunk_begin = buf;

line_end = limit = (char *)php_fgetcsv_lookup_trailing_spaces(buf, buf_len);
line_end_len = buf_len - (size_t)(limit - buf);