/* 1. Check if the stream is NULL. If so, handle the case of an unterminated enclosure,
   potentially adjusting the position pointer to exclude the null character if needed,
   and then exit the loop. Otherwise, read the next line from the stream.
   If reading fails, handle the unterminated enclosure similarly and exit the loop.
   If reading succeeds, update the buffer and related state variables for the new line. */
if (csv_stream == NULL) {
    /* handle the unterminated enclosure */
    temp_len += new_len;
    char *new_temp = erealloc(temp, temp_len);
    tptr = new_temp + (size_t)(tptr - temp);
    temp = new_temp;

    efree(buf);
    buf_len = new_len;
    bptr = buf = new_buf;

    line_end = limit = (char *)php_fgetcsv_lookup_trailing_spaces(buf, buf_len);
    line_end_len = buf_len - (size_t)(limit - buf);

    state = 0;
} else {
    /* read the next line from the stream */
    if (php_stream_get_line(csv_stream, buf, buf_len, &new_len) == NULL) {
        /* handle the unterminated enclosure */
        temp_len += new_len;
        char *new_temp = erealloc(temp, temp_len);
        tptr = new_temp + (size_t)(tptr - temp);
        temp = new_temp;

        efree(buf);
        buf_len = new_len;
        bptr = buf = new_buf;

        line_end = limit = (char *)php_fgetcsv_lookup_trailing_spaces(buf, buf_len);
        line_end_len = buf_len - (size_t)(limit - buf);

        state = 0;
    } else {
        /* update the buffer and related state variables for the new line */
        efree(buf);
        buf_len = new_len;
        bptr = buf = new_buf;

        line_end = limit = (char *)php_fgetcsv_lookup_trailing_spaces(buf, buf_len);
        line_end_len = buf_len - (size_t)(limit - buf);
    }
}