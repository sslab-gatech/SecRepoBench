if (stream == NULL) {
    // Handle the case of an unterminated enclosure
    if (hunk_begin != line_end) {
        memcpy(tptr, hunk_begin, bptr - hunk_begin);
        tptr += (bptr - hunk_begin);
    }
    *tptr = '\0';
    zval z_tmp;
    ZVAL_STRINGL(&z_tmp, temp, tptr - temp);
    zend_hash_next_index_insert(values, &z_tmp);
    return values;
} else {
    // Read the next line from the stream
    size_t new_len = php_stream_get_line(stream, NULL, 0, &buf_len);
    if (new_len == 0) {
        // Handle the case of an unterminated enclosure
        if (hunk_begin != line_end) {
            memcpy(tptr, hunk_begin, bptr - hunk_begin);
            tptr += (bptr - hunk_begin);
        }
        *tptr = '\0';
        zval z_tmp;
        ZVAL_STRINGL(&z_tmp, temp, tptr - temp);
        zend_hash_next_index_insert(values, &z_tmp);
        return values;
    } else {
        char *new_buf = emalloc(new_len + 1);
        if (php_stream_get_line(stream, new_buf, new_len + 1, &buf_len) == NULL) {
            efree(new_buf);
            // Handle the case of an unterminated enclosure
            if (hunk_begin != line_end) {
                memcpy(tptr, hunk_begin, bptr - hunk_begin);
                tptr += (bptr - hunk_begin);
            }
            *tptr = '\0';
            zval z_tmp;
            ZVAL_STRINGL(&z_tmp, temp, tptr - temp);
            zend_hash_next_index_insert(values, &z_tmp);
            return values;
        } else {
            temp_len += new_len;
            char *new_temp = erealloc(temp, temp_len);
            tptr = new_temp + (size_t)(tptr - temp);
            temp = new_temp;

            efree(buf);
            buf_len = new_len;
            bptr = buf = new_buf;
            hunk_begin = buf;

            line_end = limit = (char *)php_fgetcsv_lookup_trailing_spaces(buf, buf_len);
            line_end_len = buf_len - (size_t)(limit - buf);

            state = 0;
        }
    }
}