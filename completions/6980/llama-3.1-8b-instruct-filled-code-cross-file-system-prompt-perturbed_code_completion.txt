if (*p == '[')
  {
    // Parse a subexpression enclosed in brackets and copy it into a buffer.
    // Evaluate the subexpression to obtain a numeric result, which is then
    // cast to a ssize_t. Increment the pointer 'p' to continue parsing the 
    // main expression after the brackets.
    ssize_t
      subexpression_index;

    char
      *q,
      subexpression[MagickPathExtent];

    const char
      *value;

    Image
      *image;

    MagickBooleanType
      status;

    PixelInfo
      pixel;

    double
      alpha,
      beta;

    PointInfo
      point;

    register ssize_t
      imageindex;

    size_t
      depth,
      length,
      level;

    subexpression_index=0;
    q=subexpression;
    for (p++; *p!= '\0'; )
    {
      if (*p == '[')
        level++;
      else
        if (*p == ']')
          {
            level--;
            if (level == 0)
              break;
          }
      *q++=(*p++);
    }
    *q='\0';
    subexpression_index=GetImageIndexInList(fx_info->images);
    depth=0;
    level=0;
    point.x=(double) x;
    point.y=(double) y;
    status=FxEvaluateExpression(fx_info,&alpha,exception);
    if (status == MagickFalse)
      return(0.0);
    point.x+=alpha;
    point.y+=beta;
    image=GetImageFromList(fx_info->images,subexpression_index);
    if (image == (Image *) NULL)
      {
        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
          "NoSuchImage","`%s'",expression);
        return(0.0);
      }
    GetPixelInfo(image,&pixel);
    status=InterpolatePixelInfo(image,fx_info->view[subexpression_index],
      image->interpolate,point.x,point.y,&pixel,exception);
    (void) status;
    p++;
  }