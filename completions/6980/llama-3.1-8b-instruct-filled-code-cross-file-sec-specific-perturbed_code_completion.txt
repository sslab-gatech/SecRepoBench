if (*p == '[')
  {
    // Parse a subexpression enclosed in brackets and copy it into a buffer.
    // Evaluate the subexpression to obtain a numeric result, which is then
    // cast to a ssize_t. Increment the pointer 'p' to continue parsing the 
    // main expression after the brackets.
    ssize_t
      length,
      subexpression_length;

    char
      *q,
      subexpression[MagickPathExtent];

    const char
      *subexpression_p;

    subexpression_length=0;
    subexpression[subexpression_length++]='[';
    subexpression_p=p;
    while (*subexpression_p!= ']')
    {
      if (subexpression_length >= MagickPathExtent)
        ThrowWriterException(ResourceLimitError,"StringTooLong");
      subexpression[subexpression_length++]=*subexpression_p;
      subexpression_p++;
    }
    subexpression[subexpression_length++]=']';
    subexpression[subexpression_length]='\0';
    length=FxEvaluateSubexpression(fx_info,channel,x,y,subexpression,
      &depth,&beta,exception);
    if (length < 0)
      ThrowWriterException(ResourceLimitError,"InvalidSubexpression");
    p++;
  }