switch (v->type) {
    case FLB_RA_BOOL:
        tmp = flb_sds_cat(buf, v->val.boolean ? "true" : "false", 
                          v->val.boolean ? 4 : 5);
        break;
    case FLB_RA_INT:
        snprintf(str, sizeof(str), "%lld", v->val.i64);
        str_size = strlen(str);
        tmp = flb_sds_cat(buf, str, str_size);
        break;
    case FLB_RA_FLOAT:
        if (v->val.f64 == (long long)v->val.f64) {
            snprintf(str, sizeof(str), "%.0f", v->val.f64);
        } else {
            snprintf(str, sizeof(str), "%lf", v->val.f64);
        }
        str_size = strlen(str);
        tmp = flb_sds_cat(buf, str, str_size);
        break;
    case FLB_RA_STR:
        js = flb_utils_json_escape(v->val.str.val, v->val.str.len);
        if (js) {
            tmp = flb_sds_cat(buf, js, strlen(js));
            flb_free(js);
        }
        break;
    case FLB_RA_NULL:
        tmp = flb_sds_cat(buf, "null", 4);
        break;
    default:
        // Handle unrecognized types or log an error
        flb_error("[record accessor] Unrecognized type in keymap translation");
        break;
}