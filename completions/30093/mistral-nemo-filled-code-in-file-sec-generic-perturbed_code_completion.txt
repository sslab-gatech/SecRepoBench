static flb_sds_t ra_translate_keymap(struct flb_ra_parser *rp, flb_sds_t buf,
                                     msgpack_object map, int *found)
{
    int str_size;
    char *js;
    char str[32];
    flb_sds_t tmp = NULL;
    struct flb_ra_value *v;

    /* Lookup key or subkey value */
    v = flb_ra_key_to_value(rp->key->name, map, rp->key->subkeys);
    if (!v) {
        *found = FLB_FALSE;
        return buf;
    }
    else {
        *found = FLB_TRUE;
    }

    /* Convert the value to its string representation based on its data type */
    switch (v->type) {
        case MSGPACK_OBJECT_BOOLEAN:
            tmp = flb_sds_create_sprintf("%s", v->value.boolean ? "true" : "false");
            break;
        case MSGPACK_OBJECT_POSITIVE_INTEGER:
        case MSGPACK_OBJECT_NEGATIVE_INTEGER:
            tmp = flb_sds_create_sprintf("%lld", v->value.integer);
            break;
        case MSGPACK_OBJECT_FLOAT:
            tmp = flb_sds_create_sprintf("%f", v->value.float64);
            break;
        case MSGPACK_OBJECT_STR:
            tmp = flb_sds_create(v->value.str.ptr, v->value.str.size);
            break;
        case MSGPACK_OBJECT_NIL:
            tmp = flb_sds_create_sprintf("null");
            break;
        default:
            tmp = buf;
            break;
    }

    flb_ra_key_value_destroy(v);
    return tmp;
}