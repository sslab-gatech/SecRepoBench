switch (v->type) {
    case FLB_RA_BOOL:
        if (v->val.boolean) {
            tmp = flb_sds_cat(buf, "true", 4);
        }
        else {
            tmp = flb_sds_cat(buf, "false", 5);
        }
        break;
    case FLB_RA_INT:
        str_size = snprintf(str, sizeof(str) - 1, "%" PRId64, v->val.i64);
        tmp = flb_sds_cat(buf, str, str_size);
        break;
    case FLB_RA_FLOAT:
        str_size = snprintf(str, sizeof(str) - 1, "%f", v->val.f64);
        tmp = flb_sds_cat(buf, str, str_size);
        break;
    case FLB_RA_STRING:
        tmp = flb_sds_cat(buf, v->val.string, v->val.slen);
        break;
    case FLB_RA_NULL:
        tmp = flb_sds_cat(buf, "null", 4);
        break;
    case FLB_RA_JSON:
        js = flb_pack_msgpack_to_json_string(v->val.json_ptr, v->val.json_size);
        if (!js) {
            flb_error("[ra] cannot convert JSON to string");
            return NULL;
        }
        tmp = flb_sds_cat(buf, js, strlen(js));
        flb_free(js);
        break;
    default:
        flb_warn("[ra] cannot translate key, unknown type=%i", v->type);
        *found = FLB_FALSE;
        return buf;
    }