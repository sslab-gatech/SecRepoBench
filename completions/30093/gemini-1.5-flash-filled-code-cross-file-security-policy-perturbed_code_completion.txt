switch (v->type) {
    case FLB_RA_VALUE_BOOLEAN:
        str_size = snprintf(str, sizeof(str), "%s", v->value.bl ? "true" : "false");
        if (str_size < 0 || str_size >= sizeof(str)) {
            flb_error("[record accessor] snprintf failed");
            flb_ra_key_value_destroy(v);
            return buf;
        }
        tmp = flb_sds_cat(buf, str);
        break;
    case FLB_RA_VALUE_INTEGER:
        str_size = snprintf(str, sizeof(str), "%" PRId64, v->value.i);
        if (str_size < 0 || str_size >= sizeof(str)) {
            flb_error("[record accessor] snprintf failed");
            flb_ra_key_value_destroy(v);
            return buf;
        }
        tmp = flb_sds_cat(buf, str);
        break;
    case FLB_RA_VALUE_DOUBLE:
        str_size = snprintf(str, sizeof(str), "%g", v->value.dbl);
        if (str_size < 0 || str_size >= sizeof(str)) {
            flb_error("[record accessor] snprintf failed");
            flb_ra_key_value_destroy(v);
            return buf;
        }
        tmp = flb_sds_cat(buf, str);
        break;
    case FLB_RA_VALUE_STRING:
        tmp = flb_sds_catsds(buf, v->value.s);
        break;
    case FLB_RA_VALUE_NULL:
        tmp = flb_sds_cat(buf, "null");
        break;
    default:
        flb_error("[record accessor] unsupported keymap value type");
        flb_ra_key_value_destroy(v);
        return buf;
    }
    if (!tmp) {
        flb_error("[record accessor] cannot append value to buffer");
        flb_ra_key_value_destroy(v);
        return buf;
    }