switch (v->type) {
    case FLB_RA_VALUE_BOOL:
        if (v->data.boolean == FLB_TRUE) {
            tmp = flb_sds_cat(buf, "true", 4);
        }
        else {
            tmp = flb_sds_cat(buf, "false", 5);
        }
        break;

    case FLB_RA_VALUE_INTEGER:
        str_size = snprintf(str, sizeof(str) - 1, "%" PRId64, v->data.integer);
        if (str_size > 0 && str_size < sizeof(str)) {
            tmp = flb_sds_cat(buf, str, str_size);
        }
        else {
            flb_error("[record accessor] integer to string conversion error");
            tmp = NULL;
        }
        break;

    case FLB_RA_VALUE_DOUBLE:
        str_size = snprintf(str, sizeof(str) - 1, "%f", v->data.floating_point);
        if (str_size > 0 && str_size < sizeof(str)) {
            tmp = flb_sds_cat(buf, str, str_size);
        }
        else {
            flb_error("[record accessor] float to string conversion error");
            tmp = NULL;
        }
        break;

    case FLB_RA_VALUE_STRING:
        js = (char *) msgpack_object_str_ptr(v->data.string);
        tmp = flb_sds_cat(buf, js, msgpack_object_str_len(v->data.string));
        break;

    case FLB_RA_VALUE_NULL:
        tmp = flb_sds_cat(buf, "null", 4);
        break;

    default:
        flb_error("[record accessor] invalid data type %d", v->type);
        tmp = NULL;
    }

    if (!tmp) {
        flb_ra_key_value_destroy(v);
        flb_sds_destroy(buf);
        return NULL;
    }