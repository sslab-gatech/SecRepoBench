static flb_sds_t ra_translate_keymap(struct flb_ra_parser *rp, flb_sds_t buf,
                                     msgpack_object map, int *found)
{
    int str_size;
    char *js;
    char str[32];
    flb_sds_t tmp = NULL;
    struct flb_ra_value *v;

    /* Lookup key or subkey value */
    v = flb_ra_key_to_value(rp->key->name, map, rp->key->subkeys);
    if (!v) {
        *found = FLB_FALSE;
        return buf;
    }
    else {
        *found = FLB_TRUE;
    }

    // Convert the value extracted from the keymap to its string representation
    // based on its data type. Handle boolean, integer, floating-point, string, and 
    // null values accordingly, appending each to the buffer.
    switch (v->type) {
        case FLB_RA_VALUE_BOOL:
            if (v->bool_val) {
                tmp = flb_sds_cat(buf, "true", 4);
            }
            else {
                tmp = flb_sds_cat(buf, "false", 5);
            }
            break;
        case FLB_RA_VALUE_INT:
            tmp = flb_sds_cat(buf, v->int_val, strlen(v->int_val));
            break;
        case FLB_RA_VALUE_FLOAT:
            tmp = flb_sds_cat(buf, v->float_val, strlen(v->float_val));
            break;
        case FLB_RA_VALUE_STRING:
            tmp = flb_sds_cat(buf, v->str_val, strlen(v->str_val));
            break;
        case FLB_RA_VALUE_NULL:
            tmp = flb_sds_cat(buf, "null", 4);
            break;
        default:
            flb_error("[record accessor] unsupported value type");
            flb_ra_value_destroy(v);
            return NULL;
    }

    flb_ra_key_value_destroy(v);
    return tmp;
}