static flb_sds_t ra_translate_keymap(struct flb_ra_parser *rp, flb_sds_t buf,
                                     msgpack_object map, int *found)
{
    int str_size;
    char *js;
    char str[32];
    flb_sds_t tmp = NULL;
    struct flb_ra_value *v;

    /* Lookup key or subkey value */
    v = flb_ra_key_to_value(rp->key->name, map, rp->key->subkeys);
    if (!v) {
        *found = FLB_FALSE;
        return buf;
    }
    else {
        *found = FLB_TRUE;
    }

    /* Convert the value to its string representation based on its data type */
    switch (v->type) {
        case MSGPACK_OBJECT_BOOLEAN:
            snprintf(str, sizeof(str), "%s", v->value.boolean ? "true" : "false");
            tmp = flb_sds_cat(buf, str, strlen(str));
            break;
        case MSGPACK_OBJECT_POSITIVE_INTEGER:
        case MSGPACK_OBJECT_NEGATIVE_INTEGER:
            snprintf(str, sizeof(str), "%lld", v->value.integer);
            tmp = flb_sds_cat(buf, str, strlen(str));
            break;
        case MSGPACK_OBJECT_FLOAT:
            snprintf(str, sizeof(str), "%.17g", v->value.float64);
            tmp = flb_sds_cat(buf, str, strlen(str));
            break;
        case MSGPACK_OBJECT_STR:
            tmp = flb_sds_cat(buf, v->value.str.ptr, v->value.str.size);
            break;
        case MSGPACK_OBJECT_ARRAY:
        case MSGPACK_OBJECT_MAP:
            /* Serialize the value as JSON */
            js = flb_pack_json(v->value.map, &str_size);
            if (js) {
                tmp = flb_sds_cat(buf, js, str_size);
                flb_free(js);
            }
            break;
        case MSGPACK_OBJECT_NIL:
            tmp = flb_sds_cat(buf, "null", 4);
            break;
    }

    flb_ra_key_value_destroy(v);
    return tmp;
}