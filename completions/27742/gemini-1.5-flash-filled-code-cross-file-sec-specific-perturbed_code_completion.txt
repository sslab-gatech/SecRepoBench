parsed_object = result.data;
        if (parsed_object.type != MSGPACK_OBJECT_ARRAY ||
            parsed_object.via.array.size != 2) {
            continue;
        }

        obj = parsed_object.via.array.ptr;
        tms = flb_pack_unpack_time(obj[0]);
        map = obj[1];
        map_size = map.via.map.size;
        if (date_key != NULL) {
            map_size++;
        }

        msgpack_pack_map(&tmp_pck, map_size);
        /* Pack timestamp */
        switch (date_format) {
        case FLB_PACK_JSON_DATE_DOUBLE:
            msgpack_pack_str(&tmp_pck, 4);
            msgpack_pack_str_body(&tmp_pck, "ts", 2);
            msgpack_pack_double(&tmp_pck, flb_time_to_double(&tms));
            break;
        case FLB_PACK_JSON_DATE_ISO8601:
        /* Format the time, use microsecond precision not nanoseconds */
            gmtime_r(&tms.tm.tv_sec, &tm);
            s = strftime(time_formatted, sizeof(time_formatted) - 1,
                         FLB_PACK_JSON_DATE_ISO8601_FMT, &tm);

            len = snprintf(time_formatted + s,
                           sizeof(time_formatted) - 1 - s,
                           ".%06" PRIu64 "Z",
                           (uint64_t) tms.tm.tv_nsec / 1000);
            s += len;
            msgpack_pack_str(&tmp_pck, 4);
            msgpack_pack_str_body(&tmp_pck, "ts", 2);
            msgpack_pack_str(&tmp_pck, s);
            msgpack_pack_str_body(&tmp_pck, time_formatted, s);
            break;
        case FLB_PACK_JSON_DATE_EPOCH:
            msgpack_pack_str(&tmp_pck, 4);
            msgpack_pack_str_body(&tmp_pck, "ts", 2);
            msgpack_pack_uint64(&tmp_pck, (long long unsigned)(tms.tm.tv_sec));
            break;
        }