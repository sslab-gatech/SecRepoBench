// Extract the root object from the unpacked result and ensure it is an array
// with exactly two elements: a timestamp and a record. If these conditions
// are not met, skip the current iteration. Unpack the timestamp using a helper
// function and assign the second element of the array to a map object. Determine
// the size of the map. If a date key is provided, increment the map size by one
// to accommodate the additional date field when packing into the temporary
// message pack buffer; otherwise, use the original map size for packing.
if (map.type!= MSGPACK_OBJECT_ARRAY) {
    continue;
}

obj = msgpack_object_array_get_element(&map, 0);
if (obj->type!= MSGPACK_OBJECT_FIXBIN || obj->via.fixbin.size!= sizeof(struct flb_time)) {
    continue;
}

tms = *(struct flb_time *) obj->via.fixbin.ptr;

obj = msgpack_object_array_get_element(&map, 1);
if (obj->type!= MSGPACK_OBJECT_MAP) {
    continue;
}

map = *obj;

if (date_key!= NULL) {
    map_size++;
}

// Determine the size of the map
map_size = msgpack_object_array_size(&map);

// Pack the timestamp into the temporary message pack buffer
msgpack_pack_fixbin(&tmp_pck, sizeof(struct flb_time), (uint8_t *) &tms);

// Pack the map object into the temporary message pack buffer
msgpack_pack_map(&tmp_pck, map_size);