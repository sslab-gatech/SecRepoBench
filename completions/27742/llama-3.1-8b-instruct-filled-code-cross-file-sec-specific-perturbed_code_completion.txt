// <MASK>
if (json_format == FLB_PACK_JSON_FORMAT_JSON) {
    // Extract the root object from the unpacked result and ensure it is an array
    // with exactly two elements: a timestamp and a record. If these conditions
    // are not met, skip the current iteration. Unpack the timestamp using a helper
    // function and assign the second element of the array to a map object. Determine
    // the size of the map. If a date key is provided, increment the map size by one
    // to accommodate the additional date field when packing into the temporary
    // message pack buffer; otherwise, use the original map size for packing.
    msgpack_unpack_next(&result, data, bytes, &off);
    obj = result.data;
    if (obj.type!= MSGPACK_OBJECT_ARRAY) {
        continue;
    }

    if (obj.via.array.size!= 2) {
        continue;
    }

    msgpack_unpack_next(&result, data, bytes, &off);
    obj = result.data;
    if (obj.type!= MSGPACK_OBJECT_ARRAY) {
        continue;
    }

    map_size = obj.via.array.size;

    if (date_key!= NULL) {
        map_size++;
    }

    msgpack_unpack_next(&result, data, bytes, &off);
    obj = result.data;
    if (obj.type!= MSGPACK_OBJECT_ARRAY) {
        continue;
    }

    if (obj.via.array.size!= map_size) {
        continue;
    }

    // Unpack the timestamp
    msgpack_unpack_next(&result, data, bytes, &off);
    obj = result.data;
    if (obj.type!= MSGPACK_OBJECT_FIXINT) {
        continue;
    }

    tms.tm.tv_sec = obj.via.fixint;

    // Unpack the record
    msgpack_unpack_next(&result, data, bytes, &off);
    obj = result.data;
    if (obj.type!= MSGPACK_OBJECT_MAP) {
        continue;
    }

    // Determine the size of the map
    map_size = obj.via.map.size;

    // If a date key is provided, increment the map size by one
    if (date_key!= NULL) {
        map_size++;
    }

    // Pack the map into the temporary message pack buffer
    msgpack_sbuffer_init(&tmp_sbuf);
    msgpack_packer_init(&tmp_pck, &tmp_sbuf, msgpack_sbuffer_write);
    msgpack_pack_map(&tmp_pck, map_size);

    // Pack the date key and value
    if (date_key!= NULL) {
        msgpack_pack_str(&tmp_pck, flb_sds_len(date_key));
        msgpack_pack_str_body(&tmp_pck, date_key, flb_sds_len(date_key));

        switch (date_format) {
        case FLB_PACK_JSON_DATE_DOUBLE:
            msgpack_pack_double(&tmp_pck, flb_time_to_double(&tms));
            break;
        case FLB_PACK_JSON_DATE_ISO8601:
            /* Format the time, use microsecond precision not nanoseconds */
            gmtime_r(&tms.tm.tv_sec, &tm);
            s = strftime(time_formatted, sizeof(time_formatted) - 1,
                         FLB_PACK_JSON_DATE_ISO8601_FMT, &tm);

            len = snprintf(time_formatted + s,
                           sizeof(time_formatted) - 1 - s,
                           ".%06" PRIu64 "Z",
                           (uint64_t) tms.tm.tv_nsec / 1000);
            s += len;
            msgpack_pack_str(&tmp_pck, s);
            msgpack_pack_str_body(&tmp_pck, time_formatted, s);
            break;
        case FLB_PACK_JSON_DATE_EPOCH:
            msgpack_pack_uint64(&tmp_pck, (long long unsigned)(tms.tm.tv_sec));
            break;
        }
    }

    // Pack the remaining keys and values
    for (i = 0; i < map_size; i++) {
        k = &map.via.map.ptr[i].key;
        v = &map.via.map.ptr[i].val;
        msgpack_pack_object(&tmp_pck, *k);
        msgpack_pack_object(&tmp_pck, *v);
    }

    // If the format is the original msgpack style, just continue since
    // we don't care about separator or JSON convertion at this point.
    if (json_format == FLB_PACK_JSON_FORMAT_JSON) {
        continue;
    }

    // Here we handle two types of records concatenation:
    //
    // FLB_PACK_JSON_FORMAT_LINES: add  breakline (\n) after each record
    //
    //
    //     {'ts':abc,'k1':1}
    //     {'ts':abc,'k1':2}
    //     {N}
    //
    //
    // FLB_PACK_JSON_FORMAT_STREAM: no separators, e.g:
    //
    //     {'ts':abc,'k1':1}{'ts':abc,'k1':2}{N}
    //
    if (json_format == FLB_PACK_JSON_FORMAT_LINES ||
        json_format == FLB_PACK_JSON_FORMAT_STREAM) {

        // Encode current record into JSON in a temporary variable
        out_js = flb_msgpack_raw_to_json_sds(tmp_sbuf.data, tmp_sbuf.size);
        if (!out_js) {
            msgpack_sbuffer_destroy(&tmp_sbuf);
            flb_sds_destroy(out_buf);
            return NULL;
        }

        // One map record has been converted, now append it to the
        // outgoing out_buf sds variable.
        out_tmp = flb_sds_cat(out_buf, out_js, flb_sds_len(out_js));
        if (!out_tmp) {
            msgpack_sbuffer_destroy(&tmp_sbuf);
            flb_sds_destroy(out_js);
            flb_sds_destroy(out_buf);
            return NULL;
        }

        // Release temporary json sds buffer
        flb_sds_destroy(out_js);

        // If a realloc happened, check the returned address
        if (out_tmp!= out_buf) {
            out_buf = out_tmp;
        }

        // Append the breakline only for json lines mode
        if (json_format == FLB_PACK_JSON_FORMAT_LINES) {
            out_tmp = flb_sds_cat(out_buf, "\n", 1);
            if (!out_tmp) {
                msgpack_sbuffer_destroy(&tmp_sbuf);
                flb_sds_destroy(out_buf);
                return NULL;
            }
            if (out_tmp!= out_buf) {
                out_buf = out_tmp;
            }
        }
        msgpack_sbuffer_clear(&tmp_sbuf);
    }
}