// <MASK>
static inline MagickBooleanType IsSVGCompliant(const PixelInfo *pixel)
{
#define SVGCompliant(component) ((double) \
   ScaleCharToQuantum(ScaleQuantumToChar(ClampToQuantum(component))))

  /*
    SVG requires color depths > 8 expressed as percentages.
  */
  if (fabs(SVGCompliant(pixel->red)-pixel->red) >= MagickEpsilon)
    return(MagickFalse);
  if (fabs(SVGCompliant(pixel->green)-pixel->green) >= MagickEpsilon)
    return(MagickFalse);
  if (fabs(SVGCompliant(pixel->blue)-pixel->blue) >= MagickEpsilon)
    return(MagickFalse);
  if ((pixel->colorspace == CMYKColorspace) &&
      (fabs(SVGCompliant(pixel->black)-pixel->black) >= MagickEpsilon))
    return(MagickFalse);
  if ((pixel->alpha_trait!= UndefinedPixelTrait) &&
      (fabs(SVGCompliant(pixel->alpha)-pixel->alpha) >= MagickEpsilon))
    return(MagickFalse);
  return(MagickTrue);
}

static void ConcatentateHexColorComponent(const PixelInfo *pixel,
  const PixelChannel channel,char *tuple)
{
  char
    component[MagickPathExtent];

  double
    color;

  color=0.0;
  switch (channel)
  {
    case RedPixelChannel:
    {
      color=pixel->red;
      break;
    }
    case GreenPixelChannel:
    {
      color=pixel->green;
      break;
    }
    case BluePixelChannel:
    {
      color=pixel->blue;
      break;
    }
    case AlphaPixelChannel:
    {
      color=pixel->alpha;
      break;
    }
    case BlackPixelChannel:
    {
      color=pixel->black;
      break;
    }
    default:
      break;
  }
  if (pixel->depth > 32)
    {
      (void) FormatLocaleString(component,MagickPathExtent,"%08lX%08lX",
        (unsigned long) ScaleQuantumToLong(ClampToQuantum(color)),
        (unsigned long) ScaleQuantumToLong(ClampToQuantum(color)));
      (void) ConcatenateMagickString(tuple,component,MagickPathExtent);
      return;
    }
  if (pixel->depth > 16)
    {
      (void) FormatLocaleString(component,MagickPathExtent,"%08X",
        (unsigned int) ScaleQuantumToLong(ClampToQuantum(color)));
      (void) ConcatenateMagickString(tuple,component,MagickPathExtent);
      return;
    }
  if (pixel->depth > 8)
    {
      (void) FormatLocaleString(component,MagickPathExtent,"%04X",
        ScaleQuantumToShort(ClampToQuantum(color)));
      (void) ConcatenateMagickString(tuple,component,MagickPathExtent);
      return;
    }
  (void) FormatLocaleString(component,MagickPathExtent,"%02X",
    ScaleQuantumToChar(ClampToQuantum(color)));
  (void) ConcatenateMagickString(tuple,component,MagickPathExtent);
  return;
}

MagickExport void GetColorTuple(const PixelInfo *pixel,
  const MagickBooleanType hex,char *tuple)
{
  PixelInfo
    color;

  assert(pixel!= (const PixelInfo *) NULL);
  assert(tuple!= (char *) NULL);
  (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",tuple);
  *tuple='\0';
  if (hex!= MagickFalse)
    {
      /*
        Convert pixel to hex color.
      */
      (void) ConcatenateMagickString(tuple,"#",MagickPathExtent);
      ConcatentateHexColorComponent(pixel,RedPixelChannel,tuple);
      ConcatentateHexColorComponent(pixel,GreenPixelChannel,tuple);
      ConcatentateHexColorComponent(pixel,BluePixelChannel,tuple);
      if (pixel->colorspace == CMYKColorspace)
        ConcatentateHexColorComponent(pixel,BlackPixelChannel,tuple);
      if (pixel->alpha_trait!= UndefinedPixelTrait)
        ConcatentateHexColorComponent(pixel,AlphaPixelChannel,tuple);
      return;
    }
  /*
    Convert pixel to rgb() or cmyk() color.
  */
  color=(*pixel);
  if ((color.depth > 8) && (IsSVGCompliant(pixel)!= MagickFalse))
    color.depth=8;
  (void) ConcatenateMagickString(tuple,CommandOptionToMnemonic(
    MagickColorspaceOptions,(ssize_t) color.colorspace),MagickPathExtent);
  if (color.alpha_trait!= UndefinedPixelTrait)
    (void) ConcatenateMagickString(tuple,"a",MagickPathExtent);
  (void) ConcatenateMagickString(tuple,"(",MagickPathExtent);
  if ((color.colorspace == LinearGRAYColorspace) ||
      (color.colorspace == GRAYColorspace))
    ConcatenateColorComponent(&color,GrayPixelChannel,SVGCompliance,tuple);
  else
    {
      ConcatenateColorComponent(&color,RedPixelChannel,SVGCompliance,tuple);
      (void) ConcatenateMagickString(tuple,",",MagickPathExtent);
      ConcatenateColorComponent(&color,GreenPixelChannel,SVGCompliance,tuple);
      (void) ConcatenateMagickString(tuple,",",MagickPathExtent);
      ConcatenateColorComponent(&color,BluePixelChannel,SVGCompliance,tuple);
    }
  if (color.colorspace == CMYKColorspace)
    {
      (void) ConcatenateMagickString(tuple,",",MagickPathExtent);
      ConcatenateColorComponent(&color,BlackPixelChannel,SVGCompliance,tuple);
    }
  if (color.alpha_trait!= UndefinedPixelTrait)
    {
      (void) ConcatenateMagickString(tuple,",",MagickPathExtent);
      ConcatenateColorComponent(&color,AlphaPixelChannel,SVGCompliance,tuple);
    }
  (void) ConcatenateMagickString(tuple,")",MagickPathExtent);
  LocaleLower(tuple);
  return;
}
// <MASK>