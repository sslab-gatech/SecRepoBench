case 2:
case 3:
  if(payload_len > 11 && memcmp(packet_payload, "1 ", 2) == 0 && packet_payload[2]!='') {
    u_int16_t i = 3;
    u_int8_t numbers_left = 4;
    // Iterate through the payload to validate the presence of a specified number of numeric sequences,
    // each followed by a space. If the expected format is not met, exit the processing.
    // Continue scanning the payload for alphanumeric characters until a newline character is found.
    // If the format is correctly identified and the state progresses past a threshold, ensure the cache
    // exists, adding an entry for the flow's connection information if necessary.
    // Log the detection of a tinc TCP connection and update the detection protocol state.
    while(i < payload_len && packet_payload[i]!= '\n') {
      if(packet_payload[i] >= '0' && packet_payload[i] <= '9') {
        numbers_left--;
        if(numbers_left == 0) {
          break;
        }
      } else if(packet_payload[i] =='') {
        numbers_left = 4;
      } else {
        break;
      }
      i++;
    }
    if(i+3 == payload_len && memcmp((packet_payload+i), "17\n", 3) == 0) {
      connection_flow->tinc_state++;
      if(connection_flow->tinc_state == 4) {
        if(ndpi_struct->tinc_cache!= NULL) {
          struct tinc_cache_entry tinc_cache_entry = {
           .src_address = packet->iph->saddr,
           .dst_address = packet->iph->daddr,
           .dst_port = packet->tcp->dest
          };
          cache_add(ndpi_struct->tinc_cache, &tinc_cache_entry, sizeof(tinc_cache_entry));
        }
        NDPI_LOG_INFO(ndpi_struct, "found tinc tcp connection\n");
        ndpi_set_detected_protocol(ndpi_struct, connection_flow, NDPI_PROTOCOL_TINC, NDPI_PROTOCOL_UNKNOWN, NDPI_CONFIDENCE_DPI_CACHE);
      }
    }
  }
  break;