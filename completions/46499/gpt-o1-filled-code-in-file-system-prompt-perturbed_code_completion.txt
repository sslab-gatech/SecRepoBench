{
  u_int16_t i = 3;
  u_int8_t numbers_left = 4;

  /* Parse four sequences of digits (each followed by a space). */
  while(i < payload_len && numbers_left > 0) {
    /* Require at least one digit. */
    if(!isdigit(packet_payload[i])) break;
    /* Skip remaining digits in the sequence. */
    while(i < payload_len && isdigit(packet_payload[i])) i++;
    /* Expect a space afterward. */
    if(i < payload_len && packet_payload[i] == ' ') {
      i++;
      numbers_left--;
    } else {
      break;
    }
  }
  /* If we didn't parse all four sequences, bail out. */
  if(numbers_left != 0) break;

  /* Continue scanning for alphanumeric until newline. */
  while(i < payload_len && packet_payload[i] != '\n') {
    if(!isalnum(packet_payload[i]) && packet_payload[i] != ' ')
      break;
    i++;
  }
  /* Must end exactly at a newline. */
  if(i >= payload_len || packet_payload[i] != '\n') break;

  /* Valid format found, advance state. */
  connection_flow->tinc_state++;

  /* If we've advanced beyond the expected handshake states, mark detection. */
  if(connection_flow->tinc_state > 3) {
    if(!ndpi_struct->tinc_cache) {
      ndpi_struct->tinc_cache = cache_init(256, 1, free, 1, NULL);
      if(!ndpi_struct->tinc_cache) break;
    }
    cache_add(ndpi_struct->tinc_cache,
              &connection_flow->tinc_cache_entry,
              sizeof(connection_flow->tinc_cache_entry));

    NDPI_LOG_INFO(ndpi_struct, "found tinc tcp connection\n");
    ndpi_set_detected_protocol(ndpi_struct, connection_flow,
                               NDPI_PROTOCOL_TINC, NDPI_PROTOCOL_UNKNOWN,
                               NDPI_CONFIDENCE_DPI_CACHE);
  }
  return;
}