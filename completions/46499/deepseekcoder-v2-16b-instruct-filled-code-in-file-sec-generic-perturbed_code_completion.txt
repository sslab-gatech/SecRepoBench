case 2:
    case 3:
      if(payload_len > 11 && memcmp(packet_payload, "1 ", 2) == 0 && packet_payload[2] != ' ') {
        u_int16_t i = 3;
        u_int8_t numbers_left = 4;
        // Iterate through the payload to validate the presence of a specified number of numeric sequences,
        // each followed by a space. If the expected format is not met, exit the processing.
        // Continue scanning the payload for alphanumeric characters until a newline character is found.
        // If the format is correctly identified and the state progresses past a threshold, ensure the cache
        // exists, adding an entry for the flow's connection information if necessary.
        // Log the detection of a tinc TCP connection and update the detection protocol state.
        if(ndpi_struct->tinc_cache != NULL) {
          struct tinc_cache_entry entry = {
            .src_address = connection_flow->tinc_cache_entry.src_address,
            .dst_address = connection_flow->tinc_cache_entry.dst_address,
            .dst_port = connection_flow->tinc_cache_entry.dst_port
          };
          cache_add(ndpi_struct->tinc_cache, &entry, sizeof(entry));
        }
        NDPI_LOG_INFO(ndpi_struct, "found tinc tcp connection\n");
        ndpi_set_detected_protocol(ndpi_struct, connection_flow, NDPI_PROTOCOL_TINC, NDPI_PROTOCOL_UNKNOWN, NDPI_CONFIDENCE_DPI_CACHE);
        connection_flow->tinc_state++;
        return;
      }
      break;