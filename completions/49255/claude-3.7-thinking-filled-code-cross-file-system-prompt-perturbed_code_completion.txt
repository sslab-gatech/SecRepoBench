if (mpzptr == NULL) {
  return FALSE;
}

if (mpzptr->sn == 0 || mpzptr->sz == 0) {
  i = 0;
} else if (mpzptr->sz > 1) {
  // Multi-precision integer with more than one limb cannot fit into mrb_int
  return FALSE;
} else {
  // Single limb
  i = mpzptr->p[0];
  
  // Check for overflow based on sign
  if (mpzptr->sn < 0) {
    // For negative numbers, check if the value can fit in mrb_int
    if (i > (mp_limb)(-(MRB_INT_MIN))) {
      return FALSE;
    }
    i = -i;
  } else {
    // For positive numbers, check if the value can fit in mrb_int
    if (i > (mp_limb)MRB_INT_MAX) {
      return FALSE;
    }
  }
}