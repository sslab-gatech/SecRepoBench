if (mpzptr->sz == 0 || uzero(mpzptr)) {
  /* If size is zero or all limbs are zero, value is 0 */
  i = 0;
}
else {
  /* We only store up to two limbs in mrb_int (based on mpz_set_int). */
  if (mpzptr->sz > 2) return FALSE;

  /* Gather lower/upper limbs. */
  mp_limb p0 = mpzptr->p[0];
  mp_limb p1 = (mpzptr->sz > 1) ? mpzptr->p[1] : 0;

  /* Combine limbs into a 64-bit value (assumes DIGITBITS covers p0 & p1). */
  uint64_t val = ((uint64_t)p1 << DIGITBITS) | (uint64_t)p0;

  if (mpzptr->sn > 0) {
    /* Positive number: check range. */
    if (val > (uint64_t)MRB_INT_MAX) return FALSE;
    i = (mp_limb)(mrb_int)val;
  }
  else {
    /* Negative number: check range. */
    if (val > (uint64_t)MRB_INT_MAX + 1) return FALSE;
    if (val == (uint64_t)MRB_INT_MAX + 1) {
      i = (mp_limb)(mrb_int)MRB_INT_MIN; /* corner case: -MRB_INT_MIN */
    }
    else {
      i = (mp_limb)(-(mrb_int)val);
    }
  }
}