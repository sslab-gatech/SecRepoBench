if (mpz_size(mpzptr) > 1) {
    return FALSE; // Conversion not possible if the number has more than one limb
  }

  i = mpz_getlimbn(mpzptr, 0); // Safely retrieve the first limb of the multi-precision integer

  if (mpz_sgn(mpzptr) < 0) {
    if (i > (mp_limb)(-(MRB_INT_MIN + 1)) + 1) {
      return FALSE; // Check for underflow when converting to a signed integer
    }
    i = -i; // Convert to negative if the number is negative
  } else {
    if (i > (mp_limb)MRB_INT_MAX) {
      return FALSE; // Check for overflow when converting to a signed integer
    }
  }