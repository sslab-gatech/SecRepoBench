// If the mpz is 0, set i to 0
if (mpzptr->sn == 0) {
    i = 0;
}
else {
    // Check if the number of limbs is beyond what can fit in mrb_int
    if (mpzptr->sz > 2) return FALSE;

    // Extract the value from the limbs
    if (mpzptr->sz == 1) {
        i = mpzptr->p[0];
    } else {  // sz == 2
        i = mpzptr->p[0] | (mpzptr->p[1] << DIGITBITS);
    }

    // Apply the sign
    if (mpzptr->sn < 0) {
        i = -i;
    }

    // Check for overflow (if the sign of the result doesn't match the expected sign)
    if ((mpzptr->sn > 0 && i < 0) || (mpzptr->sn < 0 && i > 0)) {
        return FALSE;  // Overflow
    }
}