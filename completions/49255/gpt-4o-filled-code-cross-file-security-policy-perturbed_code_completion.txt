if (mpzptr->sz > 1) {
    return FALSE; // More than one limb, cannot fit into a single mrb_int
  }

  i = mpzptr->p[0]; // Get the single limb value

  // Check if the value can fit into mrb_int
  if (mpzptr->sn < 0) {
    if (i > (mp_limb)(-(MRB_INT_MIN))) {
      return FALSE; // Negative overflow
    }
    i = -i; // Convert to negative if sign is negative
  }
  else {
    if (i > (mp_limb)MRB_INT_MAX) {
      return FALSE; // Positive overflow
    }
  }