if (mpz_size(mpzptr) > 1) {
    return FALSE; // Cannot convert if the number has more than one limb
  }

  i = mpz_getlimbn(mpzptr, 0); // Get the least significant limb

  if (mpz_sgn(mpzptr) < 0) {
    if (i > (mp_limb)(-(MRB_INT_MIN + 1)) + 1) {
      return FALSE; // Out of range for negative mrb_int
    }
    i = -i; // Convert to negative
  }
  else {
    if (i > (mp_limb)MRB_INT_MAX) {
      return FALSE; // Out of range for positive mrb_int
    }
  }