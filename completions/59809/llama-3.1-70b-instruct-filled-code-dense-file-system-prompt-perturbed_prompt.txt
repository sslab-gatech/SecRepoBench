Below is the content of a C/C++ function where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
TLVRecordType getFirstTLVRecord(uint8_t* tlvDataBasePtr, size_t tlvDataLength) const
		{
			// Get the first TLV record out of a byte stream.
			// Return a instance of type TLVRecordType that contains the first TLV record.
			// If tlvDataBasePtr is NULL or tlv data length is zero the returned TLVRecordType 
			// instance will be logically NULL, meaning TLVRecordType.isNull() will return true.
			// <MASK>
		}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// Packet++/header/TLVData.h
TLVRecordType getTLVRecord(uint32_t recordType, uint8_t* tlvDataBasePtr, size_t tlvDataLen) const
		{
			TLVRecordType curRec = getFirstTLVRecord(tlvDataBasePtr, tlvDataLen);
			while (!curRec.isNull())
			{
				if (curRec.getType() == recordType)
				{
					return curRec;
				}

				curRec = getNextTLVRecord(curRec, tlvDataBasePtr, tlvDataLen);
			}

			curRec.assign(NULL);
			return curRec; // for NRVO optimization
		}

// the below code fragment can be found in:
// Packet++/header/TLVData.h
size_t getTLVRecordCount(uint8_t* tlvDataBasePtr, size_t tlvDataLen) const
		{
			if (m_RecordCount != (size_t)-1)
				return m_RecordCount;

			m_RecordCount = 0;
			TLVRecordType curRec = getFirstTLVRecord(tlvDataBasePtr, tlvDataLen);
			while (!curRec.isNull())
			{
				m_RecordCount++;
				curRec = getNextTLVRecord(curRec, tlvDataBasePtr, tlvDataLen);
			}

			return m_RecordCount;
		}

// the below code fragment can be found in:
// Packet++/header/TLVData.h
TLVRecordType getNextTLVRecord(TLVRecordType& record, const uint8_t* tlvDataBasePtr, size_t tlvDataLen) const
		{
			TLVRecordType resRec(NULL); // for NRVO optimization

			if (record.isNull())
				return resRec;

			// record pointer is out-bounds of the TLV records memory
			if ((record.getRecordBasePtr() - tlvDataBasePtr) < 0)
				return resRec;

			// record pointer is out-bounds of the TLV records memory
			if (record.getRecordBasePtr() - tlvDataBasePtr + (int)record.getTotalSize() >= (int)tlvDataLen)
				return resRec;

			resRec.assign(record.getRecordBasePtr() + record.getTotalSize());
			if (resRec.getTotalSize() == 0)
				resRec.assign(NULL);

			return resRec;
		}

// the below code fragment can be found in:
// Packet++/src/NflogLayer.cpp
NflogTlv NflogLayer::getTlvByType(NflogTlvType type) const
{
	NflogTlv tlv = m_TlvReader.getTLVRecord(
		static_cast<uint32_t> (type),
		getTlvsBasePtr(),
		m_DataLen - sizeof(nflog_header));

	return tlv;
}

// the below code fragment can be found in:
// Packet++/src/TLVData.cpp
TLVRecordBuilder::TLVRecordBuilder(uint32_t recType, const uint8_t* recValue, uint8_t recValueLen)
{
	init(recType, recValue, recValueLen);
}
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).