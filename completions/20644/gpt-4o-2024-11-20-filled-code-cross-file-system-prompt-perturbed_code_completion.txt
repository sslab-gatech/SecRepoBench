iph_check:
  if((ip_offset + sizeof(struct ndpi_iphdr)) > header->caplen) {
    workflow->stats.total_discarded_bytes += header->len;
    return(nproto); /* Incomplete IP header */
  }

  iph = (struct ndpi_iphdr *)&packet[ip_offset];

  if(iph->version == IPVERSION) {
    ip_len = ((u_int16_t)iph->ihl * 4);
    proto = iph->protocol;

    if((ip_offset + ip_len) > header->caplen) {
      workflow->stats.total_discarded_bytes += header->len;
      return(nproto); /* Incomplete IP packet */
    }

    frag_off = ntohs(iph->frag_off);
  } else if(iph->version == 6) {
    iph6 = (struct ndpi_ipv6hdr *)&packet[ip_offset];
    proto = iph6->ip6_hdr.ip6_un1_nxt;
    ip_len = sizeof(struct ndpi_ipv6hdr);

    if((ip_offset + ip_len) > header->caplen) {
      workflow->stats.total_discarded_bytes += header->len;
      return(nproto); /* Incomplete IPv6 packet */
    }

    if(proto == IPPROTO_DSTOPTS /* IPv6 destination option */) {
      u_int8_t *options = (u_int8_t*)&packet[ip_offset + ip_len];
      proto = options[0];
      ip_len += 8 * (options[1] + 1);
    }

    iph = NULL;
  } else {
    static u_int8_t ipv4_warning_used = 0;

    if(ipv4_warning_used == 0) {
      if(!workflow->prefs.quiet_mode)
        NDPI_LOG(0, workflow->ndpi_struct, NDPI_LOG_DEBUG,
                 "\n\nWARNING: only IPv4/IPv6 packets are supported in this demo (nDPI supports both IPv4 and IPv6), all other packets will be discarded\n\n");
      ipv4_warning_used = 1;
    }
    workflow->stats.total_discarded_bytes += header->len;
    return(nproto);
  }

  if((header->caplen - ip_offset) < ip_len) {
    workflow->stats.total_discarded_bytes += header->len;
    return(nproto); /* Incomplete IP header */
  }

  if((frag_off & 0x1FFF) != 0) {
    static u_int8_t ipv4_frags_warning_used = 0;
    workflow->stats.fragmented_count++;

    if(ipv4_frags_warning_used == 0) {
      if(!workflow->prefs.quiet_mode)
        NDPI_LOG(0, workflow->ndpi_struct, NDPI_LOG_DEBUG,
                 "\n\nWARNING: IPv4 fragments are not handled by this demo (nDPI supports them)\n");
      ipv4_frags_warning_used = 1;
    }

    workflow->stats.total_discarded_bytes += header->len;
    return(nproto);
  }