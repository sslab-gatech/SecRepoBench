if(header->caplen < ip_offset + sizeof(struct ndpi_iphdr)) {
  if(!workflow->prefs.quiet_mode)
    NDPI_LOG(0, workflow->ndpi_struct, NDPI_LOG_DEBUG,
	     "WARNING: packet truncated, not enough bytes for minimal IP header (caplen: %u, needed: %lu)\n",
	     header->caplen, (unsigned long)(ip_offset + sizeof(struct ndpi_iphdr)));
  workflow->stats.total_discarded_bytes += header->caplen;
  return(nproto);
}
iph = (struct ndpi_iphdr *) &packet[ip_offset];
/* Compute the IP header length in bytes */
u_int16_t ip_header_length = ((u_int16_t)(iph->ihl & 0x0F)) * 4;
if(header->caplen < ip_offset + ip_header_length) {
  if(!workflow->prefs.quiet_mode)
    NDPI_LOG(0, workflow->ndpi_struct, NDPI_LOG_DEBUG,
	     "WARNING: captured packet size (%u) is smaller than the IP header length (%u)\n",
	     header->caplen, ip_offset + ip_header_length);
  workflow->stats.total_discarded_bytes += header->caplen;
  return(nproto);
}
frag_off = ntohs(iph->frag_off);
proto = iph->protocol;