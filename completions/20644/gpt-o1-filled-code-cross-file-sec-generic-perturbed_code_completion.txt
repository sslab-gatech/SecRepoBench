if(header->len > header->caplen) {
  static int capture_warn_once = 0;
  if(!capture_warn_once && !workflow->prefs.quiet_mode) {
    NDPI_LOG(0, workflow->ndpi_struct, NDPI_LOG_DEBUG,
             "\nWARNING: Captured packet size is smaller than the actual packet size. "
             "Some data may be truncated.\n");
    capture_warn_once = 1;
  }
}

if(recheck_type)
  goto ether_type_check;

if(vlan_packet)
  workflow->stats.vlan_count++;

iph_check:
if((header->caplen - ip_offset) < sizeof(struct ndpi_iphdr)) {
  static int ip_trunc_warn_once = 0;
  if(!ip_trunc_warn_once && !workflow->prefs.quiet_mode) {
    NDPI_LOG(0, workflow->ndpi_struct, NDPI_LOG_DEBUG,
             "\nWARNING: Packet too short for IP header. Discarding.\n");
    ip_trunc_warn_once = 1;
  }
  workflow->stats.total_discarded_bytes += header->len;
  return(nproto);
}

iph = (struct ndpi_iphdr *)&packet[ip_offset];
frag_off = ntohs(iph->frag_off);
proto = iph->protocol;