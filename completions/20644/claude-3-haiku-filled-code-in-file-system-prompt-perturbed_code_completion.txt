if(iph->version == IPVERSION) {
  ip_len = ((u_int16_t)iph->ihl * 4);
  iph6 = NULL;

  if(iph->protocol == IPPROTO_IPV6) {
    ip_offset += ip_len;
    if (ip_len > 0)
      goto iph_check;
  }

  if((frag_off & 0x1FFF) != 0) {
    static u_int8_t ipv4_frags_warning_used = 0;
    workflow->stats.fragmented_count++;

    if(ipv4_frags_warning_used == 0) {
      if(!workflow->prefs.quiet_mode)
        NDPI_LOG(0, workflow->ndpi_struct, NDPI_LOG_DEBUG, "\n\nWARNING: IPv4 fragments are not handled by this demo (nDPI supports them)\n");
      ipv4_frags_warning_used = 1;
    }

    workflow->stats.total_discarded_bytes +=  header->len;
    return(nproto);
  }
} else if(iph->version == 6) {
  iph6 = (struct ndpi_ipv6hdr *)&packet[ip_offset];
  proto = iph6->ip6_hdr.ip6_un1_nxt;
  ip_len = sizeof(struct ndpi_ipv6hdr);

  if(proto == IPPROTO_DSTOPTS /* IPv6 destination option */) {
    u_int8_t *options = (u_int8_t*)&packet[ip_offset+ip_len];
    proto = options[0];
    ip_len += 8 * (options[1] + 1);
  }

  iph = NULL;
} else {
  static u_int8_t ipv4_warning_used = 0;

v4_warning:
  if(ipv4_warning_used == 0) {
    if(!workflow->prefs.quiet_mode)
      NDPI_LOG(0, workflow->ndpi_struct, NDPI_LOG_DEBUG,
               "\n\nWARNING: only IPv4/IPv6 packets are supported in this demo (nDPI supports both IPv4 and IPv6), all other packets will be discarded\n\n");
    ipv4_warning_used = 1;
  }
  workflow->stats.total_discarded_bytes +=  header->len;
  return(nproto);
}