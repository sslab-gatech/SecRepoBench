if(iph->version == IPVERSION) {
    ip_len = ((u_int16_t)iph->ihl * 4);
    iph6 = NULL;

    if(iph->protocol == IPPROTO_IPV6) {
      ip_offset += ip_len;
      if (ip_len > 0)
        goto iph_check;
    }

    if((frag_off & 0x1FFF) != 0) {
      static u_int8_t ipv4_frags_warning_used = 0;
      workflow->stats.fragmented_count++;

      if(ipv4_frags_warning_used == 0) {
	if(!workflow->prefs.quiet_mode)
	  NDPI_LOG(0, workflow->ndpi_struct, NDPI_LOG_DEBUG, "\n\nWARNING: IPv4 fragments are not handled by this demo (nDPI supports them)\n");
	ipv4_frags_warning_used = 1;
      }

      workflow->stats.total_discarded_bytes +=  header->len;
      return(nproto);
    }
  } else if(iph->version == 6) {
    iph6 = (struct ndpi_ipv6hdr *)&packet[ip_offset];
    proto = iph6->ip6_hdr.ip6_un1_nxt;
    ip_len = sizeof(struct ndpi_ipv6hdr);

    if(proto == IPPROTO_DSTOPTS /* IPv6 destination option */) {
      u_int8_t *options = (u_int8_t*)&packet[ip_offset+ip_len];
      proto = options[0];
      ip_len += 8 * (options[1] + 1);
    }

    iph = NULL;
  } else {
    static u_int8_t ipv4_warning_used = 0;

  v4_warning:
    if(ipv4_warning_used == 0) {
      if(!workflow->prefs.quiet_mode)
        NDPI_LOG(0, workflow->ndpi_struct, NDPI_LOG_DEBUG,
		 "\n\nWARNING: only IPv4/IPv6 packets are supported in this demo (nDPI supports both IPv4 and IPv6), all other packets will be discarded\n\n");
      ipv4_warning_used = 1;
    }
    workflow->stats.total_discarded_bytes +=  header->len;
    return(nproto);
  }

iph_check:
  if(header->caplen < ip_offset + ip_len) {
    static u_int8_t iph_check_warning_used = 0;
    if(!iph_check_warning_used) {
      if(!workflow->prefs.quiet_mode)
        NDPI_LOG(0, workflow->ndpi_struct, NDPI_LOG_DEBUG,
		 "\n\nWARNING: IP header is larger than the captured packet size (caplen=%u, ip_offset=%u, ip_len=%u)\n\n",
		 header->caplen, ip_offset, ip_len);
      iph_check_warning_used = 1;
    }
    workflow->stats.total_discarded_bytes +=  header->len;
    return(nproto);
  }

  if(iph->protocol == IPPROTO_TCP) {
    struct ndpi_tcphdr *tcph = (struct ndpi_tcphdr *)&packet[ip_offset+ip_len];
    *tcph = ntohl(*tcph);
    *sport = ntohs(tcph->source);
    *dport = ntohs(tcph->dest);
    proto = IPPROTO_TCP;
  } else if(iph->protocol == IPPROTO_UDP) {
    struct ndpi_udphdr *udph = (struct ndpi_udphdr *)&packet[ip_offset+ip_len];
    *udph = ntohs(*udph);
    *sport = ntohs(udph->source);
    *dport = ntohs(udph->dest);
    proto = IPPROTO_UDP;
  } else {
    proto = iph->protocol;
  }

  if(iph6 != NULL) {
    *src = ndpi_get_id_struct(workflow->ndpi_struct, NDPI_PROTOCOL_IPV6, &iph6->ip6_src);
    *dst = ndpi_get_id_struct(workflow->ndpi_struct, NDPI_PROTOCOL_IPV6, &iph6->ip6_dst);
  } else {
    *src = ndpi_get_id_struct(workflow->ndpi_struct, NDPI_PROTOCOL_IPV4, &iph->saddr);
    *dst = ndpi_get_id_struct(workflow->ndpi_struct, NDPI_PROTOCOL_IPV4, &iph->daddr);
  }

  *payload = &packet[ip_offset + ip_len + sizeof(struct ndpi_tcphdr)];
  *payload_len = header->caplen - ip_offset - ip_len - sizeof(struct ndpi_tcphdr);

  if(*payload_len > 0) {
    if(iph6 != NULL)
      *src_to_dst_direction = ndpi_get_direction(workflow->ndpi_struct, *src, *dst);
    else
      *src_to_dst_direction = ndpi_get_direction(workflow->ndpi_struct, *src, *dst);
  } else {
    *src_to_dst_direction = NDPI_MAX_DIRECTIONS;
  }

  return(get_ndpi_flow_info6(workflow, vlan_id, tunnel_type, iph6, ip_offset, header->caplen - ip_offset,
			     tcph, udph, sport, dport, src, dst, proto,
			     payload, payload_len, src_to_dst_direction, header->ts));
}