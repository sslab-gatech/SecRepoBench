iph_check:
  if(((bpf_u_int32)ip_offset + sizeof(struct ndpi_iphdr)) > header->caplen) {
    static u_int8_t ipv4_header_warning_used = 0;

    if(ipv4_header_warning_used == 0) {
      if(!workflow->prefs.quiet_mode)
	NDPI_LOG(0, workflow->ndpi_struct, NDPI_LOG_DEBUG, "\n\nWARNING: truncated IPv4 header\n");
      ipv4_header_warning_used = 1;
    }
    workflow->stats.total_discarded_bytes +=  header->len;
    return(nproto);
  }

  iph = (struct ndpi_iphdr *) &packet[ip_offset];

  if(recheck_type == 0) {
    if(iph->version == IPVERSION)
      cprototype = iph->protocol;
    else if(iph->version == 6)
      cprototype = iph6->ip6_hdr.ip6_un1_nxt;
  }

  if(cprototype == ETH_P_IP) {
    frag_off = ntohs(iph->frag_off);
    proto = iph->protocol;
  } else if(cprototype == ETH_P_IPV6) {
    frag_off = 0;
    proto = iph6->ip6_hdr.ip6_un1_nxt;
  } else {
    goto v4_warning;
  }

  if(header->caplen < (ip_offset + ip_len)) {
    static u_int8_t capture_size_warning_used = 0;

    if(capture_size_warning_used == 0) {
      if(!workflow->prefs.quiet_mode)
	NDPI_LOG(0, workflow->ndpi_struct, NDPI_LOG_DEBUG, "\n\nWARNING: capture size (%u) < actual packet size (%u)\n", header->caplen, (unsigned int)(ip_offset + ip_len));
      capture_size_warning_used = 1;
    }
    workflow->stats.total_discarded_bytes +=  header->len;
    return(nproto);
  }

  if(vlan_packet)
    workflow->stats.vlan_packet_count++;