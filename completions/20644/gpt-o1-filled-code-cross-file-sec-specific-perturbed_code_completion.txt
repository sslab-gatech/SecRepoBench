if(recheck_type)
  goto ether_type_check;

if(vlan_packet)
  workflow->stats.vlan_count++;

iph_check:
/* Verify that we have enough bytes to read an IP header */
if(((bpf_u_int32)ip_offset + sizeof(struct ndpi_iphdr)) > header->caplen) {
  static u_int8_t ip_header_warning_used = 0;

  if(!ip_header_warning_used) {
    if(!workflow->prefs.quiet_mode)
      NDPI_LOG(0, workflow->ndpi_struct, NDPI_LOG_DEBUG,
               "WARNING: not enough data for IP header (ip_offset=%u, caplen=%d)\n",
               ip_offset, header->caplen);
    ip_header_warning_used = 1;
  }
  workflow->stats.total_discarded_bytes += header->len;
  return(nproto);
}

iph = (struct ndpi_iphdr *)&packet[ip_offset];
frag_off = ntohs(iph->frag_off);
proto = iph->protocol;

/* If the capture size is smaller than the actual packet size, log warning */
if(header->len < header->caplen) {
  static u_int8_t capture_size_warning_used = 0;

  if(!capture_size_warning_used) {
    if(!workflow->prefs.quiet_mode)
      NDPI_LOG(0, workflow->ndpi_struct, NDPI_LOG_DEBUG,
               "WARNING: captured packet size is smaller than actual packet size\n");
    capture_size_warning_used = 1;
  }
}