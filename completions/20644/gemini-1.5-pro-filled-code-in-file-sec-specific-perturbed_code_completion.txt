if(recheck_type)
    goto ether_type_check;

  if(vlan_packet)
    workflow->stats.vlan_count++;

iph_check:
  if(header->caplen < (ip_offset + sizeof(struct ndpi_iphdr)))
    return(nproto);

  iph = (struct ndpi_iphdr *) &packet[ip_offset];

  if((cprototype == ETH_P_IP) && (iph->version == IPVERSION))
    ;
  else if(cprototype == ETH_P_IPV6) {
    ip_offset -= 4;
    iph = (struct ndpi_iphdr *) &packet[ip_offset];
  } else {
    static u_int8_t ipv4_warning_used = 0;

  v4_warning:
    if(ipv4_warning_used == 0) {
      if(!workflow->prefs.quiet_mode)
        NDPI_LOG(0, workflow->ndpi_struct, NDPI_LOG_DEBUG,
                 "\n\nWARNING: only IPv4/IPv6 packets are supported in this demo (nDPI supports both IPv4 and IPv6), all other packets will be discarded\n\n");
      ipv4_warning_used = 1;
    }

    workflow->stats.total_discarded_bytes +=  header->len;
    return(nproto);
  }

  frag_off = ntohs(iph->frag_off);
  proto = iph->protocol;

  if(header->caplen < header->len) {
    static u_int8_t capture_size_warning_used = 0;

    if(capture_size_warning_used == 0) {
      if(!workflow->prefs.quiet_mode)
        NDPI_LOG(0, workflow->ndpi_struct, NDPI_LOG_DEBUG, "\n\nWARNING: You are capturing truncated packets, consider increasing the snaplen of your capture tool\n\n");
      capture_size_warning_used = 1;
    }
  }