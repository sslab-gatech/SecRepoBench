iph_check:
  if(((bpf_u_int32)ip_offset + sizeof(struct ndpi_iphdr)) > header->caplen) {
    goto v4_warning;
  }

  iph = (struct ndpi_iphdr *) &packet[ip_offset];

  if(cprototype == ETH_P_IP && iph->version != IPVERSION) {
    goto v4_warning;
  }

  if(cprototype == ETH_P_IP && iph->version == IPVERSION) {
    if(iph->protocol == IPPROTO_IPIP) {
      ip_offset += iph->ihl * 4;
      goto iph_check;
    }
  }

  if(recheck_type == 0 && cprototype == ETH_P_IP) {
    if(iph->version == IPVERSION) {
      if(iph->protocol == IPPROTO_IPIP) {
	ip_offset += iph->ihl * 4;
	goto iph_check;
      }
    }
  }

  if(vlan_packet)
    workflow->stats.vlan_packet_count++;

  if(cprototype == ETH_P_IP && iph->version == IPVERSION) {
    frag_off = ntohs(iph->frag_off);
    proto = iph->protocol;
    ip_len = ntohs(iph->tot_len);

    if(header->caplen < ip_len) {
      static u_int8_t capture_size_warning_used = 0;

      if(capture_size_warning_used == 0) {
	if(!workflow->prefs.quiet_mode)
	  NDPI_LOG(0, workflow->ndpi_struct, NDPI_LOG_DEBUG, "\n\nWARNING: captured packet size is less than actual packet size (packet_id=%u)\n", (unsigned int)workflow->stats.raw_packet_count);
	capture_size_warning_used = 1;
      }
      workflow->stats.total_discarded_bytes +=  header->len;
      return(nproto);
    }
  }