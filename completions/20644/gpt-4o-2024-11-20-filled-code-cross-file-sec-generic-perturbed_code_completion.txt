iph_check:
  // Verify the presence of a complete IP header at the current offset
  if((ip_offset + sizeof(struct ndpi_iphdr)) > header->caplen) {
    workflow->stats.total_discarded_bytes += header->len;
    return(nproto); // Incomplete IP header
  }

  // Set the IP header pointer to the current packet offset
  iph = (struct ndpi_iphdr *)&packet[ip_offset];

  // Continue processing only if the packet contains Ethernet with IP protocol
  if(iph->version == IPVERSION) {
    ip_len = ((u_int16_t)iph->ihl * 4);

    // Check if the captured packet size is less than the actual packet size
    if(header->caplen < (ip_offset + ip_len)) {
      static u_int8_t capture_warning_used = 0;

      if(capture_warning_used == 0) {
        if(!workflow->prefs.quiet_mode)
          NDPI_LOG(0, workflow->ndpi_struct, NDPI_LOG_DEBUG,
                   "\n\nWARNING: Captured packet size is smaller than expected. Some packets may be truncated.\n\n");
        capture_warning_used = 1;
      }

      workflow->stats.total_discarded_bytes += header->len;
      return(nproto);
    }

    // Retrieve fragment offset from the IP header and store it
    frag_off = ntohs(iph->frag_off);

    // Extract the IP protocol type from the IP header
    proto = iph->protocol;
  } else {
    // If the IP version is not IPv4, handle IPv6 or discard the packet
    iph = NULL;
    goto v4_warning;
  }