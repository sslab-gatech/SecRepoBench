if (ip_offset + sizeof(struct ndpi_iphdr) > header->caplen) {
    workflow->stats.total_discarded_bytes += header->len;
    return nproto; // Not enough data for IP header
  }

  iph = (struct ndpi_iphdr *)&packet[ip_offset];
  if (iph->version != IPVERSION) {
    static u_int8_t ipv4_warning_used = 0;
    if (ipv4_warning_used == 0) {
      if (!workflow->prefs.quiet_mode)
        NDPI_LOG(0, workflow->ndpi_struct, NDPI_LOG_DEBUG,
                 "\n\nWARNING: only IPv4 packets are supported in this demo (nDPI supports both IPv4 and IPv6), all other packets will be discarded\n\n");
      ipv4_warning_used = 1;
    }
    workflow->stats.total_discarded_bytes += header->len;
    return nproto;
  }

  frag_off = ntohs(iph->frag_off);
  proto = iph->protocol;

  if (header->caplen < ip_offset + ip_len) {
    static u_int8_t capture_size_warning_used = 0;
    if (capture_size_warning_used == 0) {
      if (!workflow->prefs.quiet_mode)
        NDPI_LOG(0, workflow->ndpi_struct, NDPI_LOG_DEBUG,
                 "\n\nWARNING: captured packet size is less than the actual packet size\n");
      capture_size_warning_used = 1;
    }
    workflow->stats.total_discarded_bytes += header->len;
    return nproto; // Not enough data for the full packet
  }