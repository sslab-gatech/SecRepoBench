iph_check:
  // Check if we have a complete IP header at the current offset
  if((ip_offset + sizeof(struct ndpi_iphdr)) > header->caplen) {
    static u_int8_t ip_header_trunc_warning_used = 0;
    if(ip_header_trunc_warning_used == 0) {
      if(!workflow->prefs.quiet_mode)
        NDPI_LOG(0, workflow->ndpi_struct, NDPI_LOG_DEBUG,
          "\n\nWARNING: captured packet smaller than IP header, discarding packet\n\n");
      ip_header_trunc_warning_used = 1;
    }
    workflow->stats.total_discarded_bytes += header->len;
    return(nproto);
  }

  iph = (struct ndpi_iphdr *)&packet[ip_offset];

  // Only continue if this is an IPv4 or IPv6 packet
  if(iph->version == IPVERSION) {
    frag_off = ntohs(iph->frag_off);
    proto = iph->protocol;
  } else if(iph->version == 6) {
    iph6 = (struct ndpi_ipv6hdr *)&packet[ip_offset];
    proto = iph6->ip6_hdr.ip6_un1_nxt;
    frag_off = 0;
  } else {
    goto v4_warning;
  }