if (recheck_type) goto ether_type_check;

/* Update the VLAN packet count in the workflow statistics if applicable */
if (vlan_packet)
  workflow->stats.vlan_count++;

/* Label for IP header checking and setting operations */
iph_check:

/* Verify the presence of a complete IP header at the current offset */
if ((header->caplen - ip_offset) < 20) {
  static u_int8_t short_ip_header_warning_used = 0;

  if (short_ip_header_warning_used == 0) {
    if (!workflow->prefs.quiet_mode)
      NDPI_LOG(0, workflow->ndpi_struct, NDPI_LOG_DEBUG,
               "WARNING: Short IP header (caplen: %u, ip_offset: %u)\n",
               header->caplen, ip_offset);
    short_ip_header_warning_used = 1;
  }

  workflow->stats.total_discarded_bytes += header->len;
  return(nproto);
}

/* Set the IP header pointer to the current packet offset */
iph = (struct ndpi_iphdr *)&packet[ip_offset];

/* Continue processing only if the packet is IPv4 or IPv6 */
if ((iph->version != 4) && (iph->version != 6))
  goto v4_warning;

/* Retrieve fragment offset from the IP header */
frag_off = ntohs(iph->frag_off);

/* Extract the IP protocol type from the IP header */
proto = iph->protocol;

/* Check if the captured packet size is less than the actual packet size */
if (header->caplen < header->len) {
  static u_int8_t capture_size_warning_used = 0;

  if (capture_size_warning_used == 0) {
    if (!workflow->prefs.quiet_mode)
      NDPI_LOG(0, workflow->ndpi_struct, NDPI_LOG_DEBUG,
               "\nWARNING: captured packet size is smaller than actual packet size\n");
    capture_size_warning_used = 1;
  }
}