iph_check:
  /* Verify the presence of a complete IP header at the current offset */
  if((ip_offset + sizeof(struct ndpi_iphdr)) > header->caplen) {
    workflow->stats.total_discarded_bytes += header->len;
    return(nproto); /* Incomplete IP header */
  }

  /* Set the IP header pointer to the current packet offset */
  iph = (struct ndpi_iphdr *)&packet[ip_offset];

  /* Continue processing only if the packet contains Ethernet with IP protocol */
  if(iph->version == IPVERSION) {
    ip_len = ((u_int16_t)iph->ihl * 4);

    /* Ensure the IP header length is valid */
    if(ip_len < sizeof(struct ndpi_iphdr) || (ip_offset + ip_len) > header->caplen) {
      workflow->stats.total_discarded_bytes += header->len;
      return(nproto); /* Invalid IP header length */
    }

    /* Retrieve fragment offset from the IP header */
    frag_off = ntohs(iph->frag_off);

    /* Extract the IP protocol type from the IP header */
    proto = iph->protocol;

    /* Check if the captured packet size is less than the actual packet size */
    if(header->caplen < header->len) {
      static u_int8_t capture_warning_used = 0;

      if(capture_warning_used == 0) {
        if(!workflow->prefs.quiet_mode)
          NDPI_LOG(0, workflow->ndpi_struct, NDPI_LOG_DEBUG,
                   "\n\nWARNING: captured packet size is smaller than actual packet size, some packets may be truncated\n\n");
        capture_warning_used = 1;
      }
    }
  } else {
    iph = NULL;
  }