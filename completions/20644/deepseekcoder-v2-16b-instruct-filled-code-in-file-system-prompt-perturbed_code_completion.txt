2dst_pkt_len += payload_len;
    } else {
      if(flow->entropy.dst2src_last_pkt_time.tv_sec) {
	ndpi_timer_sub(&when, &flow->entropy.dst2src_last_pkt_time, &tdiff);

	if(flow->iat_s_to_c
	   && (tdiff.tv_sec >= 0) /* Discard backward time */
	   ) {
	  u_int32_t ms = ndpi_timeval_to_milliseconds(tdiff);

	  ndpi_data_add_value(flow->iat_s_to_c, ms);
	}
      }

      ndpi_data_add_value(flow->pktlen_s_to_c, rawsize);
      flow->dst2src_packets++, flow->dst2src_bytes += rawsize, flow->dst2src_pkt_len += payload_len;
    }

    memcpy(&flow->entropy.src2dst_last_pkt_time, &when, sizeof(when));
    memcpy(&flow->entropy.dst2src_last_pkt_time, &when, sizeof(when));

    if(payload_len > 0) {
      ndpi_flow_update_byte_count(flow, payload, payload_len, src_to_dst_direction);
      ndpi_flow_update_byte_dist_mean_var(flow, payload, payload_len, src_to_dst_direction);
    }

    ndpi_clear_entropy_stats(flow);

    if(begin_or_end_tcp) {
      if(tcph->fin) {
	flow->entropy.src2dst_fin_count++;
	flow->entropy.dst2src_fin_count++;
      } else if(tcph->rst) {
	flow->entropy.src2dst_rst_count++;
	flow->entropy.dst2src_rst_count++;
      } else if(tcph->syn) {
	flow->entropy.src2dst_syn_count++;
	flow->entropy.dst2src_syn_count++;
      }
    }

    if(proto == IPPROTO_TCP) {
      if(tcph->fin || tcph->rst || tcph->syn) {
	flow->detection_completed = 1;
	flow->check_extra_packets = 1;
      }
    }

    if(enable_payload_analyzer) {
      ndpi_payload_analyzer(flow, src_to_dst_direction, payload, payload_len, flow->packet_id);
    }

    process_ndpi_collected_info(workflow, flow);

    if(flow->detection_completed && flow->check_extra_packets) {
      ndpi_free_flow_info_half(flow);
    }

    nproto.master_protocol = flow->detected_protocol.master_protocol;
    nproto.app_protocol = flow->detected_protocol.app_protocol;
  }

  return(nproto);
}

/* ****************************************************** */

void ndpi_process_packet(struct ndpi_workflow * workflow,
			 const u_int64_t time,
			 u_int16_t vlan_id,
			 ndpi_packet_tunnel tunnel_type,
			 const struct pcap_pkthdr *header,
			 const u_char *packet,
                         struct timeval when) {
  const struct ndpi_iphdr *iph = (const struct ndpi_iphdr *)packet;
  struct ndpi_ipv6hdr *iph6 = (struct ndpi_ipv6hdr *)(packet + sizeof(struct ndpi_iphdr));
  u_int16_t ip_offset = 0;
  u_int16_t ipsize = header->len;

  if(iph->version == IPVERSION) {
    ip_offset = sizeof(struct ndpi_iphdr);
  } else {
    ip_offset = sizeof(struct ndpi_ipv6hdr);
  }

  if(iph->version == IPVERSION && ipsize < ip_offset + 4)
    return;

  if(iph->version == IPVERSION && ipsize < ip_offset + 4 + iph->ihl * 4)
    return;

  if(iph->version == IPVERSION && ipsize < ntohs(iph->tot_len))
    return;

  if(iph->version == IPVERSION && (iph->frag_off & htons(0x1FFF)) != 0)
    return;

  if(iph->version == IPVERSION && ipsize < ip_offset + 4 + iph->ihl * 4 + 8)
    return;

  if(iph->version == IPVERSION && ipsize < ip_offset + 4 + iph->ihl * 4 + 8 + 8)
    return;

  if(iph->version == IPVERSION && ipsize < ip_offset + 4 + iph->ihl * 4 + 8 + 8 + 8)
    return;

  if(iph->version == IPVERSION && ipsize < ip_offset + 4 + iph->ihl * 4 + 8 + 8 + 8 + 8)
    return;

  if(iph->version == IPVERSION && ipsize < ip_offset + 4 + iph->ihl * 4 + 8 + 8 + 8 + 8 + 8)
    return;

  if(iph->version == IPVERSION && ipsize < ip_offset + 4 + iph->ihl * 4 + 8 + 8 + 8 + 8 + 8 + 8)
    return;

  if(iph->version == IPVERSION && ipsize < ip_offset + 4 + iph->ihl * 4 + 8 + 8 + 8 + 8 + 8 + 8 + 8)
    return;

  if(iph->version == IPVERSION && ipsize < ip_offset + 4 + iph->ihl * 4 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8)
    return;

  if(iph->version == IPVERSION && ipsize < ip_offset + 4 + iph->ihl * 4 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8)
    return;

  if(iph->version == IPVERSION && ipsize < ip_offset + 4 + iph->ihl * 4 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8)
    return;

  if(iph->version == IPVERSION && ipsize < ip_offset + 4 + iph->ihl * 4 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8)
    return;

  if(iph->version == IPVERSION && ipsize < ip_offset + 4 + iph->ihl * 4 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8)
    return;

  if(iph->version == IPVERSION && ipsize < ip_offset + 4 + iph->ihl * 4 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8)
    return;

  if(iph->version == IPVERSION && ipsize < ip_offset + 4 + iph->ihl * 4 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8)
    return;

  if(iph->version == IPVERSION && ipsize < ip_offset + 4 + iph->ihl * 4 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8)
    return;

  if(iph->version == IPVERSION && ipsize < ip_offset + 4 + iph->ihl * 4 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8)
    return;

  if(iph->version == IPVERSION && ipsize < ip_offset + 4 + iph->ihl * 4 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8)
    return;

  if(iph->version == IPVERSION && ipsize < ip_offset + 4 + iph->ihl * 4 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8)
    return;

  if(iph->version == IPVERSION && ipsize < ip_offset + 4 + iph->ihl * 4 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8)
    return;

  if(iph->version == IPVERSION && ipsize < ip_offset + 4 + iph->ihl * 4 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8)
    return;

  if(iph->version == IPVERSION && ipsize < ip_offset + 4 + iph->ihl * 4 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8)
    return;

  if(iph->version == IPVERSION && ipsize < ip_offset + 4 + iph->ihl * 4 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8)
    return;

  if(iph->version == IPVERSION && ipsize < ip_offset + 4 + iph->ihl * 4 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8)
    return;

  if(iph->version == IPVERSION && ipsize < ip_offset + 4 + iph->ihl * 4 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8)
    return;

  if(iph->version == IPVERSION && ipsize < ip_offset + 4 + iph->ihl * 4 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8)
    return;

  if(iph->version == IPVERSION && ipsize < ip_offset + 4 + iph->ihl * 4 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8)
    return;

  if(iph->version == IPVERSION && ipsize < ip_offset