if(recheck_type) goto ether_type_check;

if(vlan_packet) workflow->stats.vlan_count++;

iph_check:
  if(header->caplen < ip_offset + sizeof(struct ndpi_iphdr))
    return(nproto); /* Too short */

  iph = (struct ndpi_iphdr *)&packet[ip_offset];

  /* process only IPv4 and IPv6 packets */
  if(cprototype == ETH_P_IP) {
    frag_off = ntohs(iph->frag_off);
    proto = iph->protocol;
  } else if(cprototype == ETH_P_IPV6) {
    iph6 = (struct ndpi_ipv6hdr *)&packet[ip_offset];
    proto = iph6->ip6_hdr.ip6_un1_nxt;
    ip_len = sizeof(struct ndpi_ipv6hdr);
    iph = NULL;
  } else {
    workflow->stats.total_discarded_bytes += header->len;
    return(nproto);
  }

  if(header->caplen < header->len) {
    static u_int8_t cap_warning_used = 0;
    if(cap_warning_used == 0) {
      if(!workflow->prefs.quiet_mode)
        NDPI_LOG(0, workflow->ndpi_struct, NDPI_LOG_DEBUG, 
                "\n\nWARNING: packet capture size is smaller than packet size, DETECTION MIGHT NOT WORK CORRECTLY\n\n");
      cap_warning_used = 1;
    }
  }