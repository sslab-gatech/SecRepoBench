// Verify the presence of a complete IP header at the current offset.
  iph = (struct ndpi_iphdr *)&packet[ip_offset];

  // Set the IP header pointer to the current packet offset.
  if(header->caplen < (ip_offset + sizeof(struct ndpi_iphdr))) 
    return(nproto);

  // Continue processing only if the packet contains Ethernet with IP protocol.
  if(iph->version == IPVERSION) {
    // Retrieve fragment offset from the IP header and store it.
    frag_off = ntohs(iph->frag);

    // Extract the IP protocol type from the IP header.
    proto = iph->protocol;
  }

  // Check if the captured packet size is less than the actual packet size.
  if(header->caplen < header->len) {
    static u_int8_t warning_sent = 0;

    // Log a warning message if this is the first time encountering a capture size issue.
    if(!warning_sent) {
      if(!workflow->prefs.quiet_mode)
        NDPI_LOG(0, workflow->ndpi_struct, NDPI_LOG_DEBUG, "WARNING: captured packet size is smaller than the actual packet size\n");
      warning_sent = 1;
    }
  }

  // Label for IP header checking and setting operations.
  iph_check:
  // Update the VLAN packet count in the workflow statistics if applicable.
  if(vlan_packet)
    workflow->stats.vlan_count++;

  // If a recheck of the Ethernet type is needed, jump to the ether_type_check label.
  if(recheck_type)
    goto ether_type_check;