// load faces with their indices
faces = mesh->mFaces;
for (unsigned int i = 0; i < numFaces; ) {
    // Read face data from the buffer and parse the number of indices per face.
    // Ensure that the number of indices is valid, logging an error if not.
    // Allocate memory for the indices of each face based on the parsed index count.
    // Adjust the total face count if an invalid face is encountered.
    unsigned int idx;
    unsigned int numIndices = 0;
    while (car < end && *car!= '\n' && *car!= '\r') {
        SkipSpaces(&car);
        if (*car =='') {
            ++car;
            continue;
        }
        if (*car == '#') {
            break;
        }
        if (*car == 'L') {
            numIndices = 3;
            car += 1;
            break;
        }
        if (*car == 'Q') {
            numIndices = 4;
            car += 1;
            break;
        }
        ASSIMP_LOG_ERROR("OFF: Invalid face type");
        break;
    }
    if (numIndices == 0) {
        ASSIMP_LOG_ERROR("OFF: Invalid face type");
        break;
    }
    faces->mNumIndices = numIndices;
    faces->mIndices = new unsigned int[numIndices];
    for (unsigned int m = 0; m < numIndices; ++m) {
        SkipSpaces(&car);
        idx = strtoul10(car, &car);
        if (idx >= numVertices) {
            ASSIMP_LOG_ERROR("OFF: Vertex index is out of range");
            idx = numVertices - 1;
        }
        faces->mIndices[m] = idx;
    }
    ++i;
    ++faces;
}