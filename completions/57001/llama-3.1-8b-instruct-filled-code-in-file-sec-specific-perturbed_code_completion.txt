// load faces with their indices
faces = mesh->mFaces;
for (unsigned int i = 0; i < numFaces; ) {
    // Read face data from the buffer and parse the number of indices per face.
    // Ensure that the number of indices is valid, logging an error if not.
    // Allocate memory for the indices of each face based on the parsed index count.
    // Adjust the total face count if an invalid face is encountered.
    unsigned int idx;
    unsigned int numIndices = 0;
    bool validFace = true;
    do {
        // Read face data from the buffer and parse the number of indices per face.
        // Ensure that the number of indices is valid, logging an error if not.
        // Allocate memory for the indices of each face based on the parsed index count.
        // Adjust the total face count if an invalid face is encountered.
        if (car >= end - 1 || *car < '0' || *car > '9') {
            validFace = false;
            break;
        }
        numIndices = strtoul10(car, &car);
        if (numIndices == 0) {
            validFace = false;
            break;
        }
        if (numIndices > 3) {
            ASSIMP_LOG_ERROR("OFF: Number of indices per face is too high");
            validFace = false;
            break;
        }
        // Allocate memory for the indices of each face based on the parsed index count.
        faces->mIndices = new unsigned int[numIndices];
        for (unsigned int m = 0; m < numIndices; ++m) {
            SkipSpaces(&vertex_data_ptr);
            idx = strtoul10(vertex_data_ptr,&vertex_data_ptr);
            if (idx >= numVertices) {
                ASSIMP_LOG_ERROR("OFF: Vertex index is out of range");
                idx = numVertices - 1;
            }
            faces->mIndices[m] = idx;
        }
        faces++;
        i++;
    } while (validFace);
    if (!validFace) {
        delete[] faces->mIndices;
        faces--;
        i--;
    }
}