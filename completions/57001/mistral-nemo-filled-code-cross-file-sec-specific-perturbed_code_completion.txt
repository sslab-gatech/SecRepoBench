void InternReadFile(const std::string& pFile, aiScene* pScene, IOSystem* pIOHandler) {
    // ... (previous code)

    // allocate storage and copy the contents of the file to a memory buffer
    std::vector<char> mBuffer2;
    TextFileToBuffer(file.get(), mBuffer2);
    const char* buffer = &mBuffer2[0];

    // ... (rest of the code)

    // Proper OFF header parser. We only implement normal loading for now.
    bool hasTexCoord = false, hasNormals = false, hasColors = false;
    bool hasHomogenous = false, hasDimension = false;
    unsigned int dimensions = 3;
    const char* car = buffer;
    const char* end = buffer + mBuffer2.size();
    NextToken(&car, end);

    if (car < end - 2 && car[0] == 'S' && car[1] == 'T') {
        hasTexCoord = true; car += 2;
    }
    if (car < end - 1 && car[0] == 'C') {
        hasColors = true; car++;
    }
    if (car < end - 1 && car[0] == 'N') {
        hasNormals = true; car++;
    }
    if (car < end - 1 && car[0] == '4') {
        hasHomogenous = true; car++;
    }
    if (car < end - 1 && car[0] == 'n') {
        hasDimension = true; car++;
    }
    if (car < end - 3 && car[0] == 'O' && car[1] == 'F' && car[2] == 'F') {
        car += 3;
        NextToken(&car, end);
    } else {
        // in case there is no OFF header (which is allowed by the
        // specification...), then we might have unintentionally read an
        // additional dimension from the primitive count fields
        dimensions = 3;
        hasHomogenous = false;
        NextToken(&car, end);

        // at this point the next token should be an integer number
        if (car >= end - 1 || *car < '0' || *car > '9') {
            throw DeadlyImportError("OFF: Header is invalid");
        }
    }
    if (hasDimension) {
        dimensions = strtoul10(car, &car);
        NextToken(&car, end);
    }
    if (dimensions > 3) {
        throw DeadlyImportError("OFF: Number of vertex coordinates higher than 3 unsupported");
    }

    NextToken(&car, end);
    const unsigned int numVertices = strtoul10(car, &car);
    NextToken(&car, end);
    const unsigned int numFaces = strtoul10(car, &car);
    NextToken(&car, end);
    const unsigned int numEdges = strtoul10(car, &car);
    NextToken(&car, end);

    if (!numVertices) {
        throw DeadlyImportError("OFF: There are no valid vertices");
    }
    if (!numFaces) {
        throw DeadlyImportError("OFF: There are no valid faces");
    }

    pScene->mNumMeshes = 1;
    pScene->mMeshes = new aiMesh*[ pScene->mNumMeshes ];

    aiMesh* mesh = new aiMesh();
    pScene->mMeshes[0] = mesh;

    mesh->mNumFaces = numFaces;
    aiFace* faces = new aiFace[mesh->mNumFaces];
    mesh->mFaces = faces;

    mesh->mNumVertices = numVertices;
    mesh->mVertices = new aiVector3D[mesh->mNumVertices];
    mesh->mNormals = hasNormals ? new aiVector3D[mesh->mNumVertices] : nullptr;
    mesh->mColors[0] = hasColors ? new aiColor4D[mesh->mNumVertices] : nullptr;

    if (hasTexCoord) {
        mesh->mNumUVComponents[0] = 2;
        mesh->mTextureCoords[0] = new aiVector3D[mesh->mNumVertices];
    }
    char line[4096];
    buffer = car;
    const char *vertex_data_ptr = car;

    // now read all vertex lines
    for (unsigned int i = 0; i < numVertices; ++i) {
        if(!GetNextLine(buffer, line)) {
            ASSIMP_LOG_ERROR("OFF: The number of verts in the header is incorrect");
            break;
        }
        aiVector3D& v = mesh->mVertices[i];
        vertex_data_ptr = line;

        // helper array to write a for loop over possible dimension values
        ai_real* vec[3] = {&v.x, &v.y, &v.z};

        // stop at dimensions: this allows loading 1D or 2D coordinate vertices
        for (unsigned int dim = 0; dim < dimensions; ++dim ) {
            SkipSpaces(&vertex_data_ptr);
            vertex_data_ptr = fast_atoreal_move<ai_real>(vertex_data_ptr, *vec[dim]);
        }

        // if has homogeneous coordinate, divide others by this one
        if (hasHomogenous) {
            SkipSpaces(&vertex_data_ptr);
            ai_real w = 1.;
            vertex_data_ptr = fast_atoreal_move<ai_real>(vertex_data_ptr, w);
            for (unsigned int dim = 0; dim < dimensions; ++dim ) {
                *(vec[dim]) /= w;
            }
        }

        // read optional normals
        if (hasNormals) {
            aiVector3D& n = mesh->mNormals[i];
            SkipSpaces(&vertex_data_ptr);
            vertex_data_ptr = fast_atoreal_move<ai_real>(vertex_data_ptr,(ai_real&)n.x);
            SkipSpaces(&vertex_data_ptr);
            vertex_data_ptr = fast_atoreal_move<ai_real>(vertex_data_ptr,(ai_real&)n.y);
            SkipSpaces(&vertex_data_ptr);
            fast_atoreal_move<ai_real>(vertex_data_ptr,(ai_real&)n.z);
        }

        // reading colors is a pain because the specification says it can be
        // integers or floats, and any number of them between 1 and 4 included,
        // until the next comment or end of line
        // in theory should be testing type !
        if (hasColors) {
            aiColor4D& c = mesh->mColors[0][i];
            SkipSpaces(&vertex_data_ptr);
            vertex_data_ptr = fast_atoreal_move<ai_real>(vertex_data_ptr,(ai_real&)c.r);
            if (*vertex_data_ptr != '#' && *vertex_data_ptr != '\n' && *vertex_data_ptr != '\r') {
                SkipSpaces(&vertex_data_ptr);
                vertex_data_ptr = fast_atoreal_move<ai_real>(vertex_data_ptr,(ai_real&)c.g);
            } else {
                c.g = 0.;
            }
            if (*vertex_data_ptr != '#' && *vertex_data_ptr != '\n' && *vertex_data_ptr != '\r') {
                SkipSpaces(&vertex_data_ptr);
                vertex_data_ptr = fast_atoreal_move<ai_real>(vertex_data_ptr,(ai_real&)c.b);
            } else {
                c.b = 0.;
            }
            if (*vertex_data_ptr != '#' && *vertex_data_ptr != '\n' && *vertex_data_ptr != '\r') {
                SkipSpaces(&vertex_data_ptr);
                vertex_data_ptr = fast_atoreal_move<ai_real>(vertex_data_ptr,(ai_real&)c.a);
            } else {
                c.a = 1.;
            }
        }
        if (hasTexCoord) {
            aiVector3D& t = mesh->mTextureCoords[0][i];
            SkipSpaces(&vertex_data_ptr);
            vertex_data_ptr = fast_atoreal_move<ai_real>(vertex_data_ptr,(ai_real&)t.x);
            SkipSpaces(&vertex_data_ptr);
            vertex_data_ptr = fast_atoreal_move<ai_real>(vertex_data_ptr,(ai_real&)t.y);
            t.y = 1.f - t.y; // DX to OGL
        }
        if (hasTexCoord) {
            aiVector3D& t = mesh->mTextureCoords[0][i];
            SkipSpaces(&vertex_data_ptr);
            vertex_data_ptr = fast_atoreal_move<ai_real>(vertex_data_ptr,(ai_real&)t.x);
            SkipSpaces(&vertex_data_ptr);
            vertex_data_ptr = fast_atoreal_move<ai_real>(vertex_data_ptr,(ai_real&)t.y);
            t.y = 1.f - t.y; // DX to OGL
        }
    }

    // load faces with their indices
    faces = mesh->mFaces;
    for (unsigned int i = 0; i < numFaces; ) {
        // Read face data from the buffer and parse the number of indices per face.
        // Ensure that the number of indices is valid, logging an error if not.
        // Allocate memory for the indices of each face based on the parsed index count.
        // Adjust the total face count if an invalid face is encountered.
        // <MASK>
        for (unsigned int m = 0; m < faces->mNumIndices;++m) {
            SkipSpaces(&vertex_data_ptr);
            idx = strtoul10(vertex_data_ptr,&vertex_data_ptr);
            if (idx >= numVertices) {
                ASSIMP_LOG_ERROR("OFF: Vertex index is out of range");
                idx = numVertices - 1;
            }
            faces->mIndices[m] = idx;
        }
        ++i;
        ++faces;
    }

    // generate the output node graph
    pScene->mRootNode = new aiNode();
    pScene->mRootNode->mName.Set("<OFFRoot>");
    pScene->mRootNode->mNumMeshes = 1;
    pScene->mRootNode->mMeshes = new unsigned int[ pScene->mRootNode->mNumMeshes ];
    pScene->mRootNode->mMeshes[0] = 0;

    // generate a default material
    pScene->mNumMaterials = 1;
    pScene->mMaterials = new aiMaterial*[pScene->mNumMaterials];
    aiMaterial* pcMat = new aiMaterial();

    aiColor4D clr( ai_real( 0.6 ), ai_real( 0.6 ), ai_real( 0.6 ), ai_real( 1.0 ) );
    pcMat->AddProperty(&clr,1,AI_MATKEY_COLOR_DIFFUSE);
    pScene->mMaterials[0] = pcMat;

    const int twosided = 1;
    pcMat->AddProperty(&twosided, 1, AI_MATKEY_TWOSIDED);
}