for (i = xd - ydigits; i != SIZE_MAX; i--) {
  // Calculate quotient digit
  mp_limb_t q_digit = 0;
  if (i + ydigits < xd) {
    mp_dbl_limb n = ((mp_dbl_limb)x.p[i + ydigits] << DIG_SIZE) | x.p[i + ydigits - 1];
    q_digit = (mp_limb_t)(n / z);
  } else if (i + ydigits - 1 < xd) {
    q_digit = x.p[i + ydigits - 1] / (mp_limb_t)z;
  }
  
  // Perform subtraction
  mp_limb_t borrow = 0;
  for (size_t j = 0; j < ydigits; j++) {
    if (i + j >= xd) break;
    mp_dbl_limb prod = (mp_dbl_limb)y.p[j] * q_digit + borrow;
    mp_limb_t subtrahend = (mp_limb_t)prod;
    borrow = (mp_limb_t)(prod >> DIG_SIZE);
    if (x.p[i + j] < subtrahend) {
      borrow++;
    }
    x.p[i + j] -= subtrahend;
  }
  
  // Adjust if necessary
  if (borrow > 0 && i + ydigits < xd) {
    q_digit--;
    mp_limb_t carry = 0;
    for (size_t j = 0; j < ydigits; j++) {
      if (i + j >= xd) break;
      mp_dbl_limb sum = (mp_dbl_limb)x.p[i + j] + y.p[j] + carry;
      x.p[i + j] = (mp_limb_t)sum;
      carry = (mp_limb_t)(sum >> DIG_SIZE);
    }
    if (i + ydigits < xd) {
      x.p[i + ydigits] += carry - borrow;
    }
  }
  
  // Store quotient digit
  if (i < q.sz) {
    q.p[i] = q_digit;
  }
}