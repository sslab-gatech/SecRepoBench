for (i = xd - ydigits; i != (size_t)-1; i--) {
    mp_limb qj;
    
    // Estimate the quotient
    if (i + ydigits < xd) {
      if (x.p[i + ydigits] == y.p[ydigits-1]) {
        qj = ~(mp_limb)0;
      } else {
        mp_dbl_limb num = (((mp_dbl_limb)x.p[i + ydigits]) << DIG_SIZE) | x.p[i + ydigits - 1];
        qj = num / z;
      }
    } else if (i + ydigits - 1 < xd) {
      qj = x.p[i + ydigits - 1] / y.p[ydigits-1];
    } else {
      qj = 0;
    }
    
    // Multiply and subtract
    mp_limb borrow = 0;
    for (size_t j = 0; j < ydigits; j++) {
      mp_dbl_limb prod = (mp_dbl_limb)qj * y.p[j];
      mp_limb lo = prod & DIG_MASK;
      mp_limb hi = prod >> DIG_SIZE;
      
      if (x.p[i + j] < lo + borrow) {
        x.p[i + j] = (((mp_dbl_limb)1 << DIG_SIZE) + x.p[i + j] - lo - borrow) & DIG_MASK;
        borrow = hi + 1;
      } else {
        x.p[i + j] = x.p[i + j] - lo - borrow;
        borrow = hi;
      }
    }
    
    // Adjust the quotient if we over-subtracted
    if (borrow) {
      qj--;
      
      // Add back the divisor
      mp_limb carry = 0;
      for (size_t j = 0; j < ydigits; j++) {
        mp_dbl_limb sum = (mp_dbl_limb)x.p[i + j] + y.p[j] + carry;
        x.p[i + j] = sum & DIG_MASK;
        carry = sum >> DIG_SIZE;
      }
    }
    
    q.p[i] = qj;
  }
  q.sz = xd;