for (i = xd; i >= ydigits; i--) {
    mp_dbl_limb qdigit = 0;
    size_t j = i - ydigits;
    mp_dbl_limb num = (mp_dbl_limb)x.p[i] << DIG_SIZE | x.p[i-1];
    if (x.p[i] != z) {
      qdigit = num / (z + 1);
      if (qdigit >= (1UL << DIG_SIZE))
        qdigit = (1UL << DIG_SIZE) - 1;
    }

    while (1) {
      mp_dbl_limb prod = qdigit * z;
      if (prod <= (num | x.p[i-2]))
        break;
      qdigit--;
    }

    mp_limb carry = 0;
    for (size_t k=0; k<ydigits; k++) {
      mp_dbl_limb p = (mp_dbl_limb)qdigit * y.p[k];
      mp_limb u = p >> DIG_SIZE;
      mp_limb l = p;
      if (l > x.p[j+k] || (x.p[j+k] - l < carry)) {
        u++;
        carry = 1;
      }
      else {
        carry = 0;
      }
      x.p[j+k] = x.p[j+k] - l - carry;
      carry = u + carry;
    }

    if (carry > x.p[j+ydigits]) {
      qdigit--;
      carry = 0;
      for (size_t k=0; k<ydigits; k++) {
        mp_dbl_limb s = x.p[j+k] + y.p[k] + carry;
        carry = s >> DIG_SIZE;
        x.p[j+k] = s;
      }
    }
    x.p[j+ydigits] -= carry;

    q.p[j] = qdigit;
  }