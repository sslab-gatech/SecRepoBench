/* classical long division (Knuth's Algorithm D) */
  /* ensure one extra limb at the top of x for ease of calculation */
  x.p[xd] = 0;

  /* main loop to calculate each quotient digit */
  for (i = xd; i-- > ydigits;) {
    /* estimate the quotient digit from the top two limbs of x */
    mp_dbl_limb top = ((mp_dbl_limb)x.p[i+1] << DIG_SIZE) + x.p[i];
    mp_dbl_limb qhat = top / z;
    mp_dbl_limb rhat = top % z;

    if (qhat > DIG_MASK) qhat = DIG_MASK;

    /* refine the estimate if it's too large */
    while (qhat * (mp_dbl_limb)y.p[ydigits - 2]
           > ((rhat << DIG_SIZE) + (mp_dbl_limb)x.p[i - 1])) {
      qhat--;
      rhat += z;
      if (rhat >= DIG_BASE) break;
    }

    /* multiply y by qhat and subtract from the corresponding part of x */
    mp_dbl_limb carry = 0;
    for (size_t j = 0; j < ydigits; j++) {
      mp_dbl_limb mul = (mp_dbl_limb)qhat * (mp_dbl_limb)y.p[j] + carry;
      mp_limb ml = LOW(mul);
      carry = HIGH(mul);

      mp_dbl_limb sub = (mp_dbl_limb)x.p[i + j] - ml;
      x.p[i + j] = LOW(sub);
      carry += (mp_limb)((sub >> DIG_SIZE) & 1); /* borrow out? */
    }
    mp_dbl_limb sub = (mp_dbl_limb)x.p[i + ydigits] - carry;
    x.p[i + ydigits] = LOW(sub);

    /* if we subtracted too much, fix it by adding y back */
    if ((sub >> DIG_SIZE) & 1) {
      qhat--;
      carry = 0;
      for (size_t j = 0; j < ydigits; j++) {
        mp_dbl_limb add = (mp_dbl_limb)x.p[i + j] + (mp_dbl_limb)y.p[j] + carry;
        x.p[i + j] = LOW(add);
        carry = HIGH(add);
      }
      x.p[i + ydigits] += (mp_limb)carry;
    }

    /* store the computed digit into q */
    q.p[i - (ydigits - 1)] = (mp_limb)qhat;
  }