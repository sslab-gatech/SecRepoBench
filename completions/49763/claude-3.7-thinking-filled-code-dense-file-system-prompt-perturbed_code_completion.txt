for (i = xd - ydigits; i != (size_t)-1; i--) {
  // Estimate the quotient digit
  mp_limb qhat;
  mp_limb rhat;
  if (i+ydigits < xd && x.p[i+ydigits] == y.p[ydigits-1]) {
    qhat = (1UL << DIG_SIZE) - 1;
    rhat = x.p[i+ydigits-1] + y.p[ydigits-1];
  } else if (i+ydigits < xd) {
    mp_dbl_limb dividend = ((mp_dbl_limb)x.p[i+ydigits] << DIG_SIZE) | x.p[i+ydigits-1];
    qhat = (mp_limb)(dividend / y.p[ydigits-1]);
    rhat = (mp_limb)(dividend % y.p[ydigits-1]);
  } else {
    qhat = x.p[i+ydigits-1] / y.p[ydigits-1];
    rhat = x.p[i+ydigits-1] % y.p[ydigits-1];
  }
  
  // Adjust quotient digit if necessary
  while (qhat >= (1UL << DIG_SIZE) || 
         (qhat * y.p[ydigits-2]) > (((mp_dbl_limb)rhat << DIG_SIZE) | x.p[i+ydigits-2])) {
    qhat--;
    rhat += y.p[ydigits-1];
    if (rhat >= (1UL << DIG_SIZE)) break;
  }
  
  // Multiply and subtract
  mp_dbl_limb borrow = 0;
  for (size_t j = 0; j < ydigits; j++) {
    mp_dbl_limb product = (mp_dbl_limb)qhat * y.p[j];
    mp_dbl_limb diff = (mp_dbl_limb)x.p[i+j] - (product & ((1UL << DIG_SIZE) - 1)) - borrow;
    x.p[i+j] = (mp_limb)(diff & ((1UL << DIG_SIZE) - 1));
    borrow = (product >> DIG_SIZE) + ((diff >> DIG_SIZE) & 1);
  }
  
  // If we've subtracted too much, add back
  if (borrow) {
    qhat--;
    mp_dbl_limb carry = 0;
    for (size_t j = 0; j < ydigits; j++) {
      mp_dbl_limb sum = (mp_dbl_limb)x.p[i+j] + y.p[j] + carry;
      x.p[i+j] = (mp_limb)(sum & ((1UL << DIG_SIZE) - 1));
      carry = sum >> DIG_SIZE;
    }
  }
  
  q.p[i] = qhat;
}