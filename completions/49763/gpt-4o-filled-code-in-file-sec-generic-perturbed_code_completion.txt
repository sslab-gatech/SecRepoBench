mpz_set(mrb, rr, &x);
  for (i = xd - ydigits; i != (size_t)-1; i--) {
    mp_dbl_limb qhat = ((mp_dbl_limb)x.p[i + ydigits] << DIG_SIZE) | x.p[i + ydigits - 1];
    qhat /= z;
    if (qhat > DIG_MASK) qhat = DIG_MASK;

    mp_dbl_limb k = 0;
    for (size_t j = 0; j < ydigits; j++) {
      k += qhat * y.p[j];
      if (x.p[i + j] < (mp_limb)k) {
        x.p[i + j] = (mp_limb)(DIG_BASE + x.p[i + j] - k);
        k = HIGH(k) + 1;
      } else {
        x.p[i + j] -= (mp_limb)k;
        k = HIGH(k);
      }
    }
    if (x.p[i + ydigits] < (mp_limb)k) {
      x.p[i + ydigits] = (mp_limb)(DIG_BASE + x.p[i + ydigits] - k);
      k = 1;
    } else {
      x.p[i + ydigits] -= (mp_limb)k;
      k = 0;
    }

    q.p[i] = (mp_limb)qhat;
    if (k) {
      q.p[i]--;
      k = 0;
      for (size_t j = 0; j < ydigits; j++) {
        k += (mp_dbl_limb)x.p[i + j] + y.p[j];
        x.p[i + j] = LOW(k);
        k = HIGH(k);
      }
      x.p[i + ydigits] += (mp_limb)k;
    }
  }