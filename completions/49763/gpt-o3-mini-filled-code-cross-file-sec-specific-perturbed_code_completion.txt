{
  size_t n = digits(&y);
  size_t m = xd - n;
  const mp_dbl_limb BASE = ((mp_dbl_limb)1 << DIG_SIZE);
  size_t j;
  /* Loop over quotient digits from high-order to low-order */
  for (i = m + 1; i-- > 0; ) {
    mp_dbl_limb dividend = ((mp_dbl_limb)x.p[i+n] << DIG_SIZE) | x.p[i+n-1];
    mp_limb qhat = dividend / z;
    mp_dbl_limb rhat = dividend % z;
    if (qhat >= BASE)
      qhat = BASE - 1;
    if (n > 1) {
      while ((mp_dbl_limb)qhat * y.p[n-2] > ((rhat << DIG_SIZE) | x.p[i+n-2])) {
        qhat--;
        rhat += z;
        if (rhat >= BASE)
          break;
      }
    }
    mp_limb borrow = 0;
    for (j = 0; j < n; j++) {
      mp_dbl_limb prod = (mp_dbl_limb)qhat * y.p[j] + borrow;
      mp_limb prod_lo = (mp_limb)(prod & (BASE - 1));
      borrow = (mp_limb)(prod >> DIG_SIZE);
      if (x.p[i+j] < prod_lo) {
        x.p[i+j] = x.p[i+j] + (mp_limb)BASE - prod_lo;
        borrow++;
      }
      else {
        x.p[i+j] -= prod_lo;
      }
    }
    if (x.p[i+n] < borrow) {
      qhat--;
      mp_limb carry = 0;
      for (j = 0; j < n; j++) {
        mp_dbl_limb sum = (mp_dbl_limb)x.p[i+j] + y.p[j] + carry;
        if (sum >= BASE) {
          x.p[i+j] = (mp_limb)(sum - BASE);
          carry = 1;
        }
        else {
          x.p[i+j] = (mp_limb)sum;
          carry = 0;
        }
      }
      x.p[i+n] = x.p[i+n] + carry - borrow;
    }
    else {
      x.p[i+n] -= borrow;
    }
    q.p[i] = qhat;
  }
  q.sz = m + 1;
}