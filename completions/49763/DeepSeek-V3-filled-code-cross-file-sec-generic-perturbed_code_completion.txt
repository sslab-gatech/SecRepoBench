for (i = xd; i > ydigits; i--) {
    mp_dbl_limb qhat;
    mp_dbl_limb rhat;
    mp_limb qhat_limb;
    size_t j = i - ydigits - 1;

    if (x.p[i-1] == y.p[ydigits-1]) {
      qhat = (mp_dbl_limb)1 << DIG_SIZE;
    } else {
      qhat = ((mp_dbl_limb)x.p[i-1] << DIG_SIZE) + x.p[i-2];
      qhat /= y.p[ydigits-1];
    }

    for (;;) {
      if (qhat >= ((mp_dbl_limb)1 << DIG_SIZE)) {
        qhat--;
        continue;
      }

      rhat = ((mp_dbl_limb)x.p[i-1] << DIG_SIZE) + x.p[i-2] - qhat * y.p[ydigits-1];
      if (rhat < ((mp_dbl_limb)1 << DIG_SIZE) && (ydigits == 1 || rhat < y.p[ydigits-2])) {
        break;
      }
      qhat++;
    }

    qhat_limb = (mp_limb)qhat;
    if (qhat_limb != 0) {
      mp_limb carry = 0;
      for (size_t k = 0; k < ydigits; k++) {
        mp_dbl_limb z = (mp_dbl_limb)y.p[k] * qhat_limb + carry;
        carry = z >> DIG_SIZE;
        mp_limb z_limb = (mp_limb)z;
        if (x.p[j+k] < z_limb) {
          x.p[j+k] = (x.p[j+k] + ((mp_limb)1 << DIG_SIZE)) - z_limb;
          carry++;
        } else {
          x.p[j+k] -= z_limb;
        }
      }
      if (x.p[j+ydigits] < carry) {
        x.p[j+ydigits] = (x.p[j+ydigits] + ((mp_limb)1 << DIG_SIZE)) - carry;
        qhat_limb--;
        carry = 1;
        for (size_t k = 0; k < ydigits; k++) {
          mp_dbl_limb z = (mp_dbl_limb)y.p[k] + x.p[j+k] + carry;
          x.p[j+k] = (mp_limb)z;
          carry = z >> DIG_SIZE;
        }
      } else {
        x.p[j+ydigits] -= carry;
      }
    }
    q.p[j] = qhat_limb;
  }