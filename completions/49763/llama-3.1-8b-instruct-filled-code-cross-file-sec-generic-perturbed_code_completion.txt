// This code block implements the division of multi-precision integers using a long division algorithm.
// It uses the following steps:
// 1. Determine the number of digits in the quotient.
// 2. Perform the division by repeatedly subtracting the divisor from the dividend.
// 3. Update the quotient and remainder accordingly.

// Determine the number of digits in the quotient.
size_t qdigits = xd - ydigits;

// Perform the division by repeatedly subtracting the divisor from the dividend.
for (i = 0; i < qdigits; i++) {
  // Subtract the divisor from the dividend.
  mp_dbl_limb z = x.p[xd-1-i];
  if (z < y.p[ydigits-1]) {
    // If the dividend is less than the divisor, set the current digit of the quotient to 0.
    q.p[qdigits-1-i] = 0;
  }
  else {
    // Otherwise, subtract the divisor from the dividend and set the current digit of the quotient to 1.
    z -= y.p[ydigits-1];
    q.p[qdigits-1-i] = 1;
  }

  // Update the dividend and the remainder.
  ulimb *xptr = x.p + xd - 1 - i;
  ulimb *yptr = y.p + ydigits - 1;
  for (size_t j = ydigits - 1; j >= 0; j--) {
    if (xptr[j] < yptr[j]) {
      // If the current digit of the dividend is less than the current digit of the divisor, borrow from the next digit.
      xptr[j] += x.p[j + 1] * 2;
      xptr[j + 1]--;
    }
    xptr[j] -= yptr[j];
  }
}

// Update the quotient and remainder.
trim(&q);
mpz_move(mrb, qq, &q);
urshift(mrb, rr, &x, ns);