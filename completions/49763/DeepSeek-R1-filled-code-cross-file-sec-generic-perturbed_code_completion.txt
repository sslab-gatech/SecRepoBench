for (i = xd - ydigits + 1; i-- > 0; ) {
    size_t j = i + ydigits;
    mp_dbl_limb num = ((j < x.sz ? (mp_dbl_limb)x.p[j] : 0) << DIG_SIZE) | x.p[j-1];
    mp_limb qhat = (mp_limb)(num / z);
    mp_limb rhat = (mp_limb)(num % z);

    while (qhat >= DIG_SIZE || (ydigits > 1 && (mp_dbl_limb)qhat * y.p[ydigits-2] > ((mp_dbl_limb)rhat << DIG_SIZE) | x.p[j-2])) {
      if (--qhat, (rhat += z) >= (mp_dbl_limb)1 << DIG_SIZE) break;
    }

    mp_limb borrow = 0;
    for (size_t k = 0; k < ydigits; k++) {
      mp_dbl_limb p = (mp_dbl_limb)qhat * y.p[k];
      mp_limb lo = (mp_limb)p;
      mp_limb hi = p >> DIG_SIZE;

      mp_limb sub = lo + borrow;
      borrow = (sub < lo);
      if (x.p[i + k] < sub) {
        x.p[i + k] += (1UL << DIG_SIZE) - sub;
        borrow += 1;
      }
      else {
        x.p[i + k] -= sub;
      }
      borrow += hi;
    }

    if (borrow) {
      qhat--;
      mp_limb carry = 0;
      for (size_t k = 0; k < ydigits; k++) {
        mp_dbl_limb sum = x.p[i + k] + y.p[k] + carry;
        x.p[i + k] = (mp_limb)sum;
        carry = sum >> DIG_SIZE;
      }
    }

    q.p[i] = qhat;
  }