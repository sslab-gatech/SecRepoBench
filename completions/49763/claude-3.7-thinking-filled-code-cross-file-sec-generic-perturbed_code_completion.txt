for (i = xd - ydigits; i != SIZE_MAX; i--) {
  // Estimate quotient digit based on the highest digits
  mp_dbl_limb qhat;
  if (i + ydigits < xd && x.p[i+ydigits] == y.p[ydigits-1]) {
    qhat = (1ULL << DIG_SIZE) - 1;
  }
  else if (i + ydigits < xd) {
    qhat = ((mp_dbl_limb)x.p[i+ydigits] << DIG_SIZE | x.p[i+ydigits-1]) / z;
    if (qhat > ((1ULL << DIG_SIZE) - 1)) {
      qhat = (1ULL << DIG_SIZE) - 1;
    }
  }
  else {
    qhat = x.p[i+ydigits-1] / z;
  }
  
  // Multiply divisor by quotient digit and subtract from dividend
  mp_dbl_limb borrow = 0;
  for (size_t j = 0; j < ydigits; j++) {
    mp_dbl_limb prod = qhat * y.p[j] + borrow;
    mp_limb subtrahend = prod & ((1ULL << DIG_SIZE) - 1);
    borrow = prod >> DIG_SIZE;
    
    if (x.p[i+j] < subtrahend) {
      x.p[i+j] += (1ULL << DIG_SIZE) - subtrahend;
      borrow++;
    }
    else {
      x.p[i+j] -= subtrahend;
    }
  }
  
  // Process borrow from the highest digit
  if (i + ydigits < xd) {
    if (x.p[i+ydigits] < borrow) {
      x.p[i+ydigits] += (1ULL << DIG_SIZE) - borrow;
      borrow = 1;
    }
    else {
      x.p[i+ydigits] -= borrow;
      borrow = 0;
    }
  }
  
  // Store quotient digit
  q.p[i] = qhat;
  
  // If quotient digit was too large, adjust
  if (borrow > 0) {
    q.p[i]--;
    
    // Add divisor back to the remainder
    mp_dbl_limb carry = 0;
    for (size_t j = 0; j < ydigits; j++) {
      mp_dbl_limb sum = x.p[i+j] + y.p[j] + carry;
      x.p[i+j] = sum & ((1ULL << DIG_SIZE) - 1);
      carry = sum >> DIG_SIZE;
    }
    
    if (i + ydigits < xd) {
      x.p[i+ydigits] += carry;
    }
  }
}

q.sz = xd - ydigits + 1;