{
  size_t n = ydigits;           /* number of digits in divisor (normalized) */
  size_t m = xd - n;            /* number of quotient digits */
  mp_limb base = (mp_limb)1 << DIG_SIZE;
  /* Loop from most significant quotient digit down to 0 */
  for (i = m + 1; i-- > 0; ) {
    mp_dbl_limb rhat;
    mp_limb qhat;
    size_t j;
    /* Form the trial dividend: combine x.p[i+n] (or 0 if i+n equals xd) and x.p[i+n-1] */
    mp_limb hi = (i + n < xd) ? x.p[i + n] : 0;
    rhat = (((mp_dbl_limb)hi) << DIG_SIZE) | x.p[i + n - 1];
    qhat = (mp_limb)(rhat / z);
    if (qhat >= base)
      qhat = base - 1;

    /* Multiply divisor by qhat and subtract from x */
    mp_dbl_limb carry = 0;
    for (j = 0; j < n; j++) {
      mp_dbl_limb prod = (mp_dbl_limb)qhat * y.p[j] + carry;
      mp_limb prod_low = (mp_limb)(prod & (base - 1));
      carry = prod >> DIG_SIZE;
      if (x.p[i + j] < prod_low) {
        x.p[i + j] = (x.p[i + j] + base) - prod_low;
        carry++;
      }
      else {
        x.p[i + j] -= prod_low;
      }
    }

    /* Check if subtraction borrowed from the next digit */
    if (x.p[i + n] < (mp_limb)carry) {
      /* qhat was too high; adjust */
      qhat--;
      mp_limb c = 0;
      for (j = 0; j < n; j++) {
        mp_limb sum = x.p[i + j] + y.p[j] + c;
        if (sum >= base) {
          sum -= base;
          c = 1;
        }
        else {
          c = 0;
        }
        x.p[i + j] = sum;
      }
      x.p[i + n] += c;
    }
    q.p[i] = qhat;
  }
}