{
  mp_dbl_limb base = ((mp_dbl_limb)1 << DIG_SIZE);
  /* Initialize quotient digits to zero */
  for (size_t j = 0; j < xd; j++) {
    q.p[j] = 0;
  }

  /* Perform long division */
  for (i = xd; i-- > ydigits - 1; ) {
    mp_dbl_limb hi = (i + 1 < xd) ? x.p[i + 1] : 0;
    mp_dbl_limb lo = x.p[i];
    mp_dbl_limb w = (hi << DIG_SIZE) + lo;
    mp_dbl_limb qhat = w / z;
    mp_dbl_limb rhat = w % z;

    /* Refine guess if it's too large */
    if (qhat > base - 1) qhat = base - 1;
    while ((ydigits > 1) &&
           (qhat * y.p[ydigits - 2] > (rhat << DIG_SIZE) + (i ? x.p[i - 1] : 0))) {
      qhat--;
      rhat += z;
      if (rhat >= base) break;
    }

    /* Multiply and subtract */
    {
      mp_dbl_limb carry = 0;
      for (size_t j = 0; j < ydigits; j++) {
        mp_dbl_limb mul = (mp_dbl_limb)qhat * y.p[j] + carry;
        mp_limb sub = x.p[i - (ydigits - 1) + j];
        mp_dbl_limb diff = (mp_dbl_limb)sub - (mul & (base - 1));
        x.p[i - (ydigits - 1) + j] = (mp_limb)(diff & (base - 1));
        carry = (mul >> DIG_SIZE) + ((diff >> DIG_SIZE) & 1);
      }

      /* If we subtracted too much, adjust */
      if ((i + 1 < xd) && (x.p[i + 1] < carry)) {
        qhat--;
        mp_dbl_limb sum = 0;
        for (size_t j = 0; j < ydigits; j++) {
          sum = (mp_dbl_limb)x.p[i - (ydigits - 1) + j] + y.p[j] + (sum >> DIG_SIZE);
          x.p[i - (ydigits - 1) + j] = (mp_limb)(sum & (base - 1));
        }
        x.p[i + 1] += (mp_limb)(sum >> DIG_SIZE);
      }
    }

    q.p[i - (ydigits - 1)] = (mp_limb)qhat;
  }
}