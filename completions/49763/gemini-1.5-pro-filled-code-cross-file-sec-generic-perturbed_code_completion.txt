for (i = xd - ydigits; i >= 0; i--) {
    mp_dbl_limb qhat;
    mp_limb rhat;

    if (ydigits+i >= xd) {
      q.p[i] = 0;
      continue;
    }
    /* estimate */
    mp_dbl_limb num = ((mp_dbl_limb)x.p[ydigits+i] << DIG_SIZE) | x.p[ydigits+i-1];
    qhat = num / z;
    rhat = num % z;

    if (qhat >= BASE) {
      qhat--;
      rhat += z;
    }

    /* adjust if too large */
    while (1) {
      mp_dbl_limb t;
      mp_limb yn;
      if (ydigits+i-2 < x.sz && (yn = y.p[ydigits-2])) {
        t = ((mp_dbl_limb)rhat << DIG_SIZE) | x.p[ydigits+i-2];
        if (qhat*yn > t) {
          qhat--;
          rhat += z;
          continue;
        }
      }
      break;
    }
    /* multiply and subtract */
    mp_dbl_limb carry = 0;
    for (size_t j = 0; j < ydigits; j++) {
      mp_dbl_limb p = qhat * y.p[j] + carry;
      carry = p >> DIG_SIZE;
      p = x.p[i+j] - p;
      if (p > x.p[i+j])
        carry++;
      x.p[i+j] = p;
    }
    x.p[ydigits+i] -= carry;
    q.p[i] = qhat;
    if (x.p[ydigits+i] > 0) { /* too much subtracted */
      q.p[i]--;
      carry = 0;
      for (size_t j = 0; j < ydigits; j++) {
        mp_dbl_limb p = x.p[i+j] + y.p[j] + carry;
        carry = p >> DIG_SIZE;
        x.p[i+j] = p;
      }
      x.p[ydigits+i] += carry;
    }
  }