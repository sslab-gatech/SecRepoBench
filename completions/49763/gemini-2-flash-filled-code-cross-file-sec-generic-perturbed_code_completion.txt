for (i=xd; i-- > ydigits; ) {
    mp_dbl_limb xx1, xx0, t;
    mp_limb qhat;

    xx1 = x.p[i]   + ((mp_dbl_limb)x.p[i-1] << DIG_SIZE);
    xx0 = i > 1 ? x.p[i-2] : 0;

    if (xx1 >= z) {
      qhat = MAX_MP_LIMB;
    }
    else {
      qhat = xx1 / z;
    }

  try_qhat:
    /* Now test qhat */
    mpz_t tmp;
    mpz_init(mrb, &tmp);
    size_t sz = ydigits;
    if (sz > i) sz = i;
    mpz_realloc(mrb, &tmp, sz+1);
    tmp.sz = sz;
    tmp.sn = 1;
    for (size_t j = 0; j < sz; j++) {
      tmp.p[j] = y.p[j];
    }
    mp_limb c = 0;
    for (size_t j = 0; j < sz; j++) {
      mp_dbl_limb r = (mp_dbl_limb)qhat * y.p[j] + c;
      tmp.p[j] = r & MAX_MP_LIMB;
      c = r >> DIG_SIZE;
    }
    if (c) {
      tmp.p[sz] = c;
      tmp.sz++;
    }
    size_t k = i - ydigits;
    for (size_t j = 0; j < tmp.sz; j++) {
      mp_dbl_limb r = (mp_dbl_limb)x.p[k+j] - tmp.p[j];
      x.p[k+j] = r & MAX_MP_LIMB;
      if (r > MAX_MP_LIMB) {
        c = 1;
        break;
      }
      c = 0;
    }
    if (c) {
      /* qhat is too big */
      qhat--;
      /* add divisor back */
      c = 0;
      for (size_t j = 0; j < ydigits; j++) {
        mp_dbl_limb r = (mp_dbl_limb)x.p[k+j] + y.p[j] + c;
        x.p[k+j] = r & MAX_MP_LIMB;
        c = r >> DIG_SIZE;
      }
      if (c) {
        x.p[i] += c;
      }
      mpz_clear(mrb, &tmp);
      goto try_qhat;
    }
    mpz_clear(mrb, &tmp);
    q.p[i-ydigits] = qhat;
  }