{
  x.p[xd] = 0; /* ensure top limb is zero for the combined two-limb step */
  for (i = xd; i-- > ydigits;) {
    /* Combine the top two limbs of x to form an estimate dividend */
    mp_dbl_limb top = ((mp_dbl_limb)x.p[i+1] << DIG_SIZE) | x.p[i];
    mp_limb_t qhat = (mp_limb_t)(top / z);
    mp_limb_t rhat = (mp_limb_t)(top % z);

    /* Refine our guess for qhat if needed */
    if (qhat && i >= 1 && ydigits > 1) {
      mp_dbl_limb t = (mp_dbl_limb)qhat * y.p[ydigits - 2];
      mp_dbl_limb c = ((mp_dbl_limb)rhat << DIG_SIZE) + x.p[i - 1];
      while (t > c) {
        qhat--;
        rhat += z;
        c = ((mp_dbl_limb)rhat << DIG_SIZE) + x.p[i - 1];
        t = (mp_dbl_limb)qhat * y.p[ydigits - 2];
      }
    }

    /* Multiply-subtract: x -= qhat * y  */
    {
      mp_limb_t borrow = 0;
      for (size_t j = 0; j < ydigits; j++) {
        mp_dbl_limb mul = (mp_dbl_limb)qhat * y.p[j];
        mp_dbl_limb diff = (mp_dbl_limb)x.p[i - ydigits + j] - borrow
                           - (mul & ((1ULL << DIG_SIZE) - 1));
        x.p[i - ydigits + j] = (mp_limb_t)(diff & ((1ULL << DIG_SIZE) - 1));
        borrow = (mp_limb_t)((mul >> DIG_SIZE) + ((diff >> DIG_SIZE) & 1));
      }
      /* Subtract the final borrow from x.p[i+1] */
      {
        mp_dbl_limb diff = (mp_dbl_limb)x.p[i + 1] - borrow;
        x.p[i + 1] = (mp_limb_t)(diff & ((1ULL << DIG_SIZE) - 1));
        borrow = (mp_limb_t)((diff >> DIG_SIZE) & 1);
      }

      /* If borrow is nonzero, we overshot and need to correct */
      if (borrow) {
        qhat--;
        mp_dbl_limb carry = 0;
        for (size_t j = 0; j < ydigits; j++) {
          mp_dbl_limb sum = (mp_dbl_limb)x.p[i - ydigits + j] + y.p[j] + carry;
          x.p[i - ydigits + j] = (mp_limb_t)(sum & ((1ULL << DIG_SIZE) - 1));
          carry = sum >> DIG_SIZE;
        }
        x.p[i + 1] = (mp_limb_t)(x.p[i + 1] + carry);
      }
    }

    /* Store the computed digit of the quotient */
    q.p[i - ydigits] = qhat;
  }
}