mp_limb_t *qp = q.p;
mp_limb_t *xp = x.p;
mp_limb_t *yp = y.p;
size_t j;

for (j = xd; j > ydigits; j--) {
  mp_dbl_limb t = xp[j] + (((mp_dbl_limb)xp[j-1]) << DIGIT_BITS);
  mp_limb t_q = t / z;
  mp_limb t_r = t % z;

  qp[j-ydigits] = t_q;

  if (t_q == BASE) {
    t_q--;
    t_r += z;
  }

  mp_dbl_limb borrow = 0;
  for (size_t k = 0; k < ydigits; k++) {
    mp_dbl_limb sub = yp[k] * t_q + borrow;
    borrow = (sub > xp[j-1-k]) ? 1 : 0;
    xp[j-1-k] -= sub - borrow;
  }
  xp[j-1-ydigits] -= borrow;

  while (xp[j-1-ydigits] >= BASE || xp[j-1-ydigits] < 0) {
    qp[j-ydigits]--;
    borrow = 0;
    for (size_t k = 0; k < ydigits; k++) {
      mp_dbl_limb add = yp[k] + borrow;
      borrow = (add < xp[j-1-k]) ? 0 : 1;
      xp[j-1-k] += add - borrow*BASE;
    }
    xp[j-1-ydigits] += borrow;
  }
}
for (j--; j >= ydigits; j--) {
  qp[j-ydigits] = 0;
}
q.sz = xd - ydigits;