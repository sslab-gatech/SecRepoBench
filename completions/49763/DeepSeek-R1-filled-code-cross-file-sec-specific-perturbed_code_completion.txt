for (i = xd - ydigits + 1; i-- > 0;) {
    size_t j = i + ydigits - 1;
    mp_dbl_limb num = ((mp_dbl_limb)x.p[j + 1] << DIG_SIZE) | x.p[j];
    mp_limb qhat = (mp_limb)(num / z);
    mp_limb rhat = (mp_limb)(num % z);

    while (qhat >= (1UL << DIG_SIZE) || (j > 0 && (qhat * y.p[ydigits - 1] > ((rhat << DIG_SIZE) | x.p[j - 1])))) {
      qhat--;
      rhat += z;
      if (rhat >= (1UL << DIG_SIZE)) break;
    }

    mp_dbl_limb carry = 0;
    mp_limb borrow = 0;
    for (size_t k = 0; k < ydigits; k++) {
      mp_dbl_limb product = (mp_dbl_limb)y.p[k] * qhat + carry;
      carry = product >> DIG_SIZE;
      mp_limb part = (mp_limb)product;

      size_t idx = i + k;
      mp_limb x_val = idx < x.sz ? x.p[idx] : 0;
      mp_dbl_limb sub = (mp_dbl_limb)x_val - part - borrow;
      borrow = 0;
      if (sub > x_val) {
        borrow = 1;
        sub += (1UL << DIG_SIZE);
      }
      if (idx < x.sz) x.p[idx] = (mp_limb)sub;
    }

    size_t carry_idx = i + ydigits;
    if (carry_idx < x.sz) {
      mp_limb x_val = x.p[carry_idx];
      mp_dbl_limb sub = (mp_dbl_limb)x_val - carry - borrow;
      if (sub > x_val) {
        borrow = 1;
      } else {
        borrow = 0;
      }
      x.p[carry_idx] = (mp_limb)sub;
    }

    if (borrow) {
      qhat--;
      mp_dbl_limb add_carry = 0;
      for (size_t k = 0; k < ydigits; k++) {
        size_t idx = i + k;
        mp_limb x_val = idx < x.sz ? x.p[idx] : 0;
        mp_dbl_limb sum = (mp_dbl_limb)x_val + y.p[k] + add_carry;
        add_carry = sum >> DIG_SIZE;
        if (idx < x.sz) x.p[idx] = (mp_limb)sum;
      }
      if (carry_idx < x.sz) {
        x.p[carry_idx] += (mp_limb)add_carry;
      }
    }

    q.p[i] = qhat;
  }