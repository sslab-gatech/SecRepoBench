for (i = xd - ydigits; i < xd; i--) {
    mp_dbl_limb qhat;
    mp_dbl_limb rhat;
    mp_dbl_limb x0, x1, y0, y1;
    size_t j;

    if (i >= xd) continue;
    x0 = (i < xd) ? x.p[i] : 0;
    x1 = (i+1 < xd) ? x.p[i+1] : 0;
    y0 = y.p[0];
    y1 = (ydigits > 1) ? y.p[1] : 0;

    qhat = (x1 * DIG_BASE + x0) / y1;
    rhat = (x1 * DIG_BASE + x0) % y1;
    while (qhat >= DIG_BASE || qhat * y0 > DIG_BASE * rhat + x0) {
      qhat--;
      rhat += y1;
      if (rhat >= DIG_BASE) break;
    }

    mp_dbl_limb carry = 0;
    for (j = 0; j < ydigits; j++) {
      mp_dbl_limb product = qhat * y.p[j];
      mp_dbl_limb sum = x.p[i+j] + carry;
      if (sum < carry) carry = 1;
      else carry = 0;
      sum -= product;
      if (sum > DIG_MASK - product) carry++;
      x.p[i+j] = sum & DIG_MASK;
    }
    if (carry) {
      qhat--;
      carry = 0;
      for (j = 0; j < ydigits; j++) {
        mp_dbl_limb sum = x.p[i+j] + y.p[j] + carry;
        x.p[i+j] = sum & DIG_MASK;
        carry = sum >> DIG_SIZE;
      }
    }
    q.p[i] = qhat;
  }