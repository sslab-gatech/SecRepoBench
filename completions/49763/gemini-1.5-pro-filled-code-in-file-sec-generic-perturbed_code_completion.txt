for (i = xd - ydigits; ; i--) {
    mp_dbl_limb qhat;
    mp_limb x0, x1, y0;

    if (i+ydigits >= xd) x0 = 0;
    else x0 = x.p[i+ydigits];
    x1 = x.p[i+ydigits-1];
    y0 = y.p[ydigits-1];

    if (x0 == y0)
      qhat = DIG_MASK;
    else
      qhat = (((mp_dbl_limb)x0 << DIG_SIZE) | x1)/y0;

    /* reduce qhat to avoid overflow */
    mp_limb y1 = y.p[ydigits-2];
    while (((mp_dbl_limb)y1*qhat) >
           ((((mp_dbl_limb)x0<<DIG_SIZE)|x1) - y0*qhat)<<DIG_SIZE)
      qhat--;

    /* subtract qhat*y from x */
    mp_dbl_limb_signed borrow = 0;
    for (size_t j=0; j<ydigits; j++) {
      borrow += (mp_dbl_limb_signed)x.p[i+j];
      borrow -= qhat * y.p[j];
      x.p[i+j] = LOW(borrow);
      borrow = HIGH(borrow);
    }

    if (borrow) { /* add back y */
      qhat--;
      mp_dbl_limb carry = 0;
      for (size_t j=0; j<ydigits; j++) {
        carry += (mp_dbl_limb)x.p[i+j];
        carry += y.p[j];
        x.p[i+j] = LOW(carry);
        carry = HIGH(carry);
      }
    }
    q.p[i] = (mp_limb)qhat;
    if (i == 0) break;
  }