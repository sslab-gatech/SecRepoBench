{
  /* Allocate a temporary buffer used for partial multiplications. */
  mpz_t tmp;
  mpz_init(mrb, &tmp);

  /* Perform the long-division loop (Knuth's Algorithm D) on each digit of x. */
  for (i = xd; i-- > ydigits;) {
    /* Form a two-limb value "top" from the leading digits of x. */
    mp_dbl_limb top = ((mp_dbl_limb)x.p[i] << DIG_SIZE) + (i >= 1 ? x.p[i - 1] : 0);
    mp_limb guess = (mp_limb)(top / z); /* Proposed quotient digit */
    mp_limb rest  = (mp_limb)(top % z); /* Remainder from that guess */

    if (guess != 0 && ydigits > 1) {
      /*
       * Compare guess*y.p[ydigits-2] with the next portion of x
       * to see if guess is too large; adjust if needed.
       */
      mp_dbl_limb x2 = ((mp_dbl_limb)rest << DIG_SIZE) + (i >= 2 ? x.p[i - 2] : 0);
      if ((mp_dbl_limb)guess * (mp_dbl_limb)y.p[ydigits - 2] > x2) {
        guess--;
        rest += z;
        x2 = ((mp_dbl_limb)rest << DIG_SIZE) + (i >= 2 ? x.p[i - 2] : 0);
        if ((mp_dbl_limb)guess * (mp_dbl_limb)y.p[ydigits - 2] > x2) {
          guess--;
          rest += z;
        }
      }
    }

    if (guess != 0) {
      /* Multiply y by the guess and subtract it from the corresponding slice of x. */
      mpz_realloc(mrb, &tmp, i + 1); /* Ensure tmp can hold up to i+1 limbs. */
      mul_1(mrb, &tmp, &y, guess);   /* Multiply y by single-limb guess. */

      /* usub_n(...) subtracts tmp from x in-place on the low i-(ydigits-1)+1 limbs.
       * If subtraction borrows, our guess was one too large, so fix up. */
      if (usub_n(mrb, &x, &x, &tmp, i - (ydigits - 1)) != 0) {
        guess--;
        uadd_n(mrb, &x, &x, &y, i - (ydigits - 1));
      }
    }

    /* Store the quotient digit we computed. */
    q.p[i - (ydigits - 1)] = guess;
  }

  /* Adjust the recorded size of q. The call to trim(&q) after this loop ensures correctness. */
  if (xd >= ydigits) {
    q.sz = xd - ydigits + 1;
  }
  else {
    q.sz = 1;
  }

  mpz_clear(mrb, &tmp);
}