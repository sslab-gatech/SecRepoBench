for (i = xd - ydigits; ; i--) {
    mp_dbl_limb qhat;
    mp_limb x0, x1, y0;

    if (i+ydigits >= xd) x0 = 0;
    else x0 = x.p[i+ydigits];
    x1 = x.p[i+ydigits-1];
    y0 = y.p[ydigits-1];

    if (x0 == y0)
      qhat = DIG_MASK;
    else
      qhat = (((mp_dbl_limb)x0 << DIG_SIZE) | x1)/y0;

    /* reduce qhat to avoid overflow */
    mp_limb y1 = y.p[ydigits-2];
    while (((mp_dbl_limb)y1*qhat) >
           ((((mp_dbl_limb)x0<<DIG_SIZE)|x1) - y0*qhat)<<DIG_SIZE)
      qhat--;

    /* now multiply and subtract */
    mp_dbl_limb_signed b = 0;
    for (size_t j=0; j<ydigits; j++) {
      b += (mp_dbl_limb_signed)x.p[i+j];
      b -= qhat * (mp_dbl_limb_signed)y.p[j];
      x.p[i+j] = LOW(b);
      b = HIGH(b);
    }

    if (b) { /* add back */
      qhat--;
      mp_dbl_limb c = 0;
      for (size_t j=0; j<ydigits; j++) {
        c += (mp_dbl_limb)x.p[i+j] + (mp_dbl_limb)y.p[j];
        x.p[i+j] = LOW(c);
        c >>= DIG_SIZE;
      }
    }
    q.p[i] = (mp_limb)qhat;
    if (i == 0) break;
  }