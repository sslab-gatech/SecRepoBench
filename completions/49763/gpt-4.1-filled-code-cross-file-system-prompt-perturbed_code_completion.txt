for (i = xd; i-- > ydigits-1;) {
    mp_dbl_limb d1 = x.p[i];
    mp_dbl_limb d2 = (i > 0) ? x.p[i-1] : 0;
    mp_dbl_limb d3 = (i > 1) ? x.p[i-2] : 0;
    mp_dbl_limb v = ((d1 << DIG_SIZE) | d2);
    mp_dbl_limb qhat = v / z;
    mp_dbl_limb rhat = v % z;

    if (qhat >= DIG_BASE) qhat = DIG_BASE-1;

    // adjust qhat if necessary
    while (1) {
      mp_dbl_limb t1 = (ydigits > 1 ? y.p[ydigits-2] : 0);
      mp_dbl_limb lhs = ((rhat << DIG_SIZE) | d3);
      mp_dbl_limb rhs = qhat * t1;
      if (qhat == 0 || lhs >= rhs) break;
      qhat--;
      rhat += z;
      if (rhat >= DIG_BASE) break;
    }

    // multiply and subtract
    mp_limb_t borrow = 0;
    for (size_t j = 0; j < ydigits; ++j) {
      mp_dbl_limb mul = (mp_dbl_limb)qhat * y.p[j];
      mp_limb_t sub = x.p[i-ydigits+1+j] - (mul & DIG_MASK) - borrow;
      x.p[i-ydigits+1+j] = sub & DIG_MASK;
      borrow = (mul >> DIG_SIZE) + ((sub >> (sizeof(mp_limb_t)*8-1)) & 1);
    }
    mp_limb_t sub = x.p[i+1] - borrow;
    x.p[i+1] = sub & DIG_MASK;
    int under = (sub >> (sizeof(mp_limb_t)*8-1)) & 1;

    // if we subtracted too much, add y back
    if (under) {
      qhat--;
      mp_limb_t carry = 0;
      for (size_t j = 0; j < ydigits; ++j) {
        mp_dbl_limb add = (mp_dbl_limb)x.p[i-ydigits+1+j] + y.p[j] + carry;
        x.p[i-ydigits+1+j] = add & DIG_MASK;
        carry = add >> DIG_SIZE;
      }
      x.p[i+1] += carry;
    }
    q.p[i-ydigits+1] = qhat;
  }