{
  size_t n = ydigits;
  size_t m = xd - n;
  for (i = m + 1; i-- > 0; ) {
    /* Estimate quotient digit */
    mp_dbl_limb dividend = (((mp_dbl_limb)x.p[i+n]) << DIG_SIZE) | x.p[i+n-1];
    mp_limb qhat = (mp_limb)(dividend / z);
    if (qhat >= (1UL << DIG_SIZE))
      qhat = (1UL << DIG_SIZE) - 1;

    /* Multiply divisor by qhat and subtract from x */
    mp_limb carry = 0;
    size_t j;
    for (j = 0; j < n; j++) {
      mp_dbl_limb prod = (mp_dbl_limb)qhat * y.p[j] + carry;
      mp_limb sub = x.p[i+j] - (mp_limb)prod;
      carry = (mp_limb)(prod >> DIG_SIZE);
      if (x.p[i+j] < (mp_limb)prod) {
        sub += (1UL << DIG_SIZE);
        carry++;
      }
      x.p[i+j] = sub;
    }
    /* Subtract carry from the next limb */
    if (x.p[i+n] < carry) {
      /* The estimated quotient digit was too high; correct it */
      qhat--;
      mp_limb carry2 = 0;
      for (j = 0; j < n; j++) {
        mp_dbl_limb sum = (mp_dbl_limb)x.p[i+j] + y.p[j] + carry2;
        x.p[i+j] = (mp_limb)sum;
        carry2 = (mp_limb)(sum >> DIG_SIZE);
      }
      x.p[i+n] += carry2;
    } else {
      x.p[i+n] -= carry;
    }
    q.p[i] = qhat;
  }
}