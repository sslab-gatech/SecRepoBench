// This code block implements the division of multi-precision integers using a long division algorithm.
// The algorithm is based on the following steps:
// 1.  Determine the number of digits in the dividend (x) and the divisor (y).
// 2.  Shift the dividend and the divisor to the right by the number of digits in the divisor.
// 3.  Perform a long division of the shifted dividend by the shifted divisor.
// 4.  Store the quotient and the remainder in the qq and rr variables, respectively.

// Determine the number of digits in the dividend (x) and the divisor (y).
size_t xd = digits(&x);
size_t ydigits = digits(yy);

// Shift the dividend and the divisor to the right by the number of digits in the divisor.
size_t ns = lzb(yy->p[ydigits-1]);
ulshift(mrb, &x, xx, ns);
ulshift(mrb, &y, yy, ns);

// Perform a long division of the shifted dividend by the shifted divisor.
mp_dbl_limb z = y.p[ydigits-1];
for (i = xd - 1; i >= 0; i--) {
  mp_dbl_limb x0 = x.p[i];
  mp_dbl_limb y0 = y.p[i];
  mp_dbl_limb q;
  mp_dbl_limb r;

  // Calculate the quotient and remainder of the current digit.
  mp_div_2exp(x0, y0, &q, &r);

  // Update the quotient and remainder.
  x.p[i] = r;
  q = mp_mul_2exp(q, z, 1);
  q += x.p[i + 1];
  x.p[i + 1] = q;
}

// Store the quotient and the remainder in the qq and rr variables, respectively.
trim(&q);
mpz_move(mrb, qq, &q);
urshift(mrb, rr, &x, ns);