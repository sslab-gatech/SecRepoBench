case CirclePrimitive:
{
  double
    delta,
    radius,
    step;

  /* Compute the circle's radius */
  radius=hypot((double) (bounds.x2-bounds.x1),(double) (bounds.y2-bounds.y1))/2.0;
  delta=2.0/MagickMax(radius,1.0);
  /* Estimate number of points needed for the circle */
  step=MagickPI/8.0;
  if ((delta >= 0.0) && (delta < (MagickPI/8.0)))
    step=MagickPI/(4.0*(MagickPI/delta/2.0+0.5));
  points_extent=ceil(2.0*MagickPI/step)+6.0;
  break;
}
case EllipsePrimitive:
{
  double
    delta,
    rx,
    ry,
    step;

  /* Compute the ellipse's radii */
  rx=(bounds.x2-bounds.x1)/2.0;
  ry=(bounds.y2-bounds.y1)/2.0;
  delta=2.0/MagickMax(MagickMax(rx,ry),1.0);
  /* Estimate number of points needed for the ellipse */
  step=MagickPI/8.0;
  if ((delta >= 0.0) && (delta < (MagickPI/8.0)))
    step=MagickPI/(4.0*(MagickPI/delta/2.0+0.5));
  points_extent=ceil(2.0*MagickPI/step)+6.0;
  break;
}
case ArcPrimitive:
{
  double
    arc_angle,
    delta,
    rx,
    ry,
    step;

  /* Compute the arc's radii and angle */
  rx=(bounds.x2-bounds.x1)/2.0;
  ry=(bounds.y2-bounds.y1)/2.0;
  delta=2.0/MagickMax(MagickMax(rx,ry),1.0);
  arc_angle=primitive_info[j+2].point.y-primitive_info[j+2].point.x;
  if (arc_angle < 0.0)
    arc_angle+=360.0;
  /* Estimate number of points needed for the arc */
  step=MagickPI/8.0;
  if ((delta >= 0.0) && (delta < (MagickPI/8.0)))
    step=MagickPI/(4.0*(MagickPI/delta/2.0+0.5));
  points_extent=ceil(arc_angle*MagickPI/(180.0*step))+6.0;
  break;
}