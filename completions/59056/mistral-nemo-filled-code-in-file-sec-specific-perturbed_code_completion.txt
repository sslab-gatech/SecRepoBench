// <MASK>
if (tok[0]->IsBinary()) {
    const char* data = tok[0]->begin(), *end = tok[0]->end();

    char type;
    uint32_t count;
    ReadBinaryDataArrayHead(data, end, type, count, el);

    if (type != 'f' && type != 'd') {
        ParseError("expected float or double array (binary)", &el);
    }

    std::vector<char> buff;
    ReadBinaryDataArray(type, count, data, end, buff, el);

    ai_assert(data == end);
    uint64_t dataToRead = static_cast<uint64_t>(count) * (type == 'd' ? 8 : 4);
    if (dataToRead != buff.size()) {
        ParseError("Invalid read size (binary)", &el);
    }

    out.reserve(count);

    if (type == 'd') {
        const double* d = reinterpret_cast<const double*>(&buff[0]);
        for (unsigned int i = 0; i < count; ++i, ++d) {
            out.push_back(static_cast<float>(*d));
        }
    } else if (type == 'f') {
        const float* f = reinterpret_cast<const float*>(&buff[0]);
        for (unsigned int i = 0; i < count; ++i, ++f) {
            out.push_back(*f);
        }
    }
} else {
    const size_t dim = ParseTokenAsDim(*tok[0]);

    // see notes in ParseVectorDataArray()
    out.reserve(dim);

    const Scope& scope = GetRequiredScope(el);
    const Element& a = GetRequiredElement(scope, "a", &el);

    for (TokenList::const_iterator it = a.Tokens().begin(), end = a.Tokens().end(); it != end; ) {
        const float ival = ParseTokenAsFloat(**it++);
        out.push_back(ival);
    }
}
// </MASK>