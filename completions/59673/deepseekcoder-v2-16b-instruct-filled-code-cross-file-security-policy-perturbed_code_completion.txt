mx = mx * 2;
    my = my * 2;
    sourcex = s->mb_x * block_s + (mx >> lowres);
    src_y = s->mb_y * block_s + (my >> lowres);

    uvsrc_x = (s->mb_x * block_s + (mx >> lowres)) >> 1;
    uvsrc_y = (s->mb_y * block_s + (my >> lowres)) >> 1;

    uvsx = (mx & 1) << 1;
    uvsy = (my & 1) << 1;

    linesize = s->linesize;
    uvlinesize = s->uvlinesize;

    if (mx < -h_edge_pos || mx >= s->width + h_edge_pos ||
        my < -v_edge_pos || my >= s->height + v_edge_pos) {
        // Motion vector goes out of bounds, apply edge emulation
        s->vdsp.emulated_edge_mc(dest_y, ref_picture[0],
                                 linesize, uvlinesize,
                                 16, 16,
                                 mx, my, h_edge_pos, v_edge_pos);
        s->vdsp.emulated_edge_mc(dest_cb, ref_picture[1],
                                 uvlinesize, uvlinesize,
                                 8, 8,
                                 uvsrc_x, uvsrc_y, h_edge_pos >> 1, v_edge_pos >> 1);
        s->vdsp.emulated_edge_mc(dest_cr, ref_picture[2],
                                 uvlinesize, uvlinesize,
                                 8, 8,
                                 uvsrc_x, uvsrc_y, h_edge_pos >> 1, v_edge_pos >> 1);
        return;
    }

    ptr_y = ref_picture[0] + src_y * linesize + sourcex;
    ptr_cb = ref_picture[1] + uvsrc_y * uvlinesize + uvsrc_x;
    ptr_cr = ref_picture[2] + uvsrc_y * uvlinesize + uvsrc_x;

    pix_op[op_index](dest_y, ptr_y, linesize, block_s, mx & s_mask, my & s_mask);
    pix_op[op_index](dest_cb, ptr_cb, uvlinesize, block_s >> s->chroma_y_shift, uvsx, uvsy);
    pix_op[op_index](dest_cr, ptr_cr, uvlinesize, block_s >> s->chroma_y_shift, uvsx, uvsy);