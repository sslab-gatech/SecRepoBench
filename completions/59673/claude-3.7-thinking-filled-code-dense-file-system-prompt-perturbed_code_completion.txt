linesize = s->linesize;
uvlinesize = s->uvlinesize;

if (s->quarter_sample) {
    motion_x /= 2;
    motion_y /= 2;
}

// Calculate source position in luma plane
sx = motion_x & s_mask;
sy = motion_y & s_mask;
src_y  = mb_y * block_s + (motion_y >> (lowres+1));
sourcex = s->mb_x * block_s + (motion_x >> (lowres+1));

// Get pointer to source luma
ptr_y  = ref_picture[0] + src_y * linesize + sourcex;

// Check if edge emulation is needed for luma
if ((unsigned)sourcex > FFMAX(h_edge_pos - (!!sx) - 2*block_s, 0) ||
    (unsigned)src_y   > FFMAX((v_edge_pos >> field_based) - (!!sy) - h, 0)) {
    s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, ptr_y, linesize, linesize,
                            17, 17 + field_based,
                            sourcex, src_y << field_based,
                            h_edge_pos, v_edge_pos);
    ptr_y = s->sc.edge_emu_buffer;
}

// Apply motion compensation for luma
sx = (sx << 2) >> lowres;
sy = (sy << 2) >> lowres;
if (field_select)
    ptr_y += linesize;
pix_op[op_index](dest_y, ptr_y, linesize, h, sx, sy);

// Handle chroma unless we're in gray mode
if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {
    // Calculate chroma positions
    mx = motion_x / 2;
    my = motion_y / 2;
    
    uvsx = mx & s_mask;
    uvsy = my & s_mask;
    uvsrc_x = s->mb_x * (block_s >> s->chroma_x_shift) + (mx >> (lowres+1));
    uvsrc_y = mb_y * (block_s >> s->chroma_y_shift) + (my >> (lowres+1));
    
    // Get pointers to source chroma
    ptr_cb = ref_picture[1] + uvsrc_y * uvlinesize + uvsrc_x;
    ptr_cr = ref_picture[2] + uvsrc_y * uvlinesize + uvsrc_x;
    
    // Check if edge emulation is needed for chroma
    if ((unsigned)uvsrc_x > FFMAX((h_edge_pos >> s->chroma_x_shift) - (!!uvsx) - block_s, 0) ||
        (unsigned)uvsrc_y > FFMAX((v_edge_pos >> s->chroma_y_shift >> field_based) - (!!uvsy) - h, 0)) {
        uint8_t *emu_buffer = s->sc.edge_emu_buffer + 17 * linesize;
        
        s->vdsp.emulated_edge_mc(emu_buffer, ptr_cb, uvlinesize, uvlinesize,
                               9, 9 + field_based,
                               uvsrc_x, uvsrc_y << field_based,
                               h_edge_pos >> s->chroma_x_shift, v_edge_pos >> s->chroma_y_shift);
        ptr_cb = emu_buffer;
        emu_buffer += 9 * uvlinesize;
        
        s->vdsp.emulated_edge_mc(emu_buffer, ptr_cr, uvlinesize, uvlinesize,
                               9, 9 + field_based,
                               uvsrc_x, uvsrc_y << field_based,
                               h_edge_pos >> s->chroma_x_shift, v_edge_pos >> s->chroma_y_shift);
        ptr_cr = emu_buffer;
    }
    
    // Apply motion compensation for chroma
    uvsx = (uvsx << 2) >> lowres;
    uvsy = (uvsy << 2) >> lowres;
    if (field_select) {
        ptr_cb += uvlinesize;
        ptr_cr += uvlinesize;
    }
    
    // Actual chroma MC
    pix_op[op_index](dest_cb, ptr_cb, uvlinesize, h >> s->chroma_y_shift, uvsx, uvsy);
    pix_op[op_index](dest_cr, ptr_cr, uvlinesize, h >> s->chroma_y_shift, uvsx, uvsy);
}