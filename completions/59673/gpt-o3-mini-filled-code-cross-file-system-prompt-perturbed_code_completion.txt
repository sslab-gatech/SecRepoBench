linesize   = s->linesize;
uvlinesize = s->uvlinesize;
{
    int block_w, denom;
    /* luma: the block width to process is given by h (e.g. 2*block_s for 16x16) */
    block_w = h;

    /* Compute luma source position and fractional offsets */
    sourcex = s->mb_x * block_s + (motion_x >> (lowres + 1));
    src_y   = mb_y * block_s       + (motion_y >> (lowres + 1));
    sx      = motion_x & s_mask;
    sy      = motion_y & s_mask;

    ptr_y = ref_picture[0] + src_y * linesize + sourcex;
    /* Emulate edge if the reference block falls outside the frame */
    if ((unsigned)sourcex > FFMAX(h_edge_pos - (!!sx) - block_w, 0) ||
        (unsigned)src_y   > FFMAX(v_edge_pos - (!!sy) - block_w, 0)) {
        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, ptr_y, linesize, linesize,
                                 block_w + 1, block_w + 1,
                                 sourcex, src_y, h_edge_pos, v_edge_pos);
        ptr_y = s->sc.edge_emu_buffer;
    }

    /* Luma interpolation: if no fractional offset, simply copy the block */
    if (!sx && !sy) {
        for (int i = 0; i < block_w; i++)
            memcpy(dest_y + i * linesize, ptr_y + i * linesize, block_w);
    } else {
        denom = s_mask + 1;
        for (int i = 0; i < block_w; i++) {
            for (int j = 0; j < block_w; j++) {
                int p0 = ptr_y[i * linesize + j];
                int p1 = ptr_y[i * linesize + j + 1];
                int p2 = ptr_y[(i + 1) * linesize + j];
                int p3 = ptr_y[(i + 1) * linesize + j + 1];
                dest_y[i * linesize + j] = (p0 * (denom - sx) * (denom - sy) +
                                            p1 * sx * (denom - sy) +
                                            p2 * (denom - sx) * sy +
                                            p3 * sx * sy + (denom * denom / 2)) / (denom * denom);
            }
        }
    }

    /* Chroma: compute source positions and adjust fractional parts */
    uvsrc_x = s->mb_x * block_s + (motion_x >> (lowres + 1));
    uvsrc_y = mb_y * block_s       + (motion_y >> (lowres + 1));
    /* Scale fractional offsets for chroma (typically lower resolution than luma) */
    uvsx = (sx << 2) >> lowres;
    uvsy = (sy << 2) >> lowres;

    ptr_cb = ref_picture[1] + uvsrc_y * uvlinesize + uvsrc_x;
    if ((unsigned)uvsrc_x > FFMAX(h_edge_pos - (!!uvsx) - block_s, 0) ||
        (unsigned)uvsrc_y > FFMAX(v_edge_pos - (!!uvsy) - block_s, 0)) {
        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, ptr_cb, uvlinesize, uvlinesize,
                                 block_s + 1, block_s + 1,
                                 uvsrc_x, uvsrc_y, h_edge_pos, v_edge_pos);
        ptr_cb = s->sc.edge_emu_buffer;
    }
    pix_op[op_index](dest_cb, ptr_cb, uvlinesize, block_s, uvsx, uvsy);

    ptr_cr = ref_picture[2] + uvsrc_y * uvlinesize + uvsrc_x;
    if ((unsigned)uvsrc_x > FFMAX(h_edge_pos - (!!uvsx) - block_s, 0) ||
        (unsigned)uvsrc_y > FFMAX(v_edge_pos - (!!uvsy) - block_s, 0)) {
        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, ptr_cr, uvlinesize, uvlinesize,
                                 block_s + 1, block_s + 1,
                                 uvsrc_x, uvsrc_y, h_edge_pos, v_edge_pos);
        ptr_cr = s->sc.edge_emu_buffer;
    }
    pix_op[op_index](dest_cr, ptr_cr, uvlinesize, block_s, uvsx, uvsy);
}