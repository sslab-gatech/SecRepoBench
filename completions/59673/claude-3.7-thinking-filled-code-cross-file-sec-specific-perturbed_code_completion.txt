linesize   = s->linesize;
uvlinesize = s->uvlinesize;

// Scale motion vectors for low resolution
mx = motion_x >> lowres;
my = motion_y >> lowres;

// Compute source positions
sourcex = s->mb_x * 2 * block_s + (mx >> 1);
src_y   = (mb_y * 2 * block_s >> field_based) + (my >> 1);

if (s->out_format == FMT_H263) {
    // In H263, chroma MV is same as luma MV
    uvsrc_x = sourcex >> 1;
    uvsrc_y = src_y >> 1;
} else {
    // In MPEG, chroma MV is half of luma MV
    uvsrc_x = s->mb_x * block_s + (mx >> 2);
    uvsrc_y = (mb_y * block_s >> field_based) + (my >> 2);
}

// Extract half-pel components
sx = mx & s_mask;
sy = my & s_mask;
uvsx = (mx << (1 - s->chroma_x_shift)) & s_mask;
uvsy = (my << (1 - s->chroma_y_shift)) & s_mask;

// Setup source pointers
ptr_y  = ref_picture[0] + src_y * linesize + sourcex;
ptr_cb = ref_picture[1] + uvsrc_y * uvlinesize + uvsrc_x;
ptr_cr = ref_picture[2] + uvsrc_y * uvlinesize + uvsrc_x;

if ((unsigned) sourcex >= h_edge_pos - 2 * block_s - sx ||
    (unsigned) src_y   >= v_edge_pos - h       - sy) {
    // Handle edge cases - emulate with edge buffer
    s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, ptr_y,
                           linesize, linesize,
                           2 * block_s + sx, h + sy,
                           sourcex, src_y,
                           h_edge_pos, v_edge_pos);
    ptr_y = s->sc.edge_emu_buffer;
}

if (!(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {
    if ((unsigned) uvsrc_x >= h_edge_pos - block_s - uvsx ||
        (unsigned) uvsrc_y >= v_edge_pos - h/2    - uvsy) {
        // Handle chroma edge cases
        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer + 16*linesize,
                               ptr_cb, uvlinesize, uvlinesize,
                               block_s + uvsx, h/2 + uvsy,
                               uvsrc_x, uvsrc_y,
                               h_edge_pos, v_edge_pos);
        ptr_cb = s->sc.edge_emu_buffer + 16*linesize;
        
        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer + 32*linesize,
                               ptr_cr, uvlinesize, uvlinesize,
                               block_s + uvsx, h/2 + uvsy,
                               uvsrc_x, uvsrc_y,
                               h_edge_pos, v_edge_pos);
        ptr_cr = s->sc.edge_emu_buffer + 32*linesize;
    }
}

if (field_based) {
    if (bottom_field) {
        ptr_y  += linesize;
        dest_y  += s->linesize;
        if (!(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {
            ptr_cb += uvlinesize;
            ptr_cr += uvlinesize;
            dest_cb += s->uvlinesize;
            dest_cr += s->uvlinesize;
        }
    }
    
    if (field_select) {
        ptr_y  += linesize;
        if (!(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {
            ptr_cb += uvlinesize;
            ptr_cr += uvlinesize;
        }
    }
        
    linesize   *= 2;
    uvlinesize *= 2;
}

// Apply motion compensation for luma (Y)
if (sy) {
    if (sx) {
        s->hdsp.put_pixels_tab[lowres][3](dest_y, ptr_y, linesize, h);
    } else {
        s->hdsp.put_pixels_tab[lowres][2](dest_y, ptr_y, linesize, h);
    }
} else {
    if (sx) {
        s->hdsp.put_pixels_tab[lowres][1](dest_y, ptr_y, linesize, h);
    } else {
        s->hdsp.put_pixels_tab[lowres][0](dest_y, ptr_y, linesize, h);
    }
}

// Process chroma (color) planes
if (!(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {
    pix_op[op_index](dest_cb, ptr_cb, uvlinesize, h >> 1, uvsx, uvsy);
    pix_op[op_index](dest_cr, ptr_cr, uvlinesize, h >> 1, uvsx, uvsy);
}