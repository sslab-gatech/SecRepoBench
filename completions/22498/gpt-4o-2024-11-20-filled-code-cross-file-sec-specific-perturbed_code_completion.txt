for(a = 0; a < packet->payload_packet_len; a++) {
    // Check for "\r\n" sequence
    if((a + 1 < packet->payload_packet_len) &&
       (packet->payload[a] == '\r') &&
       (packet->payload[a + 1] == '\n')) {
      packet->line[packet->parsed_lines].len =
        (u_int16_t)((&packet->payload[a] - packet->line[packet->parsed_lines].ptr));
      packet->parsed_lines++;

      if(packet->parsed_lines >= MAX_PACKET_LINES)
        break;

      a += 1; // Skip '\n'
      packet->line[packet->parsed_lines].ptr = &packet->payload[a + 1];
      packet->line[packet->parsed_lines].len = 0;

      // Check for "\r\n\r\n" sequence
      if((a + 3 < packet->payload_packet_len) &&
         (packet->payload[a + 1] == '\r') &&
         (packet->payload[a + 2] == '\n')) {
        dataflow->initial_binary_bytes_len = (u_int16_t)(packet->payload_packet_len - (a + 3));
        if(dataflow->initial_binary_bytes_len > sizeof(dataflow->initial_binary_bytes))
          dataflow->initial_binary_bytes_len = sizeof(dataflow->initial_binary_bytes);

        memcpy(dataflow->initial_binary_bytes, &packet->payload[a + 3], dataflow->initial_binary_bytes_len);
        break;
      }
    }
  }