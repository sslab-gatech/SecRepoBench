for(a = 0; a < packet->payload_packet_len; a++) {
    if((a + 1) >= packet->payload_packet_len) break;

    if(packet->payload[a] == '\r' && packet->payload[a+1] == '\n') {
        packet->line[packet->parsed_lines].len = (u_int16_t)(a - (packet->line[packet->parsed_lines].ptr - packet->payload));
        
        if(packet->parsed_lines >= (NDPI_MAX_PARSE_LINES-1)) break;
        packet->parsed_lines++;
        packet->line[packet->parsed_lines].ptr = &packet->payload[a+2];
        packet->line[packet->parsed_lines].len = 0;

        if(packet->line[packet->parsed_lines-1].len == 0) {
            dataflow->initial_binary_bytes.ptr = &packet->payload[a+2];
            dataflow->initial_binary_bytes.len = packet->payload_packet_len - (a+2);
            break;
        }

        if(packet->parsed_lines == 1) {
            if(packet->line[0].len >= 5 && memcmp(packet->line[0].ptr, "HTTP/", 5) == 0) {
                char *space = memchr(packet->line[0].ptr, ' ', packet->line[0].len);
                if(space && (space - packet->line[0].ptr + 3) < packet->line[0].len) {
                    packet->http_response_status_code = (u_int16_t)atoi(space + 1);
                }
            }
        } else {
            struct ndpi_packet_line_info *h = &packet->line[packet->parsed_lines-1];
            if(h->len >= 7 && memcmp(h->ptr, "Server:", 7) == 0) {
                packet->server_line = *h;
                packet->num_headers++;
            } else if(h->len >= 5 && memcmp(h->ptr, "Host:", 5) == 0) {
                packet->host_line = *h;
                packet->num_headers++;
            } else if(h->len >= 13 && memcmp(h->ptr, "Content-Type:", 13) == 0) {
                packet->content_type_line = *h;
                packet->num_headers++;
            }
        }
        
        a++; // Skip \n
    }
}