u_int8_t *ptr = packet->payload;
u_int32_t payload_len = packet->payload_packet_len;
u_int32_t max_lines = NDPI_MAX_PACKET_LINES; // Assume NDPI_MAX_PACKET_LINES is defined elsewhere
u_int32_t parsed_lines = 0;

while (payload_len > 0 && parsed_lines < max_lines) {
  u_int32_t line_len = 0;

  // Find the next "\r\n" sequence in the payload
  while (line_len < payload_len && !(ptr[line_len] == '\r' && ptr[line_len + 1] == '\n')) {
    line_len++;
  }

  // Ensure we don't overflow the buffer when storing the line length
  if (parsed_lines >= NDPI_MAX_PACKET_LINES) {
    break;
  }

  // Store the current line information
  packet->line[parsed_lines].ptr = ptr;
  packet->line[parsed_lines].len = (u_int16_t)line_len;

  // Move the pointer forward and decrease the remaining payload length
  ptr += line_len + ((line_len < payload_len) ? 2 : 0); // Skip "\r\n" if present
  payload_len -= line_len + ((line_len < payload_len) ? 2 : 0);

  // Check for the end of headers ("\r\n\r\n")
  if (line_len == 0 && payload_len >= 2 && ptr[0] == '\r' && ptr[1] == '\n') {
    dataflow->initial_binary_bytes = (u_int16_t)(packet->payload_packet_len - (ptr - packet->payload));
    break;
  }

  parsed_lines++;
}

packet->parsed_lines = (u_int16_t)parsed_lines;

// Analyze the first line for HTTP response status codes
if (parsed_lines > 0 && packet->line[0].len > 9 && 
    memcmp(packet->line[0].ptr, "HTTP/", 5) == 0 &&
    packet->line[0].ptr[packet->line[0].len - 4] == ' ') {
  // Process HTTP response code (simplified example)
  u_int32_t http_code = 0;
  sscanf((char *)(packet->line[0].ptr + 9), "%u", &http_code);
  packet->http_response_code = (u_int16_t)http_code;

  // Identify specific headers if any
  ndpi_find_http_headers(ndpi_str, dataflow, packet);
}