for(a = 0; a < packet->payload_packet_len - 1; a++) {
  if((packet->payload[a] == 0x0d) && (packet->payload[a + 1] == 0x0a)) {
    packet->line[packet->parsed_lines].len = (u_int16_t)(((unsigned long)&packet->payload[a]) -
                                                        ((unsigned long)packet->line[packet->parsed_lines].ptr));

    // Check if we have seen an empty line (header body separator)
    if(packet->line[packet->parsed_lines].len == 0) {
      packet->empty_line_position = a;
      
      // Extract content after the empty line
      if((a + 2) < packet->payload_packet_len) {
        packet->content_line.ptr = &packet->payload[a + 2];
        packet->content_line.len = packet->payload_packet_len - (a + 2);
        
        // Copy binary data into data_flow
        if(packet->content_line.len > 0) {
          if(packet->content_line.len > sizeof(dataflow->initial_binary_bytes))
            dataflow->initial_binary_bytes_len = sizeof(dataflow->initial_binary_bytes);
          else
            dataflow->initial_binary_bytes_len = packet->content_line.len;
          
          memcpy(dataflow->initial_binary_bytes, packet->content_line.ptr, dataflow->initial_binary_bytes_len);
        }
      }
    }
    
    packet->parsed_lines++;
    
    if((packet->parsed_lines + 1) >= NDPI_MAX_PARSE_LINES_PER_PACKET)
      return;

    // Set up the next line
    packet->line[packet->parsed_lines].ptr = &packet->payload[a + 2];
    packet->line[packet->parsed_lines].len = 0;
    
    // Skip the \r\n
    a++;
  }
}

// Process HTTP status codes (if first line is HTTP response)
if(packet->parsed_lines >= 1) {
  if(packet->line[0].len >= 12 && memcmp(packet->line[0].ptr, "HTTP/1.", 7) == 0) {
    if(packet->line[0].ptr[7] == '0' || packet->line[0].ptr[7] == '1') {
      if(packet->line[0].ptr[8] == ' ') {
        // Extract HTTP response code
        char buf[4];
        unsigned int http_response_code;
        
        memcpy(buf, &packet->line[0].ptr[9], 3);
        buf[3] = '\0';
        http_response_code = atoi(buf);
        packet->http_response.status_code = http_response_code;
      }
    }
  }
}

// Extract specific HTTP headers
packet->http_num_headers = 0;

for(a = 1; a < packet->parsed_lines; a++) {
  if(packet->line[a].len >= 6) {
    if(memcmp(packet->line[a].ptr, "Host:", 5) == 0) {
      packet->host_line.ptr = &packet->line[a].ptr[6];
      packet->host_line.len = packet->line[a].len - 6;
      packet->http_num_headers++;
    } else if(memcmp(packet->line[a].ptr, "Server:", 7) == 0) {
      packet->server_line.ptr = &packet->line[a].ptr[8];
      packet->server_line.len = packet->line[a].len - 8;
      packet->http_num_headers++;
    } else if(memcmp(packet->line[a].ptr, "Content-Type:", 13) == 0) {
      packet->content_line.ptr = &packet->line[a].ptr[14];
      packet->content_line.len = packet->line[a].len - 14;
      packet->http_num_headers++;
    } else if(memcmp(packet->line[a].ptr, "Accept:", 7) == 0) {
      packet->accept_line.ptr = &packet->line[a].ptr[8];
      packet->accept_line.len = packet->line[a].len - 8;
      packet->http_num_headers++;
    } else if(memcmp(packet->line[a].ptr, "User-Agent:", 11) == 0) {
      packet->user_agent_line.ptr = &packet->line[a].ptr[12];
      packet->user_agent_line.len = packet->line[a].len - 12;
      packet->http_num_headers++;
    } else if(memcmp(packet->line[a].ptr, "Referer:", 8) == 0) {
      packet->referer_line.ptr = &packet->line[a].ptr[9];
      packet->referer_line.len = packet->line[a].len - 9;
      packet->http_num_headers++;
    }
  }
}