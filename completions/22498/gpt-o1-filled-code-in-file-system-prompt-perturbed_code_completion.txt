/* Parse the payload of the packet to identify and extract lines separated by "\r\n" sequences. */
  {
    u_int32_t a = 0;
    u_int32_t limit = packet->payload_packet_len;
    packet->parsed_lines = 0;
    packet->line[packet->parsed_lines].ptr = packet->payload;
    packet->line[packet->parsed_lines].len = 0;

    /* Scan the payload looking for CR-LF pairs. */
    while((a + 1) < limit && packet->parsed_lines < NDPI_MAX_PARSE_LINES_PER_PACKET) {
      if(packet->payload[a] == '\r' && packet->payload[a+1] == '\n') {
        /* Calculate line length up to current position. */
        packet->line[packet->parsed_lines].len =
          (u_int16_t)((&packet->payload[a]) - packet->line[packet->parsed_lines].ptr);

        /* Move past the CR-LF. */
        a += 2;
        /* If we find another CR-LF immediately after, it's an empty line. */
        if((a + 1) < limit &&
           packet->payload[a] == '\r' &&
           packet->payload[a+1] == '\n') {
          /* Mark that we've encountered an empty line. */
          packet->empty_line_position_set = 1;
        }

        packet->parsed_lines++;
        if(packet->parsed_lines < NDPI_MAX_PARSE_LINES_PER_PACKET && a < limit) {
          /* Set pointer to the start of the next line. */
          packet->line[packet->parsed_lines].ptr = &packet->payload[a];
          packet->line[packet->parsed_lines].len = 0;
        }
      } else {
        a++;
      }
    }

    /* If we didn't finish on a newline, set the length of the last line. */
    if(packet->parsed_lines < NDPI_MAX_PARSE_LINES_PER_PACKET && packet->parsed_lines >= 0) {
      packet->line[packet->parsed_lines].len =
        (u_int16_t)((&packet->payload[limit]) - packet->line[packet->parsed_lines].ptr);
      packet->parsed_lines++;
    }

    /* Analyze the first line to detect HTTP status responses or request methods. */
    if(packet->parsed_lines > 0) {
      const u_int8_t *start = packet->line[0].ptr;
      const u_int16_t len = packet->line[0].len;

      /* Check if it starts with "HTTP/1." => might be a response line. */
      if(len >= 7 && !strncasecmp((const char *)start, "HTTP/1.", 7)) {
        packet->http_response.ptr = start;
        packet->http_response.len = len;
      } else {
        /* Otherwise it might be a request line with a method like GET, POST, etc. */
        packet->http_method.ptr = start;
        packet->http_method.len = len;
      }
    }

    /* Identify and extract specific HTTP headers: "Server:", "Host:", ...
     * We'll do a simple loop for demonstration; real code can parse them more exhaustively. */
    for(a = 1; a < packet->parsed_lines; a++) {
      const u_int8_t *lp = packet->line[a].ptr;
      const u_int16_t llen = packet->line[a].len;

      if(llen > 6 && !strncasecmp((const char *)lp, "Host:", 5)) {
        packet->host_line.ptr = lp;
        packet->host_line.len = llen;
        packet->http_num_headers++;
      } else if(llen > 7 && !strncasecmp((const char *)lp, "Server:", 7)) {
        packet->server_line.ptr = lp;
        packet->server_line.len = llen;
        packet->http_num_headers++;
      } else if(llen > 13 && !strncasecmp((const char *)lp, "Content-Type:", 13)) {
        packet->content_line.ptr = lp;
        packet->content_line.len = llen;
        packet->http_num_headers++;
      }
    }
  }