for(a = 0; a < packet->payload_packet_len; a++) {
    if((packet->payload[a] == '\r') && (a+1 < packet->payload_packet_len) && (packet->payload[a+1] == '\n')) {
      packet->line[packet->parsed_lines].len = (u_int16_t)(a - ((unsigned long)packet->line[packet->parsed_lines].ptr - (unsigned long)packet->payload));
      packet->parsed_lines++;
      
      if(packet->parsed_lines >= MAX_PACKET_LINES)
        break;

      a += 1; // Skip '\n'
      if((a+1 < packet->payload_packet_len) && (packet->payload[a+1] == '\r') && (a+2 < packet->payload_packet_len) && (packet->payload[a+2] == '\n')) {
        // Found "\r\n\r\n", mark the end of headers
        dataflow->initial_binary_bytes_len = packet->payload_packet_len - (a + 2);
        if(dataflow->initial_binary_bytes_len > 0) {
          memcpy(dataflow->initial_binary_bytes, &packet->payload[a + 2], dataflow->initial_binary_bytes_len);
        }
        break;
      }

      packet->line[packet->parsed_lines].ptr = &packet->payload[a + 1];
    }
  }