while (packet->parsed_lines < MAX_PACKET_LINES) {
  u_char *line_start = packet->line[packet->parsed_lines].ptr;
  u_char *line_end = (u_char *)memchr(line_start, '\n', packet->payload_packet_len - (line_start - packet->payload));

  if (line_end == NULL) {
    line_end = (u_char *)memchr(line_start, '\r', packet->payload_packet_len - (line_start - packet->payload));
    if (line_end == NULL) {
      break;
    }
    line_end = (u_char *)memchr(line_start, '\n', packet->payload_packet_len - (line_start - packet->payload));
    if (line_end == NULL) {
      break;
    }
  }

  packet->line[packet->parsed_lines].len = (u_int16_t)(line_end - line_start);
  packet->parsed_lines++;

  if (*line_start == '\r' && *(line_start + 1) == '\n') {
    // Handle "\r\n\r\n" sequence
    // ...
  } else if (strncmp(line_start, "HTTP/", 5) == 0) {
    // Analyze HTTP response status codes
    // ...
  } else if (strncmp(line_start, "Server:", 8) == 0 ||
             strncmp(line_start, "Host:", 5) == 0 ||
             strncmp(line_start, "Content-Type:", 13) == 0) {
    // Identify and extract specific HTTP headers
    // ...
  } else if (*line_start == '\r' && *(line_start + 1) == '\n') {
    // Mark empty lines
    // ...
  }

  line_start = line_end + 2; // Skip "\r\n"
}