// Parse the payload of the packet to identify and extract lines separated by "\r\n" sequences.
  // For each line, calculate its length and store it in the packet structure.
  // If a sequence "\r\n\r\n" is encountered, extract subsequent bytes and store them in the data flow's initial binary bytes.
  // Analyze the first line to detect and process HTTP response status codes.
  // Identify and extract specific HTTP headers such as "Server:", "Host:", "Content-Type:", etc., storing their positions and lengths.
  // Count the number of headers found in the packet.
  // Mark the position of any empty lines, if encountered.
  // Continue parsing until the end of the payload or the maximum number of lines is reached.

  u_int16_t line_start = 0;
  u_int16_t line_end = 0;
  u_int16_t line_len = 0;
  u_int16_t crlf_count = 0;
  u_int16_t empty_line_count = 0;
  u_int16_t header_count = 0;
  u_int16_t max_lines = 100; // Define a maximum number of lines to parse
  u_int16_t current_line = packet->parsed_lines;

  while (line_end < packet->payload_packet_len && current_line < max_lines) {
    if (packet->payload[line_end] == '\r' && line_end + 1 < packet->payload_packet_len && packet->payload[line_end + 1] == '\n') {
      crlf_count++;
      if (crlf_count == 2) {
        // Found "\r\n\r\n" indicating the end of headers
        packet->line[current_line].ptr = &packet->payload[line_start];
        packet->line[current_line].len = line_end - line_start + 2;
        packet->parsed_lines++;
        current_line++;
        break;
      }
      line_start = line_end + 2;
    } else if (packet->payload[line_end] == '\n') {
      packet->line[current_line].ptr = &packet->payload[line_start];
      packet->line[current_line].len = line_end - line_start;
      packet->parsed_lines++;
      current_line++;
      line_start = line_end + 1;
    }
    line_end++;
  }

  // Check if the last line is empty
  if (line_start < line_end && packet->payload[line_start] == '\r' && line_start + 1 == line_end) {
    empty_line_count++;
  }

  // Analyze the first line for HTTP response status codes and headers
  if (packet->parsed_lines > 0) {
    u_int16_t first_line_len = packet->line[0].len;
    char first_line[first_line_len + 1];
    memcpy(first_line, packet->line[0].ptr, first_line_len);
    first_line[first_line_len] = '\0';

    // Check for HTTP response status code
    if (strncmp(first_line, "HTTP/1.1 ", 9) == 0 || strncmp(first_line, "HTTP/1.0 ", 9) == 0) {
      // Extract and process HTTP response status code
      // This is a simplified example, actual parsing may be more complex
      char status_code[4];
      sscanf(first_line + 9, "%3s", status_code);
      // Process status_code as needed
    }

    // Identify and extract specific HTTP headers
    char *header_ptr = first_line;
    while ((header_ptr = strstr(header_ptr, "Server:")) != NULL) {
      header_count++;
      // Extract and process "Server:" header
      header_ptr += strlen("Server:");
      // Process header_ptr as needed
    }

    // Continue for other headers as needed
  }