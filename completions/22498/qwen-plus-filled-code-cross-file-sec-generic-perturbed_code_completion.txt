u_int8_t *ptr = packet->payload;
u_int32_t payload_len = packet->payload_packet_len;
u_int32_t i = 0;

while ((i < payload_len) && (packet->parsed_lines < NDPI_MAX_LINES)) {
  u_int16_t line_len = 0;

  while ((i < payload_len) && (ptr[i] != '\r')) {
    i++;
  }

  if ((i + 1 < payload_len) && ptr[i] == '\r' && ptr[i + 1] == '\n') {
    line_len = i - (packet->line[packet->parsed_lines].len);
    packet->line[packet->parsed_lines].len = line_len;
    packet->parsed_lines++;

    i += 2; // Skip \r\n
    if ((i + 1 < payload_len) && ptr[i] == '\r' && ptr[i + 1] == '\n') {
      dataflow->initial_binary_bytes = &ptr[i + 2];
      dataflow->initial_binary_bytes_len = payload_len - (i + 2);
      break;
    }
  } else {
    i++;
  }

  if (packet->line[0].len > 0) {
    if (ndpi_strncmp(ndpi_str, (char *)packet->line[0].ptr, "HTTP/", 5) == 0) {
      // Parse HTTP status code
      struct ndpi_http_status status;
      if (ndpi_parse_http_status_code(ndpi_str, (char *)(packet->line[0].ptr), &status) == 1) {
        packet->http_status_code = status.code;
        packet->is_http_response = 1;
      }
    }
  }

  // Check for HTTP headers
  if (line_len > 0) {
    if (ndpi_strncasecmp((char *)packet->line[packet->parsed_lines - 1].ptr, "Server:", 7) == 0) {
      packet->server_header_ptr = packet->line[packet->parsed_lines - 1].ptr + 7;
      packet->server_header_len = line_len - 7;
    } else if (ndpi_strncasecmp((char *)packet->line[packet->parsed_lines - 1].ptr, "Host:", 5) == 0) {
      packet->host_header_ptr = packet->line[packet->parsed_lines - 1].ptr + 5;
      packet->host_header_len = line_len - 5;
    } else if (ndpi_strncasecmp((char *)packet->line[packet->parsed_lines - 1].ptr, "Content-Type:", 13) == 0) {
      packet->content_type_ptr = packet->line[packet->parsed_lines - 1].ptr + 13;
      packet->content_type_len = line_len - 13;
    }
  }
}

if (i < payload_len) {
  packet->empty_line_pos = i;
}