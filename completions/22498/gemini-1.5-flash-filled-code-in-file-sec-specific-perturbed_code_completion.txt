for (a = 0; a < end; a++) {
    if(packet->payload[a] == 0x0a) {
      packet->line[packet->parsed_lines].len = (u_int16_t)(
							   ((unsigned long) &packet->payload[a]) - ((unsigned long) packet->line[packet->parsed_lines].ptr));

      if(a > 0 && packet->payload[a - 1] == 0x0d)
	packet->line[packet->parsed_lines].len--;

      if(packet->parsed_lines >= (NDPI_MAX_PARSE_LINES_PER_PACKET - 1))
	break;

      packet->parsed_lines++;
      packet->line[packet->parsed_lines].ptr = &packet->payload[a + 1];
      packet->line[packet->parsed_lines].len = 0;

      if((a + 1) >= packet->payload_packet_len)
	break;

      //a++;
    }
  }
  if(packet->parsed_lines >= 1) {
    packet->line[packet->parsed_lines].len =
      (u_int16_t)(((unsigned long) &packet->payload[packet->payload_packet_len]) -
		  ((unsigned long) packet->line[packet->parsed_lines].ptr));
    packet->parsed_lines++;
  }

  // Analyze the first line to detect and process HTTP response status codes.
  if(packet->parsed_lines > 0) {
    u_int16_t len = packet->line[0].len;
    u_int8_t *ptr = packet->line[0].ptr;

    if(len > 12 && ptr[0] == 'H' && ptr[1] == 'T' && ptr[2] == 'T' && ptr[3] == 'P' && ptr[4] == '/') {
      u_int16_t i = 5;
      u_int16_t code = 0;
      while (i < len && ptr[i] != ' ')
	i++;
      if(i < len && ptr[i] == ' ') {
	i++;
	while (i < len && ptr[i] != ' ') {
	  code = code * 10 + (ptr[i] - '0');
	  i++;
	}
	packet->http_response.ptr = ptr + 5, packet->http_response.len = i - 5;
	dataflow->http.response_status_code = code;
      }
    }
  }

  // Identify and extract specific HTTP headers such as "Server:", "Host:", "Content-Type:", etc., storing their positions and lengths.
  for (a = 0; a < packet->parsed_lines; a++) {
    u_int16_t len = packet->line[a].len;
    u_int8_t *ptr = packet->line[a].ptr;

    if(len > 7 && ndpi_match_prefix(ptr, len, "Server:", 7)) {
      packet->server_line.ptr = ptr + 7, packet->server_line.len = len - 7;
    } else if(len > 5 && ndpi_match_prefix(ptr, len, "Host:", 5)) {
      packet->host_line.ptr = ptr + 5, packet->host_line.len = len - 5;
    } else if(len > 12 && ndpi_match_prefix(ptr, len, "Content-Type:", 12)) {
      packet->content_line.ptr = ptr + 12, packet->content_line.len = len - 12;
    } else if(len > 8 && ndpi_match_prefix(ptr, len, "Referer:", 8)) {
      packet->referer_line.ptr = ptr + 8, packet->referer_line.len = len - 8;
    } else if(len > 7 && ndpi_match_prefix(ptr, len, "Accept:", 7)) {
      packet->accept_line.ptr = ptr + 7, packet->accept_line.len = len - 7;
    } else if(len > 11 && ndpi_match_prefix(ptr, len, "User-Agent:", 11)) {
      packet->user_agent_line.ptr = ptr + 11, packet->user_agent_line.len = len - 11;
    } else if(len > 10 && ndpi_match_prefix(ptr, len, "X-Session-Type:", 15)) {
      packet->http_x_session_type.ptr = ptr + 15, packet->http_x_session_type.len = len - 15;
    } else if(len > 4 && ndpi_match_prefix(ptr, len, "URL:", 4)) {
      packet->http_url_name.ptr = ptr + 4, packet->http_url_name.len = len - 4;
    } else if(len > 10 && ndpi_match_prefix(ptr, len, "Transfer-Encoding:", 17)) {
      packet->http_transfer_encoding.ptr = ptr + 17, packet->http_transfer_encoding.len = len - 17;
    } else if(len > 10 && ndpi_match_prefix(ptr, len, "Content-Length:", 14)) {
      packet->http_contentlen.ptr = ptr + 14, packet->http_contentlen.len = len - 14;
    } else if(len > 6 && ndpi_match_prefix(ptr, len, "Cookie:", 7)) {
      packet->http_cookie.ptr = ptr + 7, packet->http_cookie.len = len - 7;
    } else if(len > 6 && ndpi_match_prefix(ptr, len, "Origin:", 7)) {
      packet->http_origin.ptr = ptr + 7, packet->http_origin.len = len - 7;
    } else if(len > 9 && ndpi_match_prefix(ptr, len, "HTTP-Method:", 11)) {
      packet->http_method.ptr = ptr + 11, packet->http_method.len = len - 11;
    } else if(len > 0 && ptr[0] == 0x20) {
      packet->empty_line_position_set = 1;
    }
    packet->http_num_headers++;
  }