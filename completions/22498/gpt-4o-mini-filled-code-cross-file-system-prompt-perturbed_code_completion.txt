const char *line_start = packet->payload;
  const char *line_end;
  size_t line_length;
  size_t max_lines = sizeof(packet->line) / sizeof(packet->line[0]);

  while (packet->parsed_lines < max_lines && (line_end = (const char *)memmem(line_start, packet->payload_packet_len - (line_start - (const char *)packet->payload), "\r\n", 2)) != NULL) {
    line_length = line_end - line_start;
    packet->line[packet->parsed_lines].len = (u_int16_t)line_length;
    packet->line[packet->parsed_lines].ptr = line_start;

    packet->parsed_lines++;
    line_start = line_end + 2; // Move past the "\r\n"

    // Check for double CRLF indicating end of headers
    if (line_length == 0) {
      // Handle empty line (indicates end of headers)
      break;
    }
  }

  // Process the first line for HTTP response status code
  if (packet->parsed_lines > 0) {
    // Example: Check if the first line starts with "HTTP/"
    if (strncmp((const char *)packet->line[0].ptr, "HTTP/", 5) == 0) {
      // Extract and process the status code
      // (Assuming status code is the third token in the first line)
      // Further processing can be done here
    }
  }