a = 0;
  
  while ((a < packet->payload_packet_len - 1) && (packet->parsed_lines < NDPI_MAX_PARSE_LINES_PER_PACKET - 1)) {
    // Check for line breaks \r\n
    if ((packet->payload[a] == 0x0d) && (packet->payload[a+1] == 0x0a)) {
      // Calculate line length
      packet->line[packet->parsed_lines].len = (u_int16_t)(((unsigned long) &packet->payload[a]) -
                                                       ((unsigned long) packet->line[packet->parsed_lines].ptr));
      
      // Skip \r\n
      a += 2;
      
      // Start new line
      packet->parsed_lines++;
      
      // Check if we have \r\n\r\n (empty line indicating end of headers)
      if ((a + 1 < packet->payload_packet_len) && 
          (packet->payload[a] == 0x0d) && (packet->payload[a+1] == 0x0a)) {
        // Empty line found, mark its position
        packet->empty_line_position = a;
        
        // Store data after headers as initial_binary_bytes if there's more data
        if (a + 2 < packet->payload_packet_len) {
          dataflow->initial_binary_bytes_len = packet->payload_packet_len - (a + 2);
          if (dataflow->initial_binary_bytes_len > 0) {
            // Make sure we don't exceed the buffer size
            if (dataflow->initial_binary_bytes_len > sizeof(dataflow->initial_binary_bytes))
              dataflow->initial_binary_bytes_len = sizeof(dataflow->initial_binary_bytes);
            
            memcpy(dataflow->initial_binary_bytes, &packet->payload[a + 2], dataflow->initial_binary_bytes_len);
          }
        }
      }
      
      // Set pointer for new line if we're still within payload
      if (a < packet->payload_packet_len) {
        packet->line[packet->parsed_lines].ptr = &packet->payload[a];
        packet->line[packet->parsed_lines].len = 0;
        
        // Check for HTTP headers in new line safely
        if (a + 5 < packet->payload_packet_len) {  // Minimum "Host:" length
          // Check for "Server:"
          if (a + 7 <= packet->payload_packet_len &&
              (packet->payload[a] == 'S' || packet->payload[a] == 's') &&
              (packet->payload[a+1] == 'E' || packet->payload[a+1] == 'e') &&
              (packet->payload[a+2] == 'R' || packet->payload[a+2] == 'r') &&
              (packet->payload[a+3] == 'V' || packet->payload[a+3] == 'v') &&
              (packet->payload[a+4] == 'E' || packet->payload[a+4] == 'e') &&
              (packet->payload[a+5] == 'R' || packet->payload[a+5] == 'r') &&
              packet->payload[a+6] == ':') {
            packet->server_line.ptr = &packet->payload[a];
            packet->server_line.len = 0;
            packet->http_server_line_pos = packet->parsed_lines;
          }
          // Check for "Host:"
          else if (a + 5 <= packet->payload_packet_len &&
                  (packet->payload[a] == 'H' || packet->payload[a] == 'h') &&
                  (packet->payload[a+1] == 'O' || packet->payload[a+1] == 'o') &&
                  (packet->payload[a+2] == 'S' || packet->payload[a+2] == 's') &&
                  (packet->payload[a+3] == 'T' || packet->payload[a+3] == 't') &&
                  packet->payload[a+4] == ':') {
            packet->host_line.ptr = &packet->payload[a];
            packet->host_line.len = 0;
            packet->http_host_line_pos = packet->parsed_lines;
          }
          // Check for "Content-Type:"
          else if (a + 13 <= packet->payload_packet_len &&
                  (packet->payload[a] == 'C' || packet->payload[a] == 'c') &&
                  (packet->payload[a+1] == 'O' || packet->payload[a+1] == 'o') &&
                  (packet->payload[a+2] == 'N' || packet->payload[a+2] == 'n') &&
                  (packet->payload[a+3] == 'T' || packet->payload[a+3] == 't') &&
                  (packet->payload[a+4] == 'E' || packet->payload[a+4] == 'e') &&
                  (packet->payload[a+5] == 'N' || packet->payload[a+5] == 'n') &&
                  (packet->payload[a+6] == 'T' || packet->payload[a+6] == 't') &&
                  packet->payload[a+7] == '-' &&
                  (packet->payload[a+8] == 'T' || packet->payload[a+8] == 't') &&
                  (packet->payload[a+9] == 'Y' || packet->payload[a+9] == 'y') &&
                  (packet->payload[a+10] == 'P' || packet->payload[a+10] == 'p') &&
                  (packet->payload[a+11] == 'E' || packet->payload[a+11] == 'e') &&
                  packet->payload[a+12] == ':') {
            packet->content_line.ptr = &packet->payload[a];
            packet->content_line.len = 0;
            packet->http_content_line_pos = packet->parsed_lines;
          }
        }
        
        // Analyze first line for HTTP response status codes
        if (packet->parsed_lines == 1 && packet->line[0].len >= 12) {
          // Check for HTTP response like "HTTP/1.1 200 OK"
          if ((packet->line[0].ptr[0] == 'H' || packet->line[0].ptr[0] == 'h') &&
              (packet->line[0].ptr[1] == 'T' || packet->line[0].ptr[1] == 't') &&
              (packet->line[0].ptr[2] == 'T' || packet->line[0].ptr[2] == 't') &&
              (packet->line[0].ptr[3] == 'P' || packet->line[0].ptr[3] == 'p') &&
              packet->line[0].ptr[4] == '/' &&
              packet->line[0].ptr[5] == '1' &&
              packet->line[0].ptr[6] == '.') {
            if (packet->line[0].ptr[7] == '1' || packet->line[0].ptr[7] == '0') {
              if (packet->line[0].ptr[8] == ' ') {
                // Extract HTTP response code
                if (packet->line[0].len >= 12 &&
                    packet->line[0].ptr[9] >= '0' && packet->line[0].ptr[9] <= '9' &&
                    packet->line[0].ptr[10] >= '0' && packet->line[0].ptr[10] <= '9' &&
                    packet->line[0].ptr[11] >= '0' && packet->line[0].ptr[11] <= '9') {
                  u_int16_t http_response_code = (packet->line[0].ptr[9] - '0') * 100 +
                                                (packet->line[0].ptr[10] - '0') * 10 +
                                                (packet->line[0].ptr[11] - '0');
                  packet->http_response_code = http_response_code;
                }
              }
            }
          }
        }
      }
    } else {
      a++;
    }
  }
  
  // Count number of headers
  packet->http_num_headers = packet->parsed_lines;