u_int32_t i = 0;
  u_int8_t found_crlf = 0;
  u_int8_t found_double_crlf = 0;
  u_int32_t header_start = 0;
  u_int32_t header_end = 0;
  u_int32_t num_headers = 0;
  u_int32_t empty_line_pos = 0;

  while (i < packet->payload_packet_len && packet->parsed_lines < MAX_PARSE_LINES) {
    if (packet->payload[i] == '\r' && i + 1 < packet->payload_packet_len && packet->payload[i + 1] == '\n') {
      found_crlf = 1;
      packet->line[packet->parsed_lines].len = (u_int16_t)(i - (u_int32_t)packet->line[packet->parsed_lines].ptr);
      packet->parsed_lines++;

      if (i + 2 < packet->payload_packet_len && packet->payload[i + 2] == '\r' && packet->payload[i + 3] == '\n') {
        found_double_crlf = 1;
        dataflow->initial_binary_bytes_len = 0;
        for (u_int32_t j = i + 4; j < packet->payload_packet_len && dataflow->initial_binary_bytes_len < sizeof(dataflow->initial_binary_bytes); j++) {
          dataflow->initial_binary_bytes[dataflow->initial_binary_bytes_len++] = packet->payload[j];
        }
        break;
      }

      i += 2; // Skip \r\n

      if (packet->parsed_lines >= 1) {
        packet->line[packet->parsed_lines].ptr = &packet->payload[i];
        packet->line[packet->parsed_lines].len = 0;
      }

      continue;
    }

    if (found_crlf && packet->payload[i] == '\r' && i + 1 < packet->payload_packet_len && packet->payload[i + 1] == '\n') {
      empty_line_pos = packet->parsed_lines;
    }

    if (!found_crlf && packet->parsed_lines == 0) {
      // Check for HTTP response status code
      if (i >= 9 && packet->payload[i - 9] == 'H' && packet->payload[i - 8] == 'T' && packet->payload[i - 7] == 'T' &&
          packet->payload[i - 6] == 'P' && packet->payload[i - 5] == '/' && packet->payload[i - 3] == ' ') {
        // Example: HTTP/1.1 200 OK
        // Do something with the status code
      }
    }

    if (found_crlf && packet->parsed_lines > 0) {
      // Check for specific headers
      if (i >= 7 && packet->payload[i - 7] == 'S' && packet->payload[i - 6] == 'e' && packet->payload[i - 5] == 'r' &&
          packet->payload[i - 4] == 'v' && packet->payload[i - 3] == 'e' && packet->payload[i - 2] == 'r' &&
          packet->payload[i - 1] == ':') {
        header_start = i + 1;
      } else if (i >= 5 && packet->payload[i - 5] == 'H' && packet->payload[i - 4] == 'o' && packet->payload[i - 3] == 's' &&
                 packet->payload[i - 2] == 't' && packet->payload[i - 1] == ':') {
        header_start = i + 1;
      } else if (i >= 12 && packet->payload[i - 12] == 'C' && packet->payload[i - 11] == 'o' && packet->payload[i - 10] == 'n' &&
                 packet->payload[i - 9] == 't' && packet->payload[i - 8] == 'e' && packet->payload[i - 7] == 'n' &&
                 packet->payload[i - 6] == 't' && packet->payload[i - 5] == '-' && packet->payload[i - 4] == 'T' &&
                 packet->payload[i - 3] == 'y' && packet->payload[i - 2] == 'p' && packet->payload[i - 1] == 'e' &&
                 packet->payload[i] == ':') {
        header_start = i + 1;
      }

      if (header_start > 0) {
        header_end = i - 1;
        // Store header position and length
        num_headers++;
        header_start = 0;
      }
    }

    i++;
  }

  if (empty_line_pos > 0) {
    // Mark the position of the empty line
  }