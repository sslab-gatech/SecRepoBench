// Parse the payload of the packet to identify and extract lines separated by "\r\n" sequences.
// For each line, calculate its length and store it in the packet structure.
// If a sequence "\r\n\r\n" is encountered, extract subsequent bytes and store them in the data flow's initial binary bytes.
// Analyze the first line to detect and process HTTP response status codes.
// Identify and extract specific HTTP headers such as "Server:", "Host:", "Content-Type:", etc., storing their positions and lengths.
// Count the number of headers found in the packet.
// Mark the position of any empty lines, if encountered.
// Continue parsing until the end of the payload or the maximum number of lines is reached.
while(packet->payload_packet_len > 0) {
  char *linePtr = memchr(packet->line[packet->parsed_lines].ptr, '\n', packet->payload_packet_len);
  if(linePtr == NULL) {
    packet->line[packet->parsed_lines].len = packet->payload_packet_len;
    packet->parsed_lines++;
    break;
  }
  
  if((linePtr > packet->line[packet->parsed_lines].ptr) && (*(linePtr-1) == '\r')) {
    packet->line[packet->parsed_lines].len = (u_int16_t)(linePtr - packet->line[packet->parsed_lines].ptr - 1);
  } else {
    packet->line[packet->parsed_lines].len = (u_int16_t)(linePtr - packet->line[packet->parsed_lines].ptr);
  }
  
  if((packet->line[packet->parsed_lines].len == 0) && (packet->parsed_lines > 0)) {
    dataflow->initial_binary_bytes.ptr = linePtr + 1;
    dataflow->initial_binary_bytes.len = packet->payload_packet_len - (linePtr + 1 - packet->payload);
    break;
  }
  
  packet->parsed_lines++;
  packet->line[packet->parsed_lines].ptr = linePtr + 1;
  packet->line[packet->parsed_lines].len = 0;
  
  packet->payload_packet_len -= (linePtr + 1 - packet->line[packet->parsed_lines-1].ptr);
}