for(a = 0; a < packet->payload_packet_len && packet->parsed_lines < NDPI_MAX_PACKET_LINES;) {
    if((a + 1 < packet->payload_packet_len) && (packet->payload[a] == '\r') && (packet->payload[a+1] == '\n')) {
        packet->line[packet->parsed_lines].len = (u_int16_t)(a - (packet->line[packet->parsed_lines].ptr - packet->payload));
        
        if(packet->parsed_lines == 0) {
            if(packet->line[0].len >= 9 && !memcmp(packet->line[0].ptr, "HTTP/1.", 7)) {
                const u_int8_t *code_start = packet->line[0].ptr + 9;
                while(*code_start == ' ' && code_start < packet->line[0].ptr + packet->line[0].len) code_start++;
                dataflow->http.response_status_code = atoi((const char*)code_start);
            }
        } else {
            if(packet->line[packet->parsed_lines].len > 0) {
                dataflow->num_headers++;
                if(packet->line[packet->parsed_lines].len >= 6 && !memcmp(packet->line[packet->parsed_lines].ptr, "Host:", 5))
                    dataflow->host_header = packet->line[packet->parsed_lines];
                else if(packet->line[packet->parsed_lines].len >= 7 && !memcmp(packet->line[packet->parsed_lines].ptr, "Server:", 6))
                    dataflow->server_header = packet->line[packet->parsed_lines];
            } else {
                dataflow->empty_line_position = a;
                if((a + 3 < packet->payload_packet_len) && (packet->payload[a+2] == '\r') && (packet->payload[a+3] == '\n')) {
                    dataflow->initial_binary_bytes = &packet->payload[a+4];
                    dataflow->initial_binary_bytes_len = packet->payload_packet_len - (a+4);
                    break;
                }
            }
        }
        
        packet->parsed_lines++;
        if(packet->parsed_lines < NDPI_MAX_PACKET_LINES) {
            packet->line[packet->parsed_lines].ptr = &packet->payload[a+2];
            packet->line[packet->parsed_lines].len = 0;
        }
        
        a += 2;
    } else {
        a++;
    }
}