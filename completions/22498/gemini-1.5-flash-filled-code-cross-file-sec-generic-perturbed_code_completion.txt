u_int8_t *ptr = packet->payload;
  u_int8_t *end = packet->payload + packet->payload_packet_len;
  u_int16_t i = 0;

  while(ptr < end) {
    u_int8_t *line_start = ptr;
    u_int8_t *crlf = memchr(ptr, '\r', end - ptr);

    if(crlf == NULL) {
      packet->line[packet->parsed_lines].len = (u_int16_t)(end - line_start);
      ptr = end;
    } else {
      u_int8_t *lf = crlf + 1;
      if(lf < end && *lf == '\n') {
        packet->line[packet->parsed_lines].len = (u_int16_t)(crlf - line_start);
        ptr = lf + 1;
        if (ptr < end && *ptr == '\r') {
          u_int8_t *lf2 = ptr + 1;
          if (lf2 < end && *lf2 == '\n') {
            ptr = lf2 + 1;
            // Extract subsequent bytes and store them in the data flow's initial binary bytes.
            // ... (Implementation for handling "\r\n\r\n" sequence) ...
          }
        }
      } else {
        packet->line[packet->parsed_lines].len = (u_int16_t)(lf - line_start);
        ptr = lf + 1;
      }
    }
    packet->parsed_lines++;
    if (packet->parsed_lines >= NDPI_MAX_PACKET_LINES)
      break;
  }