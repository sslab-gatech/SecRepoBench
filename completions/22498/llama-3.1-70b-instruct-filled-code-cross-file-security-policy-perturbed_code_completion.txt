a = 0;
while (packet->payload_packet_len > a + 1) {
  if (packet->payload[a] == '\r' && packet->payload[a + 1] == '\n') {
    packet->line[packet->parsed_lines].len = (u_int16_t)(((unsigned long) &packet->payload[a]) - ((unsigned long) packet->line[packet->parsed_lines].ptr));
    packet->parsed_lines++;
    if (packet->parsed_lines >= MAX_PACKET_LINES) {
      break;
    }
    packet->line[packet->parsed_lines].ptr = &packet->payload[a + 2];
    packet->line[packet->parsed_lines].len = 0;
    a += 2;
    if (packet->parsed_lines == 1) {
      // Check for HTTP response status code
      if (packet->payload_packet_len > a + 7 && memcmp(&packet->payload[a], "HTTP/1.", 7) == 0) {
        // Extract HTTP response status code
        u_int16_t status_code = 0;
        if (packet->payload_packet_len > a + 8 && packet->payload[a + 7] =='') {
          status_code = (packet->payload[a + 9] - '0') * 100 + (packet->payload[a + 10] - '0') * 10 + (packet->payload[a + 11] - '0');
          // Process HTTP response status code
        }
      }
    }
    if (packet->parsed_lines > 1) {
      // Check for "\r\n\r\n" sequence
      if (packet->payload_packet_len > a + 3 && packet->payload[a] == '\r' && packet->payload[a + 1] == '\n' && packet->payload[a + 2] == '\r' && packet->payload[a + 3] == '\n') {
        // Extract subsequent bytes and store them in the data flow's initial binary bytes
        u_int16_t binary_bytes_len = (u_int16_t)(((unsigned long) &packet->payload[packet->payload_packet_len]) - ((unsigned long) &packet->payload[a + 4]));
        if (binary_bytes_len > 0) {
          memcpy(dataflow->initial_binary_bytes, &packet->payload[a + 4], binary_bytes_len);
          dataflow->initial_binary_bytes_len = binary_bytes_len;
        }
        break;
      }
    }
  } else {
    a++;
  }
}
// Identify and extract specific HTTP headers
for (u_int32_t i = 0; i < packet->parsed_lines; i++) {
  if (packet->line[i].len > 5 && memcmp(packet->line[i].ptr, "Server:", 7) == 0) {
    // Store position and length of "Server:" header
    packet->server_header_pos = (u_int16_t)(((unsigned long) packet->line[i].ptr) - ((unsigned long) packet->payload));
    packet->server_header_len = packet->line[i].len;
  } else if (packet->line[i].len > 4 && memcmp(packet->line[i].ptr, "Host:", 5) == 0) {
    // Store position and length of "Host:" header
    packet->host_header_pos = (u_int16_t)(((unsigned long) packet->line[i].ptr) - ((unsigned long) packet->payload));
    packet->host_header_len = packet->line[i].len;
  } else if (packet->line[i].len > 12 && memcmp(packet->line[i].ptr, "Content-Type:", 13) == 0) {
    // Store position and length of "Content-Type:" header
    packet->content_type_header_pos = (u_int16_t)(((unsigned long) packet->line[i].ptr) - ((unsigned long) packet->payload));
    packet->content_type_header_len = packet->line[i].len;
  }
}
// Count the number of headers found in the packet
packet->num_headers = 0;
for (u_int32_t i = 0; i < packet->parsed_lines; i++) {
  if (packet->line[i].len > 0) {
    packet->num_headers++;
  }
}
// Mark the position of any empty lines
for (u_int32_t i = 0; i < packet->parsed_lines; i++) {
  if (packet->line[i].len == 0) {
    packet->empty_line_pos = (u_int16_t)(((unsigned long) packet->line[i].ptr) - ((unsigned long) packet->payload));
  }
}