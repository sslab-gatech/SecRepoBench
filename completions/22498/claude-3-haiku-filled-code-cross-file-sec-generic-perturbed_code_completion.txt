// <MASK>
for(a = 0; a < packet->payload_packet_len; a++) {
  if(packet->payload[a] == '\r' && ((a + 1) < packet->payload_packet_len) && packet->payload[a + 1] == '\n') {
    if(packet->parsed_lines >= NDPI_MAX_PARSE_LINES_PER_PACKET) {
      break;
    }

    packet->line[packet->parsed_lines].len = (u_int16_t)(a - (unsigned long)packet->line[packet->parsed_lines].ptr);
    packet->parsed_lines++;

    if(((a + 2) < packet->payload_packet_len) && packet->payload[a + 2] == '\r' && ((a + 3) < packet->payload_packet_len) && packet->payload[a + 3] == '\n') {
      packet->empty_line_position = packet->parsed_lines;
      dataflow->initial_binary_bytes.ptr = &packet->payload[a + 4];
      dataflow->initial_binary_bytes.len = packet->payload_packet_len - (a + 4);
      break;
    }

    packet->line[packet->parsed_lines].ptr = &packet->payload[a + 2];
    packet->line[packet->parsed_lines].len = 0;
    a++;
  }
}

// Analyze the first line to detect and process HTTP response status codes
if(packet->parsed_lines >= 1) {
  ndpi_check_http_payload(ndpi_str, dataflow);
}

// Identify and extract specific HTTP headers
ndpi_search_http_host_name(ndpi_str, dataflow);
ndpi_search_http_url_content(ndpi_str, dataflow);
ndpi_search_http_transaction_metadata(ndpi_str, dataflow);