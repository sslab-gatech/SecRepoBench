{
  // Define maximum lines; if a dedicated macro exists, use that instead.
  const u_int16_t max_lines = sizeof(packet->line) / sizeof(packet->line[0]);
  u_int32_t pos = 0;
  u_int32_t line_start = 0;

  // Initialize header count in case it's used later.
  packet->header_count = 0;
  // Assume these flags/fields exist; if not, they should be added or handled appropriately.
  packet->empty_line_found = 0;
  packet->header_found_server = 0;
  packet->header_found_host = 0;
  packet->header_found_content_type = 0;
  dataflow->initial_binary_bytes = NULL;
  dataflow->initial_binary_bytes_len = 0;

  while(pos < packet->payload_packet_len && packet->parsed_lines < max_lines - 1) {
    // Ensure we have at least 2 bytes to compare
    if(pos + 1 < packet->payload_packet_len &&
       packet->payload[pos] == '\r' &&
       packet->payload[pos+1] == '\n') {

      // Check for double CRLF (i.e. "\r\n\r\n"): end of header section.
      if(pos + 3 < packet->payload_packet_len &&
         packet->payload[pos]     == '\r' &&
         packet->payload[pos+1]   == '\n' &&
         packet->payload[pos+2]   == '\r' &&
         packet->payload[pos+3]   == '\n') {

        // Set the length for the current line.
        packet->line[packet->parsed_lines].ptr = packet->payload + line_start;
        packet->line[packet->parsed_lines].len = pos - line_start;
        packet->parsed_lines++;

        // Store initial binary bytes (data following "\r\n\r\n")
        dataflow->initial_binary_bytes = packet->payload + pos + 4;
        dataflow->initial_binary_bytes_len = packet->payload_packet_len - (pos + 4);
        // All headers processed; exit the loop.
        pos = packet->payload_packet_len;
        break;
      }

      // Process a normal line ending.
      packet->line[packet->parsed_lines].ptr = packet->payload + line_start;
      packet->line[packet->parsed_lines].len = pos - line_start;

      // For the first line, attempt to detect HTTP response status code.
      if(packet->parsed_lines == 0) {
        if((pos >= 5) && (memcmp(packet->payload, "HTTP/", 5) == 0)) {
          /* Optionally, parse the status code located after "HTTP/x.x " */
          /* For example:
               char status_code_str[4] = {0};
               if(pos >= 9) {
                 memcpy(status_code_str, packet->payload + 9, 3);
                 packet->http_status_code = (u_int16_t)atoi(status_code_str);
               }
             */
        }
      }

      // Mark empty lines.
      if((pos - line_start) == 0) {
        packet->empty_line_found = 1;
      }

      // Look for specific HTTP headers in non-empty lines.
      if((pos - line_start) > 0) {
        char *line_ptr = packet->payload + line_start;
        u_int16_t line_len = pos - line_start;
        if(line_len >= 7 && strncasecmp(line_ptr, "Server:", 7) == 0) {
          packet->header_found_server = packet->parsed_lines;
        } else if(line_len >= 5 && strncasecmp(line_ptr, "Host:", 5) == 0) {
          packet->header_found_host = packet->parsed_lines;
        } else if(line_len >= 13 && strncasecmp(line_ptr, "Content-Type:", 13) == 0) {
          packet->header_found_content_type = packet->parsed_lines;
        }
        // Increment header counter except for the very first line.
        if(packet->parsed_lines > 0) {
          packet->header_count++;
        }
      }

      packet->parsed_lines++;
      pos += 2;  // Skip the "\r\n"
      line_start = pos;
    }
    else {
      pos++;
    }
  }

  // If there is remaining data which doesn't end with "\r\n", add it as the last line.
  if(line_start < packet->payload_packet_len && packet->parsed_lines < max_lines) {
    packet->line[packet->parsed_lines].ptr = packet->payload + line_start;
    packet->line[packet->parsed_lines].len = packet->payload_packet_len - line_start;
    packet->parsed_lines++;
  }
}