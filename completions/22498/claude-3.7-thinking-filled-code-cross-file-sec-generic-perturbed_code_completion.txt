for (a = 0; (a < packet->payload_packet_len - 1) && (packet->parsed_lines < NDPI_MAX_PARSE_LINES_PER_PACKET); a++) {
  if ((packet->payload[a] == 0x0d) && (packet->payload[a + 1] == 0x0a)) {
    // Found a "\r\n" sequence
    packet->line[packet->parsed_lines].len = (u_int16_t)(
      ((unsigned long) &packet->payload[a]) -
      ((unsigned long) packet->line[packet->parsed_lines].ptr)
    );

    // Check for empty line
    if (packet->line[packet->parsed_lines].len == 0) {
      packet->empty_line_position = a;
    }

    // Check for specific HTTP headers
    if (packet->parsed_lines >= 1) {
      u_int32_t line_start = (u_int32_t)(packet->line[packet->parsed_lines].ptr - packet->payload);
      u_int16_t line_len = packet->line[packet->parsed_lines].len;
      
      // Check for "Host:" header
      if ((line_len > 5) &&
          (strncasecmp((const char*)packet->line[packet->parsed_lines].ptr, "host:", 5) == 0)) {
        // Skip whitespace after the colon
        u_int16_t offset = 5;
        while ((offset < line_len) && (packet->line[packet->parsed_lines].ptr[offset] == ' ')) {
          offset++;
        }
        
        packet->host_line.ptr = &packet->payload[line_start + offset];
        packet->host_line.len = line_len - offset;
        packet->parsed_headers++;
      }
      // Check for "Server:" header
      else if ((line_len > 7) &&
               (strncasecmp((const char*)packet->line[packet->parsed_lines].ptr, "server:", 7) == 0)) {
        // Skip whitespace after the colon
        u_int16_t offset = 7;
        while ((offset < line_len) && (packet->line[packet->parsed_lines].ptr[offset] == ' ')) {
          offset++;
        }
        
        packet->server_line.ptr = &packet->payload[line_start + offset];
        packet->server_line.len = line_len - offset;
        packet->parsed_headers++;
      }
      // Check for "Content-Type:" header
      else if ((line_len > 13) &&
               (strncasecmp((const char*)packet->line[packet->parsed_lines].ptr, "content-type:", 13) == 0)) {
        // Skip whitespace after the colon
        u_int16_t offset = 13;
        while ((offset < line_len) && (packet->line[packet->parsed_lines].ptr[offset] == ' ')) {
          offset++;
        }
        
        packet->content_line.ptr = &packet->payload[line_start + offset];
        packet->content_line.len = line_len - offset;
        packet->parsed_headers++;
      }
    }
    // Check for HTTP response status code in the first line
    else if (packet->parsed_lines == 0) {
      if ((packet->line[0].len >= 9) &&
          (strncasecmp((const char*)packet->line[0].ptr, "HTTP/1.", 7) == 0)) {
        packet->http_response.ptr = &packet->line[0].ptr[7];
        packet->http_response.len = packet->line[0].len - 7;
      }
    }

    packet->parsed_lines++;
    if (a + 2 < packet->payload_packet_len) {
      packet->line[packet->parsed_lines].ptr = &packet->payload[a + 2];
      packet->line[packet->parsed_lines].len = 0;

      // Check for "\r\n\r\n" sequence
      if ((a + 3 < packet->payload_packet_len) &&
          (packet->payload[a + 2] == 0x0d) &&
          (packet->payload[a + 3] == 0x0a)) {
        // Store binary data after "\r\n\r\n"
        u_int32_t binary_data_offset = a + 4;
        dataflow->initial_binary_bytes_len = packet->payload_packet_len - binary_data_offset;
        
        if (dataflow->initial_binary_bytes_len > 0) {
          // Ensure we don't copy more than the buffer can hold
          u_int32_t bytes_to_copy = dataflow->initial_binary_bytes_len;
          if (bytes_to_copy > sizeof(dataflow->initial_binary_bytes)) {
            bytes_to_copy = sizeof(dataflow->initial_binary_bytes);
          }
          
          memcpy(dataflow->initial_binary_bytes, &packet->payload[binary_data_offset], bytes_to_copy);
          dataflow->initial_binary_bytes_len = bytes_to_copy;
        }
      }
    }
  }
}