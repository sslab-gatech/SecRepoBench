{
  u_int32_t i = 0, line_start = 0, header_count = 0;
  /* Define or use an existing maximum number of lines to avoid overflows. */
  #define NDPI_MAX_LINES 64

  while ((i + 1) < packet->payload_packet_len && packet->parsed_lines < NDPI_MAX_LINES) {
    /* Check for "\r\n" indicating the end of a line */
    if ((packet->payload[i] == '\r') && (packet->payload[i + 1] == '\n')) {
      /* Store the line information safely */
      packet->line[packet->parsed_lines].ptr = &packet->payload[line_start];
      packet->line[packet->parsed_lines].len = (u_int16_t)(i - line_start);

      /* If this is the first parsed line, check for HTTP status code (e.g., "HTTP/1.1 200 OK") */
      if (packet->parsed_lines == 0 && packet->line[0].len >= 9 &&
          !strncmp((char*)packet->line[0].ptr, "HTTP/", 5)) {
        /* Example parsing of HTTP response code (not exhaustive) */
        /* ... (HTTP response code parsing logic here) ... */
      }

      /* Example detection of specific headers in each line (e.g. "Server:", "Host:", etc.) */
      /* ... (header detection and counting logic here) ... */

      packet->parsed_lines++;

      /* Check if we have encountered a "\r\n\r\n" sequence */
      if ((i + 3) < packet->payload_packet_len &&
          packet->payload[i + 2] == '\r' && packet->payload[i + 3] == '\n') {
        /* Store subsequent bytes in dataflow->initial_binary_bytes without overflowing */
        u_int32_t remaining = packet->payload_packet_len - (i + 4);
        if (remaining > sizeof(dataflow->initial_binary_bytes)) {
          remaining = sizeof(dataflow->initial_binary_bytes);
        }
        memcpy(dataflow->initial_binary_bytes, &packet->payload[i + 4], remaining);
        break; /* End parsing on double CRLF */
      }

      /* Move to the next line start, skipping "\r\n" */
      i += 2;
      line_start = i;
    } else {
      i++;
    }
  }

  /* If there's leftover data that didn't end with "\r\n" and we have room for another line */
  if (line_start < packet->payload_packet_len && packet->parsed_lines < NDPI_MAX_LINES) {
    packet->line[packet->parsed_lines].ptr = &packet->payload[line_start];
    packet->line[packet->parsed_lines].len = (u_int16_t)(packet->payload_packet_len - line_start);
    packet->parsed_lines++;
  }

  /* Optionally, store the total header_count or other stats as needed */
  /* ... (any final accounting or cleanup) ... */
}