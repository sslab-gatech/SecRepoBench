u_int16_t line_len = 0;
u_int16_t line_start = 0;
u_int16_t i = 0;
u_int8_t found_double_cr = 0;
u_int8_t found_empty_line = 0;
u_int8_t found_server_header = 0;
u_int8_t found_host_header = 0;
u_int8_t found_content_type_header = 0;

for (i = 0; i < packet->payload_packet_len; i++) {
  if (packet->payload[i] == '\r' && i + 1 < packet->payload_packet_len && packet->payload[i + 1] == '\n') {
    line_len = (u_int16_t)(((unsigned long) &packet->payload[i]) - ((unsigned long) packet->line[packet->parsed_lines].ptr));
    packet->line[packet->parsed_lines].len = line_len;
    packet->parsed_lines++;

    if (found_double_cr == 0) {
      found_double_cr = 1;
      line_start = i + 2;
    } else {
      found_double_cr = 0;
      if (packet->parsed_lines < MAX_PACKET_LINES) {
        packet->line[packet->parsed_lines].ptr = &packet->payload[i + 2];
        packet->line[packet->parsed_lines].len = 0;
      }
    }

    if (packet->parsed_lines == 1) {
      // Analyze the first line to detect and process HTTP response status codes
      if (packet->payload[0] == 'H' && packet->payload[1] == 'T' && packet->payload[2] == 'T' && packet->payload[3] == 'P' &&
          packet->payload[4] == '/' && packet->payload[5] == '1' && packet->payload[6] == '.' && packet->payload[7] == '1') {
        // Process HTTP response status code
      }
    } else {
      // Identify and extract specific HTTP headers
      if (found_server_header == 0 && packet->payload[line_start] == 'S' && packet->payload[line_start + 1] == 'e' &&
          packet->payload[line_start + 2] == 'r' && packet->payload[line_start + 3] == 'v' && packet->payload[line_start + 4] == 'e' &&
          packet->payload[line_start + 5] == 'r' && packet->payload[line_start + 6] == ':') {
        found_server_header = 1;
        // Store the position and length of the "Server:" header
      }

      if (found_host_header == 0 && packet->payload[line_start] == 'H' && packet->payload[line_start + 1] == 'o' &&
          packet->payload[line_start + 2] =='s' && packet->payload[line_start + 3] == 't' && packet->payload[line_start + 4] == ':') {
        found_host_header = 1;
        // Store the position and length of the "Host:" header
      }

      if (found_content_type_header == 0 && packet->payload[line_start] == 'C' && packet->payload[line_start + 1] == 'o' &&
          packet->payload[line_start + 2] == 'n' && packet->payload[line_start + 3] == 't' && packet->payload[line_start + 4] == 'e' &&
          packet->payload[line_start + 5] == 'n' && packet->payload[line_start + 6] == 't' && packet->payload[line_start + 7] == '-' &&
          packet->payload[line_start + 8] == 'T' && packet->payload[line_start + 9] == 'y' && packet->payload[line_start + 10] == 'p' &&
          packet->payload[line_start + 11] == 'e' && packet->payload[line_start + 12] == ':') {
        found_content_type_header = 1;
        // Store the position and length of the "Content-Type:" header
      }

      if (packet->payload[line_start] == '\r' && packet->payload[line_start + 1] == '\n') {
        found_empty_line = 1;
        // Mark the position of the empty line
      }
    }

    i += 1;
  }
}