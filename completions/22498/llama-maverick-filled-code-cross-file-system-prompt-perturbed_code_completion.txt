for(a = 0; a < packet->payload_packet_len - 2; a++) {
  if(packet->parsed_lines >= NDPI_MAX_PARSED_LINES)
    break;

  if((packet->payload[a] == '\r') && (packet->payload[a + 1] == '\n')) {
    if((a + 3) < packet->payload_packet_len && (packet->payload[a + 2] == '\r') && (packet->payload[a + 3] == '\n')) {
      // double newline
      u_int16_t remaining_len = packet->payload_packet_len - a - 4;
      packet->parsed_lines++;
      packet->line[packet->parsed_lines - 1].len = a + 2 - (unsigned long)packet->line[packet->parsed_lines - 1].ptr;
      packet->empty_line_position = a;
      packet->empty_line_position_set = 1;

      if(remaining_len > 0) {
        if(ndpi_str->max_payload_len > remaining_len) {
          memcpy(&dataflow->initial_binary_bytes, &packet->payload[a + 4], remaining_len);
          dataflow->initial_binary_bytes_len = remaining_len;
        } else {
          memcpy(&dataflow->initial_binary_bytes, &packet->payload[a + 4], ndpi_str->max_payload_len);
          dataflow->initial_binary_bytes_len = ndpi_str->max_payload_len;
        }
      }

      return;
    } else {
      packet->line[packet->parsed_lines].len = a - (unsigned long)packet->line[packet->parsed_lines].ptr;
      packet->parsed_lines++;

      if(packet->parsed_lines >= NDPI_MAX_PARSED_LINES)
        break;

      packet->line[packet->parsed_lines].ptr = &packet->payload[a + 2];
      packet->line[packet->parsed_lines].len = 0;

      a++; // skip \n
    }
  }
}

if(packet->line[packet->parsed_lines].ptr == NULL) {
  packet->parsed_lines = 0;
  return;
}