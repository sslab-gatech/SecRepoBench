// Parse the payload of the packet to identify and extract lines separated by "\r\n" sequences.
  // For each line, calculate its length and store it in the packet structure.
  // If a sequence "\r\n\r\n" is encountered, extract subsequent bytes and store them in the data flow's initial binary bytes.
  // Analyze the first line to detect and process HTTP response status codes.
  // Identify and extract specific HTTP headers such as "Server:", "Host:", "Content-Type:", etc., storing their positions and lengths.
  // Count the number of headers found in the packet.
  // Mark the position of any empty lines, if encountered.
  // Continue parsing until the end of the payload or the maximum number of lines is reached.

  u_int16_t i = 0;
  u_int16_t start = 0;
  u_int16_t end = 0;
  u_int16_t line_len = 0;
  u_int16_t header_start = 0;
  u_int16_t header_len = 0;
  u_int16_t headers_count = 0;
  u_int16_t empty_lines_count = 0;
  u_int16_t http_status_code_detected = 0;
  u_int16_t max_lines = 100; // Set a maximum number of lines to parse

  for (i = 0; i < packet->payload_packet_len; i++) {
    if (packet->payload[i] == '\r' && packet->payload[i + 1] == '\n') {
      end = i;
      line_len = end - start + 2;
      packet->line[packet->parsed_lines].ptr = &packet->payload[start];
      packet->line[packet->parsed_lines].len = line_len;
      packet->parsed_lines++;

      if (!http_status_code_detected) {
        // Check if the line is an HTTP response status code
        if (line_len >= 3 && strncmp((char *)&packet->payload[start], "200", 3) == 0) {
          http_status_code_detected = 1;
        }
      }

      // Check for specific HTTP headers
      if (strncmp((char *)&packet->payload[start], "Server:", 7) == 0) {
        header_start = start + 7;
        header_len = line_len - 7;
        headers_count++;
      } else if (strncmp((char *)&packet->payload[start], "Host:", 5) == 0) {
        header_start = start + 5;
        header_len = line_len - 5;
        headers_count++;
      } else if (strncmp((char *)&packet->payload[start], "Content-Type:", 13) == 0) {
        header_start = start + 13;
        header_len = line_len - 13;
        headers_count++;
      }

      // Check for empty lines
      if (line_len == 2 && packet->payload[start] == '\r' && packet->payload[start + 1] == '\n') {
        empty_lines_count++;
      }

      start = i + 2;
      i += 1; // Skip the next character as it is part of the "\r\n" sequence
    }

    if (packet->parsed_lines >= max_lines) {
      break;
    }
  }

  // Handle the last line if it exists
  if (start < packet->payload_packet_len) {
    line_len = packet->payload_packet_len - start;
    packet->line[packet->parsed_lines].ptr = &packet->payload[start];
    packet->line[packet->parsed_lines].len = line_len;
    packet->parsed_lines++;
  }