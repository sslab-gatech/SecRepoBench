const char *line_start = packet->payload;
  const char *line_end = NULL;
  size_t line_length = 0;
  size_t max_lines = sizeof(packet->line) / sizeof(packet->line[0]);

  while (packet->parsed_lines < max_lines && (line_end = (const char *)memmem(line_start, packet->payload_packet_len - (line_start - (const char *)packet->payload), "\r\n", 2)) != NULL) {
    line_length = line_end - line_start;

    packet->line[packet->parsed_lines].ptr = line_start;
    packet->line[packet->parsed_lines].len = (u_int16_t)line_length;
    packet->parsed_lines++;

    line_start = line_end + 2; // Move past the "\r\n"

    // Check for double CRLF indicating the end of headers
    if (line_length == 0 && packet->parsed_lines > 1) {
      // Handle the end of headers
      break;
    }
  }

  // Process the first line for HTTP response status code
  if (packet->parsed_lines > 0) {
    // Example: Check if the first line starts with "HTTP/"
    if (strncmp((const char *)packet->line[0].ptr, "HTTP/", 5) == 0) {
      // Process HTTP response status code
      // Additional logic to extract status code can be added here
    }
  }

  // Further processing of headers can be done here
  // For example, looking for specific headers like "Server:", "Host:", etc.