for (a = 0; a < packet->payload_packet_len; a++) {
    if (packet->parsed_lines >= NDPI_MAX_LINES_PACKET) {
      break;
    }

    if (packet->payload[a] == '\n') {
      if (a > 0 && packet->payload[a - 1] == '\r') {
        packet->line[packet->parsed_lines].len = (u_int16_t)(&packet->payload[a] - packet->line[packet->parsed_lines].ptr - 1); // Exclude \r
        packet->parsed_lines++;

        if (packet->parsed_lines < NDPI_MAX_LINES_PACKET) {
          if (a + 2 <= packet->payload_packet_len) { // Check boundary before accessing a+1 and a+2
            if (packet->payload[a + 1] == '\r' && packet->payload[a + 2] == '\n') {
              // Copy initial binary bytes after "\r\n\r\n"
              if (a + 3 < packet->payload_packet_len) {
                dataflow->initial_binary_bytes_pos = a + 3;
                dataflow->initial_binary_bytes_len = packet->payload_packet_len - dataflow->initial_binary_bytes_pos;
              }
              break; // Stop parsing after double CRLF
            }
          }
          if (a + 1 < packet->payload_packet_len) { // Check boundary
            packet->line[packet->parsed_lines].ptr = &packet->payload[a + 1];
            packet->line[packet->parsed_lines].len = 0;
          } else {
            break; // Reached the end of payload
          }
        } else {
          break; // Reached max lines
        }
      }
    }
  }