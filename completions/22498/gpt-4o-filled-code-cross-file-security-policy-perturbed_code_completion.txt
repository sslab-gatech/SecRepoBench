for(a = 0; a < packet->payload_packet_len; a++) {
    if((a + 1 < packet->payload_packet_len) && (packet->payload[a] == '\r') && (packet->payload[a + 1] == '\n')) {
      packet->line[packet->parsed_lines].len =
        (u_int16_t)(((unsigned long) &packet->payload[a]) -
                    ((unsigned long) packet->line[packet->parsed_lines].ptr));
      packet->parsed_lines++;

      if(packet->parsed_lines >= MAX_PACKET_LINES)
        return;

      a += 1; // Skip '\n'
      if((a + 1 < packet->payload_packet_len) && (packet->payload[a + 1] == '\r') && (packet->payload[a + 2] == '\n')) {
        // Found "\r\n\r\n", mark the end of headers
        dataflow->initial_binary_bytes_len = packet->payload_packet_len - (a + 2);
        if(dataflow->initial_binary_bytes_len > 0) {
          memcpy(dataflow->initial_binary_bytes, &packet->payload[a + 2], dataflow->initial_binary_bytes_len);
        }
        return;
      }

      packet->line[packet->parsed_lines].ptr = &packet->payload[a + 1];
    }
  }