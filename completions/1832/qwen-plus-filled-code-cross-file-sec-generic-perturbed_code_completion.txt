if (s->num_primitive_matrices > max_primitive_matrices) {
    av_log(m->avctx, AV_LOG_ERROR, "Too many primitive matrices specified.\n");
    return AVERROR_INVALIDDATA;
}

for (mat = 0; mat < s->num_primitive_matrices; mat++) {
    channel = get_bits(gbp, 6);

    if (channel > s->max_matrix_channel) {
        av_log(m->avctx, AV_LOG_ERROR, "Output channel exceeds maximum matrix channel.\n");
        s->num_primitive_matrices = 0;
        return AVERROR_INVALIDDATA;
    }

    s->matrix_out_channel[mat] = channel;

    s->fractional_bits[mat] = get_bits(gbp, 4);
    if (s->fractional_bits[mat] > 14) {
        av_log(m->avctx, AV_LOG_ERROR, "Fractional bits value is out of range.\n");
        s->num_primitive_matrices = 0;
        return AVERROR_INVALIDDATA;
    }

    s->lsb_bypassed[mat] = get_bits1(gbp);

    for (unsigned int in_ch = 0; in_ch <= s->max_matrix_channel; in_ch++) {
        int coeff = get_sbits(gbp, 16 - s->fractional_bits[mat]);
        s->matrix_coeff[mat][in_ch] = coeff << s->fractional_bits[mat];
    }

    if (!(s->param_presence_flags & PARAM_NOISE)) {
        s->max_matrix_channel += 2;
    }

    if (s->param_presence_flags & PARAM_NOISE) {
        s->noise_shift = get_bits(gbp, 5);
    } else {
        s->noise_shift = 0;
    }
}

return 0;