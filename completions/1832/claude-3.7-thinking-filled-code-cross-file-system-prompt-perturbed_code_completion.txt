if (s->num_primitive_matrices > max_primitive_matrices) {
    av_log(m->avctx, AV_LOG_ERROR, "Too many primitive matrices: %d\n", s->num_primitive_matrices);
    return AVERROR_INVALIDDATA;
}

s->max_matrix_channel = 0;

for (mat = 0; mat < s->num_primitive_matrices; mat++) {
    s->matrix_params[mat].output_channel = get_bits(gbp, 4);
    s->matrix_params[mat].fbits          = get_bits(gbp, 4);
    s->matrix_params[mat].bypass_lsbs    = get_bits1(gbp);
    
    if (s->matrix_params[mat].output_channel > s->max_matrix_channel)
        s->max_matrix_channel = s->matrix_params[mat].output_channel;
    
    if (s->matrix_params[mat].output_channel >= MAX_CHANNELS) {
        av_log(m->avctx, AV_LOG_ERROR, "Invalid matrix output channel: %d\n", s->matrix_params[mat].output_channel);
        goto error;
    }
    
    if (s->matrix_params[mat].fbits > 14) {
        av_log(m->avctx, AV_LOG_ERROR, "Invalid matrix fractional bits: %d\n", s->matrix_params[mat].fbits);
        goto error;
    }
}

// If noise type is not set, adjust max channel for noise channels
if (!(m->avctx->codec_id == AV_CODEC_ID_TRUEHD && (s->param_presence_flags & PARAM_NOISEGEN)))
    s->max_matrix_channel += 2;

for (mat = 0; mat < s->num_primitive_matrices; mat++) {
    for (channel = 0; channel <= s->max_matrix_channel; channel++) {
        int coeff = get_sbits(gbp, 14);
        s->matrix_params[mat].coeff[channel] = coeff * (1 << s->matrix_params[mat].fbits);
    }
}

if (m->avctx->codec_id == AV_CODEC_ID_TRUEHD && (s->param_presence_flags & PARAM_NOISEGEN)) {
    s->noise_shift = get_bits(gbp, 4);
} else {
    s->noise_shift = 0;
}

return 0;

error:
    // Clean the SubStream state
    s->num_primitive_matrices = 0;
    s->max_matrix_channel = 0;
    return AVERROR_INVALIDDATA;