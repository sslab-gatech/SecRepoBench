// <MASK>
if (s->num_primitive_matrices > 0) {
    for (unsigned int i = 0; i < s->num_primitive_matrices; i++) {
        unsigned int mat = get_bits(gbp, 4);
        if (mat >= max_primitive_matrices) {
            av_log(m->avctx, AV_LOG_ERROR, "Invalid matrix index %u.\n", mat);
            return AVERROR_INVALIDDATA;
        }

        unsigned int channel = get_bits(gbp, 4);
        if (channel >= MAX_CHANNELS) {
            av_log(m->avctx, AV_LOG_ERROR, "Invalid channel index %u.\n", channel);
            return AVERROR_INVALIDDATA;
        }

        unsigned int fractional_bits = get_bits(gbp, 4);
        if (fractional_bits > 14) {
            av_log(m->avctx, AV_LOG_ERROR, "Fractional bits %u is greater than 14.\n", fractional_bits);
            return AVERROR_INVALIDDATA;
        }

        unsigned int lsb_bypass = get_bits1(gbp);
        if (lsb_bypass) {
            av_log(m->avctx, AV_LOG_ERROR, "LSBs should not be bypassed.\n");
            return AVERROR_INVALIDDATA;
        }

        if (s->noise_type == NOISE_TYPE_SET) {
            max_primitive_matrices = MAX_CHANNELS + 2;
        }

        if (channel >= max_primitive_matrices) {
            av_log(m->avctx, AV_LOG_ERROR, "Channel index %u exceeds max matrix channel %u.\n", channel, max_primitive_matrices - 1);
            return AVERROR_INVALIDDATA;
        }

        int32_t *coeff = s->channel_params[channel].coeff[PRIMITIVE];
        for (unsigned int j = 0; j < 16; j++) {
            coeff[j] = get_sbits(gbp, fractional_bits) * (1 << (fractional_bits - 1));
        }

        if (s->noise_type == NOISE_TYPE_SET) {
            s->matrix_noise_shift[channel] = get_bits(gbp, 4);
        } else {
            s->matrix_noise_shift[channel] = 0;
        }
    }
}