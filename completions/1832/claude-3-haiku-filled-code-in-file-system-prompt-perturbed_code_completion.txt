// <MASK>
// Validate the number of primitive matrices against the maximum allowed.
// For each primitive matrix, read the output channel, fractional bits,
// and whether LSBs should be bypassed. If the output channel exceeds the
// max matrix channel or the fractional bits exceed 14, log an error.
// If the noise type is not set, adjust the max
// channel to account for additional noise channels. For each channel,
// read a coefficient value, multiplying it by a power of two based on
// the fractional bits. If noise type is set, read and store the matrix
// noise shift value, otherwise set it to zero. If any validation fails,
// clean the SubStream state and return an error.
if (s->num_primitive_matrices > max_primitive_matrices) {
    av_log(m->avctx, AV_LOG_ERROR, "Too many primitive matrices (%d).\n",
           s->num_primitive_matrices);
    return AVERROR_INVALIDDATA;
}

for (mat = 0; mat < s->num_primitive_matrices; mat++) {
    s->matrix_out_ch[mat] = get_bits(gbp, 6);
    if (s->matrix_out_ch[mat] > s->max_matrix_channel) {
        av_log(m->avctx, AV_LOG_ERROR, "Matrix output channel %d exceeds max matrix channel %d.\n",
               s->matrix_out_ch[mat], s->max_matrix_channel);
        return AVERROR_INVALIDDATA;
    }

    s->lsb_bypass[mat] = get_bits1(gbp);

    int coeff_bits = get_bits(gbp, 5);
    int coeff_shift = get_bits(gbp, 3);
    if (coeff_bits > 14) {
        av_log(m->avctx, AV_LOG_ERROR, "Matrix coefficient bits %d exceeds maximum of 14.\n",
               coeff_bits);
        return AVERROR_INVALIDDATA;
    }

    for (channel = 0; channel <= s->max_matrix_channel; channel++) {
        s->matrix_coeff[mat][channel] = get_sbits(gbp, coeff_bits) * (1 << coeff_shift);
    }

    if (!s->noise_type) {
        s->max_matrix_channel += 2;
    } else {
        s->matrix_noise_shift[mat] = get_bits(gbp, 4);
    }
}