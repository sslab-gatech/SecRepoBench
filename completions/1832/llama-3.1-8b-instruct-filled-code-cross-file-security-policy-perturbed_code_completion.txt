if (s->num_primitive_matrices > 0 && s->num_primitive_matrices <= max_primitive_matrices) {
    for (unsigned int i = 0; i < s->num_primitive_matrices; i++) {
        mat = get_bits(gbp, 4);
        channel = get_bits(gbp, 4);
        if (channel >= max_matrix_channel) {
            av_log(m->avctx, AV_LOG_ERROR, "Output channel %d exceeds max matrix channel %d.\n", channel, max_matrix_channel);
            s->num_primitive_matrices = 0;
            return AVERROR_INVALIDDATA;
        }
        if (m->matrix_noise_shift[channel] == 0) {
            max_matrix_channel = channel + 1;
        }
        if (get_bits1(gbp)) {
            s->primitive_matrices[i].fractional_bits = get_bits(gbp, 4);
            if (s->primitive_matrices[i].fractional_bits > 14) {
                av_log(m->avctx, AV_LOG_ERROR, "Fractional bits for matrix %d exceed 14.\n", i);
                s->num_primitive_matrices = 0;
                return AVERROR_INVALIDDATA;
            }
        } else {
            s->primitive_matrices[i].fractional_bits = 0;
        }
        if (get_bits1(gbp)) {
            s->primitive_matrices[i].bypass_lsb = 1;
        } else {
            s->primitive_matrices[i].bypass_lsb = 0;
        }
        for (unsigned int j = 0; j < 16; j++) {
            s->primitive_matrices[i].coeff[j] = get_sbits(gbp, s->primitive_matrices[i].fractional_bits) * (1 << s->primitive_matrices[i].fractional_bits);
        }
        if (m->matrix_noise_shift[channel]!= 0) {
            s->primitive_matrices[i].noise_shift = get_bits(gbp, 4);
        } else {
            s->primitive_matrices[i].noise_shift = 0;
        }
    }
} else {
    av_log(m->avctx, AV_LOG_ERROR, "Number of primitive matrices %d is invalid.\n", s->num_primitive_matrices);
    s->num_primitive_matrices = 0;
    return AVERROR_INVALIDDATA;
}