if (s->num_primitive_matrices > max_primitive_matrices) {
        av_log(m->avctx, AV_LOG_ERROR, "Too many primitive matrices: %u (max %d).\n",
               s->num_primitive_matrices, max_primitive_matrices);
        return AVERROR_INVALIDDATA;
    }

    for (mat = 0; mat < s->num_primitive_matrices; mat++) {
        unsigned int out_channel = get_bits(gbp, 6);
        if (out_channel > s->max_matrix_channel) {
            av_log(m->avctx, AV_LOG_ERROR,
                   "Matrix output channel %u exceeds maximum %u.\n",
                   out_channel, s->max_matrix_channel);
            s->num_primitive_matrices = 0;
            return AVERROR_INVALIDDATA;
        }

        unsigned int frac_bits = get_bits(gbp, 4);
        if (frac_bits > 14) {
            av_log(m->avctx, AV_LOG_ERROR,
                   "Matrix fractional bits %u exceed maximum 14.\n",
                   frac_bits);
            s->num_primitive_matrices = 0;
            return AVERROR_INVALIDDATA;
        }

        int bypass_lsb = get_bits1(gbp);

        s->primitive_matrix[mat].output_channel    = out_channel;
        s->primitive_matrix[mat].fractional_bits     = frac_bits;
        s->primitive_matrix[mat].bypass_lsb          = bypass_lsb;

        /* Read the coefficient value for this matrix.
         * Here we assume an 8-bit signed coefficient which is scaled
         * by multiplying with 2^(fractional_bits). */
        {
            int coef = get_sbits(gbp, 8);
            s->primitive_matrix[mat].coef = coef * (1 << frac_bits);
        }

        /* Read the noise type flag.
         * If set, a noise shift value is provided.
         * Otherwise, set noise_shift to zero and adjust the maximum matrix channel
         * to account for two additional noise channels.
         */
        if (get_bits1(gbp)) {
            s->primitive_matrix[mat].noise_shift = get_bits(gbp, 4);
        } else {
            s->primitive_matrix[mat].noise_shift = 0;
            s->max_matrix_channel += 2;
        }
    }

    return 0;