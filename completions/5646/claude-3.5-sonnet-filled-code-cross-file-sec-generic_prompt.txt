Below is the content of a C/C++ file where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
MagickExport void GetNextToken(const char *start,const char **end,
  const size_t extent,char *token)
{
  double
    value;

  register const char
    *p;

  register ssize_t
    i;

  size_t
    length;

  assert(start != (const char *) NULL);
  assert(token != (char *) NULL);
  i=0;
  length=strlen(start);
  p=start;
  while ((isspace((int) ((unsigned char) *p)) != 0) && (*p != '\0'))
    p++;
  switch (*p)
  {
    case '\0':
      break;
    case '"':
    case '\'':
    case '`':
    case '{':
    {
      register char
        escape;

      switch (*p)
      {
        case '"': escape='"'; break;
        case '\'': escape='\''; break;
        case '`': escape='\''; break;
        case '{': escape='}'; break;
        default: escape=(*p); break;
      }
      for (p++; *p != '\0'; p++)
      {
        if ((*p == '\\') && ((*(p+1) == escape) || (*(p+1) == '\\')))
          p++;
        else
          if (*p == escape)
            {
              p++;
              break;
            }
        if (i < (ssize_t) (extent-1))
          token[i++]=(*p);
        if ((size_t) (p-start) >= length)
          break;
      }
      break;
    }
    case '/':
    {
      if (i < (ssize_t) (extent-1))
        token[i++]=(*p);
      p++;
      if ((*p == '>') || (*p == '/'))
        {
          if (i < (ssize_t) (extent-1))
            token[i++]=(*p);
          p++;
        }
      break;
    }
    default:
    {
      char
        *q;

      value=StringToDouble(p,&q);
      (void) value;
      if ((p != q) && (*p != ','))
        {
          for ( ; (p < q) && (*p != ','); p++)
          {
            if (i < (ssize_t) (extent-1))
              token[i++]=(*p);
            if ((size_t) (p-start) >= length)
              break;
          }
          if (*p == '%')
            {
              if (i < (ssize_t) (extent-1))
                token[i++]=(*p);
              p++;
            }
          break;
        }
      if ((*p != '\0') && (isalpha((int) ((unsigned char) *p)) == 0) &&
          (*p != *DirectorySeparator) && (*p != '#') && (*p != '<'))
        {
          if (i < (ssize_t) (extent-1))
            token[i++]=(*p);
          p++;
          break;
        }
      for ( ; *p != '\0'; p++)
      {
        if (((isspace((int) ((unsigned char) *p)) != 0) || (*p == '=') ||
            (*p == ',') || (*p == ':') || (*p == ';')) && (*(p-1) != '\\'))
          break;
        if ((i > 0) && (*p == '<'))
          break;
        if (i < (ssize_t) (extent-1))
          token[i++]=(*p);
        if (*p == '>')
          break;
        if (*p == '(')
          for (p++; *p != '\0'; p++)
          {
            if (i < (ssize_t) (extent-1))
              token[i++]=(*p);
            if ((*p == ')') && (*(p-1) != '\\'))
              break;
            if ((size_t) (p-start) >= length)
              break;
          }
        if ((size_t) (p-start) >= length)
          break;
      }
      break;
    }
  }
  // Null-terminate the token string.
  // Check if the token starts with "url(".
  // If true, extract the actual URL by skipping the "url(" prefix and optional '#' character.
  // Then copy the URL to the beginning of the token string, replacing the original content.
  // <MASK>
  while (isspace((int) ((unsigned char) *p)) != 0)
    p++;
  if (end != (const char **) NULL)
    *end=(const char *) p;
}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// MagickCore/draw.c
// static void TraceRectangle(PrimitiveInfo *primitive_info,const PointInfo start,
//   const PointInfo end)
// {
//   PointInfo
//     point;
// 
//   register PrimitiveInfo
//     *p;
// 
//   register ssize_t
//     i;
// 
//   p=primitive_info;
//   TracePoint(p,start);
//   p+=p->coordinates;
//   point.x=start.x;
//   point.y=end.y;
//   TracePoint(p,point);
//   p+=p->coordinates;
//   TracePoint(p,end);
//   p+=p->coordinates;
//   point.x=end.x;
//   point.y=start.y;
//   TracePoint(p,point);
//   p+=p->coordinates;
//   TracePoint(p,start);
//   p+=p->coordinates;
//   primitive_info->coordinates=(size_t) (p-primitive_info);
//   for (i=0; i < (ssize_t) primitive_info->coordinates; i++)
//   {
//     p->primitive=primitive_info->primitive;
//     p--;
//   }
// }

// the below code fragment can be found in:
// MagickCore/magic.c
// MagicComponentGenesis(void)
// {
//   if (magic_semaphore == (SemaphoreInfo *) NULL)
//     magic_semaphore=AcquireSemaphoreInfo();
//   return(MagickTrue);
// }

// the below code fragment can be found in:
// MagickCore/option.c
// MagickExport const OptionInfo *GetCommandOptionInfo(const char *option)
// {
//   register ssize_t
//     i;
// 
//   for (i=0; CommandOptions[i].mnemonic != (char *) NULL; i++)
//     if (LocaleCompare(option,CommandOptions[i].mnemonic) == 0)
//       break;
//   return(CommandOptions+i);
// }

// the below code fragment can be found in:
// MagickCore/option.c
// MagickExport ssize_t ParsePixelChannelOption(const char *channels)
// {
//   char
//     *q,
//     token[MagickPathExtent];
// 
//   ssize_t
//     channel;
// 
//   GetNextToken(channels,(const char **) NULL,MagickPathExtent,token);
//   if ((*token == ';') || (*token == '|'))
//     return(RedPixelChannel);
//   channel=ParseCommandOption(MagickPixelChannelOptions,MagickTrue,token);
//   if (channel >= 0)
//     return(channel);
//   q=(char *) token;
//   channel=(ssize_t) InterpretLocaleValue(token,&q);
//   if ((q == token) || (channel < 0) || (channel >= MaxPixelChannels))
//     return(-1);
//   return(channel);
// }

// the below code fragment can be found in:
// MagickCore/mime.c
// static int MimeInfoCompare(const void *x,const void *y)
// {
//   const MimeInfo
//     **p,
//     **q;
// 
//   p=(const MimeInfo **) x,
//   q=(const MimeInfo **) y;
//   if (strcasecmp((*p)->path,(*q)->path) == 0)
//     return(strcasecmp((*p)->type,(*q)->type));
//   return(strcasecmp((*p)->path,(*q)->path));
// }
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).