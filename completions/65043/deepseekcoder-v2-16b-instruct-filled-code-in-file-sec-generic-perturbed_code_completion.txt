directory != NULL) {
        inputStream->directory = (char *) xmlStrdup(directory);
        xmlFree(directory);
    }
    inputStream->filename = (char *) URI;

    xmlBufResetInput(inputStream->buf->buffer, inputStream);
    return(inputStream);
}

/**
 * xmlNewInputFromFd:
 * @ctxt:  an XML parser context
 * @fd:  the file descriptor
 * @encoding:  the charset encoding if known
 *
 * Create a new input stream based on a file descriptor.
 *
 * Returns the new input stream or NULL in case of error
 */
xmlParserInputPtr
xmlNewInputFromFd(xmlParserCtxtPtr ctxt, int fd, xmlCharEncoding encoding) {
    xmlParserInputBufferPtr buf;
    xmlParserInputPtr inputStream;

    if (xmlParserDebugEntities)
	xmlGenericError(xmlGenericErrorContext, "new input from fd: %d\n", fd);
    if (ctxt == NULL) return(NULL);
    buf = xmlParserInputBufferCreateFd(fd, encoding);
    if (buf == NULL) {
        xmlErrMemory(ctxt, NULL);
	return(NULL);
    }

    inputStream = xmlNewInputStream(ctxt);
    if (inputStream == NULL) {
	xmlFreeParserInputBuffer(buf);
	return(NULL);
    }

    inputStream->buf = buf;
    inputStream = xmlCheckHTTPInput(ctxt, inputStream);
    if (inputStream == NULL)
        return(NULL);

    xmlBufResetInput(inputStream->buf->buffer, inputStream);
    return(inputStream);
}

/**
 * xmlNewInputFromIO:
 * @ctxt:  an XML parser context
 * @ioread:  the I/O read callback
 * @ioclose:  the I/O close callback
 * @ioinfo:  the I/O info
 * @encoding:  the charset encoding if known
 *
 * Create a new input stream based on a I/O callback.
 *
 * Returns the new input stream or NULL in case of error
 */
xmlParserInputPtr
xmlNewInputFromIO(xmlParserCtxtPtr ctxt, xmlInputReadCallback ioread,
                   xmlInputCloseCallback ioclose, void *ioinfo,
                   xmlCharEncoding encoding) {
    xmlParserInputBufferPtr buf;
    xmlParserInputPtr inputStream;

    if (xmlParserDebugEntities)
	xmlGenericError(xmlGenericErrorContext, "new input from I/O\n");
    if (ctxt == NULL) return(NULL);
    buf = xmlParserInputBufferCreateIO(ioread, ioclose, ioinfo, encoding);
    if (buf == NULL) {
        xmlErrMemory(ctxt, NULL);
	return(NULL);
    }

    inputStream = xmlNewInputStream(ctxt);
    if (inputStream == NULL) {
	xmlFreeParserInputBuffer(buf);
	return(NULL);
    }

    inputStream->buf = buf;
    inputStream = xmlCheckHTTPInput(ctxt, inputStream);
    if (inputStream == NULL)
        return(NULL);

    xmlBufResetInput(inputStream->buf->buffer, inputStream);
    return(inputStream);
}

/**
 * xmlNewInputFromMem:
 * @ctxt:  an XML parser context
 * @buffer:  the memory buffer
 * @size:  the size of the buffer
 * @encoding:  the charset encoding if known
 *
 * Create a new input stream based on a memory buffer.
 *
 * Returns the new input stream or NULL in case of error
 */
xmlParserInputPtr
xmlNewInputFromMem(xmlParserCtxtPtr ctxt, const char *buffer, int size,
                    xmlCharEncoding encoding) {
    xmlParserInputBufferPtr buf;
    xmlParserInputPtr inputStream;

    if (xmlParserDebugEntities)
	xmlGenericError(xmlGenericErrorContext, "new input from mem\n");
    if (ctxt == NULL) return(NULL);
    buf = xmlParserInputBufferCreateMem(buffer, size, encoding);
    if (buf == NULL) {
        xmlErrMemory(ctxt, NULL);
	return(NULL);
    }

    inputStream = xmlNewInputStream(ctxt);
    if (inputStream == NULL) {
	xmlFreeParserInputBuffer(buf);
	return(NULL);
    }

    inputStream->buf = buf;
    inputStream = xmlCheckHTTPInput(ctxt, inputStream);
    if (inputStream == NULL)
        return(NULL);

    xmlBufResetInput(inputStream->buf->buffer, inputStream);
    return(inputStream);
}

/**
 * xmlNewInputFromSource:
 * @ctxt:  an XML parser context
 * @source:  the source
 *
 * Create a new input stream based on an xmlParserInputBufferSrcPtr
 *
 * Returns the new input stream or NULL in case of error
 */
xmlParserInputPtr
xmlNewInputFromSource(xmlParserCtxtPtr ctxt, xmlParserInputBufferSrcPtr source) {
    xmlParserInputBufferPtr buf;
    xmlParserInputPtr inputStream;

    if (xmlParserDebugEntities)
	xmlGenericError(xmlGenericErrorContext, "new input from source\n");
    if (ctxt == NULL) return(NULL);
    buf = xmlParserInputBufferCreateSrc(source);
    if (buf == NULL) {
        xmlErrMemory(ctxt, NULL);
	return(NULL);
    }

    inputStream = xmlNewInputStream(ctxt);
    if (inputStream == NULL) {
	xmlFreeParserInputBuffer(buf);
	return(NULL);
    }

    inputStream->buf = buf;
    inputStream = xmlCheckHTTPInput(ctxt, inputStream);
    if (inputStream == NULL)
        return(NULL);

    xmlBufResetInput(inputStream->buf->buffer, inputStream);
    return(inputStream);
}

/**
 * xmlFreeParserInputBuffer:
 * @buf:  the parser input buffer
 *
 * Free up an input buffer.
 */
void
xmlFreeParserInputBuffer(xmlParserInputBufferPtr buf) {
    if (buf == NULL) return;
    if (buf->encoder != NULL) {
        xmlCharEncCloseFunc(buf->encoder);
        buf->encoder = NULL;
    }
    if (buf->readcallback != NULL) {
        buf->readcallback(buf->closecallback_arg);
        buf->readcallback = NULL;
    }
    if (buf->buffer != NULL) {
        xmlBufFree(buf->buffer);
        buf->buffer = NULL;
    }
    xmlFree(buf);
}

/**
 * xmlParserInputBufferCreateFilename:
 * @filename:  the filename
 * @encoding:  the charset encoding if known
 *
 * Create a new input buffer from a filename.
 *
 * Returns the new input buffer or NULL
 */
xmlParserInputBufferPtr
xmlParserInputBufferCreateFilename(const char *filename,
                                   xmlCharEncoding encoding) {
    xmlParserInputBufferPtr buf;
    xmlCharEncodingHandlerPtr handler;
    int res;

    buf = (xmlParserInputBufferPtr) xmlMalloc(sizeof(xmlParserInputBuffer));
    if (buf == NULL) {
        xmlErrMemory(NULL, "couldn't allocate a new input buffer\n");
        return(NULL);
    }
    memset(buf, 0, sizeof(xmlParserInputBuffer));

    res = xmlLookupCharEncodingHandler(encoding, &handler);
    if (res != 0) {
        xmlFree(buf);
        return(NULL);
    }

    buf->buffer = xmlBufCreate();
    if (buf->buffer == NULL) {
        xmlCharEncCloseFunc(handler);
        xmlFree(buf);
        return(NULL);
    }

    buf->encoder = handler;
    buf->readcallback = xmlFileRead;
    buf->closecallback_arg = (void *) filename;

    return(buf);
}

/**
 * xmlParserInputBufferCreateFd:
 * @fd:  the file descriptor
 * @encoding:  the charset encoding if known
 *
 * Create a new input buffer from a file descriptor.
 *
 * Returns the new input buffer or NULL
 */
xmlParserInputBufferPtr
xmlParserInputBufferCreateFd(int fd, xmlCharEncoding encoding) {
    xmlParserInputBufferPtr buf;
    xmlCharEncodingHandlerPtr handler;
    int res;

    buf = (xmlParserInputBufferPtr) xmlMalloc(sizeof(xmlParserInputBuffer));
    if (buf == NULL) {
        xmlErrMemory(NULL, "couldn't allocate a new input buffer\n");
        return(NULL);
    }
    memset(buf, 0, sizeof(xmlParserInputBuffer));

    res = xmlLookupCharEncodingHandler(encoding, &handler);
    if (res != 0) {
        xmlFree(buf);
        return(NULL);
    }

    buf->buffer = xmlBufCreate();
    if (buf->buffer == NULL) {
        xmlCharEncCloseFunc(handler);
        xmlFree(buf);
        return(NULL);
    }

    buf->encoder = handler;
    buf->readcallback = xmlFdRead;
    buf->closecallback_arg = (void *) (intptr_t) fd;

    return(buf);
}

/**
 * xmlParserInputBufferCreateIO:
 * @ioread:  the I/O read callback
 * @ioclose:  the I/O close callback
 * @ioinfo:  the I/O info
 * @encoding:  the charset encoding if known
 *
 * Create a new input buffer from a I/O callback.
 *
 * Returns the new input buffer or NULL
 */
xmlParserInputBufferPtr
xmlParserInputBufferCreateIO(xmlInputReadCallback ioread,
                              xmlInputCloseCallback ioclose, void *ioinfo,
                              xmlCharEncoding encoding) {
    xmlParserInputBufferPtr buf;
    xmlCharEncodingHandlerPtr handler;
    int res;

    buf = (xmlParserInputBufferPtr) xmlMalloc(sizeof(xmlParserInputBuffer));
    if (buf == NULL) {
        xmlErrMemory(NULL, "couldn't allocate a new input buffer\n");
        return(NULL);
    }
    memset(buf, 0, sizeof(xmlParserInputBuffer));

    res = xmlLookupCharEncodingHandler(encoding, &handler);
    if (res != 0) {
        xmlFree(buf);
        return(NULL);
    }

    buf->buffer = xmlBufCreate();
    if (buf->buffer == NULL) {
        xmlCharEncCloseFunc(handler);
        xmlFree(buf);
        return(NULL);
    }

    buf->encoder = handler;
    buf->readcallback = ioread;
    buf->closecallback_arg = ioclose;
    buf->ioinfo = ioinfo;

    return(buf);
}

/**
 * xmlParserInputBufferCreateString:
 * @buffer:  the memory buffer
 *
 * Create a new input buffer from a string.
 *
 * Returns the new input buffer or NULL
 */
xmlParserInputBufferPtr
xmlParserInputBufferCreateString(const xmlChar *buffer) {
    xmlParserInputBufferPtr buf;

    buf = (xmlParserInputBufferPtr) xmlMalloc(sizeof(xmlParserInputBuffer));
    if (buf == NULL) {
        xmlErrMemory(NULL, "couldn't allocate a new input buffer\n");
        return(NULL);
    }
    memset(buf, 0, sizeof(xmlParserInputBuffer));

    buf->buffer = xmlBufCreateStatic((xmlChar *) buffer, xmlStrlen(buffer));
    if (buf->buffer == NULL) {
        xmlFree(buf);
        return(NULL);
    }

    return(buf);
}

/**
 * xmlParserInputBufferCreateMem:
 * @buffer:  the memory buffer
 * @size:  the size of the buffer
 * @encoding:  the charset encoding if known
 *
 * Create a new input buffer from a memory buffer.
 *
 * Returns the new input buffer or NULL
 */
xmlParserInputBufferPtr
xmlParserInputBufferCreateMem(const char *buffer, int size,
                              xmlCharEncoding encoding) {
    xmlParserInputBufferPtr buf;
    xmlCharEncodingHandlerPtr handler;
    int res;

    buf = (xmlParserInputBufferPtr) xmlMalloc(sizeof(xmlParserInputBuffer));
    if (buf == NULL) {
        xmlErrMemory(NULL, "couldn't allocate a new input buffer\n");
        return(NULL);
    }
    memset(buf, 0, sizeof(xmlParserInputBuffer));

    res = xmlLookupCharEncodingHandler(encoding, &handler);
    if (res != 0) {
        xmlFree(buf);
        return(NULL);
    }

    buf->buffer = xmlBufCreateStatic((xmlChar *) buffer, size);
    if (buf->buffer == NULL) {