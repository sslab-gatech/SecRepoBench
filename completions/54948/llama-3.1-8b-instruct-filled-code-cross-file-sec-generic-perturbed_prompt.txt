Below is the content of a C/C++ function where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
static int node_from_openstep(parse_ctx ctx, plist_t *plist)
{
    plist_t subnode = NULL;
    const char *p = NULL;
    while (ctx->pos < ctx->end && !ctx->err) {
        parse_skip_ws(ctx);
        if (ctx->pos >= ctx->end) {
            break;
        }
        plist_data_t data = plist_new_plist_data();
        if (*ctx->pos == '{') {
            data->type = PLIST_DICT;
            subnode = plist_new_node(data);
            ctx->pos++;
            parse_dict_data(ctx, subnode);
            if (ctx->err) {
                goto err_out;
            }
            if (*ctx->pos != '}') {
                PLIST_OSTEP_ERR("Missing terminating '}' at offset %ld\n", ctx->pos - ctx->start);
                ctx->err++;
                goto err_out;
            }
            ctx->pos++;
            *plist = subnode;
            parse_skip_ws(ctx);
            break;
        } else if (*ctx->pos == '(') {
            data->type = PLIST_ARRAY;
            subnode = plist_new_node(data);
            ctx->pos++;
            plist_t tmp = NULL;
            while (ctx->pos < ctx->end && !ctx->err) {
                parse_skip_ws(ctx);
                if (*ctx->pos == ')') {
                    break;
                }
                ctx->err = node_from_openstep(ctx, &tmp);
                if (ctx->err != 0) {
                    break;
                }
                if (!tmp) {
                    ctx->err++;
                    break;
                }
                plist_array_append_item(subnode, tmp);
                tmp = NULL;
                parse_skip_ws(ctx);
                if (*ctx->pos != ',') {
                    break;
                }
                ctx->pos++;
            }
            if (ctx->err) {
                goto err_out;
            }
            if (*ctx->pos != ')') {
                PLIST_OSTEP_ERR("Missing terminating ')' at offset %ld\n", ctx->pos - ctx->start);
                ctx->err++;
                goto err_out;
            }
            ctx->pos++;
            *plist = subnode;
            parse_skip_ws(ctx);
            break;
        } else if (*ctx->pos == '<') {
            data->type = PLIST_DATA;
            ctx->pos++;
            bytearray_t *bytes = byte_array_new(256);
            while (ctx->pos < ctx->end && !ctx->err) {
                parse_skip_ws(ctx);
                if (*ctx->pos == '>') {
                    break;
                }
                if (!isxdigit(*ctx->pos)) {
                    PLIST_OSTEP_ERR("Invalid byte group in data at offset %ld\n", ctx->pos - ctx->start);
                    ctx->err++;
                    break;
                }
                uint8_t b = HEX_DIGIT(*ctx->pos);
                ctx->pos++;
                if (ctx->pos >= ctx->end) {
                    PLIST_OSTEP_ERR("Unexpected end of data at offset %ld\n", ctx->pos - ctx->start);
                    ctx->err++;
                    break;
                }
                if (!isxdigit(*ctx->pos)) {
                    PLIST_OSTEP_ERR("Invalid byte group in data at offset %ld\n", ctx->pos - ctx->start);
                    ctx->err++;
                    break;
                }
                b = (b << 4) + HEX_DIGIT(*ctx->pos);
                byte_array_append(bytes, &b, 1);
                ctx->pos++;
            }
            if (ctx->err) {
                byte_array_free(bytes);
                plist_free_data(data);
                goto err_out;
            }
            if (*ctx->pos != '>') {
                byte_array_free(bytes);
                plist_free_data(data);
                PLIST_OSTEP_ERR("Missing terminating '>' at offset %ld\n", ctx->pos - ctx->start);
                ctx->err++;
                goto err_out;
            }
            ctx->pos++;
            data->buff = bytes->data;
            data->length = bytes->len;
            bytes->data = NULL;
            byte_array_free(bytes);
            *plist = plist_new_node(data);
            parse_skip_ws(ctx);
            break;
        } else if (*ctx->pos == '"' || *ctx->pos == '\'') {
            char quote_char = *ctx->pos;
            ctx->pos++;
            p = ctx->pos;
            int num_escapes = 0;
            // Parse a quoted string from the input context, handling escape characters.
            // Traverse the input until a matching closing quote is found, ensuring it is not escaped.
            // Count escape characters encountered during parsing for later processing.
            // If the end of input is reached without finding the closing quote, log an error and set the error flag.
            // Calculate the length of the parsed string and allocate memory to store it.
            // Proceed to the next character after the closing quote for further parsing.
            // <MASK>
            if (num_escapes > 0) {
                size_t i = 0;
                size_t o = 0;
                while (i < slen) {
                    if (p[i] == '\\') {
                        /* handle escape sequence */
                        i++;
                        switch (p[i]) {
                            case '0':
                            case '1':
                            case '2':
                            case '3':
                            case '4':
                            case '5':
                            case '6':
                            case '7': {
                                // max 3 digits octal
                                unsigned char chr = 0;
                                int maxd = 3;
                                while ((i < slen) && (p[i] >= '0' && p[i] <= '7') && --maxd) {
                                    chr = (chr << 3) + p[i] - '0';
                                    i++;
                                }
                                strbuf[o++] = (char)chr;
                            }   break;
                            case 'U': {
                                i++;
                                // max 4 digits hex
                                uint16_t wchr = 0;
                                int maxd = 4;
                                while ((i < slen) && isxdigit(p[i]) && maxd--) {
                                    wchr = (wchr << 4) + ((p[i] <= '9') ? (p[i] - '0') : ((p[i] <= 'F') ? (p[i] - 'A' + 10) : (p[i] - 'a' + 10)));
                                    i++;
                                }
                                if (wchr >= 0x800) {
                                    strbuf[o++] = (char)(0xE0 + ((wchr >> 12) & 0xF));
                                    strbuf[o++] = (char)(0x80 + ((wchr >> 6) & 0x3F));
                                    strbuf[o++] = (char)(0x80 + (wchr & 0x3F));
                                } else if (wchr >= 0x80) {
                                    strbuf[o++] = (char)(0xC0 + ((wchr >> 6) & 0x1F));
                                    strbuf[o++] = (char)(0x80 + (wchr & 0x3F));
                                } else {
                                    strbuf[o++] = (char)(wchr & 0x7F);
                                }
                            }   break;
                            case 'a': strbuf[o++] = '\a'; i++; break;
                            case 'b': strbuf[o++] = '\b'; i++; break;
                            case 'f': strbuf[o++] = '\f'; i++; break;
                            case 'n': strbuf[o++] = '\n'; i++; break;
                            case 'r': strbuf[o++] = '\r'; i++; break;
                            case 't': strbuf[o++] = '\t'; i++; break;
                            case 'v': strbuf[o++] = '\v'; i++; break;
                            case '"': strbuf[o++] = '"';  i++; break;
                            case '\'': strbuf[o++] = '\''; i++; break;
                            default:
                                break;
                        }
                    } else {
                        strbuf[o++] = p[i++];
                    }
                }
                strbuf[o] = '\0';
                slen = o;
            } else {
                strncpy(strbuf, p, slen);
                strbuf[slen] = '\0';
            }
            data->type = PLIST_STRING;
            data->strval = strbuf;
            data->length = slen;
            *plist = plist_new_node(data);
            parse_skip_ws(ctx);
            break;
        } else {
            // unquoted string
            size_t slen = 0;
            parse_skip_ws(ctx);
            p = ctx->pos;
            while (ctx->pos < ctx->end) {
                if (!allowed_unquoted_chars[(uint8_t)*ctx->pos]) {
                    break;
                }
                ctx->pos++;
            }
            slen = ctx->pos-p;
            if (slen > 0) {
                data->type = PLIST_STRING;
                data->strval = strndup(p, slen);
                data->length = slen;
                *plist = plist_new_node(data);
                parse_skip_ws(ctx);
                break;
            } else {
                plist_free_data(data);
                PLIST_OSTEP_ERR("Unexpected character when parsing unquoted string at offset %ld\n", ctx->pos - ctx->start);
                ctx->err++;
                break;
            }
        }
        ctx->pos++;
    }

err_out:
    if (ctx->err) {
        plist_free(subnode);
        plist_free(*plist);
        *plist = NULL;
        return PLIST_ERR_PARSE;
    }
    return PLIST_ERR_SUCCESS;
}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/oplist.c
PLIST_API int plist_from_openstep(const char *plist_ostep, uint32_t length, plist_t * plist)
{
    if (!plist) {
        return PLIST_ERR_INVALID_ARG;
    }
    *plist = NULL;
    if (!plist_ostep || (length == 0)) {
        return PLIST_ERR_INVALID_ARG;
    }

    struct _parse_ctx ctx = { plist_ostep, plist_ostep, plist_ostep + length, 0 };

    int err = node_from_openstep(&ctx, plist);
    if (err == 0) {
        if (!*plist) {
            /* whitespace only file is considered an empty dictionary */
            *plist = plist_new_dict();
        } else if (ctx.pos < ctx.end && *ctx.pos == '=') {
            /* attempt to parse this as 'strings' data */
            plist_free(*plist);
            *plist = NULL;
            plist_t pl = plist_new_dict();
            ctx.pos = plist_ostep;
            parse_dict_data(&ctx, pl);
            if (ctx.err > 0) {
                plist_free(pl);
                PLIST_OSTEP_ERR("Failed to parse strings data\n");
                err = PLIST_ERR_PARSE;
            } else {
                *plist = pl;
            }
        }
    }

    return err;
}

// the below code fragment can be found in:
// src/xplist.c
static int unescape_entities(char *str, size_t *length)
{
    size_t i = 0;
    size_t len = *length;
    while (len > 0 && i < len-1) {
        if (str[i] == '&') {
            char *entp = str + i + 1;
            while (i < len && str[i] != ';') {
                i++;
            }
            if (i >= len) {
                PLIST_XML_ERR("Invalid entity sequence encountered (missing terminating ';')\n");
                return -1;
            }
            if (str+i >= entp+1) {
                int entlen = str+i - entp;
                int bytelen = 1;
                if (!strncmp(entp, "amp", 3)) {
                    /* the '&' is already there */
                } else if (!strncmp(entp, "apos", 4)) {
                    *(entp-1) = '\'';
                } else if (!strncmp(entp, "quot", 4)) {
                    *(entp-1) = '"';
                } else if (!strncmp(entp, "lt", 2)) {
                    *(entp-1) = '<';
                } else if (!strncmp(entp, "gt", 2)) {
                    *(entp-1) = '>';
                } else if (*entp == '#') {
                    /* numerical  character reference */
                    uint64_t val = 0;
                    char* ep = NULL;
                    if (entlen > 8) {
                        PLIST_XML_ERR("Invalid numerical character reference encountered, sequence too long: &%.*s;\n", entlen, entp);
                        return -1;
                    }
                    if (*(entp+1) == 'x' || *(entp+1) == 'X') {
                        if (entlen < 3) {
                            PLIST_XML_ERR("Invalid numerical character reference encountered, sequence too short: &%.*s;\n", entlen, entp);
                            return -1;
                        }
                        val = strtoull(entp+2, &ep, 16);
                    } else {
                        if (entlen < 2) {
                            PLIST_XML_ERR("Invalid numerical character reference encountered, sequence too short: &%.*s;\n", entlen, entp);
                            return -1;
                        }
                        val = strtoull(entp+1, &ep, 10);
                    }
                    if (val == 0 || val > 0x10FFFF || ep-entp != entlen) {
                        PLIST_XML_ERR("Invalid numerical character reference found: &%.*s;\n", entlen, entp);
                        return -1;
                    }
                    /* convert to UTF8 */
                    if (val >= 0x10000) {
                        /* four bytes */
                        *(entp-1) = (char)(0xF0 + ((val >> 18) & 0x7));
                        *(entp+0) = (char)(0x80 + ((val >> 12) & 0x3F));
                        *(entp+1) = (char)(0x80 + ((val >> 6) & 0x3F));
                        *(entp+2) = (char)(0x80 + (val & 0x3F));
                        entp+=3;
                        bytelen = 4;
                    } else if (val >= 0x800) {
                        /* three bytes */
                        *(entp-1) = (char)(0xE0 + ((val >> 12) & 0xF));
                        *(entp+0) = (char)(0x80 + ((val >> 6) & 0x3F));
                        *(entp+1) = (char)(0x80 + (val & 0x3F));
                        entp+=2;
                        bytelen = 3;
                    } else if (val >= 0x80) {
                        /* two bytes */
                        *(entp-1) = (char)(0xC0 + ((val >> 6) & 0x1F));
                        *(entp+0) = (char)(0x80 + (val & 0x3F));
                        entp++;
                        bytelen = 2;
                    } else {
                        /* one byte */
                        *(entp-1) = (char)(val & 0x7F);
                    }
                } else {
                    PLIST_XML_ERR("Invalid entity encountered: &%.*s;\n", entlen, entp);
                    return -1;
                }
                memmove(entp, str+i+1, len - i);
                i -= entlen+1 - bytelen;
                len -= entlen+2 - bytelen;
                continue;
            } else {
                PLIST_XML_ERR("Invalid empty entity sequence &;\n");
                return -1;
            }
        }
        i++;
    }
    *length = len;
    return 0;
}

// the below code fragment can be found in:
// src/xplist.c
PLIST_API plist_err_t plist_from_xml(const char *plist_xml, uint32_t length, plist_t * plist)
{
    if (!plist) {
        return PLIST_ERR_INVALID_ARG;
    }
    *plist = NULL;
    if (!plist_xml || (length == 0)) {
        return PLIST_ERR_INVALID_ARG;
    }

    struct _parse_ctx ctx = { plist_xml, plist_xml + length, 0 };

    return node_from_xml(&ctx, plist);
}

// the below code fragment can be found in:
// src/oplist.c
static void parse_dict_data(parse_ctx ctx, plist_t dict)
{
    plist_t key = NULL;
    plist_t val = NULL;
    while (ctx->pos < ctx->end && !ctx->err) {
        parse_skip_ws(ctx);
        if (*ctx->pos == '}' || ctx->pos >= ctx->end) {
            break;
        }
        key = NULL;
        ctx->err = node_from_openstep(ctx, &key);
        if (ctx->err != 0) {
            break;
        }
        if (!PLIST_IS_STRING(key)) {
            PLIST_OSTEP_ERR("Invalid type for dictionary key at offset %ld\n", ctx->pos - ctx->start);
            ctx->err++;
            break;
        }
        parse_skip_ws(ctx);
        if (*ctx->pos != '=') {
            PLIST_OSTEP_ERR("Missing '=' while parsing dictionary item at offset %ld\n", ctx->pos - ctx->start);
            ctx->err++;
            break;
        }
        ctx->pos++;
        if (ctx->pos >= ctx->end) {
            PLIST_OSTEP_ERR("EOF while parsing dictionary item at offset %ld\n", ctx->pos - ctx->start);
            ctx->err++;
            break;
        }
        val = NULL;
        ctx->err = node_from_openstep(ctx, &val);
        if (ctx->err != 0) {
            plist_free(key);
            break;
        }
        if (!val) {
            plist_free(key);
            PLIST_OSTEP_ERR("Missing value for dictionary item at offset %ld\n", ctx->pos - ctx->start);
            ctx->err++;
            break;
        }
        parse_skip_ws(ctx);
        if (*ctx->pos != ';') {
            plist_free(val);
            plist_free(key);
            PLIST_OSTEP_ERR("Missing terminating ';' while parsing dictionary item at offset %ld\n", ctx->pos - ctx->start);
            ctx->err++;
            break;
        }

        plist_dict_set_item(dict, plist_get_string_ptr(key, NULL), val);
        plist_free(key);
        val = NULL;

        ctx->pos++;
    }
}

// the below code fragment can be found in:
// src/xplist.c
static text_part_t* text_part_init(text_part_t* part, const char *begin, size_t length, int is_cdata)
{
    part->begin = begin;
    part->length = length;
    part->is_cdata = is_cdata;
    part->next = NULL;
    return part;
}
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).