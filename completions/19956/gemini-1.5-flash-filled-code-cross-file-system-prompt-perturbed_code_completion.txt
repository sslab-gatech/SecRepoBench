VarRegionList *dest = c->allocate_size<VarRegionList> (VarRegionList::get_size (src->axes.length, regionmapping.size ()));
    if (unlikely (dest == nullptr)) return false;
    dest->axes.length = src->axes.length;
    dest->regions.length = regionmapping.size ();
    unsigned int size = 0;
    for (unsigned int i = 0; i < regionmapping.size (); i++)
    {
      unsigned int region_index = regionmapping.get_value (i);
      if (region_index >= src->regions.length) return false;
      size += src->regions[region_index].data.length * sizeof (hb_variable_axis_t);
    }
    unsigned char *data = c->allocate_size<unsigned char> (size);
    if (unlikely (data == nullptr)) return false;
    unsigned int offset = 0;
    for (unsigned int i = 0; i < regionmapping.size (); i++)
    {
      unsigned int region_index = regionmapping.get_value (i);
      if (region_index >= src->regions.length) return false;
      const VarRegion &region = src->regions[region_index];
      memcpy (data + offset, region.data.array, region.data.length * sizeof (hb_variable_axis_t));
      offset += region.data.length * sizeof (hb_variable_axis_t);
    }
    dest->regions.allocate (regionmapping.size ());
    offset = 0;
    for (unsigned int i = 0; i < regionmapping.size (); i++)
    {
      unsigned int region_index = regionmapping.get_value (i);
      if (region_index >= src->regions.length) return false;
      const VarRegion &region = src->regions[region_index];
      dest->regions[i].data.allocate (region.data.length);
      memcpy (dest->regions[i].data.array, data + offset, region.data.length * sizeof (hb_variable_axis_t));
      offset += region.data.length * sizeof (hb_variable_axis_t);
    }
    return true;