VarRegionList *dest = c->extend_min (*src);
if (unlikely (!dest)) return_trace (false);

dest->axisCount = src->axisCount;
dest->regionCount = regionmapping.get_population ();

if (dest->regionCount)
{
  if (unlikely (hb_unsigned_mul_overflows (dest->regionCount, dest->axisCount)))
    return_trace (false);
  unsigned int total_axes = dest->regionCount * dest->axisCount;

  if (unlikely (hb_unsigned_mul_overflows (total_axes, F2DOT14::static_size)))
    return_trace (false);
  unsigned int regions_size = total_axes * F2DOT14::static_size;

  F2DOT14 *regions = c->allocate_size<F2DOT14> (regions_size);
  if (unlikely (!regions)) return_trace (false);

  for (unsigned int i = 0; i < dest->regionCount; i++)
  {
    hb_codepoint_t src_region_idx;
    if (!regionmapping.backward (i, &src_region_idx))
      return_trace (false);

    if (unlikely (src_region_idx >= src->regionCount))
      return_trace (false);

    const F2DOT14 *src_axes = src->regions[src_region_idx].axes;
    F2DOT14 *dest_axes = Â®ions[i * dest->axisCount];
    memcpy (dest_axes, src_axes, dest->axisCount * F2DOT14::static_size);
  }
}

return_trace (true);