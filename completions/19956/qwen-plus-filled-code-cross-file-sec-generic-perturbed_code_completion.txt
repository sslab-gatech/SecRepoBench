VarRegionList *dest = c->allocate_size<VarRegionList>(VarRegionList::min_size + VarRegion::static_size * src->get_region_count());
if (unlikely (dest == nullptr)) return false;
dest->regionCount = src->get_region_count();
dest->axisCount = regionmapping.get_axis_count();

for (unsigned int i = 0; i < dest->regionCount; i++) {
  const hb_vector_t<hb_pair_t<int16_t, uint16_t>> &mapped_axes = regionmapping.get_mapped_axes(i);
  if (unlikely (!mapped_axes.sanity_check([](const hb_pair_t<int16_t, uint16_t> &p) { return p.first != 0 && p.second != 0; }))) {
    return false;
  }

  VarRegion *region = c->allocate_size<VarRegion>(VarRegion::min_size + AxisTriple::static_size * mapped_axes.length);
  if (unlikely (region == nullptr)) return false;
  region->startCoord = mapped_axes.length;
  region->peakCoord = mapped_axes.length;
  region->endCoord = mapped_axes.length;

  for (unsigned int j = 0; j < mapped_axes.length; j++) {
    const hb_pair_t<int16_t, uint16_t> &axis_data = mapped_axes[j];
    AxisTriple *triple = c->allocate_size<AxisTriple>(AxisTriple::static_size);
    if (unlikely (triple == nullptr)) return false;
    triple->startCoord = axis_data.first - src->get_start_coord(i, j);
    triple->peakCoord = axis_data.first - src->get_peak_coord(i, j);
    triple->endCoord = axis_data.first - src->get_end_coord(i, j);
  }
}
return true;