{
  TRACE_SERIALIZE (this);

  VarRegionList *dest = c->extend_min (*this);
  if (unlikely (dest == nullptr)) return_trace (false);

  dest->regionAxisCount = src->regionAxisCount;
  dest->regionCount = regionmapping.get_population ();

  unsigned int size = VarRegion::min_size * dest->regionCount;
  VarRegion *regions = c->allocate_size<VarRegion> (size);
  if (unlikely (regions == nullptr)) return_trace (false);

  for (unsigned int i = 0; i < dest->regionCount; i++)
  {
    unsigned int mapped_region = regionmapping.get_second (i);
    if (mapped_region >= src->regionCount)
      return_trace (false); // Invalid mapping

    VarRegion *region = &regions[i];
    const auto &src_region = src->regions[mapped_region];

    region->startCoord = src_region.startCoord;
    region->peakCoord = src_region.peakCoord;
    region->endCoord = src_region.endCoord;

    // Ensure the axis count matches and copy axis data.
    if (src_region.axisCount != dest->regionAxisCount)
      return_trace (false); // Axis count mismatch

    for (unsigned int j = 0; j < dest->regionAxisCount; j++)
    {
      region->axes[j] = src_region.axes[j];
    }
  }

  return_trace (true);
}