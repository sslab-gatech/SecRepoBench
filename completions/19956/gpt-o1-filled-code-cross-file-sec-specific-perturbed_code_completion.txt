{
  TRACE_SERIALIZE (this);

  // Step 1: Extend the context with the source structure.
  VarRegionList *dest = c->extend_min (*src);
  if (unlikely (dest == nullptr))
    return_trace (false);

  // Step 2: Determine axis and region counts.
  unsigned int axisCount = src->axisCount;
  unsigned int regionCount = regionmapping.get_count();

  // Step 3: Record these counts in the destination structure.
  dest->axisCount = axisCount;
  dest->regionCount = regionCount;

  // If there are no regions, we are done.
  if (regionCount == 0)
    return_trace (true);

  // Step 4: Calculate the total number of axis entries to allocate and check for overflow.
  // Each region has 'axisCount' axis entries. We ensure the multiplication doesn't overflow size_t.
  if (unlikely (regionCount > SIZE_MAX / axisCount))
    return_trace (false);
  size_t totalAxes = (size_t) regionCount * axisCount;

  // Calculate total bytes needed for the axis data; assume 'VarRegionAxis' is the axis-entry type.
  // Also ensure no overflow in the next multiplication.
  if (unlikely (totalAxes > SIZE_MAX / sizeof (dest->regions[0].axes[0])))
    return_trace (false);
  size_t neededBytes = totalAxes * sizeof (dest->regions[0].axes[0]);

  // Step 5: Allocate the memory for all region-axis data at once.
  VarRegionAxis *allAxes = c->allocate_size<VarRegionAxis> (neededBytes);
  if (unlikely (allAxes == nullptr))
    return_trace (false);

  // Step 6: Copy the axis data from the source, using the mapping.
  for (unsigned int i = 0; i < regionCount; i++)
  {
    unsigned int mappedIndex = regionmapping.map (i);
    for (unsigned int j = 0; j < axisCount; j++)
    {
      allAxes[i * axisCount + j] = src->regions[mappedIndex].axes[j];
    }
  }

  // Step 7: Assign the allocated axis array back to 'dest->regions'.
  // Each element in 'dest->regions[i].axes' will refer to the correct slice of 'allAxes'.
  for (unsigned int i = 0; i < regionCount; i++)
    dest->regions[i].axes = &allAxes[i * axisCount];

  // Step 8: Serialization completed successfully.
  return_trace (true);
}