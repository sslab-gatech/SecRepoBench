{
  TRACE_SERIALIZE (this);

  VarRegionList *dest = c->allocate_size<VarRegionList> (VarRegionList::min_size);
  if (unlikely (dest == nullptr)) return_trace (false);

  unsigned int axis_count = src->get_axis_count ();
  unsigned int region_count = regionmapping.get_population ();

  dest->regionAxisCount = axis_count;

  // Allocate memory for regions
  VarRegion *regions = c->allocate_size<VarRegion> (region_count * VarRegion::min_size);
  if (unlikely (regions == nullptr)) return_trace (false);

  // Initialize each region's axis coordinate count
  for (unsigned int i = 0; i < region_count; i++)
    regions[i].axisCoordCount = axis_count;

  // Allocate memory for axis coordinates and copy data
  for (unsigned int rgn_idx = 0; rgn_idx < region_count; rgn_idx++) {
    const uint32_t src_rgn_idx = regionmapping.get_src_for_dst (rgn_idx);
    if (src_rgn_idx == UINT32_MAX)
      continue;

    VarRegionAxisCoordinates *coords = c->allocate_size<VarRegionAxisCoordinates> (axis_count * VarRegionAxisCoordinates::min_size);
    if (unlikely (coords == nullptr)) return_trace (false);

    for (unsigned int axis_idx = 0; axis_idx < axis_count; axis_idx++) {
      coords[axis_idx].startCoordinate = src->regions[src_rgn_idx].axisCoords[axis_idx].startCoordinate;
      coords[axis_idx].peakCoordinate = src->regions[src_rgn_idx].axisCoords[axis_idx].peakCoordinate;
      coords[axis_idx].endCoordinate = src->regions[src_rgn_idx].axisCoords[axis_idx].endCoordinate;
    }

    regions[rgn_idx].set_coords (coords, axis_count);
  }

  dest->set_regions (regions, region_count);

  return_trace (true);
}