TRACE_SERIALIZE (this);

    unsigned int axis_count = src->axis_count;
    unsigned int region_count = regionmapping.get_population ();

    if (unlikely (!hb_serialize_alloc (c, sizeof (VarRegionList) +
                                      region_count * sizeof (VarRegion) +
                                      axis_count * region_count * sizeof (float)))) return false;

    VarRegionList *dest = (VarRegionList *) hb_serialize_get_ptr (c, sizeof (VarRegionList));
    if (unlikely (!dest)) return false;
    VarRegion *regions = (VarRegion *) hb_serialize_get_ptr (c, region_count * sizeof (VarRegion));
    if (unlikely (!regions)) return false;
    float *coords = (float *) hb_serialize_get_ptr (c, axis_count * region_count * sizeof (float));
    if (unlikely (!coords)) return false;

    dest->axis_count = axis_count;
    dest->region_count = region_count;
    dest->regions = regions;
    for (unsigned int i = 0; i < region_count; i++)
    {
      hb_codepoint_t old_index = regionmapping.get_reverse (i);
      regions[i].start_coord = coords + i * axis_count;
      regions[i].end_coord = regions[i].start_coord + axis_count;
      if (old_index != HB_BIMA_INVALID_VALUE)
      {
        const VarRegion &srcregion = src->regions[old_index];
        memcpy (regions[i].start_coord, srcregion.start_coord, axis_count * sizeof (float));
      }
      else
      {
        memset (regions[i].start_coord, 0, axis_count * sizeof (float));
      }
    }

    hb_serialize_ptr_t<VarRegionList> ptr (dest);
    hb_serialize_ptr_t<VarRegion> regions_ptr (regions, region_count);
    hb_serialize_ptr_t<float> coords_ptr (coords, axis_count * region_count);

    return true;