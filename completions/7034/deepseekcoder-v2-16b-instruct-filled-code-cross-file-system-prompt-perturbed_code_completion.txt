// Allocate memory for the dash_polygon array to store points for the dashed polygon, considering the number of vertices.
// Return false if memory allocation fails.
PrimitiveInfo *dash_polygon = (PrimitiveInfo *) AcquireQuantumMemory((size_t) (2 * number_vertices), sizeof(*dash_polygon));
if (dash_polygon == (PrimitiveInfo *) NULL)
    return MagickFalse;

// Clone the draw_info structure to use in creating the dashed polygon.
DrawInfo *clone_info = CloneDrawInfo(draw_info);
if (clone_info == (DrawInfo *) NULL)
{
    dash_polygon = (PrimitiveInfo *) RelinquishMagickMemory(dash_polygon);
    return MagickFalse;
}

// Set the miter limit of the cloned draw_info to zero for line joins.
clone_info->miterlimit = 0.0;

// Initialize the first element of the dash_polygon with the first element of the primitive_info.
dash_polygon[0] = primitive_info[0];

// Calculate the scale factor from the affine transformation in the draw_info.
double scale = sqrt(draw_info->affine.sx * draw_info->affine.sx + draw_info->affine.rx * draw_info->affine.rx);

// Calculate the initial dash length and offset based on the dash pattern and dash offset from the draw_info.
double length, maximum_length, dash_offset, total_length;
dash_offset = draw_info->dash_offset;
n = 0;
for (length = 0.0; dash_offset > 0.0; n++)
{
    if (draw_info->dash_pattern[n] <= 0.0)
        break;
    length = scale * (draw_info->dash_pattern[n] + 0.5);
    if (dash_offset > length)
    {
        dash_offset -= length;
        n++;
        continue;
    }
    if (dash_offset < length)
    {
        length -= dash_offset;
        dash_offset = 0.0;
        break;
    }
    dash_offset = 0.0;
    n++;
}

// Calculate the initial dash length and offset based on the dash pattern and dash offset from the draw_info.
maximum_length = 0.0;
total_length = 0.0;
i = 1;
while ((i < (ssize_t) number_vertices) && (length >= 0.0))
{
    double dx = primitive_info[i].point.x - primitive_info[i - 1].point.x;
    double dy = primitive_info[i].point.y - primitive_info[i - 1].point.y;
    maximum_length = hypot(dx, dy);
    if (fabs(length) < DrawEpsilon)
    {
        n++;
        if (fabs(draw_info->dash_pattern[n]) < DrawEpsilon)
            n = 0;
        length = scale * (draw_info->dash_pattern[n] + 0.5);
    }
    for (total_length = 0.0; (length >= 0.0) && (maximum_length >= (total_length + length)); )
    {
        total_length += length;
        if ((n & 0x01) != 0)
        {
            dash_polygon[0] = primitive_info[0];
            dash_polygon[0].point.x = (double) (primitive_info[i - 1].point.x + dx * total_length / maximum_length);
            dash_polygon[0].point.y = (double) (primitive_info[i - 1].point.y + dy * total_length / maximum_length);
            j = 1;
        }
        else
        {
            if ((j + 1) > (ssize_t) (2 * number_vertices))
                break;
            dash_polygon[j] = primitive_info[i - 1];
            dash_polygon[j].point.x = (double) (primitive_info[i - 1].point.x + dx * total_length / maximum_length);
            dash_polygon[j].point.y = (double) (primitive_info[i - 1].point.y + dy * total_length / maximum_length);
            dash_polygon[j].coordinates = 1;
            j++;
            dash_polygon[0].coordinates = (size_t) j;
            dash_polygon[j].primitive = UndefinedPrimitive;
            status &= DrawStrokePolygon(image, clone_info, dash_polygon, exception);
        }
        n++;
        if (fabs(draw_info->dash_pattern[n]) < DrawEpsilon)
            n = 0;
        length = scale * (draw_info->dash_pattern[n] + 0.5);
    }
    length -= (maximum_length - total_length);
    if ((n & 0x01) != 0)
        continue;
    dash_polygon[j] = primitive_info[i];
    dash_polygon[j].coordinates = 1;
    j++;
}

if ((total_length <= maximum_length) && ((n & 0x01) == 0) && (j > 1))
{
    dash_polygon[j] = primitive_info[i - 1];
    dash_polygon[j].point.x += DrawEpsilon;
    dash_polygon[j].point.y += DrawEpsilon;
    dash_polygon[j].coordinates = 1;
    j++;
    dash_polygon[0].coordinates = (size_t) j;
    dash_polygon[j].primitive = UndefinedPrimitive;
    status &= DrawStrokePolygon(image, clone_info, dash_polygon, exception);
}

dash_polygon = (PrimitiveInfo *) RelinquishMagickMemory(dash_polygon);
clone_info = DestroyDrawInfo(clone_info);
if (image->debug != MagickFalse)
    (void) LogMagickEvent(DrawEvent, GetMagickModule(), "    end draw-dash");
return (status != 0 ? MagickTrue : MagickFalse);