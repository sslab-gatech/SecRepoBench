number_vertices=0;
while ((primitive_info[number_vertices].point.x != 0.0 || 
        primitive_info[number_vertices].point.y != 0.0) && 
       number_vertices < MAX_VERTICES)
{
    number_vertices++;
}
dash_polygon = (PrimitiveInfo *) AcquireQuantumMemory(number_vertices * 2, sizeof(*dash_polygon));
if (dash_polygon == (PrimitiveInfo *) NULL)
{
    return MagickFalse;
}
clone_info = CloneDrawInfo((Image *) NULL, draw_info);
if (clone_info == (DrawInfo *) NULL)
{
    dash_polygon = (PrimitiveInfo *) RelinquishMagickMemory(dash_polygon);
    return MagickFalse;
}
clone_info->miterlimit = 0;
dash_polygon[0] = primitive_info[0];
scale = hypot(draw_info->affine.sx, draw_info->affine.rx);
dash_offset = scale * (draw_info->dash_offset + 0.5);