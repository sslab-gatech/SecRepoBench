theta;

  size_t
    number_points;

  register ssize_t
    i;

  number_points=0;
  step=M_PI/(double) (360*MagickMin(degrees.x,degrees.y));
  for (theta=0.0, i=0; i < (ssize_t) degrees.x; i++, theta+=step)
  {
    primitive_info[number_points].point.x=start.x+cos(theta)*(stop.x-start.x)/2.0;
    primitive_info[number_points].point.y=start.y+sin(theta)*(stop.y-start.y)/2.0;
    primitive_info[number_points].coordinates=1;
    number_points++;
  }
  delta=M_PI/(double) (360*MagickMin(degrees.x,degrees.y));
  for (theta=0.0, i=0; i < (ssize_t) degrees.y; i++, theta+=delta)
  {
    primitive_info[number_points].point.x=start.x+cos(theta)*(stop.x-start.x)/2.0;
    primitive_info[number_points].point.y=start.y+sin(theta)*(stop.y-start.y)/2.0;
    primitive_info[number_points].coordinates=1;
    number_points++;
  }
  return(number_points);
}

static size_t EllipsePoints2(const PrimitiveInfo *primitive_info,
  const PointInfo start,const PointInfo stop,const PointInfo degrees)
{
  double
    delta,
    step,
    theta;

  size_t
    number_points;

  register ssize_t
    i;

  number_points=0;
  step=M_PI/(double) (360*MagickMin(degrees.x,degrees.y));
  for (theta=0.0, i=0; i < (ssize_t) degrees.x; i++, theta+=step)
  {
    primitive_info[number_points].point.x=start.x+cos(theta)*(stop.x-start.x)/2.0;
    primitive_info[number_points].point.y=start.y+sin(theta)*(stop.y-start.y)/2.0;
    primitive_info[number_points].coordinates=1;
    number_points++;
  }
  delta=M_PI/(double) (360*MagickMin(degrees.x,degrees.y));
  for (theta=0.0, i=0; i < (ssize_t) degrees.y; i++, theta+=delta)
  {
    primitive_info[number_points].point.x=start.x+cos(theta)*(stop.x-start.x)/2.0;
    primitive_info[number_points].point.y=start.y+sin(theta)*(stop.y-start.y)/2.0;
    primitive_info[number_points].coordinates=1;
    number_points++;
  }
  return(number_points);
}

static size_t EllipsePoints3(const PrimitiveInfo *primitive_info,
  const PointInfo start,const PointInfo stop,const PointInfo degrees)
{
  double
    delta,
    step,
    theta;

  size_t
    number_points;

  register ssize_t
    i;

  number_points=0;
  step=M_PI/(double) (360*MagickMin(degrees.x,degrees.y));
  for (theta=0.0, i=0; i < (ssize_t) degrees.x; i++, theta+=step)
  {
    primitive_info[number_points].point.x=start.x+cos(theta)*(stop.x-start.x)/2.0;
    primitive_info[number_points].point.y=start.y+sin(theta)*(stop.y-start.y)/2.0;
    primitive_info[number_points].coordinates=1;
    number_points++;
  }
  delta=M_PI/(double) (360*MagickMin(degrees.x,degrees.y));
  for (theta=0.0, i=0; i < (ssize_t) degrees.y; i++, theta+=delta)
  {
    primitive_info[number_points].point.x=start.x+cos(theta)*(stop.x-start.x)/2.0;
    primitive_info[number_points].point.y=start.y+sin(theta)*(stop.y-start.y)/2.0;
    primitive_info[number_points].coordinates=1;
    number_points++;
  }
  return(number_points);
}

static size_t EllipsePoints4(const PrimitiveInfo *primitive_info,
  const PointInfo start,const PointInfo stop,const PointInfo degrees)
{
  double
    delta,
    step,
    theta;

  size_t
    number_points;

  register ssize_t
    i;

  number_points=0;
  step=M_PI/(double) (360*MagickMin(degrees.x,degrees.y));
  for (theta=0.0, i=0; i < (ssize_t) degrees.x; i++, theta+=step)
  {
    primitive_info[number_points].point.x=start.x+cos(theta)*(stop.x-start.x)/2.0;
    primitive_info[number_points].point.y=start.y+sin(theta)*(stop.y-start.y)/2.0;
    primitive_info[number_points].coordinates=1;
    number_points++;
  }
  delta=M_PI/(double) (360*MagickMin(degrees.x,degrees.y));
  for (theta=0.0, i=0; i < (ssize_t) degrees.y; i++, theta+=delta)
  {
    primitive_info[number_points].point.x=start.x+cos(theta)*(stop.x-start.x)/2.0;
    primitive_info[number_points].point.y=start.y+sin(theta)*(stop.y-start.y)/2.0;
    primitive_info[number_points].coordinates=1;
    number_points++;
  }
  return(number_points);
}

static size_t EllipsePoints5(const PrimitiveInfo *primitive_info,
  const PointInfo start,const PointInfo stop,const PointInfo degrees)
{
  double
    delta,
    step,
    theta;

  size_t
    number_points;

  register ssize_t
    i;

  number_points=0;
  step=M_PI/(double) (360*MagickMin(degrees.x,degrees.y));
  for (theta=0.0, i=0; i < (ssize_t) degrees.x; i++, theta+=step)
  {
    primitive_info[number_points].point.x=start.x+cos(theta)*(stop.x-start.x)/2.0;
    primitive_info[number_points].point.y=start.y+sin(theta)*(stop.y-start.y)/2.0;
    primitive_info[number_points].coordinates=1;
    number_points++;
  }
  delta=M_PI/(double) (360*MagickMin(degrees.x,degrees.y));
  for (theta=0.0, i=0; i < (ssize_t) degrees.y; i++, theta+=delta)
  {
    primitive_info[number_points].point.x=start.x+cos(theta)*(stop.x-start.x)/2.0;
    primitive_info[number_points].point.y=start.y+sin(theta)*(stop.y-start.y)/2.0;
    primitive_info[number_points].coordinates=1;
    number_points++;
  }
  return(number_points);
}

static size_t EllipsePoints6(const PrimitiveInfo *primitive_info,
  const PointInfo start,const PointInfo stop,const PointInfo degrees)
{
  double
    delta,
    step,
    theta;

  size_t
    number_points;

  register ssize_t
    i;

  number_points=0;
  step=M_PI/(double) (360*MagickMin(degrees.x,degrees.y));
  for (theta=0.0, i=0; i < (ssize_t) degrees.x; i++, theta+=step)
  {
    primitive_info[number_points].point.x=start.x+cos(theta)*(stop.x-start.x)/2.0;
    primitive_info[number_points].point.y=start.y+sin(theta)*(stop.y-start.y)/2.0;
    primitive_info[number_points].coordinates=1;
    number_points++;
  }
  delta=M_PI/(double) (360*MagickMin(degrees.x,degrees.y));
  for (theta=0.0, i=0; i < (ssize_t) degrees.y; i++, theta+=delta)
  {
    primitive_info[number_points].point.x=start.x+cos(theta)*(stop.x-start.x)/2.0;
    primitive_info[number_points].point.y=start.y+sin(theta)*(stop.y-start.y)/2.0;
    primitive_info[number_points].coordinates=1;
    number_points++;
  }
  return(number_points);
}

static size_t EllipsePoints7(const PrimitiveInfo *primitive_info,
  const PointInfo start,const PointInfo stop,const PointInfo degrees)
{
  double
    delta,
    step,
    theta;

  size_t
    number_points;

  register ssize_t
    i;

  number_points=0;
  step=M_PI/(double) (360*MagickMin(degrees.x,degrees.y));
  for (theta=0.0, i=0; i < (ssize_t) degrees.x; i++, theta+=step)
  {
    primitive_info[number_points].point.x=start.x+cos(theta)*(stop.x-start.x)/2.0;
    primitive_info[number_points].point.y=start.y+sin(theta)*(stop.y-start.y)/2.0;
    primitive_info[number_points].coordinates=1;
    number_points++;
  }
  delta=M_PI/(double) (360*MagickMin(degrees.x,degrees.y));
  for (theta=0.0, i=0; i < (ssize_t) degrees.y; i++, theta+=delta)
  {
    primitive_info[number_points].point.x=start.x+cos(theta)*(stop.x-start.x)/2.0;
    primitive_info[number_points].point.y=start.y+sin(theta)*(stop.y-start.y)/2.0;
    primitive_info[number_points].coordinates=1;
    number_points++;
  }
  return(number_points);
}

static size_t EllipsePoints8(const PrimitiveInfo *primitive_info,
  const PointInfo start,const PointInfo stop,const PointInfo degrees)
{
  double
    delta,
    step,
    theta;

  size_t
    number_points;

  register ssize_t
    i;

  number_points=0;
  step=M_PI/(double) (360*MagickMin(degrees.x,degrees.y));
  for (theta=0.0, i=0; i < (ssize_t) degrees.x; i++, theta+=step)
  {
    primitive_info[number_points].point.x=start.x+cos(theta)*(stop.x-start.x)/2.0;
    primitive_info[number_points].point.y=start.y+sin(theta)*(stop.y-start.y)/2.0;
    primitive_info[number_points].coordinates=1;
    number_points++;
  }
  delta=M_PI/(double) (360*MagickMin(degrees.x,degrees.y));
  for (theta=0.0, i=0; i < (ssize_t) degrees.y; i++,