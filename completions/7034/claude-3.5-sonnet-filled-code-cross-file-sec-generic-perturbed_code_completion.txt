assert(draw_info != (DrawInfo *) NULL);
assert(primitive_info != (PrimitiveInfo *) NULL);
assert(exception != (ExceptionInfo *) NULL);

// Calculate the number of vertices
number_vertices=0;
for (i=0; primitive_info[i].primitive != UndefinedPrimitive; i++)
  number_vertices++;

// Allocate memory for the dash_polygon array
dash_polygon=(PrimitiveInfo *) AcquireQuantumMemory((size_t) (2*number_vertices+1),
  sizeof(*dash_polygon));
if (dash_polygon == (PrimitiveInfo *) NULL)
  return(MagickFalse);

// Clone the draw_info structure
clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
if (clone_info == (DrawInfo *) NULL)
{
  dash_polygon=(PrimitiveInfo *) RelinquishMagickMemory(dash_polygon);
  return(MagickFalse);
}
clone_info->miterlimit=0;

// Initialize the first element of dash_polygon
dash_polygon[0]=primitive_info[0];

// Calculate scale and initial dash length
scale=ExpandAffine(&draw_info->affine);
if (draw_info->dash_pattern != (double *) NULL)
  dash_offset=draw_info->dash_pattern[0];
else
  dash_offset=0.0;