// Calculate the number of vertices in the primitive_info array
  number_vertices = 0;
  while (primitive_info[number_vertices].primitive != UndefinedPrimitive)
    number_vertices++;

  // Allocate memory for the dash_polygon array
  dash_polygon = (PrimitiveInfo *) AcquireQuantumMemory(2 * number_vertices, sizeof(*dash_polygon));
  if (dash_polygon == (PrimitiveInfo *) NULL)
  {
    (void) ThrowMagickException(exception, GetMagickModule(), ResourceLimitError,
      "MemoryAllocationFailed", "`%s'", image->filename);
    return MagickFalse;
  }

  // Clone the draw_info structure
  clone_info = CloneDrawInfo((ImageInfo *) NULL, draw_info);
  if (clone_info == (DrawInfo *) NULL)
  {
    dash_polygon = (PrimitiveInfo *) RelinquishMagickMemory(dash_polygon);
    (void) ThrowMagickException(exception, GetMagickModule(), ResourceLimitError,
      "MemoryAllocationFailed", "`%s'", image->filename);
    return MagickFalse;
  }

  // Set miter limit to zero for line joins
  clone_info->miterlimit = 0.0;

  // Initialize the first element of dash_polygon
  dash_polygon[0] = primitive_info[0];

  // Calculate the scale factor from the affine transformation
  scale = ExpandAffine(&draw_info->affine);

  // Initialize dash length and offset
  dash_offset = draw_info->dash_offset;
  length = scale * draw_info->dash_pattern[0];