assert(draw_info != (DrawInfo *) NULL);
assert(primitive_info != (PrimitiveInfo *) NULL);
if (draw_info == (DrawInfo *) NULL || primitive_info == (PrimitiveInfo *) NULL)
  return(MagickFalse);
if (image->debug != MagickFalse)
  (void) LogMagickEvent(DrawEvent,GetMagickModule(),"    begin draw-dash");

/* Calculate the number of vertices */
for (number_vertices=0; primitive_info[number_vertices].primitive != UndefinedPrimitive; number_vertices++);
if (number_vertices < 2)
  return(MagickFalse);

/* Allocate memory for the dash_polygon array */
dash_polygon=(PrimitiveInfo *) AcquireQuantumMemory((size_t) (2*number_vertices+1),
  sizeof(*dash_polygon));
if (dash_polygon == (PrimitiveInfo *) NULL)
  return(MagickFalse);

/* Clone the draw_info structure */
clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
if (clone_info == (DrawInfo *) NULL)
  {
    dash_polygon=(PrimitiveInfo *) RelinquishMagickMemory(dash_polygon);
    return(MagickFalse);
  }
/* Set the miter limit to zero for line joins */
clone_info->miterlimit=0;

/* Initialize the first element of the dash_polygon */
dash_polygon[0]=primitive_info[0];
dash_polygon[0].coordinates=1;

/* Calculate the scale factor from the affine transformation */
scale=ExpandAffine(&clone_info->affine);

/* Calculate the initial dash length and offset */
dash_offset=clone_info->dash_offset;
n=0;