/* Calculate the number of vertices */
for (number_vertices = 0; primitive_info[number_vertices].primitive != UndefinedPrimitive; number_vertices++);

/* Allocate memory for the dash_polygon array */
dash_polygon = (PrimitiveInfo *) AcquireQuantumMemory(number_vertices + 1, sizeof(*dash_polygon));
if (dash_polygon == (PrimitiveInfo *) NULL)
  return(MagickFalse);

/* Clone the draw_info structure */
clone_info = CloneDrawInfo((const ImageInfo *) NULL, draw_info);
if (clone_info == (DrawInfo *) NULL)
{
  dash_polygon = (PrimitiveInfo *) RelinquishMagickMemory(dash_polygon);
  return(MagickFalse);
}

/* Set the miter limit of the cloned draw_info to zero */
clone_info->miterlimit = 0.0;

/* Initialize the first element of the dash_polygon */
dash_polygon[0] = primitive_info[0];

/* Calculate the scale factor from the affine transformation */
scale = fabs(ExpandAffine(&draw_info->affine));

/* Calculate the initial dash offset and dash length based on the dash pattern */
if (draw_info->dash_pattern != (double *) NULL)
{
  dash_offset = scale * draw_info->dash_offset;
  n = 0;
  length = scale * (draw_info->dash_pattern[n] + (n == 0 ? -0.5 : 0.5));
}
else
{
  dash_offset = 0.0;
  n = 0;
  length = 0.0;
}