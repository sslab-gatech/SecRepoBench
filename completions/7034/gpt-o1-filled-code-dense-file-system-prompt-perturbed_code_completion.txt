/*
    Ensure the drawing info is valid and log the start of dashing if enabled.
  */
  assert(draw_info != (DrawInfo *) NULL);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(DrawEvent,GetMagickModule(),"    begin draw-dash");

  /*
    Determine how many vertices are in the primitive_info by scanning until an
    undefined primitive is encountered.
  */
  number_vertices=0;
  while (primitive_info[number_vertices].primitive != UndefinedPrimitive)
    number_vertices++;

  /*
    Allocate storage for the dashed polygon. We use up to twice as many vertices
    to split edges into dash segments, plus a sentinel element.
  */
  dash_polygon=(PrimitiveInfo *) AcquireQuantumMemory((size_t) (2*number_vertices+2),
    sizeof(*dash_polygon));
  if (dash_polygon == (PrimitiveInfo *) NULL)
    return(MagickFalse);

  /*
    Clone the draw_info so we can tweak it for our dash rendering without
    affecting the original. Set its miterlimit to zero for sharp line joins.
  */
  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
  clone_info->miterlimit=0.0;

  /*
    Initialize the first element of dash_polygon and compute the scale factor
    from the affine transform. Also compute our dash offset in device space.
  */
  dash_polygon[0]=primitive_info[0];
  scale=ExpandAffine(&draw_info->affine);
  dash_offset=draw_info->dash_offset*scale;