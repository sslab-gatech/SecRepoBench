/* 1) Assert that draw_info is not NULL */
  assert(draw_info != (DrawInfo *) NULL);

  /* 2) Log the beginning of the draw-dash process if debugging is enabled */
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(DrawEvent,GetMagickModule(),"    begin draw-dash");

  /* 3) Calculate the number of vertices by iterating over the primitive_info array */
  for (number_vertices=0; primitive_info[number_vertices].primitive != UndefinedPrimitive; number_vertices++)
    ;

  /* 4) Allocate memory for the dash_polygon array and return false if allocation fails */
  dash_polygon=(PrimitiveInfo *) AcquireQuantumMemory((size_t) (2UL*number_vertices+2UL),
    sizeof(*dash_polygon));
  if (dash_polygon == (PrimitiveInfo *) NULL)
    return(MagickFalse);

  /* 5) Clone the draw_info structure for the dashed polygon */
  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
  if (clone_info == (DrawInfo *) NULL)
    {
      dash_polygon=(PrimitiveInfo *) RelinquishMagickMemory(dash_polygon);
      return(MagickFalse);
    }

  /* 6) Set the miter limit of the cloned draw_info to zero for line joins */
  clone_info->miterlimit=0;

  /* 7) Initialize the first element of dash_polygon */
  dash_polygon[0]=primitive_info[0];

  /* 8) Calculate the scale factor from the affine transformation in draw_info */
  scale=ExpandAffine(&draw_info->affine)*draw_info->stroke_width;

  /* 9) Calculate the initial dash offset from the draw_info */
  dash_offset=draw_info->dash_offset;