assert(draw_info != (const DrawInfo *) NULL);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(DrawEvent,GetMagickModule(),"    begin draw-dash");
  number_vertices=0;
  while (number_vertices < (ssize_t) GetNumberPrimitiveInfo(primitive_info) &&
    primitive_info[number_vertices].primitive != UndefinedPrimitive)
    number_vertices++;
  dash_polygon=(PrimitiveInfo *) AcquireQuantumMemory((size_t) (2*number_vertices+6*BezierQuantum+360),
    sizeof(*dash_polygon));
  if (dash_polygon == (PrimitiveInfo *) NULL)
    return(MagickFalse);
  clone_info=CloneDrawInfo(draw_info);
  if (clone_info == (DrawInfo *) NULL)
    {
      dash_polygon=(PrimitiveInfo *) RelinquishMagickMemory(dash_polygon);
      return(MagickFalse);
    }
  clone_info->miterlimit=0.0;
  dash_polygon[0]=primitive_info[0];
  scale=ExpandAffine(&draw_info->affine);
  if (draw_info->dash_pattern == (const double *) NULL)
    {
      dash_polygon=(PrimitiveInfo *) RelinquishMagickMemory(dash_polygon);
      clone_info=DestroyDrawInfo(clone_info);
      return(MagickFalse);
    }
  dash_offset=draw_info->dash_offset;
  n=0;
  length=scale*(draw_info->dash_pattern[n]+(n == 0 ? -0.5 : 0.5));
  if (length <= 0.0)
    {
      dash_polygon=(PrimitiveInfo *) RelinquishMagickMemory(dash_polygon);
      clone_info=DestroyDrawInfo(clone_info);
      return(MagickFalse);
    }