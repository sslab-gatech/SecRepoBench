static MagickBooleanType DrawDashPolygon(const DrawInfo *draw_info,
  const PrimitiveInfo *primitive_info,Image *image,ExceptionInfo *exception)
{
  // ... (previous code)

  // Calculate the scale factor from the affine transformation in the draw_info.
  scale=ExpandAffine(&draw_info->affine)*draw_info->stroke_width/2.0;

  // Calculate the initial dash length and offset based on the dash pattern and dash offset from the draw_info.
  length=scale*(draw_info->dash_pattern[n]+(n == 0 ? -0.5 : 0.5));
  dash_offset=scale*(draw_info->dash_pattern[n]+0.5);

  // ... (rest of the code)

  // Calculate the length of the current dash segment.
  length-=(maximum_length-total_length);

  // If the length of the current dash segment is less than 0, break the loop.
  if (length < 0.0)
    break;

  // If the length of the current dash segment is greater than the maximum length, adjust the length.
  if (maximum_length < (total_length+length))
    {
      length-=maximum_length-total_length;
      total_length=maximum_length;
    }

  // ... (rest of the code)

  // If the total length is less than the maximum length and the dash offset is 0, draw the final dash segment.
  if ((total_length <= maximum_length) && (dash_offset == 0.0) && (j > 1))
    {
      dash_polygon[j]=primitive_info[i-1];
      dash_polygon[j].point.x+=DrawEpsilon;
      dash_polygon[j].point.y+=DrawEpsilon;
      dash_polygon[j].coordinates=1;
      j++;
      dash_polygon[0].coordinates=(size_t) j;
      dash_polygon[j].primitive=UndefinedPrimitive;
      status&=DrawStrokePolygon(image,clone_info,dash_polygon,exception);
    }

  // ... (rest of the code)

  return(status != 0 ? MagickTrue : MagickFalse);
}