// Initialize a variable to store the bone index.
// Skip any spaces or line endings from the current position in the string.
// Parse an unsigned integer from the current position in the string to get the bone index.
// Check for parsing errors or if the parsed index is invalid, and handle these cases appropriately.
// If the parsed bone index is valid, ensure the list of bones is large enough to accommodate the index.
// Retrieve the bone object from the list using the parsed index.
// Set a flag to indicate if the bone name should be enclosed in double quotes.

unsigned int boneIndex = 0;
if (!ParseUnsignedInt(szCurrent, &szCurrent, boneIndex)) {
    LogErrorNoThrow("Unexpected EOF/EOL while parsing bone index");
    SMDI_PARSE_RETURN;
}

if (boneIndex >= bones.size()) {
    bones.resize(boneIndex + 1);
}

bone = bones[boneIndex];

if ('\"' != *szCurrent) {
    LogWarning("Bone name is expected to be enclosed in "
        "double quotation marks. ");
    bQuota = false;
} else {
    ++szCurrent;
}

const char* szEnd = szCurrent;
for ( ;; ) {
    if (bQuota && '\"' == *szEnd) {
        boneNameLength = (unsigned int)(szEnd - szCurrent);
        ++szEnd;
        break;
    } else if (!bQuota && IsSpaceOrNewLine(*szEnd)) {
        boneNameLength = (unsigned int)(szEnd - szCurrent);
        break;
    } else if (!(*szEnd)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing bone name");
        SMDI_PARSE_RETURN;
    }
    ++szEnd;
}
bone.mName = std::string(szCurrent,boneNameLength);
szCurrent = szEnd;

// the only negative bone parent index that could occur is -1 AFAIK
if(!ParseSignedInt(szCurrent,&szCurrent,(int&)bone.iParent))  {
    LogErrorNoThrow("Unexpected EOF/EOL while parsing bone parent index. Assuming -1");
    SMDI_PARSE_RETURN;
}

// go to the beginning of the next line
SMDI_PARSE_RETURN;