// <MASK>
void SMDImporter::ParseNodeInfo(const char* currentChar, const char** szCurrentOut) {
    // Initialize a variable to store the bone index.
    // Skip any spaces or line endings from the current position in the string.
    // Parse an unsigned integer from the current position in the string to get the bone index.
    // Check for parsing errors or if the parsed index is invalid, and handle these cases appropriately.
    // If the parsed bone index is valid, ensure the list of bones is large enough to accommodate the index.
    // Retrieve the bone object from the list using the parsed index.
    // Set a flag to indicate if the bone name should be enclosed in double quotes.
    if ('\"'!= *currentChar) {
        LogWarning("Bone name is expected to be enclosed in "
            "double quotation marks. ");
        bQuota = false;
    } else {
        ++currentChar;
    }

    const char* szEnd = currentChar;
    for ( ;; ) {
        if (bQuota && '\"' == *szEnd) {
            iBone = (unsigned int)(szEnd - currentChar);
            ++szEnd;
            break;
        } else if (!bQuota && IsSpaceOrNewLine(*szEnd)) {
            iBone = (unsigned int)(szEnd - currentChar);
            break;
        } else if (!(*szEnd)) {
            LogErrorNoThrow("Unexpected EOF/EOL while parsing bone name");
            SMDI_PARSE_RETURN;
        }
        ++szEnd;
    }
    bone.mName = std::string(currentChar,iBone);
    currentChar = szEnd;

    // the only negative bone parent index that could occur is -1 AFAIK
    if(!ParseSignedInt(currentChar,&currentChar,(int&)bone.iParent))  {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing bone parent index. Assuming -1");
        SMDI_PARSE_RETURN;
    }

    // go to the beginning of the next line
    SMDI_PARSE_RETURN;
}