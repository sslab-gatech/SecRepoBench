def mrb_ary_splice(mrb_state *mrb, mrb_value ary, mrb_int head, mrb_int len, mrb_value rpl)
  # ...
  if (ARY_SHARED_P(a) && a->as.heap.aux.shared->refcnt == 1 /* shared only referenced from this array */
      && a->as.heap.ptr - a->as.heap.aux.shared->ptr >= 1) /* there's room for unshifted item */ {
    a->as.heap.ptr -= len;
    if (!mrb_nil_p(rpl)) {
      array_copy(ARY_PTR(a), ARY_PTR(rpl), RARRAY_LEN(rpl));
    }
  }
  else {
    mrb_value *ptr;

    ary_modify(mrb, a);
    if (ARY_CAPA(a) < len + RARRAY_LEN(rpl)) {
      ary_expand_capa(mrb, a, len + RARRAY_LEN(rpl));
    }
    ptr = ARY_PTR(a) + head;
    value_move(ptr + RARRAY_LEN(rpl), ptr, len);
    if (!mrb_nil_p(rpl)) {
      array_copy(ptr, ARY_PTR(rpl), RARRAY_LEN(rpl));
    }
    ARY_SET_LEN(a, len + RARRAY_LEN(rpl));
  }
  mrb_write_barrier(mrb, (struct RBasic*)a);
  return ary;
end