if (head < 0) {
  head += arraylength;
  if (head < 0) {
    mrb_raisef(mrb, E_INDEX_ERROR, "index %i out of array", head - arraylength);
  }
}
tail = head + len;
if (tail > arraylength) {
  len = arraylength - head;
  if (len < 0) len = 0;
}
if (tail > ARY_MAX_SIZE - argc) {
  goto out_of_range;
}
if (head > arraylength) {
  if (head > ARY_MAX_SIZE - argc) {
    goto out_of_range;
  }
  len = head + argc;
  if (len > ARY_CAPA(a)) {
    ary_expand_capa(mrb, a, len);
  }
  ary_fill_with_nil(ARY_PTR(a) + arraylength, head - arraylength);
  if (argc > 0) {
    array_copy(ARY_PTR(a) + head, argv, argc);
  }
  ARY_SET_LEN(a, len);
}
else {
  mrb_int newlen;

  if (arraylength - len > ARY_MAX_SIZE - argc) {
    head = arraylength + argc - len;
    goto out_of_range;
  }
  newlen = arraylength + argc - len;
  if (newlen > ARY_CAPA(a)) {
    ary_expand_capa(mrb, a, newlen);
  }

  if (len!= argc) {
    mrb_value *ptr = ARY_PTR(a);
    value_move(ptr + head + argc, ptr + tail, arraylength - tail);
    ARY_SET_LEN(a, newlen);
  }
  if (argc > 0) {
    value_move(ARY_PTR(a) + head, argv, argc);
  }
}
mrb_write_barrier(mrb, (struct RBasic*)a);
return ary;