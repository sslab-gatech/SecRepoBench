AffineMatrix
    affine,
    current;

  char
    primitive_name[MagickPathExtent],
    geometry[MagickPathExtent],
    *next_token,
    pattern[MagickPathExtent],
    *primitive,
    *token;

  const char
    *q;

  double
    factor,
    primitive_extent;

  DrawInfo
    **graphic_context;

  MagickBooleanType
    status;

  MVGInfo
    mvg_info;

  PointInfo
    point;

  PrimitiveInfo
    *primitive_info;

  size_t
    extent,
    length,
    number_stops;

  ssize_t
    n;

  StopInfo
    *stops;

  /*
    Initialize draw context.
  */
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
  assert(draw_info != (DrawInfo *) NULL);
  assert(draw_info->signature == MagickCoreSignature);
  if (draw_info->primitive == (char *) NULL)
    return(MagickFalse);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(DrawEvent,GetMagickModule(),"begin draw-image");
  status=MagickTrue;
  extent=2048;
  graphic_context=(DrawInfo **) AcquireQuantumMemory(1,sizeof(*graphic_context));
  if (graphic_context == (DrawInfo **) NULL)
    ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
      image->filename);
  graphic_context[0]=CloneDrawInfo((ImageInfo *) NULL,draw_info);
  n=0;
  stops=(StopInfo *) NULL;
  token=AcquireString(draw_info->primitive);
  primitive=AcquireString(draw_info->primitive);
  primitive_info=(PrimitiveInfo *) AcquireQuantumMemory(extent,
    sizeof(*primitive_info));
  if (primitive_info == (PrimitiveInfo *) NULL)
    ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
      image->filename);
  mvg_info.primitive_info=&primitive_info;
  mvg_info.extent=&extent;
  mvg_info.offset=0;
  mvg_info.exception=exception;
  GetAffineMatrix(&affine);
  GetAffineMatrix(&current);
  point.x=0.0;
  point.y=0.0;
  factor=ExpandAffine(&current);
  primitive_extent=0.0;
  (void) ResetMagickMemory(primitive_info,0,extent*sizeof(*primitive_info));
  for (q=primitive; *q != '\0'; )
  {
    /*
      Interpret graphic primitive.
    */
    GetNextToken(q,&q,MagickPathExtent,token);
    if (*token == '\0')
      break;
    if (*token == '#')
      {
        while ((*q != '\n') && (*q != '\0'))
          q++;
        continue;
      }
    (void) CopyMagickString(primitive_name,token,MagickPathExtent);
    if (LocaleCompare("affine",token) == 0)
      {
        /*
          Affine matrix.
        */
        GetNextToken(q,&q,MagickPathExtent,token);
        affine.sx=StringToDouble(token,&next_token);
        GetNextToken(q,&q,MagickPathExtent,token);
        affine.rx=StringToDouble(token,&next_token);
        GetNextToken(q,&q,MagickPathExtent,token);
        affine.ry=StringToDouble(token,&next_token);
        GetNextToken(q,&q,MagickPathExtent,token);
        affine.sy=StringToDouble(token,&next_token);
        GetNextToken(q,&q,MagickPathExtent,token);
        affine.tx=StringToDouble(token,&next_token);
        GetNextToken(q,&q,MagickPathExtent,token);
        affine.ty=StringToDouble(token,&next_token);
        continue;
      }
    if (LocaleCompare("clip-path",token) == 0)
      {
        char
          name[MagickPathExtent];

        /*
          Clip path.
        */
        GetNextToken(q,&q,MagickPathExtent,token);
        (void) CopyMagickString(name,token,MagickPathExtent);
        status=DrawClipPath(image,graphic_context[n],name,exception);
        continue;
      }
    if (LocaleCompare("clip-rule",token) == 0)
      {
        /*
          Clip rule.
        */
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->fill_rule=(FillRule) ParseCommandOption(
          MagickFillRuleOptions,MagickFalse,token);
        continue;
      }
    if (LocaleCompare("clip-units",token) == 0)
      {
        /*
          Clip units.
        */
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->clip_units=(ClipPathUnits) ParseCommandOption(
          MagickClipPathOptions,MagickFalse,token);
        continue;
      }
    if (LocaleCompare("composite",token) == 0)
      {
        char
          name[MagickPathExtent];

        /*
          Composite mask.
        */
        GetNextToken(q,&q,MagickPathExtent,token);
        (void) CopyMagickString(name,token,MagickPathExtent);
        graphic_context[n]->composite_mask=DrawCompositeMask(image,
          graphic_context[n],name,GetImageArtifact(image,name),exception);
        continue;
      }
    if (LocaleCompare("decorate",token) == 0)
      {
        /*
          Text decorate.
        */
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->decorate=(DecorationType) ParseCommandOption(
          MagickDecorateOptions,MagickFalse,token);
        continue;
      }
    if (LocaleCompare("density",token) == 0)
      {
        /*
          Density.
        */
        GetNextToken(q,&q,MagickPathExtent,token);
        (void) CloneString(&graphic_context[n]->density,token);
        continue;
      }
    if (LocaleCompare("direction",token) == 0)
      {
        /*
          Text direction.
        */
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->direction=(DirectionType) ParseCommandOption(
          MagickDirectionOptions,MagickFalse,token);
        continue;
      }
    if (LocaleCompare("encoding",token) == 0)
      {
        /*
          Text encoding.
        */
        GetNextToken(q,&q,MagickPathExtent,token);
        (void) CloneString(&graphic_context[n]->encoding,token);
        continue;
      }
    if (LocaleCompare("fill",token) == 0)
      {
        /*
          Fill color.
        */
        GetNextToken(q,&q,MagickPathExtent,token);
        (void) QueryColorCompliance(token,AllCompliance,
          &graphic_context[n]->fill,exception);
        continue;
      }
    if (LocaleCompare("fill-opacity",token) == 0)
      {
        /*
          Fill opacity.
        */
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->fill_alpha=StringToDouble(token,&next_token);
        continue;
      }
    if (LocaleCompare("fill-rule",token) == 0)
      {
        /*
          Fill rule.
        */
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->fill_rule=(FillRule) ParseCommandOption(
          MagickFillRuleOptions,MagickFalse,token);
        continue;
      }
    if (LocaleCompare("font",token) == 0)
      {
        /*
          Font.
        */
        GetNextToken(q,&q,MagickPathExtent,token);
        (void) CloneString(&graphic_context[n]->font,token);
        continue;
      }
    if (LocaleCompare("font-family",token) == 0)
      {
        /*
          Font family.
        */
        GetNextToken(q,&q,MagickPathExtent,token);
        (void) CloneString(&graphic_context[n]->family,token);
        continue;
      }
    if (LocaleCompare("font-size",token) == 0)
      {
        /*
          Pointsize.
        */
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->pointsize=StringToDouble(token,&next_token);
        continue;
      }
    if (LocaleCompare("font-stretch",token) == 0)
      {
        /*
          Font stretch.
        */
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->stretch=(StretchType) ParseCommandOption(
          MagickStretchOptions,MagickFalse,token);
        continue;
      }
    if (LocaleCompare("font-style",token) == 0)
      {
        /*
          Font style.
        */
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->style=(StyleType) ParseCommandOption(
          MagickStyleOptions,MagickFalse,token);
        continue;
      }
    if (LocaleCompare("font-weight",token) == 0)
      {
        /*
          Font weight.
        */
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->weight=StringToUnsignedLong(token);
        continue;
      }
    if (LocaleCompare("gravity",token) == 0)
      {
        /*
          Text gravity.
        */
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->gravity=(GravityType) ParseCommandOption(
          MagickGravityOptions,MagickFalse,token);
        continue;
      }
    if (LocaleCompare("image",token) == 0)
      {
        /*
          Image primitive.
        */
        GetNextToken(q,&q,MagickPathExtent,token);
        (void) CloneString(&primitive_info->text,token);
        primitive_info->primitive=ImagePrimitive;
        primitive_info->coordinates=1;
        status&=DrawPrimitive(image,graphic_context[n],primitive_info,
          exception);
        continue;
      }
    if (LocaleCompare("interline-spacing",token) == 0)
      {
        /*
          Interline spacing.
        */
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->interline_spacing=StringToDouble(token,&next_token);
        continue;
      }
    if (LocaleCompare("interword-spacing",token) == 0)
      {
        /*
          Interword spacing.
        */
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->interword_spacing=StringToDouble(token,&next_token);
        continue;
      }
    if (LocaleCompare("kerning",token) == 0)
      {
        /*
          Kerning.
        */
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->kerning=StringToDouble(token,&next_token);
        continue;
      }
    if (LocaleCompare("linecap",token) == 0)
      {
        /*
          Line cap.
        */
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->linecap=(LineCap) ParseCommandOption(
          MagickLineCapOptions,MagickFalse,token);
        continue;
      }
    if (LocaleCompare("linejoin",token) == 0)
      {
        /*
          Line join.
        */
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->linejoin=(LineJoin) ParseCommandOption(
          MagickLineJoinOptions,MagickFalse,token);
        continue;
      }
    if (LocaleCompare("miterlimit",token) == 0)
      {
        /*
          Miter limit.
        */
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->miterlimit=StringToUnsignedLong(token);
        continue;
      }
    if (LocaleCompare("opacity",token) == 0)
      {
        /*
          Opacity.
        */
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->alpha=StringToDouble(token,&next_token);
        continue;
      }
    if (LocaleCompare("path",token) == 0)
      {
        /*
          Path.
        */
        GetNextToken(q,&q,MagickPathExtent,token);
        (void) CloneString(&primitive_info->text,token);
        primitive_info->primitive=PathPrimitive;
        primitive_info->coordinates=1;
        status&=DrawPrimitive(image,graphic_context[n],primitive_info,
          exception);
        continue;
      }
    if (LocaleCompare("pattern",token) == 0)
      {
        /*
          Pattern.
        */
        GetNextToken(q,&q,MagickPathExtent,token);
        (void) CloneString(&primitive_info->text,token);
        primitive_info->primitive=PatternPrimitive;
        primitive_info->coordinates=1;
        status&=DrawPrimitive(image,graphic_context[n],primitive_info,
          exception);
        continue;
      }
    if (LocaleCompare("pointsize",token) == 0)
      {
        /*
          Pointsize.
        */
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->pointsize=StringToDouble(token,&next_token);
        continue;
      }
    if (LocaleCompare("pop",token) == 0)
      {
        /*
          Pop graphic context.
        */
        if (n == 0)
          continue;
        n--;
        continue;
      }
    if (LocaleCompare("push",token) == 0)
      {
        /*
          Push graphic context.
        */
        n++;
        if ((size_t) n >= extent)
          {
            extent<<=1;
            graphic_context=(DrawInfo **) ResizeQuantumMemory(graphic_context,
              extent,sizeof(*graphic_context));
            if (graphic_context == (DrawInfo **) NULL)
              ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
                image->filename);
          }
        graphic_context[n]=CloneDrawInfo((ImageInfo *) NULL,
          graphic_context[n-1]);
        continue;
      }
    if (LocaleCompare("rectangle",token) == 0)
      {
        /*