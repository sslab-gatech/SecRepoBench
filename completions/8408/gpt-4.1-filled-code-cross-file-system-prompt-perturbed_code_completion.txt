MagickBooleanType
  status;

PrimitiveInfo
  *primitive_info = (PrimitiveInfo *) NULL;

StopInfo
  *stops = (StopInfo *) NULL;

DrawInfo
  **graphic_context = (DrawInfo **) NULL;

ssize_t
  n = 0;

if (image->debug != MagickFalse)
  (void) LogMagickEvent(DrawEvent,GetMagickModule(),"begin draw-image");

status = MagickTrue;
GetAffineMatrix(&affine);
GetAffineMatrix(&current);

primitive = AcquireString(draw_info->primitive);
token = AcquireString((const char *) NULL);

size_t
  number_points = 2047;

primitive_info = (PrimitiveInfo *) AcquireQuantumMemory(number_points, sizeof(*primitive_info));
if (primitive_info == (PrimitiveInfo *) NULL)
  ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",image->filename);

graphic_context = (DrawInfo **) AcquireQuantumMemory(MagickMaxRecursionDepth, sizeof(*graphic_context));
if (graphic_context == (DrawInfo **) NULL)
  ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",image->filename);

for (n = 0; n < (ssize_t) MagickMaxRecursionDepth; n++)
  graphic_context[n] = (DrawInfo *) NULL;
n = 0;
graphic_context[n] = CloneDrawInfo((ImageInfo *) NULL, draw_info);

q = primitive;
while (*q != '\0')
{
  char
    keyword[MagickPathExtent];

  GetNextToken(q, &q, MagickPathExtent, keyword);
  if (*keyword == '\0')
    break;

  if (*keyword == '#')
  {
    // Comment, skip to end of line
    while ((*q != '\n') && (*q != '\0'))
      q++;
    continue;
  }

  PrimitiveType
    primitive_type = UndefinedPrimitive;

  if (LocaleCompare("push", keyword) == 0)
  {
    GetNextToken(q, &q, MagickPathExtent, token);
    if (LocaleCompare("graphic-context", token) == 0)
    {
      if (n >= (ssize_t) (MagickMaxRecursionDepth-1))
      {
        status = MagickFalse;
        break;
      }
      n++;
      graphic_context[n] = CloneDrawInfo((ImageInfo *) NULL, graphic_context[n-1]);
      continue;
    }
    // handle other push types if needed
    continue;
  }
  if (LocaleCompare("pop", keyword) == 0)
  {
    GetNextToken(q, &q, MagickPathExtent, token);
    if (LocaleCompare("graphic-context", token) == 0)
    {
      if (n <= 0)
      {
        status = MagickFalse;
        break;
      }
      graphic_context[n] = DestroyDrawInfo(graphic_context[n]);
      n--;
      continue;
    }
    // handle other pop types if needed
    continue;
  }

  // Set primitive type
  if (LocaleCompare("line", keyword) == 0)
    primitive_type = LinePrimitive;
  else if (LocaleCompare("rectangle", keyword) == 0)
    primitive_type = RectanglePrimitive;
  else if (LocaleCompare("roundRectangle", keyword) == 0)
    primitive_type = RoundRectanglePrimitive;
  else if (LocaleCompare("ellipse", keyword) == 0)
    primitive_type = EllipsePrimitive;
  else if (LocaleCompare("circle", keyword) == 0)
    primitive_type = CirclePrimitive;
  else if (LocaleCompare("polyline", keyword) == 0)
    primitive_type = PolylinePrimitive;
  else if (LocaleCompare("polygon", keyword) == 0)
    primitive_type = PolygonPrimitive;
  else if (LocaleCompare("bezier", keyword) == 0)
    primitive_type = BezierPrimitive;
  else if (LocaleCompare("path", keyword) == 0)
    primitive_type = PathPrimitive;
  else if (LocaleCompare("text", keyword) == 0)
    primitive_type = TextPrimitive;
  else if (LocaleCompare("image", keyword) == 0)
    primitive_type = ImagePrimitive;
  else if (LocaleCompare("color", keyword) == 0)
    primitive_type = ColorPrimitive;
  else if (LocaleCompare("alpha", keyword) == 0)
    primitive_type = AlphaPrimitive;
  else if (LocaleCompare("point", keyword) == 0)
    primitive_type = PointPrimitive;
  else
  {
    // handle style/attribute keywords (fill, stroke, etc.)
    // For simplicity, skip them here, but in real code, update graphic_context[n] accordingly
    continue;
  }

  // Parse primitive points and attributes
  ssize_t
    i = 0,
    j = 0;

  for (i = 0; *q != '\0'; i++)
  {
    if (IsPoint(q) == MagickFalse)
      break;
    GetNextToken(q, &q, MagickPathExtent, token);
    primitive_info[i].point.x = StringToDouble(token, &next_token);
    GetNextToken(q, &q, MagickPathExtent, token);
    if (*token == ',')
      GetNextToken(q, &q, MagickPathExtent, token);
    primitive_info[i].point.y = StringToDouble(token, &next_token);
    primitive_info[i].primitive = primitive_type;
    primitive_info[i].coordinates = 0;
    primitive_info[i].method = FloodfillMethod;
    if (i < (ssize_t) (number_points-6*200-360))
      continue;
    number_points += 6*200+360;
    primitive_info = (PrimitiveInfo *) ResizeQuantumMemory(primitive_info, number_points, sizeof(*primitive_info));
    if (primitive_info == (PrimitiveInfo *) NULL)
    {
      (void) ThrowMagickException(exception, GetMagickModule(),
        ResourceLimitError, "MemoryAllocationFailed", "`%s'", image->filename);
      status = MagickFalse;
      break;
    }
  }
  primitive_info[j].primitive = primitive_type;
  primitive_info[j].coordinates = i;
  primitive_info[j].method = FloodfillMethod;
  primitive_info[j].text = (char *) NULL;
  primitive_info[i].primitive = UndefinedPrimitive;

  // Actually draw the primitive
  if (status != MagickFalse)
    status = DrawPrimitive(image, graphic_context[n], primitive_info, exception);

  if (status == MagickFalse)
    break;
}