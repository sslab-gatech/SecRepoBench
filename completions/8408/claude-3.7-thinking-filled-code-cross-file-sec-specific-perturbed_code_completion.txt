/*
  Initialize drawing resources.
*/
token=AcquireString(draw_info->primitive);
if (token == (char *) NULL)
  ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
    image->filename);
primitive=token;
primitive_type=UndefinedPrimitive;
n=0;
status=MagickTrue;
stops=(StopInfo *) NULL;
number_stops=0;
graphic_context=(DrawInfo **) AcquireQuantumMemory(DrawInfoStackSize,
  sizeof(*graphic_context));
if (graphic_context == (DrawInfo **) NULL)
  {
    token=DestroyString(token);
    ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
      image->filename);
  }
graphic_context[n]=CloneDrawInfo((ImageInfo *) NULL,draw_info);
if (graphic_context[n] == (DrawInfo *) NULL)
  {
    token=DestroyString(token);
    graphic_context=(DrawInfo **) RelinquishMagickMemory(graphic_context);
    ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
      image->filename);
  }
number_points=2047;
primitive_info=(PrimitiveInfo *) AcquireQuantumMemory(number_points,
  sizeof(*primitive_info));
if (primitive_info == (PrimitiveInfo *) NULL)
  {
    token=DestroyString(token);
    graphic_context[n]=DestroyDrawInfo(graphic_context[n]);
    graphic_context=(DrawInfo **) RelinquishMagickMemory(graphic_context);
    ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
      image->filename);
  }
(void) memset(primitive_info,0,number_points*sizeof(*primitive_info));
primitive_info[0].primitive=UndefinedPrimitive;
if (image->debug != MagickFalse)
  (void) LogMagickEvent(DrawEvent,GetMagickModule(),"begin draw-image");
for (q=(char *) draw_info->primitive; *q != '\0'; )
{
  /*
    Interpret drawing primitive.
  */
  GetNextToken(q,&q,MagickPathExtent,token);
  if (*token == '\0')
    break;
  if (*token == '#')
    {
      /*
        Comment.
      */
      while ((*q != '\n') && (*q != '\0'))
        q++;
      continue;
    }
  if (LocaleCompare("push",token) == 0)
    {
      /*
        Push graphic context.
      */
      n++;
      if (n >= (ssize_t) DrawInfoStackSize)
        {
          DrawInfo
            **graphic_contexts;

          graphic_contexts=(DrawInfo **) ResizeQuantumMemory(graphic_context,
            (size_t) (n+DrawInfoStackSize),sizeof(*graphic_context));
          if (graphic_contexts == (DrawInfo **) NULL)
            {
              primitive_info=(PrimitiveInfo *) RelinquishMagickMemory(
                primitive_info);
              if (stops != (StopInfo *) NULL)
                stops=(StopInfo *) RelinquishMagickMemory(stops);
              primitive=DestroyString(primitive);
              token=DestroyString(token);
              for (i=0; i < n; i++)
                graphic_context[i]=DestroyDrawInfo(graphic_context[i]);
              graphic_context=(DrawInfo **) RelinquishMagickMemory(
                graphic_context);
              ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
                image->filename);
            }
          graphic_context=graphic_contexts;
        }
      graphic_context[n]=CloneDrawInfo((ImageInfo *) NULL,
        graphic_context[n-1]);
      if (graphic_context[n] == (DrawInfo *) NULL)
        {
          primitive_info=(PrimitiveInfo *) RelinquishMagickMemory(
            primitive_info);
          if (stops != (StopInfo *) NULL)
            stops=(StopInfo *) RelinquishMagickMemory(stops);
          primitive=DestroyString(primitive);
          token=DestroyString(token);
          for (i=0; i < n; i++)
            graphic_context[i]=DestroyDrawInfo(graphic_context[i]);
          graphic_context=(DrawInfo **) RelinquishMagickMemory(graphic_context);
          ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
            image->filename);
        }
      continue;
    }
  if (LocaleCompare("pop",token) == 0)
    {
      /*
        Pop graphic context.
      */
      if (n <= 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),DrawError,
            "UnbalancedGraphicContextPushPop","`%s'",image->filename);
          status=MagickFalse;
          break;
        }
      graphic_context[n]=DestroyDrawInfo(graphic_context[n]);
      n--;
      continue;
    }
  
  /* Process other drawing primitives here */
  
  /*
    Check for primitive attributes.
  */
  i=0;
  j=0;
  primitive_type=UndefinedPrimitive;
  
  /* Set primitive_type based on token */
  
  if (primitive_type == UndefinedPrimitive)
    continue;
  
  /*
    Parse primitive attributes.
  */
  for (x=0; *q != '\0'; x++)
  {
    /*
      Define points.
    */
    if (IsPoint(q) == MagickFalse)
      break;
    GetNextToken(q,&q,MagickPathExtent,token);
    point.x=StringToDouble(token,&next_token);
    GetNextToken(q,&q,MagickPathExtent,token);
    if (*token == ',')
      GetNextToken(q,&q,MagickPathExtent,token);
    point.y=StringToDouble(token,&next_token);
    
    /*
      Ensure we have enough space in primitive_info.
    */
    if (i >= (ssize_t) number_points)
      {
        number_points+=2047;
        PrimitiveInfo *new_primitive_info;
        new_primitive_info=(PrimitiveInfo *) ResizeQuantumMemory(primitive_info,
          number_points,sizeof(*primitive_info));
        if (new_primitive_info == (PrimitiveInfo *) NULL)
          {
            primitive_info=(PrimitiveInfo *) RelinquishMagickMemory(
              primitive_info);
            if (stops != (StopInfo *) NULL)
              stops=(StopInfo *) RelinquishMagickMemory(stops);
            primitive=DestroyString(primitive);
            token=DestroyString(token);
            for ( ; n >= 0; n--)
              graphic_context[n]=DestroyDrawInfo(graphic_context[n]);
            graphic_context=(DrawInfo **) RelinquishMagickMemory(
              graphic_context);
            ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
              image->filename);
          }
        primitive_info=new_primitive_info;
      }
    
    primitive_info[i].point=point;
    primitive_info[i].coordinates=0;
    primitive_info[i].method=FloodfillMethod;
    i++;
  }
  
  /*
    Draw primitive.
  */
  status=DrawPrimitive(image,graphic_context[n],primitive_type,primitive_info,
    exception);
  if (status == MagickFalse)
    break;
}