primitive=AcquireString(draw_info->primitive);
token=AcquireString(primitive);
next_token=token;
for (q=(const char *) primitive; *q != '\0'; )
{
  /*
    Interpret drawing primitive.
  */
  GetNextToken(q,&q,MagickPathExtent,token);
  if (*token == '\0')
    break;
  primitive_type=UndefinedPrimitive;
  switch (*token)
  {
    case 'a':
    case 'A':
    {
      if (LocaleCompare("affine",token) == 0)
        {
          GetNextToken(q,&q,extent,token);
          affine.sx=StringToDouble(token,&next_token);
          GetNextToken(q,&q,extent,token);
          if (*token == ',')
            GetNextToken(q,&q,extent,token);
          affine.rx=StringToDouble(token,&next_token);
          GetNextToken(q,&q,extent,token);
          if (*token == ',')
            GetNextToken(q,&q,extent,token);
          affine.ry=StringToDouble(token,&next_token);
          GetNextToken(q,&q,extent,token);
          if (*token == ',')
            GetNextToken(q,&q,extent,token);
          affine.sy=StringToDouble(token,&next_token);
          GetNextToken(q,&q,extent,token);
          if (*token == ',')
            GetNextToken(q,&q,extent,token);
          affine.tx=StringToDouble(token,&next_token);
          GetNextToken(q,&q,extent,token);
          if (*token == ',')
            GetNextToken(q,&q,extent,token);
          affine.ty=StringToDouble(token,&next_token);
          break;
        }
      if (LocaleCompare("alpha",token) == 0)
        {
          primitive_type=AlphaPrimitive;
          break;
        }
      if (LocaleCompare("arc",token) == 0)
        {
          primitive_type=ArcPrimitive;
          break;
        }
      status=MagickFalse;
      break;
    }
    case 'b':
    case 'B':
    {
      if (LocaleCompare("bezier",token) == 0)
        {
          primitive_type=BezierPrimitive;
          break;
        }
      status=MagickFalse;
      break;
    }
    case 'c':
    case 'C':
    {
      if (LocaleCompare("circle",token) == 0)
        {
          primitive_type=CirclePrimitive;
          break;
        }
      if (LocaleCompare("color",token) == 0)
        {
          primitive_type=ColorPrimitive;
          break;
        }
      status=MagickFalse;
      break;
    }
    case 'e':
    case 'E':
    {
      if (LocaleCompare("ellipse",token) == 0)
        {
          primitive_type=EllipsePrimitive;
          break;
        }
      status=MagickFalse;
      break;
    }
    case 'i':
    case 'I':
    {
      if (LocaleCompare("image",token) == 0)
        {
          primitive_type=ImagePrimitive;
          break;
        }
      status=MagickFalse;
      break;
    }
    case 'l':
    case 'L':
    {
      if (LocaleCompare("line",token) == 0)
        {
          primitive_type=LinePrimitive;
          break;
        }
      status=MagickFalse;
      break;
    }
    case 'p':
    case 'P':
    {
      if (LocaleCompare("path",token) == 0)
        {
          primitive_type=PathPrimitive;
          break;
        }
      if (LocaleCompare("point",token) == 0)
        {
          primitive_type=PointPrimitive;
          break;
        }
      if (LocaleCompare("polygon",token) == 0)
        {
          primitive_type=PolygonPrimitive;
          break;
        }
      if (LocaleCompare("polyline",token) == 0)
        {
          primitive_type=PolylinePrimitive;
          break;
        }
      status=MagickFalse;
      break;
    }
    case 'r':
    case 'R':
    {
      if (LocaleCompare("rectangle",token) == 0)
        {
          primitive_type=RectanglePrimitive;
          break;
        }
      if (LocaleCompare("roundrectangle",token) == 0)
        {
          primitive_type=RoundRectanglePrimitive;
          break;
        }
      status=MagickFalse;
      break;
    }
    case 't':
    case 'T':
    {
      if (LocaleCompare("text",token) == 0)
        {
          primitive_type=TextPrimitive;
          break;
        }
      status=MagickFalse;
      break;
    }
    default:
    {
      status=MagickFalse;
      break;
    }
  }
  if (status == MagickFalse)
    break;
  if (primitive_type == UndefinedPrimitive)
    continue;
  /*
    Parse the primitive attributes.
  */
  i=0;
  j=0;
  for (x=0; *q != '\0'; x++)
  {
    /*
      Define points.
    */
    if (IsPoint(q) == MagickFalse)
      break;
    GetNextToken(q,&q,extent,token);
    point.x=StringToDouble(token,&next_token);
    GetNextToken(q,&q,extent,token);
    if (*token == ',')
      GetNextToken(q,&q,extent,token);
    point.y=StringToDouble(token,&next_token);
    GetNextToken(q,(const char **) NULL,extent,token);
    if (*token == ',')
      GetNextToken(q,&q,extent,token);
    primitive_info[i].primitive=primitive_type;
    primitive_info[i].point=point;
    primitive_info[i].coordinates=0;
    primitive_info[i].method=FloodfillMethod;
    i++;
    if (i < (ssize_t) (number_points-6*BezierQuantum-360))
      continue;
    number_points+=6*BezierQuantum+360;
    primitive_info=(PrimitiveInfo *) ResizeQuantumMemory(primitive_info,
      number_points,sizeof(*primitive_info));
    if (primitive_info == (PrimitiveInfo *) NULL)
      {
        (void) ThrowMagickException(exception,GetMagickModule(),
          ResourceLimitError,"MemoryAllocationFailed","`%s'",image->filename);
        break;
      }
  }
  primitive_info[j].primitive=primitive_type;
  primitive_info[j].coordinates=x;
  primitive_info[j].method=FloodfillMethod;
  primitive_info[j].text=(char *) NULL;
  if (active)
    {
      AffineToTransform(image,&affine);
      active=MagickFalse;
    }
  switch (primitive_type)
  {
    case PointPrimitive:
    default:
    {
      if (primitive_info[j].coordinates != 1)
        {
          status=MagickFalse;
          break;
        }
      break;
    }
    case LinePrimitive:
    {
      if (primitive_info[j].coordinates != 2)
        {
          status=MagickFalse;
          break;
        }
      break;
    }
    case RectanglePrimitive:
    {
      if (primitive_info[j].coordinates != 2)
        {
          status=MagickFalse;
          break;
        }
      break;
    }
    case RoundRectanglePrimitive:
    {
      if (primitive_info[j].coordinates != 3)
        {
          status=MagickFalse;
          break;
        }
      break;
    }
    case ArcPrimitive:
    {
      if (primitive_info[j].coordinates != 3)
        {
          status=MagickFalse;
          break;
        }
      break;
    }
    case EllipsePrimitive:
    {
      if (primitive_info[j].coordinates != 3)
        {
          status=MagickFalse;
          break;
        }
      break;
    }
    case CirclePrimitive:
    {
      if (primitive_info[j].coordinates != 2)
        {
          status=MagickFalse;
          break;
        }
      break;
    }
    case PolylinePrimitive:
    {
      if (primitive_info[j].coordinates < 2)
        {
          status=MagickFalse;
          break;
        }
      break;
    }
    case PolygonPrimitive:
    {
      if (primitive_info[j].coordinates < 3)
        {
          status=MagickFalse;
          break;
        }
      break;
    }
    case BezierPrimitive:
    {
      if (primitive_info[j].coordinates < 3)
        {
          status=MagickFalse;
          break;
        }
      break;
    }
    case PathPrimitive:
    {
      /* Path parsing is handled separately */
      break;
    }
    case ColorPrimitive:
    case AlphaPrimitive:
    {
      if (primitive_info[j].coordinates != 1)
        {
          status=MagickFalse;
          break;
        }
      GetNextToken(q,&q,extent,token);
      break;
    }
    case TextPrimitive:
    {
      if (primitive_info[j].coordinates != 1)
        {
          status=MagickFalse;
          break;
        }
      GetNextToken(q,&q,extent,token);
      primitive_info[j].text=AcquireString(token);
      break;
    }
    case ImagePrimitive:
    {
      if (primitive_info[j].coordinates != 2)
        {
          status=MagickFalse;
          break;
        }
      GetNextToken(q,&q,extent,token);
      primitive_info[j].text=AcquireString(token);
      break;
    }
  }
  if (primitive_info == (PrimitiveInfo *) NULL)
    break;
  primitive_info[i].primitive=UndefinedPrimitive;
  if (status == MagickFalse)
    break;
}