{
  DrawInfo
    *context,
    *graphic_context[MaxStackDepth];

  GradientInfo
    *gradient_info;

  MagickBooleanType
    status;

  PrimitiveInfo
    *primitive_info;

  SegmentInfo
    segment_info;

  size_t
    extent,
    n;

  StopInfo
    *stops;

  /*
    Allocate graphic context.
  */
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(DrawEvent,GetMagickModule(),"begin draw-image");
  graphic_context=(DrawInfo **) AcquireQuantumMemory((size_t) MaxStackDepth,
    sizeof(*graphic_context));
  if (graphic_context == (DrawInfo **) NULL)
    ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
      draw_info->geometry);
  for (n=0; n < MaxStackDepth; n++)
    graphic_context[n]=(DrawInfo *) NULL;
  n=0;
  graphic_context[0]=CloneDrawInfo(image_info,draw_info);
  /*
    Allocate primitive info memory.
  */
  primitive_info=(PrimitiveInfo *) AcquireQuantumMemory(MaxTextExtent,
    sizeof(*primitive_info));
  if (primitive_info == (PrimitiveInfo *) NULL)
    ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
      draw_info->geometry);
  primitive_info->primitive=UndefinedPrimitive;
  stops=(StopInfo *) NULL;
  /*
    Initialize draw affine matrix.
  */
  GetAffineMatrix(&affine);
  GetAffineMatrix(&current);
  /*
    Allocate memory required for drawing commands.
  */
  primitive=AcquireString(draw_info->primitive);
  if (primitive == (char *) NULL)
    {
      graphic_context[0]=DestroyDrawInfo(graphic_context[0]);
      graphic_context=(DrawInfo **) RelinquishMagickMemory(graphic_context);
      ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
        draw_info->geometry);
    }
  extent=strlen(primitive)+MagickPathExtent;
  token=(char *) NULL;
  status=MagickTrue;
  q=(const char *) primitive;
  (void) ResetMagickMemory(primitive_name,0,sizeof(primitive_name));
  (void) ResetMagickMemory(geometry,0,sizeof(geometry));
  (void) ResetMagickMemory(pattern,0,sizeof(pattern));
  gradient_info=(GradientInfo *) NULL;
  for ( ; *q != '\0'; )
  {
    /*
      Interpret graphic primitive.
    */
    GetNextToken(q,&q,MagickPathExtent,primitive_name);
    if (*primitive_name == '\0')
      break;
    if (*primitive_name == '#')
      {
        /*
          Comment.
        */
        for ( ; (*q != '\n') && (*q != '\0'); q++);
        continue;
      }
    context=graphic_context[n];
    (void) CopyMagickString(context->primitive,primitive_name,
      MagickPathExtent);
    if (LocaleCompare(primitive_name,"alpha") == 0)
      {
        double
          alpha;

        PointInfo
          point;

        /*
          alpha x,y alpha-value.
        */
        (void) memset(&point,0,sizeof(point));
        GetNextToken(q,&q,extent,geometry);
        point.x=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,extent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,extent,geometry);
        point.y=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,extent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,extent,geometry);
        alpha=StringToDouble(geometry,&next_token);
        (void) SetImageAlpha(image,OpaqueAlpha,exception);
        (void) SetPixelAlpha(image,ClampToQuantum(alpha*QuantumRange),
          exception);
        (void) FloodfillPaintImage(image,context,context->fill_color,
          context->opacity,MagickFalse,point,AlphaFloodfillMethod,exception);
        continue;
      }
    if (LocaleCompare(primitive_name,"bezier") == 0)
      {
        double
          x0,
          x1,
          x2,
          x3,
          y0,
          y1,
          y2,
          y3;

        /*
          bezier x0,y0 x1,y1 x2,y2 x3,y3.
        */
        GetNextToken(q,&q,extent,geometry);
        x0=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,extent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,extent,geometry);
        y0=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,extent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,extent,geometry);
        x1=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,extent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,extent,geometry);
        y1=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,extent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,extent,geometry);
        x2=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,extent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,extent,geometry);
        y2=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,extent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,extent,geometry);
        x3=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,extent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,extent,geometry);
        y3=StringToDouble(geometry,&next_token);
        primitive_info[0].primitive=BezierPrimitive;
        primitive_info[0].point.x=x0;
        primitive_info[0].point.y=y0;
        primitive_info[1].point.x=x1;
        primitive_info[1].point.y=y1;
        primitive_info[2].point.x=x2;
        primitive_info[2].point.y=y2;
        primitive_info[3].point.x=x3;
        primitive_info[3].point.y=y3;
        primitive_info[4].primitive=UndefinedPrimitive;
        (void) DrawBezierPrimitive(image,context,primitive_info,exception);
        continue;
      }
    if (LocaleCompare(primitive_name,"circle") == 0)
      {
        double
          x,
          y,
          x0,
          y0;

        /*
          circle x,y x0,y0.
        */
        GetNextToken(q,&q,extent,geometry);
        x=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,extent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,extent,geometry);
        y=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,extent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,extent,geometry);
        x0=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,extent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,extent,geometry);
        y0=StringToDouble(geometry,&next_token);
        primitive_info[0].primitive=CirclePrimitive;
        primitive_info[0].point.x=x;
        primitive_info[0].point.y=y;
        primitive_info[1].point.x=x0;
        primitive_info[1].point.y=y0;
        primitive_info[2].primitive=UndefinedPrimitive;
        (void) DrawCirclePrimitive(image,context,primitive_info,exception);
        continue;
      }
    if (LocaleCompare(primitive_name,"color") == 0)
      {
        double
          x,
          y;

        /*
          color x,y method.
        */
        GetNextToken(q,&q,extent,geometry);
        x=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,extent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,extent,geometry);
        y=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,extent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,extent,geometry);
        primitive_info[0].primitive=ColorPrimitive;
        primitive_info[0].point.x=x;
        primitive_info[0].point.y=y;
        primitive_info[0].method=FloodfillMethod;
        if (LocaleCompare("point",geometry) == 0)
          primitive_info[0].method=PointMethod;
        if (LocaleCompare("replace",geometry) == 0)
          primitive_info[0].method=ReplaceMethod;
        if (LocaleCompare("floodfill",geometry) == 0)
          primitive_info[0].method=FloodfillMethod;
        if (LocaleCompare("filltoborder",geometry) == 0)
          primitive_info[0].method=FillToBorderMethod;
        if (LocaleCompare("reset",geometry) == 0)
          primitive_info[0].method=ResetMethod;
        primitive_info[1].primitive=UndefinedPrimitive;
        (void) DrawColorPrimitive(image,context,primitive_info,exception);
        continue;
      }
    if (LocaleCompare(primitive_name,"comment") == 0)
      {
        /*
          comment text.
        */
        continue;
      }
    if (LocaleCompare(primitive_name,"ellipse") == 0)
      {
        double
          x,
          y,
          rx,
          ry;

        /*
          ellipse x,y rx,ry angle start-degrees,end-degrees.
        */
        GetNextToken(q,&q,extent,geometry);
        x=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,extent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,extent,geometry);
        y=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,extent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,extent,geometry);
        rx=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,extent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,extent,geometry);
        ry=StringToDouble(geometry,&next_token);
        primitive_info[0].primitive=EllipsePrimitive;
        primitive_info[0].point.x=x;
        primitive_info[0].point.y=y;
        primitive_info[1].point.x=rx;
        primitive_info[1].point.y=ry;
        primitive_info[2].primitive=UndefinedPrimitive;
        (void) DrawEllipsePrimitive(image,context,primitive_info,exception);
        continue;
      }
    if (LocaleCompare(primitive_name,"fill") == 0)
      {
        /*
          fill color.
        */
        GetNextToken(q,&q,extent,geometry);
        (void) SetDrawInfoFill(context,geometry,exception);
        continue;
      }
    if (LocaleCompare(primitive_name,"fill-opacity") == 0)
      {
        double
          opacity;

        /*
          fill-opacity value.
        */
        GetNextToken(q,&q,extent,geometry);
        opacity=StringToDouble(geometry,&next_token);
        context->fill_opacity=ClampToQuantum(opacity*QuantumRange);
        continue;
      }
    if (LocaleCompare(primitive_name,"fill-rule") == 0)
      {
        /*
          fill-rule rule.
        */
        GetNextToken(q,&q,extent,geometry);
        if (LocaleCompare("evenodd",geometry) == 0)
          context->fill_rule=EvenOddRule;
        if (LocaleCompare("nonzero",geometry) == 0)
          context->fill_rule=NonZeroRule;
        continue;
      }
    if (LocaleCompare(primitive_name,"font") =