{
  MagickBooleanType status=MagickTrue;
  PrimitiveInfo *primitive_info=(PrimitiveInfo *) NULL;
  StopInfo *stops=(StopInfo *) NULL;
  DrawInfo **graphic_context=(DrawInfo **) NULL;
  ssize_t n=0;

  /*
    Acquire the drawing commands string from the DrawInfo.
  */
  primitive=AcquireString(draw_info->primitive);
  if (primitive == (char *) NULL)
    ThrowBinaryException(DrawError,"MemoryAllocationFailed",draw_info->primitive);

  /*
    Initialize a graphic context stack (for nested styles/transformations).
  */
  graphic_context=(DrawInfo **) AcquireQuantumMemory(10,sizeof(*graphic_context));
  if (graphic_context == (DrawInfo **) NULL)
    {
      primitive=DestroyString(primitive);
      ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",draw_info->primitive);
    }
  n=0;
  graphic_context[n]=CloneDrawInfo((ImageInfo *) NULL,draw_info);
  if (graphic_context[n] == (DrawInfo *) NULL)
    {
      primitive=DestroyString(primitive);
      graphic_context=(DrawInfo **) RelinquishMagickMemory(graphic_context);
      ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",draw_info->primitive);
    }

  /*
    Allocate memory for primitive info.
  */
  primitive_info=(PrimitiveInfo *) AcquireQuantumMemory(2048,sizeof(*primitive_info));
  if (primitive_info == (PrimitiveInfo *) NULL)
    {
      primitive=DestroyString(primitive);
      graphic_context=(DrawInfo **) RelinquishMagickMemory(graphic_context);
      ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",draw_info->primitive);
    }

  /*
    Interpret and execute the drawing commands in the primitive string.
  */
  q=primitive;
  while (*q != '\0')
  {
    char keyword[MagickPathExtent];
    GetNextToken(q,&q,MagickPathExtent,keyword);
    if (*keyword == '\0')
      break;
    if (LocaleCompare("line",keyword) == 0)
    {
      /*
        Parse two points for the line primitive.
      */
      PointInfo p[2];
      GetNextToken(q,&q,MagickPathExtent,token);
      p[0].x=StringToDouble(token,&next_token);
      GetNextToken(q,&q,MagickPathExtent,token);
      p[0].y=StringToDouble(token,&next_token);
      GetNextToken(q,&q,MagickPathExtent,token);
      p[1].x=StringToDouble(token,&next_token);
      GetNextToken(q,&q,MagickPathExtent,token);
      p[1].y=StringToDouble(token,&next_token);
      status=DrawLinePrimitive(image,draw_info,p,exception);
      if (status == MagickFalse)
        break;
    }
    else if (LocaleCompare("rectangle",keyword) == 0)
    {
      /*
        Parse two points for the rectangle primitive.
      */
      PointInfo p[2];
      GetNextToken(q,&q,MagickPathExtent,token);
      p[0].x=StringToDouble(token,&next_token);
      GetNextToken(q,&q,MagickPathExtent,token);
      p[0].y=StringToDouble(token,&next_token);
      GetNextToken(q,&q,MagickPathExtent,token);
      p[1].x=StringToDouble(token,&next_token);
      GetNextToken(q,&q,MagickPathExtent,token);
      p[1].y=StringToDouble(token,&next_token);
      status=DrawRectanglePrimitive(image,draw_info,p,exception);
      if (status == MagickFalse)
        break;
    }
    else
    {
      /*
        For unsupported or unrecognized primitives, skip the remaining parameters.
      */
      GetNextToken(q,&q,MagickPathExtent,token);
    }
  }
}