/*
    Interpret drawing commands from the input string and render graphics on the image.
  */
  char
    token[MagickPathExtent];

  const char
    *p;

  DrawInfo
    **graphic_context;

  ssize_t
    n;

  MagickBooleanType
    active,
    status;

  PrimitiveInfo
    *primitive_info;

  size_t
    number_points;

  active=MagickFalse;
  n=0;
  status=MagickTrue;
  p=draw_info->primitive;
  graphic_context=(DrawInfo **) AcquireQuantumMemory(1,sizeof(*graphic_context));
  if (graphic_context == (DrawInfo **) NULL)
    ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
      draw_info->primitive);
  graphic_context[0]=CloneDrawInfo((ImageInfo *) NULL,draw_info);
  GetAffineMatrix(&affine);
  number_points=2047;
  primitive_info=(PrimitiveInfo *) AcquireQuantumMemory(number_points,
    sizeof(*primitive_info));
  if (primitive_info == (PrimitiveInfo *) NULL)
    ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
      draw_info->primitive);
  for ( ; *p != '\0'; )
  {
    /*
      Interpret graphic primitive.
    */
    GetNextToken(p,&p,MagickPathExtent,token);
    if (*token == '\0')
      break;
    if (*token == '#')
      {
        /*
          Comment.
        */
        if (active != MagickFalse)
          {
            AffineToTransform(image,&affine);
            active=MagickFalse;
          }
        continue;
      }
    switch (*token)
    {
      case ';':
        break;
      case 'a':
      case 'A':
      {
        if (LocaleCompare("affine",token) == 0)
          {
            affine.sx=StringToDouble(GetNextToken(p,&p,MagickPathExtent,token),
              &next_token);
            affine.rx=StringToDouble(GetNextToken(p,&p,MagickPathExtent,token),
              &next_token);
            affine.ry=StringToDouble(GetNextToken(p,&p,MagickPathExtent,token),
              &next_token);
            affine.sy=StringToDouble(GetNextToken(p,&p,MagickPathExtent,token),
              &next_token);
            affine.tx=StringToDouble(GetNextToken(p,&p,MagickPathExtent,token),
              &next_token);
            affine.ty=StringToDouble(GetNextToken(p,&p,MagickPathExtent,token),
              &next_token);
            break;
          }
        if (LocaleCompare("alpha",token) == 0)
          {
            /* Handle alpha command */
            break;
          }
        if (LocaleCompare("angle",token) == 0)
          {
            /* Handle angle command */
            break;
          }
        if (LocaleCompare("arc",token) == 0)
          {
            /* Handle arc command */
            break;
          }
        status=MagickFalse;
        break;
      }
      case 'b':
      case 'B':
      {
        if (LocaleCompare("bezier",token) == 0)
          {
            /* Handle bezier command */
            break;
          }
        status=MagickFalse;
        break;
      }
      /* Continue similar pattern matching as shown above for other cases */
      default:
      {
        status=MagickFalse;
        break;
      }
    }
    if (status == MagickFalse)
      break;
  }