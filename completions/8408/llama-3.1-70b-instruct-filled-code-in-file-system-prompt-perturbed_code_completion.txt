primitive=GetNodeByURL(draw_info->primitive,draw_info->element_reference);
if (primitive == (char *) NULL)
  {
    ThrowBinaryException(DrawError,"NonconformingDrawingPrimitiveDefinition",
      draw_info->primitive);
    return(MagickFalse);
  }
if (LocaleCompare(primitive,"push") == 0)
  {
    graphic_context[n]=CloneDrawInfo((ImageInfo *) NULL,draw_info);
    if (graphic_context[n] == (DrawInfo *) NULL)
      {
        primitive=DestroyString(primitive);
        return(MagickFalse);
      }
    graphic_context[n]->debug=draw_info->debug;
    graphic_context[n]->render=draw_info->render;
    n++;
    if (n >= (ssize_t) GetMagickResourceLimit(ThreadResource))
      {
        primitive=DestroyString(primitive);
        ThrowFatalException(ResourceLimitFatalError,
          "UnableToAllocateGraphicContext");
      }
    continue;
  }
if (LocaleCompare(primitive,"pop") == 0)
  {
    if (n == 0)
      {
        primitive=DestroyString(primitive);
        ThrowBinaryException(DrawError,"NonconformingDrawingPrimitiveDefinition",
          draw_info->primitive);
      }
    graphic_context[n-1]=DestroyDrawInfo(graphic_context[n-1]);
    n--;
    continue;
  }
if (LocaleCompare(primitive,"viewbox") == 0)
  {
    double
      x,
      y;

    GetNextToken(p,&p,MagickPathExtent,token);
    if (*token == ',')
      GetNextToken(p,&p,MagickPathExtent,token);
    x=StringToDouble(token,&next_token);
    if (token == next_token)
      ThrowPointExpectedException(token,exception);
    GetNextToken(p,&p,MagickPathExtent,token);
    if (*token == ',')
      GetNextToken(p,&p,MagickPathExtent,token);
    y=StringToDouble(token,&next_token);
    if (token == next_token)
      ThrowPointExpectedException(token,exception);
    GetNextToken(p,&p,MagickPathExtent,token);
    if (*token == ',')
      GetNextToken(p,&p,MagickPathExtent,token);
    x=StringToDouble(token,&next_token);
    if (token == next_token)
      ThrowPointExpectedException(token,exception);
    GetNextToken(p,&p,MagickPathExtent,token);
    if (*token == ',')
      GetNextToken(p,&p,MagickPathExtent,token);
    y=StringToDouble(token,&next_token);
    if (token == next_token)
      ThrowPointExpectedException(token,exception);
    draw_info->viewbox.x=x;
    draw_info->viewbox.y=y;
    draw_info->viewbox.width=x;
    draw_info->viewbox.height=y;
    continue;
  }
if (LocaleCompare(primitive,"rotate") == 0)
  {
    double
      angle,
      x,
      y;

    GetNextToken(p,&p,MagickPathExtent,token);
    if (*token == ',')
      GetNextToken(p,&p,MagickPathExtent,token);
    angle=StringToDouble(token,&next_token);
    if (token == next_token)
      ThrowPointExpectedException(token,exception);
    GetNextToken(p,&p,MagickPathExtent,token);
    if (*token == ',')
      GetNextToken(p,&p,MagickPathExtent,token);
    x=StringToDouble(token,&next_token);
    if (token == next_token)
      ThrowPointExpectedException(token,exception);
    GetNextToken(p,&p,MagickPathExtent,token);
    if (*token == ',')
      GetNextToken(p,&p,MagickPathExtent,token);
    y=StringToDouble(token,&next_token);
    if (token == next_token)
      ThrowPointExpectedException(token,exception);
    draw_info->affine.sx=cos(DegreesToRadians(angle));
    draw_info->affine.ry=sin(DegreesToRadians(angle));
    draw_info->affine.rx=(-sin(DegreesToRadians(angle)));
    draw_info->affine.sy=cos(DegreesToRadians(angle));
    draw_info->affine.tx=(-x*draw_info->affine.sx-y*draw_info->affine.ry);
    draw_info->affine.ty=(-x*draw_info->affine.rx-y*draw_info->affine.sy);
    continue;
  }
if (LocaleCompare(primitive,"scale") == 0)
  {
    double
      x,
      y;

    GetNextToken(p,&p,MagickPathExtent,token);
    if (*token == ',')
      GetNextToken(p,&p,MagickPathExtent,token);
    x=StringToDouble(token,&next_token);
    if (token == next_token)
      ThrowPointExpectedException(token,exception);
    GetNextToken(p,&p,MagickPathExtent,token);
    if (*token == ',')
      GetNextToken(p,&p,MagickPathExtent,token);
    y=StringToDouble(token,&next_token);
    if (token == next_token)
      ThrowPointExpectedException(token,exception);
    draw_info->affine.sx*=x;
    draw_info->affine.sy*=y;
    draw_info->affine.tx*=x;
    draw_info->affine.ty*=y;
    continue;
  }
if (LocaleCompare(primitive,"skewX") == 0)
  {
    double
      angle;

    GetNextToken(p,&p,MagickPathExtent,token);
    if (*token == ',')
      GetNextToken(p,&p,MagickPathExtent,token);
    angle=StringToDouble(token,&next_token);
    if (token == next_token)
      ThrowPointExpectedException(token,exception);
    draw_info->affine.rx+=tan(DegreesToRadians(angle));
    continue;
  }
if (LocaleCompare(primitive,"skewY") == 0)
  {
    double
      angle;

    GetNextToken(p,&p,MagickPathExtent,token);
    if (*token == ',')
      GetNextToken(p,&p,MagickPathExtent,token);
    angle=StringToDouble(token,&next_token);
    if (token == next_token)
      ThrowPointExpectedException(token,exception);
    draw_info->affine.ry+=tan(DegreesToRadians(angle));
    continue;
  }
if (LocaleCompare(primitive,"translate") == 0)
  {
    double
      x,
      y;

    GetNextToken(p,&p,MagickPathExtent,token);
    if (*token == ',')
      GetNextToken(p,&p,MagickPathExtent,token);
    x=StringToDouble(token,&next_token);
    if (token == next_token)
      ThrowPointExpectedException(token,exception);
    GetNextToken(p,&p,MagickPathExtent,token);
    if (*token == ',')
      GetNextToken(p,&p,MagickPathExtent,token);
    y=StringToDouble(token,&next_token);
    if (token == next_token)
      ThrowPointExpectedException(token,exception);
    draw_info->affine.tx+=x;
    draw_info->affine.ty+=y;
    continue;
  }
if (LocaleCompare(primitive,"matrix") == 0)
  {
    double
      a,
      b,
      c,
      d,
      e,
      f;

    GetNextToken(p,&p,MagickPathExtent,token);
    if (*token == ',')
      GetNextToken(p,&p,MagickPathExtent,token);
    a=StringToDouble(token,&next_token);
    if (token == next_token)
      ThrowPointExpectedException(token,exception);
    GetNextToken(p,&p,MagickPathExtent,token);
    if (*token == ',')
      GetNextToken(p,&p,MagickPathExtent,token);
    b=StringToDouble(token,&next_token);
    if (token == next_token)
      ThrowPointExpectedException(token,exception);
    GetNextToken(p,&p,MagickPathExtent,token);
    if (*token == ',')
      GetNextToken(p,&p,MagickPathExtent,token);
    c=StringToDouble(token,&next_token);
    if (token == next_token)
      ThrowPointExpectedException(token,exception);
    GetNextToken(p,&p,MagickPathExtent,token);
    if (*token == ',')
      GetNextToken(p,&p,MagickPathExtent,token);
    d=StringToDouble(token,&next_token);
    if (token == next_token)
      ThrowPointExpectedException(token,exception);
    GetNextToken(p,&p,MagickPathExtent,token);
    if (*token == ',')
      GetNextToken(p,&p,MagickPathExtent,token);
    e=StringToDouble(token,&next_token);
    if (token == next_token)
      ThrowPointExpectedException(token,exception);
    GetNextToken(p,&p,MagickPathExtent,token);
    if (*token == ',')
      GetNextToken(p,&p,MagickPathExtent,token);
    f=StringToDouble(token,&next_token);
    if (token == next_token)
      ThrowPointExpectedException(token,exception);
    draw_info->affine.sx*=a;
    draw_info->affine.rx*=b;
    draw_info->affine.ry*=c;
    draw_info->affine.sy*=d;
    draw_info->affine.tx*=e;
    draw_info->affine.ty*=f;
    continue;
  }
if (LocaleCompare(primitive,"fill") == 0)
  {
    (void) QueryColorCompliance(p,AllCompliance,&draw_info->fill,exception);
    continue;
  }
if (LocaleCompare(primitive,"fill-opacity") == 0)
  {
    double
      alpha;

    GetNextToken(p,&p,MagickPathExtent,token);
    if (*token == ',')
      GetNextToken(p,&p,MagickPathExtent,token);
    alpha=StringToDouble(token,&next_token);
    if (token == next_token)
      ThrowPointExpectedException(token,exception);
    draw_info->fill_alpha=(MagickRealType) alpha;
    continue;
  }
if (LocaleCompare(primitive,"fill-rule") == 0)
  {
    GetNextToken(p,&p,MagickPathExtent,token);
    if (*token == ',')
      GetNextToken(p,&p,MagickPathExtent,token);
    if (LocaleCompare(token,"evenodd") == 0)
      draw_info->fill_rule=EvenOddRule;
    else
      if (LocaleCompare(token,"nonzero") == 0)
        draw_info->fill_rule=NonZeroRule;
      else
        ThrowBinaryException(DrawError,"NonconformingDrawingPrimitiveDefinition",
          draw_info->primitive);
    continue;
  }
if (LocaleCompare(primitive,"stroke") == 0)
  {
    (void) QueryColorCompliance(p,AllCompliance,&draw_info->stroke,exception);
    continue;
  }
if (LocaleCompare(primitive,"stroke-dasharray") == 0)
  {
    double
      dash;

    GetNextToken(p,&p,MagickPathExtent,token);
    if (*token == ',')
      GetNextToken(p,&p,MagickPathExtent,token);
    dash=StringToDouble(token,&next_token);
    if (token == next_token)
      ThrowPointExpectedException(token,exception);
    if (draw_info->dash_pattern!= (double *) NULL)
      draw_info->dash_pattern=(double *) RelinquishMagickMemory(
        draw_info->dash_pattern);
    draw_info->dash_pattern=(double *) AcquireQuantumMemory(2,sizeof(*
      draw_info->dash_pattern));
    if (draw_info->dash_pattern == (double *) NULL)
      ThrowFatalException(ResourceLimitFatalError,
        "UnableToAllocateDashPattern");
    draw_info->dash_pattern[0]=dash;
    draw_info->dash_pattern[1]=0.0;
    continue;
  }
if (LocaleCompare(primitive,"stroke-dashoffset") == 0)
  {
    double
      offset;

    GetNextToken(p,&p,MagickPathExtent,token);
    if (*token == ',')
      GetNextToken(p,&p,MagickPathExtent,token);
    offset=StringToDouble(token,&next_token);
    if (token == next_token)
      ThrowPointExpectedException(token,exception);
    draw_info->dash_offset=offset;
    continue;
  }
if (LocaleCompare(primitive,"stroke-linecap") == 0)
  {
    GetNextToken(p,&p,MagickPathExtent,token);
    if (*token == ',')
      GetNextToken(p,&p,MagickPathExtent,token);
    if (LocaleCompare(token,"butt") == 0)
      draw_info->linecap=ButtCap;
    else
      if (LocaleCompare(token,"round") == 0)
        draw_info->linecap=RoundCap;
      else
        if (LocaleCompare(token,"square") == 0)
          draw_info->linecap=SquareCap;
        else
          ThrowBinaryException(DrawError,"NonconformingDrawingPrimitiveDefinition",
            draw_info->primitive);
    continue;
  }
if (LocaleCompare(primitive,"stroke-linejoin") == 0)
  {
    GetNextToken(p,&p,MagickPathExtent,token);
    if (*token == ',')
      GetNextToken(p,&p,MagickPathExtent,token);
    if (LocaleCompare(token,"miter") == 0)
      draw_info->linejoin=MiterJoin;
    else
      if (LocaleCompare(token,"round") == 0)
        draw_info->linejoin=RoundJoin;
      else
        if (LocaleCompare(token,"bevel") == 0)
          draw_info->linejoin=BevelJoin;
        else
          ThrowBinaryException(DrawError,"NonconformingDrawingPrimitiveDefinition",
            draw_info->primitive);
    continue;
  }
if (LocaleCompare(primitive,"stroke-miterlimit") == 0)
  {
    double
      miterlimit;

    GetNextToken(p,&p,MagickPathExtent,token);
    if (*token == ',')
      GetNextToken(p,&p,MagickPathExtent,token);