DrawInfo
    **graphic_context;

  GradientInfo
    *gradient_info;

  MagickBooleanType
    status;

  PrimitiveInfo
    *primitive_info;

  SegmentInfo
    segment_info;

  size_t
    extent,
    n;

  StopInfo
    *stops;

  /*
    Allocate drawing resources.
  */
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (draw_info == (DrawInfo *) NULL)
    return(MagickTrue);
  assert(draw_info->signature == MagickCoreSignature);
  if (exception == (ExceptionInfo *) NULL)
    return(MagickTrue);
  assert(exception->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(DrawEvent,GetMagickModule(),"begin draw-image");
  graphic_context=(DrawInfo **) AcquireQuantumMemory(MaxStackDepth,
    sizeof(*graphic_context));
  if (graphic_context == (DrawInfo **) NULL)
    ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
      draw_info->geometry);
  for (n=0; n < MaxStackDepth; n++)
  {
    graphic_context[n]=CloneDrawInfo(image_info,(DrawInfo *) NULL);
    if (graphic_context[n] == (DrawInfo *) NULL)
      ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
        draw_info->geometry);
  }
  n=0;
  (void) CopyDrawInfo(graphic_context[n],draw_info);
  primitive=AcquireString(draw_info->primitive);
  if (primitive == (char *) NULL)
  {
    for ( ; n >= 0; n--)
      graphic_context[n]=DestroyDrawInfo(graphic_context[n]);
    graphic_context=(DrawInfo **) RelinquishMagickMemory(graphic_context);
    return(MagickTrue);
  }
  extent=strlen(primitive)+MagickPathExtent;
  token=AcquireString((char *) NULL);
  primitive_info=(PrimitiveInfo *) AcquireQuantumMemory(MaxTextExtent,
    sizeof(*primitive_info));
  if (primitive_info == (PrimitiveInfo *) NULL)
    ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
      draw_info->geometry);
  primitive_info->primitive=UndefinedPrimitive;
  stops=(StopInfo *) NULL;
  GetAffineMatrix(&affine);
  status=MagickTrue;
  for (q=(const char *) primitive; *q != '\0'; )
  {
    /*
      Interpret graphic primitive.
    */
    GetNextToken(q,&q,MagickPathExtent,primitive_name);
    if (*primitive_name == '\0')
      break;
    if (*primitive_name == '#')
      {
        /*
          Comment.
        */
        for ( ; (*q != '\n') && (*q != '\0'); q++);
        continue;
      }
    if (LocaleCompare(primitive_name,"alpha") == 0)
      {
        double
          alpha;

        PointInfo
          point;

        /*
          alpha x,y alpha-value.
        */
        GetNextToken(q,&q,extent,geometry);
        point.x=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,extent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,extent,geometry);
        point.y=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,extent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,extent,geometry);
        alpha=StringToDouble(geometry,&next_token);
        (void) SetImageAlpha(image,OpaqueAlpha,exception);
        (void) FloodfillPaintImage(image,graphic_context[n],
          (long) point.x,(long) point.y,OpaqueAlpha,(Quantum) (alpha*
          QuantumRange),FloodfillMethod,exception);
        continue;
      }
    if (LocaleCompare(primitive_name,"bezier") == 0)
      {
        PrimitiveInfo
          bezier[MaxTextExtent];

        register ssize_t
          i;

        /*
          bezier x0,y0 x1,y1 x2,y2 x3,y3 .... xn,yn.
        */
        for (i=0; i < MaxTextExtent; i++)
        {
          GetNextToken(q,&q,extent,geometry);
          if (*geometry == '\0')
            break;
          bezier[i].point.x=StringToDouble(geometry,&next_token);
          GetNextToken(q,&q,extent,geometry);
          if (*geometry == ',')
            GetNextToken(q,&q,extent,geometry);
          bezier[i].point.y=StringToDouble(geometry,&next_token);
          bezier[i].primitive=BezierPrimitive;
          bezier[i].coordinates=0;
        }
        bezier[i].primitive=UndefinedPrimitive;
        (void) DrawBezierPrimitive(image,graphic_context[n],bezier,exception);
        continue;
      }
    if (LocaleCompare(primitive_name,"circle") == 0)
      {
        PointInfo
          point;

        /*
          circle x,y radius.
        */
        GetNextToken(q,&q,extent,geometry);
        point.x=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,extent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,extent,geometry);
        point.y=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,extent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,extent,geometry);
        affine.sx=StringToDouble(geometry,&next_token);
        (void) DrawCirclePrimitive(image,graphic_context[n],point,affine.sx,
          exception);
        continue;
      }
    if (LocaleCompare(primitive_name,"color") == 0)
      {
        PointInfo
          point;

        /*
          color x,y method.
        */
        GetNextToken(q,&q,extent,geometry);
        point.x=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,extent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,extent,geometry);
        point.y=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,extent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,extent,geometry);
        if (LocaleCompare("point",geometry) == 0)
          (void) FloodfillPaintImage(image,graphic_context[n],(long) point.x,
            (long) point.y,image->background_color,TransparentAlpha,
            PointMethod,exception);
        else
          if (LocaleCompare("replace",geometry) == 0)
            (void) FloodfillPaintImage(image,graphic_context[n],(long) point.x,
              (long) point.y,image->background_color,TransparentAlpha,
              ReplaceMethod,exception);
          else
            if (LocaleCompare("floodfill",geometry) == 0)
              (void) FloodfillPaintImage(image,graphic_context[n],(long) point.x,
                (long) point.y,image->background_color,TransparentAlpha,
                FloodfillMethod,exception);
            else
              if (LocaleCompare("filltoborder",geometry) == 0)
                (void) FloodfillPaintImage(image,graphic_context[n],(long) point.x,
                  (long) point.y,image->border_color,TransparentAlpha,
                  FillToBorderMethod,exception);
            else
              if (LocaleCompare("reset",geometry) == 0)
                (void) FloodfillPaintImage(image,graphic_context[n],(long) point.x,
                  (long) point.y,image->background_color,TransparentAlpha,
                  ResetMethod,exception);
        continue;
      }
    if (LocaleCompare(primitive_name,"comment") == 0)
      {
        /*
          comment string.
        */
        continue;
      }
    if (LocaleCompare(primitive_name,"ellipse") == 0)
      {
        PointInfo
          point;

        /*
          ellipse x0,y0 rx,ry angle start-degrees,end-degrees.
        */
        GetNextToken(q,&q,extent,geometry);
        point.x=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,extent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,extent,geometry);
        point.y=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,extent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,extent,geometry);
        affine.sx=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,extent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,extent,geometry);
        affine.sy=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,extent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,extent,geometry);
        affine.rx=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,extent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,extent,geometry);
        affine.ry=StringToDouble(geometry,&next_token);
        (void) DrawEllipsePrimitive(image,graphic_context[n],point,affine.sx,
          affine.sy,affine.rx,affine.ry,exception);
        continue;
      }
    if (LocaleCompare(primitive_name,"gradientUnits") == 0)
      {
        /*
          gradientUnits userSpaceOnUse | objectBoundingBox
        */
        GetNextToken(q,&q,extent,geometry);
        continue;
      }
    if (LocaleCompare(primitive_name,"image") == 0)
      {
        Image
          *image_artifact;

        ImageInfo
          *image_info;

        PointInfo
          point;

        /*
          image x,y width,height filename.
        */
        image_info=CloneImageInfo(image_info);
        GetNextToken(q,&q,extent,geometry);
        point.x=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,extent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,extent,geometry);
        point.y=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,extent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,extent,geometry);
        affine.sx=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,extent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,extent,geometry);
        affine.sy=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,extent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,extent,geometry);
        (void) CopyMagickString(image_info->filename,geometry,
          MagickPathExtent);
        (void) CopyMagickString(image_info->magick,geometry,MagickPathExtent);
        image_artifact=ReadImage(image_info,exception);
        image_info=DestroyImageInfo(image_info);
        if (image_artifact == (Image *) NULL)
          {
            status=MagickFalse;
            break;
          }
        (void) CompositeImage(image,image_artifact,UndefinedCompositeOp,MagickTrue,
          (long) point.x,(long) point.y,affine.sx,affine.sy,exception);
        image_artifact=DestroyImage(image_artifact);
        continue;
      }
    if (LocaleCompare(primitive_name,"line") == 0)
      {
        PointInfo
          point;

        /*
          line x0,y0 x1,y1.
        */
        GetNextToken(q,&q,extent,geometry);
        point.x=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,extent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,extent,geometry);
        point.y=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,extent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,extent,geometry);
        affine.sx=StringT