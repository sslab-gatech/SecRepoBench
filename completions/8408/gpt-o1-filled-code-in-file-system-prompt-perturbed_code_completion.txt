/*
  Initialize resources to interpret the drawing commands.  We push the current
  graphic context, create a stack of graphic contexts for nested pushes/pops,
  and then parse through the commands in the MVG string (if any).  For each
  recognized command, we update the current context or draw the requested
  graphics on the image accordingly.  Once all commands are processed, we pop
  any remaining contexts and finish the draw operation.
*/
{
  char
    keyword[MagickPathExtent],
    geometry[MagickPathExtent],
    pattern[MagickPathExtent],
    *primitive = (char *) NULL,
    *token = (char *) NULL,
    *q;

  DrawInfo
    **graphic_context;

  MagickBooleanType
    status;

  MagickSizeType
    length;

  MVGInfo
    mvg_info;

  PrimitiveInfo
    *primitive_info = (PrimitiveInfo *) NULL;

  StopInfo
    *stops = (StopInfo *) NULL;

  register DrawInfo
    *local_info;

  register ssize_t
    i;

  size_t
    extent;

  ssize_t
    n,
    max_stack_depth;

  /*
    Prepare for drawing.
  */
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(DrawEvent,GetMagickModule(),"begin draw-image");

  status = MagickTrue;
  length = 0;
  extent = 8192;  /* Default initial capacity for commands */
  /*
    Allocate drawing contexts.
  */
  max_stack_depth = 16;
  graphic_context = (DrawInfo **) AcquireQuantumMemory((size_t) max_stack_depth,
    sizeof(*graphic_context));
  if (graphic_context == (DrawInfo **) NULL)
    ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
  (void) memset(graphic_context,0,(size_t) max_stack_depth*
    sizeof(*graphic_context));
  graphic_context[0]=CloneDrawInfo((ImageInfo *) NULL,draw_info);
  n=0;
  /*
    Process the drawing commands from draw_info->primitive.  If it's prefixed
    with '@', treat it as a filename containing the commands. Otherwise, parse
    the string directly.
  */
  if (draw_info->primitive != (char *) NULL)
    {
      if (*draw_info->primitive == '@')
        {
          /*
            Acquire commands from a file.
          */
          (void) CopyMagickString(geometry,draw_info->primitive+1,
            MagickPathExtent);
          primitive = FileToString(geometry,~0UL,&length,exception);
        }
      else
        {
          length = (MagickSizeType) strlen(draw_info->primitive);
          primitive = AcquireString(draw_info->primitive);
        }
    }
  if (primitive == (char *) NULL)
    {
      graphic_context[0] = DestroyDrawInfo(graphic_context[0]);
      graphic_context = (DrawInfo **) RelinquishMagickMemory(graphic_context);
      return(MagickFalse);
    }

  /*
    Initialize our shape/command sampler.
  */
  primitive_info = (PrimitiveInfo *) AcquireQuantumMemory(extent,
    sizeof(*primitive_info));
  if (primitive_info == (PrimitiveInfo *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),ResourceLimitError,
        "MemoryAllocationFailed","`%s'","");
      graphic_context[0] = DestroyDrawInfo(graphic_context[0]);
      graphic_context=(DrawInfo **) RelinquishMagickMemory(graphic_context);
      primitive = DestroyString(primitive);
      return(MagickFalse);
    }
  (void) memset(&mvg_info,0,sizeof(mvg_info));
  mvg_info.primitive_info = &primitive_info;
  mvg_info.extent = &extent;
  mvg_info.offset = 0;
  mvg_info.exception = exception;

  token = AcquireString(primitive);
  q=primitive;
  for ( ; ; )
  {
    /*
      Extract the next keyword (command) from the MVG string.
    */
    GetNextToken(q,&q,MagickPathExtent,keyword);
    if (*keyword == '\0')
      {
        if (*q == '\0')
          break;
        else
          continue;
      }
    /*
      Process the recognized drawing command.
    */
    if (LocaleCompare("push",keyword) == 0)
      {
        /*
          Push new graphic context onto the stack.
        */
        GetNextToken(q,&q,MagickPathExtent,keyword);
        if (*keyword == '\0')
          (void) CloneString(&keyword,"");
        n++;
        if (n == max_stack_depth)
          {
            ssize_t
              depth;

            depth = max_stack_depth;
            max_stack_depth <<= 1;
            if ((size_t) max_stack_depth > (size_t) (SSIZE_MAX/sizeof(*graphic_context)))
              ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
            graphic_context=(DrawInfo **) ResizeQuantumMemory(graphic_context,
              (size_t) max_stack_depth,sizeof(*graphic_context));
            if (graphic_context == (DrawInfo **) NULL)
              ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
            (void) memset(graphic_context+depth,0,(size_t) (max_stack_depth-depth)*
              sizeof(*graphic_context));
          }
        graphic_context[n] = CloneDrawInfo((ImageInfo *) NULL, graphic_context[n-1]);
        continue;
      }
    if (LocaleCompare("pop",keyword) == 0)
      {
        /*
          Pop existing graphic context off stack.
        */
        GetNextToken(q,&q,MagickPathExtent,keyword);
        if (*keyword == '\0')
          (void) CloneString(&keyword,"");
        if (n <= 0)
          {
            status = MagickFalse;
            (void) ThrowMagickException(exception,GetMagickModule(),DrawError,
              "InvalidPopGraphicContextArgument","`%s'",draw_info->primitive);
            break;
          }
        graphic_context[n] = DestroyDrawInfo(graphic_context[n]);
        n--;
        continue;
      }
    /*
      Many commands alter the current context or draw shapes. We parse them
      and build the geometry in 'primitive_info', then pass it to DrawPrimitive.
    */
    if (LocaleCompare("rectangle",keyword) == 0)
      {
        PointInfo
          start,
          end;

        GetNextToken(q,&q,MagickPathExtent,token);
        start.x = StringToDouble(token,(char **) NULL);
        GetNextToken(q,&q,MagickPathExtent,token);
        start.y = StringToDouble(token,(char **) NULL);
        GetNextToken(q,&q,MagickPathExtent,token);
        end.x = StringToDouble(token,(char **) NULL);
        GetNextToken(q,&q,MagickPathExtent,token);
        end.y = StringToDouble(token,(char **) NULL);
        primitive_info[mvg_info.offset].primitive=RectanglePrimitive;
        TraceRectangle(primitive_info+mvg_info.offset,start,end);
        primitive_info[mvg_info.offset].method=ReplaceMethod;
        mvg_info.offset += primitive_info[mvg_info.offset].coordinates;
        if (primitive_info[mvg_info.offset].coordinates != 0)
          status &= DrawPrimitive(image,graphic_context[n],
            primitive_info+mvg_info.offset-primitive_info[mvg_info.offset].coordinates,
            exception);
        continue;
      }
    if (LocaleCompare("roundRectangle",keyword) == 0)
      {
        PointInfo
          start,
          end,
          arc;

        GetNextToken(q,&q,MagickPathExtent,token);
        start.x = StringToDouble(token,(char **) NULL);
        GetNextToken(q,&q,MagickPathExtent,token);
        start.y = StringToDouble(token,(char **) NULL);
        GetNextToken(q,&q,MagickPathExtent,token);
        end.x = StringToDouble(token,(char **) NULL);
        GetNextToken(q,&q,MagickPathExtent,token);
        end.y = StringToDouble(token,(char **) NULL);
        GetNextToken(q,&q,MagickPathExtent,token);
        arc.x = StringToDouble(token,(char **) NULL);
        GetNextToken(q,&q,MagickPathExtent,token);
        arc.y = StringToDouble(token,(char **) NULL);
        primitive_info[mvg_info.offset].primitive = RoundRectanglePrimitive;
        TraceRoundRectangle(&mvg_info,start,end,arc);
        primitive_info[mvg_info.offset].method=ReplaceMethod;
        mvg_info.offset += primitive_info[mvg_info.offset].coordinates;
        if (primitive_info[mvg_info.offset].coordinates != 0)
          status &= DrawPrimitive(image,graphic_context[n],
            primitive_info+mvg_info.offset-primitive_info[mvg_info.offset].coordinates,
            exception);
        continue;
      }
    if (LocaleCompare("ellipse",keyword) == 0)
      {
        PointInfo
          center,
          radius,
          arc;

        GetNextToken(q,&q,MagickPathExtent,token);
        center.x=StringToDouble(token,(char **) NULL);
        GetNextToken(q,&q,MagickPathExtent,token);
        center.y=StringToDouble(token,(char **) NULL);
        GetNextToken(q,&q,MagickPathExtent,token);
        radius.x=StringToDouble(token,(char **) NULL);
        GetNextToken(q,&q,MagickPathExtent,token);
        radius.y=StringToDouble(token,(char **) NULL);
        GetNextToken(q,&q,MagickPathExtent,token);
        arc.x=StringToDouble(token,(char **) NULL);
        GetNextToken(q,&q,MagickPathExtent,token);
        arc.y=StringToDouble(token,(char **) NULL);
        primitive_info[mvg_info.offset].primitive=EllipsePrimitive;
        TraceEllipse(&mvg_info,center,radius,arc);
        primitive_info[mvg_info.offset].method=ReplaceMethod;
        mvg_info.offset += primitive_info[mvg_info.offset].coordinates;
        if (primitive_info[mvg_info.offset].coordinates != 0)
          status &= DrawPrimitive(image,graphic_context[n],
            primitive_info+mvg_info.offset-primitive_info[mvg_info.offset].coordinates,
            exception);
        continue;
      }
    if (LocaleCompare("circle",keyword) == 0)
      {
        PointInfo
          start,
          end;

        GetNextToken(q,&q,MagickPathExtent,token);
        start.x = StringToDouble(token,(char **) NULL);
        GetNextToken(q,&q,MagickPathExtent,token);
        start.y = StringToDouble(token,(char **) NULL);
        GetNextToken(q,&q,MagickPathExtent,token);
        end.x = StringToDouble(token,(char **) NULL);
        GetNextToken(q,&q,MagickPathExtent,token);
        end.y = StringToDouble(token,(char **) NULL);
        primitive_info[mvg_info.offset].primitive=CirclePrimitive;
        TraceCircle(&mvg_info,start,end);
        primitive_info[mvg_info.offset].method=ReplaceMethod;
        mvg_info.offset += primitive_info[mvg_info.offset].coordinates;
        if (primitive_info[mvg_info.offset].coordinates != 0)
          status &= DrawPrimitive(image,graphic_context[n],
            primitive_info+mvg_info.offset-primitive_info[mvg_info.offset].coordinates,
            exception);
        continue;
      }
    if (LocaleCompare("arc",keyword) == 0)
      {
        PointInfo
          start,
          end,
          degrees;

        GetNextToken(q,&q,MagickPathExtent,token);
        start.x = StringToDouble(token,(char **) NULL);
        GetNextToken(q,&q,MagickPathExtent,token);
        start.y = StringToDouble(token,(char **) NULL);
        GetNextToken(q,&q,MagickPathExtent,token);
        end.x = StringToDouble(token,(char **) NULL);
        GetNextToken(q,&q,MagickPathExtent,token);
        end.y = StringToDouble(token,(char **) NULL);
        GetNextToken(q,&q,MagickPathExtent,token);
        degrees.x = StringToDouble(token,(char **) NULL);
        GetNextToken(q,&q,MagickPathExtent,token);
        degrees.y = StringToDouble(token,(char **) NULL);
        primitive_info[mvg_info.offset].primitive=ArcPrimitive;
        TraceArc(&mvg_info,start,end,degrees);
        primitive_info[mvg_info.offset].method=ReplaceMethod;
        mvg_info.offset += primitive_info[mvg_info.offset].coordinates;
        if (primitive_info[mvg_info.offset].coordinates != 0)
          status &= DrawPrimitive(image,graphic_context[n],
            primitive_info+mvg_info.offset-primitive_info[mvg_info.offset].coordinates,
            exception);
        continue;
      }
    if (LocaleCompare("line",keyword) == 0)
      {
        PointInfo
          start,
          end;

        GetNextToken(q,&q,MagickPathExtent,token);
        start.x=StringToDouble(token,(char **) NULL);
        GetNextToken(q,&q,MagickPathExtent,token);
        start.y=StringToDouble(token,(char **) NULL);
        GetNextToken(q,&q,MagickPathExtent,token);
        end.x=StringToDouble(token,(char **) NULL);
        GetNextToken(q,&q,MagickPathExtent,token);
        end.y=StringToDouble(token,(char **) NULL);
        primitive_info[mvg_info.offset].primitive=LinePrimitive;
        TraceLine(primitive_info+mvg_info.offset,start,end);
        primitive_info[mvg_info.offset].method=ReplaceMethod;
        mvg_info.offset += primitive_info[mvg_info.offset].coordinates;
        if (primitive_info[mvg_info.offset].coordinates != 0)
          status &= DrawPrimitive(image,graphic_context[n],
            primitive_info+mvg_info.offset-primitive_info[mvg_info.offset].coordinates,
            exception);
        continue;
      }
    if (LocaleCompare("polygon",keyword) == 0)
      {
        size_t
          num_coords;

        /*
          Polygon command.  The coordinates are read and traced.
        */
        primitive_info[mvg_info.offset].primitive=PolygonPrimitive;
        num_coords=0;
        for ( ; ; )
        {
          GetNextToken(q,&q,MagickPathExtent,token);
          if (*token == '\0')
            break;
          primitive_info[mvg_info.offset+num_coords+1].point.x =
            StringToDouble(token,(char **) NULL);
          GetNextToken(q,&q,MagickPathExtent,token);
          if (*token == '\0')
            break;
          primitive_info[mvg_info.offset+num_coords+1].point.y =
            StringToDouble(token,(char **) NULL);
          num_coords++;
        }
        if (num_coords < 2)
          {
            /*
              Not enough vertices for a polygon, ignore.
            */
            continue;
          }
        primitive_info[mvg_info.offset].coordinates=num_coords+1;
        mvg_info.offset += num_coords+1;
        if (CheckPrimitiveExtent(&mvg_info,1) != MagickFalse)
          primitive_info=(*mvg_info.primitive_info)+mvg_info.offset;
        primitive_info[mvg_info.offset].primitive=UndefinedPrimitive;
        primitive_info[mvg_info.offset].coordinates=0;
        primitive_info[mvg_info.offset-num_coords-1].method=ReplaceMethod;
        status &= DrawPrimitive(image,graphic_context[n],
          primitive_info+mvg_info.offset-(num_coords+1),
          exception);
        continue;
      }
    if (LocaleCompare("path",keyword) == 0)
      {
        /*
          Path command.  A series of path elements is traced.
        */
        size_t
          num_coords;

        GetNextToken(q,&q,MagickPathExtent,token);
        primitive_info[mvg_info.offset].primitive=PathPrimitive;
        num_coords=TracePath(&mvg_info,token,exception);
        if (num_coords != 0)
          {
            mvg_info.offset+=num_coords;
            if (CheckPrimitiveExtent(&mvg_info,1) != MagickFalse)
              primitive_info=(*mvg_info.primitive_info)+mvg_info.offset;
            primitive_info[mvg_info.offset].primitive=UndefinedPrimitive;
            primitive_info[mvg_info.offset].coordinates=0;
            primitive_info[mvg_info.offset-num_coords].method=ReplaceMethod;
            status &=
              DrawPrimitive(image,graphic_context[n],
                primitive_info+mvg_info.offset-num_coords,exception);
          }
        continue;
      }
    if (LocaleCompare("text",keyword) == 0)
      {
        double
          x,
          y;

        GetNextToken(q,&q,MagickPathExtent,token);
        x=StringToDouble(token,(char **) NULL);
        GetNextToken(q,&q,MagickPathExtent,token);
        y=StringToDouble(token,(char **) NULL);
        GetNextToken(q,&q,MagickPathExtent,token);
        primitive_info[mvg_info.offset].primitive=TextPrimitive;
        primitive_info[mvg_info.offset].point.x=x;
        primitive_info[mvg_info.offset].point.y=y;
        primitive_info[mvg_info.offset].text=AcquireString(token);
        primitive_info[mvg_info.offset].method=ReplaceMethod;
        primitive_info[mvg_info.offset].coordinates=1;
        mvg_info.offset++;
        if (CheckPrimitiveExtent(&mvg_info,1) != MagickFalse)
          primitive_info=(*mvg_info.primitive_info)+mvg_info.offset;
        primitive_info[mvg_info.offset].primitive=UndefinedPrimitive;
        primitive_info[mvg_info.offset].coordinates=0;
        status &=
          DrawPrimitive(image,graphic_context[n],
            primitive_info+mvg_info.offset-1,exception);
        continue;
      }
    if (LocaleCompare("image",keyword) == 0)
      {
        /*
          Render an image onto the current image (composite form).
        */
        PointInfo
          start,
          end;

        GetNextToken(q,&q,MagickPathExtent,token);
        start.x=StringToDouble(token,(char **) NULL);
        GetNextToken(q,&q,MagickPathExtent,token);
        start.y=StringToDouble(token,(char **) NULL);
        GetNextToken(q,&q,MagickPathExtent,token);
        end.x=StringToDouble(token,(char **) NULL);
        GetNextToken(q,&q,MagickPathExtent,token);
        end.y=StringToDouble(token,(char **) NULL);
        GetNextToken(q,&q,MagickPathExtent,token);
        primitive_info[mvg_info.offset].primitive=ImagePrimitive;
        primitive_info[mvg_info.offset].point.x=start.x;
        primitive_info[mvg_info.offset].point.y=start.y;
        primitive_info[mvg_info.offset+1].point.x=end.x;
        primitive_info[mvg_info.offset+1].point.y=end.y;
        primitive_info[mvg_info.offset].text=AcquireString(token);
        primitive_info[mvg_info.offset].method=ReplaceMethod;
        primitive_info[mvg_info.offset].coordinates=2;
        mvg_info.offset+=2;
        if (CheckPrimitiveExtent(&mvg_info,1) != MagickFalse)
          primitive_info=(*mvg_info.primitive_info)+mvg_info.offset;
        primitive_info[mvg_info.offset].primitive=UndefinedPrimitive;
        primitive_info[mvg_info.offset].coordinates=0;
        status &=
          DrawPrimitive(image,graphic_context[n],
            primitive_info+mvg_info.offset-2,exception);
        continue;
      }
    if (LocaleCompare("fill",keyword) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        (void) QueryColorCompliance(token,AllCompliance,&graphic_context[n]->fill,
          exception);
        continue;
      }
    if (LocaleCompare("fill-opacity",keyword) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->fill.alpha=(double)
          (ClampToQuantum((MagickRealType) (QuantumRange-
           QuantumRange*StringToDouble(token,(char **) NULL))));
        continue;
      }
    if (LocaleCompare("fill-rule",keyword) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        if (LocaleCompare("evenodd",token) == 0)
          graphic_context[n]->fill_rule=EvenOddRule;
        else
          graphic_context[n]->fill_rule=NonZeroRule;
        continue;
      }
    if (LocaleCompare("stroke",keyword) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        (void) QueryColorCompliance(token,AllCompliance,
          &graphic_context[n]->stroke,exception);
        continue;
      }
    if (LocaleCompare("stroke-opacity",keyword) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->stroke.alpha=(double)
          (ClampToQuantum((MagickRealType) (QuantumRange-
           QuantumRange*StringToDouble(token,(char **) NULL))));
        continue;
      }
    if (LocaleCompare("stroke-width",keyword) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->stroke_width=StringToDouble(token,(char **) NULL);
        continue;
      }
    if (LocaleCompare("linecap",keyword) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->linecap=(LineCap) ParseCommandOption(
          MagickLineCapOptions,MagickFalse,token);
        continue;
      }
    if (LocaleCompare("linejoin",keyword) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->linejoin=(LineJoin) ParseCommandOption(
          MagickLineJoinOptions,MagickFalse,token);
        continue;
      }
    if (LocaleCompare("miterlimit",keyword) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->miterlimit=(size_t) StringToUnsignedLong(token);
        continue;
      }
    if (LocaleCompare("dasharray",keyword) == 0)
      {
        ssize_t
          j;

        if (graphic_context[n]->dash_pattern != (double *) NULL)
          graphic_context[n]->dash_pattern=(double *) RelinquishMagickMemory(
            graphic_context[n]->dash_pattern);
        graphic_context[n]->dash_pattern=(double *) AcquireQuantumMemory(
          MagickPathExtent,sizeof(*graphic_context[n]->dash_pattern));
        if (graphic_context[n]->dash_pattern == (double *) NULL)
          ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
        (void) memset(graphic_context[n]->dash_pattern,0,MagickPathExtent*
          sizeof(*graphic_context[n]->dash_pattern));
        for (j=0; j < (ssize_t) (MagickPathExtent-1); j++)
        {
          GetNextToken(q,&q,MagickPathExtent,token);
          if (*token == '\0')
            break;
          graphic_context[n]->dash_pattern[j]=StringToDouble(token,(char **)NULL);
        }
        continue;
      }
    if (LocaleCompare("dashoffset",keyword) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->dash_offset=StringToDouble(token,(char **) NULL);
        continue;
      }
    if (LocaleCompare("font-size",keyword) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->pointsize=StringToDouble(token,(char **)NULL);
        continue;
      }
    if (LocaleCompare("font",keyword) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        if (graphic_context[n]->font != (char *) NULL)
          graphic_context[n]->font=DestroyString(graphic_context[n]->font);
        (void) CloneString(&graphic_context[n]->font,token);
        continue;
      }
    if (LocaleCompare("font-style",keyword) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->style=(StyleType) ParseCommandOption(
          MagickStyleOptions,MagickFalse,token);
        continue;
      }
    if (LocaleCompare("font-stretch",keyword) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->stretch=(StretchType) ParseCommandOption(
          MagickStretchOptions,MagickFalse,token);
        continue;
      }
    if (LocaleCompare("font-weight",keyword) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->weight=(size_t) StringToUnsignedLong(token);
        continue;
      }
    if (LocaleCompare("font-family",keyword) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        if (graphic_context[n]->family != (char *) NULL)
          graphic_context[n]->family=DestroyString(graphic_context[n]->family);
        (void) CloneString(&graphic_context[n]->family,token);
        continue;
      }
    if (LocaleCompare("text-decoration",keyword) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->decorate=(DecorationType) ParseCommandOption(
          MagickDecorateOptions,MagickFalse,token);
        continue;
      }
    if (LocaleCompare("text-antialias",keyword) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->text_antialias=IsStringTrue(token);
        continue;
      }
    if (LocaleCompare("gravity",keyword) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->gravity=(GravityType) ParseCommandOption(
          MagickGravityOptions,MagickFalse,token);
        continue;
      }
    if (LocaleCompare("viewbox",keyword) == 0)
      {
        RectangleInfo
          bounds;

        GetNextToken(q,&q,MagickPathExtent,token);
        bounds.x=(ssize_t) StringToLong(token);
        GetNextToken(q,&q,MagickPathExtent,token);
        bounds.y=(ssize_t) StringToLong(token);
        GetNextToken(q,&q,MagickPathExtent,token);
        bounds.width=(size_t) StringToUnsignedLong(token)-
          (size_t) bounds.x;
        GetNextToken(q,&q,MagickPathExtent,token);
        bounds.height=(size_t) StringToUnsignedLong(token)-
          (size_t) bounds.y;
        graphic_context[n]->viewbox=bounds;
        continue;
      }
    if (LocaleCompare("clip-path",keyword) == 0)
      {
        (void) CloneString(&graphic_context[n]->clip_mask,(char *) NULL);
        GetNextToken(q,&q,MagickPathExtent,token);
        if (*token != '\0')
          (void) CloneString(&graphic_context[n]->clip_mask,token);
        continue;
      }
    if (LocaleCompare("clip-rule",keyword) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        if (LocaleCompare("evenodd",token) == 0)
          graphic_context[n]->clip_units=EvenOddRule;
        else
          graphic_context[n]->clip_units=NonZeroRule;
        continue;
      }
    if (LocaleCompare("mask",keyword) == 0)
      {
        /*
          Load or remove mask path.
        */
        GetNextToken(q,&q,MagickPathExtent,token);
        if (*token != '\0')
          {
            if (LocaleCompare("none",token) == 0)
              {
                if (graphic_context[n]->composite_mask != (Image *) NULL)
                  graphic_context[n]->composite_mask=
                    DestroyImage(graphic_context[n]->composite_mask);
                graphic_context[n]->clip_units=UserSpaceOnUse;
                continue;
              }
            {
              Image
                *mask_image;

              mask_image=DrawCompositeMask(image,graphic_context[n],token,
                GetNodeByURL(primitive,token),exception);
              if (mask_image == (Image *) NULL)
                {
                  status=MagickFalse;
                  break;
                }
              if (graphic_context[n]->composite_mask != (Image *) NULL)
                graphic_context[n]->composite_mask=
                  DestroyImage(graphic_context[n]->composite_mask);
              graphic_context[n]->composite_mask=mask_image;
            }
          }
        continue;
      }
    /*
      If we haven't recognized the token, it's an error or a no-op.
    */
    (void) ThrowMagickException(exception,GetMagickModule(),DrawError,
      "UnrecognizedDrawingPrimitive","`%s'",keyword);
    status=MagickFalse;
    break;
  }
}