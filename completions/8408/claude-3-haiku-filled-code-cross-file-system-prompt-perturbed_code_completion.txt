/*
    Interpret and execute drawing commands.
  */
  for (n=0; ; n++)
  {
    GetNextToken(primitive,&primitive,MagickPathExtent,primitive_name);
    if (*primitive_name == '\0')
      break;
    GetNextToken(primitive,&primitive,MagickPathExtent,geometry);
    switch (*primitive_name)
    {
      case 'a':
      case 'A':
      {
        if (LocaleCompare("affine",primitive_name) == 0)
          {
            GetNextToken(primitive,&primitive,MagickPathExtent,token);
            affine.sx=StringToDouble(token,&next_token);
            GetNextToken(primitive,&primitive,MagickPathExtent,token);
            if (*token == ',')
              GetNextToken(primitive,&primitive,MagickPathExtent,token);
            affine.rx=StringToDouble(token,&next_token);
            GetNextToken(primitive,&primitive,MagickPathExtent,token);
            if (*token == ',')
              GetNextToken(primitive,&primitive,MagickPathExtent,token);
            affine.ry=StringToDouble(token,&next_token);
            GetNextToken(primitive,&primitive,MagickPathExtent,token);
            if (*token == ',')
              GetNextToken(primitive,&primitive,MagickPathExtent,token);
            affine.sy=StringToDouble(token,&next_token);
            GetNextToken(primitive,&primitive,MagickPathExtent,token);
            if (*token == ',')
              GetNextToken(primitive,&primitive,MagickPathExtent,token);
            affine.tx=StringToDouble(token,&next_token);
            GetNextToken(primitive,&primitive,MagickPathExtent,token);
            if (*token == ',')
              GetNextToken(primitive,&primitive,MagickPathExtent,token);
            affine.ty=StringToDouble(token,&next_token);
            break;
          }
        if (LocaleCompare("alpha",primitive_name) == 0)
          {
            GetNextToken(primitive,&primitive,MagickPathExtent,token);
            if (LocaleCompare("point",token) == 0)
              primitive_info[j].method=PointMethod;
            if (LocaleCompare("replace",token) == 0)
              primitive_info[j].method=ReplaceMethod;
            if (LocaleCompare("floodfill",token) == 0)
              primitive_info[j].method=FloodfillMethod;
            if (LocaleCompare("filltoborder",token) == 0)
              primitive_info[j].method=FillToBorderMethod;
            if (LocaleCompare("reset",token) == 0)
              primitive_info[j].method=ResetMethod;
            break;
          }
        if (LocaleCompare("angle",primitive_name) == 0)
          {
            GetNextToken(primitive,&primitive,MagickPathExtent,token);
            affine.rx=StringToDouble(token,&next_token);
            affine.ry=StringToDouble(token,&next_token);
            break;
          }
        if (LocaleCompare("arc",primitive_name) == 0)
          {
            primitive_type=ArcPrimitive;
            break;
          }
        status=MagickFalse;
        break;
      }
      case 'b':
      case 'B':
      {
        if (LocaleCompare("bezier",primitive_name) == 0)
          {
            primitive_type=BezierPrimitive;
            break;
          }
        status=MagickFalse;
        break;
      }
      case 'c':
      case 'C':
      {
        if (LocaleCompare("circle",primitive_name) == 0)
          {
            primitive_type=CirclePrimitive;
            break;
          }
        if (LocaleCompare("color",primitive_name) == 0)
          {
            primitive_type=ColorPrimitive;
            break;
          }
        status=MagickFalse;
        break;
      }
      case 'e':
      case 'E':
      {
        if (LocaleCompare("ellipse",primitive_name) == 0)
          {
            primitive_type=EllipsePrimitive;
            break;
          }
        status=MagickFalse;
        break;
      }
      case 'i':
      case 'I':
      {
        if (LocaleCompare("image",primitive_name) == 0)
          {
            primitive_type=ImagePrimitive;
            break;
          }
        status=MagickFalse;
        break;
      }
      case 'l':
      case 'L':
      {
        if (LocaleCompare("line",primitive_name) == 0)
          {
            primitive_type=LinePrimitive;
            break;
          }
        status=MagickFalse;
        break;
      }
      case 'p':
      case 'P':
      {
        if (LocaleCompare("path",primitive_name) == 0)
          {
            primitive_type=PathPrimitive;
            break;
          }
        if (LocaleCompare("point",primitive_name) == 0)
          {
            primitive_type=PointPrimitive;
            break;
          }
        if (LocaleCompare("polygon",primitive_name) == 0)
          {
            primitive_type=PolygonPrimitive;
            break;
          }
        if (LocaleCompare("polyline",primitive_name) == 0)
          {
            primitive_type=PolylinePrimitive;
            break;
          }
        status=MagickFalse;
        break;
      }
      case 'r':
      case 'R':
      {
        if (LocaleCompare("rectangle",primitive_name) == 0)
          {
            primitive_type=RectanglePrimitive;
            break;
          }
        if (LocaleCompare("roundRectangle",primitive_name) == 0)
          {
            primitive_type=RoundRectanglePrimitive;
            break;
          }
        status=MagickFalse;
        break;
      }
      case 't':
      case 'T':
      {
        if (LocaleCompare("text",primitive_name) == 0)
          {
            primitive_type=TextPrimitive;
            break;
          }
        status=MagickFalse;
        break;
      }
      default:
      {
        status=MagickFalse;
        break;
      }
    }
    if (status == MagickFalse)
      break;
    if (primitive_type == UndefinedPrimitive)
      continue;
    /*
      Parse the primitive attributes.
    */
    i=0;
    j=0;
    for (x=0; *primitive != '\0'; x++)
    {
      /*
        Define points.
      */
      if (IsPoint(primitive) == MagickFalse)
        break;
      GetNextToken(primitive,&primitive,MagickPathExtent,token);
      point.x=StringToDouble(token,&next_token);
      GetNextToken(primitive,&primitive,MagickPathExtent,token);
      if (*token == ',')
        GetNextToken(primitive,&primitive,MagickPathExtent,token);
      point.y=StringToDouble(token,&next_token);
      GetNextToken(primitive,(const char **) NULL,MagickPathExtent,token);
      if (*token == ',')
        GetNextToken(primitive,&primitive,MagickPathExtent,token);
      primitive_info[i].primitive=primitive_type;
      primitive_info[i].point=point;
      primitive_info[i].coordinates=0;
      primitive_info[i].method=FloodfillMethod;
      i++;
      if (i < (ssize_t) (number_points-6*BezierQuantum-360))
        continue;
      number_points+=6*BezierQuantum+360;
      primitive_info=(PrimitiveInfo *) ResizeQuantumMemory(primitive_info,
        number_points,sizeof(*primitive_info));
      if (primitive_info == (PrimitiveInfo *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),
            ResourceLimitError,"MemoryAllocationFailed","`%s'",image->filename);
          break;
        }
    }
    primitive_info[j].primitive=primitive_type;
    primitive_info[j].coordinates=x;
    primitive_info[j].method=FloodfillMethod;
    primitive_info[j].text=(char *) NULL;
    if (active)
      {
        AffineToTransform(image,&affine);
        active=MagickFalse;
      }
    active=MagickFalse;
    switch (primitive_type)
    {
      case PointPrimitive:
      default:
      {
        if (primitive_info[j].coordinates != 1)
          {
            status=MagickFalse;
            break;
          }
        break;
      }
      case LinePrimitive:
      {
        if (primitive_info[j].coordinates != 2)
          {
            status=MagickFalse;
            break;
          }
        break;
      }
      case RectanglePrimitive:
      {
        if (primitive_info[j].coordinates != 2)
          {
            status=MagickFalse;
            break;
          }
        break;
      }
      case RoundRectanglePrimitive:
      {
        if (primitive_info[j].coordinates != 3)
          {
            status=MagickFalse;
            break;
          }
        break;
      }
      case ArcPrimitive:
      {
        if (primitive_info[j].coordinates != 3)
          {
            status=MagickFalse;
            break;
          }
        break;
      }
      case EllipsePrimitive:
      {
        if (primitive_info[j].coordinates != 3)
          {
            status=MagickFalse;
            break;
          }
        break;
      }
      case PolylinePrimitive:
      {
        if (primitive_info[j].coordinates < 2)
          {
            status=MagickFalse;
            break;
          }
        break;
      }
      case PolygonPrimitive:
      {
        if (primitive_info[j].coordinates < 3)
          {
            status=MagickFalse;
            break;
          }
        primitive_info[i]=primitive_info[j];
        primitive_info[i].coordinates=0;
        primitive_info[j].coordinates++;
        i++;
        break;
      }
      case BezierPrimitive:
      {
        if (primitive_info[j].coordinates < 3)
          {
            status=MagickFalse;
            break;
          }
        break;
      }
      case PathPrimitive:
      {
        int
          number_attributes;

        GetNextToken(primitive,&primitive,MagickPathExtent,token);
        number_attributes=1;
        for (p=token; *p != '\0'; p++)
          if (isalpha((int) *p))
            number_attributes++;
        if (i > (ssize_t) (number_points-6*BezierQuantum*number_attributes-1))
          {
            number_points+=6*BezierQuantum*number_attributes;
            primitive_info=(PrimitiveInfo *) ResizeQuantumMemory(primitive_info,
              number_points,sizeof(*primitive_info));
            if (primitive_info == (PrimitiveInfo *) NULL)
              {