DrawInfo
    **graphic_context;

  Image
    *composite_mask,
    *fill_pattern,
    *stroke_pattern;

  MagickBooleanType
    status;

  MVGInfo
    mvg_info;

  PrimitiveInfo
    *primitive_info;

  StopInfo
    *stops;

  size_t
    extent;

  ssize_t
    n;

  /*
    Initialize graphic context.
  */
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(DrawEvent,GetMagickModule(),"begin draw-image");
  status=MagickTrue;
  graphic_context=(DrawInfo **) AcquireQuantumMemory(16UL,
    sizeof(*graphic_context));
  if (graphic_context == (DrawInfo **) NULL)
    ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
  (void) memset(graphic_context,0,16UL*sizeof(*graphic_context));
  graphic_context[0]=CloneDrawInfo(image->image_info,draw_info);
  n=0;
  extent=MaxBezierCoordinates;
  primitive_info=(PrimitiveInfo *) AcquireQuantumMemory(extent,
    sizeof(*primitive_info));
  if (primitive_info == (PrimitiveInfo *) NULL)
    ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
  (void) memset(primitive_info,0,extent*sizeof(*primitive_info));
  mvg_info.primitive_info=&primitive_info;
  mvg_info.extent=&extent;
  mvg_info.offset=0;
  mvg_info.exception=exception;
  stops=(StopInfo *) NULL;
  if (graphic_context[0]->primitive != (char *) NULL)
    {
      char
        *primitive;

      primitive=GetNodeByURL(graphic_context[0]->primitive,"defs");
      if (primitive != (char *) NULL)
        {
          /*
            Parse definitions.
          */
          (void) CloneString(&graphic_context[0]->primitive,primitive);
          primitive=DestroyString(primitive);
        }
      primitive=AcquireString(graphic_context[0]->primitive);
      token=AcquireString(primitive);
      for (q=primitive; *q != '\0'; )
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        if (*token == '\0')
          break;
        if (*token == '#')
          {
            /*
              Comment.
            */
            while ((*q != '\n') && (*q != '\0'))
              q++;
            continue;
          }
        if (LocaleCompare("fill",token) == 0)
          {
            GetNextToken(q,&q,MagickPathExtent,token);
            (void) QueryColorCompliance(token,AllCompliance,
              &graphic_context[0]->fill,exception);
            continue;
          }
        if (LocaleCompare("stroke",token) == 0)
          {
            GetNextToken(q,&q,MagickPathExtent,token);
            (void) QueryColorCompliance(token,AllCompliance,
              &graphic_context[0]->stroke,exception);
            continue;
          }
        if (LocaleCompare("stroke-width",token) == 0)
          {
            GetNextToken(q,&q,MagickPathExtent,token);
            graphic_context[0]->stroke_width=StringToDouble(token,
              &next_token);
            continue;
          }
        if (LocaleCompare("stroke-linecap",token) == 0)
          {
            GetNextToken(q,&q,MagickPathExtent,token);
            graphic_context[0]->linecap=(LineCap) ParseCommandOption(
              MagickLineCapOptions,MagickFalse,token);
            continue;
          }
        if (LocaleCompare("stroke-linejoin",token) == 0)
          {
            GetNextToken(q,&q,MagickPathExtent,token);
            graphic_context[0]->linejoin=(LineJoin) ParseCommandOption(
              MagickLineJoinOptions,MagickFalse,token);
            continue;
          }
        if (LocaleCompare("stroke-miterlimit",token) == 0)
          {
            GetNextToken(q,&q,MagickPathExtent,token);
            graphic_context[0]->miterlimit=StringToDouble(token,
              &next_token);
            continue;
          }
        if (LocaleCompare("stroke-dasharray",token) == 0)
          {
            double
              *dash_pattern;

            ssize_t
              i;

            GetNextToken(q,&q,MagickPathExtent,token);
            dash_pattern=(double *) AcquireQuantumMemory((size_t)
              strlen(token)+1UL,sizeof(*dash_pattern));
            if (dash_pattern == (double *) NULL)
              ThrowFatalException(ResourceLimitFatalError,
                "MemoryAllocationFailed");
            i=0;
            for ( ; *token != '\0'; )
            {
              dash_pattern[i]=StringToDouble(token,&next_token);
              token=next_token;
              while (isspace((int) ((unsigned char) *token)) != 0)
                token++;
              if (*token == ',')
                token++;
              i++;
            }
            dash_pattern[i]=0.0;
            graphic_context[0]->dash_pattern=dash_pattern;
            continue;
          }
        if (LocaleCompare("stroke-dashoffset",token) == 0)
          {
            GetNextToken(q,&q,MagickPathExtent,token);
            graphic_context[0]->dash_offset=StringToDouble(token,
              &next_token);
            continue;
          }
        if (LocaleCompare("fill-rule",token) == 0)
          {
            GetNextToken(q,&q,MagickPathExtent,token);
            graphic_context[0]->fill_rule=(FillRule) ParseCommandOption(
              MagickFillRuleOptions,MagickFalse,token);
            continue;
          }
        if (LocaleCompare("font",token) == 0)
          {
            GetNextToken(q,&q,MagickPathExtent,token);
            (void) CloneString(&graphic_context[0]->font,token);
            continue;
          }
        if (LocaleCompare("font-family",token) == 0)
          {
            GetNextToken(q,&q,MagickPathExtent,token);
            (void) CloneString(&graphic_context[0]->family,token);
            continue;
          }
        if (LocaleCompare("font-size",token) == 0)
          {
            GetNextToken(q,&q,MagickPathExtent,token);
            graphic_context[0]->pointsize=StringToDouble(token,&next_token);
            continue;
          }
        if (LocaleCompare("font-style",token) == 0)
          {
            GetNextToken(q,&q,MagickPathExtent,token);
            graphic_context[0]->style=(StyleType) ParseCommandOption(
              MagickStyleOptions,MagickFalse,token);
            continue;
          }
        if (LocaleCompare("font-weight",token) == 0)
          {
            GetNextToken(q,&q,MagickPathExtent,token);
            graphic_context[0]->weight=(size_t) StringToUnsignedLong(token);
            continue;
          }
        if (LocaleCompare("text-anchor",token) == 0)
          {
            GetNextToken(q,&q,MagickPathExtent,token);
            graphic_context[0]->align=(AlignType) ParseCommandOption(
              MagickAlignOptions,MagickFalse,token);
            continue;
          }
        if (LocaleCompare("text-decoration",token) == 0)
          {
            GetNextToken(q,&q,MagickPathExtent,token);
            graphic_context[0]->decorate=(DecorationType) ParseCommandOption(
              MagickDecorationOptions,MagickFalse,token);
            continue;
          }
        if (LocaleCompare("pattern",token) == 0)
          {
            GetNextToken(q,&q,MagickPathExtent,token);
            (void) FormatLocaleString(pattern,MagickPathExtent,"pattern-%s",
              token);
            fill_pattern=DrawPatternPath(image,graphic_context[0],pattern,
              &fill_pattern,exception);
            if (fill_pattern != (Image *) NULL)
              graphic_context[0]->fill_pattern=fill_pattern;
            continue;
          }
        if (LocaleCompare("gradient",token) == 0)
          {
            GetNextToken(q,&q,MagickPathExtent,token);
            (void) FormatLocaleString(pattern,MagickPathExtent,"gradient-%s",
              token);
            stops=ReadGradient(image,graphic_context[0],pattern,exception);
            if (stops != (StopInfo *) NULL)
              {
                graphic_context[0]->gradient.stops=stops;
                graphic_context[0]->gradient.number_stops=
                  graphic_context[0]->gradient.number_stops;
              }
            continue;
          }
        if (LocaleCompare("stroke-pattern",token) == 0)
          {
            GetNextToken(q,&q,MagickPathExtent,token);
            (void) FormatLocaleString(pattern,MagickPathExtent,
              "pattern-%s",token);
            stroke_pattern=DrawPatternPath(image,graphic_context[0],pattern,
              &stroke_pattern,exception);
            if (stroke_pattern != (Image *) NULL)
              graphic_context[0]->stroke_pattern=stroke_pattern;
            continue;
          }
        if (LocaleCompare("clip-path",token) == 0)
          {
            GetNextToken(q,&q,MagickPathExtent,token);
            (void) DrawClipPath(image,graphic_context[0],token,exception);
            continue;
          }
        if (LocaleCompare("mask",token) == 0)
          {
            GetNextToken(q,&q,MagickPathExtent,token);
            composite_mask=DrawCompositeMask(image,graphic_context[0],token,
              token,exception);
            if (composite_mask != (Image *) NULL)
              graphic_context[0]->composite_mask=composite_mask;
            continue;
          }
        if (LocaleCompare("push",token) == 0)
          {
            n++;
            graphic_context[n]=CloneDrawInfo((ImageInfo *) NULL,
              graphic_context[n-1]);
            continue;
          }
        if (LocaleCompare("pop",token) == 0)
          {
            graphic_context[n]=DestroyDrawInfo(graphic_context[n]);
            n--;
            continue;
          }
        if (LocaleCompare("translate",token) == 0)
          {
            GetNextToken(q,&q,MagickPathExtent,token);
            graphic_context[n]->affine.tx=StringToDouble(token,&next_token);
            GetNextToken(q,&q,MagickPathExtent,token);
            graphic_context[n]->affine.ty=StringToDouble(token,&next_token);
            continue;
          }
        if (LocaleCompare("scale",token) == 0)
          {
            GetNextToken(q,&q,MagickPathExtent,token);
            graphic_context[n]->affine.sx=StringToDouble(token,&next_token);
            GetNextToken(q,&q,MagickPathExtent,token);
            graphic_context[n]->affine.sy=StringToDouble(token,&next_token);
            continue;
          }
        if (LocaleCompare("rotate",token) == 0)
          {
            GetNextToken(q,&q,MagickPathExtent,token);
            graphic_context[n]->affine.rx=StringToDouble(token,&next_token);
            graphic_context[n]->affine.ry=StringToDouble(token,&next_token);
            continue;
          }
        if (LocaleCompare("skewX",token) == 0)
          {
            GetNextToken(q,&q,MagickPathExtent,token);
            graphic_context[n]->affine.rx=tan(DegreesToRadians(
              StringToDouble(token,&next_token)));
            continue;
          }
        if (LocaleCompare("skewY",token) == 0)
          {
            GetNextToken(q,&q,MagickPathExtent,token);
            graphic_context[n]->affine.ry=tan(DegreesToRadians(
              StringToDouble(token,&next_token)));
            continue;
          }
        if (LocaleCompare("matrix",token) == 0)
          {
            GetNextToken(q,&q,MagickPathExtent,token);
            graphic_context[n]->affine.sx=StringToDouble(token,&next_token);
            GetNextToken(q,&q,MagickPathExtent,token);
            graphic_context[n]->affine.rx=StringToDouble(token,&next_token);
            GetNextToken(q,&q,MagickPathExtent,token);
            graphic_context[n]->affine.ry=StringToDouble(token,&next_token);
            GetNextToken(q,&q,MagickPathExtent,token);
            graphic_context[n]-