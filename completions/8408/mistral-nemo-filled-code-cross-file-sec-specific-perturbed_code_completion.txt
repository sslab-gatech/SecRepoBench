// <MASK>
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(DrawEvent,GetMagickModule(),"begin draw-image");
  if (primitive_info != (PrimitiveInfo *) NULL)
    primitive_info=(PrimitiveInfo *) RelinquishMagickMemory(primitive_info);
  primitive_info=(PrimitiveInfo *) AcquireQuantumMemory(number_points,
    sizeof(*primitive_info));
  if (primitive_info == (PrimitiveInfo *) NULL)
    ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
  for ( ; n >= 0; n--)
    graphic_context[n]=DestroyDrawInfo(graphic_context[n]);
  graphic_context=(DrawInfo **) RelinquishMagickMemory(graphic_context);
  graphic_context=(DrawInfo **) AcquireQuantumMemory(n+1,
    sizeof(*graphic_context));
  if (graphic_context == (DrawInfo **) NULL)
    ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
  for (n=0; n < (ssize_t) (number_points-6*BezierQuantum-360); n++)
    primitive_info[n].primitive=UndefinedPrimitive;
  for ( ; q != (const char *) NULL; )
  {
    GetNextToken(q,&q,extent,token);
    if (*token == '\0')
      break;
    if (*token == ';')
      break;
    if (*token == '#')
    {
      // Comment
      if (active != MagickFalse)
      {
        AffineToTransform(image,&affine);
        active=MagickFalse;
      }
      (void) WriteBlobString(image,"<desc>");
      (void) WriteBlobString(image,token+1);
      for ( ; (*q != '\n') && (*q != '\0'); q++)
        switch (*q)
        {
          case '<': (void) WriteBlobString(image,"&lt;"); break;
          case '>': (void) WriteBlobString(image,"&gt;"); break;
          case '&': (void) WriteBlobString(image,"&amp;"); break;
          default: (void) WriteBlobByte(image,*q); break;
        }
      (void) WriteBlobString(image,"</desc>\n");
      continue;
    }
    primitive_type=UndefinedPrimitive;
    switch (*token)
    {
      case 'a':
      case 'A':
      {
        if (LocaleCompare("affine",token) == 0)
        {
          GetNextToken(q,&q,extent,token);
          affine.sx=StringToDouble(token,&next_token);
          GetNextToken(q,&q,extent,token);
          if (*token == ',')
            GetNextToken(q,&q,extent,token);
          affine.rx=StringToDouble(token,&next_token);
          GetNextToken(q,&q,extent,token);
          if (*token == ',')
            GetNextToken(q,&q,extent,token);
          affine.ry=StringToDouble(token,&next_token);
          GetNextToken(q,&q,extent,token);
          if (*token == ',')
            GetNextToken(q,&q,extent,token);
          affine.sy=StringToDouble(token,&next_token);
          GetNextToken(q,&q,extent,token);
          if (*token == ',')
            GetNextToken(q,&q,extent,token);
          affine.tx=StringToDouble(token,&next_token);
          GetNextToken(q,&q,extent,token);
          if (*token == ',')
            GetNextToken(q,&q,extent,token);
          affine.ty=StringToDouble(token,&next_token);
          break;
        }
        // ... (other cases)
        break;
      }
      // ... (other cases)
      default:
      {
        status=MagickFalse;
        break;
      }
    }
    if (status == MagickFalse)
      break;
    if (primitive_type == UndefinedPrimitive)
      continue;
    // ... (rest of the loop)
  }
  if (primitive_info == (PrimitiveInfo *) NULL)
    break;
  primitive_info[i].primitive=UndefinedPrimitive;
  if (status == MagickFalse)
    break;
  // ... (rest of the function)