DrawInfo
    *clone_info;

  GradientInfo
    *gradient;

  MagickBooleanType
    status;

  MagickStatusType
    flags;

  PathInfo
    *path;

  PatternInfo
    *pattern;

  PrimitiveInfo
    *primitive_info;

  ssize_t
    n;

  status=MagickTrue;
  primitive_info=(PrimitiveInfo *) NULL;
  stops=(StopInfo *) NULL;
  n=0;
  graphic_context=(DrawInfo **) AcquireQuantumMemory(MagickPathExtent,
    sizeof(*graphic_context));
  if (graphic_context == (DrawInfo **) NULL)
    ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
      image->filename);
  graphic_context[n]=CloneDrawInfo((ImageInfo *) NULL,draw_info);
  GetAffineMatrix(&affine);
  GetAffineMatrix(&current);
  if (draw_info->primitive == (char *) NULL)
    return(MagickTrue);
  primitive=AcquireString(draw_info->primitive);
  token=primitive;
  for ( ; ; )
  {
    register char
      *p;

    while (isspace((int) ((unsigned char) *token)) != 0)
      token++;
    if (*token == '\0')
      break;
    p=strchr(token,';');
    if (p != (char *) NULL)
      *p='\0';
    (void) CopyMagickString(primitive_name,token,MagickPathExtent);
    if (p != (char *) NULL)
      *p++=';';
    token=p;
    (void) ParseGeometry(primitive_name,&affine.tx,&affine.ty,&affine.sx,
      &affine.sy);
    if (LocaleCompare(primitive_name,"push") == 0)
      {
        n++;
        if (n >= (ssize_t) GetMagickResourceLimit(ThreadResource))
          {
            status=MagickFalse;
            break;
          }
        graphic_context[n]=CloneDrawInfo((ImageInfo *) NULL,
          graphic_context[n-1]);
        if (graphic_context[n] == (DrawInfo *) NULL)
          {
            status=MagickFalse;
            break;
          }
        continue;
      }
    if (LocaleCompare(primitive_name,"pop") == 0)
      {
        if (n == 0)
          {
            status=MagickFalse;
            break;
          }
        graphic_context[n]=DestroyDrawInfo(graphic_context[n]);
        n--;
        continue;
      }
    clone_info=CloneDrawInfo((ImageInfo *) NULL,graphic_context[n]);
    if (clone_info == (DrawInfo *) NULL)
      {
        status=MagickFalse;
        break;
      }
    clone_info->primitive=AcquireString(primitive_name);
    flags=ParseGeometry(primitive_name,&clone_info->affine.tx,
      &clone_info->affine.ty,&clone_info->affine.sx,&clone_info->affine.sy);
    if ((flags & SigmaValue) != 0)
      clone_info->affine.sy=clone_info->affine.sx;
    if ((flags & XiValue) != 0)
      clone_info->affine.ry=clone_info->affine.rx;
    if ((flags & PsiValue) != 0)
      clone_info->affine.ty=clone_info->affine.tx;
    if ((flags & ChiValue) != 0)
      clone_info->affine.ty=clone_info->affine.tx;
    ConcatenateAffineMatrix(&clone_info->affine,&affine);
    clone_info->affine=clone_info->affine;
    status=DrawPrimitive(image,clone_info,exception);
    clone_info=DestroyDrawInfo(clone_info);
    if (status == MagickFalse)
      break;
  }