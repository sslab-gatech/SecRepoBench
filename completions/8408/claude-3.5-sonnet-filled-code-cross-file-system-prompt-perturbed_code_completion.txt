MagickBooleanType status;
DrawInfo
  *draw_info;

draw_info=CloneDrawInfo((const ImageInfo *) NULL,(const DrawInfo *) NULL);
if (draw_info == (DrawInfo *) NULL)
  ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
status=MagickTrue;
(void) CloneString(&draw_info->primitive,draw_info->text);
draw_info->fill=draw_info->stroke;
draw_info->stroke.opacity=TransparentOpacity;
draw_info->affine=affine;
if (primitive_info == (PrimitiveInfo *) NULL)
  primitive_info=(PrimitiveInfo *) AcquireMagickMemory((size_t)
    number_points*sizeof(*primitive_info));
if (primitive_info == (PrimitiveInfo *) NULL)
  {
    draw_info=DestroyDrawInfo(draw_info);
    ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
  }
for (q=(const char *) draw_info->primitive; *q != '\0'; )
{
  /*
    Interpret graphic primitive.
  */
  GetNextToken(q,&q,MagickPathExtent,keyword);
  if (*keyword == '\0')
    break;
  if (*keyword == '#')
    {
      /*
        Comment.
      */
      while ((*q != '\n') && (*q != '\0'))
        q++;
      continue;
    }
  j=0;
  primitive_type=UndefinedPrimitive;
  switch (*keyword)
  {
    case 'a':
    case 'A':
    {
      if (LocaleCompare("affine",keyword) == 0)
        {
          GetAffineMatrix(&affine);
          break;
        }
      status=MagickFalse;
      break;
    }
    case 'b':
    case 'B':
    {
      if (LocaleCompare("bezier",keyword) == 0)
        {
          primitive_type=BezierPrimitive;
          break;
        }
      status=MagickFalse;
      break;
    }
    case 'c':
    case 'C':
    {
      if (LocaleCompare("circle",keyword) == 0)
        {
          primitive_type=CirclePrimitive;
          break;
        }
      if (LocaleCompare("color",keyword) == 0)
        {
          primitive_type=ColorPrimitive;
          break;
        }
      status=MagickFalse;
      break;
    }
    case 'e':
    case 'E':
    {
      if (LocaleCompare("ellipse",keyword) == 0)
        {
          primitive_type=EllipsePrimitive;
          break;
        }
      status=MagickFalse;
      break;
    }
    case 'i':
    case 'I':
    {
      if (LocaleCompare("image",keyword) == 0)
        {
          primitive_type=ImagePrimitive;
          break;
        }
      status=MagickFalse;
      break;
    }
    case 'l':
    case 'L':
    {
      if (LocaleCompare("line",keyword) == 0)
        {
          primitive_type=LinePrimitive;
          break;
        }
      status=MagickFalse;
      break;
    }
    case 'p':
    case 'P':
    {
      if (LocaleCompare("path",keyword) == 0)
        {
          primitive_type=PathPrimitive;
          break;
        }
      if (LocaleCompare("point",keyword) == 0)
        {
          primitive_type=PointPrimitive;
          break;
        }
      if (LocaleCompare("polygon",keyword) == 0)
        {
          primitive_type=PolygonPrimitive;
          break;
        }
      if (LocaleCompare("polyline",keyword) == 0)
        {
          primitive_type=PolylinePrimitive;
          break;
        }
      status=MagickFalse;
      break;
    }
    case 'r':
    case 'R':
    {
      if (LocaleCompare("rectangle",keyword) == 0)
        {
          primitive_type=RectanglePrimitive;
          break;
        }
      if (LocaleCompare("roundrectangle",keyword) == 0)
        {
          primitive_type=RoundRectanglePrimitive;
          break;
        }
      status=MagickFalse;
      break;
    }
    case 't':
    case 'T':
    {
      if (LocaleCompare("text",keyword) == 0)
        {
          primitive_type=TextPrimitive;
          break;
        }
      status=MagickFalse;
      break;
    }
    default:
    {
      status=MagickFalse;
      break;
    }
  }
  if (status == MagickFalse)
    break;
  /*
    Parse the primitive attributes.
  */
  i=0;
  j=0;
  for (x=0; *q != '\0'; x++)
  {
    /*
      Define points.
    */
    if (IsPoint(q) == MagickFalse)
      break;
    GetNextToken(q,&q,MagickPathExtent,token);
    point.x=StringToDouble(token,&next_token);
    GetNextToken(q,&q,MagickPathExtent,token);
    if (*token == ',')
      GetNextToken(q,&q,MagickPathExtent,token);
    point.y=StringToDouble(token,&next_token);
    GetNextToken(q,(const char **) NULL,MagickPathExtent,token);
    if (*token == ',')
      GetNextToken(q,&q,MagickPathExtent,token);
    primitive_info[i].primitive=primitive_type;
    primitive_info[i].point=point;
    primitive_info[i].coordinates=0;
    primitive_info[i].method=FloodfillMethod;
    i++;
    if (i < (ssize_t) (number_points-6*BezierQuantum-360))
      continue;
    number_points+=6*BezierQuantum+360;
    primitive_info=(PrimitiveInfo *) ResizeQuantumMemory(primitive_info,
      number_points,sizeof(*primitive_info));
    if (primitive_info == (PrimitiveInfo *) NULL)
      {
        (void) ThrowMagickException(exception,GetMagickModule(),
          ResourceLimitError,"MemoryAllocationFailed","`%s'",image->filename);
        break;
      }
  }
  primitive_info[j].primitive=primitive_type;
  primitive_info[j].coordinates=x;
  primitive_info[j].method=FloodfillMethod;
  primitive_info[j].text=(char *) NULL;
  if (active)
    {
      AffineToTransform(image,&affine);
      active=MagickFalse;
    }
  status=DrawPrimitive(image,draw_info,primitive_info,exception);
  if (status == MagickFalse)
    break;
  if (primitive_info->text != (char *) NULL)
    primitive_info->text=DestroyString(primitive_info->text);
}
draw_info=DestroyDrawInfo(draw_info);
primitive_info=(PrimitiveInfo *) RelinquishMagickMemory(primitive_info);