DrawInfo
    **graphic_context;

  MagickBooleanType
    status;

  PrimitiveInfo
    *primitive_info;

  StopInfo
    *stops;

  size_t
    extent;

  ssize_t
    n;

  /*
    Initialize draw attributes.
  */
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
  assert(draw_info != (const DrawInfo *) NULL);
  status=MagickTrue;
  n=0;
  graphic_context=(DrawInfo **) AcquireQuantumMemory(16,sizeof(*graphic_context));
  if (graphic_context == (DrawInfo **) NULL)
    ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
  (void) memset(graphic_context,0,16*sizeof(*graphic_context));
  graphic_context[n]=CloneDrawInfo((ImageInfo *) NULL,draw_info);
  primitive=(char *) NULL;
  primitive_info=(PrimitiveInfo *) NULL;
  stops=(StopInfo *) NULL;
  token=AcquireString(draw_info->primitive);
  extent=strlen(token)+MagickPathExtent;
  if (token[0] == '@')
    {
      /*
        Read primitive from file.
      */
      primitive=GetNodeByURL(draw_info->primitive,token+1);
      if (primitive == (char *) NULL)
        ThrowBinaryException(DrawError,"NonconformingDrawingPrimitiveDefinition",
          token);
    }
  else
    primitive=AcquireString(token);
  if (primitive == (char *) NULL)
    ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
  if (draw_info->debug != MagickFalse)
    (void) LogMagickEvent(DrawEvent,GetMagickModule(),"begin draw-image %s",
      primitive);
  /*
    Parse primitive.
  */
  primitive_info=(PrimitiveInfo *) AcquireQuantumMemory(MaxBezierCoordinates,
    sizeof(*primitive_info));
  if (primitive_info == (PrimitiveInfo *) NULL)
    ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
  (void) memset(primitive_info,0,MaxBezierCoordinates*
    sizeof(*primitive_info));
  extent=MaxBezierCoordinates;
  q=primitive;
  for (i=0; ; i++)
  {
    if (i >= (ssize_t) extent)
      {
        extent*=2;
        primitive_info=(PrimitiveInfo *) ResizeQuantumMemory(primitive_info,
          extent,sizeof(*primitive_info));
        if (primitive_info == (PrimitiveInfo *) NULL)
          ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
      }
    (void) GetNextToken(q,&q,MagickPathExtent,primitive_name);
    if (*primitive_name == '\0')
      break;
    if (*primitive_name == '#')
      {
        /*
          Comment.
        */
        while ((*q != '\n') && (*q != '\0'))
          q++;
        continue;
      }
    if (LocaleCompare("affine",primitive_name) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,geometry);
        (void) ParseAffineGeometry(geometry,&graphic_context[n]->affine,
          exception);
        continue;
      }
    if (LocaleCompare("clip-path",primitive_name) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,geometry);
        status&=DrawClipPath(image,graphic_context[n],geometry,exception);
        continue;
      }
    if (LocaleCompare("clip-rule",primitive_name) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,geometry);
        graphic_context[n]->fill_rule=(FillRule) ParseCommandOption(
          MagickFillRuleOptions,MagickFalse,geometry);
        continue;
      }
    if (LocaleCompare("color",primitive_name) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,geometry);
        (void) QueryColorCompliance(geometry,AllCompliance,&graphic_context[n]->
          fill,exception);
        continue;
      }
    if (LocaleCompare("compose",primitive_name) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,geometry);
        graphic_context[n]->compose=(CompositeOperator) ParseCommandOption(
          MagickCompositeOptions,MagickFalse,geometry);
        continue;
      }
    if (LocaleCompare("fill",primitive_name) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,geometry);
        (void) QueryColorCompliance(geometry,AllCompliance,&graphic_context[n]->
          fill,exception);
        continue;
      }
    if (LocaleCompare("fill-opacity",primitive_name) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,geometry);
        graphic_context[n]->fill_alpha=StringToDouble(geometry,&next_token);
        continue;
      }
    if (LocaleCompare("fill-rule",primitive_name) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,geometry);
        graphic_context[n]->fill_rule=(FillRule) ParseCommandOption(
          MagickFillRuleOptions,MagickFalse,geometry);
        continue;
      }
    if (LocaleCompare("font",primitive_name) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,geometry);
        (void) CloneString(&graphic_context[n]->font,geometry);
        continue;
      }
    if (LocaleCompare("font-family",primitive_name) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,geometry);
        (void) CloneString(&graphic_context[n]->family,geometry);
        continue;
      }
    if (LocaleCompare("font-size",primitive_name) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,geometry);
        graphic_context[n]->pointsize=StringToDouble(geometry,&next_token);
        continue;
      }
    if (LocaleCompare("font-stretch",primitive_name) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,geometry);
        graphic_context[n]->stretch=(StretchType) ParseCommandOption(
          MagickStretchOptions,MagickFalse,geometry);
        continue;
      }
    if (LocaleCompare("font-style",primitive_name) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,geometry);
        graphic_context[n]->style=(StyleType) ParseCommandOption(
          MagickStyleOptions,MagickFalse,geometry);
        continue;
      }
    if (LocaleCompare("font-weight",primitive_name) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,geometry);
        graphic_context[n]->weight=(size_t) StringToUnsignedLong(geometry);
        continue;
      }
    if (LocaleCompare("gradient",primitive_name) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,geometry);
        (void) CloneString(&graphic_context[n]->gradient.stops,geometry);
        continue;
      }
    if (LocaleCompare("gravity",primitive_name) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,geometry);
        graphic_context[n]->gravity=(GravityType) ParseCommandOption(
          MagickGravityOptions,MagickFalse,geometry);
        continue;
      }
    if (LocaleCompare("image",primitive_name) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,geometry);
        (void) CloneString(&graphic_context[n]->primitive,geometry);
        continue;
      }
    if (LocaleCompare("mask",primitive_name) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,geometry);
        status&=DrawCompositeMask(image,graphic_context[n],geometry,
          graphic_context[n]->primitive,exception);
        continue;
      }
    if (LocaleCompare("path",primitive_name) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,geometry);
        (void) CloneString(&graphic_context[n]->primitive,geometry);
        continue;
      }
    if (LocaleCompare("pattern",primitive_name) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,geometry);
        status&=DrawPatternPath(image,graphic_context[n],geometry,
          &graphic_context[n]->fill_pattern,exception);
        continue;
      }
    if (LocaleCompare("pop",primitive_name) == 0)
      {
        n--;
        if (n < 0)
          ThrowBinaryException(DrawError,"UnbalancedPushPop",primitive_name);
        graphic_context[n+1]=DestroyDrawInfo(graphic_context[n+1]);
        continue;
      }
    if (LocaleCompare("push",primitive_name) == 0)
      {
        n++;
        if (n >= 16)
          ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
        graphic_context[n]=CloneDrawInfo((ImageInfo *) NULL,
          graphic_context[n-1]);
        continue;
      }
    if (LocaleCompare("rotate",primitive_name) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,geometry);
        graphic_context[n]->affine.rx=DegreesToRadians(StringToDouble(
          geometry,&next_token));
        graphic_context[n]->affine.ry=(-graphic_context[n]->affine.rx);
        continue;
      }
    if (LocaleCompare("scale",primitive_name) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,geometry);
        (void) ParseGeometry(geometry,&graphic_context[n]->affine.sx,
          &graphic_context[n]->affine.sy);
        continue;
      }
    if (LocaleCompare("skewX",primitive_name) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,geometry);
        graphic_context[n]->affine.rx=DegreesToRadians(StringToDouble(
          geometry,&next_token));
        continue;
      }
    if (LocaleCompare("skewY",primitive_name) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,geometry);
        graphic_context[n]->affine.ry=DegreesToRadians(StringToDouble(
          geometry,&next_token));
        continue;
      }
    if (LocaleCompare("stroke",primitive_name) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,geometry);
        (void) QueryColorCompliance(geometry,AllCompliance,&graphic_context[n]->
          stroke,exception);
        continue;
      }
    if (LocaleCompare("stroke-dasharray",primitive_name) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,geometry);
        (void) CloneString(&graphic_context[n]->dash_pattern,geometry);
        continue;
      }
    if (LocaleCompare("stroke-dashoffset",primitive_name) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,geometry);
        graphic_context[n]->dash_offset=StringToDouble(geometry,&next_token);
        continue;
      }
    if (LocaleCompare("stroke-linecap",primitive_name) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,geometry);
        graphic_context[n]->linecap=(LineCap) ParseCommandOption(
          MagickLineCapOptions,MagickFalse,geometry);
        continue;
      }
    if (LocaleCompare("stroke-linejoin",primitive_name) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,geometry);
        graphic_context[n]->linejoin=(LineJoin) ParseCommandOption(
          MagickLineJoinOptions,MagickFalse,geometry);
        continue;
      }
    if (LocaleCompare("stroke-miterlimit",primitive_name) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,geometry);
        graphic_context[n]->miterlimit=StringToDouble(geometry,&next_token);
        continue;
      }
    if (LocaleCompare("stroke-opacity",primitive_name) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,geometry);
        graphic_context[n]->stroke_alpha=StringToDouble(geometry,&next_token);
        continue;
      }
    if (LocaleCompare("stroke-width",primitive_name) == 0)
      {
        GetNextToken(q,