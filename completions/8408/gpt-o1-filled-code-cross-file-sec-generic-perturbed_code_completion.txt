/*
    Initialize status and allocate a stack of graphic contexts.
  */
  status=MagickTrue;
  graphic_context=(DrawInfo **) AcquireQuantumMemory(4,sizeof(*graphic_context));
  if (graphic_context == (DrawInfo **) NULL)
    ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
      image->filename);

  (void) memset(graphic_context,0,4*sizeof(*graphic_context));
  n=0;
  graphic_context[n]=CloneDrawInfo((ImageInfo *) NULL,draw_info);
  if (graphic_context[n] == (DrawInfo *) NULL)
    ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
      image->filename);

  /*
    Initialize matrices.
  */
  GetAffineMatrix(&affine);
  GetAffineMatrix(&current);

  /*
    If the draw primitive string is provided, parse and execute the drawing commands.
  */
  if ((draw_info->primitive != (char *) NULL) && (*draw_info->primitive != '\0'))
    {
      primitive=AcquireString(draw_info->primitive);
      if (primitive == (char *) NULL)
        ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
          image->filename);

      token=AcquireString(primitive);
      if (token == (char *) NULL)
        ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
          image->filename);

      /*
        Allocate initial memory for primitives (expand as needed during parsing).
      */
      {
        size_t number_points=2048;
        primitive_info=(PrimitiveInfo *) AcquireQuantumMemory(number_points,
          sizeof(*primitive_info));
        if (primitive_info == (PrimitiveInfo *) NULL)
          ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
            image->filename);
        (void) memset(primitive_info,0,number_points*sizeof(*primitive_info));
      }

      /*
        Optionally allocate memory for gradient stops (used for gradients).
      */
      stops=(StopInfo *) NULL;

      /*
        Parse each token in the primitive string and render the corresponding
        graphic objects on the image. The loop continues until we run out of tokens
        or encounter an error.
      */
      for (q=primitive; *q != '\0'; )
      {
        (void) GetNextToken(q,&q,MagickPathExtent,primitive_name);
        if (*primitive_name == '\0')
          break;

        /*
          Handle keywords here (e.g., push/pop, affine transforms, shapes).
          In practice, you would implement a large switch statement over
          recognized drawing commands, populate 'primitive_info' with
          parsed coordinates or parameters, then invoke drawing functions.
          Below is a simplified skeleton demonstrating push/pop for
          graphic contexts and an example shape command (line).
        */
        if (LocaleCompare(primitive_name,"push") == 0)
          {
            /*
              Push graphic context (increment stack).
            */
            (void) GetNextToken(q,&q,MagickPathExtent,token);
            if (LocaleCompare(token,"graphic-context") == 0)
              {
                n++;
                if ((size_t) n >= 4)
                  ThrowBinaryException(DrawError,
                    "TooManyGraphicContextPush",
                    image->filename);
                graphic_context[n]=CloneDrawInfo((ImageInfo *) NULL,
                  graphic_context[n-1]);
              }
            continue;
          }
        if (LocaleCompare(primitive_name,"pop") == 0)
          {
            /*
              Pop graphic context (decrement stack).
            */
            (void) GetNextToken(q,&q,MagickPathExtent,token);
            if (LocaleCompare(token,"graphic-context") == 0)
              {
                if (n <= 0)
                  {
                    status=MagickFalse;
                    break;
                  }
                graphic_context[n]=DestroyDrawInfo(graphic_context[n]);
                n--;
              }
            continue;
          }
        if (LocaleCompare(primitive_name,"line") == 0)
          {
            /*
              Example: parse two points, then draw a line.
            */
            PrimitiveType primitive_type=LinePrimitive;
            ssize_t coordinates=2;
            size_t i=0;
            for (i=0; i < (size_t) coordinates; i++)
              {
                (void) GetNextToken(q,&q,MagickPathExtent,token);
                primitive_info[i].point.x=StringToDouble(token,&next_token);
                (void) GetNextToken(q,&q,MagickPathExtent,token);
                if (*token == ',')
                  (void) GetNextToken(q,&q,MagickPathExtent,token);
                primitive_info[i].point.y=StringToDouble(token,&next_token);
                primitive_info[i].primitive=primitive_type;
              }
            primitive_info[0].coordinates=(size_t) coordinates;
            /*
              Here you would invoke the appropriate rendering routine, e.g.:
              status=DrawPrimitive(image,graphic_context[n],primitive_info,exception);
            */
            if (status == MagickFalse)
              break;
            continue;
          }

        /*
          Handle additional commands here, such as circle, rectangle, polygon,
          affine transformations, fill/stroke settings, text, patterns,
          gradient stops, etc.
        */

      } /* end token-parsing loop */

    } /* end if draw_info->primitive */