DrawInfo
    **graphic_context;

  GradientInfo
    *gradient_info;

  MagickBooleanType
    status;

  PrimitiveInfo
    *primitive_info;

  SegmentInfo
    segment_info;

  StopInfo
    *stops;

  ssize_t
    n;

  /*
    Initialize.
  */
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(DrawEvent,GetMagickModule(),"...");
  assert(draw_info != (const DrawInfo *) NULL);
  assert(draw_info->signature == MagickCoreSignature);
  if (draw_info->primitive == (char *) NULL)
    return(MagickTrue);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  graphic_context=(DrawInfo **) AcquireQuantumMemory((size_t) MaxStackDepth+1,
    sizeof(*graphic_context));
  if (graphic_context == (DrawInfo **) NULL)
    ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
      draw_info->primitive);
  for (n=0; n <= MaxStackDepth; n++)
  {
    graphic_context[n]=CloneDrawInfo(image_info,(DrawInfo *) NULL);
    if (graphic_context[n] == (DrawInfo *) NULL)
      {
        for ( ; n >= 0; n--)
          graphic_context[n]=DestroyDrawInfo(graphic_context[n]);
        graphic_context=(DrawInfo **) RelinquishMagickMemory(graphic_context);
        ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
          draw_info->primitive);
      }
  }
  n=0;
  (void) CloneDrawInfo(image_info,graphic_context[n]);
  (void) CopyDrawInfo(graphic_context[n],draw_info);
  primitive_info=(PrimitiveInfo *) NULL;
  stops=(StopInfo *) NULL;
  GetAffineMatrix(&affine);
  GetAffineMatrix(&current);
  primitive=AcquireString(draw_info->primitive);
  token=(char *) NULL;
  status=MagickTrue;
  for (q=(const char *) primitive; *q != '\0'; )
  {
    /*
      Interpret graphic primitive.
    */
    GetNextToken(q,&q,MagickPathExtent,primitive_name);
    if (*primitive_name == '\0')
      break;
    if (*primitive_name == '#')
      {
        /*
          Comment.
        */
        for ( ; (*q != '\n') && (*q != '\0'); q++);
        continue;
      }
    if (LocaleCompare(primitive_name,"alpha") == 0)
      {
        double
          alpha;

        char
          *end;

        /*
          alpha x,y alpha_value
        */
        primitive_info=(PrimitiveInfo *) AcquireQuantumMemory(4,
          sizeof(*primitive_info));
        if (primitive_info == (PrimitiveInfo *) NULL)
          ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
            primitive_name);
        primitive_info[0].primitive=AlphaPrimitive;
        primitive_info[0].coordinates=1;
        GetNextToken(q,&q,MagickPathExtent,geometry);
        primitive_info[0].point.x=(double) StringToLong(geometry);
        GetNextToken(q,&q,MagickPathExtent,geometry);
        primitive_info[0].point.y=(double) StringToLong(geometry);
        GetNextToken(q,&q,MagickPathExtent,geometry);
        alpha=StringToDouble(geometry,&end);
        (void) SetImageAlpha(image,alpha <= (double) QuantumRange ?
          (Quantum) alpha : QuantumRange);
        primitive_info[1].primitive=UndefinedPrimitive;
        if (image->debug != MagickFalse)
          (void) LogMagickEvent(DrawEvent,GetMagickModule(),
            "  AlphaPrimitive: %.20g, %.20g  %.20g",primitive_info[0].point.x,
            primitive_info[0].point.y,alpha);
        (void) DrawAlphaPrimitive(image,graphic_context[n],primitive_info,
          exception);
        primitive_info=(PrimitiveInfo *) RelinquishMagickMemory(
          primitive_info);
        continue;
      }
    if (LocaleCompare(primitive_name,"affine") == 0)
      {
        /*
          affine sx,rx,ry,sy,tx,ty
        */
        GetNextToken(q,&q,MagickPathExtent,geometry);
        affine.sx=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,MagickPathExtent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,MagickPathExtent,geometry);
        affine.rx=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,MagickPathExtent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,MagickPathExtent,geometry);
        affine.ry=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,MagickPathExtent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,MagickPathExtent,geometry);
        affine.sy=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,MagickPathExtent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,MagickPathExtent,geometry);
        affine.tx=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,MagickPathExtent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,MagickPathExtent,geometry);
        affine.ty=StringToDouble(geometry,&next_token);
        current=affine;
        continue;
      }
    if (LocaleCompare(primitive_name,"arc") == 0)
      {
        /*
          arc x0,y0 x1,y1 0,180
        */
        primitive_info=(PrimitiveInfo *) AcquireQuantumMemory(4,
          sizeof(*primitive_info));
        if (primitive_info == (PrimitiveInfo *) NULL)
          ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
            primitive_name);
        primitive_info[0].primitive=ArcPrimitive;
        primitive_info[0].coordinates=3;
        GetNextToken(q,&q,MagickPathExtent,geometry);
        primitive_info[0].point.x=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,MagickPathExtent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,MagickPathExtent,geometry);
        primitive_info[0].point.y=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,MagickPathExtent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,MagickPathExtent,geometry);
        primitive_info[1].point.x=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,MagickPathExtent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,MagickPathExtent,geometry);
        primitive_info[1].point.y=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,MagickPathExtent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,MagickPathExtent,geometry);
        primitive_info[2].point.x=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,MagickPathExtent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,MagickPathExtent,geometry);
        primitive_info[2].point.y=StringToDouble(geometry,&next_token);
        primitive_info[3].primitive=UndefinedPrimitive;
        if (image->debug != MagickFalse)
          (void) LogMagickEvent(DrawEvent,GetMagickModule(),
            "  ArcPrimitive: %.20g, %.20g  %.20g, %.20g  %.20g, %.20g",
            primitive_info[0].point.x,primitive_info[0].point.y,
            primitive_info[1].point.x,primitive_info[1].point.y,
            primitive_info[2].point.x,primitive_info[2].point.y);
        (void) DrawArcPrimitive(image,graphic_context[n],primitive_info,
          exception);
        primitive_info=(PrimitiveInfo *) RelinquishMagickMemory(
          primitive_info);
        continue;
      }
    if (LocaleCompare(primitive_name,"bezier") == 0)
      {
        size_t
          number_points;

        /*
          bezier x0,y0  x1,y1 ... xn,yn
        */
        number_points=0;
        for ( ; IsPoint(q) != MagickFalse; )
        {
          number_points++;
          GetNextToken(q,&q,MagickPathExtent,geometry);
          GetNextToken(q,&q,MagickPathExtent,geometry);
          if (*geometry == ',')
            GetNextToken(q,&q,MagickPathExtent,geometry);
        }
        if (number_points < 3)
          {
            status=MagickFalse;
            break;
          }
        primitive_info=(PrimitiveInfo *) AcquireQuantumMemory(number_points+1,
          sizeof(*primitive_info));
        if (primitive_info == (PrimitiveInfo *) NULL)
          ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
            primitive_name);
        primitive_info[0].primitive=BezierPrimitive;
        primitive_info[0].coordinates=(ssize_t) number_points;
        for (n=0; n < (ssize_t) number_points; n++)
        {
          GetNextToken(q,&q,MagickPathExtent,geometry);
          primitive_info[n].point.x=StringToDouble(geometry,&next_token);
          GetNextToken(q,&q,MagickPathExtent,geometry);
          if (*geometry == ',')
            GetNextToken(q,&q,MagickPathExtent,geometry);
          primitive_info[n].point.y=StringToDouble(geometry,&next_token);
        }
        primitive_info[number_points].primitive=UndefinedPrimitive;
        if (image->debug != MagickFalse)
          {
            (void) LogMagickEvent(DrawEvent,GetMagickModule(),
              "  BezierPrimitive: %ld points",(long) number_points);
            for (n=0; n < (ssize_t) number_points; n++)
              (void) LogMagickEvent(DrawEvent,GetMagickModule(),
                "    %.20g, %.20g",primitive_info[n].point.x,
                primitive_info[n].point.y);
          }
        (void) DrawBezierPrimitive(image,graphic_context[n],primitive_info,
          exception);
        primitive_info=(PrimitiveInfo *) RelinquishMagickMemory(
          primitive_info);
        continue;
      }
    if (LocaleCompare(primitive_name,"circle") == 0)
      {
        /*
          circle x0,y0  x1,y1
        */
        primitive_info=(PrimitiveInfo *) AcquireQuantumMemory(3,
          sizeof(*primitive_info));
        if (primitive_info == (PrimitiveInfo *) NULL)
          ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
            primitive_name);
        primitive_info[0].primitive=CirclePrimitive;
        primitive_info[0].coordinates=2;
        GetNextToken(q,&q,MagickPathExtent,geometry);
        primitive_info[0].point.x=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,MagickPathExtent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,MagickPathExtent,geometry);
        primitive_info[0].point.y=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,MagickPathExtent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,MagickPathExtent,geometry);
        primitive_info[1].point.x=StringToDouble(geometry,&next_token);
        GetNextToken(q,&q,MagickPathExtent,geometry);
        if (*geometry == ',')
          GetNextToken(q,&q,MagickPathExtent,geometry);
        primitive_info[1].point.y=StringToDouble(geometry,&next_token);
        primitive_info[2].primitive=UndefinedPrimitive;
        if (image-