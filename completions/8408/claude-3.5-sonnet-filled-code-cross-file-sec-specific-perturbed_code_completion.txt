double
  angle;

DrawInfo
  *clone_info;

MagickBooleanType
  status;

PointInfo
  point;

PrimitiveInfo
  *primitive_info;

register ssize_t
  i;

size_t
  length,
  number_points;

status=MagickTrue;
number_points=2047;
primitive_info=(PrimitiveInfo *) AcquireQuantumMemory(number_points,
  sizeof(*primitive_info));
if (primitive_info == (PrimitiveInfo *) NULL)
  ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
if (clone_info == (DrawInfo *) NULL)
{
  primitive_info=(PrimitiveInfo *) RelinquishMagickMemory(primitive_info);
  ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
}
for (i=0; i < (ssize_t) number_points; i++)
{
  primitive_info[i].primitive=UndefinedPrimitive;
  primitive_info[i].point.x=0.0;
  primitive_info[i].point.y=0.0;
  primitive_info[i].coordinates=0;
}
angle=0.0;
for (q=(const char *) draw_info->primitive; *q != '\0'; )
{
  /*
    Interpret drawing primitive.
  */
  GetNextToken(q,&q,MagickPathExtent,keyword);
  if (*keyword == '\0')
    break;
  if (*keyword == '#')
    {
      /*
        Comment.
      */
      while ((*q != '\n') && (*q != '\0'))
        q++;
      continue;
    }
  primitive_type=UndefinedPrimitive;
  switch (*keyword)
  {
    case 'a':
    case 'A':
    {
      if (LocaleCompare("affine",keyword) == 0)
        {
          GetNextToken(q,&q,MagickPathExtent,token);
          affine.sx=StringToDouble(token,&next_token);
          GetNextToken(q,&q,MagickPathExtent,token);
          if (*token == ',')
            GetNextToken(q,&q,MagickPathExtent,token);
          affine.rx=StringToDouble(token,&next_token);
          GetNextToken(q,&q,MagickPathExtent,token);
          if (*token == ',')
            GetNextToken(q,&q,MagickPathExtent,token);
          affine.ry=StringToDouble(token,&next_token);
          GetNextToken(q,&q,MagickPathExtent,token);
          if (*token == ',')
            GetNextToken(q,&q,MagickPathExtent,token);
          affine.sy=StringToDouble(token,&next_token);
          GetNextToken(q,&q,MagickPathExtent,token);
          if (*token == ',')
            GetNextToken(q,&q,MagickPathExtent,token);
          affine.tx=StringToDouble(token,&next_token);
          GetNextToken(q,&q,MagickPathExtent,token);
          if (*token == ',')
            GetNextToken(q,&q,MagickPathExtent,token);
          affine.ty=StringToDouble(token,&next_token);
          break;
        }
      if (LocaleCompare("arc",keyword) == 0)
        {
          primitive_type=ArcPrimitive;
          break;
        }
      status=MagickFalse;
      break;
    }
    case 'b':
    case 'B':
    {
      if (LocaleCompare("bezier",keyword) == 0)
        {
          primitive_type=BezierPrimitive;
          break;
        }
      status=MagickFalse;
      break;
    }
    case 'c':
    case 'C':
    {
      if (LocaleCompare("circle",keyword) == 0)
        {
          primitive_type=CirclePrimitive;
          break;
        }
      if (LocaleCompare("color",keyword) == 0)
        {
          primitive_type=ColorPrimitive;
          break;
        }
      status=MagickFalse;
      break;
    }
    case 'e':
    case 'E':
    {
      if (LocaleCompare("ellipse",keyword) == 0)
        {
          primitive_type=EllipsePrimitive;
          break;
        }
      status=MagickFalse;
      break;
    }
    case 'i':
    case 'I':
    {
      if (LocaleCompare("image",keyword) == 0)
        {
          primitive_type=ImagePrimitive;
          break;
        }
      status=MagickFalse;
      break;
    }
    case 'l':
    case 'L':
    {
      if (LocaleCompare("line",keyword) == 0)
        {
          primitive_type=LinePrimitive;
          break;
        }
      status=MagickFalse;
      break;
    }
    case 'p':
    case 'P':
    {
      if (LocaleCompare("path",keyword) == 0)
        {
          primitive_type=PathPrimitive;
          break;
        }
      if (LocaleCompare("point",keyword) == 0)
        {
          primitive_type=PointPrimitive;
          break;
        }
      if (LocaleCompare("polygon",keyword) == 0)
        {
          primitive_type=PolygonPrimitive;
          break;
        }
      if (LocaleCompare("polyline",keyword) == 0)
        {
          primitive_type=PolylinePrimitive;
          break;
        }
      status=MagickFalse;
      break;
    }
    case 'r':
    case 'R':
    {
      if (LocaleCompare("rectangle",keyword) == 0)
        {
          primitive_type=RectanglePrimitive;
          break;
        }
      if (LocaleCompare("roundrectangle",keyword) == 0)
        {
          primitive_type=RoundRectanglePrimitive;
          break;
        }
      if (LocaleCompare("rotate",keyword) == 0)
        {
          GetNextToken(q,&q,MagickPathExtent,token);
          angle=StringToDouble(token,&next_token);
          break;
        }
      status=MagickFalse;
      break;
    }
    case 's':
    case 'S':
    {
      if (LocaleCompare("scale",keyword) == 0)
        {
          GetNextToken(q,&q,MagickPathExtent,token);
          affine.sx=StringToDouble(token,&next_token);
          GetNextToken(q,&q,MagickPathExtent,token);
          if (*token == ',')
            GetNextToken(q,&q,MagickPathExtent,token);
          affine.sy=StringToDouble(token,&next_token);
          break;
        }
      if (LocaleCompare("skewX",keyword) == 0)
        {
          GetNextToken(q,&q,MagickPathExtent,token);
          affine.ry=StringToDouble(token,&next_token);
          break;
        }
      if (LocaleCompare("skewY",keyword) == 0)
        {
          GetNextToken(q,&q,MagickPathExtent,token);
          affine.rx=StringToDouble(token,&next_token);
          break;
        }
      status=MagickFalse;
      break;
    }
    case 't':
    case 'T':
    {
      if (LocaleCompare("text",keyword) == 0)
        {
          primitive_type=TextPrimitive;
          break;
        }
      if (LocaleCompare("translate",keyword) == 0)
        {
          GetNextToken(q,&q,MagickPathExtent,token);
          affine.tx=StringToDouble(token,&next_token);
          GetNextToken(q,&q,MagickPathExtent,token);
          if (*token == ',')
            GetNextToken(q,&q,MagickPathExtent,token);
          affine.ty=StringToDouble(token,&next_token);
          break;
        }
      status=MagickFalse;
      break;
    }
    default:
    {
      status=MagickFalse;
      break;
    }
  }
  if (status == MagickFalse)
    break;
  if (primitive_type == UndefinedPrimitive)
    continue;
  /*
    Parse the primitive attributes.
  */
  i=0;
  j=0;
  for (x=0; *q != '\0'; x++)
  {
    /*
      Define points.
    */
    if (IsPoint(q) == MagickFalse)
      break;
    GetNextToken(q,&q,MagickPathExtent,token);
    point.x=StringToDouble(token,&next_token);
    GetNextToken(q,&q,MagickPathExtent,token);
    if (*token == ',')
      GetNextToken(q,&q,MagickPathExtent,token);
    point.y=StringToDouble(token,&next_token);
    GetNextToken(q,(const char **) NULL,MagickPathExtent,token);
    if (*token == ',')
      GetNextToken(q,&q,MagickPathExtent,token);
    primitive_info[i].primitive=primitive_type;
    primitive_info[i].point=point;
    primitive_info[i].coordinates=0;
    primitive_info[i].method=FloodfillMethod;
    i++;
    if (i < (ssize_t) (number_points-6*BezierQuantum-360))
      continue;
    number_points+=6*BezierQuantum+360;
    primitive_info=(PrimitiveInfo *) ResizeQuantumMemory(primitive_info,
      number_points,sizeof(*primitive_info));
    if (primitive_info == (PrimitiveInfo *) NULL)
    {
      clone_info=DestroyDrawInfo(clone_info);
      ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
    }
  }
  primitive_info[j].primitive=primitive_type;
  primitive_info[j].coordinates=x;
  primitive_info[j].method=FloodfillMethod;
  primitive_info[j].text=(char *) NULL;
  /*
    Circumvent draw_primitive to process this primitive.
  */
  status=DrawPrimitive(image,clone_info,primitive_info,exception);
  if (status == MagickFalse)
    break;
}
clone_info=DestroyDrawInfo(clone_info);
primitive_info=(PrimitiveInfo *) RelinquishMagickMemory(primitive_info);