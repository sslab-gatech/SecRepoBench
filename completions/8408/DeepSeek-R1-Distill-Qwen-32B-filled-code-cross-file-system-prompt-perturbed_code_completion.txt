if (image->debug != MagickFalse)
    (void) LogMagickEvent(DrawEvent,GetMagickModule(),"begin draw-image");
  /*
    Initialize variables.
  */
  (void) memset(&affine,0,sizeof(affine));
  (void) memset(&current,0,sizeof(current));
  (void) CopyMagickString(primitive_name,"",MagickPathExtent);
  (void) CopyMagickString(geometry,"",MagickPathExtent);
  (void) CopyMagickString(pattern,"",MagickPathExtent);
  token=AcquireString("");
  primitive=AcquireString("");
  stops=(StopInfo *) NULL;
  status=MagickTrue;
  n=-1;
  /*
    Parse drawing commands.
  */
  for (q=(const char *) draw_info->primitive; *q != '\0'; )
  {
    /*
      Interpret graphic primitive.
    */
    GetNextToken(q,&q,MagickPathExtent,keyword);
    if (*keyword == '\0')
      break;
    if (*keyword == '#')
      {
        if (n != -1)
          {
            AffineToTransform(image,&affine);
            n=-1;
          }
        (void) WriteBlobString(image,"<desc>");
        (void) WriteBlobString(image,keyword+1);
        for ( ; (*q != '\n') && (*q != '\0'); q++)
          switch (*q)
          {
            case '<': (void) WriteBlobString(image,"&lt;"); break;
            case '>': (void) WriteBlobString(image,"&gt;"); break;
            case '&': (void) WriteBlobString(image,"&amp;"); break;
            default: (void) WriteBlobByte(image,*q); break;
          }
        (void) WriteBlobString(image,"</desc>\n");
        continue;
      }
    primitive_type=UndefinedPrimitive;
    switch (*keyword)
    {
      case ';':
        break;
      case 'a':
      case 'A':
        if (LocaleCompare("affine",keyword) == 0)
          {
            GetNextToken(q,&q,MagickPathExtent,token);
            affine.sx=StringToDouble(token,&next_token);
            GetNextToken(q,&q,MagickPathExtent,token);
            if (*token == ',')
              GetNextToken(q,&q,MagickPathExtent,token);
            affine.rx=StringToDouble(token,&next_token);
            GetNextToken(q,&q,MagickPathExtent,token);
            if (*token == ',')
              GetNextToken(q,&q,MagickPathExtent,token);
            affine.ry=StringToDouble(token,&next_token);
            GetNextToken(q,&q,MagickPathExtent,token);
            if (*token == ',')
              GetNextToken(q,&q,MagickPathExtent,token);
            affine.sy=StringToDouble(token,&next_token);
            GetNextToken(q,&q,MagickPathExtent,token);
            if (*token == ',')
              GetNextToken(q,&q,MagickPathExtent,token);
            affine.tx=StringToDouble(token,&next_token);
            GetNextToken(q,&q,MagickPathExtent,token);
            if (*token == ',')
              GetNextToken(q,&q,MagickPathExtent,token);
            affine.ty=StringToDouble(token,&next_token);
            break;
          }
        if (LocaleCompare("alpha",keyword) == 0)
          {
            primitive_type=AlphaPrimitive;
            break;
          }
        if (LocaleCompare("angle",keyword) == 0)
          {
            GetNextToken(q,&q,MagickPathExtent,token);
            affine.rx=StringToDouble(token,&next_token);
            affine.ry=StringToDouble(token,&next_token);
            break;
          }
        if (LocaleCompare("arc",keyword) == 0)
          {
            primitive_type=ArcPrimitive;
            break;
          }
        status=MagickFalse;
        break;
      // ... (other cases for different primitives)
    }
    if (status == MagickFalse)
      break;
    if (primitive_type == UndefinedPrimitive)
      continue;
    /*
      Parse the primitive attributes.
    */
    i=0;
    j=0;
    for (x=0; *q != '\0'; x++)
    {
      if (IsPoint(q) == MagickFalse)
        break;
      GetNextToken(q,&q,MagickPathExtent,token);
      point.x=StringToDouble(token,&next_token);
      GetNextToken(q,&q,MagickPathExtent,token);
      if (*token == ',')
        GetNextToken(q,&q,MagickPathExtent,token);
      point.y=StringToDouble(token,&next_token);
      GetNextToken(q,(const char **) NULL,MagickPathExtent,token);
      if (*token == ',')
        GetNextToken(q,&q,MagickPathExtent,token);
      primitive_info[i].primitive=primitive_type;
      primitive_info[i].point=point;
      primitive_info[i].coordinates=0;
      primitive_info[i].method=FloodfillMethod;
      i++;
      if (i < (ssize_t) (number_points-6*BezierQuantum-360))
        continue;
      number_points+=6*BezierQuantum+360;
      primitive_info=(PrimitiveInfo *) ResizeQuantumMemory(primitive_info,
        number_points,sizeof(*primitive_info));
      if (primitive_info == (PrimitiveInfo *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),
            ResourceLimitError,"MemoryAllocationFailed","`%s'",image->filename);
          break;
        }
    }
    primitive_info[j].primitive=primitive_type;
    primitive_info[j].coordinates=x;
    primitive_info[j].method=FloodfillMethod;
    primitive_info[j].text=(char *) NULL;
    if (n != -1)
      {
        AffineToTransform(image,&affine);
        n=-1;
      }
    switch (primitive_type)
    {
      // ... (cases for different primitive types and drawing)
    }
    if (primitive_info == (PrimitiveInfo *) NULL)
      break;
    primitive_info[i].primitive=UndefinedPrimitive;
    if (status == MagickFalse)
      break;
  }