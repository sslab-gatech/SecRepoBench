/*  
  Initialize resources and interpret the drawing commands from draw_info->primitive.
  We manage a stack of graphic contexts, apply transformations (affine, rotate,
  scale), set fill/stroke colors and opacities, parse shapes (line, rectangle, etc.),
  and then render them onto the image via the appropriate drawing primitives.
*/
{
  MagickBooleanType
    status = MagickTrue;

  size_t
    number_points = 2048;

  /*
    Allocate memory for the primitive info list and stops (for gradients).
  */
  primitive_info = (PrimitiveInfo *) AcquireQuantumMemory(number_points,
    sizeof(*primitive_info));
  if (primitive_info == (PrimitiveInfo *) NULL)
    ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
      image->filename);
  (void) memset(primitive_info,0,number_points*sizeof(*primitive_info));

  stops = (StopInfo *) NULL;

  /*
    Allocate and initialize graphic context stack.
  */
  graphic_context=(DrawInfo **) AcquireQuantumMemory(MagickMaxStackDepth,
    sizeof(*graphic_context));
  if (graphic_context == (DrawInfo **) NULL)
    ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
      image->filename);
  n=0;
  graphic_context[n]=CloneDrawInfo((ImageInfo *) NULL,draw_info);

  /*
    Set up the initial affine transform.
  */
  GetAffineMatrix(&current);

  /*
    Parse and execute the MVG (Magick Vector Graphics) commands.
  */
  if ((draw_info->primitive != (char *) NULL) &&
      (*draw_info->primitive != '\0'))
    {
      primitive=AcquireString(draw_info->primitive);
      next_token=primitive;
      while (*next_token != '\0')
      {
        /*
          Read the next keyword/token.
        */
        GetNextToken(next_token,&next_token,MagickPathExtent,token);
        if (*token == '\0')
          break;

        /*
          Dispatch the command.
        */
        if (LocaleCompare(token,"push") == 0)
          {
            /*
              Push new graphic context onto the stack.
            */
            n++;
            if (n == MagickMaxStackDepth)
              {
                status=MagickFalse;
                break;
              }
            graphic_context[n]=CloneDrawInfo((ImageInfo *) NULL,
              graphic_context[n-1]);
          }
        else if (LocaleCompare(token,"pop") == 0)
          {
            /*
              Pop graphic context off the stack.
            */
            if (n == 0)
              {
                status=MagickFalse;
                break;
              }
            graphic_context[n]=DestroyDrawInfo(graphic_context[n]);
            n--;
          }
        else if ((LocaleCompare(token,"translate") == 0) ||
                 (LocaleCompare(token,"rotate") == 0) ||
                 (LocaleCompare(token,"scale") == 0) ||
                 (LocaleCompare(token,"skewX") == 0) ||
                 (LocaleCompare(token,"skewY") == 0))
          {
            /*
              Parse transformation parameters and update 'affine' matrix.
              Later, we apply this to the current context or shapes.
            */
            double
              tx=0.0,ty=0.0;

            /* Read numeric arguments; each transform has different usage. */
            GetNextToken(next_token,&next_token,MagickPathExtent,geometry);
            tx=StringToDouble(geometry,&q);
            if (*q == ',')
              {
                GetNextToken(next_token,&next_token,MagickPathExtent,geometry);
                ty=StringToDouble(geometry,&q);
              }
            if (LocaleCompare(token,"translate") == 0)
              {
                affine.tx += tx;
                affine.ty += ty;
              }
            else if (LocaleCompare(token,"rotate") == 0)
              {
                /*
                  Combine a rotation into the affine matrix (in degrees).
                */
                double radians = DegreesToRadians(tx);
                AffineMatrix rotate = { cos(radians), sin(radians),
                                        -sin(radians), cos(radians),
                                        0.0, 0.0 };
                affine = ConcatenateAffine(rotate,affine);
              }
            else if (LocaleCompare(token,"scale") == 0)
              {
                affine.sx *= tx;
                affine.sy *= (ty == 0.0 ? tx : ty);
              }
            else if (LocaleCompare(token,"skewX") == 0)
              {
                double radians = DegreesToRadians(tx);
                AffineMatrix skew = { 1.0, 0.0, tan(radians), 1.0, 0.0, 0.0 };
                affine = ConcatenateAffine(skew,affine);
              }
            else if (LocaleCompare(token,"skewY") == 0)
              {
                double radians = DegreesToRadians(tx);
                AffineMatrix skew = { 1.0, tan(radians), 0.0, 1.0, 0.0, 0.0 };
                affine = ConcatenateAffine(skew,affine);
              }
            /* At this point, we could apply to the image or keep it for shapes. */
          }
        else if ((LocaleCompare(token,"line") == 0) ||
                 (LocaleCompare(token,"rectangle") == 0) ||
                 (LocaleCompare(token,"circle") == 0) ||
                 (LocaleCompare(token,"ellipse") == 0) ||
                 (LocaleCompare(token,"polygon") == 0) ||
                 (LocaleCompare(token,"polyline") == 0) ||
                 (LocaleCompare(token,"path") == 0) ||
                 (LocaleCompare(token,"text") == 0))
          {
            /*
              Parse shape or text coordinates into primitive_info, then render.
            */
            (void) memset(primitive_info,0,number_points*sizeof(*primitive_info));
            status=TracePath(image,graphic_context[n],exception,token,
              &affine,primitive_info,&number_points,next_token,&next_token);
            if (status == MagickFalse)
              break;
            /*
              Render the primitive onto image using the current graphic context.
            */
            if (primitive_info[0].primitive != UndefinedPrimitive)
              (void) DrawPrimitive(image,graphic_context[n],primitive_info,
                exception);
          }
        else if ((LocaleCompare(token,"fill") == 0) ||
                 (LocaleCompare(token,"stroke") == 0) ||
                 (LocaleCompare(token,"stroke-width") == 0) ||
                 (LocaleCompare(token,"font") == 0) ||
                 (LocaleCompare(token,"text-antialias") == 0) ||
                 (LocaleCompare(token,"fill-opacity") == 0) ||
                 (LocaleCompare(token,"stroke-opacity") == 0))
          {
            /*
              Parse style attribute tokens and update current graphic context.
            */
            status=ParseGraphicContextAttribute(graphic_context[n],token,
              &next_token,exception);
            if (status == MagickFalse)
              break;
          }
        else
          {
            /*
              Unrecognized command.
            */
            status=MagickFalse;
            break;
          }
      }
      primitive=DestroyString(primitive);
    }

  if (status == MagickFalse)
    ThrowBinaryException(DrawError,"NonconformingDrawingPrimitiveDefinition",
      primitive_name);
}