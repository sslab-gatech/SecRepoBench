// <MASK>
token=AcquireString(draw_info->primitive);
extent=strlen(token)+MagickPathExtent;
status=MagickTrue;
n=-1;
graphic_context=(DrawInfo **) AcquireQuantumMemory((size_t) DrawMaxStackDepth,
  sizeof(*graphic_context));
if (graphic_context == (DrawInfo **) NULL)
  ThrowFatalException(ResourceLimitFatalError,"UnableToAcquireGraphicContext");
for (q=(const char *) token; *q != '\0'; )
{
  /*
    Interpret graphic primitive.
  */
  GetNextToken(q,&q,MagickPathExtent,primitive_name);
  if (*primitive_name == '\0')
    break;
  if (*primitive_name == '#')
    {
      /*
        Comment.
      */
      for ( ; (*q != '\n') && (*q != '\0'); q++)
        ;
      continue;
    }
  switch (*primitive_name)
  {
    case 'a':
    case 'A':
    {
      if (LocaleCompare("affine",primitive_name) == 0)
        {
          GetNextToken(q,&q,extent,geometry);
          affine.sx=StringToDouble(geometry,&next_token);
          GetNextToken(q,&q,extent,geometry);
          if (*geometry == ',')
            GetNextToken(q,&q,extent,geometry);
          affine.rx=StringToDouble(geometry,&next_token);
          GetNextToken(q,&q,extent,geometry);
          if (*geometry == ',')
            GetNextToken(q,&q,extent,geometry);
          affine.ry=StringToDouble(geometry,&next_token);
          GetNextToken(q,&q,extent,geometry);
          if (*geometry == ',')
            GetNextToken(q,&q,extent,geometry);
          affine.sy=StringToDouble(geometry,&next_token);
          GetNextToken(q,&q,extent,geometry);
          if (*geometry == ',')
            GetNextToken(q,&q,extent,geometry);
          affine.tx=StringToDouble(geometry,&next_token);
          GetNextToken(q,&q,extent,geometry);
          if (*geometry == ',')
            GetNextToken(q,&q,extent,geometry);
          affine.ty=StringToDouble(geometry,&next_token);
          break;
        }
      status=MagickFalse;
      break;
    }
    // ... other cases ...
    default:
    {
      status=MagickFalse;
      break;
    }
  }
  if (status == MagickFalse)
    break;
}
// </MASK>