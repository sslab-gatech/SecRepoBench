DrawInfo
    **graphic_context;

  double
    angle,
    coordinates,
    cursor,
    factor,
    primitive_extent;

  MagickBooleanType
    proceed,
    status;

  MVGInfo
    mvg_info;

  PointInfo
    point;

  PrimitiveInfo
    *primitive_info;

  PrimitiveType
    primitive_type;

  register ssize_t
    i,
    n;

  SegmentInfo
    bounds;

  size_t
    extent,
    number_stops;

  ssize_t
    j,
    offset;

  StopInfo
    *stops;

  /*
    Set the image clipping path.
  */
  if (draw_info->compliance != SVGCompliance)
    {
      status=SetImageMask(image,WritePixelMask,draw_info->clipping_mask,
        exception);
      if (status == MagickFalse)
        return(MagickFalse);
      status=SetImageMask(image,CompositePixelMask,draw_info->composite_mask,
        exception);
      if (status == MagickFalse)
        return(MagickFalse);
    }
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(DrawEvent,GetMagickModule(),"begin draw-image");
  primitive_info=(PrimitiveInfo *) NULL;
  extent=0;
  primitive=AcquireString(draw_info->primitive);
  if (primitive == (char *) NULL)
    return(MagickFalse);
  if (draw_info->primitive != (char *) NULL)
    if (strchr(primitive,'%') != (char *) NULL)
      (void) FormatLocaleString(primitive,MagickPathExtent,
        draw_info->primitive,image->columns,image->rows);
  /*
    Allocate primitive info memory.
  */
  graphic_context=(DrawInfo **) AcquireQuantumMemory(16,
    sizeof(*graphic_context));
  if (graphic_context == (DrawInfo **) NULL)
    {
      primitive=DestroyString(primitive);
      ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
        image->filename);
    }
  n=0;
  graphic_context[n]=CloneDrawInfo((ImageInfo *) NULL,draw_info);
  if (clone_info->clip_mask != (char *) NULL)
    if (strchr(clone_info->clip_mask,'%') != (char *) NULL)
      (void) FormatLocaleString(clone_info->clip_mask,MagickPathExtent,
        clone_info->clip_mask,image->columns,image->rows);
  if (clone_info->composite_mask != (char *) NULL)
    if (strchr(clone_info->composite_mask,'%') != (char *) NULL)
      (void) FormatLocaleString(clone_info->composite_mask,MagickPathExtent,
        clone_info->composite_mask,image->columns,image->rows);
  primitive_extent=strlen(primitive)+MagickPathExtent;
  token=(char *) AcquireQuantumMemory(primitive_extent,sizeof(*token));
  stops=(StopInfo *) NULL;
  number_stops=0;
  mvg_info.primitive_info=&primitive_info;
  mvg_info.extent=&extent;
  mvg_info.offset=0;
  mvg_info.exception=exception;
  status=MagickTrue;
  for (q=primitive; *q != '\0'; )
  {
    /*
      Interpret graphic primitive.
    */
    GetNextToken(q,&q,primitive_extent,token);
    if (*token == '\0')
      break;
    if (image->debug != MagickFalse)
      (void) LogMagickEvent(DrawEvent,GetMagickModule(),"  %s",token);
    (void) FormatLocaleString(primitive_name,MagickPathExtent,"%s",token);
    primitive_type=UndefinedPrimitive;
    current=graphic_context[n]->affine;
    cursor=0.0;
    switch (*token)
    {
      case '@':
      {
        /*
          Annotation.
        */
        GetNextToken(q,&q,primitive_extent,token);
        (void) CloneString(&graphic_context[n]->text,token);
        break;
      }
      case 'a':
      case 'A':
      {
        primitive_type=ArcPrimitive;
        break;
      }
      case 'b':
      case 'B':
      {
        primitive_type=BezierPrimitive;
        break;
      }
      case 'c':
      case 'C':
      {
        primitive_type=CirclePrimitive;
        break;
      }
      case 'd':
      case 'D':
      {
        primitive_type=PathPrimitive;
        break;
      }
      case 'e':
      case 'E':
      {
        primitive_type=EllipsePrimitive;
        break;
      }
      case 'f':
      case 'F':
      {
        primitive_type=ColorPrimitive;
        break;
      }
      case 'g':
      case 'G':
      {
        /*
          Gradient fill.
        */
        GetNextToken(q,&q,primitive_extent,token);
        (void) FormatLocaleString(pattern,MagickPathExtent,"%s",token);
        if (n < 1)
          break;
        (void) CopyMagickString(token,graphic_context[n]->clip_mask,
          primitive_extent);
        graphic_context[n]->clip_mask=DestroyString(graphic_context[n]->clip_mask);
        (void) CloneString(&graphic_context[n]->clip_mask,pattern);
        break;
      }
      case 'h':
      case 'H':
      {
        /*
          Horizontal line.
        */
        primitive_type=LinePrimitive;
        break;
      }
      case 'i':
      case 'I':
      {
        primitive_type=ImagePrimitive;
        break;
      }
      case 'l':
      case 'L':
      {
        primitive_type=LinePrimitive;
        break;
      }
      case 'm':
      case 'M':
      {
        primitive_type=PathPrimitive;
        break;
      }
      case 'o':
      case 'O':
      {
        primitive_type=CirclePrimitive;
        break;
      }
      case 'p':
      case 'P':
      {
        primitive_type=PointPrimitive;
        break;
      }
      case 'q':
      case 'Q':
      {
        primitive_type=BezierPrimitive;
        break;
      }
      case 'r':
      case 'R':
      {
        primitive_type=RectanglePrimitive;
        break;
      }
      case 's':
      case 'S':
      {
        primitive_type=BezierPrimitive;
        break;
      }
      case 't':
      case 'T':
      {
        primitive_type=TextPrimitive;
        break;
      }
      case 'v':
      case 'V':
      {
        /*
          Vertical line.
        */
        primitive_type=LinePrimitive;
        break;
      }
      case 'w':
      case 'W':
      {
        primitive_type=PathPrimitive;
        break;
      }
      case 'x':
      case 'X':
      {
        primitive_type=PathPrimitive;
        break;
      }
      case 'y':
      case 'Y':
      {
        primitive_type=PathPrimitive;
        break;
      }
      default:
        break;
    }
    if (primitive_type == UndefinedPrimitive)
      {
        status=MagickFalse;
        break;
      }
    /*
      Parse the primitive attributes.
    */
    i=0;
    j=0;
    coordinates=0;
    offset=mvg_info.offset;
    if (CheckPrimitiveExtent(&mvg_info,4096) != MagickFalse)
      primitive_info=(*mvg_info.primitive_info)+offset;
    primitive_info[0].coordinates=0;
    primitive_info[0].method=PointMethod;
    primitive_info[0].closed_subpath=MagickFalse;
    point.x=0.0;
    point.y=0.0;
    for (proceed=MagickTrue; proceed != MagickFalse; j++)
    {
      GetNextToken(q,&q,primitive_extent,token);
      if (image->debug != MagickFalse)
        (void) LogMagickEvent(DrawEvent,GetMagickModule(),"    %s",token);
      if (*token == '\0')
        break;
      if (primitive_info == (PrimitiveInfo *) NULL)
        continue;
      /*
        Check for primitive attributes.
      */
      switch (*token)
      {
        case ',':
          break;
        case '(':
          break;
        case ')':
        {
          proceed=MagickFalse;
          break;
        }
        case '%':
        {
          double
            value;

          GetNextToken(q,&q,primitive_extent,token);
          value=StringToDouble(token,&next_token);
          if (token == next_token)
            ThrowPointExpectedException(token,exception);
          primitive_info[i].point.x=(double) (value*image->columns/100.0);
          GetNextToken(q,&q,primitive_extent,token);
          value=StringToDouble(token,&next_token);
          if (token == next_token)
            ThrowPointExpectedException(token,exception);
          primitive_info[i].point.y=(double) (value*image->rows/100.0);
          break;
        }
        case '<':
        {
          /*
            URL.
          */
          if (primitive_type != ImagePrimitive)
            {
              status=MagickFalse;
              break;
            }
          GetNextToken(q,&q,primitive_extent,token);
          (void) CloneString(&primitive_info[i].text,token);
          break;
        }
        case '>':
        {
          if (primitive_type != ImagePrimitive)
            {
              status=MagickFalse;
              break;
            }
          break;
        }
        default:
        {
          /*
            Coordinate.
          */
          x=StringToDouble(token,&next_token);
          if (token == next_token)
            ThrowPointExpectedException(token,exception);
          primitive_info[i].point.x=(double) (x+current.tx);
          GetNextToken(q,&q,primitive_extent,token);
          y=StringToDouble(token,&next_token);
          if (token == next_token)
            ThrowPointExpectedException(token,exception);
          primitive_info[i].point.y=(double) (y+current.ty);
          break;
        }
      }
      if (status == MagickFalse)
        break;
      if (proceed == MagickFalse)
        break;
      /*
        Transform points.
      */
      point=primitive_info[i].point;
      primitive_info[i].point.x=(double) (current.sx*point.x+current.rx*
        point.y);
      primitive_info[i].point.y=(double) (current.sy*point.y+current.ry*
        point.x);
      if (i == 0)
        {
          bounds.x1=primitive_info[i].point.x;
          bounds.y1=primitive_info[i].point.y;
          bounds.x2=primitive_info[i].point.x;
          bounds.y2=primitive_info[i].point.y;
        }
      else
        {
          if (primitive_info[i].point.x < bounds.x1)
            bounds.x1=primitive_info[i].point.x;
          if (primitive_info[i].point.y < bounds.y1)
            bounds.y1=primitive_info[i].point.y;
          if (primitive_info[i].point.x > bounds.x2)
            bounds.x2=primitive_info[i].point.x;
          if (primitive_info[i].point.y > bounds.y2)
            bounds.y2=primitive_info[i].point.y;
        }
      primitive_info[i].primitive=primitive_type;
      primitive_info[i].coordinates=1;
      primitive_info[i].closed_subpath=MagickFalse;
      i++;
      coordinates++;
      if (CheckPrimitiveExtent(&mvg_info,1) != MagickFalse)
        primitive_info=(*mvg_info.primitive_info)+offset;
    }
    if (status == MagickFalse)
      break;
    if (primitive_info == (PrimitiveInfo *) NULL)
      continue;