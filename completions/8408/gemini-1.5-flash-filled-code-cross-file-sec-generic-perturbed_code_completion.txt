DrawInfo
    *graphic_context[MagickPathExtent];

  ExceptionInfo
    *clone_exception;

  Image
    *clone_image;

  MagickBooleanType
    status;

  PrimitiveInfo
    *primitive_info;

  StopInfo
    *stops;

  char
    *message;

  size_t
    n;

  /*
    Initialize graphic context.
  */
  status=MagickTrue;
  n=0;
  graphic_context[n]=CloneDrawInfo(draw_info);
  if (graphic_context[n] == (DrawInfo *) NULL)
    {
      status=MagickFalse;
      goto cleanup;
    }
  primitive_info=(PrimitiveInfo *) NULL;
  stops=(StopInfo *) NULL;
  token=AcquireString(draw_info->primitive);
  primitive=AcquireString(draw_info->primitive);
  (void) CopyMagickString(primitive_name,draw_info->primitive,MagickPathExtent);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(DrawEvent,GetMagickModule(),"begin draw-image");
  /*
    Process the drawing commands.
  */
  GetAffineMatrix(&affine);
  GetAffineMatrix(&current);
  for (q=token; *q != '\0'; )
  {
    /*
      Interpret the drawing primitive.
    */
    GetNextToken(q,&q,MagickPathExtent,geometry);
    if (*geometry == '\0')
      break;
    if (*geometry == '#')
      {
        /*
          Comment.
        */
        continue;
      }
    if (LocaleCompare("affine",geometry) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        affine.sx=StringToDouble(token,&next_token);
        GetNextToken(q,&q,MagickPathExtent,token);
        if (*token == ',')
          GetNextToken(q,&q,MagickPathExtent,token);
        affine.rx=StringToDouble(token,&next_token);
        GetNextToken(q,&q,MagickPathExtent,token);
        if (*token == ',')
          GetNextToken(q,&q,MagickPathExtent,token);
        affine.ry=StringToDouble(token,&next_token);
        GetNextToken(q,&q,MagickPathExtent,token);
        if (*token == ',')
          GetNextToken(q,&q,MagickPathExtent,token);
        affine.sy=StringToDouble(token,&next_token);
        GetNextToken(q,&q,MagickPathExtent,token);
        if (*token == ',')
          GetNextToken(q,&q,MagickPathExtent,token);
        affine.tx=StringToDouble(token,&next_token);
        GetNextToken(q,&q,MagickPathExtent,token);
        if (*token == ',')
          GetNextToken(q,&q,MagickPathExtent,token);
        affine.ty=StringToDouble(token,&next_token);
        continue;
      }
    if (LocaleCompare("clip-path",geometry) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,pattern);
        (void) FormatLocaleString(message,MagickPathExtent,
          "clip-path:url(#%s);",pattern);
        continue;
      }
    if (LocaleCompare("color",geometry) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        (void) QueryColorCompliance(token,&graphic_context[n]->fill,
          exception);
        continue;
      }
    if (LocaleCompare("fill",geometry) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        (void) QueryColorCompliance(token,&graphic_context[n]->fill,
          exception);
        continue;
      }
    if (LocaleCompare("font",geometry) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->font=AcquireString(token);
        continue;
      }
    if (LocaleCompare("font-family",geometry) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->font=AcquireString(token);
        continue;
      }
    if (LocaleCompare("font-size",geometry) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->pointsize=StringToDouble(token,&next_token);
        continue;
      }
    if (LocaleCompare("font-weight",geometry) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->weight=AcquireString(token);
        continue;
      }
    if (LocaleCompare("gradient",geometry) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        continue;
      }
    if (LocaleCompare("gravity",geometry) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->gravity=ParseGravity(token);
        continue;
      }
    if (LocaleCompare("image",geometry) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        continue;
      }
    if (LocaleCompare("pop",geometry) == 0)
      {
        n--;
        if (n < 0)
          {
            status=MagickFalse;
            break;
          }
        continue;
      }
    if (LocaleCompare("push",geometry) == 0)
      {
        n++;
        graphic_context[n]=CloneDrawInfo(graphic_context[n-1]);
        if (graphic_context[n] == (DrawInfo *) NULL)
          {
            status=MagickFalse;
            break;
          }
        continue;
      }
    if (LocaleCompare("rotate",geometry) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        current.rx=StringToDouble(token,&next_token);
        current.ry=0.0;
        continue;
      }
    if (LocaleCompare("scale",geometry) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        current.sx=StringToDouble(token,&next_token);
        GetNextToken(q,&q,MagickPathExtent,token);
        if (*token == ',')
          GetNextToken(q,&q,MagickPathExtent,token);
        current.sy=StringToDouble(token,&next_token);
        continue;
      }
    if (LocaleCompare("skewX",geometry) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        current.rx=StringToDouble(token,&next_token);
        continue;
      }
    if (LocaleCompare("skewY",geometry) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        current.ry=StringToDouble(token,&next_token);
        continue;
      }
    if (LocaleCompare("stroke",geometry) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        (void) QueryColorCompliance(token,&graphic_context[n]->stroke,
          exception);
        continue;
      }
    if (LocaleCompare("stroke-width",geometry) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        graphic_context[n]->stroke_width=StringToDouble(token,
          &next_token);
        continue;
      }
    if (LocaleCompare("text",geometry) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        continue;
      }
    if (LocaleCompare("translate",geometry) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,token);
        current.tx=StringToDouble(token,&next_token);
        GetNextToken(q,&q,MagickPathExtent,token);
        if (*token == ',')
          GetNextToken(q,&q,MagickPathExtent,token);
        current.ty=StringToDouble(token,&next_token);
        continue;
      }
    primitive_info=DrawPrimitive(graphic_context[n],geometry,q,&q,exception);
    if (primitive_info == (PrimitiveInfo *) NULL)
      {
        status=MagickFalse;
        break;
      }
    clone_exception=AcquireExceptionInfo();
    clone_image=CloneImage(image,0,0,MagickTrue,clone_exception);
    if (clone_image != (Image *) NULL)
      {
        (void) DrawPrimitive(clone_image,graphic_context[n],primitive_info,
          clone_exception);
        (void) CompositeImage(image,OverCompositeOp,clone_image,0,0);
        clone_image=DestroyImage(clone_image);
      }
    clone_exception=DestroyExceptionInfo(clone_exception);
    primitive_info=(PrimitiveInfo *) RelinquishMagickMemory(primitive_info);
  }
cleanup: