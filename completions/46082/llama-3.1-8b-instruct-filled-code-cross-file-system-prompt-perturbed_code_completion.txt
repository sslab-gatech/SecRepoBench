else if (object.type == MSGPACK_OBJECT_MAP) {
    result->type = FLB_RA_MAP;
    result->val.map = NULL;
    result->val.map_size = 0;
    result->val.map_keys = NULL;
    result->val.map_values = NULL;

    for (i = 0; i < object.via.map.size; i++) {
        msgpack_object key = object.via.map.ptr[i].key;
        msgpack_object val = object.via.map.ptr[i].val;

        if (key.type!= MSGPACK_OBJECT_STR) {
            continue;
        }

        // Create a dynamic string copy of the key
        flb_sds_t key_sds = flb_sds_new(key.via.str.ptr, key.via.str.size);
        if (!key_sds) {
            return -1;
        }

        // Create a dynamic string copy of the value
        msgpack_object_to_ra_value(val, &result->val.map_values[i]);
        if (result->val.map_values[i].type!= FLB_RA_STRING) {
            flb_sds_free(&key_sds);
            return -1;
        }
        result->val.map_values[i].val.string = flb_sds_new(val.via.str.ptr, val.via.str.size);
        if (!result->val.map_values[i].val.string) {
            flb_sds_free(&key_sds);
            return -1;
        }

        // Add the key-value pair to the map
        result->val.map_size++;
        result->val.map_keys = flb_realloc(result->val.map_keys, result->val.map_size * sizeof(flb_sds_t));
        result->val.map_values = flb_realloc(result->val.map_values, result->val.map_size * sizeof(struct flb_ra_value));
        result->val.map_keys[result->val.map_size - 1] = key_sds;
        result->val.map_values[result->val.map_size - 1] = result->val.map_values[i];
    }

    return 0;
}
else if (object.type == MSGPACK_OBJECT_NIL) {
    result->type = FLB_RA_NULL;
    return 0;
}
else {
    return -1;
}