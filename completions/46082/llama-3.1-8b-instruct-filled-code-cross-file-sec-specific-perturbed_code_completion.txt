else if (object.type == MSGPACK_OBJECT_MAP) {
    result->type = FLB_RA_MAP;
    result->val.map = NULL;
    result->val.map_size = 0;
    result->val.map_keys = NULL;

    for (i = 0; i < object.via.map.size; i++) {
        msgpack_object key = object.via.map.ptr[i].key;
        msgpack_object val = object.via.map.ptr[i].val;

        if (key.type!= MSGPACK_OBJECT_STR) {
            continue;
        }

        // Handle cases where the msgpack object is a string by setting the result type to FLB_RA_STRING
        // and creating a dynamic string copy of the msgpack string data.
        if (result->val.map == NULL) {
            result->val.map = flb_sds_new();
            result->val.map_size = 0;
            result->val.map_keys = NULL;
        }

        // Add key to map
        flb_sds_push(result->val.map, key.via.str.ptr, key.via.str.size);
        result->val.map_size++;

        // Add value to map
        struct flb_ra_value sub_result;
        msgpack_object_to_ra_value(val, &sub_result);
        if (sub_result.type == FLB_RA_MAP) {
            // Handle nested map
            struct flb_ra_map *nested_map = flb_sds_new();
            for (j = 0; j < sub_result.val.map_size; j++) {
                flb_sds_push(nested_map, sub_result.val.map_keys[j], sub_result.val.map_size);
            }
            flb_sds_push(result->val.map, nested_map, sizeof(struct flb_ra_map));
        } else {
            flb_sds_push(result->val.map, &sub_result, sizeof(struct flb_ra_value));
        }
    }

    return 0;
}
else if (object.type == MSGPACK_OBJECT_NIL) {
    result->type = FLB_RA_NULL;
    return 0;
}