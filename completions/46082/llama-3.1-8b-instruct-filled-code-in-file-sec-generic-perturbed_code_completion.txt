else if (object.type == MSGPACK_OBJECT_MAP) {
    result->type = FLB_RA_MAP;
    result->val.map = flb_calloc(1, sizeof(struct flb_ra_map));
    if (!result->val.map) {
        flb_errno();
        return -1;
    }
    result->val.map->size = map_size = object.via.map.size;
    result->val.map->keys = flb_calloc(map_size, sizeof(struct flb_ra_map_key));
    if (!result->val.map->keys) {
        flb_errno();
        flb_free(result->val.map);
        return -1;
    }
    for (i = 0; i < map_size; i++) {
        result->val.map->keys[i].key = object.via.map.ptr[i].key;
        result->val.map->keys[i].val = object.via.map.ptr[i].val;
    }
    return 0;
}
else if (object.type == MSGPACK_OBJECT_ARRAY) {
    result->type = FLB_RA_ARRAY;
    result->val.array = flb_calloc(1, sizeof(struct flb_ra_array));
    if (!result->val.array) {
        flb_errno();
        return -1;
    }
    result->val.array->size = array_size = object.via.array.size;
    result->val.array->values = flb_calloc(array_size, sizeof(msgpack_object));
    if (!result->val.array->values) {
        flb_errno();
        flb_free(result->val.array);
        return -1;
    }
    for (i = 0; i < array_size; i++) {
        result->val.array->values[i] = object.via.array.ptr[i];
    }
    return 0;
}
else if (object.type == MSGPACK_OBJECT NIL) {
    result->type = FLB_RA_NULL;
    return 0;
}
else {
    flb_error("[ra key] cannot process key value");
    return -1;
}