Below is the content of a C/C++ file where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
static void GetEXIFProperty(const Image *image,const char *property,
  ExceptionInfo *exception)
{
#define MaxDirectoryStack  16
#define EXIF_DELIMITER  "\n"
#define EXIF_NUM_FORMATS  12
#define EXIF_FMT_BYTE  1
#define EXIF_FMT_STRING  2
#define EXIF_FMT_USHORT  3
#define EXIF_FMT_ULONG  4
#define EXIF_FMT_URATIONAL  5
#define EXIF_FMT_SBYTE  6
#define EXIF_FMT_UNDEFINED  7
#define EXIF_FMT_SSHORT  8
#define EXIF_FMT_SLONG  9
#define EXIF_FMT_SRATIONAL  10
#define EXIF_FMT_SINGLE  11
#define EXIF_FMT_DOUBLE  12
#define GPS_LATITUDE  0x10002
#define GPS_LONGITUDE  0x10004
#define GPS_TIMESTAMP  0x10007
#define TAG_EXIF_OFFSET  0x8769
#define TAG_GPS_OFFSET  0x8825
#define TAG_INTEROP_OFFSET  0xa005

#define EXIFGPSFractions(format,arg1,arg2,arg3,arg4,arg5,arg6) \
{ \
   size_t \
     extent = 0; \
 \
   ssize_t \
     component = 0; \
 \
   for ( ; component < components; component++) \
   { \
     if (component != 0) \
       extent+=(size_t) FormatLocaleString(buffer+extent,MagickPathExtent- \
         extent,", "); \
     extent+=(size_t) FormatLocaleString(buffer+extent,MagickPathExtent- \
       extent,format,(arg1),(arg2),(arg3),(arg4),(arg5),(arg6)); \
     if (extent >= (MagickPathExtent-1)) \
       extent=MagickPathExtent-1; \
   } \
   buffer[extent]='\0'; \
   value=AcquireString(buffer); \
}

#define EXIFMultipleValues(format,arg) \
{ \
   size_t \
     extent = 0; \
 \
   ssize_t \
     component = 0; \
 \
   for ( ; component < components; component++) \
   { \
     if (component != 0) \
       extent+=(size_t) FormatLocaleString(buffer+extent,MagickPathExtent- \
         extent,", "); \
     extent+=(size_t) FormatLocaleString(buffer+extent,MagickPathExtent- \
       extent,format,arg); \
     if (extent >= (MagickPathExtent-1)) \
       extent=MagickPathExtent-1; \
   } \
   buffer[extent]='\0'; \
   value=AcquireString(buffer); \
}

#define EXIFMultipleFractions(format,arg1,arg2) \
{ \
   size_t \
     extent = 0; \
 \
   ssize_t \
     component = 0; \
 \
   for ( ; component < components; component++) \
   { \
     if (component != 0) \
       extent+=(size_t) FormatLocaleString(buffer+extent,MagickPathExtent-\
         extent,", "); \
     extent+=(size_t) FormatLocaleString(buffer+extent,MagickPathExtent- \
       extent,format,(arg1),(arg2)); \
     if (extent >= (MagickPathExtent-1)) \
       extent=MagickPathExtent-1; \
   } \
   buffer[extent]='\0'; \
   value=AcquireString(buffer); \
}

  typedef struct _DirectoryInfo
  {
    const unsigned char
      *directory;

    size_t
      entry;

    ssize_t
      offset;
  } DirectoryInfo;

  typedef struct _TagInfo
  {
    size_t
      tag;

    const char
      description[36];
  } TagInfo;

  static const TagInfo
    EXIFTag[] =
    {
      {  0x001, "exif:InteroperabilityIndex" },
      {  0x002, "exif:InteroperabilityVersion" },
      {  0x100, "exif:ImageWidth" },
      {  0x101, "exif:ImageLength" },
      {  0x102, "exif:BitsPerSample" },
      {  0x103, "exif:Compression" },
      {  0x106, "exif:PhotometricInterpretation" },
      {  0x10a, "exif:FillOrder" },
      {  0x10d, "exif:DocumentName" },
      {  0x10e, "exif:ImageDescription" },
      {  0x10f, "exif:Make" },
      {  0x110, "exif:Model" },
      {  0x111, "exif:StripOffsets" },
      {  0x112, "exif:Orientation" },
      {  0x115, "exif:SamplesPerPixel" },
      {  0x116, "exif:RowsPerStrip" },
      {  0x117, "exif:StripByteCounts" },
      {  0x11a, "exif:XResolution" },
      {  0x11b, "exif:YResolution" },
      {  0x11c, "exif:PlanarConfiguration" },
      {  0x11d, "exif:PageName" },
      {  0x11e, "exif:XPosition" },
      {  0x11f, "exif:YPosition" },
      {  0x118, "exif:MinSampleValue" },
      {  0x119, "exif:MaxSampleValue" },
      {  0x120, "exif:FreeOffsets" },
      {  0x121, "exif:FreeByteCounts" },
      {  0x122, "exif:GrayResponseUnit" },
      {  0x123, "exif:GrayResponseCurve" },
      {  0x124, "exif:T4Options" },
      {  0x125, "exif:T6Options" },
      {  0x128, "exif:ResolutionUnit" },
      {  0x12d, "exif:TransferFunction" },
      {  0x131, "exif:Software" },
      {  0x132, "exif:DateTime" },
      {  0x13b, "exif:Artist" },
      {  0x13e, "exif:WhitePoint" },
      {  0x13f, "exif:PrimaryChromaticities" },
      {  0x140, "exif:ColorMap" },
      {  0x141, "exif:HalfToneHints" },
      {  0x142, "exif:TileWidth" },
      {  0x143, "exif:TileLength" },
      {  0x144, "exif:TileOffsets" },
      {  0x145, "exif:TileByteCounts" },
      {  0x14a, "exif:SubIFD" },
      {  0x14c, "exif:InkSet" },
      {  0x14d, "exif:InkNames" },
      {  0x14e, "exif:NumberOfInks" },
      {  0x150, "exif:DotRange" },
      {  0x151, "exif:TargetPrinter" },
      {  0x152, "exif:ExtraSample" },
      {  0x153, "exif:SampleFormat" },
      {  0x154, "exif:SMinSampleValue" },
      {  0x155, "exif:SMaxSampleValue" },
      {  0x156, "exif:TransferRange" },
      {  0x157, "exif:ClipPath" },
      {  0x158, "exif:XClipPathUnits" },
      {  0x159, "exif:YClipPathUnits" },
      {  0x15a, "exif:Indexed" },
      {  0x15b, "exif:JPEGTables" },
      {  0x15f, "exif:OPIProxy" },
      {  0x200, "exif:JPEGProc" },
      {  0x201, "exif:JPEGInterchangeFormat" },
      {  0x202, "exif:JPEGInterchangeFormatLength" },
      {  0x203, "exif:JPEGRestartInterval" },
      {  0x205, "exif:JPEGLosslessPredictors" },
      {  0x206, "exif:JPEGPointTransforms" },
      {  0x207, "exif:JPEGQTables" },
      {  0x208, "exif:JPEGDCTables" },
      {  0x209, "exif:JPEGACTables" },
      {  0x211, "exif:YCbCrCoefficients" },
      {  0x212, "exif:YCbCrSubSampling" },
      {  0x213, "exif:YCbCrPositioning" },
      {  0x214, "exif:ReferenceBlackWhite" },
      {  0x2bc, "exif:ExtensibleMetadataPlatform" },
      {  0x301, "exif:Gamma" },
      {  0x302, "exif:ICCProfileDescriptor" },
      {  0x303, "exif:SRGBRenderingIntent" },
      {  0x320, "exif:ImageTitle" },
      {  0x5001, "exif:ResolutionXUnit" },
      {  0x5002, "exif:ResolutionYUnit" },
      {  0x5003, "exif:ResolutionXLengthUnit" },
      {  0x5004, "exif:ResolutionYLengthUnit" },
      {  0x5005, "exif:PrintFlags" },
      {  0x5006, "exif:PrintFlagsVersion" },
      {  0x5007, "exif:PrintFlagsCrop" },
      {  0x5008, "exif:PrintFlagsBleedWidth" },
      {  0x5009, "exif:PrintFlagsBleedWidthScale" },
      {  0x500A, "exif:HalftoneLPI" },
      {  0x500B, "exif:HalftoneLPIUnit" },
      {  0x500C, "exif:HalftoneDegree" },
      {  0x500D, "exif:HalftoneShape" },
      {  0x500E, "exif:HalftoneMisc" },
      {  0x500F, "exif:HalftoneScreen" },
      {  0x5010, "exif:JPEGQuality" },
      {  0x5011, "exif:GridSize" },
      {  0x5012, "exif:ThumbnailFormat" },
      {  0x5013, "exif:ThumbnailWidth" },
      {  0x5014, "exif:ThumbnailHeight" },
      {  0x5015, "exif:ThumbnailColorDepth" },
      {  0x5016, "exif:ThumbnailPlanes" },
      {  0x5017, "exif:ThumbnailRawBytes" },
      {  0x5018, "exif:ThumbnailSize" },
      {  0x5019, "exif:ThumbnailCompressedSize" },
      {  0x501a, "exif:ColorTransferFunction" },
      {  0x501b, "exif:ThumbnailData" },
      {  0x5020, "exif:ThumbnailImageWidth" },
      {  0x5021, "exif:ThumbnailImageHeight" },
      {  0x5022, "exif:ThumbnailBitsPerSample" },
      {  0x5023, "exif:ThumbnailCompression" },
      {  0x5024, "exif:ThumbnailPhotometricInterp" },
      {  0x5025, "exif:ThumbnailImageDescription" },
      {  0x5026, "exif:ThumbnailEquipMake" },
      {  0x5027, "exif:ThumbnailEquipModel" },
      {  0x5028, "exif:ThumbnailStripOffsets" },
      {  0x5029, "exif:ThumbnailOrientation" },
      {  0x502a, "exif:ThumbnailSamplesPerPixel" },
      {  0x502b, "exif:ThumbnailRowsPerStrip" },
      {  0x502c, "exif:ThumbnailStripBytesCount" },
      {  0x502d, "exif:ThumbnailResolutionX" },
      {  0x502e, "exif:ThumbnailResolutionY" },
      {  0x502f, "exif:ThumbnailPlanarConfig" },
      {  0x5030, "exif:ThumbnailResolutionUnit" },
      {  0x5031, "exif:ThumbnailTransferFunction" },
      {  0x5032, "exif:ThumbnailSoftwareUsed" },
      {  0x5033, "exif:ThumbnailDateTime" },
      {  0x5034, "exif:ThumbnailArtist" },
      {  0x5035, "exif:ThumbnailWhitePoint" },
      {  0x5036, "exif:ThumbnailPrimaryChromaticities" },
      {  0x5037, "exif:ThumbnailYCbCrCoefficients" },
      {  0x5038, "exif:ThumbnailYCbCrSubsampling" },
      {  0x5039, "exif:ThumbnailYCbCrPositioning" },
      {  0x503A, "exif:ThumbnailRefBlackWhite" },
      {  0x503B, "exif:ThumbnailCopyRight" },
      {  0x5090, "exif:LuminanceTable" },
      {  0x5091, "exif:ChrominanceTable" },
      {  0x5100, "exif:FrameDelay" },
      {  0x5101, "exif:LoopCount" },
      {  0x5110, "exif:PixelUnit" },
      {  0x5111, "exif:PixelPerUnitX" },
      {  0x5112, "exif:PixelPerUnitY" },
      {  0x5113, "exif:PaletteHistogram" },
      {  0x1000, "exif:RelatedImageFileFormat" },
      {  0x1001, "exif:RelatedImageLength" },
      {  0x1002, "exif:RelatedImageWidth" },
      {  0x800d, "exif:ImageID" },
      {  0x80e3, "exif:Matteing" },
      {  0x80e4, "exif:DataType" },
      {  0x80e5, "exif:ImageDepth" },
      {  0x80e6, "exif:TileDepth" },
      {  0x828d, "exif:CFARepeatPatternDim" },
      {  0x828e, "exif:CFAPattern2" },
      {  0x828f, "exif:BatteryLevel" },
      {  0x8298, "exif:Copyright" },
      {  0x829a, "exif:ExposureTime" },
      {  0x829d, "exif:FNumber" },
      {  0x83bb, "exif:IPTC/NAA" },
      {  0x84e3, "exif:IT8RasterPadding" },
      {  0x84e5, "exif:IT8ColorTable" },
      {  0x8649, "exif:ImageResourceInformation" },
      {  0x8769, "exif:ExifOffset" },  /* specs as "Exif IFD Pointer"? */
      {  0x8773, "exif:InterColorProfile" },
      {  0x8822, "exif:ExposureProgram" },
      {  0x8824, "exif:SpectralSensitivity" },
      {  0x8825, "exif:GPSInfo" }, /* specs as "GPSInfo IFD Pointer"? */
      {  0x8827, "exif:PhotographicSensitivity" },
      {  0x8828, "exif:OECF" },
      {  0x8829, "exif:Interlace" },
      {  0x882a, "exif:TimeZoneOffset" },
      {  0x882b, "exif:SelfTimerMode" },
      {  0x8830, "exif:SensitivityType" },
      {  0x8831, "exif:StandardOutputSensitivity" },
      {  0x8832, "exif:RecommendedExposureIndex" },
      {  0x8833, "exif:ISOSpeed" },
      {  0x8834, "exif:ISOSpeedLatitudeyyy" },
      {  0x8835, "exif:ISOSpeedLatitudezzz" },
      {  0x9000, "exif:ExifVersion" },
      {  0x9003, "exif:DateTimeOriginal" },
      {  0x9004, "exif:DateTimeDigitized" },
      {  0x9010, "exif:OffsetTime" },
      {  0x9011, "exif:OffsetTimeOriginal" },
      {  0x9012, "exif:OffsetTimeDigitized" },
      {  0x9101, "exif:ComponentsConfiguration" },
      {  0x9102, "exif:CompressedBitsPerPixel" },
      {  0x9201, "exif:ShutterSpeedValue" },
      {  0x9202, "exif:ApertureValue" },
      {  0x9203, "exif:BrightnessValue" },
      {  0x9204, "exif:ExposureBiasValue" },
      {  0x9205, "exif:MaxApertureValue" },
      {  0x9206, "exif:SubjectDistance" },
      {  0x9207, "exif:MeteringMode" },
      {  0x9208, "exif:LightSource" },
      {  0x9209, "exif:Flash" },
      {  0x920a, "exif:FocalLength" },
      {  0x920b, "exif:FlashEnergy" },
      {  0x920c, "exif:SpatialFrequencyResponse" },
      {  0x920d, "exif:Noise" },
      {  0x9214, "exif:SubjectArea" },
      {  0x9290, "exif:SubSecTime" },
      {  0x9291, "exif:SubSecTimeOriginal" },
      {  0x9292, "exif:SubSecTimeDigitized" },
      {  0x9211, "exif:ImageNumber" },
      {  0x9212, "exif:SecurityClassification" },
      {  0x9213, "exif:ImageHistory" },
      {  0x9214, "exif:SubjectArea" },
      {  0x9215, "exif:ExposureIndex" },
      {  0x9216, "exif:TIFF-EPStandardID" },
      {  0x927c, "exif:MakerNote" },
      {  0x9286, "exif:UserComment" },
      {  0x9290, "exif:SubSecTime" },
      {  0x9291, "exif:SubSecTimeOriginal" },
      {  0x9292, "exif:SubSecTimeDigitized" },
      {  0x9400, "exif:Temperature" },
      {  0x9401, "exif:Humidity" },
      {  0x9402, "exif:Pressure" },
      {  0x9403, "exif:WaterDepth" },
      {  0x9404, "exif:Acceleration" },
      {  0x9405, "exif:CameraElevationAngle" },
      {  0x9C9b, "exif:WinXP-Title" },
      {  0x9C9c, "exif:WinXP-Comments" },
      {  0x9C9d, "exif:WinXP-Author" },
      {  0x9C9e, "exif:WinXP-Keywords" },
      {  0x9C9f, "exif:WinXP-Subject" },
      {  0xa000, "exif:FlashPixVersion" },
      {  0xa001, "exif:ColorSpace" },
      {  0xa002, "exif:PixelXDimension" },
      {  0xa003, "exif:PixelYDimension" },
      {  0xa004, "exif:RelatedSoundFile" },
      {  0xa005, "exif:InteroperabilityOffset" },
      {  0xa20b, "exif:FlashEnergy" },
      {  0xa20c, "exif:SpatialFrequencyResponse" },
      {  0xa20d, "exif:Noise" },
      {  0xa20e, "exif:FocalPlaneXResolution" },
      {  0xa20f, "exif:FocalPlaneYResolution" },
      {  0xa210, "exif:FocalPlaneResolutionUnit" },
      {  0xa214, "exif:SubjectLocation" },
      {  0xa215, "exif:ExposureIndex" },
      {  0xa216, "exif:TIFF/EPStandardID" },
      {  0xa217, "exif:SensingMethod" },
      {  0xa300, "exif:FileSource" },
      {  0xa301, "exif:SceneType" },
      {  0xa302, "exif:CFAPattern" },
      {  0xa401, "exif:CustomRendered" },
      {  0xa402, "exif:ExposureMode" },
      {  0xa403, "exif:WhiteBalance" },
      {  0xa404, "exif:DigitalZoomRatio" },
      {  0xa405, "exif:FocalLengthIn35mmFilm" },
      {  0xa406, "exif:SceneCaptureType" },
      {  0xa407, "exif:GainControl" },
      {  0xa408, "exif:Contrast" },
      {  0xa409, "exif:Saturation" },
      {  0xa40a, "exif:Sharpness" },
      {  0xa40b, "exif:DeviceSettingDescription" },
      {  0xa40c, "exif:SubjectDistanceRange" },
      {  0xa420, "exif:ImageUniqueID" },
      {  0xa430, "exif:CameraOwnerName" },
      {  0xa431, "exif:BodySerialNumber" },
      {  0xa432, "exif:LensSpecification" },
      {  0xa433, "exif:LensMake" },
      {  0xa434, "exif:LensModel" },
      {  0xa435, "exif:LensSerialNumber" },
      {  0xc4a5, "exif:PrintImageMatching" },
      {  0xa500, "exif:Gamma" },
      {  0xc640, "exif:CR2Slice" },
      { 0x10000, "exif:GPSVersionID" },
      { 0x10001, "exif:GPSLatitudeRef" },
      { 0x10002, "exif:GPSLatitude" },
      { 0x10003, "exif:GPSLongitudeRef" },
      { 0x10004, "exif:GPSLongitude" },
      { 0x10005, "exif:GPSAltitudeRef" },
      { 0x10006, "exif:GPSAltitude" },
      { 0x10007, "exif:GPSTimeStamp" },
      { 0x10008, "exif:GPSSatellites" },
      { 0x10009, "exif:GPSStatus" },
      { 0x1000a, "exif:GPSMeasureMode" },
      { 0x1000b, "exif:GPSDop" },
      { 0x1000c, "exif:GPSSpeedRef" },
      { 0x1000d, "exif:GPSSpeed" },
      { 0x1000e, "exif:GPSTrackRef" },
      { 0x1000f, "exif:GPSTrack" },
      { 0x10010, "exif:GPSImgDirectionRef" },
      { 0x10011, "exif:GPSImgDirection" },
      { 0x10012, "exif:GPSMapDatum" },
      { 0x10013, "exif:GPSDestLatitudeRef" },
      { 0x10014, "exif:GPSDestLatitude" },
      { 0x10015, "exif:GPSDestLongitudeRef" },
      { 0x10016, "exif:GPSDestLongitude" },
      { 0x10017, "exif:GPSDestBearingRef" },
      { 0x10018, "exif:GPSDestBearing" },
      { 0x10019, "exif:GPSDestDistanceRef" },
      { 0x1001a, "exif:GPSDestDistance" },
      { 0x1001b, "exif:GPSProcessingMethod" },
      { 0x1001c, "exif:GPSAreaInformation" },
      { 0x1001d, "exif:GPSDateStamp" },
      { 0x1001e, "exif:GPSDifferential" },
      { 0x1001f, "exif:GPSHPositioningError" },
      { 0x00000, "" }
    };  /* https://cipa.jp/std/documents/download_e.html?DC-008-Translation-2019-E */

  const StringInfo
    *profile;

  const unsigned char
    *directory,
    *exif;

  DirectoryInfo
    directory_stack[MaxDirectoryStack] = { { 0, 0, 0 } };

  EndianType
    endian;

  size_t
    entry,
    length,
    number_entries,
    tag,
    tag_value;

  SplayTreeInfo
    *exif_resources;

  ssize_t
    all,
    i,
    id,
    level,
    offset,
    tag_offset;

  static int
    tag_bytes[] = {0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};

  /*
    If EXIF data exists, then try to parse the request for a tag.
  */
  profile=GetImageProfile(image,"exif");
  if (profile == (const StringInfo *) NULL)
    return;
  if ((property == (const char *) NULL) || (*property == '\0'))
    return;
  while (isspace((int) ((unsigned char) *property)) != 0)
    property++;
  if (strlen(property) <= 5)
    return;
  all=0;
  tag=(~0UL);
  switch (*(property+5))
  {
    case '*':
    {
      /*
        Caller has asked for all the tags in the EXIF data.
      */
      tag=0;
      all=1; /* return the data in description=value format */
      break;
    }
    case '!':
    {
      tag=0;
      all=2; /* return the data in tagid=value format */
      break;
    }
    case '#':
    case '@':
    {
      int
        c;

      size_t
        n;

      /*
        Check for a hex based tag specification first.
      */
      tag=(*(property+5) == '@') ? 1UL : 0UL;
      property+=6;
      n=strlen(property);
      if (n != 4)
        return;
      /*
        Parse tag specification as a hex number.
      */
      n/=4;
      do
      {
        for (i=(ssize_t) n-1L; i >= 0; i--)
        {
          c=(*property++);
          tag<<=4;
          if ((c >= '0') && (c <= '9'))
            tag|=(size_t) (c-'0');
          else
            if ((c >= 'A') && (c <= 'F'))
              tag|=(size_t) (c-('A'-10));
            else
              if ((c >= 'a') && (c <= 'f'))
                tag|=(size_t) (c-('a'-10));
              else
                return;
        }
      } while (*property != '\0');
      break;
    }
    default:
    {
      /*
        Try to match the text with a tag name instead.
      */
      for (i=0; ; i++)
      {
        if (EXIFTag[i].tag == 0)
          break;
        if (LocaleCompare(EXIFTag[i].description,property) == 0)
          {
            tag=(size_t) EXIFTag[i].tag;
            break;
          }
      }
      break;
    }
  }
  if (tag == (~0UL))
    return;
  length=GetStringInfoLength(profile);
  if (length < 6)
    return;
  exif=GetStringInfoDatum(profile);
  while (length != 0)
  {
    if (ReadPropertyByte(&exif,&length) != 0x45)
      continue;
    if (ReadPropertyByte(&exif,&length) != 0x78)
      continue;
    if (ReadPropertyByte(&exif,&length) != 0x69)
      continue;
    if (ReadPropertyByte(&exif,&length) != 0x66)
      continue;
    if (ReadPropertyByte(&exif,&length) != 0x00)
      continue;
    if (ReadPropertyByte(&exif,&length) != 0x00)
      continue;
    break;
  }
  if (length < 16)
    return;
  id=(ssize_t) ReadPropertySignedShort(LSBEndian,exif);
  endian=LSBEndian;
  if (id == 0x4949)
    endian=LSBEndian;
  else
    if (id == 0x4D4D)
      endian=MSBEndian;
    else
      return;
  if (ReadPropertyUnsignedShort(endian,exif+2) != 0x002a)
    return;
  /*
    This the offset to the first IFD.
  */
  offset=(ssize_t) ReadPropertySignedLong(endian,exif+4);
  if ((offset < 0) || (size_t) offset >= length)
    return;
  /*
    Set the pointer to the first IFD and follow it were it leads.
  */
  directory=exif+offset;
  level=0;
  entry=0;
  tag_offset=0;
  exif_resources=NewSplayTree((int (*)(const void *,const void *)) NULL,
    (void *(*)(void *)) NULL,(void *(*)(void *)) NULL);
  do
  {
    /*
      If there is anything on the stack then pop it off.
    */
    if (level > 0)
      {
        level--;
        directory=directory_stack[level].directory;
        entry=directory_stack[level].entry;
        tag_offset=directory_stack[level].offset;
      }
    if ((directory < exif) || (directory > (exif+length-2)))
      break;
    /*
      Determine how many entries there are in the current IFD.
    */
    number_entries=(size_t) ReadPropertyUnsignedShort(endian,directory);
    for ( ; entry < number_entries; entry++)
    {
      size_t
        format;

      ssize_t
        components,
        number_bytes;

      unsigned char
        *p,
        *q;

      q=(unsigned char *) (directory+(12*entry)+2);
      if (q > (exif+length-12))
        break;  /* corrupt EXIF */
      if (GetValueFromSplayTree(exif_resources,q) == q)
        break;
      (void) AddValueToSplayTree(exif_resources,q,q);
      tag_value=(size_t) (ReadPropertyUnsignedShort(endian,q)+(ssize_t)
        tag_offset);
      format=(size_t) ReadPropertyUnsignedShort(endian,q+2);
      if (format >= (sizeof(tag_bytes)/sizeof(*tag_bytes)))
        break;
      if (format == 0)
        break;  /* corrupt EXIF */
      components=(ssize_t) ReadPropertySignedLong(endian,q+4);
      if (components < 0)
        break;  /* corrupt EXIF */
      number_bytes=components*(ssize_t) tag_bytes[format];
      if (number_bytes < components)
        break;  /* prevent overflow */
      if (number_bytes <= 4)
        p=q+8;
      else
        {
          ssize_t
            dir_offset;

          /*
            The directory entry contains an offset.
          */
          dir_offset=(ssize_t) ReadPropertySignedLong(endian,q+8);
          if ((dir_offset < 0) || (size_t) dir_offset >= length)
            continue;
          if (((size_t) dir_offset+(size_t) number_bytes) < (size_t) dir_offset)
            continue;  /* prevent overflow */
          if ((size_t) (dir_offset+(ssize_t) number_bytes) > length)
            continue;
          p=(unsigned char *) (exif+dir_offset);
        }
      if ((all != 0) || (tag == (size_t) tag_value))
        {
          // Initialize a buffer to store formatted property values and a pointer for the value.
          // Check if the pointer `p` is within the bounds of the EXIF data to prevent buffer overflow.
          // If the format is not valid, break the loop.
          // Reset the buffer and initialize the value pointer to NULL.
          // <MASK>
          switch (format)
          {
            case EXIF_FMT_BYTE:
            {
              value=(char *) NULL;
              if (~((size_t) number_bytes) >= 1)
                value=(char *) AcquireQuantumMemory((size_t) number_bytes+1UL,
                  sizeof(*value));
              if (value != (char *) NULL)
                {
                  for (i=0; i < (ssize_t) number_bytes; i++)
                  {
                    value[i]='.';
                    if (isprint((int) p[i]) != 0)
                      value[i]=(char) p[i];
                  }
                  value[i]='\0';
                }
              break;
            }
            case EXIF_FMT_SBYTE:
            {
              EXIFMultipleValues("%.20g",(double) (*(signed char *) p));
              break;
            }
            case EXIF_FMT_SSHORT:
            {
              EXIFMultipleValues("%hd",ReadPropertySignedShort(endian,p));
              break;
            }
            case EXIF_FMT_USHORT:
            {
              EXIFMultipleValues("%hu",ReadPropertyUnsignedShort(endian,p));
              break;
            }
            case EXIF_FMT_ULONG:
            {
              EXIFMultipleValues("%.20g",(double)
                ReadPropertyUnsignedLong(endian,p));
              break;
            }
            case EXIF_FMT_SLONG:
            {
              EXIFMultipleValues("%.20g",(double)
                ReadPropertySignedLong(endian,p));
              break;
            }
            case EXIF_FMT_URATIONAL:
            {
              if ((tag_value == GPS_LATITUDE) || (tag_value == GPS_LONGITUDE) ||
                  (tag_value == GPS_TIMESTAMP))
                {
                  components=1;
                  EXIFGPSFractions("%.20g/%.20g,%.20g/%.20g,%.20g/%.20g",
                    (double) ReadPropertyUnsignedLong(endian,p),
                    (double) ReadPropertyUnsignedLong(endian,p+4),
                    (double) ReadPropertyUnsignedLong(endian,p+8),
                    (double) ReadPropertyUnsignedLong(endian,p+12),
                    (double) ReadPropertyUnsignedLong(endian,p+16),
                    (double) ReadPropertyUnsignedLong(endian,p+20));
                  break;
                }
              EXIFMultipleFractions("%.20g/%.20g",(double)
                ReadPropertyUnsignedLong(endian,p),(double)
                ReadPropertyUnsignedLong(endian,p+4));
              break;
            }
            case EXIF_FMT_SRATIONAL:
            {
              EXIFMultipleFractions("%.20g/%.20g",(double)
                ReadPropertySignedLong(endian,p),(double)
                ReadPropertySignedLong(endian,p+4));
              break;
            }
            case EXIF_FMT_SINGLE:
            {
              EXIFMultipleValues("%.20g",(double)
                ReadPropertySignedLong(endian,p));
              break;
            }
            case EXIF_FMT_DOUBLE:
            {
              EXIFMultipleValues("%.20g",(double)
                ReadPropertySignedLong(endian,p));
              break;
            }
            case EXIF_FMT_STRING:
            case EXIF_FMT_UNDEFINED:
            default:
            {
              if ((p < exif) || (p > (exif+length-number_bytes)))
                break;
              value=(char *) NULL;
              if (~((size_t) number_bytes) >= 1)
                value=(char *) AcquireQuantumMemory((size_t) number_bytes+1UL,
                  sizeof(*value));
              if (value != (char *) NULL)
                {
                  for (i=0; i < (ssize_t) number_bytes; i++)
                  {
                    value[i]='.';
                    if ((isprint((int) p[i]) != 0) || (p[i] == '\0'))
                      value[i]=(char) p[i];
                  }
                  value[i]='\0';
                }
              break;
            }
          }
          if (value != (char *) NULL)
            {
              char
                *key;

              key=AcquireString(property);
              switch (all)
              {
                case 1:
                {
                  const char
                    *description;

                  description="unknown";
                  for (i=0; ; i++)
                  {
                    if (EXIFTag[i].tag == 0)
                      break;
                    if (EXIFTag[i].tag == tag_value)
                      {
                        description=EXIFTag[i].description;
                        break;
                      }
                  }
                  (void) FormatLocaleString(key,MagickPathExtent,"%s",
                    description);
                  if (level == 2)
                    (void) SubstituteString(&key,"exif:","exif:thumbnail:");
                  break;
                }
                case 2:
                {
                  if (tag_value < 0x10000)
                    (void) FormatLocaleString(key,MagickPathExtent,"#%04lx",
                      (unsigned long) tag_value);
                  else
                    if (tag_value < 0x20000)
                      (void) FormatLocaleString(key,MagickPathExtent,"@%04lx",
                        (unsigned long) (tag_value & 0xffff));
                    else
                      (void) FormatLocaleString(key,MagickPathExtent,"unknown");
                  break;
                }
                default:
                {
                  if (level == 2)
                    (void) SubstituteString(&key,"exif:","exif:thumbnail:");
                }
              }
              if ((image->properties == (void *) NULL) ||
                  (GetValueFromSplayTree((SplayTreeInfo *) image->properties,key) == (const void *) NULL))
                (void) SetImageProperty((Image *) image,key,value,exception);
              value=DestroyString(value);
              key=DestroyString(key);
            }
        }
        if ((tag_value == TAG_EXIF_OFFSET) ||
            (tag_value == TAG_INTEROP_OFFSET) || (tag_value == TAG_GPS_OFFSET))
          {
            ssize_t
              tag_offset1;

            tag_offset1=(ssize_t) ReadPropertySignedLong(endian,p);
            if (((size_t) tag_offset1 < length) &&
                (level < (MaxDirectoryStack-2)))
              {
                ssize_t
                  tag_offset2;

                tag_offset2=(ssize_t) ((tag_value == TAG_GPS_OFFSET) ? 0x10000 :
                  0);
                directory_stack[level].directory=directory;
                entry++;
                directory_stack[level].entry=entry;
                directory_stack[level].offset=tag_offset;
                level++;
                /*
                  Check for duplicate tag.
                */
                for (i=0; i < level; i++)
                  if (directory_stack[i].directory == (exif+tag_offset1))
                    break;
                if (i < level)
                  break;  /* duplicate tag */
                directory_stack[level].directory=exif+tag_offset1;
                directory_stack[level].offset=tag_offset2;
                directory_stack[level].entry=0;
                level++;
                if ((directory+2+(12*number_entries)+4) > (exif+length))
                  break;
                tag_offset1=(ssize_t) ReadPropertySignedLong(endian,directory+
                  2+(12*number_entries));
                if ((tag_offset1 != 0) && ((size_t) tag_offset1 < length) &&
                    (level < (MaxDirectoryStack-2)))
                  {
                    directory_stack[level].directory=exif+tag_offset1;
                    directory_stack[level].entry=0;
                    directory_stack[level].offset=tag_offset2;
                    level++;
                  }
              }
            break;
          }
    }
  } while (level > 0);
  exif_resources=DestroySplayTree(exif_resources);
}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// MagickCore/profile.c
// static void Sync8BimProfile(const Image *image,const StringInfo *profile)
// {
//   size_t
//     length;
// 
//   ssize_t
//     count;
// 
//   unsigned char
//     *p;
// 
//   unsigned short
//     id;
// 
//   length=GetStringInfoLength(profile);
//   p=GetStringInfoDatum(profile);
//   while (length != 0)
//   {
//     if (ReadProfileByte(&p,&length) != 0x38)
//       continue;
//     if (ReadProfileByte(&p,&length) != 0x42)
//       continue;
//     if (ReadProfileByte(&p,&length) != 0x49)
//       continue;
//     if (ReadProfileByte(&p,&length) != 0x4D)
//       continue;
//     if (length < 7)
//       return;
//     id=(unsigned short) ReadProfileMSBShort(&p,&length);
//     count=(ssize_t) ReadProfileByte(&p,&length);
//     if ((count >= (ssize_t) length) || (count < 0))
//       return;
//     p+=count;
//     length-=(size_t) count;
//     if ((*p & 0x01) == 0)
//       (void) ReadProfileByte(&p,&length);
//     count=(ssize_t) ReadProfileMSBLong(&p,&length);
//     if ((count > (ssize_t) length) || (count < 0))
//       return;
//     if ((id == 0x3ED) && (count == 16))
//       {
//         if (image->units == PixelsPerCentimeterResolution)
//           WriteProfileLong(MSBEndian,(unsigned int) CastDoubleToLong(
//             image->resolution.x*2.54*65536.0),p);
//         else
//           WriteProfileLong(MSBEndian,(unsigned int) CastDoubleToLong(
//             image->resolution.x*65536.0),p);
//         WriteProfileShort(MSBEndian,(unsigned short) image->units,p+4);
//         if (image->units == PixelsPerCentimeterResolution)
//           WriteProfileLong(MSBEndian,(unsigned int) CastDoubleToLong(
//             image->resolution.y*2.54*65536.0),p+8);
//         else
//           WriteProfileLong(MSBEndian,(unsigned int) CastDoubleToLong(
//             image->resolution.y*65536.0),p+8);
//         WriteProfileShort(MSBEndian,(unsigned short) image->units,p+12);
//       }
//     if (id == 0x0422)
//       SyncExifProfile(image,p,(size_t) count);
//     p+=count;
//     length-=(size_t) count;
//   }
//   return;
// }

// the below code fragment can be found in:
// coders/thumbnail.c
// static MagickBooleanType WriteTHUMBNAILImage(const ImageInfo *image_info,
//   Image *image,ExceptionInfo *exception)
// {
//   const char
//     *property;
// 
//   const MagickInfo
//     *magick_info;
// 
//   const StringInfo
//     *profile;
// 
//   Image
//     *thumbnail_image;
// 
//   ImageInfo
//     *write_info;
// 
//   MagickBooleanType
//     status;
// 
//   ssize_t
//     i;
// 
//   size_t
//     length;
// 
//   ssize_t
//     offset;
// 
//   unsigned char
//     *q;
// 
//   profile=GetImageProfile(image,"exif");
//   if (profile == (const StringInfo *) NULL)
//     ThrowWriterException(CoderError,"ImageDoesNotHaveAThumbnail");
//   property=GetImageProperty(image,"exif:JPEGInterchangeFormat",exception);
//   if (property == (const char *) NULL)
//     ThrowWriterException(CoderError,"ImageDoesNotHaveAThumbnail");
//   offset=(ssize_t) StringToLong(property);
//   if (offset < 0)
//     ThrowWriterException(CoderError,"ImageDoesNotHaveAThumbnail");
//   property=GetImageProperty(image,"exif:JPEGInterchangeFormatLength",exception);
//   if (property == (const char *) NULL)
//     ThrowWriterException(CoderError,"ImageDoesNotHaveAThumbnail");
//   length=(size_t) StringToLong(property);
//   q=GetStringInfoDatum(profile)+offset;
//   for (i=offset; i < (ssize_t) GetStringInfoLength(profile) - 3; i++)
//   {
//     if (memcmp(q,"\377\330\377",3) == 0)
//       break;
//     q++;
//   }
//   if ((q > (GetStringInfoDatum(profile)+GetStringInfoLength(profile))) ||
//       ((ssize_t) length > (GetStringInfoDatum(profile)+GetStringInfoLength(profile)-q)))
//     ThrowWriterException(CoderError,"ImageDoesNotHaveAThumbnail");
//   thumbnail_image=BlobToImage(image_info,q,length,exception);
//   if (thumbnail_image == (Image *) NULL)
//     return(MagickFalse);
//   (void) SetImageType(thumbnail_image,thumbnail_image->alpha_trait ==
//     UndefinedPixelTrait ? TrueColorType : TrueColorAlphaType,exception);
//   (void) CopyMagickString(thumbnail_image->filename,image->filename,
//     MagickPathExtent);
//   write_info=CloneImageInfo(image_info);
//   *write_info->magick='\0';
//   (void) SetImageInfo(write_info,1,exception);
//   magick_info=GetMagickInfo(write_info->magick,exception);
//   if ((magick_info == (const MagickInfo*) NULL) ||
//       (LocaleCompare(magick_info->magick_module,"THUMBNAIL") == 0))
//     (void) FormatLocaleString(thumbnail_image->filename,MagickPathExtent,
//       "miff:%s",write_info->filename);
//   status=WriteImage(write_info,thumbnail_image,exception);
//   thumbnail_image=DestroyImage(thumbnail_image);
//   write_info=DestroyImageInfo(write_info);
//   return(status);
// }

// the below code fragment can be found in:
// MagickCore/constitute.c
// MagickExport Image *ReadImage(const ImageInfo *image_info,
//   ExceptionInfo *exception)
// {
//   char
//     filename[MagickPathExtent],
//     magick[MagickPathExtent],
//     magick_filename[MagickPathExtent];
// 
//   ConstituteInfo
//     constitute_info;
// 
//   const DelegateInfo
//     *delegate_info;
// 
//   const MagickInfo
//     *magick_info;
// 
//   DecodeImageHandler
//     *decoder;
// 
//   ExceptionInfo
//     *sans_exception;
// 
//   Image
//     *image,
//     *next;
// 
//   ImageInfo
//     *read_info;
// 
//   MagickBooleanType
//     status;
// 
//   /*
//     Determine image type from filename prefix or suffix (e.g. image.jpg).
//   */
//   assert(image_info != (ImageInfo *) NULL);
//   assert(image_info->signature == MagickCoreSignature);
//   assert(image_info->filename != (char *) NULL);
//   if (IsEventLogging() != MagickFalse)
//     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",
//       image_info->filename);
//   assert(exception != (ExceptionInfo *) NULL);
//   read_info=CloneImageInfo(image_info);
//   (void) CopyMagickString(magick_filename,read_info->filename,MagickPathExtent);
//   (void) SetImageInfo(read_info,0,exception);
//   (void) CopyMagickString(filename,read_info->filename,MagickPathExtent);
//   (void) CopyMagickString(magick,read_info->magick,MagickPathExtent);
//   /*
//     Call appropriate image reader based on image type.
//   */
//   sans_exception=AcquireExceptionInfo();
//   magick_info=GetMagickInfo(read_info->magick,sans_exception);
//   if (sans_exception->severity == PolicyError)
//     InheritException(exception,sans_exception);
//   sans_exception=DestroyExceptionInfo(sans_exception);
//   if (magick_info != (const MagickInfo *) NULL)
//     {
//       if (GetMagickEndianSupport(magick_info) == MagickFalse)
//         read_info->endian=UndefinedEndian;
//       else
//         if ((image_info->endian == UndefinedEndian) &&
//             (GetMagickRawSupport(magick_info) != MagickFalse))
//           {
//             unsigned long
//               lsb_first;
// 
//             lsb_first=1;
//             read_info->endian=(*(char *) &lsb_first) == 1 ? LSBEndian :
//               MSBEndian;
//          }
//     }
//   if ((magick_info != (const MagickInfo *) NULL) &&
//       (GetMagickDecoderSeekableStream(magick_info) != MagickFalse))
//     {
//       image=AcquireImage(read_info,exception);
//       (void) CopyMagickString(image->filename,read_info->filename,
//         MagickPathExtent);
//       status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
//       if (status == MagickFalse)
//         {
//           read_info=DestroyImageInfo(read_info);
//           image=DestroyImage(image);
//           return((Image *) NULL);
//         }
//       if (IsBlobSeekable(image) == MagickFalse)
//         {
//           /*
//             Coder requires a seekable stream.
//           */
//           *read_info->filename='\0';
//           status=ImageToFile(image,read_info->filename,exception);
//           if (status == MagickFalse)
//             {
//               (void) CloseBlob(image);
//               read_info=DestroyImageInfo(read_info);
//               image=DestroyImage(image);
//               return((Image *) NULL);
//             }
//           read_info->temporary=MagickTrue;
//         }
//       (void) CloseBlob(image);
//       image=DestroyImage(image);
//     }
//   image=NewImageList();
//   decoder=GetImageDecoder(magick_info);
//   if (decoder == (DecodeImageHandler *) NULL)
//     {
//       delegate_info=GetDelegateInfo(read_info->magick,(char *) NULL,exception);
//       if (delegate_info == (const DelegateInfo *) NULL)
//         {
//           (void) SetImageInfo(read_info,0,exception);
//           (void) CopyMagickString(read_info->filename,filename,
//             MagickPathExtent);
//           magick_info=GetMagickInfo(read_info->magick,exception);
//           decoder=GetImageDecoder(magick_info);
//         }
//     }
//   if (decoder != (DecodeImageHandler *) NULL)
//     {
//       /*
//         Call appropriate image reader based on image type.
//       */
//       if ((magick_info != (const MagickInfo *) NULL) &&
//           (GetMagickDecoderThreadSupport(magick_info) == MagickFalse))
//         LockSemaphoreInfo(magick_info->semaphore);
//       status=IsCoderAuthorized(read_info->magick,ReadPolicyRights,exception);
//       image=(Image *) NULL;
//       if (status != MagickFalse)
//         image=decoder(read_info,exception);
//       if ((magick_info != (const MagickInfo *) NULL) &&
//           (GetMagickDecoderThreadSupport(magick_info) == MagickFalse))
//         UnlockSemaphoreInfo(magick_info->semaphore);
//     }
//   else
//     {
//       delegate_info=GetDelegateInfo(read_info->magick,(char *) NULL,exception);
//       if (delegate_info == (const DelegateInfo *) NULL)
//         {
//           (void) ThrowMagickException(exception,GetMagickModule(),
//             MissingDelegateError,"NoDecodeDelegateForThisImageFormat","`%s'",
//             read_info->magick);
//           if (read_info->temporary != MagickFalse)
//             (void) RelinquishUniqueFileResource(read_info->filename);
//           read_info=DestroyImageInfo(read_info);
//           return((Image *) NULL);
//         }
//       /*
//         Let our decoding delegate process the image.
//       */
//       image=AcquireImage(read_info,exception);
//       if (image == (Image *) NULL)
//         {
//           read_info=DestroyImageInfo(read_info);
//           return((Image *) NULL);
//         }
//       (void) CopyMagickString(image->filename,read_info->filename,
//         MagickPathExtent);
//       *read_info->filename='\0';
//       if (GetDelegateThreadSupport(delegate_info) == MagickFalse)
//         LockSemaphoreInfo(delegate_info->semaphore);
//       status=InvokeDelegate(read_info,image,read_info->magick,(char *) NULL,
//         exception);
//       if (GetDelegateThreadSupport(delegate_info) == MagickFalse)
//         UnlockSemaphoreInfo(delegate_info->semaphore);
//       image=DestroyImageList(image);
//       read_info->temporary=MagickTrue;
//       if (status != MagickFalse)
//         (void) SetImageInfo(read_info,0,exception);
//       magick_info=GetMagickInfo(read_info->magick,exception);
//       decoder=GetImageDecoder(magick_info);
//       if (decoder == (DecodeImageHandler *) NULL)
//         {
//           if (IsPathAccessible(read_info->filename) != MagickFalse)
//             (void) ThrowMagickException(exception,GetMagickModule(),
//               MissingDelegateError,"NoDecodeDelegateForThisImageFormat","`%s'",
//               read_info->magick);
//           else
//             ThrowFileException(exception,FileOpenError,"UnableToOpenFile",
//               read_info->filename);
//           read_info=DestroyImageInfo(read_info);
//           return((Image *) NULL);
//         }
//       /*
//         Call appropriate image reader based on image type.
//       */
//       if (GetMagickDecoderThreadSupport(magick_info) == MagickFalse)
//         LockSemaphoreInfo(magick_info->semaphore);
//       status=IsCoderAuthorized(read_info->magick,ReadPolicyRights,exception);
//       image=(Image *) NULL;
//       if (status != MagickFalse)
//         image=(decoder)(read_info,exception);
//       if (GetMagickDecoderThreadSupport(magick_info) == MagickFalse)
//         UnlockSemaphoreInfo(magick_info->semaphore);
//     }
//   if (read_info->temporary != MagickFalse)
//     {
//       (void) RelinquishUniqueFileResource(read_info->filename);
//       read_info->temporary=MagickFalse;
//       if (image != (Image *) NULL)
//         (void) CopyMagickString(image->filename,filename,MagickPathExtent);
//     }
//   if (image == (Image *) NULL)
//     {
//       read_info=DestroyImageInfo(read_info);
//       return(image);
//     }
//   if (exception->severity >= ErrorException)
//     (void) LogMagickEvent(ExceptionEvent,GetMagickModule(),
//       "Coder (%s) generated an image despite an error (%d), "
//       "notify the developers",image->magick,exception->severity);
//   if (IsBlobTemporary(image) != MagickFalse)
//     (void) RelinquishUniqueFileResource(read_info->filename);
//   if ((IsSceneGeometry(read_info->scenes,MagickFalse) != MagickFalse) &&
//       (GetImageListLength(image) != 1))
//     {
//       Image
//         *clones;
// 
//       clones=CloneImages(image,read_info->scenes,exception);
//       if (clones != (Image *) NULL)
//         {
//           image=DestroyImageList(image);
//           image=GetFirstImageInList(clones);
//         }
//     }
//   InitializeConstituteInfo(read_info,&constitute_info);
//   for (next=image; next != (Image *) NULL; next=GetNextImageInList(next))
//   {
//     char
//       magick_path[MagickPathExtent],
//       *property;
// 
//     const StringInfo
//       *profile;
// 
//     static const char
//       *source_date_epoch = (const char *) NULL;
// 
//     static MagickBooleanType
//       epoch_initialized = MagickFalse;
// 
//     next->taint=MagickFalse;
//     GetPathComponent(magick_filename,MagickPath,magick_path);
//     if ((*magick_path == '\0') && (*next->magick == '\0'))
//       (void) CopyMagickString(next->magick,magick,MagickPathExtent);
//     (void) CopyMagickString(next->magick_filename,magick_filename,
//       MagickPathExtent);
//     if (IsBlobTemporary(image) != MagickFalse)
//       (void) CopyMagickString(next->filename,filename,MagickPathExtent);
//     if (next->magick_columns == 0)
//       next->magick_columns=next->columns;
//     if (next->magick_rows == 0)
//       next->magick_rows=next->rows;
//     (void) GetImageProperty(next,"exif:*",exception);
//     (void) GetImageProperty(next,"icc:*",exception);
//     (void) GetImageProperty(next,"iptc:*",exception);
//     (void) GetImageProperty(next,"xmp:*",exception);
//     SyncOrientationFromProperties(next,&constitute_info,exception);
//     SyncResolutionFromProperties(next,&constitute_info,exception);
//     if (next->page.width == 0)
//       next->page.width=next->columns;
//     if (next->page.height == 0)
//       next->page.height=next->rows;
//     if (constitute_info.caption != (const char *) NULL)
//       {
//         property=InterpretImageProperties(read_info,next,
//           constitute_info.caption,exception);
//         (void) SetImageProperty(next,"caption",property,exception);
//         property=DestroyString(property);
//       }
//     if (constitute_info.comment != (const char *) NULL)
//       {
//         property=InterpretImageProperties(read_info,next,
//           constitute_info.comment,exception);
//         (void) SetImageProperty(next,"comment",property,exception);
//         property=DestroyString(property);
//       }
//     if (constitute_info.label != (const char *) NULL)
//       {
//         property=InterpretImageProperties(read_info,next,
//           constitute_info.label,exception);
//         (void) SetImageProperty(next,"label",property,exception);
//         property=DestroyString(property);
//       }
//     if (LocaleCompare(next->magick,"TEXT") == 0)
//       (void) ParseAbsoluteGeometry("0x0+0+0",&next->page);
//     if ((read_info->extract != (char *) NULL) &&
//         (read_info->stream == (StreamHandler) NULL))
//       {
//         RectangleInfo
//           geometry;
// 
//         MagickStatusType
//           flags;
// 
//         SetGeometry(next,&geometry);
//         flags=ParseAbsoluteGeometry(read_info->extract,&geometry);
//         if ((next->columns != geometry.width) ||
//             (next->rows != geometry.height))
//           {
//             if (((flags & XValue) != 0) || ((flags & YValue) != 0))
//               {
//                 Image
//                   *crop_image;
// 
//                 crop_image=CropImage(next,&geometry,exception);
//                 if (crop_image != (Image *) NULL)
//                   ReplaceImageInList(&next,crop_image);
//               }
//             else
//               if (((flags & WidthValue) != 0) || ((flags & HeightValue) != 0))
//                 {
//                   flags=ParseRegionGeometry(next,read_info->extract,&geometry,
//                     exception);
//                   if ((geometry.width != 0) && (geometry.height != 0))
//                     {
//                       Image *resize_image = ResizeImage(next,geometry.width,
//                         geometry.height,next->filter,exception);
//                       if (resize_image != (Image *) NULL)
//                         ReplaceImageInList(&next,resize_image);
//                     }
//                 }
//           }
//       }
//     profile=GetImageProfile(next,"icc");
//     if (profile == (const StringInfo *) NULL)
//       profile=GetImageProfile(next,"icm");
//     profile=GetImageProfile(next,"iptc");
//     if (profile == (const StringInfo *) NULL)
//       profile=GetImageProfile(next,"8bim");
//     if (epoch_initialized == MagickFalse)
//       {
//         source_date_epoch=getenv("SOURCE_DATE_EPOCH");
//         epoch_initialized=MagickTrue;
//       }
//     if (source_date_epoch == (const char *) NULL)
//       {
//         char
//           timestamp[MagickTimeExtent];
// 
//         (void) FormatMagickTime(next->timestamp,sizeof(timestamp),timestamp);
//         (void) SetImageProperty(next,"date:timestamp",timestamp,exception);
//         (void) FormatMagickTime((time_t) GetBlobProperties(next)->st_mtime,
//           sizeof(timestamp),timestamp);
//         (void) SetImageProperty(next,"date:modify",timestamp,exception);
//         (void) FormatMagickTime((time_t) GetBlobProperties(next)->st_ctime,
//           sizeof(timestamp),timestamp);
//         (void) SetImageProperty(next,"date:create",timestamp,exception);
//       }
//     if (constitute_info.delay_flags != NoValue)
//       {
//         if ((constitute_info.delay_flags & GreaterValue) != 0)
//           {
//             if (next->delay > constitute_info.delay)
//               next->delay=constitute_info.delay;
//           }
//         else
//           if ((constitute_info.delay_flags & LessValue) != 0)
//             {
//               if (next->delay < constitute_info.delay)
//                 next->delay=constitute_info.delay;
//             }
//           else
//             next->delay=constitute_info.delay;
//         if ((constitute_info.delay_flags & SigmaValue) != 0)
//           next->ticks_per_second=constitute_info.ticks_per_second;
//       }
//     if (constitute_info.dispose != (const char *) NULL)
//       {
//         ssize_t
//           option_type;
// 
//         option_type=ParseCommandOption(MagickDisposeOptions,MagickFalse,
//           constitute_info.dispose);
//         if (option_type >= 0)
//           next->dispose=(DisposeType) option_type;
//       }
//     if (read_info->verbose != MagickFalse)
//       (void) IdentifyImage(next,stderr,MagickFalse,exception);
//     image=next;
//   }
//   read_info=DestroyImageInfo(read_info);
//   if (GetBlobError(image) != MagickFalse)
//     ThrowReaderException(CorruptImageError,"UnableToReadImageData");
//   return(GetFirstImageInList(image));
// }

// the below code fragment can be found in:
// coders/jpeg.c
// static void SkipInputData(j_decompress_ptr compress_info,long number_bytes)
// {
//   SourceManager
//     *source;
// 
//   if (number_bytes <= 0)
//     return;
//   source=(SourceManager *) compress_info->src;
//   while (number_bytes > (long) source->manager.bytes_in_buffer)
//   {
//     number_bytes-=(long) source->manager.bytes_in_buffer;
//     (void) FillInputBuffer(compress_info);
//   }
//   source->manager.next_input_byte+=number_bytes;
//   source->manager.bytes_in_buffer-=(size_t) number_bytes;
// }

// the below code fragment can be found in:
// MagickCore/property.c
// static char *TracePSClippath(const unsigned char *blob,size_t length)
// {
//   char
//     *path,
//     *message;
// 
//   MagickBooleanType
//     in_subpath;
// 
//   PointInfo
//     first[3],
//     last[3],
//     point[3];
// 
//   ssize_t
//     i,
//     x;
// 
//   ssize_t
//     knot_count,
//     selector,
//     y;
// 
//   path=AcquireString((char *) NULL);
//   if (path == (char *) NULL)
//     return((char *) NULL);
//   message=AcquireString((char *) NULL);
//   (void) FormatLocaleString(message,MagickPathExtent,"/ClipImage\n");
//   (void) ConcatenateString(&path,message);
//   (void) FormatLocaleString(message,MagickPathExtent,"{\n");
//   (void) ConcatenateString(&path,message);
//   (void) FormatLocaleString(message,MagickPathExtent,
//     "  /c {curveto} bind def\n");
//   (void) ConcatenateString(&path,message);
//   (void) FormatLocaleString(message,MagickPathExtent,
//     "  /l {lineto} bind def\n");
//   (void) ConcatenateString(&path,message);
//   (void) FormatLocaleString(message,MagickPathExtent,
//     "  /m {moveto} bind def\n");
//   (void) ConcatenateString(&path,message);
//   (void) FormatLocaleString(message,MagickPathExtent,
//     "  /v {currentpoint 6 2 roll curveto} bind def\n");
//   (void) ConcatenateString(&path,message);
//   (void) FormatLocaleString(message,MagickPathExtent,
//     "  /y {2 copy curveto} bind def\n");
//   (void) ConcatenateString(&path,message);
//   (void) FormatLocaleString(message,MagickPathExtent,
//     "  /z {closepath} bind def\n");
//   (void) ConcatenateString(&path,message);
//   (void) FormatLocaleString(message,MagickPathExtent,"  newpath\n");
//   (void) ConcatenateString(&path,message);
//   /*
//     The clipping path format is defined in "Adobe Photoshop File Formats
//     Specification" version 6.0 downloadable from adobe.com.
//   */
//   (void) memset(point,0,sizeof(point));
//   (void) memset(first,0,sizeof(first));
//   (void) memset(last,0,sizeof(last));
//   knot_count=0;
//   in_subpath=MagickFalse;
//   while (length > 0)
//   {
//     selector=(ssize_t) ReadPropertyMSBShort(&blob,&length);
//     switch (selector)
//     {
//       case 0:
//       case 3:
//       {
//         if (knot_count != 0)
//           {
//             blob+=24;
//             length=(size_t) ((ssize_t) length-MagickMin(24,(ssize_t) length));
//             break;
//           }
//         /*
//           Expected subpath length record.
//         */
//         knot_count=(ssize_t) ReadPropertyMSBShort(&blob,&length);
//         blob+=22;
//         length=(size_t) ((ssize_t) length-MagickMin(22,(ssize_t) length));
//         break;
//       }
//       case 1:
//       case 2:
//       case 4:
//       case 5:
//       {
//         if (knot_count == 0)
//           {
//             /*
//               Unexpected subpath knot
//             */
//             blob+=24;
//             length=(size_t) ((ssize_t) length-MagickMin(24,(ssize_t) length));
//             break;
//           }
//         /*
//           Add sub-path knot
//         */
//         for (i=0; i < 3; i++)
//         {
//           y=(ssize_t) ReadPropertyMSBLong(&blob,&length);
//           x=(ssize_t) ReadPropertyMSBLong(&blob,&length);
//           point[i].x=(double) x/4096.0/4096.0;
//           point[i].y=1.0-(double) y/4096.0/4096.0;
//         }
//         if (in_subpath == MagickFalse)
//           {
//             (void) FormatLocaleString(message,MagickPathExtent,"  %g %g m\n",
//               point[1].x,point[1].y);
//             for (i=0; i < 3; i++)
//             {
//               first[i]=point[i];
//               last[i]=point[i];
//             }
//           }
//         else
//           {
//             /*
//               Handle special cases when Bezier curves are used to describe
//               corners and straight lines.
//             */
//             if ((last[1].x == last[2].x) && (last[1].y == last[2].y) &&
//                 (point[0].x == point[1].x) && (point[0].y == point[1].y))
//               (void) FormatLocaleString(message,MagickPathExtent,
//                 "  %g %g l\n",point[1].x,point[1].y);
//             else
//               if ((last[1].x == last[2].x) && (last[1].y == last[2].y))
//                 (void) FormatLocaleString(message,MagickPathExtent,
//                   "  %g %g %g %g v\n",point[0].x,point[0].y,
//                   point[1].x,point[1].y);
//               else
//                 if ((point[0].x == point[1].x) && (point[0].y == point[1].y))
//                   (void) FormatLocaleString(message,MagickPathExtent,
//                     "  %g %g %g %g y\n",last[2].x,last[2].y,
//                     point[1].x,point[1].y);
//                 else
//                   (void) FormatLocaleString(message,MagickPathExtent,
//                     "  %g %g %g %g %g %g c\n",last[2].x,
//                     last[2].y,point[0].x,point[0].y,point[1].x,point[1].y);
//             for (i=0; i < 3; i++)
//               last[i]=point[i];
//           }
//         (void) ConcatenateString(&path,message);
//         in_subpath=MagickTrue;
//         knot_count--;
//         /*
//           Close the subpath if there are no more knots.
//         */
//         if (knot_count == 0)
//           {
//             /*
//               Same special handling as above except we compare to the
//               first point in the path and close the path.
//             */
//             if ((last[1].x == last[2].x) && (last[1].y == last[2].y) &&
//                 (first[0].x == first[1].x) && (first[0].y == first[1].y))
//               (void) FormatLocaleString(message,MagickPathExtent,
//                 "  %g %g l z\n",first[1].x,first[1].y);
//             else
//               if ((last[1].x == last[2].x) && (last[1].y == last[2].y))
//                 (void) FormatLocaleString(message,MagickPathExtent,
//                   "  %g %g %g %g v z\n",first[0].x,first[0].y,
//                   first[1].x,first[1].y);
//               else
//                 if ((first[0].x == first[1].x) && (first[0].y == first[1].y))
//                   (void) FormatLocaleString(message,MagickPathExtent,
//                     "  %g %g %g %g y z\n",last[2].x,last[2].y,
//                     first[1].x,first[1].y);
//                 else
//                   (void) FormatLocaleString(message,MagickPathExtent,
//                     "  %g %g %g %g %g %g c z\n",last[2].x,
//                     last[2].y,first[0].x,first[0].y,first[1].x,first[1].y);
//             (void) ConcatenateString(&path,message);
//             in_subpath=MagickFalse;
//           }
//         break;
//       }
//       case 6:
//       case 7:
//       case 8:
//       default:
//       {
//         blob+=24;
//         length=(size_t) ((ssize_t) length-MagickMin(24,(ssize_t) length));
//         break;
//       }
//     }
//   }
//   /*
//     Returns an empty PS path if the path has no knots.
//   */
//   (void) FormatLocaleString(message,MagickPathExtent,"  eoclip\n");
//   (void) ConcatenateString(&path,message);
//   (void) FormatLocaleString(message,MagickPathExtent,"} bind def");
//   (void) ConcatenateString(&path,message);
//   message=DestroyString(message);
//   return(path);
// }
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).