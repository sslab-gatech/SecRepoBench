/*
    Define a macro to check and extend the memory allocation for path arrays if needed.
  */
  #define CheckPathExtent(add) \
    do { \
      if (((p + (add)) >= max_points) || ((q + (add)) >= max_points)) \
        { \
          size_t new_points = max_points + (add) + 6UL*BezierQuantum; \
          path_p=(PointInfo *) ResizeQuantumMemory(path_p,new_points,sizeof(*path_p)); \
          if (path_p == (PointInfo *) NULL) \
            { \
              polygon_primitive=(PrimitiveInfo *) RelinquishMagickMemory(polygon_primitive); \
              return((PrimitiveInfo *) NULL); \
            } \
          path_q=(PointInfo *) ResizeQuantumMemory(path_q,new_points,sizeof(*path_q)); \
          if (path_q == (PointInfo *) NULL) \
            { \
              path_p=(PointInfo *) RelinquishMagickMemory(path_p); \
              polygon_primitive=(PrimitiveInfo *) RelinquishMagickMemory(polygon_primitive); \
              return((PrimitiveInfo *) NULL); \
            } \
          max_points=new_points; \
        } \
    } while (0)

  /*
    Declare necessary structures and variables for line segments and slopes.
  */
  typedef struct _LineSegment
  {
    double p;
    double q;
  } LineSegment;

  LineSegment
    dx,
    dy,
    slope,
    inverse_slope;

  LineSegment
    theta;

  MagickBooleanType
    closed_path;

  double
    dot_product,
    mid,
    miterlimit,
    delta_theta;

  PointInfo
    offset,
    box_p[5],
    box_q[5],
    *path_p,
    *path_q;

  PrimitiveInfo
    *polygon_primitive,
    *stroke_polygon;

  size_t
    arc_segments,
    i,
    j,
    n,
    p,
    q,
    max_points,
    number_vertices;

  /*
    Allocate memory for 'polygon_primitive' based on the number of vertices in 'primitivedata'.
    If allocation fails, return NULL. Then copy 'primitivedata' into 'polygon_primitive'.
  */
  number_vertices=primitivedata->coordinates;
  polygon_primitive=(PrimitiveInfo *) AcquireQuantumMemory(number_vertices+1UL,
    sizeof(*polygon_primitive));
  if (polygon_primitive == (PrimitiveInfo *) NULL)
    return((PrimitiveInfo *) NULL);
  (void) memcpy(polygon_primitive,primitivedata,number_vertices*
    sizeof(*polygon_primitive));

  /*
    Determine if the path is closed by checking the 'closed_subpath' field.
    Adjust 'number_vertices' if needed and set the last primitive type to 'UndefinedPrimitive'.
  */
  closed_path=primitivedata->closed_subpath != MagickFalse ? MagickTrue : MagickFalse;
  if ((closed_path != MagickFalse) &&
      ((draw_info->linejoin == RoundJoin) || (draw_info->linejoin == MiterJoin)))
    number_vertices--;
  polygon_primitive[number_vertices].primitive=UndefinedPrimitive;

  /*
    Calculate the initial slope for the first non-zero line segment.
    If all vertices have zero slope, we handle zero-length subpaths and return.
  */
  dx.p=0.0;
  dy.p=0.0;
  for (i=1; i < number_vertices; i++)
  {
    dx.p=polygon_primitive[i].point.x-polygon_primitive[0].point.x;
    dy.p=polygon_primitive[i].point.y-polygon_primitive[0].point.y;
    if ((fabs(dx.p) >= MagickEpsilon) || (fabs(dy.p) >= MagickEpsilon))
      break;
  }
  if (i == number_vertices)
    {
      polygon_primitive=(PrimitiveInfo *) RelinquishMagickMemory(polygon_primitive);
      return((PrimitiveInfo *) NULL);
    }

  /*
    Allocate memory for 'path_p' and 'path_q' to store points along the path.
    If allocation fails, release memory and return NULL.
  */
  max_points=6UL*BezierQuantum+360UL+(number_vertices*2UL);
  path_p=(PointInfo *) AcquireQuantumMemory(max_points,sizeof(*path_p));
  if (path_p == (PointInfo *) NULL)
    {
      polygon_primitive=(PrimitiveInfo *) RelinquishMagickMemory(polygon_primitive);
      return((PrimitiveInfo *) NULL);
    }
  path_q=(PointInfo *) AcquireQuantumMemory(max_points,sizeof(*path_q));
  if (path_q == (PointInfo *) NULL)
    {
      path_p=(PointInfo *) RelinquishMagickMemory(path_p);
      polygon_primitive=(PrimitiveInfo *) RelinquishMagickMemory(polygon_primitive);
      return((PrimitiveInfo *) NULL);
    }