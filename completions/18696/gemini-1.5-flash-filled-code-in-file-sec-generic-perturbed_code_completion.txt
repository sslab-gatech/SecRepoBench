PointInfo
    box_p[5],
    box_q[5],
    center,
    degrees,
    dx,
    dy,
    offset,
    theta;

  PrimitiveInfo
    *polygon_primitive;

  PointInfo
    *path_p,
    *path_q;

  LineSegment
    inverse_slope,
    slope;

  double
    delta_theta,
    dot_product,
    mid,
    miterlimit;

  MagickBooleanType
    closed_path;

  register ssize_t
    i,
    n;

  size_t
    arc_segments,
    number_vertices;

  /*
    Trace stroked polygon.
  */
  n=(ssize_t) primitivedata->coordinates-1;
  number_vertices=(size_t) primitivedata->coordinates;
  polygon_primitive=(PrimitiveInfo *) AcquireQuantumMemory((size_t)
    (number_vertices+2UL),sizeof(*polygon_primitive));
  if (polygon_primitive == (PrimitiveInfo *) NULL)
    return((PrimitiveInfo *) NULL);
  (void) memcpy(polygon_primitive,primitivedata,(size_t) number_vertices*
    sizeof(*polygon_primitive));
  closed_path=primitivedata->closed_subpath;
  if (closed_path != MagickFalse)
    number_vertices++;
  polygon_primitive[number_vertices-1].primitive=UndefinedPrimitive;
  dx.p=polygon_primitive[n].point.x-polygon_primitive[0].point.x;
  dy.p=polygon_primitive[n].point.y-polygon_primitive[0].point.y;
  CheckPathExtent(6*BezierQuantum+360);
  path_p=(PointInfo *) AcquireQuantumMemory((size_t) (6*BezierQuantum+360),
    sizeof(*path_p));
  path_q=(PointInfo *) AcquireQuantumMemory((size_t) (6*BezierQuantum+360),
    sizeof(*path_q));