// Define a function to fill in the masked region
function fillMaskedRegion(image, drawInfo, exception) {
  const maskImage = drawInfo.composite_mask;
  const geometry = drawInfo.geometry;
  const geometryInfo = ParseGeometry(geometry);
  const width = geometryInfo.width;
  const height = geometryInfo.height;
  const xOffset = geometryInfo.xOffset;
  const yOffset = geometryInfo.yOffset;

  // Check if the mask image is null or empty
  if (!maskImage || (maskImage.columns == 0) || (maskImage.rows == 0)) {
    return;
  }

  // Get the image dimensions
  const imageWidth = image.columns;
  const imageHeight = image.rows;

  // Calculate the clipping rectangle
  const x1 = MagickMax(xOffset, 0);
  const y1 = MagickMax(yOffset, 0);
  const x2 = MagickMin(xOffset + width, imageWidth);
  const y2 = MagickMin(yOffset + height, imageHeight);

  // Clip the image to the masked region
  const clippedImage = clipImage(image, x1, y1, x2, y2, exception);

  // Composite the clipped image with the original image
  compositeImage(image, clippedImage, OverCompositeOp, exception);
}

// Define a function to clip an image to a specified region
function clipImage(image, x, y, width, height, exception) {
  const clippedImage = cloneImage(0, 0, width, height, image.class, exception);
  const clippedView = acquireAuthenticCacheView(clippedImage, exception);
  const imageView = acquireAuthenticCacheView(image, exception);

  // Copy the pixels from the original image to the clipped image
  for (let y1 = 0; y1 < height; y1++) {
    for (let x1 = 0; x1 < width; x1++) {
      const q = getCacheViewAuthenticPixels(imageView, x1, y1, 1, 1, exception);
      if (q == null) {
        exception.type = ResourceLimitError;
        exception.reason = "MemoryAllocationFailed";
        return null;
      }
      setCacheViewAuthenticPixels(clippedView, x1, y1, q, exception);
    }
  }

  // Release the cache views
  clippedView = destroyCacheView(clippedView);
  imageView = destroyCacheView(imageView);

  return clippedImage;
}