double
    dot_product;

  LineSegment
    dx,
    dy,
    inverse_slope,
    offset,
    slope,
    theta;

  MagickBooleanType
    closed_path;

  PointInfo
    box_p[5],
    box_q[5],
    center;

  PrimitiveInfo
    *polygon_primitive,
    *stroke_polygon;

  register ssize_t
    i,
    n;

  size_t
    arc_segments,
    number_vertices;

  ssize_t
    j,
    p,
    q;

  PointInfo
    *path_p,
    *path_q;

  /*
    Draw stroked polygon.
  */
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(DrawEvent,GetMagickModule(),
      "    begin trace-stroke-polygon");
  number_vertices=(size_t) primitivedata->coordinates;
  polygon_primitive=(PrimitiveInfo *) AcquireQuantumMemory((size_t)
    number_vertices,sizeof(*polygon_primitive));
  if (polygon_primitive == (PrimitiveInfo *) NULL)
    return((PrimitiveInfo *) NULL);
  (void) memcpy(polygon_primitive,primitivedata,(size_t) number_vertices*
    sizeof(*polygon_primitive));
  closed_path=primitivedata->closed_subpath;
  n=0;
  dx.p=0.0;
  dy.p=0.0;
  for (i=1; i < (ssize_t) number_vertices; i++)
  {
    dx.p=polygon_primitive[i].point.x-polygon_primitive[n].point.x;
    dy.p=polygon_primitive[i].point.y-polygon_primitive[n].point.y;
    if ((fabs(dx.p) >= MagickEpsilon) || (fabs(dy.p) >= MagickEpsilon))
      break;
  }
  if (i == (ssize_t) number_vertices)
    {
      if (closed_path == MagickFalse)
        {
          polygon_primitive=(PrimitiveInfo *) RelinquishMagickMemory(
            polygon_primitive);
          return((PrimitiveInfo *) NULL);
        }
      i=(ssize_t) number_vertices-1L;
    }
  path_p=(PointInfo *) AcquireQuantumMemory(2UL*number_vertices+6UL*
    BezierQuantum+360UL,sizeof(*path_p));
  path_q=(PointInfo *) AcquireQuantumMemory(2UL*number_vertices+6UL*
    BezierQuantum+360UL,sizeof(*path_q));

#define CheckPathExtent(pad) \
{ \
  size_t extent=(size_t) (2*number_vertices+pad); \
  if ((p+extent) > path_extent) \
    { \
      path_extent+=extent; \
      path_p=(PointInfo *) ResizeQuantumMemory(path_p,path_extent, \
        sizeof(*path_p)); \
      path_q=(PointInfo *) ResizeQuantumMemory(path_q,path_extent, \
        sizeof(*path_q)); \
      if ((path_p == (PointInfo *) NULL) || (path_q == (PointInfo *) NULL)) \
        { \
          if (path_p != (PointInfo *) NULL) \
            path_p=(PointInfo *) RelinquishMagickMemory(path_p); \
          if (path_q != (PointInfo *) NULL) \
            path_q=(PointInfo *) RelinquishMagickMemory(path_q); \
          polygon_primitive=(PrimitiveInfo *) RelinquishMagickMemory( \
            polygon_primitive); \
          return((PrimitiveInfo *) NULL); \
        } \
    } \
}

  size_t path_extent = 2*number_vertices+6*BezierQuantum+360;
  if (path_p == (PointInfo *) NULL)
    {
      path_q=(PointInfo *) RelinquishMagickMemory(path_q);
      polygon_primitive=(PrimitiveInfo *) RelinquishMagickMemory(
        polygon_primitive);
      return((PrimitiveInfo *) NULL);
    }