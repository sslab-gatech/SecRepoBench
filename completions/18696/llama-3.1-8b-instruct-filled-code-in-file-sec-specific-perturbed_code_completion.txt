static MagickBooleanType TraceStrokePolygon(const Image *image,
  const DrawInfo *draw_info,const PrimitiveInfo *primitivedata)
{
  // Define a macro to check and extend the memory allocation for path arrays if needed.
  #define CheckPathExtent(size) \
  { \
    if (CheckPrimitiveExtent(mvg_info,PrimitiveExtentPad*size) == MagickFalse) \
      return((PrimitiveInfo *) NULL); \
  }

  // Declare necessary structures and variables for line segments and slopes.
  PointInfo
    box_p[4],
    box_q[4],
    center,
    point,
    segment;

  double
    delta_theta,
    dot_product,
    mid,
    miterlimit,
    offset,
    theta;

  double
    slope.p,
    slope.q;

  double
    inverse_slope.p,
    inverse_slope.q;

  double
    dx.p,
    dx.q;

  double
    dy.p,
    dy.q;

  MagickBooleanType
    closed_path;

  MagickBooleanType
    status;

  PointInfo
    *path_p,
    *path_q;

  PrimitiveInfo
    *polygon_primitive,
    *stroke_polygon;

  register PrimitiveInfo
    *p;

  register ssize_t
    i,
    j;

  ssize_t
    n;

  size_t
    arc_segments;

  size_t
    number_vertices;

  number_vertices=(size_t) primitivedata->coordinates;
  if (number_vertices < 3)
    return((PrimitiveInfo *) NULL);
  polygon_primitive=(PrimitiveInfo *) AcquireQuantumMemory((size_t)
    (number_vertices+PrimitiveExtentPad),sizeof(*polygon_primitive));
  if (polygon_primitive == (PrimitiveInfo *) NULL)
    return((PrimitiveInfo *) NULL);
  (void) memset(polygon_primitive,0,sizeof(*polygon_primitive));
  (void) memset(&mvg_info,0,sizeof(mvg_info));
  mvg_info.primitive_info=(&polygon_primitive);
  mvg_info.extent=(&number_vertices);
  mvg_info.exception=exception;
  closed_path=primitivedata->closed_subpath;
  if (closed_path!= MagickFalse)
    number_vertices++;
  status=MagickTrue;
  for (i=0; i < (ssize_t) number_vertices; i++)
  {
    polygon_primitive[i].primitive=primitivedata->primitive;
    polygon_primitive[i].point=primitivedata[i].point;
    polygon_primitive[i].coordinates=1;
    if (i == (ssize_t) number_vertices-1)
      polygon_primitive[i].closed_subpath=closed_path;
  }
  polygon_primitive[number_vertices].primitive=UndefinedPrimitive;
  p=polygon_primitive;
  if (TracePoint(p,primitivedata[0].point) == MagickFalse)
    return((PrimitiveInfo *) NULL);
  p+=p->coordinates;
  if (TracePoint(p,primitivedata[number_vertices-1].point) == MagickFalse)
    return((PrimitiveInfo *) NULL);
  p+=p->coordinates;
  for (i=1; i < (ssize_t) number_vertices; i++)
  {
    dx.p=primitivedata[i].point.x-primitivedata[i-1].point.x;
    dy.p=primitivedata[i].point.y-primitivedata[i-1].point.y;
    if ((fabs((double) dx.p) >= MagickEpsilon) ||
        (fabs((double) dy.p) >= MagickEpsilon))
      break;
  }
  if (i == (ssize_t) number_vertices)
    i=(ssize_t) number_vertices-1L;
  mid=ExpandAffine(&draw_info->affine)*SaneStrokeWidth(image,draw_info)/2.0;
  miterlimit=(double) (draw_info->miterlimit*draw_info->miterlimit*mid*mid);
  if ((draw_info->linecap == SquareCap) && (closed_path == MagickFalse))
    (void) TraceSquareLinecap(polygon_primitive,number_vertices,mid);
  offset.x=sqrt((double) (mid*mid/(inverse_slope.p*inverse_slope.p+1.0)));
  offset.y=(double) (offset.x*inverse_slope.p);
  if ((dy.p*offset.x-dx.p*offset.y) > 0.0)
    {
      box_p[0].x=polygon_primitive[0].point.x-offset.x;
      box_p[0].y=polygon_primitive[0].point.y-offset.x*inverse_slope.p;
      box_p[1].x=polygon_primitive[n].point.x-offset.x;
      box_p[1].y=polygon_primitive[n].point.y-offset.x*inverse_slope.p;
      box_q[0].x=polygon_primitive[0].point.x+offset.x;
      box_q[0].y=polygon_primitive[0].point.y+offset.x*inverse_slope.p;
      box_q[1].x=polygon_primitive[n].point.x+offset.x;
      box_q[1].y=polygon_primitive[n].point.y+offset.x*inverse_slope.p;
    }
  else
    {
      box_p[0].x=polygon_primitive[0].point.x+offset.x;
      box_p[0].y=polygon_primitive[0].point.y+offset.y;
      box_p[1].x=polygon_primitive[n].point.x+offset.x;
      box_p[1].y=polygon_primitive[n].point.y+offset.y;
      box_q[0].x=polygon_primitive[0].point.x-offset.x;
      box_q[0].y=polygon_primitive[0].point.y-offset.y;
      box_q[1].x=polygon_primitive[n].point.x-offset.x;
      box_q[1].y=polygon_primitive[n].point.y-offset.y;
    }
  /*
    Create strokes for the line join attribute: bevel, miter, round.
  */
  p=0;
  q=0;
  path_q[q++]=box_q[0];
  path_p[q++]=box_p[0];
  for (i=(ssize_t) n+1; i < (ssize_t) number_vertices; i++)
  {
    /*
      Compute the slope for this line segment, q.
    */
    dx.q=primitivedata[i].point.x-primitivedata[n].point.x;
    dy.q=primitivedata[i].point.y-primitivedata[n].point.y;
    dot_product=dx.q*dx.q+dy.q*dy.q;
    if (dot_product < 0.25)
      continue;
    slope.q=0.0;
    inverse_slope.q=0.0;
    if (fabs(dx.q) < MagickEpsilon)
      {
        if (dx.q >= 0.0)
          slope.q=dy.q < 0.0? -1.0/MagickEpsilon : 1.0/MagickEpsilon;
        else
          slope.q=dy.q < 0.0? 1.0/MagickEpsilon : -1.0/MagickEpsilon;
      }
    else
      if (fabs(dy.q) < MagickEpsilon)
        {
          if (dy.q >= 0.0)
            inverse_slope.q=dx.q < 0.0? -1.0/MagickEpsilon : 1.0/MagickEpsilon;
          else
            inverse_slope.q=dx.q < 0.0? 1.0/MagickEpsilon : -1.0/MagickEpsilon;
        }
      else
        {
          slope.q=dy.q/dx.q;
          inverse_slope.q=(-1.0/slope.q);
        }
    offset.x=sqrt((double) (mid*mid/(inverse_slope.q*inverse_slope.q+1.0)));
    offset.y=(double) (offset.x*inverse_slope.q);
    dot_product=dy.q*offset.x-dx.q*offset.y;
    if (dot_product > 0.0)
      {
        box_p[2].x=primitivedata[n].point.x-offset.x;
        box_p[2].y=primitivedata[n].point.y-offset.y;
        box_p[3].x=primitivedata[i].point.x-offset.x;
        box_p[3].y=primitivedata[i].point.y-offset.y;
        box_q[2].x=primitivedata[n].point.x+offset.x;
        box_q[2].y=primitivedata[n].point.y+offset.y;
        box_q[3].x=primitivedata[i].point.x+offset.x;
        box_q[3].y=primitivedata[i].point.y+offset.y;
      }
    else
      {
        box_p[2].x=primitivedata[n].point.x+offset.x;
        box_p[2].y=primitivedata[n].point.y+offset.y;
        box_p[3].x=primitivedata[i].point.x+offset.x;
        box_p[3].y=primitivedata[i].point.y+offset.y;
        box_q[2].x=primitivedata[n].point.x-offset.x;
        box_q[2].y=primitivedata[n].point.y-offset.y;
        box_q[3].x=primitivedata[i].point.x-offset.x;
        box_q[3].y=primitivedata[i].point.y-offset.y;
      }
    if (fabs((double) (slope.p-slope.q)) < MagickEpsilon)
      {
        box_p[4]=box_p[1];
        box_q[4]=box_q[1];
      }
    else
      {
        box_p[4].x=(double) ((slope.p*box_p[0].x-box_p[0].y-slope.q*box_p[3].x+
          box_p[3].y)/(slope.p-slope.q));
        box_p[4].y=(double) (slope.p*(box_p[4].x-box_p[0].x)+box_p[0].y);
        box_q[4].x=(double) ((slope.p*box_q[0].x-box_q[0].y-slope.q*box_q[3].x+
          box_q[3].y)/(slope.p-slope.q));
        box_q[4].y=(double) (slope.p*(box_q[4].x-box_q[0].x)+box_q[0].y);
      }
    CheckPathExtent(6*BezierQuantum+360);
    dot_product=dx.q*dy.p-dx.p*dy.q;
    if (dot_product <= 0.0)
      switch (draw_info->linejoin)
      {
        case BevelJoin:
        {
          path_q[q++]=box_q[1];
          path_q[q++]=box_q[2];
          dot_product=(box_q[4].x-box_p[4].x)*(box_q[4].x-box_p[4].x)+
            (box_q[4].y-box_p[4].y)*(box_q[4].y-box_p[4].y);
          if (dot_product <= miterlimit)
            path_p[p++]=box_p[4];
          else
            {
              path_p[p++]=box_p[1];
              path_p[p++]=box_p[2];
            }
          break;
        }
        case MiterJoin:
        {
          dot_product=(box_q[4].x-box_p[4].x)*(box_q[4].x-box_p[4].x)+
            (box_q[4].y-box_p[4].y)*(box_q[4].y-box_p[4].y);
          if (dot_product <= miterlimit)
            {
              path_q[q++]=box_q[4];
              path_p[p++]=box_p[4];
            }
          else
            {
              path_q[q++]=box_q[1];
              path_q[q++]=box_q[2];
              path_p[p++]=box_p[1];
              path_p[p++]=box_p[2];
            }
          break;
        }
        case RoundJoin:
        {
          dot_product=(box_q[4].x-box_p[4].x)*(box_q[4].x-box_p[4].x)+
            (box_q[4].y-box_p[4].y)*(box_q[4].y-box_p[4].y);
          if (dot_product <= miterlimit)
            path_p[p++]=box_p[4];
          else
            {
              path_p[p++]=box_p[1];
              path_p[p++]=box_p[2];
            }
          center=primitivedata[n].point;
          theta.p=atan2(box_q[1].y-center.y,box_q[1].x-center.x);
          theta.q=atan2(box_q[2].y-center.y,box_q[2].x-center.x);
          if (theta.q < theta.p)
            theta.q+=2.0*MagickPI;
          arc_segments=(size_t) ceil((double) ((theta.q-theta.p)/
            (2.0*sqrt((double) (1.0/mid)))));
          CheckPathExtent(arc_segments+6*BezierQuantum+360);
          path_q[q].x=box_q[1].x;
          path_q[q].y=box_q[1].y;
          q++;
          for (j=1; j < (ssize_t) arc_segments; j++)
          {
            delta_theta=(double) (j*(theta.q-theta.p)/arc_segments);
            path_q[q].x=(double) (center.x+mid*cos(fmod((double)
              (theta.p+delta_theta),DegreesToRadians(360.0))));
            path_q[q].y=(double) (center.y+mid*sin(fmod((double)
              (theta.p+delta_theta),DegreesToRadians(360.0))));
            q++;
          }
          path_q[q++]=box_q[2];
          break;
        }
        default:
          break;
      }
    else
      switch (draw_info->linejoin)
      {
        case BevelJoin:
        {
          path_p[p++]=box_p[1];
          path_p[p++]=box_p[2];
          dot_product=(box_q[4].x-box_p[4].x)*(box_q[4].x-box_p[4].x)+
            (box_q[4].y-box_p[4].y)*(box_q[4].y-box_p