typedef struct _LineSegment
{
  double p, q;
} LineSegment;

PointInfo
  box_p[5],
  box_q[5],
  center,
  offset;

LineSegment
  dx,
  dy,
  slope,
  inverse_slope,
  theta;

register ssize_t
  i,
  j,
  n;

size_t
  arc_segments,
  number_vertices;

MagickBooleanType
  closed_path;

double
  delta_theta,
  dot_product,
  mid,
  miterlimit;

PointInfo
  *path_p,
  *path_q;

PrimitiveInfo
  *polygon_primitive,
  *stroke_polygon;

size_t
  p,
  q;

/*
  Allocate memory for polygon primitive.
*/
for (n=0; (primitivedata[n].primitive != UndefinedPrimitive) &&
     (primitivedata[n].point.x == primitivedata[n].point.x); n++) ;
number_vertices=(size_t) n;
polygon_primitive=(PrimitiveInfo *) AcquireQuantumMemory((size_t)
  (n+2UL),sizeof(*polygon_primitive));
if (polygon_primitive == (PrimitiveInfo *) NULL)
  return((PrimitiveInfo *) NULL);
(void) memcpy(polygon_primitive,primitivedata,(size_t) n*
  sizeof(*polygon_primitive));
if (n <= 1)
  {
    polygon_primitive=(PrimitiveInfo *) RelinquishMagickMemory(
      polygon_primitive);
    return((PrimitiveInfo *) NULL);
  }
closed_path=primitivedata[n-1].closed_subpath;
if ((closed_path != MagickFalse) &&
    ((draw_info->linejoin == RoundJoin) || (draw_info->linejoin == MiterJoin)))
  {
    polygon_primitive[n]=polygon_primitive[0];
    n++;
  }
polygon_primitive[n].primitive=UndefinedPrimitive;
/*
  Compute stroke polygon.
*/
n=0;
dx.p=polygon_primitive[1].point.x-polygon_primitive[0].point.x;
dy.p=polygon_primitive[1].point.y-polygon_primitive[0].point.y;
for (i=1; (i < (ssize_t) number_vertices) && (fabs(dx.p) < MagickEpsilon) &&
      (fabs(dy.p) < MagickEpsilon); i++)
{
  dx.p=polygon_primitive[i].point.x-polygon_primitive[0].point.x;
  dy.p=polygon_primitive[i].point.y-polygon_primitive[0].point.y;
}
if (i == (ssize_t) number_vertices)
  {
    polygon_primitive=(PrimitiveInfo *) RelinquishMagickMemory(
      polygon_primitive);
    return((PrimitiveInfo *) NULL);
  }
/*
  Allocate memory for path.
*/
path_p=(PointInfo *) AcquireQuantumMemory((size_t) 6UL*BezierQuantum+360UL,
  sizeof(*path_p));
if (path_p == (PointInfo *) NULL)
  {
    polygon_primitive=(PrimitiveInfo *) RelinquishMagickMemory(
      polygon_primitive);
    return((PrimitiveInfo *) NULL);
  }
path_q=(PointInfo *) AcquireQuantumMemory((size_t) 6UL*BezierQuantum+360UL,
  sizeof(*path_q));