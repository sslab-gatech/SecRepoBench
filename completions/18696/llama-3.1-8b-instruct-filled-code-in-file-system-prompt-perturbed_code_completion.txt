static MagickBooleanType TraceStrokePolygon(const Image *image,
  const DrawInfo *draw_info,const PrimitiveInfo *primitivedata)
{
  // Define a macro to check and extend the memory allocation for path arrays if needed.
  #define CheckPathExtent(n) \
  { \
    if (CheckPrimitiveExtent(mvg_info,n) == MagickFalse) \
      return((PrimitiveInfo *) NULL); \
  }

  // Declare necessary structures and variables for line segments and slopes.
  PointInfo
    box_p[4],
    box_q[4],
    center,
    point,
    segment;

  double
    delta_theta,
    dot_product,
    mid,
    miterlimit,
    offset,
    theta;

  LineSegment
    inverse_slope,
    slope;

  register double
    dx,
    dy;

  register ssize_t
    i,
    j;

  ssize_t
    n;

  size_t
    arc_segments,
    number_vertices;

  // Initialize variables for line properties, such as delta_theta, dot_product, mid, miterlimit.
  miterlimit=(double) (draw_info->miterlimit*draw_info->miterlimit*mid*mid);
  mid=ExpandAffine(&draw_info->affine)*SaneStrokeWidth(image,draw_info)/2.0;

  // Define LineSegment struct to hold slope components p and q.
  typedef struct _LineSegment
  {
    double
      p,
      q;
  } LineSegment;

  // Initialize variables for closed_path status and offsets for points.
  MagickBooleanType
    closed_path;

  ssize_t
    offset;

  // Declare arrays to store point information and initialize path_p and path_q pointers for point paths.
  PointInfo
    *path_p,
    *path_q;

  size_t
    p,
    q;

  // Declare variables to store polygon and stroke information, such as polygon_primitive and stroke_polygon.
  PrimitiveInfo
    *polygon_primitive,
    *stroke_polygon;

  // Allocate memory for polygon_primitive based on the number of vertices in the primitive data.
  number_vertices=(size_t) primitivedata->coordinates;
  polygon_primitive=(PrimitiveInfo *) AcquireQuantumMemory((size_t)
    (number_vertices+2UL),sizeof(*polygon_primitive));
  if (polygon_primitive == (PrimitiveInfo *) NULL)
    return((PrimitiveInfo *) NULL);
  (void) memset(polygon_primitive,0,sizeof(*polygon_primitive));
  (void) memcpy(polygon_primitive,primitivedata,sizeof(*polygon_primitive));
  polygon_primitive->coordinates=(size_t) (number_vertices+1);
  polygon_primitive->closed_subpath=MagickFalse;
  for (i=0; i < (ssize_t) number_vertices; i++)
  {
    polygon_primitive[i].primitive=primitivedata[i].primitive;
    polygon_primitive[i].point=primitivedata[i].point;
  }
  polygon_primitive[i].primitive=UndefinedPrimitive;

  // If the memory allocation fails, return NULL.
  if (polygon_primitive == (PrimitiveInfo *) NULL)
    return((PrimitiveInfo *) NULL);

  // Copy the input primitive data into polygon_primitive.
  (void) memcpy(polygon_primitive,primitivedata,sizeof(*polygon_primitive));
  polygon_primitive->coordinates=(size_t) (number_vertices+1);
  polygon_primitive->closed_subpath=MagickFalse;
  for (i=0; i < (ssize_t) number_vertices; i++)
  {
    polygon_primitive[i].primitive=primitivedata[i].primitive;
    polygon_primitive[i].point=primitivedata[i].point;
  }
  polygon_primitive[i].primitive=UndefinedPrimitive;

  // Determine if the path is closed by checking the closed_subpath field.
  closed_path=polygon_primitive[0].closed_subpath;

  // Adjust number of vertices if closed_path is true and linejoin is RoundJoin or MiterJoin.
  if ((closed_path!= MagickFalse) && ((draw_info->linejoin == RoundJoin) ||
      (draw_info->linejoin == MiterJoin)))
    number_vertices++;

  // Set the last primitive type to UndefinedPrimitive to mark the end of the array.
  polygon_primitive[i].primitive=UndefinedPrimitive;

  // Calculate the initial slope for the first line segment.
  dx.p=polygon_primitive[0].point.x-polygon_primitive[1].point.x;
  dy.p=polygon_primitive[0].point.y-polygon_primitive[1].point.y;
  if ((fabs((double) dx.p) < MagickEpsilon) &&
      (fabs((double) dy.p) < MagickEpsilon))
    {
      slope.p=0.0;
      inverse_slope.p=0.0;
    }
  else
    {
      slope.p=dy.p/dx.p;
      inverse_slope.p=(-1.0/slope.p);
    }

  // Initialize dx and dy to zero, then iterate through vertices to find the first non-zero slope.
  for (i=1; i < (ssize_t) number_vertices; i++)
  {
    dx.q=polygon_primitive[i].point.x-polygon_primitive[0].point.x;
    dy.q=polygon_primitive[i].point.y-polygon_primitive[0].point.y;
    if ((fabs((double) dx.q) >= MagickEpsilon) ||
        (fabs((double) dy.q) >= MagickEpsilon))
      break;
  }
  if (i == (ssize_t) number_vertices)
    i=(ssize_t) number_vertices-1L;

  // If all vertices have zero slope, handle zero-length subpaths appropriately and return.
  if ((fabs((double) dx.q) < MagickEpsilon) &&
      (fabs((double) dy.q) < MagickEpsilon))
    {
      if (closed_path!= MagickFalse)
        {
          polygon_primitive[0].point.x=polygon_primitive[1].point.x;
          polygon_primitive[0].point.y=polygon_primitive[1].point.y;
        }
      return(MagickTrue);
    }

  // Allocate memory for path_p and path_q to store points along the path.
  p=0;
  q=0;
  path_p=(PointInfo *) AcquireQuantumMemory((size_t) (number_vertices+2UL),
    sizeof(*path_p));
  if (path_p == (PointInfo *) NULL)
    {
      polygon_primitive=(PrimitiveInfo *) RelinquishMagickMemory(polygon_primitive);
      return((PrimitiveInfo *) NULL);
    }
  (void) memset(path_p,0,sizeof(*path_p));
  path_q=(PointInfo *) AcquireQuantumMemory((size_t) (number_vertices+2UL),
    sizeof(*path_q));
  if (path_q == (PointInfo *) NULL)
    {
      path_p=(PointInfo *) RelinquishMagickMemory(path_p);
      polygon_primitive=(PrimitiveInfo *) RelinquishMagickMemory(polygon_primitive);
      return((PrimitiveInfo *) NULL);
    }
  (void) memset(path_q,0,sizeof(*path_q));

  // If memory allocation fails for paths, release allocated memory and return NULL.
  if ((path_p == (PointInfo *) NULL) || (path_q == (PointInfo *) NULL))
    {
      if (path_q!= (PointInfo *) NULL)
        path_q=(PointInfo *) RelinquishMagickMemory(path_q);
      if (path_p!= (PointInfo *) NULL)
        path_p=(PointInfo *) RelinquishMagickMemory(path_p);
      polygon_primitive=(PrimitiveInfo *) RelinquishMagickMemory(polygon_primitive);
      return((PrimitiveInfo *) NULL);
    }

  // <MASK>
  if (path_q == (PointInfo *) NULL)
    {
      path_p=(PointInfo *) RelinquishMagickMemory(path_p);
      polygon_primitive=(PrimitiveInfo *) RelinquishMagickMemory(
        polygon_primitive);
      return((PrimitiveInfo *) NULL);
    }
  slope.p=0.0;
  inverse_slope.p=0.0;
  if (fabs(dx.p) < MagickEpsilon)
    {
      if (dx.p >= 0.0)
        slope.p=dy.p < 0.0? -1.0/MagickEpsilon : 1.0/MagickEpsilon;
      else
        slope.p=dy.p < 0.0? 1.0/MagickEpsilon : -1.0/MagickEpsilon;
    }
  else
    if (fabs(dy.p) < MagickEpsilon)
      {
        if (dy.p >= 0.0)
          inverse_slope.p=dx.p < 0.0? -1.0/MagickEpsilon : 1.0/MagickEpsilon;
        else
          inverse_slope.p=dx.p < 0.0? 1.0/MagickEpsilon : -1.0/MagickEpsilon;
      }
    else
      {
        slope.p=dy.p/dx.p;
        inverse_slope.p=(-1.0/slope.p);
      }
  mid=ExpandAffine(&draw_info->affine)*SaneStrokeWidth(image,draw_info)/2.0;
  miterlimit=(double) (draw_info->miterlimit*draw_info->miterlimit*mid*mid);
  if ((draw_info->linecap == SquareCap) && (closed_path == MagickFalse))
    (void) TraceSquareLinecap(polygon_primitive,number_vertices,mid);
  offset.x=sqrt((double) (mid*mid/(inverse_slope.p*inverse_slope.p+1.0)));
  offset.y=(double) (offset.x*inverse_slope.p);
  if ((dy.p*offset.x-dx.p*offset.y) > 0.0)
    {
      box_p[0].x=polygon_primitive[0].point.x-offset.x;
      box_p[0].y=polygon_primitive[0].point.y-offset.x*inverse_slope.p;
      box_p[1].x=polygon_primitive[0].point.x+offset.x;
      box_p[1].y=polygon_primitive[0].point.y+offset.x*inverse_slope.p;
      box_q[0].x=polygon_primitive[0].point.x+offset.x;
      box_q[0].y=polygon_primitive[0].point.y+offset.x*inverse_slope.p;
      box_q[1].x=polygon_primitive[0].point.x-offset.x;
      box_q[1].y=polygon_primitive[0].point.y-offset.x*inverse_slope.p;
    }
  else
    {
      box_p[0].x=polygon_primitive[0].point.x+offset.x;
      box_p[0].y=polygon_primitive[0].point.y+offset.y;
      box_p[1].x=polygon_primitive[0].point.x-offset.x;
      box_p[1].y=polygon_primitive[0].point.y-offset.y;
      box_q[0].x=polygon_primitive[0].point.x-offset.x;
      box_q[0].y=polygon_primitive[0].point.y-offset.y;
      box_q[1].x=polygon_primitive[0].point.x+offset.x;
      box_q[1].y=polygon_primitive[0].point.y+offset.y;
    }
  /*
    Create strokes for the line join attribute: bevel, miter, round.
  */
  p=0;
  q=0;
  path_q[p++]=box_q[0];
  path_p[q++]=box_p[0];
  for (i=(ssize_t) n+1; i < (ssize_t) number_vertices; i++)
  {
    /*
      Compute the slope for this line segment, q.
    */
    dx.q=polygon_primitive[i].point.x-polygon_primitive[n].point.x;
    dy.q=polygon_primitive[i].point.y-polygon_primitive[n].point.y;
    dot_product=dx.q*dx.q+dy.q*dy.q;
    if (dot_product < 0.25)
      continue;
    slope.q=0.0;
    inverse_slope.q=0.0;
    if (fabs(dx.q) < MagickEpsilon)
      {
        if (dx.q >= 0.0)
          slope.q=dy.q < 0.0? -1.0/MagickEpsilon : 1.0/MagickEpsilon;
        else
          slope.q=dy.q < 0.0? 1.0/MagickEpsilon : -1.0/MagickEpsilon;
      }
    else
      if (fabs(dy.q) < MagickEpsilon)
        {
          if (dy.q >= 0.0)
            inverse_slope.q=dx.q < 0.0? -1.0/MagickEpsilon : 1.0/MagickEpsilon;
          else
            inverse_slope.q=dx.q < 0.0? 1.0/MagickEpsilon : -1.0/MagickEpsilon;
        }
      else
        {
          slope.q=dy.q/dx.q;
          inverse_slope.q=(-1.0/slope.q);
        }
    offset.x=sqrt((double) (mid*mid/(inverse_slope.q*inverse_slope.q+1.0)));
    offset.y=(double) (offset.x*inverse_slope.q);
    dot_product=dy.q*offset.x-dx.q*offset.y;
    if (dot_product > 0.0)
      {
        box_p[2].x=polygon_primitive[n].point.x-offset.x;
        box_p[2].y=polygon_primitive[n].point.y-offset.y;
        box_p[3].x=polygon_primitive[i].point.x-offset.x;
        box_p[3].y=polygon_primitive[i].point.y-offset.y;
        box_q[2].x=polygon_primitive[n].point.x+offset.x;
        box_q[2].y=polygon_primitive[n].point.y+offset.y;
        box_q[3].x=polygon_primitive[i].point.x+offset.x;
        box_q[3].y=polygon_primitive[i].point.y+offset.y;
      }
    else
      {
        box_p[2].x=polygon_primitive[n].point.x+offset.x;
        box_p[2].y=polygon_primitive[n].point.y+offset.y;
        box_p[3].x=polygon_primitive[i].point.x+offset.x;
        box_p[3].y=polygon_primitive[i].point.y+offset.y;
        box_q[2].x=polygon_primitive[n].point.x-offset.x;
        box_q[2].y=polygon_primitive[n].point.y-offset.y;