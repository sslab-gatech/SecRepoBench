// Define a macro to check and extend the memory allocation for path arrays if needed.
#define CheckPathExtent(need) \
  if (CheckPrimitiveExtent(mvg_info,need) == MagickFalse) \
    { \
      path_p=(PointInfo *) RelinquishMagickMemory(path_p); \
      path_q=(PointInfo *) RelinquishMagickMemory(path_q); \
      polygon_primitive=(PrimitiveInfo *) RelinquishMagickMemory( \
        polygon_primitive); \
      return((PrimitiveInfo *) NULL); \
    }

// Declare necessary structures and variables for line segments and slopes.
typedef struct _LineSegment
{
  double
    p,
    q;
} LineSegment;

// Initialize variables for line properties, such as delta_theta, dot_product, mid, miterlimit.
double
  delta_theta,
  dot_product,
  mid,
  miterlimit;

// Declare arrays to store point information and initialize path_p and path_q pointers for point paths.
PointInfo
  *path_p,
  *path_q;

// Declare variables to store polygon and stroke information, such as polygon_primitive and stroke_polygon.
PrimitiveInfo
  *polygon_primitive,
  *stroke_polygon;

// Allocate memory for polygon_primitive based on the number of vertices in the primitive data.
polygon_primitive=(PrimitiveInfo *) AcquireQuantumMemory((size_t)
  (number_vertices+1),sizeof(*polygon_primitive));

// If the memory allocation fails, return NULL.
if (polygon_primitive == (PrimitiveInfo *) NULL)
  return((PrimitiveInfo *) NULL);

// Copy the input primitive data into polygon_primitive.
(void) CopyMagickMemory(polygon_primitive,primitivedata,(size_t)
  (number_vertices*sizeof(*primitivedata)));

// Determine if the path is closed by checking the closed_subpath field.
MagickBooleanType
  closed_path;

closed_path=primitivedata[number_vertices-1].closed_subpath;

// Adjust number of vertices if closed_path is true and linejoin is RoundJoin or MiterJoin.
ssize_t
  n,
  number_vertices_adjusted;

number_vertices_adjusted=number_vertices;
if ((closed_path!= MagickFalse) && ((draw_info->linejoin == RoundJoin) ||
  (draw_info->linejoin == MiterJoin)))
  number_vertices_adjusted--;

// Set the last primitive type to UndefinedPrimitive to mark the end of the array.
polygon_primitive[number_vertices].primitive=UndefinedPrimitive;

// Calculate the initial slope for the first line segment.
LineSegment
  slope,
  inverse_slope;

double
  dx,
  dy;

// Initialize dx and dy to zero, then iterate through vertices to find the first non-zero slope.
dx.p=0.0;
dy.p=0.0;
for (n=1; n < (ssize_t) number_vertices; n++)
{
  dx.q=polygon_primitive[n].point.x-polygon_primitive[0].point.x;
  dy.q=polygon_primitive[n].point.y-polygon_primitive[0].point.y;
  if ((fabs(dx.q) >= MagickEpsilon) || (fabs(dy.q) >= MagickEpsilon))
    break;
}

// If all vertices have zero slope, handle zero-length subpaths appropriately and return.
if (n == (ssize_t) number_vertices)
{
  polygon_primitive[0].primitive=PointPrimitive;
  polygon_primitive[0].coordinates=1;
  return(polygon_primitive);
}

// Allocate memory for path_p and path_q to store points along the path.
path_p=(PointInfo *) AcquireQuantumMemory((size_t)
  (6*number_vertices_adjusted+360),sizeof(*path_p));
path_q=(PointInfo *) AcquireQuantumMemory((size_t)
  (6*number_vertices_adjusted+360),sizeof(*path_q));