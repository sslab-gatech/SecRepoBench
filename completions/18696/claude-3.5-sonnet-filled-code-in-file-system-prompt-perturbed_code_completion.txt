LineSegment
    dx,
    dy;

  double
    delta_theta,
    dot_product,
    mid,
    miterlimit;

  MagickBooleanType
    closed_path;

  PointInfo
    box_p[5],
    box_q[5],
    center,
    offset,
    theta;

  PointInfo
    *path_p,
    *path_q;

  PrimitiveInfo
    *polygon_primitive,
    *stroke_polygon;

  register ssize_t
    i,
    n;

  size_t
    arc_segments,
    number_vertices;

  ssize_t
    j,
    p,
    q;

  /*
    Allocate memory for the polygon.
  */
  for (i=0; primitivedata[i].primitive != UndefinedPrimitive; i++) ;
  number_vertices=(size_t) i;
  polygon_primitive=(PrimitiveInfo *) AcquireQuantumMemory((size_t)
    (number_vertices+1UL),sizeof(*polygon_primitive));
  if (polygon_primitive == (PrimitiveInfo *) NULL)
    return((PrimitiveInfo *) NULL);
  (void) memcpy(polygon_primitive,primitivedata,(size_t) number_vertices*
    sizeof(*polygon_primitive));
  polygon_primitive[number_vertices].primitive=UndefinedPrimitive;
  n=0;
  closed_path=MagickFalse;
  if ((polygon_primitive[0].point.x == polygon_primitive[number_vertices-1].point.x) &&
      (polygon_primitive[0].point.y == polygon_primitive[number_vertices-1].point.y))
    {
      closed_path=MagickTrue;
      n=1;
    }
  if ((draw_info->linejoin == RoundJoin) ||
      (draw_info->linejoin == MiterJoin))
    {
      n=3;
      if (closed_path != MagickFalse)
        n=1;
    }
  /*
    Compute the slope for the first line segment, p.
  */
  dx.p=0.0;
  dy.p=0.0;
  for (i=1; i < (ssize_t) number_vertices; i++)
  {
    dx.p=polygon_primitive[n+1].point.x-polygon_primitive[n].point.x;
    dy.p=polygon_primitive[n+1].point.y-polygon_primitive[n].point.y;
    if ((fabs(dx.p) >= MagickEpsilon) || (fabs(dy.p) >= MagickEpsilon))
      break;
    n++;
  }
  if (i == (ssize_t) number_vertices)
    {
      /*
        Degenerate path within the tolerance of rendering a circle.
      */
      n=0;
      i=1;
      dx.p=polygon_primitive[n+1].point.x-polygon_primitive[n].point.x;
      dy.p=polygon_primitive[n+1].point.y-polygon_primitive[n].point.y;
    }
  /*
    Allocate memory for the paths.
  */
  path_p=(PointInfo *) AcquireQuantumMemory((size_t) (6*BezierQuantum+360),
    sizeof(*path_p));
  path_q=(PointInfo *) AcquireQuantumMemory((size_t) (6*BezierQuantum+360),
    sizeof(*path_q));