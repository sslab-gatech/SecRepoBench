#define CheckPathExtent(pad) \
{ \
  size_t extent=(size_t) (p+pad); \
  if (extent >= number_points) \
    { \
      number_points+=extent+1; \
      path_p=(PointInfo *) ResizeQuantumMemory(path_p,number_points, \
        sizeof(*path_p)); \
      path_q=(PointInfo *) ResizeQuantumMemory(path_q,number_points, \
        sizeof(*path_q)); \
      if ((path_p == (PointInfo *) NULL) || (path_q == (PointInfo *) NULL)) \
        { \
          (void) ThrowMagickException(mvg_info->exception,GetMagickModule(), \
            ResourceLimitError,"MemoryAllocationFailed","`%s'",""); \
          status=MagickFalse; \
          break; \
        } \
    } \
}

  LineSegment
    dx = {0.0, 0.0},
    dy = {0.0, 0.0},
    inverse_slope = {0.0, 0.0},
    slope = {0.0, 0.0};

  PointInfo
    box_p[5],
    box_q[5],
    center = {0.0, 0.0},
    offset = {0.0, 0.0},
    theta = {0.0, 0.0};

  PrimitiveInfo
    *polygon_primitive,
    *stroke_polygon;

  register ssize_t
    n;

  size_t
    arc_segments,
    number_points,
    number_vertices;

  ssize_t
    i;

  double
    delta_theta,
    dot_product,
    mid,
    miterlimit;

  PointInfo
    *path_p,
    *path_q;

  MagickBooleanType
    closed_path;

  /*
    Allocate paths.
  */
  number_vertices=(size_t) primitivedata->coordinates;
  polygon_primitive=(PrimitiveInfo *) AcquireQuantumMemory((size_t)
    number_vertices,sizeof(*polygon_primitive));
  if (polygon_primitive == (PrimitiveInfo *) NULL)
    return((PrimitiveInfo *) NULL);
  (void) memcpy(polygon_primitive,primitivedata,(size_t)
    number_vertices*sizeof(*polygon_primitive));
  closed_path=primitivedata->closed_subpath;
  if ((closed_path != MagickFalse) &&
      ((draw_info->linejoin == RoundJoin) ||
       (draw_info->linejoin == MiterJoin)))
    {
      number_vertices++;
      polygon_primitive=(PrimitiveInfo *) ResizeQuantumMemory(polygon_primitive,
        (size_t) number_vertices,sizeof(*polygon_primitive));
      if (polygon_primitive == (PrimitiveInfo *) NULL)
        return((PrimitiveInfo *) NULL);
      polygon_primitive[number_vertices-1]=polygon_primitive[0];
    }
  polygon_primitive[number_vertices].primitive=UndefinedPrimitive;
  number_points=2*number_vertices+6*BezierQuantum+360;
  path_p=(PointInfo *) AcquireQuantumMemory(number_points,sizeof(*path_p));
  path_q=(PointInfo *) AcquireQuantumMemory(number_points,sizeof(*path_q));
  /*
    Compute the slope for the first line segment, p.
  */
  n=0;
  dx.p=polygon_primitive[n+1].point.x-polygon_primitive[n].point.x;
  dy.p=polygon_primitive[n+1].point.y-polygon_primitive[n].point.y;
  for (i=n+2; i < (ssize_t) number_vertices; i++)
  {
    dx.q=polygon_primitive[i].point.x-polygon_primitive[n].point.x;
    dy.q=polygon_primitive[i].point.y-polygon_primitive[n].point.y;
    dot_product=dx.p*dx.q+dy.p*dy.q;
    if (dot_product*dot_product < 0.25*(dx.p*dx.p+dy.p*dy.p)*(dx.q*dx.q+dy.q*dy.q))
      break;
  }
  if (i == (ssize_t) number_vertices)
    i=(ssize_t) number_vertices-1L;
  if (i < 2)
    {
      path_p=(PointInfo *) RelinquishMagickMemory(path_p);
      path_q=(PointInfo *) RelinquishMagickMemory(path_q);
      polygon_primitive=(PrimitiveInfo *) RelinquishMagickMemory(
        polygon_primitive);
      return((PrimitiveInfo *) NULL);
    }
  n=i-1;
  if (path_p == (PointInfo *) NULL)
    {
      path_q=(PointInfo *) RelinquishMagickMemory(path_q);
      polygon_primitive=(PrimitiveInfo *) RelinquishMagickMemory(
        polygon_primitive);
      return((PrimitiveInfo *) NULL);
    }