LineSegment
    dx,
    dy;

  double
    delta_theta,
    dot_product,
    mid,
    miterlimit;

  MagickBooleanType
    closed_path;

  PointInfo
    box_p[5],
    box_q[5],
    center,
    offset,
    *path_p,
    *path_q,
    theta;

  PrimitiveInfo
    *polygon_primitive,
    *stroke_polygon;

  register PrimitiveInfo
    *p;

  register ssize_t
    i,
    j,
    n;

  size_t
    arc_segments,
    number_vertices;

#define CheckPathExtent(extent) \
{ \
  if ((p+extent) >= (size_t) (path_p+path_length)) \
    { \
      size_t \
        path_length; \
      path_length=(size_t) (p-path_p); \
      path_p=(PointInfo *) ResizeQuantumMemory(path_p,2UL*(path_length+extent+ \
        6*BezierQuantum+360),sizeof(*path_p)); \
      if (path_p == (PointInfo *) NULL) \
        { \
          path_q=(PointInfo *) RelinquishMagickMemory(path_q); \
          polygon_primitive=(PrimitiveInfo *) \
            RelinquishMagickMemory(polygon_primitive); \
          return((PrimitiveInfo *) NULL); \
        } \
      p=path_p+path_length; \
    } \
  if ((q+extent) >= (size_t) (path_q+path_length)) \
    { \
      size_t \
        path_length; \
      path_length=(size_t) (q-path_q); \
      path_q=(PointInfo *) ResizeQuantumMemory(path_q,2UL*(path_length+extent+ \
        6*BezierQuantum+360),sizeof(*path_q)); \
      if (path_q == (PointInfo *) NULL) \
        { \
          path_p=(PointInfo *) RelinquishMagickMemory(path_p); \
          polygon_primitive=(PrimitiveInfo *) \
            RelinquishMagickMemory(polygon_primitive); \
          return((PrimitiveInfo *) NULL); \
        } \
      q=path_q+path_length; \
    } \
}

  /*
    Allocate memory for path.
  */
  closed_path=primitivedata->closed_subpath;
  number_vertices=primitivedata->coordinates;
  polygon_primitive=(PrimitiveInfo *) AcquireQuantumMemory((size_t)
    number_vertices+1UL,sizeof(*polygon_primitive));
  if (polygon_primitive == (PrimitiveInfo *) NULL)
    return((PrimitiveInfo *) NULL);
  (void) memcpy(polygon_primitive,primitivedata,(size_t) number_vertices*
    sizeof(*polygon_primitive));
  polygon_primitive[number_vertices].primitive=UndefinedPrimitive;
  n=0;
  if (closed_path != MagickFalse)
    if ((draw_info->linejoin == RoundJoin) || (draw_info->linejoin == MiterJoin))
      {
        /*
          Add last point to polygon_primitive.
        */
        for (i=1; i < (ssize_t) number_vertices; i++)
          if ((fabs(polygon_primitive[0].point.x-
               polygon_primitive[i].point.x) >= MagickEpsilon) ||
              (fabs(polygon_primitive[0].point.y-
               polygon_primitive[i].point.y) >= MagickEpsilon))
            {
              polygon_primitive[number_vertices].point=
                polygon_primitive[0].point;
              polygon_primitive[number_vertices].coordinates=0;
              number_vertices++;
              polygon_primitive[number_vertices].primitive=UndefinedPrimitive;
              break;
            }
      }
  n=0;
  p=polygon_primitive;
  if (((draw_info->linejoin == RoundJoin) || (draw_info->linejoin == MiterJoin)) &&
      (closed_path != MagickFalse))
    p=polygon_primitive+number_vertices-1;
  /*
    Compute the slope for the first line segment, p.
  */
  dx.p=0.0;
  dy.p=0.0;
  for (i=1; i < (ssize_t) number_vertices; i++)
  {
    dx.p=polygon_primitive[i].point.x-polygon_primitive[n].point.x;
    dy.p=polygon_primitive[i].point.y-polygon_primitive[n].point.y;
    if ((fabs(dx.p) >= MagickEpsilon) || (fabs(dy.p) >= MagickEpsilon))
      break;
  }
  if (i == (ssize_t) number_vertices)
    {
      /*
        Zero length subpath.
      */
      stroke_polygon=(PrimitiveInfo *) AcquireQuantumMemory(6UL,
        sizeof(*stroke_polygon));
      if (stroke_polygon == (PrimitiveInfo *) NULL)
        {
          polygon_primitive=(PrimitiveInfo *)
            RelinquishMagickMemory(polygon_primitive);
          return((PrimitiveInfo *) NULL);
        }
      center=polygon_primitive[0].point;
      stroke_polygon[0]=polygon_primitive[0];
      stroke_polygon[0].coordinates=5;
      stroke_polygon[0].primitive=RectanglePrimitive;
      stroke_polygon[0].point.x=(double) (center.x-draw_info->stroke_width/2.0);
      stroke_polygon[0].point.y=(double) (center.y-draw_info->stroke_width/2.0);
      stroke_polygon[1]=stroke_polygon[0];
      stroke_polygon[1].point.x=(double) (center.x+draw_info->stroke_width/2.0);
      stroke_polygon[1].point.y=(double) (center.y-draw_info->stroke_width/2.0);
      stroke_polygon[2]=stroke_polygon[0];
      stroke_polygon[2].point.x=(double) (center.x+draw_info->stroke_width/2.0);
      stroke_polygon[2].point.y=(double) (center.y+draw_info->stroke_width/2.0);
      stroke_polygon[3]=stroke_polygon[0];
      stroke_polygon[3].point.x=(double) (center.x-draw_info->stroke_width/2.0);
      stroke_polygon[3].point.y=(double) (center.y+draw_info->stroke_width/2.0);
      stroke_polygon[4]=stroke_polygon[0];
      stroke_polygon[4].point.x=(double) (center.x-draw_info->stroke_width/2.0);
      stroke_polygon[4].point.y=(double) (center.y-draw_info->stroke_width/2.0);
      stroke_polygon[5].primitive=UndefinedPrimitive;
      polygon_primitive=(PrimitiveInfo *)
        RelinquishMagickMemory(polygon_primitive);
      return(stroke_polygon);
    }
  n=i;
  /*
    Allocate paths.
  */
  path_p=(PointInfo *) AcquireQuantumMemory(2UL*(number_vertices+
    6*BezierQuantum+360),sizeof(*path_p));
  path_q=(PointInfo *) AcquireQuantumMemory(2UL*(number_vertices+
    6*BezierQuantum+360),sizeof(*path_q));