// Define a macro to check and extend the memory allocation for path arrays if needed.
#define CheckPathExtent(extent) \
{ \
  if (mvg_info->offset+extent >= *mvg_info->extent) \
    { \
      if (CheckPrimitiveExtent(mvg_info,extent) == MagickFalse) \
        return(MagickFalse); \
    } \
}

// Declare necessary structures and variables for line segments and slopes.
typedef struct _LineSegment
{
  double
    p,
    q;
} LineSegment;

LineSegment
  slope,
  inverse_slope;

// Initialize variables for line properties, such as delta_theta, dot_product, mid, miterlimit.
double
  delta_theta,
  dot_product,
  mid,
  miterlimit;

// Declare arrays to store point information and initialize path_p and path_q pointers for point paths.
PointInfo
  *path_p,
  *path_q;

// Declare variables to store polygon and stroke information, such as polygon_primitive and stroke_polygon.
PrimitiveInfo
  *polygon_primitive,
  *stroke_polygon;

// Allocate memory for polygon_primitive based on the number of vertices in the primitive data.
polygon_primitive=(PrimitiveInfo *) AcquireQuantumMemory((size_t)
  (number_vertices+1UL),sizeof(*polygon_primitive));
if (polygon_primitive == (PrimitiveInfo *) NULL)
  return((PrimitiveInfo *) NULL);

// Copy the input primitive data into polygon_primitive.
(void) memcpy(polygon_primitive,primitivedata,sizeof(*polygon_primitive)*
  (size_t) number_vertices);

// Determine if the path is closed by checking the closed_subpath field.
MagickBooleanType
  closed_path;

closed_path=primitivedata->closed_subpath;

// Adjust number of vertices if closed_path is true and linejoin is RoundJoin or MiterJoin.
ssize_t
  n,
  number_vertices;

number_vertices=(ssize_t) primitivedata->coordinates;
if ((closed_path!= MagickFalse) &&
    ((draw_info->linejoin == RoundJoin) || (draw_info->linejoin == MiterJoin)))
  number_vertices++;

// Set the last primitive type to UndefinedPrimitive to mark the end of the array.
polygon_primitive[number_vertices].primitive=UndefinedPrimitive;

// Calculate the initial slope for the first line segment.
double
  dx,
  dy;

dx.p=polygon_primitive[1].point.x-polygon_primitive[0].point.x;
dy.p=polygon_primitive[1].point.y-polygon_primitive[0].point.y;

// Initialize dx and dy to zero, then iterate through vertices to find the first non-zero slope.
if ((fabs(dx.p) < MagickEpsilon) && (fabs(dy.p) < MagickEpsilon))
{
  for (n=2; n < (ssize_t) number_vertices; n++)
  {
    dx.p=polygon_primitive[n].point.x-polygon_primitive[n-1].point.x;
    dy.p=polygon_primitive[n].point.y-polygon_primitive[n-1].point.y;
    if ((fabs(dx.p) >= MagickEpsilon) || (fabs(dy.p) >= MagickEpsilon))
      break;
  }
  if (n == (ssize_t) number_vertices)
    n=(ssize_t) number_vertices-1L;
}

// Allocate memory for path_p and path_q to store points along the path.
path_p=(PointInfo *) AcquireQuantumMemory((size_t) (number_vertices+1UL),
  sizeof(*path_p));
path_q=(PointInfo *) AcquireQuantumMemory((size_t) (number_vertices+1UL),
  sizeof(*path_q));

// If memory allocation fails for paths, release allocated memory and return NULL.
if (path_q == (PointInfo *) NULL)
{
  path_p=(PointInfo *) RelinquishMagickMemory(path_p);
  polygon_primitive=(PrimitiveInfo *) RelinquishMagickMemory(
    polygon_primitive);
  return((PrimitiveInfo *) NULL);
}

// Initialize slope.p and inverse_slope.p based on the initial slope.
slope.p=0.0;
inverse_slope.p=0.0;
if (fabs(dx.p) < MagickEpsilon)
{
  if (dx.p >= 0.0)
    slope.p=dy.p < 0.0? -1.0/MagickEpsilon : 1.0/MagickEpsilon;
  else
    slope.p=dy.p < 0.0? 1.0/MagickEpsilon : -1.0/MagickEpsilon;
}
else
  if (fabs(dy.p) < MagickEpsilon)
  {
    if (dy.p >= 0.0)
      inverse_slope.p=dx.p < 0.0? -1.0/MagickEpsilon : 1.0/MagickEpsilon;
    else
      inverse_slope.p=dx.p < 0.0? 1.0/MagickEpsilon : -1.0/MagickEpsilon;
  }
  else
  {
    slope.p=dy.p/dx.p;
    inverse_slope.p=(-1.0/slope.p);
  }

// Calculate mid and miterlimit based on the stroke width and miter limit.
mid=ExpandAffine(&draw_info->affine)*SaneStrokeWidth(image,draw_info)/2.0;
miterlimit=(double) (draw_info->miterlimit*draw_info->miterlimit*mid*mid);

// If the line cap is SquareCap and the path is not closed, adjust the first and last points.
if ((draw_info->linecap == SquareCap) && (closed_path == MagickFalse))
  (void) TraceSquareLinecap(polygon_primitive,number_vertices,mid);

// Calculate the offset for the first line segment.
PointInfo
  offset;

offset.x=sqrt((double) (mid*mid/(inverse_slope.p*inverse_slope.p+1.0)));
offset.y=(double) (offset.x*inverse_slope.p);

// Initialize box_p and box_q to store the points for the first line segment.
PointInfo
  box_p[2],
  box_q[2];

if ((dy.p*offset.x-dx.p*offset.y) > 0.0)
{
  box_p[0].x=polygon_primitive[0].point.x-offset.x;
  box_p[0].y=polygon_primitive[0].point.y-offset.x*inverse_slope.p;
  box_p[1].x=polygon_primitive[n].point.x-offset.x;
  box_p[1].y=polygon_primitive[n].point.y-offset.x*inverse_slope.p;
  box_q[0].x=polygon_primitive[0].point.x+offset.x;
  box_q[0].y=polygon_primitive[0].point.y+offset.x*inverse_slope.p;
  box_q[1].x=polygon_primitive[n].point.x+offset.x;
  box_q[1].y=polygon_primitive[n].point.y+offset.x*inverse_slope.p;
}
else
{
  box_p[0].x=polygon_primitive[0].point.x+offset.x;
  box_p[0].y=polygon_primitive[0].point.y+offset.y;
  box_p[1].x=polygon_primitive[n].point.x+offset.x;
  box_p[1].y=polygon_primitive[n].point.y+offset.y;
  box_q[0].x=polygon_primitive[0].point.x-offset.x;
  box_q[0].y=polygon_primitive[0].point.y-offset.y;
  box_q[1].x=polygon_primitive[n].point.x-offset.x;
  box_q[1].y=polygon_primitive[n].point.y-offset.y;
}

// Create strokes for the line join attribute: bevel, miter, round.
PointInfo
  center,
  theta;

register ssize_t
  i,
  j;

size_t
  arc_segments;

for (i=(ssize_t) n+1; i < (ssize_t) number_vertices; i++)
{
  // Compute the slope for this line segment, q.
  double
    dx_q,
    dy_q;

  dx_q=polygon_primitive[i].point.x-polygon_primitive[n].point.x;
  dy_q=polygon_primitive[i].point.y-polygon_primitive[n].point.y;
  dot_product=dx_q*dx_q+dy_q*dy_q;
  if (dot_product < 0.25)
    continue;
  slope.q=0.0;
  inverse_slope.q=0.0;
  if (fabs(dx_q) < MagickEpsilon)
  {
    if (dx_q >= 0.0)
      slope.q=dy_q < 0.0? -1.0/MagickEpsilon : 1.0/MagickEpsilon;
    else
      slope.q=dy_q < 0.0? 1.0/MagickEpsilon : -1.0/MagickEpsilon;
  }
  else
    if (fabs(dy_q) < MagickEpsilon)
    {
      if (dy_q >= 0.0)
        inverse_slope.q=dx_q < 0.0? -1.0/MagickEpsilon : 1.0/MagickEpsilon;
      else
        inverse_slope.q=dx_q < 0.0? 1.0/MagickEpsilon : -1.0/MagickEpsilon;
    }
    else
    {
      slope.q=dy_q/dx_q;
      inverse_slope.q=(-1.0/slope.q);
    }
  offset.x=sqrt((double) (mid*mid/(inverse_slope.q*inverse_slope.q+1.0)));
  offset.y=(double) (offset.x*inverse_slope.q);
  dot_product=dy_q*offset.x-dx_q*offset.y;
  if (dot_product > 0.0)
  {
    box_p[2].x=polygon_primitive[n].point.x-offset.x;
    box_p[2].y=polygon_primitive[n].point.y-offset.y;
    box_p[3].x=polygon_primitive[i].point.x-offset.x;
    box_p[3].y=polygon_primitive[i].point.y-offset.y;
    box_q[2].x=polygon_primitive[n].point.x+offset.x;
    box_q[2].y=polygon_primitive[n].point.y+offset.y;
    box_q[3].x=polygon_primitive[i].point.x+offset.x;
    box_q[3].y=polygon_primitive[i].point.y+offset.y;
  }
  else
  {
    box_p[2].x=polygon_primitive[n].point.x+offset.x;
    box_p[2].y=polygon_primitive[n].point.y+offset.y;
    box_p[3].x=polygon_primitive[i].point.x+offset.x;
    box_p[3].y=polygon_primitive[i].point.y+offset.y;
    box_q[2].x=polygon_primitive[n].point.x-offset.x;
    box_q[2].y=polygon_primitive[n].point.y-offset.y;
    box_q[3].x=polygon_primitive[i].point.x-offset.x;
    box_q[3].y=polygon_primitive[i].point.y-offset.y;
  }
  if (fabs((double) (slope.p-slope.q)) < MagickEpsilon)
  {
    box_p[4]=box_p[1];
    box_q[4]=box_q[1];
  }
  else
  {
    box_p[4].x=(double) ((slope.p*box_p[0].x-box_p[0].y-slope.q*box_p[3].x+
      box_p[3].y)/(slope.p-slope.q));
    box_p[4].y=(double) (slope.p*(box_p[4].x-box_p[0].x)+box_p[0].y);
    box_q[4].x=(double) ((slope.p*box_q[0].x-box_q[0].y-slope.q*box_q[3].x+
      box_q[3].y)/(slope.p-slope.q));
    box_q[4].y=(double) (slope.p*(box_q[4].x-box_q[0].x)+box_q[0].y);
  }
  CheckPathExtent(6*BezierQuantum+360);
  dot_product=dx_q*dy.p-dx.p*dy_q;
  if (dot_product <= 0.0)
    switch (draw_info->linejoin)
    {
      case BevelJoin:
      {
        path_q[q++]=box_q[1];
        path_q[q++]=box_q[2];
        dot_product=(box_q[4].x-box_p[4].x)*(box_q[4].x-box_p[4].x)+
          (box_q[4].y-box_p[4].y)*(box_q[4].y-box_p[4].y);
        if (dot_product <= miterlimit)
          path_p[p++]=box_p[4];
        else
        {
          path_p[p++]=box_p[1];
          path_p[p++]=box_p[2];
        }
        break;
      }
      case MiterJoin:
      {
        dot_product=(box_q[4].x-box_p[4].x)*(box_q[4].x-box_p[4].x)+
          (box_q[4].y-box_p[4].y)*(box_q[4].y-box_p[4].y);
        if (dot_product <= miterlimit)
        {
          path_q[q++]=box_q[4];
          path_p[p++]=box_p[4];
        }
        else
        {
          path_q[q++]=box_q[1];
          path_q[q++]=box_q[2];
          path_p[p++]=box_p[1];
          path_p[p++]=box_p[2];
        }
        break;
      }
      case RoundJoin:
      {
        dot_product=(box_q[4].x-box_p[4].x)*(box_q[4].x-box_p[4].x)+
          (box_q[4].y-box_p[4].y)*(box_q[4].y-box_p[4].y);
        if (dot_product <= miterlimit)
          path_p[p++]=box_p[4];
        else
        {
          path_p[p++]=box_p[1];
          path_p[p++]=box_p[2];
        }
        center=polygon_primitive[n].point;
        theta.p=atan2(box_q[1].y-center.y,box_q[1].x-center.x);
        theta.q=atan2(box_q[2].y-center.y,box_q[2].x-center.