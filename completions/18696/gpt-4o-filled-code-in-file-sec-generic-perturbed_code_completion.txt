#define CheckPathExtent(pad) \
{ \
  if ((p+pad) > (ssize_t) path_extent) \
    { \
      path_extent+=MagickMax((size_t) 256,2*pad); \
      path_p=(PointInfo *) ResizeQuantumMemory(path_p,path_extent, \
        sizeof(*path_p)); \
      path_q=(PointInfo *) ResizeQuantumMemory(path_q,path_extent, \
        sizeof(*path_q)); \
      if ((path_p == (PointInfo *) NULL) || (path_q == (PointInfo *) NULL)) \
        { \
          polygon_primitive=(PrimitiveInfo *) RelinquishMagickMemory( \
            polygon_primitive); \
          return((PrimitiveInfo *) NULL); \
        } \
    } \
}

typedef struct _LineSegment
{
  double
    p,
    q;
} LineSegment;

LineSegment
  dx,
  dy,
  inverse_slope,
  slope;

double
  delta_theta,
  dot_product,
  mid,
  miterlimit;

PointInfo
  box_p[5],
  box_q[5],
  center,
  offset,
  *path_p,
  *path_q,
  *path_r,
  *path_s,
  *path_t,
  *path_u,
  *path_v;

MagickBooleanType
  closed_path;

PrimitiveInfo
  *polygon_primitive,
  *stroke_polygon;

size_t
  arc_segments,
  number_vertices,
  path_extent;

ssize_t
  i,
  j,
  n,
  p,
  q;

Theta
  theta;

number_vertices=0;
for (i=0; primitivdata[i].primitive != UndefinedPrimitive; i++)
  number_vertices++;
polygon_primitive=(PrimitiveInfo *) AcquireQuantumMemory((size_t)
  (number_vertices+2UL),sizeof(*polygon_primitive));
if (polygon_primitive == (PrimitiveInfo *) NULL)
  return((PrimitiveInfo *) NULL);
(void) memcpy(polygon_primitive,primitivedata,(size_t) number_vertices*
  sizeof(*polygon_primitive));
closed_path=polygon_primitive[0].closed_subpath;
if ((closed_path != MagickFalse) && ((draw_info->linejoin == RoundJoin) ||
    (draw_info->linejoin == MiterJoin)))
  number_vertices++;
polygon_primitive[number_vertices].primitive=UndefinedPrimitive;
dx.p=0.0;
dy.p=0.0;
for (n=0; n < (ssize_t) number_vertices; n++)
{
  dx.p=polygon_primitive[n+1].point.x-polygon_primitive[n].point.x;
  dy.p=polygon_primitive[n+1].point.y-polygon_primitive[n].point.y;
  if ((fabs(dx.p) >= MagickEpsilon) || (fabs(dy.p) >= MagickEpsilon))
    break;
}
if (n == (ssize_t) number_vertices)
  {
    polygon_primitive=(PrimitiveInfo *) RelinquishMagickMemory(
      polygon_primitive);
    return((PrimitiveInfo *) NULL);
  }
path_extent=number_vertices+6*BezierQuantum+360;
path_p=(PointInfo *) AcquireQuantumMemory(path_extent,sizeof(*path_p));
path_q=(PointInfo *) AcquireQuantumMemory(path_extent,sizeof(*path_q));