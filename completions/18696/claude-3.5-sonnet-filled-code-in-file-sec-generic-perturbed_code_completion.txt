#define CheckPathExtent(extent) \
  if ((p+extent) >= number_points) \
    { \
      number_points+=extent+MagickPathExtent; \
      path_p=(PointInfo *) ResizeQuantumMemory(path_p,number_points, \
        sizeof(*path_p)); \
      path_q=(PointInfo *) ResizeQuantumMemory(path_q,number_points, \
        sizeof(*path_q)); \
      if ((path_p == (PointInfo *) NULL) || (path_q == (PointInfo *) NULL)) \
        { \
          if (path_p != (PointInfo *) NULL) \
            path_p=(PointInfo *) RelinquishMagickMemory(path_p); \
          if (path_q != (PointInfo *) NULL) \
            path_q=(PointInfo *) RelinquishMagickMemory(path_q); \
          polygon_primitive=(PrimitiveInfo *) \
            RelinquishMagickMemory(polygon_primitive); \
          return((PrimitiveInfo *) NULL); \
        } \
    }

  typedef struct _LineSegment
  {
    double
      p,
      q;
  } LineSegment;

  LineSegment
    dx,
    dy,
    inverse_slope,
    slope;

  MagickBooleanType
    closed_path;

  PointInfo
    box_p[5],
    box_q[5],
    center,
    offset,
    *path_p,
    *path_q;

  double
    delta_theta,
    dot_product,
    mid,
    miterlimit;

  PrimitiveInfo
    *polygon_primitive,
    *stroke_polygon;

  register ssize_t
    i;

  size_t
    arc_segments,
    number_vertices;

  ssize_t
    j,
    n,
    p,
    q;

  LineSegment
    theta;

  number_vertices=primitivedata->coordinates;
  polygon_primitive=(PrimitiveInfo *) AcquireQuantumMemory((size_t)
    number_vertices+1UL,sizeof(*polygon_primitive));
  if (polygon_primitive == (PrimitiveInfo *) NULL)
    return((PrimitiveInfo *) NULL);
  (void) memcpy(polygon_primitive,primitivedata,(size_t) number_vertices*
    sizeof(*polygon_primitive));
  closed_path=primitivedata->closed_subpath;
  if ((draw_info->linejoin == RoundJoin) ||
      (draw_info->linejoin == MiterJoin))
    {
      if (closed_path != MagickFalse)
        {
          polygon_primitive[number_vertices]=polygon_primitive[0];
          number_vertices++;
        }
      polygon_primitive[number_vertices].primitive=UndefinedPrimitive;
    }
  n=0;
  path_p=(PointInfo *) NULL;
  path_q=(PointInfo *) NULL;
  for (i=1; i < (ssize_t) number_vertices; i++)
  {
    dx.p=polygon_primitive[n+1].point.x-polygon_primitive[n].point.x;
    dy.p=polygon_primitive[n+1].point.y-polygon_primitive[n].y;
    if ((fabs(dx.p) >= MagickEpsilon) || (fabs(dy.p) >= MagickEpsilon))
      break;
    n++;
  }
  if (i == (ssize_t) number_vertices)
    {
      size_t
        extent;

      extent=6*BezierQuantum+360;
      extent=MagickMax(extent,2*number_vertices);
      path_p=(PointInfo *) AcquireQuantumMemory(extent,sizeof(*path_p));
      path_q=(PointInfo *) AcquireQuantumMemory(extent,sizeof(*path_q));
      if ((path_p == (PointInfo *) NULL) || (path_q == (PointInfo *) NULL))
        {
          if (path_p != (PointInfo *) NULL)
            path_p=(PointInfo *) RelinquishMagickMemory(path_p);
          if (path_q != (PointInfo *) NULL)
            path_q=(PointInfo *) RelinquishMagickMemory(path_q);
          polygon_primitive=(PrimitiveInfo *) RelinquishMagickMemory(
            polygon_primitive);
          return((PrimitiveInfo *) NULL);
        }
      switch (draw_info->linecap)
      {
        case RoundCap:
        {
          center=polygon_primitive[n].point;
          path_p[0].x=center.x+mid;
          path_p[0].y=center.y;
          path_q[0].x=center.x-mid;
          path_q[0].y=center.y;
          for (j=1; j < 180; j++)
          {
            path_p[j].x=center.x+mid*cos(DegreesToRadians((double) j));
            path_p[j].y=center.y+mid*sin(DegreesToRadians((double) j));
            path_q[j].x=center.x-mid*cos(DegreesToRadians((double) j));
            path_q[j].y=center.y-mid*sin(DegreesToRadians((double) j));
          }
          break;
        }
        case SquareCap:
        {
          path_p[0]=polygon_primitive[n].point;
          path_p[1].x=polygon_primitive[n].point.x+mid;
          path_p[1].y=polygon_primitive[n].point.y+mid;
          path_p[2].x=polygon_primitive[n].point.x-mid;
          path_p[2].y=polygon_primitive[n].point.y+mid;
          path_p[3]=polygon_primitive[n].point;
          path_q[0]=polygon_primitive[n].point;
          path_q[1].x=polygon_primitive[n].point.x-mid;
          path_q[1].y=polygon_primitive[n].point.y-mid;
          path_q[2].x=polygon_primitive[n].point.x+mid;
          path_q[2].y=polygon_primitive[n].point.y-mid;
          path_q[3]=polygon_primitive[n].point;
          break;
        }
        case ButtCap:
        default:
        {
          path_p[0]=polygon_primitive[n].point;
          path_p[1].x=polygon_primitive[n].point.x+mid;
          path_p[1].y=polygon_primitive[n].point.y;
          path_p[2].x=polygon_primitive[n].point.x-mid;
          path_p[2].y=polygon_primitive[n].point.y;
          path_p[3]=polygon_primitive[n].point;
          path_q[0]=polygon_primitive[n].point;
          path_q[1].x=polygon_primitive[n].point.x-mid;
          path_q[1].y=polygon_primitive[n].point.y;
          path_q[2].x=polygon_primitive[n].point.x+mid;
          path_q[2].y=polygon_primitive[n].point.y;
          path_q[3]=polygon_primitive[n].point;
          break;
        }
      }
      polygon_primitive[0].coordinates=(size_t) (2*j);
      stroke_polygon=(PrimitiveInfo *) AcquireQuantumMemory((size_t)
        polygon_primitive[0].coordinates+1UL,sizeof(*stroke_polygon));
      if (stroke_polygon != (PrimitiveInfo *) NULL)
        {
          for (i=0; i < (ssize_t) j; i++)
          {
            stroke_polygon[i]=polygon_primitive[0];
            stroke_polygon[i].point=path_p[i];
          }
          for ( ; i < (ssize_t) (2*j); i++)
          {
            stroke_polygon[i]=polygon_primitive[0];
            stroke_polygon[i].point=path_q[2*j-(i+1)];
          }
          stroke_polygon[i]=polygon_primitive[0];
          stroke_polygon[i].point=stroke_polygon[0].point;
          stroke_polygon[i+1].primitive=UndefinedPrimitive;
        }
      path_p=(PointInfo *) RelinquishMagickMemory(path_p);
      path_q=(PointInfo *) RelinquishMagickMemory(path_q);
      polygon_primitive=(PrimitiveInfo *) RelinquishMagickMemory(
        polygon_primitive);
      return(stroke_polygon);
    }