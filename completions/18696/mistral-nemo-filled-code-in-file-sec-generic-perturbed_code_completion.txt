// Define a function to fill in the masked region
function fillMaskedRegion(image, drawInfo, exception) {
  const maskImage = drawInfo.composite_mask;
  const geometry = drawInfo.geometry;
  const geometryInfo = parseGeometry(geometry);
  const width = geometryInfo.width;
  const height = geometryInfo.height;
  const xOffset = geometryInfo.xOffset;
  const yOffset = geometryInfo.yOffset;

  // Check if the mask image is null or empty
  if (!maskImage || (maskImage.columns == 0 && maskImage.rows == 0)) {
    return;
  }

  // Get the image dimensions
  const imageWidth = image.columns;
  const imageHeight = image.rows;

  // Calculate the clipping rectangle
  const clipRect = {
    x: Math.max(0, Math.min(xOffset, imageWidth - width)),
    y: Math.max(0, Math.min(yOffset, imageHeight - height)),
    width: Math.min(width, imageWidth - xOffset),
    height: Math.min(height, imageHeight - yOffset)
  };

  // Get the image pixels
  const imagePixels = getImagePixels(image, clipRect.x, clipRect.y, clipRect.width, clipRect.height);

  // Get the mask image pixels
  const maskPixels = getImagePixels(maskImage, 0, 0, maskImage.columns, maskImage.rows);

  // Fill in the masked region
  for (let y = 0; y < clipRect.height; y++) {
    for (let x = 0; x < clipRect.width; x++) {
      const maskPixel = maskPixels[(y * maskImage.columns) + x];
      if (maskPixel.alpha === 0) {
        // The pixel is masked, so skip it
        continue;
      }
      const imagePixel = imagePixels[(y * imageWidth) + x];
      imagePixel.red = maskPixel.red;
      imagePixel.green = maskPixel.green;
      imagePixel.blue = maskPixel.blue;
      imagePixel.alpha = maskPixel.alpha;
    }
  }

  // Release the image and mask pixels
  imagePixels = null;
  maskPixels = null;
}

// Call the function to fill in the masked region
fillMaskedRegion(image, drawInfo, exception);