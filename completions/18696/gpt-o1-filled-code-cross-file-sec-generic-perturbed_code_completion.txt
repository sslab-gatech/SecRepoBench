/*
    Initialize dx, dy to find the first non-zero slope.
    If all slopes are zero, handle zero-length subpath.
  */
  dx.p=0.0;
  dy.p=0.0;
  for (i=1; i < (ssize_t) number_vertices; i++)
  {
    dx.p=polygon_primitive[i].point.x - polygon_primitive[0].point.x;
    dy.p=polygon_primitive[i].point.y - polygon_primitive[0].point.y;
    if ((fabs(dx.p) >= MagickEpsilon) || (fabs(dy.p) >= MagickEpsilon))
      break;
  }
  if ((fabs(dx.p) < MagickEpsilon) && (fabs(dy.p) < MagickEpsilon))
    {
      /*
        Zero-length subpath, so there's no stroke to trace.
      */
      polygon_primitive=(PrimitiveInfo *) RelinquishMagickMemory(polygon_primitive);
      return((PrimitiveInfo *) NULL);
    }

  /*
    Allocate memory for path_p and path_q to store points along the stroke.
  */
  path_p=(PointInfo *) AcquireQuantumMemory((size_t) (number_vertices*4),
    sizeof(*path_p));
  if (path_p == (PointInfo *) NULL)
    {
      polygon_primitive=(PrimitiveInfo *) RelinquishMagickMemory(polygon_primitive);
      return((PrimitiveInfo *) NULL);
    }
  path_q=(PointInfo *) AcquireQuantumMemory((size_t) (number_vertices*4),
    sizeof(*path_q));