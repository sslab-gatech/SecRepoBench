// Allocate memory for path_p and path_q to store points along the path.
size_t padding = 100;  // Additional padding for safety
path_p = (PointInfo *) AcquireQuantumMemory(number_vertices + padding, sizeof(*path_p));
if (path_p == (PointInfo *) NULL)
{
  polygon_primitive = (PrimitiveInfo *) RelinquishMagickMemory(polygon_primitive);
  return((PrimitiveInfo *) NULL);
}

path_q = (PointInfo *) AcquireQuantumMemory(number_vertices + padding, sizeof(*path_q));
if (path_q == (PointInfo *) NULL)
{
  path_p = (PointInfo *) RelinquishMagickMemory(path_p);
  polygon_primitive = (PrimitiveInfo *) RelinquishMagickMemory(polygon_primitive);
  return((PrimitiveInfo *) NULL);
}

// Initialize variables for slope calculations
LineSegment slope, inverse_slope;
PointInfo dx, dy;
dx.p = dy.p = 0.0;

// Find the first non-zero slope
for (i = 1; i < (ssize_t) number_vertices; i++)
{
  dx.p = polygon_primitive[i].point.x - polygon_primitive[0].point.x;
  dy.p = polygon_primitive[i].point.y - polygon_primitive[0].point.y;
  if ((fabs(dx.p) >= MagickEpsilon) || (fabs(dy.p) >= MagickEpsilon))
    break;
}

// Handle zero-length subpaths
if (i == (ssize_t) number_vertices)
{
  path_p = (PointInfo *) RelinquishMagickMemory(path_p);
  path_q = (PointInfo *) RelinquishMagickMemory(path_q);
  polygon_primitive = (PrimitiveInfo *) RelinquishMagickMemory(polygon_primitive);
  return((PrimitiveInfo *) NULL);
}

// Set the number of vertices for further processing
n = (size_t) i;