Below is the content of a C/C++ function where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
static mrb_int
cmpnum(mrb_state *mrb, mrb_value v1, mrb_value value)
{
// Compare two numerical values in the context of a Ruby-like environment.
// Check if either value is a big integer and handle this case separately using a specific comparison function for big integers.
// Determine the type of the first value and convert it into a numerical form suitable for comparison.
// Decide the type of variables x and y based on whether floating-point support is enabled, using integers if floating-point is disabled.
// Store the converted numerical value of the first value into the variable x for further comparison with the second value.
// <MASK>
  switch (mrb_type(value)) {
  case MRB_TT_INTEGER:
#ifdef MRB_NO_FLOAT
    y = mrb_integer(value);
#else
    y = (mrb_float)mrb_integer(value);
#endif
    break;
#ifndef MRB_NO_FLOAT
  case MRB_TT_FLOAT:
    y = mrb_float(value);
    break;
#ifdef MRB_USE_RATIONAL
  case MRB_TT_RATIONAL:
    y = mrb_as_float(mrb, value);
    break;
#endif
#endif
  default:
    return -2;
  }
  if (x > y)
    return 1;
  else {
    if (x < y)
      return -1;
    return 0;
  }
}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// mrbgems/mruby-rational/src/rational.c
static mrb_value
rational_cmp(mrb_state *mrb, mrb_value x)
{
  struct mrb_rational *p1 = rational_ptr(mrb, x);
  mrb_value y = mrb_get_arg1(mrb);

  switch(mrb_type(y)) {
  case MRB_TT_RATIONAL:
    {
      struct mrb_rational *p2 = rational_ptr(mrb, y);
      mrb_int a, b;

      if (mrb_int_mul_overflow(p1->numerator, p2->denominator, &a) ||
          mrb_int_mul_overflow(p1->denominator, p2->numerator, &b)) {
        return mrb_nil_value();
      }
      if (a > b)
        return mrb_fixnum_value(1);
      else if (a < b)
        return mrb_fixnum_value(-1);
      return mrb_fixnum_value(0);
    }
  case MRB_TT_INTEGER:
#ifndef MRB_NO_FLOAT
  case MRB_TT_FLOAT:
    {
      mrb_float a = rat_float(p1), b = mrb_as_float(mrb, y);
      if (a > b)
        return mrb_fixnum_value(1);
      else if (a < b)
        return mrb_fixnum_value(-1);
      return mrb_fixnum_value(0);
    }
#else
    {
      mrb_int a = p1->numerator, b;
      if (mrb_int_mul_overflow(p1->denominator, mrb_integer(y), &b)) {
        return mrb_nil_value();
      }
      if (a > b)
        return mrb_fixnum_value(1);
      else if (a < b)
        return mrb_fixnum_value(-1);
      return mrb_fixnum_value(0);
    }
#endif
  default:
    x = mrb_funcall_id(mrb, y, MRB_OPSYM(cmp), 1, x);
    if (mrb_integer_p(x)) {
      mrb_int z = mrb_integer(x);
      return mrb_fixnum_value(-z);
    }
    return mrb_nil_value();
 }
}

// the below code fragment can be found in:
// src/numeric.c
static mrb_value
int_equal(mrb_state *mrb, mrb_value x)
{
  mrb_value y = mrb_get_arg1(mrb);

  switch (mrb_type(y)) {
  case MRB_TT_INTEGER:
    return mrb_bool_value(mrb_integer(x) == mrb_integer(y));
#ifndef MRB_NO_FLOAT
  case MRB_TT_FLOAT:
    return mrb_bool_value((mrb_float)mrb_integer(x) == mrb_float(y));
#endif
#ifdef MRB_USE_BIGINT
  case MRB_TT_BIGINT:
    return mrb_bool_value(mrb_bint_cmp(mrb, y, x) == 0);
#endif
#ifdef MRB_USE_RATIONAL
  case MRB_TT_RATIONAL:
    return mrb_bool_value(mrb_equal(mrb, y, x));
#endif
#ifdef MRB_USE_COMPLEX
  case MRB_TT_COMPLEX:
    return mrb_bool_value(mrb_equal(mrb, y, x));
#endif
  default:
    return mrb_false_value();
  }
}

// the below code fragment can be found in:
// src/numeric.c
static mrb_value
flo_eq(mrb_state *mrb, mrb_value x)
{
  mrb_value y = mrb_get_arg1(mrb);

  switch (mrb_type(y)) {
  case MRB_TT_INTEGER:
    return mrb_bool_value(mrb_float(x) == (mrb_float)mrb_integer(y));
  case MRB_TT_FLOAT:
    return mrb_bool_value(mrb_float(x) == mrb_float(y));
#ifdef MRB_USE_RATIONAL
  case MRB_TT_RATIONAL:
    return mrb_bool_value(mrb_float(x) == mrb_as_float(mrb, y));
#endif
#ifdef MRB_USE_COMPLEX
  case MRB_TT_COMPLEX:
    return mrb_bool_value(mrb_equal(mrb, y, x));
#endif
  default:
    return mrb_false_value();
  }
}

// the below code fragment can be found in:
// src/numeric.c
static mrb_value
int_eql(mrb_state *mrb, mrb_value x)
{
  mrb_value y = mrb_get_arg1(mrb);

#ifdef MRB_USE_BIGINT
  if (mrb_bigint_p(x)) {
    return mrb_bool_value(mrb_bint_cmp(mrb, x, y) == 0);
  }
#endif
  if (!mrb_integer_p(y)) return mrb_false_value();
  return mrb_bool_value(mrb_integer(x) == mrb_integer(y));
}

// the below code fragment can be found in:
// mrbgems/mruby-bigint/core/bigint.c
mrb_int
mrb_bint_cmp(mrb_state *mrb, mrb_value x, mrb_value y)
{
#ifndef MRB_NO_FLOAT
  if (mrb_float_p(y)) {
    mrb_float v1 = mrb_bint_as_float(mrb, x);
    mrb_float v2 = mrb_float(y);
    if (v1 == v2) return 0;
    if (v1 > v2)  return 1;
    return -1;
  }
#endif
  struct RBigint *b = RBIGINT(x);
  if (!mrb_bigint_p(y)) {
    if (!mrb_integer_p(y)) return -2; /* type mismatch */

    mrb_int i1, i2 = mrb_integer(y);
    if (mpz_get_int(&b->mp, &i1)) {
      if (i1 == i2) return 0;
      if (i1 > i2) return 1;
      return -1;
    }
    if (b->mp.sn > 0) return 1;
    return -1;
  }
  struct RBigint *b2 = RBIGINT(y);
  return mpz_cmp(mrb, &b->mp, &b2->mp);
}
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).