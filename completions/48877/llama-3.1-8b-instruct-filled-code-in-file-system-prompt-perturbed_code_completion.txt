static mrb_value
int_div(mrb_state *mrb, mrb_value x)
{
#ifdef MRB_USE_BIGINT
  if (mrb_bigint_p(x)) {
    return mrb_bint_div(mrb, x, mrb_get_arg1(mrb));
  }
#endif
  mrb_int a = mrb_integer(x);

  if (mrb_integer_p(mrb_get_arg1(mrb))) {
    mrb_int b = mrb_integer(mrb_get_arg1(mrb));
#ifdef MRB_USE_BIGINT
    if(a == MRB_INT_MIN && b == -1) {
      return mrb_bint_mul_ii(mrb, a, b);
    }
#endif
    mrb_int div = mrb_div_int(mrb, a, b);
    return mrb_int_value(mrb, div);
  }
  switch (mrb_type(mrb_get_arg1(mrb))) {
#ifdef MRB_USE_BIGINT
  case MRB_TT_BIGINT:
    return mrb_bint_div(mrb, mrb_bint_new_int(mrb, a), mrb_get_arg1(mrb));
#endif
#ifdef MRB_USE_RATIONAL
  case MRB_TT_RATIONAL:
    return mrb_rational_div(mrb, mrb_rational_new(mrb, a, 1), mrb_get_arg1(mrb));
#endif
#ifdef MRB_USE_COMPLEX
  case MRB_TT_COMPLEX:
    x = mrb_complex_new(mrb, (mrb_float)a, 0);
    return mrb_complex_div(mrb, x, mrb_get_arg1(mrb));
#endif
  default:
#ifdef MRB_NO_FLOAT
    mrb_raise(mrb, E_TYPE_ERROR, "non integer division");
#else
    return mrb_float_value(mrb, mrb_div_float((mrb_float)a, mrb_as_float(mrb, mrb_get_arg1(mrb))));
#endif
  }
}