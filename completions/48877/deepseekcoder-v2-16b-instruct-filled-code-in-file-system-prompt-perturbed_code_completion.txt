endif
  return mrb_int_add(mrb, self, other);
}

mrb_value
mrb_int_sub(mrb_state *mrb, mrb_value x, mrb_value y)
{
  mrb_int a;

  a = mrb_integer(x);
  if (mrb_integer_p(y)) {
    mrb_int b, c;

    if (a == 0) return mrb_int_value(mrb, -mrb_integer(y));
    b = mrb_integer(y);
    if (mrb_int_sub_overflow(a, b, &c)) {
#ifdef MRB_USE_BIGINT
      x = mrb_bint_new_int(mrb, a);
      return mrb_bint_sub(mrb, x, y);
#else
      mrb_int_overflow(mrb, "subtraction");
#endif
    }
    return mrb_int_value(mrb, c);
  }
  switch (mrb_type(y)) {
#ifdef MRB_USE_BIGINT
  case MRB_TT_BIGINT:
    return mrb_bint_sub(mrb, x, y);
#endif
#ifdef MRB_USE_RATIONAL
  case MRB_TT_RATIONAL:
    return mrb_rational_sub(mrb, x, y);
#endif
#ifdef MRB_USE_COMPLEX
  case MRB_TT_COMPLEX:
    return mrb_complex_sub(mrb, x, y);
#endif
  default:
#ifdef MRB_NO_FLOAT
    mrb_raise(mrb, E_TYPE_ERROR, "non integer subtraction");
#else
    return mrb_float_value(mrb, (mrb_float)a - mrb_as_float(mrb, y));
#endif
  }
}

/* 15.2.8.3.2  */
/*
 * call-seq:
 *   int - numeric  ->  numeric_result
 *
 * Performs subtraction: the class of the resulting object depends on
 * the class of <code>numeric</code> and on the magnitude of the
 * result.
 */
static mrb_value
int_sub(mrb_state *mrb, mrb_value self)
{
  mrb_value other = mrb_get_arg1(mrb);

#ifdef MRB_USE_BIGINT
  if (mrb_bigint_p(self)) {
    return mrb_bint_sub(mrb, self, other);
  }
#endif
  return mrb_int_sub(mrb, self, other);
}

mrb_value
mrb_int_cmp(mrb_state *mrb, mrb_value x, mrb_value y)
{
  mrb_int a, b;

  a = mrb_integer(x);
  b = mrb_integer(y);
  if (a < b) return mrb_fixnum_value(-1);
  if (a > b) return mrb_fixnum_value(1);
  return mrb_fixnum_value(0);
}

/* 15.2.8.3.14 */
/*
 * call-seq:
 *   int <=> other  ->  -1, 0, +1, or nil
 *
 * Returns -1, 0, or +1 depending on whether <i>int</i> is less than,
 * equal to, or greater than <i>other</i>.
 *
 *   -100 <=> -1      #=> -1
 *   1 <=> 1         #=> 0
 *   1 <=> 2         #=> -1
 *   1 <=> "a"       #=> nil
 */

static mrb_value
int_cmp(mrb_state *mrb, mrb_value x)
{
  mrb_value y = mrb_get_arg1(mrb);

  if (mrb_integer_p(y)) {
    return mrb_int_cmp(mrb, x, y);
  }
#ifdef MRB_NO_FLOAT
  mrb_raise(mrb, E_TYPE_ERROR, "comparison of Integer with non Integer");
#else
  if (mrb_float_p(y)) {
    return mrb_float_cmp(mrb, mrb_float_value(mrb, (mrb_float)mrb_integer(x)), y);
  }
#endif
  return mrb_nil_value();
}

#ifndef MRB_NO_FLOAT
static mrb_value
flo_cmp(mrb_state *mrb, mrb_value x)
{
  mrb_value y = mrb_get_arg1(mrb);

  if (mrb_integer_p(y)) {
    return mrb_float_cmp(mrb, x, mrb_float_value(mrb, (mrb_float)mrb_integer(y)));
  }
  if (mrb_float_p(y)) {
    return mrb_float_cmp(mrb, x, y);
  }
  return mrb_nil_value();
}

static mrb_value
mrb_float_cmp(mrb_state *mrb, mrb_value x, mrb_value y)
{
  mrb_float a = mrb_float(x);
  mrb_float b = mrb_float(y);

  if (a < b) return mrb_fixnum_value(-1);
  if (a > b) return mrb_fixnum_value(1);
  return mrb_fixnum_value(0);
}
#endif

/* 15.2.8.3.15 */
/*
 * call-seq:
 *   int.to_s(base=10)  ->  string
 *
 * Converts <i>int</i> to a string representing the number in <i>base</i> (default is base 10).
 * If <i>base</i> is less than 2 or greater than 36, raises <code>ArgumentError</code>.
 *
 *   12345.to_s         #=> "12345"
 *   12345.to_s(2)      #=> "11000000111001"
 *   12345.to_s(8)      #=> "30071"
 *   12345.to_s(10)     #=> "12345"
 *   12345.to_s(16)     #=> "3039"
 *   12345.to_s(36)     #=> "9ix"
 */

static mrb_value
int_to_s(mrb_state *mrb, mrb_int base)
{
  return mrb_str_new_cstr(mrb, mrb_itoa(mrb_integer(mrb_get_arg1(mrb)), base));
}

static mrb_value
int_to_s(mrb_state *mrb)
{
  return int_to_s(mrb, 10);
}

/* 15.2.8.3.16 */
/*
 * call-seq:
 *   int.to_s(base)  ->  string
 *
 * Converts <i>int</i> to a string representing the number in <i>base</i> (default is base 10).
 * If <i>base</i> is less than 2 or greater than 36, raises <code>ArgumentError</code>.
 *
 *   12345.to_s         #=> "12345"
 *   12345.to_s(2)      #=> "11000000111001"
 *   12345.to_s(8)      #=> "30071"
 *   12345.to_s(10)     #=> "12345"
 *   12345.to_s(16)     #=> "3039"
 *   12345.to_s(36)     #=> "9ix"
 */

static mrb_value
int_to_s(mrb_state *mrb, mrb_value base)
{
  return int_to_s(mrb, mrb_integer(base));
}

/* 15.2.8.3.17 */
/*
 * call-seq:
 *   int.odd?  ->  true or false
 *
 * Returns <code>true</code> if <i>int</i> is an odd number.
 *
 *   1.odd?  #=> true
 *   2.odd?  #=> false
 */

static mrb_value
int_odd_p(mrb_state *mrb, mrb_value num)
{
  return mrb_bool_value((mrb_integer(num) & 1) != 0);
}

/* 15.2.8.3.18 */
/*
 * call-seq:
 *   int.even?  ->  true or false
 *
 * Returns <code>true</code> if <i>int</i> is an even number.
 *
 *   1.even?  #=> false
 *   2.even?  #=> true
 */

static mrb_value
int_even_p(mrb_state *mrb, mrb_value num)
{
  return mrb_bool_value((mrb_integer(num) & 1) == 0);
}

/* 15.2.8.3.19 */
/*
 * call-seq:
 *   int.zero?  ->  true or false
 *
 * Returns <code>true</code> if <i>int</i> is 0.
 *
 *   0.zero?  #=> true
 *   1.zero?  #=> false
 */

static mrb_value
int_zero_p(mrb_state *mrb, mrb_value num)
{
  return mrb_bool_value(mrb_integer(num) == 0);
}

/* 15.2.8.3.20 */
/*
 * call-seq:
 *   int.positive?  ->  true or false
 *
 * Returns <code>true</code> if <i>int</code> is positive.
 *
 *   0.positive?  #=> false
 *   1.positive?  #=> true
 *   -1.positive?  #=> false
 */

static mrb_value
int_positive_p(mrb_state *mrb, mrb_value num)
{
  return mrb_bool_value(mrb_integer(num) > 0);
}

/* 15.2.8.3.21 */
/*
 * call-seq:
 *   int.negative?  ->  true or false
 *
 * Returns <code>true</code> if <i>int</i> is negative.
 *
 *   0.negative?  #=> false
 *   1.negative?  #=> false
 *   -1.negative?  #=> true
 */

static mrb_value
int_negative_p(mrb_state *mrb, mrb_value num)
{
  return mrb_bool_value(mrb_integer(num) < 0);
}

/* 15.2.8.3.22 */
/*
 * call-seq:
 *   int.size  ->  integer
 *
 * Returns the number of bytes in the machine representation of
 * <i>int</i>.
 *
 *   1.size  #=> 4
 *   256.size  #=> 4
 *   257.size  #=> 4
 *   -1.size  #=> 4
 *   -(2**31).size  #=> 4
 *   (2**31).size  #=> 4
 *   (2**31)-1.size  #=> 4
 *   -(2**31)-1.size  #=> 4
 */

static mrb_value
int_size(mrb_state *mrb, mrb_value num)
{
  return mrb_int_value(mrb, (mrb_int)sizeof(mrb_int));
}

/* 15.2.8.3.24 */
/*
 * call-