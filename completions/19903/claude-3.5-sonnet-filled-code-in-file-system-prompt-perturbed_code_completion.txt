if (strchr("(",(int) *expression) != (char *) NULL)
  {
    char
      *subexpression;

    subexpression=AcquireString(expression);
    (void) CopyMagickString(subexpression,expression+1,MagickPathExtent);
    subexpression[strlen(subexpression)-1]='\0';
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,subexpression,depth+1,
      &beta,exception);
    subexpression=DestroyString(subexpression);
    FxReturn(alpha);
  }
  if (strchr(">",(int) *expression) != (char *) NULL)
    {
      double
        gamma;

      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+1,depth+1,
        &beta,exception);
      gamma=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,&beta,
        exception);
      FxReturn(alpha > gamma ? 1.0 : 0.0);
    }
  if (IsFxFunction(expression,"abs",3) != MagickFalse)
    {
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth+1,
        &beta,exception);
      FxReturn(fabs(alpha));
    }
  if (IsFxFunction(expression,"acos",4) != MagickFalse)
    {
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth+1,
        &beta,exception);
      FxReturn(acos(alpha));
    }
  if (IsFxFunction(expression,"asin",4) != MagickFalse)
    {
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth+1,
        &beta,exception);
      FxReturn(asin(alpha));
    }
  if (IsFxFunction(expression,"alt",3) != MagickFalse)
    {
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth+1,
        &beta,exception);
      FxReturn(((ssize_t) alpha) & 0x01 ? -1.0 : 1.0);
    }
  if (IsFxFunction(expression,"atan2",5) != MagickFalse)
    {
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,depth+1,
        &beta,exception);
      FxReturn(atan2(alpha,beta));
    }
  if (IsFxFunction(expression,"ceil",4) != MagickFalse)
    {
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth+1,
        &beta,exception);
      FxReturn(ceil(alpha));
    }
  if (IsFxFunction(expression,"cos",3) != MagickFalse)
    {
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth+1,
        &beta,exception);
      FxReturn(cos(alpha));
    }
  if (IsFxFunction(expression,"exp",3) != MagickFalse)
    {
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth+1,
        &beta,exception);
      FxReturn(exp(alpha));
    }
  if (IsFxFunction(expression,"floor",5) != MagickFalse)
    {
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,depth+1,
        &beta,exception);
      FxReturn(floor(alpha));
    }
  if (IsFxFunction(expression,"hypot",5) != MagickFalse)
    {
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,depth+1,
        &beta,exception);
      FxReturn(hypot(alpha,beta));
    }
  if (IsFxFunction(expression,"int",3) != MagickFalse)
    {
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth+1,
        &beta,exception);
      FxReturn(floor(alpha));
    }
  if (IsFxFunction(expression,"ln",2) != MagickFalse)
    {
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+2,depth+1,
        &beta,exception);
      FxReturn(log(alpha));
    }
  if (IsFxFunction(expression,"log",3) != MagickFalse)
    {
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth+1,
        &beta,exception);
      FxReturn(log10(alpha));
    }
  if (IsFxFunction(expression,"pow",3) != MagickFalse)
    {
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth+1,
        &beta,exception);
      FxReturn(pow(alpha,beta));
    }
  if (IsFxFunction(expression,"rand",4) != MagickFalse)
    {
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth+1,
        &beta,exception);
      FxReturn(GetPseudoRandomValue(fx_info->random_info));
    }
  if (IsFxFunction(expression,"round",5) != MagickFalse)
    {
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,depth+1,
        &beta,exception);
      FxReturn(floor(alpha+0.5));
    }
  if (IsFxFunction(expression,"sign",4) != MagickFalse)
    {
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth+1,
        &beta,exception);
      FxReturn(alpha < 0.0 ? -1.0 : 1.0);
    }
  if (IsFxFunction(expression,"sin",3) != MagickFalse)
    {
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth+1,
        &beta,exception);
      FxReturn(sin(alpha));
    }
  if (IsFxFunction(expression,"sqrt",4) != MagickFalse)
    {
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth+1,
        &beta,exception);
      FxReturn(sqrt(alpha));
    }
  if (IsFxFunction(expression,"tan",3) != MagickFalse)
    {
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth+1,
        &beta,exception);
      FxReturn(tan(alpha));
    }
  if (IsFxFunction(expression,"trunc",5) != MagickFalse)
    {
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,depth+1,
        &beta,exception);
      if (alpha >= 0.0)
        return(floor(alpha));
      return(ceil(alpha));
    }
  if (strchr("(",(int) *expression) != (char *) NULL)
    {
      char
        *subexpression;

      subexpression=AcquireString(expression);
      (void) CopyMagickString(subexpression,expression+1,MagickPathExtent);
      subexpression[strlen(subexpression)-1]='\0';
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,subexpression,depth+1,
        &beta,exception);
      subexpression=DestroyString(subexpression);
      FxReturn(alpha);
    }