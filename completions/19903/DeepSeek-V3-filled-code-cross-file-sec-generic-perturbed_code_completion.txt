if (*expression == '(')
    {
      register const char
        *q;

      ssize_t
        level;

      level=1;
      q=expression+1;
      while ((*q != '\0') && (level != 0))
      {
        if (*q == '(')
          level++;
        else
          if (*q == ')')
            level--;
        q++;
      }
      if (level != 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            "MismatchedParenthesis","`%s'",expression);
          FxReturn(0.0);
        }
      (void) CopyMagickString(subexpression,expression+1,(size_t) (q-expression-1));
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,subexpression,depth+1,beta,
        exception);
      expression=q;
      FxReturn(alpha);
    }
  if (IsFxFunction(expression,"abs",3) != MagickFalse)
    {
      expression+=3;
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,beta,
        exception);
      FxReturn(fabs(alpha));
    }
  if (IsFxFunction(expression,"acos",4) != MagickFalse)
    {
      expression+=4;
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,beta,
        exception);
      FxReturn(acos(alpha));
    }
  if (IsFxFunction(expression,"asin",4) != MagickFalse)
    {
      expression+=4;
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,beta,
        exception);
      FxReturn(asin(alpha));
    }
  if (IsFxFunction(expression,"atan",4) != MagickFalse)
    {
      expression+=4;
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,beta,
        exception);
      FxReturn(atan(alpha));
    }
  if (IsFxFunction(expression,"ceil",4) != MagickFalse)
    {
      expression+=4;
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,beta,
        exception);
      FxReturn(ceil(alpha));
    }
  if (IsFxFunction(expression,"cos",3) != MagickFalse)
    {
      expression+=3;
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,beta,
        exception);
      FxReturn(cos(alpha));
    }
  if (IsFxFunction(expression,"exp",3) != MagickFalse)
    {
      expression+=3;
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,beta,
        exception);
      FxReturn(exp(alpha));
    }
  if (IsFxFunction(expression,"floor",5) != MagickFalse)
    {
      expression+=5;
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,beta,
        exception);
      FxReturn(floor(alpha));
    }
  if (IsFxFunction(expression,"log",3) != MagickFalse)
    {
      expression+=3;
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,beta,
        exception);
      FxReturn(log(alpha));
    }
  if (IsFxFunction(expression,"sin",3) != MagickFalse)
    {
      expression+=3;
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,beta,
        exception);
      FxReturn(sin(alpha));
    }
  if (IsFxFunction(expression,"sqrt",4) != MagickFalse)
    {
      expression+=4;
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,beta,
        exception);
      FxReturn(sqrt(alpha));
    }
  if (IsFxFunction(expression,"tan",3) != MagickFalse)
    {
      expression+=3;
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,beta,
        exception);
      FxReturn(tan(alpha));
    }
  if (LocaleCompare(expression,"pi") == 0)
    FxReturn(MagickPI);
  if (LocaleCompare(expression,"e") == 0)
    FxReturn(MagickE);