if (isalpha((int) ((unsigned char) *expression)) != 0)
  {
    /*
      User defined symbol.
    */
    alpha=FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception);
    FxReturn(alpha);
  }
if (((isdigit((int) ((unsigned char) *expression)) != 0) ||
  ((*expression == '.') && (isdigit((int) ((unsigned char) *(expression+1))) != 0))) ||
  (((*expression == '+') || (*expression == '-')) &&
   ((isdigit((int) ((unsigned char) *(expression+1))) != 0) ||
    (*(expression+1) == '.'))))
  {
    /*
      Evaluate expression.
    */
    q=(char *) expression;
    alpha=InterpretSiPrefixValue(expression,&q);
    if (errno == ERANGE)
      {
        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
          "UnableToParseExpression","`%s'",expression);
        FxReturn(0.0);
      }
    FxReturn(alpha);
  }
if (*expression == '(')
  {
    /*
      Evaluate expression within parenthesis.
    */
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,++expression,depth+1,
      beta,exception);
    expression=FxSubexpression(expression,exception);
    if (*expression != ')')
      {
        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
          "UnbalancedParenthesis","`%s'",expression);
        FxReturn(0.0);
      }
    FxReturn(alpha);
  }
if (IsFxFunction(expression,"abs",3) != MagickFalse)
  {
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth+1,
      beta,exception);
    FxReturn(fabs(alpha));
  }
if (IsFxFunction(expression,"acos",4) != MagickFalse)
  {
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth+1,
      beta,exception);
    FxReturn(acos(alpha));
  }
if (IsFxFunction(expression,"acosh",5) != MagickFalse)
  {
#if defined(MAGICKCORE_HAVE_ACOSH)
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,depth+1,
      beta,exception);
    FxReturn(acosh(alpha));
#else
    (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
      "UnableToParseExpression","`%s'",expression);
    FxReturn(0.0);
#endif
  }
if (IsFxFunction(expression,"asin",4) != MagickFalse)
  {
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth+1,
      beta,exception);
    FxReturn(asin(alpha));
  }
if (IsFxFunction(expression,"asinh",5) != MagickFalse)
  {
#if defined(MAGICKCORE_HAVE_ASINH)
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,depth+1,
      beta,exception);
    FxReturn(asinh(alpha));
#else
    (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
      "UnableToParseExpression","`%s'",expression);
    FxReturn(0.0);
#endif
  }
if (IsFxFunction(expression,"atan",4) != MagickFalse)
  {
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth+1,
      beta,exception);
    FxReturn(atan(alpha));
  }
if (IsFxFunction(expression,"atanh",5) != MagickFalse)
  {
#if defined(MAGICKCORE_HAVE_ATANH)
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,depth+1,
      beta,exception);
    FxReturn(atanh(alpha));
#else
    (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
      "UnableToParseExpression","`%s'",expression);
    FxReturn(0.0);
#endif
  }
if (IsFxFunction(expression,"atan2",5) != MagickFalse)
  {
    p=expression+5;
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,beta,
      exception);
    p++;
    if (*p == ',')
      p++;
    gamma=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,beta,
      exception);
    FxReturn(atan2(alpha,gamma));
  }
if (IsFxFunction(expression,"ceil",4) != MagickFalse)
  {
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth+1,
      beta,exception);
    FxReturn(ceil(alpha));
  }
if (IsFxFunction(expression,"clamp",5) != MagickFalse)
  {
    p=expression+5;
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,beta,
      exception);
    p++;
    if (*p == ',')
      p++;
    gamma=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,beta,
      exception);
    p++;
    if (*p == ',')
      p++;
    value=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,beta,
      exception);
    FxReturn(alpha < gamma ? gamma : (alpha > value ? value : alpha));
  }
if (IsFxFunction(expression,"cos",3) != MagickFalse)
  {
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth+1,
      beta,exception);
    FxReturn(cos(alpha));
  }
if (IsFxFunction(expression,"cosh",4) != MagickFalse)
  {
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth+1,
      beta,exception);
    FxReturn(cosh(alpha));
  }
if (IsFxFunction(expression,"debug",5) != MagickFalse)
  {
    (void) FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,depth+1,
      beta,exception);
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),
      "  Debugging expression: \"%s\"",expression+5);
    FxReturn(0.0);
  }
if (IsFxFunction(expression,"deltap",6) != MagickFalse)
  {
    Image
      *image;

    MagickStatusType
      status;

    p=expression+6;
    image=GetFxSymbolImage(fx_info,p,&p,exception);
    if (image == (Image *) NULL)
      FxReturn(0.0);
    status=ParseGeometry(GetImageArtifact(image,"deltap"),&fx_info->geometry);
    if (status == MagickFalse)
      {
        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
          "UnableToParseExpression","`%s'",expression);
        FxReturn(0.0);
      }
    FxReturn(0.0);
  }
if (IsFxFunction(expression,"exp",3) != MagickFalse)
  {
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth+1,
      beta,exception);
    FxReturn(exp(alpha));
  }
if (IsFxFunction(expression,"floor",5) != MagickFalse)
  {
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,depth+1,
      beta,exception);
    FxReturn(floor(alpha));
  }
if (IsFxFunction(expression,"gauss",5) != MagickFalse)
  {
    p=expression+5;
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,beta,
      exception);
    p++;
    if (*p == ',')
      p++;
    gamma=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,beta,
      exception);
    FxReturn(gauss(alpha,gamma));
  }
if (IsFxFunction(expression,"hypot",5) != MagickFalse)
  {
    p=expression+5;
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,beta,
      exception);
    p++;
    if (*p == ',')
      p++;
    gamma=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,beta,
      exception);
    FxReturn(hypot(alpha,gamma));
  }
if (IsFxFunction(expression,"int",3) != MagickFalse)
  {
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth+1,
      beta,exception);
    FxReturn(floor(alpha+0.5));
  }
if (IsFxFunction(expression,"isnan",5) != MagickFalse)
  {
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,depth+1,
      beta,exception);
    FxReturn(IsNaN(alpha) != 0 ? 1.0 : 0.0);
  }
if (IsFxFunction(expression,"j0",2) != MagickFalse)
  {
#if defined(MAGICKCORE_HAVE_J0)
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+2,depth+1,
      beta,exception);
    FxReturn(j0(alpha));
#else
    (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
      "UnableToParseExpression","`%s'",expression);
    FxReturn(0.0);
#endif
  }
if (IsFxFunction(expression,"j1",2) != MagickFalse)
  {
#if defined(MAGICKCORE_HAVE_J1)
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+2,depth+1,
      beta,exception);
    FxReturn(j1(alpha));
#else
    (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
      "UnableToParseExpression","`%s'",expression);
    FxReturn(0.0);
#endif
  }
if (IsFxFunction(expression,"ln",2) != MagickFalse)
  {
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+2,depth+1,
      beta,exception);
    FxReturn(log(alpha));
  }
if (IsFxFunction(expression,"log",3) != MagickFalse)
  {
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth+1,
      beta,exception);
    FxReturn(log10(alpha));
  }
if (IsFxFunction(expression,"max",3) != MagickFalse)
  {
    p=expression+3;
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,beta,
      exception);
    p++;
    if (*p == ',')
      p++;
    gamma=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,beta,
      exception);
    FxReturn(alpha > gamma ? alpha : gamma);
  }
if (IsFxFunction(expression,"min",3) != MagickFalse)
  {
    p=expression+3;
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,beta,
      exception);
    p++;
    if (*p == ',')
      p++;
    gamma=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,beta,
      exception);
    FxReturn(alpha < gamma ? alpha : gamma);
  }
if (IsFxFunction(expression,"mod",3) != MagickFalse)
  {
    p=expression+3;
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,beta,
      exception);
    p++;
    if (*p == ',')
      p++;
    gamma=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,beta,
      exception);
    FxReturn(fmod(alpha,gamma));
  }
if (IsFxFunction(expression,"pow",3) != MagickFalse)
  {
    p=expression+3;
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,beta,
      exception);
    p++;
    if (*p == ',')
      p++;
    gamma=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,beta,
      exception);
    FxReturn(pow(alpha,gamma));
  }
if (IsFxFunction(expression,"rand",4) != MagickFalse)
  {
    alpha=GetPseudoRandomValue(fx_info->random_info);
    FxReturn(alpha);
  }
if (IsFxFunction(expression,"round",5) != MagickFalse)
  {
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,depth+1,
      beta,exception);
    FxReturn(floor(alpha+0.5));
  }
if (IsFxFunction(expression,"sign",4) != MagickFalse)
  {
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth+1,
      beta,exception);
    FxReturn(alpha < 0.0 ? -1.0 : 1.0);
  }
if (IsFxFunction(expression,"sin",3) != MagickFalse)
  {
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth+1,
      beta,exception);
    FxReturn(sin(alpha));
  }
if (IsFxFunction(expression,"sinc",4) != MagickFalse)
  {
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth+1,
      beta,exception);
    if (alpha == 0.0)
      FxReturn(1.0);
    FxReturn(sin(MagickPI*alpha)/(MagickPI*alpha));
  }
if (IsFxFunction(expression,"sinh",4) != MagickFalse)
  {
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth+1,
      beta,exception);
    FxReturn(sinh(alpha));
  }
if (IsFxFunction(expression,"sqrt",4) != MagickFalse)
  {
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth+1,
      beta,exception);
    FxReturn(sqrt(alpha));
  }
if (IsFxFunction(expression,"tan",3) != MagickFalse)
  {
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth+1,
      beta,exception);
    FxReturn(tan(alpha));
  }
if (IsFxFunction(expression,"tanh",4) != MagickFalse)
  {
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth+1,
      beta,exception);
    FxReturn(tanh(alpha));
  }
(void) ThrowMagickException(exception,GetMagickModule(),OptionError,
  "UnableToParseExpression","`%s'",expression);
FxReturn(0.0);