// Evaluate mathematical expressions and functions in the provided string.
  while (isspace((int) ((unsigned char) *expression)) != 0)
    expression++;
  if (*expression == '(')
    {
      /*
        Parenthesis: evaluate the subexpression within.
      */
      (void) CopyMagickString(subexpression,expression+1,MagickPathExtent);
      subexpression[strlen(subexpression)-1]='\0';
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,subexpression,depth+1,
        beta,exception);
      FxReturn(alpha);
    }
  if (isalpha((int) ((unsigned char) *expression)) != 0)
    {
      /*
        Function or symbol.
      */
      p=expression;
      while (isalnum((int) ((unsigned char) *p)) != 0)
        p++;
      if (*p == '(')
        {
          /*
            Function: evaluate the function with its arguments.
          */
          (void) CopyMagickString(subexpression,expression,MagickPathExtent);
          subexpression[p-expression]='\0';
          p++;
          (void) CopyMagickString(subexpression,p,MagickPathExtent);
          subexpression[strlen(subexpression)-1]='\0';
          alpha=FxEvaluateFunction(fx_info,channel,x,y,subexpression,depth+1,
            beta,exception);
          FxReturn(alpha);
        }
      alpha=FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception);
      FxReturn(alpha);
    }
  if (isdigit((int) ((unsigned char) *expression)) != 0 || *expression == '.')
    {
      /*
        Number: parse and return its value.
      */
      alpha=StringToDouble(expression,&q);
      if (q == expression)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            "UnableToParseExpression","`%s'",expression);
          FxReturn(0.0);
        }
      FxReturn(alpha);
    }
  (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
    "UnrecognizedExpression","`%s'",expression);
  FxReturn(0.0);