{
  size_t
    parenthesis_count = 0;

  double
    operand1,
    operand2;

  register const char
    *current;

  current = expression;
  while (*current != '\0')
  {
    if (*current == '(')
    {
      parenthesis_count++;
      if (parenthesis_count > FxMaxParenthesisDepth)
      {
        (void) ThrowMagickException(exception, GetMagickModule(), OptionError,
          "MaximumParenthesisDepthExceeded", "`%s'", expression);
        FxReturn(0.0);
      }
    }
    else if (*current == ')')
    {
      parenthesis_count--;
      if (parenthesis_count < 0)
      {
        (void) ThrowMagickException(exception, GetMagickModule(), OptionError,
          "UnbalancedParentheses", "`%s'", expression);
        FxReturn(0.0);
      }
    }
    current++;
  }

  if (parenthesis_count != 0)
  {
    (void) ThrowMagickException(exception, GetMagickModule(), OptionError,
      "UnbalancedParentheses", "`%s'", expression);
    FxReturn(0.0);
  }

  switch (*expression)
  {
    case 'a':
    case 'A':
    {
      if (IsFxFunction(expression, "abs", 3) != MagickFalse)
      {
        operand1 = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 3, depth + 1, beta, exception);
        FxReturn(fabs(operand1));
      }
      else if (IsFxFunction(expression, "acos", 4) != MagickFalse)
      {
        operand1 = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 4, depth + 1, beta, exception);
        FxReturn(acos(operand1));
      }
      break;
    }
    case 'e':
    case 'E':
    {
      if (LocaleNCompare(expression, "e", 1) == 0)
      {
        FxReturn(MagickE);
      }
      break;
    }
    case 'p':
    case 'P':
    {
      if (LocaleNCompare(expression, "pi", 2) == 0)
      {
        FxReturn(MagickPI);
      }
      break;
    }
    default:
    {
      if (isdigit((int) ((unsigned char) *expression)) != 0 ||
          *expression == '.')
      {
        alpha = InterpretSiPrefixValue(expression, &q);
        FxReturn(alpha);
      }
      break;
    }
  }
}