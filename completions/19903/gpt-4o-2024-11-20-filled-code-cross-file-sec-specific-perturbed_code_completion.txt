// Evaluate mathematical expressions and functions in the provided string.
  // Check for parentheses and recursively evaluate enclosed expressions, ensuring they don't exceed a certain depth.
  while (*p != '\0')
  {
    // Skip whitespace
    while (isspace((int) ((unsigned char) *p)) != 0)
      p++;

    // Handle parentheses
    if (*p == '(')
    {
      const char *end = FxSubexpression(p, exception);
      if (end == (const char *) NULL)
      {
        (void) ThrowMagickException(exception, GetMagickModule(), OptionError,
          "UnableToParseExpression", "`%s'", p);
        FxReturn(0.0);
      }
      (void) CopyMagickString(subexpression, p + 1, (size_t) (end - p));
      alpha = FxEvaluateSubexpression(fx_info, channel, x, y, subexpression, depth + 1, beta, exception);
      p = end + 1;
      continue;
    }

    // Handle recognized math functions
    if (isalpha((int) ((unsigned char) *p)) != 0)
    {
      char function[MagickPathExtent];
      const char *q = p;
      while (isalpha((int) ((unsigned char) *q)) != 0)
        q++;
      (void) CopyMagickString(function, p, (size_t) (q - p + 1));
      p = q;

      if (LocaleCompare(function, "abs") == 0)
        alpha = fabs(FxEvaluateSubexpression(fx_info, channel, x, y, p, depth + 1, beta, exception));
      else if (LocaleCompare(function, "sin") == 0)
        alpha = sin(FxEvaluateSubexpression(fx_info, channel, x, y, p, depth + 1, beta, exception));
      else if (LocaleCompare(function, "cos") == 0)
        alpha = cos(FxEvaluateSubexpression(fx_info, channel, x, y, p, depth + 1, beta, exception));
      else if (LocaleCompare(function, "exp") == 0)
        alpha = exp(FxEvaluateSubexpression(fx_info, channel, x, y, p, depth + 1, beta, exception));
      else if (LocaleCompare(function, "log") == 0)
        alpha = log(FxEvaluateSubexpression(fx_info, channel, x, y, p, depth + 1, beta, exception));
      else
      {
        (void) ThrowMagickException(exception, GetMagickModule(), OptionError,
          "UnrecognizedFunction", "`%s'", function);
        FxReturn(0.0);
      }
      continue;
    }

    // Handle constants like pi and e
    if (LocaleNCompare(p, "pi", 2) == 0)
    {
      alpha = M_PI;
      p += 2;
      continue;
    }
    if (LocaleNCompare(p, "e", 1) == 0)
    {
      alpha = M_E;
      p += 1;
      continue;
    }

    // Handle unrecognized or malformed expressions
    (void) ThrowMagickException(exception, GetMagickModule(), OptionError,
      "UnableToParseExpression", "`%s'", p);
    FxReturn(0.0);
  }