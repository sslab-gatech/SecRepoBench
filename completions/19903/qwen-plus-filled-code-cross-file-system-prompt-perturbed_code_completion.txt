{
  ssize_t
    i;

  double
    result;

  /* Check for parentheses and evaluate enclosed expressions recursively */
  if (*expression == '(')
  {
    size_t depth = 0;
    q = (char *) expression + 1; /* Start after the opening parenthesis */
    while (*q != '\0')
    {
      if (*q == '(')
        depth++;
      else if (*q == ')')
      {
        if (depth == 0)
        {
          *q = '\0'; /* Terminate the subexpression */
          result = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 1, depth + 1, beta, exception);
          expression = q + 1; /* Move past the closing parenthesis */
          FxReturn(result);
        }
        depth--;
      }
      q++;
    }
    (void) ThrowMagickException(exception, GetMagickModule(), OptionError,
      "UnableToParseExpression", "`%s'", expression);
    FxReturn(0.0);
  }

  /* Handle mathematical constants */
  if (LocaleCompare(expression, "pi") == 0)
  {
    FxReturn(MagickPI);
  }
  else if (LocaleCompare(expression, "e") == 0)
  {
    FxReturn(MagickE);
  }

  /* Handle recognized math functions */
  if (IsFxFunction(expression, "abs", 3) != MagickFalse)
  {
    result = fabs(FxEvaluateSubexpression(fx_info, channel, x, y, expression + 3, depth + 1, beta, exception));
    FxReturn(result);
  }
  else if (IsFxFunction(expression, "acos", 4) != MagickFalse)
  {
#if defined(MAGICKCORE_HAVE_ACOS)
    result = acos(FxEvaluateSubexpression(fx_info, channel, x, y, expression + 4, depth + 1, beta, exception));
    FxReturn(result);
#endif
  }
  else if (IsFxFunction(expression, "exp", 3) != MagickFalse)
  {
    result = exp(FxEvaluateSubexpression(fx_info, channel, x, y, expression + 3, depth + 1, beta, exception));
    FxReturn(result);
  }

  /* Handle keywords like "if" */
  if ((IsFxFunction(expression, "if", 2) != MagickFalse) && (expression[2] == '('))
  {
    q = strchr(expression + 3, ')');
    if (q == NULL)
    {
      (void) ThrowMagickException(exception, GetMagickModule(), OptionError,
        "UnableToParseExpression", "`%s'", expression);
      FxReturn(0.0);
    }
    *q = '\0'; /* Terminate the condition */
    double condition = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 3, depth + 1, beta, exception);
    *q = ')'; /* Restore the character */

    /* Parse the true and false branches */
    char *true_branch = strchr(q + 1, ',');
    char *false_branch = strrchr(q + 1, ',');

    if ((true_branch == NULL) || (false_branch == NULL) || (true_branch >= false_branch))
    {
      (void) ThrowMagickException(exception, GetMagickModule(), OptionError,
        "UnableToParseExpression", "`%s'", expression);
      FxReturn(0.0);
    }

    *true_branch = *false_branch = '\0';
    true_branch++;
    false_branch++;

    result = condition > 0.0 ? FxEvaluateSubexpression(fx_info, channel, x, y, true_branch, depth + 1, beta, exception) :
      FxEvaluateSubexpression(fx_info, channel, x, y, false_branch, depth + 1, beta, exception);
    FxReturn(result);
  }

  /* Default case: interpret as a symbol or literal value */
  subexpression = DestroyString(subexpression);
  q = (char *) expression;
  alpha = InterpretSiPrefixValue(expression, &q);
  if (q == expression)
    alpha = FxGetSymbol(fx_info, channel, x, y, expression, depth + 1, exception);
  FxReturn(alpha);
}