if (*expression == '(')
{
  char *paren_expression;
  const char *closing;
  paren_expression = AcquireString(expression + 1);
  closing = strrchr(paren_expression, ')');
  if (closing != (const char *) NULL)
    *(char *) closing = '\0';
  alpha = FxEvaluateSubexpression(fx_info, channel, x, y, paren_expression,
    depth + 1, beta, exception);
  paren_expression = DestroyString(paren_expression);
  FxReturn(alpha);
}

if (*expression == '-')  /* handle unary minus */
{
  alpha = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 1,
    depth + 1, beta, exception);
  FxReturn(-alpha);
}

if (isalpha((int) ((unsigned char) *expression)) != 0)
{
  char function_name[32];
  ssize_t i = 0;
  while (isalpha((int) ((unsigned char) expression[i])) && (i < 31))
  {
    function_name[i] = expression[i];
    i++;
  }
  function_name[i] = '\0';
  if (LocaleCompare(function_name, "sin") == 0)
    FxReturn(sin(FxEvaluateSubexpression(fx_info, channel, x, y,
      expression + 3, depth + 1, beta, exception)));
  if (LocaleCompare(function_name, "cos") == 0)
    FxReturn(cos(FxEvaluateSubexpression(fx_info, channel, x, y,
      expression + 3, depth + 1, beta, exception)));
  if (LocaleCompare(function_name, "tan") == 0)
    FxReturn(tan(FxEvaluateSubexpression(fx_info, channel, x, y,
      expression + 3, depth + 1, beta, exception)));
  if (LocaleCompare(function_name, "abs") == 0)
    FxReturn(fabs(FxEvaluateSubexpression(fx_info, channel, x, y,
      expression + 3, depth + 1, beta, exception)));
  /* If the identifier is not a recognized function, let the
     InterpretSiPrefixValue() call below attempt to resolve it as a
     numeric literal or symbol. */
}