{
  /* Skip any leading whitespace */
  while (isspace((int) ((unsigned char) *expression)) != 0)
    expression++;
  /* If the expression is enclosed in parentheses, evaluate the enclosed expression */
  if (*expression == '(')
  {
    const char *paren_start = expression;
    int parentheses = 0;
    const char *p = expression;
    while (*p != '\0')
    {
      if (*p == '(')
        parentheses++;
      else if (*p == ')')
      {
        parentheses--;
        if (parentheses == 0)
          break;
      }
      p++;
    }
    if (parentheses != 0)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
        "MismatchedParenthesis","`%s'",expression);
      FxReturn(0.0);
    }
    {
      size_t length = (size_t)(p - expression - 1) + 1;
      char *inner = AcquireString("");
      if (length > MagickPathExtent)
      {
        inner = DestroyString(inner);
        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
          "ExpressionTooLong","`%s'",expression);
        FxReturn(0.0);
      }
      (void) CopyMagickString(inner, expression + 1, length);
      double inner_value = FxEvaluateSubexpression(fx_info, channel, x, y,
        inner, depth + 1, beta, exception);
      inner = DestroyString(inner);
      FxReturn(inner_value);
    }
  }
  /* Check for known mathematical constants */
  if (LocaleCompare(expression, "pi") == 0)
    FxReturn(MagickPI);
  if (LocaleCompare(expression, "e") == 0)
    FxReturn(MagickE);
  /* Check if the expression begins with a function name */
  {
    char function_name[MagickPathExtent];
    const char *p = expression;
    int i = 0;
    while (isalpha((int) ((unsigned char) *p)) != 0 && i < (int) (MagickPathExtent - 1))
    {
      function_name[i++] = *p;
      p++;
    }
    function_name[i] = '\0';
    if (i > 0)
    {
      while (isspace((int) ((unsigned char) *p)) != 0)
        p++;
      if (*p == '(')
      {
        /* Evaluate the argument of the function */
        const char *arg_start = p;
        int paren_count = 0;
        const char *q = p;
        while (*q != '\0')
        {
          if (*q == '(')
            paren_count++;
          else if (*q == ')')
          {
            paren_count--;
            if (paren_count == 0)
              break;
          }
          q++;
        }
        if (paren_count != 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            "MismatchedParenthesis","`%s'",expression);
          FxReturn(0.0);
        }
        size_t arg_length = (size_t)(q - p - 1) + 1;
        char *arg = AcquireString("");
        if (arg_length > MagickPathExtent)
        {
          arg = DestroyString(arg);
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            "ExpressionTooLong","`%s'",expression);
          FxReturn(0.0);
        }
        (void) CopyMagickString(arg, p + 1, arg_length);
        double arg_value = FxEvaluateSubexpression(fx_info, channel, x, y,
          arg, depth + 1, beta, exception);
        arg = DestroyString(arg);
        /* Process known math functions */
        if (LocaleCompare(function_name, "abs") == 0)
          FxReturn(fabs(arg_value));
        if (LocaleCompare(function_name, "acos") == 0)
          FxReturn(acos(arg_value));
        if (LocaleCompare(function_name, "asin") == 0)
          FxReturn(asin(arg_value));
        if (LocaleCompare(function_name, "atan") == 0)
          FxReturn(atan(arg_value));
        if (LocaleCompare(function_name, "cos") == 0)
          FxReturn(cos(arg_value));
        if (LocaleCompare(function_name, "cosh") == 0)
          FxReturn(cosh(arg_value));
        if (LocaleCompare(function_name, "exp") == 0)
          FxReturn(exp(arg_value));
        if (LocaleCompare(function_name, "log") == 0)
          FxReturn(log(arg_value));
        if (LocaleCompare(function_name, "sin") == 0)
          FxReturn(sin(arg_value));
        if (LocaleCompare(function_name, "sinh") == 0)
          FxReturn(sinh(arg_value));
        if (LocaleCompare(function_name, "sqrt") == 0)
          FxReturn(sqrt(arg_value));
        if (LocaleCompare(function_name, "tan") == 0)
          FxReturn(tan(arg_value));
        if (LocaleCompare(function_name, "tanh") == 0)
          FxReturn(tanh(arg_value));
        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
          "UnrecognizedFunction","`%s'", function_name);
        FxReturn(0.0);
      }
    }
  }
}