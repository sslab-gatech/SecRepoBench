/*
  Evaluate mathematical expressions and functions in the provided string.  
  Check for parentheses and recursively evaluate enclosed expressions, ensuring
  they don't exceed the maximum parenthesis depth. Use conditionals or a switch
  to handle recognized function names at the beginning of the expression; for each
  recognized function, compute its result by recursively evaluating the subexpression.  
  Handle special cases for constants (like "pi" or "e") by returning their predefined
  values. If the expression matches certain looping or conditional keywords (e.g., "if"),
  parse and evaluate them accordingly. Fall back to interpreting the expression as a
  numeric value (with possible SI prefix) or a symbol reference.  
*/
if (*expression == '(')
{
  /*
    Handle parenthesized subexpression.
  */
  if (depth >= FxMaxParenthesisDepth)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
        "UnableToParseExpression","`%s'",expression);
      FxReturn(0.0);
    }
  expression++;  /* skip '(' */
  alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,beta,
    exception);
  /*
    Advance past matching ')' if present.
  */
  while ((*expression != '\0') && (*expression != ')'))
    expression++;
  if (*expression == ')')
    expression++;
  FxReturn(alpha);
}
else if (IsFxFunction(expression,"abs",3) != MagickFalse)
{
  /*
    abs(expression)
  */
  p=expression+3;  /* skip 'abs' */
  while (isspace((int) (unsigned char) *p) != 0)
    p++;
  alpha=fabs(FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,beta,
    exception));
  FxReturn(alpha);
}
else if (IsFxFunction(expression,"exp",3) != MagickFalse)
{
  /*
    exp(expression)
  */
  p=expression+3;  /* skip 'exp' */
  while (isspace((int) (unsigned char) *p) != 0)
    p++;
  alpha=exp(FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,beta,
    exception));
  FxReturn(alpha);
}
else if (LocaleNCompare(expression,"pi",2) == 0)
{
  /*
    pi constant
  */
  expression+=2;
  FxReturn(MagickPI);
}
else if ((LocaleNCompare(expression,"e",1) == 0) && (isalpha((int) (unsigned char) *(expression+1)) == 0))
{
  /*
    e constant
  */
  expression++;
  FxReturn(MagickE);
}
else if (IsFxFunction(expression,"if",2) != MagickFalse)
{
  /*
    if(condition, true_expr, false_expr)
    Example usage:
      if(expression != 0, 1, 0)
  */
  p=expression+2;  /* skip 'if' */
  while (isspace((int) (unsigned char) *p) != 0)
    p++;
  alpha=FxEvaluateConditionalExpression(fx_info,channel,x,y,p,depth+1,beta,
    exception);
  FxReturn(alpha);
}
/*
  If none of the above matched, interpret the expression as numeric and/or symbol.
*/
subexpression=DestroyString(subexpression);
q=(char *) expression;
alpha=InterpretSiPrefixValue(expression,&q);
if (q == expression)
  alpha=FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception);
FxReturn(alpha);