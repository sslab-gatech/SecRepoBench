/*
    Evaluate mathematical expressions and functions in the provided string.
    Check for parentheses and recursively evaluate enclosed expressions,
    ensuring they don't exceed a certain depth.
  */
  if (*expression == '(')
    {
      p=expression+1;
      while ((*p != ')') && (*p != '\0'))
        p++;
      if (*p == '\0')
        {
          (void) ThrowMagickException(exception,GetMagickModule(),
            OptionError,"UnableToParseExpression","`%s'",expression);
          FxReturn(0.0);
        }
      (void) CopyMagickString(subexpression,expression+1,(size_t) (p-expression));
      subexpression[p-expression-1]='\0';
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,subexpression,depth+1,
        beta,exception);
      FxReturn(alpha);
    }

  /*
    Use a switch statement to handle different operators or function names
    at the beginning of the expression.
  */
  if (isalpha((int) ((unsigned char) *expression)) != 0)
    {
      p=expression;
      while (isalnum((int) ((unsigned char) *p)) || (*p == '_'))
        p++;
      (void) CopyMagickString(subexpression,expression,(size_t) (p-expression+1));
      if (LocaleCompare(subexpression,"pi") == 0)
        FxReturn(MagickPI);
      if (LocaleCompare(subexpression,"e") == 0)
        FxReturn(MagickE);
      if (LocaleCompare(subexpression,"phi") == 0)
        FxReturn((1.0+sqrt(5.0))/2.0);
      if (IsFxFunction(subexpression,"abs",3) != MagickFalse)
        {
          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,beta,
            exception);
          FxReturn(fabs(alpha));
        }
      if (IsFxFunction(subexpression,"sin",3) != MagickFalse)
        {
          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,beta,
            exception);
          FxReturn(sin(alpha));
        }
      if (IsFxFunction(subexpression,"cos",3) != MagickFalse)
        {
          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,beta,
            exception);
          FxReturn(cos(alpha));
        }
      if (IsFxFunction(subexpression,"tan",3) != MagickFalse)
        {
          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,beta,
            exception);
          FxReturn(tan(alpha));
        }
      if (IsFxFunction(subexpression,"exp",3) != MagickFalse)
        {
          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,beta,
            exception);
          FxReturn(exp(alpha));
        }
      if (IsFxFunction(subexpression,"log",3) != MagickFalse)
        {
          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,beta,
            exception);
          FxReturn(log(alpha));
        }
      if (IsFxFunction(subexpression,"sqrt",4) != MagickFalse)
        {
          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,beta,
            exception);
          FxReturn(sqrt(alpha));
        }
      if (IsFxFunction(subexpression,"pow",3) != MagickFalse)
        {
          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,beta,
            exception);
          gamma=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,beta,
            exception);
          FxReturn(pow(alpha,gamma));
        }
      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
        "UnrecognizedFunction","`%s'",subexpression);
      FxReturn(0.0);
    }