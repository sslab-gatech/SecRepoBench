// Check for parentheses and recursively evaluate enclosed expressions
  if (*expression == '(')
  {
    size_t length = strlen(expression);
    char *parentheses_expr = AcquireQuantumMemory(length + 1, sizeof(*parentheses_expr));
    if (parentheses_expr == NULL)
    {
      (void) ThrowMagickException(exception, GetMagickModule(), ResourceLimitError,
        "MemoryAllocationFailed", "Unable to allocate memory for parentheses expression");
      FxReturn(0.0);
    }
    register ssize_t i;
    size_t count = 0;
    for (i = 1; i < (ssize_t)length; i++)
    {
      if (expression[i] == '(')
        count++;
      else if (expression[i] == ')')
      {
        if (count == 0)
          break;
        count--;
      }
      parentheses_expr[i - 1] = expression[i];
    }
    if (i == length || count != 0)
    {
      (void) ThrowMagickException(exception, GetMagickModule(), OptionError,
        "UnbalancedParentheses", "Unbalanced parentheses in expression `%s'", expression);
      parentheses_expr = DestroyString(parentheses_expr);
      FxReturn(0.0);
    }
    parentheses_expr[i - 1] = '\0';
    alpha = FxEvaluateSubexpression(fx_info, channel, x, y, parentheses_expr, depth + 1, beta, exception);
    if (exception->severity >= ErrorException)
    {
      parentheses_expr = DestroyString(parentheses_expr);
      FxReturn(0.0);
    }
    parentheses_expr = DestroyString(parentheses_expr);
    if (depth > FxMaxSubexpressionDepth)
    {
      (void) ThrowMagickException(exception, GetMagickModule(), OptionError,
        "ExpressionTooDeep", "Maximum subexpression depth exceeded in `%s'", expression);
      FxReturn(0.0);
    }
    p = expression + i + 1;
  }

  // Handle mathematical constants like pi and e
  if (LocaleCompare(expression, "pi") == 0)
  {
    FxReturn(MagickPI);
  }
  else if (LocaleCompare(expression, "e") == 0)
  {
    FxReturn(MagickE);
  }

  // Recognize math functions and evaluate using C math library
  if (IsFxFunction(expression, "sin", 3) != MagickFalse)
  {
    gamma = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 3, depth + 1, beta, exception);
    FxReturn(sin(gamma));
  }
  else if (IsFxFunction(expression, "cos", 3) != MagickFalse)
  {
    gamma = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 3, depth + 1, beta, exception);
    FxReturn(cos(gamma));
  }
  else if (IsFxFunction(expression, "tan", 3) != MagickFalse)
  {
    gamma = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 3, depth + 1, beta, exception);
    FxReturn(tan(gamma));
  }
  else if (IsFxFunction(expression, "exp", 3) != MagickFalse)
  {
    gamma = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 3, depth + 1, beta, exception);
    FxReturn(exp(gamma));
  }
  else if (IsFxFunction(expression, "log", 3) != MagickFalse)
  {
    gamma = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 3, depth + 1, beta, exception);
    FxReturn(log(gamma));
  }
  else if (IsFxFunction(expression, "sqrt", 4) != MagickFalse)
  {
    gamma = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 4, depth + 1, beta, exception);
    FxReturn(sqrt(gamma));
  }

  // Logical or looping structures like if, for, while can be handled here
  if (IsFxKeyword(expression, "if", 2) != MagickFalse)
  {
    q = strchr(expression + 2, '(');
    if (q == NULL)
    {
      (void) ThrowMagickException(exception, GetMagickModule(), OptionError,
        "MissingOpenParenthesis", "Expected open parenthesis after keyword `if` in `%s'", expression);
      FxReturn(0.0);
    }
    *q = '\0';
    q++;
    r = strchr(q, ')');
    if (r == NULL)
    {
      (void) ThrowMagickException(exception, GetMagickModule(), OptionError,
        "MissingCloseParenthesis", "Expected close parenthesis after condition in `if` statement in `%s'", expression);
      FxReturn(0.0);
    }
    *r = '\0';
    double condition_value = FxEvaluateSubexpression(fx_info, channel, x, y, q, depth + 1, beta, exception);
    if (condition_value != 0.0)
    {
      FxReturn(FxEvaluateSubexpression(fx_info, channel, x, y, r + 1, depth + 1, beta, exception));
    }
    else
    {
      s = strchr(r + 1, 'e'); // Assuming the else clause starts with 'else'
      if (s == NULL)
      {
        FxReturn(0.0);
      }
      FxReturn(FxEvaluateSubexpression(fx_info, channel, x, y, s + 4, depth + 1, beta, exception));
    }
  }