/*
    Check for leading parentheses indicating a subexpression. If found, recursively
    evaluate the content inside the parentheses.
  */
  while (isspace((int) ((unsigned char) *expression)) != 0)
    expression++;
  if (*expression == '(')
  {
    expression++;
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,beta,
      exception);
    /* Advance to closing parenthesis (if present). */
    while ((*expression != '\0') && (*expression != ')'))
      expression++;
    if (*expression == ')')
      expression++;
    FxReturn(alpha);
  }

  /*
    Check for recognized math functions (e.g., abs, acos, exp). Evaluate the
    function by recursively computing its argument, then return the result.
    Additional functions (asin, atan, cos, log, etc.) can be handled similarly.
  */
#if defined(MAGICKCORE_HAVE_ACOS)
  if (IsFxFunction(expression,"acos",4) != MagickFalse)
  {
    expression+=4;
    while (isspace((int) ((unsigned char) *expression)) != 0)
      expression++;
    if (*expression == '(')
      expression++;
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,beta,
      exception);
    while ((*expression != '\0') && (*expression != ')'))
      expression++;
    if (*expression == ')')
      expression++;
    FxReturn(acos(alpha));
  }
#endif
  if (IsFxFunction(expression,"abs",3) != MagickFalse)
  {
    expression+=3;
    while (isspace((int) ((unsigned char) *expression)) != 0)
      expression++;
    if (*expression == '(')
      expression++;
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,beta,
      exception);
    while ((*expression != '\0') && (*expression != ')'))
      expression++;
    if (*expression == ')')
      expression++;
    FxReturn(fabs(alpha));
  }
  if (IsFxFunction(expression,"exp",3) != MagickFalse)
  {
    expression+=3;
    while (isspace((int) ((unsigned char) *expression)) != 0)
      expression++;
    if (*expression == '(')
      expression++;
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,beta,
      exception);
    while ((*expression != '\0') && (*expression != ')'))
      expression++;
    if (*expression == ')')
      expression++;
    FxReturn(exp(alpha));
  }

  /*
    Handle special constants (e.g., pi, e) by returning their defined values.
    If not available via math.h macros, numeric approximations may be used.
  */
#if defined(M_PI)
  if (LocaleNCompare(expression,"pi",2) == 0)
  {
    expression+=2;
    FxReturn((double) M_PI);
  }
#else
  if (LocaleNCompare(expression,"pi",2) == 0)
  {
    expression+=2;
    FxReturn(3.14159265358979323846);
  }
#endif
#if defined(M_E)
  if (LocaleNCompare(expression,"e",1) == 0)
  {
    expression++;
    FxReturn((double) M_E);
  }
#else
  if (LocaleNCompare(expression,"e",1) == 0)
  {
    expression++;
    FxReturn(2.7182818284590452354);
  }
#endif

  /*
    Basic support for keywords like "if", "for", "while" could be introduced here
    by parsing and evaluating logical / looping structures. For simplicity,
    unrecognized or malformed keywords will fall back to the default handling below.
  */

  /*
    If we reach this point, no direct function/parenthesis/special keyword was matched.
    The code below is the fallback for numeric/symbol parsing.
  */