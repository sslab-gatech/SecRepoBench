while (isspace((int) ((unsigned char) *expression)) != 0)
    expression++;
  if (*expression == '(')
    {
      size_t
        level = 0;

      expression++;
      p=(const char *) expression;
      for (q=subexpression; *expression != '\0'; expression++)
      {
        if (*expression == '(')
          level++;
        if (*expression == ')')
          {
            if (level == 0)
              break;
            level--;
          }
        if ((size_t) (expression-p) < (MagickPathExtent-1))
          *q++=(*expression);
        else
          break;
      }
      *q='\0';
      if (*expression == '\0')
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            "UnbalancedParenthesis","`%s'",subexpression);
          FxReturn(0.0);
        }
      expression++;
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,beta,
        exception);
      while (isspace((int) ((unsigned char) *expression)) != 0)
        expression++;
      if (*expression == '\0')
        FxReturn(alpha);
      p=FxOperatorPrecedence(expression,exception);
      if (p == (const char *) NULL)
        FxReturn(alpha);
      (void) CopyMagickString(subexpression,expression,(size_t)
        (p-expression+1));
      *beta=FxEvaluateSubexpression(fx_info,channel,x,y,p+1,depth+1,beta,
        exception);
      switch ((unsigned char) *p)
      {
        case '^':
        {
          *beta=pow(alpha,*beta);
          FxReturn(*beta);
        }
        case '*':
        case ExponentialNotation:
        {
          FxReturn(alpha*(*beta));
        }
        case '/':
        {
          FxReturn(PerceptibleReciprocal(*beta)*alpha);
        }
        case '%':
        {
          FxReturn(fmod(alpha,*beta));
        }
        case '+':
        {
          FxReturn(alpha+(*beta));
        }
        case '-':
        {
          FxReturn(alpha-(*beta));
        }
        case '<':
        {
          FxReturn(alpha < *beta ? 1.0 : 0.0);
        }
        case LessThanEqualOperator:
        {
          FxReturn(alpha <= *beta ? 1.0 : 0.0);
        }
        case '>':
        {
          FxReturn(alpha > *beta ? 1.0 : 0.0);
        }
        case GreaterThanEqualOperator:
        {
          FxReturn(alpha >= *beta ? 1.0 : 0.0);
        }
        case EqualOperator:
        {
          FxReturn(fabs(alpha-(*beta)) < MagickEpsilon ? 1.0 : 0.0);
        }
        case NotEqualOperator:
        {
          FxReturn(fabs(alpha-(*beta)) >= MagickEpsilon ? 1.0 : 0.0);
        }
        case '&':
        {
          *beta=(double) ((size_t) (alpha+0.5) & (size_t) (*beta+0.5));
          FxReturn(*beta);
        }
        case '|':
        {
          *beta=(double) ((size_t) (alpha+0.5) | (size_t) (*beta+0.5));
          FxReturn(*beta);
        }
        case LogicalAndOperator:
        {
          if (alpha <= 0.0)
            {
              *beta=0.0;
              FxReturn(*beta);
            }
          *beta=(*beta > 0.0) ? 1.0 : 0.0;
          FxReturn(*beta);
        }
        case LogicalOrOperator:
        {
          if (alpha > 0.0)
            {
             *beta=1.0;
             FxReturn(*beta);
            }
          *beta=(*beta > 0.0) ? 1.0 : 0.0;
          FxReturn(*beta);
        }
        default:
          break;
      }
      FxReturn(alpha);
    }
  if (isdigit((int) ((unsigned char) *expression)) != 0)
    {
      alpha=strtod(expression,&q);
      if (q != expression)
        {
          expression=q;
          FxReturn(alpha);
        }
    }
  if (*expression == '-')
    {
      expression++;
      alpha=(-FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,
        beta,exception));
      FxReturn(alpha);
    }
  if (*expression == '+')
    {
      expression++;
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,
        beta,exception);
      FxReturn(alpha);
    }
  if (*expression == '!')
    {
      expression++;
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,
        beta,exception);
      FxReturn(alpha == 0.0 ? 1.0 : 0.0);
    }
  if (LocaleNCompare(expression,"abs(",4) == 0)
    {
      expression+=4;
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,
        beta,exception);
      FxReturn(fabs(alpha));
    }
  if (LocaleNCompare(expression,"acos(",5) == 0)
    {
      expression+=5;
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,
        beta,exception);
      if ((alpha < -1.0) || (alpha > 1.0))
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            "ArccosineOfXMustBeBetweenNeg1And1","`%g'",alpha);
          FxReturn(0.0);
        }
      FxReturn(acos(alpha));
    }
  if (LocaleNCompare(expression,"acosh(",6) == 0)
    {
      expression+=6;
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,
        beta,exception);
      if (alpha < 1.0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            "ArccoshOfXMustBeGreaterThanOrEqualTo1","`%g'",alpha);
          FxReturn(0.0);
        }
      FxReturn(acosh(alpha));
    }
  if (LocaleNCompare(expression,"angle(",6) == 0)
    {
      double
        x_value,
        y_value;

      expression+=6;
      x_value=FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,
        beta,exception);
      while (isspace((int) ((unsigned char) *expression)) != 0)
        expression++;
      if (*expression != ',')
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            "UnrecognizedExpression","`%s'",expression);
          FxReturn(0.0);
        }
      expression++;
      y_value=FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,
        beta,exception);
      FxReturn(atan2(y_value,x_value)*RadiansToDegrees);
    }
  if (LocaleNCompare(expression,"asin(",5) == 0)
    {
      expression+=5;
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,
        beta,exception);
      if ((alpha < -1.0) || (alpha > 1.0))
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            "ArcsinOfXMustBeBetweenNeg1And1","`%g'",alpha);
          FxReturn(0.0);
        }
      FxReturn(asin(alpha));
    }
  if (LocaleNCompare(expression,"asinh(",6) == 0)
    {
      expression+=6;
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,
        beta,exception);
      FxReturn(asinh(alpha));
    }
  if (LocaleNCompare(expression,"atan(",5) == 0)
    {
      expression+=5;
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,
        beta,exception);
      FxReturn(atan(alpha));
    }
  if (LocaleNCompare(expression,"atan2(",6) == 0)
    {
      double
        x_value,
        y_value;

      expression+=6;
      x_value=FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,
        beta,exception);
      while (isspace((int) ((unsigned char) *expression)) != 0)
        expression++;
      if (*expression != ',')
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            "UnrecognizedExpression","`%s'",expression);
          FxReturn(0.0);
        }
      expression++;
      y_value=FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,
        beta,exception);
      FxReturn(atan2(y_value,x_value));
    }
  if (LocaleNCompare(expression,"atanh(",6) == 0)
    {
      expression+=6;
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,
        beta,exception);
      if ((alpha <= -1.0) || (alpha >= 1.0))
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            "ArctanhOfXMustBeBetweenNeg1And1","`%g'",alpha);
          FxReturn(0.0);
        }
      FxReturn(atanh(alpha));
    }
  if (LocaleNCompare(expression,"ceil(",5) == 0)
    {
      expression+=5;
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,
        beta,exception);
      FxReturn(ceil(alpha));
    }
  if (LocaleNCompare(expression,"cos(",4) == 0)
    {
      expression+=4;
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,
        beta,exception);
      FxReturn(cos(alpha));
    }
  if (LocaleNCompare(expression,"cosh(",5) == 0)
    {
      expression+=5;
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,
        beta,exception);
      FxReturn(cosh(alpha));
    }
  if (LocaleNCompare(expression,"degrees(",8) == 0)
    {
      expression+=8;
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,
        beta,exception);
      FxReturn(alpha*RadiansToDegrees);
    }
  if (LocaleNCompare(expression,"exp(",4) == 0)
    {
      expression+=4;
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,
        beta,exception);
      FxReturn(exp(alpha));
    }
  if (LocaleNCompare(expression,"floor(",6) == 0)
    {
      expression+=6;
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,
        beta,exception);
      FxReturn(floor(alpha));
    }
  if (LocaleNCompare(expression,"hypot(",6) == 0)
    {
      double
        x_value,
        y_value;

      expression+=6;
      x_value=FxEvaluateSubexpression(fx_info,channel,x,y,expression,depth+1,
        beta,exception);
      while (isspace((int) ((unsigned char) *expression)) != 0)
        expression++;
      if (*expression != ',')
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            "UnrecognizedExpression","`%s'",expression);