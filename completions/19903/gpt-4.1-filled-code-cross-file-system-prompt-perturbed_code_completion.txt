/*
  Evaluate parenthesis-enclosed subexpressions.
*/
if (*expression == '(')
  {
    register ssize_t
      i;

    ssize_t
      level;

    const char
      *subexpr_start,
      *subexpr_end;

    /*
      Find the matching closing parenthesis.
    */
    subexpr_start=expression+1;
    subexpr_end=subexpr_start;
    level=1;
    for (i=0; (level > 0) && (*subexpr_end != '\0'); i++)
      {
        if (*subexpr_end == '(')
          level++;
        else
          if (*subexpr_end == ')')
            level--;
        if (level > 0)
          subexpr_end++;
      }
    if (level != 0)
      {
        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
          "UnbalancedParenthesis","`%s'",expression);
        FxReturn(0.0);
      }
    /*
      Copy the subexpression inside the parenthesis.
    */
    (void) CopyMagickString(subexpression,subexpr_start,(size_t) (subexpr_end-subexpr_start+1));
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,subexpression,depth+1,beta,exception);
    /*
      If there is more after the parenthesis, evaluate it as a multiplication.
    */
    if (*(subexpr_end+1) != '\0')
      {
        gamma=FxEvaluateSubexpression(fx_info,channel,x,y,subexpr_end+1,depth+1,beta,exception);
        FxReturn(alpha*gamma);
      }
    FxReturn(alpha);
  }

/*
  Check for functions and constants.
*/
{
  static const struct {
    const char *name;
    double (*func1)(double);
    double (*func2)(double,double);
    int args;
  } fx_functions[] = {
    { "abs", fabs, NULL, 1 },
    { "acos", acos, NULL, 1 },
#if defined(MAGICKCORE_HAVE_ACOSH)
    { "acosh", acosh, NULL, 1 },
#endif
    { "asin", asin, NULL, 1 },
#if defined(MAGICKCORE_HAVE_ASINH)
    { "asinh", asinh, NULL, 1 },
#endif
    { "atan", atan, NULL, 1 },
#if defined(MAGICKCORE_HAVE_ATANH)
    { "atanh", atanh, NULL, 1 },
#endif
    { "ceil", ceil, NULL, 1 },
    { "cos", cos, NULL, 1 },
    { "cosh", cosh, NULL, 1 },
    { "exp", exp, NULL, 1 },
    { "floor", floor, NULL, 1 },
    { "log", log, NULL, 1 },
    { "log10", log10, NULL, 1 },
    { "round", round, NULL, 1 },
    { "sin", sin, NULL, 1 },
    { "sinh", sinh, NULL, 1 },
    { "sqrt", sqrt, NULL, 1 },
    { "tan", tan, NULL, 1 },
    { "tanh", tanh, NULL, 1 },
    { "pow", NULL, pow, 2 },
    { "atan2", NULL, atan2, 2 },
    { NULL, NULL, NULL, 0 }
  };
  const char *p = expression;
  while (isalpha((int) ((unsigned char) *p)) || (*p == '_'))
    p++;
  if (p > expression)
    {
      size_t len = (size_t)(p - expression);
      for (int i = 0; fx_functions[i].name != NULL; i++)
        {
          if (LocaleNCompare(expression, fx_functions[i].name, len) == 0 &&
              strlen(fx_functions[i].name) == len)
            {
              /* Function matched */
              while (isspace((int) ((unsigned char) *p)) != 0)
                p++;
              if (*p != '(')
                break;
              /* Parse argument(s) */
              char *arg1 = AcquireString(p+1);
              char *arg2 = NULL;
              ssize_t level = 1;
              const char *q = p+1;
              const char *sep = NULL;
              while (*q != '\0' && level > 0)
                {
                  if (*q == '(')
                    level++;
                  else if (*q == ')')
                    level--;
                  else if ((*q == ',') && (level == 1) && (fx_functions[i].args == 2))
                    sep = q;
                  q++;
                }
              if (level != 0)
                {
                  arg1=DestroyString(arg1);
                  (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
                    "UnbalancedParenthesis","`%s'",expression);
                  FxReturn(0.0);
                }
              if (fx_functions[i].args == 1)
                {
                  size_t arglen = (sep ? (size_t)(sep-(p+1)) : (size_t)((q-1)-(p+1)));
                  (void) CopyMagickString(arg1, p+1, arglen+1);
                  double v = FxEvaluateSubexpression(fx_info,channel,x,y,arg1,depth+1,beta,exception);
                  arg1=DestroyString(arg1);
                  FxReturn(fx_functions[i].func1(v));
                }
              else if (fx_functions[i].args == 2)
                {
                  if (sep == NULL)
                    {
                      arg1=DestroyString(arg1);
                      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
                        "UnableToParseExpression","`%s'",expression);
                      FxReturn(0.0);
                    }
                  size_t arg1len = (size_t)(sep-(p+1));
                  (void) CopyMagickString(arg1, p+1, arg1len+1);
                  arg2 = AcquireString(sep+1);
                  size_t arg2len = (size_t)((q-1)-(sep+1));
                  (void) CopyMagickString(arg2, sep+1, arg2len+1);
                  double v1 = FxEvaluateSubexpression(fx_info,channel,x,y,arg1,depth+1,beta,exception);
                  double v2 = FxEvaluateSubexpression(fx_info,channel,x,y,arg2,depth+1,beta,exception);
                  arg1=DestroyString(arg1);
                  arg2=DestroyString(arg2);
                  FxReturn(fx_functions[i].func2(v1,v2));
                }
              break;
            }
        }
      /* Handle constants */
      if ((len == 1 && (expression[0] == 'e' || expression[0] == 'E')) &&
          !isalnum((int) ((unsigned char) *p)))
        FxReturn(MagickE);
      if ((len == 2 && (LocaleNCompare(expression,"pi",2) == 0)) &&
          !isalnum((int) ((unsigned char) *p)))
        FxReturn(MagickPI);
      if ((len == 2 && (LocaleNCompare(expression,"pi",2) == 0)) &&
          !isalnum((int) ((unsigned char) *p)))
        FxReturn(MagickPI);
      /* Handle "if" function: if(cond,expr1,expr2) */
      if (len == 2 && LocaleNCompare(expression,"if",2) == 0)
        {
          while (isspace((int) ((unsigned char) *p)) != 0)
            p++;
          if (*p != '(')
            {
              (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
                "UnableToParseExpression","`%s'",expression);
              FxReturn(0.0);
            }
          /* Parse cond, expr1, expr2 */
          const char *q = p+1;
          ssize_t level = 1;
          const char *sep1 = NULL, *sep2 = NULL;
          while (*q != '\0' && level > 0)
            {
              if (*q == '(')
                level++;
              else if (*q == ')')
                level--;
              else if ((*q == ',') && (level == 1))
                {
                  if (sep1 == NULL)
                    sep1 = q;
                  else if (sep2 == NULL)
                    sep2 = q;
                }
              q++;
            }
          if (level != 0 || sep1 == NULL || sep2 == NULL)
            {
              (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
                "UnableToParseExpression","`%s'",expression);
              FxReturn(0.0);
            }
          char *cond = AcquireString(p+1);
          (void) CopyMagickString(cond, p+1, (size_t)(sep1-(p+1))+1);
          char *expr1 = AcquireString(sep1+1);
          (void) CopyMagickString(expr1, sep1+1, (size_t)(sep2-(sep1+1))+1);
          char *expr2 = AcquireString(sep2+1);
          (void) CopyMagickString(expr2, sep2+1, (size_t)((q-1)-(sep2+1))+1);
          double vcond = FxEvaluateSubexpression(fx_info,channel,x,y,cond,depth+1,beta,exception);
          double v;
          if (fabs(vcond) >= MagickEpsilon)
            v = FxEvaluateSubexpression(fx_info,channel,x,y,expr1,depth+1,beta,exception);
          else
            v = FxEvaluateSubexpression(fx_info,channel,x,y,expr2,depth+1,beta,exception);
          cond=DestroyString(cond);
          expr1=DestroyString(expr1);
          expr2=DestroyString(expr2);
          FxReturn(v);
        }
      /* TODO: handle other keywords like "for", "while" if needed */
    }
}