// Check for mathematical functions and evaluate them
  if (IsFxFunction(expression, "abs", 3) != MagickFalse)
    {
      expression += 3;
      *beta = fabs(FxEvaluateSubexpression(fx_info, channel, x, y, expression, depth + 1, beta, exception));
      FxReturn(*beta);
    }
  else if (IsFxFunction(expression, "acos", 4) != MagickFalse)
    {
      expression += 4;
      *beta = acos(FxEvaluateSubexpression(fx_info, channel, x, y, expression, depth + 1, beta, exception));
      FxReturn(*beta);
    }
  else if (IsFxFunction(expression, "asin", 4) != MagickFalse)
    {
      expression += 4;
      *beta = asin(FxEvaluateSubexpression(fx_info, channel, x, y, expression, depth + 1, beta, exception));
      FxReturn(*beta);
    }
  else if (IsFxFunction(expression, "atan", 4) != MagickFalse)
    {
      expression += 4;
      *beta = atan(FxEvaluateSubexpression(fx_info, channel, x, y, expression, depth + 1, beta, exception));
      FxReturn(*beta);
    }
  else if (IsFxFunction(expression, "exp", 3) != MagickFalse)
    {
      expression += 3;
      *beta = exp(FxEvaluateSubexpression(fx_info, channel, x, y, expression, depth + 1, beta, exception));
      FxReturn(*beta);
    }
  else if (IsFxFunction(expression, "log", 3) != MagickFalse)
    {
      expression += 3;
      *beta = log(FxEvaluateSubexpression(fx_info, channel, x, y, expression, depth + 1, beta, exception));
      FxReturn(*beta);
    }
  else if (IsFxFunction(expression, "sqrt", 4) != MagickFalse)
    {
      expression += 4;
      *beta = sqrt(FxEvaluateSubexpression(fx_info, channel, x, y, expression, depth + 1, beta, exception));
      FxReturn(*beta);
    }
  else if (IsFxFunction(expression, "sin", 3) != MagickFalse)
    {
      expression += 3;
      *beta = sin(FxEvaluateSubexpression(fx_info, channel, x, y, expression, depth + 1, beta, exception));
      FxReturn(*beta);
    }
  else if (IsFxFunction(expression, "cos", 3) != MagickFalse)
    {
      expression += 3;
      *beta = cos(FxEvaluateSubexpression(fx_info, channel, x, y, expression, depth + 1, beta, exception));
      FxReturn(*beta);
    }
  else if (IsFxFunction(expression, "tan", 3) != MagickFalse)
    {
      expression += 3;
      *beta = tan(FxEvaluateSubexpression(fx_info, channel, x, y, expression, depth + 1, beta, exception));
      FxReturn(*beta);
    }
  else if (IsFxFunction(expression, "pi", 2) != MagickFalse)
    {
      expression += 2;
      FxReturn(MagickPI);
    }
  else if (IsFxFunction(expression, "e", 1) != MagickFalse)
    {
      expression += 1;
      FxReturn(MagickE);
    }
  else
    {
      (void) ThrowMagickException(exception, GetMagickModule(), OptionError,
        "UnableToParseExpression", "`%s'", expression);
      FxReturn(0.0);
    }