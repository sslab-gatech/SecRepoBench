Below is the content of a C/C++ function where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
int
xmlAddIDSafe(xmlDocPtr doc, const xmlChar *identifier, xmlAttrPtr attr,
             int streaming, xmlIDPtr *id) {
    xmlIDPtr ret;
    xmlIDTablePtr table;

    if (id != NULL)
        *id = NULL;

    if (doc == NULL) {
	return(-1);
    }
    if ((identifier == NULL) || (identifier[0] == 0)) {
	return(0);
    }
    if (attr == NULL) {
	return(-1);
    }

    /*
     * Create the ID table if needed.
     */
    table = (xmlIDTablePtr) doc->ids;
    if (table == NULL)  {
        doc->ids = table = xmlHashCreateDict(0, doc->dict);
        if (table == NULL)
            return(-1);
    } else {
        ret = xmlHashLookup(table, identifier);
        if (ret != NULL) {
            /*
             * Update the attribute to make entities work.
             */
            if (ret->attr != NULL) {
                ret->attr->id = NULL;
                ret->attr = attr;
            }
	    attr->atype = XML_ATTRIBUTE_ID;
            attr->id = ret;
            return(0);
        }
    }

    ret = (xmlIDPtr) xmlMalloc(sizeof(xmlID));
    if (ret == NULL)
	return(-1);
    memset(ret, 0, sizeof(*ret));

    /*
     * fill the structure.
     */
    ret->doc = doc;
    ret->value = xmlStrdup(identifier);
    if (ret->value == NULL) {
        xmlFreeID(ret);
        return(-1);
    }
    // Check if the function is operating in streaming mode. If it is, handle the case
    // where the attribute is temporary and will disappear, by setting the ID's name
    // based on the document's dictionary or duplicating the attribute's name.
    // If not in streaming mode, associate the attribute with the ID.
    // Record the line number from the attribute's parent element.
    // Add the new ID to the document's ID table. If adding the entry fails, free the ID
    // and return an error. Set the attribute type to ID, and associate the attribute
    // with the ID if not in streaming mode. If an ID pointer is provided as an argument,
    // assign the newly created ID to it. Return success.
    // <MASK>
}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// valid.c
xmlIDPtr
xmlAddID(xmlValidCtxtPtr ctxt, xmlDocPtr doc, const xmlChar *value,
         xmlAttrPtr attr) {
    xmlIDPtr id;
    int res;

    res = xmlAddIDSafe(doc, value, attr, xmlIsStreaming(ctxt), &id);
    if (res < 0) {
        xmlVErrMemory(ctxt);
    }
#ifdef LIBXML_VALID_ENABLED
    else if (res == 0) {
        if (ctxt != NULL) {
            /*
             * The id is already defined in this DTD.
             */
            xmlErrValidNode(ctxt, attr->parent, XML_DTD_ID_REDEFINED,
                            "ID %s already defined\n", value, NULL, NULL);
        }
    }
#endif /* LIBXML_VALID_ENABLED */

    return(id);
}

// the below code fragment can be found in:
// valid.c
int
xmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {
    xmlIDTablePtr table;

    if (doc == NULL) return(-1);
    if ((attr == NULL) || (attr->id == NULL)) return(-1);

    table = (xmlIDTablePtr) doc->ids;
    if (table == NULL)
        return(-1);

    if (xmlHashRemoveEntry(table, attr->id->value, xmlFreeIDTableEntry) < 0)
        return(-1);

    attr->atype = 0;
    attr->id = NULL;

    return(0);
}

// the below code fragment can be found in:
// valid.c
xmlAttrPtr
xmlGetID(xmlDocPtr doc, const xmlChar *ID) {
    xmlIDTablePtr table;
    xmlIDPtr id;

    if (doc == NULL) {
	return(NULL);
    }

    if (ID == NULL) {
	return(NULL);
    }

    table = (xmlIDTablePtr) doc->ids;
    if (table == NULL)
        return(NULL);

    id = xmlHashLookup(table, ID);
    if (id == NULL)
	return(NULL);
    if (id->attr == NULL) {
	/*
	 * We are operating on a stream, return a well known reference
	 * since the attribute node doesn't exist anymore
	 */
	return((xmlAttrPtr) doc);
    }
    return(id->attr);
}

// the below code fragment can be found in:
// valid.c
int
xmlIsID(xmlDocPtr doc, xmlNodePtr elem, xmlAttrPtr attr) {
    if ((attr == NULL) || (attr->name == NULL)) return(0);
    if ((attr->ns != NULL) && (attr->ns->prefix != NULL) &&
        (!strcmp((char *) attr->name, "id")) &&
        (!strcmp((char *) attr->ns->prefix, "xml")))
	return(1);
    if (doc == NULL) return(0);
    if ((doc->intSubset == NULL) && (doc->extSubset == NULL) &&
        (doc->type != XML_HTML_DOCUMENT_NODE)) {
	return(0);
    } else if (doc->type == XML_HTML_DOCUMENT_NODE) {
        if ((xmlStrEqual(BAD_CAST "id", attr->name)) ||
	    ((xmlStrEqual(BAD_CAST "name", attr->name)) &&
	    ((elem == NULL) || (xmlStrEqual(elem->name, BAD_CAST "a")))))
	    return(1);
	return(0);
    } else if (elem == NULL) {
	return(0);
    } else {
	xmlAttributePtr attrDecl = NULL;

	xmlChar felem[50];
	xmlChar *fullelemname;
        const xmlChar *aprefix;

	fullelemname = (elem->ns != NULL && elem->ns->prefix != NULL) ?
	    xmlBuildQName(elem->name, elem->ns->prefix, felem, 50) :
	    (xmlChar *)elem->name;
        if (fullelemname == NULL)
            return(-1);

        aprefix = (attr->ns != NULL) ? attr->ns->prefix : NULL;

	if (fullelemname != NULL) {
	    attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, fullelemname,
		                          attr->name, aprefix);
	    if ((attrDecl == NULL) && (doc->extSubset != NULL))
		attrDecl = xmlGetDtdQAttrDesc(doc->extSubset, fullelemname,
					      attr->name, aprefix);
	}

	if ((fullelemname != felem) && (fullelemname != elem->name))
	    xmlFree(fullelemname);

        if ((attrDecl != NULL) && (attrDecl->atype == XML_ATTRIBUTE_ID))
	    return(1);
    }
    return(0);
}

// the below code fragment can be found in:
// testapi.c
static int
test_xmlIsID(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr elem; /* the element carrying the attribute */
    int n_elem;
    xmlAttrPtr attr; /* the attribute */
    int n_attr;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
    for (n_attr = 0;n_attr < gen_nb_xmlAttrPtr;n_attr++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        elem = gen_xmlNodePtr(n_elem, 1);
        attr = gen_xmlAttrPtr(n_attr, 2);

        ret_val = xmlIsID(doc, elem, attr);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNodePtr(n_elem, elem, 1);
        des_xmlAttrPtr(n_attr, attr, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsID",
	           xmlMemBlocks() - mem_base);
	    test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf(" %d", n_attr);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).