if (!decode || !compressed || !raw || nCompressed < 20)
        return EXR_ERR_INVALID_ARGUMENT;

    pctxt = EXR_CCTXT(decode->context);
    if (!pctxt) return EXR_ERR_INVALID_ARGUMENT;

    im = readUInt(compressed);
    iM = readUInt(compressed + 4);
    nBits = readUInt(compressed + 12);

    if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE)
        return EXR_ERR_INVALID_TABLE;

    ptr = compressed + 20;
    nBytes = (nBits + 7) / 8;

    if (nBytes > nCompressed - 20)
        return EXR_ERR_CORRUPT_CHUNK;

    if (sparebytes != internal_exr_huf_decompress_spare_bytes())
        return EXR_ERR_INVALID_ARGUMENT;

    if (pctxt->flags & EXR_CONTEXT_FLAG_USE_FAST_HUFFMAN && nBits > 128)
    {
        FastHufDecoder fhd(ptr, nCompressed - 20, im, iM, iM);
        if (nBytes > nCompressed - 20)
            return EXR_ERR_CORRUPT_CHUNK;
        fhd.decode((unsigned char*)ptr, nBits, raw, nRawSize);
    }
    else
    {
        uint64_t* freq = (uint64_t*)spare;
        HufDec* hdec = (HufDec*)(freq + HUF_ENCSIZE);

        hufClearDecTable(hdec);
        rv = hufUnpackEncTable(&ptr, nCompressed - 20, im, iM, freq);
        if (rv != EXR_ERR_SUCCESS) return rv;

        if (nBits > 8 * (nCompressed - (ptr - compressed)))
            return EXR_ERR_CORRUPT_CHUNK;

        rv = hufBuildDecTable(freq, im, iM, hdec);
        if (rv != EXR_ERR_SUCCESS) return rv;

        rv = hufDecode(freq, hdec, ptr, nBits, iM, nRawSize, raw);
        if (rv != EXR_ERR_SUCCESS) return rv;
    }