if (decode && decode->context)
        pctxt = EXR_CCTXT (decode->context);

    rv = EXR_ERR_SUCCESS;

    if (nCompressed < 20)
    {
        if (nRawSize != 0)
            return EXR_ERR_NOT_ENOUGH_DATA;

        return EXR_ERR_SUCCESS;
    }

    im = unaligned_load32(compressed);
    iM = unaligned_load32(compressed + 4);
    uint32_t tableLength = unaligned_load32(compressed + 8);
    nBits = unaligned_load32(compressed + 12);
    // Skip 4 bytes reserved for future use

    if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE)
        return EXR_ERR_INVALID_ARGUMENT;

    ptr = compressed + 20;
    nBytes = (nBits + 7) / 8;

    if (ptr + nBytes > compressed + nCompressed)
        return EXR_ERR_NOT_ENOUGH_DATA;

    // Standard Huffman decoding path
    {
        uint64_t* freq;
        HufDec* hdec;

        if (sparebytes < internal_exr_huf_decompress_spare_bytes())
            return EXR_ERR_INVALID_ARGUMENT;

        freq = (uint64_t*)spare;
        hdec = (HufDec*)(freq + HUF_ENCSIZE);

        hufClearDecTable(hdec);

        rv = internal_huf_unpack_enc_table(&ptr, nCompressed - (ptr - compressed), im, iM, freq);
        if (rv != EXR_ERR_SUCCESS)
            return rv;

        if (nBits > 8 * (nCompressed - (ptr - compressed)))
            return EXR_ERR_INVALID_ARGUMENT;

        rv = internal_huf_build_dec_table(freq, im, iM, hdec);
        if (rv != EXR_ERR_SUCCESS)
            return rv;

        rv = internal_huf_decode(freq, hdec, ptr, nBits, iM, nRawSize, raw);
        if (rv != EXR_ERR_SUCCESS)
            return rv;
    }