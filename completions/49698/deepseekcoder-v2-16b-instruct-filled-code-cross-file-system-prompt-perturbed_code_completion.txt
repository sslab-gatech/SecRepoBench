// Retrieve the context from the decode structure if available.
    pctxt = decode->context;

    // Check if the compressed data size is at least 20 bytes for a valid header.
    if (nCompressed < 20)
    {
        return EXR_ERR_INVALID_ARGUMENT;
    }

    // Validate that 'im' and 'iM' are within acceptable limits.
    if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE)
    {
        return EXR_ERR_INVALID_ARGUMENT;
    }

    // Ensure there is enough data in the buffer to perform decompression.
    nBytes = (static_cast<uint64_t> (nBits) + 7) / 8;
    if (ptr + nBytes > compressed + nCompressed)
    {
        return EXR_ERR_INVALID_ARGUMENT;
    }

    // Check if fast Huffman decoding is enabled and applicable based on the data size.
    if (FastHufDecoder::enabled () && nBits > 128)
    {
        FastHufDecoder fhd (ptr, nCompressed - (ptr - compressed), im, iM, iM);

        // must be nBytes remaining in buffer
        if (ptr - compressed + nBytes > static_cast<uint64_t> (nCompressed))
        {
            return EXR_ERR_INVALID_ARGUMENT;
        }

        fhd.decode ((unsigned char*) ptr, nBits, raw, nRaw);
    }
    else
    {
        // Clear and unpack the Huffman encoding table for use in decoding.
        hufClearDecTable (hdec);

        hufUnpackEncTable (
            &ptr, nCompressed - (ptr - compressed), im, iM, freq);

        // Build the Huffman decoding table based on frequency data.
        hufBuildDecTable (freq, im, iM, hdec);

        // Execute the appropriate decoding function (fast or standard) and return the result.
        hufDecode (freq, hdec, ptr, nBits, iM, nRaw, raw);
    }

    return rv;