if (decode && decode->context)
        pctxt = EXR_CONST_CAST (const struct _internal_exr_context*, decode->context);

    if (nCompressed < 20)
        return EXR_ERR_CORRUPT_CHUNK;

    im = readUInt (compressed);
    iM = readUInt (compressed + 4);
    nBytes = readUInt (compressed + 8);
    nBits = readUInt (compressed + 12);

    if (im > iM || im >= HUF_ENCSIZE || iM >= HUF_ENCSIZE)
        return EXR_ERR_CORRUPT_CHUNK;

    ptr = compressed + 20;

    if (nCompressed < 20 + nBytes || nRawSize * sizeof (uint16_t) < (nBits + 7) / 8)
        return EXR_ERR_CORRUPT_CHUNK;

    if (fasthuf_decode_enabled () && nRawSize >= 2048)
    {
        FastHufDecoder* fhd = (FastHufDecoder*) spare;
        rv = fasthuf_initialize (pctxt, fhd, &ptr, (int) nBytes, im, iM, HUF_ENCSIZE);
        if (rv != EXR_ERR_SUCCESS)
            return rv;
        return fasthuf_decode (pctxt, fhd, ptr, (int) nBits, raw, (int) nRawSize);
    }
    else
    {
        uint64_t* freq = (uint64_t*) spare;
        HufDec* hdec = (HufDec*) (freq + HUF_ENCSIZE);

        hufClearDecTable (hdec);
        rv = hufUnpackEncTable (&ptr, &nBytes, im, iM, freq);
        if (rv != EXR_ERR_SUCCESS)
            return rv;

        rv = hufBuildDecTable (freq, im, iM, hdec);
        if (rv != EXR_ERR_SUCCESS)
            return rv;

        rv = hufDecode (freq, hdec, ptr, nBits, iM, nRawSize, raw);
        hufFreeDecTable (hdec);
        return rv;
    }