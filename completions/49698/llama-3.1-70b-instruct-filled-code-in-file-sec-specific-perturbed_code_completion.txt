if (decode && decode->context)
    pctxt = (const struct _internal_exr_context*) decode->context;

if (nCompressed < 20)
    return EXR_ERR_CORRUPT_CHUNK;

im = readUInt (compressed);
iM = readUInt (compressed + 4);

if (im >= HUF_ENCSIZE || iM >= HUF_ENCSIZE)
    return EXR_ERR_CORRUPT_CHUNK;

nBytes = readUInt (compressed + 8);
nBits  = readUInt (compressed + 12);

if (nCompressed < nBytes + (nBits + 7) / 8 + 20)
    return EXR_ERR_CORRUPT_CHUNK;

ptr = compressed + 20;

if (fasthuf_decode_enabled () && nRawSize > 0 &&
    nBytes + (nBits + 7) / 8 + 20 == nCompressed)
{
    FastHufDecoder fhd;
    rv = fasthuf_initialize (pctxt, &fhd, &ptr, nBytes, im, iM, iM + 1);
    if (rv!= EXR_ERR_SUCCESS) return rv;
    rv = fasthuf_decode (pctxt, &fhd, ptr, nBits, raw, nRawSize);
    if (rv!= EXR_ERR_SUCCESS) return rv;
}
else
{
    uint64_t*  freq;
    HufDec*    hdec;
    uint64_t*  scode;
    uint32_t   tableLength, dataLength;
    uint8_t*   dataStart;
    uint8_t*   tableStart = (uint8_t*) compressed + 20;
    uint8_t*   tableEnd   = tableStart;

    if (sparebytes!= internal_exr_huf_decompress_spare_bytes ())
        return EXR_ERR_INVALID_ARGUMENT;

    freq  = (uint64_t*) spare;
    hdec  = (HufDec*) (freq + HUF_ENCSIZE);
    scode = (uint64_t*) (hdec + HUF_DECSIZE);

    rv = hufUnpackEncTable (&tableStart, &nBytes, im, iM, scode);
    if (rv!= EXR_ERR_SUCCESS) return rv;

    tableLength =
        (uint32_t) (((uintptr_t) tableEnd) - ((uintptr_t) tableStart));
    dataStart = tableEnd;

    dataLength = (nBits + 7) / 8;

    rv = hufBuildDecTable (scode, im, iM, hdec);
    if (rv!= EXR_ERR_SUCCESS) return rv;

    rv = hufDecode (scode, hdec, dataStart, nBits, iM, nRawSize, raw);
    if (rv!= EXR_ERR_SUCCESS) return rv;

    hufFreeDecTable (hdec);
}
return EXR_ERR_SUCCESS;