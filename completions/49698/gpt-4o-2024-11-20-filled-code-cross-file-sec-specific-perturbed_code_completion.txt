// Ensure the compressed data size is valid
    if (nCompressed < 20)
        return EXR_ERR_CORRUPT_CHUNK;

    // Read the header values
    im = readUInt(compressed);
    iM = readUInt(compressed + 4);
    nBits = readUInt(compressed + 12);

    // Validate the header values
    if (im >= HUF_ENCSIZE || iM >= HUF_ENCSIZE || im > iM)
        return EXR_ERR_CORRUPT_CHUNK;

    // Calculate the number of bytes required for the compressed data
    nBytes = (nBits + 7) / 8;
    ptr = compressed + 20;

    // Ensure the buffer has enough data for decompression
    if (nBytes > nCompressed - 20)
        return EXR_ERR_CORRUPT_CHUNK;

    // Check if fast Huffman decoding is enabled and applicable
    if (FastHufDecoder::enabled() && nBits > 128)
    {
        FastHufDecoder fhd(ptr, nCompressed - (ptr - compressed), im, iM, iM);

        // Validate the remaining buffer size
        if (ptr - compressed + nBytes > nCompressed)
            return EXR_ERR_CORRUPT_CHUNK;

        // Perform fast Huffman decoding
        fhd.decode((unsigned char*)ptr, nBits, raw, nRawSize);
    }
    else
    {
        // Allocate and clear the Huffman decoding table
        HufDec hdec[HUF_DECSIZE];
        hufClearDecTable(hdec);

        // Unpack the Huffman encoding table
        uint64_t freq[HUF_ENCSIZE];
        hufUnpackEncTable(&ptr, nCompressed - (ptr - compressed), im, iM, freq);

        // Build the Huffman decoding table
        hufBuildDecTable(freq, im, iM, hdec);

        // Perform standard Huffman decoding
        rv = hufDecode(freq, hdec, ptr, nBits, iM, nRawSize, raw);
        if (rv != EXR_ERR_SUCCESS)
        {
            hufFreeDecTable(hdec);
            return rv;
        }

        // Free the Huffman decoding table
        hufFreeDecTable(hdec);
    }

    rv = EXR_ERR_SUCCESS;