if (sparebytes != internal_exr_huf_decompress_spare_bytes())
        return EXR_ERR_INVALID_ARGUMENT;

    if (nCompressed < 20)
        return EXR_ERR_CORRUPT_CHUNK;

    im = unaligned_load32(compressed);
    iM = unaligned_load32(compressed + 4);
    uint32_t tableLength = unaligned_load32(compressed + 8);
    nBits = unaligned_load32(compressed + 12);

    if (im >= HUF_ENCSIZE || iM >= HUF_ENCSIZE)
        return EXR_ERR_CORRUPT_CHUNK;

    nBytes = ((uint64_t)nBits + 7) / 8;

    if (20 + tableLength + nBytes > nCompressed)
        return EXR_ERR_CORRUPT_CHUNK;

    ptr = compressed + 20;
    const uint8_t* data = ptr + tableLength;

    uint64_t* freq = (uint64_t*)spare;
    HufDec* hdec = (HufDec*)(freq + HUF_ENCSIZE);

    hufClearDecTable(hdec);

    uint64_t remaining = tableLength;
    rv = hufUnpackEncTable(&ptr, &remaining, im, iM, freq);
    if (rv != EXR_ERR_SUCCESS)
        return rv;
    if (remaining != 0)
        return EXR_ERR_CORRUPT_CHUNK;

    rv = hufBuildDecTable(freq, im, iM, hdec);
    if (rv != EXR_ERR_SUCCESS)
        return rv;

    rv = hufDecode(freq, hdec, data, nBits, iM, (uint32_t)nRawSize, raw);
    return rv;