// <MASK>
    ptr = compressed + 20;

    nBytes = (static_cast<uint64_t> (nBits) + 7) / 8;

    if (ptr + nBytes > compressed + nCompressed)
    {
        notEnoughData ();
        return;
    }

    //
    // Fast decoder needs at least 2x64-bits of compressed data, and
    // needs to be run-able on this platform. Otherwise, fall back
    // to the original decoder
    //

    if (FastHufDecoder::enabled () && nBits > 128)
    {
        FastHufDecoder fhd (ptr, nCompressed - (ptr - compressed), im, iM, iM);

        // must be nBytes remaining in buffer
        if (ptr - compressed + nBytes > static_cast<uint64_t> (nCompressed))
        {
            notEnoughData ();
            return;
        }

        fhd.decode ((unsigned char*) ptr, nBits, raw, nRaw);
    }
    else
    {
        AutoArray<uint64_t, HUF_ENCSIZE> freq;
        AutoArray<HufDec, HUF_DECSIZE>   hdec;

        hufClearDecTable (hdec);

        hufUnpackEncTable (
            &ptr, nCompressed - (ptr - compressed), im, iM, freq);

        try
        {
            if (nBits > 8 * (nCompressed - (ptr - compressed))) invalidNBits ();

            hufBuildDecTable (freq, im, iM, hdec);
            hufDecode (freq, hdec, ptr, nBits, iM, nRaw, raw);
        }
        catch (...)
        {
            hufFreeDecTable (hdec);
            throw;
        }

        hufFreeDecTable (hdec);
    }