// <MASK>
if (nCompressed < 20)
{
    return EXR_ERR_CORRUPT_CHUNK;
}

const uint8_t* ptr = compressed + 20;
nBytes = (nCompressed - 20);

if (decode->fast_huffman_enabled && nBytes >= 16)
{
    FastHufDecoder fhd(ptr, nBytes, im, iM, iM);
    fhd.decode((unsigned char*)raw, nRawSize, raw, nRawSize);
}
else
{
    AutoArray<uint64_t, HUF_ENCSIZE> freq;
    AutoArray<HufDec, HUF_DECSIZE> hdec;

    hufClearDecTable(hdec);
    hufUnpackEncTable(&ptr, nBytes, im, iM, freq);

    if (nBytes < ((nBits + 7) / 8))
    {
        return EXR_ERR_CORRUPT_CHUNK;
    }

    hufBuildDecTable(freq, im, iM, hdec);
    hufDecode(freq, hdec, ptr, nBits, iM, nRawSize, raw);

    hufFreeDecTable(hdec);
}

return EXR_ERR_SUCCESS;