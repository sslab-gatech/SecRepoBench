rv = EXR_ERR_SUCCESS;

if (decode)
    pctxt = EXR_CNTXT (decode);

// Check if compressed data buffer is large enough for the header
if (nCompressed < 20)
    return EXR_ERR_INVALID_ARGUMENT;

// Read header values
ptr = compressed;
im = readUInt (ptr);
iM = readUInt (ptr + 4);
uint32_t tableLength = readUInt (ptr + 8);
nBits = readUInt (ptr + 12);
// Unused: readUInt (ptr + 16);

// Validate im and iM
if (im > HUF_ENCSIZE || iM > HUF_ENCSIZE)
    return EXR_ERR_INVALID_ARGUMENT;

// Calculate number of bytes needed for decompressed data
nBytes = (nBits + 7) / 8;

// Ensure compressed data buffer has enough bytes
if (nCompressed < 20 + tableLength + nBytes)
    return EXR_ERR_INVALID_ARGUMENT;

// Check if raw buffer is large enough
if (nRawSize * sizeof(uint16_t) < nBytes)
    return EXR_ERR_INVALID_ARGUMENT;

// Check if spare buffer is large enough
if (!spare || sparebytes < internal_exr_huf_decompress_spare_bytes())
    return EXR_ERR_INVALID_ARGUMENT;

// Clear and prepare frequency table and decoding table
uint64_t* freq = (uint64_t*) spare;
uint64_t* hdecode = freq + HUF_ENCSIZE;
memset (freq, 0, HUF_ENCSIZE * sizeof (uint64_t));

// Unpack Huffman encoding table
const uint8_t* tableStart = ptr + 20;
const uint8_t* tableEnd = tableStart;
rv = hufUnpackEncTable (&tableEnd, tableStart + tableLength, im, iM, freq);
if (rv != EXR_ERR_SUCCESS)
    return rv;

// Build Huffman decoding table
hufBuildDecTable (freq, im, iM, hdecode);

// Perform decompression
const uint8_t* dataStart = tableEnd;
rv = hufDecode (freq, hdecode, dataStart, nBytes, im, iM, raw, nRawSize);