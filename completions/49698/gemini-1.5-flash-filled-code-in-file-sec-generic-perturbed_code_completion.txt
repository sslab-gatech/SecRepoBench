if (decode) pctxt = decode->pctxt;
    if (nCompressed < 20) return EXR_ERR_CORRUPT_CHUNK;

    im = readUInt (compressed);
    iM = readUInt (compressed + 4);
    nBytes = readUInt (compressed + 8);
    nBits = readUInt (compressed + 12);

    if (im >= HUF_ENCSIZE || iM >= HUF_ENCSIZE || im > iM)
        return EXR_ERR_CORRUPT_CHUNK;

    if (nCompressed < 20 + nBytes) return EXR_ERR_CORRUPT_CHUNK;

    ptr = compressed + 20;

    if (fasthuf_decode_enabled () && nCompressed < 1024 * 1024)
    {
        FastHufDecoder fhd;
        rv = fasthuf_initialize (
            pctxt, &fhd, &ptr, nBytes, im, iM, iM + 1);
        if (rv != EXR_ERR_SUCCESS) return rv;

        rv = fasthuf_decode (
            pctxt, &fhd, ptr, nBits, raw, nRawSize);
        return rv;
    }

    uint64_t*       freq;
    HufDec*         hdecod;
    //    uint64_t*       fHeap;
    //    uint64_t*       scode;

    if (sparebytes != internal_exr_huf_decompress_spare_bytes ())
        return EXR_ERR_INVALID_ARGUMENT;

    freq   = (uint64_t*) spare;
    hdecod = (HufDec*) (freq + HUF_ENCSIZE);

    hufClearDecTable (hdecod);

    rv = hufUnpackEncTable (&ptr, &nBytes, im, iM, freq);
    if (rv != EXR_ERR_SUCCESS) return rv;

    rv = hufBuildDecTable (freq, im, iM, hdecod);
    if (rv != EXR_ERR_SUCCESS)
    {
        hufFreeDecTable (hdecod);
        return rv;
    }

    rv = hufDecode (freq, hdecod, ptr, nBits, iM + 1, nRawSize, raw);

    hufFreeDecTable (hdecod);