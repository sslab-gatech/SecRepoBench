// Retrieve the context from the decode structure if available.
    if (decode != NULL && decode->context != NULL)
        pctxt = decode->context;

    // Check if the compressed data size is at least 20 bytes for a valid header.
    if (nCompressed < 20)
        return EXR_ERR_CORRUPT_CHUNK;

    // Validate that 'im' and 'iM' are within acceptable limits.
    im = readUInt (compressed);
    iM = readUInt (compressed + 4);
    if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE)
        return EXR_ERR_INVALID_ARGUMENT;

    // Ensure there is enough data in the buffer to perform decompression.
    nBytes = (static_cast<uint64_t> (readUInt (compressed + 12)) + 7) / 8;
    if (nBytes > nCompressed - 20)
        return EXR_ERR_CORRUPT_CHUNK;
    ptr = compressed + 20;

    // Check if fast Huffman decoding is enabled and applicable based on the data size.
    // If so, initialize and perform fast Huffman decoding.
    if (FastHufDecoder::enabled () && readUInt (compressed + 12) > 128)
    {
        FastHufDecoder fhd (ptr, nCompressed - 20, im, iM, iM);
        fhd.decode ((unsigned char*) raw, readUInt (compressed + 12), raw, nRawSize / 2);
    }
    // If not, use a slower, standard Huffman decoding method.
    else
    {
        AutoArray<uint64_t, HUF_ENCSIZE> freq;
        AutoArray<HufDec, HUF_DECSIZE>   hdec;

        hufClearDecTable (hdec);
        hufUnpackEncTable (&ptr, nCompressed - 20, im, iM, freq);
        hufBuildDecTable (freq, im, iM, hdec);
        hufDecode (freq, hdec, ptr, readUInt (compressed + 12), iM, nRawSize / 2, raw);
    }

    return EXR_ERR_SUCCESS;