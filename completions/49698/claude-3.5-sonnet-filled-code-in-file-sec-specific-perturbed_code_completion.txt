if (decode && decode->context)
        pctxt = EXR_CONST_CAST(struct _internal_exr_context*, decode->context);

    if (nCompressed < 20)
        return EXR_ERR_CORRUPT_CHUNK;

    im = readUInt(compressed);
    iM = readUInt(compressed + 4);
    
    if (im > iM || im < 0 || iM >= HUF_ENCSIZE)
        return EXR_ERR_CORRUPT_CHUNK;

    ptr = compressed + 20;
    nBytes = nCompressed - 20;

    if (nBytes < readUInt(compressed + 8) + (readUInt(compressed + 12) + 7) / 8)
        return EXR_ERR_CORRUPT_CHUNK;

    if (fasthuf_decode_enabled() && nRawSize >= 256)
    {
        FastHufDecoder* fhd = (FastHufDecoder*)spare;
        rv = fasthuf_initialize(pctxt, fhd, &ptr, readUInt(compressed + 8), im, iM, HUF_ENCSIZE);
        if (rv != EXR_ERR_SUCCESS)
            return rv;

        nBits = readUInt(compressed + 12);
        return fasthuf_decode(pctxt, fhd, ptr, nBits, raw, (int)nRawSize);
    }
    else
    {
        uint64_t* freq = (uint64_t*)spare;
        HufDec* hdec = (HufDec*)(freq + HUF_ENCSIZE);

        hufClearDecTable(hdec);
        rv = hufUnpackEncTable(&ptr, &nBytes, im, iM, freq);
        if (rv != EXR_ERR_SUCCESS)
            return rv;

        rv = hufBuildDecTable(freq, im, iM, hdec);
        if (rv != EXR_ERR_SUCCESS)
            return rv;

        nBits = readUInt(compressed + 12);
        rv = hufDecode(freq, hdec, ptr, nBits, iM, nRawSize, raw);
        hufFreeDecTable(hdec);
        return rv;
    }