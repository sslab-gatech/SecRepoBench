rv = EXR_ERR_SUCCESS;

    /* Verify we have at least 20 bytes for the header and handle trivial case. */
    if (nCompressed < 20)
    {
        if (nRawSize != 0) return EXR_ERR_CORRUPT_CHUNK;
        return EXR_ERR_SUCCESS;
    }

    /* Read header fields (im, iM, tableLength, nBits, extension). */
    im          = internal_read_uint32 (compressed);
    iM          = internal_read_uint32 (compressed + 4);
    /* We do not explicitly need tableLength here, but read to advance pointer. */
    (void) internal_read_uint32 (compressed + 8);
    nBits       = internal_read_uint32 (compressed + 12);
    /* Possible future extension field. */
    (void) internal_read_uint32 (compressed + 16);

    /* Validate im/iM. */
    if (im >= HUF_ENCSIZE || iM >= HUF_ENCSIZE) return EXR_ERR_CORRUPT_CHUNK;

    /* Determine how many bytes of compressed bit data we need. */
    ptr     = compressed + 20;
    nBytes  = (nBits + 7u) >> 3;
    if (nBytes > (nCompressed - 20)) return EXR_ERR_CORRUPT_CHUNK;

    /* If fast Huffman decode is possible, handle that here (omitted or stubbed). */
    /* For now, proceed with the standard decode path. */

    /* Allocate or assign working memory from 'spare'. */
    if (sparebytes < internal_exr_huf_decompress_spare_bytes ())
        return EXR_ERR_INVALID_ARGUMENT;

    {
        /* freq space then decode table space in the spare buffer */
        uint64_t* freq  = (uint64_t*) spare;
        HufDec*   hdec  = (HufDec*) (freq + HUF_ENCSIZE);

        /* Clear the decoding table, unpack the table, build the table, then decode. */
        hufClearDecTable (hdec);

        rv = hufUnpackEncTable (&ptr, (uint32_t) (compressed + nCompressed - ptr), im, iM, freq);
        if (rv != EXR_ERR_SUCCESS) return rv;

        /* Check again that we still have enough bits left for decoding. */
        if (nBits > 8u * (uint32_t) (compressed + nCompressed - ptr))
            return EXR_ERR_CORRUPT_CHUNK;

        rv = hufBuildDecTable (freq, im, iM, hdec);
        if (rv != EXR_ERR_SUCCESS) return rv;

        rv = hufDecode (freq, hdec, ptr, (uint32_t) nBits, iM, (uint32_t) nRawSize, raw);
        if (rv != EXR_ERR_SUCCESS) return rv;

        hufFreeDecTable (hdec);
    }

    rv = EXR_ERR_SUCCESS;