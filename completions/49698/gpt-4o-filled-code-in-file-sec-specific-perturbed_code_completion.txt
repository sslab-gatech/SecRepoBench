if (decode) pctxt = decode->context;

    if (nCompressed < 20)
    {
        if (pctxt)
            pctxt->print_error(
                pctxt,
                EXR_ERR_CORRUPT_CHUNK,
                "Huffman decode error (Compressed data too small)");
        return EXR_ERR_CORRUPT_CHUNK;
    }

    im = readUInt(compressed);
    iM = readUInt(compressed + 4);
    nBytes = readUInt(compressed + 8);
    nBits = readUInt(compressed + 12);

    if (im > iM || iM >= HUF_ENCSIZE)
    {
        if (pctxt)
            pctxt->print_error(
                pctxt,
                EXR_ERR_CORRUPT_CHUNK,
                "Huffman decode error (Invalid table range)");
        return EXR_ERR_CORRUPT_CHUNK;
    }

    if (nCompressed < 20 + nBytes)
    {
        if (pctxt)
            pctxt->print_error(
                pctxt,
                EXR_ERR_CORRUPT_CHUNK,
                "Huffman decode error (Compressed data too small for table)");
        return EXR_ERR_CORRUPT_CHUNK;
    }

    ptr = compressed + 20;

    if (fasthuf_decode_enabled() && nRawSize > 1024)
    {
        FastHufDecoder* fhd = (FastHufDecoder*)spare;
        if (sparebytes < sizeof(FastHufDecoder))
            return EXR_ERR_INVALID_ARGUMENT;

        rv = fasthuf_initialize(pctxt, fhd, &ptr, (int)nBytes, (int)im, (int)iM, (int)iM);
        if (rv != EXR_ERR_SUCCESS) return rv;

        rv = fasthuf_decode(pctxt, fhd, ptr, (int)nBits, raw, (int)nRawSize);
    }
    else
    {
        uint64_t* freq = (uint64_t*)spare;
        HufDec* hdec = (HufDec*)(freq + HUF_ENCSIZE);

        if (sparebytes < HUF_ENCSIZE * sizeof(uint64_t) + HUF_DECSIZE * sizeof(HufDec))
            return EXR_ERR_INVALID_ARGUMENT;

        hufClearDecTable(hdec);

        rv = hufUnpackEncTable(&ptr, &nBytes, im, iM, freq);
        if (rv != EXR_ERR_SUCCESS) return rv;

        rv = hufBuildDecTable(freq, im, iM, hdec);
        if (rv != EXR_ERR_SUCCESS) return rv;

        rv = hufDecode(freq, hdec, ptr, nBits, iM, nRawSize, raw);
    }

    return rv;