pctxt = EXR_CONST_CAST (struct _internal_exr_context*, decode->context);

if (nCompressed < 20)
{
    if (nRawSize != 0)
        return EXR_ERR_CORRUPT_CHUNK;
    return EXR_ERR_SUCCESS;
}

im = unaligned_load32 (compressed);
iM = unaligned_load32 (compressed + 4);
uint32_t tableLength = unaligned_load32 (compressed + 8);
nBits = unaligned_load32 (compressed + 12);

if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE)
    return EXR_ERR_CORRUPT_CHUNK;

ptr = compressed + 20;

nBytes = (nBits + 7) / 8;

if (ptr + nBytes > compressed + nCompressed)
    return EXR_ERR_CORRUPT_CHUNK;

// Check if we can use fast Huffman decoder
if (pctxt && pctxt->flags.enable_fast_huffman && nBits > 128)
{
    // Fast decoder would go here
    // Since we don't have the implementation details, we'll use standard decoder
}

// Standard decoder
uint64_t* freq = (uint64_t*) spare;
HufDec* hdec = (HufDec*) (freq + HUF_ENCSIZE);

hufClearDecTable (hdec);

// Unpack encoding table
rv = hufUnpackEncTable (
    &ptr, nCompressed - (ptr - compressed), im, iM, freq);
if (rv != EXR_ERR_SUCCESS)
    return rv;

if (nBits > 8 * (nCompressed - (ptr - compressed)))
    return EXR_ERR_CORRUPT_CHUNK;

// Build decoding table
rv = hufBuildDecTable (freq, im, iM, hdec);
if (rv != EXR_ERR_SUCCESS)
    return rv;

// Decode the data
rv = hufDecode (freq, hdec, ptr, nBits, iM, nRawSize, raw);