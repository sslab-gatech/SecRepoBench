pctxt = decode ? decode->ctxt : NULL;
    if (nCompressed < 20)
    {
        if (nRawSize != 0)
        {
            EXR_DEBUG_TRACE ("ERROR: not enough data %" PRIu64, nCompressed);
            return EXR_ERR_CORRUPT_CHUNK;
        }
        return EXR_ERR_SUCCESS;
    }

    im  = readUInt (compressed);
    iM  = readUInt (compressed + 4);
    nBytes = readUInt (compressed + 8);
    nBits = readUInt (compressed + 12);

    if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE)
    {
        EXR_DEBUG_TRACE (
            "ERROR: invalid table size im %u iM %u", (unsigned)im, (unsigned)iM);
        return EXR_ERR_CORRUPT_CHUNK;
    }

    ptr = compressed + 20;

    if ((uint64_t) (ptr - compressed) + ((uint64_t) nBytes) > nCompressed)
    {
        EXR_DEBUG_TRACE (
            "ERROR: not enough data, nCompressed=%" PRIu64
            " ptr-compressed=%" PRIu64 " nBytes=%" PRIu64,
            nCompressed,
            (uint64_t) (ptr - compressed),
            nBytes);
        return EXR_ERR_CORRUPT_CHUNK;
    }

    if (FastHufDecoder::enabled () && nBits > 128)
    {
        FastHufDecoder fhd (
            ptr, (int) (nCompressed - (ptr - compressed)), im, iM, iM);

        if ((uint64_t) (ptr - compressed) +
                ((uint64_t) ((nBits + 7) / 8)) >
            nCompressed)
        {
            EXR_DEBUG_TRACE ("ERROR: not enough data");
            return EXR_ERR_CORRUPT_CHUNK;
        }

        fhd.decode ((unsigned char*) ptr, nBits, raw, (int) nRawSize);
        rv = EXR_ERR_SUCCESS;
    }
    else
    {
        AutoArray<uint64_t, HUF_ENCSIZE> freq;
        AutoArray<HufDec, HUF_DECSIZE>   hdec;

        hufClearDecTable (hdec);

        hufUnpackEncTable (
            &ptr, (int) (nCompressed - (ptr - compressed)), im, iM, freq);

        try
        {
            if (nBits > 8 * (nCompressed - (ptr - compressed)))
            {
                EXR_DEBUG_TRACE ("ERROR: invalid nBits");
                rv = EXR_ERR_CORRUPT_CHUNK;
            }
            else
            {
                hufBuildDecTable (freq, im, iM, hdec);
                hufDecode (freq, hdec, ptr, nBits, iM, (int) nRawSize, raw);
                rv = EXR_ERR_SUCCESS;
            }
        }
        catch (...)
        {
            hufFreeDecTable (hdec);
            return EXR_ERR_ERROR;
        }

        hufFreeDecTable (hdec);
    }