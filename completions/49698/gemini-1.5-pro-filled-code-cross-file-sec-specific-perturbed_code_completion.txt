if (nCompressed < 20)
    {
        return EXR_ERR_CORRUPT_CHUNK;
    }

    im = readUInt (compressed);
    iM = readUInt (compressed + 4);
    // tableLength = readUInt (compressed + 8);
    nBits = readUInt (compressed + 12);

    if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE)
    {
        return EXR_ERR_INVALID_ARGUMENT;
    }

    ptr = compressed + 20;

    nBytes = (nBits + 7) / 8;

    if (ptr + nBytes > compressed + nCompressed)
    {
        return EXR_ERR_CORRUPT_CHUNK;
    }

    if (FastHufDecoder::enabled () && nBits > 128 && sparebytes >= FastHufDecoder::spareBytes())
    {
        FastHufDecoder fhd (ptr, nCompressed - (ptr - compressed), im, iM, iM, spare);

        if (ptr - compressed + nBytes > nCompressed)
        {
            return EXR_ERR_CORRUPT_CHUNK;
        }

        fhd.decode ((unsigned char*) ptr, nBits, raw, nRawSize);
        rv = EXR_ERR_SUCCESS;
    }
    else
    {
        if (sparebytes < internal_exr_huf_decompress_spare_bytes ())
            return EXR_ERR_INVALID_ARGUMENT;

        uint64_t* freq  = (uint64_t*) spare;
        HufDec*   hdec = (HufDec*) (freq + HUF_ENCSIZE);

        hufClearDecTable (hdec);

        hufUnpackEncTable (&ptr, nCompressed - (ptr - compressed), im, iM, freq);

        if (nBits > 8 * (nCompressed - (ptr - compressed)))
        {
            return EXR_ERR_CORRUPT_CHUNK;
        }


        hufBuildDecTable (freq, im, iM, hdec);
        hufDecode (freq, hdec, ptr, nBits, iM, nRawSize, raw);

        rv = EXR_ERR_SUCCESS;
    }