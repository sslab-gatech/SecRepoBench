// Retrieve the context from the decode structure if available.
pctxt = (const struct _internal_exr_context*) decode->context;

// Check if the compressed data size is at least 20 bytes for a valid header.
if (nCompressed < 20)
{
    return EXR_ERR_INVALID_ARGUMENT;
}

// Validate that 'im' and 'iM' are within acceptable limits.
im = readUInt(compressed);
iM = readUInt(compressed + 4);
if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE)
{
    return EXR_ERR_INVALID_ARGUMENT;
}

// Ensure there is enough data in the buffer to perform decompression.
ptr = compressed + 20;
nBytes = (static_cast<uint64_t>(readUInt(compressed + 12)) + 7) / 8;
if (ptr + nBytes > compressed + nCompressed)
{
    return EXR_ERR_INVALID_ARGUMENT;
}

// Check if fast Huffman decoding is enabled and applicable based on the data size.
if (FastHufDecoder::enabled() && nBytes > 128)
{
    FastHufDecoder fhd(ptr, nCompressed - (ptr - compressed), im, iM, iM);
    fhd.decode((unsigned char*)ptr, readUInt(compressed + 12), raw, nRawSize);
}
else
{
    // Clear and unpack the Huffman encoding table for use in decoding.
    AutoArray<uint64_t, HUF_ENCSIZE> freq;
    AutoArray<HufDec, HUF_DECSIZE> hdec;
    hufClearDecTable(hdec);
    hufUnpackEncTable(&ptr, nCompressed - (ptr - compressed), im, iM, freq);

    // Build the Huffman decoding table based on frequency data.
    hufBuildDecTable(freq, im, iM, hdec);

    // Execute the standard Huffman decoding function.
    hufDecode(freq, hdec, ptr, readUInt(compressed + 12), iM, nRawSize, raw);

    // Free the Huffman decoding table.
    hufFreeDecTable(hdec);
}

rv = EXR_ERR_SUCCESS;