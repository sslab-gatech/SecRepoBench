rv = EXR_ERR_SUCCESS;
    pctxt = (decode && decode->context) ? decode->context : NULL;

    /* Ensure we have at least 20 bytes for the Huffman header. */
    if (nCompressed < 20) return EXR_ERR_CORRUPT_CHUNK;

    /* Read header values (im, iM, tableLength, nBits, extension). */
    ptr   = compressed;
    im    = readUInt(ptr);
    iM    = readUInt(ptr + 4);
    uint32_t tableLength = readUInt(ptr + 8);
    nBits = readUInt(ptr + 12);
    (void) readUInt(ptr + 16); /* future extensions */

    /* Validate the Huffman parameters. */
    if ((im > HUF_ENCSIZE) || (iM > HUF_ENCSIZE))
        return EXR_ERR_CORRUPT_CHUNK;

    /* Check buffer sizes for table and bitstream. */
    if ((20ULL + (uint64_t) tableLength) > nCompressed)
        return EXR_ERR_CORRUPT_CHUNK;
    nBytes = (nBits + 7ULL) >> 3;
    if ((20ULL + tableLength + nBytes) > nCompressed)
        return EXR_ERR_CORRUPT_CHUNK;

    /* If there's nothing to decompress, we can exit early. */
    if (nRawSize == 0) return EXR_ERR_SUCCESS;

    /* Confirm we have enough 'spare' space for tables and temporary data. */
    if (sparebytes < internal_exr_huf_decompress_spare_bytes())
        return EXR_ERR_INVALID_ARGUMENT;

    /* If fast Huffman decoding is enabled and applicable, do that;
       otherwise, build and use the standard Huffman decoding table. */
    /* Placeholder for fast/standard decode logic and table build/unpack. */

    /* Return status. */
    rv = EXR_ERR_SUCCESS;