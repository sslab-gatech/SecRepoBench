exr_result_t
internal_huf_decompress (
    exr_decode_pipeline_t* decode,
    const uint8_t*         compressed,
    uint64_t               nCompressed,
    uint16_t*              raw,
    uint64_t               nRawSize,
    void*                  spare,
    uint64_t               sparebytes)
{
    uint32_t                            im, iM, nBits;
    uint64_t                            nBytes;
    const uint8_t*                      ptr;
    exr_result_t                        rv;
    const struct _internal_exr_context* pctxt = NULL;

    if (nCompressed < 20)
    {
        return EXR_ERR_INVALID_ARGUMENT;
    }

    pctxt = decode->pctxt;
    if (!pctxt)
    {
        return EXR_ERR_INVALID_ARGUMENT;
    }

    ptr = compressed;
    im  = readUInt (ptr);
    iM  = readUInt (ptr + 4);
    nBits = readUInt (ptr + 8);
    nBytes = readUInt (ptr + 12);

    if (im < 0 || iM < 0 || nBits < 0 || nBytes < 0)
    {
        return EXR_ERR_INVALID_ARGUMENT;
    }

    if (nCompressed < (20 + nBytes))
    {
        return EXR_ERR_INVALID_ARGUMENT;
    }

    if (im > iM || iM >= HUF_ENCSIZE)
    {
        return EXR_ERR_INVALID_ARGUMENT;
    }

    if (nBits > (nCompressed - 20))
    {
        return EXR_ERR_INVALID_ARGUMENT;
    }

    if (nBytes > (nCompressed - 20 - nBits))
    {
        return EXR_ERR_INVALID_ARGUMENT;
    }

    if (sparebytes!= internal_exr_huf_decompress_spare_bytes ())
    {
        return EXR_ERR_INVALID_ARGUMENT;
    }

    uint64_t*  freq;
    uint32_t*  hlink;
    uint64_t** fHeap;
    uint64_t*  scode;
    HufDec*    hdecod;
    FastHufDecoder* fhd;

    freq  = (uint64_t*) spare;
    scode = freq + HUF_ENCSIZE;
    fHeap = (uint64_t**) (scode + HUF_ENCSIZE);
    hlink = (uint32_t*) (fHeap + HUF_ENCSIZE);
    hdecod = (HufDec*) (scode + HUF_ENCSIZE + HUF_ENCSIZE);
    fhd = (FastHufDecoder*) (scode + HUF_ENCSIZE + HUF_ENCSIZE + HUF_DECSIZE);

    uint8_t* tableStart = (uint8_t*) (compressed + 20);
    uint8_t* tableEnd   = tableStart + readUInt (ptr + 8);
    uint8_t* dataStart  = tableEnd;
    uint8_t* dataEnd    = dataStart + readUInt (ptr + 12);

    if (nCompressed < (20 + nBytes + nBits))
    {
        return EXR_ERR_INVALID_ARGUMENT;
    }

    if (nCompressed > (20 + nBytes + nBits))
    {
        return EXR_ERR_INVALID_ARGUMENT;
    }

    hufUnpackEncTable (&tableStart, &nBytes, im, iM, freq);
    hufClearDecTable (hdecod);
    hufBuildDecTable (freq, im, iM, hdecod);

    if (fasthuf_decode_enabled ())
    {
        rv = fasthuf_initialize (pctxt, fhd, &tableStart, nBytes, im, iM, 65536);
        if (rv!= EXR_ERR_SUCCESS)
        {
            return rv;
        }

        rv = fasthuf_decode (pctxt, fhd, dataStart, nBits, raw, nRawSize);
    }
    else
    {
        rv = hufDecode (freq, hdecod, dataStart, nBits, raw, nRawSize);
    }

    if (rv!= EXR_ERR_SUCCESS)
    {
        return rv;
    }

    return EXR_ERR_SUCCESS;
}