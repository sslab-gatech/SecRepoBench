if (decode) pctxt = decode->pctxt;
    if (nCompressed < 20) return EXR_ERR_CORRUPT_CHUNK;
    im = readUInt (compressed);
    iM = readUInt (compressed + 4);
    uint32_t tableLength = readUInt (compressed + 8);
    nBits = readUInt (compressed + 12);
    if (im >= HUF_ENCSIZE || iM >= HUF_ENCSIZE || im > iM)
        return EXR_ERR_CORRUPT_CHUNK;
    if (nCompressed < 20 + tableLength + (nBits + 7) / 8)
        return EXR_ERR_CORRUPT_CHUNK;
    ptr = compressed + 20;
    nBytes = nCompressed - 20 - tableLength;
    uint64_t* freq = (uint64_t*) spare;
    HufDec*   hdecod = (HufDec*) (freq + HUF_ENCSIZE);
    if (fasthuf_decode_enabled () && nBits < 1024 * 1024 * 1024)
    {
        FastHufDecoder fhd;
        rv = fasthuf_initialize (
            pctxt, &fhd, &ptr, tableLength, im, iM, iM + 1);
        if (rv != EXR_ERR_SUCCESS) return rv;
        rv = fasthuf_decode (
            pctxt, &fhd, ptr, nBits, raw, (int) nRawSize);
        ptr += (nBits + 7) / 8;
    }
    else
    {
        hufClearDecTable (hdecod);
        rv = hufUnpackEncTable (&ptr, &nBytes, im, iM, freq);
        if (rv != EXR_ERR_SUCCESS) return rv;
        rv = hufBuildDecTable (freq, im, iM, hdecod);
        if (rv != EXR_ERR_SUCCESS)
        {
            hufFreeDecTable (hdecod);
            return rv;
        }
        rv = hufDecode (freq, hdecod, ptr, nBits, iM + 1, nRawSize, raw);
        hufFreeDecTable (hdecod);
    }