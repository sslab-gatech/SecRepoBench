pctxt = decode->context;

    if (nCompressed < 20)
        return EXR_ERR_INVALID_ARGUMENT;

    im = ((uint32_t)compressed[0] << 24) | ((uint32_t)compressed[1] << 16) | ((uint32_t)compressed[2] << 8) | compressed[3];
    iM = ((uint32_t)compressed[4] << 24) | ((uint32_t)compressed[5] << 16) | ((uint32_t)compressed[6] << 8) | compressed[7];
    uint32_t tableLength = ((uint32_t)compressed[8] << 24) | ((uint32_t)compressed[9] << 16) | ((uint32_t)compressed[10] << 8) | compressed[11];
    nBits = ((uint32_t)compressed[12] << 24) | ((uint32_t)compressed[13] << 16) | ((uint32_t)compressed[14] << 8) | compressed[15];

    if (im >= HUF_ENCSIZE || iM >= HUF_ENCSIZE)
        return EXR_ERR_INVALID_ARGUMENT;

    nBytes = ((uint64_t)nBits + 7) / 8;

    if (20 + tableLength + nBytes > nCompressed)
        return EXR_ERR_INVALID_ARGUMENT;

    if (sparebytes != internal_exr_huf_decompress_spare_bytes())
        return EXR_ERR_INVALID_ARGUMENT;

    uint64_t* freq = (uint64_t*)spare;
    HufDec* hdecod = (HufDec*)(freq + HUF_ENCSIZE);

    hufClearDecTable(hdecod);

    const uint8_t* ptr = compressed + 20;
    rv = hufUnpackEncTable(&ptr, nCompressed - 20, im, iM, freq);
    if (rv != EXR_ERR_SUCCESS) return rv;

    if (nBits > 8 * (nCompressed - (ptr - compressed)))
        return EXR_ERR_INVALID_ARGUMENT;

    rv = hufBuildDecTable(freq, im, iM, hdecod);
    if (rv != EXR_ERR_SUCCESS) return rv;

    rv = hufDecode(freq, hdecod, ptr, nBits, iM, (uint32_t)nRawSize, raw);