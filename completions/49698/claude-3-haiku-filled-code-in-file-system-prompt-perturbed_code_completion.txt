if (nCompressed < 20)
{
    if (pctxt)
        pctxt->print_error(pctxt, EXR_ERR_CORRUPT_CHUNK, "Huffman decompression error (Compressed data too small)");
    return EXR_ERR_CORRUPT_CHUNK;
}

im = readUInt(compressed);
iM = readUInt(compressed + 4);
nBits = readUInt(compressed + 12);
nBytes = (nBits + 7) / 8;

if (im > iM || im >= HUF_ENCSIZE || iM >= HUF_ENCSIZE)
{
    if (pctxt)
        pctxt->print_error(pctxt, EXR_ERR_CORRUPT_CHUNK, "Huffman decompression error (Invalid Huffman table indices)");
    return EXR_ERR_CORRUPT_CHUNK;
}

if (nCompressed < 20 + nBytes)
{
    if (pctxt)
        pctxt->print_error(pctxt, EXR_ERR_CORRUPT_CHUNK, "Huffman decompression error (Compressed data too small)");
    return EXR_ERR_CORRUPT_CHUNK;
}

if (sparebytes != internal_exr_huf_decompress_spare_bytes())
    return EXR_ERR_INVALID_ARGUMENT;

if (fasthuf_decode_enabled())
{
    FastHufDecoder fhd;
    rv = fasthuf_initialize(pctxt, &fhd, &compressed[20], nBytes, im, iM, iM);
    if (rv == EXR_ERR_SUCCESS)
        rv = fasthuf_decode(pctxt, &fhd, &compressed[20], nBits, raw, nRawSize);
}
else
{
    HufDec* hdecod = (HufDec*)spare;
    hufClearDecTable(hdecod);
    rv = hufUnpackEncTable(&compressed[20], &nBytes, im, iM, freq);
    if (rv == EXR_ERR_SUCCESS)
        rv = hufDecode(freq, hdecod, &compressed[20], nBits, iM, nRawSize, raw);
}

return rv;