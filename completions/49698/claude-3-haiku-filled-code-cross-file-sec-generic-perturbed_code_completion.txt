// <MASK>
// Perform fast Huffman decoding if applicable
if (FastHufDecoder::enabled() && nBits > 128)
{
    FastHufDecoder fhd(ptr, nCompressed - (ptr - compressed), im, iM, iM);

    // Ensure there is enough data in the buffer to perform fast Huffman decoding
    if (ptr - compressed + nBytes > static_cast<uint64_t>(nCompressed))
    {
        return EXR_ERR_CORRUPT_CHUNK;
    }

    fhd.decode((unsigned char*)ptr, nBits, raw, nRaw);
}
else
{
    // Perform standard Huffman decoding
    AutoArray<uint64_t, HUF_ENCSIZE> freq;
    AutoArray<HufDec, HUF_DECSIZE> hdec;

    hufClearDecTable(hdec);

    hufUnpackEncTable(&ptr, nCompressed - (ptr - compressed), im, iM, freq);

    try
    {
        if (nBits > 8 * (nCompressed - (ptr - compressed)))
            return EXR_ERR_CORRUPT_CHUNK;

        hufBuildDecTable(freq, im, iM, hdec);
        hufDecode(freq, hdec, ptr, nBits, iM, nRaw, raw);
    }
    catch (...)
    {
        hufFreeDecTable(hdec);
        throw;
    }

    hufFreeDecTable(hdec);
}
return rv;