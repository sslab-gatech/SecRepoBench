rv = EXR_ERR_SUCCESS;

    // Check for minimum header size
    if (nCompressed < 20)
    {
        if (nRawSize != 0) return EXR_ERR_CORRUPT_CHUNK;
        return EXR_ERR_SUCCESS;
    }

    im = (uint32_t) unaligned_load32(compressed);
    iM = (uint32_t) unaligned_load32(compressed + 4);
    // uint32_t tableLength = unaligned_load32(compressed + 8);
    nBits = (uint32_t) unaligned_load32(compressed + 12);

    if (im >= HUF_ENCSIZE || iM >= HUF_ENCSIZE)
        return EXR_ERR_CORRUPT_CHUNK;

    ptr = compressed + 20;
    nBytes = ((uint64_t) nBits + 7) / 8;

    if ((uint64_t)(ptr - compressed) + nBytes > nCompressed)
        return EXR_ERR_CORRUPT_CHUNK;

    // Fast decoder needs at least 2x64-bits of compressed data, and
    // needs to be run-able on this platform. Otherwise, fall back
    // to the original decoder
    if (internal_fast_huf_decoder_enabled() && nBits > 128)
    {
        rv = internal_fast_huf_decode(
            ptr,
            nCompressed - (uint64_t)(ptr - compressed),
            im,
            iM,
            nBits,
            raw,
            nRawSize);
    }
    else
    {
        uint64_t* freq = (uint64_t*)spare;
        HufDec* hdec = (HufDec*)(freq + HUF_ENCSIZE);

        hufClearDecTable(hdec);

        rv = internal_huf_unpack_enc_table(
            &ptr,
            nCompressed - (uint64_t)(ptr - compressed),
            im,
            iM,
            freq);
        if (rv != EXR_ERR_SUCCESS)
            return rv;

        if (nBits > 8 * (nCompressed - (uint64_t)(ptr - compressed)))
            return EXR_ERR_CORRUPT_CHUNK;

        rv = internal_huf_build_dec_table(freq, im, iM, hdec);
        if (rv != EXR_ERR_SUCCESS)
            return rv;

        rv = internal_huf_decode(
            freq,
            hdec,
            ptr,
            nBits,
            iM,
            nRawSize,
            raw);
    }