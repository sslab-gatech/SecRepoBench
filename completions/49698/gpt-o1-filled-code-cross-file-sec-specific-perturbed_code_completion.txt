rv = EXR_ERR_SUCCESS;

    /* Basic argument checks */
    if (!decode || !compressed || !raw)
        return EXR_ERR_INVALID_ARGUMENT;

    /* Need at least 20 bytes for header */
    if (nCompressed < 20)
    {
        /* If we expected data but have none, error out */
        if (nRawSize != 0) return EXR_ERR_CORRUPT_CHUNK;
        /* Otherwise, nothing to decode */
        return EXR_ERR_SUCCESS;
    }

    /* Read header values (im, iM, tableLength, nBits) */
    im = readUInt(compressed);
    iM = readUInt(compressed + 4);
    {
        /* tableLength is read but not explicitly needed by this implementation */
        uint32_t tableLength = readUInt(compressed + 8);
        (void) tableLength;
    }
    nBits = readUInt(compressed + 12);

    /* Validate table sizes */
    if (im >= HUF_ENCSIZE || iM >= HUF_ENCSIZE)
        return EXR_ERR_CORRUPT_CHUNK;

    /* Determine where the Huffman-coded data starts */
    ptr = compressed + 20;
    nBytes = ((uint64_t)nBits + 7U) >> 3U;

    /* Check if we have sufficient compressed data */
    if (nBytes > (nCompressed - 20))
        return EXR_ERR_CORRUPT_CHUNK;

    /* Attempt fast Huffman decoding if enabled and data is large enough */
    if (internal_huf_fast_decoder_enabled() && nBits > 128)
    {
        rv = internal_huf_fast_decode(
            ptr,
            nBytes,
            im,
            iM,
            raw,
            nRawSize,
            spare,
            sparebytes
        );
    }
    else
    {
        /* Perform standard Huffman decoding */
        rv = hufUnpackEncTable(
            &ptr,
            (size_t)(nCompressed - (ptr - compressed)),
            im,
            iM,
            (uint64_t*) spare
        );
        if (rv == EXR_ERR_SUCCESS)
        {
            rv = hufBuildDecTable(
                (uint64_t*) spare,
                im,
                iM,
                (HufDec*) (((uint64_t*) spare) + HUF_ENCSIZE)
            );
            if (rv == EXR_ERR_SUCCESS)
            {
                rv = hufDecode(
                    (uint64_t*) spare,
                    (HufDec*) (((uint64_t*) spare) + HUF_ENCSIZE),
                    ptr,
                    nBits,
                    iM,
                    nRawSize,
                    raw
                );
                /* Free or clear decode table if required */
                hufFreeDecTable(
                    (HufDec*) (((uint64_t*) spare) + HUF_ENCSIZE)
                );
            }
        }
    }