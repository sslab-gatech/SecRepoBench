if (decode && decode->context)
    pctxt = (const struct _internal_exr_context*) decode->context;

if (nCompressed < 20)
    return EXR_ERR_CORRUPT_CHUNK;

im = readUInt (compressed);
iM = readUInt (compressed + 4);

if (im >= HUF_ENCSIZE || iM >= HUF_ENCSIZE)
    return EXR_ERR_CORRUPT_CHUNK;

nBytes = readUInt (compressed + 8);
nBits  = readUInt (compressed + 12);

if (nCompressed < nBytes + 20)
    return EXR_ERR_CORRUPT_CHUNK;

if (nRawSize == 0)
    return EXR_ERR_SUCCESS;

if (sparebytes!= internal_exr_huf_decompress_spare_bytes ())
    return EXR_ERR_INVALID_ARGUMENT;

ptr = compressed + 20;

if (fasthuf_decode_enabled () && nRawSize > 1000)
{
    FastHufDecoder fhd;
    rv = fasthuf_initialize (pctxt, &fhd, &ptr, nBytes, im, iM, iM + 1);
    if (rv!= EXR_ERR_SUCCESS) return rv;
    rv = fasthuf_decode (pctxt, &fhd, ptr, nBits, raw, nRawSize);
    return rv;
}

uint64_t* freq;
HufDec*    hdecod;

freq  = (uint64_t*) spare;
hdecod = (HufDec*) (freq + HUF_ENCSIZE);

hufClearDecTable (hdecod);

rv = hufUnpackEncTable (&ptr, &nBytes, im, iM, freq);

if (rv!= EXR_ERR_SUCCESS) return rv;

rv = hufBuildDecTable (freq, im, iM, hdecod);

if (rv!= EXR_ERR_SUCCESS)
{
    hufFreeDecTable (hdecod);
    return rv;
}

rv = hufDecode (freq, hdecod, ptr, nBits, iM, nRawSize, raw);

hufFreeDecTable (hdecod);
return rv;