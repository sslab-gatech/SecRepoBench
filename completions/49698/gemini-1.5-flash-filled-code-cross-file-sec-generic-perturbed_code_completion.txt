pctxt = (const struct _internal_exr_context*) decode->context;
    ptr   = compressed;
    im    = readUInt (ptr);
    iM    = readUInt (ptr + 4);
    nBytes = (uint64_t) readUInt (ptr + 12) + 7;
    nBytes /= 8;
    if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE)
    {
        rv = EXR_ERR_CORRUPT_CHUNK;
        goto done;
    }
    if (ptr + nBytes > compressed + nCompressed)
    {
        rv = EXR_ERR_CORRUPT_CHUNK;
        goto done;
    }
    if (pctxt && pctxt->fast_huf_decode && nBytes > 128)
    {
        FastHufDecoder fhd (ptr + 20, nCompressed - 20, im, iM, iM);
        fhd.decode ((unsigned char*) (ptr + 20), readUInt (ptr + 12), raw,
                    nRawSize);
    }
    else
    {
        AutoArray<uint64_t, HUF_ENCSIZE> freq;
        AutoArray<HufDec, HUF_DECSIZE>   hdec;
        hufClearDecTable (hdec);
        ptr += 20;
        hufUnpackEncTable (&ptr, nCompressed - (ptr - compressed), im, iM,
                           freq);
        hufBuildDecTable (freq, im, iM, hdec);
        hufDecode (freq, hdec, ptr, readUInt (ptr - 16), iM, nRawSize, raw);
        hufFreeDecTable (hdec);
    }
    rv = EXR_ERR_SUCCESS;
done: