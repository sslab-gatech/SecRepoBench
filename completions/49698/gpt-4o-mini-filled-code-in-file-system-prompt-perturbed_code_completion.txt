pctxt = decode->context;

    if (nCompressed < 20)
        return EXR_ERR_CORRUPT_CHUNK;

    im = readUInt (compressed);
    iM = readUInt (compressed + 4);
    nBits = readUInt (compressed + 12);

    if (im >= HUF_ENCSIZE || iM >= HUF_ENCSIZE || im > iM)
        return EXR_ERR_CORRUPT_CHUNK;

    nBytes = (nCompressed - 20) * 8;

    if (nBits > nBytes)
        return EXR_ERR_CORRUPT_CHUNK;

    ptr = compressed + 20;

    if (fasthuf_decode_enabled() && (nRawSize >= 256))
    {
        FastHufDecoder fhd;
        rv = fasthuf_initialize (pctxt, &fhd, &ptr, nCompressed - 20, im, iM, 0);
        if (rv != EXR_ERR_SUCCESS) return rv;

        rv = fasthuf_decode (pctxt, &fhd, ptr, nBits, raw, nRawSize);
        return rv;
    }
    else
    {
        HufDec hdecod[HUF_DECSIZE];
        hufClearDecTable (hdecod);
        rv = hufUnpackEncTable (&ptr, &nBytes, im, iM, freq);
        if (rv != EXR_ERR_SUCCESS) return rv;

        rv = hufBuildDecTable (freq, im, iM, hdecod);
        if (rv != EXR_ERR_SUCCESS) return rv;

        rv = hufDecode (freq, hdecod, ptr, nBits, 0, nRawSize, raw);
        hufFreeDecTable (hdecod);
        return rv;
    }