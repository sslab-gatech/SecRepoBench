// Retrieve the context from the decode structure if available.
pctxt = decode->context;

// Check if the compressed data size is at least 20 bytes for a valid header.
if (nCompressed < 20)
    return EXR_ERR_INVALID_ARGUMENT;

// Validate that 'im' and 'iM' are within acceptable limits.
ptr = compressed;
im = readUInt(ptr);
iM = readUInt(ptr + 4);
if (im < 2 || iM < 2 || im > 16 || iM > 16)
    return EXR_ERR_INVALID_ARGUMENT;

// Ensure there is enough data in the buffer to perform decompression.
nBytes = readUInt(ptr + 8);
if (nCompressed < 20 + nBytes)
    return EXR_ERR_INVALID_ARGUMENT;

// Check if fast Huffman decoding is enabled and applicable based on the data size.
if (decode->fast_huffman && nRawSize > 1024)
{
    // Initialize and perform fast Huffman decoding.
    rv = internal_huf_decompress_fast(decode, compressed, nCompressed, raw, nRawSize);
}
else
{
    // Clear and unpack the Huffman encoding table for use in decoding.
    uint8_t* tableStart = compressed + 20;
    uint8_t* tableEnd = tableStart + nBytes;
    uint64_t* freq = (uint64_t*) spare;
    uint32_t* hlink = (uint32_t*) (freq + HUF_ENCSIZE);
    uint64_t* scode = (uint64_t*) (hlink + HUF_ENCSIZE);
    hufUnpackEncTable(freq, im, iM, tableStart, tableEnd);

    // Build the Huffman decoding table based on frequency data.
    hufBuildDecTable(freq, hlink, scode);

    // Use a slower, standard Huffman decoding method.
    rv = internal_huf_decompress_std(decode, compressed, nCompressed, raw, nRawSize, freq, iM);
}