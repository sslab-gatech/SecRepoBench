pctxt = (const struct _internal_exr_context*) (decode->context);

if (nCompressed < 20 || nRawSize == 0)
{
    if (nRawSize != 0) return EXR_ERR_CORRUPT_CHUNK;
    return EXR_ERR_SUCCESS;
}

ptr = compressed;

im = readUInt (ptr);
iM = readUInt (ptr + 4);
// uint32_t tableLength = readUInt (ptr + 8);
nBits = readUInt (ptr + 12);

if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE)
    return EXR_ERR_CORRUPT_CHUNK;

ptr += 20;

nBytes = (nBits + 7) / 8;

if (ptr + nBytes > compressed + nCompressed)
    return EXR_ERR_CORRUPT_CHUNK;

if (sparebytes != internal_exr_huf_decompress_spare_bytes ())
    return EXR_ERR_INVALID_ARGUMENT;

if (FastHufDecoder::enabled () && nBits > 128)
{
    // must be nBytes remaining in buffer
    if (ptr - compressed + nBytes > nCompressed)
        return EXR_ERR_CORRUPT_CHUNK;

    // TODO: implement fast huffman decoding for EXR_CORE
    return EXR_ERR_SUCCESS;
}
else
{
    uint64_t* freq = (uint64_t*) spare;
    HufDec*   hdec = (HufDec*) (freq + HUF_ENCSIZE);

    hufClearDecTable (hdec);

    rv = hufUnpackEncTable (
        &ptr, nCompressed - (ptr - compressed), im, iM, freq, pctxt);
    if (rv != EXR_ERR_SUCCESS) return rv;

    if (nBits > 8 * (nCompressed - (ptr - compressed)))
        return EXR_ERR_CORRUPT_CHUNK;

    hufBuildDecTable (freq, im, iM, hdec);
    hufDecode (freq, hdec, ptr, nBits, iM, nRawSize, raw);
}
return EXR_ERR_SUCCESS;