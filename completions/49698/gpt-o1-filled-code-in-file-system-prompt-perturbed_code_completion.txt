rv = EXR_ERR_SUCCESS;
    pctxt = (decode && decode->internal_context)
                ? (const struct _internal_exr_context*) decode->internal_context
                : NULL;

    /* If nothing to decompress, return success */
    if (nRawSize == 0)
    {
        rv = EXR_ERR_SUCCESS;
        goto cleanup_and_return;
    }

    /* Ensure we have at least enough bytes for the header */
    if (nCompressed < 20)
    {
        if (pctxt)
            pctxt->print_error (
                pctxt,
                EXR_ERR_CORRUPT_CHUNK,
                "Not enough data for Huffman header (got %" PRIu64 " bytes).",
                nCompressed);
        rv = EXR_ERR_CORRUPT_CHUNK;
        goto cleanup_and_return;
    }

    im         = readUInt (compressed);
    iM         = readUInt (compressed + 4);
    nBytes     = readUInt (compressed + 8);
    nBits      = readUInt (compressed + 12);
    /* skip extension (unused currently) */
    (void) readUInt (compressed + 16);

    /* Validate range for im/iM */
    if (im > iM || iM >= HUF_ENCSIZE)
    {
        if (pctxt)
            pctxt->print_error (
                pctxt,
                EXR_ERR_CORRUPT_CHUNK,
                "Invalid Huffman table symbol range [%u..%u].",
                im,
                iM);
        rv = EXR_ERR_CORRUPT_CHUNK;
        goto cleanup_and_return;
    }

    /* Check for enough data to hold the table plus the bitstream */
    {
        uint64_t totalNeeded = 20 + nBytes + ((uint64_t) (nBits + 7) / 8);
        if (totalNeeded > nCompressed)
        {
            if (pctxt)
                pctxt->print_error (
                    pctxt,
                    EXR_ERR_CORRUPT_CHUNK,
                    "Truncated Huffman data. Need %" PRIu64
                    " bytes, have %" PRIu64,
                    totalNeeded,
                    nCompressed);
            rv = EXR_ERR_CORRUPT_CHUNK;
            goto cleanup_and_return;
        }
    }

    ptr = compressed + 20;

    /* If enabled and the symbol range is within practical bounds, try the fast decoder */
    if (fasthuf_decode_enabled () && iM <= 65535 && (iM >= im))
    {
        FastHufDecoder* fhd = (FastHufDecoder*) spare;
        if (sizeof (FastHufDecoder) <= sparebytes)
        {
            const uint8_t* tablePtr = ptr;
            rv = fasthuf_initialize (pctxt, fhd, &tablePtr, (int) nBytes, (int) im, (int) iM, (int) iM);
            if (rv == EXR_ERR_SUCCESS)
            {
                const uint8_t* bitData = ptr + nBytes;
                rv = fasthuf_decode (
                    pctxt, fhd, bitData, (int) nBits, raw, (int) nRawSize);
                if (rv == EXR_ERR_SUCCESS) goto cleanup_and_return;
                /* If fast decode fails, fall back to normal approach below */
            }
            /* if initialization fails, proceed to the normal decoder */
        }
    }

    /* Fall back to the standard Huffman decoder */
    {
        uint64_t* freq   = (uint64_t*) spare;
        HufDec*   hdec   = (HufDec*) (freq + HUF_ENCSIZE);
        uint64_t  bytesLeft = nBytes;

        if ((HUF_ENCSIZE * sizeof (uint64_t) + HUF_DECSIZE * sizeof (HufDec)) >
            sparebytes)
        {
            if (pctxt)
                pctxt->print_error (
                    pctxt,
                    EXR_ERR_INVALID_ARGUMENT,
                    "Not enough spare memory for Huffman decoding");
            rv = EXR_ERR_INVALID_ARGUMENT;
            goto cleanup_and_return;
        }

        hufClearDecTable (hdec);

        rv = hufUnpackEncTable (&ptr, &bytesLeft, im, iM, freq);
        if (rv != EXR_ERR_SUCCESS) goto cleanup_and_return;

        rv = hufBuildDecTable (freq, im, iM, hdec);
        if (rv != EXR_ERR_SUCCESS) goto cleanup_and_return;

        {
            const uint8_t* bitData = compressed + 20 + nBytes;
            rv = hufDecode (
                freq, hdec, bitData, (uint64_t) nBits, iM, nRawSize, raw);
        }
        hufFreeDecTable (hdec);
    }

cleanup_and_return:
    return rv;