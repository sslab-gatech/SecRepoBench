if (decode) pctxt = decode->context;

    if (nCompressed < 20) return EXR_ERR_CORRUPT_CHUNK;

    im = readUInt(compressed);
    iM = readUInt(compressed + 4);
    nBytes = (uint64_t)readUInt(compressed + 8);
    nBits = readUInt(compressed + 12);

    if (im > iM || iM >= HUF_ENCSIZE) return EXR_ERR_CORRUPT_CHUNK;

    ptr = compressed + 20;
    if (nBytes > nCompressed - 20) return EXR_ERR_CORRUPT_CHUNK;

    if (fasthuf_decode_enabled() && nRawSize > 1024)
    {
        FastHufDecoder* fhd = (FastHufDecoder*)spare;
        if (sparebytes < sizeof(FastHufDecoder)) return EXR_ERR_INVALID_ARGUMENT;

        rv = fasthuf_initialize(pctxt, fhd, &ptr, (int)nBytes, (int)im, (int)iM, (int)iM);
        if (rv != EXR_ERR_SUCCESS) return rv;

        return fasthuf_decode(pctxt, fhd, ptr, (int)nBits, raw, (int)nRawSize);
    }
    else
    {
        uint64_t* freq = (uint64_t*)spare;
        HufDec* hdec = (HufDec*)(freq + HUF_ENCSIZE);

        if (sparebytes < HUF_ENCSIZE * sizeof(uint64_t) + HUF_DECSIZE * sizeof(HufDec))
            return EXR_ERR_INVALID_ARGUMENT;

        hufClearDecTable(hdec);

        rv = hufUnpackEncTable(&ptr, &nBytes, im, iM, freq);
        if (rv != EXR_ERR_SUCCESS) return rv;

        rv = hufBuildDecTable(freq, im, iM, hdec);
        if (rv != EXR_ERR_SUCCESS) return rv;

        rv = hufDecode(freq, hdec, ptr, (uint64_t)nBits, iM, nRawSize, raw);
        hufFreeDecTable(hdec);
        return rv;
    }