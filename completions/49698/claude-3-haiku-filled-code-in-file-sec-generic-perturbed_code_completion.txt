if (nCompressed < 20)
{
    if (pctxt)
        pctxt->print_error(pctxt, EXR_ERR_CORRUPT_CHUNK, "Huffman decompression error (Compressed data too small)");
    return EXR_ERR_CORRUPT_CHUNK;
}

im = readUInt(compressed);
iM = readUInt(compressed + 4);
nBits = readUInt(compressed + 12);
nBytes = (nBits + 7) / 8;

if (im > iM || im >= HUF_ENCSIZE || iM >= HUF_ENCSIZE)
{
    if (pctxt)
        pctxt->print_error(pctxt, EXR_ERR_CORRUPT_CHUNK, "Huffman decompression error (Invalid Huffman table indices)");
    return EXR_ERR_CORRUPT_CHUNK;
}

if (nCompressed < 20 + nBytes)
{
    if (pctxt)
        pctxt->print_error(pctxt, EXR_ERR_CORRUPT_CHUNK, "Huffman decompression error (Compressed data too small)");
    return EXR_ERR_CORRUPT_CHUNK;
}

if (fasthuf_decode_enabled())
{
    FastHufDecoder fhd;
    rv = fasthuf_initialize(pctxt, &fhd, &compressed[20], (int)nBytes, im, iM, iM);
    if (rv == EXR_ERR_SUCCESS)
        rv = fasthuf_decode(pctxt, &fhd, compressed + 20, (int)nBits, raw, (int)nRawSize);
}
else
{
    HufDec hdecod[HUF_DECSIZE];
    hufClearDecTable(hdecod);
    rv = hufUnpackEncTable(&compressed[20], &nBytes, im, iM, freq);
    if (rv == EXR_ERR_SUCCESS)
        rv = hufBuildDecTable(freq, im, iM, hdecod);
    if (rv == EXR_ERR_SUCCESS)
        rv = hufDecode(freq, hdecod, compressed + 20, nBits, iM, nRawSize, raw);
    hufFreeDecTable(hdecod);
}

return rv;