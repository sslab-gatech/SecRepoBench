pctxt = internal_exr_decode_get_context (decode);

    if (nCompressed < 20)
    {
        return EXR_ERR_CORRUPT_CHUNK;
    }

    im = readUInt (compressed);
    iM = readUInt (compressed + 4);
    // nBytes = readUInt (compressed + 8);
    nBits = readUInt (compressed + 12);

    if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE)
    {
        return EXR_ERR_CORRUPT_CHUNK;
    }

    ptr = compressed + 20;

    nBytes = (nBits + 7) / 8;

    if (((uintptr_t) ptr) + nBytes > ((uintptr_t) compressed) + nCompressed)
    {
        return EXR_ERR_CORRUPT_CHUNK;
    }

    if (pctxt && pctxt->fast_huf && nBits > 128)
    {
        FastHufDecoder fhd (ptr, nCompressed - (ptr - compressed), im, iM, iM);

        if (((uintptr_t) ptr) - ((uintptr_t) compressed) + nBytes > nCompressed)
        {
            return EXR_ERR_CORRUPT_CHUNK;
        }

        fhd.decode ((unsigned char*) ptr, nBits, raw, nRawSize);
        rv = EXR_ERR_SUCCESS;
    }
    else
    {
        uint64_t* freq = (uint64_t*) spare;
        HufDec*   hdec = (HufDec*) (freq + HUF_ENCSIZE);

        if (sparebytes != internal_exr_huf_decompress_spare_bytes ())
            return EXR_ERR_INVALID_ARGUMENT;

        hufClearDecTable (hdec);

        hufUnpackEncTable (&ptr,
                           nCompressed - (ptr - compressed),
                           im,
                           iM,
                           freq);

        if (nBits > 8 * (nCompressed - (ptr - compressed)))
        {
            return EXR_ERR_CORRUPT_CHUNK;
        }

        hufBuildDecTable (freq, im, iM, hdec);
        hufDecode (freq, hdec, ptr, nBits, iM, nRawSize, raw);

        rv = EXR_ERR_SUCCESS;
    }