pctxt = EXR_CONST_CAST(const struct _internal_exr_context*, decode->context);

if (nCompressed < 20)
    return EXR_ERR_CORRUPT_CHUNK;

im = unaligned_load32(compressed);
iM = unaligned_load32(compressed + 4);
uint32_t tableLength = unaligned_load32(compressed + 8);
nBits = unaligned_load32(compressed + 12);

if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE)
    return EXR_ERR_CORRUPT_CHUNK;

ptr = compressed + 20;
nBytes = (nBits + 7) / 8;

if (ptr + nBytes > compressed + nCompressed)
    return EXR_ERR_CORRUPT_CHUNK;

if (pctxt && pctxt->opts.enable_fast_huffman && nBits > 128)
{
    FastHufDecoder fhd(ptr, nCompressed - (ptr - compressed), im, iM, iM);
    if (ptr - compressed + nBytes > nCompressed)
        return EXR_ERR_CORRUPT_CHUNK;
    fhd.decode((unsigned char*)ptr, nBits, raw, nRawSize);
}
else
{
    uint64_t* freq = (uint64_t*)spare;
    HufDec* hdec = (HufDec*)(freq + HUF_ENCSIZE);

    hufClearDecTable(hdec);
    rv = hufUnpackEncTable(&ptr, nCompressed - (ptr - compressed), im, iM, freq);
    if (rv != EXR_ERR_SUCCESS)
        return rv;

    if (nBits > 8 * (nCompressed - (ptr - compressed)))
        return EXR_ERR_CORRUPT_CHUNK;

    rv = hufBuildDecTable(freq, im, iM, hdec);
    if (rv != EXR_ERR_SUCCESS)
        return rv;

    rv = hufDecode(freq, hdec, ptr, nBits, iM, nRawSize, raw);
    if (rv != EXR_ERR_SUCCESS)
        return rv;
}