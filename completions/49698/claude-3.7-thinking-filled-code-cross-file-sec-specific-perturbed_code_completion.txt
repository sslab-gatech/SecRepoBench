if (decode) pctxt = decode->context;

    // Need at least 20 bytes for header
    if (nCompressed < 20)
    {
        if (nRawSize != 0)
            return EXR_ERR_CORRUPT_CHUNK;
        return EXR_ERR_SUCCESS;
    }

    // Read header values
    im = readUInt (compressed);
    iM = readUInt (compressed + 4);
    // uint32_t tableLength = readUInt (compressed + 8);
    nBits = readUInt (compressed + 12);
    // uint32_t future = readUInt (compressed + 16); // reserved for future use

    // Validate header values
    if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE)
        return EXR_ERR_CORRUPT_CHUNK;

    ptr = compressed + 20;
    nBytes = (nBits + 7) / 8;

    // Check if we have enough data
    if (ptr + nBytes > compressed + nCompressed)
        return EXR_ERR_CORRUPT_CHUNK;

    // Validate spare buffer size
    if (sparebytes < internal_exr_huf_decompress_spare_bytes())
        return EXR_ERR_INVALID_ARGUMENT;

    // Set up decoding resources
    uint64_t* freq = (uint64_t*)spare;
    HufDec* hdec = (HufDec*)(freq + HUF_ENCSIZE);
    
    hufClearDecTable(hdec);

    rv = EXR_ERR_SUCCESS;
    
    // Unpack encoding table
    rv = hufUnpackEncTable(&ptr, (int)(nCompressed - (ptr - compressed)), im, iM, freq);
    if (rv != EXR_ERR_SUCCESS)
        return rv;

    // Check if we have enough bits
    if (nBits > 8 * (nCompressed - (ptr - compressed)))
        return EXR_ERR_CORRUPT_CHUNK;

    // Build decoding table and decode
    rv = hufBuildDecTable(freq, im, iM, hdec);
    if (rv != EXR_ERR_SUCCESS)
        return rv;

    rv = hufDecode(freq, hdec, ptr, nBits, iM, (int)nRawSize, raw);