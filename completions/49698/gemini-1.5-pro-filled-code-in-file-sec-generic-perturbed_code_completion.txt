if (decode != NULL) pctxt = decode->context;

    if (nCompressed < 20) return EXR_ERR_CORRUPT_CHUNK;

    im = readUInt (compressed);
    iM = readUInt (compressed + 4);
    if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE)
        return EXR_ERR_CORRUPT_CHUNK;

    nBytes = nCompressed - 20;
    ptr    = compressed + 20;

    nBits = readUInt (compressed + 12);
    if (nBits > nCompressed * 8 - 20 * 8) return EXR_ERR_CORRUPT_CHUNK;

    if (fasthuf_decode_enabled () && nRawSize > 1024)
    {
        FastHufDecoder* fhd = (FastHufDecoder*) spare;
        if (sparebytes < sizeof (FastHufDecoder))
            return EXR_ERR_INVALID_ARGUMENT;

        rv = fasthuf_initialize (pctxt, fhd, &ptr, nBytes, im, iM, iM);
        if (rv != EXR_ERR_SUCCESS) return rv;

        nBytes -= (((uintptr_t) ptr) - ((uintptr_t) (compressed + 20)));

        rv = fasthuf_decode (
            pctxt, fhd, ptr, nBits, raw, nRawSize);
        return rv;
    }
    else
    {
        uint64_t* freq = (uint64_t*) spare;
        HufDec*   hdec = (HufDec*) (freq + HUF_ENCSIZE);

        if (sparebytes != internal_exr_huf_decompress_spare_bytes ())
            return EXR_ERR_INVALID_ARGUMENT;

        hufClearDecTable (hdec);
        rv = hufUnpackEncTable (&ptr, &nBytes, im, iM, freq);
        if (rv != EXR_ERR_SUCCESS) return rv;

        rv = hufBuildDecTable (freq, im, iM, hdec);
        if (rv != EXR_ERR_SUCCESS)
        {
            hufFreeDecTable (hdec);
            return rv;
        }

        rv = hufDecode (freq, hdec, ptr, nBits, iM, nRawSize, raw);
        hufFreeDecTable (hdec);
        return rv;
    }