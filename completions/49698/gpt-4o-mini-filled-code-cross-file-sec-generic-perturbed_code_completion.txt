// Check if the compressed data size is at least 20 bytes for a valid header.
    if (nCompressed < 20) {
        return EXR_ERR_CORRUPT_CHUNK;
    }

    // Read the header values
    im = readUInt(compressed);
    iM = readUInt(compressed + 4);
    nBits = readUInt(compressed + 12);

    // Validate that 'im' and 'iM' are within acceptable limits.
    if (im >= HUF_ENCSIZE || iM >= HUF_ENCSIZE) {
        return EXR_ERR_INVALID_ARGUMENT;
    }

    // Ensure there is enough data in the buffer to perform decompression.
    nBytes = (static_cast<uint64_t>(nBits) + 7) / 8;
    if (nCompressed < 20 + nBytes) {
        return EXR_ERR_CORRUPT_CHUNK;
    }

    // Check if fast Huffman decoding is enabled and applicable based on the data size.
    ptr = compressed + 20;
    if (FastHufDecoder::enabled() && nBits > 128) {
        FastHufDecoder fhd(ptr, nCompressed - (ptr - compressed), im, iM, iM);
        fhd.decode(raw, nBits, raw, nRawSize);
    } else {
        AutoArray<uint64_t, HUF_ENCSIZE> freq;
        AutoArray<HufDec, HUF_DECSIZE> hdec;

        hufClearDecTable(hdec);
        hufUnpackEncTable(&ptr, nCompressed - (ptr - compressed), im, iM, freq);
        hufBuildDecTable(freq, im, iM, hdec);
        hufDecode(freq, hdec, ptr, nBits, iM, nRawSize, raw);
    }

    rv = EXR_ERR_SUCCESS;