if (decode) pctxt = decode->context;

    if (nCompressed < 20)
    {
        if (nRawSize != 0) return EXR_ERR_CORRUPT_CHUNK;
        return EXR_ERR_SUCCESS;
    }

    im = readUInt (compressed);
    iM = readUInt (compressed + 4);
    uint32_t tableLength = readUInt (compressed + 8);
    nBits = readUInt (compressed + 12);

    if (im >= HUF_ENCSIZE || iM >= HUF_ENCSIZE)
        return EXR_ERR_CORRUPT_CHUNK;

    ptr = compressed + 20;
    nBytes = ((uint64_t) nBits + 7) / 8;

    if (ptr + nBytes > compressed + nCompressed)
        return EXR_ERR_CORRUPT_CHUNK;

    if (decode && decode->fast_huffman && nBits > 128)
    {
        rv = internal_fast_huf_decoder (
            decode, ptr, nCompressed - (ptr - compressed), im, iM, iM);
        if (rv != EXR_ERR_SUCCESS) return rv;

        if (ptr - compressed + nBytes > nCompressed)
            return EXR_ERR_CORRUPT_CHUNK;

        rv = internal_fast_huf_decode (
            decode, ptr, nBits, raw, nRawSize);
    }
    else
    {
        uint64_t* freq = (uint64_t*) spare;
        HufDec*   hdec = (HufDec*) (freq + HUF_ENCSIZE);

        hufClearDecTable (hdec);

        rv = hufUnpackEncTable (&ptr, nCompressed - (ptr - compressed), im, iM, freq);
        if (rv != EXR_ERR_SUCCESS) return rv;

        if (nBits > 8 * (nCompressed - (ptr - compressed)))
            return EXR_ERR_CORRUPT_CHUNK;

        rv = hufBuildDecTable (freq, im, iM, hdec);
        if (rv != EXR_ERR_SUCCESS) return rv;

        rv = hufDecode (freq, hdec, ptr, nBits, iM, nRawSize, raw);
    }