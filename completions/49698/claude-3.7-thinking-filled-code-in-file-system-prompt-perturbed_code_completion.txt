if (decode) pctxt = decode->context;
    
    if (nCompressed < 20)
    {
        if (pctxt)
            pctxt->print_error (
                pctxt,
                EXR_ERR_CORRUPT_CHUNK,
                "Huffman decompress error (Truncated header)");
        return EXR_ERR_CORRUPT_CHUNK;
    }

    im    = readUInt (compressed);
    iM    = readUInt (compressed + 4);
    nBits = readUInt (compressed + 12);

    if (im > iM || iM >= HUF_ENCSIZE)
    {
        if (pctxt)
            pctxt->print_error (
                pctxt,
                EXR_ERR_CORRUPT_CHUNK,
                "Huffman decompress error (Invalid frequency range)");
        return EXR_ERR_CORRUPT_CHUNK;
    }

    ptr = compressed + 20;

    nBytes = (nBits + 7) / 8;
    if (nBytes > nCompressed - 20)
    {
        if (pctxt)
            pctxt->print_error (
                pctxt,
                EXR_ERR_CORRUPT_CHUNK,
                "Huffman decompress error (Truncated bit stream)");
        return EXR_ERR_CORRUPT_CHUNK;
    }

    if (fasthuf_decode_enabled () && nRawSize > 2000)
    {
        FastHufDecoder* fhd = (FastHufDecoder*) spare;
        
        if (sparebytes < sizeof (FastHufDecoder))
            return EXR_ERR_INVALID_ARGUMENT;

        rv = fasthuf_initialize (
            pctxt, fhd, &ptr, nCompressed - 20, im, iM, (int) iM + 1);
        
        if (rv != EXR_ERR_SUCCESS)
            return rv;

        rv = fasthuf_decode (pctxt, fhd, ptr, nBits, raw, (int) nRawSize);
    }
    else
    {
        uint64_t* freq = (uint64_t*) spare;
        HufDec*   hdec = (HufDec*) (freq + HUF_ENCSIZE);
        
        if (sparebytes < internal_exr_huf_decompress_spare_bytes ())
            return EXR_ERR_INVALID_ARGUMENT;

        hufClearDecTable (hdec);

        uint64_t nl = nCompressed - 20;
        rv = hufUnpackEncTable (&ptr, &nl, im, iM, freq);
        
        if (rv != EXR_ERR_SUCCESS)
            return rv;

        rv = hufBuildDecTable (freq, im, iM, hdec);
        
        if (rv != EXR_ERR_SUCCESS)
        {
            hufFreeDecTable (hdec);
            return rv;
        }

        rv = hufDecode (freq, hdec, ptr, nBits, iM, nRawSize, raw);
        
        hufFreeDecTable (hdec);
    }
    
    return rv;