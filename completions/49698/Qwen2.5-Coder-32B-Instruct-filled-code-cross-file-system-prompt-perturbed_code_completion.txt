// need at least 20 bytes for header
    if (nCompressed < 20)
    {
        rv = EXR_ERR_CORRUPT_CHUNK;
        return rv;
    }

    im = readUInt(compressed);
    iM = readUInt(compressed + 4);
    nBits = readUInt(compressed + 12);

    if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE)
    {
        rv = EXR_ERR_INVALID_ARGUMENT;
        return rv;
    }

    ptr = compressed + 20;
    nBytes = (static_cast<uint64_t>(nBits) + 7) / 8;

    if (ptr + nBytes > compressed + nCompressed)
    {
        rv = EXR_ERR_CORRUPT_CHUNK;
        return rv;
    }

    // Fast decoder needs at least 2x64-bits of compressed data, and
    // needs to be run-able on this platform. Otherwise, fall back
    // to the original decoder
    if (FastHufDecoder::enabled() && nBits > 128)
    {
        FastHufDecoder fhd(ptr, nCompressed - (ptr - compressed), im, iM, iM);

        // must be nBytes remaining in buffer
        if (ptr - compressed + nBytes > static_cast<uint64_t>(nCompressed))
        {
            rv = EXR_ERR_CORRUPT_CHUNK;
            return rv;
        }

        fhd.decode((unsigned char*)ptr, nBits, raw, nRawSize);
        rv = EXR_ERR_SUCCESS;
    }
    else
    {
        AutoArray<uint64_t, HUF_ENCSIZE> freq;
        AutoArray<HufDec, HUF_DECSIZE> hdec;

        hufClearDecTable(hdec);

        hufUnpackEncTable(&ptr, nCompressed - (ptr - compressed), im, iM, freq);

        try
        {
            if (nBits > 8 * (nCompressed - (ptr - compressed)))
            {
                rv = EXR_ERR_INVALID_ARGUMENT;
                return rv;
            }

            hufBuildDecTable(freq, im, iM, hdec);
            hufDecode(freq, hdec, ptr, nBits, iM, nRawSize, raw);
            rv = EXR_ERR_SUCCESS;
        }
        catch (...)
        {
            hufFreeDecTable(hdec);
            rv = EXR_ERR_UNKNOWN_ERROR;
        }

        hufFreeDecTable(hdec);
    }