pctxt = decode->context;

if (nCompressed < 20)
{
    return EXR_ERR_CORRUPT_CHUNK;
}

im = readUInt ((const uint8_t*) compressed);
iM = readUInt ((const uint8_t*) compressed + 4);

if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE)
{
    return EXR_ERR_INVALID_ARGUMENT;
}

ptr = (const uint8_t*) compressed + 20;

nBytes = (static_cast<uint64_t> (readUInt ((const uint8_t*) compressed + 12)) + 7) / 8;

if (ptr + nBytes > (const uint8_t*) compressed + nCompressed)
{
    return EXR_ERR_CORRUPT_CHUNK;
}

if (FastHufDecoder::enabled () && readUInt ((const uint8_t*) compressed + 12) > 128)
{
    FastHufDecoder fhd (
        (const unsigned char*) ptr, 
        nCompressed - ((const uint8_t*) ptr - (const uint8_t*) compressed), 
        im, iM, iM);

    if (((const uint8_t*) ptr - (const uint8_t*) compressed) + nBytes > nCompressed)
    {
        return EXR_ERR_CORRUPT_CHUNK;
    }

    fhd.decode ((unsigned char*) ptr, readUInt ((const uint8_t*) compressed + 12), raw, nRawSize / sizeof(uint16_t));
}
else
{
    AutoArray<uint64_t, HUF_ENCSIZE> freq;
    AutoArray<HufDec, HUF_DECSIZE>   hdec;

    hufClearDecTable (hdec);

    hufUnpackEncTable (
        &ptr, 
        nCompressed - ((const uint8_t*) ptr - (const uint8_t*) compressed), 
        im, iM, freq);

    try
    {
        if (readUInt ((const uint8_t*) compressed + 12) > 8 * (nCompressed - ((const uint8_t*) ptr - (const uint8_t*) compressed))) 
        {
            return EXR_ERR_INVALID_ARGUMENT;
        }

        hufBuildDecTable (freq, im, iM, hdec);
        hufDecode (freq, hdec, (const unsigned char*) ptr, readUInt ((const uint8_t*) compressed + 12), iM, nRawSize / sizeof(uint16_t), raw);
    }
    catch (...)
    {
        hufFreeDecTable (hdec);
        return EXR_ERR_FAILURE;
    }

    hufFreeDecTable (hdec);
}