if (nCompressed < 20)
    return EXR_ERR_CORRUPT_CHUNK;

// Read header values
im    = readUInt(compressed);
iM    = readUInt(compressed + 4);
uint32_t tableLength = readUInt(compressed + 8);
nBits = readUInt(compressed + 12);
// (compressed + 16) reserved for future use

// Validate header values
if (im >= HUF_ENCSIZE || iM >= HUF_ENCSIZE)
    return EXR_ERR_CORRUPT_CHUNK;

// Set pointer to the beginning of the Huffman table and encoded data
ptr = compressed + 20;
nBytes = ((uint64_t)nBits + 7) / 8;

// Ensure the buffer contains enough data for the encoded bits
if (ptr + nBytes > compressed + nCompressed)
    return EXR_ERR_CORRUPT_CHUNK;

// Use fast Huffman decoding if enabled and applicable
if (FastHufDecoder::enabled() && nBits > 128)
{
    FastHufDecoder fhd(ptr, nCompressed - (ptr - compressed), im, iM, iM);
    // Double-check that the remaining buffer covers the compressed data length
    if ((ptr - compressed) + nBytes > nCompressed)
        return EXR_ERR_CORRUPT_CHUNK;
    fhd.decode(ptr, nBits, (unsigned char*)raw, nRawSize);
    rv = EXR_ERR_SUCCESS;
}
else
{
    AutoArray<uint64_t, HUF_ENCSIZE> freq;
    AutoArray<HufDec, HUF_DECSIZE>   hdec;

    hufClearDecTable(hdec.data());
    hufUnpackEncTable(&ptr, nCompressed - (ptr - compressed), im, iM, freq.data());

    // Validate that there is enough compressed data left for the expected number of bits
    if (nBits > 8 * (nCompressed - (ptr - compressed)))
    {
        hufFreeDecTable(hdec.data());
        return EXR_ERR_CORRUPT_CHUNK;
    }

    hufBuildDecTable(freq.data(), im, iM, hdec.data());
    rv = hufDecode(freq.data(), hdec.data(), ptr, nBits, iM, nRawSize, raw);
    hufFreeDecTable(hdec.data());
}