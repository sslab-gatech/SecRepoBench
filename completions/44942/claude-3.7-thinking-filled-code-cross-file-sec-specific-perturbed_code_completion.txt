struct ndpi_iphdr iph;
u_int16_t ip_len;
const u_int8_t *l4ptr = NULL;
u_int8_t l4proto;

/* Initialize the IPv4 header with zeros */
memset(&iph, 0, sizeof(iph));

/* Set IPv4 version and header length */
iph.version = 4;
iph.ihl = 5;

/* Copy IPv6 addresses to IPv4 structure */
memcpy(&iph.saddr, &ipv6_header->saddr.s6_addr32[3], sizeof(u_int32_t));
memcpy(&iph.daddr, &ipv6_header->daddr.s6_addr32[3], sizeof(u_int32_t));

/* Set initial Layer 4 pointer and protocol */
ip_len = ntohs(ipv6_header->payload_len) + sizeof(struct ndpi_ipv6hdr);
l4proto = ipv6_header->nexthdr;
l4ptr = (const u_int8_t *)ipv6_header + sizeof(struct ndpi_ipv6hdr);

/* Handle IPv6 extension headers */
while (l4proto == IPPROTO_HOPOPTS ||
       l4proto == IPPROTO_ROUTING ||
       l4proto == IPPROTO_FRAGMENT ||
       l4proto == IPPROTO_DSTOPTS) {
    
    /* Ensure there's enough data for the basic extension header */
    if ((l4ptr + 2) > ((const u_int8_t *)ipv6_header + ip_len)) {
        return NULL; /* Malformed packet */
    }
    
    /* Next header type */
    u_int8_t next_header = *l4ptr;
    
    /* Extension header length */
    u_int16_t ext_hdr_len;
    if (l4proto == IPPROTO_FRAGMENT) {
        ext_hdr_len = 8; /* Fragment header is always 8 bytes */
    } else {
        /* Other extension headers: length in 2nd byte, in 8-byte units, not counting first 8 bytes */
        ext_hdr_len = 8 + (*(l4ptr + 1) * 8);
    }
    
    /* Safety check to prevent buffer overflows */
    if ((l4ptr + ext_hdr_len) > ((const u_int8_t *)ipv6_header + ip_len)) {
        return NULL; /* Malformed packet */
    }
    
    /* Move to next header */
    l4ptr += ext_hdr_len;
    l4proto = next_header;
}