struct ndpi_iphdr iph;
  const u_int8_t *l4ptr = NULL;
  u_int8_t l4proto = 0;
  u_int16_t ip_len = 0;

  // Initialize the IPv4 header structure to zero
  memset(&iph, 0, sizeof(iph));

  // Extract source and destination addresses from the IPv6 header
  memcpy(&iph.saddr, &ipv6_header->saddr, sizeof(iph.saddr));
  memcpy(&iph.daddr, &ipv6_header->daddr, sizeof(iph.daddr));

  // Retrieve the protocol type and payload length from the IPv6 header
  l4proto = ipv6_header->nexthdr;
  ip_len = ntohs(ipv6_header->payload_len) + sizeof(struct ndpi_ipv6hdr);

  // Determine the pointer to the layer 4 protocol data
  l4ptr = (const u_int8_t *)ipv6_header + sizeof(struct ndpi_ipv6hdr);

  // Handle IPv6 extension headers
  while((l4proto == IPPROTO_HOPOPTS) || (l4proto == IPPROTO_ROUTING) ||
        (l4proto == IPPROTO_DSTOPTS) || (l4proto == IPPROTO_AH) ||
        (l4proto == IPPROTO_ESP) || (l4proto == IPPROTO_FRAGMENT)) {
    struct ndpi_ext_hdr *ext_hdr = (struct ndpi_ext_hdr *)l4ptr;

    if(l4proto == IPPROTO_FRAGMENT) {
      // Skip fragment header
      l4ptr += sizeof(struct ndpi_ipv6_frag_hdr);
    } else {
      // Skip other extension headers
      l4ptr += (ext_hdr->hdr_ext_len + 1) * 8;
    }

    // Update protocol and check for end of headers
    l4proto = ext_hdr->nexthdr;
    if((l4ptr - (const u_int8_t *)ipv6_header) >= ip_len) {
      // Malformed packet, return NULL
      return NULL;
    }
  }