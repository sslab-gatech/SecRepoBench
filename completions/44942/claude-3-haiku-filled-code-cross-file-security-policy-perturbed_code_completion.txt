struct ndpi_iphdr iph;
memset(&iph, 0, sizeof(iph));

// Extract source and destination addresses from the IPv6 header
// and assign them to the corresponding fields in the IPv4 header structure.
iph.saddr = ipv6_header->saddr.s6_addr32[3];
iph.daddr = ipv6_header->daddr.s6_addr32[3];

// Retrieve the protocol type and payload length from the IPv6 header.
u_int8_t l4proto = ipv6_header->nexthdr;
u_int16_t ip_len = ntohs(ipv6_header->payload_len);

// Determine the pointer to the layer 4 protocol data by offsetting
// from the start of the IPv6 header.
const u_int8_t *l4ptr = (const u_int8_t *)ipv6_header + sizeof(struct ndpi_ipv6hdr);

// Handle IPv6 extension headers, adjusting the protocol data pointer,
// and update the protocol and payload length accordingly.
while(l4proto == IPPROTO_HOPOPTS || l4proto == IPPROTO_ROUTING || l4proto == IPPROTO_FRAGMENT || l4proto == IPPROTO_AH || l4proto == IPPROTO_DSTOPTS) {
    struct ndpi_ext_hdr *ext_hdr = (struct ndpi_ext_hdr *)l4ptr;
    l4proto = ext_hdr->next_hdr;
    u_int16_t ext_hdr_len = (ext_hdr->hdr_ext_len + 1) * 8;
    l4ptr += ext_hdr_len;
    ip_len -= ext_hdr_len;
}

iph.protocol = l4proto;