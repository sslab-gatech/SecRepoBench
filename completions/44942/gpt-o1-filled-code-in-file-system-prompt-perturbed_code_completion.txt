struct ndpi_iphdr iph;
  uint8_t l4proto = ipv6_header->ip6_hdr.ip6_un1_nxt;
  uint16_t ip_len = ntohs(ipv6_header->ip6_hdr.ip6_un1_plen);
  const uint8_t *l4ptr = (const uint8_t *)(ipv6_header + 1);

  /* Initialize a dummy IPv4 header structure for compatibility */
  memset(&iph, 0, sizeof(iph));

  /* If needed, handle extension headers:
   * (Comment out if your caller already does this)
   *
   * if(ndpi_handle_ipv6_extension_headers(ipsize - sizeof(struct ndpi_ipv6hdr),
   *                                       &l4ptr, &ip_len, &l4proto) != 0) {
   *   return NULL;
   * }
   */

  iph.protocol = l4proto;

  return(get_ndpi_flow_info(workflow, 6, vlan_id, tunnel_type,
                            &iph, ipv6_header, ip_offset, ipsize,
                            ip_len, (uint16_t)(l4ptr - (const uint8_t *)ipv6_header),
                            tcph, udph, sport, dport,
                            proto, payload, payload_len, src_to_dst_direction, when));