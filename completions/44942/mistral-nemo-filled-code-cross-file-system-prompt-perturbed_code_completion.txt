// <MASK>
  struct ndpi_ipv4hdr iph;
  memset(&iph, 0, sizeof(iph));
  iph.version = 4;
  iph.ihl = 5;
  iph.tos = ipv6_header->priority;
  iph.tot_len = ipsize;
  iph.id = 0;
  iph.frag_off = 0;
  iph.ttl = ipv6_header->hop_limit;
  iph.protocol = l4proto;
  iph.check = 0;
  iph.saddr = ipv6_header->ip6_src.s6_addr32[3];
  iph.daddr = ipv6_header->ip6_dst.s6_addr32[3];

  u_int16_t l4ptr = ip_offset + ipsize;
  u_int16_t ip_len = ipsize;
  u_int8_t *l4ptr_ptr = (u_int8_t *)ipv6_header + l4ptr;

  if (ipv6_header->ip6_nxt == IPPROTO_HOPOPTS ||
      ipv6_header->ip6_nxt == IPPROTO_ROUTING) {
    l4ptr += 8;
    ip_len -= 8;
  }

  if (ipv6_header->ip6_nxt == IPPROTO_FRAGMENT) {
    l4ptr += 8;
    ip_len -= 8;
  }

  if (ipv6_header->ip6_nxt == IPPROTO_AH) {
    l4ptr += 24;
    ip_len -= 24;
  }

  if (ipv6_header->ip6_nxt == IPPROTO_ESP) {
    l4ptr += 4;
    ip_len -= 4;
  }

  if (ipv6_header->ip6_nxt == IPPROTO_DSTOPTS) {
    l4ptr += 8;
    ip_len -= 8;
  }

  iph.check = crc32_for_byte(0, (u_int8_t *)&iph, ip_len);