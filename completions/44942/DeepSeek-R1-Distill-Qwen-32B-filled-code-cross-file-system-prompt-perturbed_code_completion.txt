struct ndpi_ipv4hdr iph;
  u_int16_t ip_len;
  const u_int8_t *l4ptr;
  u_int8_t l4proto;

  memset(&iph, 0, sizeof(iph));
  iph.saddr = ((struct in6_addr *)&ipv6_header->src)[0];
  iph.daddr = ((struct in6_addr *)&ipv6_header->dst)[0];
  l4proto = ipv6_header->nexthdr;
  ip_len = 20 + ipsize;  /* 20 bytes for IPv4 header + payload */

  /* Find the pointer to the layer 4 data */
  l4ptr = (const u_int8_t *)(ipv6_header + 1);
  while(1) {
    if(l4proto == NDPI_PROTNUM_ICMPV6 || l4proto == NDPI_PROTNUM_TCP || 
       l4proto == NDPI_PROTNUM_UDP || l4proto == NDPI_PROTNUM_SCTP)
      break;

    /* Handle extension headers */
    if(l4proto == NDPI_PROTNUM_HOPOPT || l4proto == NDPI_PROTNUM_ROUTING ||
       l4proto == NDPI_PROTNUM_FRAGMENT || l4proto == NDPI_PROTNUM_ESP ||
       l4proto == NDPI_PROTNUM_AUTH) {
      const struct ndpi_ipv6_ext_hdr *ext_hdr = (const struct ndpi_ipv6_ext_hdr *)l4ptr;
      u_int8_t ext_len = ext_hdr->hdrlen + 1; /* hdrlen is in 8-byte units */
      l4ptr += ext_len * 8;
      ipsize -= ext_len * 8;
      l4proto = ext_hdr->nexthdr;
    } else {
      break;
    }
  }