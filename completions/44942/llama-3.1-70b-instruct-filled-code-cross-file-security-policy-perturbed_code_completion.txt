// Create an IPv4 header structure and initialize it to zero.
struct ndpi_ipv4hdr iph;
memset(&iph, 0, sizeof(iph));

// Extract source and destination addresses from the IPv6 header
// and assign them to the corresponding fields in the IPv4 header structure.
memcpy(&iph.src, &ipv6_header->saddr, sizeof(iph.src));
memcpy(&iph.dst, &ipv6_header->daddr, sizeof(iph.dst));

// Retrieve the protocol type and payload length from the IPv6 header.
u_int8_t l4proto = ipv6_header->ip6_ctlun.ip6_un1.ip6_un1_nxt;
u_int16_t ip_len = ntohs(ipv6_header->ip6_ctlun.ip6_un1.ip6_un1_plen);

// Determine the pointer to the layer 4 protocol data by offseting
// from the start of the IPv6 header.
const u_int8_t *l4ptr = (const u_int8_t *)ipv6_header + sizeof(*ipv6_header);

// Handle IPv6 extension headers, adjusting the protocol data pointer,
// and update the protocol and payload length accordingly.
while (l4proto == 0x29 || l4proto == 0x2b || l4proto == 0x2c || l4proto == 0x2e) {
    if (l4proto == 0x29) {
        // Handle IPv6 routing header
        const struct ndpi_ipv6_routing *routing = (const struct ndpi_ipv6_routing *)l4ptr;
        l4ptr += 8 + routing->hdr_ext_len * 8;
        l4proto = routing->next_header;
    } else if (l4proto == 0x2b) {
        // Handle IPv6 fragmentation header
        const struct ndpi_ipv6_frag *frag = (const struct ndpi_ipv6_frag *)l4ptr;
        l4ptr += 8;
        l4proto = frag->next_header;
    } else if (l4proto == 0x2c) {
        // Handle IPv6 destination options header
        const struct ndpi_ipv6_dest_opts *dest_opts = (const struct ndpi_ipv6_dest_opts *)l4ptr;
        l4ptr += 8 + dest_opts->hdr_ext_len * 8;
        l4proto = dest_opts->next_header;
    } else if (l4proto == 0x2e) {
        // Handle IPv6 mobility header
        const struct ndpi_ipv6_mobility *mobility = (const struct ndpi_ipv6_mobility *)l4ptr;
        l4ptr += 8 + mobility->hdr_ext_len * 8;
        l4proto = mobility->next_header;
    }
    ip_len -= (l4ptr - (const u_int8_t *)ipv6_header);
}

// Ensure that the total size of the data, including the IPv6 header and the payload length,
// does not exceed the available buffer size before processing it.
if (ip_len > ipsize) {
    // Handle error: packet too large
    return NULL;
}