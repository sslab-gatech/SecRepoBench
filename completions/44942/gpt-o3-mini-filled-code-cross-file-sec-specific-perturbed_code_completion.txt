memset(&iph, 0, sizeof(iph));

/* Assuming the IPv6 addresses are IPv4â€mapped, copy the last 4 bytes */
memcpy(&iph.ip_src, ((const u_int8_t *)&ipv6_header->saddr) + 12, 4);
memcpy(&iph.ip_dst, ((const u_int8_t *)&ipv6_header->daddr) + 12, 4);

/* Retrieve the initial Layer 4 protocol and payload length (converted to host order) */
u_int8_t l4proto = ipv6_header->nexthdr;
u_int16_t ip_len = ntohs(ipv6_header->payload_len);

/* Set pointer to the beginning of the Layer 4 header data */
const u_int8_t *l4ptr = (const u_int8_t *)ipv6_header + sizeof(struct ndpi_ipv6hdr);

/* Process any IPv6 extension headers */
while (l4proto == IPPROTO_HOPOPTS ||
       l4proto == IPPROTO_ROUTING ||
       l4proto == IPPROTO_FRAGMENT ||
       l4proto == IPPROTO_AH ||
       l4proto == IPPROTO_ESP ||
       l4proto == IPPROTO_DSTOPTS) {
    /* Ensure there is at least the minimum extension header length available */
    if (ip_len < 8)
        break;

    /* The first byte is the next header, the second byte specifies the header length */
    u_int8_t ext_hdr_next = *l4ptr;
    u_int8_t ext_hdr_len_field = *(l4ptr + 1);
    u_int16_t ext_total_len = (ext_hdr_len_field + 1) * 8;

    /* Validate that the extension header does not exceed the remaining payload */
    if (ip_len < ext_total_len)
        break;

    l4proto = ext_hdr_next;
    l4ptr += ext_total_len;
    ip_len -= ext_total_len;
}