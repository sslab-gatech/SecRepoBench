struct ndpi_iphdr iph;
  const u_int8_t *l4ptr = NULL;
  u_int8_t l4proto = 0;
  u_int16_t ip_len = 0;

  memset(&iph, 0, sizeof(iph)); // Initialize the IPv4 header structure to zero

  // Extract source and destination addresses from the IPv6 header
  memcpy(&iph.saddr, &ipv6_header->saddr, sizeof(ipv6_header->saddr));
  memcpy(&iph.daddr, &ipv6_header->daddr, sizeof(ipv6_header->daddr));

  // Retrieve the protocol type and payload length from the IPv6 header
  l4proto = ipv6_header->nexthdr;
  ip_len = ntohs(ipv6_header->payload_len) + sizeof(struct ndpi_ipv6hdr);

  // Determine the pointer to the layer 4 protocol data
  l4ptr = (const u_int8_t *)ipv6_header + sizeof(struct ndpi_ipv6hdr);

  // Handle IPv6 extension headers
  while((l4proto == IPPROTO_HOPOPTS) || (l4proto == IPPROTO_ROUTING) ||
        (l4proto == IPPROTO_DSTOPTS) || (l4proto == IPPROTO_AH) ||
        (l4proto == IPPROTO_ESP) || (l4proto == IPPROTO_FRAGMENT)) {
    struct ndpi_ipv6_opt_hdr *ext_hdr = (struct ndpi_ipv6_opt_hdr *)l4ptr;

    if(l4proto == IPPROTO_FRAGMENT) {
      struct ndpi_ipv6_frag_hdr *frag_hdr = (struct ndpi_ipv6_frag_hdr *)l4ptr;

      if(frag_hdr->frag_off & htons(0xFFF9)) // Check if this is the first fragment
        return NULL;

      l4proto = frag_hdr->nexthdr;
      l4ptr += sizeof(struct ndpi_ipv6_frag_hdr);
    } else {
      l4proto = ext_hdr->nexthdr;
      l4ptr += ((ext_hdr->hdrlen + 1) << 3);
    }

    if((l4ptr - (const u_int8_t *)ipv6_header) >= ip_len) // Ensure we don't exceed the payload length
      return NULL;
  }