struct ndpi_ipv4hdr iph = {0};
const u_int8_t *l4ptr = ((const u_int8_t *)ipv6_header) + ip_offset;
u_int16_t l4proto = ipv6_header->sgh.nxt;

memcpy(&iph.saddr, &ipv6_header->ip6_src.s6_addr[12], sizeof(iph.saddr));
memcpy(&iph.daddr, &ipv6_header->ip6_dst.s6_addr[12], sizeof(iph.daddr));

if(ipsize >= sizeof(struct ndpi_ipv6hdr)) {
  while((l4proto == IPPROTO_HOPOPTS) || (l4proto == IPPROTO_ROUTING) || (l4proto == IPPROTO_FRAGMENT) ||
        (l4proto == IPPROTO_AH) || (l4proto == IPPROTO_DSTOPTS)) {
    struct ndpi_ipv6_opt_hdr *opt = (struct ndpi_ipv6_opt_hdr *)l4ptr;

    if((sizeof(struct ndpi_ipv6_opt_hdr) + (((opt->hdrlen+1) << 2)) > ipsize) ||
       (sizeof(struct ndpi_ipv6_opt_hdr) > ipsize))
      return NULL;

    ipsize -= sizeof(struct ndpi_ipv6_opt_hdr) + (((opt->hdrlen+1) << 2));
    l4ptr += sizeof(struct ndpi_ipv6_opt_hdr) + (((opt->hdrlen+1) << 2));
    l4proto = opt->nxt;
  }

  if(l4proto == IPPROTO_TCP || l4proto == IPPROTO_UDP || l4proto == IPPROTO_ICMP) {
    *payload_len = ipsize - (l4ptr - (const u_int8_t *)ipv6_header);
    *payload = (u_int8_t *)l4ptr + (l4proto == IPPROTO_TCP ? sizeof(struct ndpi_tcphdr) : 
                                    (l4proto == IPPROTO_UDP ? sizeof(struct ndpi_udphdr) : 0));
    
    if(l4proto == IPPROTO_TCP) {
      *tcph = (struct ndpi_tcphdr *)l4ptr;
      *sport = ntohs((*tcph)->source);
      *dport = ntohs((*tcph)->dest);
    } else if(l4proto == IPPROTO_UDP) {
      *udph = (struct ndpi_udphdr *)l4ptr;
      *sport = ntohs((*udph)->source);
      *dport = ntohs((*udph)->dest);
    }
  }
}