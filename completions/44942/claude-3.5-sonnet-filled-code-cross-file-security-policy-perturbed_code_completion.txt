struct ndpi_iphdr iph;
u_int8_t l4proto;
u_int16_t ip_len;
const u_int8_t *l4ptr;

memset(&iph, 0, sizeof(iph));
iph.version = 4;
iph.saddr = ipv6_header->saddr.s6_addr32[3];
iph.daddr = ipv6_header->daddr.s6_addr32[3];

l4proto = ipv6_header->nexthdr;
ip_len = ntohs(ipv6_header->payload_len);
l4ptr = (const u_int8_t *)ipv6_header + sizeof(struct ndpi_ipv6hdr);

while (l4proto == IPPROTO_HOPOPTS || l4proto == IPPROTO_ROUTING || l4proto == IPPROTO_DSTOPTS) {
    struct ip6_ext *ext = (struct ip6_ext *)l4ptr;
    u_int16_t ext_len = (ext->ip6e_len + 1) << 3;

    if (l4ptr + ext_len > (const u_int8_t *)ipv6_header + ipsize) {
        return NULL;  // Extension header exceeds packet size
    }

    l4proto = ext->ip6e_nxt;
    l4ptr += ext_len;
    ip_len -= ext_len;
}

if (ip_len > ipsize - (l4ptr - (const u_int8_t *)ipv6_header)) {
    return NULL;  // Payload length exceeds remaining packet size
}