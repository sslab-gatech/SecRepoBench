struct ndpi_iphdr iph;
  memset(&iph, 0, sizeof(iph));

  /* Build a minimal IPv4 header */
  iph.version = 4;
  iph.ihl = 5;

  /* Copy last 32 bits of IPv6 addresses into IPv4 header fields */
  memcpy(&iph.saddr, &ipv6_header->saddr.s6_addr[12], 4);
  memcpy(&iph.daddr, &ipv6_header->daddr.s6_addr[12], 4);

  /* Parse initial protocol and payload length from IPv6 header */
  u_int8_t l4proto = ipv6_header->nexthdr;
  const u_int8_t *l4ptr = (const u_int8_t *)ipv6_header + sizeof(*ipv6_header);
  u_int16_t ip_len = ntohs(ipv6_header->payload_len);

  /* Safely handle known IPv6 extension headers */
  while(l4ptr + 2 <= (const u_int8_t *)ipv6_header + ipsize) {
    if(l4proto != 0 &&  /* Hop-by-Hop */
       l4proto != 43 && /* Routing */
       l4proto != 44 && /* Fragment */
       l4proto != 51 && /* AH */
       l4proto != 50 && /* ESP */
       l4proto != 60) { /* Destination Options */
      break;
    }
    if(l4ptr + 1 >= (const u_int8_t *)ipv6_header + ipsize) break;

    /* Each extension's length field is in 8-byte units minus 1. */
    u_int8_t ext_len = (u_int8_t)((l4ptr[1] + 1) << 3);
    l4proto = l4ptr[0];

    if(l4ptr + ext_len > (const u_int8_t *)ipv6_header + ipsize || ext_len < 2) break;
    l4ptr += ext_len;
  }

  /* Recompute payload size after extension headers */
  {
    u_int16_t hdr_consumed = (u_int16_t)(l4ptr - (const u_int8_t *)ipv6_header);
    if(hdr_consumed < ipsize) {
      ip_len = ipsize - hdr_consumed;
    } else {
      ip_len = 0;
    }
  }