struct ndpi_iphdr iph;
  const u_int8_t *l4ptr;
  u_int8_t l4proto;
  u_int16_t ip_len;

  memset(&iph, 0, sizeof(iph));

  // Extract source and destination addresses from the IPv6 header
  memcpy(&iph.saddr, &ipv6_header->saddr, sizeof(ipv6_header->saddr));
  memcpy(&iph.daddr, &ipv6_header->daddr, sizeof(ipv6_header->daddr));

  // Retrieve the protocol type and payload length from the IPv6 header
  l4proto = ipv6_header->nexthdr;
  ip_len = ntohs(ipv6_header->payload_len) + sizeof(struct ndpi_ipv6hdr);

  // Determine the pointer to the layer 4 protocol data
  l4ptr = (const u_int8_t *)ipv6_header + sizeof(struct ndpi_ipv6hdr);

  // Handle IPv6 extension headers
  while((l4proto == IPPROTO_HOPOPTS) || (l4proto == IPPROTO_ROUTING) ||
        (l4proto == IPPROTO_DSTOPTS) || (l4proto == IPPROTO_FRAGMENT) ||
        (l4proto == IPPROTO_AH) || (l4proto == IPPROTO_ESP)) {
    struct ndpi_ext_hdr *ext_hdr = (struct ndpi_ext_hdr *)l4ptr;

    if(l4proto == IPPROTO_FRAGMENT) {
      // Skip fragment header
      l4ptr += 8;
    } else {
      // Skip other extension headers
      l4ptr += (ext_hdr->hdrlen + 1) * 8;
    }

    l4proto = ext_hdr->nexthdr;
  }