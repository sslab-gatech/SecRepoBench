// Create an IPv4 header structure and initialize it to zero.
struct ndpi_ipv4hdr iph;
memset(&iph, 0, sizeof(iph));

// Extract source and destination addresses from the IPv6 header
// and assign them to the corresponding fields in the IPv4 header structure.
memcpy(&iph.src, &ipv6_header->saddr, sizeof(iph.src));
memcpy(&iph.dst, &ipv6_header->daddr, sizeof(iph.dst));

// Retrieve the protocol type and payload length from the IPv6 header.
u_int8_t l4proto = ipv6_header->ip6_ctlun.ip6_un1.ip6_un1_nxt;
u_int16_t ip_len = ntohs(ipv6_header->ip6_ctlun.ip6_un1.ip6_un1_flow) & 0x0FFF;

// Determine the pointer to the layer 4 protocol data by offsetting
// from the start of the IPv6 header.
const u_int8_t *l4ptr = (const u_int8_t *)ipv6_header + sizeof(*ipv6_header);

// Handle IPv6 extension headers, adjusting the protocol data pointer,
// and update the protocol and payload length accordingly.
while (l4proto == 0x29 || l4proto == 0x2B || l4proto == 0x2C || l4proto == 0x2D || l4proto == 0x2E || l4proto == 0x2F || l4proto == 0x30 || l4proto == 0x31 || l4proto == 0x32 || l4proto == 0x33 || l4proto == 0x3C || l4proto == 0x3D || l4proto == 0x3E || l4proto == 0x3F || l4proto == 0x60 || l4proto == 0x6D || l4proto == 0x6E || l4proto == 0x6F) {
    if (l4proto == 0x29) {
        // No next header
        break;
    } else {
        // Extension header
        const struct ndpi_ipv6_ext_hdr *ext_hdr = (const struct ndpi_ipv6_ext_hdr *)l4ptr;
        l4proto = ext_hdr->next_header;
        l4ptr += 8 + (ext_hdr->hdr_ext_len * 8);
    }
}