const u_int8_t *l4ptr = (const u_int8_t *)ipv6_header + sizeof(*ipv6_header);
   u_int16_t ip_len = ntohs(ipv6_header->payload_len);
   u_int8_t l4proto = ipv6_header->nexthdr;

   /* Process IPv6 extension headers */
   while ((l4proto == IPPROTO_HOPOPTS ||
           l4proto == IPPROTO_ROUTING ||
           l4proto == IPPROTO_FRAGMENT ||
           l4proto == IPPROTO_AH ||
           l4proto == IPPROTO_DSTOPTS) && ip_len > 0) {
       if (l4proto == IPPROTO_FRAGMENT) {
           /* Fragment header is always 8 bytes long */
           l4proto = *l4ptr;
           l4ptr += 8;
           ip_len = (ip_len > 8 ? ip_len - 8 : 0);
       } else if (l4proto == IPPROTO_AH) {
           /* AH header: header length field contains (payload length + 2) 32-bit words */
           u_int8_t hdr_len = (*(l4ptr + 1) + 2) * 4;
           l4proto = *l4ptr;
           l4ptr += hdr_len;
           ip_len = (ip_len > hdr_len ? ip_len - hdr_len : 0);
       } else {
           /* Hop-by-Hop, Routing, and Destination Options headers:
              header length field contains (hdr length + 1) 8-octet units */
           u_int8_t hdr_len = (*(l4ptr + 1) + 1) * 8;
           l4proto = *l4ptr;
           l4ptr += hdr_len;
           ip_len = (ip_len > hdr_len ? ip_len - hdr_len : 0);
       }
   }