struct ndpi_iphdr iph;
memset(&iph, 0, sizeof(iph));
memcpy(&iph.saddr, &ipv6_header->saddr, sizeof(struct in6_addr));
memcpy(&iph.daddr, &ipv6_header->daddr, sizeof(struct in6_addr));
u_int16_t ip_len = ntohs(ipv6_header->payload_len);
u_int8_t l4proto = ipv6_header->nexthdr;
const u_int8_t *l4ptr = (const u_int8_t *)(ipv6_header + 1);

while (l4proto == IPPROTO_FRAGMENT || l4proto == IPPROTO_HOPOPTS || l4proto == IPPROTO_ROUTING || l4proto == IPPROTO_DSTOPTS) {
  if (l4proto == IPPROTO_FRAGMENT) {
    struct ndpi_ipv6_fraghdr *fraghdr = (struct ndpi_ipv6_fraghdr *)l4ptr;
    l4proto = fraghdr->nexthdr;
    l4ptr += sizeof(struct ndpi_ipv6_fraghdr);
  } else {
    struct ndpi_ipv6_opt_hdr *opt_hdr = (struct ndpi_ipv6_opt_hdr *)l4ptr;
    l4proto = opt_hdr->nexthdr;
    l4ptr += (opt_hdr->hdrlen + 1) << 3;
  }
}

if (l4proto == IPPROTO_TCP) {
  *tcph = (struct ndpi_tcphdr *)l4ptr;
  *sport = ntohs((*tcph)->source);
  *dport = ntohs((*tcph)->dest);
} else if (l4proto == IPPROTO_UDP) {
  *udph = (struct ndpi_udphdr *)l4ptr;
  *sport = ntohs((*udph)->source);
  *dport = ntohs((*udph)->dest);
}

*proto = l4proto;
*payload = (u_int8_t *)l4ptr;
*payload_len = ip_len - (l4ptr - (const u_int8_t *)(ipv6_header + 1));