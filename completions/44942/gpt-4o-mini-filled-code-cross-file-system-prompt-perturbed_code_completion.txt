struct ndpi_ipv4hdr iph;
memset(&iph, 0, sizeof(struct ndpi_ipv4hdr));

iph.src_ip = ipv6_header->src_ip; // Assuming src_ip is a field in the ndpi_ipv6hdr
iph.dst_ip = ipv6_header->dst_ip; // Assuming dst_ip is a field in the ndpi_ipv6hdr
iph.payload_len = ntohs(ipv6_header->payload_len); // Assuming payload_len is a field in the ndpi_ipv6hdr
iph.version = 4; // Set IPv4 version
iph.ihl = sizeof(struct ndpi_ipv4hdr) / 4; // Header length in 32-bit words
iph.tos = 0; // Type of service
iph.total_length = htons(sizeof(struct ndpi_ipv4hdr) + iph.payload_len); // Total length
iph.id = htons(0); // Identification
iph.frag_off = htons(0); // Fragment offset
iph.ttl = 64; // Time to live
iph.check = 0; // Checksum (to be calculated later)

const u_int8_t *l4ptr = (const u_int8_t *)ipv6_header + ip_offset; // Layer 4 pointer
u_int8_t l4proto = ipv6_header->next_header; // Assuming next_header is a field in the ndpi_ipv6hdr