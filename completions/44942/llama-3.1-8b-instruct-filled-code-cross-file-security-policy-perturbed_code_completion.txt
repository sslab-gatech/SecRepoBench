// <MASK>
// Extract source and destination addresses from the IPv6 header
iph.saddr = ipv6_header->saddr;
iph.daddr = ipv6_header->daddr;

// Retrieve the protocol type and payload length from the IPv6 header
iph.protocol = ipv6_header->next_header;
iph.tot_len = ipv6_header->payload_len;

// Determine the pointer to the layer 4 protocol data by offsetting
// from the start of the IPv6 header
l4ptr = (const u_int8_t *)ipv6_header + ipv6_header->payload_len;

// Handle IPv6 extension headers, adjusting the protocol data pointer,
// and update the protocol and payload length accordingly.
while (iph.protocol == 41) { // 41 is the value for the IPv6 extension header
  // Check if the extension header is a fragment header
  if (iph.next_header == 44) { // 44 is the value for the IPv6 fragment header
    // Update the protocol and payload length
    iph.protocol = ipv6_header->next_header;
    iph.tot_len = ipv6_header->payload_len;
    // Move the pointer to the next extension header
    l4ptr = (const u_int8_t *)ipv6_header + ipv6_header->payload_len;
  } else {
    // Move the pointer to the next extension header
    l4ptr = (const u_int8_t *)ipv6_header + ipv6_header->payload_len;
  }
  // Move to the next extension header
  ipv6_header = (const struct ndpi_ipv6hdr *)l4ptr;
}

// Ensure that the total size of the data, including the IPv6 header and the payload length,
// does not exceed the available buffer size before processing it.
if (iph.tot_len > ipsize) {
  iph.tot_len = ipsize;
}