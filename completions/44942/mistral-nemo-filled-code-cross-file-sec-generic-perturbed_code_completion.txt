// <MASK>
  struct ndpi_ipv4hdr iph;
  memset(&iph, 0, sizeof(iph));
  iph.version = 4;
  iph.ihl = 5;
  iph.tos = ipv6_header->priority;
  iph.tot_len = ipsize;
  iph.id = 0;
  iph.frag_off = 0;
  iph.ttl = ipv6_header->hop_limit;
  iph.protocol = l4proto;
  iph.check = 0; // Will be calculated later
  iph.saddr = ipv6_header->ip6_src.s6_addr32[3];
  iph.daddr = ipv6_header->ip6_dst.s6_addr32[3];

  u_int16_t ip_len = ipsize;
  u_int8_t *l4ptr = (u_int8_t *)ipv6_header + ip_offset;

  // Handle IPv6 extension headers
  while (ip_len > 0 && l4ptr < (u_int8_t *)ipv6_header + ipsize) {
    if (*l4ptr == IPPROTO_HOPOPTS || *l4ptr == IPPROTO_ROUTING) {
      l4ptr += 2; // Skip next header and length fields
      ip_len -= 2;
    } else if (*l4ptr == IPPROTO_FRAGMENT) {
      l4ptr += 1; // Skip next header field
      ip_len -= 1;
    } else {
      break;
    }
  }

  iph.check = ~crc32_for_buffer((u_int8_t *)&iph, sizeof(iph)) & 0xFFFFFFFF;

  return(get_ndpi_flow_info(workflow, 6, vlan_id, tunnel_type,
			    &iph, ipv6_header, ip_offset, ipsize,
			    ip_len, l4ptr - (const u_int8_t *)ipv6_header,
			    tcph, udph, sport, dport,
			    proto, payload,
			    payload_len, src_to_dst_direction, when));