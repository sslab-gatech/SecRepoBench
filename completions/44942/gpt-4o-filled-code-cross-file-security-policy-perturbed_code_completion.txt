struct ndpi_iphdr iph;
  const u_int8_t *l4ptr;
  u_int16_t ip_len;
  u_int8_t l4proto;
  
  // Initialize the IPv4 header structure to zero
  memset(&iph, 0, sizeof(iph));

  // Extract source and destination addresses from the IPv6 header
  memcpy(&iph.saddr, &ipv6_header->saddr, sizeof(ipv6_header->saddr));
  memcpy(&iph.daddr, &ipv6_header->daddr, sizeof(ipv6_header->daddr));

  // Retrieve the protocol type and payload length from the IPv6 header
  l4proto = ipv6_header->nexthdr;
  ip_len = ntohs(ipv6_header->payload_len) + sizeof(struct ndpi_ipv6hdr);

  // Ensure the total size does not exceed the available buffer size
  if (ip_len > ipsize) {
    return NULL; // Prevent processing if the size is invalid
  }

  // Determine the pointer to the layer 4 protocol data
  l4ptr = (const u_int8_t *)ipv6_header + sizeof(struct ndpi_ipv6hdr);

  // Handle IPv6 extension headers
  while (l4proto == IPPROTO_HOPOPTS || l4proto == IPPROTO_ROUTING ||
         l4proto == IPPROTO_DSTOPTS || l4proto == IPPROTO_AH ||
         l4proto == IPPROTO_ESP || l4proto == IPPROTO_FRAGMENT) {
    // Process extension headers and update l4ptr, l4proto, and ip_len
    // This is a simplified example; actual processing may vary
    if (l4proto == IPPROTO_HOPOPTS || l4proto == IPPROTO_DSTOPTS) {
      l4proto = *(l4ptr + 1);
      l4ptr += ((*(l4ptr + 1)) + 1) * 8;
    } else if (l4proto == IPPROTO_ROUTING) {
      l4proto = *(l4ptr + 1);
      l4ptr += ((*(l4ptr + 1)) + 1) * 8;
    } else if (l4proto == IPPROTO_FRAGMENT) {
      l4proto = *(l4ptr + 1);
      l4ptr += 8;
    } else if (l4proto == IPPROTO_AH) {
      l4proto = *(l4ptr + 1);
      l4ptr += ((*(l4ptr + 1)) + 2) * 4;
    } else if (l4proto == IPPROTO_ESP) {
      // ESP header length is variable, handle accordingly
      break; // For simplicity, break out of the loop
    }
  }