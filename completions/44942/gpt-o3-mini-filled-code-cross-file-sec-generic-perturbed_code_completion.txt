struct ndpi_iphdr iph;
memset(&iph, 0, sizeof(iph));

/* Convert the 128‐bit IPv6 addresses into pseudo 32‐bit IPv4 addresses
   by XORing the four 32-bit words together. */
union {
  u_int8_t bytes[16];
  u_int32_t words[4];
} src, dst;
memcpy(src.bytes, &ipv6_header->src, sizeof(src.bytes));
memcpy(dst.bytes, &ipv6_header->dst, sizeof(dst.bytes));
iph.saddr = src.words[0] ^ src.words[1] ^ src.words[2] ^ src.words[3];
iph.daddr = dst.words[0] ^ dst.words[1] ^ dst.words[2] ^ dst.words[3];

/* Initialize layer‐4 protocol pointer and compute total IP length.
   Note: IPv6 payload length does not include the fixed header. */
u_int8_t l4proto = ipv6_header->nexthdr;
const u_int8_t *l4ptr = (const u_int8_t *)ipv6_header + sizeof(*ipv6_header);
u_int16_t ip_len = ntohs(ipv6_header->payload_len) + sizeof(*ipv6_header);

/* Process IPv6 extension headers, if present.
   For most extensions the second byte gives the header length (in 8‐octet units, minus 1). */
while (l4proto == IPPROTO_HOPOPTS ||
       l4proto == IPPROTO_ROUTING ||
       l4proto == IPPROTO_FRAGMENT ||
       l4proto == IPPROTO_DSTOPTS) {
    if (l4ptr + 2 > (const u_int8_t *)ipv6_header + ipsize)
        break;
    u_int8_t ext_hdr_len = *(l4ptr + 1);
    u_int16_t ext_total_len = (ext_hdr_len + 1) * 8;
    if (l4ptr + ext_total_len > (const u_int8_t *)ipv6_header + ipsize)
        break;
    l4proto = *l4ptr;
    l4ptr += ext_total_len;
    ip_len = (ip_len > ext_total_len) ? (ip_len - ext_total_len) : 0;
}