struct ndpi_iphdr iph;
  const u_int8_t *l4ptr;
  u_int8_t l4proto;
  u_int16_t ip_len;

  memset(&iph, 0, sizeof(iph));

  // Extract source and destination addresses from IPv6 header
  memcpy(&iph.saddr, &ipv6_header->saddr, sizeof(ipv6_header->saddr));
  memcpy(&iph.daddr, &ipv6_header->daddr, sizeof(ipv6_header->daddr));

  // Retrieve protocol and payload length
  l4proto = ipv6_header->nexthdr;
  ip_len = ntohs(ipv6_header->payload_len) + sizeof(struct ndpi_ipv6hdr);

  // Determine the pointer to the layer 4 protocol data
  l4ptr = (const u_int8_t *)ipv6_header + sizeof(struct ndpi_ipv6hdr);

  // Handle IPv6 extension headers
  while((l4proto == IPPROTO_HOPOPTS) || (l4proto == IPPROTO_ROUTING) ||
        (l4proto == IPPROTO_FRAGMENT) || (l4proto == IPPROTO_AH) ||
        (l4proto == IPPROTO_DSTOPTS)) {
    struct ndpi_ext_hdr *ext_hdr = (struct ndpi_ext_hdr *)l4ptr;

    if(l4proto == IPPROTO_FRAGMENT) {
      l4proto = ext_hdr->nexthdr;
      l4ptr += sizeof(struct ndpi_frag_hdr);
    } else {
      l4proto = ext_hdr->nexthdr;
      l4ptr += (ext_hdr->hdrlen + 1) * 8;
    }

    if((l4ptr - (const u_int8_t *)ipv6_header) >= ip_len) {
      // Malformed packet
      return NULL;
    }
  }