struct ndpi_ipv4hdr iph;
  u_int16_t ip_len;
  const u_int8_t *l4ptr;
  u_int8_t l4proto;

  memset(&iph, 0, sizeof(iph));

  iph.saddr = ipv6_header->saddr.s6_addr32[3];
  iph.daddr = ipv6_header->daddr.s6_addr32[3];
  ip_len = ipsize;
  l4proto = ipv6_header->nexthdr;
  l4ptr = (const u_int8_t *)ipv6_header + sizeof(struct ndpi_ipv6hdr);

  while(l4proto == IPPROTO_HOPOPTS || l4proto == IPPROTO_ROUTING
	|| l4proto == IPPROTO_FRAGMENT || l4proto == IPPROTO_AH
	|| l4proto == IPPROTO_DSTOPTS || l4proto == IPPROTO_MOBILITY_HEADER) {
    struct ndpi_ext_ipv6hdr *exthdr = (struct ndpi_ext_ipv6hdr *)l4ptr;
    u_int16_t len = 8 + exthdr->ext_len * 8;

    if(ipsize < len)
      return NULL;

    if(l4proto == IPPROTO_FRAGMENT) {
      // This is a fragment. Let the caller handle it.
      return NULL;
    }

    l4proto = exthdr->nexthdr;
    l4ptr += len;
    ipsize -= len;
  }

  if(ipsize < 0)
    return NULL;