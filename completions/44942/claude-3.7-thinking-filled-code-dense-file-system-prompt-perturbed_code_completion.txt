struct ndpi_iphdr iph;
const u_int8_t *l4ptr = NULL;
u_int16_t ip_len = 0;
u_int8_t l4proto;

/* Create an IPv4 header structure and initialize it to zero */
memset(&iph, 0, sizeof(struct ndpi_iphdr));

/* Extract source and destination addresses from the IPv6 header */
/* Use a hash of the IPv6 addresses for the IPv4 fields to maintain flow uniqueness */
iph.saddr = ipv6_header->ip6_src.u6_addr32[0] ^ ipv6_header->ip6_src.u6_addr32[1] ^
            ipv6_header->ip6_src.u6_addr32[2] ^ ipv6_header->ip6_src.u6_addr32[3];
iph.daddr = ipv6_header->ip6_dst.u6_addr32[0] ^ ipv6_header->ip6_dst.u6_addr32[1] ^
            ipv6_header->ip6_dst.u6_addr32[2] ^ ipv6_header->ip6_dst.u6_addr32[3];

/* Retrieve the protocol type and payload length */
l4proto = ipv6_header->ip6_hdr.ip6_un1_nxt;
ip_len = ntohs(ipv6_header->ip6_hdr.ip6_un1_plen);

/* Determine the pointer to the layer 4 protocol data */
l4ptr = (((const u_int8_t *) ipv6_header) + sizeof(struct ndpi_ipv6hdr));

/* Handle IPv6 extension headers */
if(ndpi_handle_ipv6_extension_headers(ipsize - sizeof(struct ndpi_ipv6hdr), &l4ptr, &ip_len, &l4proto) != 0) {
  /* Invalid packet */
  return NULL;
}