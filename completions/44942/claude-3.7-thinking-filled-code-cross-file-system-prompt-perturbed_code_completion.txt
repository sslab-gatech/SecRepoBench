struct ndpi_iphdr iph;
u_int8_t l4proto;
const u_int8_t *l4ptr;
u_int16_t ip_len;

/* Initialize the IPv4 header structure */
memset(&iph, 0, sizeof(iph));

/* Copy IPv6 addresses to IPv4 fields */
memcpy(&iph.saddr, &ipv6_header->saddr.s6_addr[12], 4);
memcpy(&iph.daddr, &ipv6_header->daddr.s6_addr[12], 4);

/* Get initial next header value and payload length */
l4proto = ipv6_header->nexthdr;
ip_len = ntohs(ipv6_header->payload_len);

/* Set Layer 4 pointer to the beginning of the payload */
l4ptr = (((const u_int8_t *) ipv6_header) + sizeof(struct ndpi_ipv6hdr));

/* Process IPv6 extension headers */
while(1) {
    switch(l4proto) {
    case IPPROTO_HOPOPTS:
    case IPPROTO_DSTOPTS:
    case IPPROTO_ROUTING:
        if(l4ptr + 2 <= ((const u_int8_t *)ipv6_header) + ip_offset + ipsize) {
            u_int8_t hdr_len = ((*(l4ptr + 1)) + 1) << 3;
            u_int8_t next_hdr = *l4ptr;
            
            if(l4ptr + hdr_len <= ((const u_int8_t *)ipv6_header) + ip_offset + ipsize) {
                l4proto = next_hdr;
                l4ptr += hdr_len;
                continue;
            }
        }
        return NULL; /* Invalid packet */
        
    case IPPROTO_AH:
        if(l4ptr + 2 <= ((const u_int8_t *)ipv6_header) + ip_offset + ipsize) {
            u_int8_t hdr_len = (*(l4ptr + 1) + 2) << 2;
            u_int8_t next_hdr = *l4ptr;
            
            if(l4ptr + hdr_len <= ((const u_int8_t *)ipv6_header) + ip_offset + ipsize) {
                l4proto = next_hdr;
                l4ptr += hdr_len;
                continue;
            }
        }
        return NULL; /* Invalid packet */
        
    case IPPROTO_FRAGMENT:
        if(l4ptr + 8 <= ((const u_int8_t *)ipv6_header) + ip_offset + ipsize) {
            u_int8_t next_hdr = *l4ptr;
            l4proto = next_hdr;
            l4ptr += 8;
            continue;
        }
        return NULL; /* Invalid packet */
        
    default:
        /* No more extension headers, break the loop */
        break;
    }
    
    break; /* Exit the loop */
}