// <MASK>
// Extract source and destination addresses from the IPv6 header
iph.saddr = ipv6_header->saddr;
iph.daddr = ipv6_header->daddr;

// Retrieve the protocol type and payload length from the IPv6 header
iph.protocol = ipv6_header->nexthdr;
iph.ihl = 5; // IPv6 header length is 40 bytes
iph.tot_len = htons(ipsize);

// Determine the pointer to the layer 4 protocol data by offsetting
// from the start of the IPv6 header
l4ptr = (const u_int8_t *)ipv6_header + ip_offset;

// Handle IPv6 extension headers, adjusting the protocol data pointer,
// and update the protocol and payload length accordingly.
while(ipv6_header->nexthdr!= IPPROTO_TCP && ipv6_header->nexthdr!= IPPROTO_UDP) {
  switch(ipv6_header->nexthdr) {
    case IPPROTO_HOPOPTS:
      iph.ihl += 2; // Hop-by-Hop Options header
      ipv6_header = (const struct ndpi_ipv6hdr *)((const u_int8_t *)ipv6_header + 2);
      break;
    case IPPROTO_ROUTING:
      iph.ihl += 8; // Routing header
      ipv6_header = (const struct ndpi_ipv6hdr *)((const u_int8_t *)ipv6_header + 8);
      break;
    case IPPROTO_FRAGMENT:
      iph.ihl += 8; // Fragment header
      ipv6_header = (const struct ndpi_ipv6hdr *)((const u_int8_t *)ipv6_header + 8);
      break;
    default:
      // Unknown extension header, just skip it
      ipv6_header = (const struct ndpi_ipv6hdr *)((const u_int8_t *)ipv6_header + 8);
      break;
  }
  l4ptr = (const u_int8_t *)ipv6_header + ip_offset;
}

// Update the protocol and payload length
iph.protocol = l4proto;
iph.tot_len = htons(ipsize - (l4ptr - (const u_int8_t *)ipv6_header));