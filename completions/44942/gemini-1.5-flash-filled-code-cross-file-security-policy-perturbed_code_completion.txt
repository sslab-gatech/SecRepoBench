struct ndpi_ipv4hdr iph;
  memset(&iph, 0, sizeof(iph));
  iph.saddr = ipv6_header->saddr.in4.s_addr;
  iph.daddr = ipv6_header->daddr.in4.s_addr;
  u_int8_t l4proto = ipv6_header->nexthdr;
  u_int16_t ip_len = ntohs(ipv6_header->payload_len);
  const u_int8_t *l4ptr = (const u_int8_t *)ipv6_header + ip_offset;

  // Check for IPv6 extension headers and adjust the protocol data pointer and length accordingly.
  while (l4proto == IPPROTO_HOPOPTS || l4proto == IPPROTO_ROUTING ||
         l4proto == IPPROTO_FRAGMENT || l4proto == IPPROTO_AH ||
         l4proto == IPPROTO_ESP || l4proto == IPPROTO_DSTOPTS) {
    // Determine the length of the current extension header.
    u_int8_t header_len = 0;
    if (l4proto == IPPROTO_HOPOPTS || l4proto == IPPROTO_ROUTING ||
        l4proto == IPPROTO_DSTOPTS) {
      header_len = ((const u_int8_t *)ipv6_header)[ip_offset] + 1;
    } else if (l4proto == IPPROTO_FRAGMENT) {
      header_len = 8;
    } else if (l4proto == IPPROTO_AH) {
      header_len = ((const u_int8_t *)ipv6_header)[ip_offset] + 2;
    } else if (l4proto == IPPROTO_ESP) {
      header_len = ((const u_int8_t *)ipv6_header)[ip_offset] + 2;
    }

    // Check if the total size exceeds the buffer size.
    if (ip_offset + header_len > ipsize) {
      return NULL;
    }

    // Update the protocol data pointer and length.
    ip_offset += header_len;
    ip_len -= header_len;
    l4proto = ((const u_int8_t *)ipv6_header)[ip_offset - 1];
    l4ptr = (const u_int8_t *)ipv6_header + ip_offset;
  }

  // Check if the total size exceeds the buffer size.
  if (ip_offset + ip_len > ipsize) {
    return NULL;
  }