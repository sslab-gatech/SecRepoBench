struct ndpi_iphdr iph = { 0 };
const u_int8_t *l4ptr = (const u_int8_t *)ipv6_header + ip_offset;
u_int16_t l4proto = ipv6_header->nexthdr, ip_len = ntohs(ipv6_header->payload_len);

memcpy(&iph.saddr, &ipv6_header->saddr, sizeof(iph.saddr));
memcpy(&iph.daddr, &ipv6_header->daddr, sizeof(iph.daddr));

while (l4proto == IPPROTO_HOPOPTS || l4proto == IPPROTO_ROUTING || 
       l4proto == IPPROTO_FRAGMENT || l4proto == IPPROTO_AH || 
       l4proto == IPPROTO_ESP || l4proto == IPPROTO_DSTOPTS) {
  struct ndpi_ipv6_ext_hdr *ext_hdr = (struct ndpi_ipv6_ext_hdr *)l4ptr;

  ip_len -= (ext_hdr->len + 1) << 3;
  l4ptr += (ext_hdr->len + 1) << 3;
  l4proto = ext_hdr->nexthdr;
}

*payload_len = ip_len;
*payload = (u_int8_t *)l4ptr + ((l4proto == IPPROTO_TCP) ? sizeof(struct ndpi_tcphdr) : 
                                (l4proto == IPPROTO_UDP) ? sizeof(struct ndpi_udphdr) : 0);
if(l4proto == IPPROTO_TCP) {
  *tcph = (struct ndpi_tcphdr *)l4ptr;
  *sport = ntohs((*tcph)->source);
  *dport = ntohs((*tcph)->dest);
} else if(l4proto == IPPROTO_UDP) {
  *udph = (struct ndpi_udphdr *)l4ptr;
  *sport = ntohs((*udph)->source);
  *dport = ntohs((*udph)->dest);
}
proto = &l4proto;
src_to_dst_direction = NULL; // Set direction logic as per application need.