struct ndpi_ipv4hdr iph;
  const u_int8_t *l4ptr;
  u_int8_t l4proto;
  u_int16_t ip_len;

  memset(&iph, 0, sizeof(iph));
  memcpy(&iph.saddr, &ipv6_header->saddr, sizeof(iph.saddr));
  memcpy(&iph.daddr, &ipv6_header->daddr, sizeof(iph.daddr));

  ip_len = ntohs(ipv6_header->payload_len);

  l4ptr = (const u_int8_t *)ipv6_header + 40; /* IPv6 header size */
  l4proto = ipv6_header->next_header;

  /* IPv6 Extension Headers */
  while (l4proto == 0 || l4proto == 43 || l4proto == 44 ||
	 l4proto == 50 || l4proto == 51 || l4proto == 60) {
    struct ndpi_ipv6_ext_hdr *ext_header = (struct ndpi_ipv6_ext_hdr *)l4ptr;
    u_int8_t next_header = ext_header->next_header;
    u_int8_t header_len = ext_header->header_len;

    if (l4proto == 0) {
      header_len = 8; /* Hop-by-Hop Options Header */
    } else if (l4proto == 60) {
      header_len = 8; /* Destination Options Header */
    } else if (l4proto == 43) {
      header_len = 8; /* Routing Header */
    } else if (l4proto == 44) {
      header_len = 8; /* Fragment Header */
    } else if (l4proto == 50) {
      header_len = 8; /* Encapsulating Security Payload Header */
    } else if (l4proto == 51) {
      header_len = 4; /* Authentication Header */
    }

    l4ptr += header_len;
    ip_len -= header_len;
    l4proto = next_header;
  }

  iph.version = 4;
  iph.ihl = 5;
  iph.tot_len = htons(ip_len + 20);
  iph.ttl = 64;
  iph.frag_off = 0;
  iph.check = 0;
  iph.tos = 0;
  iph.id = 0;