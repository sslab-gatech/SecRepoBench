// <MASK>
  if (payload_len + ip_offset + sizeof(struct ndpi_ipv6hdr) > workflow->buffer_size) {
    // Handle error or return, as the data size exceeds the available buffer size
    return NULL;
  }

  iph.version = 4;
  iph.ihl = 5;
  iph.tos = ipv6_header->priority;
  iph.tot_len = htons(payload_len + sizeof(struct ndpi_ipv6hdr));
  iph.id = 0;
  iph.frag_off = 0;
  iph.ttl = ipv6_header->hop_limit;
  iph.protocol = ipv6_header->nexthdr;
  iph.check = 0; // Calculate and set the checksum later
  iph.saddr = ipv6_header->ip6_src.s6_addr32[0];
  iph.daddr = ipv6_header->ip6_dst.s6_addr32[0];

  l4proto = ipv6_header->nexthdr;
  l4ptr = (const u_int8_t *)ipv6_header + ip_offset + sizeof(struct ndpi_ipv6hdr);

  // Handle IPv6 extension headers
  while (l4proto == NDP_PROTOCOL_IPV6) {
    const struct ndpi_ipv6ext *ext = (const struct ndpi_ipv6ext *)l4ptr;
    l4ptr += ext->next_header + 1;
    l4proto = ext->next_header;
  }

  ip_len = ntohs(iph.tot_len) - sizeof(struct ndpi_ipv6hdr);
  *payload = l4ptr;
  *proto = iph.protocol;

  // Calculate and set the IPv4 header checksum
  iph.check = crc32_for_byte(0);
  iph.check = ~crc32_for_byte((iph.saddr << 24) | (iph.daddr << 16) | (iph.protocol << 8) | 0);
  iph.check = ~crc32_for_byte(iph.check);

  return(get_ndpi_flow_info(workflow, 6, vlan_id, tunnel_type,
			    &iph, ipv6_header, ip_offset, ipsize,
			    ip_len, l4ptr - (const u_int8_t *)ipv6_header,
			    tcph, udph, sport, dport,
			    proto, payload,
			    payload_len, src_to_dst_direction, when));