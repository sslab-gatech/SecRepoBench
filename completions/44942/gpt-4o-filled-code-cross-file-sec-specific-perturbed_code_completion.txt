struct ndpi_iphdr iph;
  const u_int8_t *l4ptr;
  u_int8_t l4proto;
  u_int16_t ip_len;

  memset(&iph, 0, sizeof(iph));

  // Extract source and destination addresses from the IPv6 header
  memcpy(&iph.saddr, &ipv6_header->saddr, sizeof(iph.saddr));
  memcpy(&iph.daddr, &ipv6_header->daddr, sizeof(iph.daddr));

  // Retrieve the protocol type and payload length from the IPv6 header
  l4proto = ipv6_header->nexthdr;
  ip_len = ntohs(ipv6_header->payload_len) + sizeof(struct ndpi_ipv6hdr);

  // Determine the pointer to the layer 4 protocol data
  l4ptr = (const u_int8_t *)ipv6_header + sizeof(struct ndpi_ipv6hdr);

  // Handle IPv6 extension headers
  while((l4proto == IPPROTO_HOPOPTS) || (l4proto == IPPROTO_ROUTING) ||
        (l4proto == IPPROTO_FRAGMENT) || (l4proto == IPPROTO_AH) ||
        (l4proto == IPPROTO_DSTOPTS)) {
    struct ndpi_ipv6_opt_hdr *exthdr = (struct ndpi_ipv6_opt_hdr *)l4ptr;
    l4proto = exthdr->nexthdr;
    l4ptr += (exthdr->hdrlen + 1) * 8;
  }

  // Update protocol and payload length
  *proto = l4proto;
  *payload = (u_int8_t *)l4ptr;
  *payload_len = ip_len - (l4ptr - (const u_int8_t *)ipv6_header);