struct ndpi_iphdr iph;
  memset(&iph, 0, sizeof(struct ndpi_iphdr));

  iph.version = ipv6_header->version;
  iph.priority = ipv6_header->traffic_class >> 4;
  iph.flow_label = ipv6_header->flow_label;
  memcpy(iph.src_ip, ipv6_header->src_ip, sizeof(iph.src_ip));
  memcpy(iph.dst_ip, ipv6_header->dst_ip, sizeof(iph.dst_ip));
  iph.payload_len = htons(ipsize);
  iph.next_header = ipv6_header->proto;
  iph.hop_limit = ipv6_header->hop_limit;

  u_int8_t *l4ptr = (u_int8_t *)ipv6_header + ip_offset;
  u_int8_t l4proto = ipv6_header->proto;

  if(tcph != NULL) {
    *tcph = (struct ndpi_tcphdr *)(l4ptr + (ip_offset - (const u_int8_t *)ipv6_header));
    l4proto = (*tcph)->protocol;
  } else if(udph != NULL) {
    *udph = (struct ndpi_udphdr *)(l4ptr + (ip_offset - (const u_int8_t *)ipv6_header));
    l4proto = (*udph)->protocol;
  }

  iph.protocol = l4proto;

  return(get_ndpi_flow_info(workflow, 6, vlan_id, tunnel_type,
			    &iph, ipv6_header, ip_offset, ipsize,
			    ipsize, l4ptr - (const u_int8_t *)ipv6_header,
			    tcph, udph, sport, dport,
			    proto, payload,
			    payload_len, src_to_dst_direction, when));