struct ndpi_ipv4hdr iph;
  const u_int8_t *l4ptr = (const u_int8_t *)ipv6_header + sizeof(struct ndpi_ipv6hdr);
  u_int8_t l4proto = ipv6_header->nexthdr;
  u_int16_t ip_len = ipsize;

  memset(&iph, 0, sizeof(struct ndpi_ipv4hdr));
  memcpy(&iph.saddr, ipv6_header->saddr.s6_addr, 16);
  memcpy(&iph.daddr, ipv6_header->daddr.s6_addr, 16);

  while ((l4proto == IPPROTO_HOPOPTS) || (l4proto == IPPROTO_ROUTING)
	 || (l4proto == IPPROTO_DSTOPTS) || (l4proto == IPPROTO_AH)
         || (l4proto == IPPROTO_FRAGMENT)) {
    struct ndpi_ext_ipv6hdr *exthdr = (struct ndpi_ext_ipv6hdr *)l4ptr;
    if (ipsize < (l4ptr - (const u_int8_t *)ipv6_header) + sizeof(struct ndpi_ext_ipv6hdr)) {
      return NULL;
    }
    l4proto = exthdr->nexthdr;
    ip_len -= (exthdr->len + 1) << 3;
    l4ptr += (exthdr->len + 1) << 3;
    if (ipsize < (l4ptr - (const u_int8_t *)ipv6_header)) {
      return NULL;
    }
  }

  if (l4proto == IPPROTO_NONE) {
    l4proto = ipv6_header->nexthdr;
  }