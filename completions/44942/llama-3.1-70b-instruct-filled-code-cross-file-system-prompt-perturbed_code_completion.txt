// Create an IPv4 header structure and initialize it to zero.
struct ndpi_ipv4hdr iph;
memset(&iph, 0, sizeof(iph));

// Extract source and destination addresses from the IPv6 header
// and assign them to the corresponding fields in the IPv4 header structure.
memcpy(&iph.src, &ipv6_header->saddr, sizeof(iph.src));
memcpy(&iph.dst, &ipv6_header->daddr, sizeof(iph.dst));

// Retrieve the protocol type and payload length from the IPv6 header.
u_int8_t l4proto = ipv6_header->ip6_ctlun.ip6_un1.ip6_un1_nxt;
u_int16_t ip_len = ntohs(ipv6_header->ip6_ctlun.ip6_un1.ip6_un1_flow) & 0x0fff;

// Determine the pointer to the layer 4 protocol data by offsetting
// from the start of the IPv6 header.
const u_int8_t *l4ptr = (const u_int8_t *)ipv6_header + sizeof(*ipv6_header);

// Handle IPv6 extension headers, adjusting the protocol data pointer,
// and update the protocol and payload length accordingly.
while (l4proto == 0 || l4proto == 60 || l4proto == 43) {
  if (l4proto == 0) {
    // Hop-by-Hop Options header
    const struct ndpi_ipv6_hbh *hbh = (const struct ndpi_ipv6_hbh *)l4ptr;
    l4ptr += (hbh->hdrlen + 1) * 8;
    l4proto = hbh->nexthdr;
  } else if (l4proto == 60) {
    // Destination Options header
    const struct ndpi_ipv6_dest *dest = (const struct ndpi_ipv6_dest *)l4ptr;
    l4ptr += (dest->hdrlen + 1) * 8;
    l4proto = dest->nexthdr;
  } else if (l4proto == 43) {
    // Routing header
    const struct ndpi_ipv6_routing *routing = (const struct ndpi_ipv6_routing *)l4ptr;
    l4ptr += (routing->hdrlen + 1) * 8;
    l4proto = routing->nexthdr;
  }
  ip_len -= (l4ptr - (const u_int8_t *)ipv6_header);
}