struct ndpi_iphdr iph = {0};
  u_int8_t l4proto = 0;

  // Extract source and destination addresses from the IPv6 header
  memcpy(&iph.saddr, &ipv6_header->ip6_src, sizeof(iph.saddr));
  memcpy(&iph.daddr, &ipv6_header->ip6_dst, sizeof(iph.daddr));

  // Retrieve the protocol type and payload length from the IPv6 header
  l4proto = ipv6_header->ip6_hdr.ip6_un1_nxt;
  ip_len = ntohs(ipv6_header->ip6_hdr.ip6_un1_plen);

  // Determine the pointer to the layer 4 protocol data by offsetting
  // from the start of the IPv6 header.
  const u_int8_t *l4ptr = (const u_int8_t *)ipv6_header + sizeof(struct ndpi_ipv6hdr);
  u_int16_t ipsize = header->caplen - ip_offset;

  // Handle IPv6 extension headers, adjusting the protocol data pointer,
  // and update the protocol and payload length accordingly.
  if (ndpi_handle_ipv6_extension_headers(ipsize - sizeof(struct ndpi_ipv6hdr), &l4ptr, &ip_len, &l4proto) != 0) {
    return NULL; // Handle error appropriately
  }

  // Set the protocol and payload length for further processing
  *proto = l4proto;
  *payload_len = ip_len;
  *payload = (u_int8_t *)l4ptr;

  return get_ndpi_flow_info(workflow, 6, vlan_id, tunnel_type,
                             &iph, ipv6_header, ip_offset, ipsize,
                             ip_len, l4ptr - (const u_int8_t *)ipv6_header,
                             tcph, udph, sport, dport,
                             proto, payload,
                             payload_len, src_to_dst_direction, when);