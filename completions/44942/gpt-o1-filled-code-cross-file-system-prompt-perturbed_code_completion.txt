struct ndpi_iphdr iph;
  memset(&iph, 0, sizeof(iph));

  /* Extract IPv6 source/destination into the IPv4 header structure (here, we store lower 32 bits) */
  iph.saddr = ntohl(*((const uint32_t *)&ipv6_header->saddr.s6_addr[12]));
  iph.daddr = ntohl(*((const uint32_t *)&ipv6_header->daddr.s6_addr[12]));

  /* Retrieve IPv6 payload length and initial next header */
  u_int16_t ip_len = ntohs(ipv6_header->payload_len) + sizeof(struct ndpi_ipv6hdr);
  u_int8_t l4proto = ipv6_header->nexthdr;

  /* Determine pointer to the layer 4 protocol data */
  const u_int8_t *l4ptr = (const u_int8_t *)ipv6_header + sizeof(struct ndpi_ipv6hdr);

  /* Handle IPv6 extension headers */
  while(l4ptr < (const u_int8_t *)ipv6_header + ip_len) {
    /* Common IPv6 extension header types */
    if(l4proto == IPPROTO_HOPOPTS || l4proto == IPPROTO_ROUTING ||
       l4proto == IPPROTO_DSTOPTS || l4proto == IPPROTO_FRAGMENT) {
      /* Safely parse the extension header */
      if(l4ptr + 2 > (const u_int8_t *)ipv6_header + ip_len) break;
      const struct ndpi_ipv6_exthdr *ext = (const struct ndpi_ipv6_exthdr *)l4ptr;
      l4proto = ext->nexthdr;
      u_int16_t ext_len = (ext->length + 1) * 8;
      if(l4ptr + ext_len > (const u_int8_t *)ipv6_header + ip_len) break;
      l4ptr += ext_len;
    } else {
      break;
    }
  }

  /* Adjust the total length by the extension headers we've traversed */
  ip_len -= (l4ptr - (const u_int8_t *)ipv6_header) - sizeof(struct ndpi_ipv6hdr);