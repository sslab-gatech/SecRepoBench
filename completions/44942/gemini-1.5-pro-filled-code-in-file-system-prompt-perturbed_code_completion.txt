struct ndpi_iphdr iph;

  memset(&iph, 0, sizeof(iph));

  iph.version = 4;
  iph.saddr = ipv6_header->ip6_src.s6_addr32[3];
  iph.daddr = ipv6_header->ip6_dst.s6_addr32[3];
  u_int8_t l4proto = ipv6_header->ip6_nxt;
  u_int16_t ip_len = ntohs(ipv6_header->ip6_plen);
  const u_int8_t *l4ptr = (((const u_int8_t *) ipv6_header) + sizeof(struct ndpi_ipv6hdr));
  u_int16_t ipsize = header->caplen - ip_offset;

  if(ndpi_handle_ipv6_extension_headers(ipsize - sizeof(struct ndpi_ipv6hdr), &l4ptr, &ip_len, &l4proto) != 0) {
    return(NULL);
  }

  if(l4proto == IPPROTO_IPV6
#ifdef IPPROTO_IPIP
     || l4proto == IPPROTO_IPIP
#endif
     ) {
    if(l4ptr > packet) { /* Better safe than sorry */
      ip_offset = (l4ptr - packet);
      goto iph_check;
    }
  }