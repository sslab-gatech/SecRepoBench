struct ndpi_iphdr iph;
memset(&iph, 0, sizeof(iph));
memcpy(&iph.saddr, &ipv6_header->saddr, sizeof(iph.saddr));
memcpy(&iph.daddr, &ipv6_header->daddr, sizeof(iph.daddr));

u_int8_t l4proto = ipv6_header->nexthdr;
const u_int8_t *l4ptr = (const u_int8_t *)ipv6_header + sizeof(struct ndpi_ipv6hdr);
u_int16_t ip_len = sizeof(struct ndpi_ipv6hdr);

while(1) {
    if(!(l4proto == NDPI_IPV6_HOP_BY_HOP_HEADER ||
         l4proto == NDPI_IPV6_ROUTE_HEADER ||
         l4proto == NDPI_IPV6_FRAGMENT_HEADER ||
         l4proto == NDPI_IPV6_DESTINATION_OPTIONS ||
         l4proto == NDPI_IPV6_MOBILITY_HEADER))
        break;

    u_int16_t current_offset = l4ptr - (const u_int8_t *)ipv6_header;
    if(current_offset + 8 > ipsize) break;

    u_int8_t next_proto = l4ptr[0];
    u_int8_t hdr_len = l4ptr[1];
    u_int16_t total_hdr_len = (hdr_len + 1) * 8;

    if(current_offset + total_hdr_len > ipsize) break;

    ip_len += total_hdr_len;
    l4ptr += total_hdr_len;
    l4proto = next_proto;
}