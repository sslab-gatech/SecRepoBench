if(l4_offset > ipsize)
  return NULL;

l3 = (const u_int8_t*)iph6;
proto = iph6->ip6_hdr.ip6_un1_nxt;
ip_len = ntohs(iph6->ip6_hdr.ip6_un1_plen);

if(header->caplen < (ip_offset + sizeof(struct ndpi_ipv6hdr) + ntohs(iph6->ip6_hdr.ip6_un1_plen)))
  return NULL; /* Too short for IPv6 payload*/

const u_int8_t *l4ptr = (((const u_int8_t *) iph6) + sizeof(struct ndpi_ipv6hdr));
u_int16_t ipsize = header->caplen - ip_offset;

if(ndpi_handle_ipv6_extension_headers(ipsize - sizeof(struct ndpi_ipv6hdr), &l4ptr, &ip_len, &proto) != 0) {
  return NULL;
}

if(proto == IPPROTO_IPV6
#ifdef IPPROTO_IPIP
   || proto == IPPROTO_IPIP
#endif
   ) {
  if(l4ptr > packet) { /* Better safe than sorry */
    ip_offset = (l4ptr - packet);
    goto iph_check;
  }
}

iph = NULL;