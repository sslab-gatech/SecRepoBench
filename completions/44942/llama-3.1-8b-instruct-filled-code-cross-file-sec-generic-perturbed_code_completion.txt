// <MASK>
// Determine the protocol type and payload length from the IPv6 header.
// Retrieve the protocol type and payload length from the IPv6 header.
iph.protocol = ipv6_header->next_header;
iph.ihl = 5; // IPv6 header length is always 40 bytes
iph.tot_len = ipv6_header->payload_length;
iph.check = 0; // Initialize checksum to zero

// Determine the protocol type and payload length from the IPv6 header.
l4proto = ipv6_header->next_header;
l4ptr = (const u_int8_t *)ipv6_header + ipv6_header->payload_length;

// Handle IPv6 extension headers, adjusting the protocol data pointer,
// and update the protocol and payload length accordingly.
while (l4proto == IPPROTO_HOPOPTS || l4proto == IPPROTO_ROUTING || l4proto == IPPROTO_FRAGMENT) {
  switch (l4proto) {
    case IPPROTO_HOPOPTS:
      l4ptr += 8; // Hop-by-Hop Options header is 8 bytes long
      break;
    case IPPROTO_ROUTING:
      l4ptr += 8; // Routing header is 8 bytes long
      break;
    case IPPROTO_FRAGMENT:
      l4ptr += 4; // Fragment header is 4 bytes long
      break;
  }
  l4proto = *(u_int8_t *)l4ptr;
}

// Update the protocol and payload length accordingly.
iph.protocol = l4proto;
iph.tot_len = ipv6_header->payload_length + (l4ptr - (const u_int8_t *)ipv6_header);
iph.check = 0; // Initialize checksum to zero