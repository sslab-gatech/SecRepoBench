struct ndpi_ipv4hdr iph;
  const u_int8_t *l4ptr = (const u_int8_t *)ipv6_header + ip_offset;
  u_int8_t l4proto = ipv6_header->nexthdr;
  u_int16_t ip_len = ipsize;

  memset(&iph, 0, sizeof(iph));
  iph.version = 4;
  iph.ihl = 5;
  iph.tos = ipv6_header->priority;

  memcpy(&iph.saddr, &ipv6_header->saddr.s6_addr, 16);
  memcpy(&iph.daddr, &ipv6_header->daddr.s6_addr, 16);

  while(l4proto != IPPROTO_TCP && l4proto != IPPROTO_UDP &&
        l4proto != IPPROTO_SCTP && ip_len > 0) {

    if(ip_offset + sizeof(struct ndpi_ipv6hdr) >= ipsize) {
      return NULL;
    }

    switch(l4proto) {
    case IPPROTO_HOPOPTS:
    case IPPROTO_ROUTING:
    case IPPROTO_DSTOPTS:
      {
	const struct ndpi_ipv6_exthdr *exthdr = (struct ndpi_ipv6_exthdr *)l4ptr;
	if(ip_offset + sizeof(struct ndpi_ipv6_exthdr) > ipsize)
	  return NULL;
	l4proto = exthdr->nexthdr;
	ip_offset += (exthdr->len + 1) << 3;
	l4ptr += (exthdr->len + 1) << 3;
	ip_len -= (exthdr->len + 1) << 3;
      }
      break;

    case IPPROTO_FRAGMENT:
      {
	const struct ndpi_ipv6_frag_hdr *frag = (struct ndpi_ipv6_frag_hdr *)l4ptr;

	if(ip_offset + sizeof(struct ndpi_ipv6_frag_hdr) > ipsize)
	  return NULL;

	l4proto = frag->nexthdr;
	ip_offset += sizeof(struct ndpi_ipv6_frag_hdr);
	l4ptr += sizeof(struct ndpi_ipv6_frag_hdr);
	ip_len -= sizeof(struct ndpi_ipv6_frag_hdr);
      }
      break;

      /* We do not support AH/ESP extension headers */
    case IPPROTO_AH:
    case IPPROTO_ESP:
    default:
      return NULL;
    }

    if(l4ptr - (const u_int8_t *)ipv6_header + sizeof(struct ndpi_ipv6hdr) > ipsize)
      return NULL;
  }