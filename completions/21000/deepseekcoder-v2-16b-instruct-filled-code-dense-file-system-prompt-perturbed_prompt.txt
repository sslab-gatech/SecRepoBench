Below is the content of a C/C++ function where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
static void ndpi_search_setup_capwap(struct ndpi_detection_module_struct *ndpi_struct,
				     struct ndpi_flow_struct *flow) {
  struct ndpi_packet_struct *flow_packet = &flow->packet;
  u_int16_t sport, dport;
   
  if(!flow_packet->iph) {
    NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
    return;
  }

  sport = ntohs(flow_packet->udp->source), dport = ntohs(flow_packet->udp->dest);
  
  if((dport == NDPI_CAPWAP_CONTROL_PORT)
     && (flow_packet->iph->daddr == 0xFFFFFFFF)
     && (flow_packet->payload_packet_len >= 16)
     && (flow_packet->payload[0] == 0x0)
     && (flow_packet->payload[8] == 6 /* Mac len */)
     )
    goto capwap_found;
  
  if(((sport == NDPI_CAPWAP_CONTROL_PORT) || (dport == NDPI_CAPWAP_CONTROL_PORT))
     && ((flow_packet->payload[0] == 0x0) || (flow_packet->payload[0] == 0x1))
     ) 
     // Check if the CAPWAP control port is used in the source or destination,
     // and if the first byte of the payload is 0x0 or 0x1.
     // Calculate a message length from the payload using an offset and an additional length,
     // depending on the first byte of the payload.
     // Compare the calculated total length with the actual payload packet length.
     // If they match, jump to the code block that handles a successful CAPWAP detection.
     // <MASK>
  
  if(
     (((dport == NDPI_CAPWAP_DATA_PORT) && (flow_packet->iph->daddr != 0xFFFFFFFF)) || (sport == NDPI_CAPWAP_DATA_PORT))
     && (flow_packet->payload_packet_len >= 16)
     && (flow_packet->payload[0] == 0x0)
     ) {
    u_int8_t is_80211_data = (flow_packet->payload[9] & 0x0C) >> 2;

      
    if((sport == NDPI_CAPWAP_DATA_PORT) && (is_80211_data == 2 /* IEEE 802.11 Data */))
      goto capwap_found;
    else if(dport == NDPI_CAPWAP_DATA_PORT) {
      u_int16_t msg_len = ntohs(*(u_int16_t*)&flow_packet->payload[13]);
      
      if((flow_packet->payload[8] == 1 /* Mac len */)
	 || (flow_packet->payload[8] == 6 /* Mac len */)
	 || (flow_packet->payload[8] == 4 /* Wireless len */)
	 || ((msg_len+15) == flow_packet->payload_packet_len))
	goto capwap_found;	 
    }
  }
  
  NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
  return;

 capwap_found:
  ndpi_int_capwap_add_connection(ndpi_struct, flow);
}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/lib/protocols/capwap.c
void ndpi_search_capwap(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow)
{
  struct ndpi_packet_struct *packet = &flow->packet;

  if(packet->udp && (packet->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN))
    ndpi_search_setup_capwap(ndpi_struct, flow);
}

// the below code fragment can be found in:
// src/lib/protocols/capwap.c
static void ndpi_int_capwap_add_connection(struct ndpi_detection_module_struct *ndpi_struct,
					   struct ndpi_flow_struct *flow) {
  ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_CAPWAP, NDPI_PROTOCOL_UNKNOWN);
}

// the below code fragment can be found in:
// src/lib/protocols/capwap.c
void init_capwap_dissector(struct ndpi_detection_module_struct *ndpi_struct,
			   u_int32_t *id, NDPI_PROTOCOL_BITMASK *detection_bitmask)
{
  ndpi_set_bitmask_protocol_detection("CAPWAP", ndpi_struct, detection_bitmask, *id,
				      NDPI_PROTOCOL_CAPWAP,
				      ndpi_search_capwap,
				      NDPI_SELECTION_BITMASK_PROTOCOL_UDP_WITH_PAYLOAD,
				      SAVE_DETECTION_BITMASK_AS_UNKNOWN,
				      ADD_TO_DETECTION_BITMASK);

  *id += 1;
}

// the below code fragment can be found in:
// src/lib/protocols/coap.c
void ndpi_search_coap (struct ndpi_detection_module_struct *ndpi_struct,
		       struct ndpi_flow_struct *flow)
{
  struct ndpi_packet_struct *packet = &flow->packet;
  struct ndpi_coap_hdr * h = (struct ndpi_coap_hdr*) packet->payload;

  if(packet->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN) {
    return;
  }

  // search for udp packet
  if(packet->udp != NULL) {
    u_int16_t s_port = ntohs(flow->packet.udp->source);
    u_int16_t d_port = ntohs(flow->packet.udp->dest);

    if((!isCoAPport(s_port) && !isCoAPport(d_port))
       || (packet->payload_packet_len < 4) ) {   // header too short
      NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
      return;
    }

    NDPI_LOG_DBG2(ndpi_struct, "calculating coap over udp\n");

    // check values in header
    if(h->version == 1) {
      if(h->type == CON || h->type == NO_CON || h->type == ACK || h->type == RST ) {
	if(h->tkl < 8) {
	  if((/* h->code >= 0 && */ h->code <= 5) || (h->code >= 65 && h->code <= 69) ||
	     (h->code >= 128  && h->code <= 134) || (h->code >= 140 && h->code <= 143) ||
	     (h->code >= 160 && h->code <= 165)) {

	    NDPI_LOG_INFO(ndpi_struct, "found Coap\n");
	    ndpi_int_coap_add_connection(ndpi_struct,flow);
	    return;
	  }
	}
      }
    }
  }

  NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
  return;
}

// the below code fragment can be found in:
// src/lib/protocols/rdp.c
void ndpi_search_rdp(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow)
{
  struct ndpi_packet_struct *packet = &flow->packet;
	
  NDPI_LOG_DBG(ndpi_struct, "search RDP\n");

  if (packet->payload_packet_len > 10
      && get_u_int8_t(packet->payload, 0) > 0
      && get_u_int8_t(packet->payload, 0) < 4 && get_u_int16_t(packet->payload, 2) == ntohs(packet->payload_packet_len)
      && get_u_int8_t(packet->payload, 4) == packet->payload_packet_len - 5
      && get_u_int8_t(packet->payload, 5) == 0xe0
      && get_u_int16_t(packet->payload, 6) == 0 && get_u_int16_t(packet->payload, 8) == 0 && get_u_int8_t(packet->payload, 10) == 0) {
    NDPI_LOG_INFO(ndpi_struct, "found RDP\n");
    ndpi_int_rdp_add_connection(ndpi_struct, flow);
    return;
  }

  NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
}
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).