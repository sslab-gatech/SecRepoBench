rb_value body = regs[a+1];
      mrb_value ret;
      int ai = mrb_gc_arena_save(mrb);
      mrb_bool error = FALSE;

      ret = mrb_protect_error(mrb, body, exc, &error);
      mrb_gc_arena_restore(mrb, ai);
      if (error) {
        regs[a] = exc;
      }
      else {
        regs[a] = ret;
      }
      NEXT;
    }

    CASE(OP_ENSURE, B) {
      mrb_value body = regs[a];
      mrb_value ret;
      int ai = mrb_gc_arena_save(mrb);
      mrb_bool error = FALSE;

      ret = mrb_protect_error(mrb, body, mrb_nil_value(), &error);
      mrb_gc_arena_restore(mrb, ai);
      if (error) {
        regs[a] = mrb_nil_value();
      }
      else {
        regs[a] = ret;
      }
      NEXT;
    }

    CASE(OP_RAISE, B) {
      mrb_value exc = regs[a];

      if (mrb->exc == NULL) {
        mrb->exc = exc;
      }
      else {
        mrb_exc_raise(mrb, exc);
      }
      goto L_RAISE;
    }

    CASE(OP_RETRY, B) {
      if (mrb->exc) {
        mrb_exc_raise(mrb, mrb->exc);
      }
      goto RETRY_TRY_BLOCK;
    }

    CASE(OP_YIELD, B) {
      mrb_value blk = regs[a];
      mrb_value args = regs[a+1];
      mrb_value ret;
      int ai = mrb_gc_arena_save(mrb);

      if (mrb_nil_p(blk)) {
        localjump_error(mrb, LOCALJUMP_ERROR_YIELD);
      }
      ret = mrb_yield_with_class(mrb, blk, RARRAY_LEN(args), RARRAY_PTR(args), regs[0], check_target_class(mrb));
      mrb_gc_arena_restore(mrb, ai);
      regs[a] = ret;
      NEXT;
    }

    CASE(OP_BREAK, B) {
      uint32_t tag = (uint32_t)a;
      mrb_value val = regs[0];

      if (mrb->exc == NULL) {
        mrb->exc = (struct RObject*)break_new(mrb, tag, proc, val);
      }
      else {
        mrb_break_tag_set((struct RBreak*)mrb->exc, tag);
      }
      goto L_CATCH_TAGGED_BREAK;
    }

    CASE(OP_RESCUE_EX, B) {
      mrb_value exc = regs[a];
      mrb_value body = regs[a+1];
      mrb_value ret;
      int ai = mrb_gc_arena_save(mrb);
      mrb_bool error = FALSE;

      ret = mrb_protect_error(mrb, body, exc, &error);
      mrb_gc_arena_restore(mrb, ai);
      if (error) {
        regs[a] = exc;
      }
      else {
        regs[a] = ret;
      }
      NEXT;
    }

    CASE(OP_ENSURE_EX, B) {
      mrb_value body = regs[a];
      mrb_value ret;
      int ai = mrb_gc_arena_save(mrb);
      mrb_bool error = FALSE;

      ret = mrb_protect_error(mrb, body, mrb_nil_value(), &error);
      mrb_gc_arena_restore(mrb, ai);
      if (error) {
        regs[a] = mrb_nil_value();
      }
      else {
        regs[a] = ret;
      }
      NEXT;
    }

    CASE(OP_RETHROW, B) {
      mrb_value exc = regs[a];

      if (mrb->exc == NULL) {
        mrb->exc = exc;
      }
      else {
        mrb_exc_raise(mrb, exc);
      }
      goto L_RAISE;
    }

    CASE(OP_RETRY_EX, B) {
      if (mrb->exc) {
        mrb_exc_raise(mrb, mrb->exc);
      }
      goto RETRY_TRY_BLOCK;
    }

    CASE(OP_CHECKPOINT, S) {
      uint32_t tag = (uint32_t)a;
      CHECKPOINT_RESTORE(tag) {
        mrb_value val = regs[0];
        mrb_value blk = regs[1];
        mrb_value ret;
        int ai = mrb_gc_arena_save(mrb);

        if (mrb_nil_p(blk)) {
          localjump_error(mrb, LOCALJUMP_ERROR_BREAK);
        }
        ret = mrb_yield_with_class(mrb, blk, 1, &val, regs[0], check_target_class(mrb));
        mrb_gc_arena_restore(mrb, ai);
        regs[0] = ret;
      }
      CHECKPOINT_MAIN(tag) {
        regs[0] = regs[1];
        regs[1] = regs[2];
      }
      CHECKPOINT_END(tag);
      NEXT;
    }

    CASE(OP_CATCH, B) {
      uint32_t tag = (uint32_t)a;
      mrb_value val = regs[0];
      mrb_value blk = regs[1];
      mrb_value ret;
      int ai = mrb_gc_arena_save(mrb);

      if (mrb_nil_p(blk)) {
        localjump_error(mrb, LOCALJUMP_ERROR_BREAK);
      }
      ret = mrb_yield_with_class(mrb, blk, 1, &val, regs[0], check_target_class(mrb));
      mrb_gc_arena_restore(mrb, ai);
      regs[0] = ret;
      goto L_CATCH_TAGGED_BREAK;
    }

    CASE(OP_RESCUE_JMP, B) {
      mrb_value exc = regs[a];
      mrb_value body = regs[a+1];
      mrb_value ret;
      int ai = mrb_gc_arena_save(mrb);
      mrb_bool error = FALSE;

      ret = mrb_protect_error(mrb, body, exc, &error);
      mrb_gc_arena_restore(mrb, ai);
      if (error) {
        regs[a] = exc;
      }
      else {
        regs[a] = ret;
      }
      goto L_CATCH_TAGGED_BREAK;
    }

    CASE(OP_ENSURE_JMP, B) {
      mrb_value body = regs[a];
      mrb_value ret;
      int ai = mrb_gc_arena_save(mrb);
      mrb_bool error = FALSE;

      ret = mrb_protect_error(mrb, body, mrb_nil_value(), &error);
      mrb_gc_arena_restore(mrb, ai);
      if (error) {
        regs[a] = mrb_nil_value();
      }
      else {
        regs[a] = ret;
      }
      goto L_CATCH_TAGGED_BREAK;
    }

    CASE(OP_RETHROW_JMP, B) {
      mrb_value exc = regs[a];

      if (mrb->exc == NULL) {
        mrb->exc = exc;
      }
      else {
        mrb_exc_raise(mrb, exc);
      }
      goto L_CATCH_TAGGED_BREAK;
    }

    CASE(OP_RETRY_JMP, B) {
      if (mrb->exc) {
        mrb_exc_raise(mrb, mrb->exc);
      }
      goto RETRY_TRY_BLOCK;
    }

    CASE(OP_RESCUE_YIELD, B) {
      mrb_value exc = regs[a];
      mrb_value body = regs[a+1];
      mrb_value ret;
      int ai = mrb_gc_arena_save(mrb);
      mrb_bool error = FALSE;

      ret = mrb_protect_error(mrb, body, exc, &error);
      mrb_gc_arena_restore(mrb, ai);
      if (error) {
        regs[a] = exc;
      }
      else {
        regs[a] = ret;
      }
      goto L_CATCH_TAGGED_BREAK;
    }

    CASE(OP_ENSURE_YIELD, B) {
      mrb_value body = regs[a];
      mrb_value ret;
      int ai = mrb_gc_arena_save(mrb);
      mrb_bool error = FALSE;

      ret = mrb_protect_error(mrb, body, mrb_nil_value(), &error);
      mrb_gc_arena_restore(mrb, ai);
      if (error) {
        regs[a] = mrb_nil_value();
      }
      else {
        regs[a] = ret;
      }
      goto L_CATCH_TAGGED_BREAK;
    }

    CASE(OP_RETHROW_YIELD, B) {
      mrb_value exc = regs[a];

      if (mrb->exc == NULL) {
        mrb->exc = exc;
      }
      else {
        mrb_exc_raise(mrb, exc);
      }
      goto L_CATCH_TAGGED_BREAK;
    }

    CASE(OP_RETRY_YIELD, B) {
      if (mrb->exc) {
        mrb_exc_raise(mrb, mrb->exc);
      }
      goto RETRY_TRY_BLOCK;
    }

    CASE(OP_CALL, BB) {
      mrb_value recv = regs[a];
      mrb_sym mid = (mrb_sym)b;
      mrb_int argc = c;
      mrb_value blk = regs[a+1];
      mrb_value args;
      mrb_value val;
      int ai = mrb_gc_arena_save(mrb);

      if (argc > CALL_MAXARGS) {
        mrb_raise(mrb, E_ARGUMENT_ERROR, "Too long arguments. (limit=" MRB_STRINGIZE(CALL_MAXARGS) ")");
      }
      if (argc == 15) {
        args = regs[a+2];
      }
      else {
        args = mrb_ary_new_from_values(mrb, argc, regs+a+2);
      }
      if (blk) {
        val = mrb_funcall_with_block(mrb, recv, mid, argc, args, blk);
      }
      else {
        val = mrb_funcall_argv(mrb, recv, mid, argc, args);
      }
      mrb_gc_arena_restore(mrb, ai);
      regs[a] = val;
      NEXT;
    }

    CASE(OP_CALL_KW, BB) {
      mrb_value recv = regs[a];
      mrb_sym mid = (mrb_sym)b;
      mrb_int argc = c;
      mrb_value blk = regs[a+1];
      mrb_value args;
      mrb_value val;
      int ai = mrb_gc_arena_save(mrb);

      if (argc > CALL_MAXARGS) {
        mrb_raise(m