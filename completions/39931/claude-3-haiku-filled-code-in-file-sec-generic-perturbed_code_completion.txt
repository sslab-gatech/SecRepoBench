if (argc < 0) {
  argnum_error(mrb, argc);
  goto L_RAISE;
}

m = mrb_method_search_vm(mrb, &cls, mid);
if (MRB_METHOD_UNDEF_P(m)) {
  if (insn == OP_SEND) {
    m = prepare_missing(mrb, recv, mid, &cls, a, &c, blk, 0);
    mid = MRB_SYM(method_missing);
  }
  else {
    m = prepare_missing(mrb, recv, mid, &cls, a, &c, blk, 1);
    mid = MRB_SYM(method_missing);
  }
}

if (MRB_METHOD_CFUNC_P(m)) {
  if (MRB_METHOD_PROC_P(m)) {
    mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));
  }
  if (MRB_METHOD_NOARG_P(m) && !(n == 0 || (n == CALL_MAXARGS && RARRAY_LEN(regs[1]) == 0))) {
    argnum_error(mrb, 0);
    goto L_RAISE;
  }
  recv = MRB_METHOD_FUNC(m)(mrb, recv);
  mrb_gc_arena_shrink(mrb, ai);
  if (mrb->exc) goto L_RAISE;
  ci = mrb->c->ci;
  if (mrb_proc_p(blk)) {
    struct RProc *p = mrb_proc_ptr(blk);
    if (p && !MRB_PROC_STRICT_P(p) && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {
      p->flags |= MRB_PROC_ORPHAN;
    }
  }
  if (!ci->u.target_class) { /* return from context modifying method (resume/yield) */
    if (ci->cci == CINFO_RESUMED) {
      mrb->jmp = prev_jmp;
      return recv;
    }
    else {
      mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));
      proc = ci[-1].proc;
      irep = proc->body.irep;
      pool = irep->pool;
      syms = irep->syms;
    }
  }
  ci->stack[0] = recv;
  ci = cipop(mrb);
  pc = ci->pc;
}
else {
  mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));
  irep = proc->body.irep;
  pool = irep->pool;
  syms = irep->syms;
  mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);
  pc = irep->iseq;
}