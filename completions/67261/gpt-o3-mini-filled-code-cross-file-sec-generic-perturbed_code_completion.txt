u32 res_size = buffer_length;
u8 *dst = NULL;
const u8 *ptr = data;

/* Check for UTF-8 BOM */
if (buffer_length >= 3 && data[0] == 0xEF && data[1] == 0xBB && data[2] == 0xBF) {
    ptr = data + 3;
    res_size -= 3;
}
/* Check for UTF-16 Little Endian BOM */
else if (buffer_length >= 2 && data[0] == 0xFF && data[1] == 0xFE) {
    /* Convert from UTF-16LE to UTF-8 using a helper function;
       assume gf_utf16le_to_utf8 performs proper conversion and allocation */
    dst = gf_utf16le_to_utf8((const u16 *)data, buffer_length / 2, &res_size);
    if (!dst)
        return NULL;
    ptr = dst;
}
/* Check for UTF-16 Big Endian BOM */
else if (buffer_length >= 2 && data[0] == 0xFE && data[1] == 0xFF) {
    /* Convert from UTF-16BE to UTF-8 using a helper function */
    dst = gf_utf16be_to_utf8((const u16 *)data, buffer_length / 2, &res_size);
    if (!dst)
        return NULL;
    ptr = dst;
}

/* Strip leading whitespace characters (space, newline, carriage return, tab) */
while (res_size && (*ptr == ' ' || *ptr == '\n' || *ptr == '\r' || *ptr == '\t')) {
    ptr++;
    res_size--;
}

/* Update data pointer to point to the processed text */
data = ptr;