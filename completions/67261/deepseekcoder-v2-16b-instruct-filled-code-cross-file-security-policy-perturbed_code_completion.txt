// Initialize variables for processing the data buffer and storing results.
	// Convert the input data into a UTF string using its byte order mark (BOM).
	// Assign pointers to the processed data and allocate memory as needed.
	// Strip leading whitespace characters, including spaces, newlines, and tabs, from the processed data.
	// Define a macro to facilitate returning a MIME type and freeing allocated memory when a format is identified.

#define PROBE_OK(score, mime) \
	do { \
		if (dst) gf_free(dst); \
		dst = gf_strdup(mime); \
		if (score > GF_FPROBE_UNSUPPORTED) { \
			*score = (GF_FilterProbeScore) score; \
			return dst; \
		} \
	} while (0)

	if (!strncmp(data, "WEBVTT", 6)) {
		PROBE_OK(GF_FPROBE_SUPPORTED, "subtitle/vtt")
	}
	if (gf_strmemstr(data, res_size, " --> ")) {
		PROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, "subtitle/srt")
	}
	if (!strncmp(data, "FWS", 3) || !strncmp(data, "CWS", 3)) {
		PROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, "application/x-shockwave-flash")
	}
	if (!strncmp(data, "[Script Info", 12)) {
		PROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, "subtitle/ssa")
	}

	if ((data[0]=='{') && gf_strmemstr(data, res_size, "}{")) {
		PROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, "subtitle/sub")
	}
	/*XML formats*/
	if (!gf_strmemstr(data, res_size, "?>") ) {
		if (dst) gf_free(dst);
		return NULL;
	}

	if (gf_strmemstr(data, res_size, "<x-quicktime-tx3g") || gf_strmemstr(data, res_size, "<text3GTrack")) {
		PROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, "quicktime/text")
	}
	if (gf_strmemstr(data, res_size, "TextStream")) {
		PROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, "subtitle/ttxt")
	}
	if (gf_strmemstr(data, res_size, "<tt ") || gf_strmemstr(data, res_size, ":tt ")) {
		PROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, "subtitle/ttml")
	}

	if (dst) gf_free(dst);
	return NULL;