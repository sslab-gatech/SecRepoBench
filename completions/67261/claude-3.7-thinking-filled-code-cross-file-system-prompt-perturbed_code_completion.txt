u32 res_size = buffer_length;
u8 *dst = NULL;
const char *res = (const char *)data;

if ((buffer_length>=2) && (data[0]==0xFF) && (data[1]==0xFE)) {
    // UTF-16 LE BOM
    dst = gf_utf16_to_utf8((const u16 *)&data[2], (buffer_length-2)/2);
    if (dst) res = (const char *)dst;
    res_size = (u32)strlen(res);
} else if ((buffer_length>=2) && (data[0]==0xFE) && (data[1]==0xFF)) {
    // UTF-16 BE BOM
    u32 i, j;
    u16 *data16 = (u16 *)gf_malloc(sizeof(u16)*((buffer_length-2)/2 + 1));
    if (!data16) {
        return NULL;
    }
    for (i=1, j=0; i<buffer_length/2; i++, j++) {
        data16[j] = GF_WORD_SWAP(((u16 *)data)[i]);
    }
    data16[j] = 0;
    dst = gf_utf16_to_utf8(data16, j);
    gf_free(data16);
    if (dst) res = (const char *)dst;
    res_size = (u32)strlen(res);
} else if ((buffer_length>=3) && (data[0]==0xEF) && (data[1]==0xBB) && (data[2]==0xBF)) {
    // UTF-8 BOM
    res = (const char *)&data[3];
    res_size = buffer_length-3;
}

// Skip leading whitespace
while (res_size && (
    (res[0] == ' ') || 
    (res[0] == '\t') || 
    (res[0] == '\n') || 
    (res[0] == '\r')
)) {
    res++;
    res_size--;
}

// Define helper macro to return MIME type and cleanup
#define PROBE_OK(_score, _mime) \
    if (dst) gf_free(dst); \
    *score = _score; \
    return _mime;