u8 *dst = NULL;
u32 res_size = 0;

// Check if the data starts with a byte order mark (BOM) for UTF-16 or UTF-32
if (data[0] == 0xef && data[1] == 0xbb && data[2] == 0xbf) {
    // UTF-8 BOM, no conversion needed
    dst = (u8 *) data;
    res_size = buffer_length;
} else if (data[0] == 0xfe && data[1] == 0xff) {
    // UTF-16 BE BOM
    dst = gf_malloc(buffer_length);
    res_size = buffer_length / 2;
    for (u32 i = 0; i < res_size; i++) {
        dst[i * 2] = data[i * 2 + 1];
        dst[i * 2 + 1] = data[i * 2];
    }
} else if (data[0] == 0xff && data[1] == 0xfe) {
    // UTF-16 LE BOM
    dst = gf_malloc(buffer_length);
    res_size = buffer_length / 2;
    memcpy(dst, data + 2, buffer_length - 2);
} else if (data[0] == 0x00 && data[1] == 0x00 && data[2] == 0xfe && data[3] == 0xff) {
    // UTF-32 BE BOM
    dst = gf_malloc(buffer_length);
    res_size = buffer_length / 4;
    for (u32 i = 0; i < res_size; i++) {
        dst[i * 4] = data[i * 4 + 3];
        dst[i * 4 + 1] = data[i * 4 + 2];
        dst[i * 4 + 2] = data[i * 4 + 1];
        dst[i * 4 + 3] = data[i * 4];
    }
} else if (data[0] == 0xff && data[1] == 0xfe && data[2] == 0x00 && data[3] == 0x00) {
    // UTF-32 LE BOM
    dst = gf_malloc(buffer_length);
    res_size = buffer_length / 4;
    memcpy(dst, data + 4, buffer_length - 4);
}

// If no BOM is found, assume it's a single byte character set
if (!dst) {
    dst = gf_malloc(buffer_length + 1);
    res_size = buffer_length;
    memcpy(dst, data, buffer_length);
    dst[buffer_length] = 0;
}

// Strip leading whitespace characters
while (res_size > 0 && (dst[0] == ' ' || dst[0] == '\n' || dst[0] == '\t')) {
    memmove(dst, dst + 1, res_size - 1);
    res_size--;
}

#define PROBE_OK(score, mime) do { \
    if (dst) gf_free(dst); \
    score->score = GF_FPROBE_SUPPORTED; \
    score->mime = gf_strdup(mime); \
    return dst; \
} while (0)