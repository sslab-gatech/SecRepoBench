u8 bom[4] = {0};
	u32 bom_size = buffer_length < 4 ? buffer_length : 4;
	u32 res_size = buffer_length;
	char *dst = NULL;

	memcpy(bom, data, bom_size);

	if (bom[0] == 0xEF && bom[1] == 0xBB && bom[2] == 0xBF) {
		/* UTF-8 */
		dst = gf_strdup((char*)data);
		res_size = buffer_length;
	} else if (bom[0] == 0xFE && bom[1] == 0xFF) {
		/* UTF-16 Big Endian */
		dst = gf_utf16be_to_utf8((u16*)data, buffer_length/2, &res_size);
	} else if (bom[0] == 0xFF && bom[1] == 0xFE) {
		/* UTF-16 Little Endian */
		dst = gf_utf16le_to_utf8((u16*)data, buffer_length/2, &res_size);
	} else if (bom[0] == 0x00 && bom[1] == 0x00 && bom[2] == 0xFE && bom[3] == 0xFF) {
		/* UTF-32 Big Endian */
		//Not supported, don't convert
	} else if (bom[0] == 0xFF && bom[1] == 0xFE && bom[2] == 0x00 && bom[3] == 0x00) {
		/* UTF-32 Little Endian */
		//Not supported, don't convert
	} else {
		/* Assuming UTF-8 or ASCII */
		dst = gf_strdup((char*)data);
		res_size = buffer_length;
	}

	if (dst) {
		char *ptr = dst;
		while (*ptr == ' ' || *ptr == '\n' || *ptr == '\r' || *ptr == '\t') {
			ptr++;
			res_size--;
		}
		dst = ptr;
	} else {
		/* If dst is NULL, then we didn't convert, so use original data */
		dst = (char*)data;
	}

#define PROBE_OK(score_val, mime_type) \
{ \
	if (score) score->score = score_val; \
	if (dst && (dst != (char*)data)) gf_free(dst); \
	return mime_type; \
}