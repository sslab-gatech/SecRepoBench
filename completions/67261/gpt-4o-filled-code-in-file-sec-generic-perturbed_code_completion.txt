// Initialize variables for processing the data buffer and storing results.
u32 read;
unsigned char BOM[5];
char *dst = NULL;
u32 res_size = buffer_length;

// Convert the input data into a UTF string using its byte order mark (BOM).
read = (u32) gf_fread(BOM, 5, (FILE *)data);
if ((s32) read < 1) {
    return NULL;
}

if ((BOM[0] == 0xFF) && (BOM[1] == 0xFE)) {
    // UTF32 not supported
    if (!BOM[2] && !BOM[3]) {
        return NULL;
    }
    dst = (char *)data + 2;
    res_size -= 2;
} else if ((BOM[0] == 0xFE) && (BOM[1] == 0xFF)) {
    // UTF32 not supported
    if (!BOM[2] && !BOM[3]) {
        return NULL;
    }
    dst = (char *)data + 2;
    res_size -= 2;
} else if ((BOM[0] == 0xEF) && (BOM[1] == 0xBB) && (BOM[2] == 0xBF)) {
    dst = (char *)data + 3;
    res_size -= 3;
} else {
    dst = (char *)data;
}

// Assign pointers to the processed data and allocate memory as needed.
if (!dst) {
    dst = (char *)gf_malloc(sizeof(char) * (res_size + 1));
    if (!dst) {
        return NULL;
    }
    memcpy(dst, data, res_size);
    dst[res_size] = 0;
}

// Strip leading whitespace characters, including spaces, newlines, and tabs, from the processed data.
while (dst[0] && strchr("\n\r\t ", (char)dst[0])) {
    dst++;
}

// Define a macro to facilitate returning a MIME type and freeing allocated memory when a format is identified.
#define PROBE_OK(_score, _mime) \
    { \
        *score = _score; \
        if (dst) gf_free(dst); \
        return _mime; \
    }