const unsigned char *utf_bom = data;
char *dst = NULL;
u32 res_size = buffer_length;
u32 offset = 0;

// Check for valid buffer length
if (!buffer_length) return NULL;

//skip UTF-8 BOM if any
if ((buffer_length >= 3) && (utf_bom[0] == 0xEF) && (utf_bom[1] == 0xBB) && (utf_bom[2] == 0xBF)) {
    offset = 3;
    data += offset;
    res_size = buffer_length - offset;
}
//skip UTF-16 LE BOM if any
else if ((buffer_length >= 2) && (utf_bom[0] == 0xFF) && (utf_bom[1] == 0xFE)) {
    // Ensure we have an even number of bytes after BOM for UTF-16
    u32 len = (buffer_length - 2) / 2;
    if (!len) return NULL;
    
    // Allocate memory for converted string
    dst = (char *) gf_malloc(sizeof(char) * (len + 1));
    if (!dst) return NULL;
    
    // Extract the lower byte of each UTF-16 character (little-endian)
    for (u32 i = 0; i < len; i++) {
        u32 idx = 2 + 2*i;
        if (idx + 1 >= buffer_length) {
            gf_free(dst);
            return NULL;
        }
        dst[i] = (char) utf_bom[idx]; // Little-endian: low byte first
    }
    dst[len] = 0;
    data = (u8 *) dst;
    res_size = len;
} 
//skip UTF-16 BE BOM if any
else if ((buffer_length >= 2) && (utf_bom[0] == 0xFE) && (utf_bom[1] == 0xFF)) {
    // Ensure we have an even number of bytes after BOM for UTF-16
    u32 len = (buffer_length - 2) / 2;
    if (!len) return NULL;
    
    // Allocate memory for converted string
    dst = (char *) gf_malloc(sizeof(char) * (len + 1));
    if (!dst) return NULL;
    
    // Extract the upper byte of each UTF-16 character (big-endian)
    for (u32 i = 0; i < len; i++) {
        u32 idx = 2 + 2*i;
        if (idx + 1 >= buffer_length) {
            gf_free(dst);
            return NULL;
        }
        dst[i] = (char) utf_bom[idx + 1]; // Big-endian: high byte second
    }
    dst[len] = 0;
    data = (u8 *) dst;
    res_size = len;
} else {
    data += offset;
    res_size = buffer_length - offset;
}

// Skip leading whitespace
while (res_size && (data[0] == ' ' || data[0] == '\t' || data[0] == '\n' || data[0] == '\r')) {
    data++;
    res_size--;
}

// If empty buffer after skipping whitespace, return NULL
if (!res_size) {
    if (dst) gf_free(dst);
    return NULL;
}

// Define PROBE_OK macro
#define PROBE_OK(_score, _mime) \
    *score = _score; \
    if (dst) gf_free(dst); \
    return _mime;