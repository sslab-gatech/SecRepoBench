#define PROBE_OK(SUPPORT, MIME) \
	do { \
		*score = SUPPORT; \
		if (dst) gf_free(dst); \
		return gf_strdup(MIME); \
	} while (0)

char *dst = NULL;
u32 res_size = 0;

if (!buffer_length || !data) return NULL;

// Check for BOM and convert to UTF-8 if necessary
if (buffer_length >= 2 && data[0] == 0xFE && data[1] == 0xFF) {
	// Big endian UTF-16 detected
	res_size = gf_utf16be_to_utf8(data + 2, buffer_length - 2, &dst);
} else if (buffer_length >= 2 && data[0] == 0xFF && data[1] == 0xFE) {
	// Little endian UTF-16 detected
	res_size = gf_utf16le_to_utf8(data + 2, buffer_length - 2, &dst);
} else if (buffer_length >= 3 && data[0] == 0xEF && data[1] == 0xBB && data[2] == 0xBF) {
	// UTF-8 with BOM detected
	res_size = gf_utf8_to_utf8(data + 3, buffer_length - 3, &dst);
} else {
	// Assume input is already UTF-8
	dst = gf_malloc(buffer_length + 1);
	memcpy(dst, data, buffer_length);
	dst[buffer_length] = '\0';
	res_size = buffer_length;
}

if (!res_size || !dst) {
	if (dst) gf_free(dst);
	return NULL;
}

// Strip leading whitespace characters
char *ptr = dst;
while (res_size > 0 && (ptr[0] == ' ' || ptr[0] == '\t' || ptr[0] == '\n')) {
	ptr++;
	res_size--;
}