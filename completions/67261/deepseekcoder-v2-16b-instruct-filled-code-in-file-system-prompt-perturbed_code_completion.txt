= gf_filter_pck_get_property_str(ipck, "vtt_settings");
		if (p) vtt_settings = p->value.string;
		e = gf_webvtt_parser_parse_cue(ctx->vttparser, vtt_pre, vtt_cueid, vtt_settings);
		if (e != GF_OK) {
			if (e == GF_EOS) {
				ctx->playstate = 2;
				return GF_EOS;
			}
			GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[TXTIn] WebVTT parser error %s\n", gf_error_to_string(e) ));
			return e;
		}
	} else {
		e = gf_webvtt_parser_parse(ctx->vttparser);
		if (e != GF_OK) {
			if (e == GF_EOS) {
				ctx->playstate = 2;
				return GF_EOS;
			}
			GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[TXTIn] WebVTT parser error %s\n", gf_error_to_string(e) ));
			return e;
		}
	}

	if (ctx->playstate==2)
		return GF_EOS;

	return GF_OK;
}
#endif

static GF_Err txtin_process_srt_or_webvtt(GF_Filter *filter, GF_TXTIn *ctx, GF_FilterPacket *ipck)
{
	GF_Err e;

	if (ctx->fmt == GF_TXTIN_MODE_SRT) {
		e = txtin_process_srt(filter, ctx, GF_FALSE);
		if (e) return e;
	}
#ifndef GPAC_DISABLE_VTT
	else if (ctx->fmt == GF_TXTIN_MODE_WEBVTT) {
		e = txtin_process_webvtt(filter, ctx, ipck);
		if (e) return e;
	}
#endif
	else {
		GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[TXTIn] Invalid format for SRT/WebVTT processing\n"));
		return GF_NOT_SUPPORTED;
	}

	return GF_OK;
}

static GF_Err txtin_process_text(GF_Filter *filter, GF_TXTIn *ctx, GF_FilterPacket *ipck)
{
	GF_Err e;

	if (ctx->fmt == GF_TXTIN_MODE_SRT) {
		e = txtin_process_srt(filter, ctx, GF_FALSE);
		if (e) return e;
	}
#ifndef GPAC_DISABLE_VTT
	else if (ctx->fmt == GF_TXTIN_MODE_WEBVTT) {
		e = txtin_process_webvtt(filter, ctx, ipck);
		if (e) return e;
	}
#endif
	else if (ctx->fmt == GF_TXTIN_MODE_SUB) {
		e = txtin_process_srt(filter, ctx, GF_FALSE);
		if (e) return e;
	}
	else if (ctx->fmt == GF_TXTIN_MODE_SSA) {
		e = txtin_process_srt(filter, ctx, GF_FALSE);
		if (e) return e;
	}
	else {
		GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[TXTIn] Invalid format for SRT/WebVTT processing\n"));
		return GF_NOT_SUPPORTED;
	}

	return GF_OK;
}

static GF_Err txtin_process_ttml(GF_Filter *filter, GF_TXTIn *ctx, GF_FilterPacket *ipck)
{
	GF_Err e;

	if (ctx->playstate==2)
		return GF_EOS;

	if (!ctx->is_setup) {
		ctx->is_setup = GF_TRUE;
		e = txtin_setup_srt(filter, ctx, GF_FALSE);
		if (e || !ctx->unframed) return e;
	}
	if (!ctx->opid) return GF_NOT_SUPPORTED;

	if (ctx->seek_state==1) {
		ctx->seek_state = 2;
		gf_fseek(ctx->src, 0, SEEK_SET);
	}

	if (ctx->unframed) {
		const GF_PropertyValue *p;
		const char *ttml_pre=NULL, *ttml_cueid=NULL, *ttml_settings=NULL;
		p = gf_filter_pck_get_property_str(ipck, "ttml_pre");
		if (p) ttml_pre = p->value.string;
		p = gf_filter_pck_get_property_str(ipck, "ttml_cueid");
		if (p) ttml_cueid = p->value.string;
		p = gf_filter_pck_get_property_str(ipck, "ttml_settings");
		if (p) ttml_settings = p->value.string;
		e = gf_dom_parser_parse_cue(ctx->parser_working_copy, ttml_pre, ttml_cueid, ttml_settings);
		if (e != GF_OK) {
			if (e == GF_EOS) {
				ctx->playstate = 2;
				return GF_EOS;
			}
			GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[TXTIn] TTML parser error %s\n", gf_error_to_string(e) ));
			return e;
		}
	} else {
		e = gf_dom_parser_parse(ctx->parser_working_copy, ctx->src);
		if (e != GF_OK) {
			if (e == GF_EOS) {
				ctx->playstate = 2;
				return GF_EOS;
			}
			GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[TXTIn] TTML parser error %s\n", gf_error_to_string(e) ));
			return e;
		}
	}

	if (ctx->playstate==2)
		return GF_EOS;

	return GF_OK;
}

static GF_Err txtin_process_swf_svg(GF_Filter *filter, GF_TXTIn *ctx, GF_FilterPacket *ipck)
{
#ifndef GPAC_DISABLE_SWF_IMPORT
	GF_Err e;

	if (ctx->playstate==2)
		return GF_EOS;

	if (!ctx->is_setup) {
		ctx->is_setup = GF_TRUE;
		e = txtin_setup_srt(filter, ctx, GF_FALSE);
		if (e || !ctx->unframed) return e;
	}
	if (!ctx->opid) return GF_NOT_SUPPORTED;

	if (ctx->seek_state==1) {
		ctx->seek_state = 2;
		gf_swf_restart(ctx->swf_parse);
	}

	if (ctx->unframed) {
		const GF_PropertyValue *p;
		const char *swf_pre=NULL, *swf_cueid=NULL, *swf_settings=NULL;
		p = gf_filter_pck_get_property_str(ipck, "swf_pre");
		if (p) swf_pre = p->value.string;
		p = gf_filter_pck_get_property_str(ipck, "swf_cueid");
		if (p) swf_cueid = p->value.string;
		p = gf_filter_pck_get_property_str(ipck, "swf_settings");
		if (p) swf_settings = p->value.string;
		e = gf_swf_parse_cue(ctx->swf_parse, swf_pre, swf_cueid, swf_settings);
		if (e != GF_OK) {
			if (e == GF_EOS) {
				ctx->playstate = 2;
				return GF_EOS;
			}
			GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[TXTIn] SWF parser error %s\n", gf_error_to_string(e) ));
			return e;
		}
	} else {
		e = gf_swf_parse(ctx->swf_parse, ctx->src);
		if (e != GF_OK) {
			if (e == GF_EOS) {
				ctx->playstate = 2;
				return GF_EOS;
			}
			GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[TXTIn] SWF parser error %s\n", gf_error_to_string(e) ));
			return e;
		}
	}

	if (ctx->playstate==2)
		return GF_EOS;

	return GF_OK;
#else
	return GF_NOT_SUPPORTED;
#endif
}

static GF_Err txtin_process_probe(GF_Filter *filter, GF_TXTIn *ctx, GF_FilterPacket *ipck)
{
	GF_Err e;

	if (ctx->playstate==2)
		return GF_EOS;

	if (!ctx->is_setup) {
		ctx->is_setup = GF_TRUE;
		e = txtin_setup_srt(filter, ctx, GF_FALSE);
		if (e || !ctx->unframed) return e;
	}
	if (!ctx->opid) return GF_NOT_SUPPORTED;

	if (ctx->seek_state==1) {
		ctx->seek_state = 2;
		gf_fseek(ctx->src, 0, SEEK_SET);
	}

	if (ctx->unframed) {
		const GF_PropertyValue *p;
		const char *probe_pre=NULL, *probe_cueid=NULL, *probe_settings=NULL;
		p = gf_filter_pck_get_property_str(ipck, "probe_pre");
		if (p) probe_pre = p->value.string;
		p = gf_filter_pck_get_property_str(ipck, "probe_cueid");
		if (p) probe_cueid = p->value.string;
		p = gf_filter_pck_get_property_str(ipck, "probe_settings");
		if (p) probe_settings = p->value.string;
		e = gf_probe_parse_cue(ctx->probe_parser, probe_pre, probe_cueid, probe_settings);
		if (e != GF_OK) {
			if (e == GF_EOS) {
				ctx->playstate = 2;
				return GF_EOS;
			}
			GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[TXTIn] Probe parser error %s\n", gf_error_to_string(e) ));
			return e;
		}
	} else {
		e = gf_probe_parse(ctx->probe_parser, ctx->src);
		if (e != GF_OK) {
			if (e == GF_EOS) {
				ctx->playstate = 2;
				return GF_EOS;
			}
			GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[TXTIn] Probe parser error %s\n", gf_error_to_string(e) ));
			return e;
		}
	}

	if (ctx->playstate==2)
		return GF_EOS;

	return GF_OK;
}

static GF_Err txtin_process_text_samples(GF_Filter *filter, GF_TXTIn *ctx, GF_FilterPacket *ipck)
{
	GF_Err e;

	if (ctx->playstate==2)
		return GF_EOS;

	if (!ctx->is_setup) {
		ctx->is_setup = GF_TRUE;
		e = txtin_setup_srt(filter, ctx, GF_FALSE);
		if (e || !ctx->unframed) return e;
	}
	if (!ctx->opid) return GF_NOT_SUPPORTED;

	if (ctx->seek_state==1) {
		ctx->seek_state = 2;
		gf_fseek(ctx->src, 0, SEEK_SET);
	}

	if (ctx->unframed) {