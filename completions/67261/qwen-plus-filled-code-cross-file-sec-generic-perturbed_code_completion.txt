#define PROBE_OK(support_level, mime_type) \
    do { \
        *score = support_level; \
        return (char *)mime_type; \
    } while (0)

u8 bom[4];
u32 bom_len = 0;
const char *dst = NULL;
u32 res_size = buffer_length;

// Check for BOM and adjust data pointer accordingly
if (buffer_length >= 4) {
    memcpy(bom, data, 4);
    if (!memcmp(bom, "\xEF\xBB\xBF", 3)) { // UTF-8 BOM
        bom_len = 3;
    } else if (!memcmp(bom, "\xFF\xFE\x00\x00", 4)) { // UTF-32LE BOM
        bom_len = 4;
    } else if (!memcmp(bom, "\x00\x00\xFE\xFF", 4)) { // UTF-32BE BOM
        bom_len = 4;
    } else if (!memcmp(bom, "\xFE\xFF", 2)) { // UTF-16BE BOM
        bom_len = 2;
    } else if (!memcmp(bom, "\xFF\xFE", 2)) { // UTF-16LE BOM
        bom_len = 2;
    }
}
if (bom_len) {
    data += bom_len;
    res_size -= bom_len;
}

// Convert to UTF-8 if necessary (assuming dst is allocated elsewhere)
if (!dst && res_size > 0) {
    dst = gf_malloc(res_size + 1);
    if (!dst) return NULL;
    memcpy((void *)dst, data, res_size);
    dst[res_size] = '\0';
}

// Strip leading whitespace
while (res_size > 0 && (dst[0] == ' ' || dst[0] == '\t' || dst[0] == '\n' || dst[0] == '\r')) {
    dst++;
    res_size--;
}