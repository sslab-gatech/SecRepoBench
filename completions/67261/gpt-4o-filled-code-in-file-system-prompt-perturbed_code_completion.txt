s32 read;
unsigned char BOM[5];
read = (s32) gf_fread(BOM, 5, data);
if (read < 1) {
    return NULL;
}

if ((BOM[0] == 0xFF) && (BOM[1] == 0xFE)) {
    if (!BOM[2] && !BOM[3]) {
        return NULL;
    }
    gf_fseek(data, 2, SEEK_SET);
    return 3;
}
if ((BOM[0] == 0xFE) && (BOM[1] == 0xFF)) {
    if (!BOM[2] && !BOM[3]) {
        return NULL;
    }
    gf_fseek(data, 2, SEEK_SET);
    return 2;
} else if ((BOM[0] == 0xEF) && (BOM[1] == 0xBB) && (BOM[2] == 0xBF)) {
    gf_fseek(data, 3, SEEK_SET);
    return 1;
}
gf_fseek(data, 0, SEEK_SET);

if (BOM[0] < 0x80) {
    return 0;
}

const char *opt = gf_opts_get_key("core", "charset");
if (ctx->ipid) {
    const GF_PropertyValue *p = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_CHARSET);
    if (p && p->value.string) opt = p->value.string;
}
if (opt) {
    if (!stricmp(opt, "utf8") || !stricmp(opt, "utf-8")) return 1;
    if (!stricmp(opt, "utf16") || !stricmp(opt, "utf-16")) return 2;
    if (!stricmp(opt, "utf16be") || !stricmp(opt, "utf-16be") || !stricmp(opt, "utf-16-be") || !stricmp(opt, "utf16-be")) return 3;
    return 0;
}

if (gf_utf8_is_legal(BOM, 2) || gf_utf8_is_legal(BOM, 3) || gf_utf8_is_legal(BOM, 4)) {
    return 0;
}

GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[TXTIn] Unknown text encoding for PID %s, defaulting to passthrough - use `-charset` to override\n", gf_filter_pid_get_name(ctx->ipid)));
return 0;