double) p[0]);
              break;
            }
            case EXIF_FMT_STRING:
            {
              value=(char *) NULL;
              if (~((size_t) number_bytes) >= 1)
                value=(char *) AcquireQuantumMemory((size_t) number_bytes+1UL,
                  sizeof(*value));
              if (value != (char *) NULL)
                {
                  (void) CopyMagickString(value,(char *) p,number_bytes+1);
                }
              break;
            }
            case EXIF_FMT_USHORT:
            {
              EXIFMultipleValues(2,"%.20g",(double) ReadPropertyUnsignedShort(
                endian,p));
              break;
            }
            case EXIF_FMT_SSHORT:
            {
              EXIFMultipleValues(2,"%.20g",(double) ReadPropertySignedShort(
                endian,p));
              break;
            }
            case EXIF_FMT_ULONG:
            {
              EXIFMultipleValues(4,"%.20g",(double) ReadPropertyUnsignedLong(
                endian,p));
              break;
            }
            case EXIF_FMT_SLONG:
            {
              EXIFMultipleValues(4,"%.20g",(double) ReadPropertySignedLong(
                endian,p));
              break;
            }
            case EXIF_FMT_URATIONAL:
            {
              EXIFMultipleFractions(8,"%.20g/%.20g",(double) ReadPropertyUnsignedLong(
                endian,p),(double) ReadPropertyUnsignedLong(endian,p+4));
              break;
            }
            case EXIF_FMT_SRATIONAL:
            {
              EXIFMultipleFractions(8,"%.20g/%.20g",(double) ReadPropertySignedLong(
                endian,p),(double) ReadPropertySignedLong(endian,p+4));
              break;
            }
            case EXIF_FMT_SINGLE:
            {
              EXIFMultipleValues(4,"%.20g",(double) ReadPropertyUnsignedLong(
                LSBEndian,p));
              break;
            }
            case EXIF_FMT_DOUBLE:
            {
              EXIFMultipleValues(8,"%.20g",(double) ReadPropertyUnsignedLong(
                LSBEndian,p));
              break;
            }
            default:
            {
              value=(char *) NULL;
              if (~((size_t) number_bytes) >= 1)
                value=(char *) AcquireQuantumMemory((size_t) number_bytes+1UL,
                  sizeof(*value));
              if (value != (char *) NULL)
                {
                  for (i=0; i < (ssize_t) number_bytes; i++)
                  {
                    value[i]='.';
                    if (isprint((int) p[i]) != 0)
                      value[i]=(char) p[i];
                  }
                  value[i]='\0';
                }
              break;
            }
          }
          if (value != (char *) NULL)
            {
              if (all == 0)
                {
                  if (LocaleCompare(EXIFTag[i].description,property) == 0)
                    {
                      (void) SetImageProperty((Image *) image,property,value,
                        exception);
                      value=DestroyString(value);
                      status=MagickTrue;
                      break;
                    }
                }
              else
                {
                  if (all == 1)
                    {
                      (void) FormatLocaleString(buffer,MagickPathExtent,"%s=%s",
                        EXIFTag[i].description,value);
                      (void) SetImageProperty((Image *) image,property,buffer,
                        exception);
                      value=DestroyString(value);
                      status=MagickTrue;
                      break;
                    }
                  if (all == 2)
                    {
                      (void) FormatLocaleString(buffer,MagickPathExtent,"%04zx=%s",
                        (size_t) EXIFTag[i].tag,value);
                      (void) SetImageProperty((Image *) image,property,buffer,
                        exception);
                      value=DestroyString(value);
                      status=MagickTrue;
                      break;
                    }
                }
            }
        }
    }
    if (entry < number_entries)
      {
        /*
          Push the current directory onto the stack.
        */
        directory_stack[level].directory=directory;
        directory_stack[level].entry=entry;
        directory_stack[level].offset=tag_offset;
        level++;
        /*
          Follow the offset to the next IFD.
        */
        tag_offset=(ssize_t) ReadPropertySignedLong(endian,directory+8);
        if ((tag_offset < 0) || (size_t) tag_offset >= length)
          break;
        if (((size_t) tag_offset+12) < (size_t) tag_offset)
          break;  /* prevent overflow */
        if (((size_t) tag_offset+12) > length)
          break;
        directory=(exif+tag_offset);
        entry=0;
      }
    else
      {
        /*
          Pop the current directory off the stack.
        */
        if (level == 0)
          break;
        level--;
        directory=directory_stack[level].directory;
        entry=directory_stack[level].entry;
        tag_offset=directory_stack[level].offset;
      }
  } while (level != 0);
  exif_resources=DestroySplayTree(exif_resources);
  return(status);
}

#undef MaxDirectoryStack
#undef EXIF_DELIMITER
#undef EXIF_NUM_FORMATS
#undef EXIF_FMT_BYTE
#undef EXIF_FMT_STRING
#undef EXIF_FMT_USHORT
#undef EXIF_FMT_ULONG
#undef EXIF_FMT_URATIONAL
#undef EXIF_FMT_SBYTE
#undef EXIF_FMT_UNDEFINED
#undef EXIF_FMT_SSHORT
#undef EXIF_FMT_SLONG
#undef EXIF_FMT_SRATIONAL
#undef EXIF_FMT_SINGLE
#undef EXIF_FMT_DOUBLE
#undef TAG_EXIF_OFFSET
#undef TAG_GPS_OFFSET
#undef TAG_INTEROP_OFFSET

static inline int ReadPropertyByte(const unsigned char **p,size_t *length)
{
  int
    c;

  if (*length < 1)
    return(EOF);
  c=(int) (*(*p)++);
  (*length)--;
  return(c);
}

static inline signed int ReadPropertyMSBLong(const unsigned char **p,
  size_t *length)
{
  union
  {
    unsigned int
      unsigned_value;

    signed int
      signed_value;
  } quantum;

  int
    c;

  ssize_t
    i;

  unsigned char
    buffer[4];

  unsigned int
    value;

  if (*length < 4)
    return(-1);
  for (i=0; i < 4; i++)
  {
    c=(int) (*(*p)++);
    (*length)--;
    buffer[i]=(unsigned char) c;
  }
  value=(unsigned int) buffer[0] << 24;
  value|=(unsigned int) buffer[1] << 16;
  value|=(unsigned int) buffer[2] << 8;
  value|=(unsigned int) buffer[3];
  quantum.unsigned_value=value & 0xffffffff;
  return(quantum.signed_value);
}

static inline signed short ReadPropertyMSBShort(const unsigned char **p,
  size_t *length)
{
  union
  {
    unsigned short
      unsigned_value;

    signed short
      signed_value;
  } quantum;

  int
    c;

  ssize_t
    i;

  unsigned char
    buffer[2];

  unsigned short
    value;

  if (*length < 2)
    return((unsigned short) ~0);
  for (i=0; i < 2; i++)
  {
    c=(int) (*(*p)++);
    (*length)--;
    buffer[i]=(unsigned char) c;
  }
  value=(unsigned short) buffer[0] << 8;
  value|=(unsigned short) buffer[1];
  quantum.unsigned_value=value & 0xffff;
  return(quantum.signed_value);
}

static inline signed int ReadPropertySignedLong(const EndianType endian,
  const unsigned char *buffer)
{
  union
  {
    unsigned int
      unsigned_value;

    signed int
      signed_value;
  } quantum;

  unsigned int
    value;

  if (endian == LSBEndian)
    {
      value=(unsigned int) buffer[3] << 24;
      value|=(unsigned int) buffer[2] << 16;
      value|=(unsigned int) buffer[1] << 8;
      value|=(unsigned int) buffer[0];
      quantum.unsigned_value=value & 0xffffffff;
      return(quantum.signed_value);
    }
  value=(unsigned int) buffer[0] << 24;
  value|=(unsigned int) buffer[1] << 16;
  value|=(unsigned int) buffer[2] << 8;
  value|=(unsigned int) buffer[3];
  quantum.unsigned_value=value & 0xffffffff;
  return(quantum.signed_value);
}

static inline unsigned int ReadPropertyUnsignedLong(const EndianType endian,
  const unsigned char *buffer)
{
  unsigned int
    value;

  if (endian == LSBEndian)
    {
      value=(unsigned int) buffer[3] << 24;
      value|=(unsigned int) buffer[2] << 16;
      value|=(unsigned int) buffer[1] << 8;
      value|=(unsigned int) buffer[0];
      return(value & 0xffffffff);
    }
  value=(unsigned int) buffer[0] << 24;
  value|=(unsigned int) buffer[1] << 16;
  value|=(unsigned int) buffer[2] << 8;
  value|=(unsigned int) buffer[3];
  return(value & 0xffffffff);
}

static inline signed short ReadPropertySignedShort(const EndianType endian,
  const unsigned char *buffer)
{
  union
  {
    unsigned short
      unsigned_value;

    signed short
      signed_value;
  } quantum;

  unsigned short
    value;

  if (endian == LSBEndian)
    {
      value=(unsigned short) buffer[1] << 8;
      value|=(unsigned short) buffer[0];
      quantum.unsigned_value=value & 0xffff;
      return(quantum.signed_value);
    }
  value=(unsigned short) buffer[0] << 8;
  value|=(unsigned short) buffer[1];
  quantum.unsigned_value=value & 0xffff;
  return(quantum.signed_value);
}

static inline unsigned short ReadPropertyUnsignedShort(const EndianType endian,
  const unsigned char *buffer)
{
  unsigned short
    value;

  if (endian == LSBEndian)
    {
      value=(unsigned short) buffer[1] << 8;
      value|=(unsigned short) buffer[0];
      return(value & 0xffff);
    }
  value=(unsigned short) buffer[0] << 8;
  value|=(unsigned short) buffer[1];
  return(value & 0xffff);
}

static MagickBooleanType GetImageProperty(const Image *image,const char *key,
  ExceptionInfo *exception)
{
  char
    *attribute;

  MagickBooleanType
    status;

  assert(image != (Image *) NULL);
  assert(key != (const char *) NULL);
  attribute=(char *) NULL;
  status=MagickFalse;
  if (LocaleCompare(key,"exif:") == 0)
    status=GetEXIFProperty(image,key,exception);
  else
    if (LocaleCompare(key,"iptc:") == 0)
      status=GetIPTCProperty(image,key,exception);
    else
      if (LocaleCompare(key,"8bim:") == 0)
        status=Get8BIMProperty(image,key,exception);
  if (status == MagickFalse)
    {