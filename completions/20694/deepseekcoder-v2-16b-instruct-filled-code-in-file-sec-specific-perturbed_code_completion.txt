], blk,
                                         &seq[pos-1], &out_sz);
                if (r) return r;
                cig_op = BAM_CINS;
                cig_len++;
                seq_pos++;
                nm++;
                //printf("  %d: IN(i) = %c (ret %d)\n", f, seq[pos-1], r);
            }
            break;
        }

        case 'P': { // Pad; PD
            if (cig_len && cig_op != BAM_CPAD) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_PD) {
                if (!c->comp_hdr->codecs[DS_PD]) return -1;
                r |= c->comp_hdr->codecs[DS_PD]
                                ->decode(s, c->comp_hdr->codecs[DS_PD], blk,
                                         (char *)&i32, &out_sz);
                if (r) return r;
                cig_op = BAM_CPAD;
                cig_len += i32;
                seq_pos += i32;
                ref_pos += i32;
                //printf("  %d: PD = %d (ret %d)\n", f, i32, r);
            }
            break;
        }

        case 'H': { // Hard clip; HC
            if (cig_len && cig_op != BAM_CHARD_CLIP) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_HC) {
                if (!c->comp_hdr->codecs[DS_HC]) return -1;
                r |= c->comp_hdr->codecs[DS_HC]
                                ->decode(s, c->comp_hdr->codecs[DS_HC], blk,
                                         (char *)&i32, &out_sz);
                if (r) return r;
                cig_op = BAM_CHARD_CLIP;
                cig_len += i32;
                seq_pos += i32;
                ref_pos += i32;
                //printf("  %d: HC = %d (ret %d)\n", f, i32, r);
            }
            break;
        }

        case 'M': { // Match; MF
            if (cig_len && cig_op != BAM_CMATCH) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_MF) {
                if (!c->comp_hdr->codecs[DS_MF]) return -1;
                r |= c->comp_hdr->codecs[DS_MF]
                                ->decode(s, c->comp_hdr->codecs[DS_MF], blk,
                                         cr->len ? &seq[pos-1] : NULL,
                                         &out_sz);
                if (r) return r;
                cig_op = BAM_CMATCH;
            }
            cig_len++;
            seq_pos++;
            ref_pos++;
            nm++;
            //printf("  %d: MF = %c (ret %d)\n", f, seq[pos-1], r);
            break;
        }

        case 'Q': { // Query match; QM
            if (cig_len && cig_op != BAM_CQMATCH) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_QM) {
                if (!c->comp_hdr->codecs[DS_QM]) return -1;
                r |= c->comp_hdr->codecs[DS_QM]
                                ->decode(s, c->comp_hdr->codecs[DS_QM], blk,
                                         cr->len ? &seq[pos-1] : NULL,
                                         &out_sz);
                if (r) return r;
                cig_op = BAM_CQMATCH;
            }
            cig_len++;
            seq_pos++;
            ref_pos++;
            nm++;
            //printf("  %d: QM = %c (ret %d)\n", f, seq[pos-1], r);
            break;
        }

        case 'R': { // Reference skip; RS
            if (cig_len && cig_op != BAM_CREFERENCE_SKIP) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_RS) {
                if (!c->comp_hdr->codecs[DS_RS]) return -1;
                r |= c->comp_hdr->codecs[DS_RS]
                                ->decode(s, c->comp_hdr->codecs[DS_RS], blk,
                                         (char *)&i32, &out_sz);
                if (r) return r;
                cig_op = BAM_CREFERENCE_SKIP;
                cig_len += i32;
                ref_pos += i32;
                //printf("  %d: RS = %d (ret %d)\n", f, i32, r);
            }
            break;
        }

        case 'N': { // Reference skip; TN
            if (cig_len && cig_op != BAM_CTAG_SKIP) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_TN) {
                if (!c->comp_hdr->codecs[DS_TN]) return -1;
                r |= c->comp_hdr->codecs[DS_TN]
                                ->decode(s, c->comp_hdr->codecs[DS_TN], blk,
                                         (char *)&i32, &out_sz);
                if (r) return r;
                cig_op = BAM_CTAG_SKIP;
                cig_len += i32;
                ref_pos += i32;
                //printf("  %d: TN = %d (ret %d)\n", f, i32, r);
            }
            break;
        }

        case 'F': { // Feature; FN
            if (cig_len && cig_op != BAM_CREF_SKIP) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_FN) {
                if (!c->comp_hdr->codecs[DS_FN]) return -1;
                r |= c->comp_hdr->codecs[DS_FN]
                                ->decode(s, c->comp_hdr->codecs[DS_FN], blk,
                                         (char *)&fn, &out_sz);
                if (r) return r;
                cig_op = BAM_CREF_SKIP;
                cig_len += fn;
                ref_pos += fn;
                //printf("  %d: FN = %d (ret %d)\n", f, fn, r);
            }
            break;
        }

        case '=':
        case 'X':
            if (cig_len && cig_op != BAM_CMATCH) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            cig_op = BAM_CMATCH;
            cig_len++;
            seq_pos++;
            ref_pos++;
            nm++;
            //printf("  %d: M = %c (ret %d)\n", f, seq[pos-1], r);
            break;

        default:
            hts_log_error("Unrecognised CIGAR op %c", op);
            return -1;
        }
    }

    if (cig_len) {
        cigar[ncigar++] = (cig_len<<4) + cig_op;
        cig_len = 0;
    }

    if (decode_md && md_dist >= 0) {
        BLOCK_APPEND_UINT(s->aux_blk, md_dist);
    }

    if (decode_nm && nm) {
        BLOCK_APPEND_UINT(s->aux_blk, nm);
    }

    if (decode_md || decode_nm) {
        int aux_size = BLOCK_SIZE(s->aux_blk) - orig_aux;
        if (aux_size > 0) {
            char *aux_data = malloc(aux_size);
            if (!aux_data) {
                free(s->aux_blk);
                s->aux_blk = NULL;
                return -1;
            }
            memcpy(aux_data, BLOCK_DATA(s->aux_blk) + orig_aux, aux_size);
            free(s->aux_blk);
            s->aux_blk = aux_data;
        }
    }

    s->ncigar = ncigar;
    s->cigar_alloc = cigar_alloc;

    return 0;

 skip_cigar:
    s->ncigar = 0;
    s->cigar_alloc = 0;
    return 0;

 beyond_slice:
    hts_log_error("MD/NM: Reference position beyond slice boundary");
    return -1;
}

/*
 * Decodes a CRAM slice.
 * Returns 0 on success
 *        -1 on failure
 */
int cram_decode_slice(cram_fd *fd, cram_container *c, cram_slice *s,
                      cram_record *cr, sam_hdr_t *sh) {
    int r = 0;
    int cf = 0;
    int has_MD = 0;
    int has_NM = 0;
    int qual_size = 0;
    int name_size = 0;
    int q_id = 0;

    if (s->hdr->num_blocks < 1)
        return -1;

    if (cram_dependent_data_series(fd, c->comp_hdr, s))
        return -1;

    cram_decode_estimate_sizes(c->comp_hdr, s, &qual_size, &name_size, &q_id);

    if (s->data_series & CRAM_SEQ) {
        if (!(s->seq = malloc(cr->len + 1)))
            return -1;
    }

    if (s->data_series & CRAM_QUAL) {
        if (!(s->qual = malloc(cr->len + 1))) {
            free(s->seq);
            return -1;
        }
    }

    if (s->data_series & CRAM_RN) {
        if (!(s->name = malloc(name_size))) {
            free(s->seq);
            free(s->qual);
            return -1;
        }
    }

    if (s->data_series & CRAM_QS) {
        if (!(s->aux_blk = cram_new_block(0, 0))) {
            free(s->seq);
            free(s->qual);
            free(s->name);
            return -1;
        }
    }

    if (s->data_series & CRAM_CIGAR) {
        s->cigar = malloc(1024 * sizeof(uint32_t));
        if (!s->cigar) {
            free(s->seq);
            free(s->qual);
            free(s->name);
            cram_free_block(s->aux_blk);
            return -1;
        }
    }

    if (s->data_series & CRAM_MD) has_MD = 1;
    if (s->data_series & CRAM_NM) has_NM = 1;

    if (s->data_series & (CRAM_SEQ | CRAM_QUAL | CRAM_CIGAR | CRAM_RN | CRAM_QS)) {
        if (cram_uncompress_block(s->block[0])) {
            free(s->seq);
            free(s->qual);
            free(s->name);
            cram_free_block(s->aux_blk);
            free(s->cigar);
            return -1;
        }
    }

    if (s->data_series & CRAM_SEQ) {
        r |= cram_decode_seq(fd, c, s, s->block[0], cr, sh, cf,