if (prefix == NULL) {
    if (memcmp(name, entry->name, klen) == 0) {
        found = 1;
    }
} else {
    if (xmlDictCompareQName(prefix, entry->name) == 0) {
        found = 1;
    }
}

if (found) {
    return(entry);
}

if ((dict->subdict!= NULL) && (dict->subdict->size > 0)) {
    xmlDictEntry *subEntry;
    unsigned subHashValue;

    if (prefix == NULL)
        subHashValue = xmlDictHashName(dict->subdict->seed, name, len,
                                       &len);
    else
        subHashValue = xmlDictHashQName(dict->subdict->seed, prefix, name,
                                        &plen, &len);
    subEntry = xmlDictFindEntry(dict->subdict, prefix, name, klen,
                                subHashValue, &found);
    if (found)
        return(subEntry);
}

if (!update)
    return(NULL);

/*
 * Grow the hash table if needed
 */
if (dict->nbElems + 1 > dict->size / MAX_FILL_DENOM * MAX_FILL_NUM) {
    unsigned newSize, mask, displ, pos;

    if (dict->size == 0) {
        newSize = MIN_HASH_SIZE;
    } else {
        if (dict->size >= MAX_HASH_SIZE)
            return(NULL);
        newSize = dict->size * 2;
    }
    if (xmlDictGrow(dict, newSize)!= 0)
        return(NULL);

    /*
     * Find new entry
     */
    mask = dict->size - 1;
    displ = 0;
    pos = hashValue & mask;
    entry = &dict->table[pos];

    while ((entry->hashValue!= 0) &&
           ((pos - entry->hashValue) & mask) >= displ) {
        displ++;
        pos++;
        entry++;
        if ((pos & mask) == 0)
            entry = dict->table;
    }
}

if (prefix == NULL)
    ret = xmlDictAddString(dict, name, len);
else
    ret = xmlDictAddQString(dict, prefix, plen, name, len);
if (ret == NULL)
    return(NULL);

/*
 * Shift the remainder of the probe sequence to the right
 */
if (entry->hashValue!= 0) {
    const xmlDictEntry *end = &dict->table[dict->size];
    const xmlDictEntry *cur = entry;

    do {
        cur++;
        if (cur >= end)
            cur = dict->table;
    } while (cur->hashValue!= 0);

    if (cur < entry) {
        /*
         * If we traversed the end of the buffer, handle the part
         * at the start of the buffer.
         */
        memmove(&dict->table[1], dict->table,
                (char *) cur - (char *) dict->table);
        cur = end - 1;
        dict->table[0] = *cur;
    }

    memmove(&entry[1], entry, (char *) cur - (char *) entry);
}

/*
 * Populate entry
 */
entry->hashValue = hashValue;
entry->name = ret;

dict->nbElems++;

return(entry);