{
  char macro_name[MagickPathExtent];
  const char *macro_start, *macro_end = (const char *) NULL;
  size_t macro_length;
  ssize_t nested = 1;

  /* Save the macro name (e.g. "wheel") */
  (void) CopyMagickString(macro_name, token, MagickPathExtent);

  /* Set the start pointer for the macro definition text */
  macro_start = q;

  /* Parse through the MVG string to match nested push/pop commands */
  while (nested > 0 && *q != '\0')
  {
    const char *current = q;
    GetNextToken(q, &q, length, token);
    if (*token == '#')
    {
      /* Skip comment */
      while ((*q != '\n') && (*q != '\0'))
        q++;
      continue;
    }
    if (LocaleCompare("push", token) == 0)
      nested++;
    else if (LocaleCompare("pop", token) == 0)
    {
      nested--;
      if (nested == 0)
      {
        macro_end = current;
        break;
      }
    }
  }

  if (macro_end == (const char *) NULL)
    macro_end = q;

  macro_length = (size_t)(macro_end - macro_start);

  {
    char *macro = (char *) AcquireMagickMemory(macro_length + 1);
    if (macro == (char *) NULL)
      break;
    (void) memcpy(macro, macro_start, macro_length);
    macro[macro_length] = '\0';
    (void) AddValueToSplayTree(macros, ConstantString(macro_name), macro);
  }
}