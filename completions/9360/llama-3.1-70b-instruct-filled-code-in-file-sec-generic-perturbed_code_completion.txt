static void GetFillColor(const DrawInfo *draw_info,ssize_t x,ssize_t y,
  PixelInfo *fill_color,ExceptionInfo *exception)
{
  char
    geometry[MagickPathExtent];

  Image
    *pattern;

  MagickBooleanType
    status;

  PointInfo
    offset;

  if (draw_info->fill_pattern!= (Image *) NULL)
    {
      pattern=draw_info->fill_pattern;
      offset.x=(double) x;
      offset.y=(double) y;
      status=GetOneVirtualPixelInfo(pattern,UndefinedVirtualPixelMethod,
        offset.x,offset.y,fill_color,exception);
      if (status == MagickFalse)
        {
          GetPixelInfo(pattern,fill_color);
          fill_color->alpha=(MagickRealType) TransparentAlpha;
        }
      return;
    }
  if (draw_info->gradient.type!= UndefinedGradient)
    {
      double
        alpha,
        beta,
        gamma,
        length,
        offset;

      PointInfo
        point;

      const SegmentInfo
        *gradient_vector;

      gradient_vector=(&draw_info->gradient.gradient_vector);
      point.x=(double) x;
      point.y=(double) y;
      switch (draw_info->gradient.type)
      {
        case LinearGradient:
        {
          point.x=gradient_vector->x2-gradient_vector->x1;
          point.y=gradient_vector->y2-gradient_vector->y1;
          length=sqrt(point.x*point.x+point.y*point.y);
          gamma=sqrt(gradient_vector->x2*gradient_vector->x2+
            gradient_vector->y2*gradient_vector->y2)*length;
          gamma=PerceptibleReciprocal(gamma);
          alpha=gamma*point.x*gradient_vector->x2;
          beta=gamma*point.y*gradient_vector->y2;
          offset=alpha+beta;
          break;
        }
        case RadialGradient:
        {
          point.x=(double) x-gradient_vector->x1;
          point.y=(double) y-gradient_vector->y1;
          offset=sqrt(point.x*point.x+point.y*point.y);
          break;
        }
      }
      if (draw_info->gradient.spread == RepeatSpread)
        {
          MagickBooleanType
            antialias;

          double
            repeat;

          antialias=MagickFalse;
          repeat=0.0;
          if (draw_info->gradient.type == LinearGradient)
            {
              repeat=fmod(offset,length);
              if (repeat < 0.0)
                repeat=length-fmod(-repeat,length);
              else
                repeat=fmod(offset,length);
              antialias=(repeat < length) && ((repeat+1.0) > length)?
                MagickTrue : MagickFalse;
              offset=PerceptibleReciprocal(length)*repeat;
            }
          else
            {
              repeat=fmod(offset,draw_info->gradient.radius);
              if (repeat < 0.0)
                repeat=draw_info->gradient.radius-fmod(-repeat,
                  draw_info->gradient.radius);
              else
                repeat=fmod(offset,draw_info->gradient.radius);
              antialias=repeat+1.0 > draw_info->gradient.radius? MagickTrue :
                MagickFalse;
              offset=repeat/draw_info->gradient.radius;
            }
          if (antialias!= MagickFalse)
            {
              offset=0.0;
              if (draw_info->gradient.type == LinearGradient)
                offset=length-repeat;
              else
                offset=draw_info->gradient.radius-repeat;
            }
        }
      for (alpha=0; alpha < (double) draw_info->gradient.number_stops; alpha++)
        if (offset < draw_info->gradient.stops[(size_t) alpha].offset)
          break;
      if ((offset < 0.0) || (alpha == 0))
        *fill_color=draw_info->gradient.stops[0].color;
      else
        if ((offset > 1.0) || (alpha == (double) draw_info->gradient.number_stops))
          *fill_color=draw_info->gradient.stops[draw_info->gradient.number_stops-
            1].color;
        else
          {
            beta=alpha;
            alpha--;
            gamma=(offset-draw_info->gradient.stops[(size_t) alpha].offset)/
              (draw_info->gradient.stops[(size_t) beta].offset-
              draw_info->gradient.stops[(size_t) alpha].offset);
            CompositePixelInfoBlend(&draw_info->gradient.stops[(size_t) alpha].
              color,1.0-gamma,&draw_info->gradient.stops[(size_t) beta].color,
              gamma,fill_color);
          }
      if (draw_info->fill_alpha!= OpaqueAlpha)
        fill_color->alpha*=draw_info->fill_alpha;
      return;
    }
  if (draw_info->fill_alpha!= OpaqueAlpha)
    {
      fill_color->red*=draw_info->fill_alpha;
      fill_color->green*=draw_info->fill_alpha;
      fill_color->blue*=draw_info->fill_alpha;
      fill_color->alpha*=draw_info->fill_alpha;
    }
  *fill_color=draw_info->fill;
}