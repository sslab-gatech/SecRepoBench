static void GetFillColor(const DrawInfo *draw_info,ssize_t x,ssize_t y,
  PixelInfo *pixel,ExceptionInfo *exception)
{
  char
    geometry[MagickPathExtent];

  double
    alpha,
    blue,
    green,
    red;

  Image
    *pattern;

  MagickBooleanType
    status;

  PointInfo
    offset;

  ssize_t
    id;

  /*
    Get fill color.
  */
  if (draw_info->fill_pattern!= (Image *) NULL)
    {
      pattern=draw_info->fill_pattern;
      offset.x=(double) x;
      offset.y=(double) y;
      status=GetOneVirtualPixelInfo(pattern,draw_info->viewbox.x!= 0?
        CropVirtualPixelMethod : TileVirtualPixelMethod,x,y,pixel,exception);
      if (status == MagickFalse)
        {
          pixel->red=(double) draw_info->fill.red;
          pixel->green=(double) draw_info->fill.green;
          pixel->blue=(double) draw_info->fill.blue;
          pixel->alpha=(double) draw_info->fill_alpha;
        }
      return;
    }
  if (draw_info->gradient.stops!= (StopInfo *) NULL)
    {
      double
        length;

      PointInfo
        point;

      const SegmentInfo
        *gradient_vector;

      gradient_vector=(&draw_info->gradient.gradient_vector);
      point.x=gradient_vector->x2-gradient_vector->x1;
      point.y=gradient_vector->y2-gradient_vector->y1;
      length=sqrt(point.x*point.x+point.y*point.y);
      alpha=GetStopColorOffset(&draw_info->gradient,x,y);
      if (draw_info->gradient.type!= RadialGradient)
        alpha*=PerceptibleReciprocal(length);
      for (id=0; id < (ssize_t) draw_info->gradient.number_stops; id++)
        if (alpha < draw_info->gradient.stops[id].offset)
          break;
      if ((alpha < 0.0) || (id == 0))
        {
          red=draw_info->gradient.stops[0].color.red;
          green=draw_info->gradient.stops[0].color.green;
          blue=draw_info->gradient.stops[0].color.blue;
        }
      else
        if ((alpha > 1.0) || (id == (ssize_t) draw_info->gradient.number_stops))
          {
            red=draw_info->gradient.stops[draw_info->gradient.number_stops-1].color.red;
            green=draw_info->gradient.stops[draw_info->gradient.number_stops-1].color.green;
            blue=draw_info->gradient.stops[draw_info->gradient.number_stops-1].color.blue;
          }
        else
          {
            ssize_t
              j;

            j=id;
            id--;
            alpha=(alpha-draw_info->gradient.stops[id].offset)/
              (draw_info->gradient.stops[j].offset-draw_info->gradient.stops[id].offset);
            red=draw_info->gradient.stops[id].color.red+(draw_info->gradient.stops[j].color.red-
              draw_info->gradient.stops[id].color.red)*alpha;
            green=draw_info->gradient.stops[id].color.green+(draw_info->gradient.stops[j].color.green-
              draw_info->gradient.stops[id].color.green)*alpha;
            blue=draw_info->gradient.stops[id].color.blue+(draw_info->gradient.stops[j].color.blue-
              draw_info->gradient.stops[id].color.blue)*alpha;
          }
      pixel->red=red;
      pixel->green=green;
      pixel->blue=blue;
      pixel->alpha=(double) draw_info->fill_alpha;
      return;
    }
  if (draw_info->fill.alpha_trait == BlendPixelTrait)
    {
      (void) FormatLocaleString(geometry,MagickPathExtent,"%gx%g%+.15g%+.15g",
        draw_info->bounds.width,draw_info->bounds.height,draw_info->bounds.x1,
        draw_info->bounds.y1);
      pattern=DrawPatternPath(NULL,draw_info,"fill",draw_info->fill_pattern,
        exception);
      if (pattern!= (Image *) NULL)
        {
          offset.x=(double) x;
          offset.y=(double) y;
          status=GetOneVirtualPixelInfo(pattern,draw_info->viewbox.x!= 0?
            CropVirtualPixelMethod : TileVirtualPixelMethod,x,y,pixel,exception);
          pattern=DestroyImage(pattern);
          if (status == MagickFalse)
            {
              pixel->red=(double) draw_info->fill.red;
              pixel->green=(double) draw_info->fill.green;
              pixel->blue=(double) draw_info->fill.blue;
              pixel->alpha=(double) draw_info->fill_alpha;
            }
          return;
        }
    }
  pixel->red=(double) draw_info->fill.red;
  pixel->green=(double) draw_info->fill.green;
  pixel->blue=(double) draw_info->fill.blue;
  pixel->alpha=(double) draw_info->fill_alpha;
}