static void GetFillColor(const DrawInfo *draw_info,ssize_t x,ssize_t y,
  PixelInfo *pixel,ExceptionInfo *exception)
{
  char
    geometry[MagickPathExtent];

  double
    angle,
    aspect,
    factor,
    scale;

  Image
    *pattern;

  MagickBooleanType
    status;

  PointInfo
    offset;

  PrimitiveInfo
    primitive_info[6];

  register ssize_t
    i;

  SegmentInfo
    bounds;

  ssize_t
    coordinates;

  if (draw_info->fill_pattern!= (Image *) NULL)
    {
      pattern=draw_info->fill_pattern;
      if (pattern->alpha_trait == UndefinedPixelTrait)
        (void) SetImageAlphaChannel(pattern,OpaqueAlphaChannel,exception);
      if (draw_info->alpha!= OpaqueAlpha)
        (void) SetImageAlpha(pattern,draw_info->alpha,exception);
      SetGeometry(pattern,&bounds);
      pattern->gravity=draw_info->gravity;
      bounds.x=x;
      bounds.y=y;
      (void) FormatLocaleString(geometry,MagickPathExtent,
        "%.20gx%.20g%+.20g%+.20g",(double) pattern->columns,(double)
        pattern->rows,(double) bounds.x,(double) bounds.y);
      (void) ParseGravityGeometry(pattern,geometry,&bounds,exception);
      status=GetVirtualPixelInfo(pattern,TileVirtualPixelMethod,bounds.x,
        bounds.y,pixel,exception);
      if (status == MagickFalse)
        {
          GetPixelInfo(pattern,pixel);
          pixel->alpha=(MagickRealType) TransparentAlpha;
        }
      return;
    }
  if (draw_info->gradient.stops!= (StopInfo *) NULL)
    {
      double
        offset;

      offset=GetStopColorOffset(&draw_info->gradient,x,y);
      if (draw_info->gradient.type!= RadialGradient)
        offset*=PerceptibleReciprocal(draw_info->gradient.gradient_vector.x2-
          draw_info->gradient.gradient_vector.x1);
      if (offset < 0.0)
        {
          offset=0.0;
          if (draw_info->gradient.spread == RepeatSpread)
            offset=fmod(-offset,draw_info->gradient.radius);
        }
      if (offset > 1.0)
        {
          if (draw_info->gradient.spread == RepeatSpread)
            offset=fmod(offset,draw_info->gradient.radius);
          else
            offset=1.0;
        }
      if (draw_info->gradient.spread == ReflectSpread)
        {
          if (offset < 0.0)
            offset=(-offset);
          if ((ssize_t) fmod(offset,2.0) == 0)
            offset=fmod(offset,1.0);
          else
            offset=1.0-fmod(offset,1.0);
        }
      for (i=0; i < (ssize_t) draw_info->gradient.number_stops; i++)
        if (offset < draw_info->gradient.stops[i].offset)
          break;
      if (i == 0)
        *pixel=draw_info->gradient.stops[0].color;
      else
        if (i == (ssize_t) draw_info->gradient.number_stops)
          *pixel=draw_info->gradient.stops[draw_info->gradient.number_stops-1].
            color;
        else
          {
            ssize_t
              j;

            j=i;
            i--;
            factor=(offset-draw_info->gradient.stops[i].offset)/
              (draw_info->gradient.stops[j].offset-
              draw_info->gradient.stops[i].offset);
            CompositePixelInfoBlend(&draw_info->gradient.stops[i].color,1.0-
              factor,&draw_info->gradient.stops[j].color,factor,pixel);
          }
      if (draw_info->fill_alpha!= OpaqueAlpha)
        pixel->alpha*=draw_info->fill_alpha;
      return;
    }
  if (draw_info->fill.alpha!= OpaqueAlpha)
    {
      GetPixelInfo(image,pixel);
      pixel->alpha=(MagickRealType) TransparentAlpha;
    }
  else
    *pixel=draw_info->fill;
  if (draw_info->fill_alpha!= OpaqueAlpha)
    pixel->alpha*=draw_info->fill_alpha;
  if (draw_info->primitive!= (char *) NULL)
    {
      (void) memset(primitive_info,0,sizeof(primitive_info));
      primitive_info[0].primitive=PointPrimitive;
      primitive_info[0].point.x=(double) x;
      primitive_info[0].point.y=(double) y;
      primitive_info[0].coordinates=1;
      primitive_info[0].closed_subpath=MagickFalse;
      primitive_info[0].method=FloodfillMethod;
      primitive_info[1].primitive=UndefinedPrimitive;
      (void) CloneString(&primitive_info[0].text,draw_info->primitive);
      (void) CloneString(&primitive_info[0].geometry,draw_info->geometry);
      primitive_info[0].fill=draw_info->fill;
      primitive_info[0].fill_alpha=draw_info->fill_alpha;
      primitive_info[0].stroke=draw_info->stroke;
      primitive_info[0].stroke_alpha=draw_info->stroke_alpha;
      primitive_info[0].stroke_width=draw_info->stroke_width;
      primitive_info[0].fill_rule=draw_info->fill_rule;
      primitive_info[0].linecap=draw_info->linecap;
      primitive_info[0].linejoin=draw_info->linejoin;
      primitive_info[0].miterlimit=draw_info->miterlimit;
      primitive_info[0].dash_offset=draw_info->dash_offset;
      primitive_info[0].dash_pattern=draw_info->dash_pattern;
      primitive_info[0].decorate=draw_info->decorate;
      primitive_info[0].font=draw_info->font;
      primitive_info[0].pointsize=draw_info->pointsize;
      primitive_info[0].kerning=draw_info->kerning;
      primitive_info[0].interline_spacing=draw_info->interline_spacing;
      primitive_info[0].interword_spacing=draw_info->interword_spacing;
      primitive_info[0].direction=draw_info->direction;
      primitive_info[0].encoding=draw_info->encoding;
      primitive_info[0].style=draw_info->style;
      primitive_info[0].stretch=draw_info->stretch;
      primitive_info[0].weight=draw_info->weight;
      primitive_info[0].fill_pattern=draw_info->fill_pattern;
      primitive_info[0].stroke_pattern=draw_info->stroke_pattern;
      primitive_info[0].alpha=draw_info->alpha;
      primitive_info[0].fill_alpha=draw_info->fill_alpha;
      primitive_info[0].stroke_alpha=draw_info->stroke_alpha;
      primitive_info[0].clip_path=draw_info->clip_path;
      primitive_info[0].clip_units=draw_info->clip_units;
      primitive_info[0].clip_mask=draw_info->clip_mask;
      primitive_info[0].clipping_mask=draw_info->clipping_mask;
      primitive_info[0].composite_mask=draw_info->composite_mask;
      primitive_info[0].render=draw_info->render;
      primitive_info[0].debug=draw_info->debug;
      (void) DrawPrimitive(image,draw_info,primitive_info,exception);
      if (draw_info->debug!= MagickFalse)
        (void) LogMagickEvent(DrawEvent,GetMagickModule(),
          "  end draw-primitive");
      return;
    }
  if (draw_info->text!= (char *) NULL)
    {
      char
        geometry[MagickPathExtent];

      DrawInfo
        *clone_info;

      TypeMetric
        metrics;

      clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
      (void) CloneString(&clone_info->text,draw_info->text);
      (void) FormatLocaleString(geometry,MagickPathExtent,"%+f%+f",
        (double) x,(double) y);
      (void) CloneString(&clone_info->geometry,geometry);
      status=GetTypeMetrics(image,clone_info,&metrics,exception);
      clone_info=DestroyDrawInfo(clone_info);
      if (status == MagickFalse)
        {
          GetPixelInfo(image,pixel);
          pixel->alpha=(MagickRealType) TransparentAlpha;
          return;
        }
      offset.x=(double) x;
      offset.y=(double) y;
      angle=draw_info->affine.ry*draw_info->affine.sx-draw_info->affine.rx*
        draw_info->affine.sy;
      aspect=draw_info->affine.sx*draw_info->affine.sy+draw_info->affine.rx*
        draw_info->affine.ry;
      scale=draw_info->affine.sx*draw_info->affine.sy-aspect;
      if (scale < 0.0)
        scale=(-scale);
      offset.x=(double) (offset.x*draw_info->affine.sx+offset.y*
        draw_info->affine.ry+draw_info->affine.tx);
      offset.y=(double) (offset.x*draw_info->affine.rx+offset.y*
        draw_info->affine.sy+draw_info->affine.ty);
      if (draw_info->direction == RightToLeftDirection)
        offset.x=(double) (metrics.width-offset.x);
      if (draw_info->direction == BottomToTopDirection)
        offset.y=(double) (metrics.height-offset.y);
      (void) GetOneVirtualPixelInfo(image,TileVirtualPixelMethod,
        (ssize_t) ceil(offset.x-0.5),(ssize_t) ceil(offset.y-0.5),pixel,
        exception);
      return;
    }
  if (draw_info->primitive == (char *) NULL)
    {
      GetPixelInfo(image,pixel);
      pixel->alpha=(MagickRealType) TransparentAlpha;
      return;
    }
  (void) memset(primitive_info,0,sizeof(primitive_info));
  primitive_info[0].primitive=PointPrimitive;
  primitive_info[0].point.x=(double) x;
  primitive_info[0].point.y=(double) y;
  primitive_info[0].coordinates=1;
  primitive_info[0].closed_subpath=MagickFalse;
  primitive_info[0].method=FloodfillMethod;
  primitive_info[1].primitive=UndefinedPrimitive;
  (void) CloneString(&primitive_info[0].text,draw_info->primitive);
  (void) CloneString(&primitive_info[0].geometry,draw_info->geometry);
  primitive_info[0].fill=draw_info->fill;
  primitive_info[0].fill_alpha=draw_info->fill_alpha;
  primitive_info[0].stroke=draw_info->stroke;
  primitive_info[0].stroke_alpha=draw_info->stroke_alpha;
  primitive_info[0].stroke_width=draw_info->stroke_width;
  primitive_info[0].fill_rule=draw_info->fill_rule;
  primitive_info[0].linecap=draw_info->linecap;
  primitive_info[0].linejoin=draw_info->linejoin;
  primitive_info[0].miterlimit=draw_info->miterlimit;
  primitive_info[0].dash_offset=draw_info->dash_offset;
  primitive_info[0].dash_pattern=draw_info->dash_pattern;
  primitive_info[0].decorate=draw_info->decorate;
  primitive_info[0].font=draw_info->font;
  primitive_info[0].pointsize=draw_info->pointsize;
  primitive_info[0].kerning=draw_info->kerning;
  primitive_info[0].interline_spacing=draw_info->interline_spacing;
  primitive_info[0].interword_spacing=draw_info->interword_spacing;
  primitive_info[0].direction=draw_info->direction;
  primitive_info[0].encoding=draw_info->encoding;
  primitive_info[0].style=draw_info->style;
  primitive_info[0].stretch=draw_info->stretch;
  primitive_info[0].weight=draw_info->weight;
  primitive_info[0].fill_pattern=draw_info->fill_pattern;
  primitive_info[0].stroke_pattern=draw_info->stroke_pattern;
  primitive_info[0].alpha=draw_info->alpha;
  primitive_info[0].fill_alpha=draw_info->fill_alpha;
  primitive_info[0].stroke_alpha=draw_info->stroke_alpha;
  primitive_info[0].clip_path=draw_info->clip_path;
  primitive_info[0].clip_units=draw_info->clip_units;
  primitive_info[0].clip_mask=draw_info->clip_mask;
  primitive_info[0].clipping_mask=draw_info->clipping_mask;
  primitive_info[0].composite_mask=draw_info->composite_mask;
  primitive_info[0].render=draw_info->render;
  primitive_info[0].debug=draw_info->debug;
  (void) DrawPrimitive(image,draw_info,primitive_info,exception);
  if (draw_info->debug!= MagickFalse)
    (void) LogMagickEvent(DrawEvent,GetMagickModule(),
      "  end draw-primitive");
  return;
}