(void) CopyMagickString(name, token, MagickPathExtent);
/*
  Gather all tokens until the matching 'pop', handling nested pushes.
*/
n=1;
p=q;
while ((n > 0) && (*p != '\0'))
{
  const char
    *r = p;

  GetNextToken(r,&r,length,token);
  if (*token == '#')
    {
      /*
        Skip comment.
      */
      while ((*r != '\n') && (*r != '\0'))
        r++;
    }
  else if (LocaleCompare(token,"push") == 0)
    n++;
  else if (LocaleCompare(token,"pop") == 0)
    n--;
  p=r;
}
/*
  Store the macro definition in the splay-tree if properly closed.
*/
if (n == 0)
{
  /*
    'token' holds the last 'pop' read. Exclude it from the definition.
  */
  size_t macro_length=(size_t) (p - start - strlen(token));
  if (macro_length > 0)
    {
      char
        *definition = (char *) AcquireQuantumMemory(macro_length+1,
        sizeof(*definition));

      if (definition != (char *) NULL)
        {
          (void) memcpy(definition,start,macro_length);
          definition[macro_length]='\0';
          (void) AddValueToSplayTree(macros,ConstantString(name),definition);
        }
    }
  q=p;
}