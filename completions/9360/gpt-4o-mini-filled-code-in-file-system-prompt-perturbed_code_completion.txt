ssize_t
              n;

            n=0;
            for (p=start; *p != '\0'; )
            {
              GetNextToken(p,&p,length,token);
              if (*token == '\0')
                break;
              if (*token == '#')
                {
                  while ((*p != '\n') && (*p != '\0'))
                    p++;
                  continue;
                }
              if (LocaleCompare("pop",token) == 0)
                {
                  GetNextToken(p,&p,length,token);
                  if (LocaleCompare("class",token) == 0)
                    break;
                  if (LocaleCompare("clip-path",token) == 0)
                    break;
                  if (LocaleCompare("defs",token) == 0)
                    {
                      defsDepth--;
                      break;
                    }
                  if (LocaleCompare("gradient",token) == 0)
                    break;
                  if (LocaleCompare("graphic-context",token) == 0)
                    {
                      if (n <= 0)
                        {
                          (void) ThrowMagickException(exception,GetMagickModule(),
                            DrawError,"UnbalancedGraphicContextPushPop","`%s'",token);
                          status=MagickFalse;
                          n=0;
                          break;
                        }
                      graphic_context[n]=DestroyDrawInfo(graphic_context[n]);
                      n--;
                      break;
                    }
                  if (LocaleCompare("mask",token) == 0)
                    break;
                  if (LocaleCompare("pattern",token) == 0)
                    break;
                  if (LocaleCompare("symbol",token) == 0)
                    {
                      symbolDepth--;
                      break;
                    }
                  status=MagickFalse;
                  break;
                }
              if (LocaleCompare("push",token) == 0)
                {
                  GetNextToken(p,&p,length,token);
                  if (LocaleCompare("class",token) == 0)
                    {
                      /*
                        Class context.
                      */
                      for (p=q; *q != '\0'; )
                      {
                        GetNextToken(q,&q,length,token);
                        if (LocaleCompare(token,"pop") != 0)
                          continue;
                        GetNextToken(q,(const char **) NULL,length,token);
                        if (LocaleCompare(token,"class") != 0)
                          continue;
                        break;
                      }
                      GetNextToken(q,&q,length,token);
                      break;
                    }
                  if (LocaleCompare("clip-path",token) == 0)
                    {
                      char
                        name[MaxTextExtent];

                      const char
                        *clip_path;

                      GetNextToken(q,&q,length,token);
                      (void) FormatLocaleString(name,MaxTextExtent,"%s",token);
                      clip_path=(const char *) GetValueFromSplayTree(macros,token);
                      if (clip_path != (const char *) NULL)
                        {
                          if (graphic_context[n]->clipping_mask != (Image *) NULL)
                            graphic_context[n]->clipping_mask=
                              DestroyImage(graphic_context[n]->clipping_mask);
                          graphic_context[n]->clipping_mask=DrawClippingMask(image,
                            graphic_context[n],token,clip_path,exception);
                          if (draw_info->compliance != SVGCompliance)
                            (void) DrawClipPath(image,graphic_context[n],
                              graphic_context[n]->clip_mask,exception);
                        }
                      break;
                    }
                  if (LocaleCompare("defs",token) == 0)
                    {
                      defsDepth++;
                      graphic_context[n]->render=defsDepth > 0 ? MagickFalse :
                        MagickTrue;
                      break;
                    }
                  if (LocaleCompare("gradient",token) == 0)
                    {
                      char
                        key[2*MagickPathExtent],
                        name[MagickPathExtent],
                        type[MagickPathExtent];

                      SegmentInfo
                        segment;

                      GetNextToken(q,&q,length,token);
                      (void) CopyMagickString(name,token,MagickPathExtent);
                      GetNextToken(q,&q,length,token);
                      (void) CopyMagickString(type,token,MagickPathExtent);
                      GetNextToken(q,&q,length,token);
                      segment.x1=StringToDouble(token,&next_token);
                      if (token == next_token)
                        ThrowPointExpectedException(token,exception);
                      GetNextToken(q,&q,length,token);
                      if (*token == ',')
                        GetNextToken(q,&q,length,token);
                      segment.y1=StringToDouble(token,&next_token);
                      if (token == next_token)
                        ThrowPointExpectedException(token,exception);
                      GetNextToken(q,&q,length,token);
                      if (*token == ',')
                        GetNextToken(q,&q,length,token);
                      segment.x2=StringToDouble(token,&next_token);
                      if (token == next_token)
                        ThrowPointExpectedException(token,exception);
                      GetNextToken(q,&q,length,token);
                      if (*token == ',')
                        GetNextToken(q,&q,length,token);
                      segment.y2=StringToDouble(token,&next_token);
                      if (token == next_token)
                        ThrowPointExpectedException(token,exception);
                      if (LocaleCompare(type,"radial") == 0)
                        {
                          GetNextToken(q,&q,length,token);
                          if (*token == ',')
                            GetNextToken(q,&q,length,token);
                        }
                      for (p=q; *q != '\0'; )
                      {
                        GetNextToken(q,&q,length,token);
                        if (LocaleCompare(token,"pop") != 0)
                          continue;
                        GetNextToken(q,(const char **) NULL,length,token);
                        if (LocaleCompare(token,"gradient") != 0)
                          continue;
                        break;
                      }
                      if ((q == (char *) NULL) || (p == (char *) NULL) || ((q-4) < p))
                        {
                          status=MagickFalse;
                          break;
                        }
                      (void) CopyMagickString(token,p,(size_t) (q-p-4+1));
                      bounds.x1=graphic_context[n]->affine.sx*segment.x1+
                        graphic_context[n]->affine.ry*segment.y1+
                        graphic_context[n]->affine.tx;
                      bounds.y1=graphic_context[n]->affine.rx*segment.x1+
                        graphic_context[n]->affine.sy*segment.y1+
                        graphic_context[n]->affine.ty;
                      bounds.x2=graphic_context[n]->affine.sx*segment.x2+
                        graphic_context[n]->affine.ry*segment.y2+
                        graphic_context[n]->affine.tx;
                      bounds.y2=graphic_context[n]->affine.rx*segment.x2+
                        graphic_context[n]->affine.sy*segment.y2+
                        graphic_context[n]->affine.ty;
                      (void) FormatLocaleString(key,MagickPathExtent,"%s",name);
                      (void) SetImageArtifact(image,key,token);
                      (void) FormatLocaleString(key,MagickPathExtent,"%s-type",name);
                      (void) SetImageArtifact(image,key,type);
                      (void) FormatLocaleString(key,MagickPathExtent,"%s-geometry",name);
                      (void) FormatLocaleString(geometry,MagickPathExtent,"%gx%g%+.15g%+.15g",
                        MagickMax(fabs(bounds.x2-bounds.x1+1.0),1.0),
                        MagickMax(fabs(bounds.y2-bounds.y1+1.0),1.0),
                        bounds.x1,bounds.y1);
                      (void) SetImageArtifact(image,key,geometry);
                      GetNextToken(q,&q,length,token);
                      break;
                    }
                    if (LocaleCompare("graphic-context",token) == 0)
                    {
                      n++;
                      graphic_context=(DrawInfo **) ResizeQuantumMemory(
                        graphic_context,(size_t) (n+1),sizeof(*graphic_context));
                      if (graphic_context == (DrawInfo **) NULL)
                      {
                        (void) ThrowMagickException(exception,GetMagickModule(),
                          ResourceLimitError,"MemoryAllocationFailed","`%s'",
                          image->filename);
                        break;
                      }
                      graphic_context[n]=CloneDrawInfo((ImageInfo *) NULL,
                        graphic_context[n-1]);
                      if (*q == '"')
                        GetNextToken(q,&q,length,token);
                      break;
                    }
                    if (LocaleCompare("mask",token) == 0)
                    {
                      GetNextToken(q,&q,length,token);
                      break;
                    }
                    if (LocaleCompare("pattern",token) == 0)
                    {
                      char
                        key[2*MagickPathExtent],
                        name[MagickPathExtent];

                      RectangleInfo
                        bounds;

                      GetNextToken(q,&q,length,token);
                      (void) CopyMagickString(name,token,MagickPathExtent);
                      GetNextToken(q,&q,length,token);
                      bounds.x=(ssize_t) ceil(StringToDouble(token,&next_token)-0.5);
                      if (token == next_token)
                        ThrowPointExpectedException(token,exception);
                      GetNextToken(q,&q,length,token);
                      if (*token == ',')
                        GetNextToken(q,&q,length,token);
                      bounds.y=(ssize_t) ceil(StringToDouble(token,&next_token)-0.5);
                      if (token == next_token)
                        ThrowPointExpectedException(token,exception);
                      GetNextToken(q,&q,length,token);
                      if (*token == ',')
                        GetNextToken(q,&q,length,token);
                      bounds.width=(size_t) floor(StringToDouble(token,&next_token)+0.5);
                      if (token == next_token)
                        ThrowPointExpectedException(token,exception);
                      GetNextToken(q,&q,length,token);
                      if (*token == ',')
                        GetNextToken(q,&q,length,token);
                      bounds.height=(size_t) floor(StringToDouble(token,&next_token)+0.5);
                      if (token == next_token)
                        ThrowPointExpectedException(token,exception);
                      for (p=q; *q != '\0'; )
                      {
                        GetNextToken(q,&q,length,token);
                        if (LocaleCompare(token,"pop") != 0)
                          continue;
                        GetNextToken(q,(const char **) NULL,length,token);
                        if (LocaleCompare(token,"pattern") != 0)
                          continue;
                        break;
                      }
                      if ((q == (char *) NULL) || (p == (char *) NULL) || ((q-4) < p))
                      {
                        status=MagickFalse;
                        break;
                      }
                      (void) CopyMagickString(token,p,(size_t) (q-p-4+1));
                      (void) FormatLocaleString(key,MagickPathExtent,"%s",name);
                      (void) SetImageArtifact(image,key,token);
                      (void) FormatLocaleString(key,MagickPathExtent,"%s-geometry",name);
                      (void) FormatLocaleString(geometry,MagickPathExtent,"%gx%g%+.15g%+.15g",
                        (double) bounds.width,(double) bounds.height,(double) bounds.x,(double) bounds.y);
                      (void) SetImageArtifact(image,key,geometry);
                      GetNextToken(q,&q,length,token);
                      break;
                    }
                    if (LocaleCompare("symbol",token) == 0)
                    {
                      symbolDepth++;
                      graphic_context[n]->render=symbolDepth > 0 ? MagickFalse :
                        MagickTrue;
                      break;
                    }
                    status=MagickFalse;
                    break;
                  }
                }
                status=MagickFalse;
                break;
              }
              case 'r':
              case 'R':
              {
                if (LocaleCompare("rectangle",keyword) == 0)
                {
                  primitive_type=RectanglePrimitive;
                  break;
                }
                if (LocaleCompare("rotate",keyword) == 0)
                {
                  GetNextToken(q,&q,extent,token);
                  angle=StringToDouble(token,&next_token);
                  if (token == next_token)
                    ThrowPointExpectedException(token,exception);
                  affine.sx=cos(DegreesToRadians(fmod((double) angle,360.0)));
                  affine.rx=sin(DegreesToRadians(fmod((double) angle,360.0)));
                  affine.ry=(-sin(DegreesToRadians(fmod((double) angle,360.0))));
                  affine.sy=cos(DegreesToRadians(fmod((double) angle,360.0)));
                  break;
                }
                if (LocaleCompare("roundRectangle",keyword) == 0)
                {
                  primitive_type=RoundRectanglePrimitive;
                  break;
                }
                status=MagickFalse;
                break;
              }
              case 's':
              case 'S':
              {
                if (LocaleCompare("scale",keyword) == 0)
                {
                  GetNextToken(q,&q,extent,token);
                  affine.sx=StringToDouble(token,&next_token);
                  if (token == next_token)
                    ThrowPointExpectedException(token,exception);
                  GetNextToken(q,&q,extent,token);
                  if (*token == ',')
                    GetNextToken(q,&q,extent,token);
                  affine.sy=StringToDouble(token,&next_token);
                  if (token == next_token)
                    ThrowPointExpectedException(token,exception);
                  break;
                }
                if (LocaleCompare("skewX",keyword) == 0)
                {
                  GetNextToken(q,&q,extent,token);
                  angle=StringToDouble(token,&next_token);
                  if (token == next_token)
                    ThrowPointExpectedException(token,exception);
                  affine.ry=sin(DegreesToRadians(angle));
                  break;
                }
                if (LocaleCompare("skewY",keyword) == 0)
                {
                  GetNextToken(q,&q,extent,token);
                  angle=StringToDouble(token,&next_token);
                  if (token == next_token)
                    ThrowPointExpectedException(token,exception);
                  affine.rx=(-tan(DegreesToRadians(angle)/2.0));
                  break;
                }
                status=MagickFalse;
                break;
              }
              case 't':
              case 'T':
              {
                if (LocaleCompare("translate",keyword) == 0)
                {
                  GetNextToken(q,&q,extent,token);
                  affine.tx=StringToDouble(token,&next_token);
                  if (token == next_token)
                    ThrowPointExpectedException(token,exception);
                  GetNextToken(q,&q,extent,token);
                  if (*token == ',')
                    GetNextToken(