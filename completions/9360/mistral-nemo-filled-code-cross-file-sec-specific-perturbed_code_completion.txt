// Extract macros from the MVG string. The code iterates through the string
// to find 'push' and 'pop' commands, handling nested structures accordingly.
// It skips comments starting with '#'. When a complete macro is identified,
// it extracts the macro definition and adds it to a splay tree
// for later retrieval using the macro name as the key.
// <MASK>
for ( ; ; )
{
  if (IsPoint(q) == MagickFalse)
    break;
  GetNextToken(q,&q,length,token);
  if (*token == '\0')
    break;
  if (*token == '#')
    {
      // Skip comment.
      while ((*q != '\n') && (*q != '\0'))
        q++;
      continue;
    }
  if (LocaleCompare("push",token) == 0)
    {
      register const char
        *end,
        *start;

      GetNextToken(q,&q,length,token);
      if (*q == '"')
        {
          char
            name[MagickPathExtent];

          const char
            *p;

          ssize_t
           n;

          // Named macro (e.g. push graphic-context "wheel").
          GetNextToken(q,&q,length,token);
          start=q;
          end=start;
          while (*end != '"')
            end++;
          n=end-start;
          name=(char *) AcquireQuantumMemory(n+1, sizeof(*name));
          if (name == (char *) NULL)
            ThrowMagickException(ResourceLimitError,"MemoryAllocationFailed",
              "AcquireQuantumMemory");
          (void) CopyMagickString(name,start,n+1);
          GetNextToken(q,&q,length,token);
          if (*token == ',')
            GetNextToken(q,&q,length,token);
          // Add the macro definition to the splay tree.
          AddValueToSplayTree(macros,ConstantString(name),name);
          name=(char *) RelinquishMagickMemory(name);
        }
      else
        {
          // Anonymous macro (e.g. push graphic-context).
          // Handle this case similarly to the named macro.
          // ...
        }
    }
  // Add other primitive types here, following the same pattern as 'push'.
  // ...
}