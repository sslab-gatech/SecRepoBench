if (cmsPipelineCheckAndRetreiveStages(Src, 3,
         cmsSigCurveSetElemType, cmsSigMatrixElemType, cmsSigCurveSetElemType,
         &Curve1, &Matrix1, &Curve2)) {

    _cmsStageMatrixData* Data = (_cmsStageMatrixData*)cmsStageData(Matrix1);

    // Copy the matrix to our result
    memcpy(&res, Data->Double, sizeof(res));

    // Preserve the Odffset (may be NULL as a zero offset)
    Offset = Data->Offset;

    if (_cmsMAT3isIdentity(&res) && Offset == NULL) {

        // We can get rid of full matrix
        isIdentityMatrix = TRUE;
    }
}
else
    return FALSE; // Not optimizeable this time

// Allocate an empty LUT
Dest =  cmsPipelineAlloc(Src ->ContextID, Src ->InputChannels, Src ->OutputChannels);
if (!Dest) return FALSE;

// Assamble the new LUT
if (!cmsPipelineInsertStage(Dest, cmsAT_BEGIN, cmsStageDup(Curve1)))
    goto Error;

if (!isIdentityMatrix) {

    if (!cmsPipelineInsertStage(Dest, cmsAT_END, cmsStageAllocMatrix(Dest->ContextID, 3, 3, (const cmsFloat64Number*)&res, Offset)))
        goto Error;
}

if (!cmsPipelineInsertStage(Dest, cmsAT_END, cmsStageDup(Curve2)))
    goto Error;

// If identity on matrix, we can further optimize the curves, so call the join curves routine
if (isIdentityMatrix) {

    OptimizeByJoiningCurves(&Dest, Intent, InputFormat, OutputFormat, dwFlags);
}
else {
    _cmsStageToneCurvesData* mpeC1 = (_cmsStageToneCurvesData*) cmsStageData(Curve1);
    _cmsStageToneCurvesData* mpeC2 = (_cmsStageToneCurvesData*) cmsStageData(Curve2);

    // In this particular optimization, cache does not help as it takes more time to deal with
    // the cache that with the pixel handling
    *dwFlags |= cmsFLAGS_NOCACHE;

    // Setup the optimizarion routines
    SetMatShaper(Dest, mpeC1 ->TheCurves, &res, (cmsVEC3*) Offset, mpeC2->TheCurves, OutputFormat);
}