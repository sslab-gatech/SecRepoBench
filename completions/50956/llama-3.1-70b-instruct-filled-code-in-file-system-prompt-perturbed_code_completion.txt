_cmsStageMatrixData* m1 = (_cmsStageMatrixData*) cmsStageData(Matrix1);
_cmsStageMatrixData* m2 = (_cmsStageMatrixData*) cmsStageData(Matrix2);
cmsMAT3 res;

// Input offset and output offset should be zero to use this optimization
if (m1->Offset!= NULL || m2 ->Offset!= NULL || 
    cmsStageInputChannels(Matrix1)!= 3 || cmsStageOutputChannels(Matrix1)!= 3 ||                            
    cmsStageInputChannels(Matrix2)!= 3 || cmsStageOutputChannels(Matrix2)!= 3)
    return FALSE;

// Multiply both matrices to get the result
_cmsMAT3per(&res, (cmsMAT3*)m2->Double, (cmsMAT3*)m1->Double);

// Get the next in chain after the matrices
chain = Matrix2->Next;

// Remove both matrices
_RemoveElement(&Matrix2);
_RemoveElement(&Matrix1);

// Now what if the result is a plain identity?                     
if (!isFloatMatrixIdentity(&res)) {

    // We can not get rid of full matrix                            
    cmsStage* Multmat = cmsStageAllocMatrix(Lut->ContextID, 3, 3, (const cmsFloat64Number*) &res, NULL);
    if (Multmat == NULL) return FALSE;  // Should never happen

    // Recover the chain
    Multmat->Next = chain;
    *Matrix1 = Multmat;
}

isIdentityMatrix = FALSE;