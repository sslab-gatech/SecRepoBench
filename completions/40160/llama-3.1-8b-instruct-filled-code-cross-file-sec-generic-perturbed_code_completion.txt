// <MASK>
for(i=0; i<tot_extension_len; ) {
  u_int16_t extension_id;
  u_int32_t extension_len;

  if((offset+4) > packet->payload_packet_len) break;

  extension_id  = ntohs(*((u_int16_t*)&packet->payload[offset]));
  extension_len = ntohs(*((u_int16_t*)&packet->payload[offset+2]));
  if (offset+4+extension_len > packet->payload_packet_len) {
    break;
  }

  if(ja3.server.num_tls_extension < MAX_NUM_JA3)
    ja3.server.tls_extension[ja3.server.num_tls_extension++] = extension_id;

#ifdef DEBUG_TLS
  printf("TLS [server][extension_id: %u/0x%04X][len: %u]\n",
         extension_id, extension_id, extension_len);
#endif
  checkExtensions(ndpi_struct, flow, is_dtls, extension_id, extension_len, offset + 4);

  if(extension_id == 43 /* supported versions */) {
    if(extension_len >= 2) {
      u_int16_t tls_version = ntohs(*((u_int16_t*)&packet->payload[offset+4]));

#ifdef DEBUG_TLS
      printf("TLS [server] [TLS version: 0x%04X]\n", tls_version);
#endif

      flow->protos.tls_quic_stun.tls_quic.ssl_version = ja3.server.tls_supported_version = tls_version;
    }
  } else if(extension_id == 16 /* application_layer_protocol_negotiation (ALPN) */ &&
            offset + 6 < packet->payload_packet_len) {
    u_int16_t s_offset = offset+4;
    u_int16_t tot_alpn_len = ntohs(*((u_int16_t*)&packet->payload[s_offset]));
    char alpn_str[256];
    u_int8_t alpn_str_len = 0, i;

#ifdef DEBUG_TLS
    printf("Server TLS [ALPN: block_len=%u/len=%u]\n", extension_len, tot_alpn_len);
#endif
    s_offset += 2;
    tot_alpn_len += s_offset;

    if (tot_alpn_len > packet->payload_packet_len)
      return 0;

    while(s_offset < tot_alpn_len && s_offset < total_len) {
      u_int8_t alpn_i, alpn_len = packet->payload[s_offset++];

      if((s_offset + alpn_len) <= tot_alpn_len) {
#ifdef DEBUG_TLS
        printf("Server TLS [ALPN: %u]\n", alpn_len);
#endif

        if(((uint32_t)alpn_str_len+alpn_len+1) < (sizeof(alpn_str)-1)) {
          if(alpn_str_len > 0) {
            alpn_str[alpn_str_len] = ',';
            alpn_str_len++;
          }

          for(alpn_i=0; alpn_i<alpn_len; alpn_i++)
          {
            alpn_str[alpn_str_len+alpn_i] = packet->payload[s_offset+alpn_i];
          }

          s_offset += alpn_len, alpn_str_len += alpn_len;;
        } else {
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_UNCOMMON_ALPN);
          break;
        }
      } else {
        ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_UNCOMMON_ALPN);
        break;
      }
    } /* while */

    alpn_str[alpn_str_len] = '\0';

#ifdef DEBUG_TLS
    printf("Server TLS [ALPN: %s][len: %u]\n", alpn_str, alpn_str_len);
#endif
    if(flow->protos.tls_quic_stun.tls_quic.alpn == NULL)
      flow->protos.tls_quic_stun.tls_quic.alpn = ndpi_strdup(alpn_str);

    if(flow->protos.tls_quic_stun.tls_quic.alpn!= NULL)
      tlsCheckUncommonALPN(ndpi_struct, flow);

    snprintf(ja3.server.alpn, sizeof(ja3.server.alpn), "%s", alpn_str);

    /* Replace, with - as in JA3 */
    for(i=0; ja3.server.alpn[i]!= '\0'; i++)
      if(ja3.server.alpn[i] == ',') ja3.server.alpn[i] = '-';
  } else if(extension_id == 11 /* ec_point_formats groups */) {
    u_int16_t s_offset = offset+4 + 1;

#ifdef DEBUG_TLS
    printf("Server TLS [EllipticCurveFormat: len=%u]\n", extension_len);
#endif
    if((s_offset+extension_len-1) <= total_len) {
      for(i=0; i<extension_len-1 && s_offset+i<packet->payload_packet_len; i++) {
        u_int8_t s_group = packet->payload[s_offset+i];

#ifdef DEBUG_TLS
        printf("Server TLS [EllipticCurveFormat: %u]\n", s_group);
#endif

        if(ja3.server.num_elliptic_curve_point_format < MAX_NUM_JA3)
          ja3.server.elliptic_curve_point_format[ja3.server.num_elliptic_curve_point_format++] = s_group;
        else {
          invalid_ja3 = 1;
#ifdef DEBUG_TLS
          printf("Server TLS Invalid num elliptic %u\n", ja3.server.num_elliptic_curve_point_format);
#endif
        }
      }
    } else {
      invalid_ja3 = 1;
#ifdef DEBUG_TLS
      printf("Server TLS Invalid len %u vs %u\n", s_offset+extension_len, total_len);
#endif
    }
  }

  i += 4 + extension_len, offset += 4 + extension_len;
} /* for */