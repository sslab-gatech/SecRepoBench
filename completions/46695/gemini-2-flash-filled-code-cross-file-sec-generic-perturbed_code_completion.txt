if (encoding != (char *) NULL)
    {
      if (LocaleCompare(encoding,"AdobeCustom") == 0)
        encoding_type=FT_ENCODING_ADOBE_CUSTOM;
      else if (LocaleCompare(encoding,"AdobeExpert") == 0)
        encoding_type=FT_ENCODING_ADOBE_EXPERT;
      else if (LocaleCompare(encoding,"AdobeStandard") == 0)
        encoding_type=FT_ENCODING_ADOBE_STANDARD;
      else if (LocaleCompare(encoding,"AppleRoman") == 0)
        encoding_type=FT_ENCODING_APPLE_ROMAN;
      else if (LocaleCompare(encoding,"Latin1") == 0)
        encoding_type=FT_ENCODING_OLD_LATIN_1;
      else if (LocaleCompare(encoding,"None") == 0)
        encoding_type=FT_ENCODING_NONE;
      else if (LocaleCompare(encoding,"Symbol") == 0)
        encoding_type=FT_ENCODING_MS_SYMBOL;
      else if (LocaleCompare(encoding,"Unicode") == 0)
        encoding_type=FT_ENCODING_UNICODE;
      ft_status=FT_Select_Charmap(face,encoding_type);
      if (ft_status != 0)
        {
          (void) FT_Done_Face(face);
          (void) FT_Done_FreeType(library);
          ThrowFreetypeErrorException("UnableToSelectFontEncoding",ft_status,
            encoding);
          return(MagickFalse);
        }
    }
  /*
    Set character size.
  */
  resolution.x=(double) draw_info->density.x;
  resolution.y=(double) draw_info->density.y;
  if ((resolution.x == 0.0) || (resolution.y == 0.0))
    {
      resolution.x=DefaultResolution;
      resolution.y=DefaultResolution;
    }
  if (draw_info->density.x != draw_info->density.y)
    resolution.y=draw_info->density.x;
  ft_status=FT_Set_Char_Size(face,(FT_F26Dot6) (draw_info->pointsize*64.0),
    (FT_UInt) (resolution.x+0.5),(FT_UInt) (resolution.y+0.5));
  if (ft_status != 0)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      ThrowFreetypeErrorException("UnableToSetFontSize",ft_status,
        draw_info->font);
      return(MagickFalse);
    }
  /*
    Determine font metrics.
  */
  metrics->ascent=(double) face->size->metrics.ascender/64.0;
  metrics->descent=(double) face->size->metrics.descender/64.0;
  metrics->width=(double) face->size->metrics.max_width/64.0;
  metrics->height=(double) face->size->metrics.max_height/64.0;
  metrics->max_advance=(double) face->size->metrics.max_advance/64.0;
  if (metrics->ascent < 0.0)
    metrics->ascent=fabs(metrics->ascent);
  if (metrics->descent > 0.0)
    metrics->descent=(-fabs(metrics->descent));
  metrics->underline_position=(double) face->underline_position/64.0;
  metrics->underline_thickness=(double) face->underline_thickness/64.0;
  if ((draw_info->text == (char *) NULL) || (*draw_info->text == '\0'))
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      return(MagickTrue);
    }
  /*
    Prepare rendering options.
  */
  flags=FT_LOAD_DEFAULT;
  if (image->antialias != MagickFalse)
    flags|=FT_LOAD_TARGET_LIGHT;
  if (draw_info->hinting == MagickFalse)
    flags|=FT_LOAD_NO_HINTING;
  if (image->colorspace == CMYKColorspace)
    flags|=FT_LOAD_TARGET_MONO;
  /*
    Initialize glyph info.
  */
  (void) memset(&glyph,0,sizeof(glyph));
  /*
    Set affine transformation.
  */
  affine.xx=(FT_Fixed) (draw_info->affine.sx*65536.0);
  affine.xy=(FT_Fixed) (draw_info->affine.rx*65536.0);
  affine.yx=(FT_Fixed) (draw_info->affine.ry*65536.0);
  affine.yy=(FT_Fixed) (draw_info->affine.sy*65536.0);
  FT_Set_Transform(face,&affine,&origin);
  /*
    Allocate grapheme info.
  */
  grapheme=(GraphemeInfo *) NULL;
  length=ComplexTextLayout(image,draw_info,draw_info->text,strlen(
    draw_info->text),face,flags,&grapheme,exception);
  if (length == 0)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      return(MagickFalse);
    }
  /*
    Render each glyph.
  */
  last_character=0;
  point=(*offset);
  bounds.xMin = 32767*64;
  bounds.yMin = 32767*64;
  bounds.xMax = -32767*64;
  bounds.yMax = -32767*64;
  utf8=(unsigned char *) draw_info->text;
  for (i=0; i < (ssize_t) length; i++)
  {
    code=(ssize_t) GetUTFCode((char *) utf8+grapheme[i].cluster);
    glyph.id=(FT_UInt) grapheme[i].index;
    if (glyph.id == 0)
      glyph.id=face->face_index;
    ft_status=FT_Load_Glyph(face,glyph.id,flags);
    if (ft_status != 0)
      continue;
    glyph.origin.x=(FT_Pos) point.x;
    glyph.origin.y=(FT_Pos) point.y;
    if (draw_info->kerning != 0.0)
      glyph.origin.x+=(FT_Pos) (draw_info->kerning*i);
    glyph.origin.x+=(FT_Pos) grapheme[i].x_offset;
    glyph.origin.y+=(FT_Pos) grapheme[i].y_offset;
    ft_status=FT_Get_Glyph(face->glyph,&glyph.image);
    if (ft_status != 0)
      continue;
    if (draw_info->undercolor.opacity != OpaqueOpacity)
      {
        annotate_info=CloneDrawInfo(draw_info,(const DrawInfo *) NULL);
        annotate_info->fill=draw_info->undercolor;
        if (glyph.image->clazz->glyph_class == &FT_Glyph_Class)
          {
            FT_OutlineGlyph
              outline_glyph;

            /*
              Draw glypth to trace its outline.
            */
            outline_glyph=(FT_OutlineGlyph) glyph.image;
            (void) FT_Outline_Get_BBox(&outline_glyph->outline,&bounds);
            (void) FT_Outline_Decompose(&outline_glyph->outline,&OutlineMethods,
              (void *) annotate_info);
          }
        else
          if (glyph.image->clazz->glyph_class == &FT_Bitmap_Class)
            {
              bitmap=(FT_BitmapGlyph) glyph.image;
              point.x+=(double) bitmap->left;
              point.y+=metrics->ascent-(double) bitmap->top;
              (void) DrawImage(image,annotate_info,point.x,point.y,0,0,
                bitmap->bitmap.width,bitmap->bitmap.rows);
            }
        annotate_info=DestroyDrawInfo(annotate_info);
      }
    if (glyph.image->clazz->glyph_class == &FT_Glyph_Class)
      {
        /*
          Render FreeType outline.
        */
        if (image->colorspace == CMYKColorspace)
          {
            FT_BBox
              bbox;

            FT_OutlineGlyph
              outline_glyph;

            /*
              Draw glypth to trace its outline.
            */
            outline_glyph=(FT_OutlineGlyph) glyph.image;
            (void) FT_Outline_Get_BBox(&outline_glyph->outline,&bbox);
            (void) FT_Outline_Decompose(&outline_glyph->outline,&OutlineMethods,
              (void *) draw_info);
          }
        else
          {
            FT_Outline_Translate(&((FT_OutlineGlyph) glyph.image)->outline,
              glyph.origin.x,glyph.origin.y);
            ft_status=FT_Glyph_To_Bitmap(&glyph.image,FT_RENDER_MODE_NORMAL,0,1);
            if (ft_status != 0)
              continue;
            bitmap=(FT_BitmapGlyph) glyph.image;
            point.x+=(double) bitmap->left;
            point.y+=metrics->ascent-(double) bitmap->top;
            (void) DrawImage(image,draw_info,point.x,point.y,0,0,
              bitmap->bitmap.width,bitmap->bitmap.rows);
          }
      }
    else
      if (glyph.image->clazz->glyph_class == &FT_Bitmap_Class)
        {
          /*
            Render FreeType bitmap.
          */
          bitmap=(FT_BitmapGlyph) glyph.image;
          point.x+=(double) bitmap->left;
          point.y+=metrics->ascent-(double) bitmap->top;
          (void) DrawImage(image,draw_info,point.x,point.y,0,0,
            bitmap->bitmap.width,bitmap->bitmap.rows);
        }
    FT_Done_Glyph(glyph.image);
    point.x+=(double) (grapheme[i].x_advance/64.0);
    if (draw_info->direction == RightToLeftDirection)
      point.x-=(double) (face->glyph->advance.x/64.0);
    if (face->glyph->metrics.horiBearingY > bounds.yMax)
      bounds.yMax = face->glyph->metrics.horiBearingY;
    if (face->glyph->metrics.horiBearingY < bounds.yMin)
      bounds.yMin = face->glyph->metrics.horiBearingY;
    if ((face->glyph->metrics.horiBearingX+face->glyph->metrics.width) > bounds.xMax)
      bounds.xMax = face->glyph->metrics.horiBearingX+face->glyph->metrics.width;
    if (face->glyph->metrics.horiBearingX < bounds.xMin)
      bounds.xMin = face->glyph->metrics.horiBearingX;
    last_character=(ssize_t) code;
  }
  /*
    Normalize font metrics.
  */
  metrics->bounds.x=bounds.xMin/64.0;
  metrics->bounds.y=bounds.yMin/64.0;
  metrics->bounds.width=(bounds.xMax/64.0)-(bounds.xMin/64.0);
  grapheme=(GraphemeInfo *) RelinquishMagickMemory(grapheme);
  (void) FT_Done_Face(face);
  (void) FT_Done_FreeType(library);
  return(MagickTrue);
#else
  magick_unreferenced(img);
  magick_unreferenced(draw_info);
  magick_unreferenced(encoding);
  magick_unreferenced(offset);
  magick_unreferenced(metrics);
  magick_unreferenced(exception);
  return(MagickFalse);
#endif