if (encoding != (char *) NULL)
    {
      if (LocaleCompare(encoding,"AdobeCustom") == 0)
        encoding_type=FT_ENCODING_ADOBE_CUSTOM;
      if (LocaleCompare(encoding,"AdobeExpert") == 0)
        encoding_type=FT_ENCODING_ADOBE_EXPERT;
      if (LocaleCompare(encoding,"AdobeStandard") == 0)
        encoding_type=FT_ENCODING_ADOBE_STANDARD;
      if (LocaleCompare(encoding,"AppleRoman") == 0)
        encoding_type=FT_ENCODING_APPLE_ROMAN;
      if (LocaleCompare(encoding,"Big5") == 0)
        encoding_type=FT_ENCODING_BIG5;
      if (LocaleCompare(encoding,"GB2312") == 0)
        encoding_type=FT_ENCODING_GB2312;
      if (LocaleCompare(encoding,"Johab") == 0)
        encoding_type=FT_ENCODING_JOHAB;
      if (LocaleCompare(encoding,"SJIScode") == 0)
        encoding_type=FT_ENCODING_SJIS;
      if (LocaleCompare(encoding,"Symbol") == 0)
        encoding_type=FT_ENCODING_MS_SYMBOL;
      if (LocaleCompare(encoding,"Unicode") == 0)
        encoding_type=FT_ENCODING_UNICODE;
      if (LocaleCompare(encoding,"Wansung") == 0)
        encoding_type=FT_ENCODING_WANSUNG;
      ft_status=FT_Select_Charmap(face,encoding_type);
      if (ft_status != 0)
        ThrowFreetypeErrorException("UnrecognizedFontEncoding",ft_status,
          encoding);
    }
  if ((draw_info->text == (char *) NULL) || (*draw_info->text == '\0'))
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      stream->close=NULL;
      stream=RelinquishMagickMemory(stream);
      return(MagickFalse);
    }
  resolution.x=DefaultResolution;
  resolution.y=DefaultResolution;
  if (draw_info->density != (char *) NULL)
    {
      GeometryInfo
        geometry_info;

      MagickStatusType
        flags;

      flags=ParseGeometry(draw_info->density,&geometry_info);
      resolution.x=geometry_info.rho;
      resolution.y=resolution.x;
      if ((flags & SigmaValue) != 0)
        resolution.y=geometry_info.sigma;
    }
  ft_status=FT_Set_Char_Size(face,(FT_F26Dot6)(64.0*draw_info->pointsize),
    (FT_F26Dot6)(64.0*draw_info->pointsize),(FT_UInt) resolution.x,(FT_UInt)
    resolution.y);
  if (ft_status != 0)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      stream->close=NULL;
      stream=RelinquishMagickMemory(stream);
      ThrowFreetypeErrorException("UnableToSetFreetypeCharacterSize",ft_status,
        draw_info->text);
      return(MagickFalse);
    }
  metrics->pixels_per_em.x=(resolution.y/DefaultResolution)*
    ExpandAffine(&draw_info->affine)*draw_info->pointsize;
  metrics->pixels_per_em.y=metrics->pixels_per_em.x;
  metrics->ascent=face->size->metrics.ascender/64.0;
  metrics->descent=face->size->metrics.descender/64.0;
  metrics->width=0;
  metrics->height=0;
  metrics->max_advance=0.0;
  metrics->bounds.x1=0.0;
  metrics->bounds.y1=0.0;
  metrics->bounds.x2=0.0;
  metrics->bounds.y2=0.0;
  if (face->size->metrics.ascender > 16384)
    metrics->ascent=face->size->metrics.ascender/65536.0;
  if (face->size->metrics.descender > 16384)
    metrics->descent=face->size->metrics.descender/65536.0;
  metrics->underline_position=face->underline_position/64.0;
  metrics->underline_thickness=face->underline_thickness/64.0;
  if ((draw_info->text == (char *) NULL) || (*draw_info->text == '\0') ||
      (face->glyph == (FT_GlyphSlot) NULL))
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      stream->close=NULL;
      stream=RelinquishMagickMemory(stream);
      return(MagickFalse);
    }
  /*
    Compute the bounding box.
  */
  annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
  annotate_info->render=MagickFalse;
  annotate_info->text=DestroyString(annotate_info->text);
  flags=FT_LOAD_DEFAULT;
  if (draw_info->text_antialias == MagickFalse)
    flags|=FT_LOAD_TARGET_MONO;
  value=GetImageProperty(img,"type:hinting",exception);
  if ((value != (const char *) NULL) && (IsStringTrue(value) == MagickFalse))
    flags|=FT_LOAD_NO_HINTING;
  value=GetImageProperty(img,"type:autohint",exception);
  if ((value != (const char *) NULL) && (IsStringTrue(value) != MagickFalse))
    flags|=FT_LOAD_FORCE_AUTOHINT;
  length=strlen(draw_info->text);
  utf8=ConvertLatin1ToUTF8((unsigned char *) draw_info->text);
  if (utf8 != (unsigned char *) NULL)
    length=strlen((char *) utf8);
  grapheme=(GraphemeInfo *) NULL;
  if (draw_info->direction != UndefinedDirection)
    length=ComplexTextLayout(img,draw_info,(char *) utf8,length,face,flags,
      &grapheme,exception);
  if (utf8 != (unsigned char *) NULL)
    utf8=(unsigned char *) RelinquishMagickMemory(utf8);
  (void) memset(&glyph,0,sizeof(glyph));
  last_character=0;
  first_glyph_id=0;
  last_glyph_id=0;
  missing_glyph_id=0;
  affine.xx=65536L;
  affine.yx=0L;
  affine.xy=0L;
  affine.yy=65536L;
  for (i=0; i < (ssize_t) length; i++)
  {
    if (draw_info->direction == UndefinedDirection)
      code=GetUTFCode(draw_info->text+i);
    else
      code=GetUTFCode((char *) utf8+i);
    if (code == 0)
      break;
    p=draw_info->text+i;
    if (draw_info->direction != UndefinedDirection)
      {
        p=(char *) utf8+i;
        glyph.id=grapheme[i].index;
        glyph.origin.x=grapheme[i].x_offset;
        glyph.origin.y=grapheme[i].y_offset;
      }
    else
      {
        glyph.id=FT_Get_Char_Index(face,code);
        glyph.origin.x=0L;
        glyph.origin.y=0L;
      }
    if (((glyph.id != 0) && (last_glyph_id != 0)) && (FT_HAS_KERNING(face)))
      {
        FT_Vector
          kerning;

        ft_status=FT_Get_Kerning(face,(FT_UInt) last_glyph_id,(FT_UInt)
          glyph.id,ft_kerning_default,&kerning);
        if (ft_status == 0)
          origin.x+=(FT_Pos) ((draw_info->direction == RightToLeftDirection ?
            -1.0 : 1.0)*kerning.x);
      }
    ft_status=FT_Load_Glyph(face,(FT_UInt) glyph.id,flags);
    if (ft_status != 0)
      {
        const char
          *error_string=FreetypeErrorMessage(ft_status);

        if (error_string != (const char *) NULL)
          (void) ThrowMagickException(exception,GetMagickModule(),TypeError,
            "UnableToLoadGlyph", "`%s (%s)'", p, error_string);
        else
          (void) ThrowMagickException(exception,GetMagickModule(),TypeError,
            "UnableToLoadGlyph", "`%s'",p);
        if (missing_glyph_id == 0)
          missing_glyph_id=glyph.id;
        glyph.id=missing_glyph_id;
        ft_status=FT_Load_Glyph(face,glyph.id,flags);
        if (ft_status != 0)
          continue;
      }
    ft_status=FT_Get_Glyph(face->glyph,&glyph.image);
    if (ft_status != 0)
      continue;
    /*
      Transform glyph.
    */
    if (draw_info->render != MagickFalse)
      {
        FT_Vector
          point;

        point.x=glyph.origin.x;
        point.y=glyph.origin.y;
        FT_Vector_Transform(&point,&affine);
        origin.x+=point.x;
        origin.y+=point.y;
        FT_Glyph_Transform(glyph.image,&affine,&origin);
      }
    /*
      Get bounding box.
    */
    if (draw_info->render != MagickFalse)
      FT_Glyph_Get_CBox(glyph.image,ft_glyph_bbox_pixels,&bounds);
    else
      {
        FT_Outline
          outline;

        if (glyph.image->format != FT_GLYPH_FORMAT_OUTLINE)
          {
            ft_status=FT_Glyph_To_Bitmap(&glyph.image,FT_RENDER_MODE_NORMAL,
              (FT_Vector *) NULL,MagickTrue);
            if (ft_status != 0)
              continue;
          }
        bitmap=(FT_BitmapGlyph) glyph.image;
        bounds.xMin=bitmap->left*64;
        bounds.yMin=bitmap->top*64;
        bounds.xMax=(bitmap->left+bitmap->bitmap.width)*64;
        bounds.yMax=(bitmap->top+bitmap->bitmap.rows)*64;
        FT_Vector_Transform(&bounds.xMin,&affine);
        FT_Vector_Transform(&bounds.xMax,&affine);
        FT_Vector_Transform(&bounds.yMin,&affine);
        FT_Vector_Transform(&bounds.yMax,&affine);
        origin.x=0;
        origin.y=0;
        outline=face->glyph->outline;
        if (IsEmptyOutline(outline) == MagickFalse)
          {
            annotate_info->affine.tx=offset->x+((origin.x/64.0)+
              annotate_info->affine.ry*metrics->ascent);
            annotate_info->affine.ty=offset->y+((origin.y/64.0)-
              annotate_info->affine.sy*metrics->ascent);
            (void) FT_Outline_Decompose(&outline,&OutlineMethods,
              annotate_info);
            (void) ConcatenateString(&annotate_info->primitive,"h\n");
          }
      }
    if (i == 0)
      {
        metrics->bounds=bounds;
        metrics->origin=origin;
      }
    else
      {
        if (bounds.xMin < metrics->bounds.xMin)
          metrics->bounds.xMin=bounds.xMin;
        if (bounds.yMin < metrics->bounds.yMin)
          metrics->bounds.yMin=bounds.yMin;
        if (bounds.xMax > metrics->bounds.xMax)
          metrics->bounds.xMax=bounds.xMax;
        if (bounds.yMax > metrics->bounds.yMax)
          metrics->bounds.yMax=bounds.yMax;
      }
    if (draw_info->direction != UndefinedDirection)
      origin.x+=grapheme[i].x_advance;
    else
      origin.x+=face->glyph->advance.x;
    if (origin.x > metrics->max_advance)
      metrics->max_advance=origin.x;
    last_character=code;
    last