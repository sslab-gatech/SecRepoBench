if (encoding != (const char *) NULL)
  {
    if (LocaleCompare(encoding,"UTF-8") == 0)
      encoding_type=FT_ENCODING_UNICODE;
    else
      if (LocaleCompare(encoding,"UNICODE") == 0)
        encoding_type=FT_ENCODING_UNICODE;
      else
        if ((LocaleCompare(encoding,"ISO-8859-1") == 0) ||
            (LocaleCompare(encoding,"LATIN-1") == 0))
          encoding_type=FT_ENCODING_ADOBE_LATIN_1;
        else
          if (LocaleCompare(encoding,"SYMBOL") == 0)
            encoding_type=FT_ENCODING_ADOBE_CUSTOM;
    ft_status=FT_Select_Charmap(face,encoding_type);
    if (ft_status != 0)
      {
        (void) FT_Done_Face(face);
        (void) FT_Done_FreeType(library);
        ThrowFreetypeErrorException("UnableToSetEncoding",ft_status,encoding);
        return(MagickFalse);
      }
  }
  resolution.x=DefaultResolution;
  resolution.y=DefaultResolution;
  if (draw_info->density != (char *) NULL)
    {
      GeometryInfo
        geometry_info;

      MagickStatusType
        flags;

      flags=ParseGeometry(draw_info->density,&geometry_info);
      resolution.x=geometry_info.rho;
      resolution.y=geometry_info.sigma;
      if ((flags & SigmaValue) == 0)
        resolution.y=resolution.x;
    }
  ft_status=FT_Set_Char_Size(face,(FT_F26Dot6) (64.0*draw_info->pointsize),
    (FT_F26Dot6) (64.0*draw_info->pointsize),(FT_UInt) resolution.x,
    (FT_UInt) resolution.y);
  if (ft_status != 0)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      ThrowFreetypeErrorException("UnableToSetPointSize",ft_status,
        draw_info->font);
      return(MagickFalse);
    }
  metrics->pixels_per_em.x=face->size->metrics.x_ppem;
  metrics->pixels_per_em.y=face->size->metrics.y_ppem;
  metrics->ascent=(double) face->size->metrics.ascender/64.0;
  metrics->descent=(double) face->size->metrics.descender/64.0;
  metrics->width=0;
  metrics->origin.x=0;
  metrics->origin.y=0;
  metrics->height=(double) face->size->metrics.height/64.0;
  metrics->max_advance=(double) face->size->metrics.max_advance/64.0;
  if (face->size->metrics.ascender == 0)
    metrics->ascent=(double) face->ascender*metrics->pixels_per_em.y/
      face->units_per_EM;
  if (face->size->metrics.descender == 0)
    metrics->descent=-(double) face->descender*metrics->pixels_per_em.y/
      face->units_per_EM;
  if (face->size->metrics.height == 0)
    metrics->height=(double) face->height*metrics->pixels_per_em.y/
      face->units_per_EM;
  if (face->size->metrics.max_advance == 0)
    metrics->max_advance=(double) face->max_advance_width*
      metrics->pixels_per_em.x/face->units_per_EM;
  metrics->underline_position=face->underline_position*metrics->pixels_per_em.x/
    face->units_per_EM;
  metrics->underline_thickness=face->underline_thickness*
    metrics->pixels_per_em.x/face->units_per_EM;
  if ((draw_info->text == (char *) NULL) || (*draw_info->text == '\0') ||
      (face->glyph->metrics.width == 0) || (face->glyph->metrics.height == 0))
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      return(MagickTrue);
    }
  /*
    Render text.
  */
  flags=FT_LOAD_DEFAULT;
  if (draw_info->render == MagickFalse)
    flags|=FT_LOAD_NO_BITMAP;
  if (img->storage_class == PseudoClass)
    flags|=FT_LOAD_MONOCHROME;
  else
    if (draw_info->text_antialias == MagickFalse)
      flags|=FT_LOAD_TARGET_MONO;
    else
      flags|=FT_LOAD_TARGET_NORMAL;
  if (draw_info->style & NoAutohintStyle)
    flags|=FT_LOAD_NO_AUTOHINT;
  else
    if (draw_info->style & AutohintStyle)
      flags|=FT_LOAD_FORCE_AUTOHINT;
  grapheme=(GraphemeInfo *) NULL;
  length=ComplexTextLayout(img,draw_info,draw_info->text,
    strlen(draw_info->text),face,flags,&grapheme,exception);
  if (length == 0)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      return(MagickTrue);
    }
  status=MagickTrue;
  origin.x=0;
  origin.y=0;
  affine.xx=65536L;
  affine.yx=0L;
  affine.xy=0L;
  affine.yy=65536L;
  if (draw_info->render != MagickFalse)
    {
      if (draw_info->fill.alpha != TransparentAlpha)
        status=DrawImage(img,draw_info,exception);
      annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
      if (annotate_info == (DrawInfo *) NULL)
        return(MagickFalse);
      (void) CloneString(&annotate_info->text,draw_info->text);
      annotate_info->fill=draw_info->undercolor;
      annotate_info->affine=draw_info->affine;
      annotate_info->affine.tx=0.0;
      annotate_info->affine.ty=0.0;
      (void) DrawImage(img,annotate_info,exception);
      annotate_info=DestroyDrawInfo(annotate_info);
    }
  if (draw_info->stroke.alpha != TransparentAlpha)
    {
      /*
        Trace the outline of each character.
      */
      annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
      if (annotate_info == (DrawInfo *) NULL)
        return(MagickFalse);
      annotate_info->fill.alpha=TransparentAlpha;
      (void) CloneString(&annotate_info->text,draw_info->text);
      annotate_info->affine=draw_info->affine;
      annotate_info->affine.tx=0.0;
      annotate_info->affine.ty=0.0;
      (void) DrawImage(img,annotate_info,exception);
      annotate_info=DestroyDrawInfo(annotate_info);
    }
  point.x=0.0;
  point.y=0.0;
  for (i=0; i < (ssize_t) length; i++)
  {
    FT_Outline
      outline;

    /*
      Render this glyph.
    */
    glyph.id=grapheme[i].index;
    glyph.origin=origin;
    glyph.origin.x+=grapheme[i].x_offset;
    glyph.origin.y-=grapheme[i].y_offset;
    ft_status=FT_Load_Glyph(face,glyph.id,flags);
    if (ft_status != 0)
      continue;
    ft_status=FT_Get_Glyph(face->glyph,&glyph.image);
    if (ft_status != 0)
      continue;
    outline=((FT_OutlineGlyph) glyph.image)->outline;
    ft_status=FT_Outline_Get_BBox(&outline,&bounds);
    if (ft_status == 0)
      {
        if ((p == draw_info->text) || (bounds.xMin < metrics->bounds.x1))
          metrics->bounds.x1=(double) bounds.xMin;
        if ((p == draw_info->text) || (bounds.yMin < metrics->bounds.y1))
          metrics->bounds.y1=(double) bounds.yMin;
        if ((p == draw_info->text) || (bounds.xMax > metrics->bounds.x2))
          metrics->bounds.x2=(double) bounds.xMax;
        if ((p == draw_info->text) || (bounds.yMax > metrics->bounds.y2))
          metrics->bounds.y2=(double) bounds.yMax;
      }
    if (((draw_info->stroke.alpha != TransparentAlpha) ||
         (draw_info->stroke_pattern != (Image *) NULL)) &&
        ((status != MagickFalse) && (draw_info->render != MagickFalse)))
      {
        /*
          Trace the outline of this glyph.
        */
        annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
        if (annotate_info == (DrawInfo *) NULL)
          return(MagickFalse);
        annotate_info->fill.alpha=TransparentAlpha;
        (void) CloneString(&annotate_info->text,"");
        annotate_info->primitive=AcquireString("");
        (void) FormatLocaleString(annotate_info->primitive,MagickPathExtent,
          "path '");
        (void) FT_Outline_Decompose(&outline,&OutlineMethods,annotate_info);
        (void) ConcatenateString(&annotate_info->primitive,"'");
        annotate_info->affine.tx=glyph.origin.x/64.0;
        annotate_info->affine.ty=(-glyph.origin.y/64.0);
        (void) DrawImage(img,annotate_info,exception);
        annotate_info=DestroyDrawInfo(annotate_info);
      }
    FT_Done_Glyph(glyph.image);
    origin.x+=(FT_Pos) grapheme[i].x_advance;
    origin.y+=(FT_Pos) grapheme[i].y_advance;
    if ((origin.x >> 6) >= (ssize_t) img->columns)
      break;
  }
  for (i=0; i < (ssize_t) length; i++)
    if (grapheme[i].cluster != (size_t) i)
      break;
  if ((i == (ssize_t) length) && (draw_info->direction == RightToLeftDirection))
    {
      FT_Vector
        offset;

      offset.x=(FT_Pos) (origin.x-grapheme[length-1].x_advance);
      offset.y=0;
      for (i=0; i < (ssize_t) length; i++)
      {
        grapheme[i].x_offset+=(double) offset.x;
        grapheme[i].y_offset+=(double) offset.y;
      }
    }
  metrics->widt