if (encoding != (const char *) NULL)
  {
    if (LocaleCompare(encoding,"UTF-8") == 0)
      encoding_type=FT_ENCODING_UNICODE;
    else
      if ((LocaleCompare(encoding,"AdobeCustom") == 0) ||
          (LocaleCompare(encoding,"AdobeExpert") == 0) ||
          (LocaleCompare(encoding,"AdobeStandard") == 0))
        encoding_type=FT_ENCODING_ADOBE_CUSTOM;
      else
        if (LocaleCompare(encoding,"AppleRoman") == 0)
          encoding_type=FT_ENCODING_APPLE_ROMAN;
        else
          if (LocaleCompare(encoding,"BIG5") == 0)
            encoding_type=FT_ENCODING_BIG5;
          else
            if (LocaleCompare(encoding,"GB2312") == 0)
              encoding_type=FT_ENCODING_PRC;
            else
              if ((LocaleCompare(encoding,"Johab") == 0) ||
                  (LocaleCompare(encoding,"UCS-2") == 0) ||
                  (LocaleCompare(encoding,"UCS-4") == 0))
                encoding_type=FT_ENCODING_UNICODE;
              else
                if (LocaleCompare(encoding,"SJIScode") == 0)
                  encoding_type=FT_ENCODING_SJIS;
                else
                  if (LocaleCompare(encoding,"Symbol") == 0)
                    encoding_type=FT_ENCODING_MS_SYMBOL;
                  else
                    if (LocaleCompare(encoding,"Unicode") == 0)
                      encoding_type=FT_ENCODING_UNICODE;
                    else
                      if (LocaleCompare(encoding,"Wansung") == 0)
                        encoding_type=FT_ENCODING_WANSUNG;
    ft_status=FT_Select_Charmap(face,encoding_type);
    if (ft_status != 0)
      {
        (void) FT_Done_Face(face);
        (void) FT_Done_FreeType(library);
        ThrowFreetypeErrorException("UnableToSetEncoding",ft_status,
          encoding);
      }
  }
  /*
    Set text size.
  */
  resolution.x=DefaultResolution;
  resolution.y=DefaultResolution;
  if (draw_info->density != (char *) NULL)
    {
      GeometryInfo
        geometry_info;

      MagickStatusType
        flags;

      flags=ParseGeometry(draw_info->density,&geometry_info);
      if ((flags & RhoValue) != 0)
        resolution.x=geometry_info.rho;
      resolution.y=resolution.x;
      if ((flags & SigmaValue) != 0)
        resolution.y=geometry_info.sigma;
    }
  ft_status=FT_Set_Char_Size(face,(FT_F26Dot6) (64.0*draw_info->pointsize),
    (FT_F26Dot6) (64.0*draw_info->pointsize),(FT_UInt) resolution.x,
    (FT_UInt) resolution.y);
  if (ft_status != 0)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      ThrowFreetypeErrorException("UnableToSetTextSize",ft_status,
        draw_info->font);
    }
  metrics->pixels_per_em.x=face->size->metrics.x_ppem;
  metrics->pixels_per_em.y=face->size->metrics.y_ppem;
  metrics->ascent=(double) face->size->metrics.ascender/64.0;
  metrics->descent=(double) face->size->metrics.descender/64.0;
  metrics->width=0;
  metrics->origin.x=0;
  metrics->origin.y=0;
  metrics->height=(double) face->size->metrics.height/64.0;
  metrics->max_advance=(double) face->size->metrics.max_advance/64.0;
  if (face->size->metrics.ascender == 0)
    {
      metrics->ascent=(double) face->ascender/64.0;
      metrics->descent=(double) face->descender/64.0;
      metrics->height=(double) face->height/64.0;
    }
  if ((metrics->ascent == 0.0) && (metrics->descent == 0.0))
    {
      metrics->ascent=(double) face->bbox.yMax;
      metrics->descent=-(double) face->bbox.yMin;
      metrics->height=metrics->ascent-metrics->descent;
    }
  metrics->underline_position=face->underline_position/64.0;
  metrics->underline_thickness=face->underline_thickness/64.0;
  if ((draw_info->text == (char *) NULL) || (*draw_info->text == '\0') ||
      (face->glyph == (FT_GlyphSlot) NULL))
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      return(MagickTrue);
    }
  /*
    Render text.
  */
  flags=FT_LOAD_DEFAULT;
  if (draw_info->render == MagickFalse)
    flags=FT_LOAD_NO_BITMAP;
  if (draw_info->text_antialias == MagickFalse)
    flags|=FT_LOAD_TARGET_MONO;
  else
    {
      if (img->storage_class == PseudoClass)
        flags|=FT_LOAD_TARGET_NORMAL;
      else
        flags|=FT_LOAD_TARGET_LCD;
    }
  value=GetImageProperty(img,"type:hinting",exception);
  if ((value != (const char *) NULL) && (LocaleCompare(value,"off") == 0))
    flags|=FT_LOAD_NO_HINTING;
  glyph.id=0;
  glyph.image=NULL;
  last_glyph_id=0;
  origin.x=0;
  origin.y=0;
  affine.xx=65536L;
  affine.yx=0L;
  affine.xy=0L;
  affine.yy=65536L;
  if (draw_info->render != MagickFalse)
    {
      affine.xx=(FT_Fixed) (65536L*draw_info->affine.sx+0.5);
      affine.yx=(FT_Fixed) (-65536L*draw_info->affine.rx+0.5);
      affine.xy=(FT_Fixed) (-65536L*draw_info->affine.ry+0.5);
      affine.yy=(FT_Fixed) (65536L*draw_info->affine.sy+0.5);
    }
  annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
  if (annotate_info->dash_pattern != (double *) NULL)
    annotate_info->dash_pattern[0]=0.0;
  (void) CloneString(&annotate_info->primitive,"path '");
  status=MagickTrue;
  if (draw_info->render != MagickFalse)
    {
      if (img->alpha_trait != BlendPixelTrait)
        (void) SetImageAlphaChannel(img,OpaqueAlphaChannel,exception);
      status&=SetImageProgress(img,RenderFreetypeText,0,
        GetImageListLength(img));
    }
  utf8=(unsigned char *) NULL;
  if ((encoding != (const char *) NULL) &&
      (LocaleCompare(encoding,"UTF-8") != 0))
    utf8=ConvertLatin1ToUTF8((unsigned char *) draw_info->text);
  if (utf8 != (unsigned char *) NULL)
    {
      grapheme=ComplexTextLayout(img,draw_info,(char *) utf8,
        strlen((char *) utf8),face,flags,&length,exception);
      utf8=(unsigned char *) RelinquishMagickMemory(utf8);
    }
  else
    grapheme=ComplexTextLayout(img,draw_info,draw_info->text,
      strlen(draw_info->text),face,flags,&length,exception);
  if (grapheme == (GraphemeInfo *) NULL)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      annotate_info=DestroyDrawInfo(annotate_info);
      return(MagickFalse);
    }
  for (i=0; i < (ssize_t) length; i++)
  {
    /*
      Render UTF-8 sequence.
    */
    glyph.id=grapheme[i].index;
    if (glyph.id == 0)
      glyph.id=FT_Get_Char_Index(face,'?');
    if ((glyph.id != 0) && (last_glyph_id != 0) && (draw_info->kerning != 0))
      {
        if (FT_HAS_KERNING(face))
          {
            FT_Vector
              kerning;

            ft_status=FT_Get_Kerning(face,last_glyph_id,glyph.id,
              ft_kerning_default,&kerning);
            if (ft_status == 0)
              origin.x+=((FT_Pos) (draw_info->direction == RightToLeftDirection
                ? -kerning.x : kerning.x));
          }
      }
    last_glyph_id=glyph.id;
    ft_status=FT_Load_Glyph(face,glyph.id,flags);
    if (ft_status != 0)
      continue;
    ft_status=FT_Get_Glyph(face->glyph,&glyph.image);
    if (ft_status != 0)
      continue;
    ft_status=FT_Outline_Get_BBox(&((FT_OutlineGlyph) glyph.image)->outline,
      &bounds);
    if (ft_status != 0)
      continue;
    if ((bounds.xMin < metrics->bounds.x1) && (bounds.xMin != 0))
      metrics->bounds.x1=bounds.xMin;
    if ((bounds.yMin < metrics->bounds.y1) && (bounds.yMin != 0))
      metrics->bounds.y1=bounds.yMin;
    if ((bounds.xMax > metrics->bounds.x2) && (bounds.xMax != 0))
      metrics->bounds.x2=bounds.xMax;
    if ((bounds.yMax > metrics->bounds.y2) && (bounds.yMax != 0))
      metrics->bounds.y2=bounds.yMax;
    if (((draw_info->stroke.alpha != TransparentAlpha) ||
         (draw_info->stroke_pattern != (Image *) NULL)) &&
        ((status != MagickFalse) && (draw_info->render != MagickFalse)))
      {
        /*
          Trace the glyph.
        */
        annotate_info->affine.tx=offset->x+origin.x/64.0;
        annotate_info->affine.ty=offset->y-origin.y/64.0;
        (void) FT_Outline_Decompose(&((FT_OutlineGlyph) glyph.image)->outline,
          &OutlineMethods,annotate_info);
      }
    FT_Vector_Transform(&glyph.origin,&affine);
    (void) FT_Glyph_Transform(glyph.image