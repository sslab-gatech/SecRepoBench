/*
    Select the appropriate character map (encoding) for the font face based on
    the provided encoding string. If an encoding is specified, determine the
    corresponding FreeType encoding type using a series of string comparisons.
    If the encoding type is successfully determined, apply it to the font face.
    If the encoding type cannot be applied, handle the error by cleaning up
    resources and throwing an exception.
  */
  if (encoding != (const char *) NULL)
    {
      if (IsStringInList(encoding,"ISO-8859-1",exception))
        encoding_type=FT_ENCODING_ISO_8859_1;
      else if (IsStringInList(encoding,"ISO-8859-2",exception))
        encoding_type=FT_ENCODING_ISO_8859_2;
      else if (IsStringInList(encoding,"ISO-8859-3",exception))
        encoding_type=FT_ENCODING_ISO_8859_3;
      else if (IsStringInList(encoding,"ISO-8859-4",exception))
        encoding_type=FT_ENCODING_ISO_8859_4;
      else if (IsStringInList(encoding,"ISO-8859-5",exception))
        encoding_type=FT_ENCODING_ISO_8859_5;
      else if (IsStringInList(encoding,"ISO-8859-6",exception))
        encoding_type=FT_ENCODING_ISO_8859_6;
      else if (IsStringInList(encoding,"ISO-8859-7",exception))
        encoding_type=FT_ENCODING_ISO_8859_7;
      else if (IsStringInList(encoding,"ISO-8859-8",exception))
        encoding_type=FT_ENCODING_ISO_8859_8;
      else if (IsStringInList(encoding,"ISO-8859-9",exception))
        encoding_type=FT_ENCODING_ISO_8859_9;
      else if (IsStringInList(encoding,"ISO-8859-10",exception))
        encoding_type=FT_ENCODING_ISO_8859_10;
      else if (IsStringInList(encoding,"ISO-8859-11",exception))
        encoding_type=FT_ENCODING_ISO_8859_11;
      else if (IsStringInList(encoding,"ISO-8859-13",exception))
        encoding_type=FT_ENCODING_ISO_8859_13;
      else if (IsStringInList(encoding,"ISO-8859-14",exception))
        encoding_type=FT_ENCODING_ISO_8859_14;
      else if (IsStringInList(encoding,"ISO-8859-15",exception))
        encoding_type=FT_ENCODING_ISO_8859_15;
      else if (IsStringInList(encoding,"ISO-8859-16",exception))
        encoding_type=FT_ENCODING_ISO_8859_16;
      else if (IsStringInList(encoding,"UTF-8",exception))
        encoding_type=FT_ENCODING_UNICODE;
      else
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            "UnknownEncoding",encoding);
          goto cleanup;
        }
      ft_status=FT_Select_Charmap(face,encoding_type);
      if (ft_status != 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            "UnableToSelectEncoding",encoding);
          goto cleanup;
        }
    }

  /*
    Set the character size for the font face based on the point size and
    resolution specified in the DrawInfo structure. Adjust the resolution
    if a custom density is provided. If setting the character size fails,
    handle the error by cleaning up resources and throwing an exception.
  */
  if (draw_info->pointsize != 0.0)
    {
      resolution.x=draw_info->density;
      resolution.y=draw_info->density;
      if (draw_info->density != 0.0)
        {
          resolution.x=draw_info->density;
          resolution.y=draw_info->density;
        }
      else
        {
          resolution.x=72.0;
          resolution.y=72.0;
        }
      ft_status=FT_Set_Char_Size(face,draw_info->pointsize*64.0,
        draw_info->pointsize*64.0,&resolution.x,&resolution.y);
      if (ft_status != 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            "UnableToSetCharacterSize",draw_info->pointsize);
          goto cleanup;
        }
    }

  /*
    Initialize the TypeMetric structure with font size metrics such as ascent,
    descent, width, height, and maximum advance. If necessary, sanitize any
    incorrect ascender and descender values. Calculate underline position and
    thickness based on the font's properties.
  */
  metrics->ascent=face->ascender;
  metrics->descent=face->descender;
  metrics->width=face->max_advance_width;
  metrics->height=metrics->ascent-metrics->descent;
  metrics->underline_position=face->underline_position;
  metrics->underline_thickness=face->underline_thickness;
  if (metrics->ascent < 0)
    metrics->ascent=0;
  if (metrics->descent < 0)
    metrics->descent=0;
  if (metrics->ascent > metrics->height)
    metrics->height=metrics->ascent;
  if (metrics->descent > metrics->height)
    metrics->height=metrics->descent;

  /*
    If there is no text to render, or no glyphs in the font, clean up resources
    and return a successful status without proceeding further.
  */
  if ((text == (const char *) NULL) || (face->num_glyphs == 0))
    return(MagickTrue);

  /*
    Configure rendering options such as anti-aliasing and hinting based on
    the DrawInfo settings and image properties. Prepare structures for
    rendering each glyph in the text string, transforming the glyphs according
    to specified affine transformations.
  */
  affine.xx=draw_info->affine.xx;
  affine.xy=draw_info->affine.xy;
  affine.yx=draw_info->affine.yx;
  affine.yy=draw_info->affine.yy;
  ft_status=FT_Set_Transform(face,&affine,0);
  if (ft_status != 0)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
        "UnableToSetAffineTransform",draw_info->affine);
      goto cleanup;
    }

  /*
    Loop through each character in the text, rendering glyphs, tracing outlines
    if necessary, and rasterizing the glyphs onto the image. Adjust the
    position and metrics of each rendered glyph, and update the bounding box
    of the text as needed. Manage resources and synchronize image data
    appropriately during the rendering process.
  */
  p=text;
  last_character=0;
  while ((code=GetUTFCode(p)) != 0)
  {
    // ... (rest of the loop)
  }

  /*
    Finalize the font metrics by normalizing the bounding box coordinates and
    width. Clean up any remaining resources and return the rendering status.
  */
  metrics->ascent/=64.0;
  metrics->descent/=64.0;
  metrics->width/=64.0;
  metrics->height/=64.0;
  metrics->underline_position/=64.0;
  metrics->underline_thickness/=64.0;
  metrics->x_offset/=64.0;
  metrics->y_offset/=64.0;
  metrics->x_advance/=64.0;
  metrics->y_advance/=64.0;
  metrics->width+=metrics->x_offset;
  metrics->height+=metrics->y_offset;
  metrics->ascent+=metrics->y_offset;
  metrics->descent+=metrics->y_offset;
  metrics->x_offset+=metrics->x_advance;
  metrics->y_offset+=metrics->y_advance;
  metrics->width+=metrics->x_advance;
  metrics->height+=metrics->y_advance;
  metrics->ascent+=metrics->y_advance;
  metrics->descent+=metrics->y_advance;

cleanup:
  if (face != (FT_Face) NULL)
    (void) FT_Done_Face(face);
  if (library != (FT_Library) NULL)
    (void) FT_Done_FreeType(library);
  return(MagickFalse);
}