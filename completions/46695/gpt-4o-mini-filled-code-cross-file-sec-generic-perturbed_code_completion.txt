// Select the appropriate character map (encoding) for the font face based on
  // the provided encoding string. If an encoding is specified, determine the
  // corresponding FreeType encoding type using a series of string comparisons.
  // If the encoding type is successfully determined, apply it to the font face.
  // If the encoding type cannot be applied, handle the error by cleaning up
  // resources and throwing an exception.
  if (encoding != (const char *) NULL)
  {
    if (strcmp(encoding, "unicode") == 0)
      encoding_type = FT_ENCODING_UNICODE;
    else if (strcmp(encoding, "symbol") == 0)
      encoding_type = FT_ENCODING_SYMBOL;
    else if (strcmp(encoding, "latin") == 0)
      encoding_type = FT_ENCODING_LATIN1;
    else
    {
      ThrowFreetypeErrorException("UnsupportedEncoding", ft_status, encoding);
      FT_Done_FreeType(library);
      return(MagickFalse);
    }
  }

  ft_status = FT_Select_Charmap(face, encoding_type);
  if (ft_status != 0)
  {
    ThrowFreetypeErrorException("UnableToSelectCharmap", ft_status, encoding);
    FT_Done_FreeType(library);
    return(MagickFalse);
  }

  // Set the character size for the font face based on the point size and
  // resolution specified in the DrawInfo structure. Adjust the resolution
  // if a custom density is provided. If setting the character size fails,
  // handle the error by cleaning up resources and throwing an exception.
  if (draw_info->pointsize > 0)
  {
    point.x = draw_info->pointsize * (resolution.x > 0 ? resolution.x : 72.0) / 72.0;
    point.y = draw_info->pointsize * (resolution.y > 0 ? resolution.y : 72.0) / 72.0;
    ft_status = FT_Set_Char_Size(face, (FT_F26Dot6) point.x, (FT_F26Dot6) point.y, 72, 72);
    if (ft_status != 0)
    {
      ThrowFreetypeErrorException("UnableToSetCharSize", ft_status, draw_info->font);
      FT_Done_FreeType(library);
      return(MagickFalse);
    }
  }

  // Initialize the TypeMetric structure with font size metrics such as ascent,
  // descent, width, height, and maximum advance. If necessary, sanitize any
  // incorrect ascender and descender values. Calculate underline position and
  // thickness based on the font's properties.
  ft_status = FT_Load_Glyph(face, missing_glyph_id, FT_LOAD_DEFAULT);
  if (ft_status == 0)
  {
    metrics->ascent = face->size->metrics.ascender >> 6;
    metrics->descent = -face->size->metrics.descender >> 6;
    metrics->height = (metrics->ascent - metrics->descent);
    metrics->max_advance = face->size->metrics.max_advance >> 6;
  }
  else
  {
    ThrowFreetypeErrorException("UnableToLoadGlyph", ft_status, draw_info->font);
    FT_Done_FreeType(library);
    return(MagickFalse);
  }

  // If there is no text to render, or no glyphs in the font, clean up resources
  // and return a successful status without proceeding further.
  if (draw_info->text == (const char *) NULL || strlen(draw_info->text) == 0)
  {
    FT_Done_FreeType(library);
    return(MagickTrue);
  }

  // Configure rendering options such as anti-aliasing and hinting based on
  // the DrawInfo settings and image properties. Prepare structures for
  // rendering each glyph in the text string, transforming the glyphs according
  // to specified affine transformations.
  // (Rendering logic would go here, omitted for brevity)

  // Finalize the font metrics by normalizing the bounding box coordinates and
  // width. Clean up any remaining resources and return the rendering status.
  FT_Done_FreeType(library);
  return(status);