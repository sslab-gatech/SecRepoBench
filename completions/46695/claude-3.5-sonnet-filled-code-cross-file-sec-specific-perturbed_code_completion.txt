if (encoding != (const char *) NULL)
  {
    if (LocaleCompare(encoding,"AdobeCustom") == 0)
      encoding_type=FT_ENCODING_ADOBE_CUSTOM;
    if (LocaleCompare(encoding,"AdobeExpert") == 0)
      encoding_type=FT_ENCODING_ADOBE_EXPERT;
    if (LocaleCompare(encoding,"AdobeStandard") == 0)
      encoding_type=FT_ENCODING_ADOBE_STANDARD;
    if (LocaleCompare(encoding,"AppleRoman") == 0)
      encoding_type=FT_ENCODING_APPLE_ROMAN;
    if (LocaleCompare(encoding,"BIG5") == 0)
      encoding_type=FT_ENCODING_BIG5;
    if (LocaleCompare(encoding,"GB2312") == 0)
      encoding_type=FT_ENCODING_PRC;
    if (LocaleCompare(encoding,"Johab") == 0)
      encoding_type=FT_ENCODING_JOHAB;
    if (LocaleCompare(encoding,"MacRoman") == 0)
      encoding_type=FT_ENCODING_APPLE_ROMAN;
    if (LocaleCompare(encoding,"SJIScode") == 0)
      encoding_type=FT_ENCODING_SJIS;
    if (LocaleCompare(encoding,"Symbol") == 0)
      encoding_type=FT_ENCODING_MS_SYMBOL;
    if (LocaleCompare(encoding,"Unicode") == 0)
      encoding_type=FT_ENCODING_UNICODE;
    if (LocaleCompare(encoding,"Wansung") == 0)
      encoding_type=FT_ENCODING_WANSUNG;
    ft_status=FT_Select_Charmap(face,encoding_type);
    if (ft_status != 0)
      {
        FT_Done_Face(face);
        FT_Done_FreeType(library);
        ThrowFreetypeErrorException("UnrecognizedFontEncoding",ft_status,
          encoding);
        return(MagickFalse);
      }
  }
  resolution.x=DefaultResolution;
  resolution.y=DefaultResolution;
  if (draw_info->density != (char *) NULL)
    {
      GeometryInfo
        geometry_info;

      MagickStatusType
        flags;

      flags=ParseGeometry(draw_info->density,&geometry_info);
      resolution.x=geometry_info.rho;
      resolution.y=geometry_info.sigma;
      if ((flags & SigmaValue) == 0)
        resolution.y=resolution.x;
    }
  ft_status=FT_Set_Char_Size(face,(FT_F26Dot6) (64.0*draw_info->pointsize),
    (FT_F26Dot6) (64.0*draw_info->pointsize),(FT_UInt) resolution.x,
    (FT_UInt) resolution.y);
  if (ft_status != 0)
    {
      FT_Done_Face(face);
      FT_Done_FreeType(library);
      ThrowFreetypeErrorException("UnableToSetCharSize",ft_status,
        draw_info->font);
      return(MagickFalse);
    }
  metrics->pixels_per_em.x=face->size->metrics.x_ppem;
  metrics->pixels_per_em.y=face->size->metrics.y_ppem;
  metrics->ascent=(double) face->size->metrics.ascender/64.0;
  metrics->descent=(double) face->size->metrics.descender/64.0;
  metrics->width=0;
  metrics->origin.x=0;
  metrics->origin.y=0;
  metrics->height=(double) face->size->metrics.height/64.0;
  metrics->max_advance=(double) face->size->metrics.max_advance/64.0;
  if (face->size->metrics.ascender == 0)
    metrics->ascent=(double) face->ascender*metrics->pixels_per_em.x/
      face->units_per_EM;
  if (face->size->metrics.descender == 0)
    metrics->descent=-(double) face->descender*metrics->pixels_per_em.x/
      face->units_per_EM;
  if (face->size->metrics.height == 0)
    metrics->height=(double) face->height*metrics->pixels_per_em.x/
      face->units_per_EM;
  if (face->size->metrics.max_advance == 0)
    metrics->max_advance=(double) face->max_advance_width*
      metrics->pixels_per_em.x/face->units_per_EM;
  metrics->underline_position=FT_MulFix(face->underline_position,
    face->size->metrics.y_scale)/64.0;
  metrics->underline_thickness=FT_MulFix(face->underline_thickness,
    face->size->metrics.y_scale)/64.0;
  if ((draw_info->text == (char *) NULL) || (*draw_info->text == '\0'))
    {
      FT_Done_Face(face);
      FT_Done_FreeType(library);
      return(MagickTrue);
    }
  /*
    Render text.
  */
  flags=FT_LOAD_DEFAULT;
  if (draw_info->render == MagickFalse)
    flags|=FT_LOAD_NO_BITMAP;
  if (img->storage_class == PseudoClass)
    flags|=FT_LOAD_MONOCHROME;
  else
    if (draw_info->text_antialias == MagickFalse)
      flags|=FT_LOAD_TARGET_MONO;
    else
      flags|=FT_LOAD_TARGET_NORMAL;
  if (draw_info->style & NoAutohintStyle)
    flags|=FT_LOAD_NO_AUTOHINT;
  grapheme=(GraphemeInfo *) NULL;
  length=ComplexTextLayout(img,draw_info,draw_info->text,
    strlen(draw_info->text),face,flags,&grapheme,exception);
  if (length == 0)
    {
      FT_Done_Face(face);
      FT_Done_FreeType(library);
      return(MagickTrue);
    }
  status=MagickTrue;
  origin.x=0;
  origin.y=0;
  affine.xx=65536L;
  affine.yx=0L;
  affine.xy=0L;
  affine.yy=65536L;
  if (draw_info->render != MagickFalse)
    {
      char
        *p;

      MagickBooleanType
        active;

      /*
        Render text as a raster image.
      */
      annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
      if (annotate_info == (DrawInfo *) NULL)
        return(MagickFalse);
      (void) CloneString(&annotate_info->text,draw_info->text);
      /*
        Render label with a FreeType font.
      */
      active=MagickFalse;
      p=annotate_info->text;
      for (i=0; i < (ssize_t) length; i++)
      {
        /*
          Render UTF-8 sequence.
        */
        glyph.id=grapheme[i].index;
        if (glyph.id == 0)
          glyph.id=FT_Get_Char_Index(face,'?');
        if ((glyph.id != 0) && (active == MagickFalse))
          {
            FT_Vector
              offset;

            active=MagickTrue;
            offset.x=grapheme[i].x_offset;
            offset.y=grapheme[i].y_offset;
            (void) FT_Set_Transform(face,&affine,&offset);
          }
        if (active == MagickFalse)
          {
            p+=grapheme[i].cluster;
            continue;
          }
        ft_status=FT_Load_Glyph(face,glyph.id,flags);
        if (ft_status != 0)
          continue;
        ft_status=FT_Get_Glyph(face->glyph,&glyph.image);
        if (ft_status != 0)
          continue;
        ft_status=FT_Glyph_To_Bitmap(&glyph.image,ft_render_mode_normal,
          (FT_Vector *) NULL,MagickTrue);
        if (ft_status != 0)
          continue;
        bitmap=(FT_BitmapGlyph) glyph.image;
        point.x=offset->x+bitmap->left;
        if (bitmap->bitmap.pixel_mode == ft_pixel_mode_mono)
          point.x=offset->x+(origin.x+bitmap->left)/8;
        point.y=offset->y-bitmap->top;
        if (draw_info->text_antialias == MagickFalse)
          status=RenderType(img,annotate_info,&point,&glyph,exception);
        else
          status=RenderTypeGlyph(img,annotate_info,&point,&glyph,exception);
        FT_Done_Glyph(glyph.image);
        if (status == MagickFalse)
          break;
        origin.x+=grapheme[i].x_advance;
        origin.y+=grapheme[i].y_advance;
        p+=grapheme[i].cluster;
      }
      annotate_info=DestroyDrawInfo(annotate_info);
    }
  /*
    Determine font metrics.
  */
  glyph.id=0;
  last_glyph_id=0;
  origin.x=0;
  origin.y=0;
  for (i=0; i < (ssize_t) length; i++)
  {
    glyph.id=grapheme[i].index;
    if (glyph.id == 0)
      glyph.id=FT_Get_Char_Index(face,'?');
    ft_status=FT_Load_Glyph(face,glyph.id,flags);
    if (ft_status != 0)
      continue;
    ft_status=FT_Get_Glyph(face->glyph,&glyph.image);
    if (ft_status != 0)
      continue;
    ft_status=FT_Glyph_Get_CBox(glyph.image,ft_glyph_bbox_subpixels,&bounds);
    if (ft_status != 0)
      continue;
    FT_Done_Glyph(glyph.image);
    if ((i == 0) || (bounds.xMin < metrics->bounds.x1))
      metrics->bounds.x1=bounds.xMin;
    if ((i == 0) || (bounds.yMin < metrics->bounds.y1))
      metrics->bounds.y1=bounds.yMin;
    if ((i == 0) || (bounds.xMax > metrics->bounds.x2))
      metrics->bounds.x2=bounds.xMax;
    if ((i == 0) || (bounds.yMax > metrics->bounds.y2))
      metrics->bounds.y2=bounds.yMax;
    origin.x+=grapheme[i].x_advance;
    origin.y+=grapheme[i].y_advance;
    if (last_glyph_id != 0)
      origin.x+=grapheme[i].x_offset;
    if (((grapheme[i].x_advance == 0) && (grapheme[i].y_advance == 0)) ||
        (i == (ssiz