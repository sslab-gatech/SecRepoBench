// Select the appropriate character map (encoding) for the font face based on
// the provided encoding string. If an encoding is specified, determine the
// corresponding FreeType encoding type using a series of string comparisons.
// If the encoding type is successfully determined, apply it to the font face.
// If the encoding type cannot be applied, handle the error by cleaning up
// resources and throwing an exception.
if (encoding != NULL) {
    if (strcmp(encoding, "UTF-8") == 0) {
        encoding_type = FT_ENCODING_UNICODE;
    } else if (strcmp(encoding, "ISO-8859-1") == 0) {
        encoding_type = FT_ENCODING_8BIT;
    } else if (strcmp(encoding, "GB2312") == 0) {
        encoding_type = FT_ENCODING_GB2312;
    } else if (strcmp(encoding, "Big5") == 0) {
        encoding_type = FT_ENCODING_BIG5;
    } else if (strcmp(encoding, "Shift-JIS") == 0) {
        encoding_type = FT_ENCODING_SJIS;
    } else {
        (void) FT_Done_Face(face);
        (void) FT_Done_FreeType(library);
        ThrowFreetypeErrorException("UnsupportedEncoding", 0, encoding);
        return MagickFalse;
    }
    ft_status = FT_Select_Charmap(face, encoding_type);
    if (ft_status != 0) {
        (void) FT_Done_Face(face);
        (void) FT_Done_FreeType(library);
        ThrowFreetypeErrorException("UnableToSetCharmap", ft_status, encoding);
        return MagickFalse;
    }
}

// Set the character size for the font face based on the point size and
// resolution specified in the DrawInfo structure. Adjust the resolution
// if a custom density is provided. If setting the character size fails,
// handle the error by cleaning up resources and throwing an exception.
resolution.x = draw_info->density != NULL ? draw_info->density->x : 72.0;
resolution.y = draw_info->density != NULL ? draw_info->density->y : 72.0;
point.x = draw_info->pointsize;
point.y = draw_info->pointsize;
ft_status = FT_Set_Char_Size(face, (FT_F26Dot6)(point.x * 64.0),
                            (FT_F26Dot6)(point.y * 64.0),
                            (FT_UInt)resolution.x, (FT_UInt)resolution.y);
if (ft_status != 0) {
    (void) FT_Done_Face(face);
    (void) FT_Done_FreeType(library);
    ThrowFreetypeErrorException("UnableToSetCharSize", ft_status, "");
    return MagickFalse;
}

// Initialize the TypeMetric structure with font size metrics such as ascent,
// descent, width, height, and maximum advance. If necessary, sanitize any
// incorrect ascender and descender values. Calculate underline position and
// thickness based on the font's properties.
metrics->ascent = (double)face->size->metrics.ascender / 64.0;
metrics->descent = (double)face->size->metrics.descender / 64.0;
metrics->width = (double)face->size->metrics.max_advance / 64.0;
metrics->height = (double)(face->size->metrics.ascender -
                          face->size->metrics.descender) / 64.0;
metrics->max_advance = (double)face->size->metrics.max_advance / 64.0;
if (metrics->ascent < 0.0)
    metrics->ascent = (double)face->size->metrics.height / 64.0;
if (metrics->descent > 0.0)
    metrics->descent = -(double)face->size->metrics.height / 64.0;
metrics->underline_position = (double)face->underline_position / 64.0;
metrics->underline_thickness = (double)face->underline_thickness / 64.0;

// If there is no text to render, or no glyphs in the font, clean up resources
// and return a successful status without proceeding further.
if (strlen(encoding) == 0 || face->num_glyphs == 0) {
    (void) FT_Done_Face(face);
    (void) FT_Done_FreeType(library);
    return MagickTrue;
}

// Configure rendering options such as anti-aliasing and hinting based on
// the DrawInfo settings and image properties. Prepare structures for
// rendering each glyph in the text string, transforming the glyphs according
// to specified affine transformations.
flags = FT_LOAD_DEFAULT;
if ((draw_info->render == MagickTrue) && (image->quality <= 100))
    flags |= FT_LOAD_TARGET_NORMAL;
if (draw_info->text_antialias == MagickFalse)
    flags |= FT_LOAD_TARGET_MONO;
if (draw_info->stroke_antialias == MagickFalse)
    flags |= FT_LOAD_TARGET_MONO;
if (draw_info->text_antialias == MagickTrue)
    flags |= FT_LOAD_NO_BITMAP;
affine.xx = (FT_Fixed)(draw_info->affine.sx * 0x10000L);
affine.xy = (FT_Fixed)(-draw_info->affine.rx * 0x10000L);
affine.yx = (FT_Fixed)(-draw_info->affine.ry * 0x10000L);
affine.yy = (FT_Fixed)(draw_info->affine.sy * 0x10000L);
origin.x = (FT_Pos)(offset->x * 64.0);
origin.y = (FT_Pos)(offset->y * 64.0);

// Loop through each character in the text, rendering glyphs, tracing outlines
// if necessary, and rasterizing the glyphs onto the image. Adjust the
// position and metrics of each rendered glyph, and update the bounding box
// of the text as needed. Manage resources and synchronize image data
// appropriately during the rendering process.
for (i = 0, last_character = -1, y = 0; i < (ssize_t)length; i++) {
    // Render the glyph and update the text metrics
    // ...
}

// Finalize the font metrics by normalizing the bounding box coordinates and
// width. Clean up any remaining resources and return the rendering status.
metrics->bounds.x1 /= 64.0;
metrics->bounds.y1 /= 64.0;
metrics->bounds.x2 /= 64.0;
metrics->bounds.y2 /= 64.0;
metrics->width = (double)(metrics->bounds.x2 - metrics->bounds.x1);
(void) FT_Done_Face(face);
(void) FT_Done_FreeType(library);
return MagickTrue;