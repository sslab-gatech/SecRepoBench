if (encoding != (const char *) NULL)
    {
      if (LocaleCompare(encoding,"SymbolEncoding") == 0)
        encoding_type=FT_ENCODING_MS_SYMBOL;
      else if (LocaleCompare(encoding,"UnicodeEncoding") == 0)
        encoding_type=FT_ENCODING_UNICODE;
      else if (LocaleCompare(encoding,"Latin2Encoding") == 0)
        encoding_type=FT_ENCODING_ADOBE_LATIN_2;
      else if ((LocaleCompare(encoding,"Automatic") == 0) ||
        (LocaleCompare(encoding,"AutomaticEncoding") == 0))
        encoding_type=FT_ENCODING_UNICODE;
      ft_status=FT_Select_Charmap(face,encoding_type);
      if ((ft_status != 0) && (face->num_charmaps != 0))
        ft_status=FT_Set_Charmap(face,face->charmaps[0]);
      if (ft_status != 0)
        {
          (void) FT_Done_Face(face);
          (void) FT_Done_FreeType(library);
          ThrowFreetypeErrorException("UnableToSetEncoding",ft_status,encoding);
          return(MagickFalse);
        }
    }
  /*
    Set character size.
  */
  resolution.x=DefaultResolution;
  resolution.y=DefaultResolution;
  if (draw_info->density != (char *) NULL)
    {
      GeometryInfo
        geometry_info;

      MagickStatusType
        flags;

      flags=ParseGeometry(draw_info->density,&geometry_info);
      resolution.x=geometry_info.rho;
      resolution.y=geometry_info.sigma;
      if ((flags & SigmaValue) == 0)
        resolution.y=resolution.x;
    }
  ft_status=FT_Set_Char_Size(face,(FT_F26Dot6) (64.0*draw_info->pointsize),
    (FT_F26Dot6) (64.0*draw_info->pointsize),(FT_UInt) resolution.x,
    (FT_UInt) resolution.y);
  if (ft_status != 0)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      ThrowFreetypeErrorException("UnableToSetCharSize",ft_status,
        draw_info->font);
      return(MagickFalse);
    }
  /*
    Set font metrics.
  */
  metrics->pixels_per_em.x=face->size->metrics.x_ppem;
  metrics->pixels_per_em.y=face->size->metrics.y_ppem;
  metrics->ascent=(double) face->size->metrics.ascender/64.0;
  metrics->descent=(double) face->size->metrics.descender/64.0;
  metrics->width=0;
  metrics->origin.x=0;
  metrics->origin.y=0;
  metrics->height=(double) (face->size->metrics.height/64.0);
  metrics->max_advance=(double) face->size->metrics.max_advance/64.0;
  metrics->bounds.x1=0.0;
  metrics->bounds.y1=metrics->descent;
  metrics->bounds.x2=metrics->ascent+metrics->descent;
  metrics->bounds.y2=metrics->ascent+metrics->descent;
  metrics->underline_position=face->underline_position/64.0;
  metrics->underline_thickness=face->underline_thickness/64.0;
  if (metrics->underline_position > 0.0)
    metrics->underline_position*=(-1.0);
  if (metrics->underline_thickness <= 0.0)
    metrics->underline_thickness=1.0;
  /*
    Get font attributes.
  */
  value=GetDrawOption(draw_info,"text");
  if (value == (char *) NULL)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      return(MagickTrue);
    }
  /*
    Ensure no defects from empty fonts.
  */
  if (face->num_glyphs <= 0)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      return(MagickTrue);
    }
  /*
    Configure rendering options.
  */
  flags=FT_LOAD_DEFAULT;
  if (draw_info->render == MagickFalse)
    flags|=FT_LOAD_NO_BITMAP;
  if (draw_info->text_antialias == MagickFalse)
    flags|=FT_LOAD_TARGET_MONO;
  else
    {
      if (img->quality == 0)
        flags|=FT_LOAD_TARGET_MONO;
      else
        flags|=FT_LOAD_TARGET_NORMAL;
      if (img->alpha_trait != UndefinedPixelTrait)
        {
          flags|=FT_LOAD_NO_BITMAP;
          if (draw_info->text_antialias == MagickTrue)
            flags|=FT_LOAD_NO_HINTING;
        }
    }
  /*
    Set up affine transformation matrix.
  */
  affine.xx=65536L;
  affine.yx=0L;
  affine.xy=0L;
  affine.yy=65536L;
  if (draw_info->text_affine.sx != 1.0)
    affine.xx=(FT_Fixed) (draw_info->text_affine.sx*65536L);
  if (draw_info->text_affine.ry != 0.0)
    affine.yx=(FT_Fixed) (draw_info->text_affine.ry*65536L);
  if (draw_info->text_affine.rx != 0.0)
    affine.xy=(FT_Fixed) (draw_info->text_affine.rx*65536L);
  if (draw_info->text_affine.sy != 1.0)
    affine.yy=(FT_Fixed) (draw_info->text_affine.sy*65536L);
  /*
    Prepare layout for text.
  */
  annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
  if (annotate_info == (DrawInfo *) NULL)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      return(MagickFalse);
    }
  utf8=StringToUTF8(value,&length);
  if (utf8 == (unsigned char *) NULL)
    {
      annotate_info=DestroyDrawInfo(annotate_info);
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      return(MagickFalse);
    }
  grapheme=(GraphemeInfo *) NULL;
  status=MagickTrue;
  length=ComplexTextLayout(img,draw_info,(const char *) utf8,length,face,
    flags,&grapheme,exception);
  if (length == 0)
    {
      utf8=DestroyString((char *) utf8);
      annotate_info=DestroyDrawInfo(annotate_info);
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      return(MagickTrue);
    }
  /*
    Render text as a bitmap.
  */
  origin.x=0;
  origin.y=0;
  glyph.id=0;
  glyph.image=NULL;
  last_character=0;
  for (i=0; i < (ssize_t) length; i++)
  {
    glyph.id=grapheme[i].index;
    if (glyph.id == 0)
      glyph.id=FT_Get_Char_Index(face,'?');
    if ((glyph.id != 0) && (last_character != 0) && (FT_HAS_KERNING(face)))
      {
        FT_Vector
          kerning;

        ft_status=FT_Get_Kerning(face,(FT_UInt) last_character,(FT_UInt)
          glyph.id,ft_kerning_default,&kerning);
        if (ft_status == 0)
          origin.x+=kerning.x;
      }
    glyph.origin=origin;
    glyph.origin.x+=grapheme[i].x_offset;
    glyph.origin.y+=grapheme[i].y_offset;

    ft_status=FT_Load_Glyph(face,glyph.id,flags);
    if (ft_status != 0)
      continue;
    /*
      Render glyph and calculate metrics.
    */
    ft_status=FT_Get_Glyph(face->glyph,&glyph.image);
    if (ft_status != 0)
      continue;
    if (draw_info->render != MagickFalse)
      {
        ft_status=FT_Glyph_To_Bitmap(&glyph.image,
          draw_info->text_antialias != MagickFalse ? ft_render_mode_normal :
          ft_render_mode_mono,&glyph.origin,MagickTrue);
        if (ft_status != 0)
          continue;
        bitmap=(FT_BitmapGlyph) glyph.image;
        point.x=offset->x+bitmap->left;
        point.y=offset->y-bitmap->top;
        /*
          Update bounding box.
        */
        if (i == 0)
          {
            metrics->bounds.x1=point.x;
            metrics->bounds.y1=point.y;
            metrics->bounds.x2=point.x+bitmap->bitmap.width;
            metrics->bounds.y2=point.y+bitmap->bitmap.rows;
          }
        else
          {
            if (point.x < metrics->bounds.x1)
              metrics->bounds.x1=point.x;
            if (point.y < metrics->bounds.y1)
              metrics->bounds.y1=point.y;
            if ((point.x+bitmap->bitmap.width) > metrics->bounds.x2)
              metrics->bounds.x2=point.x+bitmap->bitmap.width;
            if ((point.y+bitmap->bitmap.rows) > metrics->bounds.y2)
              metrics->bounds.y2=point.y+bitmap->bitmap.rows;
          }
      }
    else
      {
        if (FT_HAS_TRANSFORM(face) != 0)
          {
            ft_status=FT_Outline_Get_BBox(&((FT_OutlineGlyph) glyph.image)->outline,
              &bounds);
            if (ft_status == 0)
              {
                point.x=offset->x+glyph.origin.x/64.0;
                point.y=offset->y-glyph.origin.y/64.0;
                bounds.xMin=bounds.xMin/64.0+point.x;
                bounds.yMin=bounds.yMin/64.0+point.y;
                bounds.xMax=bounds.xMax/64.0+point.x;
                bounds.yMax=bounds.yMax/64.0+point.y;
                if (i == 0)
                  {
                    metrics->bounds.x1=bounds.xMin;
                    metrics->bounds.y1=bounds.yMin;
                    metrics->bounds.x2=bounds.xMax;
                    metrics->bounds.y2=bounds.yMax;
                  }
                else
                  {
                    if (bounds.xMin < metrics->bounds.x1)
                      metrics->bounds.x1=bounds.xMin;
                    if (bounds.yMin < metrics->bounds.y1)
                      metrics->bounds.y1=bounds.yMin;
                    if (bounds.xMax > metrics->bounds.x2)
                      metrics->bounds.x2=bounds.xMax;
                    if (bounds.yMax > metrics->bounds.y2)
                      metrics->bounds.y2=bounds.yMax;
                  }
              }
          }
      }
    FT_Done_Glyph(glyph.image);
    glyph.image=NULL;
    origin.x+=grapheme[i].x_advance;
    last_character=glyph.id;
  }
  /*
    Finalize metrics and clean up.
  */
  if (metrics->bounds.x1 > metrics->bounds.x2)
    {
      metrics->bounds.x1=0.0;
      metrics->bounds.y1=0.0;
      metrics->bounds.x2=0.0;
      metrics->bounds.y2=0.0;
    }
  else
    {
      metrics->width=metrics->bounds.x2-metrics->bounds.x1;
      metrics->height=metrics->bounds.y2-metrics->bounds.y1;
    }
  if (utf8 != (unsigned char *) NULL)
    utf8=DestroyString((char *) utf8);
  i