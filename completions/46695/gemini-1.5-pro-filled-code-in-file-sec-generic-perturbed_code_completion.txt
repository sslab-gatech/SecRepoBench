if (encoding != (char *) NULL)
    {
      if (LocaleCompare(encoding,"AdobeCustom") == 0)
        encoding_type=FT_ENCODING_ADOBE_CUSTOM;
      if (LocaleCompare(encoding,"AdobeExpert") == 0)
        encoding_type=FT_ENCODING_ADOBE_EXPERT;
      if (LocaleCompare(encoding,"AdobeStandard") == 0)
        encoding_type=FT_ENCODING_ADOBE_STANDARD;
      if (LocaleCompare(encoding,"AppleRoman") == 0)
        encoding_type=FT_ENCODING_APPLE_ROMAN;
      if (LocaleCompare(encoding,"Big5") == 0)
        encoding_type=FT_ENCODING_BIG5;
      if (LocaleCompare(encoding,"GB2312") == 0)
        encoding_type=FT_ENCODING_GB2312;
      if (LocaleCompare(encoding,"Johab") == 0)
        encoding_type=FT_ENCODING_JOHAB;
      if (LocaleCompare(encoding,"SJIScode") == 0)
        encoding_type=FT_ENCODING_SJIS;
      if (LocaleCompare(encoding,"Symbol") == 0)
        encoding_type=FT_ENCODING_MS_SYMBOL;
      if (LocaleCompare(encoding,"Unicode") == 0)
        encoding_type=FT_ENCODING_UNICODE;
      if (LocaleCompare(encoding,"Wansung") == 0)
        encoding_type=FT_ENCODING_WANSUNG;
      ft_status=FT_Select_Charmap(face,encoding_type);
      if (ft_status != 0)
        ThrowFreetypeErrorException("UnrecognizedFontEncoding",ft_status,
          encoding);
    }
  if ((draw_info->pointsize == 0.0) || (draw_info->pointsize > 16384.0))
    annotate_info->pointsize=12.0;
  resolution.x=image->resolution.x;
  resolution.y=image->resolution.y;
  if ((resolution.x == 0.0) || (resolution.y == 0.0))
    {
      resolution.x=DefaultResolution;
      resolution.y=DefaultResolution;
    }
  if (draw_info->density != (char *) NULL)
    {
      GeometryInfo
        geometry_info;

      MagickStatusType
        flags;

      flags=ParseGeometry(draw_info->density,&geometry_info);
      resolution.x=geometry_info.rho;
      resolution.y=resolution.x;
      if ((flags & SigmaValue) != 0)
        resolution.y=geometry_info.sigma;
    }
  ft_status=FT_Set_Char_Size(face,(FT_F26Dot6)(64.0*draw_info->pointsize),
    (FT_F26Dot6)(64.0*draw_info->pointsize),(FT_UInt) resolution.x,(FT_UInt)
    resolution.y);
  if (ft_status != 0)
    ThrowFreetypeErrorException("UnableToSetFreetypeCharacterSize",ft_status,
      draw_info->font != (char *) NULL ? draw_info->font : "none");
  metrics->pixels_per_em.x=(resolution.y/DefaultResolution)*
    ExpandAffine(&draw_info->affine)*draw_info->pointsize;
  metrics->pixels_per_em.y=metrics->pixels_per_em.x;
  metrics->ascent=face->size->metrics.ascender/64.0;
  metrics->descent=face->size->metrics.descender/64.0;
  metrics->width=0;
  metrics->height=0;
  metrics->max_advance=0.0;
  metrics->bounds.x1=0.0;
  metrics->bounds.y1=0.0;
  metrics->bounds.x2=0.0;
  metrics->bounds.y2=0.0;
  if (draw_info->text == (char *) NULL)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      return(MagickFalse);
    }
  metrics->underline_position=face->underline_position/64.0;
  metrics->underline_thickness=face->underline_thickness/64.0;
  if ((metrics->underline_position == 0.0) &&
      (metrics->underline_thickness == 0.0))
    {
      metrics->underline_position=metrics->descent/2.0;
      metrics->underline_thickness=1.0;
    }
  if (face->glyph == (FT_GlyphSlot) NULL)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      return(MagickFalse);
    }
  /*
    Compute the bounding box.
  */
  annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
  annotate_info->render=MagickTrue;
  annotate_info->text_antialias=MagickTrue;
  value=GetImageProperty(img,"type:antialias",exception);
  if (value != (const char *) NULL)
    annotate_info->text_antialias=IsMagickTrue(value);
  flags=FT_LOAD_DEFAULT;
  if (annotate_info->text_antialias == MagickFalse)
    flags|=FT_LOAD_TARGET_MONO;
  value=GetImageProperty(img,"type:hinting",exception);
  if (value != (const char *) NULL)
    if (IsMagickTrue(value) == MagickFalse)
      flags|=FT_LOAD_NO_HINTING;
  value=GetImageProperty(img,"type:autohint",exception);
  if (value != (const char *) NULL)
    if (IsMagickTrue(value) != MagickFalse)
      flags|=FT_LOAD_FORCE_AUTOHINT;
  value=GetImageProperty(img,"type:light-hinting",exception);
  if (value != (const char *) NULL)
    if (IsMagickTrue(value) != MagickFalse)
      flags|=FT_LOAD_TARGET_LIGHT;
  length=strlen(draw_info->text);
  utf8=ConvertLatin1ToUTF8((unsigned char *) draw_info->text);
  if (utf8 != (unsigned char *) NULL)
    length=strlen((char *) utf8);
  grapheme=(GraphemeInfo *) NULL;
  if (draw_info->direction != UndefinedDirection)
    length=ComplexTextLayout(image,draw_info,(char *) utf8,length,face,flags,
      &grapheme,exception);
  if (utf8 != (unsigned char *) NULL)
    utf8=(unsigned char *) RelinquishMagickMemory(utf8);
  if (draw_info->render != MagickFalse)
    (void) SetImageType(img,TrueColorType,exception);
  glyph.image=(FT_Glyph) NULL;
  last_character=0;
  first_glyph_id=0;
  missing_glyph_id=0;
  affine.xx=65536L;
  affine.yx=0L;
  affine.xy=0L;
  affine.yy=65536L;
  for (i=0; i < (ssize_t) length; i++)
  {
    code=0;
    if (grapheme != (GraphemeInfo *) NULL)
      {
        glyph.id=grapheme[i].index;
        origin.x=grapheme[i].x_offset;
        origin.y=grapheme[i].y_offset;
        code=GetUTFCode(draw_info->text+grapheme[i].cluster);
      }
    else
      {
        p=draw_info->text;
        if (encoding == (char *) NULL)
          {
            p=draw_info->text+i;
            code=GetUTFCode(p);
          }
        else
          {
            if (draw_info->direction == RightToLeftDirection)
              p=draw_info->text+length-i-1;
            else
              p=draw_info->text+i;
            code=GetUTFCode(p);
          }
        glyph.id=FT_Get_Char_Index(face,code);
        origin.x=0L;
        origin.y=0L;
      }
    if (((glyph.id != 0) && (last_character != 0)) && (FT_HAS_KERNING(face)))
      {
        FT_Error
          ft_status;

        FT_Vector
          kerning;

        ft_status=FT_Get_Kerning(face,(FT_UInt) last_glyph_id,(FT_UInt)
          glyph.id,ft_kerning_default,&kerning);
        if (ft_status == 0)
          metrics->width+=(FT_Pos) ((draw_info->direction == RightToLeftDirection ?
            -1.0 : 1.0)*kerning.x/64.0);
      }
    ft_status=FT_Load_Glyph(face,(FT_UInt) glyph.id,flags);
    if (ft_status != 0)
      {
        if (first_glyph_id == 0)
          first_glyph_id=glyph.id;
        missing_glyph_id=glyph.id;
        continue;
      }
    ft_status=FT_Get_Glyph(face->glyph,&glyph.image);
    if (ft_status != 0)
      continue;
    FT_Glyph_Transform(glyph.image,&affine,(FT_Vector *) NULL);
    if (draw_info->render != MagickFalse)
      {
        LockSemaphoreInfo(annotate_semaphore);
        ft_status=FT_Glyph_To_Bitmap(&glyph.image,ft_render_mode_normal,
          (FT_Vector *) NULL,MagickTrue);
        UnlockSemaphoreInfo(annotate_semaphore);
        if (ft_status != 0)
          continue;
        bitmap=(FT_BitmapGlyph) glyph.image;
        point.x=offset->x+((double) bitmap->left+(origin.x/64.0));
        point.y=offset->y-((double) bitmap->top-(origin.y/64.0));
        if (draw_info->decorate != NoDecoration)
          {
            if (draw_info->decorate == LineThroughDecoration)
              point.y+=(metrics->height+metrics->underline_position+
                metrics->descent*2)/2.0;
          }
        /*
          Rasterize the glyph on the image.
        */
        status=DrawGlyphImage(img,annotate_info,bitmap,&point,exception);
        if (status == MagickFalse)
          break;
      }
    FT_Done_Glyph(glyph.image);
    glyph.image=(FT_Glyph) NULL;
    metrics->width+=(FT_Pos) ((draw_info->direction == RightToLeftDirection ?
      -1.0 : 1.0)*face->glyph->advance.x/64.0);
    if (metrics->max_advance < (face->glyph->advance.x/64.0))
      metrics->max_advance=face->glyph->advance.x/64.0;
    FT_Glyph_Get_CBox(face->glyph,ft_glyph_bbox_pixels,&bounds);
    if (metrics->bounds.x1 > (double) bounds.xMin)
      metrics->bounds.x1=(double) bounds.xMin;
    if (metrics->bounds.y1 > (double) bounds.yMin)
      metrics->bounds.y1=(double) bounds.yMin;
    if (metrics->bounds.x2 < (double) bounds.xMax)
      metrics->bounds.x2=(double) bounds.xMax;
    if (metrics->bounds.y2 < (double) bounds.yMax)
      metrics->bounds.y2=(double) bounds.yMax;
    last_character=code;
    last_glyph_id=glyph.id;
  }
  if ((missing_glyph_id != 0) && (missing_glyph_id != glyph.id))
    (void) ThrowMagickException(exception,GetMagickModule(),TypeError,
      "TypeMetricsFailed","`%s' (Freetype)",draw_info->font != (char *) NULL ?
      draw_info->font : "none");
  if (grapheme != (GraphemeInfo *) NULL)
    grapheme=(GraphemeInfo *) RelinquishMagickMemory(grapheme);
  /*
    Adjust bounding box based on rotation.
  */
  if (draw_info->render == MagickFalse)
    {
      if (grapheme != (GraphemeInfo *) NULL)
        metrics->width=metrics->max_advance*length;
      metrics->height=metrics->ascent-metrics->descent;
    }
  metrics->bounds.x1/=ExpandAffine(&draw_info-