// Select the appropriate character map (encoding) for the font face based on
// the provided encoding string.
if (LocaleCompare(encoding,"ISO-8859-1") == 0)
  encoding_type=FT_ENCODING_MS_SYMBOL;
else if (LocaleCompare(encoding,"ISO-8859-2") == 0)
  encoding_type=FT_ENCODING_MS_SYMBOL;
else if (LocaleCompare(encoding,"ISO-8859-3") == 0)
  encoding_type=FT_ENCODING_MS_SYMBOL;
else if (LocaleCompare(encoding,"ISO-8859-4") == 0)
  encoding_type=FT_ENCODING_MS_SYMBOL;
else if (LocaleCompare(encoding,"ISO-8859-5") == 0)
  encoding_type=FT_ENCODING_MS_SYMBOL;
else if (LocaleCompare(encoding,"ISO-8859-6") == 0)
  encoding_type=FT_ENCODING_MS_SYMBOL;
else if (LocaleCompare(encoding,"ISO-8859-7") == 0)
  encoding_type=FT_ENCODING_MS_SYMBOL;
else if (LocaleCompare(encoding,"ISO-8859-8") == 0)
  encoding_type=FT_ENCODING_MS_SYMBOL;
else if (LocaleCompare(encoding,"ISO-8859-9") == 0)
  encoding_type=FT_ENCODING_MS_SYMBOL;
else if (LocaleCompare(encoding,"ISO-8859-10") == 0)
  encoding_type=FT_ENCODING_MS_SYMBOL;
else if (LocaleCompare(encoding,"ISO-8859-11") == 0)
  encoding_type=FT_ENCODING_MS_SYMBOL;
else if (LocaleCompare(encoding,"ISO-8859-13") == 0)
  encoding_type=FT_ENCODING_MS_SYMBOL;
else if (LocaleCompare(encoding,"ISO-8859-14") == 0)
  encoding_type=FT_ENCODING_MS_SYMBOL;
else if (LocaleCompare(encoding,"ISO-8859-15") == 0)
  encoding_type=FT_ENCODING_MS_SYMBOL;
else if (LocaleCompare(encoding,"ISO-8859-16") == 0)
  encoding_type=FT_ENCODING_MS_SYMBOL;
else if (LocaleCompare(encoding,"KOI8-R") == 0)
  encoding_type=FT_ENCODING_MS_SYMBOL;
else if (LocaleCompare(encoding,"KOI8-U") == 0)
  encoding_type=FT_ENCODING_MS_SYMBOL;
else if (LocaleCompare(encoding,"KOI8-RU") == 0)
  encoding_type=FT_ENCODING_MS_SYMBOL;
else if (LocaleCompare(encoding,"KOI8-T") == 0)
  encoding_type=FT_ENCODING_MS_SYMBOL;
else if (LocaleCompare(encoding,"CP1250") == 0)
  encoding_type=FT_ENCODING_MS_SYMBOL;
else if (LocaleCompare(encoding,"CP1251") == 0)
  encoding_type=FT_ENCODING_MS_SYMBOL;
else if (LocaleCompare(encoding,"CP1252") == 0)
  encoding_type=FT_ENCODING_MS_SYMBOL;
else if (LocaleCompare(encoding,"CP1253") == 0)
  encoding_type=FT_ENCODING_MS_SYMBOL;
else if (LocaleCompare(encoding,"CP1254") == 0)
  encoding_type=FT_ENCODING_MS_SYMBOL;
else if (LocaleCompare(encoding,"CP1255") == 0)
  encoding_type=FT_ENCODING_MS_SYMBOL;
else if (LocaleCompare(encoding,"CP1256") == 0)
  encoding_type=FT_ENCODING_MS_SYMBOL;
else if (LocaleCompare(encoding,"CP1257") == 0)
  encoding_type=FT_ENCODING_MS_SYMBOL;
else if (LocaleCompare(encoding,"CP1258") == 0)
  encoding_type=FT_ENCODING_MS_SYMBOL;
else if (LocaleCompare(encoding,"CP874") == 0)
  encoding_type=FT_ENCODING_MS_SYMBOL;
else if (LocaleCompare(encoding,"CP932") == 0)
  encoding_type=FT_ENCODING_SJIS;
else if (LocaleCompare(encoding,"CP936") == 0)
  encoding_type=FT_ENCODING_GB2312;
else if (LocaleCompare(encoding,"CP949") == 0)
  encoding_type=FT_ENCODING_MS_SYMBOL;
else if (LocaleCompare(encoding,"CP950") == 0)
  encoding_type=FT_ENCODING_BIG5;
else if (LocaleCompare(encoding,"CP1361") == 0)
  encoding_type=FT_ENCODING_JOHAB;
else if (LocaleCompare(encoding,"SJIS") == 0)
  encoding_type=FT_ENCODING_SJIS;
else if (LocaleCompare(encoding,"BIG5") == 0)
  encoding_type=FT_ENCODING_BIG5;
else if (LocaleCompare(encoding,"BIG5HKSCS") == 0)
  encoding_type=FT_ENCODING_BIG5;
else if (LocaleCompare(encoding,"GB2312") == 0)
  encoding_type=FT_ENCODING_GB2312;
else if (LocaleCompare(encoding,"GBK") == 0)
  encoding_type=FT_ENCODING_GB2312;
else if (LocaleCompare(encoding,"GB18030") == 0)
  encoding_type=FT_ENCODING_GB2312;
else if (LocaleCompare(encoding,"JISX0201") == 0)
  encoding_type=FT_ENCODING_JISX0201;
else if (LocaleCompare(encoding,"JISX0208") == 0)
  encoding_type=FT_ENCODING_JISX0208;
else if (LocaleCompare(encoding,"JISX0212") == 0)
  encoding_type=FT_ENCODING_JISX0212;
else if (LocaleCompare(encoding,"JISX0213") == 0)
  encoding_type=FT_ENCODING_JISX0213;
else if (LocaleCompare(encoding,"KSC5601") == 0)
  encoding_type=FT_ENCODING_MS_SYMBOL;
else if (LocaleCompare(encoding,"JOHAB") == 0)
  encoding_type=FT_ENCODING_JOHAB;
else if (LocaleCompare(encoding,"WANSUNG") == 0)
  encoding_type=FT_ENCODING_MS_SYMBOL;
else if (LocaleCompare(encoding,"UNICODE") == 0)
  encoding_type=FT_ENCODING_UNICODE;
else if (LocaleCompare(encoding,"UTF-8") == 0)
  encoding_type=FT_ENCODING_UNICODE;
else if (LocaleCompare(encoding,"UTF-16") == 0)
  encoding_type=FT_ENCODING_UNICODE;
else if (LocaleCompare(encoding,"UTF-16BE") == 0)
  encoding_type=FT_ENCODING_UNICODE;
else if (LocaleCompare(encoding,"UTF-16LE") == 0)
  encoding_type=FT_ENCODING_UNICODE;
else if (LocaleCompare(encoding,"UTF-32") == 0)
  encoding_type=FT_ENCODING_UNICODE;
else if (LocaleCompare(encoding,"UTF-32BE") == 0)
  encoding_type=FT_ENCODING_UNICODE;
else if (LocaleCompare(encoding,"UTF-32LE") == 0)
  encoding_type=FT_ENCODING_UNICODE;
else
  encoding_type=FT_ENCODING_UNICODE;

ft_status=FT_Select_Charmap(face,encoding_type);
if ((ft_status!= 0) && (face->num_charmaps!= 0))
  ft_status=FT_Set_Charmap(face,face->charmaps[0]);
if (ft_status!= 0)
  {
    (void) FT_Done_FreeType(library);
    ThrowFreetypeErrorException("UnableToSelectCharmap",ft_status,encoding);
    return(MagickFalse);
  }

// Set the character size for the font face based on the point size and
// resolution specified in the DrawInfo structure. Adjust the resolution
// if a custom density is provided.
resolution.x=draw_info->pointsize;
resolution.y=draw_info->density!= 0? draw_info->density : 72.0;
ft_status=FT_Set_Char_Size(face,0,FT_LongCeil(resolution.x*64.0),
  FT_LongCeil(resolution.y*64.0),0,0);
if (ft_status!= 0)
  {
    (void) FT_Done_FreeType(library);
    ThrowFreetypeErrorException("UnableToSetCharSize",ft_status,
      draw_info->font);
    return(MagickFalse);
  }

// Initialize the TypeMetric structure with font size metrics such as ascent,
// descent, width, height, and maximum advance. If necessary, sanitize any
// incorrect ascender and descender values. Calculate underline position and
// thickness based on the font's properties.
metrics->ascender=face->size->metrics.ascender>>6;
metrics->descender=face->size->metrics.descender>>6;
metrics->width=face->size->metrics.width>>6;
metrics->height=face->size->metrics.height>>6;
metrics->max_advance=face->size->metrics.max_advance>>6;
if (metrics->ascender < 0)
  metrics->ascender=0;
if (metrics->descender > 0)
  metrics->descender=0;
metrics->underline_position=face->underline_position>>6;
metrics->underline_thickness=face->underline_thickness>>6;

// If there is no text to render, or no glyphs in the font, clean up resources
// and return a successful status without proceeding further.
if ((draw_info->text == (char *) NULL) || (*draw_info->text == '\0') ||
    (face->num_glyphs == 0))
  {
    (void) FT_Done_FreeType(library);
    return(MagickTrue);
  }

// Configure rendering options such as anti-aliasing and hinting based on
// the DrawInfo settings and image properties. Prepare structures for
// rendering each glyph in the text string, transforming the glyphs according
// to specified affine transformations.
flags=FT_LOAD_RENDER;
if (draw_info->stroke_width!= 0.0)
  flags|=FT_LOAD_NO_BITMAP;
if (draw_info->stroke_antialias!= MagickFalse)
  flags|=FT_LOAD_TARGET_NORMAL;
else
  flags|=FT_LOAD_TARGET_MONO;
if (draw_info->hinting!= MagickFalse)
  flags|=FT_LOAD_FORCE_AUTOHINT;
else
  flags|=FT_LOAD_NO_AUTOHINT;
if (draw_info->rendering == 0)
  flags|=FT_LOAD_TARGET_MONO;
else if (draw_info->rendering == 1)
  flags|=FT_LOAD_TARGET_LIGHT;
else if (draw_info->rendering == 2)
  flags|=FT_LOAD_TARGET_NORMAL;
else if (draw_info->rendering == 3)
  flags|=FT_LOAD_TARGET_LCD;
else if (draw_info->rendering == 4)
  flags|=FT_LOAD_TARGET_LCD_V;
if (draw_info->direction == RightToLeftDirection)
  {
    FT_Matrix matrix;

    matrix.xx=(FT_Fixed) (cos(draw_info->affine.x)*64.0);
    matrix.xy=(FT_Fixed) (sin(draw_info->affine.x)*64.0);
    matrix.yx=(FT_Fixed) (-sin(draw_info->affine.x)*64.0);
    matrix.yy=(FT_Fixed) (cos(draw_info->affine.x)*64.0);
    FT_Set_Transform(face,&matrix,&origin);
  }
else
  {
    FT_Matrix matrix;

    matrix.xx=(FT_Fixed) (cos(draw_info->affine.x)*64.0);
    matrix.xy=(FT_Fixed) (-sin(draw_info->affine.x)*64.0);
    matrix.yx=(FT_Fixed) (sin(draw_info->affine.x)*64.0);
    matrix.yy=(FT_Fixed) (cos(draw_info->affine.x)*64.0);
    FT_Set_Transform(face,&matrix,&origin);
  }

// Loop through each character in the text, rendering glyphs, tracing outlines
// if necessary, and rasterizing the glyphs onto the image. Adjust the
// position and metrics of each rendered glyph, and update the bounding box
// of the text as needed. Manage resources and synchronize image data
// appropriately during the rendering process.
length=strlen(draw_info->text);
grapheme=(GraphemeInfo *) NULL;
ComplexTextLayout(img,draw_info,draw_info->text,length,face,flags,&grapheme,
  exception);
if (grapheme == (GraphemeInfo *) NULL)
  {
    (void) FT_Done_FreeType(library);
    return(MagickFalse);
  }
for (i=0; i < (ssize_t) length; i++)
  {
    FT_UInt glyph_index;

    glyph_index=(FT_UInt) grapheme[i].index;
    ft_status=FT_Load_Glyph(face,glyph_index,flags);
    if (ft_status!= 0)
      {
        (void) FT_Done_FreeType(library);
        ThrowFreetypeErrorException("UnableToLoadGlyph",ft_status,
          draw_info->text);
        grapheme=(GraphemeInfo *) RelinquishMagickMemory(grapheme);
        return(MagickFalse);
      }
    if (draw_info->stroke_width!= 0.0)
      {
        FT_Outline outline;

        outline=face->glyph->outline;
        glyph.id=glyph_index;
        glyph.origin.x=grapheme[i].x_offset;
        glyph.origin.y=grapheme[i].y_offset;
        glyph.image=face->glyph;
        (void) TraceOutline(&glyph,&outline,&OutlineMethods);
      }
    else
      {
        FT_BitmapGlyph bitmap;

        bitmap=(FT_BitmapGlyph) face->glyph;
        glyph.id=glyph_index;
        glyph.origin.x=grapheme[i].x_offset;
        glyph.origin.y=grapheme[i].y_offset;
        glyph.image=face->glyph;
        (void) RenderGlyph(img,draw_info,&glyph,offset,metrics,exception);
      }
    if (draw_info->direction == RightToLeftDirection)
      offset->x-=grapheme[i].x_advance;
    else
      offset->x+=grapheme[i].x_advance;
  }
grapheme=(GraphemeInfo *) RelinquishMagickMemory(grapheme);

// Finalize the font metrics by normalizing the bounding box coordinates and
// width. Clean up any remaining resources and return the rendering status.
metrics->width=offset->x;
metrics->x=offset->x;
metrics->y=offset->y;
bounds.xMin=0;
bounds.yMin=0;
bounds.xMax=offset->x;
bounds.yMax=offset->y;
(void) FT_Done_FreeType(library);
return(MagickTrue);