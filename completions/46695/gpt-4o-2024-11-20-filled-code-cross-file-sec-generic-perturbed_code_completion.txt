/*
    Select the appropriate character map (encoding) for the font face.
  */
  if (encoding != (const char *) NULL)
  {
    if (LocaleCompare(encoding, "UTF-8") == 0)
      encoding_type = FT_ENCODING_UNICODE;
    else if (LocaleCompare(encoding, "ISO-8859-1") == 0)
      encoding_type = FT_ENCODING_ADOBE_LATIN_1;
    else if (LocaleCompare(encoding, "ISO-8859-5") == 0)
      encoding_type = FT_ENCODING_ADOBE_STANDARD;
    else if (LocaleCompare(encoding, "Symbol") == 0)
      encoding_type = FT_ENCODING_MS_SYMBOL;
    else
      encoding_type = FT_ENCODING_NONE;

    if (encoding_type != FT_ENCODING_NONE)
    {
      ft_status = FT_Select_Charmap(face, encoding_type);
      if (ft_status != 0)
      {
        (void) FT_Done_Face(face);
        (void) FT_Done_FreeType(library);
        ThrowFreetypeErrorException("UnableToSelectCharmap", ft_status, encoding);
        return MagickFalse;
      }
    }
  }

  /*
    Set the character size for the font face.
  */
  resolution.x = draw_info->density != (char *) NULL ? StringToDouble(draw_info->density, NULL) : 72.0;
  resolution.y = resolution.x;
  ft_status = FT_Set_Char_Size(face, 0, (FT_F26Dot6)(64.0 * draw_info->pointsize), (FT_UInt)resolution.x, (FT_UInt)resolution.y);
  if (ft_status != 0)
  {
    (void) FT_Done_Face(face);
    (void) FT_Done_FreeType(library);
    ThrowFreetypeErrorException("UnableToSetFontSize", ft_status, img->filename);
    return MagickFalse;
  }

  /*
    Initialize font metrics.
  */
  metrics->ascent = (double)face->size->metrics.ascender / 64.0;
  metrics->descent = (double)face->size->metrics.descender / 64.0;
  metrics->width = 0.0;
  metrics->height = metrics->ascent - metrics->descent;
  metrics->max_advance = (double)face->size->metrics.max_advance / 64.0;
  metrics->underline_position = (double)face->underline_position / 64.0;
  metrics->underline_thickness = (double)face->underline_thickness / 64.0;

  if (metrics->underline_position > -2.0)
    metrics->underline_position = -2.0;
  if (metrics->underline_thickness < 1.0)
    metrics->underline_thickness = 1.0;

  /*
    Check if there is text to render or glyphs in the font.
  */
  if (draw_info->text == (char *)NULL || *draw_info->text == '\0' || face->num_glyphs == 0)
  {
    (void)FT_Done_Face(face);
    (void)FT_Done_FreeType(library);
    return MagickTrue;
  }

  /*
    Configure rendering options.
  */
  flags = FT_LOAD_DEFAULT;
  if (draw_info->rendering_intent == AbsoluteColorimetricIntent)
    flags |= FT_LOAD_NO_HINTING;
  if (draw_info->antialias == MagickFalse)
    flags |= FT_LOAD_MONOCHROME;

  /*
    Render each glyph in the text.
  */
  utf8 = (unsigned char *)draw_info->text;
  length = strlen(draw_info->text);
  grapheme = (GraphemeInfo *)NULL;
  status = MagickTrue;

  if (ComplexTextLayout(img, draw_info, (const char *)utf8, length, face, flags, &grapheme, exception) == 0)
  {
    (void)FT_Done_Face(face);
    (void)FT_Done_FreeType(library);
    return MagickFalse;
  }

  /*
    Finalize font metrics and clean up.
  */
  metrics->width = 0.0;
  for (i = 0; i < (ssize_t)length; i++)
    metrics->width += grapheme[i].x_advance / 64.0;

  (void)FT_Done_Face(face);
  (void)FT_Done_FreeType(library);
  grapheme = (GraphemeInfo *)RelinquishMagickMemory(grapheme);

  return status;