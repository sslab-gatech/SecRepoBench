// Select the appropriate character map (encoding) for the font face based on
  // the provided encoding string. If an encoding is specified, determine the
  // corresponding FreeType encoding type using a series of string comparisons.
  // If the encoding type is successfully determined, apply it to the font face.
  // If the encoding type cannot be applied, handle the error by cleaning up
  // resources and throwing an exception.

  if (encoding != (const char *) NULL)
  {
    if (strcmp(encoding, "UTF-8") == 0)
    {
      encoding_type = FT_ENCODING_UTF8;
    }
    else if (strcmp(encoding, "Unicode") == 0)
    {
      encoding_type = FT_ENCODING_UNICODE;
    }
    else if (strcmp(encoding, "Windows-1252") == 0)
    {
      encoding_type = FT_ENCODING_MS_SYMBOL;
    }
    else
    {
      ThrowFreetypeErrorException("UnsupportedEncoding", 0, encoding);
      FT_Done_FreeType(library);
      return MagickFalse;
    }
  }
  else
  {
    encoding_type = FT_ENCODING_UNICODE;
  }

  ft_status = FT_Select_Charmap(face, encoding_type);
  if (ft_status != 0)
  {
    ThrowFreetypeErrorException("UnableToSelectCharmap", ft_status, encoding);
    FT_Done_FreeType(library);
    return MagickFalse;
  }

  // Set the character size for the font face based on the point size and
  // resolution specified in the DrawInfo structure. Adjust the resolution
  // if a custom density is provided. If setting the character size fails,
  // handle the error by cleaning up resources and throwing an exception.

  resolution.x = draw_info->density.x;
  resolution.y = draw_info->density.y;
  if (resolution.x == 0)
  {
    resolution.x = 72; // Default resolution
  }
  if (resolution.y == 0)
  {
    resolution.y = 72; // Default resolution
  }

  ft_status = FT_Set_Char_Size(face, 0, draw_info->pointsize * 64, resolution.x, resolution.y);
  if (ft_status != 0)
  {
    ThrowFreetypeErrorException("UnableToSetCharacterSize", ft_status, draw_info->font);
    FT_Done_FreeType(library);
    return MagickFalse;
  }

  // Initialize the TypeMetric structure with font size metrics such as ascent,
  // descent, width, height, and maximum advance. If necessary, sanitize any
  // incorrect ascender and descender values. Calculate underline position and
  // thickness based on the font's properties.

  metrics->ascent = face->size->metrics.ascender / 64.0;
  metrics->descent = face->size->metrics.descender / 64.0;
  metrics->width = face->size->metrics.max_advance / 64.0;
  metrics->height = (metrics->ascent - metrics->descent);

  // If there is no text to render, or no glyphs in the font, clean up resources
  // and return a successful status without proceeding further.

  if (text == NULL || length == 0)
  {
    FT_Done_FreeType(library);
    return MagickTrue;
  }

  // Configure rendering options such as anti-aliasing and hinting based on
  // the DrawInfo settings and image properties. Prepare structures for
  // rendering each glyph in the text string, transforming the glyphs according
  // to specified affine transformations.

  flags = FT_LOAD_DEFAULT;
  if (draw_info->antialias)
  {
    flags |= FT_LOAD_TARGET_NORMAL;
  }
  else
  {
    flags |= FT_LOAD_TARGET_MONO;
  }

  // Loop through each character in the text, rendering glyphs, tracing outlines
  // if necessary, and rasterizing the glyphs onto the image. Adjust the
  // position and metrics of each rendered glyph, and update the bounding box
  // of the text as needed. Manage resources and synchronize image data
  // appropriately during the rendering process.

  for (i = 0; i < length; i++)
  {
    code = GetUTFCode(text + i);
    ft_status = FT_Load_Char(face, code, flags);
    if (ft_status != 0)
    {
      ThrowFreetypeErrorException("UnableToLoadGlyph", ft_status, (char *)code);
      FT_Done_FreeType(library);
      return MagickFalse;
    }

    glyph.id = code;
    glyph.origin.x = face->glyph->bitmap_left;
    glyph.origin.y = face->glyph->bitmap_top;
    glyph.image = face->glyph->glyph;

    // Adjust the position and metrics of each rendered glyph
    point.x = offset->x + glyph.origin.x;
    point.y = offset->y + glyph.origin.y;

    // Update the bounding box of the text
    if (point.x < metrics->width)
    {
      metrics->width = point.x;
    }
    if (point.y < metrics->height)
    {
      metrics->height = point.y;
    }
  }

  // Finalize the font metrics by normalizing the bounding box coordinates and
  // width. Clean up any remaining resources and return the rendering status.

  metrics->width = metrics->width;
  metrics->height = metrics->height;

  FT_Done_FreeType(library);
  return MagickTrue;