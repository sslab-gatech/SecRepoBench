if (encoding != (const char *) NULL)
  {
    if (LocaleCompare(encoding,"UTF-8") == 0)
      encoding_type=FT_ENCODING_UNICODE;
    else
      if (LocaleCompare(encoding,"AdobeCustom") == 0)
        encoding_type=FT_ENCODING_ADOBE_CUSTOM;
      else
        if (LocaleCompare(encoding,"AdobeExpert") == 0)
          encoding_type=FT_ENCODING_ADOBE_EXPERT;
        else
          if (LocaleCompare(encoding,"AdobeStandard") == 0)
            encoding_type=FT_ENCODING_ADOBE_STANDARD;
          else
            if (LocaleCompare(encoding,"AppleRoman") == 0)
              encoding_type=FT_ENCODING_APPLE_ROMAN;
            else
              if (LocaleCompare(encoding,"BIG5") == 0)
                encoding_type=FT_ENCODING_BIG5;
              else
                if (LocaleCompare(encoding,"GB2312") == 0)
                  encoding_type=FT_ENCODING_PRC;
                else
                  if (LocaleCompare(encoding,"Johab") == 0)
                    encoding_type=FT_ENCODING_JOHAB;
                  else
                    if (LocaleCompare(encoding,"MacRoman") == 0)
                      encoding_type=FT_ENCODING_APPLE_ROMAN;
                    else
                      if (LocaleCompare(encoding,"MS-ANSI") == 0)
                        encoding_type=FT_ENCODING_MS_SYMBOL;
                      else
                        if (LocaleCompare(encoding,"MS-Greek") == 0)
                          encoding_type=FT_ENCODING_MS_GREEK;
                        else
                          if (LocaleCompare(encoding,"MS-Hangul") == 0)
                            encoding_type=FT_ENCODING_MS_HANGUL;
                          else
                            if (LocaleCompare(encoding,"MS-HebrewSJIS") == 0)
                              encoding_type=FT_ENCODING_MS_SJIS;
                            else
                              if (LocaleCompare(encoding,"MS-Shift-JIS") == 0)
                                encoding_type=FT_ENCODING_MS_SJIS;
                              else
                                if (LocaleCompare(encoding,"MS-Symbol") == 0)
                                  encoding_type=FT_ENCODING_MS_SYMBOL;
                                else
                                  if (LocaleCompare(encoding,"MS-Turkish") == 0)
                                    encoding_type=FT_ENCODING_MS_SYMBOL;
                                  else
                                    if (LocaleCompare(encoding,"None") == 0)
                                      encoding_type=FT_ENCODING_NONE;
                                    else
                                      if (LocaleCompare(encoding,"SJIScode") == 0)
                                        encoding_type=FT_ENCODING_SJIS;
                                      else
                                        if (LocaleCompare(encoding,"Symbol") == 0)
                                          encoding_type=FT_ENCODING_MS_SYMBOL;
                                        else
                                          if (LocaleCompare(encoding,"Unicode") == 0)
                                            encoding_type=FT_ENCODING_UNICODE;
                                          else
                                            if (LocaleCompare(encoding,"Wansung") == 0)
                                              encoding_type=FT_ENCODING_WANSUNG;
    ft_status=FT_Select_Charmap(face,encoding_type);
    if (ft_status != 0)
      {
        FT_Done_Face(face);
        FT_Done_FreeType(library);
        ThrowFreetypeErrorException("UnableToSetEncoding",ft_status,
          encoding);
      }
  }
  /*
    Set text size.
  */
  resolution.x=DefaultResolution;
  resolution.y=DefaultResolution;
  if (draw_info->density != (char *) NULL)
    {
      GeometryInfo
        geometry_info;

      MagickStatusType
        flags;

      flags=ParseGeometry(draw_info->density,&geometry_info);
      resolution.x=geometry_info.rho;
      resolution.y=geometry_info.sigma;
      if ((flags & SigmaValue) == 0)
        resolution.y=resolution.x;
    }
  ft_status=FT_Set_Char_Size(face,(FT_F26Dot6) (64.0*draw_info->pointsize),
    (FT_F26Dot6) (64.0*draw_info->pointsize),(FT_UInt) resolution.x,
    (FT_UInt) resolution.y);
  if (ft_status != 0)
    {
      FT_Done_Face(face);
      FT_Done_FreeType(library);
      ThrowFreetypeErrorException("UnableToSetTextSize",ft_status,
        draw_info->font);
    }
  metrics->pixels_per_em.x=face->size->metrics.x_ppem;
  metrics->pixels_per_em.y=face->size->metrics.y_ppem;
  metrics->ascent=(double) face->size->metrics.ascender/64.0;
  metrics->descent=(double) face->size->metrics.descender/64.0;
  metrics->width=0;
  metrics->origin.x=0;
  metrics->origin.y=0;
  metrics->height=(double) face->size->metrics.height/64.0;
  metrics->max_advance=(double) face->size->metrics.max_advance/64.0;
  if (face->size->metrics.ascender == 0)
    {
      metrics->ascent=(double) face->ascender/64.0;
      metrics->descent=(double) face->descender/64.0;
      metrics->height=(double) face->height/64.0;
    }
  if (face->size->metrics.ascender == 0)
    {
      metrics->ascent=(double) face->bbox.yMax/64.0;
      metrics->descent=(double) face->bbox.yMin/64.0;
      metrics->height=metrics->ascent-metrics->descent;
    }
  metrics->underline_position=face->underline_position/64.0;
  metrics->underline_thickness=face->underline_thickness/64.0;
  if ((draw_info->text == (char *) NULL) || (*draw_info->text == '\0') ||
      (face->glyph == (FT_GlyphSlot) NULL))
    {
      FT_Done_Face(face);
      FT_Done_FreeType(library);
      return(MagickTrue);
    }
  /*
    Compute bounding box.
  */
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(AnnotateEvent,GetMagickModule(),
      "Font %s; pointsize %g",draw_info->font != (char *) NULL ?
      draw_info->font : "none",draw_info->pointsize);
  flags=FT_LOAD_DEFAULT;
  if (draw_info->text_antialias == MagickFalse)
    flags|=FT_LOAD_TARGET_MONO;
  else
    {
      if (draw_info->stroke.alpha == TransparentAlpha)
        flags|=FT_LOAD_TARGET_LIGHT;
      else
        flags|=FT_LOAD_TARGET_NORMAL;
    }
  flags|=FT_LOAD_NO_BITMAP;
  if (draw_info->render == MagickFalse)
    flags|=FT_LOAD_NO_BITMAP;
  value=GetImageProperty(img,"type:hinting",exception);
  if ((value != (const char *) NULL) && (LocaleCompare(value,"off") == 0))
    flags|=FT_LOAD_NO_HINTING;
  glyph.id=0;
  glyph.image=NULL;
  last_glyph_id=0;
  origin.x=0;
  origin.y=0;
  affine.xx=65536L;
  affine.yx=0L;
  affine.xy=0L;
  affine.yy=65536L;
  if (draw_info->render != MagickFalse)
    {
      affine.xx=(FT_Fixed) (65536L*draw_info->affine.sx+0.5);
      affine.yx=(FT_Fixed) (-65536L*draw_info->affine.rx+0.5);
      affine.xy=(FT_Fixed) (-65536L*draw_info->affine.ry+0.5);
      affine.yy=(FT_Fixed) (65536L*draw_info->affine.sy+0.5);
    }
  annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
  if (annotate_info->dash_pattern != (double *) NULL)
    annotate_info->dash_pattern[0]=0.0;
  (void) CloneString(&annotate_info->primitive,"path '");
  status=MagickTrue;
  if (draw_info->render != MagickFalse)
    {
      if (image->storage_class != DirectClass)
        (void) SetImageStorageClass(img,DirectClass,exception);
      if (image->alpha_trait == UndefinedPixelTrait)
        (void) SetImageAlphaChannel(img,OpaqueAlphaChannel,exception);
    }
  grapheme=(GraphemeInfo *) NULL;
  length=ComplexTextLayout(img,draw_info,draw_info->text,
    strlen(draw_info->text),face,flags,&grapheme,exception);
  if (length == 0)
    ThrowBinaryException(DrawError,"UnableToFormatText",draw_info->text);
  first_glyph_id=grapheme[0].index;
  missing_glyph_id=FT_Get_Char_Index(face,' ');
  for (i=0; i < (ssize_t) length; i++)
  {
    if (grapheme[i].index == 0)
      grapheme[i].index=missing_glyph_id;
    ft_status=FT_Load_Glyph(face,grapheme[i].index,flags);
    if (ft_status != 0)
      continue;
    ft_status=FT_Get_Glyph(face->glyph,&glyph.image);
    if (ft_status != 0)
      continue;
    ft_status=FT_Outline_Get_BBox(&((FT_OutlineGlyph) glyph.image)->outline,
      &bounds);
    if (ft_status != 0)
      continue;
    if ((p.x+grapheme[i].x_offset+bounds.xMax) > metrics->width)
      metrics->width=p.x+grapheme[i].x_offset+bounds.xMax;
    if ((fabs(bounds.yMin) > metrics->descent) && (bounds.yMin < 0.0))
      metrics->descent=fabs(bounds.yMin);
    if ((p.y-grapheme[i].y_offset+bounds.yMax) > metrics->ascent)
      metrics->ascent=p.y-grapheme[i].y_offset+bounds.yMax;
    FT_Done_Glyph(glyph.image);
    glyph.image=NULL;
    p.x+=grapheme[i].x_advance;
    p.y+=grapheme[i].y_advance;
  }
  metrics->width/=64.0;
  metrics->ascent/=64.0;
  metrics->descent/=64.0;
  metrics->height=(double) (metrics->ascent-metrics->descent+0.5)