/*
    Select encoding if specified.
  */
  if ((encoding != (const char *) NULL) && (*encoding != '\0'))
    {
      if (LocaleCompare(encoding,"AppleRoman") == 0)
        encoding_type=FT_ENCODING_APPLE_ROMAN;
      else if (LocaleCompare(encoding,"Big5") == 0)
        encoding_type=FT_ENCODING_BIG5;
      else if (LocaleCompare(encoding,"GB2312") == 0)
        encoding_type=FT_ENCODING_PRC;
      else if (LocaleCompare(encoding,"SJIS") == 0)
        encoding_type=FT_ENCODING_SJIS;
      else if (LocaleCompare(encoding,"Unicode") == 0)
        encoding_type=FT_ENCODING_UNICODE;
      else if (LocaleCompare(encoding,"Wansung") == 0)
        encoding_type=FT_ENCODING_WANSUNG;
      else if (LocaleCompare(encoding,"Latin2") == 0)
        encoding_type=FT_ENCODING_ISO_8859_2;
      else if (LocaleCompare(encoding,"Symbol") == 0)
        encoding_type=FT_ENCODING_MS_SYMBOL;
      else if (LocaleCompare(encoding,"AdobeCustom") == 0)
        encoding_type=FT_ENCODING_ADOBE_CUSTOM;
      else if (LocaleCompare(encoding,"AdobeExpert") == 0)
        encoding_type=FT_ENCODING_ADOBE_EXPERT;
      else if (LocaleCompare(encoding,"AdobeStandard") == 0)
        encoding_type=FT_ENCODING_ADOBE_STANDARD;
      else if (LocaleCompare(encoding,"Latin1") == 0)
        encoding_type=FT_ENCODING_ADOBE_LATIN_1;
      else
        encoding_type=FT_ENCODING_NONE;
      ft_status=FT_Select_Charmap(face,encoding_type);
      if ((ft_status != 0) && (face->num_charmaps != 0))
        ft_status=FT_Set_Charmap(face,face->charmaps[0]);
      if (ft_status != 0)
        {
          (void) FT_Done_Face(face);
          (void) FT_Done_FreeType(library);
          ThrowFreetypeErrorException("UnableToSetFontEncoding",ft_status,encoding);
          (void) fclose((FILE *) stream->descriptor.pointer);
          stream=(FT_StreamRec *) RelinquishMagickMemory(stream);
          return(MagickFalse);
        }
    }

  /*
    Set character size.
  */
  resolution.x=draw_info->density;
  resolution.y=draw_info->density;
  if ((draw_info->density != 0.0) && (draw_info->density != 72.0))
    {
      resolution.x=draw_info->density;
      resolution.y=draw_info->density;
    }
  else if ((img->resolution.x > 0.0) && (img->resolution.y > 0.0))
    {
      resolution.x=img->resolution.x;
      resolution.y=img->resolution.y;
    }
  else
    {
      resolution.x=72.0;
      resolution.y=72.0;
    }
  ft_status=FT_Set_Char_Size(face,0,(FT_F26Dot6) (draw_info->pointsize*64.0),
    (FT_UInt) resolution.x,(FT_UInt) resolution.y);
  if (ft_status != 0)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      ThrowFreetypeErrorException("UnableToSetFontSize",ft_status,args.pathname);
      (void) fclose((FILE *) stream->descriptor.pointer);
      stream=(FT_StreamRec *) RelinquishMagickMemory(stream);
      return(MagickFalse);
    }

  /*
    Initialize font metrics.
  */
  (void) memset(metrics,0,sizeof(*metrics));
  metrics->pixels_per_em.x=(double) face->size->metrics.x_ppem;
  metrics->pixels_per_em.y=(double) face->size->metrics.y_ppem;
  metrics->ascent=(double) (face->size->metrics.ascender/64.0);
  metrics->descent=(double) (face->size->metrics.descender/64.0);
  metrics->width=0.0;
  metrics->height=(double) ((face->size->metrics.height > 0) ?
    (face->size->metrics.height/64.0) : (metrics->ascent-metrics->descent));
  metrics->max_advance=(double) (face->size->metrics.max_advance/64.0);

  /* Sanitize ascender/descender if necessary */
  if ((metrics->ascent < 0.0) || (metrics->descent > 0.0))
    {
      metrics->ascent=(double) (face->ascender*draw_info->pointsize/
        face->units_per_EM);
      metrics->descent=(double) (face->descender*draw_info->pointsize/
        face->units_per_EM);
    }

  /* Underline position/thickness */
  metrics->underline_position=(double) (face->underline_position*draw_info->pointsize/
    face->units_per_EM);
  metrics->underline_thickness=(double) (face->underline_thickness*draw_info->pointsize/
    face->units_per_EM);

  /*
    If no text or no glyphs, cleanup and return.
  */
  if ((draw_info->text == (char *) NULL) || (*draw_info->text == '\0') ||
      (face->num_glyphs == 0))
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      (void) fclose((FILE *) stream->descriptor.pointer);
      stream=(FT_StreamRec *) RelinquishMagickMemory(stream);
      return(MagickTrue);
    }

  /*
    Configure rendering options.
  */
  flags=FT_LOAD_DEFAULT;
  if ((draw_info->render == MagickFalse) || (draw_info->antialias == MagickFalse))
    flags|=FT_LOAD_MONOCHROME;
  if (draw_info->hinting == MagickFalse)
    flags|=FT_LOAD_NO_HINTING;

  /*
    Layout text and get grapheme info.
  */
  length=strlen(draw_info->text);
  grapheme=(GraphemeInfo *) NULL;
  size_t glyph_count=ComplexTextLayout(img,draw_info,draw_info->text,length,face,flags,&grapheme,exception);

  /*
    Prepare for rendering.
  */
  point.x=offset->x;
  point.y=offset->y;
  affine.xx=(FT_Fixed) (draw_info->affine.sx*65536.0);
  affine.xy=(FT_Fixed) (draw_info->affine.rx*65536.0);
  affine.yx=(FT_Fixed) (draw_info->affine.ry*65536.0);
  affine.yy=(FT_Fixed) (draw_info->affine.sy*65536.0);

  /* Initialize bounding box */
  bounds.xMin=bounds.yMin=LONG_MAX;
  bounds.xMax=bounds.yMax=LONG_MIN;

  status=MagickTrue;
  for (i=0; i < (ssize_t) glyph_count; i++)
    {
      FT_UInt glyph_index=(FT_UInt) grapheme[i].index;
      if (glyph_index == 0)
        continue;
      ft_status=FT_Load_Glyph(face,glyph_index,flags);
      if (ft_status != 0)
        {
          status=MagickFalse;
          continue;
        }
      /* Transform glyph if needed */
      FT_Set_Transform(face,&affine,&origin);

      /* Render glyph to bitmap */
      if (draw_info->render != MagickFalse)
        {
          ft_status=FT_Render_Glyph(face->glyph,((flags & FT_LOAD_MONOCHROME) ? FT_RENDER_MODE_MONO : FT_RENDER_MODE_NORMAL));
          if (ft_status != 0)
            {
              status=MagickFalse;
              continue;
            }
          bitmap=(FT_BitmapGlyph) NULL;
          ft_status=FT_Get_Glyph(face->glyph,&glyph.image);
          if (ft_status == 0)
            {
              if (glyph.image->format == FT_GLYPH_FORMAT_BITMAP)
                bitmap=(FT_BitmapGlyph) glyph.image;
              else
                {
                  ft_status=FT_Glyph_To_Bitmap(&glyph.image,((flags & FT_LOAD_MONOCHROME) ? FT_RENDER_MODE_MONO : FT_RENDER_MODE_NORMAL),0,1);
                  if (ft_status == 0)
                    bitmap=(FT_BitmapGlyph) glyph.image;
                }
            }
          if (bitmap != (FT_BitmapGlyph) NULL)
            {
              /* Composite bitmap onto image at (point.x, point.y) */
              /* ... (actual compositing code omitted for brevity) ... */
              FT_Done_Glyph(glyph.image);
            }
        }
      /* Update bounding box */
      FT_BBox glyph_bbox;
      FT_Outline_Get_CBox(&face->glyph->outline,&glyph_bbox);
      if (glyph_bbox.xMin < bounds.xMin)
        bounds.xMin=glyph_bbox.xMin;
      if (glyph_bbox.yMin < bounds.yMin)
        bounds.yMin=glyph_bbox.yMin;
      if (glyph_bbox.xMax > bounds.xMax)
        bounds.xMax=glyph_bbox.xMax;
      if (glyph_bbox.yMax > bounds.yMax)
        bounds.yMax=glyph_bbox.yMax;

      /* Advance to next glyph position */
      point.x+=(double) (grapheme[i].x_advance/64.0);
      point.y+=(double) (grapheme[i].y_advance/64.0);
    }

  /* Normalize bounding box and width */
  metrics->bounds.x1=(double) bounds.xMin/64.0;
  metrics->bounds.y1=(double) bounds.yMin/64.0;
  metrics->bounds.x2=(double) bounds.xMax/64.0;
  metrics->bounds.y2=(double) bounds.yMax/64.0;
  metrics->width=point.x-offset->x;

  /* Cleanup */
  if (grapheme != (GraphemeInfo *) NULL)
    grapheme=(GraphemeInfo *) RelinquishMagickMemory(grapheme);
  (void) FT_Done_Face(face);
  (void) FT_Done_FreeType(library);
  (void) fclose((FILE *) stream->descriptor.pointer);
  stream=(FT_StreamRec *) RelinquishMagickMemory(stream);

  return(status);