if (encoding != (const char *) NULL)
    {
      if (LocaleCompare(encoding,"AdobeStandard") == 0)
        encoding_type=FT_ENCODING_ADOBE_STANDARD;
      else if (LocaleCompare(encoding,"AdobeExpert") == 0)
        encoding_type=FT_ENCODING_ADOBE_EXPERT;
      else if (LocaleCompare(encoding,"AdobeCustom") == 0)
        encoding_type=FT_ENCODING_ADOBE_CUSTOM;
      else if (LocaleCompare(encoding,"AppleRoman") == 0)
        encoding_type=FT_ENCODING_APPLE_ROMAN;
      else if (LocaleCompare(encoding,"Unicode") == 0)
        encoding_type=FT_ENCODING_UNICODE;
      else if (LocaleCompare(encoding,"Symbol") == 0)
        encoding_type=FT_ENCODING_MS_SYMBOL;
      else if (LocaleCompare(encoding,"SJIS") == 0)
        encoding_type=FT_ENCODING_SJIS;
      else if (LocaleCompare(encoding,"GB2312") == 0)
        encoding_type=FT_ENCODING_GB2312;
      else if (LocaleCompare(encoding,"Big5") == 0)
        encoding_type=FT_ENCODING_BIG5;
      else if (LocaleCompare(encoding,"Wansung") == 0)
        encoding_type=FT_ENCODING_WANSUNG;
      else if (LocaleCompare(encoding,"Johab") == 0)
        encoding_type=FT_ENCODING_JOHAB;
      ft_status=FT_Select_Charmap(face,encoding_type);
      if (ft_status != 0)
        {
          (void) FT_Done_Face(face);
          (void) FT_Done_FreeType(library);
          ThrowFreetypeErrorException("UnableToSetFontEncoding",ft_status,
            encoding);
          return(MagickFalse);
        }
    }

  resolution.x=draw_info->density == (char *) NULL ? 96.0 :
    StringToDouble(draw_info->density,&p);
  resolution.y=resolution.x;
  if ((draw_info->density != (char *) NULL) && (*p == 'x'))
    resolution.y=StringToDouble(p+1,&p);
  ft_status=FT_Set_Char_Size(face,(FT_F26Dot6) (draw_info->pointsize*64.0+0.5),
    0,(FT_UInt) (resolution.x*64.0+0.5),(FT_UInt) (resolution.y*64.0+0.5));
  if (ft_status != 0)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      ThrowFreetypeErrorException("UnableToSetFontPointSize",ft_status,
        draw_info->font);
      return(MagickFalse);
    }

  if (metrics != (TypeMetric *) NULL)
    {
      metrics->pixels_per_em=(double) face->size->metrics.x_ppem;
      metrics->ascent=(double) face->size->metrics.ascender/64.0;
      metrics->descent=(double) face->size->metrics.descender/64.0;
      metrics->width=(double) face->size->metrics.max_advance/64.0;
      metrics->height=metrics->ascent-metrics->descent;
      metrics->max_advance=(double) face->size->metrics.max_advance/64.0;
      if ((face->ascender == 0) && (face->descender == 0))
        {
          metrics->ascent=metrics->height*0.8;
          metrics->descent=metrics->height*0.2;
        }
      metrics->underline_position=(double) face->underline_position/64.0;
      metrics->underline_thickness=(double) face->underline_thickness/64.0;
    }

  if ((draw_info->text == (char *) NULL) || (*draw_info->text == '\0') ||
      (face->num_glyphs == 0))
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      return(MagickTrue);
    }

  flags=FT_LOAD_DEFAULT;
  if ((draw_info->style & AnyStyle) == NoStyle)
    flags|=FT_LOAD_NO_HINTING;
  if ((draw_info->style & AnyStyle) == ItalicStyle)
    flags|=FT_LOAD_NO_BITMAP;
  if ((img->storage_class == PseudoClass) && (img->colors == 1))
    flags|=FT_LOAD_MONOCHROME;

  (void) memset(&glyph,0,sizeof(glyph));
  (void) memset(&origin,0,sizeof(origin));
  (void) memset(&bounds,0,sizeof(bounds));
  bounds.xMin=32767;
  bounds.yMin=32767;
  bounds.xMax=-32768;
  bounds.yMax=-32768;

  utf8=GetUTF8String(draw_info->text);
  if (utf8 == (unsigned char *) NULL)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
        img->filename);
      return(MagickFalse);
    }
  length=strlen((char *) utf8);
  grapheme=(GraphemeInfo *) NULL;
  length=ComplexTextLayout(img,draw_info,(char *) utf8,length,face,flags,
    &grapheme,exception);
  utf8=(unsigned char *) RelinquishMagickMemory(utf8);
  if (length == 0)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      return(MagickTrue);
    }

  status=MagickTrue;
  for (i=0; i < (ssize_t) length; i++)
  {
    if (grapheme[i].index == 0)
      continue;
    glyph.id=(FT_UInt) grapheme[i].index;
    ft_status=FT_Load_Glyph(face,glyph.id,flags);
    if (ft_status != 0)
      {
        status=MagickFalse;
        continue;
      }
    if (face->glyph->format == FT_GLYPH_FORMAT_OUTLINE)
      {
        FT_Outline_Translate(&face->glyph->outline,(FT_Pos) (offset->x+
          grapheme[i].x_offset),(FT_Pos) (offset->y+grapheme[i].y_offset));
        ft_status=FT_Get_Glyph(face->glyph,&glyph.image);
        if (ft_status != 0)
          {
            status=MagickFalse;
            continue;
          }
        FT_Glyph_Get_CBox(glyph.image,ft_glyph_bbox_pixels,&bounds);
        FT_Done_Glyph(glyph.image);
      }
    else
      {
        bitmap=(FT_BitmapGlyph) face->glyph;
        bounds.xMin=(FT_Pos) (offset->x+bitmap->left);
        bounds.yMin=(FT_Pos) (offset->y-bitmap->top);
        bounds.xMax=(FT_Pos) (bounds.xMin+bitmap->bitmap.width);
        bounds.yMax=(FT_Pos) (bounds.yMin+bitmap->bitmap.rows);
      }
    origin.x+=(FT_Pos) grapheme[i].x_advance;
    origin.y+=(FT_Pos) grapheme[i].y_offset;
  }

  if (metrics != (TypeMetric *) NULL)
    {
      metrics->bounds.x1=(double) bounds.xMin;
      metrics->bounds.y1=(double) bounds.yMin;
      metrics->bounds.x2=(double) bounds.xMax;
      metrics->bounds.y2=(double) bounds.yMax;
      metrics->width=(double) origin.x/64.0;
    }

  grapheme=(GraphemeInfo *) RelinquishMagickMemory(grapheme);
  (void) FT_Done_Face(face);
  (void) FT_Done_FreeType(library);
  return(status);