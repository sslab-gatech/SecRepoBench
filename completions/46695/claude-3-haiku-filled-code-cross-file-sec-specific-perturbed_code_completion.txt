// Select the appropriate character map (encoding) for the font face based on
// the provided encoding string. If an encoding is specified, determine the
// corresponding FreeType encoding type using a series of string comparisons.
// If the encoding type is successfully determined, apply it to the font face.
// If the encoding type cannot be applied, handle the error by cleaning up
// resources and throwing an exception.
if (encoding != NULL && *encoding != '\0') {
    if (strcasecmp(encoding, "unicode") == 0) {
        encoding_type = FT_ENCODING_UNICODE;
    } else if (strcasecmp(encoding, "symbol") == 0) {
        encoding_type = FT_ENCODING_MS_SYMBOL;
    } else if (strcasecmp(encoding, "shiftjis") == 0) {
        encoding_type = FT_ENCODING_SJIS;
    } else if (strcasecmp(encoding, "big5") == 0) {
        encoding_type = FT_ENCODING_BIG5;
    } else if (strcasecmp(encoding, "gb2312") == 0) {
        encoding_type = FT_ENCODING_GB2312;
    } else {
        (void) FT_Done_Face(face);
        (void) FT_Done_FreeType(library);
        ThrowFreetypeErrorException("UnsupportedEncoding", 0, encoding);
        return MagickFalse;
    }

    ft_status = FT_Select_Charmap(face, encoding_type);
    if (ft_status != 0) {
        (void) FT_Done_Face(face);
        (void) FT_Done_FreeType(library);
        ThrowFreetypeErrorException("UnableToSetCharMap", ft_status, encoding);
        return MagickFalse;
    }
}

// Set the character size for the font face based on the point size and
// resolution specified in the DrawInfo structure. Adjust the resolution
// if a custom density is provided. If setting the character size fails,
// handle the error by cleaning up resources and throwing an exception.
resolution.x = (draw_info->density != (char *) NULL) ?
    PerceptibleReciprocal(draw_info->density_x) : (double) DefaultResolution;
resolution.y = (draw_info->density != (char *) NULL) ?
    PerceptibleReciprocal(draw_info->density_y) : (double) DefaultResolution;
ft_status = FT_Set_Char_Size(face, 0, (FT_F26Dot6)(draw_info->pointsize * 64),
                            (unsigned int) resolution.x,
                            (unsigned int) resolution.y);
if (ft_status != 0) {
    (void) FT_Done_Face(face);
    (void) FT_Done_FreeType(library);
    ThrowFreetypeErrorException("UnableToSetFontSize", ft_status,
                                draw_info->pointsize);
    return MagickFalse;
}

// Initialize the TypeMetric structure with font size metrics such as ascent,
// descent, width, height, and maximum advance. If necessary, sanitize any
// incorrect ascender and descender values. Calculate underline position and
// thickness based on the font's properties.
metrics->ascent = (double) face->size->metrics.ascender / 64.0;
metrics->descent = (double) face->size->metrics.descender / 64.0;
metrics->width = (double) face->size->metrics.max_advance / 64.0;
metrics->height = (double) (face->size->metrics.ascender -
                           face->size->metrics.descender) / 64.0;
metrics->max_advance = (double) face->size->metrics.max_advance / 64.0;
if (metrics->ascent < 0.0)
    metrics->ascent = 0.0;
if (metrics->descent > 0.0)
    metrics->descent = 0.0;
metrics->underline_position = (double) face->underline_position / 64.0;
metrics->underline_thickness = (double) face->underline_thickness / 64.0;

// If there is no text to render, or no glyphs in the font, clean up resources
// and return a successful status without proceeding further.
if (length == 0 || face->num_glyphs == 0) {
    (void) FT_Done_Face(face);
    (void) FT_Done_FreeType(library);
    return MagickTrue;
}

// Configure rendering options such as anti-aliasing and hinting based on
// the DrawInfo settings and image properties. Prepare structures for
// rendering each glyph in the text string, transforming the glyphs according
// to specified affine transformations.
flags = FT_LOAD_DEFAULT;
if ((draw_info->text_antialias == MagickFalse) ||
    (image->quality < ScaleCharcoalIntensityToQuantum(DefaultCompressionQuality)))
    flags |= FT_LOAD_TARGET_MONO;
else
    flags |= FT_LOAD_TARGET_NORMAL;
if (draw_info->render == MagickFalse)
    flags |= FT_LOAD_RENDER;
affine.xx = (FT_Fixed)(draw_info->affine.sx * 0x10000L);
affine.xy = (FT_Fixed)(-draw_info->affine.rx * 0x10000L);
affine.yx = (FT_Fixed)(-draw_info->affine.ry * 0x10000L);
affine.yy = (FT_Fixed)(draw_info->affine.sy * 0x10000L);
origin.x = (FT_Pos)(offset->x * 64.0);
origin.y = (FT_Pos)(offset->y * 64.0);

// Loop through each character in the text, rendering glyphs, tracing outlines
// if necessary, and rasterizing the glyphs onto the image. Adjust the
// position and metrics of each rendered glyph, and update the bounding box
// of the text as needed. Manage resources and synchronize image data
// appropriately during the rendering process.
for (i = 0, last_character = -1, y = 0; i < (ssize_t) length; i++) {
    // Render the glyph and update the text metrics
    // ...

    // Clean up resources and return the rendering status
    (void) FT_Done_Face(face);
    (void) FT_Done_FreeType(library);
    return status;
}