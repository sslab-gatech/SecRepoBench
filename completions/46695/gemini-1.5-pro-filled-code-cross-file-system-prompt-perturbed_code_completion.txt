if (encoding != (const char *) NULL)
    {
      if (LocaleCompare(encoding,"AdobeCustom") == 0)
        encoding_type=FT_ENCODING_ADOBE_CUSTOM;
      else
        if (LocaleCompare(encoding,"AdobeExpert") == 0)
          encoding_type=FT_ENCODING_ADOBE_EXPERT;
        else
          if (LocaleCompare(encoding,"AdobeStandard") == 0)
            encoding_type=FT_ENCODING_ADOBE_STANDARD;
          else
            if (LocaleCompare(encoding,"AppleRoman") == 0)
              encoding_type=FT_ENCODING_APPLE_ROMAN;
            else
              if (LocaleCompare(encoding,"Big5") == 0)
                encoding_type=FT_ENCODING_BIG5;
              else
                if (LocaleCompare(encoding,"GB2312") == 0)
                  encoding_type=FT_ENCODING_GB2312;
                else
                  if (LocaleCompare(encoding,"Johab") == 0)
                    encoding_type=FT_ENCODING_JOHAB;
                  else
                    if (LocaleCompare(encoding,"SJIScode") == 0)
                      encoding_type=FT_ENCODING_SJIS;
                    else
                      if (LocaleCompare(encoding,"Symbol") == 0)
                        encoding_type=FT_ENCODING_MS_SYMBOL;
                      else
                        if (LocaleCompare(encoding,"Unicode") == 0)
                          encoding_type=FT_ENCODING_UNICODE;
      ft_status=FT_Select_Charmap(face,encoding_type);
      if (ft_status != 0)
        {
          (void) FT_Done_Face(face);
          (void) FT_Done_FreeType(library);
          ThrowFreetypeErrorException("UnrecognizedFontEncoding",ft_status,
            encoding);
          (void) fclose((FILE *) stream->descriptor.pointer);
          stream=DestroyMagickMemory(stream);
          return(MagickFalse);
        }
    }
  resolution.x=draw_info->density.x;
  resolution.y=draw_info->density.y;
  if ((resolution.x == 0.0) || (resolution.y == 0.0))
    {
      resolution.x=72.0;
      resolution.y=72.0;
    }
  if (draw_info->render)
    {
      resolution.x=draw_info->resolution.x;
      resolution.y=draw_info->resolution.y;
    }
  ft_status=FT_Set_Char_Size(face,(FT_F26Dot6)(64.0*draw_info->pointsize),
    (FT_F26Dot6)(64.0*draw_info->pointsize),(FT_UInt) resolution.x,
    (FT_UInt) resolution.y);
  if (ft_status != 0)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      ThrowFreetypeErrorException("UnableToSetFreetypeCharacterSize",ft_status,
        draw_info->font != (char *) NULL ? draw_info->font : "none");
      (void) fclose((FILE *) stream->descriptor.pointer);
      stream=DestroyMagickMemory(stream);
      return(MagickFalse);
    }
  metrics->pixels_per_em.x=face->size->metrics.x_ppem;
  metrics->pixels_per_em.y=face->size->metrics.y_ppem;
  metrics->ascent=(double) face->size->metrics.ascender/64.0;
  metrics->descent=(double) face->size->metrics.descender/64.0;
  metrics->width=(double) face->size->metrics.max_advance/64.0;
  metrics->height=(double) face->size->metrics.height/64.0;
  metrics->max_advance=(double) face->size->metrics.max_advance/64.0;
  metrics->underline_position=face->underline_position/64.0;
  metrics->underline_thickness=face->underline_thickness/64.0;
  if (metrics->ascent < (metrics->descent*-1.0))
    metrics->ascent=(metrics->descent*-1.0);
  if (draw_info->text == (char *) NULL)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      (void) fclose((FILE *) stream->descriptor.pointer);
      stream=DestroyMagickMemory(stream);
      return(MagickTrue);
    }
  if (face->glyph == (FT_GlyphSlot) NULL)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      ThrowFreetypeErrorException("UnableToReadFont",ft_status,
        draw_info->font != (char *) NULL ? draw_info->font : "none");
      (void) fclose((FILE *) stream->descriptor.pointer);
      stream=DestroyMagickMemory(stream);
      return(MagickFalse);
    }
  /*
    Compute the bounding box.
  */
  flags=FT_LOAD_DEFAULT;
  if ((draw_info->text_antialias == MagickFalse) && (draw_info->stroke_width == 0.0))
    flags|=FT_LOAD_TARGET_MONO;
  if (draw_info->render)
    flags|=FT_LOAD_TARGET_NORMAL;
  else
    flags|=FT_LOAD_TARGET_LIGHT;
  if (draw_info->hinting)
    flags|=FT_LOAD_FORCE_AUTOHINT;
  length=strlen(draw_info->text);
  utf8=(unsigned char *) draw_info->text;
  if ((draw_info->direction == RightToLeftDirection) ||
      (draw_info->direction == AutoDirection))
    {
      if (GetUTF8Direction(draw_info->text,length) == RightToLeftDirection)
        flags|=FT_LOAD_RENDER;
    }
  (void) memset(&glyph,0,sizeof(glyph));
  (void) FT_Set_Transform(face,&affine,&origin);
  grapheme=(GraphemeInfo *) NULL;
  length=ComplexTextLayout((const Image *) NULL,draw_info,draw_info->text,length,
    face,flags,&grapheme,exception);
  if (grapheme == (GraphemeInfo *) NULL)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      (void) fclose((FILE *) stream->descriptor.pointer);
      stream=DestroyMagickMemory(stream);
      return(MagickFalse);
    }

  /*
    Adjust the origin. freetype origin is the lower-left corner whereas
    ImageMagick origin is the upper-left corner. Also freetype ascent is
    from the baseline to the top whereas ImageMagick ascent is from the
    bottom to the top.
  */

  /*
    Render text.
  */
  status=MagickTrue;
  for (i=0; i < (ssize_t) length; i++)
  {
    /*
      Render character.
    */
    glyph.id=grapheme[i].index;
    ft_status=FT_Load_Glyph(face,(FT_UInt) glyph.id,flags);
    if (ft_status != 0)
      continue;
    ft_status=FT_Get_Glyph(face->glyph,&glyph.image);
    if (ft_status != 0)
      continue;
    glyph.origin.x=grapheme[i].x_offset;
    glyph.origin.y=grapheme[i].y_offset;
    /*
      Get character metrics.
    */
    if (glyph.image->format != FT_GLYPH_FORMAT_OUTLINE)
      {
        ft_status=FT_Glyph_To_Bitmap(&glyph.image,FT_RENDER_MODE_NORMAL,
          &origin,MagickTrue);
        if (ft_status != 0)
          continue;
        bitmap=(FT_BitmapGlyph) glyph.image;
      }
    FT_Done_Glyph(glyph.image);
  }
  metrics->bounds.x1=bounds.xMin/64.0;
  metrics->bounds.y1=bounds.yMin/64.0;
  metrics->bounds.x2=bounds.xMax/64.0;
  metrics->bounds.y2=bounds.yMax/64.0;
  metrics->width=(double) ((bounds.xMax-bounds.xMin)/64.0);
  /*
    Cleanup allocated memory.
  */
  grapheme=(GraphemeInfo *) RelinquishMagickMemory(grapheme);
  (void) FT_Done_Face(face);
  (void) FT_Done_FreeType(library);
  (void) fclose((FILE *) stream->descriptor.pointer);
  stream=DestroyMagickMemory(stream);
  return(status);