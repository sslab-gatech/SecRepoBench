/*
    If an encoding is provided, attempt to select the appropriate charmap.
    If selection fails, clean up properly and return an error.
  */
  if ((encoding != (char *) NULL) && (*encoding != '\0'))
    {
      if (LocaleCompare(encoding,"AdobeCustom") == 0)
        encoding_type=FT_ENCODING_ADOBE_CUSTOM;
      else if (LocaleCompare(encoding,"AdobeExpert") == 0)
        encoding_type=FT_ENCODING_ADOBE_EXPERT;
      else if (LocaleCompare(encoding,"AdobeStandard") == 0)
        encoding_type=FT_ENCODING_ADOBE_STANDARD;
      else if (LocaleCompare(encoding,"AppleRoman") == 0)
        encoding_type=FT_ENCODING_APPLE_ROMAN;
      else if (LocaleCompare(encoding,"Latin2") == 0)
        encoding_type=(FT_Encoding) FT_ENCODING_NONE;
      ft_status=FT_Select_Charmap(face,encoding_type);
      if (ft_status != 0)
        {
          (void) FT_Done_Face(face);
          (void) FT_Done_FreeType(library);
          ThrowFreetypeErrorException("UnableToSelectCharmap",ft_status,
            img->filename);
          stream=(FT_StreamRec *) RelinquishMagickMemory(stream);
          return(MagickFalse);
        }
    }

  /*
    Set character size based on point size and resolution (density).
  */
  resolution.x=72.0;
  resolution.y=72.0;
  if ((draw_info->density != (char *) NULL) && 
       (ParseGeometry(draw_info->density,&geometry_info) != 0))
    {
      resolution.x=geometry_info.rho > 0 ? geometry_info.rho : resolution.x;
      resolution.y=geometry_info.sigma > 0 ? geometry_info.sigma : resolution.y;
    }
  ft_status=FT_Set_Char_Size(face,0,
    (FT_F26Dot6) ((64.0*draw_info->pointsize)+0.5),
    (FT_UInt) (resolution.x+0.5),
    (FT_UInt) (resolution.y+0.5));
  if (ft_status != 0)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      ThrowFreetypeErrorException("UnableToSetFontSize",ft_status,
        img->filename);
      stream=(FT_StreamRec *) RelinquishMagickMemory(stream);
      return(MagickFalse);
    }

  /*
    Initialize metrics from the face properties.
  */
  metrics->ascent=(double) (face->size->metrics.ascender >> 6);
  metrics->descent=(double) (-face->size->metrics.descender >> 6);
  metrics->width=0;
  metrics->height=(double) ((face->size->metrics.ascender-face->size->metrics.
    descender) >> 6);
  metrics->max_advance=(double) (face->size->metrics.max_advance >> 6);
  if (face->bbox.yMax < face->bbox.yMin)
    {
      /* Sanitize incorrect face metrics */
      face->ascender=(FT_Short) (metrics->ascent+0.5);
      face->descender=(FT_Short) (-metrics->descent+0.5);
    }
  metrics->underline_position=(double) face->underline_position;
  metrics->underline_thickness=(double) face->underline_thickness;

  /*
    If we have no text or the font has no glyphs, clean up and return.
  */
  annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
  if ((annotate_info->text == (char *) NULL) || 
      (*(annotate_info->text) == '\0') || 
      (face->num_glyphs == 0))
    {
      annotate_info=DestroyDrawInfo(annotate_info);
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      stream=(FT_StreamRec *) RelinquishMagickMemory(stream);
      return(MagickTrue);
    }

  /*
    Continue with preparing and rendering glyphs as needed.
  */