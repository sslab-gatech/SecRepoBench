// Select the appropriate character map (encoding) for the font face based on
  // the provided encoding string. If an encoding is specified, determine the
  // corresponding FreeType encoding type using a series of string comparisons.
  // If the encoding type is successfully determined, apply it to the font face.
  // If the encoding type cannot be applied, handle the error by cleaning up
  // resources and throwing an exception.

  if (encoding != (const char *) NULL)
  {
    FT_Encoding encoding_type = FT_ENCODING_UNICODE;
    // Determine the corresponding FreeType encoding type
    // This part depends on the specific encoding string and may require additional logic

    // Example: Simple string comparison for demonstration purposes
    if (strcmp(encoding, "UTF-8") == 0)
    {
      encoding_type = FT_ENCODING_UTF8;
    }
    else if (strcmp(encoding, "ISO8859-1") == 0)
    {
      encoding_type = FT_ENCODING_ISOLatin1;
    }
    else if (strcmp(encoding, "Windows-1252") == 0)
    {
      encoding_type = FT_ENCODING_MS_SYMBOL;
    }
    // Add more encoding types as needed

    ft_status = FT_Select_Charmap(face, encoding_type);
    if (ft_status != 0)
    {
      FT_Done_FreeType(library);
      ThrowFreetypeErrorException("UnableToSelectCharmap", ft_status, face->family_name);
      return MagickFalse;
    }
  }

  // Set the character size for the font face based on the point size and
  // resolution specified in the DrawInfo structure. Adjust the resolution
  // if a custom density is provided. If setting the character size fails,
  // handle the error by cleaning up resources and throwing an exception.

  FT_Set_Char_Size(face, 
                   draw_info->pointsize * 64, // point size in 1/64th of a point
                   draw_info->pointsize * 64, // pixel height
                   draw_info->resolution.x,    // horizontal resolution
                   draw_info->resolution.y);  // vertical resolution
  if (ft_status != 0)
  {
    FT_Done_FreeType(library);
    ThrowFreetypeErrorException("UnableToSetCharacterSize", ft_status, face->family_name);
    return MagickFalse;
  }

  // Initialize the TypeMetric structure with font size metrics such as ascent,
  // descent, width, height, and maximum advance. If necessary, sanitize any
  // incorrect ascender and descender values. Calculate underline position and
  // thickness based on the font's properties.

  metrics->ascent = face->ascender / 64.0;
  metrics->descent = face->descender / 64.0;
  metrics->width = face->bbox.xMax / 64.0;
  metrics->height = (face->ascender - face->descender) / 64.0;
  metrics->max_advance = face->max_advance / 64.0;

  // If there is no text to render, or no glyphs in the font, clean up resources
  // and return a successful status without proceeding further.

  if (draw_info->text == (char *) NULL || strlen(draw_info->text) == 0)
  {
    FT_Done_FreeType(library);
    return MagickTrue;
  }

  // Configure rendering options such as anti-aliasing and hinting based on
  // the DrawInfo settings and image properties. Prepare structures for
  // rendering each glyph in the text string, transforming the glyphs according
  // to specified affine transformations.

  FT_Set_Pixel_Sizes(face, 0, draw_info->pointsize);
  if (draw_info->render == MagickFalse)
  {
    FT_Done_FreeType(library);
    return MagickTrue;
  }

  // Loop through each character in the text, rendering glyphs, tracing outlines
  // if necessary, and rasterizing the glyphs onto the image. Adjust the
  // position and metrics of each rendered glyph, and update the bounding box
  // of the text as needed. Manage resources and synchronize image data
  // appropriately during the rendering process.

  for (i = 0; i < (ssize_t) strlen(draw_info->text); i++)
  {
    code = draw_info->text[i];
    ft_status = FT_Load_Char(face, code, FT_LOAD_RENDER | FT_LOAD_TARGET_NORMAL);
    if (ft_status != 0)
    {
      ThrowFreetypeErrorException("UnableToLoadGlyph", ft_status, face->family_name);
      FT_Done_FreeType(library);
      return MagickFalse;
    }

    bitmap = face->glyph->bitmap;
    point.x = face->glyph->bitmap_left;
    point.y = face->glyph->bitmap_top;

    // Rasterize the glyph and add it to the image
    for (y = 0; y < bitmap.rows; y++)
    {
      for (x = 0; x < bitmap.width; x++)
      {
        Quantum pixel = bitmap.buffer[y * bitmap.width + x];
        if (SetPixelInImage(img, x + point.x + offset->x, y + point.y - bitmap.rows + offset->y, pixel) == MagickFalse)
        {
          FT_Done_FreeType(library);
          return MagickFalse;
        }
      }
    }

    // Update the bounding box and metrics for the text
    metrics->bounds.x1 = Min(metrics->bounds.x1, point.x + offset->x);
    metrics->bounds.y1 = Min(metrics->bounds.y1, point.y - bitmap.rows + offset->y);
    metrics->bounds.x2 = Max(metrics->bounds.x2, point.x + offset->x + bitmap.width);
    metrics->bounds.y2 = Max(metrics->bounds.y2, point.y + offset->y);
    metrics->advance = Max(metrics->advance, face->glyph->advance.x / 64.0);
  }

  // Finalize the font metrics by normalizing the bounding box coordinates and
  // width. Clean up any remaining resources and return the rendering status.

  metrics->bounds.x1 -= offset->x;
  metrics->bounds.y1 -= offset->y;
  metrics->bounds.x2 -= offset->x;
  metrics->bounds.y2 -= offset->y;
  metrics->width = metrics->bounds.x2 - metrics->bounds.x1;
  metrics->height = metrics->bounds.y2 - metrics->bounds.y1;

  FT_Done_FreeType(library);
  return MagickTrue;