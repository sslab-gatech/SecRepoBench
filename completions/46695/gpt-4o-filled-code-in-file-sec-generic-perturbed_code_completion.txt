if (encoding != (const char *) NULL)
  {
    if (LocaleCompare(encoding,"AdobeCustom") == 0)
      encoding_type=FT_ENCODING_ADOBE_CUSTOM;
    if (LocaleCompare(encoding,"AppleRoman") == 0)
      encoding_type=FT_ENCODING_APPLE_ROMAN;
    if (LocaleCompare(encoding,"BIG5") == 0)
      encoding_type=FT_ENCODING_BIG5;
    if (LocaleCompare(encoding,"GB2312") == 0)
      encoding_type=FT_ENCODING_GB2312;
    if (LocaleCompare(encoding,"Johab") == 0)
      encoding_type=FT_ENCODING_JOHAB;
    if (LocaleCompare(encoding,"Latin2") == 0)
      encoding_type=FT_ENCODING_LATIN_2;
    if (LocaleCompare(encoding,"Latin3") == 0)
      encoding_type=FT_ENCODING_LATIN_3;
    if (LocaleCompare(encoding,"Latin4") == 0)
      encoding_type=FT_ENCODING_LATIN_4;
    if (LocaleCompare(encoding,"Latin5") == 0)
      encoding_type=FT_ENCODING_LATIN_5;
    if (LocaleCompare(encoding,"Latin6") == 0)
      encoding_type=FT_ENCODING_LATIN_6;
    if (LocaleCompare(encoding,"Latin7") == 0)
      encoding_type=FT_ENCODING_LATIN_7;
    if (LocaleCompare(encoding,"Latin8") == 0)
      encoding_type=FT_ENCODING_LATIN_8;
    if (LocaleCompare(encoding,"Latin9") == 0)
      encoding_type=FT_ENCODING_LATIN_9;
    if (LocaleCompare(encoding,"Latin10") == 0)
      encoding_type=FT_ENCODING_LATIN_10;
    if (LocaleCompare(encoding,"SJIS") == 0)
      encoding_type=FT_ENCODING_SJIS;
    if (LocaleCompare(encoding,"Unicode") == 0)
      encoding_type=FT_ENCODING_UNICODE;
    if (LocaleCompare(encoding,"Wansung") == 0)
      encoding_type=FT_ENCODING_WANSUNG;
    ft_status=FT_Select_Charmap(face,encoding_type);
    if (ft_status != 0)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      ThrowFreetypeErrorException("UnableToSelectFontEncoding",ft_status,
        encoding);
      return(MagickFalse);
    }
  }

  resolution.x=DefaultResolution;
  resolution.y=DefaultResolution;
  if (draw_info->density != (char *) NULL)
  {
    GeometryInfo
      geometry_info;

    MagickStatusType
      flags;

    flags=ParseGeometry(draw_info->density,&geometry_info);
    if ((flags & RhoValue) != 0)
      resolution.x=geometry_info.rho;
    resolution.y=resolution.x;
    if ((flags & SigmaValue) != 0)
      resolution.y=geometry_info.sigma;
  }
  ft_status=FT_Set_Char_Size(face,0,(FT_F26Dot6) (64.0*draw_info->pointsize),
    (FT_UInt) resolution.x,(FT_UInt) resolution.y);
  if (ft_status != 0)
  {
    (void) FT_Done_Face(face);
    (void) FT_Done_FreeType(library);
    ThrowFreetypeErrorException("UnableToSetFontSize",ft_status,
      draw_info->font);
    return(MagickFalse);
  }

  metrics->pixels_per_em.x=(double) face->size->metrics.x_ppem;
  metrics->pixels_per_em.y=(double) face->size->metrics.y_ppem;
  metrics->ascent=(double) face->size->metrics.ascender/64.0;
  metrics->descent=(double) face->size->metrics.descender/64.0;
  metrics->width=0.0;
  metrics->height=metrics->ascent-metrics->descent;
  metrics->max_advance=(double) face->size->metrics.max_advance/64.0;
  metrics->bounds.x1=0.0;
  metrics->bounds.y1=0.0;
  metrics->bounds.x2=0.0;
  metrics->bounds.y2=0.0;
  metrics->origin.x=0.0;
  metrics->origin.y=0.0;
  metrics->underline_position=(double) face->underline_position/64.0;
  metrics->underline_thickness=(double) face->underline_thickness/64.0;
  if (metrics->underline_position > 0.0)
    metrics->underline_position=(-metrics->underline_position);
  if (metrics->underline_thickness < 1.0)
    metrics->underline_thickness=1.0;

  if ((draw_info->text == (char *) NULL) || (*draw_info->text == '\0'))
  {
    (void) FT_Done_Face(face);
    (void) FT_Done_FreeType(library);
    return(MagickTrue);
  }

  flags=FT_LOAD_DEFAULT;
  if (draw_info->text_antialias == MagickFalse)
    flags|=FT_LOAD_TARGET_MONO;
  else
    if (image->storage_class == PseudoClass)
      flags|=FT_LOAD_TARGET_MONO;
    else
      flags|=FT_LOAD_TARGET_NORMAL;
  if (draw_info->interpolate == MagickFalse)
    flags|=FT_LOAD_NO_HINTING;
  if (draw_info->interpolate == MagickTrue)
    flags|=FT_LOAD_FORCE_AUTOHINT;

  length=strlen(draw_info->text);
  grapheme=(GraphemeInfo *) NULL;
  length=ComplexTextLayout(image,draw_info,draw_info->text,length,face,flags,
    &grapheme,exception);
  if (length == 0)
  {
    (void) FT_Done_Face(face);
    (void) FT_Done_FreeType(library);
    return(MagickFalse);
  }

  annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
  annotate_info->primitive=AcquireString("");
  origin.x=0;
  origin.y=0;
  first_glyph_id=0;
  last_glyph_id=0;
  missing_glyph_id=FT_Get_Char_Index(face,0);
  for (i=0; i < (ssize_t) length; i++)
  {
    glyph.id=(FT_UInt) grapheme[i].index;
    if (glyph.id == 0)
      glyph.id=missing_glyph_id;
    if (glyph.id == 0)
      continue;
    if (FT_Load_Glyph(face,glyph.id,flags) != 0)
      continue;
    if (FT_Render_Glyph(face->glyph,FT_RENDER_MODE_NORMAL) != 0)
      continue;
    glyph.image=(FT_Glyph) NULL;
    if (FT_Get_Glyph(face->glyph,&glyph.image) != 0)
      continue;
    if (FT_Glyph_To_Bitmap(&glyph.image,FT_RENDER_MODE_NORMAL,0,1) != 0)
    {
      FT_Done_Glyph(glyph.image);
      continue;
    }
    bitmap=(FT_BitmapGlyph) glyph.image;
    if (IsEmptyOutline(face->glyph->outline) == MagickFalse)
    {
      (void) FT_Outline_Translate(&face->glyph->outline,origin.x,origin.y);
      (void) FT_Outline_Decompose(&face->glyph->outline,&OutlineMethods,
        annotate_info);
    }
    if (annotate_info->primitive != (char *) NULL)
      (void) ConcatenateString(&annotate_info->primitive,"Z");
    if (draw_info->render != MagickFalse)
    {
      CacheView
        *image_view;

      MagickBooleanType
        sync;

      ssize_t
        x;

      unsigned char
        *pixels;

      /*
        Rasterize glyph.
      */
      pixels=(unsigned char *) bitmap->bitmap.buffer;
      image_view=AcquireAuthenticCacheView(image,exception);
      for (y=0; y < (ssize_t) bitmap->bitmap.rows; y++)
      {
        ssize_t
          x_offset;

        Quantum
          *magick_restrict q;

        q=GetCacheViewAuthenticPixels(image_view,(ssize_t) (offset->x+
          bitmap->left),(ssize_t) (offset->y-bitmap->top+y),bitmap->bitmap.width,
          1,exception);
        if (q == (Quantum *) NULL)
          break;
        x_offset=0;
        for (x=0; x < (ssize_t) bitmap->bitmap.width; x++)
        {
          if (bitmap->bitmap.pixel_mode == FT_PIXEL_MODE_MONO)
            {
              if ((pixels[x_offset/8] & (0x80U >> (x_offset % 8))) != 0)
                SetPixelAlpha(image,OpaqueAlpha,q);
              else
                SetPixelAlpha(image,TransparentAlpha,q);
            }
          else
            {
              SetPixelAlpha(image,ClampToQuantum((double) QuantumRange*
                pixels[x_offset]/255.0),q);
              SetPixelRed(image,draw_info->fill.red,q);
              SetPixelGreen(image,draw_info->fill.green,q);
              SetPixelBlue(image,draw_info->fill.blue,q);
            }
          x_offset++;
          q+=GetPixelChannels(image);
        }
        sync=SyncCacheViewAuthenticPixels(image_view,exception);
        if (sync == MagickFalse)
          break;
        pixels+=bitmap->bitmap.pitch;
      }
      image_view=DestroyCacheView(image_view);
    }
    FT_Done_Glyph(glyph.image);
    origin.x+=grapheme[i].x_advance;
    origin.y+=grapheme[i].y_offset;
    if (first_glyph_id == 0)
      first_glyph_id=glyph.id;
    last_glyph_id=glyph.id;
  }
  if (annotate_info->primitive != (char *) NULL)
    (void) ConcatenateString(&annotate_info->primitive,"Z");
  if (annotate_info->primitive != (char *) NULL)
    (void) DrawImage(image,annotate_info,exception);
  annotate_info=DestroyDrawInfo(annotate_info);
  grapheme=(GraphemeInfo *) RelinquishMagickMemory(grapheme);
  (void) FT_Done_Face(face);
  (void) FT_Done_FreeType(library);
  return(MagickTrue);
}