#if defined(MAGICKCORE_FREETYPE_DELEGATE)
  // Select the appropriate character map (encoding) for the font face based on
  // the provided encoding string. If an encoding is specified, determine the
  // corresponding FreeType encoding type using a series of string comparisons.
  // If the encoding type is successfully determined, apply it to the font face.
  // If the encoding type cannot be applied, handle the error by cleaning up
  // resources and throwing an exception.
  if (encoding != NULL && *encoding != '\0') {
    if (strcasecmp(encoding, "UTF-8") == 0 || strcasecmp(encoding, "Unicode") == 0) {
      encoding_type = FT_ENCODING_UNICODE;
    } else if (strcasecmp(encoding, "Symbol") == 0) {
      encoding_type = FT_ENCODING_ADOBE_CUSTOM;
    } else if (strcasecmp(encoding, "AdobeStandard") == 0) {
      encoding_type = FT_ENCODING_ADOBE_STANDARD;
    } else if (strcasecmp(encoding, "AdobeExpert") == 0) {
      encoding_type = FT_ENCODING_ADOBE_EXPERT;
    } else if (strcasecmp(encoding, "AdobeLatinText") == 0) {
      encoding_type = FT_ENCODING_ADOBE_LATIN_1;
    } else if (strcasecmp(encoding, "ISO8859-1") == 0) {
      encoding_type = FT_ENCODING_ADOBE_LATIN_1;
    } else {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      ThrowFreetypeErrorException("UnrecognizedFontEncoding", 0, encoding);
      args.pathname = DestroyString(args.pathname);
      return MagickFalse;
    }
    ft_status = FT_Select_Charmap(face, encoding_type);
    if (ft_status != 0) {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      ThrowFreetypeErrorException("UnableToSetFontEncoding", ft_status, encoding);
      args.pathname = DestroyString(args.pathname);
      return MagickFalse;
    }
  } else {
    // If no encoding is specified, try to use the default Unicode encoding.
    encoding_type = FT_ENCODING_UNICODE;
    ft_status = FT_Select_Charmap(face, encoding_type);
    if (ft_status != 0 && face->num_charmaps != 0) {
      // If the Unicode encoding is not available, use the first available charmap.
      ft_status = FT_Set_Charmap(face, face->charmaps[0]);
      if (ft_status != 0) {
        (void) FT_Done_Face(face);
        (void) FT_Done_FreeType(library);
        ThrowFreetypeErrorException("UnableToSetFontCharmap", ft_status, "");
        args.pathname = DestroyString(args.pathname);
        return MagickFalse;
      }
    }
  }

  // Set the character size for the font face based on the point size and
  // resolution specified in the DrawInfo structure. Adjust the resolution
  // if a custom density is provided. If setting the character size fails,
  // handle the error by cleaning up resources and throwing an exception.
  resolution.x = DefaultResolution;
  resolution.y = DefaultResolution;
  if (draw_info->density != NULL) {
    GeometryInfo geometry_info;
    MagickStatusType flags = ParseGeometry(draw_info->density, &geometry_info);
    if ((flags & RhoValue) != 0)
      resolution.x = geometry_info.rho;
    if ((flags & SigmaValue) != 0)
      resolution.y = geometry_info.sigma;
  }
  ft_status = FT_Set_Char_Size(face, 0, (FT_F26Dot6)(draw_info->pointsize * 64.0), (FT_UInt)resolution.x, (FT_UInt)resolution.y);
  if (ft_status != 0) {
    (void) FT_Done_Face(face);
    (void) FT_Done_FreeType(library);
    ThrowFreetypeErrorException("UnableToSetFontPointSize", ft_status, "");
    args.pathname = DestroyString(args.pathname);
    return MagickFalse;
  }

  // Initialize the TypeMetric structure with font size metrics such as ascent,
  // descent, width, height, and maximum advance. If necessary, sanitize any
  // incorrect ascender and descender values. Calculate underline position and
  // thickness based on the font's properties.
  metrics->pixels_per_em.x = resolution.x / DefaultResolution * draw_info->pointsize;
  metrics->pixels_per_em.y = resolution.y / DefaultResolution * draw_info->pointsize;
  metrics->ascent = (double)face->size->metrics.ascender / 64.0;
  metrics->descent = (double)face->size->metrics.descender / 64.0;
  metrics->width = (double)face->size->metrics.max_advance / 64.0;
  metrics->height = floor(metrics->ascent - metrics->descent + 0.5);
  metrics->max_advance = (double)face->size->metrics.max_advance / 64.0;
  metrics->bounds.x1 = 0.0;
  metrics->bounds.y1 = metrics->descent;
  metrics->bounds.x2 = metrics->ascent + metrics->descent;
  metrics->bounds.y2 = metrics->ascent + metrics->descent;
  metrics->underline_position = (double)face->underline_position / 64.0;
  metrics->underline_thickness = (double)face->underline_thickness / 64.0;

  // If there is no text to render, or no glyphs in the font, clean up resources
  // and return a successful status without proceeding further.
  length = strlen(draw_info->text);
  if (length == 0 || face->num_glyphs == 0) {
    (void) FT_Done_Face(face);
    (void) FT_Done_FreeType(library);
    args.pathname = DestroyString(args.pathname);
    return MagickTrue;
  }

  // Configure rendering options such as anti-aliasing and hinting based on
  // the DrawInfo settings and image properties. Prepare structures for
  // rendering each glyph in the text string, transforming the glyphs according
  // to specified affine transformations.
  flags = FT_LOAD_DEFAULT;
  if (draw_info->text_antialias == MagickFalse)
    flags |= FT_LOAD_TARGET_MONO;
  else
    flags |= FT_LOAD_TARGET_NORMAL;
  if (draw_info->stroke.alpha != TransparentAlpha)
    flags |= FT_LOAD_RENDER;
  affine.xx = (FT_Fixed)(draw_info->affine.sx * 0x10000L);
  affine.xy = (FT_Fixed)(-draw_info->affine.rx * 0x10000L);
  affine.yx = (FT_Fixed)(-draw_info->affine.ry * 0x10000L);
  affine.yy = (FT_Fixed)(draw_info->affine.sy * 0x10000L);
  origin.x = (FT_Pos)(offset->x * 64.0);
  origin.y = (FT_Pos)(-offset->y * 64.0);
  first_glyph_id = 0;
  last_glyph_id = 0;
  missing_glyph_id = 0;

  // Loop through each character in the text, rendering glyphs, tracing outlines
  // if necessary, and rasterizing the glyphs onto the image. Adjust the
  // position and metrics of each rendered glyph, and update the bounding box
  // of the text as needed. Manage resources and synchronize image data
  // appropriately during the rendering process.
  for (p = draw_info->text; GetUTFCode(p) != 0; p += GetUTFOctets(p)) {
    code = GetUTFCode(p);
    glyph.id = FT_Get_Char_Index(face, code);
    if (glyph.id == 0) {
      if (missing_glyph_id == 0)
        missing_glyph_id = glyph.id;
      continue;
    }
    if (first_glyph_id == 0)
      first_glyph_id = glyph.id;
    last_glyph_id = glyph.id;
    ft_status = FT_Load_Glyph(face, glyph.id, flags);
    if (ft_status != 0) {
      ThrowFreetypeErrorException("UnableToLoadFontGlyph", ft_status, draw_info->text);
      continue;
    }
    if (draw_info->stroke.alpha != TransparentAlpha) {
      bitmap = (FT_BitmapGlyph)face->glyph;
      if (IsEmptyOutline(bitmap->root.outline) == MagickFalse) {
        glyph.origin.x = origin.x + bitmap->left;
        glyph.origin.y = origin.y - bitmap->top;
        (void)FT_Outline_Translate(&bitmap->root.outline, glyph.origin.x, glyph.origin.y);
        (void)FT_Outline_Transform(&bitmap->root.outline, &affine);
        (void)FT_Outline_Get_CBox(&bitmap->root.outline, &bounds);
        (void)FormatLocaleString(primitive, MagickPathExtent, "path %g,%g %g,%g %g,%g %g,%g",
          (double)bounds.xMin / 64.0, (double)bounds.yMin / 64.0,
          (double)bounds.xMin / 64.0, (double)bounds.yMax / 64.0,
          (double)bounds.xMax / 64.0, (double)bounds.yMax / 64.0,
          (double)bounds.xMax / 64.0, (double)bounds.yMin / 64.0);
        (void)CloneString(&annotate_info->primitive, primitive);
        (void)DrawImage(image, annotate_info, exception);
      }
    }
    if (face->glyph->format == FT_GLYPH_FORMAT_BITMAP) {
      bitmap = (FT_BitmapGlyph)face->glyph;
      (void)CompositeImage(image, bitmap->bitmap.buffer != NULL ? BitmapChannel : AlphaChannel,
        bitmap->bitmap, OverCompositeOp, MagickTrue,
        (ssize_t)ceil(origin.x / 64.0 + bitmap->left),
        (ssize_t)ceil(origin.y / 64.0 - bitmap->top), exception);
    }
    origin.x += face->glyph->advance.x;
    origin.y += face->glyph->advance.y;
    if (FT_HAS_KERNING(face) && last_glyph_id != 0 && glyph.id != 0) {
      FT_Vector delta;
      ft_status = FT_Get_Kerning(face, last_glyph_id, glyph.id, ft_kerning_default, &delta);
      if (ft_status == 0) {
        origin.x += delta.x;
        origin.y += delta.y;
      }
    }
    metrics->bounds.x2 = MAX(metrics->bounds.x2, origin.x / 64.0);
    metrics->bounds.y2