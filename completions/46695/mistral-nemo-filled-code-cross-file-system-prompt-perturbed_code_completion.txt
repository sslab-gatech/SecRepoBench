/*
    Select the appropriate character map (encoding) for the font face based on
    the provided encoding string. If an encoding is specified, determine the
    corresponding FreeType encoding type using a series of string comparisons.
    If the encoding type is successfully determined, apply it to the font face.
    If the encoding type cannot be applied, handle the error by cleaning up
    resources and throwing an exception.
  */
  if (encoding != (const char *) NULL)
    {
      if (IsStringInList(encoding,"ISO-8859-1") != MagickFalse)
        encoding_type=FT_ENCODING_ISO_8859_1;
      else
        if (IsStringInList(encoding,"ISO-8859-2") != MagickFalse)
          encoding_type=FT_ENCODING_ISO_8859_2;
        else
          if (IsStringInList(encoding,"ISO-8859-3") != MagickFalse)
            encoding_type=FT_ENCODING_ISO_8859_3;
          else
            if (IsStringInList(encoding,"ISO-8859-4") != MagickFalse)
              encoding_type=FT_ENCODING_ISO_8859_4;
            else
              if (IsStringInList(encoding,"ISO-8859-5") != MagickFalse)
                encoding_type=FT_ENCODING_ISO_8859_5;
              else
                if (IsStringInList(encoding,"ISO-8859-6") != MagickFalse)
                  encoding_type=FT_ENCODING_ISO_8859_6;
                else
                  if (IsStringInList(encoding,"ISO-8859-7") != MagickFalse)
                    encoding_type=FT_ENCODING_ISO_8859_7;
                  else
                    if (IsStringInList(encoding,"ISO-8859-8") != MagickFalse)
                      encoding_type=FT_ENCODING_ISO_8859_8;
                    else
                      if (IsStringInList(encoding,"ISO-8859-9") != MagickFalse)
                        encoding_type=FT_ENCODING_ISO_8859_9;
                      else
                        if (IsStringInList(encoding,"ISO-8859-10") != MagickFalse)
                          encoding_type=FT_ENCODING_ISO_8859_10;
                        else
                          if (IsStringInList(encoding,"ISO-8859-11") != MagickFalse)
                            encoding_type=FT_ENCODING_ISO_8859_11;
                          else
                            if (IsStringInList(encoding,"ISO-8859-13") != MagickFalse)
                              encoding_type=FT_ENCODING_ISO_8859_13;
                            else
                              if (IsStringInList(encoding,"ISO-8859-14") != MagickFalse)
                                encoding_type=FT_ENCODING_ISO_8859_14;
                              else
                                if (IsStringInList(encoding,"ISO-8859-15") != MagickFalse)
                                  encoding_type=FT_ENCODING_ISO_8859_15;
                                else
                                  if (IsStringInList(encoding,"ISO-8859-16") != MagickFalse)
                                    encoding_type=FT_ENCODING_ISO_8859_16;
                                  else
                                    if (IsStringInList(encoding,"UTF-8") != MagickFalse)
                                      encoding_type=FT_ENCODING_UNICODE;
                                    else
                                      if (IsStringInList(encoding,"UTF-16") != MagickFalse)
                                        encoding_type=FT_ENCODING_UNICODE_16;
                                      else
                                        if (IsStringInList(encoding,"UTF-32") != MagickFalse)
                                          encoding_type=FT_ENCODING_UNICODE_32;
                                        else
                                          {
                                            (void) ThrowMagickException(exception,
                                              GetMagickModule(),OptionError,
                                              "UnrecognizedEncoding",
                                              "Unrecognized encoding: %s",encoding);
                                            goto cleanup;
                                          }
      ft_status=FT_Select_Charmap(face,encoding_type);
      if (ft_status != 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),TypeError,
            "UnableToSelectCharmap", "`%s' (%s)",encoding,FreetypeErrorMessage(ft_status));
          goto cleanup;
        }
    }
  else
    {
      ft_status=FT_Select_Charmap(face,FT_ENCODING_MS_SYMBOL);
      if (ft_status != 0)
        {
          ft_status=FT_Select_Charmap(face,FT_ENCODING_MS_EXTENDED);
          if (ft_status != 0)
            {
              (void) ThrowMagickException(exception,GetMagickModule(),TypeError,
                "UnableToSelectCharmap", "`%s' (%s)",FT_ENCODING_MS_SYMBOL,FreetypeErrorMessage(ft_status));
              goto cleanup;
            }
        }
    }

  /*
    Set the character size for the font face based on the point size and
    resolution specified in the DrawInfo structure. Adjust the resolution
    if a custom density is provided. If setting the character size fails,
    handle the error by cleaning up resources and throwing an exception.
  */
  if (draw_info->pointsize != 0.0)
    {
      resolution.x=draw_info->resolution.x;
      resolution.y=draw_info->resolution.y;
      if (draw_info->density != 0.0)
        {
          resolution.x=draw_info->density;
          resolution.y=draw_info->density;
        }
      point.x=draw_info->pointsize;
      point.y=draw_info->pointsize;
      if (draw_info->pointsize < 0.0)
        {
          point.x=-point.x;
          point.y=-point.y;
        }
      affine.xx=resolution.x;
      affine.yy=resolution.y;
      affine.xy=0.0;
      affine.yx=0.0;
      ft_status=FT_Set_Char_Size(face,point.x,point.y,resolution.x,resolution.y);
      if (ft_status != 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),TypeError,
            "UnableToSetCharacterSize", "`%gx%g' (%s)",point.x,point.y,FreetypeErrorMessage(ft_status));
          goto cleanup;
        }
    }

  /*
    Initialize the TypeMetric structure with font size metrics such as ascent,
    descent, width, height, and maximum advance. If necessary, sanitize any
    incorrect ascender and descender values. Calculate underline position and
    thickness based on the font's properties.
  */
  if (metrics != (TypeMetric *) NULL)
    {
      metrics->ascent=face->ascender;
      metrics->descent=face->descender;
      metrics->width=face->max_advance_width;
      metrics->height=metrics->ascent-metrics->descent;
      metrics->underline_position=face->underline_position;
      metrics->underline_thickness=face->underline_thickness;
      if (metrics->ascent < 0)
        metrics->ascent=0;
      if (metrics->descent < 0)
        metrics->descent=0;
      if (metrics->ascent > metrics->height)
        metrics->height=metrics->ascent;
      if (metrics->descent > metrics->height)
        metrics->height=metrics->descent;
    }

  /*
    If there is no text to render, or no glyphs in the font, clean up resources
    and return a successful status without proceeding further.
  */
  if ((text == (const char *) NULL) || (face->num_glyphs == 0))
    return(MagickTrue);

  /*
    Configure rendering options such as anti-aliasing and hinting based on
    the DrawInfo settings and image properties. Prepare structures for
    rendering each glyph in the text string, transforming the glyphs according
    to specified affine transformations.
  */
  if (draw_info->antialias != MagickFalse)
    flags|=FT_LOAD_TARGET_MONO;
  else
    flags|=FT_LOAD_TARGET_LCD;
  if (draw_info->hinting != MagickFalse)
    flags|=FT_LOAD_FORCE_AUTOHINT;
  else
    flags|=FT_LOAD_NO_HINTING;
  if (draw_info->transform != (char *) NULL)
    {
      FT_Matrix
        transform;

      transform=FT_Matrix_Identity;
      if (FT_Matrix_Multiply(&transform,&affine,&transform) != 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),TypeError,
            "UnableToApplyAffineTransformation", "`%s'",draw_info->transform);
          goto cleanup;
        }
      flags|=FT_LOAD_NO_HINTING;
      affine=transform;
    }

  /*
    Loop through each character in the text, rendering glyphs, tracing outlines
    if necessary, and rasterizing the glyphs onto the image. Adjust the
    position and metrics of each rendered glyph, and update the bounding box
    of the text as needed. Manage resources and synchronize image data
    appropriately during the rendering process.
  */
  length=GetUTF8Length(text);
  if (length == 0)
    return(MagickTrue);
  grapheme=ComplexTextLayout(image,draw_info,text,length,face,flags,&grapheme,exception);
  if (grapheme == (GraphemeInfo *) NULL)
    return(MagickFalse);
  last_character=0;
  for (i=0; i < (ssize_t) length; i++)
  {
    if (grapheme[i].index != 0)
      {
        if (FT_Load_Glyph(face,(FT_UInt) grapheme[i].index,flags) != 0)
          {
            (void) ThrowMagickException(exception,GetMagickModule(),TypeError,
              "UnableToLoadGlyph", "`%u'",grapheme[i].index);
            continue;
          }
        if (FT_Render_Glyph(face->glyph,FT_RENDER_MODE_NORMAL) != 0)
          {
            (void) ThrowMagickException(exception,GetMagickModule(),TypeError,
              "UnableToRenderGlyph", "`%u'",grapheme[i].index);
            continue;
          }
        if (FT_Glyph_To_Bitmap(&face->glyph,&bitmap,FT_RENDER_MODE_NORMAL,0,1) != 0)
          {
            (void) ThrowMagickException(exception,GetMagickModule(),TypeError,
              "UnableToConvertGlyphToBitmap", "`%u'",grapheme[i].index);
            continue;
          }
        if (FT_Bitmap_Glyph_To_Outline(bitmap,&outline,0) != 0)
          {
            (void) ThrowMagickException(exception,GetMagickModule(),TypeError,
              "UnableToConvertBitmapToOutline", "`%u'",grapheme[i].index);
            continue;
          }
        if (FT_Outline_Decompose(&outline,&contours) != 0)
          {
            (void) ThrowMagickException(exception,GetMagickModule(),TypeError,
              "UnableToDecomposeOutline", "`%u'",grapheme[i].index);
            continue;
          }
        if (FT_Outline_Check(&outline) != 0)
          {
            (void) ThrowMagickException(exception,GetMagickModule(),TypeError,
              "InvalidOutline", "`%u'",grapheme[i].index);
            continue;
          }
        if (FT_Outline_Get_CBox(&outline,&bounds) != 0)
          {
            (void) ThrowMagickException(exception,GetMagickModule(),TypeError,
              "UnableToGetOutlineBoundingBox", "`%u'",grapheme[i].index);
            continue;
          }
        if (FT_Outline_Transform(&outline,&affine) != 0)
          {
            (void) ThrowMagickException(exception,GetMagickModule(),TypeError,
              "UnableToTransformOutline", "`%u'",grapheme[i].index);
            continue;
          }
        if (FT_Outline_Get_CBox(&outline,&bounds) != 0)
          {
            (void) ThrowMagickException(exception,GetMagickModule(),TypeError,
              "UnableToGetOutlineBoundingBox", "`%u'",grapheme[i].index);
            continue;
          }
        if (FT_Outline_Check(&outline) != 0)
          {
            (void) ThrowMagickException(exception,GetMagickModule(),TypeError,
              "InvalidOutline", "`%u'",grapheme[i].index);
            continue;
          }
        if (FT_Outline_Get_CBox(&outline,&bounds) != 0)
          {
            (void) ThrowMagickException(exception,GetMagickModule(),TypeError,
              "UnableToGetOutlineBoundingBox", "`%u'",grapheme[i].index);
            continue;
          }
        if (FT_Outline_Get_CBox(&outline,&bounds) != 0)
          {
            (void) ThrowMagickException(exception,GetMagickModule(),TypeError,
              "UnableToGetOutlineBoundingBox", "`%u'",grapheme[i].index);
            continue;
          }
        if (FT_Outline_Get_CBox(&outline,&bounds) != 0)
          {
            (void) ThrowMagickException(exception