/*
    Select character map based on encoding
  */
  if (encoding != NULL)
  {
    if (strcmp(encoding, "iso8859-1") == 0)
      encoding_type = FT_ENCODING_ISO8859_1;
    else if (strcmp(encoding, "iso8859-2") == 0)
      encoding_type = FT_ENCODING_ISO8859_2;
    else if (strcmp(encoding, "iso8859-3") == 0)
      encoding_type = FT_ENCODING_ISO8859_3;
    else if (strcmp(encoding, "iso8859-4") == 0)
      encoding_type = FT_ENCODING_ISO8859_4;
    else if (strcmp(encoding, "iso8859-5") == 0)
      encoding_type = FT_ENCODING_ISO8859_5;
    else if (strcmp(encoding, "iso8859-6") == 0)
      encoding_type = FT_ENCODING_ISO8859_6;
    else if (strcmp(encoding, "iso8859-7") == 0)
      encoding_type = FT_ENCODING_ISO8859_7;
    else if (strcmp(encoding, "iso8859-8") == 0)
      encoding_type = FT_ENCODING_ISO8859_8;
    else if (strcmp(encoding, "iso8859-9") == 0)
      encoding_type = FT_ENCODING_ISO8859_9;
    else if (strcmp(encoding, "iso8859-10") == 0)
      encoding_type = FT_ENCODING_ISO8859_10;
    else if (strcmp(encoding, "iso8859-11") == 0)
      encoding_type = FT_ENCODING_ISO8859_11;
    else if (strcmp(encoding, "iso8859-12") == 0)
      encoding_type = FT_ENCODING_ISO8859_12;
    else if (strcmp(encoding, "iso8859-13") == 0)
      encoding_type = FT_ENCODING_ISO8859_13;
    else if (strcmp(encoding, "iso8859-14") == 0)
      encoding_type = FT_ENCODING_ISO8859_14;
    else if (strcmp(encoding, "iso8859-15") == 0)
      encoding_type = FT_ENCODING_ISO8859_15;
    else if (strcmp(encoding, "iso8859-16") == 0)
      encoding_type = FT_ENCODING_ISO8859_16;
    else if (strcmp(encoding, "cp437") == 0)
      encoding_type = FT_ENCODING_CP437;
    else if (strcmp(encoding, "cp850") == 0)
      encoding_type = FT_ENCODING_CP850;
    else if (strcmp(encoding, "cp852") == 0)
      encoding_type = FT_ENCODING_CP852;
    else if (strcmp(encoding, "cp858") == 0)
      encoding_type = FT_ENCODING_CP858;
    else if (strcmp(encoding, "cp860") == 0)
      encoding_type = FT_ENCODING_CP860;
    else if (strcmp(encoding, "cp861") == 0)
      encoding_type = FT_ENCODING_CP861;
    else if (strcmp(encoding, "cp862") == 0)
      encoding_type = FT_ENCODING_CP862;
    else if (strcmp(encoding, "cp863") == 0)
      encoding_type = FT_ENCODING_CP863;
    else if (strcmp(encoding, "cp864") == 0)
      encoding_type = FT_ENCODING_CP864;
    else if (strcmp(encoding, "cp865") == 0)
      encoding_type = FT_ENCODING_CP865;
    else if (strcmp(encoding, "cp866") == 0)
      encoding_type = FT_ENCODING_CP866;
    else if (strcmp(encoding, "cp869") == 0)
      encoding_type = FT_ENCODING_CP869;
    else if (strcmp(encoding, "cp872") == 0)
      encoding_type = FT_ENCODING_CP872;
    else if (strcmp(encoding, "cp874") == 0)
      encoding_type = FT_ENCODING_CP874;
    else if (strcmp(encoding, "cp875") == 0)
      encoding_type = FT_ENCODING_CP875;
    else if (strcmp(encoding, "cp932") == 0)
      encoding_type = FT_ENCODING_CP932;
    else if (strcmp(encoding, "cp936") == 0)
      encoding_type = FT_ENCODING_CP936;
    else if (strcmp(encoding, "cp949") == 0)
      encoding_type = FT_ENCODING_CP949;
    else if (strcmp(encoding, "cp950") == 0)
      encoding_type = FT_ENCODING_CP950;
    else if (strcmp(encoding, "cp1250") == 0)
      encoding_type = FT_ENCODING_CP1250;
    else if (strcmp(encoding, "cp1251") == 0)
      encoding_type = FT_ENCODING_CP1251;
    else if (strcmp(encoding, "cp1252") == 0)
      encoding_type = FT_ENCODING_CP1252;
    else if (strcmp(encoding, "cp1253") == 0)
      encoding_type = FT_ENCODING_CP1253;
    else if (strcmp(encoding, "cp1254") == 0)
      encoding_type = FT_ENCODING_CP1254;
    else if (strcmp(encoding, "cp1255") == 0)
      encoding_type = FT_ENCODING_CP1255;
    else if (strcmp(encoding, "cp1256") == 0)
      encoding_type = FT_ENCODING_CP1256;
    else if (strcmp(encoding, "cp1257") == 0)
      encoding_type = FT_ENCODING_CP1257;
    else if (strcmp(encoding, "cp1258") == 0)
      encoding_type = FT_ENCODING_CP1258;
  }

  ft_status = FT_Select_Charmap(face, encoding_type);
  if (ft_status != 0)
  {
    if (face->num_charmaps > 0)
    {
      ft_status = FT_Set_Charmap(face, face->charmaps[0]);
      if (ft_status != 0)
      {
        ThrowFreetypeErrorException("UnableToSetCharMap", ft_status, "");
        return MagickFalse;
      }
    }
    else
    {
      ThrowFreetypeErrorException("NoCharMapsAvailable", ft_status, "");
      return MagickFalse;
    }
  }

  /*
    Set character size
  */
  resolution.x = (draw_info->density.x == 0) ? 72 : draw_info->density.x;
  resolution.y = (draw_info->density.y == 0) ? 72 : draw_info->density.y;

  ft_status = FT_Set_Char_Size(face, (FT_UInt)(draw_info->point * 64),
    (FT_UInt)(draw_info->point * 64), (FT_UInt)resolution.x, (FT_UInt)resolution.y);
  if (ft_status != 0)
  {
    ThrowFreetypeErrorException("UnableToSetFontSize", ft_status, "");
    return MagickFalse;
  }

  /*
    Initialize type metrics
  */
  metrics->ascent = face->ascender / 64;
  metrics->descent = face->descender / 64;
  metrics->width = face->max_advance_width / 64;
  metrics->height = (face->ascender - face->descender) / 64;
  metrics->max_advance = face->max_advance_height / 64;

  if (metrics->ascent < 0)
    metrics->ascent = 0;
  if (metrics->descent < 0)
    metrics->descent = 0;

  metrics->underline_position = face->underline_position / 64;
  metrics->underline_thickness = face->underline_thickness / 64;

  if (draw_info->text == NULL || strlen(draw_info->text) == 0)
  {
    FT_Done_Face(face);
    FT_Done_FreeType(library);
    return MagickTrue;
  }

  /*
    Configure rendering options
  */
  flags = FT_LOAD_DEFAULT;
  if (draw_info->antialias != MagickFalse)
    flags |= FT_LOAD_TARGET_NORMAL;
  else
    flags |= FT_LOAD_TARGET_MONO;

  if (draw_info->hinting != MagickFalse)
    flags |= FT_LOAD_HINTING;

  /*
    Render each glyph
  */
  grapheme = NULL;
  ComplexTextLayout(img, draw_info, draw_info->text, strlen(draw_info->text), face, flags, &grapheme, exception);

  if (grapheme == NULL)
  {
    FT_Done_Face(face);
    FT_Done_FreeType(library);
    return MagickFalse;
  }

  for (i = 0; i < (ssize_t)strlen(draw_info->text); i++)
  {
    code = GetUTFCode(draw_info->text + i);
    if (code == 0)
      break;

    glyph.id = FT_Get_Char_Index(face, code);
    if (glyph.id == 0)
    {
      glyph.id = FT_Get_Char_Index(face, 0x20); // Fallback to space
      if (glyph.id == 0)
        glyph.id = FT_Get_Char_Index(face, 0x240); // Fallback to missing glyph
    }

    ft_status = FT_Load_Glyph(face, glyph.id, flags);
    if (ft_status != 0)
    {
      ThrowFreetypeErrorException("UnableToLoadGlyph", ft_status, "");
      return MagickFalse;
    }

    // Apply affine transformation if needed
    if (draw_info->transform != NULL)
    {
      (void) memcpy(&affine, draw_info->transform, sizeof(FT_Matrix));
      FT_Set_Transform(face, &affine, NULL);
    }

    // Render glyph
    if (face->glyph->format == FT_GLYPH_FORMAT_BITMAP)
    {
      bitmap = (FT_BitmapGlyph)face->glyph->bitmap;
      // Handle bitmap rendering
    }
    else
    {
      // Handle outline rendering
      FT_Outline_Render(face, &OutlineMethods, NULL);
    }

    // Update metrics and position
    point.x += face->glyph->advance.x / 64;
    point.y += face->glyph->advance.y / 64;

    // Update bounding box
    if (i == 0)
    {
      bounds.xMin = face->glyph->bitmap_left;
      bounds.yMin = face->glyph->bitmap_top;
    }
    else
    {
      bounds.xMin = MIN(bounds.xMin, face->glyph->bitmap_left);
      bounds.yMin = MIN(bounds.yMin, face->glyph->bitmap_top);
      bounds.xMax = MAX(bounds.xMax, face->glyph->bitmap_left + face->glyph->bitmap.width);
      bounds.yMax = MAX(bounds.yMax, face->glyph->bitmap_top + face->glyph->bitmap.rows);
    }
  }

  // Normalize metrics
  metrics->ascent = bounds.yMax / 64;
  metrics->descent = -bounds.yMin / 64;
  metrics->width = (bounds.xMax - bounds.xMin) / 6