/*
    Select the appropriate character map (encoding) if requested.
  */
  if ((encoding != (char *) NULL) && (*encoding != '\0'))
    {
      if (LocaleCompare(encoding,"AppleRoman") == 0)
        encoding_type=FT_ENCODING_APPLE_ROMAN;
      else if (LocaleCompare(encoding,"SJIS") == 0)
        encoding_type=FT_ENCODING_SJIS;
      else if (LocaleCompare(encoding,"GB2312") == 0)
        encoding_type=FT_ENCODING_UNICODE;  /* Approximation for GB2312 */
      else if (LocaleCompare(encoding,"BIG5") == 0)
        encoding_type=FT_ENCODING_UNICODE;  /* Approximation for BIG5 */
      else if (LocaleCompare(encoding,"AdobeCustom") == 0)
        encoding_type=FT_ENCODING_ADOBE_CUSTOM;
      else if (LocaleCompare(encoding,"AdobeExpert") == 0)
        encoding_type=FT_ENCODING_ADOBE_EXPERT;
      else if (LocaleCompare(encoding,"AdobeStandard") == 0)
        encoding_type=FT_ENCODING_ADOBE_STANDARD;
      else if (LocaleCompare(encoding,"AppleUnicode") == 0)
        encoding_type=FT_ENCODING_UNICODE;
      else
        encoding_type=FT_ENCODING_UNICODE; /* Fallback */
      ft_status=FT_Select_Charmap(face,encoding_type);
      if (ft_status != 0)
        {
          (void) FT_Done_Face(face);
          (void) FT_Done_FreeType(library);
          ThrowFreetypeErrorException("UnableToSelectCharMap",ft_status,
            img->filename);
          return(MagickFalse);
        }
    }

  /*
    Set the character size based on the point size and resolution.
  */
  resolution.x=72.0;
  resolution.y=72.0;
  if ((draw_info->density != (char *) NULL) &&
      (IsGeometry(draw_info->density) != MagickFalse))
    {
      GeometryInfo geometry_info;
      (void) ParseGeometry(draw_info->density,&geometry_info);
      if (geometry_info.rho > 0)
        resolution.x=geometry_info.rho;
      if (geometry_info.sigma > 0)
        resolution.y=geometry_info.sigma;
    }
  ft_status=FT_Set_Char_Size(face,0,(FT_F26Dot6) (64.0*draw_info->pointsize),
    (unsigned int) (resolution.x+0.5),(unsigned int) (resolution.y+0.5));
  if (ft_status != 0)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      ThrowFreetypeErrorException("UnableToSetFont",ft_status,img->filename);
      return(MagickFalse);
    }

  /*
    Initialize metrics with basic font information.
  */
  metrics->ascent=(double) face->size->metrics.ascender/64.0;
  metrics->descent=(double) (-face->size->metrics.descender/64.0);
  if (metrics->descent < 0.0)
    metrics->descent=0.0;  /* sanitize negative descenders */
  metrics->width=0.0;
  metrics->height=metrics->ascent+metrics->descent;
  metrics->max_advance=(double) face->size->metrics.max_advance/64.0;
  metrics->underline_position=(double) face->underline_position/64.0;
  metrics->underline_thickness=(double) face->underline_thickness/64.0;

  /*
    If no text to render or no glyphs in the font, return immediately.
  */
  if ((draw_info->text == (char *) NULL) || (*draw_info->text == '\0') ||
      (face->num_glyphs == 0))
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      return(MagickTrue);
    }

  /*
    Configure rendering and prepare to process glyphs.
  */