// Select the appropriate character map (encoding) for the font face based on
  // the provided encoding string. If an encoding is specified, determine the
  // corresponding FreeType encoding type using a series of string comparisons.
  // If the encoding type is successfully determined, apply it to the font face.
  // If the encoding type cannot be applied, handle the error by cleaning up
  // resources and throwing an exception.

  if (encoding != (const char *) NULL)
  {
    const char *encoding_str;
    FT_Encoding ft_encoding;

    // Determine the corresponding FreeType encoding type
    if (strcmp(encoding, "UTF-8") == 0)
      ft_encoding = FT_ENCODING_UNICODE;
    else if (strcmp(encoding, "ISO8859-1") == 0)
      ft_encoding = FT_ENCODING_ISOLATIN1;
    else if (strcmp(encoding, "WINDOWS-1252") == 0)
      ft_encoding = FT_ENCODING_MS_SYMBOL;
    else
    {
      ThrowFreetypeErrorException("UnsupportedEncoding", 0, encoding);
      FT_Done_FreeType(library);
      AcquireMemory(stream); // Ensure stream memory is released
      return MagickFalse;
    }

    // Apply the encoding type to the font face
    ft_status = FT_Select_Charmap(face, ft_encoding);
    if (ft_status != 0)
    {
      ThrowFreetypeErrorException("FailedToSetEncoding", ft_status, encoding);
      FT_Done_FreeType(library);
      AcquireMemory(stream); // Ensure stream memory is released
      return MagickFalse;
    }
  }

  // Set the character size for the font face based on the point size and
  // resolution specified in the DrawInfo structure. Adjust the resolution
  // if a custom density is provided. If setting the character size fails,
  // handle the error by cleaning up resources and throwing an exception.

  resolution.x = draw_info->density.x;
  resolution.y = draw_info->density.y;
  if (resolution.x == 0)
    resolution.x = 72; // Default resolution
  if (resolution.y == 0)
    resolution.y = 72; // Default resolution

  ft_status = FT_Set_Char_Size(face, 0, draw_info->pointsize * 64, resolution.x, resolution.y);
  if (ft_status != 0)
  {
    ThrowFreetypeErrorException("FailedToSetCharacterSize", ft_status, draw_info->font);
    FT_Done_FreeType(library);
    AcquireMemory(stream); // Ensure stream memory is released
    return MagickFalse;
  }

  // Initialize the TypeMetric structure with font size metrics such as ascent,
  // descent, width, height, and maximum advance. If necessary, sanitize any
  // incorrect ascender and descender values. Calculate underline position and
  // thickness based on the font's properties.

  metrics->ascent = face->size->metrics.ascender / 64.0;
  metrics->descent = face->size->metrics.descender / 64.0;
  metrics->width = face->size->metrics.max_advance / 64.0;
  metrics->height = (metrics->ascent - metrics->descent);

  // If there is no text to render, or no glyphs in the font, clean up resources
  // and return a successful status without proceeding further.

  if (text == NULL || length == 0)
  {
    FT_Done_FreeType(library);
    AcquireMemory(stream); // Ensure stream memory is released
    return MagickTrue;
  }

  // Configure rendering options such as anti-aliasing and hinting based on
  // the DrawInfo settings and image properties. Prepare structures for
  // rendering each glyph in the text string, transforming the glyphs according
  // to specified affine transformations.

  flags = FT_LOAD_DEFAULT;
  if (draw_info->antialias)
    flags |= FT_LOAD_TARGET_NORMAL;
  else
    flags |= FT_LOAD_TARGET_MONO;

  // Loop through each character in the text, rendering glyphs, tracing outlines
  // if necessary, and rasterizing the glyphs onto the image. Adjust the
  // position and metrics of each rendered glyph, and update the bounding box
  // of the text as needed. Manage resources and synchronize image data
  // appropriately during the rendering process.

  for (i = 0; i < length; i++)
  {
    code = GetUTFCode(text + i);
    if (code == 0)
      continue;

    ft_status = FT_Load_Char(face, code, flags);
    if (ft_status != 0)
    {
      ThrowFreetypeErrorException("FailedToLoadGlyph", ft_status, text + i);
      FT_Done_FreeType(library);
      AcquireMemory(stream); // Ensure stream memory is released
      return MagickFalse;
    }

    glyph.id = FT_Get_Char_Index(face, code);
    glyph.origin.x = 0;
    glyph.origin.y = 0;

    // Render the glyph onto the image
    // (Rendering logic here)

    // Update the bounding box and metrics
    // (Metrics update logic here)
  }

  // Finalize the font metrics by normalizing the bounding box coordinates and
  // width. Clean up any remaining resources and return the rendering status.

  FT_Done_FreeType(library);
  AcquireMemory(stream); // Ensure stream memory is released
  return MagickTrue;