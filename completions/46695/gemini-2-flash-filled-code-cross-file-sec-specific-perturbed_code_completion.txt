if (encoding != (const char *) NULL)
    {
      if (LocaleCompare(encoding,"AdobeCustom") == 0)
        encoding_type=FT_ENCODING_ADOBE_CUSTOM;
      else if (LocaleCompare(encoding,"AdobeExpert") == 0)
        encoding_type=FT_ENCODING_ADOBE_EXPERT;
      else if (LocaleCompare(encoding,"AdobeStandard") == 0)
        encoding_type=FT_ENCODING_ADOBE_STANDARD;
      else if (LocaleCompare(encoding,"AppleRoman") == 0)
        encoding_type=FT_ENCODING_APPLE_ROMAN;
      else if (LocaleCompare(encoding,"Latin1") == 0)
        encoding_type=FT_ENCODING_LATIN_1;
      else if (LocaleCompare(encoding,"None") == 0)
        encoding_type=FT_ENCODING_NONE;
      else if (LocaleCompare(encoding,"OldLating2") == 0)
        encoding_type=FT_ENCODING_OLD_LATIN_2;
      else if (LocaleCompare(encoding,"Symbol") == 0)
        encoding_type=FT_ENCODING_SYMBOL;
      else if (LocaleCompare(encoding,"Unicode") == 0)
        encoding_type=FT_ENCODING_UNICODE;
      else
        {
          (void) FT_Done_FreeType(library);
          ThrowMagickException(exception,GetMagickModule(),OptionError,
            "UnrecognizedFreetypeEncoding","`%s'",encoding);
          FTCloseStream(stream);
          stream=NULL;
          return(MagickFalse);
        }
      ft_status=FT_Select_Charmap(face,encoding_type);
      if (ft_status != 0)
        {
          (void) FT_Done_FreeType(library);
          ThrowFreetypeErrorException("UnrecognizedFreetypeEncoding",ft_status,
            encoding);
          FTCloseStream(stream);
          stream=NULL;
          return(MagickFalse);
        }
    }
  /*
    Set character size.
  */
  resolution.x=72.0*draw_info->pointsize;
  resolution.y=72.0*draw_info->pointsize;
  if ((draw_info->density != (char *) NULL) &&
      (strchr(draw_info->density,'x') != (char *) NULL))
    {
      char
        density[MagickPathExtent];

      const char
        *p;

      p=draw_info->density;
      (void) CopyMagickString(density,p,MagickPathExtent);
      p=strchr(density,'x');
      *p='\0';
      resolution.x=StringToDouble(density)*draw_info->pointsize;
      resolution.y=StringToDouble(p+1)*draw_info->pointsize;
    }
  ft_status=FT_Set_Char_Size(face,(FT_F26Dot6) (resolution.x*64.0),
    (FT_F26Dot6) (resolution.y*64.0),0,0);
  if (ft_status != 0)
    {
      (void) FT_Done_FreeType(library);
      ThrowFreetypeErrorException("UnableToSetFreetypeCharacterSize",ft_status,
        draw_info->font);
      FTCloseStream(stream);
      stream=NULL;
      return(MagickFalse);
    }
  /*
    Determine font metrics.
  */
  metrics->ascent=(double) face->size->metrics.ascender/(double) (1 << 6);
  metrics->descent=(double) face->size->metrics.descender/(double) (1 << 6);
  metrics->width=(double) face->size->metrics.max_advance/(double) (1 << 6);
  metrics->height=metrics->ascent-metrics->descent;
  metrics->max_advance=(double) face->size->metrics.max_advance/(double)
    (1 << 6);
  /*
    Sanitize any incorrect ascender & descender values reported by the font.
    This is required to prevent clipping of text.
  */
  if (fabs(metrics->ascent) < 1.0)
    metrics->ascent=metrics->height*0.8;
  if (fabs(metrics->descent) < 1.0)
    metrics->descent=(-metrics->height*0.2);
  metrics->underline_position=(double) face->underline_position/(double)
    (face->units_per_EM != 0 ? face->units_per_EM : 1);
  metrics->underline_thickness=(double) face->underline_thickness/(double)
    (face->units_per_EM != 0 ? face->units_per_EM : 1);
  if (metrics->underline_thickness <= 0.0)
    metrics->underline_thickness=0.75;
  length=strlen(draw_info->text);
  if ((length == 0) || (face->num_glyphs == 0))
    {
      (void) FT_Done_FreeType(library);
      FTCloseStream(stream);
      stream=NULL;
      return(MagickTrue);
    }
  /*
    Render the text.
  */
  flags=FT_LOAD_DEFAULT;
  if (draw_info->hinting)
    flags|=FT_LOAD_FORCE_AUTOHINT;
  else
    flags|=FT_LOAD_NO_HINTING;
  if (draw_info->antialias != MagickFalse)
    flags|=FT_LOAD_TARGET_NORMAL;
  else
    flags|=FT_LOAD_TARGET_MONO;
  if (image->colorspace == CMYKColorspace)
    flags|=FT_LOAD_TARGET_MONO;
  if (image->type == GrayscaleType)
    flags|=FT_LOAD_TARGET_MONO;
  if (image->matte == MagickFalse)
    flags|=FT_LOAD_TARGET_MONO;
  if (draw_info->weight > 400)
    flags|=FT_LOAD_FORCE_AUTOHINT;
  if (draw_info->kerning != MagickFalse)
    flags|=FT_LOAD_NO_BITMAP;
  else
    flags|=FT_LOAD_RENDER;
  affine.xx=(FT_Fixed) (draw_info->affine.sx*(1 << 16));
  affine.xy=(FT_Fixed) (draw_info->affine.rx*(1 << 16));
  affine.yx=(FT_Fixed) (draw_info->affine.ry*(1 << 16));
  affine.yy=(FT_Fixed) (draw_info->affine.sy*(1 << 16));
  ft_status=FT_Set_Transform(face,&affine,NULL);
  if (ft_status != 0)
    {
      (void) FT_Done_FreeType(library);
      ThrowFreetypeErrorException("UnableToTransformFreetypeFont",ft_status,
        draw_info->font);
      FTCloseStream(stream);
      stream=NULL;
      return(MagickFalse);
    }
  /*
    Allocate grapheme buffer.
  */
  grapheme=(GraphemeInfo *) NULL;
  length=ComplexTextLayout(image,draw_info,draw_info->text,strlen(draw_info->text),
    face,flags,&grapheme,exception);
  if (length == 0)
    {
      (void) FT_Done_FreeType(library);
      FTCloseStream(stream);
      stream=NULL;
      return(MagickFalse);
    }
  /*
    Initialize glyph info.
  */
  glyph.image=(FT_Glyph) NULL;
  origin.x=0;
  origin.y=0;
  bounds.xMin = 32767*64;
  bounds.yMin = 32767*64;
  bounds.xMax = -32767*64;
  bounds.yMax = -32767*64;
  last_character=(-1);
  p=draw_info->text;
  utf8=(unsigned char *) draw_info->text;
  point=(*offset);
  point.x+=draw_info->location.x;
  point.y+=draw_info->location.y;
  (void) CloneString(&annotate_info->font,draw_info->font);
  annotate_info=CloneDrawInfo(NULL,draw_info);
  annotate_info->text=(char *) NULL;
  code=0;
  for (i=0; i < (ssize_t) length; i++)
  {
    double
      gamma;

    double
      pixel_x,
      pixel_y;

    /*
      Load glyph.
    */
    glyph.id=(FT_UInt) grapheme[i].index;
    ft_status=FT_Load_Glyph(face,glyph.id,flags);
    if (ft_status != 0)
      {
        if (glyph.id == 0)
          {
            code=GetUTFCode(p);
            if (code == last_character)
              (void) LogMagickEvent(PolicyEvent,GetMagickModule(),
                "Skipping infinite loop");
            last_character=code;
          }
        p+=GetUTFOctets(p);
        continue;
      }
    /*
      Transform glyph.
    */
    glyph.origin.x=origin.x+grapheme[i].x_offset;
    glyph.origin.y=origin.y+grapheme[i].y_offset;
    ft_status=FT_Get_Glyph(face->glyph,&glyph.image);
    if (ft_status != 0)
      {
        p+=GetUTFOctets(p);
        continue;
      }
    /*
      Render glyph.
    */
    if (draw_info->kerning != MagickFalse)
      {
        ft_status=FT_Glyph_To_Bitmap(&glyph.image,draw_info->antialias !=
          MagickFalse ? ft_render_mode_normal : ft_render_mode_mono,NULL,1);
        if (ft_status != 0)
          {
            p+=GetUTFOctets(p);
            continue;
          }
      }
    bitmap=(FT_BitmapGlyph) glyph.image;
    if (draw_info->kerning == MagickFalse)
      {
        /*
          Draw glyph.
        */
        value=(const char *) NULL;
        if ((draw_info->stroke != (PixelInfo *) NULL) &&
            (draw_info->stroke->opacity != 0.0))
          {
            FT_Outline
              outline;

            /*
              Stroke glyph.
            */
            outline=bitmap->bitmap.outline;
            outline.flags=FT_OUTLINE_NONE;
            outline.n_points=0;
            outline.n_contours=0;
            ft_status=FT_Outline_Decompose(&outline,&OutlineMethods,
              (void *) draw_info);
            if (ft_status != 0)
              {
                p+=GetUTFOctets(p);
                continue;
              }
          }
        if (bitmap->bitmap.buffer != (unsigned char *) NULL)
          {
            /*
              Rasterize glyph.
            */
            double
              blur,
              gamma_threshold;

            MagickBooleanType
              sync;

            ssize_t
              x;

            /*
              Allocate raster.
            */
            gamma=1.0;
            gamma_threshold=0.70710678118654752440;  /* 1/sqrt(2) */
            if (draw_info->fill != (PixelInfo *) NULL)
              {
                double
                  opacity;

                opacity=PixelOpacity(draw_info->fill);
                if (opacity <= gamma_threshold)
                  gamma=opacity/gamma_threshold;
              }
            blur=0.0;
            if ((draw_info->blur != (double) 0.0) &&
                (draw_info->signature == MagickSignature))
              blur=draw_info->blur;
            x=(ssize_t) (point.x+((double) glyph.origin.x/64.0+bitmap->left));
            y=(ssize_t) (point.y-((double) glyph.origin.y/64.0-face->glyph->metrics.horiBearingY/64.0));
            if ((x < 0) || (y < 0) || (x >= (ssize_t) image->columns) ||
                (y >= (ssize_t) image->rows))
              {
                p+=GetUTFOctets(p);
                FT_Done_Glyph(glyph.image);
                continue