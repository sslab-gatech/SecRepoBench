if (encoding != (const char *) NULL)
  {
    if (LocaleCompare(encoding,"UTF-8") == 0)
      encoding_type=FT_ENCODING_UNICODE;
    else
      if (LocaleCompare(encoding,"UNICODE") == 0)
        encoding_type=FT_ENCODING_UNICODE;
      else
        if (LocaleCompare(encoding,"ASCII") == 0)
          encoding_type=FT_ENCODING_NONE;
        else
          if (LocaleCompare(encoding,"LATIN1") == 0)
            encoding_type=FT_ENCODING_ADOBE_LATIN_1;
          else
            if (LocaleCompare(encoding,"LATIN2") == 0)
              encoding_type=FT_ENCODING_ADOBE_LATIN_2;
    ft_status=FT_Select_Charmap(face,encoding_type);
    if (ft_status != 0)
      {
        (void) FT_Done_Face(face);
        (void) FT_Done_FreeType(library);
        ThrowFreetypeErrorException("UnableToSetEncoding",ft_status,
          encoding);
        return(MagickFalse);
      }
  }
resolution.x=DefaultResolution;
resolution.y=DefaultResolution;
if (draw_info->density != (char *) NULL)
  {
    GeometryInfo
      geometry_info;

    MagickStatusType
      flags;

    flags=ParseGeometry(draw_info->density,&geometry_info);
    resolution.x=geometry_info.rho;
    resolution.y=geometry_info.sigma;
    if ((flags & SigmaValue) == 0)
      resolution.y=resolution.x;
  }
ft_status=FT_Set_Char_Size(face,(FT_F26Dot6) (64.0*draw_info->pointsize),
  (FT_F26Dot6) (64.0*draw_info->pointsize),(FT_UInt) resolution.x,
  (FT_UInt) resolution.y);
if (ft_status != 0)
  {
    (void) FT_Done_Face(face);
    (void) FT_Done_FreeType(library);
    ThrowFreetypeErrorException("UnableToSetPointSize",ft_status,
      draw_info->font);
    return(MagickFalse);
  }
metrics->pixels_per_em.x=face->size->metrics.x_ppem;
metrics->pixels_per_em.y=face->size->metrics.y_ppem;
metrics->ascent=(double) face->size->metrics.ascender/64.0;
metrics->descent=(double) face->size->metrics.descender/64.0;
metrics->width=0;
metrics->origin.x=0;
metrics->origin.y=0;
metrics->height=(double) face->size->metrics.height/64.0;
metrics->max_advance=(double) face->size->metrics.max_advance/64.0;
if (face->size->metrics.ascender == 0)
  metrics->ascent=(double) face->ascender/64.0;
if (face->size->metrics.descender == 0)
  metrics->descent=(double) face->descender/64.0;
if (metrics->height == 0)
  metrics->height=metrics->ascent-metrics->descent;
metrics->underline_position=face->underline_position/64.0;
metrics->underline_thickness=face->underline_thickness/64.0;

if ((draw_info->text == (char *) NULL) || (*draw_info->text == '\0') ||
    (face->num_glyphs == 0))
  {
    (void) FT_Done_Face(face);
    (void) FT_Done_FreeType(library);
    return(MagickTrue);
  }
/*
  Render text.
*/
flags=FT_LOAD_DEFAULT;
if (draw_info->render == MagickFalse)
  flags|=FT_LOAD_NO_BITMAP;
if (draw_info->text_antialias == MagickFalse)
  flags|=FT_LOAD_TARGET_MONO;
else
  flags|=FT_LOAD_TARGET_NORMAL;
if (draw_info->style & NoAutohintStyle)
  flags|=FT_LOAD_NO_AUTOHINT;
annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
if (annotate_info->fill.alpha == TransparentAlpha)
  annotate_info->fill=draw_info->stroke;
(void) memset(&affine,0,sizeof(affine));
affine.xx=65536L;
affine.yy=65536L;
if (draw_info->affine.sx != 1.0)
  affine.xx=(FT_Fixed) (draw_info->affine.sx*65536.0);
if (draw_info->affine.rx != 0.0)
  affine.yx=(FT_Fixed) (-draw_info->affine.rx*65536.0);
if (draw_info->affine.ry != 0.0)
  affine.xy=(FT_Fixed) (draw_info->affine.ry*65536.0);
if (draw_info->affine.sy != 1.0)
  affine.yy=(FT_Fixed) (draw_info->affine.sy*65536.0);
origin.x=0;
origin.y=0;
grapheme=(GraphemeInfo *) NULL;
length=ComplexTextLayout(img,draw_info,draw_info->text,
  strlen(draw_info->text),face,flags,&grapheme,exception);
if (length == 0)
  {
    annotate_info=DestroyDrawInfo(annotate_info);
    (void) FT_Done_Face(face);
    (void) FT_Done_FreeType(library);
    return(MagickTrue);
  }
status=MagickTrue;
glyph.id=0;
glyph.image=NULL;
last_glyph_id=0;
point.x=0.0;
point.y=0.0;
for (i=0; i < (ssize_t) length; i++)
{
  /*
    Render this glyph.
  */
  glyph.id=grapheme[i].index;
  if (glyph.id == 0)
    glyph.id=FT_Get_Char_Index(face,'?');
  if ((glyph.id != 0) && (last_glyph_id != 0))
    {
      if (FT_HAS_KERNING(face))
        {
          FT_Vector
            kerning;

          ft_status=FT_Get_Kerning(face,last_glyph_id,glyph.id,
            ft_kerning_default,&kerning);
          if (ft_status == 0)
            origin.x+=kerning.x;
        }
    }
  glyph.origin=origin;
  ft_status=FT_Load_Glyph(face,glyph.id,flags);
  if (ft_status != 0)
    continue;
  ft_status=FT_Get_Glyph(face->glyph,&glyph.image);
  if (ft_status != 0)
    continue;
  ft_status=FT_Outline_Get_BBox(&((FT_OutlineGlyph) glyph.image)->outline,
    &bounds);
  if (ft_status != 0)
    continue;
  if ((p == draw_info->text) || (bounds.xMin < metrics->bounds.x1))
    metrics->bounds.x1=bounds.xMin;
  if ((p == draw_info->text) || (bounds.yMin < metrics->bounds.y1))
    metrics->bounds.y1=bounds.yMin;
  if ((p == draw_info->text) || (bounds.xMax > metrics->bounds.x2))
    metrics->bounds.x2=bounds.xMax;
  if ((p == draw_info->text) || (bounds.yMax > metrics->bounds.y2))
    metrics->bounds.y2=bounds.yMax;
  if (((draw_info->stroke.alpha != TransparentAlpha) ||
       (draw_info->stroke_pattern != (Image *) NULL)) &&
      ((status != MagickFalse) && (draw_info->render != MagickFalse)))
    {
      /*
        Trace the glyph.
      */
      annotate_info->affine.tx=offset->x+origin.x/64.0;
      annotate_info->affine.ty=offset->y-origin.y/64.0;
      (void) FT_Outline_Decompose(&((FT_OutlineGlyph) glyph.image)->outline,
        &OutlineMethods,annotate_info);
    }
  FT_Vector_Transform(&glyph.origin,&affine);
  (void) FT_Glyph_Transform(glyph.image,&affine,&glyph.origin);
  ft_status=FT_Glyph_To_Bitmap(&glyph.image,ft_render_mode_normal,
    (FT_Vector *) NULL,MagickTrue);
  if (ft_status != 0)
    continue;
  bitmap=(FT_BitmapGlyph) glyph.image;
  point.x=offset->x+bitmap->left;
  if (bitmap->bitmap.pixel_mode == ft_pixel_mode_mono)
    point.x=offset->x+(origin.x >> 6);
  point.y=offset->y-bitmap->top;
  if (draw_info->render != MagickFalse)
    {
      CacheView
        *image_view;

      MagickBooleanType
        transparent_fill;

      register unsigned char
        *p;

      register ssize_t
        x;

      size_t
        bit;

      transparent_fill=(draw_info->fill.alpha == TransparentAlpha) &&
        (draw_info->fill_pattern == (Image *) NULL) ? MagickTrue : MagickFalse;
      image_view=AcquireAuthenticCacheView(img,exception);
      p=bitmap->bitmap.buffer;
      for (y=0; y < (ssize_t) bitmap->bitmap.rows; y++)
      {
        if ((y+(ssize_t) point.y) < 0)
          {
            p+=bitmap->bitmap.pitch;
            continue;
          }
        if ((y+(ssize_t) point.y) >= (ssize_t) img->rows)
          break;
        bit=0;
        for (x=0; x < (ssize_t) bitmap->bitmap.width; x++)
        {
          if ((x+(ssize_t) point.x) < 0)
            {
              if (bitmap->bitmap.pixel_mode != ft_pixel_mode_mono)
                p++;
              else
                {
                  if (++bit == 8)
                    {
                      bit=0;
                      p++;
                    }
                }
              continue;
            }
          if ((x+(ssize_t) point.x) >= (ssize_t) img->columns)
            break;
          if (bitmap->bitmap.pixel_mode != ft_pixel_mode_mono)
            {
              if ((*p > 0) && (status != MagickFalse))
                {
                  double
                    fill_opacity;

                  PixelInfo
                    fill_color;

                  fill_opacity=(double) (*p)/(bitmap->bitmap.num_grays-1);
                  if (transparent_fill == MagickFalse)
                    {
                      fill_color=draw_info->fill;
                      fill_color.alpha=fill_opacity;
                      (void) DrawPoint(img,&fill_color