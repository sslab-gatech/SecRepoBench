/* Select encoding if specified */
  if (encoding != (const char *) NULL)
  {
    if (LocaleCompare(encoding,"unicode") == 0)
      encoding_type=FT_ENCODING_UNICODE;
    else if (LocaleCompare(encoding,"symbol") == 0)
      encoding_type=FT_ENCODING_MS_SYMBOL;
    else if (LocaleCompare(encoding,"adobe") == 0)
      encoding_type=FT_ENCODING_ADOBE_STANDARD;
    else
    {
      FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      ThrowFreetypeErrorException("UnsupportedEncoding",0,encoding);
      return MagickFalse;
    }
    ft_status=FT_Select_Charmap(face,encoding_type);
    if (ft_status != 0)
    {
      FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      ThrowFreetypeErrorException("UnableToSelectCharmap",ft_status,encoding);
      return MagickFalse;
    }
  }

  /* Set character size using point size and resolution (density) */
  resolution.x=(draw_info->density.x != 0) ? draw_info->density.x : 72;
  resolution.y=(draw_info->density.y != 0) ? draw_info->density.y : 72;
  ft_status=FT_Set_Char_Size(face,0,(FT_F26Dot6)(draw_info->pointsize*64),
                              (FT_UInt) resolution.x,(FT_UInt) resolution.y);
  if (ft_status != 0)
  {
    FT_Done_Face(face);
    (void) FT_Done_FreeType(library);
    ThrowFreetypeErrorException("UnableToSetCharSize",ft_status,draw_info->font);
    return MagickFalse;
  }

  /* Initialize font metrics */
  metrics->ascent=(double)(face->size->metrics.ascender >> 6);
  metrics->descent=(double)(-face->size->metrics.descender >> 6);
  metrics->width=(double)(face->size->metrics.max_advance >> 6);
  metrics->height=metrics->ascent - metrics->descent;
  /* Compute underline metrics if available */
  metrics->underline_position=(double)(face->underline_position >> 6);
  metrics->underline_thickness=(double)(face->underline_thickness >> 6);

  /* If there is no text to render, clean up and return success. */
  if ((draw_info->text == (char *) NULL) || (*draw_info->text == '\0'))
  {
    FT_Done_Face(face);
    (void) FT_Done_FreeType(library);
    return MagickTrue;
  }

  /* Configure rendering options based on draw_info.
     Here we perform a simple glyph rendering loop.
     A full implementation would consider affine transformations,
     anti-aliasing, hinting, and update the image accordingly. */
  {
    const char *p=draw_info->text;
    FT_UInt glyph_index;
    FT_Vector pen;
    pen.x=0;
    pen.y=0;
    status=MagickTrue;
    while (*p != '\0')
    {
      code=GetUTFCode(p);
      glyph_index=FT_Get_Char_Index(face,(FT_ULong) code);
      if (FT_Load_Glyph(face,glyph_index,FT_LOAD_DEFAULT) != 0)
      {
        status=MagickFalse;
        break;
      }
      /* Here one could trace outlines if required:
         FT_Outline_Decompose(&face->glyph->outline,&OutlineMethods,&pen); */
      /* Advance pen position */
      pen.x += face->glyph->advance.x;
      p += GetUTFOctets(p);
    }
    /* Update metrics width based on final pen position */
    metrics->width=(double)(pen.x >> 6);
  }

  /* Cleanup allocated FreeType resources */
  FT_Done_Face(face);
  (void) FT_Done_FreeType(library);
  return status;