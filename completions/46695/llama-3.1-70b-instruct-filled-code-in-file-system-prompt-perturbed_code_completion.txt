ft_status=FT_Set_Char_Size(face,(FT_F26Dot6) (draw_info->pointsize*64.0),
    (FT_F26Dot6) (draw_info->pointsize*64.0),resolution.x,resolution.y,
    (FT_UInt) draw_info->encoding);
  if (ft_status!= 0)
    ThrowFreetypeErrorException("UnableToSetCharacterSize",ft_status,
      draw_info->font!= (char *) NULL? draw_info->font : "none");
  metrics->ascent=(double) face->size->metrics.ascender/64.0;
  metrics->descent=(double) face->size->metrics.descender/64.0;
  metrics->width=(double) face->size->metrics.width/64.0;
  metrics->height=(double) face->size->metrics.height/64.0;
  metrics->max_advance=(double) face->size->metrics.max_advance/64.0;
  metrics->underline_position=(double) face->underline_position/64.0;
  metrics->underline_thickness=(double) face->underline_thickness/64.0;
  if (metrics->ascent < 0.0)
    metrics->ascent=0.0;
  if (metrics->descent > 0.0)
    metrics->descent=0.0;
  metrics->origin.x=(double) face->size->metrics.x_ppem/64.0;
  metrics->origin.y=(double) face->size->metrics.y_ppem/64.0;
  metrics->pixels_per_em.x=(double) face->size->metrics.x_ppem/64.0;
  metrics->pixels_per_em.y=(double) face->size->metrics.y_ppem/64.0;
  if (strlen(draw_info->text) == 0)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      return(MagickTrue);
    }
  if (strlen(draw_info->text) == 1)
    {
      FT_UInt
        glyph_id;

      glyph_id=FT_Get_Char_Index(face,(FT_UInt) GetUTFCode(draw_info->text));
      if (glyph_id == 0)
        glyph_id=FT_Get_Char_Index(face,(FT_UInt) '?');
      (void) FT_Load_Glyph(face,glyph_id,FT_LOAD_NO_BITMAP);
      metrics->bounds.x1=(double) face->glyph->metrics.horiBearingX/64.0;
      metrics->bounds.y1=(double) face->glyph->metrics.horiBearingY/64.0;
      metrics->bounds.x2=(double) (face->glyph->metrics.horiBearingX+
        face->glyph->metrics.width)/64.0;
      metrics->bounds.y2=(double) (face->glyph->metrics.horiBearingY+
        face->glyph->metrics.height)/64.0;
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      return(MagickTrue);
    }
  flags=FT_LOAD_NO_BITMAP;
  if (draw_info->render!= MagickFalse)
    flags|=FT_LOAD_RENDER;
  if (draw_info->text_antialias!= MagickFalse)
    flags|=FT_LOAD_TARGET_NORMAL;
  else
    flags|=FT_LOAD_TARGET_MONO;
  if (draw_info->stroke_width!= 0.0)
    flags|=FT_LOAD_NO_AUTOHINT;
  if (draw_info->hinting!= MagickFalse)
    flags|=FT_LOAD_FORCE_AUTOHINT;
  if (draw_info->nohint!= MagickFalse)
    flags|=FT_LOAD_NO_AUTOHINT;
  if (draw_info->noautoscale!= MagickFalse)
    flags|=FT_LOAD_NO_SCALE;
  if (draw_info->noautoscale!= MagickFalse)
    flags|=FT_LOAD_NO_BITMAP;
  if (draw_info->noautoscale!= MagickFalse)
    flags|=FT_LOAD_NO_RECURSE;
  if (draw_info->noautoscale!= MagickFalse)
    flags|=FT_LOAD_IGNORE_TRANSFORM;
  if (draw_info->noautoscale!= MagickFalse)
    flags|=FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH;
  if (draw_info->noautoscale!= MagickFalse)
    flags|=FT_LOAD_PEDANTIC;
  if (draw_info->noautoscale!= MagickFalse)
    flags|=FT_LOAD_NO_COMPUTE_METRICS;
  if (draw_info->noautoscale!= MagickFalse)
    flags|=FT_LOAD_LINEAR_DESIGN;
  if (draw_info->noautoscale!= MagickFalse)
    flags|=FT_LOAD_NO_VERTICAL_LAYOUT;
  if (draw_info->noautoscale!= MagickFalse)
    flags|=FT_LOAD_FORCE_AUTOHINT;
  if (draw_info->noautoscale!= MagickFalse)
    flags|=FT_LOAD_CROP_BITMAP;
  if (draw_info->noautoscale!= MagickFalse)
    flags|=FT_LOAD_SILENT;
  if (draw_info->noautoscale!= MagickFalse)
    flags|=FT_LOAD_LAZY;
  if (draw_info->noautoscale!= MagickFalse)
    flags|=FT_LOAD_NO_BITMAP;
  if (draw_info->noautoscale!= MagickFalse)
    flags|=FT_LOAD_TARGET_LIGHT;
  if (draw_info->noautoscale!= MagickFalse)
    flags|=FT_LOAD_TARGET_NORMAL;
  if (draw_info->noautoscale!= MagickFalse)
    flags|=FT_LOAD_TARGET_MONO;
  if (draw_info->noautoscale!= MagickFalse)
    flags|=FT_LOAD_TARGET_LCD;
  if (draw_info->noautoscale!= MagickFalse)
    flags|=FT_LOAD_TARGET_LCD_V;
  length=strlen(draw_info->text);
  grapheme=(GraphemeInfo *) NULL;
  if (draw_info->direction == RightToLeftDirection)
    {
      p=draw_info->text+length-1;
      for (i=0; i < (ssize_t) length; i++)
      {
        code=GetUTFCode(p);
        if (code == '\n')
          {
            p--;
            continue;
          }
        glyph.id=FT_Get_Char_Index(face,(FT_UInt) code);
        if (glyph.id == 0)
          glyph.id=FT_Get_Char_Index(face,(FT_UInt) '?');
        (void) FT_Load_Glyph(face,glyph.id,flags);
        glyph.origin.x=(double) face->glyph->metrics.horiBearingX/64.0;
        glyph.origin.y=(double) face->glyph->metrics.horiBearingY/64.0;
        glyph.image=face->glyph;
        if (IsEmptyOutline(face->glyph->outline)!= MagickFalse)
          {
            p--;
            continue;
          }
        (void) FT_Outline_Decompose(face->glyph->outline,&OutlineMethods,
          (void *) draw_info);
        p--;
      }
    }
  else
    {
      p=draw_info->text;
      for (i=0; i < (ssize_t) length; i++)
      {
        code=GetUTFCode(p);
        if (code == '\n')
          {
            p+=GetUTFOctets(p);
            continue;
          }
        glyph.id=FT_Get_Char_Index(face,(FT_UInt) code);
        if (glyph.id == 0)
          glyph.id=FT_Get_Char_Index(face,(FT_UInt) '?');
        (void) FT_Load_Glyph(face,glyph.id,flags);
        glyph.origin.x=(double) face->glyph->metrics.horiBearingX/64.0;
        glyph.origin.y=(double) face->glyph->metrics.horiBearingY/64.0;
        glyph.image=face->glyph;
        if (IsEmptyOutline(face->glyph->outline)!= MagickFalse)
          {
            p+=GetUTFOctets(p);
            continue;
          }
        (void) FT_Outline_Decompose(face->glyph->outline,&OutlineMethods,
          (void *) draw_info);
        p+=GetUTFOctets(p);
      }
    }
  metrics->bounds.x1=0.0;
  metrics->bounds.y1=0.0;
  metrics->bounds.x2=0.0;
  metrics->bounds.y2=0.0;
  for (i=0; i < (ssize_t) length; i++)
  {
    if (IsEmptyOutline(face->glyph->outline)!= MagickFalse)
      continue;
    if (metrics->bounds.x1 > glyph.origin.x+glyph.image->metrics.horiBearingX/
      64.0)
      metrics->bounds.x1=glyph.origin.x+glyph.image->metrics.horiBearingX/64.0;
    if (metrics->bounds.y1 > glyph.origin.y+glyph.image->metrics.horiBearingY/
      64.0)
      metrics->bounds.y1=glyph.origin.y+glyph.image->metrics.horiBearingY/64.0;
    if (metrics->bounds.x2 < glyph.origin.x+(glyph.image->metrics.horiBearingX+
      glyph.image->metrics.width)/64.0)
      metrics->bounds.x2=glyph.origin.x+(glyph.image->metrics.horiBearingX+
        glyph.image->metrics.width)/64.0;
    if (metrics->bounds.y2 < glyph.origin.y+(glyph.image->metrics.horiBearingY+
      glyph.image->metrics.height)/64.0)
      metrics->bounds.y2=glyph.origin.y+(glyph.image->metrics.horiBearingY+
        glyph.image->metrics.height)/64.0;
  }
  if (draw_info->render!= MagickFalse)
    {
      bitmap=(FT_BitmapGlyph) face->glyph;
      if (draw_info->stroke_width!= 0.0)
        {
          FT_Bitmap
            *target;

          FT_BitmapRec
            bitmap;

          int
            x,
            y;

          size_t
            width,
            height;

          bitmap.width=target->width=face->glyph->bitmap.width+
            (size_t) ceil(draw_info->stroke_width);
          bitmap.rows=target->rows=face->glyph->bitmap.rows+
            (size_t) ceil(draw_info->stroke_width);
          bitmap.pitch=target->pitch=bitmap.width;
          bitmap.buffer=target->buffer=(unsigned char *) AcquireQuantumMemory(
            bitmap.pitch*bitmap.rows,sizeof(*target->buffer));
          if (target->buffer == (unsigned char *) NULL)
            {
              (void) FT_Done_Face(face);
              (void) FT_Done_FreeType(library);
              return(MagickFalse);
            }
          for (y=0; y < (int) bitmap.rows; y++)
          {
            unsigned char
              *magick_restrict p;

            p=target->buffer+y*target->pitch;
            for (x=0; x < (int) bitmap.pitch; x++)
              *p++=0;
          }
          for (y=0; y < (int) face->glyph->bitmap.rows; y++)
          {
            unsigned char
              *magick_restrict p;

            p=face->glyph->bitmap.buffer+y*face->glyph->bitmap.pitch;
            for (x=0; x < (int) face->glyph->bitmap.width; x++)
              {
                int
                  xx,
                  yy;

                for (yy=-1; yy <= 1; yy++)
                {
                  for (xx=-1; xx <= 1; xx++)
                  {
                    if ((x+xx < 0) || (x+xx >= (int) bitmap.width) ||
                        (y+yy < 0) || (y+yy >= (int) bitmap.rows))
                      continue;
                    target->buffer[(y+yy)*target->pitch+x+xx]|=*p;
                  }
                }
                p++;
              }
          }
          face->glyph->bitmap=bitmap;
        }
      if (draw_info->fill.alpha!= TransparentAlpha)
        {
          CacheView
            *annotate_view;

          MagickBooleanType
            sync;

          PixelInfo
            fill_color;

          /*
            Render fill color.
          */
          if (image->alpha_trait == UndefinedPixelTrait)
            (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);
          if (annotate_image->alpha_trait == UndefinedPixelTrait)
            (void) SetImageAlphaChannel(annotate_image,OpaqueAlphaChannel,
              exception);
          fill_color=draw_info->fill;
          annotate_view=AcquireAuthenticCacheView(annotate_image,exception);
          for (y=0; y < (ssize_t) annotate_image->rows; y++)
          {
            ssize_t
              x;

            Quantum
              *magick_restrict q;

            q=GetCacheViewAuthenticPixels(annotate_view,0,y,annotate_image->columns,
              1,exception);
            if (q == (Quantum *) NULL)
              break;
            for (x=0; x < (ssize_t) annotate_image->columns; x++)
            {
              GetFillColor(draw_info,x,y,&fill_color,exception);
              SetPixelAlpha(annotate_image,ClampToQuantum((((double) QuantumScale*
                GetPixelIntensity(annotate_image,q)*fill_color.alpha))),q);
              SetPixelRed(annotate_image,fill_color.red,q);
              SetPixelGreen(annotate_image,fill_color.green,q);
              SetPixelBlue(annotate_image,fill_color.blue,q);
              q+=GetPixelChannels(annotate_image);
            }
            sync=SyncCacheViewAuthenticPixels(annotate_view,exception);
            if (sync == MagickFalse)
              break;
          }
          annotate_view=DestroyCacheView(annotate_view);
          (void) CompositeImage(image,annotate_image,OverCompositeOp,MagickTrue,
            (ssize_t) ceil(offset->x-0.5),(ssize_t) ceil(offset->y-(metrics->ascent+
            metrics->descent)-0.5),exception);
        }
    }
  (void) FT_Done_Face(face);
  (void) FT_Done_FreeType(library);
  return(MagickTrue);
}