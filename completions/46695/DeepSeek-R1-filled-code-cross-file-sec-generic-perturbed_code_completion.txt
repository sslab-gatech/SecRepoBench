if (encoding != (const char *) NULL)
    {
      if (LocaleCompare(encoding,"Adobe Standard") == 0)
        encoding_type=FT_ENCODING_ADOBE_STANDARD;
      else if (LocaleCompare(encoding,"Apple Roman") == 0)
        encoding_type=FT_ENCODING_APPLE_ROMAN;
      else if (LocaleCompare(encoding,"Big5") == 0)
        encoding_type=FT_ENCODING_BIG5;
      else if (LocaleCompare(encoding,"GB2312") == 0)
        encoding_type=FT_ENCODING_GB2312;
      else if (LocaleCompare(encoding,"Johab") == 0)
        encoding_type=FT_ENCODING_JOHAB;
      else if (LocaleCompare(encoding,"Microsoft Symbol") == 0)
        encoding_type=FT_ENCODING_MS_SYMBOL;
      else if (LocaleCompare(encoding,"Microsoft Unicode BMP") == 0)
        encoding_type=FT_ENCODING_MS_UNICODE_BMP;
      else if (LocaleCompare(encoding,"Microsoft Unicode UCS4") == 0)
        encoding_type=FT_ENCODING_MS_UNICODE_UCS4;
      else if (LocaleCompare(encoding,"SJIS") == 0)
        encoding_type=FT_ENCODING_SJIS;
      else if (LocaleCompare(encoding,"Unicode") == 0)
        encoding_type=FT_ENCODING_UNICODE;
      else if (LocaleCompare(encoding,"Wansung") == 0)
        encoding_type=FT_ENCODING_WANSUNG;
      if (encoding_type != FT_ENCODING_UNICODE)
        {
          ft_status=FT_Select_Charmap(face,encoding_type);
          if (ft_status != 0)
            {
              FT_Done_Face(face);
              FT_Done_FreeType(library);
              ThrowFreetypeErrorException("UnableToSetEncoding",ft_status,
                encoding);
              return(MagickFalse);
            }
        }
    }
  resolution.x=img->resolution.x != 0.0 ? img->resolution.x : 96.0;
  resolution.y=img->resolution.y != 0.0 ? img->resolution.y : 96.0;
  if (draw_info->density != (const char *) NULL)
    (void) sscanf(draw_info->density,"%lf%*[,x]%lf",&resolution.x,
      &resolution.y);
  ft_status=FT_Set_Char_Size(face,(FT_F26Dot6) (draw_info->pointsize*64.0*
    resolution.x/72.0),(FT_F26Dot6) (draw_info->pointsize*64.0*resolution.y/
    72.0),(FT_UInt) resolution.x,(FT_UInt) resolution.y);
  if (ft_status != 0)
    {
      FT_Done_Face(face);
      FT_Done_FreeType(library);
      ThrowFreetypeErrorException("UnableToSetFontSize",ft_status,
        args.pathname);
      return(MagickFalse);
    }
  metrics->ascent=(double) face->size->metrics.ascender/64.0;
  metrics->descent=(-(double) face->size->metrics.descender)/64.0;
  metrics->width=(double) face->size->metrics.max_advance/64.0;
  metrics->height=(double) (face->size->metrics.ascender-
    face->size->metrics.descender)/64.0;
  metrics->max_advance=metrics->width;
  if ((metrics->ascent+metrics->descent) > metrics->height)
    {
      metrics->ascent=metrics->height;
      metrics->descent=0.0;
    }
  metrics->underline_position=(double) face->underline_position/64.0;
  metrics->underline_thickness=(double) face->underline_thickness/64.0;
  if (metrics->underline_thickness <= 0.0)
    metrics->underline_thickness=1.0;
  if ((draw_info->text == (const char *) NULL) || (*draw_info->text == '\0') ||
      (face->num_glyphs == 0))
    {
      FT_Done_Face(face);
      FT_Done_FreeType(library);
      return(MagickTrue);
    }
  flags=FT_LOAD_DEFAULT;
  if (draw_info->text_antialias == MagickFalse)
    flags|=FT_LOAD_NO_HINTING|FT_LOAD_TARGET_MONO;
  else
    flags|=FT_LOAD_TARGET_NORMAL;
  grapheme=(GraphemeInfo **) AcquireQuantumMemory(1,sizeof(*grapheme));
  length=ComplexTextLayout(img,draw_info,draw_info->text,strlen(
    draw_info->text),face,flags,grapheme,exception);
  if (length == 0)
    {
      FT_Done_Face(face);
      FT_Done_FreeType(library);
      return(MagickTrue);
    }
  affine.xx=(FT_Fixed) (draw_info->affine.sx*0x10000L);
  affine.xy=(FT_Fixed) (draw_info->affine.rx*0x10000L);
  affine.yx=(FT_Fixed) (draw_info->affine.ry*0x10000L);
  affine.yy=(FT_Fixed) (draw_info->affine.sy*0x10000L);
  FT_Set_Transform(face,&affine,&origin);
  for (i=0; i < (ssize_t) length; i++)
  {
    ft_status=FT_Load_Glyph(face,(FT_UInt) (*grapheme)[i].index,flags);
    if (ft_status != 0)
      continue;
    ft_status=FT_Render_Glyph(face->glyph,FT_RENDER_MODE_NORMAL);
    if (ft_status != 0)
      continue;
    bitmap=(FT_BitmapGlyph) face->glyph;
    if ((bitmap->left >= 0) && (bitmap->left < (FT_Int) img->columns) &&
        (bitmap->top >= 0) && (bitmap->top < (FT_Int) img->rows))
      {
        for (y=0; y < (ssize_t) bitmap->bitmap.rows; y++)
        {
          register Quantum
            *magick_restrict q;

          ssize_t
            x;

          q=QueueAuthenticPixels(img,bitmap->left,bitmap->top-y,1,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < (ssize_t) bitmap->bitmap.width; x++)
          {
            if ((bitmap->bitmap.buffer[y*bitmap->bitmap.pitch+x/8] &
                (0x80 >> (x%8))) != 0)
              SetPixelOpacity(img,ClampToQuantum(QuantumRange-
                GetPixelOpacity(img)),q);
            q+=GetPixelChannels(img);
          }
          if (SyncAuthenticPixels(img,exception) == MagickFalse)
            break;
        }
      }
  }
  bounds.xMin=0;
  bounds.yMin=0;
  bounds.xMax=(FT_Pos) (face->size->metrics.max_advance);
  bounds.yMax=(FT_Pos) (face->size->metrics.height);
  metrics->bounds.x1=(double) bounds.xMin/64.0;
  metrics->bounds.y1=(double) bounds.yMin/64.0;
  metrics->bounds.x2=(double) bounds.xMax/64.0;
  metrics->bounds.y2=(double) bounds.yMax/64.0;
  metrics->width=(double) (bounds.xMax-bounds.xMin)/64.0;
  grapheme=(GraphemeInfo **) RelinquishMagickMemory(grapheme);
  FT_Done_Face(face);
  FT_Done_FreeType(library);
  return(MagickTrue);