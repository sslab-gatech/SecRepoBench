if (encoding != (const char *) NULL)
    {
      if (LocaleCompare(encoding,"AdobeCustom") == 0)
        encoding_type=FT_ENCODING_ADOBE_CUSTOM;
      else
        if (LocaleCompare(encoding,"AdobeExpert") == 0)
          encoding_type=FT_ENCODING_ADOBE_EXPERT;
        else
          if (LocaleCompare(encoding,"AdobeStandard") == 0)
            encoding_type=FT_ENCODING_ADOBE_STANDARD;
          else
            if (LocaleCompare(encoding,"AppleRoman") == 0)
              encoding_type=FT_ENCODING_APPLE_ROMAN;
            else
              if (LocaleCompare(encoding,"Big5") == 0)
                encoding_type=FT_ENCODING_BIG5;
              else
                if (LocaleCompare(encoding,"GB2312") == 0)
                  encoding_type=FT_ENCODING_GB2312;
                else
                  if (LocaleCompare(encoding,"Johab") == 0)
                    encoding_type=FT_ENCODING_JOHAB;
                  else
                    if (LocaleCompare(encoding,"SJIScode") == 0)
                      encoding_type=FT_ENCODING_SJIS;
                    else
                      if (LocaleCompare(encoding,"Symbol") == 0)
                        encoding_type=FT_ENCODING_MS_SYMBOL;
                      else
                        if (LocaleCompare(encoding,"Unicode") == 0)
                          encoding_type=FT_ENCODING_UNICODE;
      ft_status=FT_Select_Charmap(face,encoding_type);
      if (ft_status != 0)
        {
          (void) FT_Done_Face(face);
          (void) FT_Done_FreeType(library);
          ThrowFreetypeErrorException("UnrecognizedFontEncoding",ft_status,
            encoding);
          stream=DestroyFreetypeStream(stream);
          return(MagickFalse);
        }
    }
  resolution.x=72.0;
  resolution.y=72.0;
  if (draw_info->density != (char *) NULL)
    {
      GeometryInfo
        geometry_info;

      MagickStatusType
        flags;

      flags=ParseGeometry(draw_info->density,&geometry_info);
      resolution.x=geometry_info.rho;
      resolution.y=geometry_info.sigma;
      if ((flags & SigmaValue) == 0)
        resolution.y=resolution.x;
    }
  ft_status=FT_Set_Char_Size(face,(FT_F26Dot6)(64.0*draw_info->pointsize),
    (FT_F26Dot6)(64.0*draw_info->pointsize),(FT_UInt) resolution.x,
    (FT_UInt) resolution.y);
  if (ft_status != 0)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      ThrowFreetypeErrorException("UnableToSetFreetypeCharacterSize",ft_status,
        draw_info->font != (char *) NULL ? draw_info->font : "none");
      stream=DestroyFreetypeStream(stream);
      return(MagickFalse);
    }
  metrics->pixels_per_em.x=face->size->metrics.x_ppem;
  metrics->pixels_per_em.y=face->size->metrics.y_ppem;
  metrics->ascent=(double) face->size->metrics.ascender/64.0;
  metrics->descent=(double) face->size->metrics.descender/64.0;
  metrics->width=(double) face->size->metrics.max_advance/64.0;
  metrics->height=(double) face->size->metrics.height/64.0;
  metrics->max_advance=(double) face->size->metrics.max_advance/64.0;
  metrics->underline_position=face->underline_position/64.0;
  metrics->underline_thickness=face->underline_thickness/64.0;
  if (metrics->ascent < metrics->height)
    metrics->ascent=metrics->height;
  /*
    If Descent is bigger than Ascent we have a problem.  The descender is
    supposed to go below zero from the baseline.  Ascender is above zero.
    If the sum of the two is less than the height, we have bogus values.
    This is a work around for broken fonts.
  */
  if (metrics->descent > metrics->ascent)
    {
      double
        advance;

      advance=metrics->descent-metrics->ascent;
      metrics->descent=metrics->ascent;
      metrics->ascent+=advance;
    }
  if ((draw_info->text == (char *) NULL) || (face->num_glyphs == 0))
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      stream=DestroyFreetypeStream(stream);
      return(MagickTrue);
    }
  flags=FT_LOAD_DEFAULT;
  if ((draw_info->render == MagickFalse) || (draw_info->text_antialias == MagickFalse))
    flags|=FT_LOAD_MONOCHROME;
  if (draw_info->text_antialias == MagickTrue)
    flags|=FT_LOAD_FORCE_AUTOHINT;
  annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
  if (annotate_info->font == (char *) NULL)
    annotate_info->font=AcquireString("helvetica");
  (void) memset(&affine,0,sizeof(affine));
  affine.xx=65536L;
  affine.yy=-65536L;
  length=strlen(draw_info->text);
  grapheme=(GraphemeInfo *) NULL;
  if (draw_info->direction != UndefinedDirection)
    length=ComplexTextLayout(img,draw_info,draw_info->text,length,face,flags,
      &grapheme,exception);
  else
    {
      utf8=(unsigned char *) AcquireString(draw_info->text);
      length=ConvertUTF8ToUTF32((const unsigned char **) &utf8,&length);
    }
  if (length == 0)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      annotate_info=DestroyDrawInfo(annotate_info);
      stream=DestroyFreetypeStream(stream);
      return(MagickFalse);
    }
  status=MagickTrue;
  for (i=0; i < (ssize_t) length; i++)
  {
    /*
      Render glyphs to the image.
    */
    code=grapheme != (GraphemeInfo *) NULL ? (ssize_t) grapheme[i].index :
      utf8[i];
    glyph.id=code;
    ft_status=FT_Load_Glyph(face,(FT_UInt) code,flags);
    if (ft_status != 0)
      continue;
    ft_status=FT_Get_Glyph(face->glyph,&glyph.image);
    if (ft_status != 0)
      continue;
    origin.x=0;
    origin.y=0;
    if (grapheme != (GraphemeInfo *) NULL)
      {
        origin.x=grapheme[i].x_offset;
        origin.y=grapheme[i].y_offset;
      }
    FT_Outline_Transform(&((FT_OutlineGlyph) glyph.image)->outline,&affine);
    if (draw_info->stroke_width > 0.0)
      {
        annotate_info->affine.tx=offset->x+i*metrics->width+origin.x;
        annotate_info->affine.ty=offset->y-origin.y;
        FT_Outline_Translate(((FT_OutlineGlyph) glyph.image)->outline,
          (FT_Pos) (64.0*annotate_info->affine.tx),(FT_Pos) (64.0*
          annotate_info->affine.ty));
        if (glyph.image->format == FT_GLYPH_FORMAT_OUTLINE)
          {
            ft_status=FT_Outline_Decompose(&((FT_OutlineGlyph) glyph.image)->
              outline,&OutlineMethods,(void *) annotate_info);
            if (ft_status != 0)
              {
                (void) FT_Done_FreeType(library);
                ThrowFreetypeErrorException("UnableToDecomposeOutline",ft_status,
                  draw_info->font);
                stream=DestroyFreetypeStream(stream);
                return(MagickFalse);
              }
          }
      }
    ft_status=FT_Glyph_To_Bitmap(&glyph.image,FT_RENDER_MODE_NORMAL,
      (FT_Vector *) NULL,MagickTrue);
    if (ft_status != 0)
      continue;
    bitmap=(FT_BitmapGlyph) glyph.image;
    point.x=(double) (offset->x+i*metrics->width+origin.x/64.0+
      (((ssize_t) bitmap->left) << 6)+32)/64.0-metrics->width;
    point.y=(double) (offset->y-(origin.y/64.0)+((ssize_t) bitmap->top << 6)+
      32)/64.0+metrics->ascent;
    /*
      Rasterize the glyph on the image.
    */
    for (y=0; y < (ssize_t) bitmap->bitmap.rows; y++)
    {
      p=(char *) bitmap->bitmap.buffer+y*bitmap->bitmap.pitch;
      for (last_character=0; last_character < (ssize_t) bitmap->bitmap.width; last_character++)
      {
        if (((p[last_character/8] >> (7-(last_character % 8))) & 0x01) == 0)
          continue;
        if (SetImagePixels(img,(ssize_t) ceil(point.x+last_character-0.5),
            (ssize_t) ceil(point.y+y-0.5),1,1,exception) == 0)
          break;
        *GetImagePixels(img,(ssize_t) ceil(point.x+last_character-0.5),
          (ssize_t) ceil(point.y+y-0.5),1,1,exception)=annotate_info->fill.opacity;
        if (SyncImagePixels(img,exception) == MagickFalse)
          break;
      }
      if (last_character < (ssize_t) bitmap->bitmap.width)
        break;
    }
    if (y < (ssize_t) bitmap->bitmap.rows)
      {
        status=MagickFalse;
        break;
      }
    FT_Done_Glyph(glyph.image);
    if (grapheme == (GraphemeInfo *) NULL)
      bounds.xMin=(FT_Pos) floor((point.x-0.5)*64.0);
    else
      bounds.xMin=(FT_Pos) floor(((offset->x+((i+1)*metrics->width)+
        (grapheme[i].x_advance+grapheme[i].x_offset)/64.0-0.5)*64.0));
    bounds.yMin=(FT_Pos) floor((point.y-metrics->ascent-0.5)*64.0);
    bounds.xMax=(FT_Pos) ceil(((point.x+bitmap->bitmap.width-0.5)*64.0));
    bounds.yMax=(FT_Pos) ceil(((point.y+bitmap->bitmap.rows-0.5)*64.0));
  }
  if (grapheme != (GraphemeInfo *) NULL)
    grapheme=(GraphemeInfo *) RelinquishMagickMemory(grapheme);
  else
    utf8=(unsigned char *) RelinquishMagickMemory(utf8);
  /*
    Normalize bounding box.
  */
  metrics->bounds.x1=(double) bounds.xMin/64.0;
  metrics->bounds.y1=(double) bounds.yMin/64.0;
  metrics->bounds.x2=(double) bounds.xMax/64.0;
  metrics->bounds.y2=(double) bounds.yMax/64.0;
  metrics->width=(double) (bounds.xMax-bounds.xMin)/64.0;
  (void) FT_Done_Face(face);
  (void) FT_Done_FreeType(library);
  annotate_info=DestroyDrawInfo(annotate_info);
  stream=DestroyFreetypeStream(stream);
  return(status);