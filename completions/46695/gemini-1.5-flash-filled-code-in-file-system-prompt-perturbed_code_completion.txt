if (ft_status != 0)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      ThrowFreetypeErrorException("UnableToSetCharmap",ft_status,
        draw_info->font);
      return(MagickFalse);
    }
  if (draw_info->pointsize == 0.0)
    draw_info->pointsize=12.0;
  resolution.x=DefaultResolution;
  resolution.y=DefaultResolution;
  if (draw_info->density != (char *) NULL)
    {
      GeometryInfo
        geometry_info;

      MagickStatusType
        flags;

      flags=ParseGeometry(draw_info->density,&geometry_info);
      if ((flags & RhoValue) != 0)
        resolution.x=geometry_info.rho;
      resolution.y=resolution.x;
      if ((flags & SigmaValue) != 0)
        resolution.y=geometry_info.sigma;
    }
  ft_status=FT_Set_Char_Size(face,0,
    (FT_F26Dot6)(draw_info->pointsize*64.0),resolution.x,resolution.y);
  if (ft_status != 0)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      ThrowFreetypeErrorException("UnableToSetCharacterSize",ft_status,
        draw_info->font);
      return(MagickFalse);
    }
  metrics->ascent=(double) face->size->metrics.ascender/64.0;
  metrics->descent=(double) face->size->metrics.descender/64.0;
  metrics->width=(double) face->size->metrics.max_advance/64.0;
  metrics->height=(double) (face->size->metrics.height)/64.0;
  metrics->max_advance=(double) face->size->metrics.max_advance/64.0;
  if (metrics->ascent == 0.0)
    metrics->ascent=1.0;
  if (metrics->descent == 0.0)
    metrics->descent=-1.0;
  metrics->underline_position=(double) face->underline_position/64.0;
  metrics->underline_thickness=(double) face->underline_thickness/64.0;
  if (draw_info->text == (char *) NULL)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      return(MagickTrue);
    }
  if (face->num_glyphs == 0)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      return(MagickTrue);
    }
  flags=FT_LOAD_DEFAULT;
  if (draw_info->antialias == MagickFalse)
    flags|=FT_LOAD_MONOCHROME;
  if (draw_info->hint != UndefinedHint)
    {
      if (draw_info->hint == DefaultHint)
        flags|=FT_LOAD_DEFAULT;
      else
        if (draw_info->hint == FullHint)
          flags|=FT_LOAD_FORCE_AUTOHINT;
        else
          flags|=FT_LOAD_NO_HINTING;
    }
  length=strlen(draw_info->text);
  utf8=(unsigned char *) AcquireQuantumMemory(length+1,sizeof(*utf8));
  if (utf8 == (unsigned char *) NULL)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
    }
  (void) memcpy(utf8,(unsigned char *) draw_info->text,length+1);
  (void) ComplexTextLayout(img,draw_info,(const char *) utf8,length,face,flags,
    &grapheme,exception);
  utf8=(unsigned char *) RelinquishMagickMemory(utf8);
  if (grapheme == (GraphemeInfo *) NULL)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      return(MagickFalse);
    }
  annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
  (void) memset(&bounds,0,sizeof(bounds));
  first_glyph_id=0;
  last_glyph_id=0;
  missing_glyph_id=0;
  origin.x=0;
  origin.y=0;
  for (i=0; i < (ssize_t) strlen(draw_info->text); i++)
  {
    code=GetUTFCode(draw_info->text+grapheme[i].cluster);
    if (code == '\n')
      continue;
    glyph.id=(FT_UInt) grapheme[i].index;
    if (glyph.id == 0)
      {
        if (missing_glyph_id == 0)
          missing_glyph_id=FT_Get_Char_Index(face,'?');
        glyph.id=missing_glyph_id;
      }
    if (first_glyph_id == 0)
      first_glyph_id=glyph.id;
    last_glyph_id=glyph.id;
    ft_status=FT_Load_Glyph(face,glyph.id,flags);
    if (ft_status != 0)
      {
        (void) ThrowMagickException(exception,GetMagickModule(),TypeError,
          "UnableToLoadGlyph",FreetypeErrorMessage(ft_status));
        break;
      }
    ft_status=FT_Get_Glyph(face->glyph,&glyph.image);
    if (ft_status != 0)
      {
        (void) ThrowMagickException(exception,GetMagickModule(),TypeError,
          "UnableToGetGlyph",FreetypeErrorMessage(ft_status));
        break;
      }
    if (FT_IS_SCALABLE(face) != MagickFalse)
      {
        if (IsEmptyOutline(face->glyph->outline) == MagickFalse)
          {
            FT_Outline
              *outline;

            outline=&face->glyph->outline;
            affine=draw_info->affine;
            affine.tx+=offset->x+grapheme[i].x_offset/64.0;
            affine.ty+=offset->y-grapheme[i].y_offset/64.0;
            annotate_info->affine=affine;
            ft_status=FT_Outline_Decompose(outline,&OutlineMethods,
              annotate_info);
            if (ft_status != 0)
              {
                (void) ThrowMagickException(exception,GetMagickModule(),
                  TypeError,"UnableToDecomposeOutline",
                  FreetypeErrorMessage(ft_status));
                break;
              }
            (void) DrawImage(img,annotate_info,exception);
          }
      }
    if (FT_IS_SCALABLE(face) == MagickFalse)
      {
        bitmap=(FT_BitmapGlyph) glyph.image;
        if (bitmap->bitmap.buffer != (unsigned char *) NULL)
          {
            point.x=(double) (offset->x+grapheme[i].x_offset/64.0);
            point.y=(double) (offset->y-grapheme[i].y_offset/64.0);
            (void) RenderGlyph(img,annotate_info,&point,bitmap,exception);
          }
      }
    FT_Done_Glyph(glyph.image);
    origin.x+=grapheme[i].x_advance;
    if (grapheme[i].x_advance > bounds.x2)
      bounds.x2=grapheme[i].x_advance;
  }
  metrics->width=(double) bounds.x2/64.0;
  metrics->height=metrics->ascent-metrics->descent;
  metrics->bounds.x1=0.0;
  metrics->bounds.y1=metrics->descent;
  metrics->bounds.x2=metrics->width;
  metrics->bounds.y2=metrics->ascent;
  metrics->origin.x=0.0;
  metrics->origin.y=0.0;
  grapheme=(GraphemeInfo *) RelinquishMagickMemory(grapheme);
  annotate_info=DestroyDrawInfo(annotate_info);
  (void) FT_Done_Face(face);
  (void) FT_Done_FreeType(library);
  return(MagickTrue);