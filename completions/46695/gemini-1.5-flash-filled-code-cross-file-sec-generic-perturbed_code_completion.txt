if (ft_status != 0)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      ThrowFreetypeErrorException("UnableToSetCharacterMap",ft_status,
        draw_info->font);
      return(MagickFalse);
    }
  resolution.x=MagickAbsoluteValue(draw_info->density.x);
  resolution.y=MagickAbsoluteValue(draw_info->density.y);
  if ((resolution.x == 0) || (resolution.y == 0))
    {
      resolution.x=72;
      resolution.y=72;
    }
  ft_status=FT_Set_Char_Size(face,
    (FT_F26Dot6)(draw_info->pointsize*resolution.x),
    (FT_F26Dot6)(draw_info->pointsize*resolution.y),
    (FT_UInt) resolution.x,(FT_UInt) resolution.y);
  if (ft_status != 0)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      ThrowFreetypeErrorException("UnableToSetFontSize",ft_status,
        draw_info->font);
      return(MagickFalse);
    }
  metrics->ascent=(double) face->size->metrics.ascender/64.0;
  metrics->descent=(double) face->size->metrics.descender/64.0;
  metrics->width=(double) face->size->metrics.max_advance/64.0;
  metrics->height=metrics->ascent-metrics->descent;
  metrics->max_advance=(double) face->size->metrics.max_advance/64.0;
  if (metrics->ascent < 0.0)
    metrics->ascent=0.0;
  if (metrics->descent > 0.0)
    metrics->descent=0.0;
  metrics->underline_position=(double) face->underline_position/64.0;
  metrics->underline_thickness=(double) face->underline_thickness/64.0;
  length=strlen(draw_info->text);
  if (length == 0)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      return(MagickTrue);
    }
  if (face->num_glyphs == 0)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      return(MagickTrue);
    }
  flags=FT_LOAD_DEFAULT;
  if (draw_info->antialias == MagickFalse)
    flags|=FT_LOAD_MONOCHROME;
  if (draw_info->hint != NoHint)
    flags|=FT_LOAD_NO_HINTING;
  affine.xx=(FT_Fixed) (cos(draw_info->angle)*0x10000L);
  affine.xy=(FT_Fixed) (sin(draw_info->angle)*0x10000L);
  affine.yx=(FT_Fixed) (-sin(draw_info->angle)*0x10000L);
  affine.yy=(FT_Fixed) (cos(draw_info->angle)*0x10000L);
  origin.x=0;
  origin.y=0;
  grapheme=NULL;
  length=ComplexTextLayout(img,draw_info,draw_info->text,length,face,flags,
    &grapheme,exception);
  if (length == 0)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      return(MagickFalse);
    }
  status=MagickTrue;
  bounds.xMin=bounds.yMin=0;
  bounds.xMax=bounds.yMax=0;
  point.x=offset->x;
  point.y=offset->y;
  for (i=0; i < (ssize_t) length; i++)
  {
    glyph.id=grapheme[i].index;
    if (glyph.id == 0)
      glyph.id=missing_glyph_id;
    ft_status=FT_Load_Glyph(face,glyph.id,flags);
    if (ft_status != 0)
      {
        status=MagickFalse;
        continue;
      }
    if (FT_IS_SCALABLE(face))
      {
        FT_Outline_Transform(&face->glyph->outline,&affine);
        FT_Glyph_To_Bitmap(&face->glyph,&render_mode,0,exception);
        bitmap=face->glyph->bitmap;
      }
    else
      {
        bitmap=face->glyph->bitmap;
      }
    glyph.image=face->glyph;
    glyph.origin.x=point.x+grapheme[i].x_offset;
    glyph.origin.y=point.y+grapheme[i].y_offset;
    TraceGlyph(img,draw_info,&glyph,exception);
    point.x+=grapheme[i].x_advance;
    bounds.xMax=MagickMax(bounds.xMax,(FT_Pos) (glyph.origin.x+
      bitmap->width));
    bounds.yMax=MagickMax(bounds.yMax,(FT_Pos) (glyph.origin.y+
      bitmap->rows));
  }
  metrics->width=(double) (bounds.xMax-bounds.xMin)/64.0;
  metrics->height=(double) (bounds.yMax-bounds.yMin)/64.0;
  grapheme=(GraphemeInfo *) RelinquishMagickMemory(grapheme);
  (void) FT_Done_Face(face);
  (void) FT_Done_FreeType(library);
  return(status);