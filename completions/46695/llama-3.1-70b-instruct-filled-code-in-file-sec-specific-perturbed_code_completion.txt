ft_status=FT_Set_Char_Size(face,(FT_F26Dot6) (draw_info->pointsize*64.0),
    (FT_F26Dot6) (draw_info->pointsize*64.0),resolution.x,resolution.y);
  if (ft_status!= 0)
    ThrowFreetypeErrorException("UnableToSetCharacterSize",ft_status,
      draw_info->font!= (char *) NULL? draw_info->font : "none");
  metrics->ascent=(double) face->size->metrics.ascender/64.0;
  metrics->descent=(double) face->size->metrics.descender/64.0;
  metrics->width=(double) face->size->metrics.width/64.0;
  metrics->height=(double) face->size->metrics.height/64.0;
  metrics->max_advance=(double) face->size->metrics.max_advance/64.0;
  metrics->underline_position=(double) face->underline_position/64.0;
  metrics->underline_thickness=(double) face->underline_thickness/64.0;
  if (metrics->ascent < 0.0)
    metrics->ascent=0.0;
  if (metrics->descent > 0.0)
    metrics->descent=0.0;
  metrics->origin.x=(double) face->size->metrics.x_ppem/64.0;
  metrics->origin.y=(double) face->size->metrics.y_ppem/64.0;
  metrics->pixels_per_em.x=(double) face->size->metrics.x_ppem/64.0;
  metrics->pixels_per_em.y=(double) face->size->metrics.y_ppem/64.0;
  if (strlen(draw_info->text) == 0)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      return(MagickTrue);
    }
  if (face->num_glyphs == 0)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      return(MagickTrue);
    }
  flags=FT_LOAD_NO_BITMAP|FT_LOAD_NO_HINTING|FT_LOAD_IGNORE_TRANSFORM;
  if (draw_info->text_antialias == MagickFalse)
    flags|=FT_LOAD_MONOCHROME;
  if (draw_info->render == MagickFalse)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      return(MagickTrue);
    }
  (void) memset(&affine,0,sizeof(affine));
  affine.xx=(FT_Fixed) (draw_info->affine.sx*64.0);
  affine.xy=(FT_Fixed) (-draw_info->affine.rx*64.0);
  affine.yx=(FT_Fixed) (-draw_info->affine.ry*64.0);
  affine.yy=(FT_Fixed) (draw_info->affine.sy*64.0);
  (void) FT_Set_Transform(face,&affine,(FT_Vector *) NULL);
  (void) memset(&bounds,0,sizeof(bounds));
  (void) memset(&glyph,0,sizeof(glyph));
  (void) memset(&origin,0,sizeof(origin));
  length=strlen(draw_info->text);
  grapheme=(GraphemeInfo *) NULL;
  if (draw_info->direction == RightToLeftDirection)
    {
      p=draw_info->text+length-1;
      for (i=0; i < (ssize_t) length; i++)
      {
        code=GetUTFCode(p);
        if (code == '\n')
          {
            p=draw_info->text+length-1;
            continue;
          }
        glyph.id=(FT_UInt) FT_Get_Char_Index(face,code);
        if (glyph.id == 0)
          glyph.id=missing_glyph_id;
        ft_status=FT_Load_Glyph(face,glyph.id,flags);
        if (ft_status!= 0)
          ThrowFreetypeErrorException("UnableToLoadGlyph",ft_status,
            draw_info->font!= (char *) NULL? draw_info->font : "none");
        glyph.image=FT_Get_Glyph(face,&glyph);
        if (glyph.image == (FT_Glyph) NULL)
          ThrowFreetypeErrorException("UnableToGetGlyph",ft_status,
            draw_info->font!= (char *) NULL? draw_info->font : "none");
        if (FT_Glyph_Get_CBox(glyph.image,&bounds)!= 0)
          ThrowFreetypeErrorException("UnableToGetGlyphBBox",ft_status,
            draw_info->font!= (char *) NULL? draw_info->font : "none");
        metrics->bounds.x1=(double) bounds.xMin/64.0;
        metrics->bounds.y1=(double) bounds.yMin/64.0;
        metrics->bounds.x2=(double) bounds.xMax/64.0;
        metrics->bounds.y2=(double) bounds.yMax/64.0;
        if (IsEmptyOutline(face->glyph->outline) == MagickFalse)
          {
            FT_Outline_Get_BBox(face->glyph->outline,&bounds);
            metrics->bounds.x1=(double) bounds.xMin/64.0;
            metrics->bounds.y1=(double) bounds.yMin/64.0;
            metrics->bounds.x2=(double) bounds.xMax/64.0;
            metrics->bounds.y2=(double) bounds.yMax/64.0;
          }
        if (draw_info->direction == RightToLeftDirection)
          origin.x-=(double) glyph.image->advance.x/64.0;
        else
          origin.x+=(double) glyph.image->advance.x/64.0;
        if (draw_info->direction == RightToLeftDirection)
          origin.y+=(double) glyph.image->advance.y/64.0;
        else
          origin.y-=(double) glyph.image->advance.y/64.0;
        metrics->width+=glyph.image->advance.x/64.0;
        metrics->height+=glyph.image->advance.y/64.0;
        if (draw_info->direction == RightToLeftDirection)
          p--;
        else
          p++;
      }
    }
  else
    {
      p=draw_info->text;
      for (i=0; i < (ssize_t) length; i++)
      {
        code=GetUTFCode(p);
        if (code == '\n')
          {
            p=draw_info->text;
            continue;
          }
        glyph.id=(FT_UInt) FT_Get_Char_Index(face,code);
        if (glyph.id == 0)
          glyph.id=missing_glyph_id;
        ft_status=FT_Load_Glyph(face,glyph.id,flags);
        if (ft_status!= 0)
          ThrowFreetypeErrorException("UnableToLoadGlyph",ft_status,
            draw_info->font!= (char *) NULL? draw_info->font : "none");
        glyph.image=FT_Get_Glyph(face,&glyph);
        if (glyph.image == (FT_Glyph) NULL)
          ThrowFreetypeErrorException("UnableToGetGlyph",ft_status,
            draw_info->font!= (char *) NULL? draw_info->font : "none");
        if (FT_Glyph_Get_CBox(glyph.image,&bounds)!= 0)
          ThrowFreetypeErrorException("UnableToGetGlyphBBox",ft_status,
            draw_info->font!= (char *) NULL? draw_info->font : "none");
        metrics->bounds.x1=(double) bounds.xMin/64.0;
        metrics->bounds.y1=(double) bounds.yMin/64.0;
        metrics->bounds.x2=(double) bounds.xMax/64.0;
        metrics->bounds.y2=(double) bounds.yMax/64.0;
        if (IsEmptyOutline(face->glyph->outline) == MagickFalse)
          {
            FT_Outline_Get_BBox(face->glyph->outline,&bounds);
            metrics->bounds.x1=(double) bounds.xMin/64.0;
            metrics->bounds.y1=(double) bounds.yMin/64.0;
            metrics->bounds.x2=(double) bounds.xMax/64.0;
            metrics->bounds.y2=(double) bounds.yMax/64.0;
          }
        if (draw_info->direction == RightToLeftDirection)
          origin.x-=(double) glyph.image->advance.x/64.0;
        else
          origin.x+=(double) glyph.image->advance.x/64.0;
        if (draw_info->direction == RightToLeftDirection)
          origin.y+=(double) glyph.image->advance.y/64.0;
        else
          origin.y-=(double) glyph.image->advance.y/64.0;
        metrics->width+=glyph.image->advance.x/64.0;
        metrics->height+=glyph.image->advance.y/64.0;
        if (draw_info->direction == RightToLeftDirection)
          p--;
        else
          p++;
      }
    }
  metrics->width=(double) floor(metrics->width+0.5);
  metrics->height=(double) floor(metrics->height+0.5);
  metrics->bounds.x1=(double) floor(metrics->bounds.x1+0.5);
  metrics->bounds.y1=(double) floor(metrics->bounds.y1+0.5);
  metrics->bounds.x2=(double) floor(metrics->bounds.x2+0.5);
  metrics->bounds.y2=(double) floor(metrics->bounds.y2+0.5);
  if (draw_info->direction == RightToLeftDirection)
    {
      metrics->bounds.x1=origin.x-metrics->bounds.x1;
      metrics->bounds.x2=origin.x-metrics->bounds.x2;
    }
  else
    {
      metrics->bounds.x1+=origin.x;
      metrics->bounds.x2+=origin.x;
    }
  metrics->bounds.y1+=origin.y;
  metrics->bounds.y2+=origin.y;
  if (draw_info->direction == RightToLeftDirection)
    metrics->width=metrics->bounds.x1;
  else
    metrics->width=metrics->bounds.x2;
  metrics->underline_position=(double) face->underline_position/64.0;
  metrics->underline_thickness=(double) face->underline_thickness/64.0;
  if (metrics->underline_position < 0.0)
    metrics->underline_position=0.0;
  if (metrics->underline_thickness < 0.0)
    metrics->underline_thickness=0.0;
  if (draw_info->direction == RightToLeftDirection)
    {
      p=draw_info->text+length-1;
      for (i=0; i < (ssize_t) length; i++)
      {
        code=GetUTFCode(p);
        if (code == '\n')
          {
            p=draw_info->text+length-1;
            continue;
          }
        glyph.id=(FT_UInt) FT_Get_Char_Index(face,code);
        if (glyph.id == 0)
          glyph.id=missing_glyph_id;
        ft_status=FT_Load_Glyph(face,glyph.id,flags);
        if (ft_status!= 0)
          ThrowFreetypeErrorException("UnableToLoadGlyph",ft_status,
            draw_info->font!= (char *) NULL? draw_info->font : "none");
        glyph.image=FT_Get_Glyph(face,&glyph);
        if (glyph.image == (FT_Glyph) NULL)
          ThrowFreetypeErrorException("UnableToGetGlyph",ft_status,
            draw_info->font!= (char *) NULL? draw_info->font : "none");
        if (FT_Glyph_To_Bitmap(&glyph.image,FT_RENDER_MODE_NORMAL,0,0)!= 0)
          ThrowFreetypeErrorException("UnableToConvertGlyphToBitmap",ft_status,
            draw_info->font!= (char *) NULL? draw_info->font : "none");
        bitmap=(FT_BitmapGlyph) glyph.image;
        if (draw_info->direction == RightToLeftDirection)
          origin.x-=(double) glyph.image->advance.x/64.0;
        else
          origin.x+=(double) glyph.image->advance.x/64.0;
        if (draw_info->direction == RightToLeftDirection)
          origin.y+=(double) glyph.image->advance.y/64.0;
        else
          origin.y-=(double) glyph.image->advance.y/64.0;
        if (draw_info->direction == RightToLeftDirection)
          {
            point.x=offset->x+origin.x+draw_info->affine.tx-
              (double) bitmap->bitmap.width/64.0;
            point.y=offset->y+origin.y+draw_info->affine.ty-
              (double) bitmap->bitmap.rows/64.0;
          }
        else
          {
            point.x=offset->x+origin.x+draw_info->affine.tx;
            point.y=offset->y+origin.y+draw_info->affine.ty;
          }
        if (draw_info->fill.alpha!= TransparentAlpha)
          {
            CacheView
              *annotate_view;

            MagickBooleanType
              sync;

            PixelInfo
              fill_color;

            /*
              Render fill color.
            */
            if (image->alpha_trait == UndefinedPixelTrait)
              (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);
            if (annotate_image->alpha_trait == UndefinedPixelTrait)
              (void) SetImageAlphaChannel(annotate_image,OpaqueAlphaChannel,
                exception);
            fill_color=draw_info->fill;
            annotate_view=AcquireAuthenticCacheView(annotate_image,exception);
            for (y=0; y < (ssize_t) bitmap->bitmap.rows; y++)
            {
              ssize_t
                x;

              Quantum
                *magick_restrict q;

              q=GetCacheViewAuthenticPixels(annotate_view,0,y,
                bitmap->bitmap.width,1,exception);
              if (q == (Quantum *) NULL)
                break;
              for (x=0; x < (ssize_t) bitmap->bitmap.width; x++)
              {
                GetFillColor(draw_info,x,y,&fill_color,exception);
                SetPixelAlpha(annotate_image,ClampToQuantum((((double)
                  QuantumScale*GetPixelIntensity(annotate_image,q)*
                  fill_color.alpha))),q);
                SetPixelRed(annotate_image,fill_color.red,q);
                SetPixelGreen(annotate_image,fill_color.green,q);
                SetPixelBlue(annotate_image,fill_colo