if (FT_Select_Charmap(face,encoding_type) != 0)
    {
      const char
        *message;

      if (face->num_charmaps == 0)
        message="No character maps available";
      else
        message="Unable to select character map";
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      ThrowMagickException(exception,GetMagickModule(),TypeError,
        "UnableToSetEncoding",message);
      return(MagickFalse);
    }
  resolution.x=img->resolution.x;
  resolution.y=img->resolution.y;
  if (draw_info->density != 0.0)
    {
      resolution.x=(ssize_t) draw_info->density;
      resolution.y=(ssize_t) draw_info->density;
    }
  if (FT_Set_Char_Size(face,0, (FT_F26Dot6) (draw_info->pointsize*64.0),
      resolution.x,resolution.y) != 0)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      ThrowMagickException(exception,GetMagickModule(),TypeError,
        "UnableToSetFontSize","`%g'",draw_info->pointsize);
      return(MagickFalse);
    }
  metrics->ascent=face->size->metrics.ascender;
  metrics->descent=face->size->metrics.descender;
  metrics->width=face->size->metrics.max_advance;
  metrics->height=face->size->metrics.height;
  if (metrics->ascent < 0)
    metrics->ascent=0;
  if (metrics->descent > 0)
    metrics->descent=0;
  metrics->underline_position=face->underline_position;
  metrics->underline_thickness=face->underline_thickness;
  length=strlen(draw_info->text);
  if (length == 0)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      return(MagickTrue);
    }
  if (face->num_glyphs == 0)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      ThrowMagickException(exception,GetMagickModule(),TypeError,
        "FontIsMissingGlyphs","`%s'",draw_info->font);
      return(MagickFalse);
    }
  flags=FT_LOAD_DEFAULT;
  if (draw_info->antialias == MagickFalse)
    flags|=FT_LOAD_MONOCHROME;
  if (draw_info->hint != NoHint)
    flags|=FT_LOAD_NO_HINTING;
  affine.xx=(FT_Fixed) (cos(draw_info->angle)*0x10000L);
  affine.xy=(FT_Fixed) (sin(draw_info->angle)*0x10000L);
  affine.yx=(FT_Fixed) (-sin(draw_info->angle)*0x10000L);
  affine.yy=(FT_Fixed) (cos(draw_info->angle)*0x10000L);
  grapheme=NULL;
  length=ComplexTextLayout(img,draw_info,draw_info->text,length,face,flags,
    &grapheme,exception);
  if (length == 0)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      return(MagickFalse);
    }
  status=MagickTrue;
  point.x=0;
  point.y=0;
  bounds.xMin=0;
  bounds.yMin=0;
  bounds.xMax=0;
  bounds.yMax=0;
  utf8=(unsigned char *) AcquireQuantumMemory(length,sizeof(*utf8));
  if (utf8 == (unsigned char *) NULL)
    {
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      ThrowMagickException(exception,GetMagickModule(),ResourceLimitError,
        "MemoryAllocationFailed","`%s'",draw_info->text);
      return(MagickFalse);
    }
  p=draw_info->text;
  last_character=0;
  for (i=0; i < (ssize_t) length; i++)
  {
    code=GetUTFCode(p);
    p+=GetUTFOctets(p);
    if (code == 0)
      break;
    glyph.id=grapheme[i].index;
    if (glyph.id == 0)
      {
        glyph.id=missing_glyph_id;
        if (glyph.id == 0)
          continue;
      }
    ft_status=FT_Load_Glyph(face,glyph.id,flags);
    if (ft_status != 0)
      {
        status=MagickFalse;
        continue;
      }
    if (FT_HAS_KERNING(face))
      {
        FT_Vector
          kerning;

        ft_status=FT_Get_Kerning(face,(FT_UInt) last_character,(FT_UInt)
          glyph.id,ft_kerning_default,&kerning);
        if (ft_status == 0)
          point.x+=(ssize_t) ((draw_info->direction == RightToLeftDirection ?
            -1.0 : 1.0)*kerning.x);
      }
    last_character=glyph.id;
    glyph.image=face->glyph;
    bitmap=face->glyph->output.glyph;
    glyph.origin.x=point.x+bitmap->left;
    glyph.origin.y=point.y-bitmap->top;
    point.x+=grapheme[i].x_advance;
    if (bitmap->bitmap.buffer != (unsigned char *) NULL)
      {
        ssize_t
          x;

        size_t
          y;

        unsigned char
          *pixels;

        pixels=bitmap->bitmap.buffer;
        for (y=0; y < (size_t) bitmap->bitmap.rows; y++)
        {
          for (x=0; x < (ssize_t) bitmap->bitmap.width; x++)
          {
            if (*pixels != 0)
              {
                PixelPacket
                  pixel;

                ssize_t
                  j;

                j=x+glyph.origin.x;
                if ((j >= 0) && (j < (ssize_t) img->columns) &&
                    (y+glyph.origin.y >= 0) &&
                    (y+glyph.origin.y < (ssize_t) img->rows))
                  {
                    pixel=img->pixels[y+glyph.origin.y*img->columns+j];
                    pixel.red=ScaleQuantumToChar(*pixels);
                    pixel.green=ScaleQuantumToChar(*pixels);
                    pixel.blue=ScaleQuantumToChar(*pixels);
                    pixel.opacity=OpaqueOpacity;
                    img->pixels[y+glyph.origin.y*img->columns+j]=pixel;
                  }
              }
            pixels++;
          }
        }
      }
    if (glyph.origin.x < bounds.xMin)
      bounds.xMin=glyph.origin.x;
    if (glyph.origin.y < bounds.yMin)
      bounds.yMin=glyph.origin.y;
    if ((glyph.origin.x+bitmap->bitmap.width) > bounds.xMax)
      bounds.xMax=glyph.origin.x+bitmap->bitmap.width;
    if ((glyph.origin.y+bitmap->bitmap.rows) > bounds.yMax)
      bounds.yMax=glyph.origin.y+bitmap->bitmap.rows;
  }
  utf8=(unsigned char *) RelinquishMagickMemory(utf8);
  metrics->width=bounds.xMax-bounds.xMin;
  metrics->height=bounds.yMax-bounds.yMin;
  metrics->ascent=-bounds.yMin;
  metrics->descent=bounds.yMax;
  (void) FT_Done_Face(face);
  (void) FT_Done_FreeType(library);
  return(status);