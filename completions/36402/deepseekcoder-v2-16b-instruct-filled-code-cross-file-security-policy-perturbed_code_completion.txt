#include <vector>
#include <unordered_map>

// Assuming the table is a vector of pairs where each pair contains a tag and an index
std::vector<std::pair<hb_tag_t, unsigned int>> table;

bool find_table_index(hb_tag_t hb_tag, unsigned int *table_index) const
{
    // Determine the index of the table entry corresponding to the given tag.
    // Use the appropriate search method based on table entry size.
    if (table.size() < 1000) { // Arbitrary threshold, adjust as needed
        // Linear search for smaller collections
        for (size_t i = 0; i < table.size(); ++i) {
            if (table[i].first == hb_tag) {
                *table_index = table[i].second;
                return true;
            }
        }
    } else {
        // Hash map for larger collections
        std::unordered_map<hb_tag_t, unsigned int> tag_to_index_map(table.size());
        for (const auto& entry : table) {
            tag_to_index_map[entry.first] = entry.second;
        }
        auto it = tag_to_index_map.find(hb_tag);
        if (it != tag_to_index_map.end()) {
            *table_index = it->second;
            return true;
        }
    }
    return false;
}