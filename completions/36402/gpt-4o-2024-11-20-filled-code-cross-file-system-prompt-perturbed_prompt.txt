Below is the content of a C/C++ function where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
bool find_table_index (hb_tag_t hb_tag, unsigned int *table_index) const
  {
    // Determine the index of the table entry corresponding to the given tag.
    // Use the appropriate search mehtod based on table entry size.
    // <MASK>
  }
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/hb-open-file.hh
bool serialize (hb_serialize_context_t *c,
		  hb_tag_t sfnt_tag,
		  hb_array_t<item_t> items)
  {
    TRACE_SERIALIZE (this);
    /* Alloc 12 for the OTHeader. */
    if (unlikely (!c->extend_min (*this))) return_trace (false);
    /* Write sfntVersion (bytes 0..3). */
    sfnt_version = sfnt_tag;
    /* Take space for numTables, searchRange, entrySelector, RangeShift
     * and the TableRecords themselves.  */
    if (unlikely (!tables.serialize (c, items.length))) return_trace (false);

    const char *dir_end = (const char *) c->head;
    HBUINT32 *checksum_adjustment = nullptr;

    /* Write OffsetTables, alloc for and write actual table blobs. */
    for (unsigned int i = 0; i < tables.len; i++)
    {
      hb_blob_t *blob = items[i].blob;
      unsigned len = blob->length;

      /* Allocate room for the table and copy it. */
      char *start = (char *) c->allocate_size<void> (len);
      if (unlikely (!start)) return false;

      TableRecord &rec = tables.arrayZ[i];
      rec.tag = items[i].tag;
      rec.length = len;
      rec.offset = 0;
      if (unlikely (!c->check_assign (rec.offset,
				      (unsigned) ((char *) start - (char *) this),
				      HB_SERIALIZE_ERROR_OFFSET_OVERFLOW)))
        return_trace (false);

      if (likely (len))
	memcpy (start, blob->data, len);

      /* 4-byte alignment. */
      c->align (4);
      const char *end = (const char *) c->head;

      if (items[i].tag == HB_OT_TAG_head &&
	  (unsigned) (end - start) >= head::static_size)
      {
	head *h = (head *) start;
	checksum_adjustment = &h->checkSumAdjustment;
	*checksum_adjustment = 0;
      }

      rec.checkSum.set_for_data (start, end - start);
    }

    tables.qsort ();

    if (checksum_adjustment)
    {
      CheckSum checksum;

      /* The following line is a slower version of the following block. */
      //checksum.set_for_data (this, (const char *) c->head - (const char *) this);
      checksum.set_for_data (this, dir_end - (const char *) this);
      for (unsigned int i = 0; i < items.length; i++)
      {
	TableRecord &rec = tables.arrayZ[i];
	checksum = checksum + rec.checkSum;
      }

      *checksum_adjustment = 0xB1B0AFBAu - checksum;
    }

    return_trace (true);
  }

// the below code fragment can be found in:
// src/hb-ot-map.hh
void get_stage_lookups (unsigned int table_index, unsigned int stage,
			  const struct lookup_map_t **plookups, unsigned int *lookup_count) const
  {
    if (unlikely (stage > stages[table_index].length))
    {
      *plookups = nullptr;
      *lookup_count = 0;
      return;
    }
    unsigned int start = stage ? stages[table_index][stage - 1].last_lookup : 0;
    unsigned int end   = stage < stages[table_index].length ? stages[table_index][stage].last_lookup : lookups[table_index].length;
    *plookups = end == start ? nullptr : &lookups[table_index][start];
    *lookup_count = end - start;
  }

// the below code fragment can be found in:
// src/hb-ot-map.hh
unsigned int get_feature_stage (unsigned int table_index, hb_tag_t feature_tag) const
  {
    const feature_map_t *map = features.bsearch (feature_tag);
    return map ? map->stage[table_index] : UINT_MAX;
  }

// the below code fragment can be found in:
// src/hb-ot-shape.hh
void collect_lookups (hb_tag_t table_tag, hb_set_t *lookups) const
  {
    unsigned int table_index;
    switch (table_tag) {
      case HB_OT_TAG_GSUB: table_index = 0; break;
      case HB_OT_TAG_GPOS: table_index = 1; break;
      default: return;
    }
    map.collect_lookups (table_index, lookups);
  }

// the below code fragment can be found in:
// src/hb-ot-map.cc
hb_ot_map_builder_t::~hb_ot_map_builder_t ()
{
  feature_infos.fini ();
  for (unsigned int table_index = 0; table_index < 2; table_index++)
    stages[table_index].fini ();
}
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).