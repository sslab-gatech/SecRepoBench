for (x=0; x < (ssize_t) (number_pixels-1); x+=2)
  {
    p=PushShortPixel(quantum_info->endian,p,&pixel);
    switch (x % 3)
    {
      default:
      case 0:
      {
        SetPixelRed(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),
          range),q);
        break;
      }
      case 1:
      {
        SetPixelGreen(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),
          range),q);
        break;
      }
      case 2:
      {
        SetPixelBlue(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),
          range),q);
        q+=GetPixelChannels(image);
        break;
      }
    }
    p=PushShortPixel(quantum_info->endian,p,&pixel);
    switch ((x+1) % 3)
    {
      default:
      case 0:
      {
        SetPixelRed(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),
          range),q);
        break;
      }
      case 1:
      {
        SetPixelGreen(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),
          range),q);
        break;
      }
      case 2:
      {
        SetPixelBlue(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),
          range),q);
        q+=GetPixelChannels(image);
        break;
      }
    }
    p+=quantum_info->pad;
  }
  for (bit=0; bit < (ssize_t) (3*number_pixels % 2); bit++)
  {
    p=PushShortPixel(quantum_info->endian,p,&pixel);
    switch ((x+bit) % 3)
    {
      default:
      case 0:
      {
        SetPixelRed(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),
          range),q);
        break;
      }
      case 1:
      {
        SetPixelGreen(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),
          range),q);
        break;
      }
      case 2:
      {
        SetPixelBlue(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),
          range),q);
        q+=GetPixelChannels(image);
        break;
      }
    }
    p+=quantum_info->pad;
  }
  if (bit!= 0)
    p++;
  break;