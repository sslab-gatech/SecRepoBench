// Process groups of three pixels from the input data, converting each to a grayscale value.
// For each group, extract three 10-bit values from a 32-bit pixel.
// Convert each extracted value to a quantum gray value and assign it to the output pixel array.
// Handle the remaining pixels if the total number of pixels is not a multiple of three.
if (img->endian == LSBEndian)
  {
    for (x=0; x < (ssize_t) (number_pixels-2); x+=3)
    {
      p=PushLongPixel(quantum_info->endian,p,&pixel);
      SetPixelGray(img,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,range),q);
      q+=GetPixelChannels(img);
      SetPixelGray(img,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,range),q);
      q+=GetPixelChannels(img);
      SetPixelGray(img,ScaleAnyToQuantum((pixel >> 2) & 0x3ff,range),q);
      p+=quantum_info->pad;
      q+=GetPixelChannels(img);
    }
    if (x++ < (ssize_t) (number_pixels-1))
      {
        p=PushLongPixel(quantum_info->endian,p,&pixel);
        SetPixelGray(img,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,range),q);
        q+=GetPixelChannels(img);
      }
    if (x++ < (ssize_t) number_pixels)
      {
        SetPixelGray(img,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,range),q);
        q+=GetPixelChannels(img);
      }
    break;
  }