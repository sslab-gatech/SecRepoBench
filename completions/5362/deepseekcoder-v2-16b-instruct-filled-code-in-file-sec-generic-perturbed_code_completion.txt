static void ImportAlphaQuantum(const Image *image, QuantumInfo *quantum_info,
  const MagickSizeType number_pixels, const unsigned char *magick_restrict p,
  Quantum *magick_restrict q)
{
  QuantumAny range;
  register ssize_t x;
  unsigned int pixel;

  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);

  range = GetQuantumRange(quantum_info->depth);

  for (x = 0; x < (ssize_t) number_pixels; x++)
  {
    p = PushQuantumPixel(quantum_info, p, &pixel);
    SetPixelAlpha(image, ScaleAnyToQuantum(pixel, range), q);
    p += quantum_info->pad;
    q += GetPixelChannels(image);
  }
}

static void ImportBGRQuantum(const Image *image, QuantumInfo *quantum_info,
  const MagickSizeType number_pixels, const unsigned char *magick_restrict p,
  Quantum *magick_restrict q)
{
  QuantumAny range;
  register ssize_t x;
  ssize_t bit;
  unsigned int pixel;

  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);

  range = GetQuantumRange(quantum_info->depth);

  for (x = 0; x < (ssize_t) number_pixels; x++)
  {
    p = PushCharPixel(p, &pixel);
    SetPixelBlue(image, ScaleCharToQuantum(pixel), q);
    p = PushCharPixel(p, &pixel);
    SetPixelGreen(image, ScaleCharToQuantum(pixel), q);
    p = PushCharPixel(p, &pixel);
    SetPixelRed(image, ScaleCharToQuantum(pixel), q);
    SetPixelAlpha(image, OpaqueAlpha, q);
    p += quantum_info->pad;
    q += GetPixelChannels(image);
  }
}

// Similar implementations for other quantum types...

MagickExport size_t ImportQuantumPixels(const Image *image,
  CacheView *image_view, QuantumInfo *quantum_info,
  const QuantumType quantum_type, const unsigned char *magick_restrict pixels,
  ExceptionInfo *exception)
{
  MagickSizeType number_pixels;
  register const unsigned char *magick_restrict p;
  register ssize_t x;
  register Quantum *magick_restrict q;
  size_t extent;

  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent, GetMagickModule(), "%s", image->filename);
  assert(quantum_info != (QuantumInfo *) NULL);
  assert(quantum_info->signature == MagickCoreSignature);
  if (pixels == (const unsigned char *) NULL)
    pixels = (const unsigned char *) GetQuantumPixels(quantum_info);

  x = 0;
  p = pixels;
  if (image_view == (CacheView *) NULL)
  {
    number_pixels = GetImageExtent(image);
    q = GetAuthenticPixelQueue(image);
  }
  else
  {
    number_pixels = GetCacheViewExtent(image_view);
    q = GetCacheViewAuthenticPixelQueue(image_view);
  }

  ResetQuantumState(quantum_info);
  extent = GetQuantumExtent(image, quantum_info, quantum_type);

  switch (quantum_type)
  {
    case AlphaQuantum:
      ImportAlphaQuantum(image, quantum_info, number_pixels, p, q);
      break;
    case BGRQuantum:
      ImportBGRQuantum(image, quantum_info, number_pixels, p, q);
      break;
    // Similar cases for other quantum types...
    default:
      break;
  }

  if ((quantum_type == CbYCrQuantum) || (quantum_type == CbYCrAQuantum))
  {
    Quantum quantum;
    register Quantum *magick_restrict q;
    q = GetAuthenticPixelQueue(image);
    if (image_view != (CacheView *) NULL)
      q = GetCacheViewAuthenticPixelQueue(image_view);
    for (x = 0; x < (ssize_t) number_pixels; x++)
    {
      quantum = GetPixelRed(image, q);
      SetPixelRed(image, GetPixelGreen(image, q), q);
      SetPixelGreen(image, quantum, q);
      q += GetPixelChannels(image);
    }
  }

  if (quantum_info->alpha_type == DisassociatedQuantumAlpha)
  {
    double gamma, Sa;
    register Quantum *magick_restrict q;
    q = GetAuthenticPixelQueue(image);
    if (image_view != (CacheView *) NULL)
      q = GetCacheViewAuthenticPixelQueue(image_view);
    for (x = 0; x < (ssize_t) number_pixels; x++)
    {
      register ssize_t i;
      if (GetPixelWriteMask(image, q) <= (QuantumRange / 2))
      {
        q += GetPixelChannels(image);
        continue;
      }
      Sa = QuantumScale * GetPixelAlpha(image, q);
      gamma = PerceptibleReciprocal(Sa);
      for (i = 0; i < (ssize_t) GetPixelChannels(image); i++)
      {
        PixelChannel channel = GetPixelChannelChannel(image, i);
        PixelTrait traits = GetPixelChannelTraits(image, channel);
        if ((channel == AlphaPixelChannel) || ((traits & UpdatePixelTrait) == 0))
          continue;
        q[i] = ClampToQuantum(gamma * q[i]);
      }
      q += GetPixelChannels(image);
    }
  }

  return extent;
}