case 10:
    {
      range=GetQuantumRange(quantum_info->depth);
      if (quantum_info->pack == MagickFalse)
        {
          if (img->endian == LSBEndian)
            {
              for (x=0; x < (ssize_t) (number_pixels-2); x+=3)
              {
                p=PushLongPixel(quantum_info->endian,p,&pixel);
                SetPixelGray(img,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,
                  range),q);
                q+=GetPixelChannels(img);
                SetPixelGray(img,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,
                  range),q);
                q+=GetPixelChannels(img);
                SetPixelGray(img,ScaleAnyToQuantum((pixel >> 2) & 0x3ff,
                  range),q);
                p+=quantum_info->pad;
                q+=GetPixelChannels(img);
              }
              if (x++ < (ssize_t) (number_pixels-1))
              {
                p=PushLongPixel(quantum_info->endian,p,&pixel);
                SetPixelGray(img,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,
                  range),q);
                q+=GetPixelChannels(img);
              }
              if (x++ < (ssize_t) number_pixels)
              {
                SetPixelGray(img,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,
                  range),q);
                q+=GetPixelChannels(img);
              }
              break;
            }
          // Process groups of three pixels from the input data, converting each to a grayscale value.
          // For each group, extract three 10-bit values from a 32-bit pixel.
          // Convert each extracted value to a quantum gray value and assign it to the output pixel array.
          // Handle the remaining pixels if the total number of pixels is not a multiple of three.
          // <MASK>
        }
      for (x=0; x < (ssize_t) number_pixels; x++)
      {
        p=PushQuantumPixel(quantum_info,p,&pixel);
        SetPixelGray(img,ScaleAnyToQuantum(pixel,range),q);
        p+=quantum_info->pad;
        q+=GetPixelChannels(img);
      }
      break;
    }