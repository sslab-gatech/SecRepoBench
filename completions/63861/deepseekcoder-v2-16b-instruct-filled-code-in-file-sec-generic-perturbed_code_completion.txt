UNUSED_PARAMETER(self);
}

static
void Type_MLU_Free(struct _cms_typehandler_struct* self, void* Ptr)
{
    cmsMLU* mlu = (cmsMLU*) Ptr;

    if (mlu ->MemPool != NULL)
        _cmsFree(self ->ContextID, mlu ->MemPool);

    cmsMLUfree(mlu);
    return;

    cmsUNUSED_PARAMETER(self);
}


// ********************************************************************************
// Type cmsSigProfileSequenceDescType
// ********************************************************************************

static
void *Type_ProfileSequenceDesc_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)
{
    cmsUInt32Number Count;
    cmsUInt32Number i;
    cmsUInt32Number Offset;
    cmsUInt32Number SizeOfHeader;
    cmsUInt32Number LargestPosition;
    cmsUInt32Number NumOfWchar;
    cmsUInt32Number Len;
    wchar_t* Block;
    cmsProfileSequenceDesc* psd;

    *nItems = 0;
    if (!_cmsReadUInt32Number(io, &Count)) return NULL;

    psd = (cmsProfileSequenceDesc*) _cmsMalloc(self ->ContextID, sizeof(cmsProfileSequenceDesc));
    if (psd == NULL) return NULL;

    psd ->Count = Count;
    psd ->Offsets = (cmsUInt32Number*) _cmsCalloc(self ->ContextID, Count, sizeof(cmsUInt32Number));
    if (psd ->Offsets == NULL) {
        _cmsFree(self ->ContextID, psd);
        return NULL;
    }

    SizeOfHeader = Count * sizeof(cmsUInt32Number) + sizeof(_cmsTagBase);
    LargestPosition = 0;

    for (i=0; i < Count; i++) {

        if (!_cmsReadUInt32Number(io, &Offset)) goto Error;

        // Offset MUST be even because it indexes a block of utf16 chars. 
        // Tricky profiles that uses odd positions will not work anyway
        // because the whole utf16 block is previously converted to wchar_t 
        // and sizeof this type may be of 4 bytes. On Linux systems, for example.
        if (Offset & 1) goto Error;

        // Check for overflow
        if (Offset < (SizeOfHeader + 8)) goto Error;        
        if (((Offset + Len) < Len) || ((Offset + Len) > SizeOfTag + 8)) goto Error;

        psd ->Offsets[i] = Offset - SizeOfHeader - 8;

        // To guess maximum size, add offset + len
        if (Offset > LargestPosition)
            LargestPosition = Offset;
    }

    // Now read the remaining of tag and fill all strings. Subtract the directory
    SizeOfTag   = (LargestPosition * sizeof(wchar_t)) / sizeof(cmsUInt16Number);
    if (SizeOfTag == 0)
    {
        Block = NULL;
    }
    else
    {
        // Make sure this is an even utf16 size.
        if (SizeOfTag & 1) goto Error;

        Block = (wchar_t*) _cmsCalloc(self ->ContextID, 1, SizeOfTag);
        if (Block == NULL) goto Error;
       
        NumOfWchar = SizeOfTag / sizeof(wchar_t);
        if (!_cmsReadWCharArray(io, NumOfWchar, Block)) {
            _cmsFree(self->ContextID, Block);
            goto Error;
        }
    }

    psd ->MemPool  = Block;
    psd ->PoolSize = SizeOfTag;
    psd ->PoolUsed = SizeOfTag;

    *nItems = 1;
    return (void*) psd;

Error:
    if (psd) _cmsFree(self ->ContextID, psd);
    if (Block) _cmsFree(self ->ContextID, Block);
    return NULL;
}

static
cmsBool  Type_ProfileSequenceDesc_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)
{
    cmsProfileSequenceDesc* psd =(cmsProfileSequenceDesc*) Ptr;
    cmsUInt32Number HeaderSize;
    cmsUInt32Number  Offset;
    cmsUInt32Number i;

    if (Ptr == NULL) {

          // Empty placeholder
          if (!_cmsWriteUInt32Number(io, 0)) return FALSE;
          return TRUE;
    }

    if (!_cmsWriteUInt32Number(io, psd ->Count)) return FALSE;

    HeaderSize = psd ->Count * sizeof(cmsUInt32Number) + sizeof(_cmsTagBase);

    for (i=0; i < psd ->Count; i++) {

        Offset = psd ->Offsets[i];
        Offset = (Offset * sizeof(cmsUInt16Number)) / sizeof(wchar_t) + HeaderSize + 8;

        if (!_cmsWriteUInt32Number(io, Offset)) return FALSE;
    }

    if (!_cmsWriteWCharArray(io, psd ->PoolUsed / sizeof(wchar_t), (wchar_t*)  psd ->MemPool)) return FALSE;

    return TRUE;

    cmsUNUSED_PARAMETER(nItems);
    cmsUNUSED_PARAMETER(self);
}


static
void* Type_ProfileSequenceDesc_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)
{
    return (void*) cmsDupProfileSequenceDesc((cmsProfileSequenceDesc*) Ptr);

    cmsUNUSED_PARAMETER(n);
    cmsUNUSED_PARAMETER(self);
}

static
void Type_ProfileSequenceDesc_Free(struct _cms_typehandler_struct* self, void* Ptr)
{
    cmsProfileSequenceDesc* psd = (cmsProfileSequenceDesc*) Ptr;

    if (psd ->MemPool != NULL)
        _cmsFree(self ->ContextID, psd ->MemPool);

    _cmsFree(self ->ContextID, psd ->Offsets);
    _cmsFree(self ->ContextID, ptr);
    return;

    cmsUNUSED_PARAMETER(self);
}


// ********************************************************************************
// Type cmsSigProfileSequenceIdType
// ********************************************************************************

static
void *Type_ProfileSequenceId_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)
{
    cmsUInt32Number Count;
    cmsUInt32Number i;
    cmsUInt32Number Offset;
    cmsUInt32Number SizeOfHeader;
    cmsUInt32Number LargestPosition;
    cmsUInt32Number NumOfWchar;
    cmsUInt32Number Len;
    wchar_t* Block;
    cmsProfileSequenceId* psi;

    *nItems = 0;
    if (!_cmsReadUInt32Number(io, &Count)) return NULL;

    psi = (cmsProfileSequenceId*) _cmsMalloc(self ->ContextID, sizeof(cmsProfileSequenceId));
    if (psi == NULL) return NULL;

    psi ->Count = Count;
    psi ->Offsets = (cmsUInt32Number*) _cmsCalloc(self ->ContextID, Count, sizeof(cmsUInt32Number));
    if (psi ->Offsets == NULL) {
        _cmsFree(self ->ContextID, psi);
        return NULL;
    }

    SizeOfHeader = Count * sizeof(cmsUInt32Number) + sizeof(_cmsTagBase);
    LargestPosition = 0;

    for (i=0; i < Count; i++) {

        if (!_cmsReadUInt32Number(io, &Offset)) goto Error;

        // Offset MUST be even because it indexes a block of utf16 chars. 
        // Tricky profiles that uses odd positions will not work anyway
        // because the whole utf16 block is previously converted to wchar_t 
        // and sizeof this type may be of 4 bytes. On Linux systems, for example.
        if (Offset & 1) goto Error;

        // Check for overflow
        if (Offset < (SizeOfHeader + 8)) goto Error;        
        if (((Offset + Len) < Len) || ((Offset + Len) > SizeOfTag + 8)) goto Error;

        psi ->Offsets[i] = Offset - SizeOfHeader - 8;

        // To guess maximum size, add offset + len
        if (Offset > LargestPosition)
            LargestPosition = Offset;
    }

    // Now read the remaining of tag and fill all strings. Subtract the directory
    SizeOfTag   = (LargestPosition * sizeof(wchar_t)) / sizeof(cmsUInt16Number);
    if (SizeOfTag == 0)
    {
        Block = NULL;
    }
    else
    {
        // Make sure this is an even utf16 size.
        if (SizeOfTag & 1) goto Error;

        Block = (wchar_t*) _cmsCalloc(self ->ContextID, 1, SizeOfTag);
        if (Block == NULL) goto Error;
       
        NumOfWchar = SizeOfTag / sizeof(wchar_t);
        if (!_cmsReadWCharArray(io, NumOfWchar, Block)) {
            _cmsFree(self->ContextID, Block);
            goto Error;
        }
    }

    psi ->MemPool  = Block;
    psi ->PoolSize = SizeOfTag;
    psi ->PoolUsed = SizeOfTag;

    *nItems = 1;
    return (void*) psi;

Error:
    if (psi) _cmsFree(self ->ContextID, psi);
    if (Block) _cmsFree(self ->ContextID, Block);
    return NULL;
}

static
cmsBool  Type_ProfileSequenceId_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)
{
    cmsProfileSequenceId* psi =(cmsProfileSequenceId*) Ptr;
    cmsUInt32Number HeaderSize;
    cmsUInt32Number  Offset;
    cmsUInt32Number i;

    if (Ptr == NULL) {

          // Empty placeholder
          if (!_cmsWriteUInt32Number(io, 0)) return FALSE;
          return TRUE;
    }

    if (!_cmsWriteUInt32Number(io, psi ->Count)) return FALSE;

    HeaderSize = psi ->Count * sizeof(cmsUInt32Number) + sizeof(_cmsTagBase);

    for (i=0; i < psi ->Count; i++) {

        Offset = psi ->Offsets[i];
        Offset = (Offset * sizeof(cmsUInt16Number)) / sizeof(wchar_t) + HeaderSize + 8;

        if (!_cmsWriteUInt32Number(io, Offset)) return FALSE;
    }

    if (!_cmsWriteWCharArray(io, psi ->PoolUsed / sizeof(wchar_t), (wchar_t*)  psi ->MemPool)) return FALSE;

    return TRUE;

    cmsUNUSED_PARAMETER(nItems);
    cmsUNUSED_PARAMETER(self);
}


static
void* Type_ProfileSequenceId_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)
{
    return (void*) cmsDupProfileSequenceId((cmsProfileSequenceId*) Ptr);

    cmsUNUSED_PARAMETER(n);
    cmsUNUSED_PARAMETER(self);
}

static
void Type_ProfileSequenceId_Free(struct _cms_typehandler_struct* self, void* Ptr)
{
    cmsProfileSequenceId* psi = (cmsProfileSequenceId*) Ptr;

    if (psi ->MemPool != NULL)
        _cmsFree(self ->ContextID, psi ->MemPool);

    _cmsFree(self ->ContextID, psi ->Offsets);
    _cmsFree(self ->ContextID, ptr);
    return;

    cmsUNUSED_PARAMETER(self);
}


// ********************************************************************************
// Type cmsSigNamedColor2Type
// ********************************************************************************

static
void *Type_NamedColor2_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)
{
    cmsUInt32Number Count;
    cmsUInt3