// Read and handle the Unicode string component of a text description. 
    if (SizeOfTag < 2 * sizeof(cmsUInt32Number)) goto Error;
    if (!_cmsReadUInt32Number(io, &UnicodeCode)) goto Error;
    if (!_cmsReadUInt32Number(io, &unicodeLength)) goto Error;
    SizeOfTag -= 2 * sizeof(cmsUInt32Number);

    // Allocate memory to store the Unicode string and read the characters from the IO handler. 
    UnicodeString = (wchar_t*)_cmsMalloc(self->ContextID, (unicodeLength + 1) * sizeof(wchar_t));
    if (UnicodeString == NULL) goto Error;

    if (!_cmsReadWCharArray(io, unicodeLength, UnicodeString)) {
        _cmsFree(self->ContextID, UnicodeString);
        goto Error;
    }
    UnicodeString[unicodeLength] = 0;  // Null-terminate the string

    // Add the Unicode string to the MLU structure
    if (!cmsMLUsetWide(mlu, "en", "US", UnicodeString)) {
        _cmsFree(self->ContextID, UnicodeString);
        goto Error;
    }
    _cmsFree(self->ContextID, UnicodeString);

    // Adjust the remaining size of the tag data
    SizeOfTag -= unicodeLength * sizeof(cmsUInt16Number);

    // Check for the presence of optional ScriptCode elements
    if (SizeOfTag >= 2 * sizeof(cmsUInt16Number)) {
        if (!_cmsReadUInt16Number(io, &ScriptCodeCode)) goto Error;
        if (!_cmsReadUInt8Number(io, &ScriptCodeCount)) goto Error;
        SizeOfTag -= sizeof(cmsUInt16Number) + sizeof(cmsUInt8Number);

        // Skip over the ScriptCode data
        if (!io->Seek(io, io->Tell(io) + ScriptCodeCount)) goto Error;
        SizeOfTag -= ScriptCodeCount;
    }

    *nItems = 1;
    return (void*)mlu;