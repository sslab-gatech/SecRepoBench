// Check if there is enough space for the Unicode string
if (unicodeLength > 0x1000000) goto Done; // Sanity check to prevent unreasonable allocation
if (SizeOfTag < unicodeLength * sizeof(cmsUInt16Number)) goto Done;

// Allocate memory for the Unicode string
UnicodeString = (wchar_t*) _cmsMalloc(self->ContextID, (unicodeLength + 1) * sizeof(wchar_t));
if (UnicodeString == NULL) goto Done;

// Read the Unicode string
for (i = 0; i < unicodeLength; i++) {
    if (!_cmsReadUInt16Number(io, &Dummy)) goto Error;
    UnicodeString[i] = (wchar_t) Dummy;
}

// Ensure null termination
UnicodeString[unicodeLength] = 0;

// Add the Unicode string to the MLU
if (!cmsMLUsetWide(mlu, cmsNoLanguage, cmsNoCountry, UnicodeString)) goto Error;

// Clean up the Unicode string
_cmsFree(self->ContextID, UnicodeString);
UnicodeString = NULL;

// Update the remaining size
SizeOfTag -= unicodeLength * sizeof(cmsUInt16Number);

// Check for ScriptCode entries
if (SizeOfTag < sizeof(cmsUInt8Number)) goto Done;
if (!_cmsReadUInt8Number(io, &ScriptCodeCount)) goto Done;
SizeOfTag -= sizeof(cmsUInt8Number);

// Verify we have enough data for all ScriptCode entries
if (ScriptCodeCount > 0) {
    char buffer[67]; // Buffer for reading ScriptCode data
    
    if (SizeOfTag < ScriptCodeCount * (sizeof(cmsUInt16Number) + 67)) goto Done;
    
    // Skip each ScriptCode entry
    for (i = 0; i < ScriptCodeCount; i++) {
        if (!_cmsReadUInt16Number(io, &ScriptCodeCode)) goto Done;
        
        // Read and discard the 67 bytes of ScriptCode data
        if (io->Read(io, buffer, sizeof(char), 67) != 67) goto Done;
        
        SizeOfTag -= (sizeof(cmsUInt16Number) + 67);
    }
}

// Successfully read the text description
*nItems = 1;
return mlu;

Done:
*nItems = 1;
return mlu;

Error: