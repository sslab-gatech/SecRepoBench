if (unicodeLength % 2 != 0) goto Error;
{
    cmsUInt32Number nWChars = unicodeLength / 2;
    if (SizeOfTag < unicodeLength) goto Error;

    /* Allocate temporary buffer to read the 16-bit Unicode data */
    cmsUInt16Number* tempBuffer = (cmsUInt16Number*) _cmsMalloc(self->ContextID, nWChars * sizeof(cmsUInt16Number));
    if (tempBuffer == NULL) goto Error;
    if (io->Read(io, tempBuffer, sizeof(cmsUInt16Number), nWChars) != nWChars) {
        _cmsFree(self->ContextID, tempBuffer);
        goto Error;
    }
    SizeOfTag -= unicodeLength;

    /* Allocate a buffer for the wide character string (adding room for a terminator) */
    UnicodeString = (wchar_t*) _cmsMalloc(self->ContextID, (nWChars + 1) * sizeof(wchar_t));
    if (UnicodeString == NULL) {
        _cmsFree(self->ContextID, tempBuffer);
        goto Error;
    }
    for (i = 0; i < nWChars; i++)
        UnicodeString[i] = (wchar_t) tempBuffer[i];
    UnicodeString[nWChars] = 0;
    _cmsFree(self->ContextID, tempBuffer);
}

if (!cmsMLUsetWChar(mlu, cmsNoLanguage, cmsNoCountry, UnicodeString))
    goto Error;
_cmsFree(self->ContextID, (void*) UnicodeString);
UnicodeString = NULL;

/* Process optional ScriptCode elements */
if (SizeOfTag >= sizeof(cmsUInt8Number)) {
    if (io->Read(io, &ScriptCodeCount, sizeof(cmsUInt8Number), 1) != 1)
        goto Error;
    SizeOfTag -= sizeof(cmsUInt8Number);
    for (i = 0; i < ScriptCodeCount; i++) {
        if (SizeOfTag < 2 * sizeof(cmsUInt16Number))
            break;
        if (!_cmsReadUInt16Number(io, &ScriptCodeCode))
            break;
        if (!_cmsReadUInt16Number(io, &Dummy))
            break;
        SizeOfTag -= 2 * sizeof(cmsUInt16Number);
    }
}

*nItems = 1;
return mlu;