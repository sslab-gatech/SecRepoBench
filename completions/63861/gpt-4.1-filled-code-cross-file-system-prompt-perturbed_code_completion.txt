if (unicodeLength > 0 && SizeOfTag >= unicodeLength * sizeof(cmsUInt16Number)) {
    UnicodeString = (wchar_t*) _cmsMalloc(self->ContextID, (unicodeLength + 1) * sizeof(wchar_t));
    if (UnicodeString == NULL) goto Error;

    for (i = 0; i < unicodeLength; i++) {
        cmsUInt16Number ch;
        if (!io->Read(io, &ch, sizeof(cmsUInt16Number), 1)) {
            _cmsFree(self->ContextID, UnicodeString);
            goto Error;
        }
#ifdef CMS_IS_LITTLE_ENDIAN
        // Swap bytes if needed
        ch = (cmsUInt16Number) ((ch << 8) | (ch >> 8));
#endif
        UnicodeString[i] = (wchar_t) ch;
    }
    UnicodeString[unicodeLength] = 0;
    SizeOfTag -= unicodeLength * sizeof(cmsUInt16Number);

    // Set the Unicode string in the MLU
    cmsMLUsetWide(mlu, cmsNoLanguage, cmsNoCountry, UnicodeString);
    _cmsFree(self->ContextID, UnicodeString);
    UnicodeString = NULL;
} else if (unicodeLength > 0) {
    goto Error;
}

// Skip ScriptCode if present
if (SizeOfTag >= sizeof(cmsUInt8Number)) {
    if (!io->Read(io, &ScriptCodeCount, sizeof(cmsUInt8Number), 1)) goto Done;
    SizeOfTag -= sizeof(cmsUInt8Number);

    for (i = 0; i < ScriptCodeCount; i++) {
        if (SizeOfTag < 2 * sizeof(cmsUInt16Number)) break;
        if (!io->Read(io, &ScriptCodeCode, sizeof(cmsUInt16Number), 1)) break;
        if (!io->Read(io, &Dummy, sizeof(cmsUInt16Number), 1)) break;
        SizeOfTag -= 2 * sizeof(cmsUInt16Number);
    }
}

Done:
    *nItems = 1;
    return (void*) mlu;
Error:
    if (UnicodeString) _cmsFree(self->ContextID, (void*) UnicodeString);