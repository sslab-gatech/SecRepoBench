// Check if there is enough data left to process the Unicode string
    if (SizeOfTag < unicodeLength * sizeof(cmsUInt16Number)) goto Done;

    // Allocate buffer for Unicode string
    UnicodeString = (wchar_t*)_cmsMalloc(self->ContextID, (unicodeLength + 1) * sizeof(wchar_t));
    if (UnicodeString == NULL) goto Done;

    // Convert to wchar_t
    if (!convert_utf16_to_utf32(io, unicodeLength, UnicodeString)) {
        _cmsFree(self->ContextID, UnicodeString);
        goto Done;
    }

    // Add to MLU
    if (!cmsMLUsetWide(mlu, cmsNoLanguage, cmsNoCountry, UnicodeString)) {
        _cmsFree(self->ContextID, UnicodeString);
        goto Done;
    }

    _cmsFree(self->ContextID, UnicodeString);
    SizeOfTag -= unicodeLength * sizeof(cmsUInt16Number);

    // Check for optional ScriptCode elements
    if (SizeOfTag < sizeof(cmsUInt16Number) + sizeof(cmsUInt8Number)) goto Done;

    if (!_cmsReadUInt16Number(io, &ScriptCodeCode)) goto Done;
    if (!_cmsReadUInt8Number(io, &ScriptCodeCount)) goto Done;
    SizeOfTag -= sizeof(cmsUInt16Number) + sizeof(cmsUInt8Number);

    // Skip over ScriptCode data
    if (SizeOfTag < ScriptCodeCount) goto Done;
    if (io->Seek(io, io->Tell(io) + ScriptCodeCount) == 0) goto Done;
    SizeOfTag -= ScriptCodeCount;

    return (void*)mlu;