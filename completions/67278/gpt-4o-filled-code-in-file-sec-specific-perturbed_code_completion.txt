while (gf_bs_available(bs) > 3) {
		u32 val = gf_bs_read_u8(bs);
		if (val != 0x56) {
			nb_skip++;
			continue;
		}
		val = gf_bs_read_int(bs, 3);
		if (val != 0x07) {
			gf_bs_read_int(bs, 5);
			nb_skip++;
			continue;
		}
		u32 mux_size = gf_bs_read_int(bs, 13);
		u64 pos = gf_bs_get_position(bs);
		if (mux_size > gf_bs_available(bs)) {
			gf_bs_seek(bs, pos - 3);
			break;
		}
		if (!gf_bs_read_int(bs, 1)) {
			Bool amux_version = (Bool)gf_bs_read_int(bs, 1);
			Bool amux_versionA = GF_FALSE;
			if (amux_version) amux_versionA = (Bool)gf_bs_read_int(bs, 1);
			if (!amux_versionA) {
				u32 allStreamsSameTimeFraming = gf_bs_read_int(bs, 1);
				u32 numProgram = gf_bs_read_int(bs, 4);
				for (u32 i = 0; i <= numProgram; i++) {
					u32 num_lay = gf_bs_read_int(bs, 3);
					for (u32 j = 0; j <= num_lay; j++) {
						Bool same_cfg = GF_FALSE;
						if (i || j) same_cfg = (Bool)gf_bs_read_int(bs, 1);
						if (!same_cfg) {
							if (amux_version == 1) gf_latm_get_value(bs);
							gf_m4a_parse_config(bs, &acfg, GF_FALSE);
						}
						u32 frameLengthType = gf_bs_read_int(bs, 3);
						if (!frameLengthType) {
							gf_bs_read_int(bs, 8);
							if (!allStreamsSameTimeFraming) {
								// Handle non-same time framing if needed
							}
						} else {
							// Unsupported frame length type
						}
					}
				}
				if (gf_bs_read_int(bs, 1)) {
					// Handle other data present if needed
				}
				if (gf_bs_read_int(bs, 1)) {
					// Handle CRC check present if needed
				}
			}
		}
		numframes++;
		if (acfg.base_sr_index < GF_ARRAY_LENGTH(GF_M4ASampleRates) && GF_M4ASampleRates[acfg.base_sr_index]) {
			if (numframes >= 2) {
				break;
			}
		}
	}