u32 hdr, pos;
u32 payload_len;
u32 sr_idx;

// Check if we have enough data to read a header
if (gf_bs_available(bs) < 24) break;

pos = (u32)gf_bs_get_position(bs);
hdr = gf_bs_read_int(bs, 11);
if (hdr != 0x2B7) {
    // Not a valid sync word, skip a byte and try again
    gf_bs_seek(bs, pos + 8);
    nb_skip++;
    continue;
}

// Read configuration
if (gf_bs_read_int(bs, 1)) {
    // audio_mux_version_A == 1 not supported
    nb_skip++;
    continue;
}

gf_bs_read_int(bs, 1); // audio_mux_version
if (!gf_bs_read_int(bs, 1)) {
    // same_time_framing must be 1
    nb_skip++;
    continue;
}

payload_len = gf_bs_read_int(bs, 6);
sr_idx = gf_bs_read_int(bs, 4);

// Validate sample rate index before using it
if (sr_idx <= 12) {
    // Valid sample rate
    numframes++;
    
    // Make sure we don't read past available data
    if (gf_bs_available(bs) < payload_len * 8) {
        break;
    }
    
    // Skip to the next frame
    gf_bs_skip_bytes(bs, payload_len);
} else {
    // Invalid sample rate
    nb_skip++;
    continue;
}

// If we've found enough frames, we can stop
if (numframes >= 2) break;