u32 hdr, pos, sr_idx, mux_config_present;
u32 avail, max_skip = 8000;

// Check if we have enough data left
avail = (u32) gf_bs_available(bs);
if (avail < 4) break;

pos = (u32) gf_bs_get_position(bs);

// Read first 11 bits for sync
hdr = gf_bs_read_int(bs, 11);
if (hdr != 0x2B7) {
    // Not a sync word, skip one byte and try again
    gf_bs_seek(bs, pos+1);
    nb_skip++;
    if (nb_skip > max_skip) break; // Prevent excessive processing
    continue;
}

// Parse muxConfigPresent flag and other bits to get to sample rate
mux_config_present = gf_bs_read_int(bs, 1);
if (mux_config_present) {
    // If muxConfig is present, try to parse it to get to sample rate
    memset(&acfg, 0, sizeof(GF_M4ADecSpecInfo));
    
    // Skip some bits based on LATM format (simplified)
    gf_bs_read_int(bs, 10); // Skip some bits
    
    // Read sample rate index - simplified, actual parsing would be more complex
    sr_idx = gf_bs_read_int(bs, 4);
    acfg.base_sr_index = sr_idx;
    
    // Validate sample rate index (0-12 are valid)
    if (sr_idx <= 12) {
        numframes++;
        // Move to where we think the next frame might start (simplified)
        gf_bs_seek(bs, pos + 32); // Assuming minimum frame size
    } else {
        // Invalid sample rate, skip one byte and try again
        gf_bs_seek(bs, pos+1);
        nb_skip++;
    }
} else {
    // No muxConfig present, can't validate sample rate
    // Skip one byte and continue searching
    gf_bs_seek(bs, pos+1);
    nb_skip++;
}

// Exit if we have enough frames or not enough data left
if (numframes >= 2 || gf_bs_available(bs) < 4)
    break;