}
  }
  image_view=DestroyCacheView(image_view);
  pixels=DestroyPixelThreadSet(pixels);
  return(status);
}

static MagickBooleanType DitherImage(Image *image,CubeInfo *cube_info,
  ExceptionInfo *exception)
{
  if (FloydSteinbergDither(image,cube_info,exception) == MagickFalse)
    return(MagickFalse);
  return(MagickTrue);
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
+   G e t C u b e I n f o                                                     %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  GetCubeInfo() allocates the CubeInfo structure.
%
%  The format of the GetCubeInfo method is:
%
%      CubeInfo *GetCubeInfo(const QuantizeInfo *quantize_info,
%        const size_t colors,const size_t maximum_colors)
%
%  A description of each parameter follows:
%
%    o quantize_info: the quantize info.
%
%    o colors: the number of colors.
%
%    o maximum_colors: the maximum number of colors.
%
*/
static CubeInfo *GetCubeInfo(const QuantizeInfo *quantize_info,
  const size_t colors,const size_t maximum_colors)
{
  CubeInfo
    *cube_info;

  size_t
    number_threads;

  number_threads=(size_t) GetMagickResourceLimit(ThreadResource);
  cube_info=(CubeInfo *) AcquireMagickMemory(sizeof(*cube_info));
  if (cube_info == (CubeInfo *) NULL)
    return((CubeInfo *) NULL);
  cube_info->nodes=0;
  cube_info->free_nodes=0;
  cube_info->colors=0;
  cube_info->color_number=0;
  cube_info->depth=0;
  cube_info->maximum_colors=maximum_colors;
  cube_info->transparent_index=(-1);
  cube_info->transparent_pixels=0;
  cube_info->pruning_threshold=0.0;
  cube_info->next_threshold=0.0;
  cube_info->memory_info=AcquireVirtualMemory(number_threads,
    sizeof(*cube_info->cache));
  if (cube_info->memory_info == (MemoryInfo *) NULL)
    {
      cube_info=(CubeInfo *) RelinquishMagickMemory(cube_info);
      return((CubeInfo *) NULL);
    }
  cube_info->cache=(ssize_t *) AcquireQuantumMemory(number_threads,
    (2*colors+1)*sizeof(*cube_info->cache));
  if (cube_info->cache == (ssize_t *) NULL)
    {
      cube_info->memory_info=RelinquishVirtualMemory(cube_info->memory_info);
      cube_info=(CubeInfo *) RelinquishMagickMemory(cube_info);
      return((CubeInfo *) NULL);
    }
  (void) ResetMagickMemory(cube_info->cache,0,(2*colors+1)*sizeof(*cube_info->cache));
  cube_info->node_queue=(Nodes *) AcquireMagickMemory(sizeof(*cube_info->node_queue));
  if (cube_info->node_queue == (Nodes *) NULL)
    {
      cube_info->memory_info=RelinquishVirtualMemory(cube_info->memory_info);
      cube_info->cache=(ssize_t *) RelinquishQuantumMemory(cube_info->cache);
      cube_info=(CubeInfo *) RelinquishMagickMemory(cube_info);
      return((CubeInfo *) NULL);
    }
  cube_info->node_queue->nodes=(NodeInfo *) AcquireQuantumMemory(MaxNodes,
    sizeof(*cube_info->node_queue->nodes));
  if (cube_info->node_queue->nodes == (NodeInfo *) NULL)
    {
      cube_info->node_queue=(Nodes *) RelinquishMagickMemory(cube_info->node_queue);
      cube_info->memory_info=RelinquishVirtualMemory(cube_info->memory_info);
      cube_info->cache=(ssize_t *) RelinquishQuantumMemory(cube_info->cache);
      cube_info=(CubeInfo *) RelinquishMagickMemory(cube_info);
      return((CubeInfo *) NULL);
    }
  (void) ResetMagickMemory(cube_info->node_queue->nodes,0,MaxNodes*
    sizeof(*cube_info->node_queue->nodes));
  cube_info->node_queue->next=NULL;
  cube_info->next_node=cube_info->node_queue->nodes;
  cube_info->quantize_info=CloneQuantizeInfo(quantize_info);
  if (cube_info->quantize_info == (QuantizeInfo *) NULL)
    {
      cube_info->node_queue->nodes=(NodeInfo *) RelinquishQuantumMemory(
        cube_info->node_queue->nodes);
      cube_info->node_queue=(Nodes *) RelinquishMagickMemory(cube_info->node_queue);
      cube_info->memory_info=RelinquishVirtualMemory(cube_info->memory_info);
      cube_info->cache=(ssize_t *) RelinquishQuantumMemory(cube_info->cache);
      cube_info=(CubeInfo *) RelinquishMagickMemory(cube_info);
      return((CubeInfo *) NULL);
    }
  return(cube_info);
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
+   G e t N o d e I n f o                                                     %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  GetNodeInfo() allocates the NodeInfo structure.
%
%  The format of the GetNodeInfo method is:
%
%      NodeInfo *GetNodeInfo(CubeInfo *cube_info,const size_t id,
%        const size_t level,NodeInfo *parent)
%
%  A description of each parameter follows:
%
%    o cube_info: the cube info.
%
%    o id: the node id.
%
%    o level: the node level.
%
%    o parent: the parent node.
%
*/
static NodeInfo *GetNodeInfo(CubeInfo *cube_info,const size_t id,
  const size_t level,NodeInfo *parent)
{
  NodeInfo
    *node_info;

  if (cube_info->free_nodes == 0)
    {
      if (cube_info->nodes >= MaxNodes)
        return((NodeInfo *) NULL);
      node_info=cube_info->next_node++;
    }
  else
    {
      node_info=cube_info->node_queue->nodes+cube_info->free_nodes;
      cube_info->free_nodes++;
    }
  cube_info->nodes++;
  node_info->id=id;
  node_info->level=level;
  node_info->parent=parent;
  node_info->number_unique=0;
  node_info->total_color.red=0.0;
  node_info->total_color.green=0.0;
  node_info->total_color.blue=0.0;
  node_info->total_color.alpha=0.0;
  node_info->quantize_error=0.0;
  node_info->color_number=0;
  (void) ResetMagickMemory(node_info->child,0,sizeof(node_info->child));
  return(node_info);
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
+   G e t Q u a n t i z e I n f o                                             %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  GetQuantizeInfo() allocates the QuantizeInfo structure.
%
%  The format of the GetQuantizeInfo method is:
%
%      QuantizeInfo *GetQuantizeInfo(void)
%
%  A description of each parameter follows:
%
%    o quantize_info: the quantize info.
%
*/
void GetQuantizeInfo(QuantizeInfo *quantize_info)
{
  quantize_info->number_colors=0;
  quantize_info->tree_depth=0;
  quantize_info->dither_method=NoDitherMethod;
  quantize_info->colorspace=UndefinedColorspace;
  quantize_info->measure_error=MagickFalse;
  quantize_info->signature=MagickCoreSignature;
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
+   G e t T r a n s p a r e n t I n d e x                                      %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  GetTransparentIndex() returns the index of the transparent color in the
%  image colormap.
%
%  The format of the GetTransparentIndex method is:
%
%      ssize_t GetTransparentIndex(const Image *image)
%
%  A description of each parameter follows:
%
%    o image: the image.
%
*/
MagickExport ssize_t GetTransparentIndex(const Image *image)
{
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  return(image->transparent_index);
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
+   P r u n e L e v e l                                                        %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  PruneLevel() prunes the tree from the leaves upward.  n2,  Sr, Sg,  and  Sb
%  in a node being pruned are always added to the corresponding data in that
%  node's parent.  This retains the pruned node's color characteristics for
%  later averaging.
%
%  The format of the PruneLevel method is:
%
%      void PruneLevel(CubeInfo *cube_info,const NodeInfo *node_info)
%
%  A description of each parameter follows:
%
%    o cube_info: A pointer to the Cube structure.
%
%    o node_info: the address of a structure of type NodeInfo which points to a
%      node in the color cube tree that is to be pruned.
%
*/
static void PruneLevel(CubeInfo *cube_info,const NodeInfo *node_info)
{
  register ssize_t
    i;

  size_t
    number_children;

  /*
    Traverse any children.
  */
  number_children=cube_info->associate_alpha == MagickFalse ? 8UL : 16UL;
  for (i=0; i < (ssize_t) number_children; i++)
    if (node_info->child[i] != (NodeInfo *) NULL)
      PruneLevel(cube_info,node_info->child[i]);
  if (node_info->number_unique != 0)
    {
      register double
        alpha;

      register PixelInfo
        *magick_restrict q;

      /*
        Colormap entry is defined by the mean color in this cube.
      */
      q=image->colormap+image->colors;
      alpha=(double) ((MagickOffsetType) node_info->number_unique);
      alpha=PerceptibleReciprocal(alpha);
      if (cube_info->associate_alpha == MagickFalse)
        {
          q->red=(double) ClampToQuantum(alpha*QuantumRange*
            node_info->total_color.red);
          q->green=(double) ClampToQuantum(alpha*QuantumRange*
            node_info->total_color.green);
          q->blue=(double) ClampToQuantum(alpha*QuantumRange*
            node_info->total_color.blue);
          q->alpha=(double) OpaqueAlpha;
        }
      else
        {
          double
            opacity;

          opacity=(double) (alpha*QuantumRange*node_info->total_color.alpha);
          q->alpha=(double) ClampToQuantum(opacity);
          if (q->alpha == OpaqueAlpha)
            {
              q->red=(double) ClampToQuantum(alpha*QuantumRange*
                node_info->total_color