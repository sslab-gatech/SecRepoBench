ExceptionInfo *);

static MagickBooleanType DitherImage(Image *image,CubeInfo *cube_info,
  ExceptionInfo *exception)
{
  if (cube_info->quantize_info->dither_method == NoDitherMethod)
    return(MagickTrue);
  if (cube_info->quantize_info->dither_method == FloydSteinbergDitherMethod)
    return(FloydSteinbergDither(image,cube_info,exception));
  if (cube_info->quantize_info->dither_method == RiemersmaDitherMethod)
    return(RiemersmaDither(image,AcquireAuthenticCacheView(image,exception),
      cube_info,cube_info->colors,exception));
  return(MagickFalse);
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
+   G e t C u b e I n f o                                                   %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  GetCubeInfo() allocates the CubeInfo structure.
%
%  The format of the GetCubeInfo method is:
%
%      CubeInfo *GetCubeInfo(const QuantizeInfo *quantize_info,
%        const size_t x,const size_t y)
%
%  A description of each parameter follows:
%
%    o quantize_info: the quantize info.
%
%    o x: the x-coordinate.
%
%    o y: the y-coordinate.
%
*/
static CubeInfo *GetCubeInfo(const QuantizeInfo *quantize_info,const size_t x,
  const size_t y)
{
  CubeInfo
    *cube_info;

  size_t
    colors;

  colors=quantize_info->number_colors;
  if (colors == 0)
    colors=256;
  if (colors > 256)
    colors=256;
  cube_info=(CubeInfo *) AcquireMemory(sizeof(*cube_info));
  if (cube_info == (CubeInfo *) NULL)
    return((CubeInfo *) NULL);
  cube_info->colors=0;
  cube_info->maximum_colors=colors;
  cube_info->transparent_index=(-1);
  cube_info->transparent_pixels=0;
  cube_info->target.red=0.0;
  cube_info->target.green=0.0;
  cube_info->target.blue=0.0;
  cube_info->target.alpha=0.0;
  cube_info->distance=4.0*(QuantumRange+1.0)*(QuantumRange+1.0)+1.0;
  cube_info->pruning_threshold=0.0;
  cube_info->next_threshold=0.0;
  cube_info->nodes=0;
  cube_info->free_nodes=0;
  cube_info->color_number=0;
  cube_info->next_node=NULL;
  cube_info->node_queue=NULL;
  cube_info->memory_info=NULL;
  cube_info->cache=NULL;
  cube_info->quantize_info=CloneQuantizeInfo(quantize_info);
  cube_info->associate_alpha=MagickFalse;
  cube_info->x=x;
  cube_info->y=y;
  cube_info->depth=MaxTreeDepth;
  cube_info->offset=0;
  cube_info->span=1;
  return(cube_info);
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
+   G e t N o d e I n f o                                                   %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  GetNodeInfo() allocates the NodeInfo structure.
%
%  The format of the GetNodeInfo method is:
%
%      NodeInfo *GetNodeInfo(CubeInfo *cube_info,const size_t id,
%        const size_t level,NodeInfo *parent)
%
%  A description of each parameter follows:
%
%    o cube_info: the cube info.
%
%    o id: the node id.
%
%    o level: the node level.
%
%    o parent: the parent node.
%
*/
static NodeInfo *GetNodeInfo(CubeInfo *cube_info,const size_t id,
  const size_t level,NodeInfo *parent)
{
  NodeInfo
    *node_info;

  size_t
    size;

  size=sizeof(*node_info);
  if (cube_info->free_nodes != 0)
    {
      node_info=cube_info->node_queue->nodes;
      cube_info->node_queue->nodes=node_info->parent;
      cube_info->free_nodes--;
    }
  else
    {
      node_info=(NodeInfo *) AcquireMemory(size);
      if (node_info == (NodeInfo *) NULL)
        return((NodeInfo *) NULL);
    }
  node_info->parent=parent;
  node_info->child[0]=(NodeInfo *) NULL;
  node_info->child[1]=(NodeInfo *) NULL;
  node_info->child[2]=(NodeInfo *) NULL;
  node_info->child[3]=(NodeInfo *) NULL;
  node_info->child[4]=(NodeInfo *) NULL;
  node_info->child[5]=(NodeInfo *) NULL;
  node_info->child[6]=(NodeInfo *) NULL;
  node_info->child[7]=(NodeInfo *) NULL;
  node_info->child[8]=(NodeInfo *) NULL;
  node_info->child[9]=(NodeInfo *) NULL;
  node_info->child[10]=(NodeInfo *) NULL;
  node_info->child[11]=(NodeInfo *) NULL;
  node_info->child[12]=(NodeInfo *) NULL;
  node_info->child[13]=(NodeInfo *) NULL;
  node_info->child[14]=(NodeInfo *) NULL;
  node_info->child[15]=(NodeInfo *) NULL;
  node_info->number_unique=0;
  node_info->total_color.red=0.0;
  node_info->total_color.green=0.0;
  node_info->total_color.blue=0.0;
  node_info->total_color.alpha=0.0;
  node_info->quantize_error=0.0;
  node_info->color_number=0;
  node_info->id=id;
  node_info->level=level;
  if (parent != (NodeInfo *) NULL)
    {
      parent->child[id]=(NodeInfo *) node_info;
      node_info->number_unique=parent->number_unique;
      node_info->total_color.red=parent->total_color.red;
      node_info->total_color.green=parent->total_color.green;
      node_info->total_color.blue=parent->total_color.blue;
      node_info->total_color.alpha=parent->total_color.alpha;
      node_info->quantize_error=parent->quantize_error;
    }
  cube_info->nodes++;
  return(node_info);
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
+   G e t Q u a n t i z e I n f o                                           %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  GetQuantizeInfo() initializes the QuantizeInfo structure.
%
%  The format of the GetQuantizeInfo method is:
%
%      void GetQuantizeInfo(QuantizeInfo *quantize_info)
%
%  A description of each parameter follows:
%
%    o quantize_info: the quantize info.
%
*/
static void GetQuantizeInfo(QuantizeInfo *quantize_info)
{
  assert(quantize_info != (QuantizeInfo *) NULL);
  quantize_info->number_colors=0;
  quantize_info->tree_depth=0;
  quantize_info->dither_method=NoDitherMethod;
  quantize_info->colorspace=UndefinedColorspace;
  quantize_info->measure_error=MagickFalse;
  quantize_info->signature=MagickCoreSignature;
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
+   G e t T r a n s p a r e n t I n d e x                                     %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  GetTransparentIndex() returns the index of the transparent color in the
%  colormap.
%
%  The format of the GetTransparentIndex method is:
%
%      ssize_t GetTransparentIndex(const Image *image)
%
%  A description of each parameter follows:
%
%    o image: the image.
%
*/
static ssize_t GetTransparentIndex(const Image *image)
{
  register ssize_t
    i;

  for (i=0; i < (ssize_t) image->colors; i++)
    if (image->colormap[i].alpha == TransparentAlpha)
      return(i);
  return(-1);
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
+   P r u n e L e v e l                                                       %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  PruneLevel() prunes the tree from the leaves upward.
%
%  The format of the PruneLevel method is:
%
%      void PruneLevel(CubeInfo *cube_info,const NodeInfo *node_info)
%
%  A description of each parameter follows:
%
%    o cube_info: the cube info.
%
%    o node_info: the address of a structure of type NodeInfo which points to a
%      node in the color cube tree that is to be pruned.
%
*/
static void PruneLevel(CubeInfo *cube_info,const NodeInfo *node_info)
{
  register ssize_t
    i;

  size_t
    number_children;

  number_children=cube_info->associate_alpha == MagickFalse ? 8UL : 16UL;
  for (i=0; i < (ssize_t) number_children; i++)
    if (node_info->child[i] != (NodeInfo *) NULL)
      PruneLevel(cube_info,node_info->child[i]);
  if (node_info->number_unique != 0)
    {
      register NodeInfo
        *parent_info;

      register size_t
        node_id;

      parent_info=node_info->parent;
      if (parent_info != (NodeInfo *) NULL)
        {
          parent_info->number_unique+=node_info->number_unique;
          parent_info->total_color.red+=node_info->total_color.red;
          parent_info->total_color.green+=node_info->total_color.green;
          parent_info->total_color.blue+=node_info->total_color.blue;
          parent_info->total_color.alpha+=node_info->total_color.alpha;
          parent_info->quantize_error+=node_info->quantize_error;
          node_id=node_info->id;
          parent_info->child[node_id]=(NodeInfo *) NULL;
          cube_info->free_nodes++;
        }
    }
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
+   P r u n e T o C u b e D e p t h                                           %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  PruneToCubeDepth() prunes the tree to the specified depth.
%
%  The format of the PruneToCubeDepth method is:
%
%      void PruneToCubeDepth(CubeInfo *cube_info,const NodeInfo *node_info)
%
%  A description of each parameter follows:
%
%    o cube_info: the cube info.