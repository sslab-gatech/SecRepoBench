case VALUE_UNISTR:
{
  /* Ensure we have enough bytes to read the size. */
  if(payload_len < 4)
    return 0;

  /* Read the size (4 bytes). */
  uint32_t data_size = ntohl(get_u_int32_t(databuffer, 0));

  /* Check that data size is nonzero and does not exceed remaining payload. */
  if(data_size == 0 || data_size > payload_len - 4)
    return 0;

  /* Assign the pointer to the actual data following the size field. */
  v->value.ptr.value_str = (const char *)(databuffer + 4);

  /* For VALUE_DATA, you might adjust the value in some fashion if needed.
   * Currently, we do the same as VALUE_UNISTR and VALUE_STR. */
  if(t == VALUE_DATA) {
    /* Adjustment (if required) can be done here. */
  }

  /* Update the value size and total bytes processed. */
  v->value_size = data_size;
  ret = 4 + data_size;
}
break;