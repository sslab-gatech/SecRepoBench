VALUE_UNISTR:
      if (payload_len < 4)
        return 0;

      // Read the size of the UNISTR
      uint32_t unistr_size = ntohl(get_u_int32_t(databuffer, 0));
      if (unistr_size == 0 || unistr_size > payload_len - 4)
        return 0;

      // Allocate memory for the UNISTR value
      v->value.ptr.value_unistr = (char *)malloc(unistr_size + 1);
      if (v->value.ptr.value_unistr == NULL)
        return 0;

      // Copy the UNISTR data
      memcpy(v->value.ptr.value_unistr, databuffer + 4, unistr_size);
      v->value.ptr.value_unistr[unistr_size] = '\0'; // Null-terminate the string

      v->value_size = unistr_size;
      ret = unistr_size + 4; // Include the size indicator
      break;

    case VALUE_DATA:
      if (payload_len < 4)
        return 0;

      // Read the size of the DATA
      uint32_t data_size = ntohl(get_u_int32_t(databuffer, 0));
      if (data_size == 0 || data_size > payload_len - 4)
        return 0;

      // Allocate memory for the DATA value
      v->value.ptr.value_data = (uint8_t *)malloc(data_size);
      if (v->value.ptr.value_data == NULL)
        return 0;

      // Copy the DATA
      memcpy(v->value.ptr.value_data, databuffer + 4, data_size);

      v->value_size = data_size;
      ret = data_size + 4; // Include the size indicator
      break;

    case VALUE_STR:
      if (payload_len < 4)
        return 0;

      // Read the size of the STR
      uint32_t str_size = ntohl(get_u_int32_t(databuffer, 0));
      if (str_size == 0 || str_size > payload_len - 4)
        return 0;

      // Allocate memory for the STR value
      v->value.ptr.value_str = (char *)malloc(str_size + 1);
      if (v->value.ptr.value_str == NULL)
        return 0;

      // Copy the STR data
      memcpy(v->value.ptr.value_str, databuffer + 4, str_size);
      v->value.ptr.value_str[str_size] = '\0'; // Null-terminate the string

      v->value_size = str_size;
      ret = str_size + 4; // Include the size indicator
      break;