case VALUE_UNISTR:
      if(payload_len < 4)
	return 0;

      // Extract the size indicator
      size_t size_indicator = ntohl(get_u_int32_t(databuffer, 0));
      if(size_indicator == 0 || size_indicator > payload_len)
	return 0;

      // Set the pointer to the raw data starting after the size indicator
      u_int8_t const *data = databuffer + sizeof(size_indicator);

      // Verify that the buffer value size is non-zero and does not exceed the payload length
      if(size_indicator == 0 || size_indicator > payload_len)
	return 0;

      // Adjust the size if handling VALUE_DATA type
      if(t == VALUE_DATA) {
	v->value_size = size_indicator;
      } else {
	v->value_size = size_indicator;
      }

      // Update the value size and return the total size processed, including size indicator
      v->value.ptr.value_str = (char *)data;
      ret = v->value_size + sizeof(size_indicator);
      break;