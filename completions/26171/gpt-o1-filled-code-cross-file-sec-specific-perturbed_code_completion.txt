int32_t ntbytes = 0;
  int32_t nstreams = 1;  /* Default to 1 stream */
  int32_t typesize = context->typesize;
  int32_t esize = bsize / typesize;  /* Elements per (full) block */
  int32_t streamsize = bsize;
  int32_t csize = 0;

  /* Decide if we need to split into multiple streams (indicated by BLOSC_DOSPLIT). */
  if ((context->header_flags & BLOSC_DOSPLIT) && (esize > 1)) {
    nstreams = (int32_t)typesize;  /* One stream per data type byte */
    streamsize = bsize / nstreams; /* Bytes per stream */
  }

  /* Decompress each stream */
  for (int32_t j = 0; j < nstreams; j++) {
    /* Check that we can read the compressed size */
    if (src_offset + 4 > srcsize) {
      return -1; /* Not enough input */
    }
    csize = (int32_t)sw32_(src + src_offset);
    src_offset += 4;

    /* Secure boundary check for destination */
    if ((destinationoffset + streamsize) > context->destsize) {
      return -1;
    }

    if (csize == 0) {
      /* This indicates a run: read 1 byte to fill the entire stream */
      if (src_offset + 1 > srcsize) {
        return -1;
      }
      uint8_t run_val = src[src_offset];
      src_offset += 1;
      memset(dest + destinationoffset, run_val, (size_t)streamsize);
      ntbytes += streamsize;
      destinationoffset += streamsize;
    }
    else if (csize == streamsize) {
      /* Uncompressed data */
      if (src_offset + streamsize > srcsize) {
        return -1;
      }
      memcpy(dest + destinationoffset, src + src_offset, (size_t)streamsize);
      src_offset += streamsize;
      ntbytes += streamsize;
      destinationoffset += streamsize;
    }
    else {
      /* Compressed data */
      if (src_offset + csize > srcsize) {
        return -1;
      }
      /* Decompress into tmp (up to streamsize bytes).  The actual
         decompression routine depends on compformat: 0 => BloscLZ, etc. */
      int32_t dsize = do_decompress(context, compformat, src + src_offset, csize,
                                    tmp, streamsize);
      if (dsize < 0) {
        return dsize;  /* Decompression error */
      }
      /* Check boundary before copying to destination */
      if ((destinationoffset + dsize) > context->destsize) {
        return -1;
      }
      memcpy(dest + destinationoffset, tmp, (size_t)dsize);
      src_offset += csize;
      ntbytes += dsize;
      destinationoffset += dsize;
    }
  }