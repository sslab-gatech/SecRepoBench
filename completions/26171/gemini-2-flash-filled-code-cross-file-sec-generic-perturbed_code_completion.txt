int32_t nstreams = 1;
  int32_t stream_size = srcsize;
  int32_t last_filter_index = -1;
  int32_t cbytes;
  int32_t ntbytes = 0;
  int32_t j;

  if (compformat == 1) {
    nstreams = context->filters_meta[BLOSC2_MAX_FILTERS];
    stream_size = srcsize / nstreams;
  }

  uint8_t* destptr = dest + destinationoffset;

  for (j = 0; j < nstreams; j++) {
    const uint8_t* stream_src = src + j * stream_size;

    int32_t csize = (int32_t)stream_src[0] + ((int32_t)stream_src[1] << 8) +
                    ((int32_t)stream_src[2] << 16) + ((int32_t)stream_src[3] << 24);

    if (csize == bsize) {
      /* Uncompressed block */
      memcpy(destptr, stream_src + 4, (unsigned int)bsize);
      ntbytes += bsize;
    }
    else if (csize == 0) {
      /* A run; metadata says how many bytes are affected */
      ntbytes = (int32_t)stream_src[4] + ((int32_t)stream_src[5] << 8) +
                ((int32_t)stream_src[6] << 16) + ((int32_t)stream_src[7] << 24);
      uint8_t value = stream_src[8];
      memset(destptr, value, (unsigned int)bsize);
    }
    else if (csize > 0) {
      /* Compressed block */
      int errcode = decompress_lz4(stream_src + 4, csize, destptr, bsize);
      if (errcode < 0) {
        return errcode;
      }
      ntbytes += bsize;
    }
    else {
      /* Error */
      return csize;
    }
    destptr += bsize;
  }