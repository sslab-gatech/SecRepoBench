int32_t j, cbytes;
  int32_t ntbytes = 0;
  int32_t nstreams = context->typesize;
  int32_t last_filter_index = -1;

  if (filters[0] != BLOSC_NOFILTER) {
    for (int i = 0; i < BLOSC2_MAX_FILTERS; i++) {
      if (filters[i] != BLOSC_NOFILTER) {
        last_filter_index = i;
      }
    }
  }

  for (j = 0; j < nstreams; j++) {
    int32_t bsize2 = bsize / nstreams;
    int32_t leftover2 = (j == nstreams - 1) ? bsize % nstreams : 0;
    int32_t src_offset2 = src_offset + j * bsize2;
    int32_t dest_offset2 = destinationoffset + j * bsize2;

    if (compformat == BLOSC_BLOSCLZ_FORMAT) {
      cbytes = blosclz_decompress(src + src_offset2, srcsize - src_offset2,
                                  dest + dest_offset2, bsize2 + leftover2);
    }
    else if (compformat == BLOSC_LZ4_FORMAT) {
      cbytes = LZ4_decompress_safe((const char*)(src + src_offset2),
                                   (char*)(dest + dest_offset2),
                                   srcsize - src_offset2, bsize2 + leftover2);
    }
    else if (compformat == BLOSC_LZ4HC_FORMAT) {
      cbytes = LZ4_decompress_safe((const char*)(src + src_offset2),
                                   (char*)(dest + dest_offset2),
                                   srcsize - src_offset2, bsize2 + leftover2);
    }
    else if (compformat == BLOSC_ZLIB_FORMAT) {
      cbytes = zlib_decompress(src + src_offset2, srcsize - src_offset2,
                               dest + dest_offset2, bsize2 + leftover2);
    }
    else if (compformat == BLOSC_ZSTD_FORMAT) {
      cbytes = zstd_decompress(src + src_offset2, srcsize - src_offset2,
                               dest + dest_offset2, bsize2 + leftover2);
    }
    else {
      return -1;  // Unsupported compression format
    }

    if (cbytes < 0) {
      return cbytes;  // Error during decompression
    }

    ntbytes += cbytes;
  }