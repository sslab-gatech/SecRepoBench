int32_t ntbytes = 0;              /* the number of uncompressed bytes */
  int32_t nstreams;                  /* number of streams */
  int32_t neblock, nchunk;           /* number of elements per block */
  int32_t j, k;
  int32_t typesize = context->typesize;
  int last_filter_index = last_filter(context->filters, 'd');
  const char* compname;

  if (compformat == BLOSC_BLOSCLZ_FORMAT) {
    context->dest[1] = BLOSC_BLOSCLZ_VERSION_FORMAT;
  }
#if defined(HAVE_LZ4)
  else if (compformat == BLOSC_LZ4_FORMAT) {
    context->dest[1] = BLOSC_LZ4_VERSION_FORMAT;
  }
  else if (compformat == BLOSC_LZ4HC_FORMAT) {
    context->dest[1] = BLOSC_LZ4HC_VERSION_FORMAT;
  }
#endif /* HAVE_LZ4 */
#if defined(HAVE_LIZARD)
  else if (compformat == BLOSC_LIZARD_FORMAT) {
    context->dest[1] = BLOSC_LIZARD_VERSION_FORMAT;
  }
#endif /* HAVE_LIZARD */
#if defined(HAVE_SNAPPY)
  else if (compformat == BLOSC_SNAPPY_FORMAT) {
    context->dest[1] = BLOSC_SNAPPY_VERSION_FORMAT;
  }
#endif /* HAVE_SNAPPY */
#if defined(HAVE_ZLIB)
  else if (compformat == BLOSC_ZLIB_FORMAT) {
    context->dest[1] = BLOSC_ZLIB_VERSION_FORMAT;
  }
#endif /* HAVE_ZLIB */
#if defined(HAVE_ZSTD)
  else if (compformat == BLOSC_ZSTD_FORMAT) {
    context->dest[1] = BLOSC_ZSTD_VERSION_FORMAT;
  }
#endif /* HAVE_ZSTD */
  else {
    compname = clibcode_to_clibname(compformat);
    fprintf(stderr,
        "Blosc has not been compiled with '%s' ", compname);
    fprintf(stderr, "compression support.  Please use one having it.");
    return -5;    /* signals no compression support */
  }

  nstreams = context->typesize;
  neblock = bsize / nstreams;
  nchunk = neblock * nstreams;
  uint8_t* _tmp = tmp;

  for (j = 0; j < nstreams; j++) {
    int32_t bcode = sw32_(src + src_offset);
    src += sizeof(int32_t);
    src_offset += sizeof(int32_t);
    srcsize -= sizeof(int32_t);

    if (bcode < 0) {
      // A run.  Write the repeated byte as many times as needed.
      int32_t value = -bcode;
      if (value >= 0 && value <= 255) {
        memset(tmp + ntbytes + j * neblock, value, (unsigned int)neblock);
      }
      else {
        return -1;
      }
    }
    else if (bcode == neblock) {
      // Uncompressed data.  Copy it to tmp.
      if (srcsize < neblock) {
        /* Not enough input to copy data */
        return -1;
      }
      memcpy(_tmp + ntbytes + j * neblock, src, (unsigned int)neblock);
      src += neblock;
      src_offset += neblock;
      srcsize -= neblock;
    }
    else {
      // Compressed data.  Decompress it to tmp.
      if (srcsize < bcode) {
        /* Not enough input to decompress data */
        return -1;
      }
      if (context->compcode == BLOSC_BLOSCLZ) {
        int32_t dbytes = blosclz_decompress(src, bcode,
                                            _tmp + ntbytes + j * neblock, neblock);
        if (dbytes <= 0) {
          return -1;
        }
      }
  #if defined(HAVE_LZ4)
      else if ((context->compcode == BLOSC_LZ4) ||
               (context->compcode == BLOSC_LZ4HC)) {
        int32_t dbytes = lz4_wrap_decompress(
            (char*)src, (size_t)bcode, (char*)_tmp + ntbytes + j * neblock,
            (size_t)neblock);
        if (dbytes <= 0) {
          return -1;
        }
      }
  #endif /* HAVE_LZ4 */
  #if defined(HAVE_LIZARD)
      else if (context->compcode == BLOSC_LIZARD) {
        int32_t dbytes = lizard_wrap_decompress(
            (char*)src, (size_t)bcode, (char*)_tmp + ntbytes + j * neblock,
            (size_t)neblock);
        if (dbytes <= 0) {
          return -1;
        }
      }
  #endif /* HAVE_LIZARD */
  #if defined(HAVE_SNAPPY)
      else if (context->compcode == BLOSC_SNAPPY) {
        int32_t dbytes = snappy_wrap_decompress(
            (char*)src, (size_t)bcode, (char*)_tmp + ntbytes + j * neblock,
            (size_t)neblock);
        if (dbytes <= 0) {
          return -1;
        }
      }
  #endif /* HAVE_SNAPPY */
  #if defined(HAVE_ZLIB)
      else if (context->compcode == BLOSC_ZLIB) {
        int32_t dbytes = zlib_wrap_decompress(
            (char*)src, (size_t)bcode, (char*)_tmp + ntbytes + j * neblock,
            (size_t)neblock);
        if (dbytes <= 0) {
          return -1;
        }
      }
  #endif /* HAVE_ZLIB */
  #if defined(HAVE_ZSTD)
      else if (context->compcode == BLOSC_ZSTD) {
        int32_t dbytes = zstd_wrap_decompress(thread_context,
            (char*)src, (size_t)bcode, (char*)_tmp + ntbytes + j * neblock,
            (size_t)neblock);
        if (dbytes <= 0) {
          return -1;
        }
      }
  #endif /* HAVE_ZSTD */
      else {
        compname = clibcode_to_clibname(context->compcode);
        fprintf(stderr, "Blosc has not been compiled with '%s' ", compname);
        fprintf(stderr, "compression support.  Please use one having it.");
        return -5;    /* signals no compression support */
      }
      src += bcode;
      src_offset += bcode;
      srcsize -= bcode;
    }
  }
  ntbytes += nchunk;