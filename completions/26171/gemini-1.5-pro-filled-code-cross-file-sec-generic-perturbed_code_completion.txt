uint32_t nstreams = context->nstreams;
  int32_t nbytes, bsize2, leftoverblock2;
  int32_t cbytes, ntbytes = 0;
  int32_t proc, last_filter_index = -1;
  int32_t stream_offset = 0;

  proc = context->blocksize / context->typesize / nstreams;

  /* Check whether we need to apply filters */
  if (context->filter_flags) {
    last_filter_index = check_filters(filters, BLOSC2_MAX_FILTERS);
    if (last_filter_index < 0) {
      return -1;
    }
  }

  for (int j = 0; j < nstreams; j++) {
    bsize2 = bsize;
    leftoverblock2 = leftoverblock;
    if (nstreams > 1 && j < (nstreams - 1)) {
      bsize2 = proc * context->typesize;
      leftoverblock2 = 0;
    } else if (nstreams > 1 && j == (nstreams - 1)) {
      bsize2 = bsize - j * proc * context->typesize;
    }

    /* Get the compressed size for current stream */
    if (compformat == BLOSC_BLOSCLZ_FORMAT) {
      cbytes = (int32_t)sw32_(src + src_offset + 4 * j);
    } else {
      cbytes = (int32_t)sw32_(src + src_offset + 8 * j);
    }

    nbytes = bsize2;

    if (cbytes == 0) {
      /* Case of a run. */
      if (srcsize < src_offset + 4 + 1) {
        /* Not enough input to read run's header */
        return -1;
      }
      uint8_t val = src[src_offset + 4 + 8 * j];
      memset(dest + destinationoffset + stream_offset, val, (unsigned int)nbytes);
    } else if (cbytes < 0) {
      /* Case of uncompressed data. */
      int32_t sbytes = -cbytes;
      if (srcsize < src_offset + sbytes) {
        /* Not enough input to copy uncompressed data */
        return -1;
      }
      memcpy(dest + destinationoffset + stream_offset, src + src_offset + 8 * nstreams + 4, (unsigned int)sbytes);
    } else {
      /* Case of compressed data. */
      int32_t sbytes = cbytes;
      if (srcsize < src_offset + sbytes + 8 * nstreams + 4) {
        /* Not enough input to decompress data */
        return -1;
      }
      int decompressed_bytes = 0;
      if (compformat == BLOSC_BLOSCLZ_FORMAT) {
        decompressed_bytes = blosclz_decompress(src + src_offset + 8 * nstreams + 4, sbytes,
                                               dest + destinationoffset + stream_offset, nbytes);
      } else if (compformat == BLOSC_LZ4_FORMAT) {
        decompressed_bytes = LZ4_decompress_safe((char*)(src + src_offset + 8 * nstreams + 4),
                                                (char*)(dest + destinationoffset + stream_offset),
                                                sbytes, nbytes);
      } else if (compformat == BLOSC_ZSTD_FORMAT) {
        decompressed_bytes = ZSTD_decompress(dest + destinationoffset + stream_offset, nbytes,
                                            src + src_offset + 8 * nstreams + 4, sbytes);
      }
      if (decompressed_bytes != nbytes) {
        return -2;
      }
    }

    ntbytes += nbytes;
    stream_offset += nbytes;
  }