int32_t j, cbytes, nstreams, ntbytes = 0;
  int32_t compbytes, uncompressed_bytes;
  const uint8_t* src_ptr = src + src_offset;
  int32_t remaining_srcsize = srcsize - src_offset;

  nstreams = context->nstreams;
  uncompressed_bytes = bsize / nstreams;

  for (j = 0; j < nstreams; j++) {
    if (remaining_srcsize < sizeof(int32_t)) {
      return -1;  // Not enough data to read compressed size
    }
    compbytes = sw32_(src_ptr);
    src_ptr += sizeof(int32_t);
    remaining_srcsize -= sizeof(int32_t);

    if (compbytes == 0) {
      // Run of zeros
      memset(dest + destinationoffset + j * uncompressed_bytes, 0, uncompressed_bytes);
      cbytes = uncompressed_bytes;
    }
    else if (compbytes < 0) {
      // Uncompressed data
      cbytes = -compbytes;
      if (remaining_srcsize < cbytes) {
        return -1;  // Not enough data to copy uncompressed bytes
      }
      memcpy(dest + destinationoffset + j * uncompressed_bytes, src_ptr, cbytes);
      src_ptr += cbytes;
      remaining_srcsize -= cbytes;
    }
    else {
      // Compressed data
      if (remaining_srcsize < compbytes) {
        return -1;  // Not enough data to read compressed bytes
      }
      cbytes = blosc_d(context, uncompressed_bytes, leftoverblock, src_ptr, compbytes, 0,
                       dest, destinationoffset + j * uncompressed_bytes, tmp, tmp2);
      if (cbytes < 0) {
        return cbytes;  // Error in decompression
      }
      src_ptr += compbytes;
      remaining_srcsize -= compbytes;
    }

    ntbytes += cbytes;
  }