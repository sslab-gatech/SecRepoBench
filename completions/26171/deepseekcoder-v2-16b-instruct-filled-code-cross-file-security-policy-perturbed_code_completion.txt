// Calculate the number of streams and elements per block based on the context
  // and determine whether to split the compressed data into multiple streams.
  // Prepare destination buffer depending on whether filters are applied.
  // Iterate over each stream and for each stream, read the compressed size and
  // decompress the data using the appropriate decompression format.
  // Handle cases of runs, uncompressed data, or compressed data based on the
  // compressed byte size.
  // Accumulate the total number of compressed and uncompressed bytes for the block.
  // If successful, the number of uncompressed bytes is returned; otherwise,
  // appropriate error codes are returned to indicate failure.

  int32_t nstreams = context->nstreams;
  int32_t elements_per_block = context->elements_per_block;
  bool split_streams = (context->header_flags & BLOSC_SPLIT_STREAMS) != 0;

  if (split_streams) {
    nstreams = 1; // For simplicity, assume only one stream if split_streams is true
  }

  int32_t total_uncompressed_bytes = 0;
  int32_t total_compressed_bytes = 0;

  for (int32_t i = 0; i < nstreams; i++) {
    int32_t compressed_size;
    if (split_streams) {
      compressed_size = sw32_(src + src_offset + i * elements_per_block * typesize);
    } else {
      compressed_size = sw32_(src + src_offset + i * elements_per_block * typesize);
    }

    if (compressed_size > srcsize - src_offset) {
      return -1; // Not enough data to read compressed size
    }

    int32_t uncompressed_size;
    if (context->do_compress) {
      uncompressed_size = blosc_d(thread_context, bsize, leftoverblock,
                                  src + src_offset + i * elements_per_block * typesize,
                                  compressed_size, 0,
                                  dest + destinationoffset + i * elements_per_block * typesize,
                                  destinationoffset, tmp, tmp2);
    } else {
      uncompressed_size = blosc_d(thread_context, bsize, leftoverblock,
                                  src + src_offset + i * elements_per_block * typesize,
                                  compressed_size, 0,
                                  dest + destinationoffset + i * elements_per_block * typesize,
                                  destinationoffset, tmp, tmp2);
    }

    if (uncompressed_size < 0) {
      return uncompressed_size; // Error in decompression
    }

    total_uncompressed_bytes += uncompressed_size;
    total_compressed_bytes += compressed_size;
  }

  return total_uncompressed_bytes;