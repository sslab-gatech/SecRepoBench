int32_t ntbytes = 0;  // Total number of uncompressed bytes
  int32_t cbytes;       // Compressed bytes for the current block
  int32_t nstreams;     // Number of streams in the block
  int32_t leftoverblock = 0;  // Whether this is the leftover block
  int32_t bsize = context->blocksize;  // Block size
  int32_t last_filter_index = -1;  // Index of the last filter applied
  int32_t stream_offset = 0;  // Offset for the current stream
  uint8_t* src_ptr = (uint8_t*)src + src_offset;  // Pointer to the source data
  uint8_t* dest_ptr = dest + destinationoffset;  // Pointer to the destination buffer

  // Determine if this is the leftover block
  if (leftoverblock) {
    bsize = context->leftover;
  }

  // Calculate the number of streams
  nstreams = (bsize + context->typesize - 1) / context->typesize;

  for (int j = 0; j < nstreams; j++) {
    // Read the compressed size of the current stream
    if (src_ptr + sizeof(int32_t) > src + srcsize) {
      return -1;  // Error: insufficient input
    }
    cbytes = sw32_(src_ptr);
    src_ptr += sizeof(int32_t);

    if (cbytes == 0) {
      // Handle uncompressed data
      if (src_ptr + bsize > src + srcsize) {
        return -1;  // Error: insufficient input
      }
      memcpy(dest_ptr, src_ptr, bsize);
      src_ptr += bsize;
      ntbytes += bsize;
    } else if (cbytes < 0) {
      // Handle runs
      if (src_ptr + 1 > src + srcsize) {
        return -1;  // Error: insufficient input
      }
      memset(dest_ptr, *src_ptr, bsize);
      src_ptr += 1;
      ntbytes += bsize;
    } else {
      // Handle compressed data
      if (src_ptr + cbytes > src + srcsize) {
        return -1;  // Error: insufficient input
      }
      int decompressed = decompress_format(compformat, src_ptr, cbytes, tmp, bsize);
      if (decompressed < 0) {
        return decompressed;  // Error during decompression
      }
      memcpy(dest_ptr, tmp, bsize);
      src_ptr += cbytes;
      ntbytes += bsize;
    }

    dest_ptr += bsize;
    stream_offset += bsize;
  }