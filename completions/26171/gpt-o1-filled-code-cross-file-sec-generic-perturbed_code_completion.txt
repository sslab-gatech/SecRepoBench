int32_t ntbytes = 0;
  int last_filter_index = -1;
  int32_t typesize = context->typesize;
  int32_t nstreams = 1;  /* Default: a single stream */
  int32_t blocksize = bsize;
  uint8_t* outptr;
  int32_t csize;

  /* Determine if filters are present and find the last filter index */
  for (int i = 0; i < BLOSC2_MAX_FILTERS; i++) {
    if (filters[i] != BLOSC_NOFILTER) {
      last_filter_index = i;
    }
  }

  /* Decide how many sub-streams to split into (if any).
   * For simplicity, we assume a single stream here, but more complex logic
   * (e.g., based on splitmode or typesize) can be added as needed.
   */

  /* Decompress into tmp if filters are used, otherwise directly to dest. */
  outptr = (last_filter_index >= 0) ? tmp : (dest + destinationoffset);

  /* Read the compressed size for the stream. */
  if (src_offset + 4 > srcsize) {
    return -1; /* Not enough room to read csize */
  }
  csize = (int32_t)sw32_(src + src_offset);
  src_offset += 4;

  /* Handle runs, uncompressed data, or compressed data. */
  if (csize < 0) {
    /* Corrupted csize */
    return -1;
  }
  else if (csize == 0) {
    /* Potential run: read run byte and fill outptr */
    if (src_offset >= srcsize) {
      return -1;
    }
    uint8_t run_byte = src[src_offset++];
    memset(outptr, run_byte, (size_t)blocksize);
    ntbytes = blocksize;
  }
  else if (csize == blocksize) {
    /* Uncompressed data block */
    if (src_offset + blocksize > srcsize) {
      return -1; /* Not enough input */
    }
    memcpy(outptr, src + src_offset, (size_t)blocksize);
    src_offset += blocksize;
    ntbytes = blocksize;
  }
  else {
    /* Compressed data block */
    if (src_offset + csize > srcsize) {
      return -1; /* Not enough input */
    }
    /* Switch on compformat to choose decompression routine. */
    switch (compformat) {
      case BLOSC_BLOSCLZ_FORMAT: {
        int dbytes = blosclz_decompress(src + src_offset, csize, outptr, blocksize);
        if (dbytes < 0) {
          return -1;
        }
        ntbytes = dbytes;
        break;
      }
      case BLOSC_LZ4_FORMAT: {
        int dbytes = lz4_decompress(src + src_offset, csize, outptr, blocksize);
        if (dbytes < 0) {
          return -1;
        }
        ntbytes = dbytes;
        break;
      }
      case BLOSC_ZSTD_FORMAT: {
        size_t dbytes = zstd_decompress(outptr, (size_t)blocksize,
                                        src + src_offset, (size_t)csize);
        if (dbytes == 0 || dbytes > (size_t)blocksize) {
          return -1;
        }
        ntbytes = (int32_t)dbytes;
        break;
      }
      default: {
        /* Unsupported compformat */
        return -1;
      }
    }
    src_offset += csize;
  }