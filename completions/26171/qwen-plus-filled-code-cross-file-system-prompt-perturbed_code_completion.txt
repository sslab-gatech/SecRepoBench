int32_t ntbytes = 0;
int32_t cbytes = 0;
int32_t j, nstreams;

nstreams = context->nstreams;
for (j = 0; j < nstreams; j++) {
  int32_t stream_size = sw32_(src + src_offset);
  if (stream_size == BLOSC_RUN) {
    // Handle run case
    bool is_run = get_run(src + src_offset + sizeof(int32_t), src + srcsize);
    if (!is_run) {
      return -1;  // Error in run detection
    }
    cbytes = bsize;
    memcpy(dest + destinationoffset, src + src_offset + sizeof(int32_t), (unsigned int)cbytes);
  }
  else if (stream_size == BLOSC_UNCOMPRESSED) {
    // Handle uncompressed data
    cbytes = bsize;
    memcpy(dest + destinationoffset, src + src_offset + sizeof(int32_t), (unsigned int)cbytes);
  }
  else {
    // Handle compressed data
    uint8_t* comp_data = (uint8_t*)(src + src_offset + sizeof(int32_t));
    switch (compformat) {
      case BLOSC_BLOSCLZ:
        cbytes = decompress_blosclz(comp_data, stream_size, dest + destinationoffset, bsize);
        break;
      case BLOSC_LZ4:
        cbytes = decompress_lz4(comp_data, stream_size, dest + destinationoffset, bsize);
        break;
      case BLOSC_LZ4HC:
        cbytes = decompress_lz4hc(comp_data, stream_size, dest + destinationoffset, bsize);
        break;
      case BLOSC_ZLIB:
        cbytes = decompress_zlib(comp_data, stream_size, dest + destinationoffset, bsize);
        break;
      case BLOSC_ZSTD:
        cbytes = decompress_zstd(comp_data, stream_size, dest + destinationoffset, bsize);
        break;
      default:
        return -1;  // Unsupported compression format
    }
    if (cbytes < 0) {
      return cbytes;  // Decompression error
    }
  }

  // Update offsets and accumulate bytes
  src_offset += sizeof(int32_t) + stream_size;
  destinationoffset += cbytes;
  ntbytes += cbytes;
}