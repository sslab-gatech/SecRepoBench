int32_t nstreams = 1;
if (compformat == 0) {
  nstreams = (bsize + BLOSC2_MAX_TYPESIZE - 1) / BLOSC2_MAX_TYPESIZE;
}
int32_t ntbytes = 0;
int32_t cbytes = 0;
int32_t j;
uint8_t* ip = src + src_offset;
uint8_t* ip_bound = ip + srcsize;
uint8_t* op = dest + destinationoffset;
uint8_t* op_bound = op + bsize;
int last_filter_index = -1;
for (j = 0; j < nstreams; j++) {
  int32_t streamsize = bsize / nstreams;
  if (j == nstreams - 1) {
    streamsize = bsize - (nstreams - 1) * (bsize / nstreams);
  }
  if (streamsize == 0) {
    break;
  }
  if (ip + 1 > ip_bound) {
    return -1;
  }
  cbytes = *ip++;
  if (cbytes == 0) {
    /* Runs */
    if (ip + 1 > ip_bound) {
      return -1;
    }
    uint8_t x = *ip++;
    int32_t nruns = streamsize / BLOSC2_MAX_TYPESIZE;
    if (nruns * BLOSC2_MAX_TYPESIZE < streamsize) {
      nruns++;
    }
    for (int i = 0; i < nruns; i++) {
      memset(op, x, BLOSC2_MAX_TYPESIZE);
      op += BLOSC2_MAX_TYPESIZE;
    }
  }
  else if (cbytes == 1) {
    /* Uncompressed data */
    if (ip + streamsize > ip_bound) {
      return -1;
    }
    memcpy(op, ip, streamsize);
    ip += streamsize;
    op += streamsize;
  }
  else {
    /* Compressed data */
    if (ip + cbytes > ip_bound) {
      return -1;
    }
    if (filters[0] == BLOSC_NOFILTER) {
      memcpy(op, ip, cbytes);
    }
    else {
      last_filter_index = 0;
      int errcode = pipeline_d(context, streamsize, op, 0, ip, tmp, tmp2, last_filter_index);
      if (errcode < 0) {
        return errcode;
      }
    }
    ip += cbytes;
    op += streamsize;
  }
  ntbytes += streamsize;
}