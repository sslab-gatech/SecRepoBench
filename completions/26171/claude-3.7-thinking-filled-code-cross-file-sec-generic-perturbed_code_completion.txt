int32_t typesize = context->typesize;
int32_t j, neblock, ntbytes = 0;
const int32_t* bstarts;
uint8_t* _src;
uint8_t* _dest;
int32_t compressedsize;
int32_t nstreams;
int last_filter_index = -1;

/* Get the number of streams */
if (context->header_flags & BLOSC_DOSHUFFLE) {
  /* Byte shuffle is active */
  nstreams = typesize;
} 
else {
  /* Byte shuffle is not active */
  nstreams = 1;
}

/* Check if filters are needed */
if (context->filters[0] != BLOSC_NOFILTER || context->filters[1] != BLOSC_NOFILTER) {
  _dest = tmp;
  for (j = 0; j < BLOSC2_MAX_FILTERS; j++) {
    if (context->filters[j] == BLOSC_NOFILTER) {
      break;
    }
    last_filter_index = j;
  }
} else {
  _dest = dest + destinationoffset;
}

/* Calculate the number of elements in a block */
neblock = bsize / typesize;

/* Pointer to the compressed streams */
_src = (uint8_t*)(src) + src_offset;

/* Pointer to block starts in source */
bstarts = (const int32_t*)((uint8_t *)(src) + context->bstarts);

for (j = 0; j < nstreams; j++) {
  /* Handle special cases */
  if ((j == 0) && (compformat == BLOSC_BLOSCLZ_FORMAT)) {
    /* BLOSC_BLOSCLZ_FORMAT has standard preamble */
    if (srcsize < 4) {
      return -1;  /* Not enough input */
    }
    if (*(int32_t*)_src == 0) {
      /* This is an uncompressed block */
      if (srcsize < 4 + bsize) {
        return -1;  /* Not enough input to decompress */
      }
      memcpy(_dest, _src + 4, (unsigned int)bsize);
      ntbytes += bsize;
      _src += 4 + bsize;
      continue;
    }
    if ((*(int32_t*)_src & 0xffff0000) == BLOSC2_EXTENDED_HEADER_MASK) {
      /* The compressor added extended header */
      int32_t header_len = (*((int32_t*)_src) & 0xffff);
      if (srcsize < header_len) {
        return -1;  /* Not enough input to decompress */
      }
      _src += header_len;
    }
  }

  /* Get compressed size */
  if ((uint8_t*)(bstarts + j) >= src + srcsize) {
    return -1;  /* Invalid bstarts pointer */
  }
  compressedsize = sw32_(bstarts + j);
  if (compressedsize == 0) {
    // Last block not initialized yet
    if (j == 0) {
      return 0;
    }
    continue;
  }
  else if (compressedsize == BLOSC_MAX_OVERHEAD) {
    /* This is a memcpyed sub-block */
    if (srcsize < bsize) {
      return -1;  /* Not enough input to decompress */
    }
    memcpy(_dest, _src, (unsigned int)bsize);
    _src += bsize;
    ntbytes += bsize;
  }
  else if (compressedsize < 0) {
    /* Runs */
    int val = 0;
    if (j == 0) {
      if (srcsize < 1) {
        return -1;  /* Not enough input to decompress */
      }
      val = _src[0];
      _src += 1;
    }
    memset(_dest, val, (unsigned int)bsize);
    ntbytes += bsize;
  }
  else {
    /* Regular decompression */
    int compsize = compressedsize;
    if (j > 0) {
      if ((uint8_t*)(bstarts + j - 1) >= src + srcsize) {
        return -1;  /* Invalid bstarts pointer */
      }
      compsize = compressedsize - sw32_(bstarts + j - 1);
    }
    
    /* Check bounds */
    if (compsize < 0 || compsize > srcsize) {
      return -1;  /* Invalid compressed size */
    }
    if (_src + compsize > src + srcsize) {
      return -1;  /* Compressed data goes beyond input buffer */
    }

    int32_t cbytes;
    switch (compformat) {
      case BLOSC_BLOSCLZ_FORMAT:
        cbytes = blosclz_decompress(_src, compsize, _dest, (unsigned int)bsize);
        break;
#if defined(HAVE_LZ4)
      case BLOSC_LZ4_FORMAT:
        cbytes = lz4_decompress(_src, compsize, _dest, (unsigned int)bsize);
        break;
#endif /* HAVE_LZ4 */
#if defined(HAVE_SNAPPY)
      case BLOSC_SNAPPY_FORMAT:
        cbytes = snappy_decompress(_src, compsize, _dest, (unsigned int)bsize);
        break;
#endif /* HAVE_SNAPPY */
#if defined(HAVE_ZLIB)
      case BLOSC_ZLIB_FORMAT:
        cbytes = zlib_decompress(_src, compsize, _dest, (unsigned int)bsize);
        break;
#endif /* HAVE_ZLIB */
#if defined(HAVE_ZSTD)
      case BLOSC_ZSTD_FORMAT:
        cbytes = zstd_decompress(thread_context, _src, compsize, _dest,
                                 (unsigned int)bsize);
        break;
#endif /* HAVE_ZSTD */
      default:
        return -5;  /* signals that we don't support this format */
    }

    if (cbytes < 0) {
      return cbytes;  /* Error during decompression */
    }
    if (cbytes != bsize) {
      return -2;  /* Decompressed size doesn't match expected size */
    }
    _src += compsize;
    ntbytes += bsize;
  }

  /* Advance pointers for next stream */
  if (j + 1 < nstreams) {
    /* For regular streams, advance destination */
    _dest += neblock;
  }
}