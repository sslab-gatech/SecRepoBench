int ntbytes = 0;
/* For now, assume one stream per block. In future, nstreams can be derived from the context. */
int nstreams = 1;
int offset = src_offset;
int32_t csize;

for (int j = 0; j < nstreams; j++) {
  /* Ensure there is enough data to read the stream header (compressed size) */
  if ((offset + (int)sizeof(int32_t)) > srcsize) {
    return -1;  /* Error: insufficient input */
  }
  csize = sw32_(src + offset);
  offset += sizeof(int32_t);

  if (csize == 0) {
    /* Runâ€length encoding: next byte holds the repeated value */
    if (offset >= srcsize) {
      return -1;  /* Error: no byte available for run value */
    }
    uint8_t run_value = src[offset++];
    memset(dest + destinationoffset + ntbytes, run_value, bsize);
    ntbytes += bsize;
  }
  else if (csize == bsize) {
    /* Uncompressed block */
    if ((offset + bsize) > srcsize) {
      return -1;  /* Error: not enough input bytes for uncompressed block */
    }
    memcpy(dest + destinationoffset + ntbytes, src + offset, (unsigned int)bsize);
    offset += bsize;
    ntbytes += bsize;
  }
  else {
    /* Compressed block */
    int decompressed;
    switch (compformat) {
      case BLOSC_BLOSCLZ:
        decompressed = blosc2_decompress_blosclz(src + offset, csize,
                                                  dest + destinationoffset + ntbytes, bsize);
        break;
      case BLOSC_LZ4:
        decompressed = blosc2_decompress_lz4(src + offset, csize,
                                             dest + destinationoffset + ntbytes, bsize);
        break;
      case BLOSC_ZLIB:
        decompressed = blosc2_decompress_zlib(src + offset, csize,
                                              dest + destinationoffset + ntbytes, bsize);
        break;
      default:
        return -1;  /* Error: unknown compression format */
    }
    if (decompressed != bsize) {
      return -1;  /* Error: decompressed size mismatch */
    }
    offset += csize;
    ntbytes += bsize;
  }
}

int last_filter_index = -1;
for (int i = 0; i < BLOSC2_MAX_FILTERS; i++) {
  if (filters[i] != BLOSC_NOFILTER) {
    last_filter_index = i;
  }
}