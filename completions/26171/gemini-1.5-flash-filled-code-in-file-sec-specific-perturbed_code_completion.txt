int32_t j, neblock, nstreams;
  int32_t dbytes;                   /* number of decompressed bytes in split */
  int32_t dtbytes = 0;              /* number of decompressed bytes in block */
  int32_t last_filter_index = last_filter(filters, 'd');
  int64_t maxout;
  bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;

  /* The number of compressed data streams for this block */
  if (!leftoverblock && !memcpyed) {
    nstreams = (int32_t)typesize;
  }
  else {
    nstreams = 1;
  }
  neblock = bsize / nstreams;
  for (j = 0; j < nstreams; j++) {
    int32_t cbytes;
    if (!memcpyed) {
      dest += sizeof(int32_t);
      src += sizeof(int32_t);
      src_offset += sizeof(int32_t);
      cbytes = sw32_(src - sizeof(int32_t));
    }
    else {
      cbytes = neblock;
    }

    // See if we have a run here
    if (cbytes < 0) {
      // A run.  Decode the repeated byte.
      int32_t value = -cbytes;
      memset(dest, (uint8_t)value, (unsigned int)neblock);
      continue;
    }

    maxout = neblock;
    if (cbytes == 0 || cbytes == neblock) {
      /* The compressor has been unable to compress data at all. */
      memcpy(dest, src, (unsigned int)neblock);
      dbytes = neblock;
    }
    else {
      if (context->compcode == BLOSC_BLOSCLZ) {
        dbytes = blosclz_decompress(src, (int)cbytes, dest, (int)maxout);
      }
#if defined(HAVE_LZ4)
      else if (context->compcode == BLOSC_LZ4) {
        dbytes = lz4_wrap_decompress((char*)src, (size_t)cbytes,
                                     (char*)dest, (size_t)maxout);
      }
      else if (context->compcode == BLOSC_LZ4HC) {
        dbytes = lz4_wrap_decompress((char*)src, (size_t)cbytes,
                                     (char*)dest, (size_t)maxout);
      }
#endif /* HAVE_LZ4 */
#if defined(HAVE_LIZARD)
      else if (context->compcode == BLOSC_LIZARD) {
        dbytes = lizard_wrap_decompress((char*)src, (size_t)cbytes,
                                        (char*)dest, (size_t)maxout);
      }
#endif /* HAVE_LIZARD */
#if defined(HAVE_SNAPPY)
      else if (context->compcode == BLOSC_SNAPPY) {
        dbytes = snappy_wrap_decompress((char*)src, (size_t)cbytes,
                                        (char*)dest, (size_t)maxout);
      }
#endif /* HAVE_SNAPPY */
#if defined(HAVE_ZLIB)
      else if (context->compcode == BLOSC_ZLIB) {
        dbytes = zlib_wrap_decompress((char*)src, (size_t)cbytes,
                                      (char*)dest, (size_t)maxout);
      }
#endif /* HAVE_ZLIB */
#if defined(HAVE_ZSTD)
      else if (context->compcode == BLOSC_ZSTD) {
        dbytes = zstd_wrap_decompress(thread_context,
                                      (char*)src, (size_t)cbytes,
                                      (char*)dest, (size_t)maxout);
      }
#endif /* HAVE_ZSTD */
      else {
        const char* compname;
        blosc_compcode_to_compname(context->compcode, &compname);
        fprintf(stderr, "Blosc has not been compiled with '%s' ", compname);
        fprintf(stderr, "decompression support.  Please use one having it.");
        return -5;    /* signals no compression support */
      }
      if (dbytes <= 0) {
        /* Decompression failure */
        return -2;
      }
    }
    dest += dbytes;
    src += cbytes;
    src_offset += cbytes;
    dtbytes += dbytes;
  }
  int32_t ntbytes = dtbytes;