int32_t nstreams = (context->typesize > 1) ? context->blocksize / context->typesize : 1;
int32_t j, neblock;
int32_t cbytes = 0;
int32_t ntbytes = 0;
int last_filter_index = -1;
uint8_t* dest_ptr = (filters[0] != BLOSC_NOFILTER) ? tmp2 : dest + destinationoffset;

for (j = 0; j < nstreams; j++) {
  neblock = bsize;
  if (j == nstreams - 1 && leftoverblock) {
    neblock = leftoverblock;
  }
  int32_t csiz = sw32_(src + src_offset);
  src_offset += sizeof(int32_t);
  if (csiz == 0) {
    // Uncompressed data
    memcpy(dest_ptr + j * context->typesize, src + src_offset, (unsigned int)neblock);
    src_offset += neblock;
  } else if (csiz == BLOSC_MAX_OVERHEAD) {
    // Run of zeros
    memset(dest_ptr + j * context->typesize, 0, (unsigned int)neblock);
  } else if (csiz == (int32_t)neblock) {
    // Run of bytes
    memset(dest_ptr + j * context->typesize, src[src_offset], (unsigned int)neblock);
    src_offset += 1;
  } else {
    // Decompression required
    int32_t decomp_size = blosc_decompress_unsafe(src + src_offset, csiz,
                                                  dest_ptr + j * context->typesize,
                                                  neblock, compformat);
    if (decomp_size < 0) {
      return decomp_size;
    }
    src_offset += csiz;
  }
  cbytes += csiz;
  ntbytes += neblock;
}

if (filters[0] != BLOSC_NOFILTER) {
  last_filter_index = 0;
  for (int i = 1; i < BLOSC_MAX_FILTERS; i++) {
    if (filters[i] == BLOSC_NOFILTER) {
      break;
    }
    last_filter_index = i;
  }
}