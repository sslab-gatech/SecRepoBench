int last_filter_index = context->filters_meta[0];
for (int i = 0; i < last_filter_index; i++) {
  switch (filters[i]) {
    case BLOSC_SHUFFLE:
      unshuffle(typesize, bsize, src, dest + destinationoffset);
      break;
    case BLOSC_BITSHUFFLE:
      bitunshuffle(typesize, bsize, src, dest + destinationoffset, tmp, context->src[0]);
      break;
    case BLOSC_DELTA:
      if (context->nthreads == 1) {
        delta_decoder(dest, destinationoffset, bsize, typesize, dest + destinationoffset);
      } else {
        pthread_mutex_lock(&context->delta_mutex);
        if (context->dref_not_init) {
          if (destinationoffset != 0) {
            pthread_cond_wait(&context->delta_cv, &context->delta_mutex);
          } else {
            delta_decoder(dest, destinationoffset, bsize, typesize, dest + destinationoffset);
            context->dref_not_init = 0;
            pthread_cond_broadcast(&context->delta_cv);
          }
        }
        pthread_mutex_unlock(&context->delta_mutex);
        if (destinationoffset != 0) {
          delta_decoder(dest, destinationoffset, bsize, typesize, dest + destinationoffset);
        }
      }
      break;
    case BLOSC_TRUNC_PREC:
      // TRUNC_PREC filter does not need to be undone
      break;
    default:
      if (filters[i] != BLOSC_NOFILTER) {
        fprintf(stderr, "Filter %d not handled during decompression\n", filters[i]);
        return -1;
      }
  }
}