int32_t compressed_size;
  int32_t total_bytes = 0;
  const uint8_t* src_ptr = src + src_offset;
  const uint8_t* src_end = src + srcsize;

  // Validate the source pointer against the source buffer's boundaries
  if (src_ptr + sizeof(int32_t) > src_end) {
    return -1; // Not enough data for compressed size
  }

  // Read the compressed size
  compressed_size = *(int32_t*)src_ptr;
  src_ptr += sizeof(int32_t);

  // Validate the compressed size against the remaining source buffer
  if (src_ptr + compressed_size > src_end) {
    return -1; // Not enough data for compressed bytes
  }

  // Decompress the data based on the compression format
  switch (compformat) {
    case BLOSC_BLOSCLZ:
      total_bytes = blosc_blosclz_decompress(src_ptr, compressed_size, dest + destinationoffset, bsize);
      break;
    case BLOSC_LZ4:
      total_bytes = blosc_lz4_decompress(src_ptr, compressed_size, dest + destinationoffset, bsize);
      break;
    case BLOSC_LZ4HC:
      total_bytes = blosc_lz4hc_decompress(src_ptr, compressed_size, dest + destinationoffset, bsize);
      break;
    case BLOSC_ZLIB:
      total_bytes = blosc_zlib_decompress(src_ptr, compressed_size, dest + destinationoffset, bsize);
      break;
    case BLOSC_SNAPPY:
      total_bytes = blosc_snappy_decompress(src_ptr, compressed_size, dest + destinationoffset, bsize);
      break;
    default:
      return -1; // Unsupported compression format
  }

  // Update the number of uncompressed bytes
  if (total_bytes < 0) {
    return total_bytes; // Error during decompression
  }
  ntbytes += total_bytes;