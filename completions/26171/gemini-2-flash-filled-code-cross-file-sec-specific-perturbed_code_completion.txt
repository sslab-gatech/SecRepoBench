int32_t cbytes;
  int32_t nstreams = context->nstreams;
  int32_t last_filter_index = context->last_filter_index;
  int32_t ntbytes = 0;
  int32_t stream;
  const uint8_t* start = src + src_offset;

  for (stream = 0; stream < nstreams; stream++) {
    int32_t csize = sw32_(start);   /* compressed buffer size */
    start += 4;

    if (csize > bsize) {
      /* Decompressed size larger than blocksize */
      return -6;
    }

    if (csize == 0) {
      /* Run detected */
      uint8_t x = *start;
      start++;
      if (start > (src + srcsize)) {
        return -1;
      }
      memset(dest + destinationoffset, x, (unsigned int)bsize);
      ntbytes += bsize;
    }
    else if (csize == bsize) {
      /* Uncompressed block */
      if ((start + bsize) > (src + srcsize)) {
        return -1;
      }
      memcpy(dest + destinationoffset, start, (unsigned int)bsize);
      start += bsize;
      ntbytes += bsize;
    }
    else if (csize > bsize) {
      /* Decompressed size larger than blocksize */
      return -6;
    }
    else {
      /* Compressed block */
      if ((start + csize) > (src + srcsize)) {
        return -1;
      }

      switch (compformat) {
        case 0:
          /* BloscLZ */
          cbytes = blosc_decompress_lz(start, csize, dest + destinationoffset, bsize);
          break;
        case 1:
          /* LZ4 */
          cbytes = blosc_decompress_lz4(start, csize, dest + destinationoffset, bsize);
          break;
        case 2:
          /* Snappy */
          cbytes = blosc_decompress_snappy(start, csize, dest + destinationoffset, bsize);
          break;
        case 3:
          /* Zlib */
          cbytes = blosc_decompress_zlib(start, csize, dest + destinationoffset, bsize);
          break;
        case 4:
          /* Zstd */
          cbytes = blosc_decompress_zstd(start, csize, dest + destinationoffset, bsize);
          break;
        default:
          /* Unsupported compformat */
          return -4;
      }

      if (cbytes != bsize) {
        /* Decompressed size differs from blocksize */
        return -5;
      }
      start += csize;
      ntbytes += bsize;
    }
    destinationoffset += bsize;
  }