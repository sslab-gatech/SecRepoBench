int32_t nstreams = context->nstreams;
int32_t typesize = context->typesize;
int32_t j, neblock;
int32_t cbytes;
int32_t ntbytes = 0;
int last_filter_index = -1;

if (context->header_flags & BLOSC_DOSHUFFLE) {
  last_filter_index = BLOSC2_MAX_FILTERS - 1;
  filters[last_filter_index] = BLOSC_SHUFFLE;
}
else if (context->header_flags & BLOSC_DOBITSHUFFLE) {
  last_filter_index = BLOSC2_MAX_FILTERS - 1;
  filters[last_filter_index] = BLOSC_BITSHUFFLE;
}

for (j = 0; j < nstreams; j++) {
  neblock = bsize;
  if (j == nstreams - 1 && leftoverblock) {
    neblock = leftoverblock;
  }
  cbytes = sw32_(src + src_offset);
  src_offset += sizeof(int32_t);
  ntbytes += (int32_t)sizeof(int32_t);

  if (cbytes == 0) {
    /* Runs */
    if (j == 0) {
      uint8_t value = src[src_offset];
      memset(dest + destinationoffset, value, (size_t)neblock);
    }
    else {
      memcpy(dest + destinationoffset, dest + destinationoffset - typesize, (size_t)neblock);
    }
  }
  else if (cbytes == neblock) {
    /* Uncompressed data */
    if (src_offset + neblock > srcsize) {
      return BLOSC2_ERROR_READ_BUFFER;
    }
    memcpy(dest + destinationoffset, src + src_offset, (size_t)neblock);
    src_offset += neblock;
    ntbytes += neblock;
  }
  else {
    /* Compressed data */
    if (src_offset + cbytes > srcsize) {
      return BLOSC2_ERROR_READ_BUFFER;
    }
    int32_t decomp_size = BLOSC_MAX_OVERHEAD + neblock;
    if (compformat == BLOSC_BLOSCLZ_FORMAT) {
      cbytes = blosclz_decompress(src + src_offset, cbytes,
                                  tmp, (int)decomp_size);
    }
    else if (compformat == BLOSC_LZ4_FORMAT) {
      cbytes = lz4_wrap_decompress((char*)src + src_offset, (char*)tmp,
                                   (int)cbytes, (int)decomp_size);
    }
    else if (compformat == BLOSC_ZLIB_FORMAT) {
      cbytes = zlib_wrap_decompress(src + src_offset, (int32_t)cbytes,
                                    tmp, (int32_t)decomp_size);
    }
    else if (compformat == BLOSC_ZSTD_FORMAT) {
      cbytes = zstd_wrap_decompress(src + src_offset, (int32_t)cbytes,
                                    tmp, (int32_t)decomp_size);
    }
    else {
      return BLOSC2_ERROR_CODEC_SUPPORT;
    }
    if (cbytes < 0) {
      return cbytes;
    }
    if (cbytes != neblock) {
      return BLOSC2_ERROR_DECOMPRESSION;
    }
    memcpy(dest + destinationoffset, tmp, (size_t)neblock);
    src_offset += cbytes;
    ntbytes += cbytes;
  }
  destinationoffset += neblock;
}