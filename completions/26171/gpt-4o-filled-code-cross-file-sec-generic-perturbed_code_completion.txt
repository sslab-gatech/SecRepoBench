int32_t j, cbytes;
  int32_t ntbytes = 0;
  int32_t nstreams = context->nstreams;
  int32_t leftover = context->leftover;
  int32_t blocksize = context->blocksize;
  int32_t nblocks = context->nblocks;
  int32_t* bstarts = context->bstarts;
  bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;

  for (j = 0; j < nstreams; j++) {
    int32_t bsize = blocksize;
    int32_t leftoverblock = 0;
    if ((j == nstreams - 1) && (leftover > 0)) {
      bsize = leftover;
      leftoverblock = 1;
    }

    if (memcpyed) {
      // Check that sizes in header are compatible, otherwise there is a header corruption
      int32_t csize = sw32_(src + 12);   /* compressed buffer size */
      if (srcsize < BLOSC_MAX_OVERHEAD + (j * blocksize) + bsize) {
        /* Not enough input to copy block */
        return -1;
      }
      memcpy(dest + destinationoffset + j * blocksize,
             src + BLOSC_MAX_OVERHEAD + j * blocksize,
             (unsigned int)bsize);
      cbytes = (int32_t)bsize;
    }
    else {
      /* Regular decompression */
      cbytes = blosc_d(thread_context, bsize, leftoverblock,
                       src, srcsize, sw32_(bstarts + j),
                       dest, destinationoffset + j * blocksize, tmp, tmp2);
    }

    if (cbytes < 0) {
      return cbytes;  /* error in blosc_d */
    }
    ntbytes += cbytes;
  }