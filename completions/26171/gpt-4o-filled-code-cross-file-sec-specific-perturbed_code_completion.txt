int32_t j, cbytes;
  int32_t ntbytes = 0;
  int32_t* bstarts = context->bstarts;
  uint8_t* tmp = thread_context->tmp;
  uint8_t* tmp2 = thread_context->tmp2;
  bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;

  for (j = 0; j < context->nblocks; j++) {
    bsize = context->blocksize;
    leftoverblock = 0;
    if ((j == context->nblocks - 1) && (context->leftover > 0)) {
      bsize = context->leftover;
      leftoverblock = 1;
    }

    if (memcpyed) {
      // Check that sizes in header are compatible, otherwise there is a header corruption
      int32_t csize = sw32_(context->src + 12);   /* compressed buffer size */
      if (context->sourcesize + BLOSC_MAX_OVERHEAD != csize) {
        return -1;
      }
      if (context->srcsize < BLOSC_MAX_OVERHEAD + (j * context->blocksize) + bsize) {
        /* Not enough input to copy block */
        return -1;
      }
      memcpy(context->dest + j * context->blocksize,
             context->src + BLOSC_MAX_OVERHEAD + j * context->blocksize,
             (unsigned int)bsize);
      cbytes = (int32_t)bsize;
    }
    else {
      /* Regular decompression */
      cbytes = blosc_d(thread_context, bsize, leftoverblock,
                       context->src, context->srcsize, sw32_(bstarts + j),
                       context->dest, j * context->blocksize, tmp, tmp2);
    }

    if (cbytes < 0) {
      ntbytes = cbytes;         /* error in blosc_d */
      break;
    }
    ntbytes += cbytes;
  }