int32_t ntbytes = 0;
  int32_t csize = 0;
  int32_t nstreams = 1;
  int32_t typesize = context->typesize;
  int32_t stream_size = bsize;
  int last_filter_index = -1;

  /* Determine the last filter index, if any */
  for (int i = 0; i < BLOSC2_MAX_FILTERS; i++) {
    if (filters[i] != BLOSC_NOFILTER) {
      last_filter_index = i;
    }
  }

  /* Decide whether to split the compressed block into multiple streams */
  if ((compformat & 0x04) && (typesize > 1)) {
    /* e.g. "split" mode, one stream per type element */
    nstreams = typesize;
    if (nstreams > 1) {
      stream_size = bsize / nstreams;
    }
  }

  /* Decompress each stream */
  const uint8_t* csrc = src + src_offset;
  for (int j = 0; j < nstreams; j++) {
    if ((csrc + 4) > (src + srcsize)) {
      return -1;  /* Not enough data to read compressed size */
    }
    csize = sw32_(csrc);  /* Get the compressed size for this stream */
    csrc += 4;

    /* Check buffer boundaries */
    if ((csrc + csize) > (src + srcsize)) {
      return -1;  /* Not enough data for the declared compressed size */
    }

    if (csize == 0) {
      /* This indicates a run. A single-byte value follows. */
      if ((csrc + 1) > (src + srcsize)) {
        return -1;
      }
      uint8_t run_val = *csrc++;
      memset(dest + destinationoffset + (j * stream_size), run_val, (size_t)stream_size);
      ntbytes += stream_size;
    }
    else if (csize == stream_size) {
      /* Uncompressed data */
      memcpy(dest + destinationoffset + (j * stream_size), csrc, (size_t)csize);
      csrc += csize;
      ntbytes += stream_size;
    }
    else {
      /* Compressed data (use the appropriate format) */
      int dsize = 0;
      switch (compformat & 0x03) {
        case 0: /* e.g. BLOSC_BLOSCLZ_FORMAT */
          dsize = blosclz_decompress(csrc, csize, tmp, stream_size);
          break;
        case 1: /* e.g. BLOSC_LZ4_FORMAT */
          dsize = lz4_decompress(csrc, csize, tmp, stream_size);
          break;
        /* More formats can be added here */
        default:
          return -2;  /* Unsupported compression format */
      }
      if (dsize <= 0 || dsize > stream_size) {
        return -2;  /* Decompression error */
      }
      memcpy(dest + destinationoffset + (j * stream_size), tmp, (size_t)dsize);
      csrc += csize;
      ntbytes += dsize;
    }
  }