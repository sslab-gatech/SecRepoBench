int32_t nstreams = 1;
if (compformat == 0) {
  nstreams = (bsize + BLOSC2_MAX_TYPESIZE - 1) / BLOSC2_MAX_TYPESIZE;
}
int32_t ntbytes = 0;
int32_t cbytes = 0;
int32_t j;
uint8_t* ip = src + src_offset;
uint8_t* ip_bound = ip + srcsize;
uint8_t* op = dest + destinationoffset;
uint8_t* op_bound = op + bsize;
int last_filter_index = -1;
for (j = 0; j < nstreams; j++) {
  int32_t streamsize = (j == nstreams - 1)? (bsize - j * BLOSC2_MAX_TYPESIZE) : BLOSC2_MAX_TYPESIZE;
  if (ip + 1 > ip_bound) {
    return -1;  // Not enough input
  }
  uint8_t cbyte = *ip++;
  if (cbyte == 0) {
    // Run of zeros
    memset(op, 0, streamsize);
    op += streamsize;
    ntbytes += streamsize;
  }
  else if (cbyte == 1) {
    // Run of identical values
    if (ip + 1 > ip_bound) {
      return -1;  // Not enough input
    }
    uint8_t value = *ip++;
    memset(op, value, streamsize);
    op += streamsize;
    ntbytes += streamsize;
  }
  else if (cbyte == 2) {
    // Uncompressed data
    if (ip + streamsize > ip_bound) {
      return -1;  // Not enough input
    }
    memcpy(op, ip, streamsize);
    ip += streamsize;
    op += streamsize;
    ntbytes += streamsize;
  }
  else {
    // Compressed data
    if (ip + 1 > ip_bound) {
      return -1;  // Not enough input
    }
    uint8_t csize = *ip++;
    if (ip + csize > ip_bound) {
      return -1;  // Not enough input
    }
    if (csize == 0) {
      // Uncompressible data
      memcpy(op, ip, streamsize);
      ip += streamsize;
      op += streamsize;
      ntbytes += streamsize;
    }
    else {
      // Compressed data
      if (last_filter_index < 0) {
        last_filter_index = 0;
        while (filters[last_filter_index] == BLOSC_NOFILTER) {
          last_filter_index++;
        }
      }
      cbytes = pipeline_d(context, streamsize, op, 0, ip, tmp, tmp2, last_filter_index);
      if (cbytes < 0) {
        return cbytes;  // Error in pipeline_d
      }
      ip += csize;
      op += streamsize;
      ntbytes += streamsize;
    }
  }
}