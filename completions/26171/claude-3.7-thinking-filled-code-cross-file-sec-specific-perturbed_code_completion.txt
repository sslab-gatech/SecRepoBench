int last_filter_index = -1;
  int32_t neblock = bsize / context->typesize;
  int32_t nstreams = context->nstreams;
  int32_t stream_size = bsize / nstreams;
  int32_t cbytes;
  int32_t ntbytes = 0;
  uint8_t* _dest;
  uint8_t* _src = (uint8_t*)(src + src_offset);

  // Find the last filter to apply
  for (int i = 0; i < BLOSC2_MAX_FILTERS; i++) {
    if (filters[i] != BLOSC_NOFILTER) {
      last_filter_index = i;
    }
  }

  // Determine where decompressed data should go initially
  if (last_filter_index >= 0) {
    _dest = tmp;
  } else {
    _dest = dest + destinationoffset;
  }

  // Check if we have enough input data
  if (src_offset + 4 > srcsize) {
    return -1;  // Not enough source data
  }

  // Get the compressed size
  cbytes = sw32_(_src);
  _src += 4;

  // Handle special cases
  if (cbytes == 0) {
    ntbytes = 0;  // No data to decompress
    return 0;
  } else if (cbytes < 0) {
    // Run-length encoding
    cbytes = -cbytes;
    if (_src - src + 1 > srcsize) {
      return -1;  // Not enough source data
    }
    // Get the run value and fill the destination
    uint8_t value = *_src;
    memset(_dest, value, bsize);
    ntbytes = bsize;
  } else if (cbytes == bsize) {
    // Data is stored uncompressed
    if (_src - src + bsize > srcsize) {
      return -1;  // Not enough source data
    }
    memcpy(_dest, _src, bsize);
    ntbytes = bsize;
  } else {
    // Regular decompression with multiple streams
    uint8_t* dest_ptr = _dest;

    for (int j = 0; j < nstreams; j++) {
      // Ensure we have enough data for stream header
      if (_src - src + 4 > srcsize) {
        return -1;
      }

      // Get compressed size for this stream
      int32_t stream_cbytes = sw32_(_src);
      _src += 4;

      // Handle special cases for the stream
      if (stream_cbytes == 0) {
        // Stream is all zeros
        memset(dest_ptr, 0, stream_size);
      } else if (stream_cbytes == 0xFFFFFFFF) {
        // Stream is stored uncompressed
        if (_src - src + stream_size > srcsize) {
          return -1;
        }
        memcpy(dest_ptr, _src, stream_size);
        _src += stream_size;
      } else {
        // Regular compressed stream
        if (_src - src + stream_cbytes > srcsize) {
          return -1;
        }

        // Decompress based on format
        int decompressed_size;
        switch (compformat) {
          case BLOSC_BLOSCLZ_FORMAT:
            decompressed_size = blosclz_decompress(_src, stream_cbytes, 
                                                 dest_ptr, stream_size);
            break;
          case BLOSC_LZ4_FORMAT:
            decompressed_size = lz4_decompress(_src, stream_cbytes,
                                             dest_ptr, stream_size);
            break;
          case BLOSC_ZLIB_FORMAT:
            decompressed_size = zlib_decompress(_src, stream_cbytes,
                                              dest_ptr, stream_size);
            break;
          case BLOSC_ZSTD_FORMAT:
            decompressed_size = zstd_decompress(_src, stream_cbytes,
                                              dest_ptr, stream_size);
            break;
          default:
            return -1;  // Unsupported format
        }

        if (decompressed_size != stream_size) {
          return -1;  // Decompression error
        }

        _src += stream_cbytes;
      }

      dest_ptr += stream_size;
    }

    ntbytes = bsize;
  }