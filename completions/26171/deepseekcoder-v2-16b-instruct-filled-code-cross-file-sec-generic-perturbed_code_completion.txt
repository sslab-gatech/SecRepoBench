// Iterate over each stream and for each stream, read the compressed size and
  // decompress the data using the appropriate decompression format.
  // Handle cases of runs, uncompressed data, or compressed data based on the
  // compressed byte size.
  // Accumulate the total number of compressed and uncompressed bytes for the block.
  // If successful, the number of uncompressed bytes is returned; otherwise,
  // appropriate error codes are returned to indicate failure.

  int32_t cbytes;
  int32_t ntbytes = 0;
  int32_t j;
  int32_t bsize;
  int32_t leftoverblock;
  uint8_t* src_ptr = (uint8_t*)src + src_offset;
  uint8_t* dest_ptr = dest + destinationoffset;

  for (j = 0; j < context->nblocks; j++) {
    bsize = context->blocksize;
    leftoverblock = 0;
    if ((j == context->nblocks - 1) && (context->leftover > 0)) {
      bsize = context->leftover;
      leftoverblock = 1;
    }

    if (context->do_compress) {
      cbytes = blosc_d(thread_context, bsize, leftoverblock,
                       src_ptr, srcsize, (j * context->blocksize) + src_offset,
                       dest_ptr, (j * context->blocksize) + destinationoffset, tmp, tmp2);
      if (cbytes == 0) {
        ntbytes = 0;  // uncompressible data
        break;
      }
      src_ptr += bsize;
      dest_ptr += cbytes;
    } else {
      cbytes = blosc_d(thread_context, bsize, leftoverblock,
                       src_ptr, srcsize, (j * context->blocksize) + src_offset,
                       dest_ptr, (j * context->blocksize) + destinationoffset, tmp, tmp2);
      if (cbytes < 0) {
        ntbytes = cbytes;  // error in blosc_c or blosc_d
        break;
      }
      src_ptr += bsize;
      dest_ptr += bsize;
    }
    ntbytes += cbytes;
  }

  return ntbytes;