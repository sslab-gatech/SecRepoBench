int32_t ntbytes = 0;
int32_t csize;
uint8_t* ip = src + sw32_(bstarts) + src_offset;
uint8_t* ip_bound = src + srcsize;

// Determine the number of streams
int32_t nstreams = leftoverblock ? (bsize / context->stream_size) + 1 : (bsize / context->stream_size);
if ((bsize % context->stream_size) == 0 && !leftoverblock) {
  nstreams--;
}

for (int j = 0; j < nstreams; j++) {
  // Read compressed size for each stream
  if (j < nstreams - 1) {
    csize = *(int32_t*)(ip);
    ip += sizeof(int32_t);
  }
  else {
    csize = srcsize - (ip - src);
  }

  uint8_t* op = dest + destinationoffset + ntbytes;

  if (csize == 0) {
    // Handle uncompressed data case
    memcpy(op, ip, bsize);
    ntbytes += bsize;
    ip += bsize;
  }
  else if (get_run(ip, ip + csize)) {
    // Handle runs case
    memset(op, *ip, bsize);
    ip += csize;
    ntbytes += bsize;
  }
  else {
    // Decompress data using appropriate format
    int32_t uncomp_bytes = decompress_data(compformat, ip, csize, op, bsize, tmp, tmp2);
    if (uncomp_bytes < 0) {
      return uncomp_bytes;  // Return error code on failure
    }
    ntbytes += uncomp_bytes;
    ip += csize;
  }
}