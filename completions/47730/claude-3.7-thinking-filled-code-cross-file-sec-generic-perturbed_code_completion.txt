// Find the next comma or null terminator
while (*comma_or_nul != ',' && *comma_or_nul != '\0') {
  comma_or_nul++;
}

// Now comma_or_nul points to either a comma or the null terminator
if (comma_or_nul > alpn_start) {
  // Extract the current ALPN identifier
  size_t alpn_len = (size_t)(comma_or_nul - alpn_start);
  
  // Declare the buffer for storing the ALPN
  char alpn_str[256];
  
  // Check if length is reasonable and within buffer bounds
  if (alpn_len > 0 && alpn_len < sizeof(alpn_str)) {
    memcpy(alpn_str, alpn_start, alpn_len);
    alpn_str[alpn_len] = '\0'; // Null-terminate
    
    // List of common ALPNs in TLS/QUIC
    if (strcmp(alpn_str, "h2") != 0 && 
        strcmp(alpn_str, "http/1.1") != 0 && 
        strcmp(alpn_str, "h3") != 0 && 
        strcmp(alpn_str, "webrtc") != 0 && 
        strcmp(alpn_str, "spdy/3") != 0 &&
        strcmp(alpn_str, "stun.turn") != 0 &&
        strcmp(alpn_str, "stun.nat-discovery") != 0) {
      
      // Log the uncommon ALPN
      NDPI_LOG_DBG(ndpi_struct, "Uncommon ALPN found: %s\n", alpn_str);
      
      // Prepare risk message
      char str[384];
      snprintf(str, sizeof(str), "Uncommon ALPN: %s", alpn_str);
      
      // Set the risk
      ndpi_set_risk(ndpi_struct, connectionflow, NDPI_TLS_UNCOMMON_ALPN, str);
    }
  }
}