https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml */
  switch(extension_id) {
  case 0x000a: /* server_name */
    {
      u_int8_t * const payload = &packet->payload[extension_payload_offset];
      u_int16_t payload_len = extension_len;
      u_int16_t name_len;
      u_int8_t name_type;

      while(payload_len > 0) {
        if(payload_len < 3) {
#ifdef DEBUG_TLS
          printf("[TLS] server_name extension payload too short: %u bytes.\n", payload_len);
#endif
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_SUSPICIOUS_EXTENSION, NULL);
          return;
        }

        name_len = payload[1];
        name_type = payload[0];

        if(name_len + 2 > payload_len) {
#ifdef DEBUG_TLS
          printf("[TLS] server_name extension name length exceeds remaining payload: %u > %u.\n",
                 name_len, payload_len - 2);
#endif
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_SUSPICIOUS_EXTENSION, NULL);
          return;
        }

        if(name_type == 0) { /* host_name */
          char host_name[256];
          u_int16_t host_name_len = ndpi_min(name_len, sizeof(host_name) - 1);

          memcpy(host_name, &payload[2], host_name_len);
          host_name[host_name_len] = '\0';

          if(ndpi_is_printable_string(host_name, host_name_len) == 0) {
            ndpi_set_risk(ndpi_struct, flow, NDPI_INVALID_CHARACTERS, host_name);
          }

          if(flow->host_server_name[0] == '\0') {
            strncpy(flow->host_server_name, host_name, sizeof(flow->host_server_name) - 1);
            flow->host_server_name[sizeof(flow->host_server_name) - 1] = '\0';
          } else {
            char * label = strstr(flow->host_server_name, host_name);

            if(label != NULL) {
              char * first_dot = strchr(flow->host_server_name, '.');

              if((first_dot == NULL) || (first_dot <= label)) {
                /* The server name matches the SNI. */
                return;
              }
            }

            ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_CERTIFICATE_MISMATCH, NULL);
          }
        } else {
#ifdef DEBUG_TLS
          printf("[TLS] server_name extension with unsupported name type: %u.\n", name_type);
#endif
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_SUSPICIOUS_EXTENSION, NULL);
        }

        payload_len -= name_len + 2;
        payload += name_len + 2;
      }
    }
    break;
  case 0x0010: /* supported_groups */
    {
      u_int8_t * const payload = &packet->payload[extension_payload_offset];
      u_int16_t payload_len = extension_len;
      u_int16_t group_len;

      while(payload_len > 0) {
        if(payload_len < 2) {
#ifdef DEBUG_TLS
          printf("[TLS] supported_groups extension payload too short: %u bytes.\n", payload_len);
#endif
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_SUSPICIOUS_EXTENSION, NULL);
          return;
        }

        group_len = payload[0];

        if(group_len + 1 > payload_len) {
#ifdef DEBUG_TLS
          printf("[TLS] supported_groups extension group length exceeds remaining payload: %u > %u.\n",
                 group_len, payload_len - 1);
#endif
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_SUSPICIOUS_EXTENSION, NULL);
          return;
        }

        if(group_len == 2) { /* Named group */
          u_int16_t group_id = (payload[1] << 8) + payload[2];

          if(group_id == 0x001d) { /* X25519 */
            flow->protos.tls_quic.supported_groups |= (1 << 0);
          } else if(group_id == 0x001e) { /* P-256 */
            flow->protos.tls_quic.supported_groups |= (1 << 1);
          } else if(group_id == 0x001f) { /* P-384 */
            flow->protos.tls_quic.supported_groups |= (1 << 2);
          } else if(group_id == 0x0020) { /* P-521 */
            flow->protos.tls_quic.supported_groups |= (1 << 3);
          }
        } else {
#ifdef DEBUG_TLS
          printf("[TLS] supported_groups extension with unsupported group length: %u.\n", group_len);
#endif
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_SUSPICIOUS_EXTENSION, NULL);
        }

        payload_len -= group_len + 1;
        payload += group_len + 1;
      }
    }
    break;
  case 0x001c: /* signature_algorithms */
    {
      u_int8_t * const payload = &packet->payload[extension_payload_offset];
      u_int16_t payload_len = extension_len;
      u_int16_t sig_algo_len;

      while(payload_len > 0) {
        if(payload_len < 2) {
#ifdef DEBUG_TLS
          printf("[TLS] signature_algorithms extension payload too short: %u bytes.\n", payload_len);
#endif
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_SUSPICIOUS_EXTENSION, NULL);
          return;
        }

        sig_algo_len = payload[0];

        if(sig_algo_len + 1 > payload_len) {
#ifdef DEBUG_TLS
          printf("[TLS] signature_algorithms extension signature algorithm length exceeds remaining payload: %u > %u.\n",
                 sig_algo_len, payload_len - 1);
#endif
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_SUSPICIOUS_EXTENSION, NULL);
          return;
        }

        if(sig_algo_len == 2) { /* Signature algorithm */
          u_int16_t sig_algo_id = (payload[1] << 8) + payload[2];

          if(sig_algo_id == 0x0201) { /* RSA */
            flow->protos.tls_quic.signature_algorithms |= (1 << 0);
          } else if(sig_algo_id == 0x0202) { /* DSA */
            flow->protos.tls_quic.signature_algorithms |= (1 << 1);
          } else if(sig_algo_id == 0x0401) { /* ECDSA */
            flow->protos.tls_quic.signature_algorithms |= (1 << 2);
          } else if(sig_algo_id == 0x0501) { /* Ed25519 */
            flow->protos.tls_quic.signature_algorithms |= (1 << 3);
          } else if(sig_algo_id == 0x0502) { /* Ed448 */
            flow->protos.tls_quic.signature_algorithms |= (1 << 4);
          }
        } else {
#ifdef DEBUG_TLS
          printf("[TLS] signature_algorithms extension with unsupported signature algorithm length: %u.\n", sig_algo_len);
#endif
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_SUSPICIOUS_EXTENSION, NULL);
        }

        payload_len -= sig_algo_len + 1;
        payload += sig_algo_len + 1;
      }
    }
    break;
  case 0x0033: /* ALPN */
    {
      u_int8_t * const payload = &packet->payload[extension_payload_offset];
      u_int16_t payload_len = extension_len;
      u_int16_t alpn_len;

      while(payload_len > 0) {
        if(payload_len < 2) {
#ifdef DEBUG_TLS
          printf("[TLS] ALPN extension payload too short: %u bytes.\n", payload_len);
#endif
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_SUSPICIOUS_EXTENSION, NULL);
          return;
        }

        alpn_len = payload[0];

        if(alpn_len + 1 > payload_len) {
#ifdef DEBUG_TLS
          printf("[TLS] ALPN extension ALPN length exceeds remaining payload: %u > %u.\n",
                 alpn_len, payload_len - 1);
#endif
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_SUSPICIOUS_EXTENSION, NULL);
          return;
        }

        if(alpn_len > 0) {
          char * alpn_str = (char *)&payload[1];
          u_int16_t alpn_str_len = alpn_len;

          if(ndpi_is_printable_string(alpn_str, alpn_str_len) == 0) {
            ndpi_set_risk(ndpi_struct, flow, NDPI_INVALID_CHARACTERS, alpn_str);
          }

          if(flow->protos.tls_quic.alpn[0] == '\0') {
            strncpy(flow->protos.tls_quic.alpn, alpn_str, sizeof(flow->protos.tls_quic.alpn) - 1);
            flow->protos.tls_quic.alpn[sizeof(flow->protos.tls_quic.alpn) - 1] = '\0';
          } else {
            char * label = strstr(flow->protos.tls_quic.alpn, alpn_str);

            if(label != NULL) {
              char * first_dot = strchr(flow->protos.tls_quic.alpn, '.');

              if((first_dot == NULL) || (first_dot <= label)) {
                /* The ALPN matches the existing ALPN. */
                return;
              }
            }

            ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_CERTIFICATE_MISMATCH, NULL);
          }
        }

        payload_len -= alpn_len + 1;
        payload += alpn_len + 1;
      }
    }
    break;
  case 0x0034: /* SCT */
    {
      u_int8_t * const payload = &packet->payload[extension_payload_offset];
      u_int16_t payload_len = extension_len;

      if(payload_len < 3) {
#ifdef DEBUG_TLS
        printf("[TLS] SCT extension payload too short: %u bytes.\n", payload_len);
#endif
        ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_SUSPICIOUS_EXTENSION, NULL);
        return;
      }

      u_int16_t sct_list_len = (payload[1] << 8) + payload[2];

      if(sct_list_len + 3 > payload_len) {
#ifdef DEBUG_TLS
        printf("[TLS] SCT extension SCT list length exceeds remaining payload: %u > %u.\n",
               sct_list_len, payload_len - 3);
#endif
        ndpi_set_risk(ndpi