);
#endif
      return;
    }

  switch(extension_id) {
  case 0x000d: /* server_name */
    {
      u_int8_t * const payload = &packet->payload[extension_payload_offset];
      u_int16_t name_type, name_len;
      u_int16_t offset = 0;

      while(offset < extension_len) {
        name_type = payload[offset];
        offset++;
        name_len = payload[offset];
        offset++;

        if(offset + name_len > extension_len) {
#ifdef DEBUG_TLS
          printf("[TLS] name length exceeds remaining extension length: %u > %u.\n",
                 name_len, extension_len - offset);
#endif
          break;
        }

        if(name_type == 0) { /* host_name */
          char * const hostname = (char *)&payload[offset];
          u_int16_t hostname_len = name_len;

          if(is_dtls) {
            ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_DTLS_SERVER_NAME, hostname);
          } else {
            flow->host_server_name[0] = '\0';
            strncpy(flow->host_server_name, hostname, hostname_len);
            flow->host_server_name[hostname_len] = '\0';
            ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_SERVER_NAME, hostname);
          }
        }

        offset += name_len;
      }
    }
    break;
  case 0x0010: /* max_fragment_length */
    {
      u_int8_t max_fragment_length = packet->payload[extension_payload_offset];

      if(max_fragment_length == 0x01) {
        ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_MAX_FRAGMENT_LENGTH_1, NULL);
      } else if(max_fragment_length == 0x02) {
        ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_MAX_FRAGMENT_LENGTH_2, NULL);
      } else if(max_fragment_length == 0x03) {
        ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_MAX_FRAGMENT_LENGTH_3, NULL);
      }
    }
    break;
  case 0x0013: /* renegotiation_info */
    {
      u_int8_t * const payload = &packet->payload[extension_payload_offset];
      u_int16_t info_type, info_len;
      u_int16_t offset = 0;

      while(offset < extension_len) {
        info_type = payload[offset];
        offset++;
        info_len = payload[offset];
        offset++;

        if(offset + info_len > extension_len) {
#ifdef DEBUG_TLS
          printf("[TLS] info length exceeds remaining extension length: %u > %u.\n",
                 info_len, extension_len - offset);
#endif
          break;
        }

        if(info_type == 0) { /* renego_info */
          if(info_len == 1) {
            if(payload[offset] == 0x01) {
              ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_RENEGOTIATION, NULL);
            }
          }
        }

        offset += info_len;
      }
    }
    break;
  case 0x001b: /* supported_versions */
    {
      u_int8_t * const payload = &packet->payload[extension_payload_offset];
      u_int16_t version_len = extension_len;
      u_int16_t offset = 0;

      while(offset < version_len) {
        u_int16_t version = ntohs(*(u_int16_t *)&payload[offset]);
        offset += 2;

        if(version == 0x0304) { /* TLS 1.3 */
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_VERSION_1_3, NULL);
        } else if(version == 0x0303) { /* TLS 1.2 */
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_VERSION_1_2, NULL);
        } else if(version == 0x0302) { /* TLS 1.1 */
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_VERSION_1_1, NULL);
        } else if(version == 0x0301) { /* TLS 1.0 */
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_VERSION_1_0, NULL);
        } else if(version == 0x0200) { /* SSL 3.0 */
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_VERSION_SSL_3_0, NULL);
        }
      }
    }
    break;
  case 0x001c: /* signature_algorithms */
    {
      u_int8_t * const payload = &packet->payload[extension_payload_offset];
      u_int16_t sig_count = extension_len;
      u_int16_t offset = 0;

      while(offset < sig_count) {
        u_int16_t sig_alg = ntohs(*(u_int16_t *)&payload[offset]);
        offset += 2;

        if(sig_alg == 0x0403) { /* RSA with SHA-1 */
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_RSA_WITH_SHA1, NULL);
        } else if(sig_alg == 0x0503) { /* DSA with SHA-1 */
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_DSA_WITH_SHA1, NULL);
        } else if(sig_alg == 0x0601) { /* ECDSA with SHA-1 */
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_ECDSA_WITH_SHA1, NULL);
        } else if(sig_alg == 0x0401) { /* RSA with SHA-256 */
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_RSA_WITH_SHA256, NULL);
        } else if(sig_alg == 0x0501) { /* DSA with SHA-256 */
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_DSA_WITH_SHA256, NULL);
        } else if(sig_alg == 0x0603) { /* ECDSA with SHA-256 */
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_ECDSA_WITH_SHA256, NULL);
        } else if(sig_alg == 0x0402) { /* RSA with SHA-384 */
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_RSA_WITH_SHA384, NULL);
        } else if(sig_alg == 0x0502) { /* DSA with SHA-384 */
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_DSA_WITH_SHA384, NULL);
        } else if(sig_alg == 0x0602) { /* ECDSA with SHA-384 */
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_ECDSA_WITH_SHA384, NULL);
        } else if(sig_alg == 0x0201) { /* RSA with SHA-512 */
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_RSA_WITH_SHA512, NULL);
        } else if(sig_alg == 0x0302) { /* DSA with SHA-512 */
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_DSA_WITH_SHA512, NULL);
        } else if(sig_alg == 0x0604) { /* ECDSA with SHA-512 */
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_ECDSA_WITH_SHA512, NULL);
        }
      }
    }
    break;
  case 0x0033: /* session_ticket */
    {
      u_int8_t * const payload = &packet->payload[extension_payload_offset];
      u_int16_t ticket_len = extension_len;

      if(ticket_len > 0) {
        ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_SESSION_TICKET, NULL);
      }
    }
    break;
  case 0x0034: /* supported_groups */
    {
      u_int8_t * const payload = &packet->payload[extension_payload_offset];
      u_int16_t group_count = extension_len;
      u_int16_t offset = 0;

      while(offset < group_count) {
        u_int16_t group = ntohs(*(u_int16_t *)&payload[offset]);
        offset += 2;

        if(group == 0x000d) { /* X25519 */
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_X25519, NULL);
        } else if(group == 0x000e) { /* X448 */
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_X448, NULL);
        } else if(group == 0x000f) { /* secp256r1 */
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_SECP256R1, NULL);
        } else if(group == 0x0010) { /* secp384r1 */
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_SECP384R1, NULL);
        } else if(group == 0x0011) { /* secp521r1 */
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_SECP521R1, NULL);
        } else if(group == 0x0012) { /* secp256k1 */
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_SECP256K1, NULL);
        } else if(group == 0x0013) { /* X25519 */
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_X25519, NULL);
        } else if(group == 0x0014) { /* X448 */
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_X448, NULL);
        } else if(group == 0x0015) { /* secp256r1 */
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_SECP256R1, NULL);
        } else if(group == 0x0016) { /* secp384r1 */
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_SECP384R1, NULL);
        } else if(group == 0x0017) { /* secp521r1 */
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_SECP521R1, NULL);
        } else if(group == 0x0018) { /* secp256k1 */
          ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_SECP256K1, NULL);
        }
      }
    }
    break;
  case