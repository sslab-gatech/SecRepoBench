static void tlsCheckUncommonALPN(struct ndpi_detection_module_struct *ndpi_struct,
				 struct ndpi_flow_struct *connectionflow) {
  char * alpn_start = connectionflow->protos.tls_quic.alpn;
  char * comma_or_nul = alpn_start;
  do {
    // Iterate through the ALPN string, delimited by commas, to extract each ALPN identifier.
    // For each ALPN identifier, check if it is not common using a helper function.
    // If an uncommon ALPN is found, prepare a string representation of the ALPN,
    // log a debug message if debugging is enabled, and set a risk using the detection module.
    // <MASK>

    alpn_start = comma_or_nul + 1;
  } while (*(comma_or_nul++)!= '\0');

  // Check if the ALPN string is not empty
  if (alpn_start!= NULL) {
    // Iterate through the ALPN string, delimited by commas, to extract each ALPN identifier.
    while (*alpn_start!= '\0') {
      // Find the next comma or null character
      char *comma_or_nul = strchr(alpn_start, ',');
      if (comma_or_nul == NULL) {
        comma_or_nul = alpn_start + strlen(alpn_start);
      }

      // Extract the ALPN identifier
      char *alpn_identifier = strndup(alpn_start, comma_or_nul - alpn_start);

      // Check if the ALPN identifier is not common
      if (!is_common_alpn(alpn_identifier)) {
        // Prepare a string representation of the ALPN
        char *alpn_str = malloc(strlen(alpn_identifier) + 1);
        strcpy(alpn_str, alpn_identifier);

        // Log a debug message if debugging is enabled
        if (ndpi_struct->debug_level >= NDPI_DEBUG_LEVEL_INFO) {
          printf("[TLS] Uncommon ALPN: %s\n", alpn_str);
        }

        // Set a risk using the detection module
        ndpi_set_risk(ndpi_struct, connectionflow, NDPI_TLS_UNCOMMON_ALPN, alpn_str);

        // Free the allocated memory
        free(alpn_str);
      }

      // Free the allocated memory
      free(alpn_identifier);

      // Move to the next ALPN identifier
      alpn_start = comma_or_nul + 1;
    }
  }
}