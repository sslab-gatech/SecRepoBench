if (!iterator)
    {
      startGlyph = 0;
      classValue.len = 0;
      return_trace (true);
    }

    hb_codepoint_t glyph_min = (*iterator).first;
    hb_codepoint_t glyph_max = glyph_min;
    unsigned max_class = (*iterator).second;

    for (const auto gid_klass_pair : iterator)
    {
      glyph_min = hb_min (glyph_min, gid_klass_pair.first);
      glyph_max = hb_max (glyph_max, gid_klass_pair.first);
      max_class = hb_max (max_class, gid_klass_pair.second);
    }

    unsigned glyph_count = glyph_max - glyph_min + 1;
    startGlyph = glyph_min;

    if (unlikely (!classValue.serialize (c, glyph_count))) return_trace (false);

    for (const auto gid_klass_pair : + hb_zip (hb_range (glyph_min, glyph_max + 1),
                                              hb_iter (classValue)))
    {
      classValue[gid_klass_pair.first - glyph_min] = 0;
    }

    for (const auto gid_klass_pair : iterator)
    {
      classValue[gid_klass_pair.first - glyph_min] = gid_klass_pair.second;
    }

    return_trace (true);