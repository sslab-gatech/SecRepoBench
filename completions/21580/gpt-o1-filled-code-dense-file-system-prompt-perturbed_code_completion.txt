if (iterator.len () == 0)
{
  // If the iterator is empty, allocate two words for start glyph and length (both zero).
  uint16_t *data = c->allocate_min<uint16_t> (2);
  if (unlikely (!data)) return_trace (false);
  data[0] = 0; // Starting glyph index
  data[1] = 0; // Count
  return_trace (true);
}

// Determine min and max glyph indices
uint16_t min_glyph = 0xFFFF, max_glyph = 0;
for (const auto &kv : +iterator)
{
  if (kv.first < min_glyph) min_glyph = kv.first;
  if (kv.first > max_glyph) max_glyph = kv.first;
}

// Calculate glyph count
uint16_t glyph_count = max_glyph - min_glyph + 1;

// Allocate space for start glyph, the length, and each glyph's class value
uint16_t *data = c->allocate_min<uint16_t> (2 + glyph_count);
if (unlikely (!data)) return_trace (false);

// Set the starting glyph and total count
data[0] = min_glyph;
data[1] = glyph_count;

// Assign class values to each glyph index relative to the start
for (const auto &kv : +iterator)
{
  data[2 + (kv.first - min_glyph)] = kv.second;
}

return_trace (true);