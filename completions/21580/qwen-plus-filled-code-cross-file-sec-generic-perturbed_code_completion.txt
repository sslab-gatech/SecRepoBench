if (!iterator) {
  startGlyphIndex = 0;
  classValueLength = 0;
  return true;
}

hb_codepoint_t minGlyphIndex = iterator->get_min_glyph_index();
hb_codepoint_t maxGlyphIndex = iterator->get_max_glyph_index();
unsigned int glyphCount = maxGlyphIndex - minGlyphIndex + 1;

startGlyphIndex = minGlyphIndex;

if (unlikely(!c->allocate(glyphCount))) return_trace(false);

unsigned int i = 0;
for (auto glyphClassPair : *iterator) {
  hb_codepoint_t glyphIndex = glyphClassPair.first;
  hb_codepoint_t classValue = glyphClassPair.second;

  if (glyphIndex >= minGlyphIndex && glyphIndex <= maxGlyphIndex) {
    unsigned int relativeGlyphIndex = glyphIndex - minGlyphIndex;
    if (relativeGlyphIndex < glyphCount) {
      arrayZ[relativeGlyphIndex] = classValue;
    }
  }
}

return_trace(true);