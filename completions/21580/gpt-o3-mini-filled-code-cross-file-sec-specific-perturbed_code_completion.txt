if (!iterator)
{
  c->start_glyph = 0;
  c->class_value_length = 0;
  return_trace(true);
}

hb_codepoint_t min_glyph = (hb_codepoint_t)~0U;
hb_codepoint_t max_glyph = 0;
for (auto it = iterator; it; ++it)
{
  hb_codepoint_t glyph = it->first;
  if (glyph < min_glyph)
    min_glyph = glyph;
  if (glyph > max_glyph)
    max_glyph = glyph;
}

unsigned glyph_count = max_glyph - min_glyph + 1;
c->start_glyph = min_glyph;
c->class_value_length = glyph_count;

/* 
  Allocate/ensure space for glyph class values.
  serialize() is assumed to allocate a buffer of exactly glyph_count items 
  (or validate that enough space exists) to avoid heap overflow.
*/
if (unlikely(!c->serialize(glyph_count)))
  return_trace(false);

/* Zeroâ€initialize the buffer to be safe */
memset(c->classValues, 0, glyph_count * sizeof(c->classValues[0]));

/* For each glyph-class pair, assign the class value at the position relative to min_glyph */
for (auto it = iterator; it; ++it)
{
  hb_codepoint_t glyph = it->first;
  unsigned offset = glyph - min_glyph;
  c->classValues[offset] = it->second;
}

return_trace(true);