if (unlikely (iterator.len () == 0))
{
  COUNT *dest = c->allocate_min<COUNT> ();
  if (unlikely (dest == nullptr)) return_trace (false);
  *dest = 0;
  return_trace (true);
}

unsigned int min_glyph = iterator.min ();
unsigned int max_glyph = iterator.max ();
unsigned int glyph_count = max_glyph - min_glyph + 1;

if (unlikely (!c->extend_min (*this))) return_trace (false);

if (unlikely (!c->check_assign (len, glyph_count))) return_trace (false);

hb_codepoint_t *dest = c->allocate_array<COUNT> (glyph_count);
if (unlikely (dest == nullptr)) return_trace (false);

for (auto glyph_class : iterator)
  dest[glyph_class.first - min_glyph] = glyph_class.second;

return_trace (true);