if (iterator.is_empty ())
    {
      if (unlikely (!c->extend_min (2))) return_trace (false);
      c->u16 (0);
      c->u16 (0);
      return_trace (true);
    }

    unsigned min_glyph = iterator.min_value ();
    unsigned max_glyph = iterator.max_value ();

    unsigned glyph_count = max_glyph - min_glyph + 1;

    if (unlikely (!c->extend_min (glyph_count * 2 + 2))) return_trace (false);

    c->u16 (min_glyph);
    c->u16 (glyph_count);

    unsigned class_value = 0;
    unsigned last_glyph = min_glyph - 1;
    for (const auto& item : iterator)
    {
      unsigned glyph = item.first;
      class_value = item.second;

      // Fill in any gaps with the previous class value.
      for (unsigned i = last_glyph + 1; i < glyph; i++)
      {
        c->u16 (0);
      }

      c->u16 (class_value);
      last_glyph = glyph;
    }

    // Fill in any remaining gaps with the last class value.
    for (unsigned i = last_glyph + 1; i <= max_glyph; i++)
    {
      c->u16 (0);
    }

    return_trace (true);