if (!iterator)
{
  c->put_uint16(0);  // starting glyph index
  c->put_uint16(0);  // class value length (i.e. number of entries)
  return_trace(true);
}

// Compute the minimum and maximum glyph indices.
hb_codepoint_t min_glyph = UINT16_MAX;
hb_codepoint_t max_glyph = 0;
for (Iterator it = iterator; it; ++it)
{
  const auto &pair = *it; // expect pair.glyph and pair.class_value
  if (pair.glyph < min_glyph)
    min_glyph = pair.glyph;
  if (pair.glyph > max_glyph)
    max_glyph = pair.glyph;
}
unsigned glyph_count = max_glyph - min_glyph + 1;

// Reserve space and serialize the class value array.
// First, serialize the glyph count so that the context knows how many entries will follow.
if (unlikely (!c->serialize(glyph_count)))
  return_trace(false);

// Write the starting glyph index.
c->put_uint16(min_glyph);

// Reserve space for the class table by initializing all values to zero.
unsigned table_pos = c->current_position();
for (unsigned i = 0; i < glyph_count; i++)
  c->put_uint16(0);

// Iterate over the glyph-class pairs again and fill in the class table;
// each glyphâ€™s class is stored at the position corresponding to its offset from min_glyph.
for (Iterator it = iterator; it; ++it)
{
  const auto &pair = *it;
  unsigned offset = pair.glyph - min_glyph;
  c->put_uint16_at(table_pos + offset * sizeof(uint16_t), pair.class_value);
}

return_trace(true);