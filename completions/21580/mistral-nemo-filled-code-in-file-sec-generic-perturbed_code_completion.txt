// <MASK>
template<typename Iterator>
static inline void
Coverage_serialize (hb_serialize_context_t *c,
                    Iterator it)
{
  TRACE_SERIALIZE (this);
  if (unlikely (!c->extend_min ((*this)))) return_trace (false);

  unsigned count = 0;
  unsigned num_ranges = 0;
  hb_codepoint_t last = (hb_codepoint_t) -2;
  for (auto g: glyphs)
  {
    if (last + 1 != g)
      num_ranges++;
    last = g;
    count++;
  }

  if (unlikely (!(*this).len.serialize (c, num_ranges))) return_trace (false);

  unsigned int size = (*this).get_size () - HBUINT16::static_size/*(*this).len*/ + (get_row_size () * count);
  if (unlikely (!c->allocate_size<HBUINT8> (size))) return_trace (false);

  for (const auto _ : it)
  {
    auto *o = c->copy (_);
    if (unlikely (!o)) return_trace (false);
    c->copy (o, (*this).get_delta_bytes ());
    (*this).len++;
  }

  return_trace (true);
}

template<typename Iterator>
static inline void
ClassDef_serialize (hb_serialize_context_t *c,
                    Iterator it)
{
  TRACE_SERIALIZE (this);
  if (unlikely (!c->extend_min ((*this)))) return_trace (false);

  unsigned count = 0;
  hb_codepoint_t prev_gid = (*it).first;
  unsigned prev_klass = (*it).second;

  ClassDefRecord range_rec;
  range_rec.first = prev_gid;
  range_rec.last = prev_gid;
  range_rec.value = prev_klass;

  ClassDefRecord *record = c->copy (range_rec);
  if (unlikely (!record)) return_trace (false);

  for (const auto gid_klass_pair : + (++it))
  {
    hb_codepoint_t cur_gid = gid_klass_pair.first;
    unsigned cur_klass = gid_klass_pair.second;

    if (cur_gid != prev_gid + 1 ||
        cur_klass != prev_klass)
    {
      if (unlikely (!record)) break;
      record->last = prev_gid;
      num_ranges++;

      range_rec.first = cur_gid;
      range_rec.last = cur_gid;
      range_rec.value = cur_klass;

      record = c->copy (range_rec);
    }

    prev_klass = cur_klass;
    prev_gid = cur_gid;
  }

  if (likely (record)) record->last = prev_gid;
  (*this).len = num_ranges;
  return_trace (true);
}