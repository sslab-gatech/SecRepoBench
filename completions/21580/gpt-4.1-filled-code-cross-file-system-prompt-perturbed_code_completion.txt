if (!iterator)
    {
      startGlyph = 0;
      classValue.len = 0;
      return_trace (true);
    }

    // Find min and max glyph indices
    hb_codepoint_t min_glyph = HB_CODEPOINT_MAX, max_glyph = 0;
    unsigned count = 0;
    for (auto it = iterator; it; ++it)
    {
      hb_codepoint_t glyph = (*it).first;
      if (glyph < min_glyph) min_glyph = glyph;
      if (glyph > max_glyph) max_glyph = glyph;
      count++;
    }
    if (!count)
    {
      startGlyph = 0;
      classValue.len = 0;
      return_trace (true);
    }

    startGlyph = min_glyph;
    unsigned glyph_count = max_glyph - min_glyph + 1;

    if (unlikely (!classValue.serialize (c, glyph_count)))
      return_trace (false);

    // Set all to zero first
    for (unsigned i = 0; i < glyph_count; i++)
      classValue[i] = 0;

    // Assign class values
    for (auto it = iterator; it; ++it)
    {
      hb_codepoint_t glyph = (*it).first;
      uint16_t klass = (*it).second;
      classValue[glyph - min_glyph] = klass;
    }

    return_trace (true);