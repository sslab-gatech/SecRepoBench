if (!iterator)
{
    this->startGlyphID = 0;
    this->classValueCount = 0;
    return_trace (true);
}

hb_codepoint_t min_glyph = HB_SET_VALUE_INVALID, max_glyph = HB_SET_VALUE_INVALID;
for (const auto& pair : iterator)
{
    hb_codepoint_t g = pair.first;
    if (g < min_glyph || min_glyph == HB_SET_VALUE_INVALID) min_glyph = g;
    if (g > max_glyph || max_glyph == HB_SET_VALUE_INVALID) max_glyph = g;
}

if (min_glyph == HB_SET_VALUE_INVALID) return_trace (false);

unsigned count = max_glyph - min_glyph + 1;
this->startGlyphID = min_glyph;
this->classValueCount = count;

hb_vector_t<HBUINT16> classValues;
if (unlikely (!classValues.resize (count, false) || !c->extend_min (this->classValueArray))) return_trace (false);

for (unsigned i = 0; i < count; i++)
    classValues[i] = 0;

for (const auto& pair : iterator)
{
    unsigned idx = pair.first - min_glyph;
    if (idx >= count) return_trace (false);
    classValues[idx] = pair.second;
}

return_trace (classValueArray.serialize (c, classValues.arrayZ, count));