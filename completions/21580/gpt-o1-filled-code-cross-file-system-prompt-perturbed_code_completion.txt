{
  if (!iterator)
  {
    startGlyphIndex = 0;
    classValueLength = 0;
    return_trace(true);
  }

  hb_codepoint_t minGlyph = HB_CODEPOINT_MAX;
  hb_codepoint_t maxGlyph = 0;

  // Determine min and max glyph indices
  for (auto it = iterator.clone(); it; ++it)
  {
    hb_codepoint_t g = it->first;
    if (g < minGlyph) minGlyph = g;
    if (g > maxGlyph) maxGlyph = g;
  }

  // If no valid glyphs, set values to zero and return
  if (minGlyph == HB_CODEPOINT_MAX)
  {
    startGlyphIndex = 0;
    classValueLength = 0;
    return_trace(true);
  }

  // Calculate glyph range and set start
  unsigned glyphCount = maxGlyph - minGlyph + 1;
  startGlyphIndex = minGlyph;

  // Serialize the glyph count
  if (unlikely(!serialize(c, glyphCount))) return_trace(false);

  // Initialize class values array
  memset(classArray, 0, glyphCount * sizeof(classArray[0]));

  // Fill class values using iterator
  for (auto it = iterator.clone(); it; ++it)
  {
    hb_codepoint_t g = it->first;
    uint16_t classVal = it->second;
    classArray[g - minGlyph] = classVal;
  }

  // Store length and return success
  classValueLength = glyphCount;
  return_trace(true);
}