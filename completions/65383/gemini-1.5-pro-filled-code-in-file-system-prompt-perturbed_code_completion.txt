case 'H':
    if (aux_limit - aux < 4)
        goto err;

    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto err;
        codec->out = tm->blk;
    }

    aux+=3;
    //codec->encode(s, codec, aux, 1);
    BLOCK_APPEND_CHAR(tm->blk, *aux);
    aux++;
    break;

case 'B': {
    // "B" type aux field.
    if (aux_limit - aux < 5)
        goto err;

    uint8_t sub_type = aux[3];
    uint32_t count = le_to_u32(aux+4);

    // Compute size
    size_t size = 0;
    switch (sub_type) {
    case 'c': case 'C': size = count; break;
    case 's': case 'S': size = count * 2; break;
    case 'i': case 'I': case 'f': size = count * 4; break;
    default:
        hts_log_error("Unhandled sub-type '%c' for aux type B", sub_type);
        goto err;
    }

    if (aux_limit - aux < 9 + size)
        goto err;

    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto err;
        codec->u.e_byte_array_len.val_codec->out = tm->blk;
    }
    if (!tm->blk2) {
        if (!(tm->blk2 = cram_new_block(EXTERNAL, key+128)))
            goto err;
        codec->u.e_byte_array_len.len_codec->out = tm->blk2;
    }

    aux+=3;
    //codec->encode(s, codec, aux, size+5);
    BLOCK_APPEND(tm->blk2, aux, 4); // sub-type + count
    BLOCK_APPEND(tm->blk, aux+4, size);
    aux+=size+4;
    break;
}