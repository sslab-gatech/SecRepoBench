case 'Z':
case 'H': {
    // string as byte_array_stop
    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto err;
        codec->u.e_byte_array_stop.val_codec->out = tm->blk;
    }
    aux += 3;
    // Find the end of the string (null-terminated)
    char *end = memchr(aux, 0, aux_limit - aux);
    if (!end)
        goto err;
    size_t len = end - aux;
    BLOCK_APPEND(tm->blk, aux, len + 1); // include null terminator
    aux += len + 1;
    break;
}
case 'B': {
    // Byte array of variable size
    if (aux_limit - aux < 3 + 5)
        goto err;
    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto err;
        codec->u.e_byte_array_len.val_codec->out = tm->blk;
    }
    aux += 3;
    char subtype = *aux++;
    int32_t count;
    memcpy(&count, aux, 4);
    aux += 4;
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
    // nothing
#else
    count = bswap_32(count);
#endif
    size_t item_size;
    switch (subtype) {
        case 'c': case 'C': case 'A': item_size = 1; break;
        case 's': case 'S': item_size = 2; break;
        case 'i': case 'I': case 'f': item_size = 4; break;
        case 'd': item_size = 8; break;
        default:
            hts_log_error("Unknown B array subtype '%c'", subtype);
            goto err;
    }
    size_t total = 1 + 4 + count * item_size;
    if (aux_limit - (aux - 5) < (ssize_t)total)
        goto err;
    // Write type, count, and data
    BLOCK_APPEND_CHAR(tm->blk, subtype);
    BLOCK_APPEND(tm->blk, aux - 4, 4); // count
    BLOCK_APPEND(tm->blk, aux, count * item_size);
    aux += count * item_size;
    break;
}