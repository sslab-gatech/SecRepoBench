case 'Z':
    if (aux_limit - aux < 3)
        goto err;
    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto err;
        codec->u.e_byte_array_len.val_codec->out = tm->blk;
    }
    aux += 3;
    while (aux < aux_limit && *aux)
        BLOCK_APPEND_CHAR(tm->blk, *aux++);
    if (aux >= aux_limit)
        goto err;
    BLOCK_APPEND_CHAR(tm->blk, *aux++);
    break;

case 'H':
    if (aux_limit - aux < 3)
        goto err;
    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto err;
        codec->u.e_byte_array_len.val_codec->out = tm->blk;
    }
    aux += 3;
    while (aux < aux_limit && *aux)
        BLOCK_APPEND_CHAR(tm->blk, *aux++);
    if (aux >= aux_limit)
        goto err;
    BLOCK_APPEND_CHAR(tm->blk, *aux++);
    break;

case 'B':
    if (aux_limit - aux < 5)
        goto err;
    {
        int type = aux[3], blen;
        uint32_t count = le_to_u32(aux+4);
        if (aux_limit - aux < 8 + count * aux_size[type])
            goto err;
        if (!tm->blk) {
            if (!(tm->blk = cram_new_block(EXTERNAL, key)))
                goto err;
            codec->u.e_byte_array_len.val_codec->out = tm->blk;
        }
        blen = aux_size[type] * count;
        BLOCK_APPEND(tm->blk, aux+3, blen+5);
        aux += 8 + blen;
    }
    break;