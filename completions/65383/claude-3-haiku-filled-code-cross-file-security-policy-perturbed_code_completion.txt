case 'H':
    if (aux_limit - aux < 2)
        goto err;

    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto err;
        codec->u.e_byte_array_len.val_codec->out = tm->blk;
    }

    // Encode the hexadecimal string from the auxiliary field
    while (aux < aux_limit && *aux != 0) {
        BLOCK_APPEND_CHAR(tm->blk, *aux++);
    }
    if (aux < aux_limit)
        aux++;
    break;

case 'B':
    if (aux_limit - aux < 3)
        goto err;

    // Compute the length based on the sub-type and count
    int sub_type = aux[2];
    int count = 0;
    switch (sub_type) {
    case 'c': case 'C': count = aux_limit - aux - 3; break;
    case 's': case 'S': count = (aux_limit - aux - 3) / 2; break;
    case 'i': case 'I': case 'f': count = (aux_limit - aux - 3) / 4; break;
    default:
        hts_log_error("Unsupported BAM aux type 'B:%c'", sub_type);
        goto err;
    }

    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto err;
        codec->u.e_byte_array_len.val_codec->out = tm->blk;
    }

    // Encode the byte array data from the auxiliary field
    aux += 3;
    for (int i = 0; i < count; i++) {
        switch (sub_type) {
        case 'c': case 'C':
            BLOCK_APPEND_CHAR(tm->blk, *aux++);
            break;
        case 's': case 'S':
            BLOCK_APPEND(tm->blk, aux, 2);
            aux += 2;
            break;
        case 'i': case 'I': case 'f':
            BLOCK_APPEND(tm->blk, aux, 4);
            aux += 4;
            break;
        }
    }
    break;