// Case handlers for auxiliary fields of types 'H' and 'B' in BAM records.
// Handles 'H' type (hexadecimal string) by creating a new block if necessary,
// and encoding the data from the auxiliary fields.
if (aux[0] == 'H' && aux[1] == 'E' && aux[2] == 'X') {
    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto err;
        codec->u.e_byte_array_len.val_codec->out = tm->blk;
    }

    aux+=3;
    //codec->encode(s, codec, aux, 4);
    BLOCK_APPEND(tm->blk, aux, 4);
    aux+=4;
}

// Handles 'B' type (byte array) by computing the length based on the sub-type and count,
// allocating blocks as needed, and encoding the data.
if (aux[0] == 'B' && aux[1] == 'Y' && aux[2] == 'T') {
    int len = 0;
    int sub_type = aux[3];
    int count = 0;

    // Parse the length from the auxiliary field
    while (aux < aux_limit && *aux != 0) {
        if (*aux == 'L') {
            len = strtol(aux+1, &aux, 10);
            break;
        }
        count++;
        aux++;
    }

    // Allocate blocks as needed
    while (len > 0) {
        if (!tm->blk) {
            if (!(tm->blk = cram_new_block(EXTERNAL, key)))
                goto err;
            codec->u.e_byte_array_len.val_codec->out = tm->blk;
        }

        int block_size = BLOCK_SIZE(tm->blk);
        if (len >= block_size) {
            BLOCK_APPEND(tm->blk, aux, block_size);
            len -= block_size;
            aux += block_size;
        } else {
            BLOCK_APPEND(tm->blk, aux, len);
            len = 0;
            aux += len;
        }
    }

    aux += count; // Skip the count field
}