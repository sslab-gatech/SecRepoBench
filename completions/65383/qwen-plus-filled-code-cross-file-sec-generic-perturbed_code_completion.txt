case 'H':
    if (aux_limit - aux < 3+1) // Minimum length for 'H' type
        goto err;

    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto err;
        codec->u.e_byte_array_len.val_codec->out = tm->blk;
    }

    aux += 3;
    int hex_len = strlen(aux);
    BLOCK_APPEND(tm->blk, aux, hex_len);
    aux += hex_len;
    break;

case 'B':
    if (aux_limit - aux < 5)
        goto err;

    char sub_type = aux[3]; // Sub-type of 'B'
    int count = bam_aux2i((uint8_t *)aux + 4); // Number of elements

    if (count < 0 || aux_limit - aux < 5 + count * (sub_type == 'c' || sub_type == 'C' ? 1 :
                                                    sub_type == 's' || sub_type == 'S' ? 2 :
                                                    sub_type == 'i' || sub_type == 'I' || sub_type == 'f' ? 4 : 0))
        goto err;

    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto err;
        codec->u.e_byte_array_len.len_codec->out = tm->blk;
        codec->u.e_byte_array_len.val_codec->out = tm->blk;
    }

    aux += 4; // Skip 'B', sub-type, and count
    BLOCK_APPEND_CHAR(tm->blk, sub_type); // Store the sub-type in the block
    BLOCK_APPEND_INT(tm->blk, count); // Store the count in the block

    switch(sub_type) {
        case 'c': case 'C':
            BLOCK_APPEND(tm->blk, aux, count);
            aux += count;
            break;
        case 's': case 'S':
            BLOCK_APPEND(tm->blk, aux, count * 2);
            aux += count * 2;
            break;
        case 'i': case 'I': case 'f':
            BLOCK_APPEND(tm->blk, aux, count * 4);
            aux += count * 4;
            break;
        default:
            hts_log_error("Unsupported sub-type '%c' for 'B' aux type", sub_type);
            goto err;
    }
    break;