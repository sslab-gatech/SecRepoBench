if (aux_limit - aux < 3 + 1)
                goto err;

            if (!tm->blk) {
                if (!(tm->blk = cram_new_block(EXTERNAL, key)))
                    goto err;
                codec->u.e_byte_array_len.val_codec->out = tm->blk;
            }

            aux += 3;
            //codec->encode(s, codec, aux, 1);
            BLOCK_APPEND_CHAR(tm->blk, *aux);
            aux++;
            break;

        case 'S': case 's':
            if (aux_limit - aux < 3 + 2)
                goto err;

            if (!tm->blk) {
                if (!(tm->blk = cram_new_block(EXTERNAL, key)))
                    goto err;
                codec->u.e_byte_array_len.val_codec->out = tm->blk;
            }

            aux += 3;
            //codec->encode(s, codec, aux, 2);
            BLOCK_APPEND(tm->blk, aux, 2);
            aux += 2;
            break;

        case 'I': case 'i': case 'f':
            if (aux_limit - aux < 3 + 4)
                goto err;

            if (!tm->blk) {
                if (!(tm->blk = cram_new_block(EXTERNAL, key)))
                    goto err;
                codec->u.e_byte_array_len.val_codec->out = tm->blk;
            }

            aux += 3;
            //codec->encode(s, codec, aux, 4);
            BLOCK_APPEND(tm->blk, aux, 4);
            aux += 4;
            break;

        case 'd':
            if (aux_limit - aux < 3 + 8)
                goto err;

            if (!tm->blk) {
                if (!(tm->blk = cram_new_block(EXTERNAL, key)))
                    goto err;
                codec->u.e_byte_array_len.val_codec->out = tm->blk;
            }

            aux += 3; //*tmp++=*aux++; *tmp++=*aux++; *tmp++=*aux++;
            //codec->encode(s, codec, aux, 8);
            BLOCK_APPEND(tm->blk, aux, 8);
            aux += 8;
            break;

        case 'Z': 
        // Case handlers for auxiliary fields of types 'H' and 'B' in BAM records.
        // Handles 'H' type (hexadecimal string) by creating a new block if necessary,
        // and encoding the data from the auxiliary fields.
        // For 'B' type (byte array), computes the length based on the sub-type and count,
        // allocates blocks as needed, and encodes the data.
        // Checks for sufficient data remaining in the auxiliary field buffer before processing.
        // Updates the auxiliary field pointer appropriately after encoding.
        // <MASK>
        default:
            hts_log_error("Unknown aux type '%c'", aux_limit - aux < 2 ? '?' : aux[2]);
            goto err;