case 'H':
            if (aux_limit - aux < 3 + 1)
                goto err;

            if (!tm->blk) {
                if (!(tm->blk = cram_new_block(EXTERNAL, key)))
                    goto err;
                codec->u.e_byte_array_len.val_codec->out = tm->blk;
            }

            aux +=3;
            size_t h_len = strlen(aux) + 1;
            if (aux + h_len > aux_limit)
                goto err;
            BLOCK_APPEND(tm->blk, aux, h_len);
            aux += h_len;
            break;

        case 'B': {
            if (aux_limit - aux < 3 + 1 + 4)
                goto err;

            if (!tm->blk) {
                if (!(tm->blk = cram_new_block(EXTERNAL, key)))
                    goto err;
                codec->u.e_byte_array_len.val_codec->out = tm->blk;
            }

            BLOCK_APPEND(tm->blk, aux, 3);
            aux +=3;

            char subtype = *aux++;
            BLOCK_APPEND_CHAR(tm->blk, subtype);

            int32_t count;
            memcpy(&count, aux, 4);
            count = le32toh(count);
            BLOCK_APPEND(tm->blk, aux, 4);
            aux +=4;

            int elem_size;
            switch (subtype) {
                case 'c': case 'C': case 'A': elem_size = 1; break;
                case 's': case 'S': elem_size = 2; break;
                case 'i': case 'I': case 'f': elem_size = 4; break;
                case 'd': elem_size = 8; break;
                default:
                    hts_log_error("Unsupported B subtype '%c'", subtype);
                    goto err;
            }

            size_t data_size = count * elem_size;
            if (aux_limit - aux < data_size)
                goto err;

            BLOCK_APPEND(tm->blk, aux, data_size);
            aux += data_size;
            break;
        }