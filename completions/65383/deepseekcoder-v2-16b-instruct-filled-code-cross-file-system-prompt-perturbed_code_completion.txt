// Handles 'H' type (hexadecimal string) by creating a new block if necessary,
// and encoding the data from the auxiliary fields.
// For 'B' type (byte array), computes the length based on the sub-type and count,
// allocates blocks as needed, and encodes the data.
// Checks for sufficient data remaining in the auxiliary field buffer before processing.
// Updates the auxiliary field pointer appropriately after encoding.
case 'H': {
    size_t hex_len = aux_limit - aux;
    if (hex_len % 2 != 0) {
        hts_log_error("Hexadecimal string length is not even");
        goto err;
    }
    size_t byte_len = hex_len / 2;
    uint8_t *byte_array = malloc(byte_len);
    if (!byte_array) {
        hts_log_error("Failed to allocate memory for byte array");
        goto err;
    }
    for (size_t i = 0; i < byte_len; i++) {
        sscanf(&aux[i * 2], "%2hhx", &byte_array[i]);
    }
    aux += hex_len;

    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto err;
        codec->u.e_byte_array_len.val_codec->out = tm->blk;
    }

    BLOCK_APPEND(tm->blk, (char *)byte_array, byte_len);
    free(byte_array);
    break;
}