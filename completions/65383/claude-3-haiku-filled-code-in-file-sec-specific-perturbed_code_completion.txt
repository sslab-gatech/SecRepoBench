// <MASK>
case 'H': 
case 'B':
    // Case handlers for auxiliary fields of types 'H' and 'B' in BAM records.
    // Handles 'H' type (hexadecimal string) by creating a new block if necessary,
    // and encoding the data from the auxiliary fields.
    // For 'B' type (byte array), computes the length based on the sub-type and count,
    // allocates blocks as needed, and encodes the data.
    // Checks for sufficient data remaining in the auxiliary field buffer before processing.
    // Updates the auxiliary field pointer appropriately after encoding.
    if (aux_limit - aux < 3) {
        hts_log_error("Insufficient data for aux type '%c'", aux[2]);
        goto err;
    }

    if (aux[2] == 'H') {
        // Hexadecimal string
        int len = (aux_limit - aux - 3 + 1) / 2;
        if (!tm->blk) {
            if (!(tm->blk = cram_new_block(EXTERNAL, key)))
                goto err;
            codec->u.e_byte_array_stop.content_id = key;
            codec->out = tm->blk;
        }
        BLOCK_APPEND_HEX(tm->blk, aux + 3, len);
        aux += 3 + len;
    } else if (aux[2] == 'B') {
        // Byte array
        char type = aux[3];
        int32_t count = bam_aux2i_end(aux + 4, aux_limit);
        aux += 4;
        int elem_size;
        switch (type) {
        case 'c': case 'C': elem_size = 1; break;
        case 's': case 'S': elem_size = 2; break;
        case 'i': case 'I': case 'f': elem_size = 4; break;
        case 'd': elem_size = 8; break;
        default:
            hts_log_error("Unknown 'B' sub-type '%c'", type);
            goto err;
        }
        if (aux_limit - aux < count * elem_size) {
            hts_log_error("Insufficient data for 'B' type");
            goto err;
        }
        if (!tm->blk) {
            if (!(tm->blk = cram_new_block(EXTERNAL, key)))
                goto err;
            codec->u.e_byte_array_len.len_codec->out = tm->blk;
            codec->u.e_byte_array_len.val_codec->out = tm->blk;
        }
        BLOCK_APPEND(tm->blk, aux, count * elem_size);
        aux += count * elem_size;
    } else {
        hts_log_error("Unknown aux type '%c'", aux[2]);
        goto err;
    }
    break;
// </MASK>