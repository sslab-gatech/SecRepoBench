case 'H': {
    // hexadecimal string
    cram_byte_array_len_encoder e;
    cram_stats st;

    if (CRAM_MAJOR_VERS(fd->version) <= 3) {
        e.len_encoding = E_HUFFMAN;
        e.len_dat = NULL; // will get codes from st
    } else {
        e.len_encoding = E_CONST_INT;
        e.len_dat = NULL; // will get codes from st
    }
    memset(&st, 0, sizeof(st));
    if (cram_stats_add(&st, 2) < 0) goto block_err;
    cram_stats_encoding(fd, &st);

    e.val_encoding = E_EXTERNAL;
    e.val_dat = (void *)sk;

    c = cram_encoder_init(E_BYTE_ARRAY_LEN, &st,
                          E_BYTE_ARRAY, (void *)&e,
                          fd->version, &fd->vv);
    break;

case 'B': {
    // Byte array of variable size, but we generate our tag
    // byte stream at the wrong stage (during reading and not
    // after slice header construction). So we use
    // BYTE_ARRAY_LEN with the length codec being external
    // too.
    cram_byte_array_len_encoder e;

    e.len_encoding = CRAM_MAJOR_VERS(fd->version) >= 4
       ? E_VARINT_UNSIGNED
        : E_EXTERNAL;
    e.len_dat = (void *)sk; // or key+128 for len?

    e.val_encoding = E_EXTERNAL;
    e.val_dat = (void *)sk;

    c = cram_encoder_init(E_BYTE_ARRAY_LEN, NULL,
                          E_BYTE_ARRAY, (void *)&e,
                          fd->version, &fd->vv);
    break;

default:
    hts_log_error("Unsupported SAM aux type '%c'", aux[2]);
    c = NULL;
}