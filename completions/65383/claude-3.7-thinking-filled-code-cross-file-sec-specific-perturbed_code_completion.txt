case 'Z': case 'H':
    if (aux_limit - aux < 4) // Need at least tag type + one character + null
        goto err;

    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto_err;
        codec->u.e_byte_array_len.val_codec->out = tm->blk;
    }

    aux += 3;
    char *endp = aux;
    while (endp < aux_limit && *endp)
        endp++;
    
    if (endp >= aux_limit) // No null terminator found
        goto err;
    
    // Include the null terminator in the data
    size_t len = endp - aux + 1;
    
    // Copy string including null terminator
    BLOCK_APPEND(tm->blk, aux, len);
    aux += len;
    break;

case 'B':
    if (aux_limit - aux < 8) // tag type + subtype + count minimum
        goto err;

    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto_err;
        codec->u.e_byte_array_len.val_codec->out = tm->blk;
    }

    aux += 3;
    uint8_t subtype = *aux++;
    int32_t count;
    
    // Get count safely
    if (aux_limit - aux < 4)
        goto err;
    
    memcpy(&count, aux, 4);
    aux += 4;
    
    // Calculate element size based on subtype
    int ele_size;
    switch(subtype) {
    case 'c': case 'C': ele_size = 1; break;
    case 's': case 'S': ele_size = 2; break;
    case 'i': case 'I': case 'f': ele_size = 4; break;
    case 'd': ele_size = 8; break;
    default:
        hts_log_error("Unknown sub-type '%c' for array field type 'B'", subtype);
        goto err;
    }
    
    // Check for buffer overflow
    size_t data_len = count * ele_size;
    if (count < 0 || aux_limit - aux < data_len)
        goto err;
    
    // Store subtype and count
    BLOCK_APPEND_CHAR(tm->blk, subtype);
    BLOCK_APPEND(tm->blk, &count, 4);
    
    // Append array data
    BLOCK_APPEND(tm->blk, aux, data_len);
    aux += data_len;
    break;