case 'Z': case 'H':
    {
        if (aux_limit - aux < 3)
            goto err;

        if (!tm->blk) {
            if (!(tm->blk = cram_new_block(EXTERNAL, key)))
                goto err;
            codec->u.e_byte_array_len.val_codec->out = tm->blk;
        }

        aux += 3;
        char *aux_orig = aux;
        while (aux < aux_limit && *aux)
            aux++;
        
        if (aux >= aux_limit)
            goto err;
        
        BLOCK_APPEND(tm->blk, aux_orig, aux - aux_orig + 1);
        aux++;
    }
    break;

case 'B':
    {
        if (aux_limit - aux < 8) // Need at least tag(3) + type(1) + count(4)
            goto err;

        if (!tm->blk) {
            if (!(tm->blk = cram_new_block(EXTERNAL, key)))
                goto err;
            codec->u.e_byte_array_len.val_codec->out = tm->blk;
        }

        aux += 3;
        int subtype = *aux++;
        
        uint32_t count;
        if (aux_limit - aux < 4)
            goto err;
        
        memcpy(&count, aux, 4);
        aux += 4;
        
        int el_size;
        switch (subtype) {
        case 'c': case 'C': el_size = 1; break;
        case 's': case 'S': el_size = 2; break;
        case 'i': case 'I': case 'f': el_size = 4; break;
        case 'd': el_size = 8; break;
        default:
            hts_log_error("Unknown sub-type '%c' for array field", subtype);
            goto err;
        }
        
        // Check for integer overflow in multiplication and buffer overrun
        if (count > (UINT32_MAX / el_size) || aux_limit - aux < count * el_size)
            goto err;
        
        uint32_t byte_len = count * el_size;
        
        // Ensure we store subtype and size too
        BLOCK_APPEND_CHAR(tm->blk, subtype);
        BLOCK_APPEND(tm->blk, (char *)&count, 4);
        BLOCK_APPEND(tm->blk, aux, byte_len);
        
        aux += byte_len;
    }
    break;