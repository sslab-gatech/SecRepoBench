case 'Z': 
    // Case handlers for auxiliary fields of types 'H' and 'B' in BAM records.
    // Handles 'H' type (hexadecimal string) by creating a new block if necessary,
    // and encoding the data from the auxiliary fields.
    // For 'B' type (byte array), computes the length based on the sub-type and count,
    // allocates blocks as needed, and encodes the data.
    // Checks for sufficient data remaining in the auxiliary field buffer before processing.
    // Updates the auxiliary field pointer appropriately after encoding.
    // <MASK>
    case 'H': {
        // Handle 'H' type (hexadecimal string)
        if (aux_limit - aux < 3+1)
            goto err;

        if (!tm->blk) {
            if (!(tm->blk = cram_new_block(EXTERNAL, key)))
                goto err;
            codec->u.e_byte_array_len.val_codec->out = tm->blk;
        }

        // Convert hexadecimal string to byte array
        int len = 0;
        for (int i = 3; i < aux_limit; i++) {
            if (isxdigit(aux[i])) {
                len++;
            } else {
                break;
            }
        }

        if (len > 0) {
            uint8_t *data = malloc(len);
            if (!data)
                goto err;

            for (int i = 3, j = 0; i < aux_limit; i++) {
                if (isxdigit(aux[i])) {
                    data[j++] = hex2int(aux[i]);
                } else {
                    break;
                }
            }

            // Encode byte array
            BLOCK_APPEND(tm->blk, data, len);
            free(data);
        }

        aux += 3 + len;
        break;
    }
    case 'B': {
        // Handle 'B' type (byte array)
        if (aux_limit - aux < 3+1)
            goto err;

        if (!tm->blk) {
            if (!(tm->blk = cram_new_block(EXTERNAL, key)))
                goto err;
            codec->u.e_byte_array_len.val_codec->out = tm->blk;
        }

        // Compute length based on sub-type and count
        int len = 0;
        switch(aux[2]) {
        case 'A': case 'C': case 'c':
            len = 1;
            break;
        case 'S': case's':
            len = 2;
            break;
        case 'I': case 'i': case 'f':
            len = 4;
            break;
        default:
            hts_log_error("Unsupported SAM aux type '%c'", aux[2]);
            goto err;
        }

        // Encode byte array
        BLOCK_APPEND(tm->blk, aux + 3, len);
        aux += 3 + len;
        break;
    }
    default:
        hts_log_error("Unknown aux type '%c'", aux_limit - aux < 2? '?' : aux[2]);
        goto err;