case 'Z': case 'H':
    {
        char *s = aux+3;
        int slen = 0;
        
        // Find null termination
        while (s < aux_limit && *s)
            s++, slen++;
        if (s >= aux_limit)
            goto err;
        slen++; // include termination
        
        if (!tm->blk) {
            if (!(tm->blk = cram_new_block(EXTERNAL, key)))
                goto err;
            codec->u.e_byte_array_len.val_codec->out = tm->blk;
        }
        
        aux += 3;
        //codec->encode(s, codec, aux, slen);
        BLOCK_APPEND(tm->blk, aux, slen);
        aux += slen;
        break;
    }
    
case 'B':
    {
        int type = aux[3], blen;
        uint32_t count = 0;
        
        if (aux_limit - aux < 8)
            goto err;
        
        count = le_to_u32((uint8_t *)aux+4);
        
        switch (type) {
        case 'c': case 'C': 
            blen = count;
            break;
        case 's': case 'S':
            blen = 2 * count;
            break;
        case 'i': case 'I': case 'f':
            blen = 4 * count;
            break;
        default:
            hts_log_error("Unknown aux type '%c'", type);
            goto err;
        }
        
        if (aux_limit - aux < 8 + blen)
            goto err;
        
        if (!tm->blk) {
            if (!(tm->blk = cram_new_block(EXTERNAL, key)))
                goto err;
            codec->u.e_byte_array_len.val_codec->out = tm->blk;
        }
        
        aux += 3;
        //codec->encode(s, codec, aux, blen+5);
        BLOCK_APPEND(tm->blk, aux, blen+5);
        aux += blen+5;
        break;
    }