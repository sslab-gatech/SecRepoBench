case 'H':
            if (aux_limit - aux < 3+1)
                goto err;

            if (!tm->blk) {
                if (!(tm->blk = cram_new_block(EXTERNAL, key)))
                    goto err;
                codec->u.e_byte_array_len.val_codec->out = tm->blk;
            }

            aux+=3;
            BLOCK_APPEND(tm->blk, aux, orig + aux_size - aux);
            aux = orig + aux_size;
            break;

        case 'B': {
            if (aux_limit - aux < 3+5)
                goto err;

            uint8_t type = aux[3];
            int32_t count;
            memcpy(&count, aux+4, 4);
            count = le32toh(count);

            int elem_size = 0;
            switch(type) {
            case 'c': case 'C': elem_size = 1; break;
            case 's': case 'S': elem_size = 2; break;
            case 'i': case 'I': case 'f': elem_size = 4; break;
            default:
                hts_log_error("Unsupported B aux type '%c'", type);
                goto err;
            }

            if (aux_limit - aux < 3+5+count*elem_size)
                goto err;

            if (!tm->blk) {
                if (!(tm->blk = cram_new_block(EXTERNAL, key)))
                    goto err;
                codec->u.e_byte_array_len.val_codec->out = tm->blk;
            }

            aux+=3;
            BLOCK_APPEND(tm->blk, aux, 5+count*elem_size);
            aux += 5+count*elem_size;
            break;
        }