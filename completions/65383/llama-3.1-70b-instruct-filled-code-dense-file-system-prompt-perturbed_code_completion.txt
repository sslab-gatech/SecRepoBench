i = 0;

            k = kh_put(map, h->preservation_map, "MI", &r);
            if (-1 == r) return NULL;
            kh_val(h->preservation_map, k).i = 0;
        }

        k = kh_put(map, h->preservation_map, "AP", &r);
        if (-1 == r) return NULL;
        kh_val(h->preservation_map, k).i = c->AP_delta;

        k = kh_put(map, h->preservation_map, "RR", &r);
        if (-1 == r) return NULL;
        kh_val(h->preservation_map, k).i =!no_ref;

        k = kh_put(map, h->preservation_map, "QO", &r);
        if (-1 == r) return NULL;
        kh_val(h->preservation_map, k).i = c->qs_seq_orient;

        k = kh_put(map, h->preservation_map, "SM", &r);
        if (-1 == r) return NULL;
        kh_val(h->preservation_map, k).p = c->substitution_matrix;
    }

    // Tag dictionary
    if (c->comp_hdr->TD_blk) {
        kstring_t str = {0,0,0};
        int sz = cram_encode_TD(fd, c, &str);
        if (sz < 0) {
            free(str.s);
            return NULL;
        }
        r |= itf8_put_blk(cb, sz);
        r |= itf8_put_blk(cb, str.l);
        r |= itf8_put_blk(cb, str.s, str.l);
        free(str.s);
    }

    // Record encoding map
    mc = 0;
    for (i = 0; i < CRAM_MAP_HASH; i++) {
        cram_map *m = h->rec_encoding_map[i];
        while (m) {
            mc++;
            m = m->next;
        }
    }

    r |= itf8_put_blk(cb, mc);
    for (i = 0; i < CRAM_MAP_HASH; i++) {
        cram_map *m = h->rec_encoding_map[i];
        while (m) {
            r |= itf8_put_blk(cb, m->key);
            r |= itf8_put_blk(cb, m->encoding);
            r |= itf8_put_blk(cb, m->size);
            r |= itf8_put_blk(cb, m->offset);
            m = m->next;
        }
    }

    // Tag encoding map
    mc = 0;
    for (i = 0; i < CRAM_MAP_HASH; i++) {
        cram_map *m = h->tag_encoding_map[i];
        while (m) {
            mc++;
            m = m->next;
        }
    }

    r |= itf8_put_blk(cb, mc);
    for (i = 0; i < CRAM_MAP_HASH; i++) {
        cram_map *m = h->tag_encoding_map[i];
        while (m) {
            r |= itf8_put_blk(cb, m->key);
            r |= itf8_put_blk(cb, m->encoding);
            r |= itf8_put_blk(cb, m->size);
            r |= itf8_put_blk(cb, m->offset);
            m = m->next;
        }
    }

    // Now we know the size of the header, we can add this to the
    // compression header block.
    r |= itf8_put_blk(cb, BLOCK_SIZE(cb));

    // Copy the header into the compression header block
    r |= itf8_put_blk(cb, BLOCK_DATA(map), BLOCK_SIZE(map));

    // Copy the compression header block into the container block
    r |= itf8_put_blk(c->comp_hdr->block, BLOCK_DATA(cb), BLOCK_SIZE(cb));

    // Free the compression header block
    cram_free_block(cb);

    // Free the map block
    cram_free_block(map);

    return c->comp_hdr->block;
}

// the below code fragment can be found in:
// cram/cram_encode.c
static int cram_encode_TD(cram_fd *fd, cram_container *c, kstring_t *str) {
    int i, r = 0, new;
    khint_t k;

    if (c->comp_hdr->TD_blk) {
        kstring_t str = {0,0,0};
        r = itf8_put_blk(&str, c->comp_hdr->nTL);
        for (i = 0; i < c->comp_hdr->nTL; i++) {
            r |= itf8_put_blk(&str, c->comp_hdr->TL[i]);
        }
        if (r < 0) {
            free(str.s);
            return -1;
        }
        r = str.l;
        free(str.s);
    }

    return r;
}

// the below code fragment can be found in:
// cram/cram_encode.c
static int cram_encode_compression_header(cram_fd *fd, cram_container *c,
                                         cram_block_compression_hdr *h,
                                         int embed_ref) {
    cram_block *cb  = cram_new_block(COMPRESSION_HEADER, 0);
    cram_block *map = cram_new_block(COMPRESSION_HEADER, 0);
    int i, mc, r = 0;

    int no_ref = c->no_ref;

    if (!cb ||!map)
        return NULL;

    /*
     * This is a concatenation of several blocks of data:
     * header + landmarks, preservation map, read encoding map, and the tag
     * encoding map.
     * All 4 are variable sized and we need to know how large these are
     * before creating the compression header itself as this starts with
     * the total size (stored as a variable length string).
     */

    // Duplicated from container itself, and removed in 1.1
    if (CRAM_MAJOR_VERS(fd->version) == 1) {
        r |= itf8_put_blk(cb, h->ref_seq_id);
        r |= itf8_put_blk(cb, h->ref_seq_start);
        r |= itf8_put_blk(cb, h->ref_seq_span);
        r |= itf8_put_blk(cb, h->num_records);
        r |= itf8_put_blk(cb, h->num_landmarks);
        for (i = 0; i < h->num_landmarks; i++) {
            r |= itf8_put_blk(cb, h->landmark[i]);
        }
    }

    if (h->preservation_map) {
        kh_destroy(map, h->preservation_map);
        h->preservation_map = NULL;
    }

    /* Create in-memory preservation map */
    /* FIXME: should create this when we create the container */
    if (c->num_records > 0) {
        khint_t k;
        int r;

        if (!(h->preservation_map = kh_init(map)))
            return NULL;

        k = kh_put(map, h->preservation_map, "RN", &r);
        if (-1 == r) return NULL;
        kh_val(h->preservation_map, k).i =!fd->lossy_read_names;

        if (CRAM_MAJOR_VERS(fd->version) == 1) {
            k = kh_put(map, h->preservation_map, "PI", &r);
            if (-1 == r) return NULL;
            kh_val(h->preservation_map, k).i = 0;

            k = kh_put(map, h->preservation_map, "UI", &r);
            if (-1 == r) return NULL;
            kh_val(h->preservation_map, k).i = 0;

            k = kh_put(map, h->preservation_map, "MI", &r);
            if (-1 == r) return NULL;
            kh_val(h->preservation_map, k).i = 0;
        }

        k = kh_put(map, h->preservation_map, "AP", &r);
        if (-1 == r) return NULL;
        kh_val(h->preservation_map, k).i = c->AP_delta;

        k = kh_put(map, h->preservation_map, "RR", &r);
        if (-1 == r) return NULL;
        kh_val(h->preservation_map, k).i =!no_ref;

        k = kh_put(map, h->preservation_map, "QO", &r);
        if (-1 == r) return NULL;
        kh_val(h->preservation_map, k).i = c->qs_seq_orient;

        k = kh_put(map, h->preservation_map, "SM", &r);
        if (-1 == r) return NULL;
        kh_val(h->preservation_map, k).p = c->substitution_matrix;
    }

    // Tag dictionary
    if (c->comp_hdr->TD_blk) {
        kstring_t str = {0,0,0};
        int sz = cram_encode_TD(fd, c, &str);
        if (sz < 0) {
            free(str.s);
            return -1;
        }
        r = itf8_put_blk(cb, sz);
        r |= itf8_put_blk(cb, str.l);
        r |= itf8_put_blk(cb, str.s, str.l);
        free(str.s);
    }

    // Record encoding map
    mc = 0;
    for (i = 0; i < CRAM_MAP_HASH; i++) {
        cram_map *m = h->rec_encoding_map[i];
        while (m) {
            mc++;
            m = m->next;
        }
    }

    r |= itf8_put_blk(cb, mc);
    for (i = 0; i < CRAM_MAP_HASH; i++) {
        cram_map *m = h->rec_encoding_map[i];
        while (m) {
            r |= itf8_put_blk(cb, m->key);
            r |= itf8_put_blk(cb, m->encoding);
            r |= itf8_put_blk(cb, m->size);
            r |= itf8_put_blk(cb, m->offset);
            m = m->next;
        }
    }

    // Tag encoding map
    mc = 0;
    for (i = 0; i < CRAM_MAP_HASH; i++) {
        cram_map *m = h->tag_encoding_map[i];
        while (m) {
            mc++;
            m = m->next;
        }
    }

    r |= itf8_put_blk(cb, mc);
    for (i = 0; i < CRAM_MAP_HASH; i++) {
        cram_map *m = h->tag_encoding_map[i];
        while (m) {
            r |= itf8_put_blk(cb, m->key);
            r |= itf8_put_blk(cb, m->encoding);
            r |= itf8_put_blk(cb, m->size);
            r |= itf8_put_blk(cb, m->offset);
            m = m->next;
        }
    }

    // Now we know the size of the header, we can add this to the
    // compression header block.
    r |= itf8_put_blk(cb, BLOCK_SIZE(cb));

    // Copy the header into the compression header block
    r |= itf8_put_blk(cb, BLOCK_DATA(map), BLOCK_SIZE(map));

    // Copy the compression header block into the container block
    r |= itf8_put_blk(c->comp_hdr->block, BLOCK_DATA(cb), BLOCK_SIZE(cb));

    // Free the compression header block
    cram_free_block(cb);

    // Free the map block
    cram_free_block(map);

    return c->comp_hdr->block;
}

// the below code fragment can be found in:
// cram/cram_encode.c
static int cram_encode_compression_header(cram_fd *fd, cram_container *c,
                                         cram_block_compression_hdr *h,
                                         int embed_ref) {
    cram_block *cb  = cram_new_block(COMPRESSION_HEADER, 0);
    cram_block *map = cram_new_block(COMPRESSION_HEADER, 0);
    int i, mc, r = 0;

    int no_ref = c->no_ref;

    if (!cb ||!map)
        return NULL;

    /*
     * This is a concatenation of several blocks of data:
     * header + landmarks, preservation map, read encoding map, and the tag
     * encoding map.
     * All 4 are variable sized and we need to know how large these are
     * before creating the compression header itself as this starts with
     * the total size (stored as a variable length string).
     */

    // Duplicated from container itself, and removed in 1.1
    if (CRAM_MAJOR_VERS(fd->version) == 1) {
        r |= itf8_put_blk(cb, h->ref_seq_id);
        r |= itf8_put_blk(cb, h->ref_seq_start);
        r |= itf8_put_blk(cb, h->ref_seq_span);
        r |= itf8_put_blk(cb, h->num_records);
        r |= itf8_put_blk(cb, h->num_landmarks);
        for (i = 0; i < h->num_landmarks; i++) {
            r |= itf8_put_blk(cb, h->landmark[i]);
        }
    }

    if (h->preservation_map) {
        kh_destroy(map, h->preservation_map);
        h->preservation_map = NULL;
    }

    /* Create in-memory preservation map */
    /* FIXME: should create this when we create the container */
    if (c->num_records > 0) {
        khint_t k;
        int r;

        if (!(h->preservation_map = kh_init(map)))
            return NULL;

        k = kh_put(map, h->preservation_map, "RN", &r);
        if (-1 == r) return NULL;
        kh_val(h->preservation_map, k).i =!fd->lossy_read_names;

        if (CRAM_MAJOR_VERS(fd->version) == 1) {
            k = kh_put(map, h->preservation_map, "PI", &r);
            if (-1 == r) return NULL;
            kh_val(h->preservation_map, k).i = 0;

            k = kh_put(map, h->preservation_map, "UI", &r);
            if (-1 == r) return NULL;
            kh_val(h->pres