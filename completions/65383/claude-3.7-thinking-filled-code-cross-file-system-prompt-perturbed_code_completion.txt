case 'Z': case 'H':
    if (aux_limit - aux < 4)
        goto err;

    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto err;
        codec->u.e_byte_array_len.val_codec->out = tm->blk;
    }

    aux += 3;
    {
        char *s = aux;
        while (aux < aux_limit && *aux)
            aux++;
        
        if (aux >= aux_limit)
            goto err;
        
        BLOCK_APPEND(tm->blk, s, aux-s+1);
        aux++; // Move past NUL
    }
    break;

case 'B':
    if (aux_limit - aux < 8)
        goto err;
    
    {
        uint32_t count;
        int sub_type = aux[3];
        int element_size;
        
        // Determine element size based on subtype
        switch (sub_type) {
        case 'c': case 'C': element_size = 1; break;
        case 's': case 'S': element_size = 2; break;
        case 'i': case 'I': case 'f': element_size = 4; break;
        case 'd': element_size = 8; break;
        default: 
            hts_log_error("Unknown B sub-type '%c'", sub_type);
            goto err;
        }
        
        memcpy(&count, aux+4, 4);
        
        if (aux_limit - aux < 8 + element_size * count)
            goto err;
        
        if (!tm->blk) {
            if (!(tm->blk = cram_new_block(EXTERNAL, key)))
                goto err;
            codec->u.e_byte_array_len.val_codec->out = tm->blk;
        }
        
        aux += 3; // Skip tag type
        BLOCK_APPEND(tm->blk, aux, element_size * count + 5);
        aux += element_size * count + 5;
    }
    break;