case 'Z':
case 'H': {
    /* Ensure there's a terminating NULL within the remaining buffer */
    char *end = memchr(aux + 3, 0, aux_limit - (aux + 3));
    if (!end)
        goto err;

    /* Calculate the length of the string including the NULL terminator */
    size_t len = end - (aux + 3) + 1;

    /* If needed, allocate a new block for this tag */
    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto err;
        codec->u.e_byte_array_len.val_codec->out = tm->blk;
    }

    /* Append the string (with terminator) to the block */
    BLOCK_APPEND(tm->blk, aux + 3, len);

    /* Advance the pointer */
    aux += 3 + len;
    break;
}

case 'B': {
    /* Check we have enough room for: code[3], subtype[1], count[4] */
    if (aux_limit - aux < 3 + 1 + 4)
        goto err;

    /* Allocate block if needed */
    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto err;
        codec->u.e_byte_array_len.val_codec->out = tm->blk;
    }

    /* Parse subtype and number of elements */
    char sub_type = aux[3];
    int32_t count = ((uint8_t)aux[4]) | ((uint8_t)aux[5] << 8) |
                    ((uint8_t)aux[6] << 16) | ((uint8_t)aux[7] << 24);

    /* Determine element size for the given subtype */
    int element_size;
    switch (sub_type) {
    case 'c': case 'C':
        element_size = 1;
        break;
    case 's': case 'S':
        element_size = 2;
        break;
    case 'i': case 'I': case 'f':
        element_size = 4;
        break;
    case 'd':
        element_size = 8;
        break;
    default:
        hts_log_error("Unknown sub-type '%c' for 'B' tag", sub_type);
        goto err;
    }

    /* Check buffer for required elements */
    size_t needed = 3 + 1 + 4 + (size_t)count * element_size;
    if (aux_limit - aux < (ptrdiff_t)needed)
        goto err;

    /* Append subtype + 4-byte count + data */
    BLOCK_APPEND(tm->blk, aux + 3, needed - 3);

    /* Advance pointer */
    aux += needed;
    break;
}