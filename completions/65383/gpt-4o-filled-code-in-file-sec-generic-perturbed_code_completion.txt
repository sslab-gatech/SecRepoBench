case 'H': {
            // string as byte_array_stop
            if (!tm->blk) {
                if (!(tm->blk = cram_new_block(EXTERNAL, key)))
                    goto err;
                codec->u.e_byte_array_stop.content_id = key;
                codec->out = tm->blk;
            }

            aux += 3;
            while (aux < aux_limit && *aux) {
                BLOCK_APPEND_CHAR(tm->blk, *aux);
                aux++;
            }
            BLOCK_APPEND_CHAR(tm->blk, 0);
            aux++;
            break;
        }

        case 'B': {
            // Byte array
            int32_t count;
            int type = aux[3];
            int sub_type_size;

            switch (type) {
            case 'c': case 'C': case 'A':
                sub_type_size = 1;
                break;
            case 's': case 'S':
                sub_type_size = 2;
                break;
            case 'i': case 'I': case 'f':
                sub_type_size = 4;
                break;
            default:
                hts_log_error("Unknown sub-type '%c' for aux type 'B'", type);
                goto err;
            }

            if (aux_limit - aux < 3 + 1 + 4)
                goto err;

            if (!tm->blk) {
                if (!(tm->blk = cram_new_block(EXTERNAL, key)))
                    goto err;
                codec->u.e_byte_array_len.val_codec->out = tm->blk;
            }

            aux += 3;
            BLOCK_APPEND_CHAR(tm->blk, *aux); // sub-type
            aux++;

            count = le_to_i32(aux);
            aux += 4;

            if (aux_limit - aux < count * sub_type_size)
                goto err;

            BLOCK_APPEND(tm->blk, aux, count * sub_type_size);
            aux += count * sub_type_size;
            break;
        }