case 'H':
    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto err;
        codec->u.e_byte_array_len.val_codec->out = tm->blk;
    }

    aux += 3;
    while (aux < aux_limit && *aux)
        BLOCK_APPEND_CHAR(tm->blk, *aux++);
    if (aux >= aux_limit)
        goto err;
    BLOCK_APPEND_CHAR(tm->blk, *aux++);
    break;

case 'B': {
    int type = aux[3], blen;
    uint32_t count = (uint32_t)((((unsigned char *)aux)[4]<< 0) +
                                (((unsigned char *)aux)[5]<< 8) +
                                (((unsigned char *)aux)[6]<<16) +
                                (((unsigned char *)aux)[7]<<24));

    if (aux_limit - aux < 8)
        goto err;

    switch (type) {
    case 'c': case 'C':
        blen = count;
        break;
    case 's': case 'S':
        blen = 2*count;
        break;
    case 'i': case 'I': case 'f':
        blen = 4*count;
        break;
    default:
        hts_log_error("Unknown aux 'B' type '%c'", type);
        return NULL;
    }

    if (aux_limit - aux - 8 < blen)
        goto err;

    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto err;
        codec->u.e_byte_array_len.val_codec->out = tm->blk;
    }

    BLOCK_APPEND(tm->blk, aux+3, blen+5);
    aux += 8 + blen;
    break;
}

case 'Z':
    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto err;
        codec->u.e_byte_array_len.val_codec->out = tm->blk;
    }

    aux += 3;
    while (aux < aux_limit && *aux)
        BLOCK_APPEND_CHAR(tm->blk, *aux++);
    if (aux >= aux_limit)
        goto err;
    BLOCK_APPEND_CHAR(tm->blk, *aux++);
    break;