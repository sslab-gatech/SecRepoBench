case 'H': 
    if (aux_limit - aux < 3+1) // Minimum length check
        goto err;

    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto err;
        codec->u.e_byte_array_len.val_codec->out = tm->blk;
    }

    aux += 3; // Skip the tag identifier
    int len = strlen(aux); // Calculate the length of the hexadecimal string
    BLOCK_APPEND(tm->blk, aux, len); // Append the string to the block
    aux += len; // Update the auxiliary field pointer
    break;

case 'B': 
    if (aux_limit - aux < 6) // Ensure sufficient data for type and count
        goto err;

    char sub_type = *aux++; // Read subtype
    int count = bam_aux2i((const uint8_t *)aux, (const uint8_t *)aux_limit); // Get count
    aux += 4; // Move past the count

    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto err;
        codec->u.e_byte_array_len.val_codec->out = tm->blk;
    }

    switch(sub_type) {
        case 'c': case 'C':
            if (aux_limit - aux < count)
                goto err;
            BLOCK_APPEND(tm->blk, aux, count);
            aux += count;
            break;
        case 's': case 'S':
            if (aux_limit - aux < count*2)
                goto err;
            BLOCK_APPEND(tm->blk, aux, count*2);
            aux += count*2;
            break;
        case 'i': case 'I': case 'f':
            if (aux_limit - aux < count*4)
                goto err;
            BLOCK_APPEND(tm->blk, aux, count*4);
            aux += count*4;
            break;
        default:
            hts_log_error("Unsupported BAM aux type '%c' in B array", sub_type);
            goto err;
    }
    break;