switch(aux[2]) {
case 'Z':
case 'H':
    // Handle 'Z' and 'H' type auxiliary fields
    {
        char *zptr = aux + 3;
        while (aux_limit - zptr > 0 && *zptr != '\0') {
            zptr++;
        }
        if (aux_limit - zptr < 0) {
            hts_log_error("Malformed 'Z' or 'H' type auxiliary field");
            goto err;
        }
        BLOCK_APPEND(tm->blk, aux + 3, zptr - (aux + 3) + 1);
        aux = zptr + 1;
    }
    break;

case 'B':
    // Handle 'B' type auxiliary fields
    {
        char sub_type = aux[3];
        int32_t count = bam_aux_len((uint8_t *)aux) - 2;
        int elem_size = 0;
        switch (sub_type) {
        case 'c': case 'C': elem_size = 1; break;
        case 's': case 'S': elem_size = 2; break;
        case 'i': case 'I': case 'f': elem_size = 4; break;
        case 'd': elem_size = 8; break;
        default:
            hts_log_error("Unknown 'B' sub-type '%c'", sub_type);
            goto err;
        }
        if (aux_limit - aux < 5 + count * elem_size) {
            hts_log_error("Malformed 'B' type auxiliary field");
            goto err;
        }
        BLOCK_APPEND(tm->blk, aux + 4, count * elem_size);
        aux += 5 + count * elem_size;
    }
    break;

default:
    hts_log_error("Unknown aux type '%c'", aux[2]);
    goto err;
}