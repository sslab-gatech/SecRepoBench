// <MASK>
// Codecs which are hard-coded to use the CORE block
case E_GOLOMB:
case E_HUFFMAN:
case E_BETA:
case E_SUBEXP:
case E_GOLOMB_RICE:
case E_GAMMA:
    codec->out = s->block[0];
    break;

// Codecs which don't use external blocks
case E_CONST_BYTE:
case E_CONST_INT:
    codec->out = NULL;
    break;

// Codecs that emit directly to external blocks
case E_EXTERNAL:
case E_VARINT_UNSIGNED:
case E_VARINT_SIGNED:
    if (!(s->block[ds_id] = cram_new_block(EXTERNAL, ds_id)))
        return -1;
    codec->u.external.content_id = ds_id;
    codec->out = s->block[ds_id];
    break;

case E_BYTE_ARRAY_STOP: // Why no sub-codec?
    if (!(s->block[ds_id] = cram_new_block(EXTERNAL, ds_id)))
        return -1;
    codec->u.byte_array_stop.content_id = ds_id;
    codec->out = s->block[ds_id];
    break;

// Codecs that contain sub-codecs which may in turn emit to external blocks
case E_BYTE_ARRAY_LEN: {
    cram_codec *bal = codec->u.e_byte_array_len.len_codec;
    if (cram_allocate_block(bal, s, bal->u.external.content_id))
        return -1;
    bal = codec->u.e_byte_array_len.val_codec;
    if (cram_allocate_block(bal, s, bal->u.external.content_id))
        return -1;

    break;
}

case E_XRLE:
    if (cram_allocate_block(codec->u.e_xrle.len_codec, s, ds_id))
        //ds_id == DS_QS? DS_QS_len : ds_id))
        return -1;
    if (cram_allocate_block(codec->u.e_xrle.lit_codec, s, ds_id))
        return -1;

    break;

case E_XPACK:
    if (cram_allocate_block(codec->u.e_xpack.sub_codec, s, ds_id))
        return -1;
    codec->out = cram_new_block(0, 0); // ephemeral
    if (!codec->out)
        return -1;

    break;

case E_XDELTA:
    if (cram_allocate_block(codec->u.e_xdelta.sub_codec, s, ds_id))
        return -1;
    codec->out = cram_new_block(0, 0); // ephemeral
    if (!codec->out)
        return -1;

    break;

default:
    break;
}
// </MASK>