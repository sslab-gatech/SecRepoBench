case 'H':
    if (aux_limit - aux < 3+1)
        goto err;

    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto err;
        codec->u.e_byte_array_len.val_codec->out = tm->blk;
    }

    aux+=3;
    // Find the length of the hex string
    int hex_len = 0;
    while (aux < aux_limit && aux[hex_len] != '\0')
        hex_len++;

    // Hex string length must be even
    if (hex_len % 2 != 0) {
        hts_log_error("Invalid hex string length for tag 'H'");
        goto err;
    }

    // Convert hex string to binary data
    int bin_len = hex_len / 2;
    unsigned char *bin_data = malloc(bin_len);
    if (!bin_data)
        goto err;

    for (int i = 0; i < bin_len; i++) {
        if (sscanf((const char *)(aux + 2*i), "%2hhx", &bin_data[i]) != 1) {
            free(bin_data);
            hts_log_error("Invalid hex string for tag 'H'");
            goto err;
        }
    }

    BLOCK_APPEND(tm->blk, (char *)bin_data, bin_len);
    free(bin_data);
    aux += hex_len + 1; // Move past the hex string and the null terminator
    break;

case 'B':
    if (aux_limit - aux < 3+5)
        goto err;

    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto err;
        codec->u.e_byte_array_len.val_codec->out = tm->blk;
    }

    aux+=3;
    char subtype = *aux++;
    int32_t count = bam_aux2i_end((uint8_t *)aux, (uint8_t *)aux_limit);
    aux+=4;

    int element_size = 0;
    switch(subtype) {
        case 'c': case 'C': element_size = 1; break;
        case 's': case 'S': element_size = 2; break;
        case 'i': case 'I': case 'f': element_size = 4; break;
        case 'd': element_size = 8; break;
        default:
            hts_log_error("Unsupported subtype '%c' for B-type tag", subtype);
            goto err;
    }

    if (aux_limit - aux < count * element_size)
        goto err;

    BLOCK_APPEND(tm->blk, (char *)aux, count * element_size);
    aux += count * element_size;
    break;