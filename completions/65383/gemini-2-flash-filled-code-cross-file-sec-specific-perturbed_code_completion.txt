case 'H': {
            if (aux_limit - aux < 3+1)
                goto err;

            if (!tm->blk) {
                if (!(tm->blk = cram_new_block(EXTERNAL, key)))
                    goto err;
                codec->u.e_byte_array_len.val_codec->out = tm->blk;
            }

            aux+=3;
            size_t len = 0;
            while (aux + len < aux_limit && isxdigit(aux[len])) {
                len++;
            }

            if (aux + len > aux_limit) {
                goto err;
            }

            if (len % 2 != 0) {
                hts_log_error("Hex string has odd length");
                goto err;
            }

            if (len > 0) {
                BLOCK_APPEND(tm->blk, aux, len);
            }
            aux += len;
            break;
        }

        case 'B': {
            char type = aux[3];
            int32_t count;
            size_t data_size = 0;

            if (aux_limit - aux < 5)
                goto err;

            aux += 4;
            count = bam_aux2i_end((uint8_t *)aux, (uint8_t *)aux_limit);

            switch (type) {
                case 'c': data_size = count * sizeof(int8_t); break;
                case 'C': data_size = count * sizeof(uint8_t); break;
                case 's': data_size = count * sizeof(int16_t); break;
                case 'S': data_size = count * sizeof(uint16_t); break;
                case 'i': data_size = count * sizeof(int32_t); break;
                case 'I': data_size = count * sizeof(uint32_t); break;
                case 'f': data_size = count * sizeof(float); break;
                default:
                    hts_log_error("Unsupported 'B' array type '%c'", type);
                    goto err;
            }

            if (aux_limit - aux < 4)
                goto err;

            // Check for integer overflow
            if (data_size / count != sizeof(int32_t)) {
                hts_log_error("Integer overflow calculating data size");
                goto err;
            }

            if ((size_t)(aux - (char*)bam_aux(b)) + 5 + data_size > (size_t)aux_size) {
                hts_log_error("Insufficient data remaining for 'B' array");
                goto err;
            }

            if (!tm->blk) {
                if (!(tm->blk = cram_new_block(EXTERNAL, key)))
                    goto err;
                codec->u.e_byte_array_len.val_codec->out = tm->blk;
            }

            aux += 4;
            BLOCK_APPEND(tm->blk, aux, data_size);
            aux += data_size;
            break;
        }