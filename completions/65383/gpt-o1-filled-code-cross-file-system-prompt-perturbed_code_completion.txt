case 'Z':
case 'H': {
    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto err;
        codec->u.e_byte_array_len.val_codec->out = tm->blk;
    }

    aux += 3; // skip tag name & type
    char *end = memchr(aux, 0, aux_limit - aux);
    if (!end)
        goto err;
    int len = end - aux + 1; // include trailing '\0'
    BLOCK_APPEND(tm->blk, aux, len);
    aux += len;
    break;
}

case 'B': {
    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto err;
        codec->u.e_byte_array_len.val_codec->out = tm->blk;
    }

    aux += 3; // skip tag name & type
    if (aux_limit - aux < 5)
        goto err; // need subtype+count

    BLOCK_APPEND(tm->blk, aux, 5);
    char sub = aux[0];
    int count = (aux[1] & 0xff)
              | ((aux[2] & 0xff) << 8)
              | ((aux[3] & 0xff) << 16)
              | ((aux[4] & 0xff) << 24);
    aux += 5;

    int item_size;
    switch (sub) {
    case 'c': case 'C': case 'A': item_size = 1; break;
    case 's': case 'S':          item_size = 2; break;
    case 'i': case 'I': case 'f': item_size = 4; break;
    case 'd':                    item_size = 8; break;
    default:
        hts_log_error("Unknown subtype '%c' for 'B' tag", sub);
        goto err;
    }

    int data_size = item_size * count;
    if (aux_limit - aux < data_size)
        goto err;

    BLOCK_APPEND(tm->blk, aux, data_size);
    aux += data_size;
    break;
}