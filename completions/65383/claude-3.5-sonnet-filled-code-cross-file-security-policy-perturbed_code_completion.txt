case 'Z': case 'H':
    if (aux_limit - aux < 3)
        goto err;

    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto err;
        codec->u.e_byte_array_len.val_codec->out = tm->blk;
    }

    aux += 3;
    while (aux < aux_limit && *aux) {
        BLOCK_APPEND_CHAR(tm->blk, *aux);
        aux++;
    }
    if (aux >= aux_limit)
        goto err;
    BLOCK_APPEND_CHAR(tm->blk, *aux);
    aux++;
    break;

case 'B':
    if (aux_limit - aux < 5)
        goto err;

    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto err;
        codec->u.e_byte_array_len.val_codec->out = tm->blk;
    }

    {
        int type = aux[3], nel = le_to_u32(&aux[4]);
        int i, sz;

        switch (type) {
        case 'c': case 'C': sz = 1; break;
        case 's': case 'S': sz = 2; break;
        case 'i': case 'I': case 'f': sz = 4; break;
        default: goto err;
        }

        if (aux_limit - aux < 8 + nel * sz)
            goto err;

        // We use BLOCK_APPEND_CHAR here as it's equivalent to
        // block_append_char, inlined, and allows for better optimisation.
        BLOCK_APPEND_CHAR(tm->blk, aux[0]);
        BLOCK_APPEND_CHAR(tm->blk, aux[1]);
        BLOCK_APPEND_CHAR(tm->blk, aux[2]);
        BLOCK_APPEND_CHAR(tm->blk, aux[3]);
        BLOCK_APPEND(tm->blk, &aux[4], 4);
        BLOCK_APPEND(tm->blk, &aux[8], nel * sz);
        aux += 8 + nel * sz;
    }
    break;