case 'H':
            if (aux_limit - aux < 3+1)
                goto err;

            if (!tm->blk) {
                if (!(tm->blk = cram_new_block(EXTERNAL, key)))
                    goto err;
                codec->u.e_byte_array_len.val_codec->out = tm->blk;
            }

            aux+=3;
            {
                char *hex = aux;
                while (hex < aux_limit && isxdigit(*hex))
                    hex++;
                if (hex == aux || (hex - aux) % 2 != 0) {
                    hts_log_error("Malformed hex string in H tag");
                    goto err;
                }
                BLOCK_APPEND(tm->blk, aux, hex - aux);
                aux = hex;
            }
            break;

        case 'B': {
            uint8_t sub_type = ((unsigned char *)aux)[3];
            int32_t count;
            size_t len;

            if (aux_limit - aux < 5)
                goto err;

            count = bam_aux2i_end((uint8_t *)aux+4, (uint8_t *)aux_limit);

            switch (sub_type) {
            case 'c': len = count; break;
            case 'C': len = count * 1; break;
            case 's': len = count * 2; break;
            case 'S': len = count * 2; break;
            case 'i': len = count * 4; break;
            case 'I': len = count * 4; break;
            case 'f': len = count * 4; break;
            default:
                hts_log_error("Unknown sub-type '%c' for B tag", sub_type);
                goto err;
            }

            if (aux_limit - aux < 5 + (len > INT32_MAX ? INT32_MAX : (int32_t)len))
                goto err;

            if (!tm->blk) {
                if (!(tm->blk = cram_new_block(EXTERNAL, key)))
                    goto err;
                codec->u.e_byte_array_len.val_codec->out = tm->blk;
            }

            aux+=4;
            BLOCK_APPEND_CHAR(tm->blk, sub_type);
            aux+=4;
            BLOCK_APPEND(tm->blk, (char *)&count, 4);
            BLOCK_APPEND(tm->blk, aux, len);
            aux += len;
            break;
        }