case 'H': 
    if (aux_limit - aux < 3+1)
        goto err;

    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto err;
        codec->u.e_byte_array_len.val_codec->out = tm->blk;
    }

    aux+=3;
    //codec->encode(s, codec, aux, strlen(aux)+1);
    BLOCK_APPEND(tm->blk, aux, strlen(aux)+1);
    aux += strlen(aux)+1;
    break;

case 'B': {
    if (aux_limit - aux < 6)
        goto err;

    char sub_type = *aux++;
    int count = bam_aux2i_end((uint8_t *)aux, (uint8_t *)aux_limit);
    aux += 4;

    switch(sub_type) {
    case 'c': case 'C':
        if (aux_limit - aux < count)
            goto err;

        if (!tm->blk) {
            if (!(tm->blk = cram_new_block(EXTERNAL, key)))
                goto err;
            codec->u.e_byte_array_len.val_codec->out = tm->blk;
        }

        BLOCK_APPEND(tm->blk, aux, count);
        aux += count;
        break;

    case 's': case 'S':
        if (aux_limit - aux < count*2)
            goto err;

        if (!tm->blk) {
            if (!(tm->blk = cram_new_block(EXTERNAL, key)))
                goto err;
            codec->u.e_byte_array_len.val_codec->out = tm->blk;
        }

        BLOCK_APPEND(tm->blk, aux, count*2);
        aux += count*2;
        break;

    case 'i': case 'I': case 'f':
        if (aux_limit - aux < count*4)
            goto err;

        if (!tm->blk) {
            if (!(tm->blk = cram_new_block(EXTERNAL, key)))
                goto err;
            codec->u.e_byte_array_len.val_codec->out = tm->blk;
        }

        BLOCK_APPEND(tm->blk, aux, count*4);
        aux += count*4;
        break;

    default:
        hts_log_error("Unsupported sub-type '%c' for B array", sub_type);
        goto err;
    }
    break;
}