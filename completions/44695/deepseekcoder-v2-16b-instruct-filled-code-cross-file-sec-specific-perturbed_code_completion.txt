int64_t fracpart = 0;
int64_t exppart = 0;
int exp_sign = 1;
int exp_num_digits = 0;
bool is_float = false;

const char* endp_float = (char*)str_val;
int64_t intpart = parse_decimal(str_val, str_end, &endp_float);

if (endp_float != str_val && *endp_float == '.') {
    endp_float++;
    fracpart = parse_decimal(endp_float, str_end, &endp_float);
    is_float = true;
}

if (endp_float != str_val && (*endp_float == 'e' || *endp_float == 'E')) {
    endp_float++;
    if (*endp_float == '-') {
        exp_sign = -1;
        endp_float++;
    } else if (*endp_float == '+') {
        endp_float++;
    }
    while (isdigit(*endp_float)) {
        exppart = exppart * 10 + (*endp_float - '0');
        endp_float++;
        exp_num_digits++;
    }
    if (exp_num_digits == 0) {
        PLIST_JSON_ERR("%s: invalid exponent\n", __func__);
        return NULL;
    }
    exppart *= exp_sign;
}

if (is_float) {
    double float_val = intpart;
    if (fracpart != 0) {
        float_val += (double)fracpart / (1LL << (8 * sizeof(fracpart)));
    }
    if (exppart != 0) {
        float_val *= pow(10, exppart);
    }
    primitivevalue = plist_new_real(float_val);
} else {
    if (fracpart != 0 || exppart != 0) {
        PLIST_JSON_ERR("%s: fractional or exponent part not allowed in integer\n", __func__);
        return NULL;
    }
    primitivevalue = plist_new_uint(intpart);
}