char *pos = endp;
        int is_real = 0;
        double realval = (double)intpart;

        /* Check for fractional part */
        if (pos < str_end && (*pos == '.')) {
            is_real = 1;
            pos++;
            const char *frac_start = pos;
            while ((pos < str_end) && isdigit((unsigned char)*pos)) {
                pos++;
            }
            if (pos == frac_start) {
                PLIST_JSON_ERR("%s: invalid fractional digits\n", __func__);
                return NULL;
            }
            double fraction = 0.0;
            for (const char *p = frac_start; p < pos; p++) {
                fraction = fraction * 10.0 + (*p - '0');
            }
            int frac_len = (int)(pos - frac_start);
            while (frac_len-- > 0) {
                fraction /= 10.0;
            }
            if (intpart < 0) {
                realval -= fraction;
            } else {
                realval += fraction;
            }
        }

        /* Check for exponent part */
        if (pos < str_end && (*pos == 'e' || *pos == 'E')) {
            is_real = 1;
            pos++;
            int exp_sign = 1;
            if (pos < str_end && (*pos == '+' || *pos == '-')) {
                if (*pos == '-') exp_sign = -1;
                pos++;
            }
            if (pos >= str_end || !isdigit((unsigned char)*pos)) {
                PLIST_JSON_ERR("%s: invalid exponent\n", __func__);
                return NULL;
            }
            int exponent = 0;
            while (pos < str_end && isdigit((unsigned char)*pos)) {
                exponent = exponent * 10 + (*pos - '0');
                pos++;
            }
            realval *= pow(10.0, exp_sign * exponent);
        }

        /* If there are unexpected characters left, error out */
        if (pos != str_end) {
            PLIST_JSON_ERR("%s: invalid numeric characters encountered\n", __func__);
            return NULL;
        }

        /* Create an integer or real plist node */
        if (is_real) {
            primitivevalue = plist_new_real(realval);
        } else {
            if (intpart < 0) {
                primitivevalue = plist_new_int(intpart);
            } else {
                primitivevalue = plist_new_uint((uint64_t)intpart);
            }
        }