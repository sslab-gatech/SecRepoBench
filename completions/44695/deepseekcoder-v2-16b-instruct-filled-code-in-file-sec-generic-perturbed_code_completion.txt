if (isdigit(str_val[0]) || (str_val[0] == '-' && str_val+1 < str_end && isdigit(str_val[1]))) {
    char* endp = (char*)str_val;
    int64_t intpart = parse_decimal(str_val, str_end, &endp);
    // Determine if the parsed numeric value is an integer or floating point.
    // If it's an integer, create a plist node for an unsigned integer.
    // If it's a floating point, convert and accumulate the fractional and exponent parts.
    // Create a plist node for a real number if the value is a valid floating point number.
    // Handle errors for invalid characters or unrepresentable floating point values.
    double realval = (double)intpart;
    size_t len = dtostr(NULL, 0, realval);
    if (len > 0 && str_val[0] == '-' && len < 64) {
        char* val = (char*)malloc(len + 1);
        if (val) {
            len = dtostr(val, len + 1, realval);
            plist_data_t data = plist_new_plist_data();
            data->type = PLIST_REAL;
            data->realval = atof(val);
            plist_t node = plist_new_node(data);
            free(val);
            return node;
        }
    } else if (len < 64) {
        char* val = (char*)malloc(len + 1);
        if (val) {
            len = dtostr(val, len + 1, realval);
            plist_data_t data = plist_new_plist_data();
            data->type = PLIST_REAL;
            data->realval = atof(val);
            plist_t node = plist_new_node(data);
            free(val);
            return node;
        }
    }
} else {
    PLIST_JSON_ERR("%s: invalid primitive value '%.*s' encountered\n", __func__, (int)str_len, str_val);
}