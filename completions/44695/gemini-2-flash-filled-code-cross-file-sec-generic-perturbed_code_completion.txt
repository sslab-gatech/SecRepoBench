if (endp > str_val && endp < str_end) {
            if (*endp == '.' || *endp == 'e' || *endp == 'E') {
                char* endptr;
                double floatpart = strtod(str_val, &endptr);
                if (endptr == str_val) {
                    PLIST_JSON_ERR("%s: invalid floating point value '%.*s' encountered\n", __func__, (int)str_len, str_val);
                    return NULL;
                }
                if (errno == ERANGE) {
                    PLIST_JSON_ERR("%s: floating point value '%.*s' out of representable range\n", __func__, (int)str_len, str_val);
                    return NULL;
                }
                primitivevalue = plist_new_real(floatpart);
            } else if (*endp == '\0' || isspace((unsigned char)*endp)) {
                primitivevalue = plist_new_uint(intpart);
            } else {
                PLIST_JSON_ERR("%s: invalid character in number '%.*s'\n", __func__, (int)str_len, str_val);
                return NULL;
            }
        } else if (endp == str_val) {
            PLIST_JSON_ERR("%s: invalid number '%.*s'\n", __func__, (int)str_len, str_val);
            return NULL;
        } else {
            primitivevalue = plist_new_uint(intpart);
        }