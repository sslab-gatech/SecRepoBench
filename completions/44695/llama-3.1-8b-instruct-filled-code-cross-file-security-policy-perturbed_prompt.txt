Below is the content of a C/C++ function where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
static plist_t parse_primitive(const char* js, jsmntok_info_t* ti, int* index)
{
    if (ti->tokens[*index].type != JSMN_PRIMITIVE) {
        PLIST_JSON_ERR("%s: token type != JSMN_PRIMITIVE\n", __func__);
        return NULL;
    }
    plist_t primitivevalue = NULL;
    const char* str_val = js + ti->tokens[*index].start;
    const char* str_end = js + ti->tokens[*index].end;
    size_t str_len = ti->tokens[*index].end - ti->tokens[*index].start;
    if (!strncmp("false", str_val, str_len)) {
        primitivevalue = plist_new_bool(0);
    } else if (!strncmp("true", str_val, str_len)) {
        primitivevalue = plist_new_bool(1);
    } else if (!strncmp("null", str_val, str_len)) {
        plist_data_t data = plist_new_plist_data();
        data->type = PLIST_NULL;
        primitivevalue = plist_new_node(data);
    } else if (isdigit(str_val[0]) || (str_val[0] == '-' && str_val+1 < str_end && isdigit(str_val[1]))) {
        char* endp = (char*)str_val;
        int64_t intpart = parse_decimal(str_val, str_end, &endp);
        // Determine if the parsed numeric value is an integer or floating point.
        // If it's an integer, create a plist node for an unsigned integer.
        // If it's a floating point, convert and accumulate the fractional and exponent parts.
        // Create a plist node for a real number if the value is a valid floating point number.
        // Handle errors for invalid characters or unrepresentable floating point values.
        // <MASK>
    } else {
        PLIST_JSON_ERR("%s: invalid primitive value '%.*s' encountered\n", __func__, (int)str_len, str_val);
    }
    (*index)++;
    return primitivevalue;
}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/jplist.c
static plist_t parse_array(const char* js, jsmntok_info_t* ti, int* index)
{
    if (ti->tokens[*index].type != JSMN_ARRAY) {
        PLIST_JSON_ERR("%s: token type != JSMN_ARRAY\n", __func__);
        return NULL;
    }
    plist_t arr = plist_new_array();
    int num_tokens = ti->tokens[*index].size;
    int num;
    int j = (*index)+1;
    for (num = 0; num < num_tokens; num++) {
        if (j >= ti->count) {
            PLIST_JSON_ERR("%s: token index out of valid range\n", __func__);
            plist_free(arr);
            return NULL;
        }
        plist_t val = NULL;
        switch (ti->tokens[j].type) {
            case JSMN_OBJECT:
                val = parse_object(js, ti, &j);
                break;
            case JSMN_ARRAY:
                val = parse_array(js, ti, &j);
                break;
            case JSMN_STRING:
                val = parse_string(js, ti, &j);
                break;
            case JSMN_PRIMITIVE:
                val = parse_primitive(js, ti, &j);
                break;
            default:
                break;
        }
        if (val) {
            plist_array_append_item(arr, val);
        } else {
            plist_free(arr);
            return NULL;
        }
    }
    *(index) = j;
    return arr;
}

// the below code fragment can be found in:
// src/jplist.c
PLIST_API int plist_from_json(const char *json, uint32_t length, plist_t * plist)
{
    if (!plist) {
        return PLIST_ERR_INVALID_ARG;
    }
    *plist = NULL;
    if (!json || (length == 0)) {
        return PLIST_ERR_INVALID_ARG;
    }

    jsmn_parser parser;
    jsmn_init(&parser);
    int maxtoks = 256;
    int curtoks = 0;
    int r = 0;
    jsmntok_t *tokens = NULL;

    do {
        jsmntok_t* newtokens = realloc(tokens, sizeof(jsmntok_t)*maxtoks);
        if (!newtokens) {
            PLIST_JSON_ERR("%s: Out of memory\n", __func__);
            return PLIST_ERR_NO_MEM;
        }
        memset((unsigned char*)newtokens + sizeof(jsmntok_t)*curtoks, '\0', sizeof(jsmntok_t)*(maxtoks-curtoks));
        tokens = newtokens;
        curtoks = maxtoks;

        r = jsmn_parse(&parser, json, length, tokens, maxtoks);
        if (r == JSMN_ERROR_NOMEM) {
            maxtoks+=16;
            continue;
        }
    } while (r == JSMN_ERROR_NOMEM);

    switch(r) {
        case JSMN_ERROR_NOMEM:
            PLIST_JSON_ERR("%s: Out of memory...\n", __func__);
            free(tokens);
            return PLIST_ERR_NO_MEM;
        case JSMN_ERROR_INVAL:
            PLIST_JSON_ERR("%s: Invalid character inside JSON string\n", __func__);
            free(tokens);
            return PLIST_ERR_PARSE;
        case JSMN_ERROR_PART:
            PLIST_JSON_ERR("%s: Incomplete JSON, more bytes expected\n", __func__);
            free(tokens);
            return PLIST_ERR_PARSE;
        default:
            break;
    }

    int startindex = 0;
    jsmntok_info_t ti = { tokens, parser.toknext };
    switch (tokens[startindex].type) {
        case JSMN_PRIMITIVE:
            *plist = parse_primitive(json, &ti, &startindex);
            break;
        case JSMN_STRING:
            *plist = parse_string(json, &ti, &startindex);
            break;
        case JSMN_ARRAY:
            *plist = parse_array(json, &ti, &startindex);
            break;
        case JSMN_OBJECT:
            *plist = parse_object(json, &ti, &startindex);
            break;
        default:
            break;
    }
    free(tokens);
    return PLIST_ERR_SUCCESS;
}

// the below code fragment can be found in:
// src/jplist.c
static plist_t parse_object(const char* js, jsmntok_info_t* ti, int* index)
{
    if (ti->tokens[*index].type != JSMN_OBJECT) {
        PLIST_JSON_ERR("%s: token type != JSMN_OBJECT\n", __func__);
        return NULL;
    }
    int num_tokens = ti->tokens[*index].size;
    int num;
    int j = (*index)+1;
    if (num_tokens % 2 != 0) {
        PLIST_JSON_ERR("%s: number of children must be even\n", __func__);
        return NULL;
    }
    plist_t obj = plist_new_dict();
    for (num = 0; num < num_tokens; num++) {
        if (j+1 >= ti->count) {
            PLIST_JSON_ERR("%s: token index out of valid range\n", __func__);
            plist_free(obj);
            return NULL;
        }
        if (ti->tokens[j].type == JSMN_STRING) {
            char* key = unescape_string(js + ti->tokens[j].start, ti->tokens[j].end - ti->tokens[j].start, NULL);
            if (!key) {
                plist_free(obj);
                return NULL;
            }
            plist_t val = NULL;
            j++;
            num++;
            switch (ti->tokens[j].type) {
                case JSMN_OBJECT:
                    val = parse_object(js, ti, &j);
                    break;
                case JSMN_ARRAY:
                    val = parse_array(js, ti, &j);
                    break;
                case JSMN_STRING:
                    val = parse_string(js, ti, &j);
                    break;
                case JSMN_PRIMITIVE:
                    val = parse_primitive(js, ti, &j);
                    break;
                default:
                    break;
            }
            if (val) {
                plist_dict_set_item(obj, key, val);
            } else {
                free(key);
                plist_free(obj);
                return NULL;
            }
            free(key);
        } else {
            PLIST_JSON_ERR("%s: keys must be of type STRING\n", __func__);
            plist_free(obj);
            return NULL;
        }
    }
    (*index) = j;
    return obj;
}

// the below code fragment can be found in:
// src/jplist.c
static plist_t parse_string(const char* js, jsmntok_info_t* ti, int* index)
{
    if (ti->tokens[*index].type != JSMN_STRING) {
        PLIST_JSON_ERR("%s: token type != JSMN_STRING\n", __func__);
        return NULL;
    }

    size_t str_len = 0; ;
    char* strval = unescape_string(js + ti->tokens[*index].start, ti->tokens[*index].end - ti->tokens[*index].start, &str_len);
    if (!strval) {
        return NULL;
    }
    plist_t node;

    plist_data_t data = plist_new_plist_data();
    data->type = PLIST_STRING;
    data->strval = strval;
    data->length = str_len;
    node = plist_new_node(data);

    (*index)++;
    return node;
}

// the below code fragment can be found in:
// src/jsmn.c
void jsmn_init(jsmn_parser *parser) {
	parser->pos = 0;
	parser->end = 0;
	parser->toknext = 0;
	parser->toksuper = -1;
}
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).