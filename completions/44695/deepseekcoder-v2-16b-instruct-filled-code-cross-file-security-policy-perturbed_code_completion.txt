int64_t fractional_part = 0;
int64_t exponent_part = 0;
int64_t sign = 1;
int64_t intpart_value = intpart;

// Check for floating point representation
const char* fendp = endp;
if (*endp == '.') {
    fendp++;
    endp++;
    while (endp < str_end && isdigit(*endp)) {
        fractional_part = fractional_part * 10 + (*endp - '0');
        endp++;
    }
}

// Check for exponent representation
if (*endp == 'e' || *endp == 'E') {
    sign = (*endp == 'e') ? 1 : -1;
    endp++;
    if (*endp == '+' || *endp == '-') {
        endp++;
    }
    while (endp < str_end && isdigit(*endp)) {
        exponent_part = exponent_part * 10 + (*endp - '0');
        endp++;
    }
}

// Calculate the final value
double final_value = intpart_value + (double)fractional_part / pow(10, (int)strlen((char*)endp - (char*)str_val));
final_value *= pow(10, sign * exponent_part);

// Check for overflow and underflow
if (isinf(final_value) || isnan(final_value)) {
    PLIST_JSON_ERR("%s: invalid floating point value\n", __func__);
    return NULL;
}

// Create plist node based on the final value
if (fractional_part == 0 && exponent_part == 0) {
    primitivevalue = plist_new_int(intpart_value);
} else {
    primitivevalue = plist_new_real(final_value);
}