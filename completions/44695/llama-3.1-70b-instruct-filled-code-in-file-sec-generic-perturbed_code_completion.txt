// Determine if the parsed numeric value is an integer or floating point.
// If it's an integer, create a plist node for an unsigned integer.
// If it's a floating point, convert and accumulate the fractional and exponent parts.
// Create a plist node for a real number if the value is a valid floating point number.
// Handle errors for invalid characters or unrepresentable floating point values.
if (*endp < str_end && *endp[0] == '.') {
    double realval = (double)intpart;
    int64_t frac = 0;
    int64_t frac_div = 1;
    int exp = 0;
    int exp_sign = 1;
    (*endp)++;
    while (*endp < str_end && isdigit(**endp)) {
        frac = frac * 10 + (**endp - '0');
        frac_div *= 10;
        (*endp)++;
    }
    if (*endp < str_end && (**endp == 'e' || **endp == 'E')) {
        (*endp)++;
        if (*endp < str_end && **endp == '-') {
            exp_sign = -1;
            (*endp)++;
        } else if (*endp < str_end && **endp == '+') {
            (*endp)++;
        }
        if (*endp >= str_end ||!isdigit(**endp)) {
            PLIST_JSON_ERR("%s: invalid exponent\n", __func__);
            return NULL;
        }
        exp = 0;
        while (*endp < str_end && isdigit(**endp)) {
            exp = exp * 10 + (**endp - '0');
            (*endp)++;
        }
    }
    realval += (double)frac / (double)frac_div;
    realval *= pow(10.0, (double)(exp_sign * exp));
    plist_data_t data = plist_new_plist_data();
    data->type = PLIST_REAL;
    data->realval = realval;
    primitivevalue = plist_new_node(data);
} else {
    if (is_neg) {
        plist_data_t data = plist_new_plist_data();
        data->type = PLIST_UINT;
        data->intval = (int64_t)intpart;
        data->length = 8;
        primitivevalue = plist_new_node(data);
    } else {
        plist_data_t data = plist_new_plist_data();
        data->type = PLIST_UINT;
        data->intval = (uint64_t)intpart;
        data->length = 8;
        primitivevalue = plist_new_node(data);
    }
}