{
    char* saveendp = endp;
    int is_float = 0;

    /* Check if there is a decimal or exponent part remaining after parsing the integer. */
    if (endp < str_end && (*endp == '.' || *endp == 'e' || *endp == 'E')) {
        is_float = 1;
    }

    if (is_float) {
        /* We'll parse the entire string segment as a double. */
        errno = 0;
        double dval = strtod(str_val, &saveendp);
        if ((dval == 0.0 && saveendp == str_val) || errno == ERANGE || saveendp > str_end) {
            PLIST_JSON_ERR("%s: invalid float value '%.*s'\n", __func__, (int)str_len, str_val);
            return NULL;
        }
        /* Ensure we've reached the end of this token. */
        if (saveendp != str_end) {
            /* If there are extra non-whitespace characters, it's invalid. */
            while (saveendp < str_end && isspace((unsigned char)*saveendp)) {
                saveendp++;
            }
            if (saveendp != str_end) {
                PLIST_JSON_ERR("%s: extra characters after float '%.*s'\n", __func__, (int)str_len, str_val);
                return NULL;
            }
        }
        plist_data_t data = plist_new_plist_data();
        data->type = PLIST_REAL;
        data->realval = dval;
        primitivevalue = plist_new_node(data);
    } else {
        /* Integer value. */
        /* Ensure we've reached the end of this token or only have spaces left. */
        while (saveendp < str_end && isspace((unsigned char)*saveendp)) {
            saveendp++;
        }
        if (saveendp != str_end) {
            PLIST_JSON_ERR("%s: extra characters after integer '%.*s'\n", __func__, (int)str_len, str_val);
            return NULL;
        }
        plist_data_t data = plist_new_plist_data();
        data->type = PLIST_UINT;
        data->intval = intpart;
        /* Use length=8 to indicate a signed value, length=16 for non-negative. */
        data->length = (intpart < 0) ? 8 : 16;
        primitivevalue = plist_new_node(data);
    }
}