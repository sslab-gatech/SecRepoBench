if (endp < str_end) {
    // We have more characters to parse, could be a decimal point or an exponent
    double dblval = (double)intpart;
    int had_decimal = 0;
    
    // Check for decimal point
    if (*endp == '.') {
        had_decimal = 1;
        endp++; // Move past the decimal point
        double fracpart = 0.0;
        double frac_mul = 0.1;
        
        // Parse the fractional part
        while (endp < str_end && isdigit(*endp)) {
            fracpart += (*endp - '0') * frac_mul;
            frac_mul *= 0.1;
            endp++;
        }
        
        // Add the fractional part to the integer part
        dblval = (double)intpart + (intpart < 0 ? -fracpart : fracpart);
    }
    
    // Check for exponent
    if (endp < str_end && (*endp == 'e' || *endp == 'E')) {
        endp++; // Move past 'e' or 'E'
        
        // Check for sign of exponent
        int exp_sign = 1;
        if (endp < str_end && *endp == '+') {
            endp++;
        } else if (endp < str_end && *endp == '-') {
            exp_sign = -1;
            endp++;
        }
        
        // Parse exponent value
        int exp_val = 0;
        int exp_digits = 0;
        while (endp < str_end && isdigit(*endp)) {
            exp_val = exp_val * 10 + (*endp - '0');
            exp_digits++;
            endp++;
        }
        
        if (exp_digits == 0) {
            PLIST_JSON_ERR("%s: missing exponent value\n", __func__);
            return NULL;
        }
        
        // Apply exponent
        double exp_factor = 1.0;
        for (int i = 0; i < exp_val; i++) {
            exp_factor *= 10.0;
        }
        
        dblval = exp_sign > 0 ? dblval * exp_factor : dblval / exp_factor;
        had_decimal = 1; // If we have an exponent, treat it as a float
    }
    
    // Check if we've consumed all characters
    if (endp != str_end) {
        PLIST_JSON_ERR("%s: invalid character in numeric value\n", __func__);
        return NULL;
    }
    
    // Create the appropriate node
    if (had_decimal) {
        // Create a real plist node
        plist_data_t data = plist_new_plist_data();
        data->type = PLIST_REAL;
        data->realval = dblval;
        primitivevalue = plist_new_node(data);
    } else {
        // It's an integer, but we've already parsed it
        if (intpart >= 0) {
            // Unsigned integer
            plist_data_t data = plist_new_plist_data();
            data->type = PLIST_UINT;
            data->intval = (uint64_t)intpart;
            primitivevalue = plist_new_node(data);
        } else {
            // Signed integer
            plist_data_t data = plist_new_plist_data();
            data->type = PLIST_INT;
            data->intval = intpart;
            primitivevalue = plist_new_node(data);
        }
    }
} else {
    // This is an integer
    if (intpart >= 0) {
        // Unsigned integer
        plist_data_t data = plist_new_plist_data();
        data->type = PLIST_UINT;
        data->intval = (uint64_t)intpart;
        primitivevalue = plist_new_node(data);
    } else {
        // Signed integer
        plist_data_t data = plist_new_plist_data();
        data->type = PLIST_INT;
        data->intval = intpart;
        primitivevalue = plist_new_node(data);
    }
}