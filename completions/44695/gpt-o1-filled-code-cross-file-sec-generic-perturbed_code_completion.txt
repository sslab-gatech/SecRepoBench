{
    bool is_float = false;
    char *cur = endp;

    /* Check if there's a decimal point or exponent indicator remaining */
    if (cur < str_end && (*cur == '.' || *cur == 'e' || *cur == 'E')) {
        is_float = true;
    }

    if (is_float) {
        /* Parse as floating-point using a temporary buffer */
        size_t num_len = (size_t)(str_end - str_val);
        /* Limit length to avoid excessively large allocations */
        if (num_len > 511) {
            PLIST_JSON_ERR("%s: numeric value too long '%.*s'\n", __func__, (int)str_len, str_val);
            return NULL;
        }

        char tmpbuf[512];
        memcpy(tmpbuf, str_val, num_len);
        tmpbuf[num_len] = '\0';

        char *parse_end_float = NULL;
        long double ldval = strtold(tmpbuf, &parse_end_float);

        if (parse_end_float == tmpbuf) {
            PLIST_JSON_ERR("%s: invalid float '%.*s'\n", __func__, (int)str_len, str_val);
            return NULL;
        }
        if (fabsl(ldval) == HUGE_VALL) {
            PLIST_JSON_ERR("%s: float overflow '%.*s'\n", __func__, (int)str_len, str_val);
            return NULL;
        }
        /* Ensure the entire numeric substring was parsed */
        if (parse_end_float != (tmpbuf + num_len)) {
            PLIST_JSON_ERR("%s: trailing characters after float '%.*s'\n", __func__, (int)str_len, str_val);
            return NULL;
        }

        primitivevalue = plist_new_real((double)ldval);
    } else {
        /* Treat as integer (unsigned or signed) */
        if (intpart < 0) {
            primitivevalue = plist_new_int((int64_t)intpart);
        } else {
            primitivevalue = plist_new_uint((uint64_t)intpart);
        }
    }
}