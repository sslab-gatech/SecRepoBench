// Determine if the parsed numeric value is an integer or floating point.
// If it's an integer, create a plist node for an unsigned integer.
// If it's a floating point, convert and accumulate the fractional and exponent parts.
// Create a plist node for a real number if the value is a valid floating point number.
// Handle errors for invalid characters or unrepresentable floating point values.
if (str_val[str_len - 1] == '.') {
    // Floating point number
    char* endp = (char*)str_val;
    int64_t intpart = parse_decimal(str_val, str_end, &endp);
    if (endp == str_end) {
        PLIST_JSON_ERR("%s: invalid floating point value '%.*s' encountered\n", __func__, (int)str_len, str_val);
    }
    plist_data_t data = plist_new_plist_data();
    data->type = PLIST_REAL;
    data->real = strtod(str_val, &endp);
    if (endp!= str_end) {
        PLIST_JSON_ERR("%s: invalid floating point value '%.*s' encountered\n", __func__, (int)str_len, str_val);
    }
    primitivevalue = plist_new_node(data);
} else if (str_val[str_len - 1] == 'e' || str_val[str_len - 1] == 'E') {
    // Floating point number with exponent
    char* endp = (char*)str_val;
    int64_t intpart = parse_decimal(str_val, str_end, &endp);
    if (endp == str_end) {
        PLIST_JSON_ERR("%s: invalid floating point value '%.*s' encountered\n", __func__, (int)str_len, str_val);
    }
    plist_data_t data = plist_new_plist_data();
    data->type = PLIST_REAL;
    data->real = strtod(str_val, &endp);
    if (endp!= str_end) {
        PLIST_JSON_ERR("%s: invalid floating point value '%.*s' encountered\n", __func__, (int)str_len, str_val);
    }
    primitivevalue = plist_new_node(data);
} else {
    // Integer
    plist_data_t data = plist_new_plist_data();
    data->type = PLIST_UINT;
    data->uint = strtoull(str_val, NULL, 10);
    primitivevalue = plist_new_node(data);
}