// Determine if the parsed numeric value is an integer or floating point.
// If it's an integer, create a plist node for an unsigned integer.
// If it's a floating point, convert and accumulate the fractional and exponent parts.
// Create a plist node for a real number if the value is a valid floating point number.
// Handle errors for invalid characters or unrepresentable floating point values.
if (str_val[str_len - 1] == '.') {
    // Floating point number
    char* endp = (char*)str_val;
    int64_t intpart = parse_decimal(str_val, str_end, &endp);
    if (endp == str_end) {
        PLIST_JSON_ERR("%s: invalid floating point value '%.*s' encountered\n", __func__, (int)str_len, str_val);
        return NULL;
    }
    char* decimal_endp = endp;
    if (*endp == 'e' || *endp == 'E') {
        // Exponent part
        if (endp + 1 >= str_end) {
            PLIST_JSON_ERR("%s: invalid floating point value '%.*s' encountered\n", __func__, (int)str_len, str_val);
            return NULL;
        }
        int64_t exponent = 0;
        if (*endp == 'e' || *endp == 'E') {
            if (isdigit(*endp) || (*endp == '-' && isdigit(endp[1]))) {
                char* exponent_endp = endp + 1;
                if (isdigit(*exponent_endp)) {
                    while (isdigit(*exponent_endp)) {
                        exponent = exponent * 10 + (*exponent_endp - '0');
                        exponent_endp++;
                    }
                    if (*exponent_endp == '.') {
                        PLIST_JSON_ERR("%s: invalid floating point value '%.*s' encountered\n", __func__, (int)str_len, str_val);
                        return NULL;
                    }
                    if (*exponent_endp == 'e' || *exponent_endp == 'E') {
                        PLIST_JSON_ERR("%s: invalid floating point value '%.*s' encountered\n", __func__, (int)str_len, str_val);
                        return NULL;
                    }
                    if (isdigit(*exponent_endp)) {
                        while (isdigit(*exponent_endp)) {
                            exponent = exponent * 10 + (*exponent_endp - '0');
                            exponent_endp++;
                        }
                    }
                } else {
                    PLIST_JSON_ERR("%s: invalid floating point value '%.*s' encountered\n", __func__, (int)str_len, str_val);
                    return NULL;
                }
            } else {
                PLIST_JSON_ERR("%s: invalid floating point value '%.*s' encountered\n", __func__, (int)str_len, str_val);
                return NULL;
            }
        }
        if (exponent < 0) {
            int64_t multiplier = 1;
            for (int i = 0; i < -exponent; i++) {
                if (intpart < multiplier) {
                    PLIST_JSON_ERR("%s: invalid floating point value '%.*s' encountered\n", __func__, (int)str_len, str_val);
                    return NULL;
                }
                intpart /= 10;
                multiplier *= 10;
            }
        } else if (exponent > 0) {
            int64_t multiplier = 1;
            for (int i = 0; i < exponent; i++) {
                if (intpart >= multiplier) {
                    intpart *= 10;
                    multiplier *= 10;
                } else {
                    PLIST_JSON_ERR("%s: invalid floating point value '%.*s' encountered\n", __func__, (int)str_len, str_val);
                    return NULL;
                }
            }
        }
    }
    if (decimal_endp == endp) {
        // No fractional part
        plist_data_t data = plist_new_plist_data();
        data->type = PLIST_REAL;
        data->ival = intpart;
        primitivevalue = plist_new_node(data);
    } else {
        // Fractional part
        plist_data_t data = plist_new_plist_data();
        data->type = PLIST_REAL;
        data->ival = intpart;
        data->fval = (double)intpart / pow(10, decimal_endp - endp);
        primitivevalue = plist_new_node(data);
    }
} else {
    // Integer
    plist_data_t data = plist_new_plist_data();
    data->type = PLIST_UINT;
    data->ival = intpart;
    primitivevalue = plist_new_node(data);
}