_constructor(&ma);
            dwarfstring_constructor(&mb);
            dwarfstring_append_printf_u(&ma,
                "*** DWARF CHECK: SPECIAL opcode %d ",
                origop);
            dwarfstring_append_printf_u(&ma,
                "with %d operands: ",
                opcnt);
            _dwarf_printf(dbg,dwarfstring_string(&ma));
            dwarfstring_destructor(&ma);
            }
#endif /* PRINTING_DETAILS */
        } else if (type == LOP_ADVANCE_PC) {
            int oc = 0;
            int opcnt = line_context->lc_opcode_length_table[opcode];
#ifdef PRINTING_DETAILS
            {
            dwarfstring m9b;
            dwarfstring_constructor(&m9b);
            dwarfstring_append_printf_i(&m9b,
                "*** DWARF CHECK: ADVANCE_PC standard opcode %d ",
                opcode);
            dwarfstring_append_printf_i(&m9b,
                "with %d operands: ", opcnt);
            _dwarf_printf(dbg,dwarfstring_string(&m9b));
            *err_count_out += 1;
            dwarfstring_destructor(&m9b);
            }
#endif /* PRINTING_DETAILS */
            for (oc = 0; oc < opcnt; oc++) {
                int ocres = 0;
                /*  Read and discard operands we don't
                    understand.
                    arbitrary choice of unsigned read.
                    signed read would work as well.    */
                Dwarf_Unsigned utmp2 = 0;

                (void) utmp2;
                ocres =  read_uword_de( &line_ptr,&utmp2,
                    dbg,error,line_ptr_end);
                if (ocres == DW_DLV_ERROR) {
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                        curr_line = 0;
                    }
                    return DW_DLV_ERROR;
                }

#ifdef PRINTING_DETAILS
                {
                dwarfstring m9e;
                dwarfstring_constructor(&m9e);
                dwarfstring_append_printf_u(&m9e,
                    " %" DW_PR_DUu,
                    utmp2);
                dwarfstring_append_printf_u(&m9e,
                    " (0x%" DW_PR_XZEROS DW_PR_DUx ")",
                    utmp2);
                _dwarf_printf(dbg,dwarfstring_string(&m9e));
                dwarfstring_destructor(&m9e);
                }
#endif /* PRINTING_DETAILS */
            }
#ifdef PRINTING_DETAILS
            _dwarf_printf(dbg,"***\n");
#endif /* PRINTING_DETAILS */
            regs.lr_address = regs.lr_address +
                (line_context->lc_minimum_instruction_length *
                (opcode % line_context->lc_line_range));
        } else if (type == LOP_ADVANCE_LINE) {
            int oc = 0;
            int opcnt = line_context->lc_opcode_length_table[opcode];
#ifdef PRINTING_DETAILS
            {
            dwarfstring m9b;
            dwarfstring_constructor(&m9b);
            dwarfstring_append_printf_i(&m9b,
                "*** DWARF CHECK: ADVANCE_LINE standard opcode %d ",
                opcode);
            dwarfstring_append_printf_i(&m9b,
                "with %d operands: ", opcnt);
            _dwarf_printf(dbg,dwarfstring_string(&m9b));
            *err_count_out += 1;
            dwarfstring_destructor(&m9b);
            }
#endif /* PRINTING_DETAILS */
            for (oc = 0; oc < opcnt; oc++) {
                int ocres = 0;
                /*  Read and discard operands we don't
                    understand.
                    arbitrary choice of unsigned read.
                    signed read would work as well.    */
                Dwarf_Unsigned utmp2 = 0;

                (void) utmp2;
                ocres =  read_uword_de( &line_ptr,&utmp2,
                    dbg,error,line_ptr_end);
                if (ocres == DW_DLV_ERROR) {
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                        curr_line = 0;
                    }
                    return DW_DLV_ERROR;
                }

#ifdef PRINTING_DETAILS
                {
                dwarfstring m9e;
                dwarfstring_constructor(&m9e);
                dwarfstring_append_printf_u(&m9e,
                    " %" DW_PR_DUu,
                    utmp2);
                dwarfstring_append_printf_u(&m9e,
                    " (0x%" DW_PR_XZEROS DW_PR_DUx ")",
                    utmp2);
                _dwarf_printf(dbg,dwarfstring_string(&m9e));
                dwarfstring_destructor(&m9e);
                }
#endif /* PRINTING_DETAILS */
            }
#ifdef PRINTING_DETAILS
            _dwarf_printf(dbg,"***\n");
#endif /* PRINTING_DETAILS */
            regs.lr_line = regs.lr_line + line_context->lc_line_base +
                (opcode % line_context->lc_line_range);
        } else if (type == LOP_SET_FILE) {
            int oc = 0;
            int opcnt = line_context->lc_opcode_length_table[opcode];
#ifdef PRINTING_DETAILS
            {
            dwarfstring m9b;
            dwarfstring_constructor(&m9b);
            dwarfstring_append_printf_i(&m9b,
                "*** DWARF CHECK: SET_FILE standard opcode %d ",
                opcode);
            dwarfstring_append_printf_i(&m9b,
                "with %d operands: ", opcnt);
            _dwarf_printf(dbg,dwarfstring_string(&m9b));
            *err_count_out += 1;
            dwarfstring_destructor(&m9b);
            }
#endif /* PRINTING_DETAILS */
            for (oc = 0; oc < opcnt; oc++) {
                int ocres = 0;
                /*  Read and discard operands we don't
                    understand.
                    arbitrary choice of unsigned read.
                    signed read would work as well.    */
                Dwarf_Unsigned utmp2 = 0;

                (void) utmp2;
                ocres =  read_uword_de( &line_ptr,&utmp2,
                    dbg,error,line_ptr_end);
                if (ocres == DW_DLV_ERROR) {
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                        curr_line = 0;
                    }
                    return DW_DLV_ERROR;
                }

#ifdef PRINTING_DETAILS
                {
                dwarfstring m9e;
                dwarfstring_constructor(&m9e);
                dwarfstring_append_printf_u(&m9e,
                    " %" DW_PR_DUu,
                    utmp2);
                dwarfstring_append_printf_u(&m9e,
                    " (0x%" DW_PR_XZEROS DW_PR_DUx ")",
                    utmp2);
                _dwarf_printf(dbg,dwarfstring_string(&m9e));
                dwarfstring_destructor(&m9e);
                }
#endif /* PRINTING_DETAILS */
            }
#ifdef PRINTING_DETAILS
            _dwarf_printf(dbg,"***\n");
#endif /* PRINTING_DETAILS */
            if (line_count >= logicals_count) {
                _dwarf_error(dbg, error, DW_DLE_LINE_TABLE_LINENO_ERROR);
                _dwarf_free_chain_entries(dbg,head_chain,line_count);
                if (curr_line) {
                    dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    curr_line = 0;
                }
                return DW_DLV_ERROR;
            }
            logicals[line_count].ll_file = utmp2;
        } else if (type == LOP_SET_COLUMN) {
            int oc = 0;
            int opcnt = line_context->lc_opcode_length_table[opcode];
#ifdef PRINTING_DETAILS
            {
            dwarfstring m9b;
            dwarfstring_constructor(&m9b);
            dwarfstring_append_printf_i(&m9b,
                "*** DWARF CHECK: SET_COLUMN standard opcode %d ",
                opcode);
            dwarfstring_append_printf_i(&m9b,
                "with %d operands: ", opcnt);
            _dwarf_printf(dbg,dwarfstring_string(&m9b));
            *err_count_out += 1;
            dwarfstring_destructor(&m9b);
            }
#endif /* PRINTING_DETAILS */
            for (oc = 0; oc < opcnt; oc++) {
                int ocres = 0;
                /*  Read and discard operands we don't
                    understand.
                    arbitrary choice of unsigned read.
                    signed read would work as well.    */
                Dwarf_Unsigned utmp2 = 0;

                (void) utmp2;
                ocres =  read_uword_de( &line_ptr,&utmp2,
                    dbg,error,line_ptr_end);
                if (ocres == DW_DLV_ERROR) {
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                        curr_line = 0;
                    }
                    return DW_DLV_ERROR;
                }

#ifdef PRINTING_DETAILS
                {
                dwarfstring m9e;
                dwarfstring_constructor(&m9e);
                dwarfstring_append_printf_u(&m9e,
                    " %" DW_PR_DUu,
                    utmp2);
                dwarfstring_append_printf_u(&m9e,
                    " (0x%" DW_PR_XZEROS DW_PR_DUx ")",
                    utmp2);
                _dwarf_printf(dbg,dwarfstring_string(&m9e));
                dwarfstring_destructor(&m9e);
                }
#endif /* PRINTING_DETAILS */
            }
#ifdef PRINTING_DETAILS
            _dwarf_printf(dbg,"***\n");
#endif /* PRINTING_DETAILS */
            if (line_count >= logicals_count) {
                _dwarf_error(dbg, error, DW_DLE_LINE_TABLE_LINENO_ERROR);
                _dwarf_free_chain_entries(dbg,head_chain,line_count);
                if (curr_line) {
                    dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    curr_line = 0;
                }
                return DW_DLV_ERROR;
            }
            logicals[line_count].ll_column = utmp2;
        } else if (type == LOP_SET_ADDRESS) {
            int oc = 0;
            int opcnt = line_context->lc_opcode_length_table[opcode];
#ifdef PRINTING_DETAILS
            {
            dwarfstring m9b;
            dwarfstring_constructor(&m9b);
            dwarfstring_append_printf_i(&m9b,
                "*** DWARF CHECK: SET_ADDRESS standard opcode %d ",
                opcode);
            dwarfstring_append_printf_i(&m9b,
                "with %d operands: ", opcnt);
            _dwarf_printf(dbg,dwarfstring_string(&m9b));
            *err_count_out += 1;
            dwarfstring_destructor(&m9b);
            }
#endif /* PRINTING_DETAILS */
            for (oc = 0; oc < opcnt; oc++) {
                int ocres = 0;
                /*  Read and discard