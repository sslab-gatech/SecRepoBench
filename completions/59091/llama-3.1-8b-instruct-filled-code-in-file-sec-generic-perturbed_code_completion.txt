static int
read_line_table_program(Dwarf_Debug dbg,
    Dwarf_Small *line_ptr,
    Dwarf_Small *line_ptr_end,
    Dwarf_Small *orig_line_ptr,
    Dwarf_Small *section_start,
    Dwarf_Line_Context line_context,
    Dwarf_Half address_size,
    Dwarf_Bool doaddrs, /* Only true if SGI IRIX rqs calling. */
    Dwarf_Bool dolines,
    Dwarf_Bool is_single_table,
    Dwarf_Bool is_actuals_table,
    Dwarf_Error *error,
    int *err_count_out)
{
    // Initialize variables to store the format count, entry types, and entry forms for subprograms.
    // Check if the current pointer position is within the valid range of the data section.
    // Retrieve the subprogram format count from the current position of the data pointer.
    // Increment the data pointer to move past the retrieved format count.
    // <MASK>
    subprog_format_count = *(unsigned char *) line_ptr;
    line_context->lc_subprog_format_count = subprog_format_count;
    line_ptr = line_ptr + sizeof(Dwarf_Small);
    if (subprog_format_count > total_length) {
        IssueExpError(dbg,err,
            "Subprog format count Count too "
            "large to be real",
            subprog_format_count);
        return DW_DLV_ERROR;
    }
    subprog_entry_types = malloc(sizeof(Dwarf_Unsigned) *
        subprog_format_count);
    if (subprog_entry_types == NULL) {
        _dwarf_error_string(dbg, err, DW_DLE_ALLOC_FAIL,
            "DW_DLE_ALLOC_FAIL allocating subprog_entry_types");
        return DW_DLV_ERROR;
    }
    subprog_entry_forms = malloc(sizeof(Dwarf_Unsigned) *
        subprog_format_count);
    if (subprog_entry_forms == NULL) {
        free(subprog_entry_types);
        _dwarf_error(dbg, err, DW_DLE_ALLOC_FAIL);
        _dwarf_error_string(dbg, err, DW_DLE_ALLOC_FAIL,
            "DW_DLE_ALLOC_FAIL allocating subprog_entry_forms");
        return DW_DLV_ERROR;
    }

    for (index = 0; index < subprog_format_count; index++) {

        dres=read_uword_de(&line_ptr,subprog_entry_types+index,
            dbg,err,line_ptr_end);
        if (dres!= DW_DLV_OK) {
            free(subprog_entry_types);
            free(subprog_entry_forms);
            return dres;
        }
        if (subprog_entry_types[index] > total_length) {
            IssueExpError(dbg,err,
                "Subprog entry_types[i] count Count too "
                "large to be real",
                subprog_entry_types[index]);
            free(subprog_entry_types);
            free(subprog_entry_forms);
            return DW_DLV_ERROR;
        }
        dres=read_uword_de(&line_ptr,subprog_entry_forms+index,
            dbg,err,line_ptr_end);
        if (dres!= DW_DLV_OK) {
            free(subprog_entry_types);
            free(subprog_entry_forms);
            return dres;
        }
        if (subprog_entry_forms[index] > total_length) {
            IssueExpError(dbg,err,
                "Subprog entry_forms[i] count Count too "
                "large to be real",
                subprog_entry_forms[index]);
            free(subprog_entry_types);
            free(subprog_entry_forms);
            return DW_DLV_ERROR;
        }
    }
    dres=read_uword_de(&line_ptr,&subprogs_count,
        dbg,err,line_ptr_end);
    if (dres!= DW_DLV_OK) {
        free(subprog_entry_types);
        free(subprog_entry_forms);
        return dres;
    }
    if (subprogs_count > total_length) {
        IssueExpError(dbg,err,
            "Subprogs Count too large to be real",
            subprogs_count);
        free(subprog_entry_types);
        free(subprog_entry_forms);
        return DW_DLV_ERROR;
    }
    line_context->lc_subprogs =
        malloc(sizeof(struct Dwarf_Subprog_Entry_s) *
            subprogs_count);
    if (line_context->lc_subprogs == NULL) {
        free(subprog_entry_types);
        free(subprog_entry_forms);
        _dwarf_error(dbg, err, DW_DLE_ALLOC_FAIL);
        return DW_DLV_ERROR;
    }
    memset(line_context->lc_subprogs, 0,
        sizeof(struct Dwarf_Subprog_Entry_s) * subprogs_count);
    for (index = 0; index < subprogs_count; index++) {
        struct Dwarf_Subprog_Entry_s *curline =
            line_context->lc_subprogs + index;
        for (j = 0; j < subprog_format_count; j++) {
            Dwarf_Unsigned lntype =
                subprog_entry_types[j];
            Dwarf_Unsigned lnform =
                subprog_entry_forms[j];
            switch (lntype) {
            case DW_LNCT_GNU_subprogram_name:
                res = _dwarf_decode_line_string_form(dbg,
                    lntype,lnform,
                    local_length_size,
                    &line_ptr,
                    line_ptr_end,
                    (char **)&curline->ds_subprog_name,
                    err);
                if (res!= DW_DLV_OK) {
                    free(subprog_entry_types);
                    free(subprog_entry_forms);
                    return res;
                }
                break;
            case DW_LNCT_GNU_decl_file:
                res = _dwarf_decode_line_udata_form(dbg,
                    lntype,lnform,
                    &line_ptr,
                    &curline->ds_decl_file,
                    line_ptr_end,
                    err);
                if (res!= DW_DLV_OK) {
                    free(subprog_entry_forms);
                    free(subprog_entry_types);
                    return res;
                }
                break;
            case DW_LNCT_GNU_decl_line:
                res = _dwarf_decode_line_udata_form(dbg,
                    lntype,lnform,
                    &line_ptr,
                    &curline->ds_decl_line,
                    line_ptr_end,
                    err);
                if (res!= DW_DLV_OK) {
                    free(subprog_entry_forms);
                    free(subprog_entry_types);
                    return res;
                }
                break;
            default:
                free(subprog_entry_forms);
                free(subprog_entry_types);
                _dwarf_report_bad_lnct(dbg,
                    lntype,
                    DW_DLE_LINE_NUMBER_HEADER_ERROR,
                    "DW_DLE_LINE_NUMBER_HEADER_ERROR",
                    err);
                return DW_DLV_ERROR;
            }
            if (line_ptr >= line_ptr_end) {
                free(subprog_entry_types);
                free(subprog_entry_forms);
                _dwarf_error_string(dbg, err,
                    DW_DLE_LINE_NUMBER_HEADER_ERROR,
                    "DW_DLE_LINE_NUMBER_HEADER_ERROR:"
                    " Reading suprogram entry DW_LNCT* types "
                    " we run off the end of the table");
                return DW_DLV_ERROR;
            }
        }
    }

    free(subprog_entry_types);
    free(subprog_entry_forms);
    line_context->lc_subprogs_count = subprogs_count;
}