regs.lr_line < 0) {
                        dwarfstring m;

                        dwarfstring_constructor(&m);
                        dwarfstring_append_printf_i(&m,
                            "\nERROR: DW_DLE_LINE_TABLE_LINENO_ERROR"
                            " The line number is %d "
                            "and negative line numbers after "
                            "DW_LNS_set_address_from_logical ",
                            (Dwarf_Signed)regs.lr_line);
                        dwarfstring_append_printf_i(&m,
                            " of %d "
                            "are not correct.",stmp);
                        _dwarf_error_string(dbg, error,
                            DW_DLE_LINE_TABLE_LINENO_ERROR,
                            dwarfstring_string(&m));
                        dwarfstring_destructor(&m);
                        regs.lr_line = 0;
                        if (curr_line) {
                            dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                        }
                        _dwarf_free_chain_entries(dbg,head_chain,
                            line_count);
                        return DW_DLV_ERROR;
                    }
                } else {
                    /* DW_LNS_set_subprogram */
                    Dwarf_Unsigned utmp2 = 0;
                    int ssres = 0;

                    ssres =  read_uword_de( &line_ptr,&utmp2,
                        dbg,error,line_ptr_end);
                    if (ssres == DW_DLV_ERROR) {
                        _dwarf_free_chain_entries(dbg,head_chain,
                            line_count);
                        if (curr_line) {
                            dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                        }
                        return DW_DLV_ERROR;
                    }
                    regs.lr_subprogram = utmp2;
                }
                break;

                /*  Experimental two-level line tables */
            case DW_LNS_set_discriminator:{
                Dwarf_Unsigned utmp2 = 0;
                int sdres = 0;

                sdres =  read_uword_de( &line_ptr,&utmp2,
                    dbg,error,line_ptr_end);
                if (sdres == DW_DLV_ERROR) {
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    }
                    return DW_DLV_ERROR;
                }
                regs.lr_discriminator = utmp2;
#ifdef PRINTING_DETAILS
                dwarfstring_constructor(&mb);
                dwarfstring_append_printf_u(&mb,
                    "DW_LNS_set_discriminator new value 0x%"
                    DW_PR_XZEROS DW_PR_DUx ".\n",
                    utmp2);
                _dwarf_printf(dbg,dwarfstring_string(&mb));
                dwarfstring_destructor(&mb);
#endif /* PRINTING_DETAILS */
                }
                break;

                /*  Experimental two-level line tables */
            case DW_LNS_set_call_context:{
                Dwarf_Unsigned utmp2 = 0;
                int sccres = 0;

                sccres =  read_uword_de( &line_ptr,&utmp2,
                    dbg,error,line_ptr_end);
                if (sccres == DW_DLV_ERROR) {
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    }
                    return DW_DLV_ERROR;
                }
                regs.lr_call_context = utmp2;
#ifdef PRINTING_DETAILS
                dwarfstring_constructor(&mb);
                dwarfstring_append_printf_u(&mb,
                    "DW_LNS_set_call_context new value 0x%"
                    DW_PR_XZEROS DW_PR_DUx ".\n",
                    utmp2);
                _dwarf_printf(dbg,dwarfstring_string(&mb));
                dwarfstring_destructor(&mb);
#endif /* PRINTING_DETAILS */
                }
                break;

                /*  Experimental two-level line tables */
            case DW_LNS_set_address:{
                Dwarf_Addr addr = 0;
                int sares = 0;

                sares =  read_address(dbg,&addr,
                    line_ptr,address_size,
                    error,line_ptr_end);
                if (sares == DW_DLV_ERROR) {
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    }
                    return DW_DLV_ERROR;
                }
                line_ptr += address_size;
                if (line_ptr > line_ptr_end) {
                    dwarfstring g;
                    /*  ptrdiff_t is generated but not named */
                    Dwarf_Unsigned localoff =
                        (line_ptr >= section_start)?
                        (line_ptr - section_start):0xfffffff;

                    dwarfstring_constructor(&g);
                    dwarfstring_append_printf_u(&g,
                        "DW_DLE_LINE_TABLE_BAD reading "
                        "DW_LNS_set_address we are "
                        "off this line table at section "
                        "offset. 0x%x .",
                        localoff);
                    _dwarf_error_string(dbg, error,
                        DW_DLE_LINE_TABLE_BAD,
                        dwarfstring_string(&g));
                    dwarfstring_destructor(&g);
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    }
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    return DW_DLV_ERROR;
                }
                regs.lr_address = addr;
                is_addr_set = true;
#ifdef PRINTING_DETAILS
                dwarfstring_constructor(&mb);
                dwarfstring_append_printf_u(&mb,
                    "DW_LNS_set_address new value 0x%"
                    DW_PR_XZEROS DW_PR_DUx ".\n",
                    addr);
                _dwarf_printf(dbg,dwarfstring_string(&mb));
                dwarfstring_destructor(&mb);
#endif /* PRINTING_DETAILS */
                }
                break;

                /*  Experimental two-level line tables */
            case DW_LNS_set_end_sequence:{
                Dwarf_Unsigned utmp2 = 0;
                int sesres = 0;

                sesres =  read_uword_de( &line_ptr,&utmp2,
                    dbg,error,line_ptr_end);
                if (sesres == DW_DLV_ERROR) {
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    }
                    return DW_DLV_ERROR;
                }
                regs.lr_end_sequence = utmp2;
                if (utmp2) {
                    /*  If end_sequence is set, reset the
                        state machine. */
                    _dwarf_set_line_table_regs_default_values(
                        &regs,
                        line_context->lc_version_number,
                        line_context->lc_default_is_stmt);
                }
#ifdef PRINTING_DETAILS
                dwarfstring_constructor(&mb);
                dwarfstring_append_printf_u(&mb,
                    "DW_LNS_set_end_sequence new value 0x%"
                    DW_PR_XZEROS DW_PR_DUx ".\n",
                    utmp2);
                _dwarf_printf(dbg,dwarfstring_string(&mb));
                dwarfstring_destructor(&mb);
#endif /* PRINTING_DETAILS */
                }
                break;

                /*  Experimental two-level line tables */
            case DW_LNS_set_machine_isa:{
                Dwarf_Unsigned utmp2 = 0;
                int smires = 0;

                smires =  read_uword_de( &line_ptr,&utmp2,
                    dbg,error,line_ptr_end);
                if (smires == DW_DLV_ERROR) {
                    _dwarf_free_chain_entries(dbg,head_chain,
                        line_count);
                    if (curr_line) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                    }
                    return DW_DLV_ERROR;
                }
                regs.lr_machine_isa = utmp2;
#ifdef PRINTING_DETAILS
                dwarfstring_constructor(&mb);
                dwarfstring_append_printf_u(&mb,
                    "DW_LNS_set_machine_isa new value 0x%"
                    DW_PR_XZEROS DW_PR_DUx ".\n",
                    utmp2);
                _dwarf_printf(dbg,dwarfstring_string(&mb));
                dwarfstring_destructor(&mb);
#endif /* PRINTING_DETAILS */
                }
                break;

                /*  Experimental two-level line tables */
            case DW_LNS_set_lo_user:
            case DW_LNS_set_hi_user:
                /*  These are reserved for user extensions.
                    We ignore them. */
                break;

            default:
                dwarfstring m;

                dwarfstring_constructor(&m);
                dwarfstring_append_printf_i(&m,
                    "DW_DLE_LINE_TABLE_OPCODE_ERROR "
                    "Unknown opcode %d in line table.",
                    opcode);
                _dwarf_error_string(dbg, error,
                    DW_DLE_LINE_TABLE_OPCODE_ERROR,
                    dwarfstring_string(&m));
                dwarfstring_destructor(&m);
                if (curr_line) {
                    dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                }
                _dwarf_free_chain_entries(dbg,head_chain,
                    line_count);
                return DW_DLV_ERROR;
            }
        } else if (type == LOP_EXTENDED) {
            Dwarf_Unsigned utmp2 = 0;
            int exres = 0;

            exres =  read_uword_de( &line_ptr,&utmp2,
                dbg,error,line_ptr_end);
            if (exres == DW_DLV_ERROR) {
                _dwarf_free_chain_entries(dbg,head_chain,
                    line_count);
                if (curr_line) {
                    dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                }
                return DW_DLV_ERROR;
            }
            instr_length = utmp2;
            if (instr_length == 0) {
                dwarfstring m;

                dwarfstring_constructor(&m);
                dwarfstring_append_printf_i(&m,
                    "DW_DLE_LINE_TABLE_INSTR_LENGTH_ERROR "
                    "Extended opcode instr length is 0.");
                _dwarf_error_string(dbg, error,
                    DW_DLE_LINE_TABLE_INSTR_LENGTH_ERROR,
                    dwarfstring_string(&m));
                dwarfstring_destructor(&m);
                if (curr_line) {
                    dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                }
                _dwarf_free_chain_entries(dbg,head_chain,
                    line_count);
                return DW_DLV_ERROR;
            }
            instr_length--; /* Subtract opcode byte. */
            if (instr_length > (line_ptr_end - line_ptr)) {
                dwarfstring m;

                dwarfstring_constructor(&m);
                dwarfstring_append_printf_i(&m,
                    "DW_DLE_LINE_TABLE_INSTR_LENGTH_ERROR "
                    "Extended opcode instr length is too long.");
                _dwarf_error_string(dbg, error,
                    DW_DLE_LINE_TABLE_INSTR_LENGTH_ERROR,
                    dwarfstring_string(&m));
                dwarfstring_destructor(&m);
                if (curr_line) {
                    dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                }
                _dwarf_free_chain_entries(dbg,head_chain,
                    line_count);
                return DW_DLV_ERROR;
            }
            opcode = *(Dwarf_Small *) line_ptr;
            line_ptr++;
            instr_length--;
            switch (opcode) {
            case DW_LNE_end_sequence:
                if (dolines) {
                    curr_line = (Dwarf_Line) _dwarf_get_alloc(dbg,
                        DW_DLA_LINE, 1);
                    if (curr_line == NULL) {
                        _dwarf_free_chain_entries(dbg,head_chain,
                            line_count);
                        _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);
                        return DW_DLV_ERROR;
                    }

                    /* Mark a line record as being DW_LNS_set_address */
                    curr_line->li_l_data.li_is_addr_set =
                        is_addr_set;
                    is_addr_set = false;

                    curr_line->li_address = regs.lr_address;
                    curr_line->li_l_data.li_file =
                        (Dwarf_Signed) regs.lr_file;
                    curr_line->li_l_data.li_line =
                        (Dwarf_Signed) regs.lr_line;
                    curr_line->li_l_data.li_column =
                        (Dwarf_Half) regs.lr_column;
                    curr_line->li_l_data.li_is_stmt =
                        regs.lr_is_stmt;
                    curr_line->li_l_data.
                        li_basic_block = regs.lr_basic_block;
                    curr_line->li_l_data.
                        li_end_sequence = regs.lr_end_sequence;
                    curr_line->li_context = line_context;
                    curr_line->li_is_actuals_table = is_actuals_table;
                    curr_line->li_l_data.
                        li_epilogue_begin = regs.lr_epilogue_begin;
                    curr_line->li_l_data.
                        li_prologue_end = regs.lr_prologue_end;
                    curr_line->li_l_data.li_isa =
                        regs.lr_isa;
                    curr_line->li_l_data.li_discriminator
                        = regs.lr_discriminator;
                    curr_line->li_l_data.li_call_context
                        = regs.lr_call_context;
                    curr_line->li_l_data.li_subprogram =
                        regs.lr_subprogram;
                    line_count++;

                    chain_line = (Dwarf_Chain)
                        _dwarf_get_alloc(dbg, DW_DLA_CHAIN, 1);
                    if (chain_line == NULL) {
                        dwarf_dealloc(dbg,curr_line,DW_DLA_LINE);
                        _dwarf_free_chain_entries(dbg,head_chain,
                            line_count);
                        _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);
                        return DW_DLV_ERROR;
                    }
                    chain_line->ch_itemtype = DW_DLA_LINE;
                    chain_line->ch_item = curr_line;
                    _dwarf_update_chain_list(chain_line,&head_chain,
                        &curr_chain);
                    curr_line = 0;
                }

                regs.lr_end_sequence = 1;
                _dwarf_set_line_table_regs_default_values(&regs,
                    line_context->lc_version_number,
                    line_context->lc_default_is_stmt);
                break;
            case DW_LNE_set_address:
                if (dolines) {
                    curr_line = (Dwarf_Line) _dwarf_get_alloc(dbg,
                        DW_DLA_LINE, 1);
                    if (curr_line == NULL) {
                        _dwarf_free_chain_entries(dbg,head_chain,
                            line_count);
                        _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);
                        return DW_DLV_ERROR;
                    }

                    /* Mark a line record as being DW_LNS_set_address */
                    curr_line->li_l_data.li_is_addr_set =
                        is_addr_set;
                    is_addr_set = false;

                    curr_line->li_address = regs.lr_address;
                    curr_line->li_l_data.li_file =