// Convert several fields from the header data in the frame to native byte order.
  // These fields include frame length, uncompressed size, compressed size,
  // block size, chunk size, and type size, depending on provided pointers.
  // Return an error code if any of the fields are invalid or if the header length is out of bounds.
  from_big(frame_len, frame_pointer + FRAME_FRAME_LEN, sizeof(*frame_len));
  from_big(nbytes, frame_pointer + FRAME_NBYTES, sizeof(*nbytes));
  from_big(cbytes, frame_pointer + FRAME_CBYTES, sizeof(*cbytes));
  from_big(blocksize, frame_pointer + FRAME_BLOCKSIZE, sizeof(*blocksize));
  from_big(chunksize, frame_pointer + FRAME_CHUNKSIZE, sizeof(*chunksize));
  from_big(typesize, frame_pointer + FRAME_TYPESIZE, sizeof(*typesize));

  // Sanity check for frame length
  if (*frame_len <= 0 || *frame_len > BLOSC2_MAX_FRAME_LEN) {
    return BLOSC2_ERROR_INVALID_HEADER;
  }

  // Sanity check for uncompressed size
  if (*nbytes < 0 || *nbytes > BLOSC2_MAX_NBYTES) {
    return BLOSC2_ERROR_INVALID_HEADER;
  }

  // Sanity check for compressed size
  if (*cbytes < 0 || *cbytes > BLOSC2_MAX_CBYTES) {
    return BLOSC2_ERROR_INVALID_HEADER;
  }

  // Sanity check for block size
  if (*blocksize < 0 || *blocksize > BLOSC2_MAX_BLOCKSIZE) {
    return BLOSC2_ERROR_INVALID_HEADER;
  }

  // Sanity check for chunk size
  if (*chunksize < 0 || *chunksize > BLOSC2_MAX_CHUNKSIZE) {
    return BLOSC2_ERROR_INVALID_HEADER;
  }

  // Sanity check for type size
  if (*typesize < 0 || *typesize > BLOSC2_MAX_TYPESIZE) {
    return BLOSC2_ERROR_INVALID_HEADER;
  }