// Fetch some internal lengths
from_big(header_len, frame_pointer + FRAME_HEADER_LEN, sizeof(*header_len));
// Convert several fields from the header data in the frame to native byte order.
// These fields include frame length, uncompressed size, compressed size,
// block size, chunk size, and type size, depending on provided pointers.
// Return an error code if any of the fields are invalid or if the header length is out of bounds.
if (from_big(frame_len, frame_pointer + FRAME_LEN, sizeof(*frame_len)) < 0) {
  return BLOSC2_ERROR_INVALID_HEADER;
}
if (from_big(nbytes, frame_pointer + FRAME_NBYTES, sizeof(*nbytes)) < 0) {
  return BLOSC2_ERROR_INVALID_HEADER;
}
if (from_big(cbytes, frame_pointer + FRAME_CBYTES, sizeof(*cbytes)) < 0) {
  return BLOSC2_ERROR_INVALID_HEADER;
}
if (from_big(blocksize, frame_pointer + FRAME_BLOCKSIZE, sizeof(*blocksize)) < 0) {
  return BLOSC2_ERROR_INVALID_HEADER;
}
if (from_big(chunksize, frame_pointer + FRAME_CHUNKSIZE, sizeof(*chunksize)) < 0) {
  return BLOSC2_ERROR_INVALID_HEADER;
}
if (from_big(nchunks, frame_pointer + FRAME_NCHUNKS, sizeof(*nchunks)) < 0) {
  return BLOSC2_ERROR_INVALID_HEADER;
}
if (from_big(typesize, frame_pointer + FRAME_TYPESIZE, sizeof(*typesize)) < 0) {
  return BLOSC2_ERROR_INVALID_HEADER;
}
if (*header_len < FRAME_HEADER_MINLEN) {
  return BLOSC2_ERROR_INVALID_HEADER;
}
if (*header_len > FRAME_HEADER_MAXLEN) {
  return BLOSC2_ERROR_INVALID_HEADER;
}
if (*frame_len < 0) {
  return BLOSC2_ERROR_INVALID_HEADER;
}
if (*nbytes < 0) {
  return BLOSC2_ERROR_INVALID_HEADER;
}
if (*cbytes < 0) {
  return BLOSC2_ERROR_INVALID_HEADER;
}
if (*blocksize < 0) {
  return BLOSC2_ERROR_INVALID_HEADER;
}
if (*chunksize < 0) {
  return BLOSC2_ERROR_INVALID_HEADER;
}
if (*nchunks < 0) {
  return BLOSC2_ERROR_INVALID_HEADER;
}
if (*typesize < 0) {
  return BLOSC2_ERROR_INVALID_HEADER;
}
if (*nbytes < 0 || *nbytes > *frame_len) {
  return BLOSC2_ERROR_INVALID_HEADER;
}
if (*cbytes < 0 || *cbytes > *nbytes) {
  return BLOSC2_ERROR_INVALID_HEADER;
}
if (*blocksize < 0 || *blocksize > *chunksize) {
  return BLOSC2_ERROR_INVALID_HEADER;
}
if (*chunksize < 0 || *chunksize > *nbytes) {
  return BLOSC2_ERROR_INVALID_HEADER;
}
if (*nchunks < 0 || *nchunks > *nbytes / *chunksize) {
  return BLOSC2_ERROR_INVALID_HEADER;
}