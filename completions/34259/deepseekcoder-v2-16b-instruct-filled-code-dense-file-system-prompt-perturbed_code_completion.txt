// Convert several fields from the header data in the frame to native byte order.
  // These fields include frame length, uncompressed size, compressed size,
  // block size, chunk size, and type size, depending on provided pointers.
  // Return an error code if any of the fields are invalid or if the header length is out of bounds.
  from_big(frame_pointer + FRAME_LEN, &frame_len, sizeof(frame_len));
  from_big(frame_pointer + FRAME_NBYTES, &nbytes, sizeof(nbytes));
  from_big(frame_pointer + FRAME_CBYTES, &cbytes, sizeof(cbytes));
  from_big(frame_pointer + FRAME_BLOCKSIZE, &blocksize, sizeof(blocksize));
  from_big(frame_pointer + FRAME_CHUNKSIZE, &chunksize, sizeof(chunksize));
  from_big(frame_pointer + FRAME_TYPESIZE, &typesize, sizeof(typesize));

  // Validate the header length
  if (*header_len != FRAME_HEADER_MINLEN) {
    return BLOSC2_ERROR_INVALID_HEADER;
  }

  // Validate the frame length
  if (frame_len <= 0 || frame_len < *header_len + FRAME_TRAILER_MINLEN) {
    return BLOSC2_ERROR_INVALID_HEADER;
  }

  // Validate the uncompressed size
  if (nbytes <= 0) {
    return BLOSC2_ERROR_INVALID_HEADER;
  }

  // Validate the compressed size
  if (cbytes <= 0 || cbytes > nbytes) {
    return BLOSC2_ERROR_INVALID_HEADER;
  }

  // Validate the block size
  if (blocksize <= 0) {
    return BLOSC2_ERROR_INVALID_HEADER;
  }

  // Validate the chunk size
  if (chunksize <= 0 || chunksize > nbytes) {
    return BLOSC2_ERROR_INVALID_HEADER;
  }

  // Validate the type size
  if (typesize <= 0) {
    return BLOSC2_ERROR_INVALID_HEADER;
  }