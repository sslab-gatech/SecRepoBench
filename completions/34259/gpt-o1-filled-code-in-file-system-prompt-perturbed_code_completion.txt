// Make sure we can read all required fields from the header
  if ((uint32_t)*header_len < FRAME_CHUNKSIZE + 4) {
    BLOSC_TRACE_ERROR("Header length is too small to contain all required fields.");
    return BLOSC2_ERROR_INVALID_HEADER;
  }

  // Convert frame length
  if (frame_len != NULL) {
    from_big(frame_len, frame_pointer + FRAME_LEN, sizeof(*frame_len));
    if (*frame_len < FRAME_HEADER_MINLEN) {
      BLOSC_TRACE_ERROR("Frame length in header is smaller than the minimum required.");
      return BLOSC2_ERROR_INVALID_HEADER;
    }
  }

  // Convert uncompressed size
  if (nbytes != NULL) {
    from_big(nbytes, frame_pointer + FRAME_NBYTES, sizeof(*nbytes));
    if (*nbytes < 0) {
      BLOSC_TRACE_ERROR("Invalid uncompressed size in frame header.");
      return BLOSC2_ERROR_INVALID_HEADER;
    }
  }

  // Convert compressed size
  if (cbytes != NULL) {
    from_big(cbytes, frame_pointer + FRAME_CBYTES, sizeof(*cbytes));
    if (*cbytes < 0) {
      BLOSC_TRACE_ERROR("Invalid compressed size in frame header.");
      return BLOSC2_ERROR_INVALID_HEADER;
    }
  }

  // Convert type size
  if (typesize != NULL) {
    int32_t tsize;
    from_big(&tsize, frame_pointer + FRAME_TYPESIZE, sizeof(tsize));
    if (tsize < 1 || tsize > 255) {
      BLOSC_TRACE_ERROR("Invalid typesize in frame header.");
      return BLOSC2_ERROR_INVALID_HEADER;
    }
    *typesize = tsize;
  }

  // Convert block size
  if (blocksize != NULL) {
    int32_t bsize;
    from_big(&bsize, frame_pointer + FRAME_BLOCKSIZE, sizeof(bsize));
    if (bsize < 0) {
      BLOSC_TRACE_ERROR("Invalid block size in frame header.");
      return BLOSC2_ERROR_INVALID_HEADER;
    }
    *blocksize = bsize;
  }

  // Convert chunk size
  if (chunksize != NULL) {
    int32_t csize;
    from_big(&csize, frame_pointer + FRAME_CHUNKSIZE, sizeof(csize));
    if (csize < 0) {
      BLOSC_TRACE_ERROR("Invalid chunk size in frame header.");
      return BLOSC2_ERROR_INVALID_HEADER;
    }
    *chunksize = csize;
  }