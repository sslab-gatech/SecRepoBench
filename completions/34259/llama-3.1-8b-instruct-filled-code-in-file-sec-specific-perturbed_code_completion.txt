// Fetch some internal lengths
from_big(header_len, frame_pointer + FRAME_HEADER_LEN, sizeof(*header_len));
// Convert several fields from the header data in the frame to native byte order.
// These fields include frame length, uncompressed size, compressed size,
// block size, chunk size, and type size, depending on provided pointers.
// Return an error code if any of the fields are invalid or if the header length is out of bounds.
// <MASK>

// Check that the header length is valid
if (header_len < FRAME_HEADER_MINLEN) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the frame length is valid
if (frame_len < 0 || frame_len > INT64_MAX - header_len) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the uncompressed size is valid
if (nbytes < 0 || nbytes > INT64_MAX - header_len) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the compressed size is valid
if (cbytes < 0 || cbytes > INT64_MAX - header_len) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the block size is valid
if (blocksize < 0 || blocksize > INT32_MAX) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the chunk size is valid
if (chunksize < 0 || chunksize > INT32_MAX) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks < 0 || nchunks > INT32_MAX) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the type size is valid
if (typesize < 0 || typesize > INT32_MAX) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the compression code is valid
if (compcode < 0 || compcode >= BLOSC_LAST_CODEC) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the compression level is valid
if (clevel < 0 || clevel > BLOSC_MAX_LEVEL) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of filters is valid
if (nfilters < 0 || nfilters > BLOSC2_MAX_FILTERS) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the filter pipeline is valid
if (filters == NULL || filters_meta == NULL) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks == 0 && (nbytes > 0 || cbytes > 0)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (nbytes % chunksize!= 0)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the compressed size is valid
if (cbytes < 0 || cbytes > INT64_MAX - header_len) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (cbytes < (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (nbytes < (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (cbytes < nbytes)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (cbytes > nbytes)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (cbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (nbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (cbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (nbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (cbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (nbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (cbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (nbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (cbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (nbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (cbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (nbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (cbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (nbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (cbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (nbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (cbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (nbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (cbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (nbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (cbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (nbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (cbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (nbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (cbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (nbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (cbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (nbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (cbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (nbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (cbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (nbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (cbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (nbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (cbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (nbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (cbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (nbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (cbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (nbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (cbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (nbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (cbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (nbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (cbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (nbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (cbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (nbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (cbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (nbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks is valid
if (nchunks > 0 && (cbytes!= (int64_t)nchunks * chunksize)) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Check that the number of chunks i