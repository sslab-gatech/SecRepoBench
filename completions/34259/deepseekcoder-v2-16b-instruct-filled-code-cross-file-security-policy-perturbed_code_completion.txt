// Validate critical input values
if (header_len < FRAME_HEADER_MINLEN || typesize <= 0) {
  BLOSC_TRACE_ERROR("Invalid header length or typesize.");
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Convert several fields from the header data in the frame to native byte order.
// These fields include frame length, uncompressed size, compressed size,
// block size, chunk size, and type size, depending on provided pointers.
// Return an error code if any of the fields are invalid or if the header length is out of bounds.

// Frame length
from_big(frame_len, frame_pointer + FRAME_FRAME_LEN, sizeof(*frame_len));
if (*frame_len <= 0) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Uncompressed size
from_big(nbytes, frame_pointer + FRAME_NBYTES, sizeof(*nbytes));
if (*nbytes < 0) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Compressed size
from_big(cbytes, frame_pointer + FRAME_CBYTES, sizeof(*cbytes));
if (*cbytes < 0) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Block size
from_big(blocksize, frame_pointer + FRAME_BLOCKSIZE, sizeof(*blocksize));
if (*blocksize <= 0) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Chunk size
from_big(chunksize, frame_pointer + FRAME_CHUNKSIZE, sizeof(*chunksize));
if (*chunksize <= 0) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

// Type size
from_big(typesize, frame_pointer + FRAME_TYPESIZE, sizeof(*typesize));
if (*typesize <= 0) {
  return BLOSC2_ERROR_INVALID_HEADER;
}