Below is the content of a C/C++ function where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
void Cleanup (std::string& input_string) const {
        // This function cleans up a given file path by performing various operations to standardize it.
        // It first checks if the input string is empty and returns if so. It then removes leading spaces
        // or new lines from the path. The function iterates through each character in the path to 
        // replace both forward slashes ('/') and backslashes ('\\') with the operating system's 
        // directory separator. It ensures double delimiters are reduced to single delimiters and 
        // handles special cases such as skipping over "://" and "\\\\" sequences. Additionally, it
        // detects and converts hexadecimal sequences (e.g., %20) in URIs to their respective characters.
        // <MASK>
    }
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// code/AssetLib/XGL/XGLLoader.h
std::string GetElementName();

// the below code fragment can be found in:
// code/AssetLib/X3D/X3DExporter.cpp
X3DExporter::X3DExporter(const char *pFileName, IOSystem *pIOSystem, const aiScene *pScene, const ExportProperties * /*pProperties*/) :
        mScene(pScene) {
    list<SAttribute> attr_list;

    mOutFile = pIOSystem->Open(pFileName, "wt");
    if (mOutFile == nullptr) throw DeadlyExportError("Could not open output .x3d file: " + string(pFileName));

    // Begin document
    XML_Write("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
    XML_Write("<!DOCTYPE X3D PUBLIC \"ISO//Web3D//DTD X3D 3.3//EN\" \"http://www.web3d.org/specifications/x3d-3.3.dtd\">\n");
    // Root node
    attr_list.push_back({ "profile", "Interchange" });
    attr_list.push_back({ "version", "3.3" });
    attr_list.push_back({ "xmlns:xsd", "http://www.w3.org/2001/XMLSchema-instance" });
    attr_list.push_back({ "xsd:noNamespaceSchemaLocation", "http://www.web3d.org/specifications/x3d-3.3.xsd" });
    NodeHelper_OpenNode("X3D", 0, false, attr_list);
    attr_list.clear();
    // <head>: meta data.
    NodeHelper_OpenNode("head", 1);
    XML_Write(mIndentationString + "<!-- All \"meta\" from this section tou will found in <Scene> node as MetadataString nodes. -->\n");
    NodeHelper_CloseNode("head", 1);
    // Scene node.
    NodeHelper_OpenNode("Scene", 1);
    Export_Node(mScene->mRootNode, 2);
    NodeHelper_CloseNode("Scene", 1);
    // Close Root node.
    NodeHelper_CloseNode("X3D", 0);
    // Cleanup
    pIOSystem->Close(mOutFile);
    mOutFile = nullptr;
}

// the below code fragment can be found in:
// code/AssetLib/3MF/D3MFExporter.h
namespace Assimp {

class IOStream;

namespace D3MF {


struct OpcPackageRelationship;

class D3MFExporter {
public:
    D3MFExporter( const char* pFile, const aiScene* pScene );
    ~D3MFExporter();
    bool validate();
    bool exportArchive( const char *file );
    bool exportContentTypes();
    bool exportRelations();
    bool export3DModel();

protected:
    void writeHeader();
    void writeMetaData();
    void writeBaseMaterials();
    void writeObjects();
    void writeMesh( aiMesh *mesh );
    void writeVertex( const aiVector3D &pos );
    void writeFaces( aiMesh *mesh, unsigned int matIdx );
    void writeBuild();

    // Zip the data
    void zipContentType( const std::string &filename );
    void zipModel( const std::string &folder, const std::string &modelName );
    void zipRelInfo( const std::string &folder, const std::string &relName );
    void addFileInZip( const std::string &entry, const std::string &content );

private:
    std::string mArchiveName;
    zip_t *m_zipArchive;
    const aiScene *mScene;
    std::ostringstream mModelOutput;
    std::ostringstream mRelOutput;
    std::ostringstream mContentOutput;
    std::vector<unsigned int> mBuildItems;
    std::vector<OpcPackageRelationship*> mRelations;
};


} // Namespace D3MF
}

// the below code fragment can be found in:
// code/Pbrt/PbrtExporter.h
namespace Assimp {

class IOSystem;
class IOStream;
class ExportProperties;

// ---------------------------------------------------------------------
/** Helper class to export a given scene to a Pbrt file. */
// ---------------------------------------------------------------------
class PbrtExporter
{
public:
    /// Constructor for a specific scene to export
    PbrtExporter(const aiScene *pScene, IOSystem *pIOSystem,
            const std::string &path, const std::string &file);

    /// Destructor
    virtual ~PbrtExporter();

private:
    // the scene to export
    const aiScene* mScene;

    /// Stringstream to write all output into
    std::stringstream mOutput;

    /// The IOSystem for output
    IOSystem* mIOSystem;

    /// Path of the directory where the scene will be exported
    const std::string mPath;

    /// Name of the file (without extension) where the scene will be exported
    const std::string mFile;

private:
    //  A private set to keep track of which textures have been declared
    std::set<std::string> mTextureSet;

    aiMatrix4x4 GetNodeTransform(const aiString& name) const;
    static std::string TransformAsString(const aiMatrix4x4& m);

    static std::string RemoveSuffix(std::string filename);
    std::string CleanTextureFilename(const aiString &f, bool rewriteExtension = true) const;

    void WriteMetaData();

    void WriteWorldDefinition();

    void WriteCameras();
    void WriteCamera(int i);

    void WriteLights();

    void WriteTextures();
    static bool TextureHasAlphaMask(const std::string &filename);

    void WriteMaterials();
    void WriteMaterial(int i);

    void WriteMesh(aiMesh* mesh);

    void WriteInstanceDefinition(int i);
    void WriteGeometricObjects(aiNode* node, aiMatrix4x4 parentTransform,
                               std::map<int, int> &meshUses);
};

}

// the below code fragment can be found in:
// code/AssetLib/Q3BSP/Q3BSPFileImporter.h
namespace Assimp {
    class ZipArchiveIOSystem;

namespace Q3BSP {
    struct Q3BSPModel;
    struct sQ3BSPFace;
}

// ------------------------------------------------------------------------------------------------
/** Loader to import BSP-levels from a PK3 archive or from a unpacked BSP-level.
 */
// ------------------------------------------------------------------------------------------------
class Q3BSPFileImporter : public BaseImporter {
public:
    /// @brief  Default constructor.
    Q3BSPFileImporter();

    /// @brief  Destructor.
    ~Q3BSPFileImporter() override;

    /// @brief  Returns whether the class can handle the format of the given file.
    /// @remark See BaseImporter::CanRead() for details.
    bool CanRead( const std::string& pFile, IOSystem* pIOHandler, bool checkSig ) const override;

protected:
    using FaceMap = std::map<std::string, std::vector<Q3BSP::sQ3BSPFace*>*>;
    using FaceMapIt = std::map<std::string, std::vector<Q3BSP::sQ3BSPFace*>* >::iterator;
    using FaceMapConstIt = std::map<std::string, std::vector<Q3BSP::sQ3BSPFace*>*>::const_iterator;

    const aiImporterDesc* GetInfo () const override;
    void InternReadFile(const std::string& pFile, aiScene* pScene, IOSystem* pIOHandler) override;
    void separateMapName( const std::string &rImportName, std::string &rArchiveName, std::string &rMapName );
    bool findFirstMapInArchive(ZipArchiveIOSystem &rArchive, std::string &rMapName );
    void CreateDataFromImport( const Q3BSP::Q3BSPModel *pModel, aiScene* pScene, ZipArchiveIOSystem *pArchive );
    void CreateNodes( const Q3BSP::Q3BSPModel *pModel, aiScene* pScene, aiNode *pParent );
    aiNode *CreateTopology( const Q3BSP::Q3BSPModel *pModel, unsigned int materialIdx,
        std::vector<Q3BSP::sQ3BSPFace*> &rArray, aiMesh  **pMesh );
    void createTriangleTopology( const Q3BSP::Q3BSPModel *pModel, Q3BSP::sQ3BSPFace *pQ3BSPFace, aiMesh* pMesh, unsigned int &rFaceIdx,
        unsigned int &rVertIdx  );
    void createMaterials( const Q3BSP::Q3BSPModel *pModel, aiScene* pScene, ZipArchiveIOSystem *pArchive );
    size_t countData( const std::vector<Q3BSP::sQ3BSPFace*> &rArray ) const;
    size_t countFaces( const std::vector<Q3BSP::sQ3BSPFace*> &rArray ) const;
    size_t countTriangles( const std::vector<Q3BSP::sQ3BSPFace*> &rArray ) const;
    void createMaterialMap( const Q3BSP::Q3BSPModel *pModel);
    aiFace *getNextFace( aiMesh *pMesh, unsigned int &rFaceIdx );
    bool importTextureFromArchive( const Q3BSP::Q3BSPModel *pModel, ZipArchiveIOSystem *pArchive, aiScene* pScene,
        aiMaterial *pMatHelper, int textureId );
    bool importLightmap( const Q3BSP::Q3BSPModel *pModel, aiScene* pScene, aiMaterial *pMatHelper, int lightmapId );
    bool importEntities( const Q3BSP::Q3BSPModel *pModel, aiScene* pScene );
    bool expandFile(ZipArchiveIOSystem *pArchive, const std::string &rFilename, const std::vector<std::string> &rExtList,
        std::string &rFile, std::string &rExt );

private:
    aiMesh *m_pCurrentMesh;
    aiFace *m_pCurrentFace;
    FaceMap m_MaterialLookupMap;
    std::vector<aiTexture*> mTextures;
};

// ------------------------------------------------------------------------------------------------

}
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).