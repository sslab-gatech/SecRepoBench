void Cleanup(std::string& input_string) const {
    // Check if the input string is empty
    if (input_string.empty()) {
        return;
    }

    // Remove leading spaces or new lines
    input_string.erase(0, input_string.find_first_not_of(" \n"));

    // Replace all forward slashes and backslashes with the operating system's directory separator
    for (size_t i = 0; i < input_string.length(); i++) {
        if (input_string[i] == '/' || input_string[i] == '\\') {
            input_string[i] = mSep;
        }
    }

    // Reduce double delimiters to single delimiters
    size_t pos = 0;
    while ((pos = input_string.find(mSep + mSep, pos)) != std::string::npos) {
        input_string.erase(pos, 1);
    }

    // Handle special cases: skip over "://" and "\\\\" sequences
    pos = 0;
    while ((pos = input_string.find("://", pos)) != std::string::npos) {
        pos += 3;
    }
    pos = 0;
    while ((pos = input_string.find("\\\\", pos)) != std::string::npos) {
        pos += 2;
    }

    // Detect and convert hexadecimal sequences (e.g., %20) in URIs to their respective characters
    pos = 0;
    while ((pos = input_string.find('%', pos)) != std::string::npos) {
        if (pos + 2 < input_string.length() && IsHex(input_string[pos + 1]) && IsHex(input_string[pos + 2])) {
            char hex[3] = {input_string[pos + 1], input_string[pos + 2], '\0'};
            input_string[pos] = static_cast<char>(std::strtol(hex, nullptr, 16));
            input_string.erase(pos + 1, 2);
        }
        pos++;
    }
}