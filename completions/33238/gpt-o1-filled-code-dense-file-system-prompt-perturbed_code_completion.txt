if (input_string.empty()) {
    return;
}

// Remove leading whitespace
{
    size_t startPos = input_string.find_first_not_of(" \t\r\n");
    if (startPos != std::string::npos) {
        input_string.erase(0, startPos);
    }
}

// Remove trailing whitespace
{
    size_t endPos = input_string.find_last_not_of(" \t\r\n");
    if (endPos != std::string::npos) {
        input_string.erase(endPos + 1);
    }
}

std::string standardized;
standardized.reserve(input_string.size());

// Process slashes and protocol separators
bool inProtocol = false;
for (size_t i = 0; i < input_string.size(); ++i) {
    // Detect a protocol "://"
    if (!inProtocol && i + 2 < input_string.size() && input_string.compare(i, 3, "://") == 0) {
        standardized += "://";
        i += 2;
        inProtocol = true;
        continue;
    }

    char c = input_string[i];
    if (c == '/' || c == '\\') {
        // Reduce consecutive delimiters to one
        if (!standardized.empty() && (standardized.back() == '/' || standardized.back() == '\\')) {
            continue;
        }
        standardized.push_back('/');
    } else {
        standardized.push_back(c);
    }
}

// Decode percent-encoded sequences
std::string decoded;
decoded.reserve(standardized.size());
for (size_t i = 0; i < standardized.size(); ++i) {
    if (standardized[i] == '%' &&
        i + 2 < standardized.size() &&
        std::isxdigit(static_cast<unsigned char>(standardized[i + 1])) &&
        std::isxdigit(static_cast<unsigned char>(standardized[i + 2]))) {
        // Convert the next two hex digits
        std::string hexValue = standardized.substr(i + 1, 2);
        int val = std::strtol(hexValue.c_str(), nullptr, 16);
        decoded.push_back(static_cast<char>(val));
        i += 2;
    } else {
        decoded.push_back(standardized[i]);
    }
}

input_string = decoded;