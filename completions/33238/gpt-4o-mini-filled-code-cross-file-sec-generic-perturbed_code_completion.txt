if (input_string.empty()) {
    return;
}

// Remove leading spaces and new lines
input_string.erase(0, input_string.find_first_not_of(" \n\r\t"));

// Replace slashes with the OS-specific directory separator
const char separator = std::filesystem::path::preferred_separator;
for (char& c : input_string) {
    if (c == '/' || c == '\\') {
        c = separator;
    }
}

// Reduce double delimiters to single delimiters
std::string::size_type pos;
while ((pos = input_string.find(std::string(2, separator))) != std::string::npos) {
    input_string.erase(pos, 1);
}

// Handle special cases for "://" and "\\\\"
if (input_string.find("://") != std::string::npos) {
    // Handle URI scheme
    // (No changes needed for "://")
} else {
    // Handle backslash sequences
    while ((pos = input_string.find("\\\\")) != std::string::npos) {
        input_string.replace(pos, 2, std::string(1, separator));
    }
}

// Decode hexadecimal sequences (e.g., %20)
size_t start_pos = 0;
while ((start_pos = input_string.find('%', start_pos)) != std::string::npos) {
    if (start_pos + 2 < input_string.size()) {
        std::string hex = input_string.substr(start_pos + 1, 2);
        char decoded_char = static_cast<char>(strtol(hex.c_str(), nullptr, 16));
        input_string.replace(start_pos, 3, 1, decoded_char);
    } else {
        break; // No valid hex sequence
    }
}