if (input_string.empty()) {
    return;
}

// Remove leading spaces or new lines
size_t start = input_string.find_first_not_of(" \n");
if (start != std::string::npos) {
    input_string = input_string.substr(start);
}

bool skip_next = false;
char os_separator = '/';  // Assuming POSIX-style path separator

for (size_t i = 0; i < input_string.length(); ++i) {
    if (skip_next) {
        skip_next = false;
        continue;
    }

    if (input_string[i] == '/' || input_string[i] == '\\') {
        input_string[i] = os_separator;

        // Handle special cases
        if (i > 0 && input_string[i - 1] == ':') {
            if (i + 1 < input_string.length() && input_string[i + 1] == '/') {
                skip_next = true;
            }
        } else if (i > 0 && input_string[i - 1] == '\\') {
            if (i + 1 < input_string.length() && input_string[i + 1] == '\\') {
                skip_next = true;
            }
        } else {
            // Remove double separators
            while (i + 1 < input_string.length() && (input_string[i + 1] == '/' || input_string[i + 1] == '\\')) {
                input_string.erase(i + 1, 1);
            }
        }
    } else if (input_string[i] == '%' && i + 2 < input_string.length()) {
        // Convert hexadecimal sequences
        std::string hex = input_string.substr(i + 1, 2);
        char ch = static_cast<char>(std::stoi(hex, nullptr, 16));
        input_string.replace(i, 3, 1, ch);
    }
}

// Remove trailing spaces or new lines
size_t end = input_string.find_last_not_of(" \n");
if (end != std::string::npos) {
    input_string = input_string.substr(0, end + 1);
}