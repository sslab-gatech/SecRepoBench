if(input_string.empty())
    return;

input_string.erase(0, input_string.find_first_not_of(" \n\r\t"));

#ifdef _WIN32
    const char dirSep = '\\';
#else
    const char dirSep = '/';
#endif

std::string cleaned;
cleaned.reserve(input_string.size());

for (size_t i = 0; i < input_string.size(); ++i)
{
    char c = input_string[i];

    // Detect and convert hexadecimal sequences (e.g., %20)
    if(c == '%' && i + 2 < input_string.size() &&
       std::isxdigit(input_string[i+1]) && std::isxdigit(input_string[i+2]))
    {
        std::string hexStr = input_string.substr(i + 1, 2);
        char decoded = static_cast<char>(std::strtol(hexStr.c_str(), nullptr, 16));
        cleaned.push_back(decoded);
        i += 2;
        continue;
    }

    // Handle delimiters: replace both '/' and '\' with the system's directory separator
    if(c == '/' || c == '\\')
    {
        // Special case: if the last character is ':' (as in "://"), preserve the original delimiter.
        if(!cleaned.empty() && cleaned.back() == ':')
        {
            cleaned.push_back(c);
            continue;
        }

        // Special case: preserve UNC paths starting with double delimiters.
        if(cleaned.empty() && i + 1 < input_string.size() &&
           (input_string[i+1] == '/' || input_string[i+1] == '\\'))
        {
            cleaned.push_back(dirSep);
            cleaned.push_back(dirSep);
            ++i;
            continue;
        }

        // Reduce multiple consecutive directory separators to a single one.
        if(!cleaned.empty() && cleaned.back() == dirSep)
            continue;

        cleaned.push_back(dirSep);
        continue;
    }

    // Default case: add character as-is.
    cleaned.push_back(c);
}

input_string = cleaned;