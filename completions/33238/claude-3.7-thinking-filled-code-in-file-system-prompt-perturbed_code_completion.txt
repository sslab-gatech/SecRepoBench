void Cleanup (std::string& input_string) const {
    // Return if the input is empty
    if (input_string.empty()) {
        return;
    }

    // Remove leading spaces or newlines
    std::string::size_type start = input_string.find_first_not_of(" \r\n\t");
    if (start != 0 && start != std::string::npos) {
        input_string = input_string.substr(start);
    }

    for (std::string::size_type i = 0; i < input_string.length(); ++i) {
        // Convert URI hex sequences (e.g., %20 for space)
        if (input_string[i] == '%' && i + 2 < input_string.length() && 
            IsHex(input_string[i+1]) && IsHex(input_string[i+2])) {
            const char hex[3] = { input_string[i+1], input_string[i+2], 0 };
            input_string[i] = (char)strtol(hex, nullptr, 16);
            input_string.erase(i+1, 2);
        }
        // Handle path separators
        else if (input_string[i] == '/' || input_string[i] == '\\') {
            // Skip for "://" (URL schemes)
            if (i > 0 && input_string[i-1] == ':' && 
                i+1 < input_string.length() && (input_string[i+1] == '/' || input_string[i+1] == '\\')) {
                ++i;  // Skip the next separator
                continue;
            }
            
            // Skip for "\\\\" at beginning (UNC paths)
            if (i == 0 && i+1 < input_string.length() && 
                (input_string[i+1] == '/' || input_string[i+1] == '\\')) {
                ++i;  // Skip the next separator
                continue;
            }
            
            // Replace with OS separator
            input_string[i] = mSep;
            
            // Remove duplicate separators
            while (i+1 < input_string.length() && 
                  (input_string[i+1] == '/' || input_string[i+1] == '\\')) {
                input_string.erase(i+1, 1);
            }
        }
    }
}