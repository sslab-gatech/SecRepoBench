if (input_string.empty()) {
    return;
}

// Remove leading spaces or new lines
size_t start = 0;
while (start < input_string.size() && (input_string[start] == ' ' || input_string[start] == '\n' || input_string[start] == '\r')) {
    start++;
}
if (start > 0) {
    input_string = input_string.substr(start);
}

// Define the OS directory separator
#ifdef _WIN32
    const char separator = '\\';
#else
    const char separator = '/';
#endif

size_t i = 0;
while (i < input_string.size()) {
    // Handle "://" protocol specifier (like http://)
    if (i > 0 && i < input_string.size() - 2 && 
        input_string[i] == ':' && input_string[i + 1] == '/' && input_string[i + 2] == '/') {
        i += 3; // Skip over the "://" without modifying it
        continue;
    }

    // Handle network path "\\server" specifier
    if (i == 0 && i < input_string.size() - 1 && 
        input_string[i] == '\\' && input_string[i + 1] == '\\') {
        i += 2; // Skip over the "\\" without modifying it
        continue;
    }

    // Replace slashes with directory separator
    if (input_string[i] == '/' || input_string[i] == '\\') {
        input_string[i] = separator;
        
        // Reduce double separators to single
        while (i + 1 < input_string.size() && (input_string[i + 1] == '/' || input_string[i + 1] == '\\')) {
            input_string.erase(i + 1, 1);
        }
    }
    
    // Convert hexadecimal sequences in URIs (like %20 for space)
    if (i < input_string.size() - 2 && input_string[i] == '%') {
        // Check if next two characters are hex digits
        if (isxdigit(input_string[i + 1]) && isxdigit(input_string[i + 2])) {
            std::string hex = input_string.substr(i + 1, 2);
            char ch = static_cast<char>(std::stoi(hex, nullptr, 16));
            input_string.replace(i, 3, 1, ch);
        }
    }
    
    i++;
}