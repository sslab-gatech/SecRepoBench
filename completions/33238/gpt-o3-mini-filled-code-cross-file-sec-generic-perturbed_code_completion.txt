{
    // Remove leading whitespace and newlines
    input_string.erase(0, input_string.find_first_not_of(" \n\r\t"));
    if(input_string.empty())
        return;

    std::string result;
#ifdef _WIN32
    const char sep = '\\';
#else
    const char sep = '/';
#endif

    for (size_t i = 0, n = input_string.size(); i < n; ++i) {
        // If at the very beginning, preserve UNC prefix (e.g. "\\server")
        if(i == 0 && i + 1 < n &&
           ((input_string[i] == '/' || input_string[i] == '\\') &&
            (input_string[i+1] == '/' || input_string[i+1] == '\\')))
        {
            result.push_back(sep);
            result.push_back(sep);
            ++i; // skip the second slash
            continue;
        }

        // Check for "://" sequence; do not modify its slashes.
        if (input_string[i] == ':' && i + 2 < n &&
            input_string[i+1] == '/' && input_string[i+2] == '/')
        {
            result.push_back(':');
            result.push_back('/');
            result.push_back('/');
            i += 2; // skip the "://"
            continue;
        }

        // Detect percent-encoded hex sequences, e.g., "%20"
        if (input_string[i] == '%' && i + 2 < n &&
            std::isxdigit(static_cast<unsigned char>(input_string[i+1])) &&
            std::isxdigit(static_cast<unsigned char>(input_string[i+2])))
        {
            char hex[3] = { input_string[i+1], input_string[i+2], '\0' };
            char decoded = static_cast<char>(std::strtol(hex, nullptr, 16));
            result.push_back(decoded);
            i += 2; // skip the two hex digits
            continue;
        }

        // Replace directory separators with OS's preferred separator.
        if (input_string[i] == '/' || input_string[i] == '\\') {
            // Avoid multiple consecutive separators
            if (!result.empty() && result.back() == sep)
                continue;
            result.push_back(sep);
            continue;
        }

        // Default: copy the character as is.
        result.push_back(input_string[i]);
    }

    input_string = result;
}