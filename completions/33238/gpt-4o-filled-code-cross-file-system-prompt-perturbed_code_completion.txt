if (input_string.empty()) {
        return;
    }

    // Remove leading spaces and new lines
    size_t start = input_string.find_first_not_of(" \n\r\t");
    if (start != std::string::npos) {
        input_string = input_string.substr(start);
    }

    // Replace slashes and handle double delimiters
    std::string result;
    bool last_was_delimiter = false;
    for (size_t i = 0; i < input_string.size(); ++i) {
        char c = input_string[i];

        // Handle "://" and "\\\\" sequences
        if ((c == ':' && i + 2 < input_string.size() && input_string[i + 1] == '/' && input_string[i + 2] == '/') ||
            (c == '\\' && i + 1 < input_string.size() && input_string[i + 1] == '\\')) {
            result += c;
            last_was_delimiter = false;
            continue;
        }

        // Convert slashes to the system's directory separator
        if (c == '/' || c == '\\') {
            if (!last_was_delimiter) {
                result += std::filesystem::path::preferred_separator;
                last_was_delimiter = true;
            }
        } else {
            result += c;
            last_was_delimiter = false;
        }
    }

    // Decode percent-encoded characters
    for (size_t i = 0; i < result.size(); ++i) {
        if (result[i] == '%' && i + 2 < result.size() &&
            std::isxdigit(result[i + 1]) && std::isxdigit(result[i + 2])) {
            std::string hex = result.substr(i + 1, 2);
            char decoded_char = static_cast<char>(std::stoi(hex, nullptr, 16));
            result.replace(i, 3, 1, decoded_char);
        }
    }

    input_string = result;