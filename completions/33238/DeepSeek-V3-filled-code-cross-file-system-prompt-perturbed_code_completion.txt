if (input_string.empty()) {
    return;
}

// Remove leading whitespace and newlines
input_string.erase(0, input_string.find_first_not_of(" \n\r\t"));

char prev_char = '\0';
bool in_hex_sequence = false;
std::string hex_buffer;
std::string result;

for (size_t i = 0; i < input_string.size(); ++i) {
    char c = input_string[i];
    
    if (in_hex_sequence) {
        if (isxdigit(c)) {
            hex_buffer += c;
            if (hex_buffer.size() == 2) {
                int value;
                sscanf(hex_buffer.c_str(), "%02x", &value);
                result += static_cast<char>(value);
                in_hex_sequence = false;
                hex_buffer.clear();
            }
        } else {
            result += '%' + hex_buffer;
            in_hex_sequence = false;
            hex_buffer.clear();
            --i; // reprocess current character
        }
        continue;
    }

    if (c == '%') {
        in_hex_sequence = true;
        continue;
    }

    // Handle path separators
    if (c == '/' || c == '\\') {
        // Skip if previous character was also a separator
        if (prev_char == '/' || prev_char == '\\') {
            continue;
        }
        // Skip if part of :// or \\ sequences
        if (i > 0 && input_string[i-1] == ':' && c == '/') {
            result += "://";
            i += 1; // skip next slash
            prev_char = '/';
            continue;
        }
        if (i > 0 && input_string[i-1] == '\\' && c == '\\') {
            result += "\\\\";
            i += 1; // skip next backslash
            prev_char = '\\';
            continue;
        }
        c = '/'; // normalize to forward slash
    }

    result += c;
    prev_char = c;
}

input_string = result;