if (input_string.empty()) {
    return;
}

// Remove leading spaces and newlines
size_t start = input_string.find_first_not_of(" \n\r\t");
if (start != std::string::npos) {
    input_string = input_string.substr(start);
} else {
    input_string.clear();
    return;
}

char delimiter =
#ifdef _WIN32
    '\\';
#else
    '/';
#endif

std::string result;
result.reserve(input_string.size());
size_t i = 0;
while (i < input_string.size()) {
    char c = input_string[i];

    // Handle URI hex encoding: %XX
    if (c == '%' && i + 2 < input_string.size() &&
        isxdigit(input_string[i + 1]) && isxdigit(input_string[i + 2])) {
        char hex[3] = { input_string[i + 1], input_string[i + 2], 0 };
        char decoded = static_cast<char>(strtol(hex, nullptr, 16));
        result += decoded;
        i += 3;
        continue;
    }

    // Handle "://" and "\\\\"
    if ((c == ':' && i + 2 < input_string.size() && input_string[i + 1] == '/' && input_string[i + 2] == '/') ||
        (c == '\\' && i + 1 < input_string.size() && input_string[i + 1] == '\\')) {
        result += c;
        ++i;
        while (i < input_string.size() && (input_string[i] == '/' || input_string[i] == '\\')) {
            result += input_string[i];
            ++i;
        }
        continue;
    }

    // Replace slashes/backslashes with delimiter
    if (c == '/' || c == '\\') {
        // Avoid double delimiters
        if (!result.empty() && result.back() == delimiter) {
            ++i;
            continue;
        }
        result += delimiter;
    } else {
        result += c;
    }
    ++i;
}

// Remove trailing delimiters (except for root "/")
while (result.size() > 1 && result.back() == delimiter) {
    result.pop_back();
}

input_string = result;