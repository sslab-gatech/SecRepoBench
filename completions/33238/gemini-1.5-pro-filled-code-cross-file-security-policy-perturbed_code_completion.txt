if (input_string.empty()) {
            return;
        }

        // Remove leading spaces and newlines
        size_t first_char = input_string.find_first_not_of(" \r\n");
        if (first_char != std::string::npos && first_char > 0) {
            if (first_char <= input_string.length()) {
                input_string.erase(0, first_char);
            }
        }


        for (size_t i = 0; i < input_string.length(); ++i) {
            if (input_string[i] == '/' || input_string[i] == '\\') {
                input_string[i] = directory_separator;
            }
        }

        // Reduce double delimiters to single delimiters
        size_t double_delim_pos = input_string.find(std::string(2, directory_separator));

        while (double_delim_pos != std::string::npos && double_delim_pos + 1 < input_string.length()) {
            input_string.erase(double_delim_pos, 1);
            double_delim_pos = input_string.find(std::string(2, directory_separator));
        }

        size_t pos = input_string.find("://");
        if (pos != std::string::npos && pos + 2 < input_string.length()) {
            i = pos + 2;
        }

        pos = input_string.find("\\\\");
        if (pos != std::string::npos && pos + 1 < input_string.length()) {
            i = pos + 1;
        }


        // Convert encoded characters in the path.
        size_t perc_pos = input_string.find('%');
        while (perc_pos != std::string::npos && perc_pos + 2 < input_string.length()) {
            char hex_str[3] = { input_string[perc_pos + 1], input_string[perc_pos + 2], '\0' };

            char* p_end;
            char decoded_char = static_cast<char>(strtol(hex_str, &p_end, 16));

            if (*p_end == '\0') {
                input_string.replace(perc_pos, 3, 1, decoded_char);
            }

            perc_pos = input_string.find('%', perc_pos + 1);
        }