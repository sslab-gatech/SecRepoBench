void Cleanup (std::string& input_string) const {
    // If there's nothing to clean up, return immediately.
    if (input_string.empty()) {
        return;
    }

    // Remove leading and trailing whitespace.
    {
        static const char* whitespaces = " \t\r\n";
        const auto startPos = input_string.find_first_not_of(whitespaces);
        if (startPos == std::string::npos) {
            // String is all whitespace, clear it and return.
            input_string.clear();
            return;
        }
        const auto endPos = input_string.find_last_not_of(whitespaces);
        input_string = input_string.substr(startPos, endPos - startPos + 1);
    }

    std::string output;
    output.reserve(input_string.size());
    bool lastWasSeparator = false;

    // Convert all slashes to the OS separator, collapsing duplicates.
    // Skip special cases such as "://" and "\\\\"
    for (size_t i = 0; i < input_string.size(); ++i) {
        const char c = input_string[i];

        // Check for "://" sequence in URIs.
        if ((c == ':') && (i + 2 < input_string.size()) &&
            (input_string[i + 1] == '/') && (input_string[i + 2] == '/')) {
            // Copy them as-is and move on.
            output.push_back(c);
            ++i;
            output.push_back(input_string[i]);
            ++i;
            output.push_back(input_string[i]);
            lastWasSeparator = false;
            continue;
        }

        // Check for "\\\\" sequence (Windows UNC paths).
        if ((c == '\\') && (i + 1 < input_string.size()) &&
            (input_string[i + 1] == '\\')) {
            // Copy them as-is and move on.
            output.push_back(c);
            ++i;
            output.push_back(input_string[i]);
            lastWasSeparator = false;
            continue;
        }

        // Convert single slash or backslash to OS separator.
        if (c == '\\' || c == '/') {
            if (!lastWasSeparator) {
                output.push_back(mSep);
                lastWasSeparator = true;
            }
        } else {
            output.push_back(c);
            lastWasSeparator = false;
        }
    }

    // Decode hexadecimal sequences (e.g., %20)
    for (size_t i = 0; i + 2 < output.size();) {
        if (output[i] == '%' && IsHex(output[i + 1]) && IsHex(output[i + 2])) {
            const char hex[] = { output[i + 1], output[i + 2], '\0' };
            const int decoded = strtol(hex, nullptr, 16);
            output[i] = static_cast<char>(decoded);
            output.erase(i + 1, 2);
        } else {
            ++i;
        }
    }

    // Replace the original with the cleaned path.
    input_string.swap(output);
}