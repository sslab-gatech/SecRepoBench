// -------------------------------------------------------------------
    /** Cleanup the given path
     */
    void Cleanup (std::string& input_string) const {
        // This function cleans up a given file path by performing various operations to standardize it.
        // It first checks if the input string is empty and returns if so. It then removes leading spaces
        // or new lines from the path. The function iterates through each character in the path to
        // replace both forward slashes ('/') and backslashes ('\\') with the operating system's
        // directory separator. It ensures double delimiters are reduced to single delimiters and
        // handles special cases such as skipping over "://" and "\\\\" sequences. Additionally, it
        // detects and converts hexadecimal sequences (e.g., %20) in URIs to their respective characters.

        if (input_string.empty()) {
            return;
        }

        // Remove leading spaces or new lines
        input_string.erase(0, input_string.find_first_not_of(" \n\r\t"));

        // Replace both forward slashes and backslashes with the operating system's directory separator
        std::replace_if(input_string.begin(), input_string.end(), [this](char c) { return c == '/' || c == '\\'; }, mSep);

        // Ensure double delimiters are reduced to single delimiters
        input_string.erase(std::remove(input_string.begin(), input_string.end(), mSep), input_string.end());

        // Handle special cases such as skipping over "://" and "\\\\" sequences
        size_t pos = 0;
        while ((pos = input_string.find("://", pos)) != std::string::npos) {
            input_string.replace(pos, 3, &mSep);
            pos += 2;
        }

        pos = 0;
        while ((pos = input_string.find("\\\\", pos)) != std::string::npos) {
            input_string.replace(pos, 2, 1, mSep);
            pos += 2;
        }

        // Detect and convert hexadecimal sequences in URIs to their respective characters
        pos = 0;
        while ((pos = input_string.find("%", pos)) != std::string::npos) {
            if (IsHex(input_string[pos + 1]) && IsHex(input_string[pos + 2])) {
                char c = static_cast<char>(std::stoi(input_string.substr(pos + 1, 2), nullptr, 16));
                input_string.replace(pos, 3, 1, c);
            } else {
                pos++;
            }
        }
    }