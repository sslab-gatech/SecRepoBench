#ifdef _WIN32
    static const char DIR_SEP = '\\';
#else
    static const char DIR_SEP = '/';
#endif

// Return if the string is empty.
if (input_string.empty()) {
    return;
}

// Remove leading whitespace and newlines.
input_string.erase(0, input_string.find_first_not_of(" \t\r\n"));
if (input_string.empty()) {
    return;
}

std::string cleaned;
cleaned.reserve(input_string.size());

// Special-case flag for skipping double-delimiter checks after "://" or "\\\\".
bool skipDoubleDelimCheck = false;
for (size_t i = 0; i < input_string.size(); ++i) {
    // Detect and skip over "://" or "\\\\" sequences to preserve them.
    if ((i + 2 < input_string.size()) &&
        ((input_string[i] == ':' && input_string[i + 1] == '/' && input_string[i + 2] == '/') ||
         (input_string[i] == '\\' && input_string[i + 1] == '\\'))) {
        cleaned.append(input_string, i, 3);
        i += 2;
        skipDoubleDelimCheck = true;
        continue;
    }

    // Replace backslashes or forward slashes with the OS directory separator.
    if (input_string[i] == '\\' || input_string[i] == '/') {
        // Avoid duplicating the delimiter if the last character added was the same.
        if (!skipDoubleDelimCheck && !cleaned.empty() && cleaned.back() == DIR_SEP) {
            continue;
        }
        cleaned.push_back(DIR_SEP);
        skipDoubleDelimCheck = false;
    }
    else {
        cleaned.push_back(input_string[i]);
        skipDoubleDelimCheck = false;
    }
}

// Decode any %-encoded sequences like "%20".
std::string decoded;
decoded.reserve(cleaned.size());
for (size_t i = 0; i < cleaned.size(); ) {
    if (i + 2 < cleaned.size() && cleaned[i] == '%' &&
        std::isxdigit(static_cast<unsigned char>(cleaned[i + 1])) &&
        std::isxdigit(static_cast<unsigned char>(cleaned[i + 2]))) {
        // Convert two hex digits into a character.
        const std::string hex_value = cleaned.substr(i + 1, 2);
        char ch = static_cast<char>(std::stoi(hex_value, nullptr, 16));
        decoded.push_back(ch);
        i += 3;
    }
    else {
        decoded.push_back(cleaned[i]);
        ++i;
    }
}

input_string = decoded;