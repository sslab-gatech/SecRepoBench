if (input_string.empty()) {
    return;
}

// Remove leading spaces and new lines
size_t start = input_string.find_first_not_of(" \n");
if (start != std::string::npos) {
    input_string.erase(0, start);
}

// Replace slashes with the OS directory separator
char separator = '/'; // Assume '/' is the desired separator for this example
for (size_t i = 0; i < input_string.size(); ++i) {
    if (input_string[i] == '/' || input_string[i] == '\\') {
        input_string[i] = separator;
    }
}

// Reduce double delimiters to single
size_t pos;
while ((pos = input_string.find(std::string(2, separator))) != std::string::npos) {
    input_string.erase(pos, 1);
}

// Handle special cases for "://" and "\\\\"
if (input_string.size() >= 3 && input_string.substr(0, 3) == "://") {
    // Do nothing, keep "://"
} else {
    // Handle other cases as needed
}

// Convert hexadecimal sequences (e.g., %20) to characters
size_t hex_pos;
while ((hex_pos = input_string.find('%')) != std::string::npos) {
    if (hex_pos + 2 < input_string.size()) {
        std::string hex = input_string.substr(hex_pos + 1, 2);
        char decoded_char = static_cast<char>(strtol(hex.c_str(), nullptr, 16));
        input_string.replace(hex_pos, 3, 1, decoded_char);
    } else {
        break; // Not enough characters left for a valid hex sequence
    }
}