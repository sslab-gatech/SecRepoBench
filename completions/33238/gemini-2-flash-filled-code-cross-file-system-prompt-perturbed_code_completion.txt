if (input_string.empty()) {
            return;
        }

        // Remove leading spaces and newlines
        size_t start = input_string.find_first_not_of(" \r\n");
        if (start != std::string::npos) {
            input_string = input_string.substr(start);
        } else {
            input_string.clear();
            return;
        }

        // Replace forward and backward slashes with the OS directory separator
        std::replace_if(input_string.begin(), input_string.end(), [](char c){ return c == '/' || c == '\\'; }, Assimp::IOStream::getDirectorySeparator());

        // Remove duplicate delimiters
        size_t pos = 0;
        while ((pos = input_string.find(std::string(2, Assimp::IOStream::getDirectorySeparator()), pos)) != std::string::npos) {
            // Special cases: skip "://" and "\\\\"
            if (pos > 0 && input_string[pos - 1] == ':') {
                pos += 2;
                continue;
            }
            if (pos > 0 && input_string[pos - 1] == Assimp::IOStream::getDirectorySeparator()) {
                pos += 2;
                continue;
            }

            input_string.replace(pos, 2, std::string(1, Assimp::IOStream::getDirectorySeparator()));
        }

        // Decode URI-encoded characters (e.g., %20 for space)
        pos = 0;
        while ((pos = input_string.find('%', pos)) != std::string::npos) {
            if (pos + 2 < input_string.length() && isxdigit(input_string[pos + 1]) && isxdigit(input_string[pos + 2])) {
                std::string hex_str = input_string.substr(pos + 1, 2);
                unsigned char char_code = static_cast<unsigned char>(std::strtol(hex_str.c_str(), nullptr, 16));
                input_string.replace(pos, 3, 1, char_code);
            } else {
                ++pos;
            }
        }