// Check if the input string is empty
if (input_string.empty()) {
    return;
}

// Remove leading spaces or new lines
size_t start = input_string.find_first_not_of(" \n\r\t");
if (start != std::string::npos) {
    input_string = input_string.substr(start);
} else {
    // If the string contains only whitespace, clear it
    input_string.clear();
    return;
}

// OS specific directory separator
#ifdef _WIN32
    const char dir_sep = '\\';
#else
    const char dir_sep = '/';
#endif

// Iterate through the string and standardize the path
size_t i = 0;
while (i < input_string.length()) {
    // Handle URI-encoded characters (e.g., %20 for space)
    if (input_string[i] == '%' && i + 2 < input_string.length()) {
        // Check if the next two characters are valid hex digits
        if (std::isxdigit(static_cast<unsigned char>(input_string[i + 1])) && 
            std::isxdigit(static_cast<unsigned char>(input_string[i + 2]))) {
            // Convert hex to character
            std::string hex = input_string.substr(i + 1, 2);
            int value;
            std::istringstream iss(hex);
            iss >> std::hex >> value;
            if (!iss.fail()) {
                input_string.replace(i, 3, 1, static_cast<char>(value));
                continue; // Reprocess current position
            }
        }
    }
    
    // Handle path separators
    if (input_string[i] == '/' || input_string[i] == '\\') {
        // Special case for protocol notation (e.g., "http://")
        if (i > 0 && input_string[i - 1] == ':' && 
            i + 1 < input_string.length() && 
            (input_string[i + 1] == '/' || input_string[i + 1] == '\\')) {
            // Skip and preserve the protocol slashes
            i += 2;
            continue;
        }
        
        // Special case for Windows UNC paths (\\server)
        if (i == 0 && i + 1 < input_string.length() && 
            (input_string[i + 1] == '/' || input_string[i + 1] == '\\')) {
            input_string[i] = dir_sep;
            input_string[i + 1] = dir_sep;
            i += 2;
            continue;
        }
        
        // Replace with OS specific directory separator
        input_string[i] = dir_sep;
        
        // Handle consecutive separators (reduce to single)
        if (i + 1 < input_string.length() && 
            (input_string[i + 1] == '/' || input_string[i + 1] == '\\')) {
            input_string.erase(i + 1, 1);
            continue; // Recheck current position
        }
    }
    
    i++;
}

// Remove trailing spaces or new lines
size_t end = input_string.find_last_not_of(" \n\r\t");
if (end != std::string::npos) {
    if (end + 1 < input_string.length()) {
        input_string.erase(end + 1);
    }
} else {
    input_string.clear();
}