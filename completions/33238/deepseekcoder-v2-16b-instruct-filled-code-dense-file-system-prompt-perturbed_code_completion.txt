#include <string>
#include <cctype>
#include <sstream>
#include <iostream>

void Cleanup(std::string& input_string) const {
    if (input_string.empty()) {
        return;
    }

    // Remove leading spaces or new lines from the path
    input_string.erase(0, input_string.find_first_not_of(" \n\r\t"));

    // Replace both forward slashes ('/') and backslashes ('\\') with the operating system's directory separator
    for (size_t i = 0; i < input_string.size(); ++i) {
        if (input_string[i] == '/' || input_string[i] == '\\') {
            input_string[i] = std::isspace(input_string[i]) ? input_string[i] : (std::iswindows() ? '\\' : '/');
        }
    }

    // Ensure double delimiters are reduced to single delimiters
    std::string::size_type pos = 0;
    while ((pos = input_string.find("//", pos)) != std::string::npos) {
        input_string.replace(pos, 2, "/");
    }
    pos = 0;
    while ((pos = input_string.find("\\\\", pos)) != std::string::npos) {
        input_string.replace(pos, 2, "\\");
    }

    // Handle special cases such as skipping over "://" and "\\\\" sequences
    if (input_string.substr(0, 3) == "://") {
        input_string.erase(0, 3);
    } else if (input_string.substr(0, 2) == "\\\\") {
        input_string.erase(0, 2);
    }

    // Detect and convert hexadecimal sequences (e.g., %20) in URIs to their respective characters
    std::string::size_type hex_pos = 0;
    while ((hex_pos = input_string.find("%", hex_pos)) != std::string::npos) {
        if (hex_pos + 2 < input_string.size() && std::isxdigit(input_string[hex_pos + 1]) && std::isxdigit(input_string[hex_pos + 2])) {
            std::string hex_str = input_string.substr(hex_pos + 1, 2);
            char ch = static_cast<char>(std::strtol(hex_str.c_str(), nullptr, 16));
            input_string.replace(hex_pos, 3, 1, ch);
            hex_pos += 1; // Skip the converted character
        } else {
            hex_pos += 1; // Move past the '%'
        }
    }
}