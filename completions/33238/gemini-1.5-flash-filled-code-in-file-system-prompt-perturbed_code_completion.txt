if (input_string.empty()) {
            return;
        }
        // Remove leading spaces or newlines
        size_t first = input_string.find_first_not_of(" \t\r\n");
        if (first != std::string::npos) {
            input_string = input_string.substr(first);
        }
        // Replace slashes with OS separator
        for (size_t i = 0; i < input_string.length(); ++i) {
            if (input_string[i] == '/' || input_string[i] == '\\') {
                input_string[i] = mSep;
            }
        }
        // Reduce double delimiters to single delimiters
        size_t pos = input_string.find(mSep, 0);
        while (pos != std::string::npos) {
            size_t next = input_string.find(mSep, pos + 1);
            if (next != std::string::npos && next == pos + 1) {
                input_string.erase(pos + 1, 1);
                next = std::string::npos;
            }
            pos = input_string.find(mSep, pos + 1);
        }
        // Handle special cases like "://" and "\\\\"
        size_t pos_colon = input_string.find("://");
        if (pos_colon != std::string::npos) {
            size_t next_sep = input_string.find(mSep, pos_colon + 3);
            if (next_sep != std::string::npos) {
                input_string.replace(pos_colon + 3, next_sep - (pos_colon + 3), "");
            }
        }
        size_t pos_bslash = input_string.find("\\\\");
        if (pos_bslash != std::string::npos) {
            size_t next_sep = input_string.find(mSep, pos_bslash + 2);
            if (next_sep != std::string::npos) {
                input_string.replace(pos_bslash + 2, next_sep - (pos_bslash + 2), "");
            }
        }
        // Convert hexadecimal sequences in URIs
        size_t hex_pos = input_string.find('%');
        while (hex_pos != std::string::npos) {
            if (hex_pos + 2 < input_string.length() && IsHex(input_string[hex_pos + 1]) && IsHex(input_string[hex_pos + 2])) {
                std::string hex_str = input_string.substr(hex_pos + 1, 2);
                unsigned int hex_val;
                try {
                    hex_val = std::stoul(hex_str, nullptr, 16);
                } catch (const std::invalid_argument& e) {
                    break;
                } catch (const std::out_of_range& e) {
                    break;
                }
                input_string.replace(hex_pos, 3, 1, static_cast<char>(hex_val));
            } else {
                break;
            }
            hex_pos = input_string.find('%', hex_pos + 1);
        }
    }