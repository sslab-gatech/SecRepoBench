#ifdef _WIN32
    static const char DIR_DELIM = '\\';
#else
    static const char DIR_DELIM = '/';
#endif

// 1. If input_string is empty, just return
if (input_string.empty()) {
    return;
}

// 2. Remove leading spaces or new lines
{
    size_t pos = 0;
    while (pos < input_string.size() && std::isspace(static_cast<unsigned char>(input_string[pos]))) {
        ++pos;
    }
    if (pos > 0) {
        input_string.erase(0, pos);
    }
    if (input_string.empty()) {
        return;
    }
}

// 3. Build the cleaned string
std::string output;
output.reserve(input_string.size());

// Helper to convert two hex digits to a character
auto hexToChar = [](char h, char l) -> char {
    auto hexVal = [](char c)->int {
        if (c >= '0' && c <= '9') return c - '0';
        c = static_cast<char>(std::toupper(static_cast<unsigned char>(c)));
        if (c >= 'A' && c <= 'F') return c - 'A' + 10;
        return -1;
    };
    int high = hexVal(h);
    int low  = hexVal(l);
    if (high < 0 || low < 0) {
        return '\0';
    }
    return static_cast<char>((high << 4) | low);
};

for (size_t i = 0; i < input_string.size(); ++i) {
    // Handle special case: skip "://" verbatim
    if (i + 2 < input_string.size() &&
        input_string[i] == ':' &&
        ((input_string[i + 1] == '/' && input_string[i + 2] == '/') ||
         (input_string[i + 1] == '\\' && input_string[i + 2] == '\\'))) {
        output.push_back(input_string[i]);
        output.push_back(input_string[i + 1]);
        output.push_back(input_string[i + 2]);
        i += 2;
        continue;
    }

    // Handle special case: skip "\\\\" verbatim
    if (i + 1 < input_string.size() &&
        input_string[i] == '\\' && input_string[i + 1] == '\\') {
        output.push_back('\\');
        output.push_back('\\');
        ++i; 
        continue;
    }

    // Replace forward/back slashes with DIR_DELIM, reduce doubles
    if (input_string[i] == '/' || input_string[i] == '\\') {
        if (!output.empty() && output.back() == DIR_DELIM) {
            continue; // skip consecutive delimiter
        }
        output.push_back(DIR_DELIM);
        continue;
    }

    // Handle hex-encoded characters like "%20"
    if (input_string[i] == '%' && i + 2 < input_string.size()) {
        char decoded = hexToChar(input_string[i + 1], input_string[i + 2]);
        if (decoded != '\0') {
            output.push_back(decoded);
            i += 2;
            continue;
        }
    }

    // Default case: just copy character
    output.push_back(input_string[i]);
}

// 4. Assign the processed string back to input_string
input_string = std::move(output);