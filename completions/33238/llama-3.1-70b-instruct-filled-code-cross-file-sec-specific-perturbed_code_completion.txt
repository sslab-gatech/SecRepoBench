// Check if the input string is empty and return if so
if (input_string.empty()) {
    return;
}

// Remove leading spaces or new lines from the path
input_string.erase(0, input_string.find_first_not_of(" \n\r\t"));

// Iterate through each character in the path to replace both forward slashes ('/') and backslashes ('\\') 
// with the operating system's directory separator
for (char& c : input_string) {
    if (c == '/' || c == '\\') {
        c = '/';
    }
}

// Reduce double delimiters to single delimiters
size_t pos = 0;
while ((pos = input_string.find("//"))!= std::string::npos) {
    input_string.replace(pos, 2, "/");
}

// Handle special cases such as skipping over "://" and "\\\\" sequences
pos = 0;
while ((pos = input_string.find("://"))!= std::string::npos) {
    input_string.replace(pos, 3, ":/");
}
pos = 0;
while ((pos = input_string.find("\\\\"))!= std::string::npos) {
    input_string.replace(pos, 2, "\\");
}

// Detect and convert hexadecimal sequences (e.g., %20) in URIs to their respective characters
pos = 0;
while ((pos = input_string.find("%"))!= std::string::npos) {
    if (pos + 2 < input_string.length()) {
        int code = std::stoi(input_string.substr(pos + 1, 2), 0, 16);
        input_string.replace(pos, 3, 1, static_cast<char>(code));
    }
}