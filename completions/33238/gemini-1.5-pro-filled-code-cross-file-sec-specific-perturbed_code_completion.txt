if (input_string.empty()) {
            return;
        }

        // Remove leading spaces or new lines
        size_t first_char = input_string.find_first_not_of(" \r\n");
        if (first_char != std::string::npos && first_char > 0) {
            input_string.erase(0, first_char);
        }

        std::string cleaned_path;
        cleaned_path.reserve(input_string.size()); // Reserve enough space to prevent reallocations.

        for (size_t i = 0; i < input_string.size(); ++i) {
            const char current_char = input_string[i];

            if (current_char == '/' || current_char == '\\') {
                // Check for double delimiters and "://" or "\\\\" sequences
                if (i + 1 < input_string.size() && (input_string[i + 1] == current_char || (current_char == '/' && input_string[i+1] == ':') || (current_char == '\\' && input_string[i+1] == '\\'))) {
                    if (input_string[i + 1] == current_char) {
                        ++i; // Skip the next character if it's the same delimiter.
                    } else if ((current_char == '/' && input_string[i+1] == ':') || (current_char == '\\' && input_string[i+1] == '\\')) {
                        cleaned_path.append(input_string, i, 2); // Append "://" or "\\\\" as is.
                        i++;
                        continue;
                    }
                }
                cleaned_path += AI_DIRECTORY_SEPARATOR_CHAR; // Replace with OS-specific separator.
            } else if (current_char == '%') {
                // Handle hexadecimal sequences like '%20'
                if (i + 2 < input_string.size()) {
                    char hex_str[3] = {input_string[i + 1], input_string[i + 2], '\0'};
                    char* end_ptr;
                    long int hex_value = strtol(hex_str, &end_ptr, 16);
                    if (*end_ptr == '\0' && hex_value >= 0 && hex_value <= 255) {
                        cleaned_path += static_cast<char>(hex_value);
                        i += 2;
                        continue;
                    }
                }
                cleaned_path += '%'; // Append '%' if not a valid hex sequence.

            } else {
                cleaned_path += current_char;
            }
        }

        input_string = cleaned_path;