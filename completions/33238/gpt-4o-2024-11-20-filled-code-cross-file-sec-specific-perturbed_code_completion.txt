// Check if the input string is empty
if (input_string.empty()) {
    return;
}

// Remove leading and trailing whitespace
input_string.erase(0, input_string.find_first_not_of(" \t\n\r"));
input_string.erase(input_string.find_last_not_of(" \t\n\r") + 1);

// Replace backslashes with forward slashes for consistency
std::replace(input_string.begin(), input_string.end(), '\\', '/');

// Reduce multiple consecutive slashes to a single slash
std::string::size_type pos = 0;
while ((pos = input_string.find("//", pos)) != std::string::npos) {
    input_string.erase(pos, 1);
}

// Handle special cases for "://" and "\\\\" sequences
pos = 0;
while ((pos = input_string.find("://", pos)) != std::string::npos) {
    pos += 3; // Skip over the "://"
    while ((pos = input_string.find("//", pos)) != std::string::npos) {
        input_string.erase(pos, 1);
    }
}

// Decode percent-encoded characters (e.g., %20 -> space)
pos = 0;
while ((pos = input_string.find('%', pos)) != std::string::npos) {
    if (pos + 2 < input_string.size()) {
        char hex[3] = { input_string[pos + 1], input_string[pos + 2], '\0' };
        char decoded_char = static_cast<char>(std::strtol(hex, nullptr, 16));
        input_string.replace(pos, 3, 1, decoded_char);
    } else {
        break; // Malformed percent-encoding, stop processing
    }
}