if(input_string.empty()) return;

// Remove leading spaces and newlines
input_string.erase(0, input_string.find_first_not_of(" \n\r\t"));

// Determine platform-specific directory separator
#ifdef _WIN32
    const char dir_sep = '\\';
#else
    const char dir_sep = '/';
#endif

std::string result;
result.reserve(input_string.size());

for (size_t i = 0; i < input_string.size(); ++i) {
    char c = input_string[i];

    // Convert hexadecimal sequences e.g. "%20" to the actual character.
    if (c == '%' && i + 2 < input_string.size() && std::isxdigit(input_string[i+1]) && std::isxdigit(input_string[i+2])) {
        char hex[3] = { input_string[i+1], input_string[i+2], '\0' };
        int hex_val = 0;
        std::sscanf(hex, "%x", &hex_val);
        result.push_back(static_cast<char>(hex_val));
        i += 2;
    }
    // Replace both forward and back slashes with dir_sep.
    else if (c == '/' || c == '\\') {
        // Count how many consecutive dir_sep characters are already at the end of result.
        int cons = 0;
        while (!result.empty() && result.back() == dir_sep) {
            ++cons;
            result.pop_back();
        }
        // Special case: if the previously appended character is a colon,
        // allow up to two delimiters (as in "://") or ("\\\\" in UNC paths).
        if (!result.empty() && result.back() == ':') {
            // Append two dir_sep characters.
            result.push_back(dir_sep);
            result.push_back(dir_sep);
        } else {
            // Otherwise append a single delimiter.
            result.push_back(dir_sep);
        }
    }
    else {
        result.push_back(c);
    }
}

input_string = result;