if (input_string.empty()) {
    return;
}

// Remove leading spaces or new lines
size_t start_pos = input_string.find_first_not_of(" \t\n\r");
if (start_pos != std::string::npos) {
    input_string = input_string.substr(start_pos);
}

// Replace forward slashes and backslashes with the system's directory separator
for (char& ch : input_string) {
    if (ch == '/' || ch == '\\') {
        ch = GetSystemDirSeparator(); // Assume this function returns the correct separator for the OS
    }
}

// Reduce double delimiters to single delimiters
std::string result;
bool previous_was_delimiter = false;
for (size_t i = 0; i < input_string.length(); ++i) {
    char current = input_string[i];
    if (current == GetSystemDirSeparator()) {
        if (!previous_was_delimiter) {
            result += current;
            previous_was_delimiter = true;
        }
    } else {
        result += current;
        previous_was_delimiter = false;
    }
}

// Handle special cases such as skipping over "://" or "\\\\" sequences
size_t pos = 0;
while ((pos = result.find("://", pos)) != std::string::npos) {
    result.replace(pos, 3, "___"); // Temporarily replace to avoid modifying them
    pos += 3;
}
pos = 0;
while ((pos = result.find("\\\\\\\", pos)) != std::string::npos) {
    result.replace(pos, 3, "___"); // Similarly handle
    pos += 3;
}

// Convert hexadecimal sequences (e.g., %20) in URIs to their respective characters
pos = 0;
while ((pos = result.find('%', pos)) != std::string::npos) {
    if (pos + 2 < result.length()) {
        std::string hex_str = result.substr(pos + 1, 2);
        char decoded_char = static_cast<char>(strtol(hex_str.c_str(), nullptr, 16));
        result.replace(pos, 3, 1, decoded_char);
    }
    pos++;
}

// Restore skipped sequences if necessary
pos = 0;
while ((pos = result.find("___", pos)) != std::string::npos) {
    result.replace(pos, 3, "://"); // Restore original sequence
    pos += 3;
}

input_string = result;