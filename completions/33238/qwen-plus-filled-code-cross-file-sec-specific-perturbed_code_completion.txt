if (input_string.empty()) {
    return;
}

size_t pos = 0;
while ((pos = input_string.find_first_of(" \n", pos)) != std::string::npos) {
    if (pos == 0) {
        input_string.erase(pos, 1);
    } else {
        ++pos;
    }
}

for (size_t i = 0; i < input_string.length(); ++i) {
    if (input_string[i] == '/' || input_string[i] == '\\') {
        input_string[i] = GetOSPathSeparator(); // Assume this function returns the correct OS-specific separator
    }
}

// Reduce double delimiters to single delimiters
pos = 0;
while ((pos = input_string.find("//", pos)) != std::string::npos || 
       (pos = input_string.find("\\\\", pos)) != std::string::npos) {
    input_string.replace(pos, 2, GetOSPathSeparatorString());
}

// Handle special cases like "://", "\\\\"
pos = 0;
while ((pos = input_string.find("://", pos)) != std::string::npos) {
    pos += 3; // Skip over "://"
}

pos = 0;
while ((pos = input_string.find("\\\\", pos)) != std::string::npos) {
    pos += 2; // Skip over "\\\\"
}

// Convert URI hexadecimal sequences
pos = 0;
while ((pos = input_string.find("%", pos)) != std::string::npos) {
    if (pos + 2 < input_string.length()) {
        std::string hex = input_string.substr(pos + 1, 2);
        try {
            char decoded_char = static_cast<char>(std::stoi(hex, nullptr, 16));
            input_string.replace(pos, 3, 1, decoded_char);
        } catch (const std::exception&) {
            // Invalid sequence, skip it
            ++pos;
        }
    } else {
        ++pos;
    }
}