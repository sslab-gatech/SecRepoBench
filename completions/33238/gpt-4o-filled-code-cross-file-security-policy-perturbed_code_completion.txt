if (input_string.empty()) {
        return;
    }

    // Remove leading spaces or new lines
    size_t start = input_string.find_first_not_of(" \n\r\t");
    if (start != std::string::npos) {
        input_string = input_string.substr(start);
    }

    // Replace slashes and handle double delimiters
    const char delimiter = '/'; // Assuming UNIX-like system
    bool last_was_delimiter = false;
    for (size_t i = 0; i < input_string.size(); ++i) {
        if (input_string[i] == '/' || input_string[i] == '\\') {
            if (!last_was_delimiter) {
                input_string[i] = delimiter;
                last_was_delimiter = true;
            } else {
                input_string.erase(i--, 1);
            }
        } else {
            last_was_delimiter = false;
        }

        // Skip over "://" and "\\\\" sequences
        if (i + 2 < input_string.size() && 
            ((input_string[i] == ':' && input_string[i+1] == '/' && input_string[i+2] == '/') ||
             (input_string[i] == '\\' && input_string[i+1] == '\\' && input_string[i+2] == '\\'))) {
            i += 2;
            last_was_delimiter = false;
        }
    }

    // Convert hexadecimal sequences (e.g., %20) in URIs to their respective characters
    size_t pos = 0;
    while ((pos = input_string.find('%', pos)) != std::string::npos) {
        if (pos + 2 < input_string.size() && 
            isxdigit(input_string[pos + 1]) && isxdigit(input_string[pos + 2])) {
            std::string hex_value = input_string.substr(pos + 1, 2);
            char decoded_char = static_cast<char>(std::stoi(hex_value, nullptr, 16));
            input_string.replace(pos, 3, 1, decoded_char);
        }
        ++pos;
    }