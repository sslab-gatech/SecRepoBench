void Cleanup (std::string& input_string) const {
    // This function cleans up a given file path by performing various operations to standardize it.
    // It first checks if the input string is empty and returns if so. It then removes leading spaces
    // or new lines from the path. The function iterates through each character in the path to 
    // replace both forward slashes ('/') and backslashes ('\\') with the operating system's 
    // directory separator. It ensures double delimiters are reduced to single delimiters and 
    // handles special cases such as skipping over "://" and "\\\\" sequences. Additionally, it
    // detects and converts hexadecimal sequences (e.g., %20) in URIs to their respective characters.

    if (input_string.empty()) {
        return;
    }

    // Remove leading spaces or new lines
    std::string::size_type pos = input_string.find_first_not_of(" \t\n\r");
    if (pos != std::string::npos) {
        input_string.erase(0, pos);
    }

    // Replace slashes with the OS directory separator
    std::string::size_type start = 0;
    while ((start = input_string.find('/', start)) != std::string::npos) {
        input_string[start] = mSep;
        start++;
    }

    start = 0;
    while ((start = input_string.find('\\', start)) != std::string::npos) {
        input_string[start] = mSep;
        start++;
    }

    // Ensure double delimiters are reduced to single delimiters
    std::string::size_type i = 0;
    while (i < input_string.size()) {
        if (input_string[i] == mSep && i + 1 < input_string.size() && input_string[i + 1] == mSep) {
            input_string.erase(i, 1);
        } else {
            i++;
        }
    }

    // Handle special cases for "://" and "\\\\"
    if (input_string.substr(0, 3) == "://") {
        input_string.erase(0, 3);
    } else if (input_string.substr(0, 2) == "\\\\") {
        input_string.erase(0, 2);
    }

    // Detect and convert hexadecimal sequences (e.g., %20) in URIs to their respective characters
    std::string::size_type hex_start = 0;
    while ((hex_start = input_string.find('%', hex_start)) != std::string::npos) {
        if (hex_start + 2 < input_string.size() && IsHex(input_string[hex_start + 1]) && IsHex(input_string[hex_start + 2])) {
            std::string hex_value = input_string.substr(hex_start + 1, 2);
            char character = static_cast<char>(std::strtol(hex_value.c_str(), nullptr, 16));
            input_string.replace(hex_start, 3, 1, character);
            hex_start += 1; // Skip the converted character
        } else {
            hex_start++;
        }
    }
}