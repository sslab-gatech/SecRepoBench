/ (QuantumRange/255.0);
          *v1 = colour.green / (QuantumRange/255.0);
          *v2 = colour.blue  / (QuantumRange/255.0);
          dummy_exception = DestroyExceptionInfo (dummy_exception);
          pfx->pex += lenfun;
          return ((ssize_t) lenfun);
        }
      }
    }
    dummy_exception = DestroyExceptionInfo (dummy_exception);
    return 0;
  }
  dummy_exception = DestroyExceptionInfo (dummy_exception);

  *v0 = colour.red   / (QuantumRange/255.0);
  *v1 = colour.green / (QuantumRange/255.0);
  *v2 = colour.blue  / (QuantumRange/255.0);
  pfx->pex += pfx->lenToken;
  return ((ssize_t) pfx->lenToken);
}

static MagickBooleanType GetConstant (FxInfo * pfx, fxFltType *val)
{
  ssize_t len;
  fxFltType v0, v1, v2;
  v0 = v1 = v2 = 0.0;

  len = GetConstantColour (pfx, &v0, &v1, &v2);
  if (len < 0) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "Invalid constant colour", "'%s' at '%s'",
      pfx->token, SetShortExp(pfx));
    return MagickFalse;
  }
  if (len == 0) {
    len = GetToken (pfx);
    if (len == 0) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "Invalid constant", "'%s' at '%s'",
        pfx->token, SetShortExp(pfx));
      return MagickFalse;
    }
    if (LocaleCompare (pfx->token, "quantumrange") == 0) {
      *val = QuantumRange / (QuantumRange/255.0);
      pfx->pex += pfx->lenToken;
      return MagickTrue;
    }
    if (LocaleCompare (pfx->token, "quantumscale") == 0) {
      *val = QuantumScale / (QuantumRange/255.0);
      pfx->pex += pfx->lenToken;
      return MagickTrue;
    }
    if (LocaleCompare (pfx->token, "MaxRGB") == 0) {
      *val = QuantumRange / (QuantumRange/255.0);
      pfx->pex += pfx->lenToken;
      return MagickTrue;
    }
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "Invalid constant", "'%s' at '%s'",
      pfx->token, SetShortExp(pfx));
    return MagickFalse;
  }
  *val = v0;
  return MagickTrue;
}

static MagickBooleanType GetSymbol (FxInfo * pfx, fxFltType *val)
{
  int ndx;
  if (!TokenMaybeUserSymbol (pfx)) return MagickFalse;
  ndx = FindUserSymbol (pfx, pfx->token);
  if (ndx == NULL_ADDRESS) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "Unknown symbol", "'%s' at '%s'",
      pfx->token, SetShortExp(pfx));
    return MagickFalse;
  }
  *val = pfx->UserSymVals[ndx];
  pfx->pex += pfx->lenToken;
  return MagickTrue;
}

static MagickBooleanType GetFunction (FxInfo * pfx, FunctionE fe)
{
  int i;
  if (fe == fNull) return MagickFalse;
  for (i = 0; Functions[i].func != fNull; i++) {
    if (Functions[i].func == fe) break;
  }
  if (Functions[i].func == fNull) return MagickFalse;
  if (Functions[i].nArgs != 0) {
    if (pfx->usedElements + Functions[i].nArgs > pfx->numElements) {
      if (!ExtendRPN (pfx)) return MagickFalse;
    }
    for (int j = 0; j < Functions[i].nArgs; j++) {
      if (!TranslateExpression (pfx, NULL, NULL, NULL)) return MagickFalse;
    }
  }
  return AddElement (pfx, (fxFltType) 0, fe);
}

static MagickBooleanType GetImgAttr (FxInfo * pfx, fxFltType *val)
{
  ImgAttrE ia;
  for (ia = FirstImgAttr; ia < aNull; ia=(ImgAttrE) (ia+1)) {
    if (LocaleCompare (ImgAttrs[ia-FirstImgAttr].str, pfx->token)==0) {
      if (ImgAttrs[ia-FirstImgAttr].NeedStats == 1) pfx->NeedStats = MagickTrue;
      MaybeXYWH (pfx, &ia);
      *val = GetImageProperty (pfx->image, ImgAttrs[ia-FirstImgAttr].str);
      pfx->pex += pfx->lenToken;
      return MagickTrue;
    }
  }
  return MagickFalse;
}

static MagickBooleanType GetSymbolOrImgAttr (FxInfo * pfx, fxFltType *val)
{
  if (GetSymbol (pfx, val)) return MagickTrue;
  if (GetImgAttr (pfx, val)) return MagickTrue;
  return MagickFalse;
}

static MagickBooleanType GetConstantOrSymbol (FxInfo * pfx, fxFltType *val)
{
  if (GetConstant (pfx, val)) return MagickTrue;
  if (GetSymbol (pfx, val)) return MagickTrue;
  return MagickFalse;
}

static MagickBooleanType GetValue (FxInfo * pfx, fxFltType *val)
{
  ssize_t len;
  len = GetProperty (pfx, val);
  if (len > 0) return MagickTrue;
  len = GetConstantOrSymbol (pfx, val);
  if (len > 0) return MagickTrue;
  return MagickFalse;
}

static MagickBooleanType GetValueOrChannel (FxInfo * pfx, fxFltType *val, PixelChannel * channel)
{
  ssize_t len;
  len = GetProperty (pfx, val);
  if (len > 0) {
    *channel = NO_CHAN_QUAL;
    return MagickTrue;
  }
  len = GetConstantOrSymbol (pfx, val);
  if (len > 0) {
    *channel = NO_CHAN_QUAL;
    return MagickTrue;
  }
  len = GetChannel (pfx, val, channel);
  if (len > 0) return MagickTrue;
  return MagickFalse;
}

static MagickBooleanType GetChannel (FxInfo * pfx, fxFltType *val, PixelChannel * channel)
{
  int i;
  for (i = 0; Channels[i].str[0] != '\0'; i++) {
    if (LocaleCompare (Channels[i].str, pfx->token)==0) {
      *val = (fxFltType) Channels[i].pixChan;
      pfx->pex += pfx->lenToken;
      *channel = Channels[i].pixChan;
      return MagickTrue;
    }
  }
  return MagickFalse;
}

static MagickBooleanType GetOperator (FxInfo * pfx, OperatorE * opr)
{
  int i;
  for (i = 0; Operators[i].op != oNull; i++) {
    if (LocaleCompare (Operators[i].str, pfx->token)==0) {
      *opr = (OperatorE) Operators[i].op;
      pfx->pex += pfx->lenToken;
      return MagickTrue;
    }
  }
  return MagickFalse;
}

static MagickBooleanType GetImgAttrOrSymbol (FxInfo * pfx, fxFltType *val)
{
  if (GetImgAttr (pfx, val)) return MagickTrue;
  if (GetSymbol (pfx, val)) return MagickTrue;
  return MagickFalse;
}

static MagickBooleanType GetImgAttrOrSymbolOrChannel (FxInfo * pfx, fxFltType *val, PixelChannel * channel)
{
  if (GetImgAttr (pfx, val)) {
    *channel = NO_CHAN_QUAL;
    return MagickTrue;
  }
  if (GetSymbol (pfx, val)) {
    *channel = NO_CHAN_QUAL;
    return MagickTrue;
  }
  if (GetChannel (pfx, val, channel)) return MagickTrue;
  return MagickFalse;
}

static MagickBooleanType GetImgAttrOrSymbolOrChannelOrFunction (FxInfo * pfx, fxFltType *val, PixelChannel * channel, FunctionE * func)
{
  if (GetImgAttr (pfx, val)) {
    *channel = NO_CHAN_QUAL;
    *func = fNull;
    return MagickTrue;
  }
  if (GetSymbol (pfx, val)) {
    *channel = NO_CHAN_QUAL;
    *func = fNull;
    return MagickTrue;
  }
  if (GetChannel (pfx, val, channel)) {
    *func = fNull;
    return MagickTrue;
  }
  if (GetFunction (pfx, func)) {
    *channel = NO_CHAN_QUAL;
    return MagickTrue;
  }
  return MagickFalse;
}

static MagickBooleanType GetImgAttrOrSymbolOrChannelOrFunctionOrOperator (FxInfo * pfx, fxFltType *val, PixelChannel * channel, FunctionE * func, OperatorE * opr)
{
  if (GetImgAttr (pfx, val)) {
    *channel = NO_CHAN_QUAL;
    *func = fNull;
    *opr = oNull;
    return MagickTrue;
  }
  if (GetSymbol (pfx, val)) {
    *channel = NO_CHAN_QUAL;
    *func = fNull;
    *opr = oNull;
    return MagickTrue;
  }
  if (GetChannel (pfx, val, channel)) {
    *func = fNull;
    *opr = oNull;
    return MagickTrue;
  }
  if (GetFunction (pfx, func)) {
    *channel = NO_CHAN_QUAL;
    *opr = oNull;
    return MagickTrue;
  }
  if (GetOperator (pfx, opr)) {
    *channel = NO_CHAN_QUAL;
    *func = fNull;
    return MagickTrue;
  }
  return MagickFalse;
}

static MagickBooleanType GetImgAttrOrSymbolOrChannelOrOperator (FxInfo * pfx, fxFltType *val, PixelChannel * channel, OperatorE * opr)
{
  if (GetImgAttr (pfx, val)) {
    *channel = NO_CHAN_QUAL;
    *opr = oNull;
    return MagickTrue;
  }
  if (GetSymbol (pfx, val)) {
    *channel = NO_CHAN_QUAL;
    *opr = oNull;
    return MagickTrue;
  }
  if (GetChannel (pfx, val, channel)) {
    *opr = oNull;
    return MagickTrue;
  }
  if (GetOperator (pfx, opr)) {
    *channel = NO_CHAN_QUAL;
    return MagickTrue;
  }
  return MagickFalse;
}

static MagickBooleanType GetImgAttrOrSymbolOrOperator (FxInfo * pfx, fxFltType *val, PixelChannel * channel, OperatorE * opr)
{
  if (GetImgAttr (pfx, val)) {
    *channel = NO_CHAN_QUAL;
    *opr = oNull;
    return MagickTrue;
  }
  if (GetSymbol (pfx, val)) {
    *channel = NO_CHAN_QUAL;
    *opr = oNull;
    return MagickTrue;
  }
  if (GetOperator (pfx, opr)) {
    *channel = NO_CHAN_QUAL;
    return Mag