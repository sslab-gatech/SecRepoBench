dummy_exception = DestroyExceptionInfo (dummy_exception);
          return (ssize_t) lenfun;
        }
      }
    }
    dummy_exception = DestroyExceptionInfo (dummy_exception);
    return 0;
  }

  *v0 = colour.red   / QuantumRange;
  *v1 = colour.green / QuantumRange;
  *v2 = colour.blue  / QuantumRange;
  dummy_exception = DestroyExceptionInfo (dummy_exception);
  return (ssize_t) pfx->lenToken;
}

static MagickBooleanType GetConstant (FxInfo * pfx, fxFltType *val)
{
  ssize_t len;
  len = GetConstantColour (pfx, val, val+1, val+2);
  if (len < 0) return MagickFalse;
  if (len == 0) {
    len = GetToken (pfx);
    if (len == 0) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "Expected constant at", "'%s'",
        SetShortExp(pfx));
      return MagickFalse;
    }
    if (LocaleCompare ("quantumrange", pfx->token)==0) {
      *val = QuantumRange;
      return MagickTrue;
    }
    if (LocaleCompare ("transparent", pfx->token)==0) {
      *val = 0.0;
      return MagickTrue;
    }
    if (LocaleCompare ("opaque", pfx->token)==0) {
      *val = 1.0;
      return MagickTrue;
    }
    if (LocaleCompare ("epsilon", pfx->token)==0) {
      *val = MagickEpsilon;
      return MagickTrue;
    }
    if (LocaleCompare ("pi", pfx->token)==0) {
      *val = MagickPI;
      return MagickTrue;
    }
    if (LocaleCompare ("phi", pfx->token)==0) {
      *val = MagickPHI;
      return MagickTrue;
    }
    if (LocaleCompare ("e", pfx->token)==0) {
      *val = 2.7182818284590452354;
      return MagickTrue;
    }
    if (LocaleCompare ("MaxRGB", pfx->token)==0) {
      *val = QuantumRange;
      return MagickTrue;
    }
    if (LocaleCompare ("quantumscale", pfx->token)==0) {
      *val = QuantumScale;
      return MagickTrue;
    }
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "Unknown constant", "'%s' at '%s'",
      pfx->token, SetShortExp(pfx));
    return MagickFalse;
  }
  return MagickTrue;
}

static MagickBooleanType GetNumber (FxInfo * pfx, fxFltType *val)
{
  char * tailptr;
  char * text;
  text = pfx->token;
  *val = strtold (text, &tailptr);
  if (text == tailptr) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "Number", "'%s' is not a number at '%s'",
      text, SetShortExp(pfx));
    return MagickFalse;
  }
  pfx->pex += pfx->lenToken;
  return MagickTrue;
}

static MagickBooleanType GetSymbol (FxInfo * pfx, fxFltType *val)
{
  int ndx;
  if (!TokenMaybeUserSymbol (pfx)) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "Expected symbol at", "'%s'",
      SetShortExp(pfx));
    return MagickFalse;
  }
  ndx = FindUserSymbol (pfx, pfx->token);
  if (ndx == NULL_ADDRESS) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "Unknown symbol", "'%s' at '%s'",
      pfx->token, SetShortExp(pfx));
    return MagickFalse;
  }
  *val = pfx->UserSymVals[ndx];
  pfx->pex += pfx->lenToken;
  return MagickTrue;
}

static MagickBooleanType GetFunction (FxInfo * pfx, FunctionE fe)
{
  int i;
  for (i = 0; Functions[i].func != fNull; i++) {
    if (Functions[i].func == fe) {
      pfx->pex += strlen (Functions[i].str);
      return MagickTrue;
    }
  }
  (void) ThrowMagickException (
    pfx->exception, GetMagickModule(), OptionError,
    "Unknown function", "'%s' at '%s'",
    Functions[i-1].str, SetShortExp(pfx));
  return MagickFalse;
}

static MagickBooleanType GetImgAttr (FxInfo * pfx, fxFltType *val)
{
  ImgAttrE ia;
  if (!GetToken (pfx)) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "Expected image attribute at", "'%s'",
      SetShortExp(pfx));
    return MagickFalse;
  }
  ia = GetImgAttrToken (pfx);
  if (ia == aNull) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "Unknown image attribute", "'%s' at '%s'",
      pfx->token, SetShortExp(pfx));
    return MagickFalse;
  }
  *val = (fxFltType) ia;
  return MagickTrue;
}

static MagickBooleanType GetOperator (FxInfo * pfx, fxFltType *val)
{
  int i;
  for (i = 0; Operators[i].op != oNull; i++) {
    if (LocaleCompare (Operators[i].str, pfx->token)==0) {
      pfx->pex += strlen (Operators[i].str);
      *val = (fxFltType) Operators[i].op;
      return MagickTrue;
    }
  }
  (void) ThrowMagickException (
    pfx->exception, GetMagickModule(), OptionError,
    "Unknown operator", "'%s' at '%s'",
    pfx->token, SetShortExp(pfx));
  return MagickFalse;
}

static MagickBooleanType GetControl (FxInfo * pfx, fxFltType *val)
{
  int i;
  for (i = 0; Controls[i].cont != rNull; i++) {
    if (LocaleCompare (Controls[i].str, pfx->token)==0) {
      pfx->pex += strlen (Controls[i].str);
      *val = (fxFltType) Controls[i].cont;
      return MagickTrue;
    }
  }
  (void) ThrowMagickException (
    pfx->exception, GetMagickModule(), OptionError,
    "Unknown control", "'%s' at '%s'",
    pfx->token, SetShortExp(pfx));
  return MagickFalse;
}

static MagickBooleanType GetSymbolOrImgAttr (FxInfo * pfx, fxFltType *val)
{
  if (PeekStr (pfx, "a") || PeekStr (pfx, "A")) {
    return GetImgAttr (pfx, val);
  }
  return GetSymbol (pfx, val);
}

static MagickBooleanType GetChannel (FxInfo * pfx, fxFltType *val)
{
  int i;
  for (i = 0; Channels[i].str[0] != '\0'; i++) {
    if (LocaleCompare (Channels[i].str, pfx->token)==0) {
      pfx->pex += strlen (Channels[i].str);
      *val = (fxFltType) Channels[i].pixChan;
      return MagickTrue;
    }
  }
  (void) ThrowMagickException (
    pfx->exception, GetMagickModule(), OptionError,
    "Unknown channel", "'%s' at '%s'",
    pfx->token, SetShortExp(pfx));
  return MagickFalse;
}

static MagickBooleanType GetElement (FxInfo * pfx, ElementT * pel)
{
  int op;
  fxFltType val;
  if (PeekStr (pfx, "if") || PeekStr (pfx, "IF")) {
    return TranslateStatementList (pfx, pfx->pex, pfx->pex);
  }
  if (PeekStr (pfx, "for") || PeekStr (pfx, "FOR")) {
    return TranslateStatementList (pfx, pfx->pex, pfx->pex);
  }
  if (PeekStr (pfx, "while") || PeekStr (pfx, "WHILE")) {
    return TranslateStatementList (pfx, pfx->pex, pfx->pex);
  }
  if (PeekStr (pfx, "do") || PeekStr (pfx, "DO")) {
    return TranslateStatementList (pfx, pfx->pex, pfx->pex);
  }
  if (PeekStr (pfx, "goto") || PeekStr (pfx, "GOTO")) {
    return TranslateStatementList (pfx, pfx->pex, pfx->pex);
  }
  if (PeekStr (pfx, "ifzerogoto") || PeekStr (pfx, "IFZEROGOTO")) {
    return TranslateStatementList (pfx, pfx->pex, pfx->pex);
  }
  if (PeekStr (pfx, "ifnotzerogoto") || PeekStr (pfx, "IFNOTZEROGOTO")) {
    return TranslateStatementList (pfx, pfx->pex, pfx->pex);
  }
  if (PeekStr (pfx, "copyfrom") || PeekStr (pfx, "COPYFROM")) {
    return TranslateStatementList (pfx, pfx->pex, pfx->pex);
  }
  if (PeekStr (pfx, "copyto") || PeekStr (pfx, "COPYTO")) {
    return TranslateStatementList (pfx, pfx->pex, pfx->pex);
  }
  if (PeekStr (pfx, "zerstk") || PeekStr (pfx, "ZERSTK")) {
    return TranslateStatementList (pfx, pfx->pex, pfx->pex);
  }
  if (PeekStr (pfx, "debug") || PeekStr (pfx, "DEBUG")) {
    return TranslateStatementList (pfx, pfx->pex, pfx->pex);
  }
  if (PeekStr (pfx, "u") || PeekStr (pfx, "U")) {
    return GetSymbol (pfx, &val);
  }
  if (PeekStr (pfx, "u0") || PeekStr (pfx, "U0")) {
    return GetSymbol (pfx, &val);
  }
  if (PeekStr (pfx, "up") || PeekStr (pfx, "UP")) {
    return GetSymbol (pfx, &val);
  }
  if (PeekStr (pfx, "s") || PeekStr (pfx, "S")) {
    return GetSymbol (pfx, &val);
  }
  if (PeekStr (pfx, "v") || PeekStr (pfx, "V")) {
    return GetSymbol (pfx, &val);
  }
  if (PeekStr (pfx, "p") || PeekStr (pfx, "P")) {
    return GetSymbol (pfx, &val);
  }
  if (PeekStr (pfx, "sp") || PeekStr (pfx, "SP")) {
    return GetSymbol (pfx, &val);
  }
  if (PeekStr (pfx, "vp") || PeekStr (pfx, "VP")) {
    return GetSymbol (pfx, &val);
  }
  if (PeekStr (pfx, "abs") || PeekStr (pfx, "ABS")) {
    return GetFunction (pfx, fAbs);
  }
  if (PeekStr (pfx, "acosh") || PeekStr (pfx, "ACOSH")) {
    return GetFunction (pfx, fAcosh);
  }
  if (