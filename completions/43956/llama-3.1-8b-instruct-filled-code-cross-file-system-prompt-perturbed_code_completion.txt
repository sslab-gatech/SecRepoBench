switch (FndArgs) {
  case 1:
    if (fe == fP || fe == fS || fe == fU || fe == fV) {
      if (fe == fP) {
        (void) AddAddressingElement (pfx, rGoto, ndx1+1);
      } else if (fe == fS) {
        (void) AddAddressingElement (pfx, rZerStk, ndx1+1);
      } else if (fe == fU) {
        (void) AddAddressingElement (pfx, rIfZeroGoto, ndx1+1);
      } else if (fe == fV) {
        (void) AddAddressingElement (pfx, rIfNotZeroGoto, ndx1+1);
      }
      pfx->Elements[ndx0].EleNdx = ndx1+1;
    } else if (fe == fDo) {
      (void) AddAddressingElement (pfx, rGoto, ndx1+1);
      pfx->Elements[ndx0].EleNdx = ndx1+1;
    } else if (fe == fFor) {
      (void) AddAddressingElement (pfx, rZerStk, ndx1+1);
      pfx->Elements[ndx2].EleNdx = ndx1+1;
    } else if (fe == fIf) {
      (void) AddAddressingElement (pfx, rIfZeroGoto, ndx1+1);
      pfx->Elements[ndx1].EleNdx = ndx1+1;
    } else {
      (void) AddElement (pfx, (fxFltType) 0, fe);
      if (fe == fP || fe == fU  || fe == fU0 || fe == fUP ||
          fe == fV || fe == fVP || fe == fS || fe == fSP)
      {
        ElementT * pel = &pfx->Elements[pfx->usedElements-1];
        pel->IsRelative = (expChLimit == ']'? MagickTrue : isCoordQualifier);
        if (chQual >= 0) pel->ChannelQual = chQual;
        if (iaQual!= aNull && (fe == fU || fe == fV || fe == fS)) {
          /* Note: we don't allow "p[2,3].mean" or "p.mean" etc. */
          pel->ImgAttrQual = iaQual;
        }
      }
    }
    break;
  case 2:
    if (fe == fP || fe == fS || fe == fU || fe == fV) {
      if (fe == fP) {
        (void) AddAddressingElement (pfx, rIfZeroGoto, ndx2+1);
      } else if (fe == fS) {
        (void) AddAddressingElement (pfx, rIfNotZeroGoto, ndx2+1);
      } else if (fe == fU) {
        (void) AddAddressingElement (pfx, rZerStk, ndx2+1);
      } else if (fe == fV) {
        (void) AddAddressingElement (pfx, rGoto, ndx2+1);
      }
      pfx->Elements[ndx1].EleNdx = ndx2+1;
    } else if (fe == fDo) {
      (void) AddAddressingElement (pfx, rIfZeroGoto, ndx2+1);
      pfx->Elements[ndx0].EleNdx = ndx1+1;
      pfx->Elements[ndx1].EleNdx = ndx2+1;
    } else if (fe == fFor) {
      (void) AddAddressingElement (pfx, rIfNotZeroGoto, ndx2+1);
      pfx->Elements[ndx2].EleNdx = ndx2+1;
    } else if (fe == fIf) {
      (void) AddAddressingElement (pfx, rGoto, ndx2+1);
      pfx->Elements[ndx1].EleNdx = ndx2 + 1;
      pfx->Elements[ndx2].EleNdx = ndx3;
    } else {
      (void) AddElement (pfx, (fxFltType) 0, fe);
      if (fe == fP || fe == fU  || fe == fU0 || fe == fUP ||
          fe == fV || fe == fVP || fe == fS || fe == fSP)
      {
        ElementT * pel = &pfx->Elements[pfx->usedElements-1];
        pel->IsRelative = (expChLimit == ']'? MagickTrue : isCoordQualifier);
        if (chQual >= 0) pel->ChannelQual = chQual;
        if (iaQual!= aNull && (fe == fU || fe == fV || fe == fS)) {
          /* Note: we don't allow "p[2,3].mean" or "p.mean" etc. */
          pel->ImgAttrQual = iaQual;
        }
      }
    }
    break;
  case 3:
    if (fe == fP || fe == fS || fe == fU || fe == fV) {
      if (fe == fP) {
        (void) AddAddressingElement (pfx, rIfNotZeroGoto, ndx3);
      } else if (fe == fS) {
        (void) AddAddressingElement (pfx, rZerStk, ndx3);
      } else if (fe == fU) {
        (void) AddAddressingElement (pfx, rGoto, ndx3);
      } else if (fe == fV) {
        (void) AddAddressingElement (pfx, rIfZeroGoto, ndx3);
      }
      pfx->Elements[ndx2].EleNdx = ndx3;
    } else if (fe == fDo) {
      (void) AddAddressingElement (pfx, rIfNotZeroGoto, ndx3);
      pfx->Elements[ndx0].EleNdx = ndx1+1;
      pfx->Elements[ndx1].EleNdx = ndx2+1;
    } else if (fe == fFor) {
      (void) AddAddressingElement (pfx, rIfZeroGoto, ndx3);
      pfx->Elements[ndx2].EleNdx = ndx3;
    } else if (fe == fIf) {
      (void) AddAddressingElement (pfx, rZerStk, ndx3);
      pfx->Elements[ndx1].EleNdx = ndx2 + 1;
      pfx->Elements[ndx2].EleNdx = ndx3;
    } else {
      (void) AddElement (pfx, (fxFltType) 0, fe);
      if (fe == fP || fe == fU  || fe == fU0 || fe == fUP ||
          fe == fV || fe == fVP || fe == fS || fe == fSP)
      {
        ElementT * pel = &pfx->Elements[pfx->usedElements-1];
        pel->IsRelative = (expChLimit == ']'? MagickTrue : isCoordQualifier);
        if (chQual >= 0) pel->ChannelQual = chQual;
        if (iaQual!= aNull && (fe == fU || fe == fV || fe == fS)) {
          /* Note: we don't allow "p[2,3].mean" or "p.mean" etc. */
          pel->ImgAttrQual = iaQual;
        }
      }
    }
    break;
  default:
    break;
}