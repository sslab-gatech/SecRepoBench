case 1:
        ndx1 = pfx->usedElements-1;
        if (fe==fFor) {
          (void) AddAddressingElement (pfx, rGoto, NULL_ADDRESS); /* address will be ndx2+1 */
          (void) AddAddressingElement (pfx, rIfNotZeroGoto, NULL_ADDRESS); /* address will be pfx->usedElements (just past end of loop) */
          pfx->Elements[ndx1+1].DoPush = MagickFalse; /* for() doesn't push unless needed */
        } else if (fe==fIf) {
          (void) AddAddressingElement (pfx, rIfZeroGoto, NULL_ADDRESS); /* address will be ndx2+1 */
        } else if (fe==fWhile) {
          /* While is implemented as "if" then "goto" */
          (void) AddAddressingElement (pfx, rIfZeroGoto, NULL_ADDRESS); /* address will be ndx2+1 */
        }
        break;
      case 2:
        ndx2 = pfx->usedElements-1;
        if (fe==fFor) {
          (void) AddAddressingElement (pfx, rGoto, ndx1);
          pfx->Elements[ndx2].EleNdx = pfx->usedElements; /* so the last goto goes to just past the end of the loop */
          pfx->Elements[ndx2].DoPush = MagickFalse; /* for() doesn't push unless needed */
        } else if (fe==fDo) {
          (void) AddAddressingElement (pfx, rIfNotZeroGoto, NULL_ADDRESS); /* address will be ndx2+1 */
        }
        break;
      case 3:
        ndx3 = pfx->usedElements;
        if (fe==fFor) {
          /* We really want this to be ndx3, but we can't until after the expression is parsed. */
          (void) AddAddressingElement (pfx, rGoto, ndx1+1);
          pfx->Elements[ndx3].DoPush = MagickFalse; /* for() doesn't push unless needed */
        }
        break;