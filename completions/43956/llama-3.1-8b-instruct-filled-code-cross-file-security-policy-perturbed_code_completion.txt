switch (FndArgs) {
  case 1:
    if (fe == fP || fe == fS || fe == fU || fe == fV) {
      pfx->Elements[ndx0].EleNdx = firstArgIndex+1;
    } else if (fe == fDo) {
      pfx->Elements[ndx0].EleNdx = firstArgIndex+1;
      pfx->Elements[firstArgIndex].EleNdx = ndx2+1;
    } else if (fe == fFor) {
      pfx->Elements[ndx2].EleNdx = ndx3;
    } else if (fe == fIf) {
      pfx->Elements[firstArgIndex].EleNdx = ndx2 + 1;
      pfx->Elements[ndx2].EleNdx = ndx3;
    } else {
      (void) AddElement (pfx, (fxFltType) 0, fe);
      if (fe == fP || fe == fU  || fe == fU0 || fe == fUP ||
          fe == fV || fe == fVP || fe == fS || fe == fSP)
      {
        ElementT * pel = &pfx->Elements[pfx->usedElements-1];
        pel->IsRelative = (expChLimit == ']'? MagickTrue : MagickFalse);
        if (chQual >= 0) pel->ChannelQual = chQual;
        if (iaQual!= aNull && (fe == fU || fe == fV || fe == fS)) {
          /* Note: we don't allow "p[2,3].mean" or "p.mean" etc. */
          pel->ImgAttrQual = iaQual;
        }
      }
    }
    break;
  case 2:
    if (fe == fP || fe == fS || fe == fU || fe == fV) {
      pfx->Elements[firstArgIndex].EleNdx = ndx2+1;
    } else if (fe == fDo) {
      pfx->Elements[firstArgIndex].EleNdx = ndx2+1;
      pfx->Elements[ndx2].EleNdx = ndx3;
    } else if (fe == fFor) {
      pfx->Elements[ndx2].EleNdx = ndx3;
    } else if (fe == fIf) {
      pfx->Elements[firstArgIndex].EleNdx = ndx2 + 1;
      pfx->Elements[ndx2].EleNdx = ndx3;
    } else {
      (void) AddElement (pfx, (fxFltType) 0, fe);
      if (fe == fP || fe == fU  || fe == fU0 || fe == fUP ||
          fe == fV || fe == fVP || fe == fS || fe == fSP)
      {
        ElementT * pel = &pfx->Elements[pfx->usedElements-1];
        pel->IsRelative = (expChLimit == ']'? MagickTrue : MagickFalse);
        if (chQual >= 0) pel->ChannelQual = chQual;
        if (iaQual!= aNull && (fe == fU || fe == fV || fe == fS)) {
          /* Note: we don't allow "p[2,3].mean" or "p.mean" etc. */
          pel->ImgAttrQual = iaQual;
        }
      }
    }
    break;
  case 3:
    if (fe == fP || fe == fS || fe == fU || fe == fV) {
      pfx->Elements[firstArgIndex].EleNdx = ndx3;
    } else if (fe == fDo) {
      pfx->Elements[firstArgIndex].EleNdx = ndx3;
    } else if (fe == fFor) {
      pfx->Elements[ndx2].EleNdx = ndx3;
    } else if (fe == fIf) {
      pfx->Elements[firstArgIndex].EleNdx = ndx3;
    } else {
      (void) AddElement (pfx, (fxFltType) 0, fe);
      if (fe == fP || fe == fU  || fe == fU0 || fe == fUP ||
          fe == fV || fe == fVP || fe == fS || fe == fSP)
      {
        ElementT * pel = &pfx->Elements[pfx->usedElements-1];
        pel->IsRelative = (expChLimit == ']'? MagickTrue : MagickFalse);
        if (chQual >= 0) pel->ChannelQual = chQual;
        if (iaQual!= aNull && (fe == fU || fe == fV || fe == fS)) {
          /* Note: we don't allow "p[2,3].mean" or "p.mean" etc. */
          pel->ImgAttrQual = iaQual;
        }
      }
    }
    break;
  default:
    break;
}