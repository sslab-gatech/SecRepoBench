= colour.blue  / QuantumRange;
          dummy_exception = DestroyExceptionInfo (dummy_exception);
          return (ssize_t) lenfun;
        }
      }
    }
    dummy_exception = DestroyExceptionInfo (dummy_exception);
    return 0;
  }

  *v0 = colour.red   / QuantumRange;
  *v1 = colour.green / QuantumRange;
  *v2 = colour.blue  / QuantumRange;
  dummy_exception = DestroyExceptionInfo (dummy_exception);
  return (ssize_t) pfx->lenToken;
}

static MagickBooleanType GetConstant (FxInfo * pfx, fxFltType *val)
{
  ssize_t len;
  len = GetConstantColour (pfx, val, val+1, val+2);
  if (len < 0) return MagickFalse;
  if (len == 0) {
    len = GetToken (pfx);
    if (len == 0) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "Expected constant at", "'%s'",
        SetShortExp(pfx));
      return MagickFalse;
    }
    if (LocaleCompare (pfx->token, "quantumrange") == 0) {
      *val = QuantumRange;
      return MagickTrue;
    }
    if (LocaleCompare (pfx->token, "quantumscale") == 0) {
      *val = QuantumScale;
      return MagickTrue;
    }
    if (LocaleCompare (pfx->token, "epsilon") == 0) {
      *val = MagickEpsilon;
      return MagickTrue;
    }
    if (LocaleCompare (pfx->token, "pi") == 0) {
      *val = MagickPI;
      return MagickTrue;
    }
    if (LocaleCompare (pfx->token, "phi") == 0) {
      *val = MagickPHI;
      return MagickTrue;
    }
    if (LocaleCompare (pfx->token, "transparent") == 0) {
      *val = 0.0;
      return MagickTrue;
    }
    if (LocaleCompare (pfx->token, "opaque") == 0) {
      *val = 1.0;
      return MagickTrue;
    }
    if (LocaleCompare (pfx->token, "MaxRGB") == 0) {
      *val = QuantumRange;
      return MagickTrue;
    }
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "Unknown constant", "'%s' at '%s'",
      pfx->token, SetShortExp(pfx));
    return MagickFalse;
  }
  return MagickTrue;
}

static MagickBooleanType GetSymbol (FxInfo * pfx, fxFltType *val)
{
  int ndx;
  if (!TokenMaybeUserSymbol (pfx)) return MagickFalse;
  ndx = FindUserSymbol (pfx, pfx->token);
  if (ndx == NULL_ADDRESS) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "Unknown symbol", "'%s' at '%s'",
      pfx->token, SetShortExp(pfx));
    return MagickFalse;
  }
  *val = pfx->UserSymVals[ndx];
  pfx->pex += pfx->lenToken;
  return MagickTrue;
}

static MagickBooleanType GetFunction (FxInfo * pfx, FunctionE fe)
{
  int i;
  if (fe == fNull) return MagickFalse;
  for (i=0; i < (int) (sizeof(Functions)/sizeof(FunctionT)); i++) {
    if (Functions[i].func == fe) {
      pfx->pex += strlen(Functions[i].str);
      return MagickTrue;
    }
  }
  (void) ThrowMagickException (
    pfx->exception, GetMagickModule(), OptionError,
    "Unknown function", "'%s' at '%s'",
    Functions[fe-FirstFunc].str, SetShortExp(pfx));
  return MagickFalse;
}

static MagickBooleanType GetImgAttr (FxInfo * pfx, fxFltType *val)
{
  ImgAttrE ia;
  if (PeekChar (pfx) == '.') {
    pfx->pex++;
    (void) GetToken (pfx);
    ia = GetImgAttrToken (pfx);
    if (ia == aNull) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "Unknown image attribute", "'%s' at '%s'",
        pfx->token, SetShortExp(pfx));
      return MagickFalse;
    }
    *val = GetImageProperty (pfx->image, ImgAttrs[ia-FirstImgAttr].str);
    return MagickTrue;
  }
  return MagickFalse;
}

static MagickBooleanType GetSymbolOrImgAttr (FxInfo * pfx, fxFltType *val)
{
  if (PeekChar (pfx) == '.') {
    pfx->pex++;
    return GetImgAttr (pfx, val);
  }
  return GetSymbol (pfx, val);
}

static MagickBooleanType GetValue (FxInfo * pfx, fxFltType *val)
{
  ssize_t len;
  len = GetProperty (pfx, val);
  if (len >= 0) {
    pfx->pex += len;
    return MagickTrue;
  }
  len = GetConstantColour (pfx, val, val+1, val+2);
  if (len >= 0) {
    pfx->pex += len;
    return MagickTrue;
  }
  len = GetSymbol (pfx, val);
  if (len >= 0) {
    pfx->pex += len;
    return MagickTrue;
  }
  len = GetImgAttr (pfx, val);
  if (len >= 0) {
    pfx->pex += len;
    return MagickTrue;
  }
  return MagickFalse;
}

static MagickBooleanType GetValueOrFunction (FxInfo * pfx, fxFltType *val)
{
  if (PeekChar (pfx) == '(') {
    pfx->pex++;
    (void) GetToken (pfx);
    if (LocaleCompare (pfx->token, "rand") == 0) {
      *val = GetPseudoRandomValue (pfx->random_info);
      pfx->pex += pfx->lenToken;
      return MagickTrue;
    }
    if (LocaleCompare (pfx->token, "debug") == 0) {
      pfx->pex += strlen(pfx->token);
      pfx->ContainsDebug = MagickTrue;
      return MagickTrue;
    }
    if (GetFunction (pfx, fNull)) {
      if (!GetValue (pfx, val)) return MagickFalse;
      if (!ExpectChar (pfx, ')')) return MagickFalse;
      return MagickTrue;
    }
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "Expected function or value at", "'%s'",
      SetShortExp(pfx));
    return MagickFalse;
  }
  return GetValue (pfx, val);
}

static MagickBooleanType GetValueOrSymbol (FxInfo * pfx, fxFltType *val)
{
  if (PeekChar (pfx) == '(') {
    pfx->pex++;
    (void) GetToken (pfx);
    if (LocaleCompare (pfx->token, "rand") == 0) {
      *val = GetPseudoRandomValue (pfx->random_info);
      pfx->pex += pfx->lenToken;
      return MagickTrue;
    }
    if (GetFunction (pfx, fNull)) {
      if (!GetValue (pfx, val)) return MagickFalse;
      if (!ExpectChar (pfx, ')')) return MagickFalse;
      return MagickTrue;
    }
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "Expected function or value at", "'%s'",
      SetShortExp(pfx));
    return MagickFalse;
  }
  return GetValue (pfx, val);
}

static MagickBooleanType GetValueOrFunctionOrSymbol (FxInfo * pfx, fxFltType *val)
{
  if (PeekChar (pfx) == '(') {
    pfx->pex++;
    (void) GetToken (pfx);
    if (LocaleCompare (pfx->token, "rand") == 0) {
      *val = GetPseudoRandomValue (pfx->random_info);
      pfx->pex += pfx->lenToken;
      return MagickTrue;
    }
    if (GetFunction (pfx, fNull)) {
      if (!GetValue (pfx, val)) return MagickFalse;
      if (!ExpectChar (pfx, ')')) return MagickFalse;
      return MagickTrue;
    }
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "Expected function or value at", "'%s'",
      SetShortExp(pfx));
    return MagickFalse;
  }
  return GetValue (pfx, val);
}

static MagickBooleanType GetValueOrFunctionOrSymbolOrImgAttr (FxInfo * pfx, fxFltType *val)
{
  if (PeekChar (pfx) == '(') {
    pfx->pex++;
    (void) GetToken (pfx);
    if (LocaleCompare (pfx->token, "rand") == 0) {
      *val = GetPseudoRandomValue (pfx->random_info);
      pfx->pex += pfx->lenToken;
      return MagickTrue;
    }
    if (GetFunction (pfx, fNull)) {
      if (!GetValue (pfx, val)) return MagickFalse;
      if (!ExpectChar (pfx, ')')) return MagickFalse;
      return MagickTrue;
    }
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "Expected function or value at", "'%s'",
      SetShortExp(pfx));
    return MagickFalse;
  }
  return GetValue (pfx, val);
}

static MagickBooleanType GetValueOrFunctionOrSymbolOrImgAttrOrQualifier (FxInfo * pfx, fxFltType *val)
{
  if (PeekChar (pfx) == '(') {
    pfx->pex++;
    (void) GetToken (pfx);
    if (LocaleCompare (pfx->token, "rand") == 0) {
      *val = GetPseudoRandomValue (pfx->random_info);
      pfx->pex += pfx->lenToken;
      return MagickTrue;
    }
    if (GetFunction (pfx, fNull)) {
      if (!GetValue (pfx, val)) return MagickFalse;
      if (!ExpectChar (pfx, ')')) return MagickFalse;
      return MagickTrue;
    }
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "Expected function or value at", "'%s'",
      SetShortExp(pfx));
    return MagickFalse;
  }
  if (PeekChar (pfx) == '.') {
    pfx->pex++;
    return GetImgAttr (pfx, val);
  }
  return GetValue (pfx, val);
}

static MagickBooleanType GetValueOrFunctionOrSymbolOrImgAttrOrQualifierOrChannel (FxInfo * pfx, fxFltType *val)
{
  if (PeekChar (pfx) == '(') {
    pfx->pex++;
    (void) GetToken (pfx);
    if (LocaleCompare (pfx->token, "rand") == 0) {
      *val = GetPseudoRandomValue (pfx->random_info);
      pfx->pex += pfx->lenToken;
      return MagickTrue;
    }
    if (GetFunction (pfx, fNull)) {
      if (!GetValue (pfx, val)) return MagickFalse;
      if (!ExpectChar (pfx, ')')) return MagickFalse;
      return MagickTrue;
    }
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "Expected function or value