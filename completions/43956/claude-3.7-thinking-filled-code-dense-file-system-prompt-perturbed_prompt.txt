Below is the content of a C/C++ function where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
static MagickBooleanType GetFunction (FxInfo * pfx, FunctionE fe)
{
  /* A function, so get open-parens, n args, close-parens
  */
  const char * funStr = Functions[fe-FirstFunc].str;
  int nArgs = Functions[fe-FirstFunc].nArgs;
  char chLimit = ')';
  char expChLimit = ')';
  const char *strLimit = ",)";
  OperatorE pushOp = oOpenParen;

  char * pExpStart;

  int lenExp = 0;

  int FndArgs = 0;
  int ndx0 = NULL_ADDRESS, firstArgIndex = NULL_ADDRESS, ndx2 = NULL_ADDRESS, ndx3 = NULL_ADDRESS;

  MagickBooleanType coordQual = MagickFalse;
  PixelChannel chQual = NO_CHAN_QUAL;
  ImgAttrE iaQual = aNull;

  pfx->pex += pfx->lenToken;

  if (fe == fP) {
    char p = PeekChar (pfx);
    if (p=='{') {
      (void) ExpectChar (pfx, '{');
      pushOp = oOpenBrace;
      strLimit = ",}";
      chLimit = '}';
      expChLimit = '}';
    } else if (p=='[') {
      (void) ExpectChar (pfx, '[');
      pushOp = oOpenBracket;
      strLimit = ",]";
      chLimit = ']';
      expChLimit = ']';
    } else {
      nArgs = 0;
      chLimit = ']';
      expChLimit = ']';
    }
  } else if (fe == fU) {
    char p = PeekChar (pfx);
    if (p=='[') {
      (void) ExpectChar (pfx, '[');
      pushOp = oOpenBracket;
      strLimit = ",]";
      chLimit = ']';
      expChLimit = ']';
    } else {
      nArgs = 0;
      chLimit = ']';
      expChLimit = ']';
    }
  } else if (fe == fV || fe == fS) {
      nArgs = 0;
      pushOp = oOpenBracket;
      chLimit = ']';
      expChLimit = ']';
  } else {
    if (!ExpectChar (pfx, '(')) return MagickFalse;
  }
  if (!PushOperatorStack (pfx, pushOp)) return MagickFalse;

  pExpStart = pfx->pex;
  ndx0 = pfx->usedElements;
  if (fe==fDo) {
    (void) AddAddressingElement (pfx, rGoto, NULL_ADDRESS); /* address will be ndx1+1 */
  }
  while (nArgs > 0) {
    int FndOne = 0;
    if (TranslateStatementList (pfx, strLimit, &chLimit)) {
      FndOne = 1;
    } else {
      /* Maybe don't break because other expressions may be not empty. */
      if (!chLimit) break;
      if (fe == fP || fe == fS|| fe == fIf) {
        (void) AddElement (pfx, (fxFltType) 0, oNull);
        FndOne = 1;
      } 
    }

    if (strchr (strLimit, chLimit)==NULL) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "For function", "'%s' expected one of '%s' after expression but found '%c' at '%s'",
        funStr, strLimit, chLimit ? chLimit : ' ', SetShortExp(pfx));
      return MagickFalse;
    }
    if (FndOne) {
      FndArgs++;
      nArgs--;
    }
    switch (FndArgs) {
      // Handle the specific cases of function element processing based on the number of arguments found.
      // For the first argument, update the index to the current element and handle special instructions
      // based on the function type. These may include adding elements to the addressing stack with potential
      // conditional jumps or specific flags for loop and conditional constructs.
      // For the second argument, further update the index and similarly manage instructions based on the function type,
      // which might include unconditional jumps, stack manipulations, or flags for loops.
      // For the third argument, update the index and handle specific loop constructs by inserting jump operations
      // to previously recorded indices to ensure proper loop control flow.
      // <MASK>
      default:
        break;
    }
    if (chLimit == expChLimit) {
      lenExp = pfx->pex - pExpStart - 1;
      break;
    }
  } /* end while args of a function */
  if (chLimit && chLimit != expChLimit && chLimit != ',' ) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "For function", "'%s' expected '%c', found '%c' at '%s'",
      funStr, expChLimit, chLimit ? chLimit : ' ', SetShortExp(pfx));
    return MagickFalse;
  }

  if (fe == fP || fe == fS || fe == fU) {
    while (FndArgs < Functions[fe-FirstFunc].nArgs) {
      (void) AddElement (pfx, (fxFltType) 0, oNull);
      FndArgs++;
    }
  }

  if (FndArgs > Functions[fe-FirstFunc].nArgs) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "For function", "'%s' expected %i arguments, found '%i' at '%s'",
      funStr, Functions[fe-FirstFunc].nArgs, FndArgs, SetShortExp(pfx));
    return MagickFalse;
  }
  if (FndArgs < Functions[fe-FirstFunc].nArgs) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "For function", "'%s' expected %i arguments, found too few (%i) at '%s'",
      funStr, Functions[fe-FirstFunc].nArgs, FndArgs, SetShortExp(pfx));
    return MagickFalse;
  }
  if (fe != fS && fe != fV && FndArgs == 0 && Functions[fe-FirstFunc].nArgs == 0) {
    /* This is for "rand()" and similar. */
    chLimit = expChLimit;
    if (!ExpectChar (pfx, ')')) return MagickFalse;
  }

  if (chLimit != expChLimit) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "For function", "'%s', arguments don't end with '%c' at '%s'",
      funStr, expChLimit, SetShortExp(pfx));
    return MagickFalse;
  }
  if (!PopOprOpenParen (pfx, pushOp)) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "Bug: For function", "'%s' tos not '%s' at '%s'",
      funStr, Operators[pushOp].str, SetShortExp(pfx));
    return MagickFalse;
  }

  if (IsQualifier (pfx)) {

    if (fe == fU || fe == fV || fe == fS) {

      coordQual = (GetCoordQualifier (pfx, fe) == 1) ? MagickTrue : MagickFalse;

      if (coordQual) {

        /* Remove last element, which should be fP */
        ElementT * pel = &pfx->Elements[pfx->usedElements-1];
        if (pel->oprNum != fP) {
          (void) ThrowMagickException (
            pfx->exception, GetMagickModule(), OptionError,
            "Bug: For function", "'%s' last element not 'p' at '%s'",
            funStr, SetShortExp(pfx));
          return MagickFalse;
        }
        chQual = pel->ChannelQual;
        expChLimit = (pel->IsRelative) ? ']' : '}';
        pfx->usedElements--;
        if (fe == fU) fe = fUP;
        else if (fe == fV) fe = fVP;
        else if (fe == fS) fe = fSP;
        funStr = Functions[fe-FirstFunc].str;
      }
    }

    if ( chQual == NO_CHAN_QUAL &&
         (fe == fP || fe == fS || fe == fSP || fe == fU || fe == fUP || fe == fV || fe == fVP)
       )
    {
      chQual = GetChannelQualifier (pfx, fe);
    }

    if (chQual == NO_CHAN_QUAL && (fe == fU || fe == fV || fe == fS)) {
      /* Note: we don't allow "p.mean" etc. */
      iaQual = GetImgAttrQualifier (pfx, fe);
    }
    if (IsQualifier (pfx) && chQual == NO_CHAN_QUAL && iaQual != aNull) {
      chQual = GetChannelQualifier (pfx, fe);
    }
    if (coordQual && iaQual != aNull) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "For function", "'%s', can't have qualifiers 'p' and image attribute '%s' at '%s'",
        funStr, pfx->token, SetShortExp(pfx));
      return MagickFalse;
    }
    if (!coordQual && chQual == NO_CHAN_QUAL && iaQual == aNull) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "For function", "'%s', bad qualifier '%s' at '%s'",
        funStr, pfx->token, SetShortExp(pfx));
      return MagickFalse;
    }
    if (!coordQual && chQual == CompositePixelChannel && iaQual == aNull) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "For function", "'%s', bad composite qualifier '%s' at '%s'",
        funStr, pfx->token, SetShortExp(pfx));
      return MagickFalse;
    }

    if (chQual == HUE_CHANNEL || chQual == SAT_CHANNEL || chQual == LIGHT_CHANNEL) {
      pfx->NeedHsl = MagickTrue;

      if (iaQual >= FirstImgAttr && iaQual < aNull) {
        (void) ThrowMagickException (
          pfx->exception, GetMagickModule(), OptionError,
          "Can't have image attribute with HLS qualifier at", "'%s'",
          SetShortExp(pfx));
        return MagickFalse;
      }
    }
  }

  if (fe==fWhile) {
    pfx->Elements[firstArgIndex].EleNdx = ndx2+1;
  } else if (fe==fDo) {
    pfx->Elements[ndx0].EleNdx = firstArgIndex+1;
    pfx->Elements[firstArgIndex].EleNdx = ndx2+1;
  } else if (fe==fFor) {
    pfx->Elements[ndx2].EleNdx = ndx3;
  } else if (fe==fIf) {
    pfx->Elements[firstArgIndex].EleNdx = ndx2 + 1;
    pfx->Elements[ndx2].EleNdx = ndx3;
  } else {
    if (fe == fU && iaQual == aNull) {
      ElementT * pel = &pfx->Elements[pfx->usedElements-1];
      if (pel->type == etConstant && pel->val == 0.0) {
        pfx->usedElements--;
        fe = fU0;
      }
    }
    (void) AddElement (pfx, (fxFltType) 0, fe);
    if (fe == fP || fe == fU  || fe == fU0 || fe == fUP ||
        fe == fV || fe == fVP || fe == fS || fe == fSP)
    {
      ElementT * pel = &pfx->Elements[pfx->usedElements-1];
      pel->IsRelative = (expChLimit == ']' ? MagickTrue : MagickFalse);
      if (chQual >= 0) pel->ChannelQual = chQual;
      if (iaQual != aNull && (fe == fU || fe == fV || fe == fS)) {
        /* Note: we don't allow "p[2,3].mean" or "p.mean" etc. */
        pel->ImgAttrQual = iaQual;
      }
    }
  }

  if (pExpStart && lenExp) {
    ElementT * pel = &pfx->Elements[pfx->usedElements-1];
    pel->pExpStart = pExpStart;
    pel->lenExp = lenExp;
  }

  if (fe == fDebug)
    pfx->ContainsDebug = MagickTrue;

  return MagickTrue;
}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// MagickCore/fx.c
static MagickBooleanType ExecuteRPN (FxInfo * pfx, fxRtT * pfxrt, fxFltType *result,
  const PixelChannel channel, const ssize_t imgx, const ssize_t imgy)
{
  const Quantum * p = pfxrt->thisPixel;
  fxFltType regA=0, regB=0, regC=0, regD=0, regE=0;
  Image * img = pfx->image;
  ChannelStatistics * cs = NULL;
  MagickBooleanType NeedRelinq = MagickFalse;
  double hue=0, saturation=0, lightness=0;
  int i;

  /* For -fx, this sets p to ImgNum 0.
     for %[fx:...], this sets p to the currrent image.
     Similarly img.
  */
  if (!p) p = GetCacheViewVirtualPixels (
    pfx->Imgs[pfx->ImgNum].View, imgx, imgy, 1, 1, pfx->exception);

  if (pfx->GotStats) {
    cs = pfx->statistics[pfx->ImgNum];
  } else if (pfx->NeedStats) {
    cs = CollectOneImgStats (pfx, pfx->Images[pfx->ImgNum]);
    NeedRelinq = MagickTrue;
  }

  /*  Folllowing is only for expressions like "saturation", with no image specifier.
  */
  if (pfx->NeedHsl) {
    ConvertRGBToHSL (
      GetPixelRed (img, p), GetPixelGreen (img, p), GetPixelBlue (img, p),
      &hue, &saturation, &lightness);
  }

  for (i=0; i < pfx->usedElements; i++) {
    ElementT *pel = &pfx->Elements[i];
      switch (pel->nArgs) {
        case 0:
          break;
        case 1:
          regA = PopVal (pfx, pfxrt, i);
          break;
        case 2:
          regB = PopVal (pfx, pfxrt, i);
          regA = PopVal (pfx, pfxrt, i);
          break;
        case 3:
          regC = PopVal (pfx, pfxrt, i);
          regB = PopVal (pfx, pfxrt, i);
          regA = PopVal (pfx, pfxrt, i);
          break;
        case 4:
          regD = PopVal (pfx, pfxrt, i);
          regC = PopVal (pfx, pfxrt, i);
          regB = PopVal (pfx, pfxrt, i);
          regA = PopVal (pfx, pfxrt, i);
          break;
        case 5:
          regE = PopVal (pfx, pfxrt, i);
          regD = PopVal (pfx, pfxrt, i);
          regC = PopVal (pfx, pfxrt, i);
          regB = PopVal (pfx, pfxrt, i);
          regA = PopVal (pfx, pfxrt, i);
          break;
        default:
          (void) ThrowMagickException (
            pfx->exception, GetMagickModule(), OptionError,
            "Too many args:", "%i", pel->nArgs);
          break;
      }

      switch (pel->oprNum) {
        case oAddEq:
          regA = (pfxrt->UserSymVals[pel->EleNdx] += regA);
          break;
        case oSubtractEq:
          regA = (pfxrt->UserSymVals[pel->EleNdx] -= regA);
          break;
        case oMultiplyEq:
          regA = (pfxrt->UserSymVals[pel->EleNdx] *= regA);
          break;
        case oDivideEq:
          regA = (pfxrt->UserSymVals[pel->EleNdx] *= PerceptibleReciprocal((double)regA));
          break;
        case oPlusPlus:
          regA = pfxrt->UserSymVals[pel->EleNdx]++;
          break;
        case oSubSub:
          regA = pfxrt->UserSymVals[pel->EleNdx]--;
          break;
        case oAdd:
          regA += regB;
          break;
        case oSubtract:
          regA -= regB;
          break;
        case oMultiply:
          regA *= regB;
          break;
        case oDivide:
          regA *= PerceptibleReciprocal((double)regB);
          break;
        case oModulus:
          regA = fmod ((double) regA, fabs(floor((double) regB+0.5)));
          break;
        case oUnaryPlus:
          /* Do nothing. */
          break;
        case oUnaryMinus:
          regA = -regA;
          break;
        case oLshift:
          if ((size_t) (regB+0.5) >= (8*sizeof(size_t)))
            {
              (void) ThrowMagickException ( pfx->exception, GetMagickModule(),
                OptionError, "undefined shift", "%g", (double) regB);
              regA = (fxFltType) 0.0;
              break;
            }
          regA = (fxFltType) ((size_t)(regA+0.5) << (size_t)(regB+0.5));
          break;
        case oRshift:
          if ((size_t) (regB+0.5) >= (8*sizeof(size_t)))
            {
              (void) ThrowMagickException ( pfx->exception, GetMagickModule(),
                OptionError, "undefined shift", "%g", (double) regB);
              regA = (fxFltType) 0.0;
              break;
            }
          regA = (fxFltType) ((size_t)(regA+0.5) >> (size_t)(regB+0.5));
          break;
        case oEq:
          regA = fabs((double) (regA-regB)) < MagickEpsilon ? 1.0 : 0.0;
          break;
        case oNotEq:
          regA = fabs((double) (regA-regB)) >= MagickEpsilon ? 1.0 : 0.0;
          break;
        case oLtEq:
          regA = (regA <= regB) ? 1.0 : 0.0;
          break;
        case oGtEq:
          regA = (regA >= regB) ? 1.0 : 0.0;
          break;
        case oLt:
          regA = (regA < regB) ? 1.0 : 0.0;
          break;
        case oGt:
          regA = (regA > regB) ? 1.0 : 0.0;
          break;
        case oLogAnd:
          regA = (regA<=0) ? 0.0 : (regB > 0) ? 1.0 : 0.0;
          break;
        case oLogOr:
          regA = (regA>0) ? 1.0 : (regB > 0.0) ? 1.0 : 0.0;
          break;
        case oLogNot:
          regA = (regA==0) ? 1.0 : 0.0;
          break;
        case oBitAnd:
          regA = (fxFltType) ((size_t)(regA+0.5) & (size_t)(regB+0.5));
          break;
        case oBitOr:
          regA = (fxFltType) ((size_t)(regA+0.5) | (size_t)(regB+0.5));
          break;
        case oBitNot:
          /* Old fx doesn't add 0.5. */
          regA = (fxFltType) (~(size_t)(regA+0.5));
          break;
        case oPow:
          regA = pow ((double) regA, (double) regB);
          break;
        case oQuery:
        case oColon:
          break;
        case oOpenParen:
        case oCloseParen:
        case oOpenBracket:
        case oCloseBracket:
        case oOpenBrace:
        case oCloseBrace:
          break;
        case oAssign:
          pel->val = regA;
          break;
        case oNull: {
          if (pel->type == etColourConstant) {
            switch (channel) {
              default:
              case 0:
                regA = pel->val;
                break;
              case 1:
                regA = pel->val1;
                break;
              case 2:
                regA = pel->val2;
                break;
            }
          } else {
            regA = pel->val;
          }
          break;
        }
        case fAbs:
          regA = fabs ((double) regA);
          break;
#if defined(MAGICKCORE_HAVE_ACOSH)
        case fAcosh:
          regA = acosh ((double) regA);
          break;
#endif
        case fAcos:
          regA = acos ((double) regA);
          break;
#if defined(MAGICKCORE_HAVE_J1)
        case fAiry:
          if (regA==0) regA = 1.0;
          else {
            fxFltType gamma = 2.0 * j1 ((MagickPI*regA)) / (MagickPI*regA);
            regA = gamma * gamma;
          }
          break;
#endif
        case fAlt:
          regA = (fxFltType) (((ssize_t) regA) & 0x01 ? -1.0 : 1.0);
          break;
#if defined(MAGICKCORE_HAVE_ASINH)
        case fAsinh:
          regA = asinh ((double) regA);
          break;
#endif
        case fAsin:
          regA = asin ((double) regA);
          break;
#if defined(MAGICKCORE_HAVE_ATANH)
        case fAtanh:
          regA = atanh ((double) regA);
          break;
#endif
        case fAtan2:
          regA = atan2 ((double) regA, (double) regB);
          break;
        case fAtan:
          regA = atan ((double) regA);
          break;
        case fCeil:
          regA = ceil ((double) regA);
          break;
        case fChannel:
          switch (channel) {
            case 0: break;
            case 1: regA = regB; break;
            case 2: regA = regC; break;
            case 3: regA = regD; break;
            case 4: regA = regE; break;
            default: regA = 0.0;
          }
          break;
        case fClamp:
          if (regA < 0) regA = 0.0;
          else if (regA > 1.0) regA = 1.0;
          break;
        case fCosh:
          regA = cosh ((double) regA);
          break;
        case fCos:
          regA = cos ((double) regA);
          break;
        case fDebug:
          /* FIXME: debug() should give channel name. */

          (void) fprintf (stderr, "%s[%g,%g].[%i]: %s=%.*Lg\n",
                   img->filename, (double) imgx, (double) imgy,
                   channel, SetPtrShortExp (pfx, pel->pExpStart, (size_t) (pel->lenExp+1)),
                   pfx->precision, regA);
          break;
        case fDrc:
          regA = regA / (regB*(regA-1.0) + 1.0);
          break;
#if defined(MAGICKCORE_HAVE_ERF)
        case fErf:
          regA = erf ((double) regA);
          break;
#endif
        case fExp:
          regA = exp ((double) regA);
          break;
        case fFloor:
          regA = floor ((double) regA);
          break;
        case fGauss:
          regA = exp((double) (-regA*regA/2.0))/sqrt(2.0*MagickPI);
          break;
        case fGcd:
          if (!IsNaN(regA)) 
            regA = FxGcd (regA, regB, 0);
          break;
        case fHypot:
          regA = hypot ((double) regA, (double) regB);
          break;
        case fInt:
          regA = floor ((double) regA);
          break;
        case fIsnan:
          regA = (fxFltType) (!!IsNaN (regA));
          break;
#if defined(MAGICKCORE_HAVE_J0)
        case fJ0:
          regA = j0 ((double) regA);
          break;
#endif
#if defined(MAGICKCORE_HAVE_J1)
        case fJ1:
          regA = j1 ((double) regA);
          break;
#endif
#if defined(MAGICKCORE_HAVE_J1)
        case fJinc:
          if (regA==0) regA = 1.0;
          else regA = 2.0 * j1 ((MagickPI*regA))/(MagickPI*regA);
          break;
#endif
        case fLn:
          regA = log ((double) regA);
          break;
        case fLogtwo:
          regA = log10((double) regA) / log10(2.0);
          break;
        case fLog:
          regA = log10 ((double) regA);
          break;
        case fMax:
          regA = (regA > regB) ? regA : regB;
          break;
        case fMin:
          regA = (regA < regB) ? regA : regB;
          break;
        case fMod:
          regA = regA - floor((double) (regA*PerceptibleReciprocal((double) regB)))*regB;
          break;
        case fNot:
          regA = (fxFltType) (regA < MagickEpsilon);
          break;
        case fPow:
          regA = pow ((double) regA, (double) regB);
          break;
        case fRand: {
#if defined(MAGICKCORE_OPENMP_SUPPORT)
          #pragma omp critical (MagickCore_ExecuteRPN)
#endif
          regA = GetPseudoRandomValue (pfxrt->random_info);
          break;
        }
        case fRound:
          regA = floor ((double) regA + 0.5);
          break;
        case fSign:
          regA = (regA < 0) ? -1.0 : 1.0;
          break;
        case fSinc:
          regA = sin ((double) (MagickPI*regA)) / (MagickPI*regA);
          break;
        case fSinh:
          regA = sinh ((double) regA);
          break;
        case fSin:
          regA = sin ((double) regA);
          break;
        case fSqrt:
          regA = sqrt ((double) regA);
          break;
        case fSquish:
          regA = 1.0 / (1.0 + exp ((double) -regA));
          break;
        case fTanh:
          regA = tanh ((double) regA);
          break;
        case fTan:
          regA = tan ((double) regA);
          break;
        case fTrunc:
          if (regA >= 0) regA = floor ((double) regA);
          else regA = ceil ((double) regA);
          break;

        case fDo:
        case fFor:
        case fIf:
        case fWhile:
          break;
        case fU: {
          /* Note: 1 value is available, index into image list.
             May have ImgAttr qualifier or channel qualifier or both.
          */
          ssize_t ImgNum = ChkImgNum (pfx, regA);
          if (ImgNum < 0) break;
          regA = (fxFltType) 0;
          if (ImgNum == 0) {
            Image * pimg = pfx->Images[0];
            int pech = (int)pel->ChannelQual;
            if (pel->ImgAttrQual == aNull) {
              if (pech < 0) {
                if (pech == NO_CHAN_QUAL || pech == THIS_CHANNEL) {
                  if (pfx->ImgNum==0) {
                    regA = QuantumScale * p[pimg->channel_map[WHICH_NON_ATTR_CHAN].offset];
                  } else {
                    const Quantum * pv = GetCacheViewVirtualPixels (
                                   pfx->Imgs[0].View, imgx, imgy, 1,1, pfx->exception);
                    if (!pv) {
                      (void) ThrowMagickException (
                        pfx->exception, GetMagickModule(), OptionError,
                        "fU can't get cache", "%lu", ImgNum);
                      break;
                    }
                    regA = QuantumScale * pv[pimg->channel_map[WHICH_NON_ATTR_CHAN].offset];
                  }
                } else if (pech == HUE_CHANNEL || pech == SAT_CHANNEL ||
                    pech == LIGHT_CHANNEL) {
                  regA = GetHslInt (pfx, ImgNum, imgx, imgy, pech);
                  break;
                } else if (pech == INTENSITY_CHANNEL) {
                  regA = GetIntensity (pfx, 0, (double) imgx, (double) imgy);
                  break;
                }
              } else {
                if (pfx->ImgNum==0) {
                  regA = QuantumScale * p[pimg->channel_map[WHICH_NON_ATTR_CHAN].offset];
                } else {
                  const Quantum * pv = GetCacheViewVirtualPixels (
                                 pfx->Imgs[0].View, imgx, imgy, 1,1, pfx->exception);
                  if (!pv) {
                    (void) ThrowMagickException (
                      pfx->exception, GetMagickModule(), OptionError,
                      "fU can't get cache", "%lu", ImgNum);
                    break;
                  }
                  regA = QuantumScale * pv[pimg->channel_map[WHICH_NON_ATTR_CHAN].offset];
                }
              }
            } else {
              /* we have an image atttribute */
              regA = ImageStat (pfx, 0, WHICH_ATTR_CHAN, pel->ImgAttrQual);
            }
          } else {
            /* We have non-zero ImgNum. */
            if (pel->ImgAttrQual == aNull) {
              const Quantum * pv;
              if ((int)pel->ChannelQual < 0) {
                if (pel->ChannelQual == HUE_CHANNEL || pel->ChannelQual == SAT_CHANNEL ||
                    pel->ChannelQual == LIGHT_CHANNEL)
                {
                  regA = GetHslInt (pfx, ImgNum, imgx, imgy, pel->ChannelQual);
                  break;
                } else if (pel->ChannelQual == INTENSITY_CHANNEL)
                {
                  regA = GetIntensity (pfx, ImgNum, (fxFltType) imgx, (fxFltType) imgy);
                  break;
                }
              }

              pv = GetCacheViewVirtualPixels (
                     pfx->Imgs[ImgNum].View, imgx, imgy, 1,1, pfx->exception);
              if (!pv) {
                (void) ThrowMagickException (
                  pfx->exception, GetMagickModule(), OptionError,
                  "fU can't get cache", "%lu", ImgNum);
                break;
              }
              regA = QuantumScale *
         pv[pfx->Images[ImgNum]->channel_map[WHICH_NON_ATTR_CHAN].offset];
            } else {
              regA = ImageStat (pfx, ImgNum, WHICH_ATTR_CHAN, pel->ImgAttrQual);
            }
          }
          break;
        }
        case fU0: {
          /* No args. No image attribute. We may have a ChannelQual.
             If called from %[fx:...], ChannelQual will be CompositePixelChannel.
          */
          Image * pimg = pfx->Images[0];
          int pech = (int)pel->ChannelQual;
          if (pech < 0) {
            if (pech == NO_CHAN_QUAL || pech == THIS_CHANNEL) {

              if (pfx->ImgNum==0) {
                regA = QuantumScale * p[pimg->channel_map[WHICH_NON_ATTR_CHAN].offset];
              } else {
                const Quantum * pv = GetCacheViewVirtualPixels (
                               pfx->Imgs[0].View, imgx, imgy, 1,1, pfx->exception);
                if (!pv) {
                  (void) ThrowMagickException (
                    pfx->exception, GetMagickModule(), OptionError,
                    "fU0 can't get cache", "%i", 0);
                  break;
                }
                regA = QuantumScale * pv[pimg->channel_map[WHICH_NON_ATTR_CHAN].offset];
              }

            } else if (pel->ChannelQual == HUE_CHANNEL || pel->ChannelQual == SAT_CHANNEL ||
                       pel->ChannelQual == LIGHT_CHANNEL) {
              regA = GetHslInt (pfx, 0, imgx, imgy, pel->ChannelQual);
              break;
            } else if (pel->ChannelQual == INTENSITY_CHANNEL) {
              regA = GetIntensity (pfx, 0, (fxFltType) imgx, (fxFltType) imgy);
            }
          } else {
            if (pfx->ImgNum==0) {
              regA = QuantumScale * p[pimg->channel_map[WHICH_NON_ATTR_CHAN].offset];
            } else {
              const Quantum * pv = GetCacheViewVirtualPixels (
                                   pfx->Imgs[0].View, imgx, imgy, 1,1, pfx->exception);
              if (!pv) {
                (void) ThrowMagickException (
                  pfx->exception, GetMagickModule(), OptionError,
                  "fU0 can't get cache", "%i", 0);
                break;
              }
              regA = QuantumScale * pv[pimg->channel_map[WHICH_NON_ATTR_CHAN].offset];
            }
          }
          break;
        }
        case fUP: {
          /* 3 args are: ImgNum, x, y */
          ssize_t ImgNum = ChkImgNum (pfx, regA);
          fxFltType fx, fy;

          if (ImgNum < 0) break;

          if (pel->IsRelative) {
            fx = imgx + regB;
            fy = imgy + regC;
          } else {
            fx = regB;
            fy = regC;
          }

          if ((int)pel->ChannelQual < 0) {
            if (pel->ChannelQual == HUE_CHANNEL || pel->ChannelQual == SAT_CHANNEL
             || pel->ChannelQual == LIGHT_CHANNEL) {
              regA = GetHslFlt (pfx, ImgNum, fx, fy, pel->ChannelQual);
              break;
            } else if (pel->ChannelQual == INTENSITY_CHANNEL) {
              regA = GetIntensity (pfx, ImgNum, fx, fy);
              break;
            }
          }

          {
            double v;
            Image * imUP = pfx->Images[ImgNum];
            if (! InterpolatePixelChannel (imUP, pfx->Imgs[ImgNum].View, WHICH_NON_ATTR_CHAN,
                    imUP->interpolate, (double) fx, (double) fy, &v, pfx->exception))
            {
              (void) ThrowMagickException (
                pfx->exception, GetMagickModule(), OptionError,
                "fUP can't get interpolate", "%lu", ImgNum);
              break;
            }
            regA = v * QuantumScale;
          }

          break;
        }
        case fS:
        case fV: {
          /* No args. */
          ssize_t ImgNum = 1;
          if (pel->oprNum == fS) ImgNum = pfx->ImgNum;

          if (pel->ImgAttrQual == aNull) {
            const Quantum * pv = GetCacheViewVirtualPixels (
                                   pfx->Imgs[ImgNum].View, imgx, imgy, 1,1, pfx->exception);
            if (!pv) {
              (void) ThrowMagickException (
                pfx->exception, GetMagickModule(), OptionError,
                "fV can't get cache", "%lu", ImgNum);
              break;
            }

            if ((int)pel->ChannelQual < 0) {
              if (pel->ChannelQual == HUE_CHANNEL || pel->ChannelQual == SAT_CHANNEL ||
                  pel->ChannelQual == LIGHT_CHANNEL) {
                regA = GetHslInt (pfx, ImgNum, imgx, imgy, pel->ChannelQual);
                break;
              } else if (pel->ChannelQual == INTENSITY_CHANNEL) {
                regA = GetIntensity (pfx, ImgNum, (double) imgx, (double) imgy);
                break;
              }
            }

            regA = QuantumScale *
         pv[pfx->Images[ImgNum]->channel_map[WHICH_NON_ATTR_CHAN].offset];
          } else {
            regA = ImageStat (pfx, ImgNum, WHICH_ATTR_CHAN, pel->ImgAttrQual);
          }

          break;
        }
        case fP:
        case fSP:
        case fVP: {
          /* 2 args are: x, y */
          fxFltType fx, fy;
          ssize_t ImgNum = pfx->ImgNum;
          if (pel->oprNum == fVP) ImgNum = 1;
          if (pel->IsRelative) {
            fx = imgx + regA;
            fy = imgy + regB;
          } else {
            fx = regA;
            fy = regB;
          }
          if ((int)pel->ChannelQual < 0) {
            if (pel->ChannelQual == HUE_CHANNEL || pel->ChannelQual == SAT_CHANNEL ||
                pel->ChannelQual == LIGHT_CHANNEL) {
              regA = GetHslFlt (pfx, ImgNum, fx, fy, pel->ChannelQual);
              break;
            } else if (pel->ChannelQual == INTENSITY_CHANNEL) {
              regA = GetIntensity (pfx, ImgNum, fx, fy);
            }
          }

          {
            double v;

            if (! InterpolatePixelChannel (pfx->Images[ImgNum], pfx->Imgs[ImgNum].View,
                                           WHICH_NON_ATTR_CHAN, pfx->Images[ImgNum]->interpolate,
                                           (double) fx, (double) fy, &v, pfx->exception)
                                          )
            {
              (void) ThrowMagickException (
                pfx->exception, GetMagickModule(), OptionError,
                "fSP or fVP can't get interp", "%lu", ImgNum);
              break;
            }
            regA = v * (fxFltType)QuantumScale;
          }

          break;
        }
        case fNull:
          break;
        case aDepth:
          regA = (fxFltType) GetImageDepth (img, pfx->exception);
          break;
        case aExtent:
          regA = (fxFltType) img->extent;
          break;
        case aKurtosis:
          regA = cs[WHICH_ATTR_CHAN].kurtosis;
          break;
        case aMaxima:
          regA = cs[WHICH_ATTR_CHAN].maxima;
          break;
        case aMean:
          regA = cs[WHICH_ATTR_CHAN].mean;
          break;
        case aMedian:
          regA = cs[WHICH_ATTR_CHAN].median;
          break;
        case aMinima:
          regA = cs[WHICH_ATTR_CHAN].minima;
          break;
        case aPage:
          break;
        case aPageX:
          regA = (fxFltType) img->page.x;
          break;
        case aPageY:
          regA = (fxFltType) img->page.y;
          break;
        case aPageWid:
          regA = (fxFltType) img->page.width;
          break;
        case aPageHt:
          regA = (fxFltType) img->page.height;
          break;
        case aPrintsize:
          break;
        case aPrintsizeX:
          regA = (fxFltType) PerceptibleReciprocal (img->resolution.x) * img->columns;
          break;
        case aPrintsizeY:
          regA = (fxFltType) PerceptibleReciprocal (img->resolution.y) * img->rows;
          break;
        case aQuality:
          regA = (fxFltType) img->quality;
          break;
        case aRes:
          break;
        case aResX:
          regA = (fxFltType) img->resolution.x;
          break;
        case aResY:
          regA = (fxFltType) img->resolution.y;
          break;
        case aSkewness:
          regA = cs[WHICH_ATTR_CHAN].skewness;
          break;
        case aStdDev:
          regA = cs[WHICH_ATTR_CHAN].standard_deviation;
          break;
        case aH: /* image->rows */
          regA = (fxFltType) img->rows;
          break;
        case aN: /* image list length */
          regA = (fxFltType) pfx->ImgListLen;
          break;
        case aT: /* image index in list */
          regA = (fxFltType) pfx->ImgNum;
          break;
        case aW: /* image->columns */
          regA = (fxFltType) img->columns;
          break;
        case aZ: /* image depth */
          regA = (fxFltType) GetImageDepth (img, pfx->exception);
          break;
        case aNull:
          break;
        case sHue: /* of conversion to HSL */
          regA = hue;
          break;
        case sIntensity:
          regA = GetIntensity (pfx, pfx->ImgNum, (double) imgx, (double) imgy);
          break;
        case sLightness: /* of conversion to HSL */
          regA = lightness;
          break;
        case sLuma: /* calculation */
        case sLuminance: /* as Luma */
          regA = QuantumScale * (0.212656 * GetPixelRed (img,p) +
                                 0.715158 * GetPixelGreen (img,p) +
                                 0.072186 * GetPixelBlue (img,p));
          break;
        case sSaturation: /* from conversion to HSL */
          regA = saturation;
          break;
        case sA: /* alpha */
          regA = QuantumScale * GetPixelAlpha (img, p);
          break;
        case sB: /* blue */
          regA = QuantumScale * GetPixelBlue (img, p);
          break;
        case sC: /* red (ie cyan) */
          regA = QuantumScale * GetPixelCyan (img, p);
          break;
        case sG: /* green */
          regA = QuantumScale * GetPixelGreen (img, p);
          break;
        case sI: /* current x-coordinate */
          regA = (fxFltType) imgx;
          break;
        case sJ: /* current y-coordinate */
          regA = (fxFltType) imgy;
          break;
        case sK: /* black of CMYK */
          regA = QuantumScale * GetPixelBlack (img, p);
          break;
        case sM: /* green (ie magenta) */
          regA = QuantumScale * GetPixelGreen (img, p);
          break;
        case sO: /* alpha */
          regA = QuantumScale * GetPixelAlpha (img, p);
          break;
        case sR:
          regA = QuantumScale * GetPixelRed (img, p);
          break;
        case sY:
          regA = QuantumScale * GetPixelYellow (img, p);
          break;
        case sNull:
          break;

        case rGoto:
          assert (pel->EleNdx >= 0);
          i = pel->EleNdx-1; /* -1 because 'for' loop will increment. */
          break;
        case rIfZeroGoto:
          assert (pel->EleNdx >= 0);
          if (fabs((double) regA) < MagickEpsilon) i = pel->EleNdx-1;
          break;
        case rIfNotZeroGoto:
          assert (pel->EleNdx >= 0);
          if (fabs((double) regA) > MagickEpsilon) i = pel->EleNdx-1;
          break;
        case rCopyFrom:
          assert (pel->EleNdx >= 0);
          regA = pfxrt->UserSymVals[pel->EleNdx];
          break;
        case rCopyTo:
          assert (pel->EleNdx >= 0);
          pfxrt->UserSymVals[pel->EleNdx] = regA;
          break;
        case rZerStk:
          pfxrt->usedValStack = 0;
          break;
        case rNull:
          break;

        default:
          (void) ThrowMagickException (
            pfx->exception, GetMagickModule(), OptionError,
            "pel->oprNum", "%i '%s' not yet implemented",
            (int)pel->oprNum, OprStr(pel->oprNum));
          break;
    }
    if (i < 0) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "Bad run-time address", "%i", i);
    }
    if (pel->DoPush) 
      if (!PushVal (pfx, pfxrt, regA, i)) break;
  }

  if (pfxrt->usedValStack > 0) regA = PopVal (pfx, pfxrt, 9999);

  *result = regA;

  if (NeedRelinq) cs = (ChannelStatistics *)RelinquishMagickMemory (cs);

  if (pfx->exception->severity != UndefinedException) {
    return MagickFalse;
  }

  if (pfxrt->usedValStack != 0) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "ValStack not empty", "(%i)", pfxrt->usedValStack);
    return MagickFalse;
  }

  return MagickTrue;
}

// the below code fragment can be found in:
// MagickCore/fx.c
static MagickBooleanType GetOperand (
  FxInfo * pfx, MagickBooleanType * UserSymbol, MagickBooleanType * NewUserSymbol, int * UserSymNdx,
  MagickBooleanType * needPopAll)
{

  *NewUserSymbol = *UserSymbol = MagickFalse;
  *UserSymNdx = NULL_ADDRESS;

  SkipSpaces (pfx);
  if (!*pfx->pex) return MagickFalse;
  (void) GetToken (pfx);

  if (pfx->lenToken==0) {

    /* Try '(' or unary prefix
    */
    OperatorE op = GetLeadingOp (pfx);
    if (op==oOpenParen) {
      char chLimit = '\0';
      if (!PushOperatorStack (pfx, op)) return MagickFalse;
      pfx->pex++;
      if (!TranslateExpression (pfx, ")", &chLimit, needPopAll)) {
        (void) ThrowMagickException (
          pfx->exception, GetMagickModule(), OptionError,
          "Empty expression in parentheses at", "'%s'",
          SetShortExp(pfx));
        return MagickFalse;
      }
      if (chLimit != ')') {
        (void) ThrowMagickException (
          pfx->exception, GetMagickModule(), OptionError,
          "'(' but no ')' at", "'%s'",
          SetShortExp(pfx));
        return MagickFalse;
      }
      /* Top of opr stack should be '('. */
      if (!PopOprOpenParen (pfx, oOpenParen)) {
        (void) ThrowMagickException (
          pfx->exception, GetMagickModule(), OptionError,
          "Bug: tos not '(' at", "'%s'",
          SetShortExp(pfx));
        return MagickFalse;
      }
      return MagickTrue;
    } else if (OprIsUnaryPrefix (op)) {
      if (!PushOperatorStack (pfx, op)) return MagickFalse;
      pfx->pex++;
      SkipSpaces (pfx);
      if (!*pfx->pex) return MagickFalse;

      if (!GetOperand (pfx, UserSymbol, NewUserSymbol, UserSymNdx, needPopAll)) {
        (void) ThrowMagickException (
          pfx->exception, GetMagickModule(), OptionError,
          "After unary, bad operand at", "'%s'",
          SetShortExp(pfx));
        return MagickFalse;
      }

      if (*NewUserSymbol) {
        (void) ThrowMagickException (
          pfx->exception, GetMagickModule(), OptionError,
          "After unary, NewUserSymbol at", "'%s'",
          SetShortExp(pfx));
        return MagickFalse;
      }

      if (*UserSymbol) {
        (void) AddAddressingElement (pfx, rCopyFrom, *UserSymNdx);
        *UserSymNdx = NULL_ADDRESS;

        *UserSymbol = MagickFalse;
        *NewUserSymbol = MagickFalse;
      }

      (void) GetToken (pfx);
      return MagickTrue;
    } else if (*pfx->pex == '#') {
      fxFltType v0=0, v1=0, v2=0;
      ssize_t lenToken = GetHexColour (pfx, &v0, &v1, &v2);
      if (lenToken < 0) {
        (void) ThrowMagickException (
          pfx->exception, GetMagickModule(), OptionError,
          "Bad hex number at", "'%s'",
          SetShortExp(pfx));
        return MagickFalse;
      } else if (lenToken > 0) {
        (void) AddColourElement (pfx, v0, v1, v2);
        pfx->pex+=lenToken;
      }
      return MagickTrue;
    }

    /* Try a constant number.
    */
    {
      char * tailptr;
      ssize_t lenOptArt;
      fxFltType val = strtold (pfx->pex, &tailptr);
      if (pfx->pex != tailptr) {
        pfx->pex = tailptr;
        if (*tailptr) {
          /* Could have "prefix" K, Ki, M etc.
             See https://en.wikipedia.org/wiki/Metric_prefix
             and https://en.wikipedia.org/wiki/Binary_prefix
          */
          double Pow = 0.0;
          const char Prefices[] = "yzafpnum.kMGTPEZY";
          const char * pSi = strchr (Prefices, *tailptr);
          if (pSi && *pSi != '.') Pow = (pSi - Prefices) * 3 - 24;
          else if (*tailptr == 'c') Pow = -2;
          else if (*tailptr == 'h') Pow =  2;
          else if (*tailptr == 'k') Pow =  3;
          if (Pow != 0.0) {
            if (*(++pfx->pex) == 'i') {
              val *= pow (2.0, Pow/0.3);
              pfx->pex++;
            } else {
              val *= pow (10.0, Pow);
            }
          }
        }
        (void) AddElement (pfx, val, oNull);
        return MagickTrue;
      }

      val = (fxFltType) 0;
      lenOptArt = GetProperty (pfx, &val);
      if (lenOptArt < 0) return MagickFalse;
      if (lenOptArt > 0) {
        (void) AddElement (pfx, val, oNull);
        pfx->pex += lenOptArt;
        return MagickTrue;
      }
    }

  } /* end of lenToken==0 */

  if (pfx->lenToken > 0) {
    /* Try a constant
    */
    {
      ConstantE ce;
      for (ce = (ConstantE)0; ce < cNull; ce=(ConstantE) (ce+1)) {
        const char * ceStr = Constants[ce].str;
        if (LocaleCompare (ceStr, pfx->token)==0) {
          break;
        }
      }

      if (ce != cNull) {
        (void) AddElement (pfx, Constants[ce].val, oNull);
        pfx->pex += pfx->lenToken;
        return MagickTrue;
      }
    }

    /* Try a function
    */
    {
      FunctionE fe;
      for (fe = FirstFunc; fe < fNull; fe=(FunctionE) (fe+1)) {
        const char * feStr = Functions[fe-FirstFunc].str;
        if (LocaleCompare (feStr, pfx->token)==0) {
          break;
        }
      }

      if (fe == fV && pfx->ImgListLen < 2) {
        (void) ThrowMagickException (
          pfx->exception, GetMagickModule(), OptionError,
          "Symbol 'v' but fewer than two images at", "'%s'",
          SetShortExp(pfx));
        return MagickFalse;
      }

      if (IsStealth (fe)) {
        (void) ThrowMagickException (
          pfx->exception, GetMagickModule(), OptionError,
          "Function", "'%s' not permitted at '%s'",
          pfx->token, SetShortExp(pfx));
      }

      if (fe == fDo || fe == fFor || fe == fIf || fe == fWhile) {
        *needPopAll = MagickTrue;
      }

      if (fe != fNull) return (GetFunction (pfx, fe));
    }

    /* Try image attribute
    */
    {
      ImgAttrE ia = GetImgAttrToken (pfx);
      if (ia != aNull) {
        fxFltType val = 0;
        (void) AddElement (pfx, val, ia);

        if (ImgAttrs[ia-FirstImgAttr].NeedStats==1) {
          if (IsQualifier (pfx)) {
            PixelChannel chQual = GetChannelQualifier (pfx, ia);
            ElementT * pel;
            if (chQual == NO_CHAN_QUAL) {
              (void) ThrowMagickException (
                pfx->exception, GetMagickModule(), OptionError,
                "Bad channel qualifier at", "'%s'",
                SetShortExp(pfx));
              return MagickFalse;
            }
            /* Adjust the element */
            pel = &pfx->Elements[pfx->usedElements-1];
            pel->ChannelQual = chQual;
          }
        }
        return MagickTrue;
      }
    }

    /* Try symbol
    */
    {
      SymbolE se;
      for (se = FirstSym; se < sNull; se=(SymbolE) (se+1)) {
        const char * seStr = Symbols[se-FirstSym].str;
        if (LocaleCompare (seStr, pfx->token)==0) {
          break;
        }
      }
      if (se != sNull) {
        fxFltType val = 0;
        (void) AddElement (pfx, val, se);
        pfx->pex += pfx->lenToken;

        if (se==sHue || se==sSaturation || se==sLightness) pfx->NeedHsl = MagickTrue;
        return MagickTrue;
      }
    }

    /* Try constant colour.
    */
    {
      fxFltType v0, v1, v2;
      ssize_t ColLen = GetConstantColour (pfx, &v0, &v1, &v2);
      if (ColLen < 0) return MagickFalse;
      if (ColLen > 0) {
        (void) AddColourElement (pfx, v0, v1, v2);
        pfx->pex+=ColLen;
        return MagickTrue;
      }
    }

    /* Try image artifact.
    */
    {
      const char *artifact;
      artifact = GetImageArtifact (pfx->image, pfx->token);
      if (artifact != (const char *) NULL) {
        char * tailptr;
        fxFltType val = strtold (artifact, &tailptr);
        if (pfx->token == tailptr) {
          (void) ThrowMagickException (
            pfx->exception, GetMagickModule(), OptionError,
            "Artifact", "'%s' has value '%s', not a number, at '%s'",
            pfx->token, artifact, SetShortExp(pfx));
          return MagickFalse;
        }
        (void) AddElement (pfx, val, oNull);
        pfx->pex+=pfx->lenToken;
        return MagickTrue;
      }
    }

    /* Try user symbols. If it is, don't AddElement yet.
    */
    if (TokenMaybeUserSymbol (pfx)) {
      *UserSymbol = MagickTrue;
      *UserSymNdx = FindUserSymbol (pfx, pfx->token);
      if (*UserSymNdx == NULL_ADDRESS) {
        *UserSymNdx = AddUserSymbol (pfx, pfx->pex, pfx->lenToken);
        *NewUserSymbol = MagickTrue;
      } else {
      }
      pfx->pex += pfx->lenToken;

      return MagickTrue;
    }
  }

  (void) ThrowMagickException (
    pfx->exception, GetMagickModule(), OptionError,
    "Expected operand at", "'%s'",
    SetShortExp(pfx));

  return MagickFalse;
}

// the below code fragment can be found in:
// MagickCore/fx.c
static MagickBooleanType TranslateExpression (
  FxInfo * pfx, const char * strLimit, char * chLimit, MagickBooleanType * needPopAll)
{
  /* There should be only one New per expression (oAssign), but can be many Old.
  */
  MagickBooleanType UserSymbol, NewUserSymbol;
  int UserSymNdx0, UserSymNdx1;

  MagickBooleanType
    Assign = MagickFalse,
    Update = MagickFalse,
    IncrDecr = MagickFalse;

  int StartEleNdx;

  TernaryT ternary;
  ternary.addrQuery = NULL_ADDRESS;
  ternary.addrColon = NULL_ADDRESS;

  pfx->teDepth++;

  *chLimit = '\0';

  StartEleNdx = pfx->usedElements-1;
  if (StartEleNdx < 0) StartEleNdx = 0;

  SkipSpaces (pfx);

  if (!*pfx->pex) {
    pfx->teDepth--;
    return MagickFalse;
  }

  if (strchr(strLimit,*pfx->pex)!=NULL) {
    *chLimit = *pfx->pex;
    pfx->pex++;
    pfx->teDepth--;

    return MagickFalse;
  }

  if (!GetOperand (pfx, &UserSymbol, &NewUserSymbol, &UserSymNdx0, needPopAll)) return MagickFalse;
  SkipSpaces (pfx);

  /* Loop through Operator, Operand, Operator, Operand, ...
  */
  while (*pfx->pex && (!*strLimit || (strchr(strLimit,*pfx->pex)==NULL))) {
    if (!GetOperator (pfx, &Assign, &Update, &IncrDecr)) return MagickFalse;
    SkipSpaces (pfx);
    if (NewUserSymbol && !Assign) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "Expected assignment after new UserSymbol", "'%s' at '%s'",
        pfx->token, SetShortExp(pfx));
      return MagickFalse;
    }
    if (!UserSymbol && Assign) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "Attempted assignment to non-UserSymbol", "'%s' at '%s'",
        pfx->token, SetShortExp(pfx));
      return MagickFalse;
    }
    if (!UserSymbol && Update) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "Attempted update to non-UserSymbol", "'%s' at '%s'",
        pfx->token, SetShortExp(pfx));
      return MagickFalse;
    }
    if (UserSymbol && (Assign || Update) && !IncrDecr) {

      if (!TranslateExpression (pfx, strLimit, chLimit, needPopAll)) return MagickFalse;
      if (!*pfx->pex) break;
      if (!*strLimit) break;
      if (strchr(strLimit,*chLimit)!=NULL) break;
    }
    if (UserSymbol && !Assign && !Update && UserSymNdx0 != NULL_ADDRESS) {
      ElementT * pel;
      (void) AddAddressingElement (pfx, rCopyFrom, UserSymNdx0);
      UserSymNdx0 = NULL_ADDRESS;
      pel = &pfx->Elements[pfx->usedElements-1];
      pel->DoPush = MagickTrue;
    }

    if (UserSymbol) {
      while (TopOprIsUnaryPrefix (pfx)) {
        OperatorE op = pfx->OperatorStack[pfx->usedOprStack-1];
        (void) AddElement (pfx, (fxFltType) 0, op);
        pfx->usedOprStack--;
      }
    }

    if (!ProcessTernaryOpr (pfx, &ternary)) return MagickFalse;

    if (ternary.addrColon != NULL_ADDRESS) {
      if (!TranslateExpression (pfx, ",);", chLimit, needPopAll)) return MagickFalse;
      break;
    }

    UserSymbol = NewUserSymbol = MagickFalse;

    if ( (!*pfx->pex) || (*strLimit && (strchr(strLimit,*pfx->pex)!=NULL) ) )
    {
      if (IncrDecr) break;

      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "Expected operand after operator", "at '%s'",
        SetShortExp(pfx));
      return MagickFalse;
    }

    if (IncrDecr) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "'++' and '--' must be the final operators in an expression at", "'%s'",
        SetShortExp(pfx));
      return MagickFalse;
    }

    if (!GetOperand (pfx, &UserSymbol, &NewUserSymbol, &UserSymNdx1, needPopAll)) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "Expected operand at", "'%s'",
        SetShortExp(pfx));
      return MagickFalse;
    }
    SkipSpaces (pfx);
    if (NewUserSymbol && !Assign) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "NewUserSymbol", "'%s' after non-assignment operator at '%s'",
        pfx->token, SetShortExp(pfx));
      return MagickFalse;
    }
    if (UserSymbol && !NewUserSymbol) {
      (void) AddAddressingElement (pfx, rCopyFrom, UserSymNdx1);
      UserSymNdx1 = NULL_ADDRESS;
    }
    UserSymNdx0 = UserSymNdx1;
  }

  if (UserSymbol && !Assign && !Update && UserSymNdx0 != NULL_ADDRESS) {
    ElementT * pel;
    if (NewUserSymbol) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "NewUserSymbol", "'%s' needs assignment operator at '%s'",
        pfx->token, SetShortExp(pfx));
      return MagickFalse;
    }
    (void) AddAddressingElement (pfx, rCopyFrom, UserSymNdx0);
    pel = &pfx->Elements[pfx->usedElements-1];
    pel->DoPush = MagickTrue;
  }

  if (*pfx->pex && !*chLimit && (strchr(strLimit,*pfx->pex)!=NULL)) {
    *chLimit = *pfx->pex;
    pfx->pex++;
  }
  while (pfx->usedOprStack) {
    OperatorE op = pfx->OperatorStack[pfx->usedOprStack-1];
    if (op == oOpenParen || op == oOpenBracket || op == oOpenBrace) {
      break;
    }
    if ( (op==oAssign && !Assign) || (OprInPlace(op) && !Update) ) {
      break;
    }
    pfx->usedOprStack--;
    (void) AddElement (pfx, (fxFltType) 0, op);
    if (op == oAssign) {
      if (UserSymNdx0 < 0) {
        (void) ThrowMagickException (
          pfx->exception, GetMagickModule(), OptionError,
          "Assignment to unknown user symbol at", "'%s'",
          SetShortExp(pfx));
        return MagickFalse;
      }
      /* Adjust last element, by deletion and add.
      */
      pfx->usedElements--;
      (void) AddAddressingElement (pfx, rCopyTo, UserSymNdx0);
      break;
    } else if (OprInPlace (op)) {
      if (UserSymNdx0 < 0) {
        (void) ThrowMagickException (
          pfx->exception, GetMagickModule(), OptionError,
          "Operator-in-place to unknown user symbol at", "'%s'",
          SetShortExp(pfx));
        return MagickFalse;
      }
      /* Modify latest element.
      */
      pfx->Elements[pfx->usedElements-1].EleNdx = UserSymNdx0;
      break;
    }
  }

  (void) ResolveTernaryAddresses (pfx, &ternary);

  pfx->teDepth--;

  if (!pfx->teDepth && *needPopAll) {
    (void) AddAddressingElement (pfx, rZerStk, NULL_ADDRESS);
    *needPopAll = MagickFalse;
  }

  if (pfx->exception->severity != UndefinedException)
    return MagickFalse;

  return MagickTrue;
}

// the below code fragment can be found in:
// MagickCore/fx.c
static MagickBooleanType DumpRPN (FxInfo * pfx, FILE * fh)
{
  int i;

  fprintf (fh, "DumpRPN:");
  fprintf (fh, "  numElements=%i", pfx->numElements);
  fprintf (fh, "  usedElements=%i", pfx->usedElements);
  fprintf (fh, "  maxUsedOprStack=%i", pfx->maxUsedOprStack);
  fprintf (fh, "  ImgListLen=%g", (double) pfx->ImgListLen);
  fprintf (fh, "  NeedStats=%s", pfx->NeedStats ? "yes" : "no");
  fprintf (fh, "  GotStats=%s", pfx->GotStats ? "yes" : "no");
  fprintf (fh, "  NeedHsl=%s\n", pfx->NeedHsl ? "yes" : "no");
  if      (pfx->runType==rtEntireImage) fprintf (stderr, "EntireImage");
  else if (pfx->runType==rtCornerOnly)  fprintf (stderr, "CornerOnly");
  fprintf (fh, "\n");


  for (i=0; i < pfx->usedElements; i++) {
    ElementT * pel = &pfx->Elements[i];
    pel->nDest = 0;
  }
  for (i=0; i < pfx->usedElements; i++) {
    ElementT * pel = &pfx->Elements[i];
    if (pel->oprNum == rGoto || pel->oprNum == rIfZeroGoto || pel->oprNum == rIfNotZeroGoto) {
      if (pel->EleNdx >= 0 && pel->EleNdx < pfx->numElements) {
        ElementT * pelDest = &pfx->Elements[pel->EleNdx];
        pelDest->nDest++;
      }
    }
  }
  for (i=0; i < pfx->usedElements; i++) {
    char UserSym[MagickPathExtent];

    ElementT * pel = &pfx->Elements[i];
    const char * str = OprStr (pel->oprNum);
    const char *sRelAbs = "";

    if (pel->oprNum == fP || pel->oprNum == fUP || pel->oprNum == fVP || pel->oprNum == fSP)
      sRelAbs = pel->IsRelative ? "[]" : "{}";

    if (pel->type == etColourConstant)
      fprintf (fh, "  %i: %s vals=%.*Lg,%.*Lg,%.*Lg '%s%s' nArgs=%i ndx=%i  %s",
               i, sElementTypes[pel->type],
               pfx->precision, pel->val, pfx->precision, pel->val1, pfx->precision, pel->val2,
               str, sRelAbs, pel->nArgs, pel->EleNdx,
               pel->DoPush ? "push" : "NO push");
    else
      fprintf (fh, "  %i: %s val=%.*Lg '%s%s' nArgs=%i ndx=%i  %s",
               i, sElementTypes[pel->type], pfx->precision, pel->val, str, sRelAbs,
               pel->nArgs, pel->EleNdx,
               pel->DoPush ? "push" : "NO push");

    if (pel->ImgAttrQual != aNull)
      fprintf (fh, " ia=%s", OprStr(pel->ImgAttrQual));

    if (pel->ChannelQual != NO_CHAN_QUAL) {
      if (pel->ChannelQual == THIS_CHANNEL) fprintf (stderr, "  ch=this");
      else fprintf (stderr, "  ch=%i", pel->ChannelQual);
    }

    if (pel->oprNum == rCopyTo) {
      fprintf (fh, "  CopyTo ==> %s", NameOfUserSym (pfx, pel->EleNdx, UserSym));
    } else if (pel->oprNum == rCopyFrom) {
      fprintf (fh, "  CopyFrom <== %s", NameOfUserSym (pfx, pel->EleNdx, UserSym));
    } else if (OprInPlace (pel->oprNum)) {
      fprintf (fh, "  <==> %s", NameOfUserSym (pfx, pel->EleNdx, UserSym));
    }
    if (pel->nDest > 0)  fprintf (fh, "  <==dest(%i)", pel->nDest);
    fprintf (fh, "\n");
  }
  return MagickTrue;
}

// the below code fragment can be found in:
// MagickWand/identify.c
WandExport MagickBooleanType IdentifyImageCommand(ImageInfo *image_info,
  int argc,char **argv,char **metadata,ExceptionInfo *exception)
{
#define DestroyIdentify() \
{ \
  DestroyImageStack(); \
  for (i=0; i < (ssize_t) argc; i++) \
    argv[i]=DestroyString(argv[i]); \
  argv=(char **) RelinquishMagickMemory(argv); \
}
#define ThrowIdentifyException(asperity,tag,option) \
{ \
  (void) ThrowMagickException(exception,GetMagickModule(),asperity,tag,"`%s'", \
    option); \
  DestroyIdentify(); \
  return(MagickFalse); \
}
#define ThrowIdentifyInvalidArgumentException(option,argument) \
{ \
  (void) ThrowMagickException(exception,GetMagickModule(),OptionError, \
    "InvalidArgument","'%s': %s",option,argument); \
  DestroyIdentify(); \
  return(MagickFalse); \
}

  const char
    *format,
    *option;

  Image
    *image;

  ImageStack
    image_stack[MaxImageStackDepth+1];

  MagickBooleanType
    fire,
    pend,
    respect_parenthesis;

  MagickStatusType
    status;

  ssize_t
    i;

  size_t
    count;

  ssize_t
    j,
    k;

  /*
    Set defaults.
  */
  assert(image_info != (ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),"...");
  assert(exception != (ExceptionInfo *) NULL);
  if (argc == 2)
    {
      option=argv[1];
      if ((LocaleCompare("version",option+1) == 0) ||
          (LocaleCompare("-version",option+1) == 0))
        {
          ListMagickVersion(stdout);
          return(MagickTrue);
        }
    }
  if (argc < 2)
    return(IdentifyUsage());
  count=0;
  format=NULL;
  j=1;
  k=0;
  NewImageStack();
  option=(char *) NULL;
  pend=MagickFalse;
  respect_parenthesis=MagickFalse;
  status=MagickTrue;
  /*
    Identify an image.
  */
  ReadCommandlLine(argc,&argv);
  status=ExpandFilenames(&argc,&argv);
  if (status == MagickFalse)
    ThrowIdentifyException(ResourceLimitError,"MemoryAllocationFailed",
      GetExceptionMessage(errno));
  image_info->ping=MagickTrue;
  for (i=1; i < (ssize_t) argc; i++)
  {
    option=argv[i];
    if (LocaleCompare(option,"(") == 0)
      {
        FireImageStack(MagickFalse,MagickTrue,pend);
        if (k == MaxImageStackDepth)
          ThrowIdentifyException(OptionError,"ParenthesisNestedTooDeeply",
            option);
        PushImageStack();
        continue;
      }
    if (LocaleCompare(option,")") == 0)
      {
        FireImageStack(MagickFalse,MagickTrue,MagickTrue);
        if (k == 0)
          ThrowIdentifyException(OptionError,"UnableToParseExpression",option);
        PopImageStack();
        continue;
      }
    if (IsCommandOption(option) == MagickFalse)
      {
        char
          *filename;

        Image
          *images;

        ImageInfo
          *identify_info;

        /*
          Read input image.
        */
        FireImageStack(MagickFalse,MagickFalse,pend);
        identify_info=CloneImageInfo(image_info);
        identify_info->verbose=MagickFalse;
        filename=argv[i];
        if ((LocaleCompare(filename,"--") == 0) && (i < (ssize_t) (argc-1)))
          filename=argv[++i];
        if (identify_info->ping != MagickFalse)
          images=PingImages(identify_info,filename,exception);
        else
          images=ReadImages(identify_info,filename,exception);
        identify_info=DestroyImageInfo(identify_info);
        status&=(images != (Image *) NULL) &&
          (exception->severity < ErrorException);
        if (images == (Image *) NULL)
          continue;
        AppendImageStack(images);
        FinalizeImageSettings(image_info,image,MagickFalse);
        count=0;
        for ( ; image != (Image *) NULL; image=GetNextImageInList(image))
        {
          if (image->scene == 0)
            image->scene=count++;
          if (format == (char *) NULL)
            {
              (void) IdentifyImage(image,stdout,image_info->verbose,exception);
              continue;
            }
          if (metadata != (char **) NULL)
            {
              char
                *text;

              text=InterpretImageProperties(image_info,image,format,exception);
              if (text == (char *) NULL)
                ThrowIdentifyException(ResourceLimitError,
                  "MemoryAllocationFailed",GetExceptionMessage(errno));
              (void) ConcatenateString(&(*metadata),text);
              text=DestroyString(text);
            }
        }
        RemoveAllImageStack();
        continue;
      }
    pend=image != (Image *) NULL ? MagickTrue : MagickFalse;
    image_info->ping=MagickFalse;
    switch (*(option+1))
    {
      case 'a':
      {
        if (LocaleCompare("alpha",option+1) == 0)
          {
            ssize_t
              type;

            if (*option == '+')
              break;
            i++;
            if (i == (ssize_t) argc)
              ThrowIdentifyException(OptionError,"MissingArgument",option);
            type=ParseCommandOption(MagickAlphaChannelOptions,MagickFalse,
              argv[i]);
            if (type < 0)
              ThrowIdentifyException(OptionError,
                "UnrecognizedAlphaChannelOption",argv[i]);
            break;
          }
        if (LocaleCompare("antialias",option+1) == 0)
          break;
        if (LocaleCompare("authenticate",option+1) == 0)
          {
            if (*option == '+')
              break;
            i++;
            if (i == (ssize_t) argc)
              ThrowIdentifyException(OptionError,"MissingArgument",option);
            break;
          }
        if (LocaleCompare("auto-orient",option+1) == 0)
          break;
        ThrowIdentifyException(OptionError,"UnrecognizedOption",option)
      }
      case 'c':
      {
        if (LocaleCompare("cache",option+1) == 0)
          {
            if (*option == '+')
              break;
            i++;
            if (i == (ssize_t) argc)
              ThrowIdentifyException(OptionError,"MissingArgument",option);
            if (IsGeometry(argv[i]) == MagickFalse)
              ThrowIdentifyInvalidArgumentException(option,argv[i]);
            break;
          }
        if (LocaleCompare("channel",option+1) == 0)
          {
            ssize_t
              channel;

            if (*option == '+')
              break;
            i++;
            if (i == (ssize_t) argc)
              ThrowIdentifyException(OptionError,"MissingArgument",option);
            channel=ParseChannelOption(argv[i]);
            if (channel < 0)
              ThrowIdentifyException(OptionError,"UnrecognizedChannelType",
                argv[i]);
            break;
          }
        if (LocaleCompare("clip",option+1) == 0)
          break;
        if (LocaleCompare("clip-mask",option+1) == 0)
          {
            if (*option == '+')
              break;
            i++;
            if (i == (ssize_t) argc)
              ThrowIdentifyException(OptionError,"MissingArgument",option);
            break;
          }
        if (LocaleCompare("clip-path",option+1) == 0)
          {
            i++;
            if (i == (ssize_t) argc)
              ThrowIdentifyException(OptionError,"MissingArgument",option);
            break;
          }
        if (LocaleCompare("colorspace",option+1) == 0)
          {
            ssize_t
              colorspace;

            if (*option == '+')
              break;
            i++;
            if (i == (ssize_t) argc)
              ThrowIdentifyException(OptionError,"MissingArgument",option);
            colorspace=ParseCommandOption(MagickColorspaceOptions,
              MagickFalse,argv[i]);
            if (colorspace < 0)
              ThrowIdentifyException(OptionError,"UnrecognizedColorspace",
                argv[i]);
            break;
          }
        if (LocaleCompare("crop",option+1) == 0)
          {
            if (*option == '+')
              break;
            i++;
            if (i == (ssize_t) argc)
              ThrowIdentifyException(OptionError,"MissingArgument",option);
            if (IsGeometry(argv[i]) == MagickFalse)
              ThrowIdentifyInvalidArgumentException(option,argv[i]);
            break;
          }
        if (LocaleCompare("concurrent",option+1) == 0)
          break;
        ThrowIdentifyException(OptionError,"UnrecognizedOption",option)
      }
      case 'd':
      {
        if (LocaleCompare("debug",option+1) == 0)
          {
            ssize_t
              event;

            if (*option == '+')
              break;
            i++;
            if (i == (ssize_t) argc)
              ThrowIdentifyException(OptionError,"MissingArgument",option);
            event=ParseCommandOption(MagickLogEventOptions,MagickFalse,argv[i]);
            if (event < 0)
              ThrowIdentifyException(OptionError,"UnrecognizedEventType",
                argv[i]);
            (void) SetLogEventMask(argv[i]);
            break;
          }
        if (LocaleCompare("define",option+1) == 0)
          {
            i++;
            if (i == (ssize_t) argc)
              ThrowIdentifyException(OptionError,"MissingArgument",option);
            if (*option == '+')
              {
                const char
                  *define;

                define=GetImageOption(image_info,argv[i]);
                if (define == (const char *) NULL)
                  ThrowIdentifyException(OptionError,"NoSuchOption",argv[i]);
                break;
              }
            break;
          }
        if (LocaleCompare("density",option+1) == 0)
          {
            if (*option == '+')
              break;
            i++;
            if (i == (ssize_t) argc)
              ThrowIdentifyException(OptionError,"MissingArgument",option);
            if (IsGeometry(argv[i]) == MagickFalse)
              ThrowIdentifyInvalidArgumentException(option,argv[i]);
            break;
          }
        if (LocaleCompare("depth",option+1) == 0)
          {
            if (*option == '+')
              break;
            i++;
            if (i == (ssize_t) argc)
              ThrowIdentifyException(OptionError,"MissingArgument",option);
            if (IsGeometry(argv[i]) == MagickFalse)
              ThrowIdentifyInvalidArgumentException(option,argv[i]);
            break;
          }
        if (LocaleCompare("duration",option+1) == 0)
          {
            if (*option == '+')
              break;
            i++;
            if (i == (ssize_t) argc)
              ThrowIdentifyException(OptionError,"MissingArgument",option);
            if (IsGeometry(argv[i]) == MagickFalse)
              ThrowIdentifyInvalidArgumentException(option,argv[i]);
            break;
          }
        ThrowIdentifyException(OptionError,"UnrecognizedOption",option)
      }
      case 'e':
      {
        if (LocaleCompare("endian",option+1) == 0)
          {
            ssize_t
              endian;

            if (*option == '+')
              break;
            i++;
            if (i == (ssize_t) argc)
              ThrowIdentifyException(OptionError,"MissingArgument",option);
            endian=ParseCommandOption(MagickEndianOptions,MagickFalse,
              argv[i]);
            if (endian < 0)
              ThrowIdentifyException(OptionError,"UnrecognizedEndianType",
                argv[i]);
            break;
          }
        ThrowIdentifyException(OptionError,"UnrecognizedOption",option)
      }
      case 'f':
      {
        if (LocaleCompare("features",option+1) == 0)
          {
            if (*option == '+')
              break;
            i++;
            if (i == (ssize_t) argc)
              ThrowIdentifyException(OptionError,"MissingArgument",option);
            if (IsGeometry(argv[i]) == MagickFalse)
              ThrowIdentifyInvalidArgumentException(option,argv[i]);
            break;
          }
        if (LocaleCompare("format",option+1) == 0)
          {
            format=(char *) NULL;
            if (*option == '+')
              break;
            i++;
            if (i == (ssize_t) argc)
              ThrowIdentifyException(OptionError,"MissingArgument",option);
            format=argv[i];
            break;
          }
        if (LocaleCompare("fuzz",option+1) == 0)
          {
            if (*option == '+')
              break;
            i++;
            if (i == (ssize_t) argc)
              ThrowIdentifyException(OptionError,"MissingArgument",option);
            if (IsGeometry(argv[i]) == MagickFalse)
              ThrowIdentifyInvalidArgumentException(option,argv[i]);
            break;
          }
        ThrowIdentifyException(OptionError,"UnrecognizedOption",option)
      }
      case 'g':
      {
        if (LocaleCompare("gamma",option+1) == 0)
          {
            i++;
            if (i == (ssize_t) argc)
              ThrowIdentifyException(OptionError,"MissingArgument",option);
            if (IsGeometry(argv[i]) == MagickFalse)
              ThrowIdentifyInvalidArgumentException(option,argv[i]);
            break;
          }
        if (LocaleCompare("grayscale",option+1) == 0)
          {
            ssize_t
              method;

            if (*option == '+')
              break;
            i++;
            if (i == (ssize_t) argc)
              ThrowIdentifyException(OptionError,"MissingArgument",option);
            method=ParseCommandOption(MagickPixelIntensityOptions,MagickFalse,
              argv[i]);
            if (method < 0)
              ThrowIdentifyException(OptionError,"UnrecognizedIntensityMethod",
                argv[i]);
            break;
          }
        if (LocaleCompare("green-primary",option+1) == 0)
          {
            if (*option == '+')
              break;
            i++;
            if (i == (ssize_t) argc)
              ThrowIdentifyException(OptionError,"MissingArgument",option);
            if (IsGeometry(argv[i]) == MagickFalse)
              ThrowIdentifyInvalidArgumentException(option,argv[i]);
            break;
          }
        ThrowIdentifyException(OptionError,"UnrecognizedOption",option)
      }
      case 'h':
      {
        if ((LocaleCompare("help",option+1) == 0) ||
            (LocaleCompare("-help",option+1) == 0))
          {
            DestroyIdentify();
            return(IdentifyUsage());
          }
        ThrowIdentifyException(OptionError,"UnrecognizedOption",option)
      }
      case 'i':
      {
        if (LocaleCompare("interlace",option+1) == 0)
          {
            ssize_t
              interlace;

            if (*option == '+')
              break;
            i++;
            if (i == (ssize_t) argc)
              ThrowIdentifyException(OptionError,"MissingArgument",option);
            interlace=ParseCommandOption(MagickInterlaceOptions,MagickFalse,
              argv[i]);
            if (interlace < 0)
              ThrowIdentifyException(OptionError,"UnrecognizedInterlaceType",
                argv[i]);
            break;
          }
        if (LocaleCompare("interpolate",option+1) == 0)
          {
            ssize_t
              interpolate;

            if (*option == '+')
              break;
            i++;
            if (i == (ssize_t) argc)
              ThrowIdentifyException(OptionError,"MissingArgument",option);
            interpolate=ParseCommandOption(MagickInterpolateOptions,MagickFalse,
              argv[i]);
            if (interpolate < 0)
              ThrowIdentifyException(OptionError,
                "UnrecognizedInterpolateMethod",argv[i]);
            break;
          }
        ThrowIdentifyException(OptionError,"UnrecognizedOption",option)
      }
      case 'l':
      {
        if (LocaleCompare("limit",option+1) == 0)
          {
            char
              *p;

            double
              value;

            ssize_t
              resource;

            if (*option == '+')
              break;
            i++;
            if (i == (ssize_t) argc)
              ThrowIdentifyException(OptionError,"MissingArgument",option);
            resource=ParseCommandOption(MagickResourceOptions,MagickFalse,
              argv[i]);
            if (resource < 0)
              ThrowIdentifyException(OptionError,"UnrecognizedResourceType",
                argv[i]);
            i++;
            if (i == (ssize_t) argc)
              ThrowIdentifyException(OptionError,"MissingArgument",option);
            value=StringToDouble(argv[i],&p);
            (void) value;
            if ((p == argv[i]) && (LocaleCompare("unlimited",argv[i]) != 0))
              ThrowIdentifyInvalidArgumentException(option,argv[i]);
            break;
          }
        if (LocaleCompare("list",option+1) == 0)
          {
            ssize_t
              list;

            if (*option == '+')
              break;
            i++;
            if (i == (ssize_t) argc)
              ThrowIdentifyException(OptionError,"MissingArgument",option);
            list=ParseCommandOption(MagickListOptions,MagickFalse,argv[i]);
            if (list < 0)
              ThrowIdentifyException(OptionError,"UnrecognizedListType",
                argv[i]);
            status=MogrifyImageInfo(image_info,(int) (i-j+1),(const char **)
              argv+j,exception);
            DestroyIdentify();
            return(status == 0 ? MagickFalse : MagickTrue);
          }
        if (LocaleCompare("log",option+1) == 0)
          {
            if (*option == '+')
              break;
            i++;
            if ((i == (ssize_t) argc) ||
                (strchr(argv[i],'%') == (char *) NULL))
              ThrowIdentifyException(OptionError,"MissingArgument",option);
            break;
          }
        ThrowIdentifyException(OptionError,"UnrecognizedOption",option)
      }
      case 'm':
      {
        if (LocaleCompare("mask",option+1) == 0)
          {
            if (*option == '+')
              break;
            i++;
            if (i == (ssize_t) argc)
              ThrowIdentifyException(OptionError,"MissingArgument",option);
            break;
          }
        if (LocaleCompare("matte",option+1) == 0)
          break;
        if (LocaleCompare("moments",option+1) == 0)
          break;
        if (LocaleCompare("monitor",option+1) == 0)
          break;
        ThrowIdentifyException(OptionError,"UnrecognizedOption",option)
      }
      case 'n':
      {
        if (LocaleCompare("negate",option+1) == 0)
          break;
        ThrowIdentifyException(OptionError,"UnrecognizedOption",option)
      }
      case 'p':
      {
        if (LocaleCompare("ping",option+1) == 0)
          {
            image_info->ping=MagickTrue;
            break;
          }
        if (LocaleCompare("precision",option+1) == 0)
          {
            if (*option == '+')
              break;
            i++;
            if (i == (ssize_t) argc)
              ThrowIdentifyException(OptionError,"MissingArgument",option);
            if (IsGeometry(argv[i]) == MagickFalse)
              ThrowIdentifyInvalidArgumentException(option,argv[i]);
            break;
          }
        ThrowIdentifyException(OptionError,"UnrecognizedOption",option)
      }
      case 'q':
      {
        if (LocaleCompare("quiet",option+1) == 0)
          break;
        ThrowIdentifyException(OptionError,"UnrecognizedOption",option)
      }
      case 'r':
      {
        if (LocaleCompare("regard-warnings",option+1) == 0)
          break;
        if (LocaleNCompare("respect-parentheses",option+1,17) == 0)
          {
            respect_parenthesis=(*option == '-') ? MagickTrue : MagickFalse;
            break;
          }
        ThrowIdentifyException(OptionError,"UnrecognizedOption",option)
      }
      case 's':
      {
        if (LocaleCompare("sampling-factor",option+1) == 0)
          {
            if (*option == '+')
              break;
            i++;
            if (i == (ssize_t) argc)
              ThrowIdentifyException(OptionError,"MissingArgument",option);
            if (IsGeometry(argv[i]) == MagickFalse)
              ThrowIdentifyInvalidArgumentException(option,argv[i]);
            break;
          }
        if (LocaleCompare("seed",option+1) == 0)
          {
            if (*option == '+')
              break;
            i++;
            if (i == (ssize_t) argc)
              ThrowIdentifyException(OptionError,"MissingArgument",option);
            if (IsGeometry(argv[i]) == MagickFalse)
              ThrowIdentifyInvalidArgumentException(option,argv[i]);
            break;
          }
        if (LocaleCompare("set",option+1) == 0)
          {
            i++;
            if (i == (ssize_t) argc)
              ThrowIdentifyException(OptionError,"MissingArgument",option);
            if (*option == '+')
              break;
            i++;
            if (i == (ssize_t) argc)
              ThrowIdentifyException(OptionError,"MissingArgument",option);
            break;
          }
        if (LocaleCompare("size",option+1) == 0)
          {
            if (*option == '+')
              break;
            i++;
            if (i == (ssize_t) argc)
              ThrowIdentifyException(OptionError,"MissingArgument",option);
            if (IsGeometry(argv[i]) == MagickFalse)
              ThrowIdentifyInvalidArgumentException(option,argv[i]);
            break;
          }
        if (LocaleCompare("strip",option+1) == 0)
          break;
        if (LocaleCompare("support",option+1) == 0)
          {
            if (*option == '+')
              break;
            i++;
            if (i == (ssize_t) argc)
              ThrowIdentifyException(OptionError,"MissingArgument",option);
            if (IsGeometry(argv[i]) == MagickFalse)
              ThrowIdentifyInvalidArgumentException(option,argv[i]);
            break;
          }
        ThrowIdentifyException(OptionError,"UnrecognizedOption",option)
      }
      case 'u':
      {
        if (LocaleCompare("unique",option+1) == 0)
          break;
        if (LocaleCompare("units",option+1) == 0)
          {
            ssize_t
              units;

            if (*option == '+')
              break;
            i++;
            if (i == (ssize_t) argc)
              ThrowIdentifyException(OptionError,"MissingArgument",option);
            units=ParseCommandOption(MagickResolutionOptions,MagickFalse,
              argv[i]);
            if (units < 0)
              ThrowIdentifyException(OptionError,"UnrecognizedUnitsType",
                argv[i]);
            break;
          }
        ThrowIdentifyException(OptionError,"UnrecognizedOption",option)
      }
      case 'v':
      {
        if (LocaleCompare("verbose",option+1) == 0)
          break;
        if (LocaleCompare("virtual-pixel",option+1) == 0)
          {
            ssize_t
              method;

            if (*option == '+')
              break;
            i++;
            if (i == (ssize_t) argc)
              ThrowIdentifyException(OptionError,"MissingArgument",option);
            method=ParseCommandOption(MagickVirtualPixelOptions,MagickFalse,
              argv[i]);
            if (method < 0)
              ThrowIdentifyException(OptionError,
                "UnrecognizedVirtualPixelMethod",argv[i]);
            break;
          }
        ThrowIdentifyException(OptionError,"UnrecognizedOption",option)
      }
      case '?':
        break;
      default:
        ThrowIdentifyException(OptionError,"UnrecognizedOption",option)
    }
    fire=(GetCommandOptionFlags(MagickCommandOptions,MagickFalse,option) &
      FireOptionFlag) == 0 ?  MagickFalse : MagickTrue;
    if (fire != MagickFalse)
      FireImageStack(MagickFalse,MagickTrue,MagickTrue);
  }
  if (k != 0)
    ThrowIdentifyException(OptionError,"UnbalancedParenthesis",argv[i]);
  if (i != (ssize_t) argc)
    ThrowIdentifyException(OptionError,"MissingAnImageFilename",argv[i]);
  DestroyIdentify();
  return(status != 0 ? MagickTrue : MagickFalse);
}
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).