{
    unsigned short* out = dest;
    while (*src) {
        // Find the next comma or the end of the string
        const char* comma = strchr(src, ',');
        int number;
        if (comma) {
            std::string piece(src, comma - src);
            number = atoi(piece.c_str());
            src = comma + 1;
        } else {
            number = atoi(src);
            src += strlen(src);
        }

        if (number >= DEFAULTFLAGS) {
            HUNSPELL_WARNING(stderr, "error: line %d: flag id %d is too large (max: %d)\n",
                             af->getlinenum(), number, DEFAULTFLAGS - 1);
            number = 0;
        }

        if (number == 0) {
            HUNSPELL_WARNING(stderr, "error: line %d: 0 is wrong flag id\n",
                             af->getlinenum());
        }

        *out++ = (unsigned short)number;
        if (!comma) {
            // No more commas, we're done
            break;
        }
    }
}