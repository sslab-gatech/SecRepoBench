// Parse the 'flags' string, interpreting it as a series of decimal numbers
// separated by commas. Convert each number to an unsigned short and store it
// in the 'result' array. Check if each number is within the allowable range,
// and issue warnings if any numbers are too large or zero. Update the 'src'
// pointer to track the start of the next number after each comma.
std::string num;
while (*src) {
  if (*src == ',') {
    ++src;
    continue;
  }
  num.clear();
  while (*src && *src != ',') {
    if (!isdigit(*src)) {
      HUNSPELL_WARNING(stderr, "error: line %d: invalid character in flag\n", af->getlinenum());
      return -1; // Indicate error condition
    }
    num += *src++;
  }
  if (!num.empty()) {
    int value = atoi(num.c_str());
    if (value >= DEFAULTFLAGS && af != NULL) {
      HUNSPELL_WARNING(stderr,
                       "error: line %d: flag id %d is too large (max: %d)\n",
                       af->getlinenum(), value, DEFAULTFLAGS - 1);
      value = 0;
    }
    if (value == 0 && af != NULL) {
      HUNSPELL_WARNING(stderr, "error: line %d: flag id is zero\n", af->getlinenum());
    }
    *dest++ = static_cast<unsigned short>(value);
  }
}