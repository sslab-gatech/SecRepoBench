// Parse the 'flags' string, interpreting it as a series of decimal numbers
    // separated by commas. Convert each number to an unsigned short and store it
    // in the 'result' array. Check if each number is within the allowable range,
    // and issue warnings if any numbers are too large or zero. Update the 'src'
    // pointer to track the start of the next number after each comma.
    const char* src = flags.c_str();
    while (*src) {
      // Skip leading commas
      while (*src == ',') {
        src++;
      }

      // Parse the next number
      char* endptr;
      unsigned long num = strtoul(src, &endptr, 10);
      if (src == endptr) {
        HUNSPELL_WARNING(stderr, "error: line %d: bad flagvector\n", af->getlinenum());
        delete[] *result;
        *result = NULL;
        return -1;
      }

      // Check if the number is within the allowable range
      if (num > USHRT_MAX) {
        HUNSPELL_WARNING(stderr, "error: line %d: flag id %lu is too large (max: %d)\n",
                         af->getlinenum(), num, USHRT_MAX);
        num = 0;
      } else if (num == 0) {
        HUNSPELL_WARNING(stderr, "error: line %d: flag id 0 is not allowed\n", af->getlinenum());
        num = 0;
      }

      // Store the number in the result array
      if (dest - *result < len) {
        *dest = (unsigned short)num;
        dest++;
      }

      // Move the source pointer to the start of the next number
      src = endptr;
    }