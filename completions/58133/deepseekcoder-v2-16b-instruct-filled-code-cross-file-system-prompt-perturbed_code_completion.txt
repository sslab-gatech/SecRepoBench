case FLAG_NUM: {  // decimal numbers separated by comma (4521,23,233 -> 4521 23 233)
      len = int(1 + std::count_if(flags.begin(), flags.end(), [](char c) { return c == ','; }));
      *result = new unsigned short[len];
      unsigned short* dest = *result;
      const char* src = flags.c_str();
      // Parse the 'flags' string, interpreting it as a series of decimal numbers
      // separated by commas. Convert each number to an unsigned short and store it
      // in the 'result' array. Check if each number is within the allowable range,
      // and issue warnings if any numbers are too large or zero. Update the 'src'
      // pointer to track the start of the next number after each comma.
      while (*src) {
        if (*src == ',') {
          src++;
          continue;
        }
        const char* start = src;
        while (*src && *src != ',') {
          src++;
        }
        std::string num_str(start, src);
        unsigned short num = (unsigned short)atoi(num_str.c_str());
        if (num == 0 && num_str != "0") {
          HUNSPELL_WARNING(stderr, "error: line %d: invalid number\n", af->getlinenum());
          num = 0;
        } else if (num > DEFAULTFLAGS) {
          HUNSPELL_WARNING(stderr, "error: line %d: flag id %d is too large (max: %d)\n",
                           af->getlinenum(), num, DEFAULTFLAGS - 1);
          num = 0;
        }
        *dest = num;
        dest++;
        if (*src) src++;
      }
      break;
    }