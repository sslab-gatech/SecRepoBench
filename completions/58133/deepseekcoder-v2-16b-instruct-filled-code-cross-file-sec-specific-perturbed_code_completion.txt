// Parse the 'flags' string, interpreting it as a series of decimal numbers
    // separated by commas. Convert each number to an unsigned short and store it
    // in the 'result' array. Check if each number is within the allowable range,
    // and issue warnings if any numbers are too large or zero. Update the 'src'
    // pointer to track the start of the next number after each comma.
    const char* src = flags.c_str();
    const char* end = src + flags.size();
    while (src < end) {
      char* next_comma = strchr(src, ',');
      if (next_comma == NULL) {
        next_comma = end;
      }
      std::string num_str(src, next_comma);
      unsigned short num = static_cast<unsigned short>(atoi(num_str.c_str()));
      if (num == 0 && af != NULL) {
        HUNSPELL_WARNING(stderr, "error: line %d: flag id 0 is not allowed\n", af->getlinenum());
      }
      if (num >= DEFAULTFLAGS && af != NULL) {
        HUNSPELL_WARNING(stderr, "error: line %d: flag id %d is too large (max: %d)\n",
                         af->getlinenum(), num, DEFAULTFLAGS - 1);
        num = 0;
      }
      *dest++ = num;
      src = next_comma + 1;
    }