case FLAG_NUM: {  // decimal numbers separated by comma (4521,23,233 -> 4521
                  // 23 233)
  len = int(1 + std::count_if(flags.begin(), flags.end(), [](char c) { return c == ','; }));
  *result = new unsigned short[len];
  unsigned short* dest = *result;
  const char* src = flags.c_str();
  // Parse the 'flags' string, interpreting it as a series of decimal numbers
  // separated by commas. Convert each number to an unsigned short and store it
  // in the'result' array. Check if each number is within the allowable range,
  // and issue warnings if any numbers are too large or zero. Update the'src'
  // pointer to track the start of the next number after each comma.
  while (*src!= '\0') {
    const char* start = src;
    while (*src!= '\0' && *src!= ',') {
      ++src;
    }
    if (start == src) {
      HUNSPELL_WARNING(stderr, "error: line %d: bad flagvector\n",
                       af->getlinenum());
      break;
    }
    std::string num(start, src);
    unsigned short flag = std::stoi(num);
    if (flag >= DEFAULTFLAGS) {
      HUNSPELL_WARNING(stderr,
                       "error: line %d: flag id %d is too large (max: %d)\n",
                       af->getlinenum(), flag, DEFAULTFLAGS - 1);
      flag = 0;
    }
    if (flag!= 0) {
      *dest = flag;
      ++dest;
    }
    if (*src!= '\0') {
      ++src;
    }
  }
  break;
}