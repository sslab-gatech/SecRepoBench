case FLAG_NUM: {  // decimal numbers separated by comma (4521,23,233 -> 4521 23 233)
      len = int(1 + std::count_if(flags.begin(), flags.end(), [](char c) { return c == ','; }));
      *result = new unsigned short[len];
      unsigned short* dest = *result;
      const char* src = flags.c_str();
      // Parse the 'flags' string, interpreting it as a series of decimal numbers
      // separated by commas. Convert each number to an unsigned short and store it
      // in the 'result' array. Check if each number is within the allowable range,
      // and issue warnings if any numbers are too large or zero. Update the 'src'
      // pointer to track the start of the next number after each comma.
      while (*src) {
        if (*src == ',') {
          src++;
          continue;
        }
        char* end;
        unsigned long num = strtoul(src, &end, 10);
        if (num == 0 && src == end) {
          HUNSPELL_WARNING(stderr, "error: line %d: invalid number\n", af->getlinenum());
          src++;
          continue;
        }
        if (num > USHRT_MAX) {
          HUNSPELL_WARNING(stderr, "error: line %d: number %lu is too large (max: %u)\n",
                           af->getlinenum(), num, USHRT_MAX);
          num = 0;
        }
        *dest = (unsigned short)num;
        dest++;
        src = end;
      }
      break;
    }