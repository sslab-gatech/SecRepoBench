int i = 0;
std::string::size_type pos = 0;
std::string::size_type next_pos;

while (i < len && pos < flags.size()) {
  // Find the end of the current number
  next_pos = flags.find(',', pos);
  if (next_pos == std::string::npos)
    next_pos = flags.size();
  
  // Parse the number
  std::string num_str = flags.substr(pos, next_pos - pos);
  int flag;
  try {
    flag = std::stoi(num_str);
  } catch (const std::exception&) {
    if (af != NULL) {
      HUNSPELL_WARNING(stderr, "error: line %d: invalid number in flag vector\n",
                       af->getlinenum());
    }
    flag = 0;
  }
  
  // Check if flag is valid
  if (flag >= DEFAULTFLAGS && af != NULL) {
    HUNSPELL_WARNING(stderr,
                     "error: line %d: flag id %d is too large (max: %d)\n",
                     af->getlinenum(), flag, DEFAULTFLAGS - 1);
    flag = 0;
  }
  
  if (flag == 0 && af != NULL) {
    HUNSPELL_WARNING(stderr, "error: line %d: 0 is wrong flag id\n",
                     af->getlinenum());
  }
  
  // Store the flag
  dest[i++] = (unsigned short)flag;
  
  // Move to the next number (after the comma)
  pos = next_pos + 1;
}
break;