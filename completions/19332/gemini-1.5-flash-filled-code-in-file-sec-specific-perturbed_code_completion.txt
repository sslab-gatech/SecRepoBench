while (offset < messagelength) {
        u_int16_t attribute_type = ntohs(*((u_int16_t*)(payload + offset)));
        u_int16_t attribute_length = ntohs(*((u_int16_t*)(payload + offset + 2)));
        u_int32_t attribute_padding = (attribute_length + 3) & ~3; // Align to 4-byte boundary

        switch (attribute_type) {
          case 0x0001: // MAPPED-ADDRESS
            if (attribute_length >= 8) {
              u_int16_t family = ntohs(*((u_int16_t*)(payload + offset + 4)));
              if (family == 2) { // IPv4
                u_int32_t address = ntohl(*((u_int32_t*)(payload + offset + 6)));
                u_int16_t port = ntohs(*((u_int16_t*)(payload + offset + 10)));
                // Check if the address and port match known protocols
                if (address == 0x0A000002 && port == 5060) { // Example: SIP
                  flow->guessed_host_protocol_id = NDPI_PROTOCOL_SIP;
                } else if (address == 0x7F000001 && port == 8080) { // Example: HTTP
                  flow->guessed_host_protocol_id = NDPI_PROTOCOL_HTTP;
                }
              }
            }
            break;
          case 0x0005: // ERROR-CODE
            // Handle error code attribute
            break;
          case 0x0006: // UNKNOWN-ATTRIBUTES
            // Handle unknown attributes
            break;
          // Add more cases for other STUN attributes as needed
          default:
            break;
        }
        offset += attribute_padding + 4;
      }