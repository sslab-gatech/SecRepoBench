// Iterate through the payload to process STUN message attributes.
// For each attribute, determine its type and length and align the length to 4-byte boundaries.
// Depending on the attribute type, deduce the application protocol and set the guessed host protocol.
// If specific attributes associated with known protocols are found (like WhatsApp, Skype, Zoom, etc.),
// update the guessed protocol accordingly and return the result indicating the presence of STUN.
while (offset < messagelength) {
    u_int16_t attr_type = ntohs(*((u_int16_t *) &payload[offset]));
    u_int16_t attr_len = ntohs(*((u_int16_t *) &payload[offset + 2]));
    offset += 4;

    switch (attr_type) {
        case 0x0001: // MAPPED-ADDRESS
        case 0x0020: // USERNAME
        case 0x0024: // REALM
        case 0x0025: // NONCE
        case 0x8020: // FINGERPRINT
            // These are standard STUN attributes, no need to update the protocol
            break;
        case 0x8022: // SOFTWARE
            if (strstr((const char *) &payload[offset], "WhatsApp")) {
                flow->guessed_host_protocol_id = NDPI_PROTOCOL_WHATSAPP_CALL;
                return NDPI_IS_STUN;
            } else if (strstr((const char *) &payload[offset], "Skype")) {
                flow->guessed_host_protocol_id = NDPI_PROTOCOL_SKYPE;
                return NDPI_IS_STUN;
            } else if (strstr((const char *) &payload[offset], "Zoom")) {
                flow->guessed_host_protocol_id = NDPI_PROTOCOL_ZOOM;
                return NDPI_IS_STUN;
            }
            break;
        default:
            // Unknown attribute, continue processing
            break;
    }

    // Align the length to 4-byte boundaries
    attr_len = (attr_len + 3) & ~3;
    offset += attr_len;
}