while(offset + 4 <= payload_length) {
        u_int16_t attr_type = ntohs(*((u_int16_t*)&payload[offset]));
        u_int16_t attr_length = ntohs(*((u_int16_t*)&payload[offset + 2]));
        u_int16_t aligned_length = (attr_length + 3) & ~3; // Align to 4-byte boundary

        if(offset + 4 + aligned_length > payload_length) {
          // Malformed attribute, break out of the loop
          break;
        }

        switch(attr_type) {
          case 0x0006: // USERNAME
            if(attr_length > 0) {
              flow->guessed_host_protocol_id = NDPI_PROTOCOL_SKYPE;
              return(NDPI_IS_STUN);
            }
            break;

          case 0x0015: // REALM
            if(attr_length > 0) {
              flow->guessed_host_protocol_id = NDPI_PROTOCOL_ZOOM;
              return(NDPI_IS_STUN);
            }
            break;

          case 0x8022: // SOFTWARE
            if(attr_length > 0) {
              if(strncmp((const char*)&payload[offset + 4], "Google", 6) == 0) {
                flow->guessed_host_protocol_id = NDPI_PROTOCOL_HANGOUT_DUO;
                return(NDPI_IS_STUN);
              } else if(strncmp((const char*)&payload[offset + 4], "Skype", 5) == 0) {
                flow->guessed_host_protocol_id = NDPI_PROTOCOL_SKYPE;
                return(NDPI_IS_STUN);
              }
            }
            break;

          case 0x8028: // FINGERPRINT
            // FINGERPRINT attribute found, continue processing
            break;

          default:
            // Unknown attribute, continue processing
            break;
        }

        offset += 4 + aligned_length; // Move to the next attribute
      }