{
  u_int offset = 20;
  while (offset + 4 <= (messagelength + 20)) {
    /* Read attribute type and length */
    u_int16_t attr_type = ntohs(*(u_int16_t*)&payload[offset]);
    u_int16_t attr_len  = ntohs(*(u_int16_t*)&payload[offset+2]);

    /* Ensure attribute length is valid within the message */
    if ((offset + 4 + attr_len) > (messagelength + 20)) {
      break; /* Malformed STUN attribute, stop parsing */
    }

    /* A switch on attribute type to detect known protocols */
    switch(attr_type) {
      case 0x8022: /* SOFTWARE attribute (RFC 5389) */
        if(attr_len > 0) {
          /* Copy software attribute string */
          char sw_str[256];
          memset(sw_str, 0, sizeof(sw_str));
          if (attr_len < sizeof(sw_str)) {
            memcpy(sw_str, &payload[offset + 4], attr_len);
          } else {
            memcpy(sw_str, &payload[offset + 4], sizeof(sw_str) - 1);
          }

          /* Check for known protocol indicators in the software string */
          if(strstr(sw_str, "Skype") != NULL) {
            flow->guessed_host_protocol_id = NDPI_PROTOCOL_SKYPE;
            return(NDPI_IS_STUN);
          } else if(strstr(sw_str, "Zoom") != NULL) {
            flow->guessed_host_protocol_id = NDPI_PROTOCOL_ZOOM;
            return(NDPI_IS_STUN);
          } else if(strstr(sw_str, "WhatsApp") != NULL) {
            flow->guessed_host_protocol_id = NDPI_PROTOCOL_WHATSAPP_CALL;
            return(NDPI_IS_STUN);
          }
        }
        break;

      /* Add other STUN attributes here if needed */

      default:
        /* For unhandled attributes, just skip them */
        break;
    }

    /* Advance to the next attribute, aligning to 4-byte boundary */
    attr_len = (attr_len + 3) & ~3;
    offset += 4 + attr_len;
  }
}