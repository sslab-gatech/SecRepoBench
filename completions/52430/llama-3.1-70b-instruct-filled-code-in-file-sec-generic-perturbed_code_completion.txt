// Check if the current entry `rv` is a valid component of a compound word.
// Validate against various conditions including compound flags, maximum word
// number constraints, and maximum syllable constraints. Ensure that the entry
// does not violate any compound pattern rules from the `checkcpdtable` and
// that it is not a duplicate of the first entry in the compound. Ensure that
// all necessary conditions from the compound pattern table are met.
if (
    // Check if the current entry `rv` is a valid component of a compound word.
    // Validate against various conditions including compound flags, maximum word
    // number constraints, and maximum syllable constraints. Ensure that the entry
    // does not violate any compound pattern rules from the `checkcpdtable` and
    // that it is not a duplicate of the first entry in the compound. Ensure that
    // all necessary conditions from the compound pattern table are met.
    ((rv) &&
     (checked_prefix || (words && words[wnum]) ||
      (compoundflag && TESTAFF(rv->astr, compoundflag, rv->alen)) ||
      ((oldwordnum == 0) && compoundbegin &&
       TESTAFF(rv->astr, compoundbegin, rv->alen)) ||
      ((oldwordnum > 0) && compoundmiddle &&
       TESTAFF(rv->astr, compoundmiddle, rv->alen))

      // LANG_hu section: spec. Hungarian rule
      || ((langnum == LANG_hu) && hu_mov_rule &&
          (TESTAFF(
               rv->astr, 'F',
               rv->alen) ||  // XXX hardwired Hungarian dictionary codes
           TESTAFF(rv->astr, 'G', rv->alen) ||
           TESTAFF(rv->astr, 'H', rv->alen)))
      // END of LANG_hu section
      ) &&
     (
         // test CHECKCOMPOUNDPATTERN conditions
         scpd == 0 || checkcpdtable[scpd - 1].cond == FLAG_NULL ||
         TESTAFF(rv->astr, checkcpdtable[scpd - 1].cond, rv->alen)) &&
    !((checkcompoundtriple && scpd == 0 &&
       !words &&  // test triple letters
        (word[i - 1] == word[i]) &&
        (((i > 1) && (word[i - 1] == word[i - 2])) ||
         ((word[i - 1] == word[i + 1]))  // may be word[i+1] == '\0'
         )) ||
       (checkcompoundcase && scpd == 0 &&!words && cpdcase_check(word.c_str(), i))))
    // LANG_hu section: spec. Hungarian rule
    ||
    ((!rv) && (langnum == LANG_hu) && hu_mov_rule &&
     (rv = affix_check(st, 0, i)) &&
     (sfx && sfx->getCont() &&
      (  // XXX hardwired Hungarian dic. codes
           TESTAFF(sfx->getCont(), (unsigned short)'x',
                   sfx->getContLen()) ||
           TESTAFF(
               sfx->getCont(), (unsigned short)'%',
               sfx->getContLen()))))) {  // first word is ok condition