{
  /* We'll implement Knuth's Algorithm D for long division of x by y (both normalized). */
  /* Clear the quotient array first. */
  for (size_t i = 0; i < q.sz; i++) {
    q.p[i] = 0;
  }

  /* Use a wider type for intermediate products and sums. */
  const mp_wide base = (mp_wide)1 << DIG_SIZE;
  const mp_wide mask = base - 1;

  /* Main loop: process from the most significant limb down to the least significant. */
  for (index = xd; index-- > yd - 1;) {
    /* Combine two top limbs of the current 'x' portion into a single double-wide value. */
    mp_limb2 hi = (index + 1 < x.sz) ? x.p[index + 1] : 0;
    mp_limb2 lo = x.p[index];
    mp_wide t = ((mp_wide)hi << DIG_SIZE) + (mp_wide)lo;

    /* Initial guess for this digit of the quotient. */
    mp_limb2 qhat = (mp_limb2)(t / z);
    mp_limb2 rhat = (mp_limb2)(t % z);

    /* Refine guess if it's too large by comparing against the next limb of x. */
    if (yd >= 2) {
      mp_limb2 nxt = (index > 0) ? x.p[index - 1] : 0;
      while (qhat == (mp_limb2)base ||
             ( (mp_wide)qhat * (mp_wide)y.p[yd - 2] >
               ((mp_wide)rhat << DIG_SIZE) + (mp_wide)nxt )) {
        qhat--;
        rhat += (mp_limb2)z;
        if (rhat >= (mp_limb2)base) break;
      }
    }

    /* Multiply and subtract: x -= qhat * y, at the proper offset. */
    {
      mp_wide carry = 0;
      mp_wide diff;
      for (size_t j = 0; j < yd; j++) {
        mp_wide prod = (mp_wide)qhat * (mp_wide)y.p[j];
        diff = (mp_wide)x.p[index - (yd - 1) + j] - (prod & mask) - carry;
        x.p[index - (yd - 1) + j] = (mp_limb2)(diff & mask);
        carry = (prod >> DIG_SIZE) + (mp_wide)((diff >> (sizeof(mp_limb2)*8 - 1)) & 1);
      }

      /* If we went 'below zero', fix by adding back one multiple of y. */
      if ((diff >> (sizeof(mp_limb2)*8 - 1)) & 1) {
        qhat--;
        carry = 0;
        for (size_t j = 0; j < yd; j++) {
          mp_wide sumv = (mp_wide)x.p[index - (yd - 1) + j] + (mp_wide)y.p[j] + carry;
          x.p[index - (yd - 1) + j] = (mp_limb2)(sumv & mask);
          carry = sumv >> DIG_SIZE;
        }
      }
    }

    /* Store computed limb of the quotient. */
    q.p[index - (yd - 1)] = qhat;
  }
}