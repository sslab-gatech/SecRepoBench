mp_limb2 carry = 0;
for (index = xd - yd; index < xd; index++) {
  mp_limb2 qhat;
  if (index >= yd) {
    mp_limb2 uh = x.p[index + 1];
    mp_limb2 ul = x.p[index];
    mp_limb2 vh = z >> (BITS_PER_MP_LIMB / 2);
    mp_limb2 vl = z & (((mp_limb_t)1 << (BITS_PER_MP_LIMB / 2)) - 1);
    if (uh == vh) {
      qhat = MAX_LIMB;
    } else {
      qhat = ((uh << (BITS_PER_MP_LIMB / 2)) | (ul >> (BITS_PER_MP_LIMB / 2))) / vh;
    }
    // Adjust qhat to avoid overestimation
    while (qhat * vl > ((ul << (BITS_PER_MP_LIMB / 2)) | (x.p[index - yd] >> (BITS_PER_MP_LIMB / 2))))
      qhat--;
  } else {
    qhat = 0;
  }
  q.p[index - (xd - yd)] = qhat;
  carry = mpn_submul_1(x->p + index - yd, y->p, yd, qhat);
}
if (carry != 0) {
  mpz_sub_int(mrb, &q, &q, 1);
  mpn_add_n(x->p, x->p, y->p, yd);
}
x.p[xd - yd] = 0; // Ensure termination of the number