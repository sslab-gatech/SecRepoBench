{
  size_t n = yd;
  size_t m = xd - n;
  for (ssize_t j = m; j >= 0; j--) {
    mp_limb2 qhat, rhat;
    /* Form a two‚Äêdigit number from x.p[j+n] and x.p[j+n-1] */
    mp_limb2 high = x.p[j+n];
    mp_limb2 next = x.p[j+n-1];
    mp_limb2 dividend = (high << DIG_SIZE) | next;
    qhat = dividend / z;
    rhat = dividend % z;
    if (qhat >= ((mp_limb2)1 << DIG_SIZE))
      qhat = (((mp_limb2)1 << DIG_SIZE) - 1);
    
    mp_limb2 borrow = 0;
    for (size_t i = 0; i < n; i++) {
      mp_limb2 prod = (mp_limb2)y.p[i] * qhat;
      /* Subtract prod (low part) plus borrow from x.p[i+j] */
      mp_limb2 sub = x.p[i+j] - (prod & ((((mp_limb2)1) << DIG_SIZE) - 1)) - borrow;
      x.p[i+j] = sub & ((((mp_limb2)1) << DIG_SIZE) - 1);
      /* Compute new borrow: if sub underflowed or high part of prod */
      borrow = ((sub >> (sizeof(mp_limb2)*8 - 1)) & 1) + (prod >> DIG_SIZE);
    }
    mp_limb2 u = x.p[j+n] - borrow;
    x.p[j+n] = u & ((((mp_limb2)1) << DIG_SIZE) - 1);
    if (borrow) {
      qhat--;
      mp_limb2 carry = 0;
      for (size_t i = 0; i < n; i++) {
        mp_limb2 sum = (mp_limb2)x.p[i+j] + y.p[i] + carry;
        x.p[i+j] = sum & ((((mp_limb2)1) << DIG_SIZE) - 1);
        carry = sum >> DIG_SIZE;
      }
      x.p[j+n] += carry;
    }
    q.p[j] = qhat;
  }
}