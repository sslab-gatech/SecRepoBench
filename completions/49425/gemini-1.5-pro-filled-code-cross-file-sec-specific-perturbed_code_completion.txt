for (index = xd - yd; index >= 0; index--) {
    mp_limb2 qhat;  /* estimated quotient digit */
    mp_limb2 rhat;  /* remainder */

    if (z == MP_LIMB_MAX) {
      qhat = x.p[index + yd];
    }
    else {
      mp_limb2_double v = (((mp_limb2_double)x.p[index + yd]) << DIG_SIZE) | x.p[index + yd - 1];
      qhat = v / z;
      rhat = v % z;
    }

    /* check if qhat is too big */
    while (yd > 1 && qhat * y.p[yd - 2] > (((mp_limb2_double)rhat) << DIG_SIZE) | x.p[index + yd - 2]) {
      qhat--;
      rhat += z;
      if (rhat < z) break;  // overflow, qhat is now correct
    }

    /*
     * qhat is now either exact or one too big.  Do a
     * trial subtraction to see which case holds.
     */
    mp_limb_signed_t borrow = 0;
    for (size_t i = 0; i < yd; i++) {
      mp_limb2_double diff = x.p[index + i] - qhat * y.p[i] - borrow;
      x.p[index + i] = diff & MP_LIMB_MAX;
      borrow = (diff >> DIG_SIZE) & 1;
    }

    if (borrow) {
      qhat--;
      mp_limb_signed_t carry = 0;
      for (size_t i = 0; i < yd; i++) {
        mp_limb2_double sum = x.p[index + i] + y.p[i] + carry;
        x.p[index + i] = sum & MP_LIMB_MAX;
        carry = (sum >> DIG_SIZE) & 1;
      }
    }

    q.p[index] = qhat;
  }