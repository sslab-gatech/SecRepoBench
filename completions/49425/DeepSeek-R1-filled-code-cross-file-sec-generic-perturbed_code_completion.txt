for (index = xd; index-- > yd;) {
    mp_limb2 num = ((mp_limb2)x.p[index] << DIG_SIZE) | x.p[index - 1];
    mp_limb2 qhat = num / z;
    if (qhat > DIG_MASK) qhat = DIG_MASK;

    mp_limb2 carry = 0;
    mp_limb2 borrow = 0;

    while (1) {
      carry = 0;
      borrow = 0;
      for (size_t j = 0; j < yd; j++) {
        mp_limb2 product = y.p[j] * qhat + carry;
        carry = product >> DIG_SIZE;
        mp_limb2 digit = x.p[index - yd + j];
        mp_limb2 sub = digit - (product & DIG_MASK);
        if (sub > digit) borrow++;
        digit = sub - borrow;
        borrow = (digit > sub) ? 1 : 0;
        x.p[index - yd + j] = digit;
      }

      if (borrow || x.p[index] < carry) {
        qhat--;
        mp_limb2 add_carry = 0;
        for (size_t j = 0; j < yd; j++) {
          mp_limb2 sum = x.p[index - yd + j] + y.p[j] + add_carry;
          add_carry = sum >> DIG_SIZE;
          x.p[index - yd + j] = sum & DIG_MASK;
        }
        if (add_carry) break;
      } else {
        break;
      }
    }

    q.p[index - yd] = qhat;
  }