for (index = xd - yd; index != (size_t) -1; index--) {
  // Calculate the trial quotient
  mp_limb2 qhat;
  mp_limb2 rhat;
  
  if (x.p[index + yd] == y.p[yd - 1]) {
    qhat = ((mp_limb2)1 << DIG_SIZE) - 1;
  } else {
    qhat = ((((mp_limb2)x.p[index + yd]) << DIG_SIZE) + x.p[index + yd - 1]) / y.p[yd - 1];
  }
  
  if (qhat >= ((mp_limb2)1 << DIG_SIZE)) {
    qhat = ((mp_limb2)1 << DIG_SIZE) - 1;
  }
  
  // Multiply and subtract
  mp_limb_t borrow = 0;
  for (size_t j = 0; j < yd; j++) {
    mp_limb2 prod = qhat * y.p[j];
    mp_limb_t prod_low = prod & MP_LIMB_MAX;
    mp_limb_t prod_high = prod >> DIG_SIZE;
    
    mp_limb2 diff = (mp_limb2)x.p[index + j] - prod_low - borrow;
    
    if (diff > MP_LIMB_MAX) {
      x.p[index + j] = diff & MP_LIMB_MAX;
      borrow = 0;
    } else {
      x.p[index + j] = diff;
      borrow = 1;
    }
    
    if (j + 1 < yd) {
      if (borrow) prod_high++;
      
      mp_limb2 temp = (mp_limb2)x.p[index + j + 1] - prod_high;
      
      if (temp > MP_LIMB_MAX) {
        x.p[index + j + 1] = temp & MP_LIMB_MAX;
        borrow = 0;
      } else {
        x.p[index + j + 1] = temp;
        borrow = 1;
      }
    }
  }
  
  // If we borrowed too much, add back once
  if (borrow) {
    qhat--;
    mp_limb_t carry = 0;
    for (size_t j = 0; j < yd; j++) {
      mp_limb2 sum = (mp_limb2)x.p[index + j] + y.p[j] + carry;
      x.p[index + j] = sum & MP_LIMB_MAX;
      carry = sum >> DIG_SIZE;
    }
    
    x.p[index + yd] += carry;
  }
  
  // Store the quotient digit
  q.p[index] = qhat;
}