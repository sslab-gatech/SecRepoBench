{
  size_t m = digits(&y);
  size_t n = xd;  /* number of limbs in x */
  /* Loop over quotient digits from high index down to 0 */
  for (ssize_t i = n - m; i >= 0; i--) {
    /* Estimate quotient digit: use two most‚Äêsignificant limbs of x starting at i */
    unsigned __int128 high = x.p[i + m];
    unsigned __int128 low  = x.p[i + m - 1];
    unsigned __int128 dividend = (high << DIG_SIZE) | low;
    mp_limb2 qhat = (mp_limb2)(dividend / z);
    if (qhat >= ((mp_limb2)1 << DIG_SIZE))
      qhat = (((mp_limb2)1 << DIG_SIZE) - 1);

    /* Multiply y by qhat and subtract from x starting at position i. */
    unsigned __int128 carry = 0;
    for (size_t j = 0; j < m; j++) {
      /* Multiply: product fits in 2 limbs */
      unsigned __int128 prod = (unsigned __int128)qhat * y.p[j];
      /* Subtract lower limb and borrow */
      unsigned __int128 sub = (unsigned __int128)x.p[i + j] - carry - (prod & ((((unsigned __int128)1) << DIG_SIZE) - 1));
      x.p[i + j] = (mp_limb2)(sub & ((((unsigned __int128)1) << DIG_SIZE) - 1));
      /* carry is sum of high part of product plus borrow from subtraction */
      carry = (prod >> DIG_SIZE) + ((sub >> DIG_SIZE) & 1);
    }
    /* Subtract remaining carry from the next limb */
    unsigned __int128 sub = (unsigned __int128)x.p[i + m] - carry;
    x.p[i + m] = (mp_limb2)(sub & ((((unsigned __int128)1) << DIG_SIZE) - 1));
    /* If subtraction borrowed, qhat was overestimated; adjust */
    if (sub >> DIG_SIZE) {
      qhat--;
      unsigned __int128 carry2 = 0;
      for (size_t j = 0; j < m; j++) {
        unsigned __int128 sum = (unsigned __int128)x.p[i + j] + y.p[j] + carry2;
        x.p[i + j] = (mp_limb2)(sum & ((((unsigned __int128)1) << DIG_SIZE) - 1));
        carry2 = sum >> DIG_SIZE;
      }
      x.p[i + m] += (mp_limb2)carry2;
    }
    q.p[i] = qhat;
  }
}