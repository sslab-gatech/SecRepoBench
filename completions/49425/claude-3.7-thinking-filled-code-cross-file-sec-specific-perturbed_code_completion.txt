for (int i = (int)xd - (int)yd; i >= 0; i--) {
  // Compute quotient digit
  mp_limb2 qhat = 0;
  if (i + yd < x.sz) {
    if (x.p[i + yd] == y.p[yd - 1]) {
      qhat = DIG_BASE - 1;
    } else {
      qhat = ((mp_limb2)x.p[i + yd] << DIG_SIZE | x.p[i + yd - 1]) / z;
    }
  }
  
  if (qhat >= DIG_BASE) qhat = DIG_BASE - 1;
  
  // Multiply and subtract
  mp_limb2 borrow = 0;
  for (size_t j = 0; j < yd; j++) {
    mp_limb2 product = qhat * y.p[j];
    mp_limb2 subtrahend = (product & (DIG_BASE - 1)) + borrow;
    borrow = (product >> DIG_SIZE);
    
    if (x.p[i + j] < subtrahend) {
      x.p[i + j] += DIG_BASE - subtrahend;
      borrow++;
    } else {
      x.p[i + j] -= subtrahend;
    }
  }
  
  // Correct if quotient digit was too large
  if (i + yd < x.sz && borrow > x.p[i + yd]) {
    qhat--;
    
    // Add back
    mp_limb2 carry = 0;
    for (size_t j = 0; j < yd; j++) {
      mp_limb2 sum = (mp_limb2)x.p[i + j] + y.p[j] + carry;
      x.p[i + j] = sum & (DIG_BASE - 1);
      carry = sum >> DIG_SIZE;
    }
    
    x.p[i + yd] += carry - borrow;
  } else if (i + yd < x.sz) {
    x.p[i + yd] -= borrow;
  }
  
  q.p[i] = qhat;
}
q.sz = (xd >= yd) ? (xd - yd + 1) : 0;