for (index = 0; index <= xd - yd; index++) {
  q.p[index] = 0;
}
for (index = xd - yd; index != (size_t)-1; index--) {
  // Estimate quotient digit
  mp_limb qt;
  if (index + yd < xd) {
    mp_limb2 u = ((mp_limb2)x.p[index + yd] << DIG_SIZE) | x.p[index + yd - 1];
    qt = u / z;
  } else {
    qt = x.p[index + yd - 1] / z;
  }
  if (qt >= (1UL << DIG_SIZE)) {
    qt = (1UL << DIG_SIZE) - 1;
  }
  
  // Multiply quotient digit by divisor and subtract
  mp_limb borrow = 0;
  for (size_t i = 0; i < yd; i++) {
    mp_limb2 prod = (mp_limb2)qt * y.p[i];
    mp_limb hi = prod >> DIG_SIZE;
    mp_limb lo = prod & ((1UL << DIG_SIZE) - 1);
    
    mp_limb2 diff = (mp_limb2)x.p[index + i] - lo - borrow;
    borrow = (diff >> DIG_SIZE) & 1;
    x.p[index + i] = diff & ((1UL << DIG_SIZE) - 1);
    
    borrow += hi;
  }
  
  // Adjust if necessary
  if (index + yd < xd) {
    if (x.p[index + yd] < borrow) {
      qt--;
      mp_limb carry = 0;
      for (size_t i = 0; i < yd; i++) {
        mp_limb2 sum = (mp_limb2)x.p[index + i] + y.p[i] + carry;
        carry = sum >> DIG_SIZE;
        x.p[index + i] = sum & ((1UL << DIG_SIZE) - 1);
      }
      x.p[index + yd] += carry;
    } else {
      x.p[index + yd] -= borrow;
    }
  } else if (borrow > 0) {
    qt--;
    mp_limb carry = 0;
    for (size_t i = 0; i < yd; i++) {
      mp_limb2 sum = (mp_limb2)x.p[index + i] + y.p[i] + carry;
      carry = sum >> DIG_SIZE;
      x.p[index + i] = sum & ((1UL << DIG_SIZE) - 1);
    }
  }
  
  q.p[index] = qt;
}
q.sz = xd - yd + 1;