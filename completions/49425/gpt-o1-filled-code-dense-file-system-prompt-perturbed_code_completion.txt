zero(&q);

  /* Knuth's Algorithm D for multi-limb unsigned division. */
  mpz_t tmp, prod;
  mpz_init(mrb, &tmp);
  mpz_init(mrb, &prod);

  /* We'll iterate from the highest shifted limb of x down to the index where
   * the divisor (y) could still fit. */
  for (index = xd; index-- > yd - 1;) {
    /* Step D3: Compute an initial guess for the current quotient digit. */
    mp_limb2 high = x.p[index];
    mp_limb2 low  = (index > 0) ? x.p[index - 1] : 0;
    mp_limb2 w    = (high << DIG_SIZE) + low;
    mp_limb2 qhat = w / z;  /* guess for quotient digit */
    mp_limb2 rhat = w % z;  /* remainder from that guess */

    /* Step D3 (correction): Check whether qhat is too large using the next
     * limb of y (y->p[yd-2]) and the next limb of x (x.p[index-2]), if they exist. */
    if (yd > 1 && index > 1) {
      mp_limb2 left  = qhat * (mp_limb2)y.p[yd - 2];
      mp_limb2 right = (rhat << DIG_SIZE) + x.p[index - 2];
      while ((qhat == ((mp_limb2)1 << DIG_SIZE)) || (left > right)) {
        qhat--;
        rhat += z;
        if (rhat >= ((mp_limb2)1 << DIG_SIZE)) break;
        left  = qhat * (mp_limb2)y.p[yd - 2];
        right = (rhat << DIG_SIZE) + x.p[index - 2];
      }
    }

    /* Step D4: Multiply y by qhat to get partial product. */
    mpz_set_int(mrb, &tmp, (mp_int)qhat);
    /* Assume "umul" or an equivalent is available; it multiplies y by tmp => prod. */
    umul(mrb, &prod, &y, &tmp);

    /* Step D5: Subtract the product from x's corresponding portion (in place).
     * We'll subtract into x directly (where x holds shifted data). */
    {
      /* Use usub to subtract from the portion starting at index-(yd-1). */
      mpz_t portion;
      mpz_init(mrb, &portion);
      /* Build a temporary mpz pointing to x's relevant slice. */
      portion.sz = prod.sz;
      mpz_realloc(mrb, &portion, prod.sz);
      for (size_t i2 = 0; i2 < portion.sz; i2++) {
        portion.p[i2] = (index - (yd - 1) + i2 < x.sz)
          ? x.p[index - (yd - 1) + i2] : 0;
      }
      portion.sz = digits(&portion);

      /* Subtract product: portion := portion - prod. */
      usub(mrb, &portion, &portion, &prod);

      /* Copy back the result into x. */
      for (size_t i2 = 0; i2 < portion.sz; i2++) {
        x.p[index - (yd - 1) + i2] = portion.p[i2];
      }
      /* If there's a borrow (portion is effectively negative), it means qhat
       * was overestimated. We correct it by decrementing qhat and adding y back. */
      if ((short)portion.sn < 0) {
        qhat--;
        /* Add y back into that portion. */
        uadd(mrb, &portion, &portion, &y);
        for (size_t i2 = 0; i2 < portion.sz; i2++) {
          x.p[index - (yd - 1) + i2] = portion.p[i2];
        }
      }
      mpz_clear(mrb, &portion);
    }

    /* Store the quotient digit. */
    q.p[index - (yd - 1)] = (mp_limb1)qhat;
  }

  mpz_clear(mrb, &tmp);
  mpz_clear(mrb, &prod);
  q.sz = digits(&q);