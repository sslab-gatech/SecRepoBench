for (index = xd - yd; index >= 0; index--) {
    mp_limb2 qhat;  /* estimated quotient digit */
    mp_limb2 rhat;  /* remainder */

    if (z == MP_LIMB_MAX)
      qhat = x.p[index+yd];
    else {
      mp_limb2_double v = ((mp_limb2_double)x.p[index+yd] << DIG_SIZE) | x.p[index+yd-1];
      qhat = v / z;
      rhat = v % z;
    }

    /* check if qhat is too big */
    while (yd > 1 && qhat * y.p[yd-2] > (rhat << DIG_SIZE) + x.p[index+yd-2]) {
      qhat--;
      rhat += z;
      if (rhat < z) break;
    }

    /*
     * qhat is now either exact or one too big.  Do a trial
     * subtraction to check which case holds.
     */
    {
      signed long borrow;
      size_t i;
      mp_limb_signed_t diff;

      borrow = 0;
      for (i = 0; i < yd; i++) {
        mp_limb2_double p = (mp_limb2_double)qhat * y.p[i];
        diff = x.p[index+i] - borrow - (mp_limb2)p;
        x.p[index+i] = diff;
        borrow = (p >> DIG_SIZE) - (diff >> DIG_SIZE);
      }
      diff = x.p[index+yd] - borrow;
      x.p[index+yd] = diff;

      /*
       * If borrow is nonzero here, qhat was one too big.
       * Correct by adding y back in.
       */
      if (borrow) {
        qhat--;
        usadd(mrb, &x, &x, &y, index);
      }
    }
    q.p[index] = qhat;
  }