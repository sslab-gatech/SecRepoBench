{
  mp_limb2 base = ((mp_limb2)1 << DIG_SIZE);
  /* Ensure there's room for a possible extra carry at the top */
  if (x.p[xd - 1] < y.p[yd - 1]) {
    x.p[xd] = 0;
    xd++;
  }

  for (index = xd; index-- > yd; ) {
    /* Step D3: Compute an approximate quotient digit */
    mp_limb2 t = ((mp_limb2)x.p[index] << DIG_SIZE)
               + (index > 0 ? (mp_limb2)x.p[index - 1] : 0);
    mp_limb2 qhat = t / z;
    mp_limb2 rhat = t % z;

    /* Step D4: Correct qhat if it's too large by comparing against next divisor digit */
    if (yd > 1) {
      mp_limb2 left = qhat * (mp_limb2)y.p[yd - 2];
      mp_limb2 right = (rhat << DIG_SIZE)
                     + (index > 1 ? (mp_limb2)x.p[index - 2] : 0);
      while (left > right) {
        qhat--;
        rhat += z;
        if (rhat >= base) break;  /* no more corrections needed if remainder "wraps" */
        left = qhat * (mp_limb2)y.p[yd - 2];
        right = (rhat << DIG_SIZE)
              + (index > 1 ? (mp_limb2)x.p[index - 2] : 0);
      }
    }

    /* Step D5: Multiply the divisor by qhat, subtract from current portion of x */
    mp_limb2 carry = 0;
    for (size_t j = 0; j < yd; j++) {
      mp_limb2 mul = (mp_limb2)qhat * (mp_limb2)y.p[j] + carry;
      mp_limb2 sub = (mp_limb2)x.p[index - yd + j] - (mul & (base - 1));
      x.p[index - yd + j] = (mp_limb)(sub & (base - 1));
      carry = (mul >> DIG_SIZE) + ((sub >> DIG_SIZE) & 1);
    }

    /* Step D6: If there was a borrow, adjust and decrement qhat */
    if (carry) {
      qhat--;
      mp_limb2 addcarry = 0;
      for (size_t j = 0; j < yd; j++) {
        mp_limb2 sum = (mp_limb2)x.p[index - yd + j]
                     + (mp_limb2)y.p[j]
                     + addcarry;
        x.p[index - yd + j] = (mp_limb)(sum & (base - 1));
        addcarry = sum >> DIG_SIZE;
      }
    }

    /* Store the computed digit of the quotient */
    q.p[index - yd] = (mp_limb)qhat;
  }
}