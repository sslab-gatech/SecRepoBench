for (index = xd - yd; ; index--) {
    mp_limb2 num = (x.p[index + yd] << DIG_SIZE) + x.p[index + yd - 1];
    mp_limb2 qhat = num / z;
    mp_limb2 rhat = num % z;

    while (qhat >= (1UL << DIG_SIZE) ||
           (yd > 1 && qhat * y.p[yd-2] > ((rhat << DIG_SIZE) + x.p[index + yd - 2]))) {
      qhat--;
      rhat += z;
      if (rhat >= (1UL << DIG_SIZE)) break;
    }

    mp_limb borrow = 0;
    for (size_t j = 0; j < yd; j++) {
      mp_limb2 product = qhat * y.p[j];
      mp_limb2 sub = (product & ((1UL << DIG_SIZE) - 1)) + borrow;
      borrow = (product >> DIG_SIZE) + (sub >> DIG_SIZE);
      mp_limb current = x.p[index + j];
      if (current < (sub & ((1UL << DIG_SIZE) - 1))) {
        borrow++;
      }
      x.p[index + j] = current - (sub & ((1UL << DIG_SIZE) - 1));
    }
    borrow += x.p[index + yd];

    if (borrow) {
      qhat--;
      mp_limb carry = 0;
      for (size_t j = 0; j < yd; j++) {
        mp_limb2 sum = x.p[index + j] + y.p[j] + carry;
        x.p[index + j] = sum & ((1UL << DIG_SIZE) - 1);
        carry = sum >> DIG_SIZE;
      }
      x.p[index + yd] += carry;
    }

    q.p[index] = qhat;
    if (index == 0) break;
  }