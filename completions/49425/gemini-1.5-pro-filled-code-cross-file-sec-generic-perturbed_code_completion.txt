for (index = xd - yd; index >= 0; index--) {
    mp_limb2 qhat;  /* estimated quotient digit */
    mp_limb2 rhat;  /* remainder */

    if (z == MP_LIMB_MAX) {
      qhat = x.p[index + yd];
    }
    else {
      mp_limb2_double v = ((mp_limb2_double)x.p[index+yd] << DIG_SIZE) | x.p[index+yd-1];
      qhat = v / z;
      rhat = v % z;
    }

    /* check if qhat is too big */
    while (yd > 1 && qhat * y.p[yd - 2] > (rhat << DIG_SIZE) + x.p[index + yd - 2]) {
      qhat--;
      rhat += z;
      if (rhat < z) break;
    }

    /*
     * qhat is now either correct or 1 too large. Subtract qhat * y from x.
     * if qhat is correct, the result will be non-negative. If qhat is 1 too
     * large, the result will be negative.
     */
    mp_limb_signed_t borrow = 0;
    for (size_t i = 0; i < yd; ++i) {
      mp_limb2_double p = (mp_limb2_double)qhat * y.p[i];
      mp_limb_signed_t diff = x.p[index + i] - borrow - (mp_limb2)p;
      x.p[index + i] = diff;
      borrow = (p >> DIG_SIZE) - (diff >> DIG_SIZE);
    }

    mp_limb_signed_t diff = x.p[index + yd] - borrow;
    x.p[index + yd] = diff;

    q.p[index] = qhat;

    if (diff < 0) {
      q.p[index]--;
      borrow = 0;
      for (size_t i = 0; i < yd; i++) {
        mp_limb2_double p = x.p[index + i] + y.p[i] + borrow;
        borrow = p >> DIG_SIZE;
        x.p[index + i] = p;
      }
      x.p[index + yd] += borrow;
    }
  }