for (index = xd; index-- > yd;) {
    mp_limb2 qhat;
    mp_limb2 rhat;
    mp_limb2 x0 = x.p[index];
    mp_limb2 x1 = x.p[index-1];
    mp_limb2 x2 = (index >= 2) ? x.p[index-2] : 0;

    // Estimate qhat
    qhat = (x0 == z) ? MP_LIMB_MAX : (x0 * MP_LIMB_RADIX + x1) / z;
    rhat = (x0 == z) ? x1 : (x0 * MP_LIMB_RADIX + x1) % z;

    // Adjust qhat
    while (qhat * y.p[yd-2] > rhat * MP_LIMB_RADIX + x2) {
      qhat--;
      rhat += z;
      if (rhat >= MP_LIMB_RADIX) break;
    }

    // Multiply and subtract
    mp_limb2 borrow = 0;
    for (size_t j = 0; j < yd; j++) {
      mp_limb2 prod = qhat * y.p[j];
      mp_limb2 sub = x.p[index-yd+j] - borrow - (prod & MP_LIMB_MASK);
      x.p[index-yd+j] = sub & MP_LIMB_MASK;
      borrow = (prod >> MP_LIMB_BITS) + ((sub >> MP_LIMB_BITS) & 1);
    }
    mp_limb2 sub = x.p[index] - borrow;
    x.p[index] = sub & MP_LIMB_MASK;

    // If subtraction was negative, add back
    if (sub >> MP_LIMB_BITS) {
      qhat--;
      mp_limb2 carry = 0;
      for (size_t j = 0; j < yd; j++) {
        mp_limb2 sum = x.p[index-yd+j] + y.p[j] + carry;
        x.p[index-yd+j] = sum & MP_LIMB_MASK;
        carry = sum >> MP_LIMB_BITS;
      }
      x.p[index] += carry;
    }

    q.p[index-yd] = qhat;
  }