{
  size_t n = yd;
  size_t m = xd - n;
  /* Compute the base = 2^(BITS_PER_LIMB) */
  const mp_limb2 base = ((mp_limb2)1) << (sizeof(mp_limb2)*8 - 1);
  const mp_limb2 full_base = base << 1;  /* full_base = 2^(sizeof(mp_limb2)*8) */
  for (ssize_t j = m; j >= 0; j--) {
    /* Estimate quotient digit qhat using the leading two limbs */
    mp_limb2 dividend_high = (j + n < xd) ? x.p[j + n] : 0;
    mp_limb2 dividend_low  = x.p[j + n - 1];
    /* Combine two limbs into a doubleâ€limb value */
    mp_limb2 num = dividend_high * full_base + dividend_low;
    mp_limb2 qhat = num / z;
    if (qhat >= full_base)
      qhat = full_base - 1;

    /* Multiply divisor y by qhat and subtract from x starting at position j */
    mp_limb2 carry = 0;
    for (size_t i = 0; i < n; i++) {
      mp_limb2 prod = y.p[i] * qhat;
      /* Subtract the low part of prod and the carry from x.p[j+i] */
      mp_limb2 p = x.p[j + i];
      mp_limb2 sub = p - (prod % full_base) - carry;
      /* Determine the new carry: the high part of prod plus an extra borrow if needed */
      carry = prod / full_base;
      if (p < (prod % full_base) + carry)
        carry++;
      x.p[j + i] = sub;
    }
    /* Subtract the carry from x.p[j+n] */
    mp_limb2 p = x.p[j + n];
    x.p[j + n] = p - carry;
    /* If a borrow occurred, qhat was overestimated; fix by decrementing qhat and restoring x */
    if (p < carry) {
      qhat--;
      mp_limb2 carry2 = 0;
      for (size_t i = 0; i < n; i++) {
        mp_limb2 sum = x.p[j + i] + y.p[i] + carry2;
        /* Check for carry in addition */
        if (sum < x.p[j + i])
          carry2 = 1;
        else
          carry2 = 0;
        x.p[j + i] = sum;
      }
      x.p[j + n] += carry2;
    }
    q.p[j] = qhat;
  }
}