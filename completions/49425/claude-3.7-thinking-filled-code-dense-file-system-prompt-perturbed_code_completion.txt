for (index = xd - yd; index != (size_t)-1; index--) {
  // Estimate quotient digit
  mp_limb2 qhat;
  if (index + yd < xd && x.p[index+yd] == y.p[yd-1]) {
    qhat = (mp_limb)~0;  // Maximum value for a limb
  } else if (index + yd < xd) {
    qhat = ((mp_limb2)x.p[index+yd] << DIG_SIZE | x.p[index+yd-1]) / z;
  } else {
    qhat = x.p[index+yd-1] / z;
  }
  
  // Ensure quotient fits in a limb
  if (qhat > (mp_limb)~0) qhat = (mp_limb)~0;
  
  // Multiply divisor by quotient digit and subtract
  mp_limb2 borrow = 0;
  for (size_t j = 0; j < yd; j++) {
    mp_limb2 product = qhat * y.p[j];
    if (LOW(product) + borrow > x.p[index+j]) {
      x.p[index+j] = (mp_limb)((1ULL << DIG_SIZE) + x.p[index+j] - LOW(product) - borrow);
      borrow = HIGH(product) + 1;
    } else {
      x.p[index+j] = x.p[index+j] - LOW(product) - borrow;
      borrow = HIGH(product);
    }
  }
  
  // Handle borrow from highest digit
  if (index + yd < xd) {
    if (borrow > x.p[index+yd]) {
      // We borrowed too much, add back
      qhat--;
      mp_limb2 carry = 0;
      for (size_t j = 0; j < yd; j++) {
        carry += (mp_limb2)x.p[index+j] + y.p[j];
        x.p[index+j] = LOW(carry);
        carry >>= DIG_SIZE;
      }
      x.p[index+yd] += carry;
    } else {
      x.p[index+yd] -= borrow;
    }
  }
  
  q.p[index] = qhat;
}