for (index = xd; index-- > yd-1;) {
    mp_limb2 qhat;
    mp_limb2 x2 = (index >= 1 ? x.p[index-1] : 0);
    mp_limb2 x1 = x.p[index];
    mp_limb2 x0 = (index+1 < xd ? x.p[index+1] : 0);
    mp_limb2 dividend = ((mp_limb2)x1 << DIG_SIZE) | x0;
    if (x1 == z) {
      qhat = MP_LIMB_MAX;
    }
    else {
      qhat = dividend / z;
    }
    // adjust qhat if necessary
    while (1) {
      mp_limb2 y1 = (yd >= 2 ? y.p[yd-2] : 0);
      mp_limb2 prod1 = (mp_limb2)qhat * y1;
      mp_limb2 prod2 = (mp_limb2)qhat * z;
      mp_limb2 left = ((mp_limb2)x1 << DIG_SIZE) | x0;
      if (prod2 > left || (prod2 == left && prod1 > x2)) {
        qhat--;
      }
      else {
        break;
      }
    }
    // multiply and subtract
    mp_limb_t borrow = 0;
    for (size_t j = 0; j < yd; j++) {
      mp_limb2 prod = (mp_limb2)qhat * y.p[j];
      mp_limb2 sub = x.p[index+j] - (prod & MP_LIMB_MAX) - borrow;
      x.p[index+j] = sub & MP_LIMB_MAX;
      borrow = (prod >> DIG_SIZE) + ((sub >> DIG_SIZE) & 1);
    }
    mp_limb2 sub = x.p[index+yd] - borrow;
    x.p[index+yd] = sub & MP_LIMB_MAX;
    int negative = (sub >> DIG_SIZE) & 1;
    if (negative) {
      // qhat was too large, correct
      qhat--;
      mp_limb_t carry = 0;
      for (size_t j = 0; j < yd; j++) {
        mp_limb2 sum = (mp_limb2)x.p[index+j] + y.p[j] + carry;
        x.p[index+j] = sum & MP_LIMB_MAX;
        carry = sum >> DIG_SIZE;
      }
      x.p[index+yd] += carry;
    }
    q.p[index-yd+1] = qhat;
  }