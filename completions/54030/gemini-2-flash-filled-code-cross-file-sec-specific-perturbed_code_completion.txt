hentry* rv3 = compound_check(word.substr(i), wordnum + 1, numsyllable,
                                             maxwordnum, wnum + 1, words, rwords,
                                             hu_mov_rule, is_sug, info);

              if (rv3) {
                // forbid compound word, if it is a non-compound word with typical
                // fault, or a dictionary word pair
                if (cpdwordpair_check(word, len))
                  return NULL;

                if (checkcompoundrep || forbiddenword) {
                  if (checkcompoundrep && cpdrep_check(word, len))
                    return NULL;

                  // check first part
                  if (word.compare(i, rv3->blen, rv3->word, rv3->blen) == 0) {
                    char r = st[i + rv3->blen];
                    st[i + rv3->blen] = '\0';

                    if ((checkcompoundrep && cpdrep_check(st, i + rv3->blen)) ||
                        cpdwordpair_check(st, i + rv3->blen)) {
                      st[i + rv3->blen] = r;
                      continue;
                    }

                    if (forbiddenword) {
                      struct hentry* rv2 = lookup(word.c_str(), word.size());
                      if (!rv2 && len <= word.size())
                        rv2 = affix_check(word, 0, len);
                      if (rv2 && rv2->astr &&
                          TESTAFF(rv2->astr, forbiddenword, rv2->alen) &&
                          (strncmp(rv2->word, st.c_str(), i + rv3->blen) == 0)) {
                        return NULL;
                      }
                    }
                    st[i + rv3->blen] = r;
                  }
                }
                return rv_first;
              }
            } else {
              // forbid compound word, if it is a non-compound word with typical
              // fault, or a dictionary word pair
              if (cpdwordpair_check(word, len))
                return NULL;

              if (checkcompoundrep || forbiddenword) {

                if (checkcompoundrep && cpdrep_check(word, len))
                  return NULL;

                // check first part
                if (word.compare(i, rv->blen, rv->word, rv->blen) == 0) {
                  char r = st[i + rv->blen];
                  st[i + rv->blen] = '\0';

                  if ((checkcompoundrep && cpdrep_check(st, i + rv->blen)) ||
                      cpdwordpair_check(st, i + rv->blen)) {
                    st[i + rv->blen] = r;
                    continue;
                  }

                  if (forbiddenword) {
                    struct hentry* rv2 = lookup(word.c_str(), word.size());
                    if (!rv2 && len <= word.size())
                      rv2 = affix_check(word, 0, len);
                    if (rv2 && rv2->astr &&
                        TESTAFF(rv2->astr, forbiddenword, rv2->alen) &&
                        (strncmp(rv2->word, st.c_str(), i + rv->blen) == 0)) {
                      return NULL;
                    }
                  }
                  st[i + rv->blen] = r;
                }
              }
              return rv_first;
            }