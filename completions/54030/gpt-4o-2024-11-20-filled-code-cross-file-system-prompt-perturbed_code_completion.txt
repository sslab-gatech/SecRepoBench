if (rv) {
  // Validate the compound word against the compound pattern table
  if (!checkcpdtable.empty() && scpd == 0) {
    if (cpdpat_check(word, i, rv_first, rv, is_affixed)) {
      rv = NULL;
    }
  }

  // Check for forbidden words or patterns
  if (rv && (checkcompoundrep || forbiddenword)) {
    if (checkcompoundrep && cpdrep_check(word, len)) {
      return NULL;
    }

    // Check the first part of the compound word
    if (word.compare(i, rv->blen, rv->word, rv->blen) == 0) {
      char r = st[i + rv->blen];
      st[i + rv->blen] = '\0';

      if ((checkcompoundrep && cpdrep_check(st, i + rv->blen)) ||
          cpdwordpair_check(st, i + rv->blen)) {
        st[i + rv->blen] = r;
        continue;
      }

      if (forbiddenword) {
        struct hentry* rv2 = lookup(word.c_str(), word.size());
        if (!rv2 && len <= word.size()) {
          rv2 = affix_check(word, 0, len);
        }
        if (rv2 && rv2->astr &&
            TESTAFF(rv2->astr, forbiddenword, rv2->alen) &&
            (strncmp(rv2->word, st.c_str(), i + rv->blen) == 0)) {
          return NULL;
        }
      }
      st[i + rv->blen] = r;
    }
  }

  // If all checks pass, return the first part of the compound word
  return rv_first;
}