// Attempt to identify the second word as a compound word.
// Validate the result against the compound pattern table. If the result
// violates any defined compound pattern conditions, set the result to NULL.
if (rv) {
  // forbid compound word, if it is a non-compound word with typical fault, 
  // or a dictionary word pair
  if (cpdwordpair_check(word, len))
    return NULL;

  if (checkcompoundrep || forbiddenword) {
    // check first part
    if (word.compare(i, rv->blen, rv->word, rv->blen) == 0) {
      char r = st[i + rv->blen];
      st[i + rv->blen] = '\0';

      if ((checkcompoundrep && cpdrep_check(st, i + rv->blen)) ||
          cpdwordpair_check(st, i + rv->blen)) {
        st[i + rv->blen] = r;
        continue;
      }

      if (forbiddenword) {
        struct hentry* rv2 = lookup(word.c_str(), word.size());
        if (!rv2 && len <= word.size())
          rv2 = affix_check(word, 0, len);
        if (rv2 && rv2->astr &&
            TESTAFF(rv2->astr, forbiddenword, rv2->alen) &&
            (strncmp(rv2->word, st.c_str(), i + rv->blen) == 0)) {
          return NULL;
        }
      }
      st[i + rv->blen] = r;
    }
  }
  return rv_first;
}