// Check that there is enough room to read Blosc header
if (frame->cframe == NULL) {
  FILE* fp = fopen(frame->urlpath, "rb");
  fseek(fp, header_len + cbytes, SEEK_SET);
  size_t rbytes = fread(header, 1, BLOSC_MIN_HEADER_LENGTH, fp);
  fclose(fp);
  if (rbytes!= BLOSC_MIN_HEADER_LENGTH) {
    BLOSC_TRACE_ERROR("Cannot read the header for offsets chunk in the frame.");
    return NULL;
  }
}
else {
  if ((int64_t)header_len + cbytes + BLOSC_MIN_HEADER_LENGTH > frame->len) {
    BLOSC_TRACE_ERROR("Cannot read the header for offsets chunk in the (contiguous) frame.");
    return NULL;
  }
  memcpy(header, frame->cframe + header_len + cbytes, BLOSC_MIN_HEADER_LENGTH);
}

// Calculate the start pointer for the offsets based on the current frame position.
uint8_t* coffsets = NULL;
if (frame->cframe!= NULL) {
  coffsets = frame->cframe + header_len + cbytes;
}
else {
  coffsets = malloc(cbytes);
  FILE* fp = fopen(frame->urlpath, "rb");
  fseek(fp, header_len + cbytes, SEEK_SET);
  size_t rbytes = fread(coffsets, 1, cbytes, fp);
  fclose(fp);
  if (rbytes!= (size_t)cbytes) {
    BLOSC_TRACE_ERROR("Cannot read the offsets out of the frame.");
    free(coffsets);
    return NULL;
  }
}

// Return the computed start pointer for the offsets.
return coffsets;