rb");
    }
    if (fp != NULL) {
      fseek(fp, trailer_offset, SEEK_SET);
      rbytes = fread(trailer, 1, trailer_len, fp);
      fclose(fp);
    }
    if (rbytes != (size_t) trailer_len) {
      BLOSC_TRACE_ERROR("Cannot access the trailer out of the frame.");
      free(trailer);
      return BLOSC2_ERROR_FILE_READ;
    }
  }

  ret = get_vlmeta_from_trailer(frame, schunk, trailer, trailer_len);

  if (frame->cframe == NULL) {
    free(trailer);
  }

  return ret;
}


int frame_get_filters(blosc2_frame_s* frame, blosc2_schunk* schunk) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int32_t blocksize;
  int32_t chunksize;
  int32_t nchunks;
  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes,
                            &blocksize, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
    return ret;
  }

  // Get the header
  uint8_t* header = NULL;
  if (frame->cframe != NULL) {
    header = frame->cframe;
  } else {
    size_t rbytes = 0;
    header = malloc(header_len);
    FILE* fp = NULL;
    if (frame->sframe) {
      fp = sframe_open_index(frame->urlpath, "rb");
    }
    else {
      fp = fopen(frame->urlpath, "rb");
    }
    if (fp != NULL) {
      rbytes = fread(header, 1, header_len, fp);
      fclose(fp);
    }
    if (rbytes != (size_t) header_len) {
      BLOSC_TRACE_ERROR("Cannot access the header out of the frame.");
      free(header);
      return BLOSC2_ERROR_FILE_READ;
    }
  }

  uint8_t* framep = header;
  uint8_t frame_codecs = framep[FRAME_CODECS];
  uint8_t nfilters = framep[FRAME_FILTER_PIPELINE];
  if (nfilters > BLOSC2_MAX_FILTERS) {
    BLOSC_TRACE_ERROR("The number of filters in frame header are too large for Blosc2.");
    return BLOSC2_ERROR_INVALID_HEADER;
  }
  for (int i = 0; i < nfilters; i++) {
    schunk->filters[i] = frame_codecs & 0x0F;
    frame_codecs >>= 4u;
    schunk->filters_meta[i] = framep[FRAME_FILTER_PIPELINE + 1 + i];
  }

  if (frame->cframe == NULL) {
    free(header);
  }

  return 1;
}


int frame_get_cbytes(blosc2_frame_s* frame) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes,
                            NULL, NULL, NULL,
                            NULL, NULL, NULL, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
    return ret;
  }
  return (int)cbytes;
}


int frame_get_nbytes(blosc2_frame_s* frame) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes,
                            NULL, NULL, NULL,
                            NULL, NULL, NULL, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
    return ret;
  }
  return (int)nbytes;
}


int frame_get_chunksize(blosc2_frame_s* frame) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int32_t chunksize;
  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes,
                            NULL, &chunksize, NULL,
                            NULL, NULL, NULL, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
    return ret;
  }
  return chunksize;
}


int frame_get_nchunks(blosc2_frame_s* frame) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int32_t nchunks;
  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes,
                            NULL, NULL, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
    return ret;
  }
  return nchunks;
}


int frame_get_blocksize(blosc2_frame_s* frame) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int32_t blocksize;
  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes,
                            &blocksize, NULL, NULL,
                            NULL, NULL, NULL, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
    return ret;
  }
  return blocksize;
}


int frame_get_typesize(blosc2_frame_s* frame) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int32_t typesize;
  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes,
                            NULL, NULL, NULL,
                            &typesize, NULL, NULL, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
    return ret;
  }
  return typesize;
}


int frame_get_compcode(blosc2_frame_s* frame) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  uint8_t compcode;
  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes,
                            NULL, NULL, NULL,
                            NULL, &compcode, NULL, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
    return ret;
  }
  return compcode;
}


int frame_get_clevel(blosc2_frame_s* frame) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  uint8_t clevel;
  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes,
                            NULL, NULL, NULL,
                            NULL, NULL, &clevel, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
    return ret;
  }
  return clevel;
}


int frame_get_nthreads_c(blosc2_frame_s* frame) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int32_t nthreads;
  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes,
                            NULL, NULL, NULL,
                            NULL, NULL, NULL, NULL, &nthreads);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
    return ret;
  }
  return nthreads;
}


int frame_get_nthreads_d(blosc2_frame_s* frame) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int32_t nthreads;
  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes,
                            NULL, NULL, NULL,
                            NULL, NULL, NULL, NULL, &nthreads);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
    return ret;
  }
  return nthreads;
}


int frame_get_nvlmetalayers(blosc2_frame_s* frame) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int32_t nvlmetalayers;
  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes,
                            NULL, NULL, NULL,
                            NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, &nvlmetalayers);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
    return ret;
  }
  return nvlmetalayers;
}


int frame_get_filters_meta(blosc2_frame_s* frame, blosc2_schunk* schunk) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  uint8_t filters_meta[BLOSC2_MAX_FILTERS];
  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes,
                            NULL, NULL, NULL,
                            NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,