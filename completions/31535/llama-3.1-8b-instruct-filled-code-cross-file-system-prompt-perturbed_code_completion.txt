if (cbytes < INT64_MAX - header_len) {
  off_pos += cbytes;
}
// Check that there is enough room to read Blosc header
// Check if the computed offset position and header length are within valid boundaries.
// Calculate the start pointer for the offsets based on the current frame position.
// If provided, retrieve the compressed chunk size.
// Return the computed start pointer for the offsets.
uint8_t* offsets = malloc((size_t)BLOSC_EXTENDED_HEADER_LENGTH);
FILE* fp = NULL;
if (frame->sframe) {
  fp = sframe_open_index(frame->urlpath, "rb");
  fseek(fp, header_len + 0, SEEK_SET);
}
else {
  fp = fopen(frame->urlpath, "rb");
  fseek(fp, header_len + cbytes, SEEK_SET);
}
size_t rbytes = fread(offsets, 1, (size_t)BLOSC_EXTENDED_HEADER_LENGTH, fp);
fclose(fp);
if (rbytes!= (size_t)BLOSC_EXTENDED_HEADER_LENGTH) {
  BLOSC_TRACE_ERROR("Cannot read the offsets out of the frame.");
  free(offsets);
  return NULL;
}
blosc2_context* cctx = blosc2_create_cctx(BLOSC2_CPARAMS_DEFAULTS);
cctx->typesize = 8;
void* off_chunk = malloc((size_t)BLOSC_EXTENDED_HEADER_LENGTH + BLOSC_MAX_OVERHEAD);
int32_t new_off_cbytes = blosc2_compress_ctx(cctx, offsets, BLOSC_EXTENDED_HEADER_LENGTH,
                                             off_chunk, BLOSC_EXTENDED_HEADER_LENGTH + BLOSC_MAX_OVERHEAD);
blosc2_free_ctx(cctx);
free(offsets);
if (new_off_cbytes < 0) {
  free(off_chunk);
  return NULL;
}
frame->coffsets = off_chunk;
return off_chunk;