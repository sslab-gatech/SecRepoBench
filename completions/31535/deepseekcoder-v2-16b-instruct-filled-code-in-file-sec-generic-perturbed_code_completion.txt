_name);
    }
    else {
      fp = fopen(frame->urlpath, "rb");
    }
    if (fp != NULL) {
      fseek(fp, trailer_offset, SEEK_SET);
      rbytes = fread(trailer, 1, trailer_len, fp);
      fclose(fp);
    }
    if (rbytes != (size_t) trailer_len) {
      BLOSC_TRACE_ERROR("Cannot access the trailer out of the frame.");
      free(trailer);
      return BLOSC2_ERROR_FILE_READ;
    }
  }

  ret = get_vlmeta_from_trailer(frame, schunk, trailer, trailer_len);

  if (frame->cframe == NULL) {
    free(trailer);
  }

  return ret;
}


int frame_get_data(blosc2_frame_s* frame, blosc2_schunk* schunk, int32_t chunk_index,
                    uint8_t** data_chunk, int32_t* data_chunk_size) {
  int32_t nchunks = schunk->nchunks;
  int64_t cbytes = schunk->cbytes;
  int32_t chunksize = schunk->chunksize;
  int32_t chunk_cbytes;
  int rc;

  if (chunk_index < 0 || chunk_index >= nchunks) {
    BLOSC_TRACE_ERROR("Invalid chunk index.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  if (frame->coffsets == NULL) {
    get_coffsets(frame, 0, cbytes, &chunk_cbytes);
  }
  else {
    rc = blosc2_cbuffer_sizes(frame->coffsets, NULL, &chunk_cbytes, NULL);
    if (rc < 0) {
      return rc;
    }
  }

  int64_t coffset = ((int64_t)chunk_index) * sizeof(int64_t);
  if (frame->coffsets != NULL) {
    from_big((int64_t*)data_chunk, frame->coffsets + coffset, sizeof(int64_t));
    *data_chunk_size = chunk_cbytes;
    return 0;
  }

  int64_t trailer_offset = get_trailer_offset(frame, 0, true);
  if (trailer_offset < BLOSC_EXTENDED_HEADER_LENGTH || trailer_offset + chunk_cbytes > frame->len) {
    BLOSC_TRACE_ERROR("Cannot read the trailer out of the frame.");
    return BLOSC2_ERROR_READ_BUFFER;
  }

  FILE* fp = NULL;
  if (frame->sframe) {
    fp = sframe_open_index(frame->urlpath, "rb");
  }
  else {
    fp = fopen(frame->urlpath, "rb");
  }
  fseek(fp, trailer_offset + coffset, SEEK_SET);
  *data_chunk = malloc((size_t)chunk_cbytes);
  size_t rbytes = fread(*data_chunk, 1, (size_t)chunk_cbytes, fp);
  fclose(fp);
  if (rbytes != (size_t)chunk_cbytes) {
    BLOSC_TRACE_ERROR("Cannot read the data chunk out of the frame.");
    free(*data_chunk);
    return BLOSC2_ERROR_FILE_READ;
  }
  *data_chunk_size = chunk_cbytes;

  return 0;
}


int frame_get_data_chunk(blosc2_frame_s* frame, blosc2_schunk* schunk, int32_t chunk_index,
                         uint8_t** data_chunk, int32_t* data_chunk_size) {
  int32_t nchunks = schunk->nchunks;
  int64_t cbytes = schunk->cbytes;
  int32_t chunksize = schunk->chunksize;
  int32_t chunk_cbytes;
  int rc;

  if (chunk_index < 0 || chunk_index >= nchunks) {
    BLOSC_TRACE_ERROR("Invalid chunk index.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  if (frame->coffsets == NULL) {
    get_coffsets(frame, 0, cbytes, &chunk_cbytes);
  }
  else {
    rc = blosc2_cbuffer_sizes(frame->coffsets, NULL, &chunk_cbytes, NULL);
    if (rc < 0) {
      return rc;
    }
  }

  int64_t coffset = ((int64_t)chunk_index) * sizeof(int64_t);
  if (frame->coffsets != NULL) {
    from_big((int64_t*)data_chunk, frame->coffsets + coffset, sizeof(int64_t));
    *data_chunk_size = chunk_cbytes;
    return 0;
  }

  int64_t trailer_offset = get_trailer_offset(frame, 0, true);
  if (trailer_offset < BLOSC_EXTENDED_HEADER_LENGTH || trailer_offset + chunk_cbytes > frame->len) {
    BLOSC_TRACE_ERROR("Cannot read the trailer out of the frame.");
    return BLOSC2_ERROR_READ_BUFFER;
  }

  FILE* fp = NULL;
  if (frame->sframe) {
    fp = sframe_open_index(frame->urlpath, "rb");
  }
  else {
    fp = fopen(frame->urlpath, "rb");
  }
  fseek(fp, trailer_offset + coffset, SEEK_SET);
  *data_chunk = malloc((size_t)chunk_cbytes);
  size_t rbytes = fread(*data_chunk, 1, (size_t)chunk_cbytes, fp);
  fclose(fp);
  if (rbytes != (size_t)chunk_cbytes) {
    BLOSC_TRACE_ERROR("Cannot read the data chunk out of the frame.");
    free(*data_chunk);
    return BLOSC2_ERROR_FILE_READ;
  }
  *data_chunk_size = chunk_cbytes;

  return 0;
}


int frame_get_data_chunks(blosc2_frame_s* frame, blosc2_schunk* schunk, uint8_t** data_chunks,
                           int32_t* data_chunks_sizes) {
  int32_t nchunks = schunk->nchunks;
  int64_t cbytes = schunk->cbytes;
  int32_t chunksize = schunk->chunksize;
  int32_t chunk_cbytes;
  int rc;

  if (frame->coffsets == NULL) {
    get_coffsets(frame, 0, cbytes, &chunk_cbytes);
  }
  else {
    rc = blosc2_cbuffer_sizes(frame->coffsets, NULL, &chunk_cbytes, NULL);
    if (rc < 0) {
      return rc;
    }
  }

  if (frame->coffsets != NULL) {
    for (int i = 0; i < nchunks; i++) {
      from_big((int64_t*)data_chunks + i, frame->coffsets + i * sizeof(int64_t), sizeof(int64_t));
      data_chunks_sizes[i] = chunk_cbytes;
    }
    return 0;
  }

  int64_t trailer_offset = get_trailer_offset(frame, 0, true);
  if (trailer_offset < BLOSC_EXTENDED_HEADER_LENGTH || trailer_offset + chunk_cbytes > frame->len) {
    BLOSC_TRACE_ERROR("Cannot read the trailer out of the frame.");
    return BLOSC2_ERROR_READ_BUFFER;
  }

  FILE* fp = NULL;
  if (frame->sframe) {
    fp = sframe_open_index(frame->urlpath, "rb");
  }
  else {
    fp = fopen(frame->urlpath, "rb");
  }
  fseek(fp, trailer_offset, SEEK_SET);
  for (int i = 0; i < nchunks; i++) {
    fseek(fp, trailer_offset + ((int64_t)i) * sizeof(int64_t), SEEK_SET);
    data_chunks[i] = malloc((size_t)chunk_cbytes);
    size_t rbytes = fread(data_chunks[i], 1, (size_t)chunk_cbytes, fp);
    if (rbytes != (size_t)chunk_cbytes) {
      BLOSC_TRACE_ERROR("Cannot read the data chunk out of the frame.");
      for (int j = 0; j < i; j++) {
        free(data_chunks[j]);
      }
      fclose(fp);
      return BLOSC2_ERROR_FILE_READ;
    }
    data_chunks_sizes[i] = chunk_cbytes;
  }
  fclose(fp);

  return 0;
}


int frame_get_data_chunk_at(blosc2_frame_s* frame, blosc2_schunk* schunk, int64_t offset,
                            uint8_t** data_chunk, int32_t* data_chunk_size) {
  int32_t nchunks = schunk->nchunks;
  int64_t cbytes = schunk->cbytes;
  int32_t chunksize = schunk->chunksize;
  int32_t chunk_cbytes;
  int rc;

  if (offset < 0 || offset >= cbytes) {
    BLOSC_TRACE_ERROR("Invalid offset.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  if (frame->coffsets == NULL) {
    get_coffsets(frame, 0, cbytes, &chunk_cbytes);
  }
  else {
    rc = blosc2_cbuffer_sizes(frame->coffsets, NULL, &chunk_cbytes, NULL);
    if (rc < 0) {
      return rc;
    }
  }

  int64_t coffset = offset / sizeof(int64_t);
  if (frame->coffsets != NULL) {
    from_big((int64_t*)data_chunk, frame->coffsets + coffset, sizeof(int64_t));
    *data_chunk_size = chunk_cbytes;
    return 0;
  }

  int64_t trailer_offset = get_trailer_offset(frame, 0, true);
  if (trailer_offset < BLOSC_EXTENDED_HEADER_LENGTH || trailer_offset + chunk_cbytes > frame->len) {
    BLOSC_TRACE_ERROR("Cannot read the trailer out of the frame.");
    return BLOSC2_ERROR_READ_BUFFER;
  }

  FILE* fp = NULL;
  if (frame->sframe) {
    fp = sframe_open_index(frame->urlpath, "rb");
  }
  else {
    fp = fopen(frame->urlpath, "rb");
  }
  fseek(fp, trailer_offset + coffset, SEEK_SET);
  *data_chunk = malloc((size_t)chunk_cbytes);
  size_t rbytes = fread(*data_chunk, 1, (size_t)chunk_cbytes, fp);
  fclose(fp);
  if (rbytes != (size_t)chunk_cbytes) {
    BLOSC_TRACE_ERROR("Cannot read the data chunk out of the frame.");
    free(*data_chunk);
    return BLOSC2_ERROR_FILE_READ;
  }
  *data_chunk_size = chunk_cbytes;

  return 0;
}


int frame_get_data_chunk_at_index(blosc2_frame_s* frame, blosc2_schunk* schunk, int32_t chunk_index,
                                  uint8_t** data_chunk, int32_t* data_chunk_size) {
  int32_t nchunks = schunk->nchunks;
  int64_t cbytes = schunk->cbytes;
  int32_t chunksize