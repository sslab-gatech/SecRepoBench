// Check that there is enough room to read Blosc header
// Check if the computed offset position and header length are within valid boundaries.
// Calculate the start pointer for the offsets based on the current frame position.
// If provided, retrieve the compressed chunk size.
// Return the computed start pointer for the offsets.
uint8_t* get_coffsets(blosc2_frame_s *frame, int32_t header_len, int64_t cbytes, int32_t *compressed_chunk_size) {
  // Check that there is enough room to read Blosc header
  if (header_len + cbytes > frame->len) {
    BLOSC_TRACE_ERROR("Not enough space to read the Blosc header.");
    return NULL;
  }

  // Check if the computed offset position and header length are within valid boundaries.
  int64_t off_pos = header_len;
  if (cbytes < INT64_MAX - header_len) {
    off_pos += cbytes;
  }
  if (off_pos < 0 || off_pos > frame->len) {
    BLOSC_TRACE_ERROR("Computed offset position is out of bounds.");
    return NULL;
  }

  // Calculate the start pointer for the offsets based on the current frame position.
  uint8_t* coffsets = frame->cframe + off_pos;

  // If provided, retrieve the compressed chunk size.
  if (compressed_chunk_size!= NULL) {
    int32_t chunk_cbytes;
    int rc = blosc2_cbuffer_sizes(coffsets, NULL, &chunk_cbytes, NULL);
    if (rc < 0) {
      return NULL;
    }
    *compressed_chunk_size = (int32_t)chunk_cbytes;
  }

  // Return the computed start pointer for the offsets.
  return coffsets;
}