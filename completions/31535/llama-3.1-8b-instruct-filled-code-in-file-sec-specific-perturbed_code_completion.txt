// Get the offset to nchunk
uint8_t *coffsets = get_coffsets(frame, header_len, cbytes, &off_cbytes);
if (coffsets == NULL) {
  BLOSC_TRACE_ERROR("Cannot get the offset for chunk %d for the frame.", nchunk);
  return BLOSC2_ERROR_DATA;
}

// Get the 64-bit offset
int rc = blosc2_getitem(coffsets, off_cbytes, nchunk, 1, offset, (int32_t)sizeof(int64_t));
if (rc < 0) {
  BLOSC_TRACE_ERROR("Problems retrieving a chunk offset.");
} else if (*offset > frame->len) {
  BLOSC_TRACE_ERROR("Cannot read chunk %d outside of frame boundary.", nchunk);
  rc = BLOSC2_ERROR_READ_BUFFER;
}

// Check if the computed offset position and header length are within valid boundaries.
// Calculate the start pointer for the offsets based on the current frame position.
// If provided, retrieve the compressed chunk size.
// Return the computed start pointer for the offsets.
uint8_t* start_ptr = frame->cframe + header_len + *offset;
if (start_ptr + BLOSC_MIN_HEADER_LENGTH > frame->cframe + frame->len) {
  BLOSC_TRACE_ERROR("Cannot read the chunk out of the frame.");
  return BLOSC2_ERROR_READ_BUFFER;
}

// If provided, retrieve the compressed chunk size.
int32_t chunk_cbytes;
rc = blosc2_cbuffer_sizes(start_ptr, NULL, &chunk_cbytes, NULL);
if (rc < 0) {
  return rc;
}

// Return the computed start pointer for the offsets.
return start_ptr;