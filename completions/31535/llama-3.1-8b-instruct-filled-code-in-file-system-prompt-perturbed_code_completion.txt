// Get the 64-bit offset
int rc = blosc2_getitem(coffsets, off_cbytes, nchunk, 1, offset, (int32_t)sizeof(int64_t));
if (rc < 0) {
  BLOSC_TRACE_ERROR("Problems retrieving a chunk offset.");
}
else if (*offset > frame->len) {
  BLOSC_TRACE_ERROR("Cannot read chunk %d outside of frame boundary.", nchunk);
  rc = BLOSC2_ERROR_READ_BUFFER;
}

// Check if the computed offset position and header length are within valid boundaries.
// Calculate the start pointer for the offsets based on the current frame position.
// If provided, retrieve the compressed chunk size.
// Return the computed start pointer for the offsets.
if (frame->cframe!= NULL) {
  int64_t offset_pos = header_len + *offset;
  if (offset_pos + BLOSC_MIN_HEADER_LENGTH > frame->len) {
    BLOSC_TRACE_ERROR("Cannot read the header for chunk in the frame.");
    return BLOSC2_ERROR_READ_BUFFER;
  }
  uint8_t* coffsets_ptr = frame->cframe + offset_pos;
  if (compressed_chunk_size!= NULL) {
    rc = blosc2_cbuffer_sizes(coffsets_ptr, NULL, compressed_chunk_size, NULL);
    if (rc < 0) {
      return rc;
    }
  }
  return coffsets_ptr;
}
else {
  // The frame is on disk, so we need to read the offsets chunk
  int64_t offset_pos = header_len + *offset;
  if (offset_pos + BLOSC_MIN_HEADER_LENGTH > frame->len) {
    BLOSC_TRACE_ERROR("Cannot read the header for chunk in the frame.");
    return BLOSC2_ERROR_READ_BUFFER;
  }
  uint8_t* coffsets_ptr = NULL;
  if (frame->sframe) {
    // The chunk is not in the frame
    FILE* fp = sframe_open_chunk(frame->urlpath, offset, "rb");
    size_t rbytes = fread(coffsets_ptr, 1, BLOSC_MIN_HEADER_LENGTH, fp);
    fclose(fp);
    if (rbytes!= BLOSC_MIN_HEADER_LENGTH) {
      BLOSC_TRACE_ERROR("Cannot read the header for chunk in the frame.");
      return BLOSC2_ERROR_FILE_READ;
    }
  }
  else {
    // Regular frame
    FILE* fp = fopen(frame->urlpath, "rb");
    fseek(fp, offset_pos, SEEK_SET);
    size_t rbytes = fread(coffsets_ptr, 1, BLOSC_MIN_HEADER_LENGTH, fp);
    fclose(fp);
    if (rbytes!= BLOSC_MIN_HEADER_LENGTH) {
      BLOSC_TRACE_ERROR("Cannot read the header for chunk in the frame.");
      return BLOSC2_ERROR_FILE_READ;
    }
  }
  if (compressed_chunk_size!= NULL) {
    rc = blosc2_cbuffer_sizes(coffsets_ptr, NULL, compressed_chunk_size, NULL);
    if (rc < 0) {
      return rc;
    }
  }
  return coffsets_ptr;
}