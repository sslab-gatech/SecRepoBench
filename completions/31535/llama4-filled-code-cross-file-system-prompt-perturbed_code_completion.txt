// Check that there is enough room to read Blosc header
if (cbytes < 0 || header_len < 0 || header_len + cbytes > frame->len) {
  BLOSC_TRACE_ERROR("Cannot read the offsets out of the frame.");
  return NULL;
}
// Calculate the start pointer for the offsets based on the current frame position.
uint8_t* coffsets;
if (frame->cframe != NULL) {
  coffsets = frame->cframe + header_len + cbytes;
} else {
  coffsets = malloc((size_t)cbytes);
  if (coffsets == NULL) {
    BLOSC_TRACE_ERROR("Cannot malloc space for the offsets.");
    return NULL;
  }
  FILE* fp = NULL;
  if (frame->sframe) {
    fp = sframe_open_index(frame->urlpath, "rb");
    fseek(fp, header_len + 0, SEEK_SET);
  }
  else {
    fp = fopen(frame->urlpath, "rb");
    fseek(fp, header_len + cbytes, SEEK_SET);
  }
  size_t rbytes = fread(coffsets, 1, (size_t)cbytes, fp);
  fclose(fp);
  if (rbytes != (size_t)cbytes) {
    BLOSC_TRACE_ERROR("Cannot read the offsets out of the frame.");
    free(coffsets);
    return NULL;
  }
}
// If provided, retrieve the compressed chunk size.
if (compressed_chunk_size != NULL) {
  *compressed_chunk_size = (int32_t)cbytes;
}
frame->coffsets = coffsets;