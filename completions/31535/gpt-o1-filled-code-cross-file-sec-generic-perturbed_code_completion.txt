// Check that off_pos is within valid boundaries
    if (off_pos < 0 || off_pos >= frame->len) {
      BLOSC_TRACE_ERROR("Offset out of range in cframe.");
      return NULL;
    }

    // Check there is room for at least the minimal header
    if ((off_pos + BLOSC_MIN_HEADER_LENGTH) > frame->len) {
      BLOSC_TRACE_ERROR("Not enough space to read the chunk header in cframe.");
      return NULL;
    }

    uint8_t* offsets_ptr = frame->cframe + off_pos;

    // If we need the compressed chunk size, retrieve it
    if (compressed_chunk_size != NULL) {
      rc = blosc2_cbuffer_sizes(offsets_ptr, NULL, &chunk_cbytes, NULL);
      if (rc < 0) {
        BLOSC_TRACE_ERROR("Error getting cbuffer sizes from cframe offsets.");
        return NULL;
      }
      // Check that the entire chunk fits in cframe
      if (off_pos + chunk_cbytes > frame->len) {
        BLOSC_TRACE_ERROR("Not enough space for the offsets chunk in cframe.");
        return NULL;
      }
      *compressed_chunk_size = chunk_cbytes;
    }

    return offsets_ptr;