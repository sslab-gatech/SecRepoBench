// Check whatever the transform is 16 bits and involves linear RGB in first profile. If so, disable optimizations
if (EntryColorSpace == cmsSigRgbData && T_BYTES(InputFormat) == 2 &&!(dwFlags & cmsFLAGS_NOOPTIMIZE))
{
    cmsFloat64Number gamma = cmsDetectRGBProfileGamma(hProfiles[0], 0.1);

    if (gamma > 0 && gamma < 1.6)
        dwFlags |= cmsFLAGS_NOOPTIMIZE;
}
else
{
    // Formats are intended to be changed before use
    if 
    // Check if the input and output formats are uninitialized (set to zero).
    // If uninitialized, set input and output processing functions to default
    // and update flags to allow formatter change. Otherwise, obtain the
    // appropriate formatters for both input and output based on current formats.
    // If the formatters are unavailable, signal an error, delete the transformation,
    // and terminate the function. Determine bytes per pixel for the input format,
    // and if conditions are met, adjust flags to permit formatter changes.
    if (*dwFlags & cmsFLAGS_NULLTRANSFORM) {

        p ->xform = NullXFORM;
    }
    else {
        if (*dwFlags & cmsFLAGS_NOCACHE) {

            if (*dwFlags & cmsFLAGS_GAMUTCHECK)
                p ->xform = PrecalculatedXFORMGamutCheck;  // Gamut check, no cache
            else
                p ->xform = PrecalculatedXFORM;  // No cache, no gamut check
        }
        else {

            if (*dwFlags & cmsFLAGS_GAMUTCHECK)
                p ->xform = CachedXFORMGamutCheck;    // Gamut check, cache
            else
                p ->xform = CachedXFORM;  // No gamut check, cache

        }
    }
}