switch (ptr->sampleSize) {
case 4:
    // For 4-bit entries, read 2 samples at a time
    for (; index < ptr->sampleCount; index += 2) {
        // Read the first sample (4 bits)
        ptr->sizes[index] = gf_bs_read_int(bs, 4);
        if (ptr->max_size < ptr->sizes[index])
            ptr->max_size = ptr->sizes[index];
        ptr->total_size += ptr->sizes[index];
        ptr->total_samples++;
        
        // If there's another sample to read
        if (index + 1 < ptr->sampleCount) {
            // Read the second sample (4 bits)
            ptr->sizes[index + 1] = gf_bs_read_int(bs, 4);
            if (ptr->max_size < ptr->sizes[index + 1])
                ptr->max_size = ptr->sizes[index + 1];
            ptr->total_size += ptr->sizes[index + 1];
            ptr->total_samples++;
        } else {
            // Skip the padding if we have an odd number of samples
            gf_bs_read_int(bs, 4);
        }
    }
    break;
default:
    // For other bit widths (8 or 16)
    for (; index < ptr->sampleCount; index++) {
        ptr->sizes[index] = gf_bs_read_int(bs, ptr->sampleSize);
        if (ptr->max_size < ptr->sizes[index])
            ptr->max_size = ptr->sizes[index];
        ptr->total_size += ptr->sizes[index];
        ptr->total_samples++;
    }
    break;
}