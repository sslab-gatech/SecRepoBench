_size);
	return GF_OK;
}

GF_Err gnrv_box_size(GF_Box *s)
{
	GF_GenericVisualSampleEntryBox *ptr = (GF_GenericVisualSampleEntryBox *)s;
	s->type = GF_ISOM_BOX_TYPE_GNRV;
	gf_isom_video_sample_entry_size((GF_VisualSampleEntryBox *)ptr);
	ptr->size += 8+ptr->data_size;
	return GF_OK;
}

#endif /*GPAC_DISABLE_ISOM_WRITE*/

void hdlr_box_del(GF_Box *s)
{
	GF_HandlerBox *ptr = (GF_HandlerBox *) s;
	if (ptr->name) gf_free(ptr->name);
	gf_free(ptr);
}

GF_Box *hdlr_box_new()
{
	ISOM_DECL_BOX_ALLOC(GF_HandlerBox, GF_ISOM_BOX_TYPE_HDLR);
	return (GF_Box *)tmp;
}

GF_Err hdlr_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_HandlerBox *ptr = (GF_HandlerBox *)s;

	ISOM_DECREASE_SIZE(ptr, 24);
	ptr->pre_defined = gf_bs_read_u32(bs);
	ptr->handler_type = gf_bs_read_u32(bs);
	ptr->reserved = gf_bs_read_u32(bs);
	if (ptr->size) {
		u32 bytesToRead = (u32) ptr->size;
		ptr->name = (char*)gf_malloc(bytesToRead * sizeof(char));
		if (!ptr->name) return GF_OUT_OF_MEM;
		gf_bs_read_data(bs, ptr->name, bytesToRead);
		ptr->name[bytesToRead-1] = 0;
	}
	return GF_OK;
}

#ifndef GPAC_DISABLE_ISOM_WRITE

GF_Err hdlr_box_write(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	GF_HandlerBox *ptr = (GF_HandlerBox *) s;

	e = gf_isom_box_write_header(s, bs);
	if (e) return e;
	gf_bs_write_u32(bs, ptr->pre_defined);
	gf_bs_write_u32(bs, ptr->handler_type);
	gf_bs_write_u32(bs, ptr->reserved);
	if (ptr->name) {
		gf_bs_write_data(bs, ptr->name, (u32)strlen(ptr->name) + 1);
	}
	return GF_OK;
}

GF_Err hdlr_box_size(GF_Box *s)
{
	GF_HandlerBox *ptr = (GF_HandlerBox *) s;

	ptr->size += 12;
	if (ptr->name) {
		ptr->size += strlen(ptr->name) + 1;
	}
	return GF_OK;
}

#endif /*GPAC_DISABLE_ISOM_WRITE*/

void hinf_box_del(GF_Box *s)
{
	GF_HintInformationBox *ptr = (GF_HintInformationBox *) s;
	if (ptr->data) gf_free(ptr->data);
	gf_free(ptr);
}

GF_Box *hinf_box_new()
{
	ISOM_DECL_BOX_ALLOC(GF_HintInformationBox, GF_ISOM_BOX_TYPE_HINF);
	return (GF_Box *)tmp;
}

GF_Err hinf_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_HintInformationBox *ptr = (GF_HintInformationBox *)s;

	if (ptr->size) {
		u32 bytesToRead = (u32) ptr->size;
		ptr->data = (char*)gf_malloc(bytesToRead * sizeof(char));
		if (!ptr->data) return GF_OUT_OF_MEM;
		gf_bs_read_data(bs, ptr->data, bytesToRead);
		ptr->dataSize = bytesToRead;
	}
	return GF_OK;
}

#ifndef GPAC_DISABLE_ISOM_WRITE

GF_Err hinf_box_write(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	GF_HintInformationBox *ptr = (GF_HintInformationBox *) s;

	e = gf_isom_box_write_header(s, bs);
	if (e) return e;
	if (ptr->data) {
		gf_bs_write_data(bs, ptr->data, ptr->dataSize);
	}
	return GF_OK;
}

GF_Err hinf_box_size(GF_Box *s)
{
	GF_HintInformationBox *ptr = (GF_HintInformationBox *) s;

	ptr->size += ptr->dataSize;
	return GF_OK;
}

#endif /*GPAC_DISABLE_ISOM_WRITE*/

void iinf_box_del(GF_Box *s)
{
	GF_ItemInformationBox *ptr = (GF_ItemInformationBox *) s;
	if (ptr->data) gf_free(ptr->data);
	gf_free(ptr);
}

GF_Box *iinf_box_new()
{
	ISOM_DECL_BOX_ALLOC(GF_ItemInformationBox, GF_ISOM_BOX_TYPE_IINF);
	return (GF_Box *)tmp;
}

GF_Err iinf_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_ItemInformationBox *ptr = (GF_ItemInformationBox *)s;

	if (ptr->size) {
		u32 bytesToRead = (u32) ptr->size;
		ptr->data = (char*)gf_malloc(bytesToRead * sizeof(char));
		if (!ptr->data) return GF_OUT_OF_MEM;
		gf_bs_read_data(bs, ptr->data, bytesToRead);
		ptr->dataSize = bytesToRead;
	}
	return GF_OK;
}

#ifndef GPAC_DISABLE_ISOM_WRITE

GF_Err iinf_box_write(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	GF_ItemInformationBox *ptr = (GF_ItemInformationBox *) s;

	e = gf_isom_box_write_header(s, bs);
	if (e) return e;
	if (ptr->data) {
		gf_bs_write_data(bs, ptr->data, ptr->dataSize);
	}
	return GF_OK;
}

GF_Err iinf_box_size(GF_Box *s)
{
	GF_ItemInformationBox *ptr = (GF_ItemInformationBox *) s;

	ptr->size += ptr->dataSize;
	return GF_OK;
}

#endif /*GPAC_DISABLE_ISOM_WRITE*/

void iloc_box_del(GF_Box *s)
{
	GF_ItemLocationBox *ptr = (GF_ItemLocationBox *) s;
	if (ptr->entries) gf_free(ptr->entries);
	gf_free(ptr);
}

GF_Box *iloc_box_new()
{
	ISOM_DECL_BOX_ALLOC(GF_ItemLocationBox, GF_ISOM_BOX_TYPE_ILOC);
	return (GF_Box *)tmp;
}

GF_Err iloc_box_read(GF_Box *s, GF_BitStream *bs)
{
	u32 i;
	u32 entries;
	GF_ItemLocationBox *ptr = (GF_ItemLocationBox *)s;

	ISOM_DECREASE_SIZE(ptr, 4);
	ptr->entry_count = gf_bs_read_u32(bs);

	if (ptr->entry_count > ptr->size / 16) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[iso file] Invalid number of entries %d in iloc\n", ptr->entry_count));
		return GF_ISOM_INVALID_FILE;
	}

	ptr->entries = (GF_ItemLocationEntry *)gf_malloc(sizeof(GF_ItemLocationEntry) * ptr->entry_count);
	if (!ptr->entries) return GF_OUT_OF_MEM;

	for (i = 0; i < ptr->entry_count; i++) {
		ISOM_DECREASE_SIZE(ptr, 16);
		ptr->entries[i].item_ID = gf_bs_read_u32(bs);
		ptr->entries[i].construction_method = gf_bs_read_u32(bs);
		ptr->entries[i].data_reference_index = gf_bs_read_u32(bs);
		entries = gf_bs_read_u32(bs);
		ptr->entries[i].base_offset = gf_bs_read_u64(bs);
		if (entries > 0) {
			ptr->entries[i].extent_offsets = (u64 *)gf_malloc(sizeof(u64) * entries);
			if (!ptr->entries[i].extent_offsets) return GF_OUT_OF_MEM;
			for (u32 j = 0; j < entries; j++) {
				ptr->entries[i].extent_offsets[j] = gf_bs_read_u64(bs);
			}
		} else {
			ptr->entries[i].extent_offsets = NULL;
		}
	}
	return GF_OK;
}

#ifndef GPAC_DISABLE_ISOM_WRITE

GF_Err iloc_box_write(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	u32 i;
	GF_ItemLocationBox *ptr = (GF_ItemLocationBox *)s;

	e = gf_isom_full_box_write(s, bs);
	if (e) return e;
	gf_bs_write_u32(bs, ptr->entry_count);
	for (i = 0; i < ptr->entry_count; i++) {
		gf_bs_write_u32(bs, ptr->entries[i].item_ID);
		gf_bs_write_u32(bs, ptr->entries[i].construction_method);
		gf_bs_write_u32(bs, ptr->entries[i].data_reference_index);
		gf_bs_write_u32(bs, (u32) (ptr->entries[i].extent_offsets ? gf_list_count(ptr->entries[i].extent_offsets) : 0));
		gf_bs_write_u64(bs, ptr->entries[i].base_offset);
		if (ptr->entries[i].extent_offsets) {
			for (u32 j = 0; j < gf_list_count(ptr->entries[i].extent_offsets); j++) {
				gf_bs_write_u64(bs, gf_list_get(ptr->entries[i].extent_offsets, j));
			}
		}
	}
	return GF_OK;
}

GF_Err iloc_box_size(GF_Box *s)
{
	GF_ItemLocationBox *ptr = (GF_ItemLocationBox *)s;

	ptr->size += 4;
	for (u32 i = 0; i < ptr->entry_count; i++) {
		ptr->size += 16;
		if (ptr->entries[i].extent_offsets) {
			ptr->size += gf_list_count(ptr->entries[i].extent_offsets) * 8;
		}
	}
	return GF_OK;
}

#endif /*GPAC_DISABLE_ISOM_WRITE*/

void iprp_box_del(GF_Box *s)
{
	GF_ItemPropertyBox *ptr = (GF_ItemPropertyBox *) s;
	if (ptr->data) gf_free(ptr->data);
	gf_free(ptr);
}

GF_Box *iprp_box_new()
{
	ISOM_DECL_BOX_ALLOC(GF_ItemPropertyBox, GF_ISOM_BOX_TYPE_IPRP);
	return (GF_Box *)tmp;
}

GF_Err iprp