switch (ptr->sampleSize) {
			case 4:
			{
				/* 4 bits per sample, two samples per byte */
				while (index + 1 < ptr->sampleCount) {
					u8 val = gf_bs_read_u8(bs);
					ptr->sizes[index] = (val >> 4) & 0x0F;
					if (ptr->max_size < ptr->sizes[index]) ptr->max_size = ptr->sizes[index];
					ptr->total_size += ptr->sizes[index];
					ptr->total_samples++;
					index++;

					ptr->sizes[index] = val & 0x0F;
					if (ptr->max_size < ptr->sizes[index]) ptr->max_size = ptr->sizes[index];
					ptr->total_size += ptr->sizes[index];
					ptr->total_samples++;
					index++;
				}
				/* If there's an odd sample out, read one nibble and skip the other nibble */
				if (index < ptr->sampleCount) {
					u8 val = gf_bs_read_u8(bs);
					ptr->sizes[index] = (val >> 4) & 0x0F;
					if (ptr->max_size < ptr->sizes[index]) ptr->max_size = ptr->sizes[index];
					ptr->total_size += ptr->sizes[index];
					ptr->total_samples++;
					index++;
				}
			}
			break;

			case 8:
			{
				/* 8 bits per sample, one sample per byte */
				u32 count_left = ptr->sampleCount - index;
				while (count_left--) {
					u8 val = gf_bs_read_u8(bs);
					ptr->sizes[index] = val;
					if (ptr->max_size < val) ptr->max_size = val;
					ptr->total_size += val;
					ptr->total_samples++;
					index++;
				}
			}
			break;

			case 16:
			{
				/* 16 bits per sample, one sample per 2 bytes */
				u32 count_left = ptr->sampleCount - index;
				while (count_left--) {
					u16 val = gf_bs_read_u16(bs);
					ptr->sizes[index] = val;
					if (ptr->max_size < val) ptr->max_size = val;
					ptr->total_size += val;
					ptr->total_samples++;
					index++;
				}
			}
			break;

			default:
				/* This should never happen if stz2 is properly specified (4,8,16 bits),
				   but in case there is an error, we skip. */
				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER,
				       ("[iso file] stz2 box compact sampleSize field has invalid value %u\n",
				        ptr->sampleSize));
				return GF_ISOM_INVALID_FILE;
			}