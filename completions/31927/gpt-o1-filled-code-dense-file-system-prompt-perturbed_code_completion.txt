switch (ptr->sampleSize) {
case 4:
	/* Each byte holds two 4-bit sample sizes. If the sample count is odd,
	 * the last nibble is reserved for padding and must be read (and discarded). */
	while (index < ptr->sampleCount) {
		/* Read the first nibble. */
		ptr->sizes[index] = gf_bs_read_int(bs, 4);
		if (ptr->max_size < ptr->sizes[index]) ptr->max_size = ptr->sizes[index];
		ptr->total_size += ptr->sizes[index];
		ptr->total_samples++;
		index++;

		if (index < ptr->sampleCount) {
			/* Read the second nibble in this byte. */
			ptr->sizes[index] = gf_bs_read_int(bs, 4);
			if (ptr->max_size < ptr->sizes[index]) ptr->max_size = ptr->sizes[index];
			ptr->total_size += ptr->sizes[index];
			ptr->total_samples++;
			index++;
		} else {
			/* Discard the padding nibble if the sample count is odd. */
			(void) gf_bs_read_int(bs, 4);
		}
	}
	break;

default:
	/* For 8-bit, 16-bit, etc., read each sample size in one go. */
	for (; index < ptr->sampleCount; index++) {
		ptr->sizes[index] = gf_bs_read_int(bs, ptr->sampleSize);
		if (ptr->max_size < ptr->sizes[index]) ptr->max_size = ptr->sizes[index];
		ptr->total_size += ptr->sizes[index];
		ptr->total_samples++;
	}
	break;
}