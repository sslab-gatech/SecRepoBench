// <MASK>
while (rpl_tmp.nb_refs < sh->nb_refs[list_idx]) {
    // Iterate over the candidate reference picture lists (ST_CURR_BEF, ST_CURR_AFT, LT_CURR).
    // For each candidate list, append its references to a temporary reference picture list.
    // If the current picture reference is enabled by the PPS, add the current picture as a reference.
    if (s->rps[ST_CURR_BEF].nb_refs + s->rps[ST_CURR_AFT].nb_refs +
        s->rps[LT_CURR].nb_refs) {
        for (int cand_idx = 0; cand_idx < 3; cand_idx++) {
            const ShortTermRPS *rps = &s->rps[cand_lists[cand_idx]];
            if (cand_idx == LT_CURR &&!s->ps.pps->pps_curr_pic_ref_enabled_flag)
                continue;
            for (int i = 0; i < rps->nb_refs; i++) {
                if (rps->used[i]) {
                    if (cand_idx == LT_CURR) {
                        rpl_tmp.list[rpl_tmp.nb_refs] = rps->poc[i];
                        rpl_tmp.ref[rpl_tmp.nb_refs] = s->ref;
                    } else {
                        rpl_tmp.list[rpl_tmp.nb_refs] = rps->poc[i];
                        rpl_tmp.ref[rpl_tmp.nb_refs] = rps->used[i]? rps->ref[i] : NULL;
                    }
                    rpl_tmp.isLongTerm[rpl_tmp.nb_refs] = cand_idx == LT_CURR;
                    rpl_tmp.nb_refs++;
                }
            }
        }
    } else {
        if (s->ps.pps->pps_curr_pic_ref_enabled_flag) {
            rpl_tmp.list[rpl_tmp.nb_refs] = s->ref->poc;
            rpl_tmp.ref[rpl_tmp.nb_refs] = s->ref;
            rpl_tmp.isLongTerm[rpl_tmp.nb_refs] = 0;
            rpl_tmp.nb_refs++;
        }
    }
}