// <MASK>
if (embed_ref) {
    cram_block *b;
    if (slice->hdr->ref_base_id < 0) {
        hts_log_error("No reference specified and no embedded reference is available"
                      " at #%d:%"PRId64"-%"PRId64, ref_id, slice->hdr->ref_seq_start,
                      slice->hdr->ref_seq_start + slice->hdr->ref_seq_span-1);
        return -1;
    }
    b = cram_get_block_by_id(slice, slice->hdr->ref_base_id);
    if (!b)
        return -1;
    if (cram_uncompress_block(b)!= 0)
        return -1;
    // Assign the decompressed data from the block as the reference sequence for the slice.
    // Set the start and end positions of this reference sequence based on the slice header.
    // Log an error and return -1 if the embedded reference is too small.
    // <MASK>
    // Assign the decompressed data from the block as the reference sequence for the slice.
    // Set the start and end positions of this reference sequence based on the slice header.
    // Log an error and return -1 if the embedded reference is too small.
    slice->ref = BLOCK_DATA(b);
    slice->ref_start = 1;
    pthread_mutex_lock(&fd->ref_lock);
    pthread_mutex_lock(&fd->refs->lock);
    slice->ref_end = fd->refs->ref_id[cr->ref_id]->length;
    pthread_mutex_unlock(&fd->refs->lock);
    pthread_mutex_unlock(&fd->ref_lock);
}
// <MASK>