++;
            cig_len++;
            ref_pos++;
            seq_pos++;
            break;
        }

        case 'I': { // Insertion; IN
            int32_t out_sz2 = 1;
            int have_sc = 0;

            if (cig_len) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            switch (CRAM_MAJOR_VERS(fd->version)) {
            case 1:
                if (ds & CRAM_IN) {
                    r |= c->comp_hdr->codecs[DS_IN]
                       ? c->comp_hdr->codecs[DS_IN]
                                     ->decode(s, c->comp_hdr->codecs[DS_IN],
                                              blk,
                                              cr->len? &seq[pos-1] : NULL,
                                              &out_sz2)
                        : (seq[pos-1] = 'N', out_sz2 = 1, 0);
                    have_sc = 1;
                }
                break;
            case 2:
            default:
                if (ds & CRAM_SC) {
                    r |= c->comp_hdr->codecs[DS_SC]
                       ? c->comp_hdr->codecs[DS_SC]
                                     ->decode(s, c->comp_hdr->codecs[DS_SC],
                                              blk,
                                              cr->len? &seq[pos-1] : NULL,
                                              &out_sz2)
                        : (seq[pos-1] = 'N', out_sz2 = 1, 0);
                    have_sc = 1;
                }
                break;
            }
            if (have_sc) {
                if (r) return r;
                cigar[ncigar++] = (out_sz2<<4) + BAM_CINS;
                cig_op = BAM_CINS;
                seq_pos += out_sz2;
            }
            break;
        }

        case 'D': { // Deletion; DL
            int32_t out_sz2 = 1;
            int have_sc = 0;

            if (cig_len && cig_op!= BAM_CDEL) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_DL) {
                if (!c->comp_hdr->codecs[DS_DL]) return -1;
                r |= c->comp_hdr->codecs[DS_DL]
                                ->decode(s, c->comp_hdr->codecs[DS_DL], blk,
                                         (char *)&out_sz2, &out_sz);
                if (r) return r;
                cigar[ncigar++] = (out_sz2<<4) + BAM_CDEL;
                cig_op = BAM_CDEL;
                ref_pos += out_sz2;
            }
            break;
        }

        case 'N': { // Skip; DL
            int32_t out_sz2 = 1;
            int have_sc = 0;

            if (cig_len && cig_op!= BAM_CDEL) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_DL) {
                if (!c->comp_hdr->codecs[DS_DL]) return -1;
                r |= c->comp_hdr->codecs[DS_DL]
                                ->decode(s, c->comp_hdr->codecs[DS_DL], blk,
                                         (char *)&out_sz2, &out_sz);
                if (r) return r;
                cigar[ncigar++] = (out_sz2<<4) + BAM_CDEL;
                cig_op = BAM_CDEL;
                ref_pos += out_sz2;
            }
            break;
        }

        case 'P': { // Padding; DL
            int32_t out_sz2 = 1;
            int have_sc = 0;

            if (cig_len && cig_op!= BAM_CDEL) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_DL) {
                if (!c->comp_hdr->codecs[DS_DL]) return -1;
                r |= c->comp_hdr->codecs[DS_DL]
                                ->decode(s, c->comp_hdr->codecs[DS_DL], blk,
                                         (char *)&out_sz2, &out_sz);
                if (r) return r;
                cigar[ncigar++] = (out_sz2<<4) + BAM_CDEL;
                cig_op = BAM_CDEL;
                ref_pos += out_sz2;
            }
            break;
        }

        case 'M': { // Match; DL
            int32_t out_sz2 = 1;
            int have_sc = 0;

            if (cig_len && cig_op!= BAM_CMATCH) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_DL) {
                if (!c->comp_hdr->codecs[DS_DL]) return -1;
                r |= c->comp_hdr->codecs[DS_DL]
                                ->decode(s, c->comp_hdr->codecs[DS_DL], blk,
                                         (char *)&out_sz2, &out_sz);
                if (r) return r;
                cigar[ncigar++] = (out_sz2<<4) + BAM_CMATCH;
                cig_op = BAM_CMATCH;
                ref_pos += out_sz2;
            }
            break;
        }

        case '=': { // Match; DL
            int32_t out_sz2 = 1;
            int have_sc = 0;

            if (cig_len && cig_op!= BAM_CEQUAL) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_DL) {
                if (!c->comp_hdr->codecs[DS_DL]) return -1;
                r |= c->comp_hdr->codecs[DS_DL]
                                ->decode(s, c->comp_hdr->codecs[DS_DL], blk,
                                         (char *)&out_sz2, &out_sz);
                if (r) return r;
                cigar[ncigar++] = (out_sz2<<4) + BAM_CEQUAL;
                cig_op = BAM_CEQUAL;
                ref_pos += out_sz2;
            }
            break;
        }

        default:
            hts_log_error("Unknown CIGAR op '%c'", op);
            return -1;
        }
    }

 skip_cigar:
    if (cig_len) {
        cigar[ncigar++] = (cig_len<<4) + cig_op;
        cig_len = 0;
    }

    if (ref_pos > s->ref_end) {
        hts_log_error("CIGAR extends beyond reference end");
        return -1;
    }

    if (seq_pos < cr->len) {
        if (s->ref && cr->ref_id >= 0) {
            if (ref_pos + cr->len - seq_pos > bfd->ref[cr->ref_id].len) {
                static int whinged = 0;
                int rlen;
                if (!whinged)
                    hts_log_warning("Ref pos outside of ref sequence boundary");
                whinged = 1;
                rlen = bfd->ref[cr->ref_id].len - ref_pos;
                // May miss MD/NM cases where both seq/ref are N, but this is a
                // malformed cram file anyway.
                if (rlen > 0) {
                    if (ref_pos + rlen > s->ref_end)
                        goto beyond_slice;

                    memcpy(&seq[seq_pos-1],
                           &s->ref[ref_pos - s->ref_start +1], rlen);
                    if ((cr->len - seq_pos) - rlen > 0)
                        memset(&seq[seq_pos-1+rlen], 'N',
                               (cr->len - seq_pos) - rlen);
                } else {
                    memset(&seq[seq_pos-1], 'N', cr->len - seq_pos + 1);
                }
                if (md_dist >= 0)
                    md_dist += cr->len - seq_pos;
            } else {
                // 'N' in both ref and seq is also mismatch for NM/MD
                if (ref_pos + cr->len - seq_pos > s->ref_end)
                    goto beyond_slice;
                if (decode_md || decode_nm) {
                    int i;
                    for (i = 0; i < cr->len - seq_pos + 1; i++) {
                        // FIXME: not N, but nt16 lookup == 15?
                        char base = s->ref[ref_pos - s->ref_start + 1 + i];
                        if (base == 'N') {
                            if (add_md_char(s, decode_md,
                                            s->ref[ref_pos - s->ref_start + 1 + i],
                                            &md_dist) < 0)
                                return -1;
                            nm++;
                        } else {
                            md_dist++;
                        }
                        seq[seq_pos-1+i] = base;
                    }
                } else {
                    memcpy(&seq[seq_pos-1], &s->ref[ref_pos - s->ref_start +1],
                           cr->len - seq_pos + 1);
                }
            }
        }
    }

    if (decode_md) {
        if (md_dist >= 0)
            BLOCK_APPEND_UINT(s->aux_blk, md_dist);
        BLOCK_APPEND(s->aux_blk, "Z", 1);
    }

    if (decode_nm) {
        BLOCK_APPEND_UINT(s->aux_blk, nm);
        BLOCK_APPEND(s->aux_blk, "Z", 1);
    }

    if (orig_aux!= BLOCK_SIZE(s->aux_blk)) {
        if (BLOCK_SIZE(s->aux_blk) - orig_aux!= 3) {
            hts_log_error("MD/NM aux block size mismatch");
            return -1;
        }
    }

    if (ncigar > s->cigar_alloc) {
        s->cigar_alloc = ncigar;
        if (!(s->cigar = realloc(s->cigar, s->cigar_alloc * sizeof(*s->cigar))))
            return -1;
    }

    cr->cigar = s->cigar;
    cr->ncigar = ncigar;

    if (cr->ref_id >= 0 && cr->apos + cr->len > s->ref_end) {
        hts_log_error("Read extends beyond reference end");
        return -1;
    }

    return r;

 beyond_slice:
    hts_log_error("CIGAR extends beyond slice end");
    return -1;
}

// the below code fragment can be found in:
// cram/cram_decode.c
static int cram_decode_aux(cram_fd *fd, cram_container *c, cram_slice *s,
                           cram_block *blk, cram_record *cr,
                           int *has_MD, int *has_NM) {
    int r = 0, out_sz = 1;
    int32_t tag_id;
    int32_t tag_len;
    int32_t tag_type;
    int32_t tag_value;
    int32_t tag_value_len;
    int32_t tag_value_type;
    int32_t tag_value_len_type;
    int32_t tag_value_len_len;
    int32_t tag_value_len_type_len;
    int32_t tag_value_len_len_type;
    int32_t tag_value_len_len_len;
    int32_t tag_value_len_len_type_len;
    int32_t tag_value_len_len_len_type;
    int32_t tag_value_len_len_len_len;
    int32_t tag_value_len_len_len_type_len;
    int32_t tag_value_len_len_len_len_type;
    int32_t tag_value_len_len_len_len_len;
    int32_t tag_value_len_len_len_len_type_len;
    int32_t tag_value_len_len_len_len_len_type;
    int32_t tag_value_len_len_len_len_len_len;
    int32_t tag_value_len_len_len_len_len_type_len;
    int32_t tag_value_len_len_len_len_len_len_type;
    int32_t tag_value_len_len_len_len_len_len_len;
    int32_t tag_value_len_len_len_len_len_len_type_len;
    int32_t tag_value_len_len_len_len_len_len_len_type;
    int32_t tag_value_len_len_len_len_len_len_len_len;
    int32_t tag_value_len_len_len_len_len_len_len_type_len;
    int32_t tag_value_len_len_len_len_len_len_len_len_type;
    int32_t tag_value_len_len_len_len_len_len_len_len_len;
    int32_t tag_value_len_len_len_len_len_len_len_len_type_len;
    int32_t tag_value_len_len_len_len_len_len_len_len_len_type;
    int32_t tag_value_len_len_len_len_len_len_len_len_len_len;
    int32_t tag_value_len_len_len_len_len_len_len_len_len_type_len;
    int32_t tag_value_len_len_len_len_len_len_len_len_len_len_type;
    int32_t tag_value_len_len_len_len_len_len_len_len_len_len_len;
    int32_t tag_value_len_len_len_len_len_len_len_len_len_len_type_len;
    int32_t tag_value_len_len_len_len_len_len_len_len_len_len_len_type;
    int32_t tag_value_len_len_len_len_len_len_len_len_len_len_len_len;
    int32_t tag_value_len_len_len_len_len_len_len_len_len_len_len_type_len;
    int32_t tag_value_len_len_len_len_len_len_len_len_len_len_len_len_type;
    int32_t tag_value_len_len_len_len_len_len_len_len_len_len_len_len_len;
    int32_t tag_value_len_len_len_len_len_len_len_len_len_len_len_len_type_len;
    int32_t tag_value_len_len_len_len_len_len_len_len_len_len_len_len_len_type;
    int32_t tag_value_len_len_len_len_len_len_len_len_len_len_len_len_len_len;
    int32_t tag_value_len_len_len_len_len_len_len_len_len_len_len_len_len_type_len;
    int32_t tag_value_len_len_len_len_len_len_len_len_len_len_len_len_len_len_type;
    int32_t tag_value_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len;
    int32_t tag_value_len_len_len_len_len_len_len_len_len_len_len_len_len_len_type_len;
    int32_t tag_value_len_len_len_len_len_len_len_len_len