if (embed_ref) {
    cram_block *b;
    if (slice->hdr->ref_base_id < 0) {
        hts_log_error("No reference specified and no embedded reference is available"
                      " at #%d:%"PRId64"-%"PRId64, ref_id, slice->hdr->ref_seq_start,
                      slice->hdr->ref_seq_start + slice->hdr->ref_seq_span-1);
        return -1;
    }
    b = cram_get_block_by_id(slice, slice->hdr->ref_base_id);
    if (!b)
        return -1;
    if (cram_uncompress_block(b)!= 0)
        return -1;
    // Assign the decompressed data from the block as the reference sequence for the slice.
    // Set the start and end positions of this reference sequence based on the slice header.
    // Log an error and return -1 if the embedded reference is too small.
    if (slice->ref_end - slice->ref_start + 1 < slice->hdr->ref_seq_span) {
        hts_log_error("Embedded reference too small at #%d:%d-%d",
                      ref_id, slice->ref_start, slice->ref_end);
        return -1;
    }
    slice->ref = (char *)b->data;
    slice->ref_start = 1;
    slice->ref_end = slice->hdr->ref_seq_start + slice->hdr->ref_seq_span-1;
}