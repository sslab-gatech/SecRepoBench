return -1;
                r |= c->comp_hdr->codecs[DS_BA]
                                ->decode(s, c->comp_hdr->codecs[DS_BA], blk,
                                         &seq[pos-1], &out_sz);
                if (r) return r;
                cig_op = BAM_CINS;
                cig_len++;
                seq_pos++;
                nm++;
            }
            break;
        }

        case 'P': { // Pad; PD
            if (cig_len && cig_op != BAM_CPAD) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_PD) {
                if (!c->comp_hdr->codecs[DS_PD]) return -1;
                r |= c->comp_hdr->codecs[DS_PD]
                                ->decode(s, c->comp_hdr->codecs[DS_PD], blk,
                                         (char *)&i32, &out_sz);
                if (r) return r;
                cig_op = BAM_CPAD;
                cig_len += i32;
                seq_pos += i32;
            }
            break;
        }

        case 'H': { // Hard clip: HC
            if (cig_len && cig_op != BAM_CHARD_CLIP) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_HC) {
                if (!c->comp_hdr->codecs[DS_HC]) return -1;
                r |= c->comp_hdr->codecs[DS_HC]
                                ->decode(s, c->comp_hdr->codecs[DS_HC], blk,
                                         (char *)&i32, &out_sz);
                if (r) return r;
                cig_op = BAM_CHARD_CLIP;
                cig_len += i32;
                seq_pos += i32;
            }
            break;
        }

        case 'Q': { // Quality; QS
            if (cig_len && cig_op != BAM_CQUAL) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_QS) {
                if (!c->comp_hdr->codecs[DS_QS]) return -1;
                r |= c->comp_hdr->codecs[DS_QS]
                                ->decode(s, c->comp_hdr->codecs[DS_QS], blk,
                                         cr->len ? &qual[pos-1] : NULL,
                                         &out_sz);
                if (r) return r;
                cig_op = BAM_CQUAL;
                cig_len += out_sz;
                seq_pos += out_sz;
            }
            break;
        }

        case 'R': { // Reference; RI
            if (cig_len && cig_op != BAM_CREF_BASE) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_RI) {
                if (!c->comp_hdr->codecs[DS_RI]) return -1;
                r |= c->comp_hdr->codecs[DS_RI]
                                ->decode(s, c->comp_hdr->codecs[DS_RI], blk,
                                         (char *)&i32, &out_sz);
                if (r) return r;
                cig_op = BAM_CREF_BASE;
                cig_len += i32;
                seq_pos += i32;
            }
            break;
        }

        case 'L': { // Link; RL
            if (cig_len && cig_op != BAM_CLINK) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_RL) {
                if (!c->comp_hdr->codecs[DS_RL]) return -1;
                r |= c->comp_hdr->codecs[DS_RL]
                                ->decode(s, c->comp_hdr->codecs[DS_RL], blk,
                                         (char *)&i32, &out_sz);
                if (r) return r;
                cig_op = BAM_CLINK;
                cig_len += i32;
                seq_pos += i32;
            }
            break;
        }

        case 'N': { // Skip; TN
            if (cig_len && cig_op != BAM_CREF_SKIP) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_TN) {
                if (!c->comp_hdr->codecs[DS_TN]) return -1;
                r |= c->comp_hdr->codecs[DS_TN]
                                ->decode(s, c->comp_hdr->codecs[DS_TN], blk,
                                         (char *)&i32, &out_sz);
                if (r) return r;
                cig_op = BAM_CREF_SKIP;
                cig_len += i32;
                seq_pos += i32;
            }
            break;
        }

        case 'F': { // Feature; FN
            if (cig_len && cig_op != BAM_CSEQ) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_FN) {
                if (!c->comp_hdr->codecs[DS_FN]) return -1;
                r |= c->comp_hdr->codecs[DS_FN]
                                ->decode(s, c->comp_hdr->codecs[DS_FN], blk,
                                         (char *)&fn, &out_sz);
                if (r) return r;
                cig_op = BAM_CSEQ;
                cig_len += fn;
                seq_pos += fn;
            }
            break;
        }

        case 'C': { // CIGAR; TC
            if (cig_len && cig_op != BAM_CCIGAR) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_TC) {
                if (!c->comp_hdr->codecs[DS_TC]) return -1;
                r |= c->comp_hdr->codecs[DS_TC]
                                ->decode(s, c->comp_hdr->codecs[DS_TC], blk,
                                         (char *)&i32, &out_sz);
                if (r) return r;
                cig_op = BAM_CCIGAR;
                cig_len += i32;
                seq_pos += i32;
            }
            break;
        }

        case 'A': { // Aux; AC
            if (cig_len && cig_op != BAM_CAUX) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_AC) {
                if (!c->comp_hdr->codecs[DS_AC]) return -1;
                r |= c->comp_hdr->codecs[DS_AC]
                                ->decode(s, c->comp_hdr->codecs[DS_AC], blk,
                                         (char *)&i32, &out_sz);
                if (r) return r;
                cig_op = BAM_CAUX;
                cig_len += i32;
                seq_pos += i32;
            }
            break;
        }

        case 'M': { // Match; MF
            if (cig_len && cig_op != BAM_CMATCH) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_MF) {
                if (!c->comp_hdr->codecs[DS_MF]) return -1;
                r |= c->comp_hdr->codecs[DS_MF]
                                ->decode(s, c->comp_hdr->codecs[DS_MF], blk,
                                         (char *)&i32, &out_sz);
                if (r) return r;
                cig_op = BAM_CMATCH;
                cig_len += i32;
                seq_pos += i32;
            }
            break;
        }

        case 'V': { // Variant; TV
            if (cig_len && cig_op != BAM_CREF_SKIP) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_TV) {
                if (!c->comp_hdr->codecs[DS_TV]) return -1;
                r |= c->comp_hdr->codecs[DS_TV]
                                ->decode(s, c->comp_hdr->codecs[DS_TV], blk,
                                         (char *)&i32, &out_sz);
                if (r) return r;
                cig_op = BAM_CREF_SKIP;
                cig_len += i32;
                seq_pos += i32;
            }
            break;
        }

        case 'T': { // Tag; TN
            if (cig_len && cig_op != BAM_CTAG) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_TN) {
                if (!c->comp_hdr->codecs[DS_TN]) return -1;
                r |= c->comp_hdr->codecs[DS_TN]
                                ->decode(s, c->comp_hdr->codecs[DS_TN], blk,
                                         (char *)&i32, &out_sz);
                if (r) return r;
                cig_op = BAM_CTAG;
                cig_len += i32;
                seq_pos += i32;
            }
            break;
        }

        case 'B': { // Block; BB
            if (cig_len && cig_op != BAM_CBLOCK) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_BB) {
                if (!c->comp_hdr->codecs[DS_BB]) return -1;
                r |= c->comp_hdr->codecs[DS_BB]
                                ->decode(s, c->comp_hdr->codecs[DS_BB], blk,
                                         (char *)&i32, &out_sz);
                if (r) return r;
                cig_op = BAM_CBLOCK;
                cig_len += i32;
                seq_pos += i32;
            }
            break;
        }

        case 'Q': { // Quality; QQ
            if (cig_len && cig_op != BAM_CQUAL) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_QQ) {
                if (!c->comp_hdr->codecs[DS_QQ]) return -1;
                r |= c->comp_hdr->codecs[DS_QQ]
                                ->decode(s, c->comp_hdr->codecs[DS_QQ], blk,
                                         cr->len ? &qual[pos-1] : NULL,
                                         &out_sz);
                if (r) return r;
                cig_op = BAM_CQUAL;
                cig_len += out_sz;
                seq_pos += out_sz;
            }
            break;
        }

        case 'L': { // Link; TL
            if (cig_len && cig_op != BAM_CLINK) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_TL) {
                if (!c->comp_hdr->codecs[DS_TL]) return -1;
                r |= c->comp_hdr->codecs[DS_TL]
                                ->decode(s