AM_BA) {
                if (!c->comp_hdr->codecs[DS_BA]) return -1;
                r |= c->comp_hdr->codecs[DS_BA]
                                ->decode(s, c->comp_hdr->codecs[DS_BA], blk,
                                         &seq[pos-1], &out_sz);
                if (r) return r;
                cig_op = BAM_CINS;
                cig_len++;
                seq_pos++;
                nm++;
            }
            break;
        }

        case 'P': { // Pad; PD
            if (cig_len && cig_op != BAM_CPAD) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_PD) {
                if (!c->comp_hdr->codecs[DS_PD]) return -1;
                r |= c->comp_hdr->codecs[DS_PD]
                                ->decode(s, c->comp_hdr->codecs[DS_PD], blk,
                                         (char *)&i32, &out_sz);
                if (r) return r;
                cig_op = BAM_CPAD;
                cig_len += i32;
                seq_pos += i32;
            }
            break;
        }

        case 'H': { // Hard clip: HC
            if (cig_len && cig_op != BAM_CHARD_CLIP) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_HC) {
                if (!c->comp_hdr->codecs[DS_HC]) return -1;
                r |= c->comp_hdr->codecs[DS_HC]
                                ->decode(s, c->comp_hdr->codecs[DS_HC], blk,
                                         (char *)&i32, &out_sz);
                if (r) return r;
                cig_op = BAM_CHARD_CLIP;
                cig_len += i32;
                seq_pos += i32;
            }
            break;
        }

        case 'Q': { // Quality; QQ
            if (cig_len && cig_op != BAM_CREF_SKIP) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_QQ) {
                if (!c->comp_hdr->codecs[DS_QQ]) return -1;
                r |= c->comp_hdr->codecs[DS_QQ]
                                ->decode(s, c->comp_hdr->codecs[DS_QQ], blk,
                                         cr->len ? &qual[pos-1] : NULL,
                                         &out_sz);
                if (r) return r;
                cig_op = BAM_CREF_SKIP;
                cig_len += out_sz;
                seq_pos += out_sz;
            }
            break;
        }

        case 'T': { // Template length; TS
            if (cig_len && cig_op != BAM_CTEMPLATE) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_TS) {
                if (!c->comp_hdr->codecs[DS_TS]) return -1;
                r |= c->comp_hdr->codecs[DS_TS]
                                ->decode(s, c->comp_hdr->codecs[DS_TS], blk,
                                         (char *)&i32, &out_sz);
                if (r) return r;
                cig_op = BAM_CTEMPLATE;
                cig_len += i32;
                seq_pos += i32;
            }
            break;
        }

        case 'M': { // Match; TC
            if (cig_len && cig_op != BAM_CMATCH) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_TC) {
                if (!c->comp_hdr->codecs[DS_TC]) return -1;
                r |= c->comp_hdr->codecs[DS_TC]
                                ->decode(s, c->comp_hdr->codecs[DS_TC], blk,
                                         cr->len ? &seq[pos-1] : NULL,
                                         &out_sz);
                if (r) return r;
                cig_op = BAM_CMATCH;
                cig_len += out_sz;
                seq_pos += out_sz;
            }
            break;
        }

        case 'N': { // Skip; TN
            if (cig_len && cig_op != BAM_CREF_SKIP) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_TN) {
                if (!c->comp_hdr->codecs[DS_TN]) return -1;
                r |= c->comp_hdr->codecs[DS_TN]
                                ->decode(s, c->comp_hdr->codecs[DS_TN], blk,
                                         (char *)&i32, &out_sz);
                if (r) return r;
                cig_op = BAM_CREF_SKIP;
                cig_len += i32;
                seq_pos += i32;
            }
            break;
        }

        case 'F': { // Feature; FC
            if (cig_len && cig_op != BAM_CBASE_SKIP) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_FC) {
                if (!c->comp_hdr->codecs[DS_FC]) return -1;
                r |= c->comp_hdr->codecs[DS_FC]
                                ->decode(s, c->comp_hdr->codecs[DS_FC], blk,
                                         cr->len ? &seq[pos-1] : NULL,
                                         &out_sz);
                if (r) return r;
                cig_op = BAM_CBASE_SKIP;
                cig_len += out_sz;
                seq_pos += out_sz;
            }
            break;
        }

        case 'A': { // Alignment; AS
            if (cig_len && cig_op != BAM_CSOFT_CLIP) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_AS) {
                if (!c->comp_hdr->codecs[DS_AS]) return -1;
                r |= c->comp_hdr->codecs[DS_AS]
                                ->decode(s, c->comp_hdr->codecs[DS_AS], blk,
                                         cr->len ? &seq[pos-1] : NULL,
                                         &out_sz);
                if (r) return r;
                cig_op = BAM_CSOFT_CLIP;
                cig_len += out_sz;
                seq_pos += out_sz;
            }
            break;
        }

        case 'V': { // Vector; VV
            if (cig_len && cig_op != BAM_CDEL) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_VV) {
                if (!c->comp_hdr->codecs[DS_VV]) return -1;
                r |= c->comp_hdr->codecs[DS_VV]
                                ->decode(s, c->comp_hdr->codecs[DS_VV], blk,
                                         cr->len ? &seq[pos-1] : NULL,
                                         &out_sz);
                if (r) return r;
                cig_op = BAM_CDEL;
                cig_len += out_sz;
                seq_pos += out_sz;
            }
            break;
        }

        case 'R': { // Reference; RS
            if (cig_len && cig_op != BAM_CREF_SKIP) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_RS) {
                if (!c->comp_hdr->codecs[DS_RS]) return -1;
                r |= c->comp_hdr->codecs[DS_RS]
                                ->decode(s, c->comp_hdr->codecs[DS_RS], blk,
                                         cr->len ? &seq[pos-1] : NULL,
                                         &out_sz);
                if (r) return r;
                cig_op = BAM_CREF_SKIP;
                cig_len += out_sz;
                seq_pos += out_sz;
            }
            break;
        }

        case 'L': { // Link; LL
            if (cig_len && cig_op != BAM_CSOFT_CLIP) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_LL) {
                if (!c->comp_hdr->codecs[DS_LL]) return -1;
                r |= c->comp_hdr->codecs[DS_LL]
                                ->decode(s, c->comp_hdr->codecs[DS_LL], blk,
                                         cr->len ? &seq[pos-1] : NULL,
                                         &out_sz);
                if (r) return r;
                cig_op = BAM_CSOFT_CLIP;
                cig_len += out_sz;
                seq_pos += out_sz;
            }
            break;
        }

        case 'G': { // Gap; RG
            if (cig_len && cig_op != BAM_CREF_SKIP) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_RG) {
                if (!c->comp_hdr->codecs[DS_RG]) return -1;
                r |= c->comp_hdr->codecs[DS_RG]
                                ->decode(s, c->comp_hdr->codecs[DS_RG], blk,
                                         cr->len ? &seq[pos-1] : NULL,
                                         &out_sz);
                if (r) return r;
                cig_op = BAM_CREF_SKIP;
                cig_len += out_sz;
                seq_pos += out_sz;
            }
            break;
        }

        case 'B': { // Block; BB
            if (cig_len && cig_op != BAM_CSOFT_CLIP) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_BB) {
                if (!c->comp_hdr->codecs[DS_BB]) return -1;
                r |= c->comp_hdr->codecs[DS_BB]
                                ->decode(s, c->comp_hdr->codecs[DS_BB], blk,
                                         cr->len ? &seq[pos-1] : NULL,
                                         &out_sz);
                if (r) return r;
                cig_op = BAM_CSOFT_CLIP;
                cig_len += out_sz;
                seq_pos += out_sz;
            }
            break;
        }

        case 'Q': { // Query; QQ
            if (cig_len && cig_op != BAM_CSOFT_CLIP) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_QQ) {
                if (!c->comp_hdr->codecs[DS_QQ]) return -1;
                r |= c->comp_hdr->codecs[DS_QQ]
                                ->decode(s, c->comp_hdr->codecs[DS_QQ], blk,
                                         cr->len ? &seq[pos-1] : NULL,
                                         &out_sz);
                if (r) return r;
                cig_op = BAM_CSOFT_CLIP;
                cig_len += out_sz;
                seq_pos +=