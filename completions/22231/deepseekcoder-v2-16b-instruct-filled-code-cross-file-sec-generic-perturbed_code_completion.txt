if (blk->content_type != CORE)
    return -1;

if (slice->crecs)
    free(slice->crecs);
if (!(slice->crecs = malloc(slice->hdr->num_records * sizeof(*slice->crecs))))
    return -1;

ref_id = slice->hdr->ref_seq_id;
embed_ref = slice->hdr->ref_base_id >= 0 ? 1 : 0;

if (ref_id >= 0) {
    if (embed_ref) {
        cram_block *b;
        if (slice->hdr->ref_base_id < 0) {
            hts_log_error("No reference specified and no embedded reference is available"
                          " at #%d:%"PRId64"-%"PRId64, ref_id, slice->hdr->ref_seq_start,
                          slice->hdr->ref_seq_start + slice->hdr->ref_seq_span-1);
            return -1;
        }
        b = cram_get_block_by_id(slice, slice->hdr->ref_base_id);
        if (!b)
            return -1;
        if (cram_uncompress_block(b) != 0)
            return -1;
        // Assign the decompressed data from the block as the reference sequence for the slice.
        // Set the start and end positions of this reference sequence based on the slice header.
        // Log an error and return -1 if the embedded reference is too small.
        if (slice->hdr->ref_seq_start + slice->hdr->ref_seq_span - 1 >= b->uncomp_size) {
            hts_log_error("Embedded reference is too small to fit the slice");
            return -1;
        }
        slice->ref = b->data + slice->hdr->ref_seq_start;
        slice->ref_start = slice->hdr->ref_seq_start;
        slice->ref_end = slice->hdr->ref_seq_start + slice->hdr->ref_seq_span - 1;
    } else if (!c->comp_hdr->no_ref) {
        if (fd->required_fields & SAM_SEQ) {
            slice->ref =
            cram_get_ref(fd, slice->hdr->ref_seq_id,
                         slice->hdr->ref_seq_start,
                         slice->hdr->ref_seq_start + slice->hdr->ref_seq_span -1);
        }
        slice->ref_start = slice->hdr->ref_seq_start;
        slice->ref_end   = slice->hdr->ref_seq_start + slice->hdr->ref_seq_span-1;

        /* Sanity check */
        if (slice->ref_start < 0) {
            hts_log_warning("Slice starts before base 1"
                            " at #%d:%"PRId64"-%"PRId64, ref_id, slice->hdr->ref_seq_start,
                            slice->hdr->ref_seq_start + slice->hdr->ref_seq_span-1);
            slice->ref_start = 0;
        }
        pthread_mutex_lock(&fd->ref_lock);
        pthread_mutex_lock(&fd->refs->lock);
        if ((fd->required_fields & SAM_SEQ) &&
            ref_id < fd->refs->nref &&
            slice->ref_end > fd->refs->ref_id[ref_id]->length) {
            slice->ref_end = fd->refs->ref_id[ref_id]->length;
        }
        pthread_mutex_unlock(&fd->refs->lock);
        pthread_mutex_unlock(&fd->ref_lock);
    }
}

if ((fd->required_fields & SAM_SEQ) &&
    slice->ref == NULL && slice->hdr->ref_seq_id >= 0 && !c->comp_hdr->no_ref) {
    hts_log_error("Unable to fetch reference #%d:%"PRId64"-%"PRId64"\n",
                  ref_id, slice->hdr->ref_seq_start,
                  slice->hdr->ref_seq_start + slice->hdr->ref_seq_span-1);
    return -1;
}

if (CRAM_MAJOR_VERS(fd->version) != 1
    && (fd->required_fields & SAM_SEQ)
    && slice->hdr->ref_seq_id >= 0
    && !fd->ignore_md5
    && memcmp(slice->hdr->md5, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 16)) {
    hts_md5_context *md5;
    unsigned char digest[16];

    if (slice->ref && slice->hdr->ref_seq_id >= 0) {
        int start, len;

        if (slice->hdr->ref_seq_start >= slice->ref_start) {
            start = slice->hdr->ref_seq_start - slice->ref_start;
        } else {
            hts_log_warning("Slice starts before base 1 at #%d:%d-%d",
                            ref_id, slice->ref_start, slice->ref_end);
            start = 0;
        }

        if (slice->hdr->ref_seq_span <= slice->ref_end - slice->ref_start + 1) {
            len = slice->hdr->ref_seq_span;
        } else {
            hts_log_warning("Slice ends beyond reference end at #%d:%d-%d",
                            ref_id, slice->ref_start, slice->ref_end);
            len = slice->ref_end - slice->ref_start + 1;
        }

        if (!(md5 = hts_md5_init()))
            return -1;
        if (start + len > slice->ref_end - slice->ref_start + 1)
            len = slice->ref_end - slice->ref_start + 1 - start;
        if (len >= 0)
            hts_md5_update(md5, slice->ref + start, len);
        hts_md5_final(digest, md5);
        hts_md5_destroy(md5);
    } else if (!slice->ref && slice->hdr->ref_base_id >= 0) {
        cram_block *b = cram_get_block_by_id(slice, slice->hdr->ref_base_id);
        if (b) {
            if (!(md5 = hts_md5_init()))
                return -1;
            hts_md5_update(md5, b->data, b->uncomp_size);
            hts_md5_final(digest, md5);
            hts_md5_destroy(md5);
        }
    }

    if ((!slice->ref && slice->hdr->ref_base_id < 0)
        || memcmp(digest, slice->hdr->md5, 16) != 0) {
        char M[33];
        hts_log_error("MD5 checksum reference mismatch at #%d:%d-%d",
                      ref_id, slice->ref_start, slice->ref_end);
        hts_log_error("CRAM: %s", md5_print(slice->hdr->md5, M));
        hts_log_error("Ref : %s", md5_print(digest, M));
        return -1;
    }
}