BAM_CINS) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_BA) {
                if (!c->comp_hdr->codecs[DS_BA]) return -1;
                r |= c->comp_hdr->codecs[DS_BA]
                                ->decode(s, c->comp_hdr->codecs[DS_BA], blk,
                                         &seq[pos-1], &out_sz);
                if (r) return r;
                cig_op = BAM_CINS;
                cig_len++;
                seq_pos++;
                nm++;
            }
            break;
        }

        case 'P': { // Pad; PD
            if (cig_len && cig_op != BAM_CPAD) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_PD) {
                if (!c->comp_hdr->codecs[DS_PD]) return -1;
                r |= c->comp_hdr->codecs[DS_PD]
                                ->decode(s, c->comp_hdr->codecs[DS_PD], blk,
                                         (char *)&i32, &out_sz);
                if (r) return r;
                cig_op = BAM_CPAD;
                cig_len += i32;
                seq_pos += i32;
            }
            break;
        }

        case 'H': { // Hard clip: HC
            if (cig_len && cig_op != BAM_CHARD_CLIP) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_HC) {
                if (!c->comp_hdr->codecs[DS_HC]) return -1;
                r |= c->comp_hdr->codecs[DS_HC]
                                ->decode(s, c->comp_hdr->codecs[DS_HC], blk,
                                         (char *)&i32, &out_sz);
                if (r) return r;
                cig_op = BAM_CHARD_CLIP;
                cig_len += i32;
                seq_pos += i32;
            }
            break;
        }

        case 'M': { // Match; MF
            if (cig_len && cig_op != BAM_CMATCH) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_MF) {
                if (!c->comp_hdr->codecs[DS_MF]) return -1;
                r |= c->comp_hdr->codecs[DS_MF]
                                ->decode(s, c->comp_hdr->codecs[DS_MF], blk,
                                         cr->len ? &seq[pos-1] : NULL,
                                         &out_sz);
                if (r) return r;
                cig_op = BAM_CMATCH;
                cig_len++;
                seq_pos++;
                ref_pos++;
            }
            break;
        }

        case 'Q': { // Query soft clip: QS
            if (cig_len && cig_op != BAM_CSOFT_CLIP) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_QS) {
                if (!c->comp_hdr->codecs[DS_QS]) return -1;
                r |= c->comp_hdr->codecs[DS_QS]
                                ->decode(s, c->comp_hdr->codecs[DS_QS], blk,
                                         cr->len ? &qual[pos-1] : NULL,
                                         &out_sz);
                if (r) return r;
                cig_op = BAM_CSOFT_CLIP;
                cig_len += out_sz;
                seq_pos += out_sz;
            }
            break;
        }

        case '=': { // Sequence match: CF
            if (cig_len && cig_op != BAM_CEQUAL) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_CF) {
                if (!c->comp_hdr->codecs[DS_CF]) return -1;
                r |= c->comp_hdr->codecs[DS_CF]
                                ->decode(s, c->comp_hdr->codecs[DS_CF], blk,
                                         cr->len ? &seq[pos-1] : NULL,
                                         &out_sz);
                if (r) return r;
                cig_op = BAM_CEQUAL;
                cig_len += out_sz;
                seq_pos += out_sz;
                ref_pos += out_sz;
            }
            break;
        }

        case 'X': { // Sequence mismatch: FC
            if (cig_len && cig_op != BAM_CDIFF) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_FC) {
                if (!c->comp_hdr->codecs[DS_FC]) return -1;
                r |= c->comp_hdr->codecs[DS_FC]
                                ->decode(s, c->comp_hdr->codecs[DS_FC], blk,
                                         &seq[pos-1], &out_sz);
                if (r) return r;
                cig_op = BAM_CDIFF;
                cig_len += out_sz;
                seq_pos += out_sz;
                ref_pos += out_sz;
            }
            break;
        }

        case 'N': { // Skip: TN
            if (cig_len && cig_op != BAM_CREF_SKIP) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_TN) {
                if (!c->comp_hdr->codecs[DS_TN]) return -1;
                r |= c->comp_hdr->codecs[DS_TN]
                                ->decode(s, c->comp_hdr->codecs[DS_TN], blk,
                                         (char *)&i32, &out_sz);
                if (r) return r;
                cig_op = BAM_CREF_SKIP;
                cig_len += i32;
                seq_pos += i32;
                ref_pos += i32;
            }
            break;
        }

        case 'R': { // Reference skip: RS
            if (cig_len && cig_op != BAM_CREF_SKIP) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_RS) {
                if (!c->comp_hdr->codecs[DS_RS]) return -1;
                r |= c->comp_hdr->codecs[DS_RS]
                                ->decode(s, c->comp_hdr->codecs[DS_RS], blk,
                                         (char *)&i32, &out_sz);
                if (r) return r;
                cig_op = BAM_CREF_SKIP;
                cig_len += i32;
                seq_pos += i32;
                ref_pos += i32;
            }
            break;
        }

        case 'F': { // Feature: FN
            if (cig_len && cig_op != BAM_CSEQ) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_FN) {
                if (!c->comp_hdr->codecs[DS_FN]) return -1;
                r |= c->comp_hdr->codecs[DS_FN]
                                ->decode(s, c->comp_hdr->codecs[DS_FN], blk,
                                         cr->len ? &seq[pos-1] : NULL,
                                         &out_sz);
                if (r) return r;
                cig_op = BAM_CSEQ;
                cig_len += out_sz;
                seq_pos += out_sz;
                ref_pos += out_sz;
            }
            break;
        }

        case 'S': { // Soft clip: FP
            if (cig_len && cig_op != BAM_CSOFT_CLIP) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_FP) {
                if (!c->comp_hdr->codecs[DS_FP]) return -1;
                r |= c->comp_hdr->codecs[DS_FP]
                                ->decode(s, c->comp_hdr->codecs[DS_FP], blk,
                                         (char *)&i32, &out_sz);
                if (r) return r;
                cig_op = BAM_CSOFT_CLIP;
                cig_len += i32;
                seq_pos += i32;
            }
            break;
        }

        case 'A': { // Skip (alignment gap): AP
            if (cig_len && cig_op != BAM_CGAP) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_AP) {
                if (!c->comp_hdr->codecs[DS_AP]) return -1;
                r |= c->comp_hdr->codecs[DS_AP]
                                ->decode(s, c->comp_hdr->codecs[DS_AP], blk,
                                         (char *)&i32, &out_sz);
                if (r) return r;
                cig_op = BAM_CGAP;
                cig_len += i32;
                seq_pos += i32;
                ref_pos += i32;
            }
            break;
        }

        case 'G': { // Gap (alignment gap): RG
            if (cig_len && cig_op != BAM_CGAP) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_RG) {
                if (!c->comp_hdr->codecs[DS_RG]) return -1;
                r |= c->comp_hdr->codecs[DS_RG]
                                ->decode(s, c->comp_hdr->codecs[DS_RG], blk,
                                         (char *)&i32, &out_sz);
                if (r) return r;
                cig_op = BAM_CGAP;
                cig_len += i32;
                seq_pos += i32;
                ref_pos += i32;
            }
            break;
        }

        case 'L': { // Skip (large insertion): TL
            if (cig_len && cig_op != BAM_CREF_SKIP) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_TL) {
                if (!c->comp_hdr->codecs[DS_TL]) return -1;
                r |= c->comp_hdr->codecs[DS_TL]
                                ->decode(s, c->comp_hdr->codecs[DS_TL], blk,
                                         (char *)&i32, &out_sz);
                if (r) return r;
                cig_op = BAM_CREF_SKIP;
                cig_len += i32;
                seq_pos += i32;
                ref_pos += i32;
            }
            break;
        }

        case 'V': { // Variant: QQ
            if (cig_len && cig_op != BAM_CSEQ) {
                cigar[ncigar++] = (cig_len<<4) + cig_op;
                cig_len = 0;
            }
            if (ds & CRAM_QQ) {
                if (!c->comp_hdr->codecs[DS_QQ]) return -1;
                r |= c->comp_hdr->codecs[DS_QQ]
                                ->decode(s, c->comp_hdr->