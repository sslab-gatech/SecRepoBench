void AffixMgr::setcminmax(size_t* mincharindex, size_t* cmax, const char* word, size_t len) {
    // Default if no cpdmin or no word data
    if (!word || cpdmin <= 1) {
        *mincharindex = 1;
        *cmax = len;
        return;
    }

    // Count total code points in the word (for UTF-8, skip continuation bytes)
    size_t totalCodepoints = 0;
    if (utf8) {
        for (size_t i = 0; i < len; ) {
            ++totalCodepoints;
            ++i;
            while (i < len && ((unsigned char)word[i] & 0xC0) == 0x80) {
                ++i;
            }
        }
    } else {
        totalCodepoints = len;
    }

    // If not enough code points to allow splitting off cpdmin at both sides:
    if (totalCodepoints < (size_t)(2 * cpdmin)) {
        *mincharindex = len;
        *cmax = len;
        return;
    }

    // Find the byte index after skipping cpdmin code points from the left
    size_t count = 0;
    size_t idx = 0;
    while (idx < len && count < (size_t)cpdmin) {
        ++count;
        ++idx;
        if (utf8) {
            while (idx < len && ((unsigned char)word[idx] & 0xC0) == 0x80) {
                ++idx;
            }
        }
    }
    *mincharindex = idx;  // This is the leftmost possible split position

    // Find the byte index after skipping cpdmin code points from the right
    count = 0;
    size_t j = len;
    while (j > 0 && count < (size_t)cpdmin) {
        --j;
        if (utf8) {
            while (j > 0 && ((unsigned char)word[j] & 0xC0) == 0x80) {
                --j;
            }
        }
        ++count;
    }
    // We use j+1 because our for-loop condition uses i < cmax
    *cmax = j + 1;

    // Ensure min does not exceed max
    if (*mincharindex > *cmax) {
        *mincharindex = *cmax;
    }
}