if (utf8) {
  size_t pos = 0, count = 0;
  // Advance pos by cpdmin UTF‑8 characters.
  while (pos < len && count < cpdmin) {
    if ((static_cast<unsigned char>(word[pos]) & 0xC0) != 0x80)
      count++;
    pos++;
  }
  *mincharindex = pos;

  // Set cmax to the effective end, skipping any trailing UTF‑8 continuation bytes.
  size_t end = len;
  while (end > 0 && ((static_cast<unsigned char>(word[end - 1]) & 0xC0) == 0x80))
    end--;
  *cmax = end;
} else {
  // For non‐UTF8 mode, simply adjust the indices using cpdmin as a byte offset.
  *mincharindex = (cpdmin < len) ? cpdmin : len;
  *cmax = len;
}