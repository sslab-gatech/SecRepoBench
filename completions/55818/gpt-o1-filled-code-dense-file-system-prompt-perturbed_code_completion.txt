if (utf8) {
    // set mincharindex to the start
    *mincharindex = 0;
    // move mincharindex forward by cpdmin UTF-8 characters
    for (size_t i = 0; i < cpdmin && *mincharindex < len; i++) {
        // advance by the number of bytes occupied by the next UTF-8 character
        unsigned char c = (unsigned char)word[*mincharindex];
        if ((c & 0x80) == 0) {
            // 1-byte character
            (*mincharindex)++;
        } else if ((c & 0xE0) == 0xC0) {
            (*mincharindex) += 2;
        } else if ((c & 0xF0) == 0xE0) {
            (*mincharindex) += 3;
        } else if ((c & 0xF8) == 0xF0) {
            (*mincharindex) += 4;
        } else {
            // fallback for unexpected continuation or invalid byte
            (*mincharindex)++;
        }
        if (*mincharindex > len) {
            *mincharindex = len;
            break;
        }
    }
    // set cmax to the end of the string
    *cmax = len;
    // move cmax backward over any trailing UTF-8 continuation bytes
    while (*cmax > 0 && (word[*cmax] & 0xC0) == 0x80) {
        (*cmax)--;
    }
} else {
    // in non-UTF8 mode, simply adjust by cpdmin
    *mincharindex = (cpdmin > len) ? len : cpdmin;
    *cmax = len;
}