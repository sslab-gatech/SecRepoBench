if (utf8) {
  // Start with mincharindex at the beginning of the string
  *mincharindex = 0;
  
  // Adjust mincharindex based on cpdmin
  if (cpdmin > 0) {
    size_t char_count = 0;
    size_t i = 0;
    while (i < len && char_count < cpdmin) {
      if ((word[i] & 0xC0) != 0x80) { // Not a continuation byte
        char_count++;
      }
      i++;
    }
    *mincharindex = i;
  }
  
  // Calculate cmax, which is the byte position of the last character's start
  if (len > 0) {
    // Start from the end of the word and move backward
    size_t pos = len - 1;
    
    // Skip trailing UTF-8 continuation bytes
    while (pos > 0 && (word[pos] & 0xC0) == 0x80) {
      pos--;
    }
    
    *cmax = pos;
  } else {
    *cmax = 0;
  }
} else {
  // For non-UTF-8, simply adjust mincharindex based on cpdmin and cmax is the index of the last character
  *mincharindex = cpdmin;
  *cmax = len > 0 ? len - 1 : 0;
}