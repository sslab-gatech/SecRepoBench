if (utf8) {
    // Skip the first cpdmin UTF-8 characters to set the initial mincharindex.
    size_t i = 0;
    size_t count = 0;
    while (i < len && count < cpdmin) {
        unsigned char ch = (unsigned char)word[i];
        size_t charLen = 1;
        if (ch < 0x80)
            charLen = 1;
        else if ((ch & 0xE0) == 0xC0)
            charLen = 2;
        else if ((ch & 0xF0) == 0xE0)
            charLen = 3;
        else if ((ch & 0xF8) == 0xF0)
            charLen = 4;
        else
            charLen = 1;
        if (i + charLen > len)
            break;
        i += charLen;
        count++;
    }
    *mincharindex = i;

    // Exclude any trailing continuation bytes.
    size_t valid_end = len;
    while (valid_end > *mincharindex && ((unsigned char)word[valid_end - 1] & 0xC0) == 0x80) {
        valid_end--;
    }
    // Count complete UTF-8 characters from *mincharindex to valid_end.
    count = 0;
    size_t j = *mincharindex;
    while (j < valid_end) {
        unsigned char ch = (unsigned char)word[j];
        size_t charLen = 1;
        if (ch < 0x80)
            charLen = 1;
        else if ((ch & 0xE0) == 0xC0)
            charLen = 2;
        else if ((ch & 0xF0) == 0xE0)
            charLen = 3;
        else if ((ch & 0xF8) == 0xF0)
            charLen = 4;
        else
            charLen = 1;
        if (j + charLen > valid_end)
            break;
        j += charLen;
        count++;
    }
    *cmax = count;
} else {
    // In non-UTF8 mode, each byte is a character.
    size_t start = (cpdmin > len ? len : cpdmin);
    *mincharindex = start;
    *cmax = len - start;
}