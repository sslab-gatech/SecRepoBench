if (utf8) {
  // Initialize min char index to the start of the word
  *mincharindex = 0;
  
  // Calculate the minimum character position considering UTF-8
  // characters and cpdmin (compound minimum?)
  if (cpdmin > 0) {
    // Count UTF-8 characters to reach cpdmin
    size_t i = 0;
    size_t chars = 0;
    while (i < len && chars < cpdmin) {
      unsigned char c = (unsigned char)word[i];
      if ((c & 0x80) == 0) {
        i += 1;  // ASCII
      } else if ((c & 0xE0) == 0xC0) {
        if (i + 1 < len) i += 2;  // 2-byte UTF-8
        else i = len;  // Ensure we don't go past the end
      } else if ((c & 0xF0) == 0xE0) {
        if (i + 2 < len) i += 3;  // 3-byte UTF-8
        else i = len;  // Ensure we don't go past the end
      } else if ((c & 0xF8) == 0xF0) {
        if (i + 3 < len) i += 4;  // 4-byte UTF-8
        else i = len;  // Ensure we don't go past the end
      } else {
        i += 1;  // Default case, likely an invalid UTF-8 byte
      }
      chars++;
    }
    *mincharindex = i;
  }
  
  // Initialize max char index to the end of the word
  *cmax = len;
  
  // Adjust max char index to exclude trailing UTF-8 continuation bytes
  if (*cmax > 0) {
    size_t i = *cmax - 1;
    while (i > 0 && ((unsigned char)word[i] & 0xC0) == 0x80) {
      i--;  // Move back past continuation bytes
    }
    // Now 'i' points to the start of the last character
    *cmax = i + 1;  // +1 to include this character
  }
} else {
  // Non-UTF-8 text (ASCII or other single-byte encoding)
  *mincharindex = (cpdmin < len) ? cpdmin : len;
  *cmax = len;
}