if (len == 0) {
  *mincharindex = 0;
  *cmax = 0;
  return;
}

if (utf8) {
  // Advance to the compound min position by counting UTF-8 codepoints.
  size_t idx = 0;
  size_t count = 0;
  while (idx < len && count < (size_t)cpdmin) {
    unsigned char ch = (unsigned char)word[idx];
    int char_len = 1;
    if (ch < 0x80) {
      char_len = 1;
    } else if ((ch & 0xE0) == 0xC0) {
      char_len = 2;
    } else if ((ch & 0xF0) == 0xE0) {
      char_len = 3;
    } else if ((ch & 0xF8) == 0xF0) {
      char_len = 4;
    }
    idx += char_len;
    count++;
  }
  *mincharindex = idx;

  // Adjust cmax to the end of the last complete character.
  size_t pos = len;
  while (pos > 0 && (((unsigned char)word[pos - 1] & 0xC0) == 0x80))
    pos--;
  *cmax = pos;
} else {
  // For non UTF-8, each byte is considered a character.
  *mincharindex = cpdmin < len ? cpdmin : len;
  *cmax = len;
}