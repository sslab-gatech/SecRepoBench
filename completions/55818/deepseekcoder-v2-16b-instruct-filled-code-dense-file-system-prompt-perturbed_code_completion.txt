// <MASK>
  if (utf8) {
    // Calculate min and max character positions based on UTF-8 boundaries
    size_t min_char_index = 0;
    size_t max_char_index = len;

    // Adjust min_char_index by the number of UTF-8 characters specified by `cpdmin`
    min_char_index += cpdmin;

    // Exclude trailing UTF-8 continuation bytes while adjusting max_char_index
    while (max_char_index > 0 && (word[max_char_index - 1] & 0xC0) == 0x80) {
      max_char_index--;
    }

    // Update the output parameters
    *mincharindex = min_char_index;
    *cmax = max_char_index;
  } else {
    // Adjust min and max character positions for non-UTF-8 case
    *mincharindex = 0;
    *cmax = len;
  }
}