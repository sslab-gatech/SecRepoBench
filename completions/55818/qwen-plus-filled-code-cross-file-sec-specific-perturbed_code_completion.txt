if (utf8) {
  size_t cpdmin = get_cpdmin(); // Assume this method returns the number of UTF-8 characters to skip
  const char* word_start = word;
  const char* word_end = word + len;

  // Calculate min char index as starting position plus cpdmin characters
  const char* min_char_pos = word_start;
  for (size_t i = 0; i < cpdmin && min_char_pos < word_end; ++i) {
    while (min_char_pos < word_end && ((*min_char_pos & 0xc0) == 0x80)) {
      min_char_pos++; // Skip continuation bytes if any
    }
    if (min_char_pos < word_end) {
      min_char_pos++; // Move to next character start
    }
  }

  *mincharindex = static_cast<size_t>(min_char_pos - word_start);

  // Calculate max char index as ending position excluding trailing continuation bytes
  const char* max_char_pos = word_end;
  while (max_char_pos > word_start && (*reinterpret_cast<const unsigned char*>(max_char_pos - 1) & 0xc0) == 0x80) {
    max_char_pos--; // Exclude trailing continuation bytes
  }

  *cmax = static_cast<size_t>(max_char_pos - word_start);
} else {
  // Non-UTF8 case, adjust indices directly
  *mincharindex = std::max(static_cast<size_t>(0), len > cpdmin ? len - cpdmin : 0);
  *cmax = len;
}