return (cur);
}

/**
 * xmlNewProp:
 * @node:  the element to add the property to
 * @name:  the name of the property
 * @value:  the value of the property
 *
 * Create a new property for an element.
 *
 * Returns a pointer to the new property or NULL in case of error.
 */
xmlAttrPtr
xmlNewProp(xmlNodePtr node, const xmlChar *name, const xmlChar *value) {
    return (xmlNewPropInternal(node, NULL, name, value, 0));
}

/**
 * xmlNewNsProp:
 * @node:  the element to add the property to
 * @ns:  the namespace for the property
 * @name:  the name of the property
 * @value:  the value of the property
 *
 * Create a new property for an element with a namespace.
 *
 * Returns a pointer to the new property or NULL in case of error.
 */
xmlAttrPtr
xmlNewNsProp(xmlNodePtr node, xmlNsPtr ns, const xmlChar *name,
             const xmlChar *value) {
    return (xmlNewPropInternal(node, ns, name, value, 1));
}

/**
 * xmlSetNs:
 * @node:  a node in the document
 * @ns:  a namespace pointer
 *
 * Associate a namespace to a node, a posteriori.
 */
void
xmlSetNs(xmlNodePtr node, xmlNsPtr ns) {
    if (node == NULL) {
#ifdef DEBUG_TREE
        xmlGenericError(xmlGenericErrorContext,
		"xmlSetNs: node == NULL\n");
#endif
	return;
    }
    if ((node->type == XML_ELEMENT_NODE) ||
        (node->type == XML_ATTRIBUTE_NODE))
	node->ns = ns;
}

/**
 * xmlUnsetNs:
 * @node:  a node in the document
 * @ns:  a namespace pointer
 *
 * Remove a namespace association from a node.
 */
void
xmlUnsetNs(xmlNodePtr node, xmlNsPtr ns) {
    xmlAttrPtr cur;

    if (node == NULL) {
#ifdef DEBUG_TREE
        xmlGenericError(xmlGenericErrorContext,
		"xmlUnsetNs: node == NULL\n");
#endif
	return;
    }
    if ((node->type == XML_ELEMENT_NODE) ||
        (node->type == XML_ATTRIBUTE_NODE)) {
        if (node->ns == ns)
            node->ns = NULL;
        cur = node->properties;
        while (cur != NULL) {
            xmlAttrPtr next = cur->next;

            if ((cur->ns == ns) && (cur->parent == node)) {
                xmlUnlinkNode(cur);
                xmlFreeProp(cur);
            }
            cur = next;
        }
    }
}

/**
 * xmlUnsetNsProp:
 * @node:  a node in the document
 * @ns:  a namespace pointer
 * @name:  the name of the property
 *
 * Remove a property with a given name and namespace from a node.
 */
void
xmlUnsetNsProp(xmlNodePtr node, xmlNsPtr ns, const xmlChar *name) {
    xmlAttrPtr cur;

    if (node == NULL) {
#ifdef DEBUG_TREE
        xmlGenericError(xmlGenericErrorContext,
		"xmlUnsetNsProp: node == NULL\n");
#endif
	return;
    }
    if ((node->type == XML_ELEMENT_NODE) ||
        (node->type == XML_ATTRIBUTE_NODE)) {
        cur = node->properties;
        while (cur != NULL) {
            xmlAttrPtr next = cur->next;

            if ((cur->ns == ns) && (cur->name == name) && (cur->parent == node)) {
                xmlUnlinkNode(cur);
                xmlFreeProp(cur);
            }
            cur = next;
        }
    }
}

/**
 * xmlUnsetProp:
 * @node:  a node in the document
 * @name:  the name of the property
 *
 * Remove a property with a given name from a node.
 */
void
xmlUnsetProp(xmlNodePtr node, const xmlChar *name) {
    xmlAttrPtr cur;

    if (node == NULL) {
#ifdef DEBUG_TREE
        xmlGenericError(xmlGenericErrorContext,
		"xmlUnsetProp: node == NULL\n");
#endif
	return;
    }
    if ((node->type == XML_ELEMENT_NODE) ||
        (node->type == XML_ATTRIBUTE_NODE)) {
        cur = node->properties;
        while (cur != NULL) {
            xmlAttrPtr next = cur->next;

            if ((cur->name == name) && (cur->parent == node)) {
                xmlUnlinkNode(cur);
                xmlFreeProp(cur);
            }
            cur = next;
        }
    }
}

/**
 * xmlHasNsProp:
 * @node:  a node in the document
 * @ns:  a namespace pointer
 * @name:  the name of the property
 *
 * Check if a node has a property with a given name and namespace.
 *
 * Returns 1 if the property is found, 0 otherwise.
 */
int
xmlHasNsProp(const xmlNodePtr node, const xmlNsPtr ns, const xmlChar *name) {
    xmlAttrPtr cur;

    if ((node == NULL) || ((node->type != XML_ELEMENT_NODE) &&
                           (node->type != XML_ATTRIBUTE_NODE)))
        return(0);

    cur = node->properties;
    while (cur != NULL) {
        if ((cur->ns == ns) && (cur->name == name))
            return(1);
        cur = cur->next;
    }
    return(0);
}

/**
 * xmlHasProp:
 * @node:  a node in the document
 * @name:  the name of the property
 *
 * Check if a node has a property with a given name.
 *
 * Returns 1 if the property is found, 0 otherwise.
 */
int
xmlHasProp(const xmlNodePtr node, const xmlChar *name) {
    xmlAttrPtr cur;

    if ((node == NULL) || ((node->type != XML_ELEMENT_NODE) &&
                           (node->type != XML_ATTRIBUTE_NODE)))
        return(0);

    cur = node->properties;
    while (cur != NULL) {
        if (cur->name == name)
            return(1);
        cur = cur->next;
    }
    return(0);
}

/**
 * xmlGetNsProp:
 * @node:  a node in the document
 * @ns:  a namespace pointer
 * @name:  the name of the property
 *
 * Get a property with a given name and namespace from a node.
 *
 * Returns a pointer to the property or NULL if not found.
 */
xmlAttrPtr
xmlGetNsProp(const xmlNodePtr node, const xmlChar *name, const xmlChar *ns) {
    xmlAttrPtr cur;

    if ((node == NULL) || ((node->type != XML_ELEMENT_NODE) &&
                           (node->type != XML_ATTRIBUTE_NODE)))
        return(NULL);

    cur = node->properties;
    while (cur != NULL) {
        if ((cur->ns == ns) && (cur->name == name))
            return(cur);
        cur = cur->next;
    }
    return(NULL);
}

/**
 * xmlGetProp:
 * @node:  a node in the document
 * @name:  the name of the property
 *
 * Get a property with a given name from a node.
 *
 * Returns a pointer to the property or NULL if not found.
 */
xmlAttrPtr
xmlGetProp(const xmlNodePtr node, const xmlChar *name) {
    xmlAttrPtr cur;

    if ((node == NULL) || ((node->type != XML_ELEMENT_NODE) &&
                           (node->type != XML_ATTRIBUTE_NODE)))
        return(NULL);

    cur = node->properties;
    while (cur != NULL) {
        if (cur->name == name)
            return(cur);
        cur = cur->next;
    }
    return(NULL);
}

/**
 * xmlGetNodePath:
 * @node:  the node to get the path for
 *
 * Get the XPath representation of a node.
 *
 * Returns a pointer to the string or NULL in case of error.
 */
xmlChar *
xmlGetNodePath(xmlNodePtr node) {
    xmlChar *path = NULL;
    xmlNodePtr cur;
    int count = 0;

    if (node == NULL)
        return(NULL);

    cur = node;
    while (cur != NULL) {
        if (cur->type == XML_ELEMENT_NODE) {
            xmlChar *name;
            xmlChar *tmp;

            name = cur->name;
            if (cur->ns != NULL) {
                if (cur->ns->prefix != NULL) {
                    tmp = xmlBuildQName(name, cur->ns->prefix, NULL, 0);
                } else {
                    tmp = xmlStrdup(name);
                }
            } else {
                tmp = xmlStrdup(name);
            }
            if (tmp == NULL) {
                if (path != NULL) xmlFree(path);
                return(NULL);
            }
            if (count > 0) {
                path = xmlStrcat(path, BAD_CAST "/");
                if (path == NULL) {
                    xmlFree(tmp);
                    return(NULL);
                }
            }
            path = xmlStrcat(path, tmp);
            if (path == NULL) {
                xmlFree(tmp);
                return(NULL);
            }
            xmlFree(tmp);
        }
        cur = cur->parent;
        count++;
    }
    /*
     * Reverse the path
     */
    xmlChar *start = path;
    xmlChar *end = path + xmlStrlen(path) - 1;
    xmlChar tmp;

    while (start < end) {
        tmp = *start;
        *start = *end;
        *end = tmp;
        start++;
        end--;
    }
    return(path);
}

/**
 * xmlGetNodePathNoDepth:
 * @node:  the node to get the path for
 *
 * Get the XPath representation of a node without the depth information.
 *
 * Returns a pointer to the string or NULL in case of error.
 */
xmlChar *
xmlGetNodePathNoDepth(xmlNodePtr node) {
    xmlChar *path = NULL;
    xmlNodePtr cur;
    int count = 0;

    if (node == NULL)
        return(NULL);

    cur = node;
    while (cur != NULL) {
        if (cur->type == XML_ELEMENT_NODE) {
            xmlChar *name;
            xmlChar *tmp;

            name = cur->name;
            if (cur->ns != NULL) {
                if (cur->ns->prefix != NULL) {
                    tmp = xmlBuildQName(name, cur->ns->prefix, NULL, 0);
                } else {
                    tmp = xmlStrdup(name);
                }
            } else {
                tmp = xmlStrdup(name);
            }
            if (tmp == NULL) {
                if (path != NULL) xmlFree(path);
                return(NULL);
            }
            if (count > 0) {
                path = xmlStrcat(path, BAD_CAST "/");
                if (path == NULL) {
                    xmlFree(tmp);
                    return(NULL);
                }
            }
            path = xmlStrcat(path, tmp);
            if (path == NULL) {
                xmlFree(tmp);
                return(NULL);
            }
            xmlFree(tmp);
        }
        cur = cur->parent;
        count++;
    }
    return(path);
}

/**
 * xmlGetNodeListPath:
 * @list:  the node list to get the path for
 *
 * Get the XPath representation of a node list.
 *
 * Returns a pointer to the string or NULL in case of error.
 */
xmlChar *
xmlGetNodeListPath(xmlNodePtr list) {
    xmlChar *path = NULL;
    xmlNodePtr cur;
    int count = 0;

    if (list == NULL)
        return(NULL);

    cur = list;
    while (cur != NULL) {
        if (cur->type == XML_ELEMENT_NODE) {
            xmlChar *name;
            xmlChar *tmp;

            name = cur->name;
            if (cur->ns != NULL) {
                if (cur->ns->prefix != NULL)