defined(LIBXML_SCHEMAS_ENABLED)
/**
 * xmlNewProp:
 * @node:  the element to add the property to
 * @name:  the name of the property
 * @value:  the value of the property
 *
 * Create a new property for an element.
 *
 * Returns a pointer to the new property or NULL in case of error.
 */
xmlAttrPtr
xmlNewProp(xmlNodePtr node, const xmlChar *name, const xmlChar *value) {
    return(xmlNewPropInternal(node, NULL, name, value, 0));
}
#endif

#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
/**
 * xmlNewNsProp:
 * @node:  the element to add the property to
 * @ns:  the namespace for the property
 * @name:  the name of the property
 * @value:  the value of the property
 *
 * Create a new property for an element with a namespace.
 *
 * Returns a pointer to the new property or NULL in case of error.
 */
xmlAttrPtr
xmlNewNsProp(xmlNodePtr node, xmlNsPtr ns, const xmlChar *name,
             const xmlChar *value) {
    return(xmlNewPropInternal(node, ns, name, value, 0));
}
#endif

#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
/**
 * xmlNewNsPropEatName:
 * @node:  the element to add the property to
 * @ns:  the namespace for the property
 * @name:  the name of the property
 * @value:  the value of the property
 *
 * Create a new property for an element with a namespace.
 * The name is eaten, i.e. it is freed with xmlFree().
 *
 * Returns a pointer to the new property or NULL in case of error.
 */
xmlAttrPtr
xmlNewNsPropEatName(xmlNodePtr node, xmlNsPtr ns, xmlChar *name,
                    const xmlChar *value) {
    return(xmlNewPropInternal(node, ns, name, value, 1));
}
#endif

#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
/**
 * xmlNewDocProp:
 * @doc:  the document to add the property to
 * @node:  the element to add the property to
 * @name:  the name of the property
 * @value:  the value of the property
 *
 * Create a new property for an element in a document.
 *
 * Returns a pointer to the new property or NULL in case of error.
 */
xmlAttrPtr
xmlNewDocProp(xmlDocPtr doc, xmlNodePtr node, const xmlChar *name,
              const xmlChar *value) {
    xmlAttrPtr cur;

    if (doc == NULL)
        return(NULL);

    cur = xmlNewPropInternal(node, NULL, name, value, 0);
    if (cur != NULL)
        cur->doc = doc;
    return(cur);
}
#endif

#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
/**
 * xmlNewDocNsProp:
 * @doc:  the document to add the property to
 * @node:  the element to add the property to
 * @ns:  the namespace for the property
 * @name:  the name of the property
 * @value:  the value of the property
 *
 * Create a new property for an element in a document with a namespace.
 *
 * Returns a pointer to the new property or NULL in case of error.
 */
xmlAttrPtr
xmlNewDocNsProp(xmlDocPtr doc, xmlNodePtr node, xmlNsPtr ns,
                const xmlChar *name, const xmlChar *value) {
    xmlAttrPtr cur;

    if (doc == NULL)
        return(NULL);

    cur = xmlNewPropInternal(node, ns, name, value, 0);
    if (cur != NULL)
        cur->doc = doc;
    return(cur);
}
#endif

#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
/**
 * xmlNewDocNsPropEatName:
 * @doc:  the document to add the property to
 * @node:  the element to add the property to
 * @ns:  the namespace for the property
 * @name:  the name of the property
 * @value:  the value of the property
 *
 * Create a new property for an element in a document with a namespace.
 * The name is eaten, i.e. it is freed with xmlFree().
 *
 * Returns a pointer to the new property or NULL in case of error.
 */
xmlAttrPtr
xmlNewDocNsPropEatName(xmlDocPtr doc, xmlNodePtr node, xmlNsPtr ns,
                       xmlChar *name, const xmlChar *value) {
    xmlAttrPtr cur;

    if (doc == NULL)
        return(NULL);

    cur = xmlNewPropInternal(node, ns, name, value, 1);
    if (cur != NULL)
        cur->doc = doc;
    return(cur);
}
#endif

/**
 * xmlSetNs:
 * @node:  the node to associate the namespace with
 * @ns:  the namespace to associate
 *
 * Associate a namespace with a node.
 */
void
xmlSetNs(xmlNodePtr node, xmlNsPtr ns) {
    if ((node == NULL) || (node->type != XML_ELEMENT_NODE))
        return;
    node->ns = ns;
}

/**
 * xmlUnsetNs:
 * @node:  the node to remove the namespace from
 * @ns:  the namespace to remove
 *
 * Remove a namespace association from a node.
 */
void
xmlUnsetNs(xmlNodePtr node, xmlNsPtr ns) {
    xmlAttrPtr attr;

    if ((node == NULL) || (node->type != XML_ELEMENT_NODE))
        return;
    attr = node->properties;
    while (attr != NULL) {
        xmlAttrPtr next = attr->next;

        if ((attr->ns == ns) && (attr->parent == node)) {
            if (attr->prev != NULL)
                attr->prev->next = attr->next;
            else
                node->properties = attr->next;
            if (attr->next != NULL)
                attr->next->prev = attr->prev;
            if (node->last == attr)
                node->last = attr->prev;
            if (attr->doc != NULL)
                xmlRegisterNodeDefaultValue((xmlNodePtr) attr);
            xmlFree(attr);
        }
        attr = next;
    }
}

/**
 * xmlUnsetNsProp:
 * @node:  the node to remove the property from
 * @ns:  the namespace of the property
 * @name:  the name of the property
 *
 * Remove a property from a node.
 */
void
xmlUnsetNsProp(xmlNodePtr node, xmlNsPtr ns, const xmlChar *name) {
    xmlAttrPtr attr;

    if ((node == NULL) || (node->type != XML_ELEMENT_NODE))
        return;
    attr = node->properties;
    while (attr != NULL) {
        xmlAttrPtr next = attr->next;

        if ((attr->ns == ns) && (xmlStrEqual(attr->name, name)) &&
            (attr->parent == node)) {
            if (attr->prev != NULL)
                attr->prev->next = attr->next;
            else
                node->properties = attr->next;
            if (attr->next != NULL)
                attr->next->prev = attr->prev;
            if (node->last == attr)
                node->last = attr->prev;
            if (attr->doc != NULL)
                xmlRegisterNodeDefaultValue((xmlNodePtr) attr);
            xmlFree(attr);
        }
        attr = next;
    }
}

/**
 * xmlUnsetProp:
 * @node:  the node to remove the property from
 * @name:  the name of the property
 *
 * Remove a property from a node.
 */
void
xmlUnsetProp(xmlNodePtr node, const xmlChar *name) {
    xmlAttrPtr attr;

    if ((node == NULL) || (node->type != XML_ELEMENT_NODE))
        return;
    attr = node->properties;
    while (attr != NULL) {
        xmlAttrPtr next = attr->next;

        if ((xmlStrEqual(attr->name, name)) && (attr->parent == node)) {
            if (attr->prev != NULL)
                attr->prev->next = attr->next;
            else
                node->properties = attr->next;
            if (attr->next != NULL)
                attr->next->prev = attr->prev;
            if (node->last == attr)
                node->last = attr->prev;
            if (attr->doc != NULL)
                xmlRegisterNodeDefaultValue((xmlNodePtr) attr);
            xmlFree(attr);
        }
        attr = next;
    }
}

/**
 * xmlHasNsProp:
 * @node:  the node to check
 * @name:  the name of the property
 * @ns:  the namespace of the property
 *
 * Check if a node has a property with a given name and namespace.
 *
 * Returns 1 if the property is found, 0 otherwise.
 */
int
xmlHasNsProp(const xmlNodePtr node, const xmlChar *name, const xmlChar *ns) {
    xmlAttrPtr attr;

    if ((node == NULL) || (node->type != XML_ELEMENT_NODE))
        return(0);
    attr = node->properties;
    while (attr != NULL) {
        if ((xmlStrEqual(attr->name, name)) && (attr->ns == ns))
            return(1);
        attr = attr->next;
    }
    return(0);
}

/**
 * xmlHasProp:
 * @node:  the node to check
 * @name:  the name of the property
 *
 * Check if a node has a property with a given name.
 *
 * Returns 1 if the property is found, 0 otherwise.
 */
int
xmlHasProp(const xmlNodePtr node, const xmlChar *name) {
    xmlAttrPtr attr;

    if ((node == NULL) || (node->type != XML_ELEMENT_NODE))
        return(0);
    attr = node->properties;
    while (attr != NULL) {
        if (xmlStrEqual(attr->name, name))
            return(1);
        attr = attr->next;
    }
    return(0);
}

/**
 * xmlGetNsProp:
 * @node:  the node to get the property from
 * @name:  the name of the property
 * @ns:  the namespace of the property
 *
 * Get a property from a node with a given name and namespace.
 *
 * Returns a pointer to the property or NULL if not found.
 */
xmlAttrPtr
xmlGetNsProp(const xmlNodePtr node, const xmlChar *name, const xmlChar *ns) {
    xmlAttrPtr attr;

    if ((node == NULL) || (node->type != XML_ELEMENT_NODE))
        return(NULL);
    attr = node->properties;
    while (attr != NULL) {
        if ((xmlStrEqual(attr->name, name)) && (attr->ns == ns))
            return(attr);
        attr = attr->next;
    }
    return(NULL);
}

/**
 * xmlGetProp:
 * @node:  the node to get the property from
 * @name:  the name of the property
 *
 * Get a property from a node with a given name.
 *
 * Returns a pointer to the property or NULL if not found.
 */
xmlAttrPtr
xmlGetProp(const xmlNodePtr node, const xmlChar *name) {
    xmlAttrPtr attr;

    if ((node == NULL) || (node->type != XML_ELEMENT_NODE))
        return(NULL);
    attr = node->properties;
    while (attr != NULL) {
        if (xmlStrEqual(attr->name, name))
            return(attr);
        attr = attr->next;
    }
    return(NULL);
}

/**
 * xmlGetNodePath:
 * @node:  the node to get the path for
 *
 * Get the XPath path for a node.
 *
 * Returns a pointer to the path string or NULL if not found.
 */
xmlChar *
xmlGetNodePath(const xmlNodePtr node) {
    xmlChar *path = NULL;
    xmlNodePtr cur;

    if (node == NULL)
        return(NULL);

    cur = node;
    while (cur != NULL) {
        xmlChar *part = NULL;