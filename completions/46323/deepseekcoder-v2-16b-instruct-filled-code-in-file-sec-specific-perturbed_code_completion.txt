!= NULL) && (eatname == 1) &&
        (doc != NULL) && (doc->dict != NULL))
        xmlFree((xmlChar *) name);

    return (cur);
}

/**
 * xmlNewProp:
 * @node:  the element to add the property to
 * @name:  the name of the property
 * @value:  the value of the property
 *
 * Create a new property for an element.
 *
 * Returns a pointer to the new property or NULL in case of error.
 */
xmlAttrPtr
xmlNewProp(xmlNodePtr node, const xmlChar *name, const xmlChar *value) {
    return(xmlNewPropInternal(node, NULL, name, value, 0));
}

/**
 * xmlNewNsProp:
 * @node:  the element to add the property to
 * @ns:  the namespace for the property
 * @name:  the name of the property
 * @value:  the value of the property
 *
 * Create a new property for an element with a namespace.
 *
 * Returns a pointer to the new property or NULL in case of error.
 */
xmlAttrPtr
xmlNewNsProp(xmlNodePtr node, xmlNsPtr ns, const xmlChar *name,
             const xmlChar *value) {
    return(xmlNewPropInternal(node, ns, name, value, 0));
}

/**
 * xmlNewNsPropEatName:
 * @node:  the element to add the property to
 * @ns:  the namespace for the property
 * @name:  the name of the property
 * @value:  the value of the property
 *
 * Create a new property for an element with a namespace.
 * The name is eaten, i.e. it is freed after being used.
 *
 * Returns a pointer to the new property or NULL in case of error.
 */
xmlAttrPtr
xmlNewNsPropEatName(xmlNodePtr node, xmlNsPtr ns, xmlChar *name,
                    const xmlChar *value) {
    return(xmlNewPropInternal(node, ns, name, value, 1));
}

/**
 * xmlNewDocProp:
 * @doc:  the document to add the property to
 * @name:  the name of the property
 * @value:  the value of the property
 *
 * Create a new property for a document.
 *
 * Returns a pointer to the new property or NULL in case of error.
 */
xmlAttrPtr
xmlNewDocProp(xmlDocPtr doc, const xmlChar *name, const xmlChar *value) {
    xmlAttrPtr cur;

    if (doc == NULL)
        return(NULL);

    /*
     * Allocate a new property and fill the fields.
     */
    cur = (xmlAttrPtr) xmlMalloc(sizeof(xmlAttr));
    if (cur == NULL) {
        xmlTreeErrMemory("building document attribute");
        return(NULL);
    }
    memset(cur, 0, sizeof(xmlAttr));
    cur->type = XML_ATTRIBUTE_NODE;

    cur->doc = doc;
    cur->name = xmlStrdup(name);
    if (cur->name == NULL) {
        xmlTreeErrMemory("building document attribute");
        xmlFree(cur);
        return(NULL);
    }

    if (value != NULL) {
        xmlNodePtr tmp;

        cur->children = xmlNewDocText(doc, value);
        cur->last = NULL;
        tmp = cur->children;
        while (tmp != NULL) {
            tmp->parent = (xmlNodePtr) cur;
            if (tmp->next == NULL)
                cur->last = tmp;
            tmp = tmp->next;
        }
    }

    /*
     * Add it at the end to preserve parsing order ...
     */
    if (doc->properties == NULL) {
        doc->properties = cur;
    } else {
        xmlAttrPtr prev = doc->properties;

        while (prev->next != NULL)
            prev = prev->next;
        prev->next = cur;
        cur->prev = prev;
    }

    return(cur);
}

/**
 * xmlFreeProp:
 * @cur:  the property to free
 *
 * Free up the structures associated to a property
 */
void
xmlFreeProp(xmlAttrPtr cur) {
    if (cur == NULL) {
#ifdef DEBUG_TREE
        xmlGenericError(xmlGenericErrorContext,
		"xmlFreeProp : prop == NULL\n");
#endif
	return;
    }
    if (cur->name != NULL) xmlFree((char *) cur->name);
    if (cur->children != NULL) xmlFreeNodeList(cur->children);
    xmlFree(cur);
}

/**
 * xmlFreePropList:
 * @cur:  the first property pointer
 *
 * Free up all the structures associated to the chained properties.
 */
void
xmlFreePropList(xmlAttrPtr cur) {
    xmlAttrPtr next;
    if (cur == NULL) {
#ifdef DEBUG_TREE
        xmlGenericError(xmlGenericErrorContext,
		"xmlFreePropList : prop == NULL\n");
#endif
	return;
    }
    while (cur != NULL) {
        next = cur->next;
        xmlFreeProp(cur);
	cur = next;
    }
}

/**
 * xmlGetNsProp:
 * @node:  the element to look the property in
 * @name:  the name of the property
 *
 * Get a property by name from an element.
 *
 * Returns a pointer to the property or NULL if not found.
 */
xmlAttrPtr
xmlGetNsProp(const xmlNode *node, const xmlChar *name) {
    xmlAttrPtr cur;

    if (node == NULL)
        return(NULL);

    cur = node->properties;
    while (cur != NULL) {
        if ((cur->name != NULL) && (xmlStrEqual(cur->name, name)))
            return(cur);
        cur = cur->next;
    }
    return(NULL);
}

/**
 * xmlGetDocProp:
 * @doc:  the document to look the property in
 * @name:  the name of the property
 *
 * Get a property by name from a document.
 *
 * Returns a pointer to the property or NULL if not found.
 */
xmlAttrPtr
xmlGetDocProp(const xmlDoc *doc, const xmlChar *name) {
    xmlAttrPtr cur;

    if (doc == NULL)
        return(NULL);

    cur = doc->properties;
    while (cur != NULL) {
        if ((cur->name != NULL) && (xmlStrEqual(cur->name, name)))
            return(cur);
        cur = cur->next;
    }
    return(NULL);
}

/**
 * xmlGetNodeProp:
 * @node:  the node to look the property in
 * @name:  the name of the property
 *
 * Get a property by name from a node.
 *
 * Returns a pointer to the property or NULL if not found.
 */
xmlAttrPtr
xmlGetNodeProp(const xmlNode *node, const xmlChar *name) {
    xmlAttrPtr cur;

    if (node == NULL)
        return(NULL);

    cur = node->properties;
    while (cur != NULL) {
        if ((cur->name != NULL) && (xmlStrEqual(cur->name, name)))
            return(cur);
        cur = cur->next;
    }
    return(NULL);
}

/**
 * xmlHasNsProp:
 * @node:  the element to look the property in
 * @name:  the name of the property
 * @ns:  the namespace of the property
 *
 * Check if an element has a property with a given name and namespace.
 *
 * Returns 1 if the property is found, 0 otherwise.
 */
int
xmlHasNsProp(const xmlNode *node, const xmlChar *name, const xmlChar *ns) {
    xmlAttrPtr cur;

    if (node == NULL)
        return(0);

    cur = node->properties;
    while (cur != NULL) {
        if ((cur->name != NULL) && (xmlStrEqual(cur->name, name))) {
            if ((cur->ns == NULL) || (ns == NULL) ||
                xmlStrEqual(cur->ns->prefix, ns))
                return(1);
        }
        cur = cur->next;
    }
    return(0);
}

/**
 * xmlHasProp:
 * @node:  the element to look the property in
 * @name:  the name of the property
 *
 * Check if an element has a property with a given name.
 *
 * Returns 1 if the property is found, 0 otherwise.
 */
int
xmlHasProp(const xmlNode *node, const xmlChar *name) {
    xmlAttrPtr cur;

    if (node == NULL)
        return(0);

    cur = node->properties;
    while (cur != NULL) {
        if ((cur->name != NULL) && (xmlStrEqual(cur->name, name)))
            return(1);
        cur = cur->next;
    }
    return(0);
}

/**
 * xmlRemoveProp:
 * @cur:  the property to remove
 *
 * Remove a property from an element.
 *
 * Returns the removed property or NULL if not found.
 */
xmlAttrPtr
xmlRemoveProp(xmlAttrPtr cur) {
    xmlAttrPtr ret;

    if (cur == NULL)
        return(NULL);

    if (cur->parent != NULL) {
        if (cur->prev != NULL)
            cur->prev->next = cur->next;
        else
            cur->parent->properties = cur->next;
        if (cur->next != NULL)
            cur->next->prev = cur->prev;
        if (cur->last != NULL)
            cur->last->next = NULL;
        ret = cur->next;
    } else {
        ret = cur->next;
    }

    if (cur->name != NULL) xmlFree((char *) cur->name);
    if (cur->children != NULL) xmlFreeNodeList(cur->children);
    xmlFree(cur);

    return(ret);
}

/**
 * xmlRemovePropList:
 * @list:  the first property pointer
 *
 * Remove a list of properties from an element.
 *
 * Returns the first property of the removed list or NULL if not found.
 */
xmlAttrPtr
xmlRemovePropList(xmlAttrPtr list) {
    xmlAttrPtr ret;

    if (list == NULL)
        return(NULL);

    ret = list;
    while (list != NULL) {
        ret = xmlRemoveProp(list);
        list = ret;
    }

    return(ret);
}

/**
 * xmlGetNodePath:
 * @node:  the node to get the path for
 *
 * Get the XPath representation of a node.
 *
 * Returns a pointer to the string or NULL in case of error.
 */
xmlChar *
xmlGetNodePath(const xmlNode *node) {
    xmlChar *ret = NULL;
    xmlNode *cur;

    if (node == NULL)
        return(NULL);

    cur = (xmlNode *) node;
    while (cur != NULL) {
        xmlChar *buffer;
        xmlNode *parent;

        if (cur->type == XML_ELEMENT_NODE) {
            buffer = xmlStrdup(cur->name);
            if (buffer == NULL)
                goto out;
            parent = cur->parent;
            if ((parent != NULL) && (parent->type == XML_ELEMENT_NODE)) {
                xmlChar *tmp;

                tmp = xmlStrchr(buffer, ':');
                if (tmp != NULL) {
                    xmlChar *prefix;

                    prefix = xmlStrndup(buffer, tmp - buffer);
                    if (prefix != NULL) {
                        xmlChar *name;

                        name = xmlStrdup(tmp + 1);
                        if (name != NULL) {
                            xmlChar *tmp2;

                            tmp2 = xmlStrcat(prefix, name);
                            if (tmp2 != NULL) {
                                xmlFree(buffer);
                                buffer = tmp2;
                            }
                            xmlFree(name);
                        }
                        xmlFree(prefix);
                    }
                }
            }
            if (ret == NULL) {
                ret = buffer;
            } else {
                xmlChar *tmp;

                tmp = xmlStrcat(ret, BAD_CAST "/");
                if (tmp == NULL) {
                    xmlFree(buffer);
                    ret = NULL;
                    goto out;
                }
                xmlFree(ret);
                ret = tmp;
                tmp = xmlStrcat(ret, buffer);
                if (tmp == NULL) {
                    xmlFree(buffer);
                    ret = NULL;
                    goto