phone = new phonetable();
std::string::const_iterator iter = line.begin();
std::string::const_iterator start_piece = mystrsep(line, iter);
int np = 0;
while (start_piece != line.end()) {
  switch (np) {
    case 0: {
      if (line.compare(start_piece - line.begin(), 5, "PHONE", 5) != 0) {
        HUNSPELL_WARNING(stderr, "error: line %d: missing PHONE keyword\n",
                         fileMgr->getlinenum());
        delete phone;
        return false;
      }
      break;
    }
    case 1: {
      phone->num = atoi(std::string(start_piece, iter).c_str());
      if (phone->num < 1) {
        HUNSPELL_WARNING(stderr, "error: line %d: bad entry number\n",
                         fileMgr->getlinenum());
        delete phone;
        return false;
      }
      phone->rules.reserve(std::min(phone->num, 16384));
      break;
    }
    default: {
      std::string rule(start_piece, iter);
      size_t slash_pos = rule.find('/');
      if (slash_pos != std::string::npos) {
        std::string chunk(rule, slash_pos + 1);
        rule.resize(slash_pos);
        phone->rules.push_back(std::make_pair(rule, pHMgr->decode_flag(chunk)));
      } else {
        phone->rules.push_back(std::make_pair(rule, 0));
      }
      std::replace(phone->rules.back().first.begin(), phone->rules.back().first.end(), '_', ' ');
      break;
    }
  }
  ++np;
  start_piece = mystrsep(line, iter);
}

if (np != 2) {
  HUNSPELL_WARNING(stderr, "error: line %d: missing data\n",
                   fileMgr->getlinenum());
  delete phone;
  return false;
}

if (static_cast<size_t>(phone->num) != phone->rules.size()) {
  HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n",
                   fileMgr->getlinenum());
  delete phone;
  return false;
}

phone->init_hash();
return true;