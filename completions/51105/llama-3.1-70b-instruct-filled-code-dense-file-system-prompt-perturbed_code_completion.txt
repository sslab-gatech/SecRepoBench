// Parse the input line to extract phonetic table parameters.
std::string s;
if (!parse_string(line, s, fileMgr->getlinenum()))
  return false;

// Initialize a new phonetable structure and set its properties.
phone = new phonetable;
phone->clear();

// Validate the line to ensure it contains the correct number of entries.
int numphone = -1;
if (!parse_num(s, &numphone, fileMgr))
  return false;
if (numphone < 1) {
  HUNSPELL_WARNING(stderr, "error: line %d: bad entry number\n",
                   fileMgr->getlinenum());
  return false;
}

// Read and process the specified number of phonetic rules from the file.
for (int j = 0; j < numphone; ++j) {
  std::string nl;
  if (!fileMgr->getline(nl))
    return false;
  mychomp(nl);

  // For each rule, ensure it starts with a "PHONE" keyword, then extract and store the rule details.
  if (nl.compare(0, 5, "PHONE", 5)!= 0) {
    HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n",
                     fileMgr->getlinenum());
    return false;
  }

  // Extract and store the rule details.
  std::string::const_iterator iter = nl.begin();
  std::string::const_iterator start_piece = mystrsep(nl, iter);
  std::string phone_str;
  if (start_piece == nl.end()) {
    HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n",
                     fileMgr->getlinenum());
    return false;
  }
  phone_str.assign(start_piece, iter);

  // Strip underscores from specific parts of the rules before storing them.
  size_t pos = phone_str.find('_');
  if (pos!= std::string::npos)
    phone_str.replace(pos, 1, "");

  // Store the rule details.
  phone->push_back(phone_str);
}

// Verify the integrity of the rules by checking the expected size after insertion.
if (phone->size()!= static_cast<size_t>(numphone)) {
  HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n",
                   fileMgr->getlinenum());
  return false;
}

// Finalize the phonetable by adding empty strings and initializing its hash.
phone->push_back("");
phone->init_hash();