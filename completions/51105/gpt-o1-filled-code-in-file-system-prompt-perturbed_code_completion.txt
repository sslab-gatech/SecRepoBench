int i = 0, np = 0, numphone = -1;
  // Split the initial line "PHONE <num>" into pieces.
  std::string::const_iterator iter = line.begin();
  std::string::const_iterator start_piece = mystrsep(line, iter);
  while (start_piece != line.end()) {
    switch (i) {
      case 0:
        // "PHONE"
        np++;
        break;
      case 1:
        // number of phonetic entries
        numphone = atoi(std::string(start_piece, iter).c_str());
        if (numphone < 1) {
          HUNSPELL_WARNING(stderr, "error: line %d: bad entry number\n",
                           fileMgr->getlinenum());
          return false;
        }
        np++;
        break;
      default:
        break;
    }
    i++;
    start_piece = mystrsep(line, iter);
  }
  // Check basic correctness
  if (np != 2) {
    HUNSPELL_WARNING(stderr, "error: line %d: missing data\n",
                     fileMgr->getlinenum());
    return false;
  }

  // Initialize the phonetable structure
  phone = new phonetable;
  if (!phone) return false;
  phone->num = numphone;
  phone->phonrule.reserve(numphone);

  // Now parse and store each phonetic rule
  for (int j = 0; j < numphone; j++) {
    std::string nl;
    if (!fileMgr->getline(nl)) {
      delete phone;
      phone = NULL;
      return false;
    }
    mychomp(nl);

    // Split each rule line into pieces: "PHONE <pattern> <pattern2> ..."
    int tokens = 0;
    std::string pat, pat2;
    iter = nl.begin();
    start_piece = mystrsep(nl, iter);
    while (start_piece != nl.end()) {
      if (tokens == 0) {
        // Each rule line should start with "PHONE"
        if (nl.compare(start_piece - nl.begin(), 5, "PHONE", 5) != 0) {
          HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n",
                           fileMgr->getlinenum());
          delete phone;
          phone = NULL;
          return false;
        }
      } else if (tokens == 1) {
        // first pattern
        pat.assign(start_piece, iter);
        // strip underscores from pat if needed
        for (size_t k = 0; k < pat.size(); ) {
          if (pat[k] == '_') pat.erase(k,1); else k++;
        }
      } else if (tokens == 2) {
        // second pattern or replacement
        pat2.assign(start_piece, iter);
        // strip underscores
        for (size_t k = 0; k < pat2.size(); ) {
          if (pat2[k] == '_') pat2.erase(k,1); else k++;
        }
      }
      tokens++;
      start_piece = mystrsep(nl, iter);
    }
    if (tokens < 3) {
      HUNSPELL_WARNING(stderr, "error: line %d: bad phonetic rule\n",
                       fileMgr->getlinenum());
      delete phone;
      phone = NULL;
      return false;
    }
    // Store the parsed rule in the table
    phone->phonrule.push_back(std::make_pair(pat, pat2));
  }

  // Hash or index any final data if needed (dummy here)
  // phone->init_hash(); // optionally implement if needed

  return true;