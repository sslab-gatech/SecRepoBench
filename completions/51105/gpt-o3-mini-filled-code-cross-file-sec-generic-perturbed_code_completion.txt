{
  std::istringstream iss(line);
  std::vector<std::string> tokens;
  std::string token;
  while (iss >> token)
    tokens.push_back(token);
  if (tokens.size() < 2) {
    HUNSPELL_WARNING(stderr, "error: line %d: insufficient parameters for phonetable definition\n", fileMgr->getlinenum());
    return false;
  }
  int num_rules = 0;
  try {
    num_rules = std::stoi(tokens[1]);
  } catch (const std::exception&) {
    HUNSPELL_WARNING(stderr, "error: line %d: invalid rule count in phonetable definition\n", fileMgr->getlinenum());
    return false;
  }
  if (num_rules < 1) {
    HUNSPELL_WARNING(stderr, "error: line %d: phonetable must contain at least one rule\n", fileMgr->getlinenum());
    return false;
  }

  // Allocate and initialize the phonetable structure.
  phone = new Phonetable();
  phone->rules.reserve(static_cast<size_t>(num_rules));

  // Read and process the specified number of phonetic rules.
  for (int i = 0; i < num_rules; ++i) {
    std::string rule_line;
    if (!fileMgr->getline(rule_line)) {
      HUNSPELL_WARNING(stderr, "error: line %d: unexpected end of file while reading phonetic rules\n", fileMgr->getlinenum());
      delete phone;
      phone = nullptr;
      return false;
    }
    mychomp(rule_line);

    // Ensure the rule starts with the "PHONE" keyword.
    if (rule_line.compare(0, 5, "PHONE") != 0) {
      HUNSPELL_WARNING(stderr, "error: line %d: phonetic rule does not start with PHONE\n", fileMgr->getlinenum());
      delete phone;
      phone = nullptr;
      return false;
    }

    // Extract the rule details by skipping the "PHONE" keyword.
    std::string rule_detail = rule_line.substr(5);
    // Trim leading whitespace.
    rule_detail.erase(0, rule_detail.find_first_not_of(" \t"));
    // Remove underscores from the rule detail.
    rule_detail.erase(std::remove(rule_detail.begin(), rule_detail.end(), '_'), rule_detail.end());
    phone->rules.push_back(rule_detail);
  }

  // Verify the integrity: Check that the expected number of rules were read.
  if (phone->rules.size() != static_cast<size_t>(num_rules)) {
    HUNSPELL_WARNING(stderr, "error: line %d: phonetable rule count mismatch\n", fileMgr->getlinenum());
    delete phone;
    phone = nullptr;
    return false;
  }

  // Finalize the phonetable by adding an empty string and initializing its hash.
  phone->rules.push_back("");
  std::string combined;
  for (const auto& r : phone->rules)
    combined.append(r);
  phone->hash = std::hash<std::string>()(combined);
}