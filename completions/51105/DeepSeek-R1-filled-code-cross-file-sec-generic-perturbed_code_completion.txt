int numphone = 0;
int np = 0;
int i = 0;
std::string::const_iterator iter = line.begin();
std::string::const_iterator start_piece = mystrsep(line, iter);
while (start_piece != line.end()) {
    switch (i) {
        case 0: {
            np++;
            break;
        }
        case 1: {
            numphone = atoi(std::string(start_piece, iter).c_str());
            if (numphone < 1) {
                HUNSPELL_WARNING(stderr, "error: line %d: bad entry number\n", fileMgr->getlinenum());
                return false;
            }
            phone = new std::vector<std::pair<std::string, std::string>>();
            phone->reserve(std::min(numphone, 16384));
            np++;
            break;
        }
        default:
            break;
    }
    i++;
    start_piece = mystrsep(line, iter);
}
if (np != 2) {
    HUNSPELL_WARNING(stderr, "error: line %d: missing data\n", fileMgr->getlinenum());
    return false;
}

for (int j = 0; j < numphone; ++j) {
    std::string nl;
    if (!fileMgr->getline(nl)) {
        HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n", fileMgr->getlinenum());
        return false;
    }
    mychomp(nl);
    i = 0;
    std::string pattern, replacement;
    iter = nl.begin();
    start_piece = mystrsep(nl, iter);
    while (start_piece != nl.end()) {
        switch (i) {
            case 0: {
                if (nl.compare(start_piece - nl.begin(), 5, "PHONE", 5) != 0) {
                    HUNSPELL_WARNING(stderr, "error: line %d: expected PHONE\n", fileMgr->getlinenum());
                    return false;
                }
                break;
            }
            case 1: {
                pattern.assign(start_piece, iter);
                size_t slash_pos = pattern.find('/');
                if (slash_pos != std::string::npos) {
                    std::string cond(pattern.substr(slash_pos + 1));
                    reverse_condition(cond);
                    pattern = pattern.substr(0, slash_pos + 1) + cond;
                }
                break;
            }
            case 2: {
                replacement.assign(start_piece, iter);
                replacement.erase(std::remove(replacement.begin(), replacement.end(), '_'), replacement.end());
                break;
            }
            default:
                break;
        }
        i++;
        start_piece = mystrsep(nl, iter);
    }
    if (i < 3) {
        HUNSPELL_WARNING(stderr, "error: line %d: missing PHONE data\n", fileMgr->getlinenum());
        return false;
    }
    phone->emplace_back(pattern, replacement);
}

if (static_cast<int>(phone->size()) != numphone) {
    HUNSPELL_WARNING(stderr, "error: line %d: table size mismatch\n", fileMgr->getlinenum());
    return false;
}

phone->emplace_back("", "");
phone->emplace_back("", "");