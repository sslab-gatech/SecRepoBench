// <MASK>
phone = new phonetable();
std::string::const_iterator iter = line.begin();
std::string::const_iterator start_piece = mystrsep(line, iter);
int i = 0;
int np = 0;
while (start_piece != line.end()) {
  switch (i) {
    case 0: {
      if (line.compare(start_piece - line.begin(), 5, "PHONE", 5) != 0) {
        HUNSPELL_WARNING(stderr, "error: line %d: missing PHONE keyword\n",
                         fileMgr->getlinenum());
        delete phone;
        phone = nullptr;
        return false;
      }
      np++;
      break;
    }
    case 1: {
      phone->rules.push_back(std::string(start_piece, iter));
      break;
    }
    default:
      break;
  }
  i++;
  start_piece = mystrsep(line, iter);
}
if (np != 2) {
  HUNSPELL_WARNING(stderr, "error: line %d: missing data\n",
                   fileMgr->getlinenum());
  delete phone;
  phone = nullptr;
  return false;
}
if (phone->rules.size() != static_cast<size_t>(phone->num)) {
  HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n",
                   fileMgr->getlinenum());
  delete phone;
  phone = nullptr;
  return false;
}
for (std::string& rule : phone->rules) {
  size_t pos = rule.find('_');
  while (pos != std::string::npos) {
    rule[pos] = ' ';
    pos = rule.find('_', pos + 1);
  }
}
phone->hash = new std::unordered_set<std::string>();
for (const std::string& rule : phone->rules) {
  phone->hash->insert(rule);
}
return true;