phone = new phonetable();
int num_rules = 0;
std::string::const_iterator iter = line.begin();
std::string::const_iterator start_piece = mystrsep(line, iter);
int i = 0;

while (start_piece != line.end()) {
  if (i == 1) {
    num_rules = atoi(std::string(start_piece, iter).c_str());
    if (num_rules < 1) {
      HUNSPELL_WARNING(stderr, "error: line %d: bad entry number\n", fileMgr->getlinenum());
      delete phone;
      phone = nullptr;
      return false;
    }
    phone->rules.reserve(std::min(num_rules, 16384));
  }
  ++i;
  start_piece = mystrsep(line, iter);
}

if (i != 2) {
  HUNSPELL_WARNING(stderr, "error: line %d: missing data\n", fileMgr->getlinenum());
  delete phone;
  phone = nullptr;
  return false;
}

for (int j = 0; j < num_rules; ++j) {
  std::string nl;
  if (!fileMgr->getline(nl)) {
    delete phone;
    phone = nullptr;
    return false;
  }
  mychomp(nl);
  
  if (nl.compare(0, 5, "PHONE", 5) != 0) {
    HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n", fileMgr->getlinenum());
    delete phone;
    phone = nullptr;
    return false;
  }

  std::string rule;
  iter = nl.begin() + 6;  // Skip "PHONE "
  start_piece = mystrsep(nl, iter);
  if (start_piece != nl.end()) {
    rule.assign(start_piece, iter);
    size_t pos = rule.find('_');
    while (pos != std::string::npos) {
      rule.erase(pos, 1);
      pos = rule.find('_', pos);
    }
    phone->rules.push_back(rule);
  }
}

if (phone->rules.size() != static_cast<size_t>(num_rules)) {
  HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n", fileMgr->getlinenum());
  delete phone;
  phone = nullptr;
  return false;
}

phone->rules.push_back(std::string());
phone->rules.push_back(std::string());
phone->hash.reset(new HashMgr(1, phone));