char version[32];
u_int v1 = 0, v2 = 0, v3 = 0;
int matched = 0;

// Safely copy the version string
if (server_len > off) {
  u_int i, j;
  
  for(i=off, j=0; (i<server_len) && (j<sizeof(version)-1) && (http_server_name[i] != ' '); i++, j++)
    version[j] = http_server_name[i];
  
  version[j] = '\0';
  
  // Parse version numbers (format: X.X.X)
  matched = sscanf(version, "%u.%u.%u", &v1, &v2, &v3);
  
  if(matched >= 2) { // At least major and minor version needed
    char obsolete_message[128];
    int is_obsolete = 0;
    
    if(off == 7) { // Apache
      // Check for obsolete Apache versions
      // Apache 2.4.x < 2.4.52 or Apache 2.2.x/2.0.x or older are considered obsolete
      if((v1 < 2) || 
         (v1 == 2 && v2 < 4) || 
         (v1 == 2 && v2 == 4 && v3 < 52)) {
        is_obsolete = 1;
        snprintf(obsolete_message, sizeof(obsolete_message), 
                 "Obsolete Apache version %u.%u.%u", v1, v2, v3);
      }
    } else { // nginx
      // Check for obsolete Nginx versions
      // nginx 1.20.x < 1.20.2 or nginx 1.18.x < 1.18.0 or older are considered obsolete
      if((v1 < 1) || 
         (v1 == 1 && v2 < 18) || 
         (v1 == 1 && v2 == 18 && v3 < 0) || 
         (v1 == 1 && v2 == 20 && v3 < 2)) {
        is_obsolete = 1;
        snprintf(obsolete_message, sizeof(obsolete_message), 
                 "Obsolete Nginx version %u.%u.%u", v1, v2, v3);
      }
    }
    
    if(is_obsolete) {
      // Set risk indicator for obsolete server
      ndpi_set_risk(ndpi_struct, flow, NDPI_HTTP_OBSOLETE_SERVER, obsolete_message);
    }
  }
}