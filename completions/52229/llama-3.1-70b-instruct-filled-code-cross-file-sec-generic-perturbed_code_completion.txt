// Extract the version number from the server string after the "Apache/" or "nginx/" prefix.
char *version_str = (char *)http_server_name + off;
char *version_end = strchr(version_str,'');
if(version_end == NULL) {
  version_end = (char *)http_server_name + server_len;
}

// Convert the version string into a numeric format.
char major_version_str[4] = {0};
char minor_version_str[4] = {0};
char patch_version_str[4] = {0};
sscanf(version_str, "%3[^.].%3[^.].%3s", major_version_str, minor_version_str, patch_version_str);
int major_version = atoi(major_version_str);
int minor_version = atoi(minor_version_str);
int patch_version = atoi(patch_version_str);

// Check if the version is below a predefined minimum version threshold for either Apache or nginx.
if(strncasecmp(http_server_name, "Apache/", off) == 0) {
  // Minimum version threshold for Apache: 2.4.7
  if(major_version < 2 || (major_version == 2 && (minor_version < 4 || (minor_version == 4 && patch_version < 7)))) {
    char risk_message[64];
    snprintf(risk_message, sizeof(risk_message), "Outdated Apache server version %d.%d.%d", major_version, minor_version, patch_version);
    ndpi_set_risk(ndpi_struct, flow, NDPI_RISK_OUTDATED_SERVER, risk_message);
  }
} else if(strncasecmp(http_server_name, "nginx/", off) == 0) {
  // Minimum version threshold for nginx: 1.6.2
  if(major_version < 1 || (major_version == 1 && (minor_version < 6 || (minor_version == 6 && patch_version < 2)))) {
    char risk_message[64];
    snprintf(risk_message, sizeof(risk_message), "Outdated nginx server version %d.%d.%d", major_version, minor_version, patch_version);
    ndpi_set_risk(ndpi_struct, flow, NDPI_RISK_OUTDATED_SERVER, risk_message);
  }
}