char version_str[16];
      int i, version_major, version_minor, version_patch;
      const char *min_apache_version = "2.4.0";
      const char *min_nginx_version = "1.14.0";

      // Copy version string safely
      for(i = 0; i < sizeof(version_str) - 1 && off + i < server_len && http_server_name[off + i] != ' '; i++) {
        version_str[i] = http_server_name[off + i];
      }
      version_str[i] = '\0';

      // Parse version numbers
      if(sscanf(version_str, "%d.%d.%d", &version_major, &version_minor, &version_patch) == 3) {
        char *min_version = (strncasecmp(http_server_name, "Apache/", 7) == 0) ? min_apache_version : min_nginx_version;
        int min_major, min_minor, min_patch;

        // Parse minimum version numbers
        sscanf(min_version, "%d.%d.%d", &min_major, &min_minor, &min_patch);

        // Compare versions
        if((version_major < min_major) ||
           (version_major == min_major && version_minor < min_minor) ||
           (version_major == min_major && version_minor == min_minor && version_patch < min_patch)) {
          char risk_message[128];
          snprintf(risk_message, sizeof(risk_message), "Outdated %s server version: %s", 
                   (strncasecmp(http_server_name, "Apache/", 7) == 0) ? "Apache" : "nginx", version_str);
          ndpi_set_risk(ndpi_struct, flow, NDPI_OUTDATED_SERVER_VERSION, risk_message);
        }
      }