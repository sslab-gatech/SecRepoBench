char version_str[32];
u_int8_t j;
u_int32_t version = 0;
u_int32_t major = 0, minor = 0, patch = 0;
int parts = 0;

/* Extract version string (e.g., "2.4.0") */
for(j = 0; (j < sizeof(version_str)-1) && ((off+j) < server_len) && 
    (http_server_name[off+j] != ' ') && (http_server_name[off+j] != '\r') && 
    (http_server_name[off+j] != '\n'); j++) {
  version_str[j] = http_server_name[off+j];
}
version_str[j] = '\0';

/* Parse version components */
if(j > 0) {
  parts = sscanf(version_str, "%u.%u.%u", &major, &minor, &patch);
  
  if(parts >= 2) {
    /* Convert to numeric format (same as used in MIN_APACHE_VERSION and MIN_NGINX_VERSION) */
    version = major * 1000000 + minor * 1000 + patch;
    
    char msg[128];
    u_int32_t min_version = (strncasecmp(http_server_name, "Apache/", 7) == 0) ? 
      MIN_APACHE_VERSION : MIN_NGINX_VERSION;
    
    if(version < min_version) {
      char *server_type = (strncasecmp(http_server_name, "Apache/", 7) == 0) ? 
        "Apache" : "nginx";
      
      snprintf(msg, sizeof(msg), "Obsolete %s version %s", server_type, version_str);
      ndpi_set_risk(ndpi_struct, flow, NDPI_HTTP_OBSOLETE_SERVER, msg);
    }
  }
}