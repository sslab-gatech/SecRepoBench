u_int8_t const *tuple_start = payload;
  u_int16_t tuple_len;
  u_int8_t identifier;
  u_int8_t value_len;
  u_int8_t const *value;

  while (payload_len > 0) {
    // Extract the identifier and value length from the current tuple
    identifier = *tuple_start++;
    value_len = *tuple_start++;
    value = tuple_start;
    tuple_len = 2 + value_len;

    // Check the identifier and process the tuple accordingly
    if (identifier == 0x01) { // "host_name" identifier
      if (value_len > 0 && value_len < NDPI_HOSTNAME_LEN) {
        memcpy(ndpiflow->protos.softether.hostname, value, value_len);
        ndpiflow->protos.softether.hostname[value_len] = '\0';
      }
    } else if (identifier == 0x02) { // "ddns_fqdn" identifier
      if (value_len > 0 && value_len < NDPI_HOSTNAME_LEN) {
        memcpy(ndpiflow->protos.softether.fqdn, value, value_len);
        ndpiflow->protos.softether.fqdn[value_len] = '\0';
      }
    }

    // Move to the next tuple
    tuple_start += tuple_len;
    payload_len -= tuple_len;
  }

  if (payload_len > 0 || tuple_count > 0) {
    return NDPI_PROTOCOL_UNKNOWN;
  }

  return 0;