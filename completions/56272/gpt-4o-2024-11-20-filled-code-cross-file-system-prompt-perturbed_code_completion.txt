// Check if the payload length is sufficient
  if (payload_len < sizeof(u_int32_t)) {
    return -1; // Error: insufficient payload length
  }

  // Retrieve the tuple count from the payload
  tuple_count = ntohl(*(u_int32_t *)payload);
  payload += sizeof(u_int32_t);
  payload_len -= sizeof(u_int32_t);

  // Validate the tuple count
  if (tuple_count == 0 || tuple_count > 1000) {
    return -1; // Error: invalid tuple count
  }

  // Process each tuple
  for (u_int32_t i = 0; i < tuple_count; i++) {
    if (payload_len < sizeof(u_int16_t)) {
      return -1; // Error: insufficient payload length for tuple
    }

    u_int16_t tuple_type = ntohs(*(u_int16_t *)payload);
    payload += sizeof(u_int16_t);
    payload_len -= sizeof(u_int16_t);

    if (tuple_type == 1) { // Hostname identifier
      if (payload_len < sizeof(u_int16_t)) {
        return -1; // Error: insufficient payload length for hostname
      }

      u_int16_t hostname_len = ntohs(*(u_int16_t *)payload);
      payload += sizeof(u_int16_t);
      payload_len -= sizeof(u_int16_t);

      if (payload_len < hostname_len || hostname_len >= sizeof(ndpiflow->protos.softether.hostname)) {
        return -1; // Error: invalid hostname length
      }

      memcpy(ndpiflow->protos.softether.hostname, payload, hostname_len);
      ndpiflow->protos.softether.hostname[hostname_len] = '\0';
      payload += hostname_len;
      payload_len -= hostname_len;
    } else if (tuple_type == 2) { // FQDN identifier
      if (payload_len < sizeof(u_int16_t)) {
        return -1; // Error: insufficient payload length for FQDN
      }

      u_int16_t fqdn_len = ntohs(*(u_int16_t *)payload);
      payload += sizeof(u_int16_t);
      payload_len -= sizeof(u_int16_t);

      if (payload_len < fqdn_len || fqdn_len >= sizeof(ndpiflow->protos.softether.fqdn)) {
        return -1; // Error: invalid FQDN length
      }

      memcpy(ndpiflow->protos.softether.fqdn, payload, fqdn_len);
      ndpiflow->protos.softether.fqdn[fqdn_len] = '\0';
      payload += fqdn_len;
      payload_len -= fqdn_len;
    } else {
      // Unknown tuple type, skip it
      if (payload_len < sizeof(u_int16_t)) {
        return -1; // Error: insufficient payload length for unknown tuple
      }

      u_int16_t unknown_len = ntohs(*(u_int16_t *)payload);
      payload += sizeof(u_int16_t);
      payload_len -= sizeof(u_int16_t);

      if (payload_len < unknown_len) {
        return -1; // Error: invalid unknown tuple length
      }

      payload += unknown_len;
      payload_len -= unknown_len;
    }
  }

  // Ensure no unprocessed data remains
  if (payload_len != 0) {
    return -1; // Error: unprocessed data remains
  }