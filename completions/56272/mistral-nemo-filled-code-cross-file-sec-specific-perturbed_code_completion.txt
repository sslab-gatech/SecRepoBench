// Check if the payload length is sufficient and retrieve the tuple count from the payload.
  if (payload_len < 4) {
    return -1; // Insufficient payload length
  }
  tuple_count = ntohl(*(u_int32_t *)payload);

  // Validate the tuple count and adjust the payload and its length accordingly.
  if (tuple_count * 4 > payload_len) {
    return -1; // Invalid tuple count
  }
  payload += 4;
  payload_len -= 4;

  // Extract the first value from the payload to determine if it contains a "host_name" identifier.
  u_int32_t first_value = ntohl(*(u_int32_t *)payload);
  payload += 4;
  payload_len -= 4;

  // Iterate over each tuple in the payload, extracting values and checking their types and identifiers.
  for (u_int32_t i = 0; i < tuple_count; i++) {
    if (payload_len < 4) {
      return -1; // Insufficient payload length for tuple
    }
    u_int32_t value = ntohl(*(u_int32_t *)payload);
    payload += 4;
    payload_len -= 4;

    // Check the type and identifier of the value.
    // If a "host_name" is detected, prepare to store its value in the flow structure's hostname field.
    // If a "ddns_fqdn" identifier is detected, prepare to store its value in the flow structure's fqdn field.
    // Continue processing tuples, adjusting the payload and its length after each extraction.
    // If any unprocessed data remains or tuple count is not exhausted, return an error code.
  }

  if (payload_len > 0 || tuple_count * 4 != payload_len + 4) {
    return -1; // Unprocessed data or incorrect tuple count
  }

  return 0;
}