// Ensure payload length is sufficient for processing
  if (payload_len < sizeof(u_int32_t)) {
    return -1; // Error: insufficient payload length
  }

  // Extract tuple count from the payload
  tuple_count = ntohl(*(u_int32_t *)payload);
  payload += sizeof(u_int32_t);
  payload_len -= sizeof(u_int32_t);

  // Validate tuple count
  if (tuple_count == 0 || tuple_count > MAX_TUPLE_COUNT) {
    return -1; // Error: invalid tuple count
  }

  // Process each tuple
  for (u_int32_t i = 0; i < tuple_count; i++) {
    if (payload_len < sizeof(u_int16_t)) {
      return -1; // Error: insufficient payload length for tuple
    }

    // Extract tuple type
    u_int16_t tuple_type = ntohs(*(u_int16_t *)payload);
    payload += sizeof(u_int16_t);
    payload_len -= sizeof(u_int16_t);

    // Handle "host_name" identifier
    if (tuple_type == HOST_NAME_IDENTIFIER) {
      if (payload_len < MAX_HOSTNAME_LEN) {
        return -1; // Error: insufficient payload length for hostname
      }
      strncpy(ndpiflow->protos.softether.hostname, (char *)payload, MAX_HOSTNAME_LEN - 1);
      ndpiflow->protos.softether.hostname[MAX_HOSTNAME_LEN - 1] = '\0';
      payload += MAX_HOSTNAME_LEN;
      payload_len -= MAX_HOSTNAME_LEN;
    }
    // Handle "ddns_fqdn" identifier
    else if (tuple_type == DDNS_FQDN_IDENTIFIER) {
      if (payload_len < MAX_FQDN_LEN) {
        return -1; // Error: insufficient payload length for FQDN
      }
      strncpy(ndpiflow->protos.softether.fqdn, (char *)payload, MAX_FQDN_LEN - 1);
      ndpiflow->protos.softether.fqdn[MAX_FQDN_LEN - 1] = '\0';
      payload += MAX_FQDN_LEN;
      payload_len -= MAX_FQDN_LEN;
    }
    // Unknown tuple type
    else {
      return -1; // Error: unknown tuple type
    }
  }

  // Ensure no unprocessed data remains
  if (payload_len != 0) {
    return -1; // Error: unprocessed data remains
  }