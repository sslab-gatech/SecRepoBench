// Check if the payload length is sufficient and retrieve the tuple count from the payload.
  if (payload_len < 4) {
    return -1; // Not enough data to read the tuple count
  }

  // Read the tuple count from the payload
  memcpy(&tuple_count, payload, sizeof(tuple_count));
  tuple_count = ntohl(tuple_count); // Convert from network byte order to host byte order

  // Validate the tuple count and adjust the payload and its length accordingly.
  if (tuple_count == 0 || payload_len < 4 + tuple_count * 4) {
    return -1; // Invalid tuple count or insufficient payload length
  }

  // Adjust the payload and its length
  payload += 4;
  payload_len -= 4;

  // Extract the first value from the payload to determine if it contains a "host_name" identifier.
  u_int32_t identifier;
  memcpy(&identifier, payload, sizeof(identifier));
  identifier = ntohl(identifier); // Convert from network byte order to host byte order
  payload += 4;
  payload_len -= 4;

  // Iterate over each tuple in the payload, extracting values and checking their types and identifiers.
  for (u_int32_t i = 0; i < tuple_count; ++i) {
    // Check the identifier of the current tuple
    memcpy(&identifier, payload, sizeof(identifier));
    identifier = ntohl(identifier); // Convert from network byte order to host byte order
    payload += 4;
    payload_len -= 4;

    // Extract the value based on the identifier
    if (identifier == 0x12345678) { // Example identifier for "host_name"
      // Prepare to store the value in the flow structure's hostname field
      if (payload_len < 4) {
        return -1; // Not enough data to read the hostname length
      }

      u_int32_t hostname_len;
      memcpy(&hostname_len, payload, sizeof(hostname_len));
      hostname_len = ntohl(hostname_len); // Convert from network byte order to host byte order
      payload += 4;
      payload_len -= 4;

      if (payload_len < hostname_len) {
        return -1; // Not enough data to read the hostname
      }

      // Store the hostname in the flow structure's hostname field
      // Assuming flow->protos.softether.hostname is a char array
      memcpy(flow->protos.softether.hostname, payload, hostname_len);
      flow->protos.softether.hostname[hostname_len] = '\0'; // Null-terminate the string
      payload += hostname_len;
      payload_len -= hostname_len;
    } else if (identifier == 0x87654321) { // Example identifier for "ddns_fqdn"
      // Prepare to store the value in the flow structure's fqdn field
      if (payload_len < 4) {
        return -1; // Not enough data to read the fqdn length
      }

      u_int32_t fqdn_len;
      memcpy(&fqdn_len, payload, sizeof(fqdn_len));
      fqdn_len = ntohl(fqdn_len); // Convert from network byte order to host byte order
      payload += 4;
      payload_len -= 4;

      if (payload_len < fqdn_len) {
        return -1; // Not enough data to read the fqdn
      }

      // Store the fqdn in the flow structure's fqdn field
      // Assuming flow->protos.softether.fqdn is a char array
      memcpy(flow->protos.softether.fqdn, payload, fqdn_len);
      flow->protos.softether.fqdn[fqdn_len] = '\0'; // Null-terminate the string
      payload += fqdn_len;
      payload_len -= fqdn_len;
    } else {
      // Unrecognized identifier, skip the value
      if (payload_len < 4) {
        return -1; // Not enough data to read the skipped value length
      }

      u_int32_t skipped_len;
      memcpy(&skipped_len, payload, sizeof(skipped_len));
      skipped_len = ntohl(skipped_len); // Convert from network byte order to host byte order
      payload += 4;
      payload_len -= 4;

      if (payload_len < skipped_len) {
        return -1; // Not enough data to read the skipped value
      }

      payload += skipped_len;
      payload_len -= skipped_len;
    }
  }

  // If any unprocessed data remains or tuple count is not exhausted, return an error code.
  if (payload_len > 0) {
    return -1; // Unprocessed data remains
  }

  return 0; // Success