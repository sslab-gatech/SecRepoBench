// <MASK>
char *hostname_ptr = NULL, *fqdn_ptr = NULL;
int hostname_len = 0, fqdn_len = 0;

for (tuple_count = 0; tuple_count < ndpiflow->protos.softether.tuple_count; tuple_count++) {
    u_int8_t identifier = *payload++;
    payload_len--;

    switch (identifier) {
    case 0x01: // "host_name"
        hostname_ptr = (char *)payload;
        hostname_len = strnlen((char *)payload, payload_len);
        payload += hostname_len + 1;
        payload_len -= hostname_len + 1;
        break;
    case 0x02: // "ddns_fqdn"
        fqdn_ptr = (char *)payload;
        fqdn_len = strnlen((char *)payload, payload_len);
        payload += fqdn_len + 1;
        payload_len -= fqdn_len + 1;
        break;
    default:
        // Unknown identifier, skip the value
        while (payload_len > 0 && *payload != '\0') {
            payload++;
            payload_len--;
        }
        if (payload_len > 0) {
            payload++;
            payload_len--;
        }
        break;
    }
}

if (hostname_ptr != NULL && hostname_len > 0) {
    strncpy(ndpiflow->protos.softether.hostname, hostname_ptr, sizeof(ndpiflow->protos.softether.hostname) - 1);
    ndpiflow->protos.softether.hostname[sizeof(ndpiflow->protos.softether.hostname) - 1] = '\0';
}

if (fqdn_ptr != NULL && fqdn_len > 0) {
    strncpy(ndpiflow->protos.softether.fqdn, fqdn_ptr, sizeof(ndpiflow->protos.softether.fqdn) - 1);
    ndpiflow->protos.softether.fqdn[sizeof(ndpiflow->protos.softether.fqdn) - 1] = '\0';
}

if (payload_len > 0 || tuple_count != ndpiflow->protos.softether.tuple_count) {
    return -1;
}

return 0;