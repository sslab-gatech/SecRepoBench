struct softether_value first_value;
  struct softether_value second_value;
  size_t processed_len = 0;
  int tuple_index;
  int host_name_found = 0;
  int ddns_fqdn_found = 0;

  if(payload_len < 4)
    return 1;

  tuple_count = ntohl(get_u_int32_t(payload, 0));
  payload += 4;
  payload_len -= 4;

  if(tuple_count == 0 || tuple_count > 1000)
    return 1;

  for(tuple_index = 0; tuple_index < tuple_count; tuple_index++) {
    processed_len += dissect_softether_tuples(payload + processed_len, payload_len - processed_len,
                                              &first_value, &second_value);
    if(processed_len == 0)
      return 1;

    if(first_value.type == VALUE_STR && second_value.type == VALUE_STR) {
      if(strncmp(first_value.value.ptr.value_str, "host_name", first_value.value_size) == 0) {
        host_name_found = 1;
        strncpy(ndpiflow->protos.softether.hostname, second_value.value.ptr.value_str,
                ndpi_min(sizeof(ndpiflow->protos.softether.hostname) - 1, second_value.value_size));
        ndpiflow->protos.softether.hostname[ndpi_min(sizeof(ndpiflow->protos.softether.hostname) - 1, second_value.value_size)] = '\0';
      } else if(strncmp(first_value.value.ptr.value_str, "ddns_fqdn", first_value.value_size) == 0) {
        ddns_fqdn_found = 1;
        strncpy(ndpiflow->protos.softether.fqdn, second_value.value.ptr.value_str,
                ndpi_min(sizeof(ndpiflow->protos.softether.fqdn) - 1, second_value.value_size));
        ndpiflow->protos.softether.fqdn[ndpi_min(sizeof(ndpiflow->protos.softether.fqdn) - 1, second_value.value_size)] = '\0';
      }
    }
  }

  if(processed_len != payload_len)
    return 1;

  if(host_name_found == 0 || ddns_fqdn_found == 0)
    return 1;

  return 0;