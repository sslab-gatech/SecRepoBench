// Check if the payload length is sufficient and retrieve the tuple count from the payload.
  if (payload_len < 4) {
    return -1; // Not enough data to process
  }

  // Extract the tuple count from the payload
  memcpy(&tuple_count, payload, sizeof(tuple_count));
  tuple_count = ntohl(tuple_count);

  // Validate the tuple count and adjust the payload and its length accordingly.
  if (tuple_count * 4 > payload_len) {
    return -1; // Invalid tuple count
  }

  payload_len -= 4;
  payload += 4;

  // Iterate over each tuple in the payload, extracting values and checking their types and identifiers.
  for (u_int32_t i = 0; i < tuple_count; ++i) {
    u_int8_t type;
    memcpy(&type, payload, sizeof(type));
    payload += sizeof(type);
    payload_len -= sizeof(type);

    if (type == 0x01) { // "host_name" identifier
      // Prepare to store the value in the flow structure's hostname field.
      // Assuming flow->protos.softether.hostname is a buffer to store the hostname.
      if (payload_len < 4) {
        return -1; // Not enough data to process
      }

      u_int32_t hostname_len;
      memcpy(&hostname_len, payload, sizeof(hostname_len));
      hostname_len = ntohl(hostname_len);
      payload += sizeof(hostname_len);
      payload_len -= sizeof(hostname_len);

      if (hostname_len > payload_len) {
        return -1; // Invalid hostname length
      }

      // Copy the hostname to the flow structure's hostname field.
      memset(flow->protos.softether.hostname, 0, NDPI_MAX_FQDN_LEN);
      memcpy(flow->protos.softether.hostname, payload, hostname_len);
      payload += hostname_len;
      payload_len -= hostname_len;
    } else if (type == 0x02) { // "ddns_fqdn" identifier
      // Prepare to store the value in the flow structure's fqdn field.
      // Assuming flow->protos.softether.fqdn is a buffer to store the FQDN.
      if (payload_len < 4) {
        return -1; // Not enough data to process
      }

      u_int32_t fqdn_len;
      memcpy(&fqdn_len, payload, sizeof(fqdn_len));
      fqdn_len = ntohl(fqdn_len);
      payload += sizeof(fqdn_len);
      payload_len -= sizeof(fqdn_len);

      if (fqdn_len > payload_len) {
        return -1; // Invalid FQDN length
      }

      // Copy the FQDN to the flow structure's fqdn field.
      memset(flow->protos.softether.fqdn, 0, NDPI_MAX_FQDN_LEN);
      memcpy(flow->protos.softether.fqdn, payload, fqdn_len);
      payload += fqdn_len;
      payload_len -= fqdn_len;
    } else {
      // Skip unknown types
      continue;
    }
  }

  // If any unprocessed data remains or tuple count is not exhausted, return an error code.
  if (payload_len > 0) {
    return -1; // Unprocessed data remains
  }

  return 0;