if(payload_len < 4) return 1;

  tuple_count = ntohl(get_u_int32_t(payload, 0));
  if(tuple_count == 0) return 1;

  payload += 4;
  payload_len -= 4;

  {
    size_t offset = 0;

    for(u_int32_t i = 0; i < tuple_count; i++) {
      struct softether_value first_value, second_value;
      size_t used = dissect_softether_tuples(payload + offset, payload_len - offset,
                                             &first_value, &second_value);
      if(used == 0 || used > (payload_len - offset)) {
        return 1;
      }

      offset += used;

      if((first_value.type == VALUE_STR || first_value.type == VALUE_UNISTR) &&
         first_value.value.ptr.value_str != NULL) {

        /* Check if it's "host_name" */
        if(first_value.value_size == 9 &&
           memcmp(first_value.value.ptr.value_str, "host_name", 9) == 0) {
          if((second_value.type == VALUE_STR || second_value.type == VALUE_UNISTR) &&
             second_value.value_size < sizeof(ndpiflow->protos.softether.hostname)) {
            memcpy(ndpiflow->protos.softether.hostname,
                   second_value.value.ptr.value_str,
                   second_value.value_size);
            ndpiflow->protos.softether.hostname[second_value.value_size] = '\0';
          }

        /* Check if it's "ddns_fqdn" */
        } else if(first_value.value_size == 8 &&
                  memcmp(first_value.value.ptr.value_str, "ddns_fqdn", 8) == 0) {
          if((second_value.type == VALUE_STR || second_value.type == VALUE_UNISTR) &&
             second_value.value_size < sizeof(ndpiflow->protos.softether.fqdn)) {
            memcpy(ndpiflow->protos.softether.fqdn,
                   second_value.value.ptr.value_str,
                   second_value.value_size);
            ndpiflow->protos.softether.fqdn[second_value.value_size] = '\0';
          }
        }
      }
    }

    /* If there's unprocessed data or not enough for all tuples, return error. */
    if(offset != payload_len) return 1;
  }