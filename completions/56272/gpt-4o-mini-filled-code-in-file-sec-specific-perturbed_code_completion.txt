if (payload_len < 4) {
    return 0; // Not enough data for tuple count
  }

  tuple_count = ntohl(get_u_int32_t(payload, 0));
  if (tuple_count == 0 || payload_len < tuple_count * 8 + 4) {
    return 0; // Invalid tuple count or insufficient data
  }

  payload += 4; // Move past the tuple count
  payload_len -= 4;

  for (u_int32_t i = 0; i < tuple_count; i++) {
    struct softether_value first_value, second_value;
    size_t processed_size = dissect_softether_tuples(payload, payload_len, &first_value, &second_value);
    
    if (processed_size == 0) {
      return 0; // Failed to dissect tuples
    }

    // Check for "host_name" and "ddns_fqdn" identifiers
    if (first_value.type == VALUE_STR && strncmp(first_value.value.ptr.value_str, "host_name", first_value.value_size) == 0) {
      strncpy(ndpiflow->hostname, (char const *)first_value.value.ptr.value_str, sizeof(ndpiflow->hostname) - 1);
      ndpiflow->hostname[sizeof(ndpiflow->hostname) - 1] = '\0'; // Null-terminate
    } else if (first_value.type == VALUE_STR && strncmp(first_value.value.ptr.value_str, "ddns_fqdn", first_value.value_size) == 0) {
      strncpy(ndpiflow->fqdn, (char const *)first_value.value.ptr.value_str, sizeof(ndpiflow->fqdn) - 1);
      ndpiflow->fqdn[sizeof(ndpiflow->fqdn) - 1] = '\0'; // Null-terminate
    }

    payload += processed_size;
    payload_len -= processed_size;
  }

  return 1; // Successfully processed all tuples