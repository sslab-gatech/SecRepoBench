if (payload_len < sizeof(tuple_count)) {
    return -1; // Not enough data for tuple count
  }

  memcpy(&tuple_count, payload, sizeof(tuple_count));
  payload += sizeof(tuple_count);
  payload_len -= sizeof(tuple_count);

  if (payload_len < tuple_count * sizeof(u_int32_t)) {
    return -1; // Not enough data for all tuples
  }

  u_int32_t host_name_identifier = 0x12345678; // Example identifier for host_name
  u_int32_t ddns_fqdn_identifier = 0x87654321; // Example identifier for ddns_fqdn

  for (u_int32_t i = 0; i < tuple_count; i++) {
    u_int32_t identifier;
    u_int32_t value_length;

    memcpy(&identifier, payload, sizeof(identifier));
    payload += sizeof(identifier);
    payload_len -= sizeof(identifier);

    memcpy(&value_length, payload, sizeof(value_length));
    payload += sizeof(value_length);
    payload_len -= sizeof(value_length);

    if (value_length > payload_len) {
      return -1; // Value length exceeds remaining payload
    }

    if (identifier == host_name_identifier) {
      if (value_length < sizeof(ndpiflow->protos.softether.hostname)) {
        memcpy(ndpiflow->protos.softether.hostname, payload, value_length);
        ndpiflow->protos.softether.hostname[value_length] = '\0';
      }
    } else if (identifier == ddns_fqdn_identifier) {
      if (value_length < sizeof(ndpiflow->protos.softether.fqdn)) {
        memcpy(ndpiflow->protos.softether.fqdn, payload, value_length);
        ndpiflow->protos.softether.fqdn[value_length] = '\0';
      }
    }

    payload += value_length;
    payload_len -= value_length;
  }

  if (payload_len != 0) {
    return -1; // Unprocessed data remains
  }