if (payload == NULL || payload_len == 0) {
    return -1; // Error code for insufficient payload
  }

  tuple_count = ntohs(*((u_int16_t const *)payload));
  payload += sizeof(u_int16_t);
  payload_len -= sizeof(u_int16_t);

  if (tuple_count == 0 || payload_len < tuple_count * sizeof(u_int16_t)) {
    return -2; // Error code for invalid tuple count or insufficient payload length
  }

  for (u_int32_t i = 0; i < tuple_count; ++i) {
    if (payload_len < sizeof(u_int16_t)) {
      return -3; // Error code for unexpected end of payload
    }

    u_int16_t identifier = ntohs(*((u_int16_t const *)payload));
    payload += sizeof(u_int16_t);
    payload_len -= sizeof(u_int16_t);

    if (identifier == HOST_NAME_ID) {
      u_int16_t host_name_len = ntohs(*((u_int16_t const *)payload));
      payload += sizeof(u_int16_t);
      payload_len -= sizeof(u_int16_t);

      if (payload_len < host_name_len) {
        return -4; // Error code for insufficient payload for hostname
      }

      memcpy(ndpiflow->protos.softether.hostname, payload, host_name_len);
      ndpiflow->protos.softether.hostname[host_name_len] = '\0';
      payload += host_name_len;
      payload_len -= host_name_len;
    } else if (identifier == DDNS_FQDN_ID) {
      u_int16_t fqdn_len = ntohs(*((u_int16_t const *)payload));
      payload += sizeof(u_int16_t);
      payload_len -= sizeof(u_int16_t);

      if (payload_len < fqdn_len) {
        return -5; // Error code for insufficient payload for FQDN
      }

      memcpy(ndpiflow->protos.softether.fqdn, payload, fqdn_len);
      ndpiflow->protos.softether.fqdn[fqdn_len] = '\0';
      payload += fqdn_len;
      payload_len -= fqdn_len;
    }
  }

  if (payload_len > 0 || i != tuple_count) {
    return -6; // Error code for unprocessed data or mismatched tuple count
  }