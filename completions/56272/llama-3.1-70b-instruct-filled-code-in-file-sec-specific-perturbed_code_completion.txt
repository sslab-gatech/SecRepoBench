u_int32_t tuple_count = ntohl(get_u_int32_t(payload, 0));
payload += 4;
payload_len -= 4;

if(tuple_count == 0 || (u_int64_t)payload_len < (u_int64_t)tuple_count * 8)
  return 1;

struct softether_value first_value;
struct softether_value second_value;
u_int32_t host_name_detected = 0;
u_int32_t ddns_fqdn_detected = 0;

for(u_int32_t i = 0; i < tuple_count; i++) {
  size_t value_siz = dissect_softether_tuples(payload, payload_len, &first_value, &second_value);
  if(value_siz == 0)
    return 1;

  payload += value_siz;
  payload_len -= value_siz;

  if(first_value.type == VALUE_INT && first_value.value.value_int == 0x00000001) {
    if(second_value.type == VALUE_STR && second_value.value.ptr.value_str!= NULL) {
      size_t hostname_len = ndpi_min(sizeof(ndpiflow->protos.softether.hostname) - 1,
                                     second_value.value_size);
      strncpy(ndpiflow->protos.softether.hostname,
              second_value.value.ptr.value_str,
              hostname_len);
      ndpiflow->protos.softether.hostname[hostname_len] = '\0';
      host_name_detected = 1;
    }
  }

  if(first_value.type == VALUE_INT && first_value.value.value_int == 0x00000002) {
    if(second_value.type == VALUE_STR && second_value.value.ptr.value_str!= NULL) {
      size_t fqdn_len = ndpi_min(sizeof(ndpiflow->protos.softether.fqdn) - 1,
                                 second_value.value_size);
      strncpy(ndpiflow->protos.softether.fqdn,
              second_value.value.ptr.value_str,
              fqdn_len);
      ndpiflow->protos.softether.fqdn[fqdn_len] = '\0';
      ddns_fqdn_detected = 1;
    }
  }
}

if(payload_len > 0 || tuple_count == 0)
  return 1;

if(host_name_detected == 0 || ddns_fqdn_detected == 0)
  return 1;

return 0;