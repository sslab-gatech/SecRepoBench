if (payload_len < 4)
    return 1;

  tuple_count = ntohl(get_u_int32_t(payload, 0));
  if (tuple_count == 0 || (u_int64_t)payload_len < (u_int64_t)(tuple_count * 8) + sizeof(tuple_count))
    return 1;

  payload += 4;
  payload_len -= 4;

  for (u_int32_t i = 0; i < tuple_count; i++) {
    struct softether_value first_value, second_value;
    size_t dissected_size = dissect_softether_tuples(payload, payload_len, &first_value, &second_value);
    
    if (dissected_size == 0)
      return 1;

    payload += dissected_size;
    payload_len -= dissected_size;

    if (first_value.type == VALUE_STR && strncmp(first_value.value.ptr.value_str, "host_name", first_value.value_size) == 0) {
      strncpy(ndpiflow->protos.softether.hostname, (char const *)first_value.value.ptr.value_data, first_value.value_size);
      ndpiflow->protos.softether.hostname[first_value.value_size] = '\0';
    } else if (first_value.type == VALUE_STR && strncmp(first_value.value.ptr.value_str, "ddns_fqdn", first_value.value_size) == 0) {
      strncpy(ndpiflow->protos.softether.fqdn, (char const *)first_value.value.ptr.value_data, first_value.value_size);
      ndpiflow->protos.softether.fqdn[first_value.value_size] = '\0';
    }
  }

  return 0;