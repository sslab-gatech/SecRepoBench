if (!packet || !payload || payload_len < sizeof(tuple_count)) {
    return -1; /* Insufficient data or NULL pointer */
  }

  memcpy(&tuple_count, payload, sizeof(tuple_count));
  tuple_count = ntohl(tuple_count);
  payload += sizeof(tuple_count);
  payload_len -= sizeof(tuple_count);

  for (u_int32_t i = 0; i < tuple_count; i++) {
    /* Ensure there's enough data for at least type + length indicators */
    if (payload_len < 2) return -1;

    u_int8_t field_type = payload[0];
    u_int8_t field_len = payload[1];
    payload += 2;
    payload_len -= 2;

    if (payload_len < field_len) return -1;

    if (field_type == 1) { /* Suppose 1 indicates "host_name" */
      size_t copy_len = (field_len < (sizeof(ndpiflow->protos.softether.hostname) - 1))
                        ? field_len
                        : (sizeof(ndpiflow->protos.softether.hostname) - 1);

      memcpy(ndpiflow->protos.softether.hostname, payload, copy_len);
      ndpiflow->protos.softether.hostname[copy_len] = '\0';
    } else if (field_type == 2) { /* Suppose 2 indicates "ddns_fqdn" */
      size_t copy_len = (field_len < (sizeof(ndpiflow->protos.softether.fqdn) - 1))
                        ? field_len
                        : (sizeof(ndpiflow->protos.softether.fqdn) - 1);

      memcpy(ndpiflow->protos.softether.fqdn, payload, copy_len);
      ndpiflow->protos.softether.fqdn[copy_len] = '\0';
    }

    payload += field_len;
    payload_len -= field_len;
  }

  /* If there's unprocessed data or an unexpected mismatch, you might return an error code here. */