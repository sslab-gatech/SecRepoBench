static int dissect_softether_host_fqdn(struct ndpi_flow_struct *ndpiflow,
                                       struct ndpi_packet_struct const *packet) {
  u_int8_t const *payload = packet->payload;
  u_int16_t payload_len = packet->payload_packet_len;
  u_int32_t tuple_count;
  // Initialize variables for processing and flags for hostname and FQDN detection.
  // Check if the payload length is sufficient and retrieve the tuple count from the payload.
  // Validate the tuple count and adjust the payload and its length accordingly.
  // Extract the first value from the payload to determine if it contains a "host_name" identifier.
  // Iterate over each tuple in the payload, extracting values and checking their types and identifiers.
  // If a "host_name" is detected, prepare to store its value in the flow structure's hostname field.
  // If a "ddns_fqdn" identifier is detected, prepare to store its value in the flow structure's fqdn field.
  // Continue processing tuples, adjusting the payload and its length after each extraction.
  // If any unprocessed data remains or tuple count is not exhausted, return an error code.
  if(payload_len < 8)
    return 1;

  tuple_count = ntohl(get_u_int32_t(payload, 0));
  if(tuple_count == 0 || (u_int64_t)payload_len < (u_int64_t)tuple_count * 8 + 8)
    return 1;

  payload += 8;
  payload_len -= 8;

  for (u_int32_t i = 0; i < tuple_count; i++) {
    struct softether_value value;
    size_t value_siz;

    value_siz = dissect_softether_type(VALUE_UNISTR, &value, payload, payload_len);
    if(value_siz == 0)
      return 1;

    payload += value_siz;
    payload_len -= value_siz;

    if (i == 0) {
      // Extract the first value from the payload to determine if it contains a "host_name" identifier.
      if (value.type == VALUE_UNISTR && strncmp((char const *)value.value.ptr.value_unistr, "host_name", NDPI_STATICSTRING_LEN("host_name")) == 0) {
        // If a "host_name" is detected, prepare to store its value in the flow structure's hostname field.
        strncpy(ndpiflow->protos.softether.hostname, (char const *)value.value.ptr.value_unistr + NDPI_STATICSTRING_LEN("host_name"), NDPI_STATICSTRING_LEN("host_name"));
        ndpiflow->protos.softether.hostname[NDPI_STATICSTRING_LEN("host_name") - 1] = '\0';
      } else if (value.type == VALUE_UNISTR && strncmp((char const *)value.value.ptr.value_unistr, "ddns_fqdn", NDPI_STATICSTRING_LEN("ddns_fqdn")) == 0) {
        // If a "ddns_fqdn" identifier is detected, prepare to store its value in the flow structure's fqdn field.
        strncpy(ndpiflow->protos.softether.fqdn, (char const *)value.value.ptr.value_unistr + NDPI_STATICSTRING_LEN("ddns_fqdn"), NDPI_STATICSTRING_LEN("ddns_fqdn"));
        ndpiflow->protos.softether.fqdn[NDPI_STATICSTRING_LEN("ddns_fqdn") - 1] = '\0';
      }
    }
  }

  if (payload_len!= 0)
    return 1;

  return 0;
}