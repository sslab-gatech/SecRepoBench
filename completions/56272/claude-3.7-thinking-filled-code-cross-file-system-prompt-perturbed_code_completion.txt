if (payload_len < 4) {
    return -1;  // Not enough data for tuple count
  }

  // Extract tuple count (first 4 bytes, little endian)
  tuple_count = *(u_int32_t *)payload;
  payload += 4;
  payload_len -= 4;

  // Validate tuple count
  if (tuple_count == 0 || tuple_count > 100 || tuple_count * 5 > payload_len) {
    return -1;  // Invalid tuple count or not enough data
  }

  int expecting_hostname = 0;
  int expecting_fqdn = 0;

  // Process each tuple
  for (u_int32_t i = 0; i < tuple_count; i++) {
    if (payload_len < 5) {  // Need at least type (1 byte) and length (4 bytes)
      return -1;
    }

    u_int8_t value_type = *payload;
    payload++;
    payload_len--;

    u_int32_t value_len = *(u_int32_t *)payload;
    payload += 4;
    payload_len -= 4;

    if (value_len > payload_len) {
      return -1;  // Value length exceeds remaining payload
    }

    // Process based on value type
    if (value_type == 1) {  // String type
      // Check for identifiers
      if (value_len == 9 && memcmp(payload, "host_name", 9) == 0) {
        expecting_hostname = 1;
      }
      else if (value_len == 9 && memcmp(payload, "ddns_fqdn", 9) == 0) {
        expecting_fqdn = 1;
      }
      // Check for values we're expecting
      else if (expecting_hostname) {
        if (value_len < sizeof(ndpiflow->protos.softether.hostname)) {
          memcpy(ndpiflow->protos.softether.hostname, payload, value_len);
          ndpiflow->protos.softether.hostname[value_len] = '\0';
        }
        expecting_hostname = 0;
      }
      else if (expecting_fqdn) {
        if (value_len < sizeof(ndpiflow->protos.softether.fqdn)) {
          memcpy(ndpiflow->protos.softether.fqdn, payload, value_len);
          ndpiflow->protos.softether.fqdn[value_len] = '\0';
        }
        expecting_fqdn = 0;
      }
    }

    // Move to next tuple
    payload += value_len;
    payload_len -= value_len;
  }

  // If we have unprocessed data or didn't finish processing tuples, that's an error
  if (payload_len > 0) {
    return -1;
  }