// <MASK>
if (payload_len < 4) {
  return -1; // Insufficient payload length
}

// Check if the payload starts with a valid SoftEther protocol header
if (payload[0]!= 0x01 || payload[1]!= 0x00 || payload[2]!= 0x00 || payload[3]!= 0x00) {
  return -1; // Invalid protocol header
}

// Extract the tuple count from the payload
tuple_count = (payload[4] << 24) | (payload[5] << 16) | (payload[6] << 8) | payload[7];

// Validate the tuple count
if (tuple_count < 1 || tuple_count > (payload_len - 8) / 8) {
  return -1; // Invalid tuple count
}

// Adjust the payload and its length accordingly
payload += 8;
payload_len -= 8;

// Iterate over each tuple in the payload
for (u_int32_t i = 0; i < tuple_count; i++) {
  // Extract the identifier and value from the tuple
  u_int16_t identifier = (payload[0] << 8) | payload[1];
  u_int32_t value = (payload[2] << 24) | (payload[3] << 16) | (payload[4] << 8) | payload[5];

  // Check if the identifier is a "host_name" or "ddns_fqdn" identifier
  if (identifier == 0x0001 || identifier == 0x0002) {
    // Prepare to store the value in the flow structure's hostname or fqdn field
    if (identifier == 0x0001) {
      // Store the hostname value
      if (flow->protos.softether.hostname[0] == '\0') {
        memcpy(flow->protos.softether.hostname, &payload[6], 256);
        flow->protos.softether.hostname[255] = '\0';
      }
    } else {
      // Store the FQDN value
      if (flow->protos.softether.fqdn[0] == '\0') {
        memcpy(flow->protos.softether.fqdn, &payload[6], 256);
        flow->protos.softether.fqdn[255] = '\0';
      }
    }
  }

  // Adjust the payload and its length after each extraction
  payload += 6;
  payload_len -= 6;
}

// If any unprocessed data remains or tuple count is not exhausted, return an error code
if (payload_len > 0 || tuple_count!= 0) {
  return -1;
}

return 0;