if (payload_len < 4) {
  return -1; // Not enough data for tuple count
}

// Extract tuple count from the payload (first 4 bytes)
u_int32_t tuple_count_n;
memcpy(&tuple_count_n, payload, sizeof(tuple_count_n));
tuple_count = ntohl(tuple_count_n);
payload += 4;
payload_len -= 4;

// Validate tuple count to prevent excessive loop iterations
if (tuple_count > 1000 || tuple_count < 1) {
  return -1; // Invalid tuple count
}

// Process each tuple
for (u_int32_t i = 0; i < tuple_count; i++) {
  u_int16_t value_type;
  u_int16_t identifier_len;
  u_int16_t value_len;
  u_int16_t temp;
  const u_int8_t *identifier_ptr;
  
  // Check if we have enough data for tuple header (6 bytes)
  if (payload_len < 6) {
    return -1; // Not enough data for tuple header
  }
  
  // Extract value type (2 bytes)
  memcpy(&temp, payload, sizeof(temp));
  value_type = ntohs(temp);
  payload += 2;
  payload_len -= 2;
  
  // Extract identifier length (2 bytes)
  memcpy(&temp, payload, sizeof(temp));
  identifier_len = ntohs(temp);
  payload += 2;
  payload_len -= 2;
  
  // Extract value length (2 bytes)
  memcpy(&temp, payload, sizeof(temp));
  value_len = ntohs(temp);
  payload += 2;
  payload_len -= 2;
  
  // Validate lengths to prevent buffer overflows
  if (identifier_len > payload_len || value_len > payload_len - identifier_len) {
    return -1; // Invalid lengths
  }
  
  // Save pointer to identifier
  identifier_ptr = payload;
  
  // Check if identifier is "host_name" (9 bytes)
  if (identifier_len == 9 && memcmp(identifier_ptr, "host_name", 9) == 0) {
    // Skip identifier
    payload += identifier_len;
    payload_len -= identifier_len;
    
    // Store hostname in flow structure
    if (value_len < sizeof(ndpiflow->protos.softether.hostname)) {
      memcpy(ndpiflow->protos.softether.hostname, payload, value_len);
      ndpiflow->protos.softether.hostname[value_len] = '\0'; // Null-terminate
    }
    
    // Move to next tuple
    payload += value_len;
    payload_len -= value_len;
  } 
  // Check if identifier is "ddns_fqdn" (9 bytes)
  else if (identifier_len == 9 && memcmp(identifier_ptr, "ddns_fqdn", 9) == 0) {
    // Skip identifier
    payload += identifier_len;
    payload_len -= identifier_len;
    
    // Store FQDN in flow structure
    if (value_len < sizeof(ndpiflow->protos.softether.fqdn)) {
      memcpy(ndpiflow->protos.softether.fqdn, payload, value_len);
      ndpiflow->protos.softether.fqdn[value_len] = '\0'; // Null-terminate
    }
    
    // Move to next tuple
    payload += value_len;
    payload_len -= value_len;
  } 
  else {
    // Skip both identifier and value
    payload += identifier_len + value_len;
    payload_len -= identifier_len + value_len;
  }
}

// Check if we've processed all data
if (payload_len > 0) {
  return -1; // Unprocessed data remains
}