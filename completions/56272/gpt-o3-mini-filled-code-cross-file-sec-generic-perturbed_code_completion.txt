if (payload_len < sizeof(u_int32_t))
  return -1;

/* Retrieve tuple count from the payload (assuming network byte order) */
tuple_count = ntohl(*(const u_int32_t *)payload);
payload += sizeof(u_int32_t);
payload_len -= sizeof(u_int32_t);

for (u_int32_t i = 0; i < tuple_count; i++) {
  /* Each tuple header consists of: 1 byte type, 1 byte identifier, 2 bytes value length */
  if (payload_len < 4)
    return -1;

  u_int8_t tuple_type = payload[0];
  u_int8_t tuple_id = payload[1];

  u_int16_t net_value_len;
  memcpy(&net_value_len, payload + 2, sizeof(u_int16_t));
  u_int16_t value_len = ntohs(net_value_len);

  payload += 4;
  payload_len -= 4;

  if (payload_len < value_len)
    return -1;

  /* Check tuple identifier for host_name (assumed id 1) or ddns_fqdn (assumed id 2) */
  if (tuple_id == 1) {
    /* Copy host_name safely */
    size_t max_size = sizeof(flow->protos.softether.hostname) - 1;
    size_t copy_len = (value_len < max_size) ? value_len : max_size;
    memcpy(flow->protos.softether.hostname, payload, copy_len);
    flow->protos.softether.hostname[copy_len] = '\0';
  } else if (tuple_id == 2) {
    /* Copy ddns_fqdn safely */
    size_t max_size = sizeof(flow->protos.softether.fqdn) - 1;
    size_t copy_len = (value_len < max_size) ? value_len : max_size;
    memcpy(flow->protos.softether.fqdn, payload, copy_len);
    flow->protos.softether.fqdn[copy_len] = '\0';
  }

  payload += value_len;
  payload_len -= value_len;
}

/* If there is any extra data remaining, consider it as malformed */
if (payload_len != 0)
  return -1;