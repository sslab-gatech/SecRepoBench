if (payload_len < 2) {
    return -1; // Error: insufficient payload length
  }

  tuple_count = (payload[0] << 8) | payload[1];
  payload += 2;
  payload_len -= 2;

  if (tuple_count == 0 || payload_len < tuple_count * 2) {
    return -1; // Error: invalid tuple count or insufficient payload length
  }

  for (u_int32_t i = 0; i < tuple_count; i++) {
    if (payload_len < 2) {
      return -1; // Error: insufficient payload length for tuple
    }

    u_int8_t type = payload[0];
    u_int8_t length = payload[1];
    payload += 2;
    payload_len -= 2;

    if (payload_len < length) {
      return -1; // Error: insufficient payload length for value
    }

    if (type == 0x01) { // host_name identifier
      if (length < sizeof(ndpiflow->protos.softether.hostname)) {
        memcpy(ndpiflow->protos.softether.hostname, payload, length);
        ndpiflow->protos.softether.hostname[length] = '\0';
      }
    } else if (type == 0x02) { // ddns_fqdn identifier
      if (length < sizeof(ndpiflow->protos.softether.fqdn)) {
        memcpy(ndpiflow->protos.softether.fqdn, payload, length);
        ndpiflow->protos.softether.fqdn[length] = '\0';
      }
    }

    payload += length;
    payload_len -= length;
  }

  if (payload_len != 0) {
    return -1; // Error: unprocessed data remains
  }