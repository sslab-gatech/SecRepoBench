// Check if the payload length is sufficient and retrieve the tuple count from the payload.
if (payload_len < 4) {
  return -1; // Insufficient payload length
}

u_int32_t *tuple_count_ptr = (u_int32_t *)payload;
if (*tuple_count_ptr == 0) {
  return -1; // Invalid tuple count
}

tuple_count = *tuple_count_ptr;

// Validate the tuple count and adjust the payload and its length accordingly.
if (tuple_count > (payload_len / 4)) {
  return -1; // Invalid tuple count
}

payload_len -= 4;
payload += 4;

// Extract the first value from the payload to determine if it contains a "host_name" identifier.
u_int8_t *host_name_ptr = (u_int8_t *)payload;
if (ndpi_match_strprefix(host_name_ptr, payload_len, "host_name")) {
  // Prepare to store the hostname value in the flow structure's hostname field.
  flow->hostname = (char *)malloc(payload_len + 1);
  if (flow->hostname == NULL) {
    return -1; // Memory allocation failed
  }
  memcpy(flow->hostname, host_name_ptr, payload_len);
  flow->hostname[payload_len] = '\0';
}

// Iterate over each tuple in the payload, extracting values and checking their types and identifiers.
for (u_int32_t i = 0; i < tuple_count; i++) {
  u_int32_t tuple_len = 0;
  u_int8_t *tuple_ptr = (u_int8_t *)payload;
  // Check the tuple type and identifier
  if (ndpi_match_strprefix(tuple_ptr, payload_len, "ddns_fqdn")) {
    // Prepare to store the FQDN value in the flow structure's fqdn field.
    flow->fqdn = (char *)malloc(payload_len + 1);
    if (flow->fqdn == NULL) {
      return -1; // Memory allocation failed
    }
    memcpy(flow->fqdn, tuple_ptr, payload_len);
    flow->fqdn[payload_len] = '\0';
  }
  // Adjust the payload and its length after each extraction
  payload_len -= 4;
  payload += 4;
}

// If any unprocessed data remains or tuple count is not exhausted, return an error code.
if (payload_len > 0 || tuple_count!= 0) {
  return -1; // Unprocessed data or invalid tuple count
}

return 0;