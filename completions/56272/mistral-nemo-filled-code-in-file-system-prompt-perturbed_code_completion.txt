if(payload_len < 4)
    return 0;

  tuple_count = ntohl(get_u_int32_t(payload, 0));
  if(tuple_count == 0 || (u_int64_t)payload_len < (u_int64_t)tuple_count * tuple_type_len)
    return 0;

  payload += tuple_type_len;
  payload_len -= tuple_type_len;

  for(u_int32_t i = 0; i < tuple_count; i++) {
    struct softether_value first_value, second_value;
    size_t value_siz = dissect_softether_tuples(payload, payload_len, &first_value, &second_value);

    if(value_siz == 0)
      return 1;

    payload += value_siz;
    payload_len -= value_siz;

    if(first_value.type == VALUE_STR && strncmp(first_value.ptr.value_str, "host_name", 9) == 0) {
      if(second_value.type == VALUE_STR || second_value.type == VALUE_UNISTR) {
        strncpy(ndpiflow->protos.softether.hostname, second_value.ptr.value_str, sizeof(ndpiflow->protos.softether.hostname) - 1);
        ndpiflow->protos.softether.hostname[sizeof(ndpiflow->protos.softether.hostname) - 1] = '\0';
      }
    } else if(first_value.type == VALUE_STR && strncmp(first_value.ptr.value_str, "ddns_fqdn", 9) == 0) {
      if(second_value.type == VALUE_STR || second_value.type == VALUE_UNISTR) {
        strncpy(ndpiflow->protos.softether.fqdn, second_value.ptr.value_str, sizeof(ndpiflow->protos.softether.fqdn) - 1);
        ndpiflow->protos.softether.fqdn[sizeof(ndpiflow->protos.softether.fqdn) - 1] = '\0';
      }
    }
  }

  if(payload_len > 0 || tuple_count == 0)
    return 1;

  return 0;