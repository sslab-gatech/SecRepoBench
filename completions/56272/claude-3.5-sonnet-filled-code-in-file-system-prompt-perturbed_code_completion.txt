if(payload_len < 4)
    return 1;

  tuple_count = ntohl(get_u_int32_t(payload, 0));
  if(tuple_count == 0 || tuple_count > 100)
    return 1;

  payload += 4;
  payload_len -= 4;

  struct softether_value first_value, second_value;
  int hostname_detected = 0;
  int fqdn_detected = 0;

  for(u_int32_t i = 0; i < tuple_count; i++) {
    size_t tuple_size = dissect_softether_tuples(payload, payload_len, &first_value, &second_value);
    if(tuple_size == 0)
      return 1;

    if(first_value.type == VALUE_STR && first_value.value_size == 9 &&
       memcmp(first_value.value.ptr.value_str, "host_name", 9) == 0) {
      hostname_detected = 1;
    } else if(first_value.type == VALUE_STR && first_value.value_size == 9 &&
              memcmp(first_value.value.ptr.value_str, "ddns_fqdn", 9) == 0) {
      fqdn_detected = 1;
    }

    if(hostname_detected && second_value.type == VALUE_UNISTR) {
      size_t hostname_len = ndpi_min(sizeof(ndpiflow->protos.softether.hostname) - 1, second_value.value_size / 2);
      for(size_t j = 0; j < hostname_len; j++) {
        ndpiflow->protos.softether.hostname[j] = second_value.value.ptr.value_unistr[j * 2];
      }
      ndpiflow->protos.softether.hostname[hostname_len] = '\0';
      hostname_detected = 0;
    }

    if(fqdn_detected && second_value.type == VALUE_UNISTR) {
      size_t fqdn_len = ndpi_min(sizeof(ndpiflow->protos.softether.fqdn) - 1, second_value.value_size / 2);
      for(size_t j = 0; j < fqdn_len; j++) {
        ndpiflow->protos.softether.fqdn[j] = second_value.value.ptr.value_unistr[j * 2];
      }
      ndpiflow->protos.softether.fqdn[fqdn_len] = '\0';
      fqdn_detected = 0;
    }

    payload += tuple_size;
    payload_len -= tuple_size;
  }

  if(payload_len > 0 || tuple_count > 0)
    return 1;