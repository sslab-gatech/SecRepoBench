if (payload == NULL || ndpiflow == NULL) {
    return -1; // Error: Null pointer detected
  }

  if (payload_len < sizeof(u_int32_t)) {
    return -1; // Error: Payload length too short
  }

  // Extract tuple count from the payload
  tuple_count = ntohl(*(u_int32_t *)payload);
  payload += sizeof(u_int32_t);
  payload_len -= sizeof(u_int32_t);

  if (tuple_count == 0 || payload_len == 0) {
    return -1; // Error: Invalid tuple count or payload length
  }

  for (u_int32_t i = 0; i < tuple_count; i++) {
    if (payload_len < sizeof(u_int8_t)) {
      return -1; // Error: Insufficient payload length
    }

    u_int8_t identifier = *payload;
    payload += sizeof(u_int8_t);
    payload_len -= sizeof(u_int8_t);

    if (identifier == HOSTNAME_IDENTIFIER) {
      if (payload_len < MAX_HOSTNAME_LENGTH) {
        return -1; // Error: Insufficient payload length for hostname
      }
      strncpy(ndpiflow->protos.softether.hostname, (const char *)payload, MAX_HOSTNAME_LENGTH - 1);
      ndpiflow->protos.softether.hostname[MAX_HOSTNAME_LENGTH - 1] = '\0';
      payload += MAX_HOSTNAME_LENGTH;
      payload_len -= MAX_HOSTNAME_LENGTH;
    } else if (identifier == FQDN_IDENTIFIER) {
      if (payload_len < MAX_FQDN_LENGTH) {
        return -1; // Error: Insufficient payload length for FQDN
      }
      strncpy(ndpiflow->protos.softether.fqdn, (const char *)payload, MAX_FQDN_LENGTH - 1);
      ndpiflow->protos.softether.fqdn[MAX_FQDN_LENGTH - 1] = '\0';
      payload += MAX_FQDN_LENGTH;
      payload_len -= MAX_FQDN_LENGTH;
    } else {
      // Skip unknown identifier
      if (payload_len < sizeof(u_int8_t)) {
        return -1; // Error: Insufficient payload length for unknown identifier
      }
      payload += sizeof(u_int8_t);
      payload_len -= sizeof(u_int8_t);
    }
  }

  if (payload_len > 0) {
    return -1; // Error: Unprocessed data remains
  }