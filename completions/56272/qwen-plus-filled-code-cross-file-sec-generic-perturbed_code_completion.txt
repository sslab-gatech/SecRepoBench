if (payload_len < sizeof(u_int32_t)) {
  return -1; // Insufficient payload length
}

// Retrieve tuple count from the payload
tuple_count = ntohl(*(u_int32_t const *)payload);
payload += sizeof(u_int32_t);
payload_len -= sizeof(u_int32_t);

if (tuple_count == 0 || payload_len < tuple_count * sizeof(u_int32_t)) {
  return -2; // Invalid tuple count or insufficient data
}

bool hostname_found = false, fqdn_found = false;
for (u_int32_t i = 0; i < tuple_count && payload_len >= sizeof(u_int32_t); ++i) {
  u_int32_t tuple_type = ntohl(*(u_int32_t const *)payload);
  payload += sizeof(u_int32_t);
  payload_len -= sizeof(u_int32_t);

  if (payload_len < sizeof(u_int32_t)) {
    return -3; // Incomplete tuple
  }

  u_int32_t tuple_len = ntohl(*(u_int32_t const *)payload);
  payload += sizeof(u_int32_t);
  payload_len -= sizeof(u_int32_t);

  if (payload_len < tuple_len) {
    return -4; // Insufficient data for tuple value
  }

  if (tuple_type == HOST_NAME_IDENTIFIER) {
    if (!hostname_found && tuple_len <= NDPI_MAX_HOSTNAME_LEN) {
      memcpy(ndpiflow->protos.softether.hostname, payload, tuple_len);
      ndpiflow->protos.softether.hostname[tuple_len] = '\0';
      hostname_found = true;
    }
  } else if (tuple_type == DDNS_FQDN_IDENTIFIER) {
    if (!fqdn_found && tuple_len <= NDPI_MAX_FQDN_LEN) {
      memcpy(ndpiflow->protos.softether.fqdn, payload, tuple_len);
      ndpiflow->protos.softether.fqdn[tuple_len] = '\0';
      fqdn_found = true;
    }
  }

  payload += tuple_len;
  payload_len -= tuple_len;
}

if (payload_len != 0 || i != tuple_count) {
  return -5; // Unprocessed data or incomplete tuple processing
}

return 0;