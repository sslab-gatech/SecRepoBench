if(payload_len < sizeof(u_int32_t)) {
  return -1; // Insufficient payload length
}

// Retrieve tuple count from the payload (assuming it's stored as a 32-bit value)
tuple_count = ntohl(*(u_int32_t*)payload);
payload += sizeof(u_int32_t);
payload_len -= sizeof(u_int32_t);

if(tuple_count == 0 || payload_len < tuple_count * sizeof(u_int16_t)) {
  return -2; // Invalid tuple count or insufficient payload for tuples
}

u_int8_t const *current_payload = payload;
u_int16_t current_payload_len = payload_len;

for(u_int32_t i = 0; i < tuple_count && current_payload_len >= sizeof(u_int16_t); ++i) {
  u_int16_t identifier = ntohs(*(u_int16_t*)current_payload);
  current_payload += sizeof(u_int16_t);
  current_payload_len -= sizeof(u_int16_t);

  if(identifier == HOST_NAME_ID) { // Assuming HOST_NAME_ID is defined elsewhere
    u_int16_t host_name_length = ntohs(*(u_int16_t*)current_payload);
    current_payload += sizeof(u_int16_t);
    current_payload_len -= sizeof(u_int16_t);

    if(host_name_length > current_payload_len) {
      return -3; // Hostname length exceeds available payload
    }

    strncpy(ndpiflow->protos.softether.hostname, (char*)current_payload, host_name_length);
    ndpiflow->protos.softether.hostname[host_name_length] = '\0'; // Null-terminate

    current_payload += host_name_length;
    current_payload_len -= host_name_length;
  }
  else if(identifier == DDNS_FQDN_ID) { // Assuming DDNS_FQDN_ID is defined elsewhere
    u_int16_t fqdn_length = ntohs(*(u_int16_t*)current_payload);
    current_payload += sizeof(u_int16_t);
    current_payload_len -= sizeof(u_int16_t);

    if(fqdn_length > current_payload_len) {
      return -4; // FQDN length exceeds available payload
    }

    strncpy(ndpiflow->protos.softether.fqdn, (char*)current_payload, fqdn_length);
    ndpiflow->protos.softether.fqdn[fqdn_length] = '\0'; // Null-terminate

    current_payload += fqdn_length;
    current_payload_len -= fqdn_length;
  }
  else {
    // Skip unknown identifiers
    u_int16_t unknown_length = ntohs(*(u_int16_t*)current_payload);
    current_payload += sizeof(u_int16_t);
    current_payload_len -= sizeof(u_int16_t);

    if(unknown_length > current_payload_len) {
      return -5; // Unknown data length exceeds available payload
    }

    current_payload += unknown_length;
    current_payload_len -= unknown_length;
  }
}

if(current_payload_len != 0 || i != tuple_count) {
  return -6; // Unprocessed data remains or tuple count mismatch
}