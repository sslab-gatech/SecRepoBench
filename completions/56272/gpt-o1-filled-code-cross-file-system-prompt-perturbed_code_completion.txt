int i;
  /* Ensure we have enough data for tuple_count */
  if (payload_len < 4)
    return -1;

  /* Retrieve and validate tuple_count */
  tuple_count = ndpi_ntohl(*(const uint32_t *)payload);
  payload += 4;
  payload_len -= 4;

  /* If tuple_count is 0 or unreasonably large, bail out */
  if (tuple_count == 0 || tuple_count > 64)
    return -1;

  /* Iterate through the tuples */
  for (i = 0; i < (int)tuple_count; i++) {
    uint16_t id, len;

    /* Make sure we have enough room for id/len */
    if (payload_len < 4)
      return -1;

    /* Read the identifier */
    id = ndpi_ntohs(*(const uint16_t *)payload);
    payload += 2;
    payload_len -= 2;

    /* Read the data length */
    len = ndpi_ntohs(*(const uint16_t *)payload);
    payload += 2;
    payload_len -= 2;

    /* Check if payload has enough space for the data */
    if (len > payload_len)
      return -1;

    /* If it's host_name */
    if (id == 1) {
      /* Copy host_name into flow struct */
      memset(ndpiflow->protos.softether.hostname, 0, sizeof(ndpiflow->protos.softether.hostname));
      if (len < sizeof(ndpiflow->protos.softether.hostname))
        memcpy(ndpiflow->protos.softether.hostname, payload, len);
      else
        memcpy(ndpiflow->protos.softether.hostname, payload, sizeof(ndpiflow->protos.softether.hostname) - 1);
    }
    /* If it's ddns_fqdn */
    else if (id == 2) {
      /* Copy ddns_fqdn into flow struct */
      memset(ndpiflow->protos.softether.fqdn, 0, sizeof(ndpiflow->protos.softether.fqdn));
      if (len < sizeof(ndpiflow->protos.softether.fqdn))
        memcpy(ndpiflow->protos.softether.fqdn, payload, len);
      else
        memcpy(ndpiflow->protos.softether.fqdn, payload, sizeof(ndpiflow->protos.softether.fqdn) - 1);
    }

    /* Move past this tuple's data */
    payload += len;
    payload_len -= len;
  }

  /* If there's leftover data, return an error */
  if (payload_len != 0)
    return -1;