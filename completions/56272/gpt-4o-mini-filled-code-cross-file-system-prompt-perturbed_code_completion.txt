if (payload_len < 4) {
    return -1; // Error: insufficient payload length
  }

  // Assuming the first 2 bytes represent the tuple count
  tuple_count = (payload[0] << 8) | payload[1];
  payload += 2; // Move past the tuple count
  payload_len -= 2;

  if (tuple_count == 0 || payload_len < tuple_count * 2) {
    return -1; // Error: invalid tuple count or insufficient payload length
  }

  for (u_int32_t i = 0; i < tuple_count; i++) {
    u_int16_t identifier = (payload[0] << 8) | payload[1];
    payload += 2; // Move past the identifier
    payload_len -= 2;

    if (payload_len < 2) {
      return -1; // Error: insufficient payload length for value
    }

    u_int16_t value_length = (payload[0] << 8) | payload[1];
    payload += 2; // Move past the value length
    payload_len -= 2;

    if (payload_len < value_length) {
      return -1; // Error: insufficient payload length for value
    }

    if (identifier == HOST_NAME_IDENTIFIER) {
      strncpy(flow->protos.softether.hostname, (const char *)payload, value_length);
      flow->protos.softether.hostname[value_length] = '\0'; // Null-terminate
    } else if (identifier == DDNS_FQDN_IDENTIFIER) {
      strncpy(flow->protos.softether.fqdn, (const char *)payload, value_length);
      flow->protos.softether.fqdn[value_length] = '\0'; // Null-terminate
    }

    payload += value_length; // Move past the value
    payload_len -= value_length;
  }

  return 0; // Success