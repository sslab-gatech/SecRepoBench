struct softether_value first_value;
  struct softether_value second_value;
  size_t processed_len = 0;
  u_int32_t tuple_count;

  if (payload_len < sizeof(tuple_count))
    return 1;

  tuple_count = ntohl(get_u_int32_t(payload, 0));
  payload += sizeof(tuple_count);
  payload_len -= sizeof(tuple_count);

  for (u_int32_t i = 0; i < tuple_count; i++) {
    size_t tuple_len = dissect_softether_tuples(payload, payload_len, &first_value, &second_value);
    if (tuple_len == 0)
      return 1;

    if (first_value.type == VALUE_STR && second_value.type == VALUE_STR) {
      if (strncmp(first_value.value.ptr.value_str, "host_name", first_value.value_size) == 0) {
        size_t len = ndpi_min(sizeof(ndpiflow->protos.softether.hostname) - 1, second_value.value_size);
        strncpy(ndpiflow->protos.softether.hostname, second_value.value.ptr.value_str, len);
        ndpiflow->protos.softether.hostname[len] = '\0';
      } else if (strncmp(first_value.value.ptr.value_str, "ddns_fqdn", first_value.value_size) == 0) {
        size_t len = ndpi_min(sizeof(ndpiflow->protos.softether.fqdn) - 1, second_value.value_size);
        strncpy(ndpiflow->protos.softether.fqdn, second_value.value.ptr.value_str, len);
        ndpiflow->protos.softether.fqdn[len] = '\0';
      }
    }

    processed_len += tuple_len;
    payload += tuple_len;
    payload_len -= tuple_len;
  }

  if (processed_len != payload_len + sizeof(tuple_count))
    return 1;

  return 0;