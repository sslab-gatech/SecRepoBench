if (payload_len < 4) {
    return -1; // Error: insufficient payload length
  }

  // Assuming the first 4 bytes represent the tuple count
  tuple_count = ntohl(*(u_int32_t *)payload);
  payload += 4;
  payload_len -= 4;

  if (tuple_count == 0 || payload_len < tuple_count * 2) {
    return -1; // Error: invalid tuple count or insufficient payload length
  }

  for (u_int32_t i = 0; i < tuple_count; i++) {
    u_int16_t identifier = ntohs(*(u_int16_t *)payload);
    payload += 2;
    payload_len -= 2;

    if (payload_len < 2) {
      return -1; // Error: insufficient payload length for value
    }

    u_int16_t value_length = ntohs(*(u_int16_t *)payload);
    payload += 2;
    payload_len -= 2;

    if (value_length > payload_len) {
      return -1; // Error: value length exceeds remaining payload
    }

    if (identifier == HOST_NAME_IDENTIFIER) {
      strncpy(flow->protos.softether.hostname, (const char *)payload, value_length);
      flow->protos.softether.hostname[value_length] = '\0'; // Null-terminate
    } else if (identifier == DDNS_FQDN_IDENTIFIER) {
      strncpy(flow->protos.softether.fqdn, (const char *)payload, value_length);
      flow->protos.softether.fqdn[value_length] = '\0'; // Null-terminate
    }

    payload += value_length;
    payload_len -= value_length;
  }

  return 0; // Success