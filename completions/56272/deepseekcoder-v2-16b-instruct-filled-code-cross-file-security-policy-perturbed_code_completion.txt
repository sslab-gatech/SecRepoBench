// <MASK>
  u_int8_t *temp_hostname = NULL;
  u_int8_t *temp_fqdn = NULL;
  u_int32_t tuple_index = 0;
  u_int32_t tuple_offset = 0;

  // Check if the payload length is sufficient and retrieve the tuple count from the payload.
  if (payload_len < 4) {
    return -1; // Not enough data to read the tuple count.
  }

  // Read the tuple count from the payload.
  tuple_count = (payload[0] << 24) | (payload[1] << 16) | (payload[2] << 8) | payload[3];
  tuple_offset = 4;

  // Validate the tuple count and adjust the payload and its length accordingly.
  if (tuple_count == 0 || tuple_count > payload_len - tuple_offset) {
    return -1; // Invalid tuple count.
  }

  payload_len -= tuple_offset;
  payload += tuple_offset;

  // Extract the first value from the payload to determine if it contains a "host_name" identifier.
  if (payload_len < 1 || payload[0] != 0x01) {
    return -1; // No "host_name" identifier found.
  }

  // Iterate over each tuple in the payload, extracting values and checking their types and identifiers.
  for (tuple_index = 0; tuple_index < tuple_count; tuple_index++) {
    if (payload_len < 1) {
      return -1; // Not enough data to read the tuple type.
    }

    u_int8_t tuple_type = payload[0];
    payload++;
    payload_len--;

    switch (tuple_type) {
      case 0x01: // host_name
        if (payload_len < 1) {
          return -1; // Not enough data to read the hostname length.
        }

        u_int16_t hostname_len = payload[0];
        payload++;
        payload_len--;

        if (payload_len < hostname_len) {
          return -1; // Not enough data to read the hostname.
        }

        temp_hostname = (u_int8_t *)malloc(hostname_len + 1);
        if (!temp_hostname) {
          return -1; // Memory allocation failed.
        }

        memcpy(temp_hostname, payload, hostname_len);
        temp_hostname[hostname_len] = '\0';
        payload += hostname_len;
        payload_len -= hostname_len;

        // Store the hostname in the flow structure's hostname field.
        if (ndpiflow->hostname) {
          free(ndpiflow->hostname);
        }
        ndpiflow->hostname = temp_hostname;
        temp_hostname = NULL;
        break;

      case 0x02: // ddns_fqdn
        if (payload_len < 1) {
          return -1; // Not enough data to read the FQDN length.
        }

        u_int16_t fqdn_len = payload[0];
        payload++;
        payload_len--;

        if (payload_len < fqdn_len) {
          return -1; // Not enough data to read the FQDN.
        }

        temp_fqdn = (u_int8_t *)malloc(fqdn_len + 1);
        if (!temp_fqdn) {
          return -1; // Memory allocation failed.
        }

        memcpy(temp_fqdn, payload, fqdn_len);
        temp_fqdn[fqdn_len] = '\0';
        payload += fqdn_len;
        payload_len -= fqdn_len;

        // Store the FQDN in the flow structure's fqdn field.
        if (ndpiflow->fqdn) {
          free(ndpiflow->fqdn);
        }
        ndpiflow->fqdn = temp_fqdn;
        temp_fqdn = NULL;
        break;

      default:
        // Unrecognized tuple type, continue processing.
        break;
    }
  }

  // If any unprocessed data remains or tuple count is not exhausted, return an error code.
  if (payload_len > 0) {
    return -1; // Unprocessed data remains.
  }

  return 0;