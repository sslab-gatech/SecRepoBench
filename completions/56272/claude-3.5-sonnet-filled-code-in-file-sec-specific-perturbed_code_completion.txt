if (payload_len < sizeof(u_int32_t))
    return 1;

tuple_count = ntohl(get_u_int32_t(payload, 0));
if (tuple_count == 0 || tuple_count > (payload_len - sizeof(u_int32_t)) / 8)
    return 1;

payload += sizeof(u_int32_t);
payload_len -= sizeof(u_int32_t);

int hostname_found = 0;
int fqdn_found = 0;

for (u_int32_t i = 0; i < tuple_count; i++) {
    struct softether_value first_value, second_value;
    size_t tuple_size = dissect_softether_tuples(payload, payload_len, &first_value, &second_value);
    
    if (tuple_size == 0 || tuple_size > payload_len)
        return 1;

    if (first_value.type == VALUE_STR && first_value.value_size == 9 &&
        memcmp(first_value.value.ptr.value_str, "host_name", 9) == 0) {
        hostname_found = 1;
        if (second_value.type == VALUE_STR && second_value.value_size < sizeof(ndpiflow->protos.softether.hostname)) {
            memcpy(ndpiflow->protos.softether.hostname, second_value.value.ptr.value_str, second_value.value_size);
            ndpiflow->protos.softether.hostname[second_value.value_size] = '\0';
        }
    } else if (first_value.type == VALUE_STR && first_value.value_size == 9 &&
               memcmp(first_value.value.ptr.value_str, "ddns_fqdn", 9) == 0) {
        fqdn_found = 1;
        if (second_value.type == VALUE_STR && second_value.value_size < sizeof(ndpiflow->protos.softether.fqdn)) {
            memcpy(ndpiflow->protos.softether.fqdn, second_value.value.ptr.value_str, second_value.value_size);
            ndpiflow->protos.softether.fqdn[second_value.value_size] = '\0';
        }
    }

    payload += tuple_size;
    payload_len -= tuple_size;

    if (hostname_found && fqdn_found)
        break;
}

if (payload_len > 0 || i < tuple_count)
    return 1;

return 0;