if (payload_len < 4)
  return -1;

tuple_count = ntohl(*(u_int32_t const *) payload);
payload += 4;
payload_len -= 4;

if (tuple_count == 0)
  return -1;

while (tuple_count > 0) {
  /* Each tuple: 1 byte for key length, key, 1 byte for value length, value */
  if (payload_len < 2)
    return -1;

  u_int8_t key_len = payload[0];
  if (payload_len < (1 + key_len + 1))
    return -1;
  /* Extract the key (identifier) */
  char key[64];
  if (key_len >= sizeof(key))
    return -1;

  memcpy(key, payload + 1, key_len);
  key[key_len] = '\0';

  u_int8_t value_len = payload[1 + key_len];
  if (payload_len < (1 + key_len + 1 + value_len))
    return -1;

  /* Check for host_name or ddns_fqdn keywords */
  if (strcmp(key, "host_name") == 0) {
    int copy_len = (value_len < (int) sizeof(ndpiflow->protos.softether.hostname) - 1)
                     ? value_len
                     : (int) sizeof(ndpiflow->protos.softether.hostname) - 1;
    memcpy(ndpiflow->protos.softether.hostname, payload + 1 + key_len + 1, copy_len);
    ndpiflow->protos.softether.hostname[copy_len] = '\0';
  }
  else if (strcmp(key, "ddns_fqdn") == 0) {
    int copy_len = (value_len < (int) sizeof(ndpiflow->protos.softether.fqdn) - 1)
                     ? value_len
                     : (int) sizeof(ndpiflow->protos.softether.fqdn) - 1;
    memcpy(ndpiflow->protos.softether.fqdn, payload + 1 + key_len + 1, copy_len);
    ndpiflow->protos.softether.fqdn[copy_len] = '\0';
  }

  /* Advance pointer past this tuple */
  u_int16_t tuple_size = 1 + key_len + 1 + value_len;
  if (tuple_size > payload_len)
    return -1;

  payload += tuple_size;
  payload_len -= tuple_size;
  tuple_count--;
}

if (payload_len != 0)
  return -1;