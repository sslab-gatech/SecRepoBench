// Initialize variables for processing and flags for hostname and FQDN detection.
u_int8_t *payload_ptr = payload;
u_int16_t remaining_payload_len = payload_len;
u_int32_t tuple_count = 0;
u_int8_t hostname_detected = 0;
u_int8_t fqdn_detected = 0;

// Check if the payload length is sufficient and retrieve the tuple count from the payload.
if (remaining_payload_len < 4) {
    return -1;
}
tuple_count = ntohs(*((u_int16_t *)payload_ptr));
payload_ptr += 2;
remaining_payload_len -= 2;

// Validate the tuple count and adjust the payload and its length accordingly.
if (tuple_count > remaining_payload_len / 4) {
    return -1;
}
payload_ptr += 2;
remaining_payload_len -= 2;

// Extract the first value from the payload to determine if it contains a "host_name" identifier.
u_int16_t value_type = ntohs(*((u_int16_t *)payload_ptr));
payload_ptr += 2;
remaining_payload_len -= 2;
if (value_type == 0x0001) { // "host_name" identifier
    hostname_detected = 1;
}

// Iterate over each tuple in the payload, extracting values and checking their types and identifiers.
for (u_int32_t i = 0; i < tuple_count; i++) {
    if (remaining_payload_len < 4) {
        return -1;
    }
    u_int16_t value_type = ntohs(*((u_int16_t *)payload_ptr));
    payload_ptr += 2;
    remaining_payload_len -= 2;
    u_int16_t value_len = ntohs(*((u_int16_t *)payload_ptr));
    payload_ptr += 2;
    remaining_payload_len -= 2;
    if (value_type == 0x0001) { // "host_name" identifier
        if (hostname_detected == 0) {
            hostname_detected = 1;
            strncpy(ndpiflow->protos.softether.hostname, (char *)payload_ptr, value_len);
            ndpiflow->protos.softether.hostname[value_len] = '\0';
        }
    } else if (value_type == 0x0002) { // "ddns_fqdn" identifier
        if (fqdn_detected == 0) {
            fqdn_detected = 1;
            strncpy(ndpiflow->protos.softether.fqdn, (char *)payload_ptr, value_len);
            ndpiflow->protos.softether.fqdn[value_len] = '\0';
        }
    }
    payload_ptr += value_len;
    remaining_payload_len -= value_len;
}

// If any unprocessed data remains or tuple count is not exhausted, return an error code.
if (remaining_payload_len > 0 || tuple_count > 0) {
    return -1;
}