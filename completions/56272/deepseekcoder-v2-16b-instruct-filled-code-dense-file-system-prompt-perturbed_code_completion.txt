// <MASK>
  struct softether_value first_value, second_value;
  size_t tuple_size;
  u_int32_t tuple_count = 0;
  u_int8_t const *payload_start = payload;

  while (payload_len > 0) {
    tuple_size = dissect_softether_tuples(payload, payload_len, &first_value, &second_value);
    if (tuple_size == 0) {
      return -1; // Error in dissecting tuples
    }

    payload += tuple_size;
    payload_len -= tuple_size;
    tuple_count++;

    if (first_value.type == SOFTETHER_VALUE_TYPE_HOST_NAME) {
      // Store the value in the flow structure's hostname field
      // Assuming flow->protos.softether.hostname is a char array
      strncpy(flow->protos.softether.hostname, first_value.value, sizeof(flow->protos.softether.hostname) - 1);
      flow->protos.softether.hostname[sizeof(flow->protos.softether.hostname) - 1] = '\0';
    } else if (first_value.type == SOFTETHER_VALUE_TYPE_DDNS_FQDN) {
      // Store the value in the flow structure's fqdn field
      // Assuming flow->protos.softether.fqdn is a char array
      strncpy(flow->protos.softether.fqdn, first_value.value, sizeof(flow->protos.softether.fqdn) - 1);
      flow->protos.softether.fqdn[sizeof(flow->protos.softether.fqdn) - 1] = '\0';
    }
  }

  if (payload_len > 0 || tuple_count == 0) {
    return -1; // Error in processing tuples
  }

  return 0;