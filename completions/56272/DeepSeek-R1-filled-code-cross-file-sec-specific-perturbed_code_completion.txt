if (payload_len < 4)
        return 1;

    tuple_count = ntohl(*(const u_int32_t*)payload);
    payload += 4;
    payload_len -= 4;

    for (u_int32_t i = 0; i < tuple_count; ++i) {
        if (payload_len < 1)
            return 1;

        u_int8_t id_len = *payload++;
        --payload_len;

        if (id_len == 0 || id_len > payload_len)
            return 1;

        const char *identifier = (const char*)payload;
        payload += id_len;
        payload_len -= id_len;

        if (payload_len < 2)
            return 1;

        u_int16_t val_len = ntohs(*(const u_int16_t*)payload);
        payload += 2;
        payload_len -= 2;

        if (val_len > payload_len)
            return 1;

        if (id_len == 9) {
            if (memcmp(identifier, "host_name", 9) == 0) {
                size_t copy_len = val_len < sizeof(flow->protos.softether.hostname) - 1 ? val_len : sizeof(flow->protos.softether.hostname) - 1;
                memcpy(flow->protos.softether.hostname, payload, copy_len);
                flow->protos.softether.hostname[copy_len] = '\0';
            } else if (memcmp(identifier, "ddns_fqdn", 9) == 0) {
                size_t copy_len = val_len < sizeof(flow->protos.softether.fqdn) - 1 ? val_len : sizeof(flow->protos.softether.fqdn) - 1;
                memcpy(flow->protos.softether.fqdn, payload, copy_len);
                flow->protos.softether.fqdn[copy_len] = '\0';
            }
        }

        payload += val_len;
        payload_len -= val_len;
    }

    if (payload_len != 0)
        return 1;