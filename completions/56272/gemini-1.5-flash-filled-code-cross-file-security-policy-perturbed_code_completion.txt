if (payload_len < sizeof(tuple_count)) {
    return -1;
  }
  memcpy(&tuple_count, payload, sizeof(tuple_count));
  payload += sizeof(tuple_count);
  payload_len -= sizeof(tuple_count);
  if (tuple_count == 0 || payload_len == 0) {
    return -1;
  }
  u_int32_t value_len;
  u_int32_t value_type;
  u_int32_t value_id;
  char *hostname = NULL;
  char *fqdn = NULL;
  for (u_int32_t i = 0; i < tuple_count; i++) {
    if (payload_len < sizeof(value_len) + sizeof(value_type) + sizeof(value_id)) {
      return -1;
    }
    memcpy(&value_len, payload, sizeof(value_len));
    payload += sizeof(value_len);
    payload_len -= sizeof(value_len);
    memcpy(&value_type, payload, sizeof(value_type));
    payload += sizeof(value_type);
    payload_len -= sizeof(value_type);
    memcpy(&value_id, payload, sizeof(value_id));
    payload += sizeof(value_id);
    payload_len -= sizeof(value_id);
    if (payload_len < value_len) {
      return -1;
    }
    if (value_id == 1 && value_type == 1) {
      if (hostname) {
        free(hostname);
      }
      hostname = (char *)malloc(value_len + 1);
      if (!hostname) {
        return -1;
      }
      memcpy(hostname, payload, value_len);
      hostname[value_len] = '\0';
      ndpiflow->protos.softether.hostname = hostname;
    } else if (value_id == 2 && value_type == 1) {
      if (fqdn) {
        free(fqdn);
      }
      fqdn = (char *)malloc(value_len + 1);
      if (!fqdn) {
        return -1;
      }
      memcpy(fqdn, payload, value_len);
      fqdn[value_len] = '\0';
      ndpiflow->protos.softether.fqdn = fqdn;
    }
    payload += value_len;
    payload_len -= value_len;
  }
  if (payload_len > 0) {
    return -1;
  }