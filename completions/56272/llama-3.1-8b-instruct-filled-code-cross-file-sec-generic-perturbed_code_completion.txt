static int dissect_softether_host_fqdn(struct ndpi_flow_struct *ndpiflow,
                                       struct ndpi_packet_struct const *packet) {
  u_int8_t const *payload = packet->payload;
  u_int16_t payload_len = packet->payload_packet_len;
  u_int32_t tuple_count;
  // Initialize variables for processing and flags for hostname and FQDN detection.
  // Check if the payload length is sufficient and retrieve the tuple count from the payload.
  // Validate the tuple count and adjust the payload and its length accordingly.
  // Extract the first value from the payload to determine if it contains a "host_name" identifier.
  // Iterate over each tuple in the payload, extracting values and checking their types and identifiers.
  // If a "host_name" is detected, prepare to store its value in the flow structure's hostname field.
  // If a "ddns_fqdn" identifier is detected, prepare to store its value in the flow structure's fqdn field.
  // Continue processing tuples, adjusting the payload and its length after each extraction.
  // If any unprocessed data remains or tuple count is not exhausted, return an error code.
  if (payload_len < 4) {
    return -1; // Insufficient payload length
  }

  tuple_count = ndpi_get_be32(payload);
  if (tuple_count == 0) {
    return -1; // Invalid tuple count
  }

  payload += 4;
  payload_len -= 4;

  while (payload_len >= 4 && tuple_count > 0) {
    u_int8_t const *tuple = payload;
    u_int8_t const *end = payload + 4;
    u_int8_t const *value = NULL;
    u_int8_t const *value_end = NULL;
    u_int8_t const *identifier = NULL;
    u_int8_t const *identifier_end = NULL;

    // Check if the tuple contains a "host_name" identifier
    if (ndpi_match_strprefix(tuple, 4, "host_name")) {
      value = tuple + 4;
      value_end = value + 4;
      identifier = tuple;
      identifier_end = tuple + 4;
    }
    // Check if the tuple contains a "ddns_fqdn" identifier
    else if (ndpi_match_strprefix(tuple, 4, "ddns_fqdn")) {
      value = tuple + 4;
      value_end = value + 4;
      identifier = tuple;
      identifier_end = tuple + 4;
    }

    if (value!= NULL) {
      // Store the value in the flow structure's hostname or fqdn field
      if (identifier!= NULL && ndpi_match_strprefix(identifier, 4, "host_name")) {
        ndpiflow->protos.softether.hostname = ndpi_strdup(value, value_end - value);
      } else if (identifier!= NULL && ndpi_match_strprefix(identifier, 4, "ddns_fqdn")) {
        ndpiflow->protos.softether.fqdn = ndpi_strdup(value, value_end - value);
      }
    }

    payload += 4;
    payload_len -= 4;
    tuple_count--;
  }

  // If any unprocessed data remains or tuple count is not exhausted, return an error code
  if (payload_len > 0 || tuple_count > 0) {
    return -1;
  }

  return 0;
}