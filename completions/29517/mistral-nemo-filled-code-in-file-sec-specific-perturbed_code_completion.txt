# Fill in the masked region with the appropriate code

def Mat_Critical(message):
    print(f"MATIO: {message}")

def Mat_VarFree(matvar):
    if matvar is not None:
        if matvar.data is not None:
            if matvar.isComplex:
                ComplexFree(matvar.data)
            else:
                free(matvar.data)
        if matvar.internal is not None:
            if matvar.internal.hdf5_name is not None:
                free(matvar.internal.hdf5_name)
            if matvar.internal.fieldnames is not None:
                for i in range(matvar.internal.num_fields):
                    if matvar.internal.fieldnames[i] is not None:
                        free(matvar.internal.fieldnames[i])
                free(matvar.internal.fieldnames)
            free(matvar.internal)
        free(matvar)

def Mat_VarCalloc():
    matvar = Mat_VarCreate()
    if matvar is None:
        return None
    matvar.internal = Mat_VarInternalCreate()
    if matvar.internal is None:
        Mat_VarFree(matvar)
        return None
    return matvar

def Mat_VarCreate():
    matvar = None
    try:
        matvar = matvar_t()
    except MemoryError:
        pass
    return matvar

def Mat_VarInternalCreate():
    internal = None
    try:
        internal = matvar_internal_t()
    except MemoryError:
        pass
    return internal

def Mat_SizeOf(class_type):
    if class_type == MAT_C_DOUBLE:
        return 8
    elif class_type == MAT_C_SINGLE:
        return 4
    elif class_type == MAT_C_INT64:
        return 8
    elif class_type == MAT_C_UINT64:
        return 8
    elif class_type == MAT_C_INT32:
        return 4
    elif class_type == MAT_C_UINT32:
        return 4
    elif class_type == MAT_C_INT16:
        return 2
    elif class_type == MAT_C_UINT16:
        return 2
    elif class_type == MAT_C_INT8:
        return 1
    elif class_type == MAT_C_UINT8:
        return 1
    elif class_type == MAT_C_CHAR:
        return 1
    else:
        return 0

def Mat_SizeOfClass(class_type):
    if class_type == MAT_C_DOUBLE:
        return 8
    elif class_type == MAT_C_SINGLE:
        return 4
    elif class_type == MAT_C_INT64:
        return 8
    elif class_type == MAT_C_UINT64:
        return 8
    elif class_type == MAT_C_INT32:
        return 4
    elif class_type == MAT_C_UINT32:
        return 4
    elif class_type == MAT_C_INT16:
        return 2
    elif class_type == MAT_C_UINT16:
        return 2
    elif class_type == MAT_C_INT8:
        return 1
    elif class_type == MAT_C_UINT8:
        return 1
    elif class_type == MAT_C_CHAR:
        return 1
    else:
        return 0

def Mat_MulDims(matvar, dims):
    if matvar is None or dims is None:
        return MATIO_E_BAD_ARGUMENT
    if matvar.rank == 0:
        return MATIO_E_NO_ERROR
    if matvar.rank > MAX_RANK:
        return MATIO_E_TOO_MANY_DIMENSIONS
    if matvar.dims is None:
        matvar.dims = (size_t*)malloc(matvar.rank*sizeof(*matvar.dims))
        if matvar.dims is None:
            return MATIO_E_OUT_OF_MEMORY
    for i in range(matvar.rank):
        matvar.dims[i] = dims[i]
    return MATIO_E_NO_ERROR

def Mul(a, b):
    c = a * b
    if c < 0 or c > a or c > b:
        return MATIO_E_INTEGER_MULTIPLICATION_OVERFLOW
    return MATIO_E_NO_ERROR

def Mat_H5ReadDims(dset_id, nelems, rank):
    if dset_id < 0:
        return None
    dims = (size_t*)malloc(rank*sizeof(*dims))
    if dims is None:
        return None
    herr = H5Dget_simple_extent_dims(dset_id, dims, NULL)
    if herr < 0:
        free(dims)
        return None
    *nelems = 1
    for i in range(rank):
        *nelems *= dims[i]
    return dims

def Mat_H5ReadFieldNames(matvar, dset_id, nfields):
    if dset_id < 0 or nfields <= 0:
        return MATIO_E_BAD_ARGUMENT
    if matvar.internal is None:
        return MATIO_E_OUT_OF_MEMORY
    matvar.internal.num_fields = nfields
    matvar.internal.fieldnames = (char**)malloc(nfields*sizeof(*matvar.internal.fieldnames))
    if matvar.internal.fieldnames is None:
        return MATIO_E_OUT_OF_MEMORY
    for i in range(nfields):
        matvar.internal.fieldnames[i] = None
    return MATIO_E_NO_ERROR

def Mat_H5ReadDatasetInfo(mat, matvar, dset_id):
    if mat is None or matvar is None or dset_id < 0:
        return MATIO_E_BAD_ARGUMENT
    err = Mat_H5ReadVarInfo(matvar, dset_id)
    if err < 0:
        return err
    if matvar.internal.hdf5_name is None:
        matvar.internal.hdf5_name = strdup(matvar.name)
    if matvar.internal.hdf5_ref == 0:
        matvar.internal.hdf5_ref = H5Iget_ref(dset_id)
    if matvar.internal.id < 0:
        matvar.internal.id = dset_id
        H5Iinc_ref(dset_id)
    return MATIO_E_NO_ERROR

def Mat_H5ReadGroupInfo(mat, matvar, dset_id):
    if mat is None or matvar is None or dset_id < 0:
        return MATIO_E_BAD_ARGUMENT
    err = Mat_H5ReadVarInfo(matvar, dset_id)
    if err < 0:
        return err
    if matvar.internal.hdf5_name is None:
        matvar.internal.hdf5_name = strdup(matvar.name)
    if matvar.internal.hdf5_ref == 0:
        matvar.internal.hdf5_ref = H5Iget_ref(dset_id)
    if matvar.internal.id < 0:
        matvar.internal.id = dset_id
        H5Iinc_ref(dset_id)
    return MATIO_E_NO_ERROR

def Mat_H5ReadNextReferenceInfo(ref_id, matvar, mat):
    if ref_id < 0 or matvar is None or mat is None:
        return MATIO_E_BAD_ARGUMENT
    if matvar.internal.hdf5_ref == 0:
        matvar.internal.hdf5_ref = H5Iget_ref(ref_id)
    if matvar.internal.id < 0:
        matvar.internal.id = ref_id
        H5Iinc_ref(ref_id)
    return MATIO_E_NO_ERROR

def Mat_H5ReadNextReferenceData(ref_id, matvar, mat):
    if ref_id < 0 or matvar is None or mat is None:
        return MATIO_E_BAD_ARGUMENT
    if matvar.internal.hdf5_ref == 0:
        matvar.internal.hdf5_ref = H5Iget_ref(ref_id)
    if matvar.internal.id < 0:
        matvar.internal.id = ref_id
        H5Iinc_ref(ref_id)
    return MATIO_E_NO_ERROR

def Mat_H5ReadData(dset_id, h5_type, mem_space, dset_space, isComplex, data):
    if dset_id < 0 or data is None:
        return MATIO_E_BAD_ARGUMENT
    if isComplex:
        mat_complex_split_t *complex_data = (mat_complex_split_t*)data
        hid_t h5_complex
        size_t h5_size = H5Tget_size(h5_type)
        h5_complex = H5Tcreate(H5T_COMPOUND, h5_size)
        H5Tinsert(h5_complex, "real", 0, h5_type)
        herr = H5Dread(dset_id, h5_complex, mem_space, dset_space, H5P_DEFAULT,
            complex_data->Re)
        H5Tclose(h5_complex)
        if herr < 0:
            return MATIO_E_GENERIC_READ_ERROR
        h5_complex = H5Tcreate(H5T_COMPOUND, h5_size)
        H5Tinsert(h5_complex, "imag", 0, h5_type)
        herr = H5Dread(dset_id, h5_complex, mem_space, dset_space, H5P_DEFAULT,
            complex_data->Im)
        H5Tclose(h5_complex)
        if herr < 0:
            return MATIO_E_GENERIC_READ_ERROR
    else:
        matvar_t **fields
        size_t i, nelems_x_nfields, nelems = 1
        err = Mat_MulDims(matvar, &nelems)
        if err:
            return err
        err = Mul(&nelems_x_nfields, nelems, matvar.internal.num_fields)
        if err:
            return err
        fields = (matvar_t**)matvar.data
        for i in range(nelems_x_nfields):
            if fields[i] is not None:
                err = Mat_H5ReadData(dset_id, h5_type, mem_space, dset_space,
                    matvar.isComplex, fields[i].data)
                if err:
                    break
    return MATIO_E_NO_ERROR

def Mat_H5WriteData(dset_id, h5_type, mem_space, dset_space, isComplex, data):
    if dset_id < 0 or data is None:
        return MATIO_E_BAD_ARGUMENT
    if isComplex:
        mat_complex_split_t *complex_data = (mat_complex_split_t*)data
        hid_t h5_complex
        size_t h5_size = H5Tget_size(h5_type)
        h5_complex = H5Tcreate(H5T_COMPOUND, h5_size)
        H5Tinsert(h5_complex, "real", 0, h5_type)
        herr = H5Dwrite(dset_id, h5_complex, mem_space, dset_space, H5P_DEFAULT,
            complex_data->Re)
        H5Tclose(h5_complex)
        if herr < 0:
            return MATIO_E_GENERIC_WRITE_ERROR
        h5_complex = H5Tcreate(H5T_COMPOUND, h5_size)
        H5Tinsert(h5_complex, "imag", 0, h5_type)
        herr = H5Dwrite(dset_id, h5_complex, mem_space, dset_space, H5P_DEFAULT,
            complex_data->Im)
        H5Tclose(h5_complex)
        if herr < 0:
            return MATIO_E_GENERIC_WRITE_ERROR
    else:
        matvar_t **fields
        size_t i, nelems_x_nfields, nelems = 1
        err = Mat_MulDims(matvar, &nelems)
        if err:
            return err
        err = Mul(&nelems_x_nfields, nelems, matvar.internal.num_fields)
        if err:
            return err
        fields = (matvar_t**)matvar.data
        for i in range(nelems_x_nfields):
            if fields[i] is not None:
                err = Mat_H5WriteData(dset_id, h5_type, mem_space, dset_space,
                    matvar.isComplex, fields[i].data)
                if err:
                    break
    return MATIO_E_NO_ERROR

def Mat_H5WriteAppendData(dset_id, h5_type, mrank, name, dims, dim, isComplex, data):
    if dset_id < 0 or data is None:
        return MATIO_E_BAD_ARGUMENT
    if dim < 1 or dim > mrank:
        return MATIO_E_BAD_ARGUMENT
    hid_t mem_space = H5Screate_simple(mrank, dims, NULL)
    hid_t dset_space = H5Dget_space(dset_id)
    hid_t mspace_id = H5Screate_simple(mrank, dims, NULL)
    hid_t dset_id = H5Dcreate(dset_id, name, h5_type, mspace_id,
        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT)
    if dset_id < 0:
        return MATIO_E_GENERIC_WRITE_ERROR
    H5Sselect_hyperslab(dset_space, H5S_SELECT_SET, dims, NULL, dims, NULL)
    free(dims)
    err = Mat_H5WriteData(dset_id, h5_type, mem_space, dset_space,
        isComplex, data)
    H5Sclose(mem_space)
    H5Sclose(dset_space)
    H5Dclose(dset_id)
    return err

def Mat_VarWriteRef(id, matvar, compression, refs_id, ref):
    if id < 0 or matvar is None or refs_id < 0 or ref is None:
        return MATIO_E_BAD_ARGUMENT
    if matvar.compression != compression:
        matvar.compression = compression
    err = Mat_VarWriteNext73(id, matvar, matvar.name, refs_id)
    if err:
        return err
    H5Rcreate(ref, id, matvar.name, H5R_OBJECT, -1)

def Mat_VarWriteEmpty(id, matvar, name, class_name):
    if id < 0 or matvar is None:
        return MATIO_E_BAD_ARGUMEN