Below is the content of a C/C++ function where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
static int
Mat_H5ReadGroupInfo(mat_t *mat,matvar_t *matvariable,hid_t dset_id)
{
    int      fields_are_variables = 1;
    hsize_t  nfields=0,nelems;
    hid_t    attr_id,field_id;
    matvar_t **fields;
    H5O_type_t obj_type;
    int err;

    err = Mat_H5ReadVarInfo(matvariable,dset_id);
    if ( err < 0 ) {
        return err;
    }

    /* Check if the variable is sparse */
    if ( H5Aexists_by_name(dset_id,".","MATLAB_sparse",H5P_DEFAULT) ) {
        herr_t herr;
        hid_t sparse_dset_id;
        unsigned nrows = 0;

        attr_id = H5Aopen_by_name(dset_id,".","MATLAB_sparse",H5P_DEFAULT,H5P_DEFAULT);
        herr = H5Aread(attr_id,H5T_NATIVE_UINT,&nrows);
        H5Aclose(attr_id);
        if ( herr < 0 ) {
            return MATIO_E_GENERIC_READ_ERROR;
        }

        matvariable->class_type = MAT_C_SPARSE;

        sparse_dset_id = H5Dopen(dset_id,"jc",H5P_DEFAULT);
        matvariable->dims = Mat_H5ReadDims(sparse_dset_id, &nelems, &matvariable->rank);
        H5Dclose(sparse_dset_id);
        if ( NULL != matvariable->dims ) {
            if ( 1 == matvariable->rank ) {
                size_t* dims = (size_t*)realloc(matvariable->dims, 2*sizeof(*matvariable->dims));
                if ( NULL != dims ) {
                    matvariable->rank = 2;
                    matvariable->dims = dims;
                }
            }
            if ( 2 == matvariable->rank ) {
                matvariable->dims[1] = matvariable->dims[0] - 1;
                matvariable->dims[0] = nrows;
            }
        } else {
            return MATIO_E_UNKNOWN_ERROR;
        }

        /* Test if dataset type is compound and if so if it's complex */
        if ( H5Lexists(dset_id,"data",H5P_DEFAULT) ) {
            hid_t type_id;
            sparse_dset_id = H5Dopen(dset_id,"data",H5P_DEFAULT);
            type_id = H5Dget_type(sparse_dset_id);
            if ( H5T_COMPOUND == H5Tget_class(type_id) ) {
                /* FIXME: Any more checks? */
                matvariable->isComplex = MAT_F_COMPLEX;
            }
            H5Tclose(type_id);
            H5Dclose(sparse_dset_id);
        }
        return MATIO_E_NO_ERROR;
    }

    // Check if the structure defines its fields using the "MATLAB_fields" attribute.
    // If the attribute exists, read the field names and update the number of fields.
    // If the attribute does not exist, retrieve the number of links in the dataset group.
    // If there are links, iterate over them to count and collect field names.
    // Store the field names in the matvar structure and update the total number of fields.
    // <MASK>

    if ( nfields > 0 ) {
        H5O_INFO_T object_info;
        object_info.type = H5O_TYPE_UNKNOWN;
        H5OGET_INFO_BY_NAME(dset_id, matvariable->internal->fieldnames[0], &object_info, H5P_DEFAULT);
        obj_type = object_info.type;
    } else {
        obj_type = H5O_TYPE_UNKNOWN;
    }
    if ( obj_type == H5O_TYPE_DATASET ) {
        hid_t field_type_id;
        field_id = H5Dopen(dset_id,matvariable->internal->fieldnames[0],H5P_DEFAULT);
        field_type_id = H5Dget_type(field_id);
        if ( H5T_REFERENCE == H5Tget_class(field_type_id) ) {
            /* Check if the field has the MATLAB_class attribute. If so, it
             * means the structure is a scalar. Otherwise, the dimensions of
             * the field dataset is the dimensions of the structure
             */
            if ( H5Aexists_by_name(field_id,".","MATLAB_class",H5P_DEFAULT) ) {
                matvariable->rank = 2;
                matvariable->dims = (size_t*)malloc(2*sizeof(*matvariable->dims));
                if ( NULL != matvariable->dims ) {
                    matvariable->dims[0] = 1;
                    matvariable->dims[1] = 1;
                    nelems = 1;
                } else {
                    H5Tclose(field_type_id);
                    H5Dclose(field_id);
                    Mat_Critical("Error allocating memory for matvar->dims");
                    return MATIO_E_OUT_OF_MEMORY;
                }
            } else {
                matvariable->dims = Mat_H5ReadDims(field_id, &nelems, &matvariable->rank);
                if ( NULL != matvariable->dims ) {
                    fields_are_variables = 0;
                } else {
                    H5Tclose(field_type_id);
                    H5Dclose(field_id);
                    return MATIO_E_UNKNOWN_ERROR;
                }
            }
        } else {
            /* Structure should be a scalar */
            matvariable->rank = 2;
            matvariable->dims = (size_t*)malloc(2*sizeof(*matvariable->dims));
            if ( NULL != matvariable->dims ) {
                matvariable->dims[0] = 1;
                matvariable->dims[1] = 1;
                nelems = 1;
            } else {
                H5Tclose(field_type_id);
                H5Dclose(field_id);
                Mat_Critical("Error allocating memory for matvar->dims");
                return MATIO_E_UNKNOWN_ERROR;
            }
        }
        H5Tclose(field_type_id);
        H5Dclose(field_id);
    } else {
        /* Structure should be a scalar */
        matvariable->rank = 2;
        matvariable->dims = (size_t*)malloc(2*sizeof(*matvariable->dims));
        if ( NULL != matvariable->dims ) {
            matvariable->dims[0] = 1;
            matvariable->dims[1] = 1;
            nelems = 1;
        } else {
            Mat_Critical("Error allocating memory for matvar->dims");
            return MATIO_E_OUT_OF_MEMORY;
        }
    }

    if ( nelems < 1 || nfields < 1 )
        return err;

    matvariable->data_size = sizeof(*fields);
    {
        size_t nelems_x_nfields;
        err = Mul(&nelems_x_nfields, nelems, nfields);
        err |= Mul(&matvariable->nbytes, nelems_x_nfields, matvariable->data_size);
        if ( err ) {
            Mat_Critical("Integer multiplication overflow");
            matvariable->nbytes = 0;
            return err;
        }
    }
    fields = (matvar_t**)calloc(matvariable->nbytes, 1);
    matvariable->data = fields;
    if ( NULL != fields ) {
        hsize_t k;
        for ( k = 0; k < nfields; k++ ) {
            H5O_INFO_T object_info;
            fields[k] = NULL;
            object_info.type = H5O_TYPE_UNKNOWN;
            H5OGET_INFO_BY_NAME(dset_id, matvariable->internal->fieldnames[k], &object_info, H5P_DEFAULT);
            if ( object_info.type == H5O_TYPE_DATASET ) {
                field_id = H5Dopen(dset_id,matvariable->internal->fieldnames[k], H5P_DEFAULT);
                if ( !fields_are_variables ) {
                    hobj_ref_t *ref_ids = (hobj_ref_t*)calloc((size_t)nelems, sizeof(*ref_ids));
                    if ( ref_ids != NULL ) {
                        hsize_t l;
                        herr_t herr = H5Dread(field_id,H5T_STD_REF_OBJ,H5S_ALL,H5S_ALL,
                            H5P_DEFAULT,ref_ids);
                        if ( herr < 0 ) {
                            err = MATIO_E_GENERIC_READ_ERROR;
                        } else {
                            for ( l = 0; l < nelems; l++ ) {
                                hid_t ref_id;
                                fields[l*nfields+k] = Mat_VarCalloc();
                                fields[l*nfields+k]->name =
                                    strdup(matvariable->internal->fieldnames[k]);
                                fields[l*nfields+k]->internal->hdf5_ref=ref_ids[l];
                                /* Closing of ref_id is done in Mat_H5ReadNextReferenceInfo */
                                ref_id = H5RDEREFERENCE(field_id,H5R_OBJECT,ref_ids+l);
                                if ( ref_id < 0 ) {
                                    err = MATIO_E_GENERIC_READ_ERROR;
                                } else {
                                    fields[l*nfields+k]->internal->id = ref_id;
                                    err = Mat_H5ReadNextReferenceInfo(ref_id,fields[l*nfields+k],mat);
                                }
                                if ( err ) {
                                    break;
                                }
                            }
                        }
                        free(ref_ids);
                    } else {
                        err = MATIO_E_OUT_OF_MEMORY;
                    }
                } else {
                    fields[k] = Mat_VarCalloc();
                    fields[k]->name = strdup(matvariable->internal->fieldnames[k]);
                    err = Mat_H5ReadDatasetInfo(mat,fields[k],field_id);
                }
                H5Dclose(field_id);
            } else if ( object_info.type == H5O_TYPE_GROUP ) {
                field_id = H5Gopen(dset_id,matvariable->internal->fieldnames[k],
                                   H5P_DEFAULT);
                if ( -1 < field_id ) {
                    fields[k] = Mat_VarCalloc();
                    fields[k]->name = strdup(matvariable->internal->fieldnames[k]);
                    err = Mat_H5ReadGroupInfo(mat,fields[k],field_id);
                    H5Gclose(field_id);
                }
            }
            if ( err ) {
                break;
            }
        }
    } else {
        err = MATIO_E_OUT_OF_MEMORY;
    }

    return err;
}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/mat73.c
static herr_t
Mat_H5ReadGroupInfoIterate(hid_t dset_id, const char *name, const H5L_info_t *info, void *op_data)
{
    matvar_t  *matvar;
    H5O_INFO_T object_info;
    struct ReadGroupInfoIterData *group_data;

    /* FIXME: follow symlinks, datatypes? */

    object_info.type = H5O_TYPE_UNKNOWN;
    H5OGET_INFO_BY_NAME(dset_id, name, &object_info, H5P_DEFAULT);
    if ( H5O_TYPE_DATASET != object_info.type && H5O_TYPE_GROUP != object_info.type )
        return 0;

    group_data = (struct ReadGroupInfoIterData *)op_data;
    if ( group_data == NULL )
        return -1;
    matvar = group_data->matvar;

    switch ( object_info.type ) {
        case H5O_TYPE_GROUP:
            /* Check that this is not the /#refs# group */
            if ( 0 == strcmp(name,"#refs#") )
                return 0;
            /* Fall through */
        case H5O_TYPE_DATASET:
            if ( matvar != NULL ) {
                matvar->internal->fieldnames[group_data->nfields] = strdup(name);
            }
            group_data->nfields++;
            break;
        default:
            /* Not possible to get here */
            break;
    }

    return 1;
}

// the below code fragment can be found in:
// src/mat73.c
static int
Mat_VarWriteAppendStruct73(hid_t id,matvar_t *matvar,const char *name,hid_t *refs_id,hsize_t *dims,int dim)
{
    int err = MATIO_E_NO_ERROR;
    hsize_t nelems = 1;

    {
        int k;
        for ( k = 0; k < matvar->rank; k++ ) {
            nelems *= dims[k];
        }
    }

    if ( 0 != nelems && NULL != matvar->data ) {
        if ( H5Lexists(id, name, H5P_DEFAULT) ) {
            hobj_ref_t **refs;
            hsize_t nfields = matvar->internal->num_fields;
            matvar_t** fields = (matvar_t**)matvar->data;

            if ( *refs_id <= -1 )
                return MATIO_E_OUTPUT_BAD_DATA;

            refs = (hobj_ref_t**)calloc((size_t)nfields, sizeof(*refs));
            if ( NULL != refs) {
                hsize_t l;
                for ( l = 0; l < nfields; l++ ) {
                    refs[l] = (hobj_ref_t*)calloc((size_t)nelems, sizeof(*refs[l]));
                    if ( NULL == refs[l] ) {
                        err = MATIO_E_OUT_OF_MEMORY;
                        break;
                    }
                }

                if ( MATIO_E_NO_ERROR == err ) {
                    hsize_t k;
                    for ( k = 0; k < nelems; k++ ) {
                        for ( l = 0; l < nfields; l++ ) {
                            err = Mat_VarWriteRef(id, fields[k*nfields+l], matvar->compression,
                                                   refs_id, refs[l]+k);
                            if ( err )
                                break;
                        }
                        if ( err )
                            break;
                    }
                }

                if ( MATIO_E_NO_ERROR == err ) {
                    hid_t struct_id = H5Gopen(id, name, H5P_DEFAULT);
                    for ( l = 0; l < nfields; l++ ) {
                        err = Mat_H5WriteAppendData(struct_id, H5T_STD_REF_OBJ, matvar->rank,
                            matvar->internal->fieldnames[l], matvar->dims, dims, dim, 0, refs[l]);
                        if ( err )
                            break;
                    }
                    H5Gclose(struct_id);
                }
                for ( l = 0; l < nfields; l++ )
                    free(refs[l]);
                free(refs);
            }
        } else {
            /* Create with unlimited number of dimensions */
            if ( MAX_RANK >= matvar->rank ) {
                hsize_t max_dims[MAX_RANK];
                int k;
                for ( k = 0; k < matvar->rank; k++ ) {
                    max_dims[k] = H5S_UNLIMITED;
                }
                err = Mat_VarWriteStruct73(id,matvar,name,refs_id,dims,max_dims);
            } else {
                hsize_t* max_dims = (hsize_t*)malloc(matvar->rank*sizeof(hsize_t));
                if ( NULL != max_dims ) {
                    int k;
                    for ( k = 0; k < matvar->rank; k++ ) {
                        max_dims[k] = H5S_UNLIMITED;
                    }
                    err = Mat_VarWriteStruct73(id,matvar,name,refs_id,dims,max_dims);
                    free(max_dims);
                } else {
                    err = MATIO_E_OUT_OF_MEMORY;
                }
            }
        }
    }

    return err;
}

// the below code fragment can be found in:
// src/mat73.c
int
Mat_VarReadData73(mat_t *mat,matvar_t *matvar,void *data,
          int *start,int *stride,int *edge)
{
    int err = MATIO_E_NO_ERROR, k;
    hid_t fid,dset_id,ref_id,dset_space,mem_space;
    hsize_t *dset_start_stride_edge;
    hsize_t *dset_start, *dset_stride, *dset_edge;

    if ( NULL == mat || NULL == matvar || NULL == data || NULL == start ||
         NULL == stride || NULL == edge )
         return MATIO_E_BAD_ARGUMENT;
    else if ( NULL == matvar->internal->hdf5_name && 0 > matvar->internal->id )
        return MATIO_E_FAIL_TO_IDENTIFY;

    fid = *(hid_t*)mat->fp;

    dset_start_stride_edge = (hsize_t*)malloc(matvar->rank*3*sizeof(hsize_t));
    if ( NULL == dset_start_stride_edge ) {
        return MATIO_E_OUT_OF_MEMORY;
    }
    dset_start  = &dset_start_stride_edge[0];
    dset_stride = &dset_start_stride_edge[matvar->rank];
    dset_edge   = &dset_start_stride_edge[2*matvar->rank];

    for ( k = 0; k < matvar->rank; k++ ) {
        dset_start[k]  = start[matvar->rank-k-1];
        dset_stride[k] = stride[matvar->rank-k-1];
        dset_edge[k]   = edge[matvar->rank-k-1];
    }
    mem_space = H5Screate_simple(matvar->rank, dset_edge, NULL);

    switch ( matvar->class_type ) {
        case MAT_C_DOUBLE:
        case MAT_C_SINGLE:
        case MAT_C_INT64:
        case MAT_C_UINT64:
        case MAT_C_INT32:
        case MAT_C_UINT32:
        case MAT_C_INT16:
        case MAT_C_UINT16:
        case MAT_C_INT8:
        case MAT_C_UINT8:
            if ( NULL != matvar->internal->hdf5_name ) {
                ref_id = H5Dopen(fid,matvar->internal->hdf5_name,H5P_DEFAULT);
            } else {
                ref_id = matvar->internal->id;
                H5Iinc_ref(ref_id);
            }
            if ( 0 < matvar->internal->hdf5_ref ) {
                dset_id = H5RDEREFERENCE(ref_id,H5R_OBJECT,&matvar->internal->hdf5_ref);
            } else {
                dset_id = ref_id;
                H5Iinc_ref(dset_id);
            }

            dset_space = H5Dget_space(dset_id);
            H5Sselect_hyperslab(dset_space, H5S_SELECT_SET, dset_start,
                                dset_stride, dset_edge, NULL);
            err = Mat_H5ReadData(dset_id, ClassType2H5T(matvar->class_type), mem_space,
                dset_space, matvar->isComplex, data);
            H5Sclose(dset_space);
            H5Dclose(dset_id);
            H5Dclose(ref_id);
            break;
        default:
            err = MATIO_E_FAIL_TO_IDENTIFY;
            break;
    }
    H5Sclose(mem_space);
    free(dset_start_stride_edge);

    return err;
}

// the below code fragment can be found in:
// src/mat73.c
static int
Mat_H5ReadDatasetInfo(mat_t *mat,matvar_t *matvar,hid_t dset_id)
{
    int err;
    hsize_t nelems;

    err = Mat_H5ReadVarInfo(matvar, dset_id);
    if ( err ) {
        return err;
    }

    matvar->dims = Mat_H5ReadDims(dset_id, &nelems, &matvar->rank);
    if ( NULL == matvar->dims ) {
        return MATIO_E_UNKNOWN_ERROR;
    }

    /* Check for attribute that indicates an empty array */
    if ( H5Aexists_by_name(dset_id,".","MATLAB_empty",H5P_DEFAULT) ) {
        int empty = 0;
        herr_t herr;
        hid_t attr_id = H5Aopen_by_name(dset_id,".","MATLAB_empty",H5P_DEFAULT,H5P_DEFAULT);
        /* FIXME: Check that dataspace is scalar */
        herr = H5Aread(attr_id,H5T_NATIVE_INT,&empty);
        H5Aclose(attr_id);
        if ( herr < 0 ) {
            err = MATIO_E_GENERIC_READ_ERROR;
        } else if ( empty ) {
            matvar->rank = (int)matvar->dims[0];
            free(matvar->dims);
            matvar->dims = (size_t*)calloc(matvar->rank,sizeof(*matvar->dims));
            if ( matvar->dims == NULL ) {
                err = MATIO_E_OUT_OF_MEMORY;
            } else {
                herr = H5Dread(dset_id,SizeType2H5T(),H5S_ALL,H5S_ALL,H5P_DEFAULT,matvar->dims);
                if ( herr < 0 ) {
                    err = MATIO_E_GENERIC_READ_ERROR;
                } else {
                    size_t tmp = 1;
                    err = Mat_MulDims(matvar, &tmp);
                    nelems = (hsize_t)tmp;
                }
            }
        }
        if ( err ) {
            return err;
        }
    }

    /* Test if dataset type is compound and if so if it's complex */
    {
        hid_t type_id = H5Dget_type(dset_id);
        if ( H5T_COMPOUND == H5Tget_class(type_id) ) {
            /* FIXME: Any more checks? */
            matvar->isComplex = MAT_F_COMPLEX;
        }
        H5Tclose(type_id);
    }

    /* If the dataset is a cell array read the info of the cells */
    if ( MAT_C_CELL == matvar->class_type ) {
        matvar_t **cells;

        matvar->data_size = sizeof(matvar_t**);
        err = Mul(&matvar->nbytes, nelems, matvar->data_size);
        if ( err ) {
            Mat_Critical("Integer multiplication overflow");
            return err;
        }
        matvar->data = calloc(matvar->nbytes, 1);
        if ( NULL == matvar->data ) {
            Mat_Critical("Couldn't allocate memory for the data");
            return MATIO_E_OUT_OF_MEMORY;
        }
        cells = (matvar_t**)matvar->data;

        if ( nelems ) {
            hobj_ref_t *ref_ids = (hobj_ref_t*)calloc(nelems, sizeof(*ref_ids));
            if ( ref_ids != NULL ) {
                size_t i;
                herr_t herr = H5Dread(dset_id,H5T_STD_REF_OBJ,H5S_ALL,H5S_ALL,H5P_DEFAULT,ref_ids);
                if ( herr < 0 ) {
                    free(ref_ids);
                    return MATIO_E_GENERIC_READ_ERROR;
                }
                for ( i = 0; i < nelems; i++ ) {
                    hid_t ref_id;
                    cells[i] = Mat_VarCalloc();
                    cells[i]->internal->hdf5_ref = ref_ids[i];
                    /* Closing of ref_id is done in Mat_H5ReadNextReferenceInfo */
                    ref_id = H5RDEREFERENCE(dset_id,H5R_OBJECT,ref_ids+i);
                    if ( ref_id < 0 ) {
                        err = MATIO_E_GENERIC_READ_ERROR;
                    } else {
                        cells[i]->internal->id = ref_id;
                        err = Mat_H5ReadNextReferenceInfo(ref_id,cells[i],mat);
                    }
                    if ( err ) {
                        break;
                    }
                }
                free(ref_ids);
            } else {
                err = MATIO_E_OUT_OF_MEMORY;
            }
        }
    } else if ( MAT_C_STRUCT == matvar->class_type ) {
        /* Empty structures can be a dataset */

        /* Check if the structure defines its fields in MATLAB_fields */
        if ( H5Aexists_by_name(dset_id,".","MATLAB_fields",H5P_DEFAULT) ) {
            hsize_t nfields;
            err = Mat_H5ReadFieldNames(matvar, dset_id, &nfields);
        }
    }

    return err;
}

// the below code fragment can be found in:
// src/mat73.c
static int
Mat_VarWriteNext73(hid_t id,matvar_t *matvar,const char *name,hid_t *refs_id)
{
    int err;

    if ( NULL == matvar ) {
        size_t dims[2] = {0,0};
        return Mat_WriteEmptyVariable73(id,name,2,dims);
    }

    if ( MAX_RANK >= matvar->rank ) {
        hsize_t perm_dims[MAX_RANK];
        err = Mat_VarWriteNextType73(id, matvar, name, refs_id, perm_dims);
    } else {
        hsize_t *perm_dims = (hsize_t*)malloc(matvar->rank*sizeof(hsize_t));
        if ( NULL != perm_dims ) {
            err = Mat_VarWriteNextType73(id, matvar, name, refs_id, perm_dims);
            free(perm_dims);
        } else {
            err = MATIO_E_OUT_OF_MEMORY;
        }
    }

    return err;
}
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).