if ( H5Aexists_by_name(dset_id,".","MATLAB_fields",H5P_DEFAULT) ) {
    hid_t attr_id;
    hsize_t nfields = 0;

    attr_id = H5Aopen_by_name(dset_id,".","MATLAB_fields",H5P_DEFAULT,H5P_DEFAULT);
    if ( attr_id < 0 ) {
        return MATIO_E_GENERIC_READ_ERROR;
    }

    H5Aget_storage_size(attr_id); // Ensure attribute exists and is accessible
    err = H5Aread(attr_id, H5T_C_S1, NULL); // Replace `NULL` with field name buffer if needed
    H5Aclose(attr_id);

    matvariable->internal->num_fields = (int)nfields;
    matvariable->internal->fieldnames = (char**)calloc(nfields, sizeof(char*));
    if ( NULL == matvariable->internal->fieldnames ) {
        return MATIO_E_OUT_OF_MEMORY;
    }

    for ( hsize_t i = 0; i < nfields; ++i ) {
        matvariable->internal->fieldnames[i] = (char*)malloc(MAX_FIELD_NAME_LEN * sizeof(char));
        if ( NULL == matvariable->internal->fieldnames[i] ) {
            return MATIO_E_OUT_OF_MEMORY;
        }
        // Read field names from attribute into `matvariable->internal->fieldnames[i]`
    }

    nfields = (hsize_t)matvariable->internal->num_fields;
} else {
    H5G_info_t group_info;
    herr_t status = H5Gget_info(dset_id, &group_info);
    if ( status < 0 ) {
        return MATIO_E_GENERIC_READ_ERROR;
    }

    nfields = group_info.nlinks;
    if ( nfields > 0 ) {
        matvariable->internal->num_fields = (int)nfields;
        matvariable->internal->fieldnames = (char**)calloc(nfields, sizeof(char*));
        if ( NULL == matvariable->internal->fieldnames ) {
            return MATIO_E_OUT_OF_MEMORY;
        }

        struct ReadGroupInfoIterData group_data;
        group_data.matvar = matvariable;
        group_data.nfields = 0;

        status = H5Literate(dset_id, H5_INDEX_NAME, H5_ITER_NATIVE, NULL, Mat_H5ReadGroupInfoIterate, &group_data);
        if ( status < 0 || group_data.nfields != nfields ) {
            return MATIO_E_GENERIC_READ_ERROR;
        }
    }
}