// Check if the structure defines its fields using the "MATLAB_fields" attribute.
// If the attribute exists, read the field names and update the number of fields.
// If the attribute does not exist, retrieve the number of links in the dataset group.
// If there are links, iterate over them to count and collect field names.
// Store the field names in the matvar structure and update the total number of fields.
if ( H5Aexists_by_name(dset_id,".","MATLAB_fields",H5P_DEFAULT) ) {
    err = Mat_H5ReadFieldNames(matvariable, dset_id, &nfields);
} else {
    hid_t group_id = H5Gopen(dset_id,".",H5P_DEFAULT);
    if ( group_id < 0 ) {
        return MATIO_E_GENERIC_READ_ERROR;
    }
    H5Gget_num_objs(group_id, &nfields);
    H5Gclose(group_id);
    if ( nfields > 0 ) {
        matvariable->internal->num_fields = (unsigned int)nfields;
        matvariable->internal->fieldnames = (char**)calloc((size_t)nfields,sizeof(*matvariable->internal->fieldnames));
        if ( NULL == matvariable->internal->fieldnames ) {
            return MATIO_E_OUT_OF_MEMORY;
        }
        group_id = H5Gopen(dset_id,".",H5P_DEFAULT);
        if ( group_id < 0 ) {
            return MATIO_E_GENERIC_READ_ERROR;
        }
        for ( hsize_t k = 0; k < nfields; k++ ) {
            ssize_t name_len = H5Lget_name_by_idx(dset_id,".",H5_INDEX_NAME,H5_ITER_INC,k,NULL,0,NULL);
            if ( name_len > 0 ) {
                matvariable->internal->fieldnames[k] = (char*)malloc(name_len+1);
                if ( NULL == matvariable->internal->fieldnames[k] ) {
                    H5Gclose(group_id);
                    return MATIO_E_OUT_OF_MEMORY;
                }
                H5Lget_name_by_idx(dset_id,".",H5_INDEX_NAME,H5_ITER_INC,k,NULL,name_len+1,matvariable->internal->fieldnames[k]);
            } else {
                H5Gclose(group_id);
                return MATIO_E_GENERIC_READ_ERROR;
            }
        }
        H5Gclose(group_id);
    }
}