// Check if the structure defines its fields using the "MATLAB_fields" attribute.
// If the attribute exists, read the field names and update the number of fields.
// If the attribute does not exist, retrieve the number of links in the dataset group.
// If there are links, iterate over them to count and collect field names.
// Store the field names in the matvar structure and update the total number of fields.
if ( H5Aexists_by_name(dset_id,".","MATLAB_fields",H5P_DEFAULT) ) {
    herr_t herr;
    hid_t attr_id = H5Aopen_by_name(dset_id,".","MATLAB_fields",H5P_DEFAULT,H5P_DEFAULT);
    hid_t type_id = H5Aget_type(attr_id);
    hid_t space_id = H5Aget_space(attr_id);
    hsize_t nfields;
    herr = H5Sget_simple_extent_dims(space_id, &nfields, NULL);
    if ( herr < 0 ) {
        H5Tclose(type_id);
        H5Sclose(space_id);
        H5Aclose(attr_id);
        return MATIO_E_GENERIC_READ_ERROR;
    }
    matvariable->internal->fieldnames = (char**)calloc((size_t)nfields,sizeof(*matvariable->internal->fieldnames));
    if ( NULL == matvariable->internal->fieldnames ) {
        H5Tclose(type_id);
        H5Sclose(space_id);
        H5Aclose(attr_id);
        return MATIO_E_OUT_OF_MEMORY;
    }
    herr = H5Aread(attr_id, H5T_NATIVE_CHAR, matvariable->internal->fieldnames);
    if ( herr < 0 ) {
        H5Tclose(type_id);
        H5Sclose(space_id);
        H5Aclose(attr_id);
        return MATIO_E_GENERIC_READ_ERROR;
    }
    H5Tclose(type_id);
    H5Sclose(space_id);
    H5Aclose(attr_id);
    nfields = (hsize_t)matvariable->internal->num_fields;
} else {
    struct ReadGroupInfoIterData group_data;
    group_data.matvar = matvariable;
    group_data.nfields = 0;
    herr_t herr = H5Literate(dset_id, H5_INDEX_NAME, H5_ITER_NATIVE, NULL, Mat_H5ReadGroupInfoIterate, &group_data);
    if ( herr < 0 ) {
        return MATIO_E_GENERIC_READ_ERROR;
    }
    nfields = group_data.nfields;
}