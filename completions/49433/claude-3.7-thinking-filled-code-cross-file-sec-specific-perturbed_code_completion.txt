for (tagIndex = 0; tagIndex < TagCount; tagIndex++) {
    
    // Read tag signature, offset, and size
    if (!_cmsReadUInt32Number(io, &Tag.sig)) return FALSE;
    if (!_cmsReadUInt32Number(io, &Tag.offset)) return FALSE;
    if (!_cmsReadUInt32Number(io, &Tag.size)) return FALSE;
    
    // Adjust endianness
    Tag.sig = _cmsAdjustEndianess32(Tag.sig);
    Tag.offset = _cmsAdjustEndianess32(Tag.offset);
    Tag.size = _cmsAdjustEndianess32(Tag.size);
    
    // Verify tag position and size
    if (Tag.offset >= HeaderSize || 
        Tag.size > HeaderSize ||
        Tag.offset > HeaderSize - Tag.size) {
        cmsSignalError(Icc->ContextID, cmsERROR_CORRUPTION, "Tag %d outside profile", tagIndex);
        continue;
    }
    
    // Check for zero size tags
    if (Tag.size == 0) {
        cmsSignalError(Icc->ContextID, cmsERROR_CORRUPTION, "Tag %d with zero size", tagIndex);
        continue;
    }
    
    // Store the tag in the profile structure
    if (Icc->TagCount < MAX_TABLE_TAG) {
        Icc->TagNames[Icc->TagCount] = (cmsTagSignature) Tag.sig;
        Icc->TagOffsets[Icc->TagCount] = Tag.offset;
        Icc->TagSizes[Icc->TagCount] = Tag.size;
        Icc->TagLinked[Icc->TagCount] = (cmsTagSignature) 0;
        
        // Check for links
        for (j = 0; j < Icc->TagCount; j++) {
            if (Tag.offset == Icc->TagOffsets[j] && Tag.size == Icc->TagSizes[j]) {
                Icc->TagLinked[Icc->TagCount] = Icc->TagNames[j];
                break;
            }
        }
        
        Icc->TagCount++;
    } else {
        // We've reached MAX_TABLE_TAG but still have more tags to process
        cmsSignalError(Icc->ContextID, cmsERROR_RANGE, "Too many tags");
        return FALSE;
    }
}

// Set links between tags
SetLinks(Icc);