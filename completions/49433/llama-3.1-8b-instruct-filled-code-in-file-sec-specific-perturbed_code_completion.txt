// For each tag, cerify that the offset and size are valid and within the profile's header size.
// If valid, store the tag's signature, offset, and size in the profile structure.
// Check for existing tags with matching offsets and sizes to establish links between them.
// If a link is found, store the linked tag signature in the profile structure.
// Increment the tag count in the profile structure for each successfully processed tag.
for (i=0; i < TagCount; i++) {
    cmsTagEntry Tag;
    cmsUInt32Number Offset, Size;
    cmsTagSignature Sig;

    if (!io -> Read(io, &Tag, sizeof(cmsTagEntry), 1)) return FALSE;

    Sig = _cmsAdjustEndianess32(Tag.sig);
    Offset = _cmsAdjustEndianess32(Tag.offset);
    Size = _cmsAdjustEndianess32(Tag.size);

    // Check if the tag is within the profile's header size
    if (Offset + Size > HeaderSize) {
        cmsSignalError(Icc ->ContextID, cmsERROR_RANGE, "Tag %d out of range", i);
        continue;
    }

    // Check if the tag already exists in the profile
    n = SearchOneTag(Icc, Sig);
    if (n >= 0) {
        // If the tag already exists, check if the offset and size match
        if (Icc -> TagOffsets[n] == Offset && Icc -> TagSizes[n] == Size) {
            // If the offsets and sizes match, store the linked tag signature
            Icc ->TagLinked[i] = Sig;
        } else {
            // If the offsets and sizes don't match, store the tag's signature, offset, and size
            Icc -> TagNames[i] = Sig;
            Icc -> TagOffsets[i] = Offset;
            Icc -> TagSizes[i] = Size;
        }
    } else {
        // If the tag doesn't exist, store the tag's signature, offset, and size
        Icc -> TagNames[i] = Sig;
        Icc -> TagOffsets[i] = Offset;
        Icc -> TagSizes[i] = Size;
    }

    // Increment the tag count in the profile structure
    Icc -> TagCount++;
}