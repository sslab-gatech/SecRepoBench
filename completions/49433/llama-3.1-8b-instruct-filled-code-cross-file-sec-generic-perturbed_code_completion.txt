// <MASK>
cmsUInt32Number tagIndex;
cmsUInt32Number i;
cmsUInt32Number nMaxTags;
cmsUInt32Number nMaxTypes;
cmsTagDescriptor* TagDescriptor;
cmsTagEntry Tag;
cmsTagSignature sig;
cmsUInt32Number offset;
cmsUInt32Number size;
cmsUInt32Number j;

// Read tag directory
if (!_cmsReadUInt32Number(io, &TagCount)) return FALSE;
if (TagCount > MAX_TABLE_TAG) {

    cmsSignalError(Icc ->ContextID, cmsERROR_RANGE, "Too many tags (%d)", TagCount);
    return FALSE;
}

// Allocate memory for the tag directory
Icc -> TagCount = 0;
Icc -> TagOffsets = (cmsUInt32Number*) malloc(TagCount * sizeof(cmsUInt32Number));
Icc -> TagSizes = (cmsUInt32Number*) malloc(TagCount * sizeof(cmsUInt32Number));
Icc -> TagLinked = (cmsTagSignature*) malloc(TagCount * sizeof(cmsTagSignature));

// For each tag, cerify that the offset and size are valid and within the profile's header size.
// If valid, store the tag's signature, offset, and size in the profile structure.
// Check for existing tags with matching offsets and sizes to establish links between them.
// If a link is found, store the linked tag signature in the profile structure.
// Increment the tag count in the profile structure for each successfully processed tag.
for (i = 0; i < TagCount; i++) {
    if (!_cmsReadUInt32Number(io, &offset)) return FALSE;
    if (!_cmsReadUInt32Number(io, &size)) return FALSE;
    if (offset + size > HeaderSize) {
        cmsSignalError(Icc ->ContextID, cmsERROR_RANGE, "Invalid tag offset or size");
        return FALSE;
    }

    // Read tag signature
    if (!_cmsReadUInt32Number(io, &sig)) return FALSE;

    // Check if tag is supported
    TagDescriptor = _cmsGetTagDescriptor(sig);
    if (TagDescriptor == NULL) {
        cmsSignalError(Icc ->ContextID, cmsERROR_RANGE, "Unsupported tag signature");
        return FALSE;
    }

    nMaxTypes = TagDescriptor->nSupportedTypes;
    if (nMaxTypes >= MAX_TYPES_IN_LCMS_PLUGIN)
        nMaxTypes = MAX_TYPES_IN_LCMS_PLUGIN;

    for (j = 0; j < nMaxTypes; j++) {
        if (IsTypeSupported(TagDescriptor, TagDescriptor->SupportedTypes[j])) break;
    }

    if (j == nMaxTypes) {
        cmsSignalError(Icc ->ContextID, cmsERROR_RANGE, "Unsupported tag type");
        return FALSE;
    }

    // Check for existing tags with matching offsets and sizes
    for (j = 0; j < Icc -> TagCount; j++) {
        if (Icc -> TagOffsets[j] == offset && Icc -> TagSizes[j] == size) {
            Icc -> TagLinked[i] = Icc -> TagSignatures[j];
            break;
        }
    }

    // Store the tag's signature, offset, and size in the profile structure
    Icc -> TagSignatures[Icc -> TagCount] = sig;
    Icc -> TagOffsets[Icc -> TagCount] = offset;
    Icc -> TagSizes[Icc -> TagCount] = size;
    Icc -> TagCount++;

    // Check for links to existing tags
    if (Icc -> TagLinked[i]!= (cmsTagSignature) 0) {
        j = _cmsSearchTag(Icc, Icc -> TagLinked[i], FALSE);
        if (j >= 0) {
            Icc -> TagOffsets[i] = Icc -> TagOffsets[j];
            Icc -> TagSizes[i] = Icc -> TagSizes[j];
        }
    }
}

// Free allocated memory
free(Icc -> TagOffsets);
free(Icc -> TagSizes);
free(Icc -> TagLinked);

return TRUE;