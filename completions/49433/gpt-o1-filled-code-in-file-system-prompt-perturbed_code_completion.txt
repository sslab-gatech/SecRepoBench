for (tagIndex = 0; tagIndex < TagCount; tagIndex++) {

        // Read the tag entry
        if (io->Read(io, &Tag, sizeof(Tag), 1) != 1) {
            cmsSignalError(Icc->ContextID, cmsERROR_READ, "Couldn't read tag directory");
            return FALSE;
        }

        // Adjust endianness
        Tag.sig    = (cmsTagSignature) _cmsAdjustEndianess32(Tag.sig);
        Tag.offset = _cmsAdjustEndianess32(Tag.offset);
        Tag.size   = _cmsAdjustEndianess32(Tag.size);

        // Basic validity check: offset+size must fit within HeaderSize and neither can be zero
        if (Tag.offset == 0 || Tag.size == 0 || (Tag.offset + Tag.size) > HeaderSize) {
            // Skip this tag entry if invalid
            continue;
        }

        // Check if there's an existing tag with the same offset & size => link
        for (j = 0; j < Icc->TagCount; j++) {
            if (Icc->TagOffsets[j] == Tag.offset && Icc->TagSizes[j] == Tag.size) {

                // Mark this new tag as linked to an existing one
                Icc->TagNames[Icc->TagCount]       = Tag.sig;
                Icc->TagOffsets[Icc->TagCount]     = 0;
                Icc->TagSizes[Icc->TagCount]       = 0;
                Icc->TagPtrs[Icc->TagCount]        = NULL;
                Icc->TagTypeHandlers[Icc->TagCount]= NULL;
                Icc->TagSaveAsRaw[Icc->TagCount]   = FALSE;
                Icc->TagLinked[Icc->TagCount]      = Icc->TagNames[j];

                Icc->TagCount++;
                goto nextTag;
            }
        }

        // If no link found, store as a new entry
        Icc->TagNames[Icc->TagCount]       = Tag.sig;
        Icc->TagOffsets[Icc->TagCount]     = Tag.offset;
        Icc->TagSizes[Icc->TagCount]       = Tag.size;
        Icc->TagPtrs[Icc->TagCount]        = NULL;
        Icc->TagTypeHandlers[Icc->TagCount]= NULL;
        Icc->TagSaveAsRaw[Icc->TagCount]   = FALSE;
        Icc->TagLinked[Icc->TagCount]      = 0;

        Icc->TagCount++;

    nextTag:
        ; // Label target for "goto" usage above
    }

    return TRUE;