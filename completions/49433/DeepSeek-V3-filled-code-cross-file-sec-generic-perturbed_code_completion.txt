for (tagIndex = 0; tagIndex < TagCount; tagIndex++) {

        if (!_cmsReadUInt32Number(io, &Tag.sig)) return FALSE;
        if (!_cmsReadUInt32Number(io, &Tag.offset)) return FALSE;
        if (!_cmsReadUInt32Number(io, &Tag.size)) return FALSE;

        // Validate tag offset and size
        if (Tag.offset < sizeof(cmsICCHeader) || 
            Tag.offset > HeaderSize || 
            Tag.size > HeaderSize || 
            (Tag.offset + Tag.size) > HeaderSize) {
            cmsSignalError(Icc ->ContextID, cmsERROR_RANGE, "Invalid tag offset/size");
            return FALSE;
        }

        // Check for existing tags with matching offsets and sizes
        cmsTagSignature linkedSig = (cmsTagSignature) 0;
        for (j = 0; j < Icc ->TagCount; j++) {
            if (Tag.offset == Icc ->TagOffsets[j] && Tag.size == Icc ->TagSizes[j]) {
                linkedSig = Icc ->TagNames[j];
                break;
            }
        }

        // Store tag information
        Icc ->TagNames[Icc ->TagCount] = (cmsTagSignature) _cmsAdjustEndianess32(Tag.sig);
        Icc ->TagOffsets[Icc ->TagCount] = _cmsAdjustEndianess32(Tag.offset);
        Icc ->TagSizes[Icc ->TagCount] = _cmsAdjustEndianess32(Tag.size);
        Icc ->TagLinked[Icc ->TagCount] = linkedSig;
        Icc ->TagCount++;
    }

    if (!SetLinks(Icc)) return FALSE;