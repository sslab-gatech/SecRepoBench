for (j=0; j < TagCount; j++) {

        if (!_cmsReadTagEntry(io, &Tag)) return FALSE;

        // Adjust endianness
        Tag.sig    = _cmsAdjustEndianess32(Tag.sig);
        Tag.offset = _cmsAdjustEndianess32(Tag.offset);
        Tag.size   = _cmsAdjustEndianess32(Tag.size);

        // Check for valid offset and size
        if (Tag.offset >= HeaderSize || Tag.size >= HeaderSize || Tag.offset + Tag.size > HeaderSize) {

            cmsSignalError(Icc ->ContextID, cmsERROR_CORRUPTION_DETECTED, "Corrupted profile: tag offset or size is invalid");
            return FALSE;
        }

        // Store the tag information in the profile structure
        Icc ->TagNames[Icc ->TagCount] = Tag.sig;
        Icc ->TagOffsets[Icc ->TagCount] = Tag.offset;
        Icc ->TagSizes[Icc ->TagCount] = Tag.size;
        Icc ->TagLinked[Icc ->TagCount] = (cmsTagSignature) 0;
        Icc ->TagPtrs[Icc ->TagCount] = NULL;
        Icc ->TagTypeHandlers[Icc ->TagCount] = NULL;
        Icc ->TagSaveAsRaw[Icc ->TagCount] = FALSE;

        // Check for existing tags with matching offsets and sizes
        for (tagIndex = 0; tagIndex < Icc->TagCount; tagIndex++) {
            if (Icc->TagOffsets[tagIndex] == Tag.offset && Icc->TagSizes[tagIndex] == Tag.size) {
                // Link the tags
                Icc->TagLinked[Icc->TagCount] = Icc->TagNames[tagIndex];
                break;
            }
        }

        Icc ->TagCount++;
    }