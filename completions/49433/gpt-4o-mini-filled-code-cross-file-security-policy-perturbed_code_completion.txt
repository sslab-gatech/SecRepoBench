for (tagIndex = 0; tagIndex < TagCount; tagIndex++) {
        cmsTagEntry TagEntry;

        // Read the tag entry
        if (io->Read(io, &TagEntry, sizeof(cmsTagEntry), 1) != 1) {
            return FALSE;
        }

        // Validate tag offset and size
        if (TagEntry.offset + TagEntry.size > HeaderSize) {
            cmsSignalError(Icc->ContextID, cmsERROR_RANGE, "Invalid tag offset or size");
            return FALSE;
        }

        // Check if we have space for the new tag
        if (Icc->TagCount >= MAX_TABLE_TAG) {
            cmsSignalError(Icc->ContextID, cmsERROR_RANGE, "Too many tags processed");
            return FALSE;
        }

        // Store the tag signature, offset, and size
        Icc->TagSignature[Icc->TagCount] = TagEntry.signature;
        Icc->TagOffsets[Icc->TagCount] = TagEntry.offset;
        Icc->TagSizes[Icc->TagCount] = TagEntry.size;

        // Check for type compatibility before linking
        if (IsTypeSupported(&TagEntry.descriptor, TagEntry.type)) {
            Icc->TagLinked[Icc->TagCount] = TagEntry.linkedSignature;
        } else {
            Icc->TagLinked[Icc->TagCount] = 0; // No link if types are incompatible
        }

        // Increment the tag count
        Icc->TagCount++;
    }