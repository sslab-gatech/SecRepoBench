for (tagIndex = 0; tagIndex < TagCount; tagIndex++) {
        cmsUInt32Number offset, size;

        if (!_cmsReadUInt32Number(io, &offset) ||
            !_cmsReadUInt32Number(io, &size)) {
            return FALSE;
        }

        // Validate offset and size
        if (offset >= HeaderSize || offset + size > HeaderSize || size == 0) {
            cmsSignalError(Icc->ContextID, cmsERROR_BAD_TAG, "Invalid tag offset or size");
            return FALSE;
        }

        if (!_cmsReadTagEntry(io, &Tag)) return FALSE;

        // Check for buffer overflow
        if (Icc->TagCount >= MAX_TABLE_TAG) {
            cmsSignalError(Icc->ContextID, cmsERROR_RANGE, "Too many tags");
            return FALSE;
        }

        // Check tag type compatibility
        cmsTagDescriptor* tagDescriptor = _cmsGetTagDescriptor(Tag.sig);
        if (tagDescriptor != NULL && !IsTypeSupported(tagDescriptor, Tag.type)) {
            cmsSignalError(Icc->ContextID, cmsERROR_BAD_TAG, "Unsupported tag type");
            continue; // Skip unsupported tags
        }

        Icc->TagSignatures[Icc->TagCount] = Tag.sig;
        Icc->TagOffsets[Icc->TagCount] = offset;
        Icc->TagSizes[Icc->TagCount] = size;
        Icc->TagTypes[Icc->TagCount] = Tag.type;
        Icc->TagLinked[Icc->TagCount] = 0; // Initialize linked tag to 0

        // Check for existing tags with matching offsets and sizes
        for (j = 0; j < Icc->TagCount; j++) {
            if (Icc->TagOffsets[j] == offset && Icc->TagSizes[j] == size) {
                Icc->TagLinked[Icc->TagCount] = Icc->TagSignatures[j];
                break;
            }
        }
        Icc->TagCount++;
    }

    // Set links between tags
    SetLinks(Icc);