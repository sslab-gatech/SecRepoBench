{
        cmsUInt32Number k;

        for (j = 0; j < TagCount; j++) {

            if (!_cmsReadUInt32Number(io, &Tag.Signature)) return FALSE;
            if (!_cmsReadUInt32Number(io, &Tag.Offset))    return FALSE;
            if (!_cmsReadUInt32Number(io, &Tag.Size))      return FALSE;

            Tag.Signature = _cmsAdjustEndianess32(Tag.Signature);
            Tag.Offset    = _cmsAdjustEndianess32(Tag.Offset);
            Tag.Size      = _cmsAdjustEndianess32(Tag.Size);

            // Validate tag boundaries and prevent potential overflow
            if (Tag.Offset > HeaderSize || Tag.Size > (HeaderSize - Tag.Offset)) {
                // Invalid or corrupted tag, skip or report
                continue;
            }

            // Assume no link by default
            Icc->TagLinked[Icc->TagCount] = 0;

            // Check if this tag links to a previously read one
            for (k = 0; k < Icc->TagCount; k++) {
                if (Icc->TagOffsets[k] == Tag.Offset && Icc->TagSizes[k] == Tag.Size) {
                    // Tag shares the same data block as an earlier tag
                    Icc->TagLinked[Icc->TagCount] = Icc->TagNames[k];
                    break;
                }
            }

            // Store the new tag information
            Icc->TagNames[Icc->TagCount]   = Tag.Signature;
            Icc->TagOffsets[Icc->TagCount] = Tag.Offset;
            Icc->TagSizes[Icc->TagCount]   = Tag.Size;

            Icc->TagCount++;
        }
    }