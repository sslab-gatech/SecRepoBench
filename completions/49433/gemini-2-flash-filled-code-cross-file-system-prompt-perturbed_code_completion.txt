for (tagIndex = 0; tagIndex < TagCount; tagIndex++) {

        if (!_cmsReadUInt32Number(io, &Tag.sig)) return FALSE;
        if (!_cmsReadUInt32Number(io, &Tag.offset)) return FALSE;
        if (!_cmsReadUInt32Number(io, &Tag.size)) return FALSE;

        // All offsets should be beyond the header
        if (Tag.offset < HeaderSize) {
            cmsSignalError(Icc ->ContextID, cmsERROR_RANGE, "Tag '%#x' offset (%d) is before header (%d)", (unsigned int) Tag.sig, Tag.offset, HeaderSize);
            return FALSE;
        }

        // Check for overflow
        if (Tag.offset + Tag.size < Tag.offset) {
            cmsSignalError(Icc->ContextID, cmsERROR_RANGE, "Tag '%#x' offset (%d) + size (%d) overflows", (unsigned int)Tag.sig, Tag.offset, Tag.size);
            return FALSE;
        }

        // Check for validity
        if (Tag.offset + Tag.size > Icc ->IOhandler ->ReportedSize) {
            cmsSignalError(Icc ->ContextID, cmsERROR_RANGE, "Tag '%#x' offset (%d) + size (%d) goes beyond profile (%d)", (unsigned int) Tag.sig, Tag.offset, Tag.size, Icc ->IOhandler ->ReportedSize);
            return FALSE;
        }

        // Store the tag
        Icc ->TagSignatures[Icc ->TagCount] = _cmsAdjustEndianess32(Tag.sig);
        Icc ->TagOffsets[Icc ->TagCount]    = _cmsAdjustEndianess32(Tag.offset);
        Icc ->TagSizes[Icc ->TagCount]      = _cmsAdjustEndianess32(Tag.size);
        Icc ->TagLinked  [Icc ->TagCount]    = (cmsTagSignature) 0;

        // Check for links
        for (j=0; j < Icc ->TagCount; j++) {

            if (Icc ->TagOffsets[j] == Icc ->TagOffsets[Icc ->TagCount] &&
                Icc ->TagSizes[j]   == Icc ->TagSizes[Icc ->TagCount]) {

                    Icc ->TagLinked[Icc ->TagCount] = Icc ->TagSignatures[j];
            }
        }

        Icc ->TagCount++;
    }

    // Fix eventual links
    SetLinks(Icc);