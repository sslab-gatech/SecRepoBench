}
        xmlBufferAdd(buff, buff2->content, buff2->use);
        xmlBufferFree(buff2);
        xmlFreeNode(node);
    }
    resbuf = xmlBufferContent(buff);
    xmlBufferFree(buff);
    return resbuf;
}

/**
 * xmlTextReaderReadOuterXml:
 * @reader:  the xmlTextReaderPtr used
 *
 * Reads the contents of the current node including child nodes and markup,
 * and also the markup for the current node itself.
 *
 * Returns a string containing the XML content, or NULL if the current node
 *         is neither an element nor attribute, or has no child nodes. The
 *         string must be deallocated by the caller.
 */
xmlChar *
xmlTextReaderReadOuterXml(xmlTextReaderPtr reader ATTRIBUTE_UNUSED)
{
    xmlChar *resbuf;
    xmlNodePtr node, cur_node;
    xmlBufferPtr buff, buff2;
    xmlDocPtr doc;

    if (xmlTextReaderExpand(reader) == NULL) {
        return NULL;
    }
    doc = reader->node->doc;
    buff = xmlBufferCreate();
    if (buff == NULL)
        return NULL;
    for (cur_node = reader->node->children; cur_node != NULL;
         cur_node = cur_node->next) {
        /* XXX: Why is the node copied? */
        node = xmlDocCopyNode(cur_node, doc, 1);
        buff2 = xmlBufferCreate();
        if (xmlNodeDump(buff2, doc, node, 0, 0) == -1) {
            xmlFreeNode(node);
            xmlBufferFree(buff2);
            xmlBufferFree(buff);
            return NULL;
        }
        xmlBufferAdd(buff, buff2->content, buff2->use);
        xmlBufferFree(buff2);
        xmlFreeNode(node);
    }
    /* XXX: Why is the node copied? */
    node = xmlDocCopyNode(reader->node, doc, 1);
    buff2 = xmlBufferCreate();
    if (xmlNodeDump(buff2, doc, node, 0, 0) == -1) {
        xmlFreeNode(node);
        xmlBufferFree(buff2);
        xmlBufferFree(buff);
        return NULL;
    }
    xmlBufferAdd(buff, buff2->content, buff2->use);
    xmlBufferFree(buff2);
    xmlFreeNode(node);
    resbuf = xmlBufferContent(buff);
    xmlBufferFree(buff);
    return resbuf;
}
#endif /* LIBXML_WRITER_ENABLED */

/**
 * xmlTextReaderReadString:
 * @reader:  the xmlTextReaderPtr used
 *
 * Reads the contents of the current node and concatenates them into a
 * single string.
 *
 * Returns a string containing the content, or NULL if the current node
 *         is neither a text nor a CDATA node, or has no child nodes.
 *         The string must be deallocated by the caller.
 */
xmlChar *
xmlTextReaderReadString(xmlTextReaderPtr reader) {
    xmlChar *resbuf;
    xmlNodePtr node;
    xmlBufferPtr buff;

    if (xmlTextReaderExpand(reader) == NULL) {
        return NULL;
    }
    node = reader->node;
    if ((node == NULL) ||
        ((node->type != XML_TEXT_NODE) && (node->type != XML_CDATA_SECTION_NODE))) {
        return NULL;
    }
    buff = xmlBufferCreate();
    if (buff == NULL)
        return NULL;
    xmlBufferAdd(buff, node->content, xmlStrlen(node->content));
    resbuf = xmlBufferContent(buff);
    xmlBufferFree(buff);
    return resbuf;
}

/**
 * xmlTextReaderGetAttribute:
 * @reader:  the xmlTextReaderPtr used
 * @name:  the name of the attribute
 *
 * Gets the value of an attribute of the current node.
 *
 * Returns the value of the attribute, or NULL if the attribute is not found.
 *         The string must be deallocated by the caller.
 */
xmlChar *
xmlTextReaderGetAttribute(xmlTextReaderPtr reader, const xmlChar *name) {
    xmlAttrPtr attr;

    if (reader == NULL)
        return NULL;
    if (reader->node == NULL)
        return NULL;
    if (reader->node->properties == NULL)
        return NULL;
    attr = xmlHasProp(reader->node, name);
    if (attr == NULL)
        return NULL;
    return xmlNodeListGetString(reader->node->doc, attr->children, 1);
}

/**
 * xmlTextReaderGetAttributeNo:
 * @reader:  the xmlTextReaderPtr used
 * @no:  the index of the attribute
 *
 * Gets the value of an attribute of the current node.
 *
 * Returns the value of the attribute, or NULL if the attribute is not found.
 *         The string must be deallocated by the caller.
 */
xmlChar *
xmlTextReaderGetAttributeNo(xmlTextReaderPtr reader, int no) {
    xmlAttrPtr attr;
    int i;

    if (reader == NULL)
        return NULL;
    if (reader->node == NULL)
        return NULL;
    if (reader->node->properties == NULL)
        return NULL;
    for (i = 0, attr = reader->node->properties; attr != NULL; attr = attr->next, i++) {
        if (i == no)
            return xmlNodeListGetString(reader->node->doc, attr->children, 1);
    }
    return NULL;
}

/**
 * xmlTextReaderGetAttributeNs:
 * @reader:  the xmlTextReaderPtr used
 * @localName:  the local name of the attribute
 * @namespaceURI:  the namespace URI of the attribute
 *
 * Gets the value of an attribute of the current node.
 *
 * Returns the value of the attribute, or NULL if the attribute is not found.
 *         The string must be deallocated by the caller.
 */
xmlChar *
xmlTextReaderGetAttributeNs(xmlTextReaderPtr reader,
                             const xmlChar *localName,
                             const xmlChar *namespaceURI) {
    xmlAttrPtr attr;

    if (reader == NULL)
        return NULL;
    if (reader->node == NULL)
        return NULL;
    if (reader->node->properties == NULL)
        return NULL;
    attr = xmlGetProp(reader->node, localName, namespaceURI);
    if (attr == NULL)
        return NULL;
    return xmlNodeListGetString(reader->node->doc, attr->children, 1);
}

/**
 * xmlTextReaderGetParserProp:
 * @reader:  the xmlTextReaderPtr used
 * @prop:  the property to get
 *
 * Gets the value of a parser property.
 *
 * Returns the value of the property, or -1 if the property is not recognized.
 */
int
xmlTextReaderGetParserProp(xmlTextReaderPtr reader, int prop) {
    if (reader == NULL)
        return(-1);
    return(reader->parserFlags & prop);
}

/**
 * xmlTextReaderSetParserProp:
 * @reader:  the xmlTextReaderPtr used
 * @prop:  the property to set
 * @value:  the value to set
 *
 * Sets the value of a parser property.
 *
 * Returns the value of the property, or -1 if the property is not recognized.
 */
int
xmlTextReaderSetParserProp(xmlTextReaderPtr reader, int prop, int value) {
    if (reader == NULL)
        return(-1);
    if (value)
        reader->parserFlags |= prop;
    else
        reader->parserFlags &= ~prop;
    return(reader->parserFlags & prop);
}

/**
 * xmlTextReaderPreserve:
 * @reader:  the xmlTextReaderPtr used
 *
 * Preserves the current node and its subtree.
 *
 * Returns 1 if the node was preserved successfully, 0 if there is no more
 *          nodes to preserve, or -1 in case of error
 */
int
xmlTextReaderPreserve(xmlTextReaderPtr reader) {
    if (reader == NULL)
        return(-1);
    if (reader->node == NULL)
        return(-1);
    if (reader->preserves > 0)
        return(0);
    reader->preserves++;
    if (reader->node->children != NULL) {
        xmlNodePtr cur;
        for (cur = reader->node->children; cur != NULL; cur = cur->next) {
            if (cur->type == XML_ELEMENT_NODE) {
                cur->extra |= NODE_IS_SPRESERVED;
                reader->preserves++;
            }
        }
    }
    return(1);
}

/**
 * xmlTextReaderGetNodeType:
 * @reader:  the xmlTextReaderPtr used
 *
 * Gets the type of the current node.
 *
 * Returns the type of the current node, or XML_TEXTREADER_NONE in case of error.
 */
int
xmlTextReaderGetNodeType(xmlTextReaderPtr reader) {
    if (reader == NULL)
        return(XML_TEXTREADER_NONE);
    return(reader->state);
}

/**
 * xmlTextReaderGetNodeName:
 * @reader:  the xmlTextReaderPtr used
 *
 * Gets the name of the current node.
 *
 * Returns the name of the current node, or NULL in case of error.
 *         The string must be deallocated by the caller.
 */
xmlChar *
xmlTextReaderGetNodeName(xmlTextReaderPtr reader) {
    if (reader == NULL)
        return(NULL);
    if (reader->node == NULL)
        return(NULL);
    return(xmlNodeListGetString(reader->node->doc, reader->node->properties, 1));
}

/**
 * xmlTextReaderGetNodePosition:
 * @reader:  the xmlTextReaderPtr used
 *
 * Gets the position of the current node in the document.
 *
 * Returns the position of the current node, or -1 in case of error.
 */
int
xmlTextReaderGetNodePosition(xmlTextReaderPtr reader) {
    if (reader == NULL)
        return(-1);
    if (reader->node == NULL)
        return(-1);
    return(reader->ctxt->nodeNr);
}

/**
 * xmlTextReaderGetDepth:
 * @reader:  the xmlTextReaderPtr used
 *
 * Gets the depth of the current node.
 *
 * Returns the depth of the current node, or -1 in case of error.
 */
int
xmlTextReaderGetDepth(xmlTextReaderPtr reader) {
    if (reader == NULL)
        return(-1);
    return(reader->depth);
}

/**
 * xmlTextReaderGetLineNumber:
 * @reader:  the xmlTextReaderPtr used
 *
 * Gets the line number of the current node.
 *
 * Returns the line number of the current node, or -1 in case of error.
 */
int
xmlTextReaderGetLineNumber(xmlTextReaderPtr reader) {
    if (reader == NULL)
        return(-1);
    if (reader->node == NULL)
        return(-1);
    return(reader->ctxt->input->line);
}

/**
 * xmlTextReaderGetColumnNumber:
 * @reader:  the xmlTextReaderPtr used
 *
 * Gets the column number of the current node.
 *
 * Returns the column number of the current node, or -1 in case of error.
 */
int
xmlTextReaderGetColumnNumber(xmlTextReaderPtr reader) {
    if (reader == NULL)
        return(-1);
    if (reader->node == NULL)
        return(-1);
    return(reader->ctxt->input->col);
}

/**
 * xmlTextReaderGetBaseUri:
 * @reader:  the xmlTextReaderPtr used
 *
 * Gets the base URI of the current node.
 *
 * Returns the base URI of the current node, or NULL in case of error.
 *         The string must be deallocated by the caller.
 */
xmlChar *
xmlTextReaderGetBaseUri(xmlTextReaderPtr reader) {
    if (reader == NULL)
        return(NULL);
    if (reader->node == NULL)
        return(NULL);
    return(xmlNodeGetBaseUri(reader->node));
}

/**
 * xmlTextReaderGetEncoding:
 * @reader:  the xmlTextReaderPtr used
 *
 * Gets the encoding of the current document.
 *
 * Returns the encoding of the current document, or NULL in case of error.
 *         The string must be deallocated by the caller.
 */
xmlChar *
xmlTextReaderGetEncoding(xmlTextReaderPtr reader) {
    if (reader == NULL)
        return(NULL);
    if (reader->doc == NULL)