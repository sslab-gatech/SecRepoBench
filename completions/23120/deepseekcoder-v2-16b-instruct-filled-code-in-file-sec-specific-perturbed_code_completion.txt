(cur_node, doc, 1);
        if (node == NULL) {
            xmlBufferFree(buff);
            return NULL;
        }
        xmlBufferAdd(buff, (const char *) node->content,
                     xmlNodeGetContentLength(node));
        xmlFreeNode(node);
    }
    resbuf = buff->content;
    buff->content = NULL;
    xmlBufferFree(buff);
    return resbuf;
}

/**
 * xmlTextReaderReadOuterXml:
 * @reader:  the xmlTextReaderPtr used
 *
 * Reads the current node and all its child nodes, including markup.
 *
 * Returns a string containing the XML content, or NULL if the current node
 *         is neither an element nor attribute, or has no child nodes. The
 *         string must be deallocated by the caller.
 */
xmlChar *
xmlTextReaderReadOuterXml(xmlTextReaderPtr reader ATTRIBUTE_UNUSED)
{
    xmlChar *resbuf;
    xmlNodePtr node, cur_node;
    xmlBufferPtr buff, buff2;
    xmlDocPtr doc;

    if (xmlTextReaderExpand(reader) == NULL) {
        return NULL;
    }
    doc = reader->node->doc;
    buff = xmlBufferCreate();
    if (buff == NULL)
        return NULL;
    for (cur_node = reader->node->children; cur_node != NULL;
         cur_node = cur_node->next) {
        /* XXX: Why is the node copied? */
        node = xmlDocCopyNode(cur_node, doc, 1);
        if (node == NULL) {
            xmlBufferFree(buff);
            return NULL;
        }
        xmlBufferAdd(buff, (const char *) node->content,
                     xmlNodeGetContentLength(node));
        xmlFreeNode(node);
    }
    /* Add the current node */
    node = xmlDocCopyNode(reader->node, doc, 1);
    if (node == NULL) {
        xmlBufferFree(buff);
        return NULL;
    }
    xmlBufferAdd(buff, (const char *) node->content,
                 xmlNodeGetContentLength(node));
    xmlFreeNode(node);
    resbuf = buff->content;
    buff->content = NULL;
    xmlBufferFree(buff);
    return resbuf;
}
#endif /* LIBXML_WRITER_ENABLED */

/**
 * xmlTextReaderReadString:
 * @reader:  the xmlTextReaderPtr used
 *
 * Reads the contents of the current node and all its child nodes,
 * concatenating them into a single string.
 *
 * Returns a string containing the XML content, or NULL if the current node
 *         is neither an element nor attribute, or has no child nodes. The
 *         string must be deallocated by the caller.
 */
xmlChar *
xmlTextReaderReadString(xmlTextReaderPtr reader) {
    xmlChar *resbuf;
    xmlNodePtr node;
    xmlBufferPtr buff;

    if (xmlTextReaderExpand(reader) == NULL) {
        return NULL;
    }
    buff = xmlBufferCreate();
    if (buff == NULL)
        return NULL;
    for (node = reader->node->children; node != NULL; node = node->next) {
        switch (node->type) {
        case XML_TEXT_NODE:
        case XML_CDATA_SECTION_NODE:
            xmlBufferAdd(buff, node->content, xmlNodeGetContentLength(node));
            break;
        case XML_ELEMENT_NODE:
            if (node->children != NULL) {
                xmlChar *tmp;
                tmp = xmlTextReaderCollectSiblings(node->children);
                if (tmp == NULL) {
                    xmlBufferFree(buff);
                    return NULL;
                }
                xmlBufferAdd(buff, tmp, xmlStrlen(tmp));
                xmlFree(tmp);
            }
            break;
        default:
            break;
        }
    }
    resbuf = buff->content;
    buff->content = NULL;
    xmlBufferFree(buff);
    return resbuf;
}

/**
 * xmlTextReaderGetAttribute:
 * @reader:  the xmlTextReaderPtr used
 * @name:  the attribute name
 *
 * Get the value of an attribute of the current node.
 *
 * Returns the attribute value or NULL if the attribute is not found.
 */
xmlChar *
xmlTextReaderGetAttribute(xmlTextReaderPtr reader, const xmlChar *name) {
    xmlAttrPtr attr;

    if ((reader == NULL) || (reader->node == NULL))
        return(NULL);
    if (reader->node->type != XML_ELEMENT_NODE)
        return(NULL);
    attr = reader->node->properties;
    while (attr != NULL) {
        if ((attr->name != NULL) && (xmlStrEqual(attr->name, name)))
            return(attr->children->content);
        attr = attr->next;
    }
    return(NULL);
}

/**
 * xmlTextReaderGetAttributeNo:
 * @reader:  the xmlTextReaderPtr used
 * @index:  the attribute index
 *
 * Get the value of an attribute of the current node.
 *
 * Returns the attribute value or NULL if the attribute is not found.
 */
xmlChar *
xmlTextReaderGetAttributeNo(xmlTextReaderPtr reader, int index) {
    xmlAttrPtr attr;
    int i;

    if ((reader == NULL) || (reader->node == NULL))
        return(NULL);
    if (reader->node->type != XML_ELEMENT_NODE)
        return(NULL);
    attr = reader->node->properties;
    for (i = 0; (i < index) && (attr != NULL); i++)
        attr = attr->next;
    if ((attr == NULL) || (i != index))
        return(NULL);
    return(attr->children->content);
}

/**
 * xmlTextReaderGetAttributeNs:
 * @reader:  the xmlTextReaderPtr used
 * @localName:  the local name of the attribute
 * @namespaceURI:  the namespace URI of the attribute
 *
 * Get the value of an attribute of the current node.
 *
 * Returns the attribute value or NULL if the attribute is not found.
 */
xmlChar *
xmlTextReaderGetAttributeNs(xmlTextReaderPtr reader,
                            const xmlChar *localName,
                            const xmlChar *namespaceURI) {
    xmlAttrPtr attr;

    if ((reader == NULL) || (reader->node == NULL))
        return(NULL);
    if (reader->node->type != XML_ELEMENT_NODE)
        return(NULL);
    attr = reader->node->properties;
    while (attr != NULL) {
        if ((attr->name != NULL) && (attr->ns != NULL) &&
            (xmlStrEqual(attr->name, localName)) &&
            (xmlStrEqual(attr->ns->href, namespaceURI)))
            return(attr->children->content);
        attr = attr->next;
    }
    return(NULL);
}

/**
 * xmlTextReaderGetParserProp:
 * @reader:  the xmlTextReaderPtr used
 * @prop:  the property to get
 *
 * Get the value of a parser property.
 *
 * Returns the property value or -1 if the property is not found.
 */
int
xmlTextReaderGetParserProp(xmlTextReaderPtr reader, int prop) {
    if (reader == NULL)
        return(-1);
    return(reader->parserFlags & prop);
}

/**
 * xmlTextReaderSetParserProp:
 * @reader:  the xmlTextReaderPtr used
 * @prop:  the property to set
 * @value:  the value to set
 *
 * Set the value of a parser property.
 *
 * Returns the previous value of the property or -1 if the property is not found.
 */
int
xmlTextReaderSetParserProp(xmlTextReaderPtr reader, int prop, int value) {
    int old;

    if (reader == NULL)
        return(-1);
    old = reader->parserFlags & prop;
    if (value)
        reader->parserFlags |= prop;
    else
        reader->parserFlags &= ~prop;
    return(old);
}

/**
 * xmlTextReaderPreserve:
 * @reader:  the xmlTextReaderPtr used
 *
 * Preserve the current node and its subtree.
 */
void
xmlTextReaderPreserve(xmlTextReaderPtr reader) {
    if ((reader == NULL) || (reader->node == NULL))
        return;
    if (reader->node->type == XML_ELEMENT_NODE)
        reader->node->extra |= NODE_IS_PRESERVED;
}

/**
 * xmlTextReaderSkip:
 * @reader:  the xmlTextReaderPtr used
 *
 * Skip the children of the current node.
 *
 * Returns 1 if the node was skipped successfully, 0 if there is no more
 *          nodes to read, or -1 in case of error
 */
int
xmlTextReaderSkip(xmlTextReaderPtr reader) {
    if ((reader == NULL) || (reader->node == NULL))
        return(-1);
    if (reader->node->type != XML_ELEMENT_NODE)
        return(0);
    if (reader->node->children == NULL)
        return(0);
    reader->node = reader->node->children;
    reader->depth++;
    return(1);
}

/**
 * xmlTextReaderGetNodeType:
 * @reader:  the xmlTextReaderPtr used
 *
 * Get the type of the current node.
 *
 * Returns the node type or -1 in case of error.
 */
int
xmlTextReaderGetNodeType(xmlTextReaderPtr reader) {
    if (reader == NULL)
        return(-1);
    return(reader->node->type);
}

/**
 * xmlTextReaderGetNodeName:
 * @reader:  the xmlTextReaderPtr used
 *
 * Get the name of the current node.
 *
 * Returns the node name or NULL in case of error.
 */
xmlChar *
xmlTextReaderGetNodeName(xmlTextReaderPtr reader) {
    if (reader == NULL)
        return(NULL);
    return(reader->node->name);
}

/**
 * xmlTextReaderGetNodePosition:
 * @reader:  the xmlTextReaderPtr used
 *
 * Get the current node position in the document.
 *
 * Returns the node position or -1 in case of error.
 */
int
xmlTextReaderGetNodePosition(xmlTextReaderPtr reader) {
    if (reader == NULL)
        return(-1);
    return(reader->ctxt->nodeNr);
}

/**
 * xmlTextReaderGetDepth:
 * @reader:  the xmlTextReaderPtr used
 *
 * Get the current node depth in the document.
 *
 * Returns the node depth or -1 in case of error.
 */
int
xmlTextReaderGetDepth(xmlTextReaderPtr reader) {
    if (reader == NULL)
        return(-1);
    return(reader->depth);
}

/**
 * xmlTextReaderGetAttributeCount:
 * @reader:  the xmlTextReaderPtr used
 *
 * Get the number of attributes for the current node.
 *
 * Returns the number of attributes or -1 in case of error.
 */
int
xmlTextReaderGetAttributeCount(xmlTextReaderPtr reader) {
    int count;
    xmlAttrPtr attr;

    if ((reader == NULL) || (reader->node == NULL))
        return(-1);
    if (reader->node->type != XML_ELEMENT_NODE)
        return(0);
    count = 0;
    attr = reader->node->properties;
    while (attr != NULL) {
        count++;
        attr = attr->next;
    }
    return(count);
}

/**
 * xmlTextReaderGetNamespaceCount:
 * @reader:  the xmlTextReaderPtr used
 *
 * Get the number of namespaces for the current node.
 *
 * Returns the number of namespaces or -1 in case of error.
 */
int
xmlTextReaderGetNamespaceCount(xmlTextReaderPtr reader) {
    int count;
    xmlNsPtr ns;

    if ((reader == NULL) || (reader->node == NULL))
        return(-1);
    count = 0;
    ns = reader->node->nsDef;
    while (ns != NULL) {
        count++;
        ns = ns->next;
    }
    return(count);
}

/**
 * xmlTextReaderGetLocalName:
 * @reader:  the xmlTextReaderPtr used
 *
 * Get the local name of the current node.
 *
 * Returns the local name or NULL in case of error.
 */
xmlChar *
xmlTextReaderGetLocalName(xmlTextReaderPtr reader) {
    if (reader == NULL)
        return(NULL);
    return(reader->node->name);
}

/**
 * xmlTextReaderGetBaseUri: