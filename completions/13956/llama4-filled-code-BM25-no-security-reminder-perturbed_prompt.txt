Below is the content of a C/C++ function where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
static const char* str_table_entry(
    const char* str_table_base,
    const char* str_table_limit,
    int entry_index)
{
  // Calculate the position of the string entry in the table using the given index.
  // Return NULL if the string entry is invalid.
  // <MASK>
}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// tests/util.c
int compile_rule(
    char* string,
    YR_RULES** rules)
{
  YR_COMPILER* compiler = NULL;
  int result = ERROR_SUCCESS;

  compile_error[0] = '\0';
  warnings = 0;

  if (yr_compiler_create(&compiler) != ERROR_SUCCESS)
  {
    perror("yr_compiler_create");
    goto _exit;
  }

  yr_compiler_set_callback(compiler, callback_function, &warnings);

  if (yr_compiler_add_string(compiler, string, NULL) != 0)
  {
    result = compiler->last_error;
    goto _exit;
  }

  result = yr_compiler_get_rules(compiler, rules);

_exit:
  yr_compiler_destroy(compiler);
  return result;
}

// the below code fragment can be found in:
// yarac.c
static bool define_external_variables(
    YR_COMPILER* compiler)
{
  for (int i = 0; ext_vars[i] != NULL; i++)
  {
    char* equal_sign = strchr(ext_vars[i], '=');

    if (!equal_sign)
    {
      fprintf(stderr, "error: wrong syntax for `-d` option.\n");
      return false;
    }

    // Replace the equal sign with null character to split the external
    // variable definition (i.e: myvar=somevalue) in two strings: identifier
    // and value.

    *equal_sign = '\0';

    char* identifier = ext_vars[i];
    char* value = equal_sign + 1;

    if (is_float(value))
    {
      yr_compiler_define_float_variable(
          compiler,
          identifier,
          atof(value));
    }
    else if (is_integer(value))
    {
      yr_compiler_define_integer_variable(
          compiler,
          identifier,
          atoi(value));
    }
    else if (strcmp(value, "true") == 0 || strcmp(value, "false") == 0)
    {
      yr_compiler_define_boolean_variable(
          compiler,
          identifier,
          strcmp(value, "true") == 0);
    }
    else
    {
      yr_compiler_define_string_variable(
          compiler,
          identifier,
          value);
    }
  }

  return true;
}

// the below code fragment can be found in:
// yara.c
static void print_rules_stats(
    YR_RULES* rules)
{
  YR_RULES_STATS stats;

  int t = sizeof(stats.top_ac_match_list_lengths) /
          sizeof(stats.top_ac_match_list_lengths[0]);

  int result = yr_rules_get_stats(rules, &stats);

  if (result != ERROR_SUCCESS)
  {
     print_error(result);
     return;
  }

  printf(
      "size of AC transition table        : %d\n",
      stats.ac_tables_size);

  printf(
      "average length of AC matches lists : %f\n",
      stats.ac_average_match_list_length);

  printf(
      "number of rules                    : %d\n",
      stats.rules);

  printf(
      "number of strings                  : %d\n",
      stats.strings);

  printf(
      "number of AC matches               : %d\n",
      stats.ac_matches);

  printf(
      "number of AC matches in root node  : %d\n",
      stats.ac_root_match_list_length);

  printf("number of AC matches in top %d longest lists\n", t);

  for (int i = 0; i < t; i++)
    printf(" %3d: %d\n", i + 1, stats.top_ac_match_list_lengths[i]);

  printf("match list length percentiles\n");

  for (int i = 0; i <= 100; i++)
    printf(" %3d: %d\n", i, stats.ac_match_list_length_pctls[i]);
}

// the below code fragment can be found in:
// libyara/modules/hash.c
define_function(string_md5)
{
  unsigned char digest[YR_MD5_LEN];
  char digest_ascii[YR_MD5_LEN * 2 + 1];

  yr_md5_ctx md5_context;
  SIZED_STRING* s = sized_string_argument(1);

  yr_md5_init(&md5_context);
  yr_md5_update(&md5_context, s->c_string, s->length);
  yr_md5_final(digest, &md5_context);

  digest_to_ascii(digest, digest_ascii, YR_MD5_LEN);

  return_string(digest_ascii);
}

// the below code fragment can be found in:
// libyara/lexer.c
void *yyalloc (yy_size_t  size , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;
	return malloc(size);
}
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).