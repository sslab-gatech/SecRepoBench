int digit;
   if (ch >= '0' && ch <= '9') {
       digit = ch - '0';
   } else if (ch >= 'A' && ch <= 'F') {
       digit = ch - 'A' + 10;
   } else if (ch >= 'a' && ch <= 'f') {
       digit = ch - 'a' + 10;
   } else {
       return FP_VAL;
   }
   /* If starting a new digit slot ensure it is zeroed */
   if (j == 0) {
       fpnumber->dp[k] = 0;
   }
   /* Check if the current digit fits entirely into the current fp_digit */
   if (j <= (DIGIT_BIT - 4)) {
       /* Ensure we are within bounds */
       if (k >= FP_SIZE)
           return FP_MEM;
       fpnumber->dp[k] |= ((fp_digit)digit << j);
       j += 4;
       if (j == DIGIT_BIT) {
           j = 0;
           k++;
       }
   } else {
       int rem = (j + 4) - DIGIT_BIT;
       /* Write the lower part into the current fp_digit */
       if (k >= FP_SIZE)
           return FP_MEM;
       fpnumber->dp[k] |= ((fp_digit)digit << j);
       k++;
       if (k >= FP_SIZE)
           return FP_MEM;
       /* Store the carry over bits into the next fp_digit */
       fpnumber->dp[k] = ((fp_digit)digit >> (4 - rem));
       j = rem;
   }