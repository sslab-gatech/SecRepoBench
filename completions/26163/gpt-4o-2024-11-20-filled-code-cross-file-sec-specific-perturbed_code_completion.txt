// Validate the character and convert it to a numeric value
      if (ch >= '0' && ch <= '9') {
          ch = ch - '0';
      } else if (ch >= 'A' && ch <= 'F') {
          ch = ch - 'A' + 10;
      } else if (ch >= 'a' && ch <= 'f') {
          ch = ch - 'a' + 10;
      } else {
          return FP_VAL; // Invalid character for radix 16
      }

      // Ensure the numeric value is within the valid range for radix 16
      if (ch >= 16) {
          return FP_VAL; // Out of range for radix 16
      }

      // Compute the current position in the array
      if (j == 0) {
          fpnumber->dp[k] = (fp_digit)ch;
      } else {
          fpnumber->dp[k] |= ((fp_digit)ch << (j * 4));
      }

      // Update the bit position and digit index
      j = (j + 1) % (int)(sizeof(fp_digit) * 2);
      if (j == 0) {
          k++;
          if (k >= FP_SIZE) {
              return FP_VAL; // Exceeds maximum size
          }
      }