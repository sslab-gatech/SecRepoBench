// Convert the current character in the string to its corresponding numeric value
// based on whether it is a digit or a hexadecimal letter (both uppercase and lowercase).
// If the character is not valid, return an error code.
if (ch >= '0' && ch <= '9')
    ch -= '0';
else if (ch >= 'A' && ch <= 'F')
    ch -= 'A' - 10;
else if (ch >= 'a' && ch <= 'f')
    ch -= 'a' - 10;
else {
    return FP_VAL;
}

// Compute the current position in the array where the resulting value should be stored.
// Update the array dp to reflect the decoded number.
// Manage the current bit position and digit index appropriately.
// Ensure that the number of digits does not exceed the maximum size (`FP_SIZE`).
fpnumber->dp[k] |= ((fp_digit)ch) << j;
j += 4;
if (k >= FP_SIZE - 1) {
    return FP_VAL;
}
if (j == DIGIT_BIT)
    fpnumber->dp[++k] = 0;
j &= DIGIT_BIT - 1;