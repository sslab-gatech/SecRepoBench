// Convert the current character in the string to its corresponding numeric value
// based on whether it is a digit or a hexadecimal letter (both uppercase and lowercase).
// If the character is not valid, return an error code.
if ((ch >= '0' && ch <= '9') || (ch >= 'A' && ch <= 'F') || (ch >= 'a' && ch <= 'f')) {
    fp_digit val;
    if (ch >= '0' && ch <= '9') {
        val = (fp_digit)(ch - '0');
    } else if (ch >= 'A' && ch <= 'F') {
        val = (fp_digit)(ch - 'A' + 10);
    } else {
        val = (fp_digit)(ch - 'a' + 10);
    }

    // Compute the current position in the array where the resulting value should be stored.
    int pos = j / (int)sizeof(fp_digit);
    if (pos >= FP_SIZE) {
        return FP_VAL;  // Index out of bounds
    }

    // Update the array dp to reflect the decoded number.
    fp_digit mask = (fp_digit)1 << (j % (int)sizeof(fp_digit) * 8);
    fpnumber->dp[pos] |= (val & 0xF) << (j % (int)sizeof(fp_digit) * 8);
    j += 4;  // Move to the next 4-bit position
    k = MAX(k, pos + 1);  // Update the used count
} else {
    return FP_VAL;  // Invalid character
}