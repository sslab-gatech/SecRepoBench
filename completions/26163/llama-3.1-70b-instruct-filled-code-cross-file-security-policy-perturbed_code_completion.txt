// Convert the current character in the string to its corresponding numeric value
// based on whether it is a digit or a hexadecimal letter (both uppercase and lowercase).
// If the character is not valid, return an error code.
if ((ch >= '0') && (ch <= '9')) {
    ch = ch - '0';
} else if ((ch >= 'a') && (ch <= 'f')) {
    ch = ch - 'a' + 10;
} else if ((ch >= 'A') && (ch <= 'F')) {
    ch = ch - 'A' + 10;
} else {
    return FP_VAL;
}

// Compute the current position in the array where the resulting value should be stored.
// Update the array dp to reflect the decoded number.
// Manage the current bit position and digit index appropriately.
// Ensure that the number of digits does not exceed the maximum size (`FP_SIZE`).
if (j >= FP_SIZE) {
    return FP_VAL;
}
fpnumber->dp[j] = (fpnumber->dp[j] << 4) | (fp_digit)ch;
if (fpnumber->dp[j]!= 0) {
    k = j + 1;
}
j++;