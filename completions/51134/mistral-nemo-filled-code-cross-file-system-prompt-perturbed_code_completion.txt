if (pos == std::string::npos) {
  if (*p == '.') {
    p = nextchar(p);
    ++st;
    while ((opts & aeUTF8) && st < str.size() && (str[st] & 0xc0) == 0x80)
      ++st;
    if (st == str.size() && p)
      return 0;  // word <= condition
  } else {
    // Compare the current character in the input string with the current condition character.
    // If they match, increment the position in the input string and advance to the next condition character.
    // Handle multibyte UTF-8 characters if the option is set, ensuring the entire character sequence matches.
    // If the input character matches within a group, mark that the character was found in the group.
    // If the character does not match and is not within a group, return 0 to indicate the condition failed.
    // Continue processing the condition string or group until the end of the string or group.
    if (str[st] == *p) {
      ++st;
      while ((opts & aeUTF8) && st < str.size() && (str[st] & 0xc0) == 0x80)
        ++st;
      p = nextchar(p);
      if (ingroup)
        ingroup = true;
    } else if (!ingroup) {
      return 0;
    }
  }
} else {
  // Compare the current character in the input string with the current condition character.
  // If they match, increment the position in the input string and advance to the next condition character.
  // Handle multibyte UTF-8 characters if the option is set, ensuring the entire character sequence matches.
  // If the input character matches within a group, mark that the character was found in the group.
  // If the character does not match and is not within a group, return 0 to indicate the condition failed.
  // Continue processing the condition string or group until the end of the string or group.
  if (str[st] == *p) {
    ++st;
    while ((opts & aeUTF8) && st < str.size() && (str[st] & 0xc0) == 0x80)
      ++st;
    p = nextchar(p);
    ingroup = true;
  } else {
    return 0;
  }
}