if (st >= str.size()) {
  // No more input characters to match
  return 0;
}
if ((opts & aeUTF8) && (unsigned char)str[st] >= 0x80) {
  // Handle multibyte UTF-8 character
  size_t charlen = 1;
  unsigned char lead = (unsigned char)str[st];
  if ((lead & 0xe0) == 0xc0) charlen = 2;
  else if ((lead & 0xf0) == 0xe0) charlen = 3;
  else if ((lead & 0xf8) == 0xf0) charlen = 4;
  // Compare the bytes of the UTF-8 character
  bool match = true;
  for (size_t i = 0; i < charlen; ++i) {
    if (st + i >= str.size() || str[st + i] != p[i]) {
      match = false;
      break;
    }
  }
  if (match) {
    if (pos != std::string::npos) {
      ingroup = true;
      p = nextchar(p);
      break;
    }
    st += charlen;
    p = nextchar(p + charlen - 1);
    if (st == str.size() && p)
      return 0;
    break;
  } else {
    if (pos != std::string::npos) {
      p = nextchar(p);
      break;
    }
    return 0;
  }
} else {
  // Single byte character
  if (str[st] == *p) {
    if (pos != std::string::npos) {
      ingroup = true;
      p = nextchar(p);
      break;
    }
    ++st;
    p = nextchar(p);
    if ((opts & aeUTF8) && st < str.size() && (str[st] & 0xc0) == 0x80) {
      // Skip continuation bytes
      while (st < str.size() && (str[st] & 0xc0) == 0x80)
        ++st;
    }
    if (st == str.size() && p)
      return 0;
    break;
  } else {
    if (pos != std::string::npos) {
      p = nextchar(p);
      break;
    }
    return 0;
  }
}