default: {
  // Compare the current character in the input string with the current condition character.
  // If they match, increment the position in the input string and advance to the next condition character.
  // Handle multibyte UTF-8 characters if the option is set, ensuring the entire character sequence matches.
  // If the input character matches within a group, mark that the character was found in the group.
  // If the character does not match and is not within a group, return 0 to indicate the condition failed.
  // Continue processing the condition string or group until the end of the string or group.
  if (*st == *p) {
    p = nextchar(p);
    if ((opts & aeUTF8) && (*st & 0x80)) {
      st--;
      while (p && (st >= beg)) {
        if (*p!= *st) {
          if (!pos)
            return 0;
          st = pos;
          break;
        }
        // first byte of the UTF-8 multibyte character
        if ((*p & 0xc0)!= 0x80)
          break;
        p = nextchar(p);
        st--;
      }
      if (pos && st!= pos) {
        if (neg)
          return 0;
        else if (i == numconds)
          return 1;
        ingroup = true;
        while (p && *p!= ']' && ((p = nextchar(p))!= NULL)) {
        }
        st--;
      }
      if (p && *p!= ']')
        p = nextchar(p);
    } else if (pos) {
      if (neg)
        return 0;
      else if (i == numconds)
        return 1;
      ingroup = true;
      while (p && *p!= ']' && ((p = nextchar(p))!= NULL)) {
      }
      //			if (p && *p!= ']') p = nextchar(p);
      st--;
    }
    if (!pos) {
      i++;
      st--;
    }
    if (st < beg && p && *p!= ']')
      return 0;      // word <= condition
  } else if (pos) {  // group
    p = nextchar(p);
  } else
    return 0;
}