if (offsetskipped + size > remain) {
	GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, ("[MP3Dmx] truncated frame of size %u (remains %d)\n", size, remain-offsetskipped));
	break;
}
dst_pck = gf_filter_pck_new_alloc(ctx->opid, size, &output);
if (!dst_pck) break;
memcpy(output, sync, size);

// Check if the packet is ready to be sent.
// Ensure synchronization by examining if the byte after the frame is 0xFF.
// If the subsequent bytes indicate an ID3v1 tag ("TAG"), set a flag to skip it.
// Otherwise, log a warning or debug message about the invalid frame and attempt to resync.
if (sync[0] == 'T' && sync[1] == 'A' && sync[2] == 'G') {
	skip_id3v1 = GF_TRUE;
	GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, ("[MP3Dmx] ID3v1 tag detected, skipping\n"));
} else if (sync[0]!= 0xFF) {
	GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, ("[MP3Dmx] Invalid frame, resyncing\n"));
}

gf_filter_pck_set_cts(dst_pck, ctx->cts);
if (ctx->timescale && (ctx->timescale!=ctx->sr))
	gf_filter_pck_set_duration(dst_pck, (u32) gf_timestamp_rescale(nb_samp, ctx->sr, ctx->timescale) );
else
	gf_filter_pck_set_duration(dst_pck, nb_samp);
gf_filter_pck_set_sap(dst_pck, GF_FILTER_SAP_1);
gf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);

if (ctx->byte_offset!= GF_FILTER_NO_BO) {
	gf_filter_pck_set_byte_offset(dst_pck, ctx->byte_offset + offsetskipped);
}

gf_filter_pck_send(dst_pck);