// Get the frame size from the MP3 header
size = gf_mp3_frame_size(ctx->hdr);
if (!size) {
    // Invalid header - force resynch
    GF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, ("[MP3Dmx] Invalid MP3 frame size - skipping byte\n"));
    bytes_to_drop = 1;
    continue;
}

// Make sure we have enough data for the complete frame
if (offsetskipped + size > remain) {
    if (is_eos) {
        // At EOS with incomplete frame, just use what we have
        GF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, ("[MP3Dmx] Incomplete frame at EOS\n"));
    } else {
        // Need more data, exit and wait for next packet
        break;
    }
}

// Check for ID3v1 tag after the frame
if ((remain >= offsetskipped + size + 3) && 
    (sync[size] == 'T' && sync[size+1] == 'A' && sync[size+2] == 'G')) {
    
    // We'll need to skip the ID3v1 tag (128 bytes) after the frame
    if (remain >= offsetskipped + size + 128) {
        skip_id3v1 = GF_TRUE;
        GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, ("[MP3Dmx] Found ID3v1 tag\n"));
    }
}

// Verify next frame sync if not ID3v1 and if we have enough data
if (!skip_id3v1 && (remain >= offsetskipped + size + 1)) {
    // Check if the next potential frame starts with a sync byte (0xFF)
    if ((sync[size] & 0xFF) != 0xFF) {
        // No valid sync byte found, log warning but continue
        GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, ("[MP3Dmx] No sync byte after frame - possibly corrupted data\n"));
    }
}