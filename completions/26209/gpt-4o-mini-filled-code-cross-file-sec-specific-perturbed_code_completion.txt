static const struct {
        int class;
        int index;
        int bits[16];
        int values[16];
    } ht[] = {
        // Example Huffman table entries
        {0, 0, {0, 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}, {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}},
        {1, 1, {0, 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}, {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}},
        // Add more entries as needed
    };

    for (int i = 0; i < sizeof(ht) / sizeof(ht[0]); i++) {
        if (ht[i].class < 2) {
            // Ensure the output buffer is large enough
            if (sizeof(ht[i].bits) <= sizeof(s->bits) && sizeof(ht[i].values) <= sizeof(s->values)) {
                memcpy(s->bits, ht[i].bits, sizeof(ht[i].bits));
                memcpy(s->values, ht[i].values, sizeof(ht[i].values));
            } else {
                av_log(mjpegdecodecontext->avctx, AV_LOG_ERROR, "Huffman table size exceeds output buffer size\n");
                return AVERROR_INVALIDDATA;
            }
        }
        build_vlc(mjpegdecodecontext, ht[i].class, ht[i].index, ht[i].bits, ht[i].values);
    }