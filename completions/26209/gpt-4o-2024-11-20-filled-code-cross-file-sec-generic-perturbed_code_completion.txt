static const struct {
        uint8_t cls; // Class: 0 for DC, 1 for AC
        uint8_t idx; // Index: 0 for luminance, 1 for chrominance
        const uint8_t *bits; // Number of codes for each bit length
        const uint8_t *vals; // Huffman values
    } ht[] = {
        { 0, 0, avpriv_mjpeg_bits_dc_luminance, avpriv_mjpeg_val_dc },
        { 0, 1, avpriv_mjpeg_bits_dc_chrominance, avpriv_mjpeg_val_dc },
        { 1, 0, avpriv_mjpeg_bits_ac_luminance, avpriv_mjpeg_val_ac_luminance },
        { 1, 1, avpriv_mjpeg_bits_ac_chrominance, avpriv_mjpeg_val_ac_chrominance },
    };

    for (int i = 0; i < 4; i++) {
        VLC *vlc = &mjpegdecodecontext->vlcs[ht[i].cls][ht[i].idx];
        int ret = build_vlc(vlc, 1, 16, ht[i].bits + 1, 1, 1, ht[i].vals, 1, 1, 0);
        if (ret < 0) {
            av_log(NULL, AV_LOG_ERROR, "Failed to build VLC table for Huffman class %d index %d\n", ht[i].cls, ht[i].idx);
            return ret;
        }

        if (ht[i].cls < 2) {
            memcpy(mjpegdecodecontext->raw_huffman_lengths[ht[i].cls][ht[i].idx], ht[i].bits, 17);
            memcpy(mjpegdecodecontext->raw_huffman_values[ht[i].cls][ht[i].idx], ht[i].vals, 256);
        }
    }