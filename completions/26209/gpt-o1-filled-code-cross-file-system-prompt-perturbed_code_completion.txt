static const uint8_t bits_dc_luminance[16] = {
        0, 1, 2, 3, 4, 5, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0
    };
    static const uint8_t val_dc_luminance[12] = {
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
    };

    static const uint8_t bits_dc_chrominance[16] = {
        0, 3, 1, 1, 1, 1, 1, 1,
        0, 0, 0, 0, 0, 0, 0, 0
    };
    static const uint8_t val_dc_chrominance[12] = {
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
    };

    static const uint8_t bits_ac_luminance[16] = {
        0, 2, 1, 3, 3, 2, 4, 3,
        5, 5, 4, 4, 0, 0, 1, 0x7d
    };
    static const uint8_t val_ac_luminance[162] = {
        0x01,0x02,0x03,0x00,0x04,0x11,0x05,0x12,0x21,0x31,0x41,0x06,0x13,0x51,0x61,0x07,
        0x22,0x71,0x14,0x32,0x81,0x91,0xa1,0x08,0x23,0x42,0xb1,0xc1,0x15,0x52,0xd1,0xf0,
        0x24,0x33,0x62,0x72,0x82,0x09,0x0a,0x16,0x17,0x18,0x19,0x1a,0x25,0x26,0x27,0x28,
        0x29,0x2a,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x43,0x44,0x45,0x46,0x47,0x48,0x49,
        0x4a,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x63,0x64,0x65,0x66,0x67,0x68,0x69,
        0x6a,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x83,0x84,0x85,0x86,0x87,0x88,0x89,
        0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,
        0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xc2,0xc3,0xc4,0xc5,
        0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xe1,0xe2,
        0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,
        0xf9,0xfa
    };

    static const uint8_t bits_ac_chrominance[16] = {
        0, 2, 1, 2, 4, 4, 3, 4,
        7, 5, 4, 4, 0, 1, 2, 0x77
    };
    static const uint8_t val_ac_chrominance[162] = {
        0x00,0x01,0x02,0x03,0x11,0x04,0x05,0x21,0x31,0x06,0x12,0x41,0x51,0x07,0x61,0x71,
        0x13,0x22,0x32,0x81,0x08,0x14,0x42,0x91,0xa1,0xb1,0xc1,0x09,0x23,0x33,0x52,0xf0,
        0x15,0x62,0x72,0xd1,0x0a,0x16,0x24,0x34,0xe1,0x25,0xf1,0x17,0x18,0x19,0x1a,0x26,
        0x27,0x28,0x29,0x2a,0x35,0x36,0x37,0x38,0x39,0x3a,0x43,0x44,0x45,0x46,0x47,0x48,
        0x49,0x4a,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x63,0x64,0x65,0x66,0x67,0x68,
        0x69,0x6a,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x82,0x83,0x84,0x85,0x86,0x87,
        0x88,0x89,0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0xa2,0xa3,0xa4,0xa5,
        0xa6,0xa7,0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xc2,0xc3,
        0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,
        0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,
        0xf9,0xfa
    };

    /* We define a small table indicating which set of bits/vals to use, and whether
     * it's DC (cclass=0) or AC (cclass=1) plus the index (0=luma, 1=chroma). */
    static const struct {
        const uint8_t *bits;
        const uint8_t *vals;
        int cclass; /* 0 for DC, 1 for AC */
        int index;  /* 0 for luma, 1 for chroma */
    } ht[] = {
        { bits_dc_luminance,   val_dc_luminance,   0, 0 },
        { bits_dc_chrominance, val_dc_chrominance, 0, 1 },
        { bits_ac_luminance,   val_ac_luminance,   1, 0 },
        { bits_ac_chrominance, val_ac_chrominance, 1, 1 }
    };

    int i, j, nb_codes;
    for (i = 0; i < 4; i++) {
        nb_codes = 0;
        /* The sum of the 16 "bits" entries tells us how many values we'll read. */
        for (j = 0; j < 16; j++)
            nb_codes += ht[i].bits[j];

        /* Build VLC table for either DC or AC, luma or chroma */
        if (build_vlc(&mjpegdecodecontext->vlcs[ ht[i].cclass ][ ht[i].index ],
                      9, nb_codes,
                      ht[i].bits, 1, 1,
                      ht[i].vals, 1, 1, 4) < 0) {
            av_log(NULL, AV_LOG_ERROR, "Failed to build VLC for default Huffman table.\n");
            return AVERROR_INVALIDDATA;
        }

        /* If it's a DC or AC table (class < 2), store the bits/vals in raw form, too. */
        if (ht[i].cclass < 2) {
            memcpy(mjpegdecodecontext->raw_huff_bits[ ht[i].index ], ht[i].bits, 16);
            memcpy(mjpegdecodecontext->raw_huff_values[ ht[i].index ], ht[i].vals, nb_codes);
        }
    }