{
    // Define a small table of default Huffman data for DC and AC, luma and chroma.
    // Each entry has a "class" (0 for DC, 1 for AC), an index (0 for luma, 1 for chroma),
    // 16 "bits" specifying the number of codes of each length from 1..16, and the
    // "values" providing the symbol assignments in canonical order.
    static const struct {
        int table_class;
        int table_index;
        const uint8_t bits[16];
        const uint8_t values[12];
    } ht[] = {
        // Default DC Luma
        {
            0, 0,
            { 0x00, 0x02, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01,
              0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00 },
            { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
              0x08, 0x09, 0x0A, 0x0B }
        },
        // Default DC Chroma
        {
            0, 1,
            { 0x00, 0x02, 0x02, 0x02, 0x03, 0x01, 0x01, 0x01,
              0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00 },
            { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
              0x08, 0x09, 0x0A, 0x0B }
        },
        // Default AC Luma
        {
            1, 0,
            { 0x00, 0x02, 0x01, 0x03, 0x03, 0x02, 0x04, 0x03,
              0x05, 0x05, 0x04, 0x04, 0x00, 0x00, 0x01, 0x7D },
            { 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12,
              0x21, 0x31, 0x41, 0x06 }
        },
        // Default AC Chroma
        {
            1, 1,
            { 0x00, 0x02, 0x02, 0x02, 0x03, 0x02, 0x04, 0x03,
              0x05, 0x05, 0x04, 0x04, 0x00, 0x01, 0x02, 0x77 },
            { 0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21,
              0x31, 0x06, 0x12, 0x41 }
        }
    };

    int i, j, ret;
    for (i = 0; i < 4; i++) {
        int nb_codes = 0;
        // Sum up the codes from the 'bits' array to ensure we stay within bounds.
        for (j = 0; j < 16; j++)
            nb_codes += ht[i].bits[j];

        // If computed nb_codes exceeds 256, skip to avoid buffer overflow.
        if (nb_codes > 256) {
            av_log(mjpegdecodecontext->avctx, AV_LOG_ERROR,
                   "Too many Huffman codes in default table\n");
            return AVERROR_INVALIDDATA;
        }

        // Class < 2 indicates DC or AC table, so we fill the raw arrays.
        if (ht[i].table_class < 2) {
            memcpy(mjpegdecodecontext->raw_huff_bits[ht[i].table_class][ht[i].table_index],
                   ht[i].bits, sizeof(ht[i].bits));
            memcpy(mjpegdecodecontext->raw_huff_values[ht[i].table_class][ht[i].table_index],
                   ht[i].values, nb_codes);
        }

        // Build VLC with the data. If this fails, return the error.
        ret = build_vlc(&mjpegdecodecontext->vlcs[ht[i].table_class][ht[i].table_index],
                        9, nb_codes,
                        mjpegdecodecontext->raw_huff_bits[ht[i].table_class][ht[i].table_index],
                        1, 1,
                        mjpegdecodecontext->raw_huff_values[ht[i].table_class][ht[i].table_index],
                        1, 1, 4);
        if (ret < 0)
            return ret;
    }
}