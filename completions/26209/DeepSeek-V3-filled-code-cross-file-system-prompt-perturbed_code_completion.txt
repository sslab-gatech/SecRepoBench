static const struct {
        uint8_t class;
        uint8_t index;
        uint8_t bits[16];
        uint8_t values[12];
    } ht[] = {
        { 0, 0, { 0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0 }, { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B } },
        { 0, 1, { 0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0 }, { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B } },
        { 1, 0, { 0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1 }, { 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21, 0x31, 0x41, 0x06 } },
        { 1, 1, { 0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2 }, { 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21, 0x31, 0x41, 0x13 } },
    };

    for (int i = 0; i < FF_ARRAY_ELEMS(ht); i++) {
        if (build_vlc(&mjpegdecodecontext->vlcs[ht[i].class][ht[i].index],
                      ht[i].bits, ht[i].values, 0, 0) < 0) {
            return AVERROR_INVALIDDATA;
        }

        if (ht[i].class < 2) {
            memcpy(mjpegdecodecontext->raw_huffman_lengths[ht[i].class][ht[i].index],
                   ht[i].bits, 16);
            memcpy(mjpegdecodecontext->raw_huffman_values[ht[i].class][ht[i].index],
                   ht[i].values, 12);
        }
    }