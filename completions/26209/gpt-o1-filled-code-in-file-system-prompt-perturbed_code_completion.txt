static const struct {
        int cla;
        int idx;
        const uint8_t *bits;
        const uint8_t *vals;
        int nb_codes;
        int is_ac;
    } ht[] = {
        { 0, 0, avpriv_mjpeg_bits_dc_luminance,   avpriv_mjpeg_val_dc,             12, 0 },
        { 0, 1, avpriv_mjpeg_bits_dc_chrominance, avpriv_mjpeg_val_dc,             12, 0 },
        { 1, 0, avpriv_mjpeg_bits_ac_luminance,   avpriv_mjpeg_val_ac_luminance,  162, 1 },
        { 1, 1, avpriv_mjpeg_bits_ac_chrominance, avpriv_mjpeg_val_ac_chrominance,162, 1 },
    };
    int i, ret;

    for (i = 0; i < 4; i++) {
        int cla = ht[i].cla;
        int idx = ht[i].idx;

        /* free any previously-initialized VLC */
        ff_free_vlc(&mjpegdecodecontext->vlcs[cla][idx]);

        /* build current VLC table */
        ret = build_vlc(&mjpegdecodecontext->vlcs[cla][idx],
                        ht[i].bits,
                        ht[i].vals,
                        ht[i].nb_codes,
                        1,
                        ht[i].is_ac);
        if (ret < 0)
            return ret;

        /* build "refinement" AC VLC as well if this is AC */
        if (cla > 0) {
            ff_free_vlc(&mjpegdecodecontext->vlcs[2][idx]);
            ret = build_vlc(&mjpegdecodecontext->vlcs[2][idx],
                            ht[i].bits,
                            ht[i].vals,
                            ht[i].nb_codes,
                            1,
                            0);
            if (ret < 0)
                return ret;
        }

        /* store huffman data in raw tables for possible external references */
        if (cla < 2) {
            int j, n = 0;
            for (j = 1; j <= 16; j++)
                n += ht[i].bits[j];
            memcpy(mjpegdecodecontext->raw_huffman_lengths[cla][idx], &ht[i].bits[1], 16);
            memcpy(mjpegdecodecontext->raw_huffman_values[cla][idx], ht[i].vals, n);
        }
    }