static const struct {
        int cls;
        int idx;
        uint8_t bits[16];
        uint8_t vals[256];
        int nb_vals;
    } ht[] = {
        /* Default DC Luminance */
        {
            0, 0,
            { 0x00, 0x01, 0x05, 0x01, 0x01, 0x01, 0x01, 0x01,
              0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
            { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
              0x08, 0x09, 0x0A, 0x0B },
            12
        },
        /* Default DC Chrominance */
        {
            0, 1,
            { 0x00, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
              0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
            { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
              0x08, 0x09, 0x0A, 0x0B },
            12
        },
        /* Default AC Luminance */
        {
            1, 0,
            { 0x00, 0x02, 0x01, 0x03, 0x03, 0x02, 0x04, 0x03,
              0x05, 0x05, 0x04, 0x04, 0x00, 0x00, 0x01, 0x7D },
            {
              0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12,
              0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07,
              /* ... full set of AC symbols omitted for brevity ... */
            },
            162 /* for example, actual number of AC symbols */
        },
        /* Default AC Chrominance */
        {
            1, 1,
            { 0x00, 0x02, 0x01, 0x02, 0x04, 0x04, 0x03, 0x04,
              0x07, 0x05, 0x04, 0x04, 0x00, 0x01, 0x02, 0x77 },
            {
              0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21,
              0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71,
              /* ... full set of AC symbols omitted for brevity ... */
            },
            162 /* for example, actual number of AC symbols */
        }
    };

    for (int i = 0; i < FF_ARRAY_ELEMS(ht); i++) {
        int c   = ht[i].cls;
        int idx = ht[i].idx;
        /* Build VLC table for this Huffman set */
        if (build_vlc(&mjpegdecodecontext->vlcs[c][idx],
                      ht[i].bits, ht[i].vals,
                      16, ht[i].nb_vals) < 0) {
            return AVERROR_INVALIDDATA;
        }

        /* If it's a DC table, store raw lengths and codes for later use */
        if (c < 2) {
            memcpy(mjpegdecodecontext->raw_huff_bits[c][idx], ht[i].bits, 16);
            memcpy(mjpegdecodecontext->raw_huff_val[c][idx],  ht[i].vals, ht[i].nb_vals);
        }
    }