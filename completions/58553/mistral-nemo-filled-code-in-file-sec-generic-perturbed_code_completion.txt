// build a hash table from a munched word list

HashMgr::HashMgr(const char* tpath, const char* apath, const char* key)
    : flag_mode(FLAG_CHAR),
      complexprefixes(0),
      utf8(0),
      forbiddenword(FORBIDDENWORD), // forbidden word signing flag
      langnum(0),
      csconv(NULL)
{
  load_config(apath, key);
  if (!csconv)
    csconv = get_current_cs(SPELL_ENCODING);
  int ec = load_tables(tpath, key);
  if (ec) {
    /* error condition - what should we do here */
    HUNSPELL_WARNING(stderr, "Hash Manager Error : %d\n", ec);
    free_table();
    //keep table size to 1 to fix possible division with zero
    tableptr.resize(1, nullptr);
  }
}

// the hash function is a simple load and rotate
// algorithm borrowed
int HashMgr::hash(const char* word, size_t len) const {
  unsigned long hv = 0;
  size_t i = 0;
  while (i < 4 && i < len)
    hv = (hv << 8) | word[i++];
  while (i < len) {
    ROTATE(hv, ROTATE_LEN);
    hv ^= word[i++];
  }
  return (unsigned long)hv % tableptr.size();
}