// Skip leading whitespace after comma
        while (index < flags.size() && isspace(flags[index])) {
            ++index;
        }
        src = &flags[index];
        
        // Find the next comma or end of string to determine the number range
        const char* next_comma = strchr(src, ',');
        size_t num_length = (next_comma) ? (next_comma - src) : strlen(src);
        
        // Extract the number substring
        char number_str[20] = {0}; // Buffer large enough for any decimal unsigned short value plus null terminator
        strncpy(number_str, src, std::min(num_length, sizeof(number_str) - 1));
        
        // Convert the string to an integer
        int i = atoi(number_str);
        
        // Validate and store the flag
        if (i >= DEFAULTFLAGS || i < 0) {
            HUNSPELL_WARNING(stderr,
                             "error: line %d: flag id %d is too large (max: %d)\n",
                             af->getlinenum(), i, DEFAULTFLAGS - 1);
            i = 0; // Set invalid flags to zero as per logic
        }

        *dest = (unsigned short)i;
        if (*dest == 0)
            HUNSPELL_WARNING(stderr, "error: line %d: 0 is wrong flag id\n",
                             af->getlinenum());

        // Move to the next destination element
        ++dest;

        // If we encountered a comma, move past it for the next iteration
        if (next_comma) {
            index += (next_comma - src) + 1; // Include the comma itself in the jump
        } else {
            break; // No more commas, exit loop
        }