if (index > 0) {
  src = &flags[index + 1]; // Move the source pointer to the position after the current comma
} else {
  src = &flags[0]; // Start from the beginning if it's the first number
}
while (*src && *src == ' ') ++src; // Skip any leading spaces
char* endptr;
unsigned short num = (unsigned short)strtol(src, &endptr, 10); // Parse the number
if (num >= DEFAULTFLAGS || num < 0) {
  HUNSPELL_WARNING(stderr,
                   "error: line %d: flag id %d is too large (max: %d)\n",
                   af->getlinenum(), num, DEFAULTFLAGS - 1);
  num = 0;
}
if (num == 0)
  HUNSPELL_WARNING(stderr, "error: line %d: 0 is wrong flag id\n",
                   af->getlinenum());
*dest++ = num; // Store the parsed number in the result array
src = endptr; // Update the source pointer for the next iteration