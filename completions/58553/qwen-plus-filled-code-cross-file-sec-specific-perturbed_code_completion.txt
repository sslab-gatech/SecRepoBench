// Skip any leading whitespace
      while (index < flags.size() && isspace(flags[index])) {
        ++index;
      }
      if (index >= flags.size()) {
        break; // No more flags to process
      }

      // Parse the number until a comma or end of string is encountered
      int num_start = index;
      while (index < flags.size() && flags[index] != ',') {
        ++index;
      }

      // Extract the substring for conversion
      std::string num_str = flags.substr(num_start, index - num_start);
      int i = atoi(num_str.c_str());

      // Validate and store the flag
      if (i >= DEFAULTFLAGS || i < 0) {
        HUNSPELL_WARNING(stderr,
                         "error: line %d: flag id %d is too large (max: %d)\n",
                         af->getlinenum(), i, DEFAULTFLAGS - 1);
        i = 0;
      }

      *dest = (unsigned short)i;
      if (*dest == 0)
        HUNSPELL_WARNING(stderr, "error: line %d: 0 is wrong flag id\n",
                         af->getlinenum());
      ++dest;

      // Move past the comma
      if (index < flags.size() && flags[index] == ',') {
        ++index;
      }