// <MASK>
// Ensure the parsed box `a` is not NULL, and if it is, return success indicating no further processing is needed.
if (!a) {
    return GF_OK;
}

// Check if the size of the parent box is smaller than the size of the newly parsed box `a`. If it is, log a warning if logging is enabled.
if (container->size < a->size) {
    if (!skip_logs) {
        GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, ("[ISOM] Box of type '%s' has a size (%d) larger than its parent box (%d)\n", gf_4cc_to_str(a->type), (u32)a->size, (u32)container->size));
    }
}

// Adjust the parent box size by subtracting the size of the parsed box `a`, or reset it if the size was exceeded.
container->size -= a->size;
if (container->size < 0) {
    container->size = 0;
}

// Validate if the container box type is compatible with the parsed box `a`. This involves checking if the parent box type is a valid type for the current box using predefined rules in the registry.
if (!gf_isom_box_valid_in_parent(a, container)) {
    if (!skip_logs) {
        GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, ("[ISOM] Box of type '%s' is not valid in parent box of type '%s'\n", gf_4cc_to_str(a->type), gf_4cc_to_str(container->type)));
    }
}

// Log a warning if the parsed box is invalid in its current container, but only if logging is not skipped.
if (a->type == GF_ISOM_BOX_TYPE_UNKNOWN) {
    if (!skip_logs) {
        GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, ("[ISOM] Unknown box of type '%s' found in parent box of type '%s'\n", gf_4cc_to_str(a->type), gf_4cc_to_str(container->type)));
    }
}