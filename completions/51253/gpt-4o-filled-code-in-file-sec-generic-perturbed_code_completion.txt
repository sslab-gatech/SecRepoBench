for (i = 1; i <= rounds; i++) {
        // Rotate and apply S-box to the first word
        t = tk[KC - 1][0];
        tk[KC - 1][0] = sbox[tk[0][1]] ^ rcon[rconpointer++];
        tk[0][1] = sbox[tk[1][2]];
        tk[1][2] = sbox[tk[2][3]];
        tk[2][3] = sbox[t];

        // XOR with the previous round key
        for (t = 0; t < KC; t++) {
            tk[t][0] ^= tk[t ? t - 1 : KC - 1][0];
            tk[t][1] ^= tk[t ? t - 1 : KC - 1][1];
            tk[t][2] ^= tk[t ? t - 1 : KC - 1][2];
            tk[t][3] ^= tk[t ? t - 1 : KC - 1][3];
        }

        // Copy the round key
        memcpy(a->round_key[i].u8, tk, KC * 4);

        // If decrypting, apply inverse mix columns to all but the first and last round keys
        if (decrypt && i < rounds) {
            av_aes_block temp;
            subshift(&temp, 0, inv_sbox);
            mix(&temp, dec_multbl, 3, 1);
            memcpy(a->round_key[i].u8, temp.u8, 16);
        }
    }

    // If decrypting, reverse the order of the round keys
    if (decrypt) {
        for (i = 0; i < rounds / 2; i++) {
            av_aes_block temp = a->round_key[i];
            a->round_key[i] = a->round_key[rounds - i];
            a->round_key[rounds - i] = temp;
        }
    }