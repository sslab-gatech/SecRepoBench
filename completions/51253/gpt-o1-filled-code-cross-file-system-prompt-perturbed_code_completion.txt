static const uint8_t rcon[30] = {
        0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,
        0x1B,0x36,0x6C,0xD8,0xAB,0x4D,0x9A,
        0x2F,0x5E,0xBC,0x63,0xC6,0x97,0x35,0x6A,
        0xD4,0xB3,0x7D,0xFA,0xEF,0xC5
    };
    rconpointer = 0;

    /* Expand the key into round keys */
    for (i = KC; i < 4 * (rounds + 1); i++) {
        uint8_t temp[4];
        memcpy(temp, &a->round_key[(i - 1) / 4].u8[4 * ((i - 1) % 4)], 4);

        if (!(i % KC)) {
            uint8_t tmp = temp[0];
            temp[0] = sbox[temp[1]] ^ rcon[rconpointer++];
            temp[1] = sbox[temp[2]];
            temp[2] = sbox[temp[3]];
            temp[3] = sbox[tmp];
        } else if (KC > 6 && (i % KC) == 4) {
            temp[0] = sbox[temp[0]];
            temp[1] = sbox[temp[1]];
            temp[2] = sbox[temp[2]];
            temp[3] = sbox[temp[3]];
        }

        a->round_key[i / 4].u8[4 * (i % 4) + 0] =
            a->round_key[(i - KC) / 4].u8[4 * ((i - KC) % 4) + 0] ^ temp[0];
        a->round_key[i / 4].u8[4 * (i % 4) + 1] =
            a->round_key[(i - KC) / 4].u8[4 * ((i - KC) % 4) + 1] ^ temp[1];
        a->round_key[i / 4].u8[4 * (i % 4) + 2] =
            a->round_key[(i - KC) / 4].u8[4 * ((i - KC) % 4) + 2] ^ temp[2];
        a->round_key[i / 4].u8[4 * (i % 4) + 3] =
            a->round_key[(i - KC) / 4].u8[4 * ((i - KC) % 4) + 3] ^ temp[3];
    }

    /* For decryption, apply the inverse mix step (except first and last round)
       and reverse the order of round keys. */
    if (decrypt) {
        for (i = 1; i < rounds; i++) {
            int j;
            for (j = 0; j < 16; j += 4) {
                uint32_t v = AV_RB32(&a->round_key[i].u8[j]);
                v = inv_mix_column(v);
                AV_WB32(&a->round_key[i].u8[j], v);
            }
        }
        for (i = 1; i <= rounds / 2; i++) {
            AESBlock tmp = a->round_key[i];
            a->round_key[i] = a->round_key[rounds - i];
            a->round_key[rounds - i] = tmp;
        }
    } else {
        /* For encryption, if required, additional steps such as reversing
           round key order can be done here. In this implementation, the
           round keys are already in forward order for encryption. */
    }