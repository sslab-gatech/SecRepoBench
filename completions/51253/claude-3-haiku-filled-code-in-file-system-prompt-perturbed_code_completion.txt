for (i = KC; i < (rounds + 1) * 4; i++) {
    t = tk[i - 1][0];
    if (i % KC == 0) {
        t = sbox[t >> 16] ^ (sbox[(t >> 8) & 0xff] << 8) ^
            (sbox[t & 0xff] << 16) ^ (sbox[(t >> 24)] << 24) ^ rcon[rconpointer++];
    } else if (KC > 6 && i % KC == 4) {
        t = sbox[t >> 24] << 24 | sbox[(t >> 16) & 0xff] << 16 |
            sbox[(t >> 8) & 0xff] << 8 | sbox[t & 0xff];
    }
    tk[i][0] = tk[i - KC][0] ^ t;
    tk[i][1] = tk[i - KC][1] ^ tk[i][0];
    tk[i][2] = tk[i - KC][2] ^ tk[i][1];
    tk[i][3] = tk[i - KC][3] ^ tk[i][2];
    if (decrypt) {
        a->round_key[rounds - i / 4].u8[4 * (i % 4) + 0] = tk[i][0];
        a->round_key[rounds - i / 4].u8[4 * (i % 4) + 1] = tk[i][1];
        a->round_key[rounds - i / 4].u8[4 * (i % 4) + 2] = tk[i][2];
        a->round_key[rounds - i / 4].u8[4 * (i % 4) + 3] = tk[i][3];
    } else {
        a->round_key[i / 4].u8[4 * (i % 4) + 0] = tk[i][0];
        a->round_key[i / 4].u8[4 * (i % 4) + 1] = tk[i][1];
        a->round_key[i / 4].u8[4 * (i % 4) + 2] = tk[i][2];
        a->round_key[i / 4].u8[4 * (i % 4) + 3] = tk[i][3];
    }
}