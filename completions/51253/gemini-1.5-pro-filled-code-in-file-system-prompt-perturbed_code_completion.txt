for (r = 1; r <= rounds; r++) {
        for (i = 0; i < 4; i++)
            tk[0][i] ^= sbox[tk[KC * (r % 2)][(i - 1 + 4) % 4]];
        tk[0][0] ^= rcon[rconpointer++];

        for (i = 1; i < KC; i++)
            for (t = 0; t < 4; t++)
                tk[i][t] ^= tk[i - 1][t];

        if (KC > 6 && r < rounds) {
            if (KC == 8) {
                for (i = KC; i < KC * 2; i++)
                    for (t = 0; t < 4; t++)
                        tk[i][t] ^= sbox[tk[i - KC][t]];
            } else {
                for (i = KC; i < KC * 2; i++)
                    for (t = 0; t < 4; t++)
                        tk[i][t] ^= tk[i - KC][t];
            }
        }

        for (i = 0; i < KC * 4; i++)
            a->round_key[r].u8[i] = tk[i / 4][i % 4];
    }

    if (decrypt) {
        av_aes_block tmp;
        for (r = 1; r < rounds; r++) {
            subshift(&tmp, 0, inv_sbox);
            mix(&tmp, dec_multbl, 1, 3);
            tmp.u64[0] ^= a->round_key[r].u64[0];
            tmp.u64[1] ^= a->round_key[r].u64[1];
            a->round_key[r] = tmp;
        }
    } else {
        for (i = 1; i < rounds / 2; i++) {
            FFSWAP(av_aes_block, a->round_key[i], a->round_key[rounds - i]);
        }
    }