for (i = 0; i < rounds; i++) {
        for (t = 0; t < KC; t++) {
            if (t == 0) {
                uint8_t temp[4];
                // Rotate and substitute
                temp[0] = sbox[tk[KC - 1][1]];
                temp[1] = sbox[tk[KC - 1][2]];
                temp[2] = sbox[tk[KC - 1][3]];
                temp[3] = sbox[tk[KC - 1][0]];
                // XOR with Rcon
                temp[0] ^= rcon[rconpointer++];
                // XOR with the first word of the previous round key
                for (sidx = 0; sidx < 4; sidx++) {
                    tk[0][sidx] ^= temp[sidx];
                }
            } else if (KC > 6 && t == 4) {
                // Special case for 256-bit keys
                for (sidx = 0; sidx < 4; sidx++) {
                    tk[t][sidx] ^= sbox[tk[t - 1][sidx]];
                }
            } else {
                // Regular key schedule
                for (sidx = 0; sidx < 4; sidx++) {
                    tk[t][sidx] ^= tk[t - 1][sidx];
                }
            }
            // Copy the generated word to the round key
            memcpy(a->round_key[i + 1].u8 + t * 4, tk[t], 4);
        }
    }

    if (decrypt) {
        // Reverse the round keys for decryption
        for (i = 1; i < rounds; i++) {
            aes_crypt(a, i, inv_sbox, dec_multbl);
        }
    }