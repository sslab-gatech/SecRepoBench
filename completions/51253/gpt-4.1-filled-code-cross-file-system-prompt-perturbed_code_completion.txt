for (i = KC; i < 4 * (rounds + 1); i++) {
        t = ((uint32_t *)a->round_key[0].u8)[i - 1];
        if (i % KC == 0) {
            t = (t << 8) | (t >> 24);
            t = (sbox[(t >> 24)       ] << 24) |
                (sbox[(t >> 16) & 0xff] << 16) |
                (sbox[(t >>  8) & 0xff] <<  8) |
                (sbox[(t      ) & 0xff]);
            t ^= rcon[rconpointer++] << 24;
        } else if (KC > 6 && i % KC == 4) {
            t = (sbox[(t >> 24)       ] << 24) |
                (sbox[(t >> 16) & 0xff] << 16) |
                (sbox[(t >>  8) & 0xff] <<  8) |
                (sbox[(t      ) & 0xff]);
        }
        ((uint32_t *)a->round_key[0].u8)[i] =
            ((uint32_t *)a->round_key[0].u8)[i - KC] ^ t;
    }

    if (decrypt) {
        for (i = 1; i < rounds; i++) {
            int j;
            uint8_t *rk = a->round_key[i].u8;
            for (j = 0; j < 16; j++)
                rk[j] = inv_sbox[rk[j]];
        }
    }