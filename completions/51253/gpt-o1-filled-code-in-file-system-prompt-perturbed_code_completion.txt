{
    int i, j;
    for (i = 1; i <= rounds; i++) {
        uint8_t temp0 = tk[KC - 1][0];
        uint8_t temp1 = tk[KC - 1][1];
        uint8_t temp2 = tk[KC - 1][2];
        uint8_t temp3 = tk[KC - 1][3];

        if (!(i % KC)) {
            uint8_t t = temp0;
            temp0 = temp1; temp1 = temp2; temp2 = temp3; temp3 = t;
            temp0 = sbox[temp0];
            temp1 = sbox[temp1];
            temp2 = sbox[temp2];
            temp3 = sbox[temp3];
            temp0 ^= rcon[rconpointer++];
        } else if (KC == 8 && ((i % 8) == 4)) {
            temp0 = sbox[temp0];
            temp1 = sbox[temp1];
            temp2 = sbox[temp2];
            temp3 = sbox[temp3];
        }

        tk[0][0] ^= temp0; tk[0][1] ^= temp1; tk[0][2] ^= temp2; tk[0][3] ^= temp3;
        for (j = 1; j < KC; j++) {
            tk[j][0] ^= tk[j - 1][0];
            tk[j][1] ^= tk[j - 1][1];
            tk[j][2] ^= tk[j - 1][2];
            tk[j][3] ^= tk[j - 1][3];
        }
        memcpy(a->round_key[i].u8, tk, 16);
    }

    if (decrypt) {
        av_aes_block tmp[2];
        for (i = 1; i < rounds; i++) {
            tmp[1] = a->round_key[i];
            subshift(tmp, 0, inv_sbox);
            mix(tmp, dec_multbl, 3, 1);
            a->round_key[i] = tmp[0];
        }
    }

    for (i = 0; i < (rounds + 1) / 2; i++) {
        av_aes_block tmp = a->round_key[i];
        a->round_key[i] = a->round_key[rounds - i];
        a->round_key[rounds - i] = tmp;
    }
}