for (r = 1; r <= rounds; r++) {
        tk[0][0] ^= sbox[tk[KC - 1][1]];
        tk[0][1] ^= sbox[tk[KC - 1][2]];
        tk[0][2] ^= sbox[tk[KC - 1][3]];
        tk[0][3] ^= sbox[tk[KC - 1][0]];
        tk[0][0] ^= rcon[rconpointer++];

        for (i = 1; i < 4; i++)
            tk[i][0] ^= tk[i - 1][0],
            tk[i][1] ^= tk[i - 1][1],
            tk[i][2] ^= tk[i - 1][2],
            tk[i][3] ^= tk[i - 1][3];

        if (KC > 6 && i == 4) {
            tk[4][0] ^= sbox[tk[3][0]];
            tk[4][1] ^= sbox[tk[3][1]];
            tk[4][2] ^= sbox[tk[3][2]];
            tk[4][3] ^= sbox[tk[3][3]];
            i++;
        }
        if (KC > 8 && i == KC) {
            tk[i][0] ^= sbox[tk[i-1][0]];
            tk[i][1] ^= sbox[tk[i-1][1]];
            tk[i][2] ^= sbox[tk[i-1][2]];
            tk[i][3] ^= sbox[tk[i-1][3]];
        }

        memcpy(a->round_key[r].u8, tk, KC * 4);
    }

    if (decrypt) {
        av_aes_block tmp;
        for (r = 1; r < rounds; r++) {
            subshift(&tmp, 0, inv_sbox);
            tmp.u32[0] = a->round_key[r].u32[0];
            tmp.u32[1] = a->round_key[r].u32[1];
            tmp.u32[2] = a->round_key[r].u32[2];
            tmp.u32[3] = a->round_key[r].u32[3];
            mix(&a->round_key[r], dec_multbl, 1, 3);
        }
    } else {
        for (i = 1; i <= rounds / 2; i++) {
            FFSWAP(av_aes_block, a->round_key[i], a->round_key[rounds - i + 1]);
        }
    }