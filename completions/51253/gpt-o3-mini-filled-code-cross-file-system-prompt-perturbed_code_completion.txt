{
    int j;
    uint32_t temp;
    for (i = KC; i < 4 * (rounds + 1); i++) {
        temp = ((uint32_t *)tk)[i - 1];
        if ((i % KC) == 0) {
            temp = ((uint32_t)sbox[(temp >> 16) & 0xff] << 24) |
                   ((uint32_t)sbox[(temp >> 8) & 0xff] << 16) |
                   ((uint32_t)sbox[temp & 0xff] << 8) |
                   ((uint32_t)sbox[temp >> 24]);
            temp ^= rcon[rconpointer++];
        } else if (KC > 6 && ((i % KC) == 4)) {
            temp = ((uint32_t)sbox[(temp >> 24)] << 24) |
                   ((uint32_t)sbox[(temp >> 16) & 0xff] << 16) |
                   ((uint32_t)sbox[(temp >> 8) & 0xff] << 8) |
                   ((uint32_t)sbox[temp & 0xff]);
        }
        ((uint32_t *)tk)[i] = ((uint32_t *)tk)[i - KC] ^ temp;
        ((uint32_t *)a->round_key[i/4].u8)[i % 4] = ((uint32_t *)tk)[i];
    }
    if (decrypt) {
        for (i = 1; i < rounds; i++) {
            uint32_t *rk = a->round_key[i].u32;
            rk[0] = inv_mcol(rk[0]);
            rk[1] = inv_mcol(rk[1]);
            rk[2] = inv_mcol(rk[2]);
            rk[3] = inv_mcol(rk[3]);
        }
    } else {
        for (i = 1; i < rounds/2 + 1; i++) {
            for (j = 0; j < 4; j++) {
                uint32_t tmp = a->round_key[i].u32[j];
                a->round_key[i].u32[j] = a->round_key[rounds - i].u32[j];
                a->round_key[rounds - i].u32[j] = tmp;
            }
        }
    }
}