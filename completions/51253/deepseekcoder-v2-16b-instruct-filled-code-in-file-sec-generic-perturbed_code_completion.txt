for (i = 1; i < rounds; i++) {
        for (t = 0; t < 4; t++) {
            uint8_t temp[4];
            for (int j = 0; j < 4; j++) {
                temp[j] = tk[(i - 1) * 4 + (t + j) % 4];
            }
            uint8_t k = temp[0];
            for (int j = 0; j < 4; j++) {
                temp[j] = sbox[(temp[j] ^ (j == 0 ? rcon[rconpointer] : 0))];
            }
            for (int j = 0; j < 4; j++) {
                tk[i * 4 + t] = temp[j] ^ k;
            }
        }
        rconpointer = (rconpointer + 1) % 10;
    }

    for (i = 0; i < rounds; i++) {
        memcpy(a->round_key[i].u8, tk[i * 4], 4);
        for (int j = 1; j < 4; j++) {
            a->round_key[i].u8[j * 4 + 0] = tk[i * 4 + j];
            a->round_key[i].u8[j * 4 + 1] = tk[i * 4 + j] ^ tk[(i + 1) * 4 - 1];
            a->round_key[i].u8[j * 4 + 2] = tk[i * 4 + j] ^ tk[(i + 2) * 4 - 1];
            a->round_key[i].u8[j * 4 + 3] = tk[i * 4 + j] ^ tk[(i + 3) * 4 - 1];
        }
    }

    if (decrypt) {
        for (i = 0; i < rounds; i++) {
            for (int j = 0; j < 4; j++) {
                uint8_t temp[4];
                for (int k = 0; k < 4; k++) {
                    temp[k] = a->round_key[i].u8[k * 4 + j];
                }
                for (int k = 0; k < 4; k++) {
                    a->round_key[i].u8[k * 4 + j] = inv_sbox[temp[k]];
                }
            }
        }
    }