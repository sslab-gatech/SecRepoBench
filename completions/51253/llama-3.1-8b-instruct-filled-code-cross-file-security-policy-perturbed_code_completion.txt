// Generate round keys for AES encryption or decryption.
// Iterates over the key schedule and computes each round key
// using the provided S-box and Rcon tables. The initial key is
// expanded into a series of round keys using an XOR-based process
// with a cyclic shift and substitution for the first word of each
// key. If decryption is requested, the round keys are modified
// using inverse subshift and mix transformations. Finally, if
// encryption is intended, the round keys are reversed for use
// in the forward order during encryption.
for (i = 1; i < rounds; i++) {
    if (decrypt) {
        // Inverse subshift and mix transformations for decryption
        for (t = 0; t < 4; t++) {
            tk[i][t] = tk[i - 1][(t + 1) & 3] ^ rcon[rconpointer];
            rconpointer = (rconpointer + 1) % FF_ARRAY_ELEMS(rcon);
        }
    } else {
        // Cyclic shift and substitution for encryption
        for (t = 0; t < 4; t++) {
            tk[i][t] = tk[i - 1][t] ^ rcon[rconpointer];
            rconpointer = (rconpointer + 1) % FF_ARRAY_ELEMS(rcon);
        }
    }
    // Mix the round key
    for (t = 0; t < 4; t++) {
        tk[i][t] = tk[i][t] ^ tk[i][(t + 1) & 3] ^ tk[i][(t + 2) & 3] ^ tk[i][(t + 3) & 3];
    }
}

// Store the round keys in the AVAES structure
memcpy(&a->round_key[i], tk[i], 4);