for (i = KC; i < 4 * (rounds + 1); i++) {
        uint8_t *rki = a->round_key[i >> 2].u8 + 4 * (i & 3);
        memcpy(rki, tk[i - 1], 4);
        if (!(i % KC)) {
            t = rki[0];
            rki[0] = sbox[rki[1]] ^ rcon[rconpointer++];
            rki[1] = sbox[rki[2]];
            rki[2] = sbox[rki[3]];
            rki[3] = sbox[t];
        } else if (KC > 6 && i % KC == 4) {
            rki[0] = sbox[rki[0]];
            rki[1] = sbox[rki[1]];
            rki[2] = sbox[rki[2]];
            rki[3] = sbox[rki[3]];
        }
        rki[0] ^= tk[i - KC][0];
        rki[1] ^= tk[i - KC][1];
        rki[2] ^= tk[i - KC][2];
        rki[3] ^= tk[i - KC][3];
        memcpy(tk[i], rki, 4);
    }

    if (decrypt) {
        for (i = 1; i < rounds; i++) {
            aes_crypt(a, i, inv_sbox, dec_multbl);
        }
    }