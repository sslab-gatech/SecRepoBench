// Generate round keys for AES encryption or decryption.
// Iterates over the key schedule and computes each round key
// using the provided S-box and Rcon tables. The initial key is
// expanded into a series of round keys using an XOR-based process
// with a cyclic shift and substitution for the first word of each
// key. If decryption is requested, the round keys are modified
// using inverse subshift and mix transformations. Finally, if
// encryption is intended, the round keys are reversed for use
// in the forward order during encryption.
for (t = 1; t < rounds; t++) {
    if (decrypt) {
        // Inverse shift rows
        for (i = 0; i < 4; i++) {
            uint8_t tmp = a->round_key[t - 1].u8[i];
            a->round_key[t].u8[i] = a->round_key[t - 1].u8[(i + 1) % 4];
            a->round_key[t - 1].u8[(i + 1) % 4] = tmp;
        }
        // Inverse mix columns
        for (i = 0; i < 4; i++) {
            uint8_t tmp = a->round_key[t - 1].u8[i];
            a->round_key[t].u8[i] = dec_multbl[0][tmp] ^ dec_multbl[1][a->round_key[t - 1].u8[(i + 1) % 4]] ^
                                     dec_multbl[2][a->round_key[t - 1].u8[(i + 2) % 4]] ^ dec_multbl[3][a->round_key[t - 1].u8[(i + 3) % 4]];
        }
    } else {
        // Shift rows
        for (i = 0; i < 4; i++) {
            uint8_t tmp = a->round_key[t - 1].u8[i];
            a->round_key[t].u8[i] = a->round_key[t - 1].u8[(i + 1) % 4];
            a->round_key[t - 1].u8[(i + 1) % 4] = tmp;
        }
        // Mix columns
        for (i = 0; i < 4; i++) {
            uint8_t tmp = a->round_key[t - 1].u8[i];
            a->round_key[t].u8[i] = sbox[tmp] ^ sbox[a->round_key[t - 1].u8[(i + 1) % 4]] ^ sbox[a->round_key[t - 1].u8[(i + 2) % 4]] ^ sbox[a->round_key[t - 1].u8[(i + 3) % 4]];
        }
    }
    // XOR with Rcon
    a->round_key[t].u8[0] ^= rcon[t - 1];
}