for (i = 0; i < (rounds + 1) * 4; i++) {
    if (i / 4 == 0 && i % 4 == 0) {
        for (t = 0; t < 4; t++)
            tk[0][t] ^= sbox[tk[KC - 1][(t + 1) & 3]];
        tk[0][0] ^= rcon[rconpointer++];
    } else if (KC > 6 && i / 4 == 0 && i % 4 == 4) {
        for (t = 0; t < 4; t++)
            tk[0][t] ^= sbox[tk[0][t]];
    }
    for (t = 0; t < 4; t++)
        tk[0][t] ^= tk[(i / 4) % KC][t];
    for (t = 0; t < 4; t++)
        a->round_key[i / 4].u8[t + (i % 4) * 4] = tk[0][t];
    for (t = 0; t < KC - 1; t++)
        memcpy(tk[t], tk[t + 1], 4);
}

if (decrypt) {
    for (i = 1; i < rounds; i++) {
        subshift(&a->round_key[i], 0, inv_sbox);
        mix_columns(&a->round_key[i], dec_multbl);
    }
} else {
    for (i = 0; i < (rounds + 1) / 2; i++) {
        FFSWAP(av_aes_block, a->round_key[i], a->round_key[rounds - i]);
    }
}