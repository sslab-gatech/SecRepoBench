for (i = KC; i < (rounds + 1) * 4; i++) {
        uint8_t temp[4];
        memcpy(temp, tk[(i - 1) % KC], 4);

        if (i % KC == 0) {
            // Rotate the word
            uint8_t tmp = temp[0];
            temp[0] = temp[1];
            temp[1] = temp[2];
            temp[2] = temp[3];
            temp[3] = tmp;

            // Apply S-box
            temp[0] = sbox[temp[0]];
            temp[1] = sbox[temp[1]];
            temp[2] = sbox[temp[2]];
            temp[3] = sbox[temp[3]];

            // XOR with Rcon
            temp[0] ^= rcon[rconpointer++];
        } else if (KC > 6 && i % KC == 4) {
            // Apply S-box for 256-bit keys
            temp[0] = sbox[temp[0]];
            temp[1] = sbox[temp[1]];
            temp[2] = sbox[temp[2]];
            temp[3] = sbox[temp[3]];
        }

        // Compute the round key
        for (t = 0; t < 4; t++) {
            tk[i % KC][t] = tk[(i - KC) % KC][t] ^ temp[t];
            a->round_key[i / 4].u8[4 * (i % 4) + t] = tk[i % KC][t];
        }
    }

    if (decrypt) {
        // Reverse the round keys for decryption
        for (i = 1; i < rounds; i++) {
            aes_crypt(a, 0, inv_sbox, dec_multbl);
            addkey_s(&a->state[0], a->round_key[i].u8, &a->state[0]);
        }
    }