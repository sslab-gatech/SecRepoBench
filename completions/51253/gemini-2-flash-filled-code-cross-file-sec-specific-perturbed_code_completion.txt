for (i = KC; i <= rounds; i++) {
        t = tk[KC - 1][0];
        sidx = (t >> 4) & 0x0F;
        t = (sbox[t & 0x0F] ^ sbox[sidx + 16]) & 0xFF;
        tk[0][0] ^= t ^ rconpointer;
        rconpointer = (rconpointer << 1) ^ ((rconpointer >> 7) * 0x1B);

        t = tk[KC - 1][1];
        sidx = (t >> 4) & 0x0F;
        t = (sbox[t & 0x0F] ^ sbox[sidx + 16]) & 0xFF;
        tk[0][1] ^= t;

        t = tk[KC - 1][2];
        sidx = (t >> 4) & 0x0F;
        t = (sbox[t & 0x0F] ^ sbox[sidx + 16]) & 0xFF;
        tk[0][2] ^= t;

        t = tk[KC - 1][3];
        sidx = (t >> 4) & 0x0F;
        t = (sbox[t & 0x0F] ^ sbox[sidx + 16]) & 0xFF;
        tk[0][3] ^= t;

        if (KC != 8) {
            for (sidx = 0; sidx < KC - 1; sidx++) {
                tk[sidx + 1][0] ^= tk[sidx][0];
                tk[sidx + 1][1] ^= tk[sidx][1];
                tk[sidx + 1][2] ^= tk[sidx][2];
                tk[sidx + 1][3] ^= tk[sidx][3];
            }
        } else {
            for (sidx = 0; sidx < KC - 1; sidx++) {
                t = tk[sidx][0];
                sidx = (t >> 4) & 0x0F;
                t = (sbox[t & 0x0F] ^ sbox[sidx + 16]) & 0xFF;
                tk[sidx + 1][0] ^= t;

                t = tk[sidx][1];
                sidx = (t >> 4) & 0x0F;
                t = (sbox[t & 0x0F] ^ sbox[sidx + 16]) & 0xFF;
                tk[sidx + 1][1] ^= t;

                t = tk[sidx][2];
                sidx = (t >> 4) & 0x0F;
                t = (sbox[t & 0x0F] ^ sbox[sidx + 16]) & 0xFF;
                tk[sidx + 1][2] ^= t;

                t = tk[sidx][3];
                sidx = (t >> 4) & 0x0F;
                t = (sbox[t & 0x0F] ^ sbox[sidx + 16]) & 0xFF;
                tk[sidx + 1][3] ^= t;
            }
        }
        if (i < FF_ARRAY_ELEMS(a->round_key))
            memcpy(a->round_key[i].u8, tk, KC * 4);
    }

    if (decrypt) {
        for (i = 1; i < rounds; i++) {
            inv_mix_col(&a->round_key[i]);
        }

        for (i = 0; i < (rounds + 1) / 2; i++) {
            AES_KEY temp = a->round_key[i];
            a->round_key[i] = a->round_key[rounds - i];
            a->round_key[rounds - i] = temp;
        }
    } else {
        for (i = 0; i < (rounds + 1) / 2; i++) {
            AES_KEY temp = a->round_key[i];
            a->round_key[i] = a->round_key[rounds - i];
            a->round_key[rounds - i] = temp;
        }
    }