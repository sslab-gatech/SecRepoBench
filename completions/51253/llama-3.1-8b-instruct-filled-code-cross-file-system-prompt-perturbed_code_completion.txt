// Generate round keys for AES encryption or decryption.
// Iterates over the key schedule and computes each round key
// using the provided S-box and Rcon tables. The initial key is
// expanded into a series of round keys using an XOR-based process
// with a cyclic shift and substitution for the first word of each
// key. If decryption is requested, the round keys are modified
// using inverse subshift and mix transformations. Finally, if
// encryption is intended, the round keys are reversed for use
// in the forward order during encryption.
for (t = 1; t < rounds; t++) {
    if (decrypt) {
        // Inverse subshift and mix transformations for decryption
        addkey_s(&a->round_key[t - 1], &a->round_key[t - 1], &a->round_key[t - 1]);
        addkey_s(&a->round_key[t - 1], &a->round_key[t - 1], &a->round_key[t - 1]);
        addkey_s(&a->round_key[t - 1], &a->round_key[t - 1], &a->round_key[t - 1]);
        addkey_s(&a->round_key[t - 1], &a->round_key[t - 1], &a->round_key[t - 1]);
    } else {
        // Cyclic shift and substitution for encryption
        addkey_s(&a->round_key[t - 1], &a->round_key[t - 1], &a->round_key[t - 1]);
        addkey_s(&a->round_key[t - 1], &a->round_key[t - 1], &a->round_key[t - 1]);
        addkey_s(&a->round_key[t - 1], &a->round_key[t - 1], &a->round_key[t - 1]);
        addkey_s(&a->round_key[t - 1], &a->round_key[t - 1], &a->round_key[t - 1]);
    }
    addkey_s(&a->round_key[t], &a->round_key[t - 1], &a->round_key[t]);
    memcpy(&a->round_key[t - 1], &a->round_key[t - 2], 4);
}