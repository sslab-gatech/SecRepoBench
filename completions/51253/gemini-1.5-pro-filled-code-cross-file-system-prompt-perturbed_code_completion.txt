for (i = KC; i < (rounds + 1) * 4; i++) {
        int j;
        uint8_t *rk = a->round_key[i / 4].u8 + (i % 4);

        memcpy(tk[0], tk[KC], 4 * KC);
        for (j = 0; j < KC; j++)
            tk[0][j] = sbox[tk[0][j]];
        tk[0][0] ^= rcon[rconpointer++];

        if (KC == 8) {
            for (j = 1; j < 4; j++)
                tk[j][0] = sbox[tk[j][0]] ^ tk[j - 1][0];
            for (j = 0; j < 4 * KC; j++)
                *rk++ = tk[(j / 4 + (j % 4) * 2) % 8][j % 4] ^ a->round_key[(i - KC) / 4].u8[j % 4];
        } else {
            for (j = 1; j < KC; j++)
                tk[0][j] ^= tk[0][j - 1];
            for (j = 0; j < 4 * KC; j++)
                *rk++ = tk[0][j % 4] ^ a->round_key[(i - KC) / 4].u8[j % 4];
        }
    }

    if (decrypt) {
        for (i = 1; i < rounds; i++) {
            uint8_t t0, t1, t2, t3;
            uint8_t *rk = a->round_key[i].u8;

            t0 = inv_sbox[rk[0]];
            t1 = inv_sbox[rk[1]];
            t2 = inv_sbox[rk[2]];
            t3 = inv_sbox[rk[3]];

            rk[0] = dec_multbl[0][t0] ^ dec_multbl[1][t1] ^ dec_multbl[2][t2] ^ dec_multbl[3][t3];
            rk[1] = dec_multbl[0][t1] ^ dec_multbl[1][t2] ^ dec_multbl[2][t3] ^ dec_multbl[3][t0];
            rk[2] = dec_multbl[0][t2] ^ dec_multbl[1][t3] ^ dec_multbl[2][t0] ^ dec_multbl[3][t1];
            rk[3] = dec_multbl[0][t3] ^ dec_multbl[1][t0] ^ dec_multbl[2][t1] ^ dec_multbl[3][t2];
        }
    } else {
        for (i = 1; i <= rounds; i++) {
            FFSWAP(AVRoundKey, a->round_key[i], a->round_key[rounds + 1 - i]);
        }
    }