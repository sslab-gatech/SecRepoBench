for (i = 1; i <= rounds; i++) {
        // Rotate the first word and apply S-box
        t = tk[KC - 1][0];
        tk[KC - 1][0] = sbox[tk[0][1]] ^ rcon[rconpointer++];
        tk[0][1] = sbox[tk[1][2]];
        tk[1][2] = sbox[tk[2][3]];
        tk[2][3] = sbox[t];

        // XOR with the previous key
        for (t = 0; t < KC; t++) {
            tk[t][0] ^= tk[t ? t - 1 : KC - 1][0];
            tk[t][1] ^= tk[t ? t - 1 : KC - 1][1];
            tk[t][2] ^= tk[t ? t - 1 : KC - 1][2];
            tk[t][3] ^= tk[t ? t - 1 : KC - 1][3];
        }

        // Copy the generated key to the round key array
        memcpy(a->round_key[i].u8, tk, KC * 4);
    }

    if (decrypt) {
        // Reverse the round keys for decryption
        for (i = 1; i < rounds; i++) {
            subshift(&a->round_key[i], 0, inv_sbox);
            mix(&a->round_key[i], dec_multbl, 1, 3);
        }
    }