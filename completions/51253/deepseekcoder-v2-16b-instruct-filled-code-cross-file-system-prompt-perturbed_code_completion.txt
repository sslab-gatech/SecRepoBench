// Generate round keys for AES encryption or decryption.
    // Iterates over the key schedule and computes each round key
    // using the provided S-box and Rcon tables. The initial key is
    // expanded into a series of round keys using an XOR-based process
    // with a cyclic shift and substitution for the first word of each
    // key. If decryption is requested, the round keys are modified
    // using inverse subshift and mix transformations. Finally, if
    // encryption is intended, the round keys are reversed for use
    // in the forward order during encryption.

    for (i = 1; i < rounds; i++) {
        for (t = 0; t < 4; t++) {
            tk[i * 4 + t] = tk[(i - 1) * 4 + t] ^ tk[(i - 1) * 4 + (t + 1) % 4] ^ tk[(i - 1) * 4 + (t + 2) % 4] ^ tk[(i - 1) * 4 + (t + 3) % 4] ^ rcon[rconpointer++];
        }
        for (t = 0; t < 4; t++) {
            tk[i * 4 + t] ^= tk[(i - 1) * 4 + t];
        }
    }

    for (i = 0; i < rounds; i++) {
        for (t = 0; t < 4; t++) {
            a->round_key[i].u8[t] = tk[i * 4 + t];
        }
    }

    if (decrypt) {
        for (i = 0; i < rounds; i++) {
            for (t = 0; t < 4; t++) {
                a->round_key[i].u8[t] = tk[i * 4 + t];
            }
        }
    }