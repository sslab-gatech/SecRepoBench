for (i = KC; i < 4 * (rounds + 1); i++) {
        uint8_t temp[4];
        memcpy(temp, tk[(i - 1) & 7], 4);

        if (i % KC == 0) {
            // Rotate the word
            uint8_t tmp = temp[0];
            temp[0] = temp[1];
            temp[1] = temp[2];
            temp[2] = temp[3];
            temp[3] = tmp;

            // Apply S-box
            temp[0] = sbox[temp[0]];
            temp[1] = sbox[temp[1]];
            temp[2] = sbox[temp[2]];
            temp[3] = sbox[temp[3]];

            // Apply Rcon
            if (rconpointer < FF_ARRAY_ELEMS(rcon)) {
                temp[0] ^= rcon[rconpointer++];
            }
        } else if (KC > 6 && i % KC == 4) {
            // Apply S-box
            temp[0] = sbox[temp[0]];
            temp[1] = sbox[temp[1]];
            temp[2] = sbox[temp[2]];
            temp[3] = sbox[temp[3]];
        }

        // XOR with the previous word
        tk[i & 7][0] = tk[(i - KC) & 7][0] ^ temp[0];
        tk[i & 7][1] = tk[(i - KC) & 7][1] ^ temp[1];
        tk[i & 7][2] = tk[(i - KC) & 7][2] ^ temp[2];
        tk[i & 7][3] = tk[(i - KC) & 7][3] ^ temp[3];

        // Copy the generated key to the round key array
        if (i < FF_ARRAY_ELEMS(a->round_key)) {
            memcpy(a->round_key[i].u8, tk[i & 7], 4);
        }
    }

    if (decrypt) {
        for (i = 1; i < rounds; i++) {
            if (i < FF_ARRAY_ELEMS(a->round_key)) {
                aes_crypt(a, i, inv_sbox, dec_multbl);
            }
        }
    }