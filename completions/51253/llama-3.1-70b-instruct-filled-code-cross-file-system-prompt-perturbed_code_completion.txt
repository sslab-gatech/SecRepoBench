for (t = 1; t < rounds; t++) {
    uint8_t *rkt = a->round_key[t].u8;
    uint8_t *rkt_1 = a->round_key[t - 1].u8;
    uint8_t *rkt_4 = a->round_key[t - 4].u8;

    if (t % KC == 0) {
        for (i = 0; i < 4; i++) {
            uint8_t tmp = rkt_4[i];
            rkt[i] = sbox[tmp] ^ rcon[rconpointer++];
        }
        rconpointer %= 11;
    } else if (KC > 6 && t % KC == 4) {
        for (i = 0; i < 4; i++) {
            uint8_t tmp = rkt_4[i];
            rkt[i] = sbox[tmp];
        }
    } else {
        for (i = 0; i < 4; i++) {
            uint8_t tmp = rkt_4[i];
            rkt[i] = tmp;
        }
    }

    for (i = 0; i < 4; i++) {
        rkt[i] ^= rkt_1[i];
    }

    if (decrypt) {
        for (i = 0; i < 4; i++) {
            uint8_t tmp = rkt[i];
            rkt[i] = inv_sbox[tmp];
        }
    }
}