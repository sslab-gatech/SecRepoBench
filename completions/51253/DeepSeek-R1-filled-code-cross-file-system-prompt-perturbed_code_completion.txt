for (i = KC; i < (rounds + 1) * 4; i++) {
        int j = (i - 1) % KC;
        memcpy(&t, tk[j], 4);
        if (i % KC == 0) {
            uint8_t tmp = t[0];
            t[0] = t[1];
            t[1] = t[2];
            t[2] = t[3];
            t[3] = tmp;
            for (int k = 0; k < 4; k++)
                t[k] = sbox[t[k]];
            t[0] ^= alog8[rconpointer++];
        } else if (KC > 6 && i % KC == 4) {
            for (int k = 0; k < 4; k++)
                t[k] = sbox[t[k]];
        }
        for (int k = 0; k < 4; k++)
            tk[i % KC][k] ^= t[k];
        memcpy(a->round_key[i / 4].u8 + 4 * (i % 4), tk[i % KC], 4);
    }

    if (decrypt) {
        for (i = 1; i < rounds; i++) {
            uint32_t *k = a->round_key[i].u32;
            for (int j = 0; j < 4; j++) {
                uint32_t v = k[j];
                k[j] = dec_multbl[0][v >> 24] ^ dec_multbl[1][(v >> 16) & 0xff] ^
                       dec_multbl[2][(v >> 8) & 0xff] ^ dec_multbl[3][v & 0xff];
            }
        }
        for (i = 0; i < (rounds + 1) / 2; i++) {
            int j = rounds - i;
            FFSWAP(AVUnion, a->round_key[i], a->round_key[j]);
        }
    }