for (t = 1; t < rounds; t++) {
    if (KC == 8 && t >= 7 && t % KC == 0) {
        for (i = 0; i < 4; i++) {
            uint8_t tmp = tk[i][3];
            tk[i][3] = tk[i][0];
            tk[i][0] = tk[i][1];
            tk[i][1] = tk[i][2];
            tk[i][2] = tmp;
        }
        for (i = 0; i < 4; i++)
            tk[i][0] = sbox[tk[i][0]];
        tk[0][0] ^= rcon[rconpointer++];
    } else if (KC == 6 && t >= 6 && t % KC == 0) {
        for (i = 0; i < 4; i++) {
            uint8_t tmp = tk[i][2];
            tk[i][2] = tk[i][0];
            tk[i][0] = tk[i][1];
            tk[i][1] = tk[i][3];
            tk[i][3] = tmp;
        }
        for (i = 0; i < 4; i++)
            tk[i][0] = sbox[tk[i][0]];
        tk[0][0] ^= rcon[rconpointer++];
    } else if (KC == 4 && t >= 4 && t % KC == 0) {
        for (i = 0; i < 4; i++) {
            uint8_t tmp = tk[i][1];
            tk[i][1] = tk[i][0];
            tk[i][0] = tk[i][3];
            tk[i][3] = tk[i][2];
            tk[i][2] = tmp;
        }
        for (i = 0; i < 4; i++)
            tk[i][0] = sbox[tk[i][0]];
        tk[0][0] ^= rcon[rconpointer++];
    } else if (t % KC == 0) {
        for (i = 0; i < 4; i++) {
            uint8_t tmp = tk[i][3];
            tk[i][3] = tk[i][0];
            tk[i][0] = tk[i][1];
            tk[i][1] = tk[i][2];
            tk[i][2] = tmp;
        }
        for (i = 0; i < 4; i++)
            tk[i][0] = sbox[tk[i][0]];
        tk[0][0] ^= rcon[rconpointer++];
    } else if (KC > 6 && t % KC == 4) {
        for (i = 0; i < 4; i++)
            tk[i][0] = sbox[tk[i][0]];
    }
    memcpy(a->round_key[t].u8, tk, KC * 4);
    if (decrypt) {
        addkey(&a->round_key[t], &a->round_key[t], &a->round_key[0]);
        if (t > 1)
            mix(&a->round_key[t - 1], dec_multbl, 3, 1);
    }
}
if (decrypt) {
    for (t = rounds - 1; t > 0; t--)
        addkey(&a->round_key[t], &a->round_key[t], &a->round_key[t - 1]);
}