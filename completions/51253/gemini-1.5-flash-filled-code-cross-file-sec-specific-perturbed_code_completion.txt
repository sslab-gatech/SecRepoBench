for (t = 1; t < rounds; t++) {
        uint8_t *rk = a->round_key[t].u8;
        uint8_t *pk = a->round_key[t - 1].u8;
        if (t == 1) {
            for (i = 0; i < KC; i++) {
                rk[i * 4 + 0] = sbox[pk[i * 4 + 3]];
                rk[i * 4 + 1] = sbox[pk[i * 4 + 0]];
                rk[i * 4 + 2] = sbox[pk[i * 4 + 1]];
                rk[i * 4 + 3] = sbox[pk[i * 4 + 2]];
            }
            rk[0] ^= rcon[rconpointer++];
        } else {
            memcpy(rk, pk + KC * 4, KC * 4);
        }
        for (i = 0; i < KC; i++)
            rk[i * 4] ^= rk[(i - 1 + KC) * 4];
        if (decrypt) {
            for (i = 0; i < KC; i++) {
                rk[i * 4 + 0] = inv_sbox[rk[i * 4 + 0]];
                rk[i * 4 + 1] = inv_sbox[rk[i * 4 + 1]];
                rk[i * 4 + 2] = inv_sbox[rk[i * 4 + 2]];
                rk[i * 4 + 3] = inv_sbox[rk[i * 4 + 3]];
            }
        }
    }
    if (decrypt) {
        for (t = 0; t < rounds; t++) {
            memcpy(a->round_key[t].u8, a->round_key[rounds - 1 - t].u8, 16);
        }
    }