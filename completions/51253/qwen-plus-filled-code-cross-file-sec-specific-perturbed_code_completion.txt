for (i = 1; i < rounds + 1; i++) {
    uint8_t *key_dest = a->round_key[i].u8;
    int j;

    if (KC == 4) { // AES-128
        for (j = 0; j < 4; j++) {
            key_dest[j] = tk[(j + 1) % 4][3];
        }
        t = subshift(tk[0][3], rconpointer);
        rconpointer++;
        for (; j < 16; j += 4) {
            key_dest[j]     = tk[(j - 15) % 4][0] ^ t;
            key_dest[j + 1] = tk[(j - 14) % 4][1] ^ key_dest[j];
            key_dest[j + 2] = tk[(j - 13) % 4][2] ^ key_dest[j + 1];
            key_dest[j + 3] = tk[(j - 12) % 4][3] ^ key_dest[j + 2];
            t = key_dest[j + 3];
        }
    } else if (KC == 6) { // AES-192
        for (j = 0; j < 6; j++) {
            key_dest[j] = tk[(j + 1) % 6][3];
        }
        if (i % 2 == 1) {
            t = subshift(tk[0][3], rconpointer);
            rconpointer++;
        } else {
            t = tk[0][3];
        }
        for (; j < 24; j += 6) {
            key_dest[j]     = tk[(j - 23) % 6][0] ^ t;
            key_dest[j + 1] = tk[(j - 22) % 6][1] ^ key_dest[j];
            key_dest[j + 2] = tk[(j - 21) % 6][2] ^ key_dest[j + 1];
            key_dest[j + 3] = tk[(j - 20) % 6][3] ^ key_dest[j + 2];
            key_dest[j + 4] = tk[(j - 19) % 6][0] ^ key_dest[j + 3];
            key_dest[j + 5] = tk[(j - 18) % 6][1] ^ key_dest[j + 4];
            t = key_dest[j + 5];
        }
    } else if (KC == 8) { // AES-256
        for (j = 0; j < 8; j++) {
            key_dest[j] = tk[(j + 1) % 8][3];
        }
        if (i % 2 == 1) {
            t = subshift(tk[0][3], rconpointer);
            rconpointer++;
        } else {
            t = subshift(tk[0][3], 0);
        }
        for (; j < 32; j += 8) {
            key_dest[j]     = tk[(j - 31) % 8][0] ^ t;
            key_dest[j + 1] = tk[(j - 30) % 8][1] ^ key_dest[j];
            key_dest[j + 2] = tk[(j - 29) % 8][2] ^ key_dest[j + 1];
            key_dest[j + 3] = tk[(j - 28) % 8][3] ^ key_dest[j + 2];
            key_dest[j + 4] = tk[(j - 27) % 8][0] ^ key_dest[j + 3];
            key_dest[j + 5] = tk[(j - 26) % 8][1] ^ key_dest[j + 4];
            key_dest[j + 6] = tk[(j - 25) % 8][2] ^ key_dest[j + 5];
            key_dest[j + 7] = tk[(j - 24) % 8][3] ^ key_dest[j + 6];
            t = key_dest[j + 7];
        }
    }

    memcpy(tk, key_dest, KC * 4);
}

if (decrypt) {
    for (i = 1; i <= rounds / 2; i++) {
        uint8_t *temp = a->round_key[i].u8;
        a->round_key[i].u8 = a->round_key[rounds - i + 1].u8;
        a->round_key[rounds - i + 1].u8 = temp;
    }
}