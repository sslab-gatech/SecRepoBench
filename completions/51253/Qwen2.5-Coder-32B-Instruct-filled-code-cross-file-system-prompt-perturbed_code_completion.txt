for (t = KC; t < (rounds + 1) * 4; t++) {
    if (t % KC == 0) {
        uint8_t tmp[4];
        memcpy(tmp, tk[KC - 1], 4);
        rotword(tmp);
        subword(tmp, sbox);
        tmp[0] ^= rcon[rconpointer++];
        xor4(tk[0], tmp);
    } else if (KC > 6 && t % KC == 4) {
        subword(tk[0], sbox);
    } else {
        xor4(tk[0], tk[KC - 1]);
    }
    memcpy(tk[t % KC], tk[0], 4);
    memcpy(a->round_key[t].u8, tk[t % KC], 4);
}

if (decrypt) {
    for (i = 1; i < rounds; i++) {
        inv_mix_columns(a->round_key[i].u8);
    }
}

if (!decrypt) {
    for (i = 0; i < rounds / 2; i++) {
        AVAESBlock tmp;
        tmp = a->round_key[i];
        a->round_key[i] = a->round_key[rounds - i];
        a->round_key[rounds - i] = tmp;
    }
}