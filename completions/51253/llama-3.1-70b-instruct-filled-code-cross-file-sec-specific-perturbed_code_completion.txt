for (t = 1; t < rounds; t++) {
    for (i = 0; i < KC; i++) {
        uint8_t *rki = a->round_key[t].u8 + i * 4;
        uint8_t *rkm = a->round_key[t - 1].u8 + i * 4;
        if (i == 0) {
            uint8_t *rkc = a->round_key[t - 1].u8 + (KC - 1) * 4;
            rki[0] = sbox[rkm[0] ^ rkc[0] ^ Rcon[t - 1]];
            rki[1] = sbox[rkm[1] ^ rkc[1]];
            rki[2] = sbox[rkm[2] ^ rkc[2]];
            rki[3] = sbox[rkm[3] ^ rkc[3]];
        } else {
            rki[0] = sbox[rkm[0] ^ rkm[0 - 4]];
            rki[1] = sbox[rkm[1] ^ rkm[1 - 4]];
            rki[2] = sbox[rkm[2] ^ rkm[2 - 4]];
            rki[3] = sbox[rkm[3] ^ rkm[3 - 4]];
        }
    }
}
if (decrypt) {
    for (t = 0; t < rounds; t++) {
        uint8_t *rk = a->round_key[t].u8;
        uint8_t *rkp = a->round_key[rounds - t - 1].u8;
        for (i = 0; i < KC * 4; i++)
            rk[i] ^= rkp[i];
    }
}