for (t = KC; t < (rounds + 1) * 4; t++) {
    uint8_t temp[4];
    
    // Check array bounds to prevent buffer overflows
    if (t/4 >= FF_ARRAY_ELEMS(a->round_key)) {
        return AVERROR(EINVAL);
    }
    
    // Copy the last added word
    memcpy(temp, a->round_key[(t-1)/4].u8 + ((t-1)%4)*4, 4);
    
    // Apply transformations based on position
    if (t % KC == 0) {
        // Rotate left by one byte
        uint8_t tmp = temp[0];
        temp[0] = temp[1];
        temp[1] = temp[2];
        temp[2] = temp[3];
        temp[3] = tmp;
        
        // Apply S-box substitution
        temp[0] = sbox[temp[0]];
        temp[1] = sbox[temp[1]];
        temp[2] = sbox[temp[2]];
        temp[3] = sbox[temp[3]];
        
        // XOR with round constant
        temp[0] ^= (1 << rconpointer++);
    } else if (KC > 6 && t % KC == 4) {
        // Extra substitution for 256-bit keys
        temp[0] = sbox[temp[0]];
        temp[1] = sbox[temp[1]];
        temp[2] = sbox[temp[2]];
        temp[3] = sbox[temp[3]];
    }
    
    // XOR with word from KC positions back
    for (i = 0; i < 4; i++) {
        a->round_key[t/4].u8[(t%4)*4 + i] = 
            temp[i] ^ a->round_key[(t-KC)/4].u8[((t-KC)%4)*4 + i];
    }
}

if (decrypt) {
    // For decryption, modify round keys using inverse operations
    // Leave first and last round keys unchanged
    for (i = 1; i < rounds; i++) {
        AVAES s = *a;
        memcpy(&s.round_key[0], &a->round_key[i], sizeof(s.round_key[0]));
        aes_crypt(&s, 0, inv_sbox, dec_multbl);
        memcpy(&a->round_key[i], &s.state[0], sizeof(a->round_key[i]));
    }
} else {
    // For encryption, reverse the order of round keys
    for (i = 0; i < (rounds + 1) / 2; i++) {
        AVAES tmp = a->round_key[i];
        a->round_key[i] = a->round_key[rounds - i];
        a->round_key[rounds - i] = tmp;
    }
}