// Generate round keys for AES encryption or decryption.
    // Iterates over the key schedule and computes each round key
    // using the provided S-box and Rcon tables. The initial key is
    // expanded into a series of round keys using an XOR-based process
    // with a cyclic shift and substitution for the first word of each
    // key. If decryption is requested, the round keys are modified
    // using inverse subshift and mix transformations. Finally, if
    // encryption is intended, the round keys are reversed for use
    // in the forward order during encryption.
    for (i = KC; i < rounds; i++) {
        uint8_t *r = a->round_key[i].u8;
        r[0] ^= sbox[r[0] ^ r[4] ^ r[8] ^ r[12] ^ rcon[rconpointer]];
        r[1] ^= r[0];
        r[2] ^= r[1];
        r[3] ^= r[2];
        r[4] ^= r[3];
        r[5] ^= r[4];
        r[6] ^= r[5];
        r[7] ^= r[6];
        r[8] ^= r[7];
        r[9] ^= r[8];
        r[10] ^= r[9];
        r[11] ^= r[10];
        r[12] ^= r[11];
        r[13] ^= r[12];
        r[14] ^= r[13];
        r[15] ^= r[14];
        if (decrypt) {
            subshift(&a->round_key[i], 0, inv_sbox);
            mix(&a->round_key[i], dec_multbl, 3, 1);
        }
        rconpointer = (rconpointer + 1) % 10;
    }
    if (!decrypt)
        for (i = 0; i < rounds / 2; i++)
            SWAP(a->round_key[i], a->round_key[rounds - i - 1]);
    return 0;
}