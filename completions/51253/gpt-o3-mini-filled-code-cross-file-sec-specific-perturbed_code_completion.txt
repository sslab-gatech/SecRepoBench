{
    int i, j;
    uint32_t temp;
    int num_words = (rounds + 1) * 4;
    uint32_t *rk = (uint32_t *)a->round_key;
    uint8_t rcon = 1;

    for (i = KC; i < num_words; i++) {
        temp = rk[i - 1];
        if (i % KC == 0) {
            /* RotWord: rotate temp left by 8 bits */
            temp = (temp << 8) | (temp >> 24);
            /* SubWord: substitute each byte using sbox */
            temp = ((uint32_t)sbox[(temp >> 24)       ] << 24) |
                   ((uint32_t)sbox[(temp >> 16) & 0xFF] << 16) |
                   ((uint32_t)sbox[(temp >> 8)  & 0xFF] << 8)  |
                   ((uint32_t)sbox[(temp)       & 0xFF]);
            /* XOR with round constant */
            temp ^= ((uint32_t)rcon << 24);
            /* Update rcon: multiply by 2 in GF(2^8) */
            rcon = (rcon << 1) ^ ((rcon & 0x80) ? 0x1B : 0);
        } else if (KC > 6 && (i % KC == 4)) {
            /* For 256-bit keys, apply SubWord without rotation */
            temp = ((uint32_t)sbox[(temp >> 24)       ] << 24) |
                   ((uint32_t)sbox[(temp >> 16) & 0xFF] << 16) |
                   ((uint32_t)sbox[(temp >> 8)  & 0xFF] << 8)  |
                   ((uint32_t)sbox[(temp)       & 0xFF]);
        }
        rk[i] = rk[i - KC] ^ temp;
    }

    if (decrypt) {
        /* For decryption, transform intermediate round keys using inverse mix columns,
           except for the first and the last round */
        for (i = 1; i < rounds; i++) {
            for (j = 0; j < 4; j++) {
                uint32_t w = rk[i * 4 + j];
                rk[i * 4 + j] = dec_multbl[0][ w         >> 24       ] ^
                                dec_multbl[1][(w >> 16) & 0xFF         ] ^
                                dec_multbl[2][(w >> 8 ) & 0xFF         ] ^
                                dec_multbl[3][ w         & 0xFF         ];
            }
        }
    } else {
        /* For encryption, reverse the order of the round keys (except first and last) */
        for (i = 1; i < (rounds / 2) + 1; i++) {
            for (j = 0; j < 4; j++) {
                uint32_t tmp = rk[i * 4 + j];
                rk[i * 4 + j] = rk[(rounds - i) * 4 + j];
                rk[(rounds - i) * 4 + j] = tmp;
            }
        }
    }
}