for (t = 1; t < rounds + 1; t++) {
    uint8_t temp[4];

    memcpy(temp, tk[(t - 1) * KC + 3], 4);

    if (KC > 6) {
        subword(tk[t * KC], enc_multbl, sbox, tk[(t - 1) * KC]);
        xor_key(tk[t * KC + 1], tk[(t - 1) * KC + 1], tk[t * KC]);
        subword_mult(tk[t * KC + 2], enc_multbl, sbox, tk[(t - 1) * KC + 2], (const int[4]){0xe, 0x9, 0xd, 0xb});
        xor_key(tk[t * KC + 2], tk[t * KC + 2], tk[t * KC]);
        xor_key(tk[t * KC + 3], tk[(t - 1) * KC + 3], tk[t * KC + 2]);
    } else {
        rotword(temp);
        subword(temp, enc_multbl, sbox, temp);
    }

    temp[0] ^= rcon[rconpointer][0];
    rconpointer++;
    xor_key(tk[t * KC], tk[(t - 1) * KC], temp);

    for (i = 1; i < KC; i++) {
        xor_key(tk[t * KC + i], tk[(t - 1) * KC + i], tk[t * KC + i - 1]);
    }

    memcpy(a->round_key[t].u8, tk[t * KC], 4 * KC);
}

if (decrypt) {
    uint32_t round_key;

    for (t = 0; t < rounds + 1; t++) {
        round_key = AV_RB32(a->round_key[t].u32);
        AV_WB32(a->round_key[rounds - t].u32, round_key);
    }
}