for (i = KC; i < 4 * (rounds + 1); i++) {
    t = AV_RN32(a->round_key[0].u8 + 4 * (i - 1));
    if (i % KC == 0) {
        t = SubWord(RotWord(t)) ^ rcon[rconpointer++];
    } else if (KC > 6 && i % KC == 4) {
        t = SubWord(t);
    }
    t ^= AV_RN32(a->round_key[0].u8 + 4 * (i - KC));
    AV_WN32(a->round_key[0].u8 + 4 * i, t);
}

if (decrypt) {
    for (i = 1; i < rounds; i++) {
        uint8_t *key = a->round_key[i].u8;
        uint32_t v0 = AV_RN32(key);
        uint32_t v1 = AV_RN32(key + 4);
        uint32_t v2 = AV_RN32(key + 8);
        uint32_t v3 = AV_RN32(key + 12);
        v0 = dec_multbl[0][v0 >> 24] << 24 | dec_multbl[1][(v0 >> 16) & 0xff] << 16 |
             dec_multbl[2][(v0 >> 8) & 0xff] << 8 | dec_multbl[3][v0 & 0xff];
        v1 = dec_multbl[0][v1 >> 24] << 24 | dec_multbl[1][(v1 >> 16) & 0xff] << 16 |
             dec_multbl[2][(v1 >> 8) & 0xff] << 8 | dec_multbl[3][v1 & 0xff];
        v2 = dec_multbl[0][v2 >> 24] << 24 | dec_multbl[1][(v2 >> 16) & 0xff] << 16 |
             dec_multbl[2][(v2 >> 8) & 0xff] << 8 | dec_multbl[3][v2 & 0xff];
        v3 = dec_multbl[0][v3 >> 24] << 24 | dec_multbl[1][(v3 >> 16) & 0xff] << 16 |
             dec_multbl[2][(v3 >> 8) & 0xff] << 8 | dec_multbl[3][v3 & 0xff];
        AV_WN32(key, v0);
        AV_WN32(key + 4, v1);
        AV_WN32(key + 8, v2);
        AV_WN32(key + 12, v3);
    }
    for (i = 0; i < (rounds + 1) / 2; i++) {
        int j = (rounds + 1) - 1 - i;
        struct { uint8_t u8[16]; } tmp = a->round_key[i];
        a->round_key[i] = a->round_key[j];
        a->round_key[j] = tmp;
    }
}