for (i = 1; i < rounds; i++) {
    uint8_t *in = tk[(i - 1) & 3];
    uint8_t *out = tk[i & 3];
    uint8_t t;

    if (i % KC == 0) {
        t = in[0];
        out[0] = sbox[t ^ rcon[rconpointer++]];
        out[1] = sbox[in[5] ^ out[0]];
        out[2] = sbox[in[10] ^ out[1]];
        out[3] = sbox[in[15] ^ out[2]];
    } else if (KC > 6 && (i % KC == 4)) {
        out[0] = sbox[in[0]];
        out[1] = sbox[in[5]];
        out[2] = sbox[in[10]];
        out[3] = sbox[in[15]];
    } else {
        out[0] = in[0] ^ out[0];
        out[1] = in[5] ^ out[1];
        out[2] = in[10] ^ out[2];
        out[3] = in[15] ^ out[3];
    }

    memcpy(a->round_key[i].u8, out, 4 * sizeof(uint8_t));
    if (decrypt) {
        if (i < rounds - 1)
            subshift_inv(out, out);
        else
            subshift_inv(out, a->round_key[i - 1].u8);
        mix_inv(out, out);
    }
}
if (decrypt) {
    for (i = 0; i < rounds / 2; i++) {
        uint8_t *tmp = a->round_key[i].u8;
        a->round_key[i].u8 = a->round_key[rounds - 1 - i].u8;
        a->round_key[rounds - 1 - i].u8 = tmp;
    }
}