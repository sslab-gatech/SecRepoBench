for (i = 0; i < rounds; i++) {
    if (i == 0) {
        for (t = 0; t < 4; t++)
            tk[0][t] ^= sbox[tk[KC - 1][(t + 1) & 3]];
        tk[0][0] ^= rcon[rconpointer++];
    } else if (KC != 8 || i % KC != 0) {
        for (t = 0; t < 4; t++)
            tk[0][t] ^= tk[KC - 1][t];
    } else {
        for (t = 0; t < 4; t++)
            tk[0][t] ^= sbox[tk[KC - 1][t]];
    }

    for (j = 1; j < KC; j++) {
        for (t = 0; t < 4; t++)
            tk[j][t] ^= tk[j - 1][t];
    }
    memcpy(a->round_key[i + 1].u8, tk, KC * 4);
}

if (decrypt) {
    for (i = 1; i < rounds; i++) {
        subshift(&a->round_key[i], 0, inv_sbox);
        mix_columns(&a->round_key[i], dec_multbl);
    }
} else {
    for (i = 0; i <= rounds / 2; i++) {
        FFSWAP(av_aes_block, a->round_key[i], a->round_key[rounds - i]);
    }
}