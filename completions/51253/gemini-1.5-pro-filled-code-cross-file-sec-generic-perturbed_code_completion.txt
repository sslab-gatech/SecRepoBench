for (i = KC; i < (rounds + 1) * 4; i++) {
        uint8_t tmp[4];
        memcpy(tmp, tk[i - 1], 4);

        if (i % KC == 0) {
            t = tmp[0];
            tmp[0] = sbox[tmp[1]] ^ rcon[rconpointer++];
            tmp[1] = sbox[tmp[2]];
            tmp[2] = sbox[tmp[3]];
            tmp[3] = sbox[t];
        } else if (KC > 6 && i % KC == 4) {
            tmp[0] = sbox[tmp[0]];
            tmp[1] = sbox[tmp[1]];
            tmp[2] = sbox[tmp[2]];
            tmp[3] = sbox[tmp[3]];
        }

        tk[i][0] = a->round_key[i / 4].u8[i % 4] = tk[i - KC][0] ^ tmp[0];
        tk[i][1] = a->round_key[i / 4].u8[i % 4 + 4] = tk[i - KC][1] ^ tmp[1];
        tk[i][2] = a->round_key[i / 4].u8[i % 4 + 8] = tk[i - KC][2] ^ tmp[2];
        tk[i][3] = a->round_key[i / 4].u8[i % 4 + 12] = tk[i - KC][3] ^ tmp[3];
    }

    if (decrypt) {
        for (i = 1; i < rounds; i++) {
            inv_subshiftrows(a->round_key[i].u8);
            inv_mixcolumns(a->round_key[i].u8, inv_sbox, dec_multbl);
        }
    } else {
        for (i = 1; i <= rounds; i++)
            for (int j = 0; j < 4; j++)
                a->round_key[i].u8[j] = a->round_key[rounds - i + 1].u8[j];
    }