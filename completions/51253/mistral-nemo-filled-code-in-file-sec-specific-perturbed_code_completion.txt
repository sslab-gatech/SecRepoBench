for (i = 1; i < rounds; i++) {
        // Perform cyclic shift and substitution for the first word of each key
        tk[0][0] = sbox[tk[0][0] ^ rcon[rconpointer]];
        tk[0][1] = sbox[tk[0][1]];
        tk[0][2] = sbox[tk[0][2]];
        tk[0][3] = sbox[tk[0][3]];

        // XOR the shifted and substituted word with the other words in the key
        for (t = 0; t < 4; t++)
            tk[t] ^= tk[(t + 1) & 3];

        // Store the new round key
        memcpy(a->round_key[i].u8, tk, 16);

        // Prepare for the next iteration
        rconpointer = (rconpointer + 1) % 10;
    }

    // If decryption is requested, modify the round keys using inverse subshift and mix transformations
    if (decrypt) {
        for (i = 1; i < rounds; i++) {
            av_aes_block tmp;
            subshift(&tmp, 0, inv_sbox);
            mix(&tmp, dec_multbl, 3, 1);
            addkey(&a->round_key[rounds - i], &tmp, &a->round_key[rounds - i - 1]);
        }
    }

    // If encryption is intended, reverse the round keys for use in the forward order during encryption
    if (!decrypt) {
        for (i = 1; i < (rounds + 1) / 2; i++) {
            av_aes_block tmp;
            memcpy(tmp.u8, a->round_key[i].u8, 16);
            memcpy(a->round_key[i].u8, a->round_key[rounds - i].u8, 16);
            memcpy(a->round_key[rounds - i].u8, tmp.u8, 16);
        }
    }