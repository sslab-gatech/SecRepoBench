for (i = KC; i < (rounds + 1) * 4; i++) {
        uint8_t temp[4];
        memcpy(temp, tk[(i - 1) % KC], 4);
        if (i % KC == 0) {
            uint8_t t = temp[0];
            temp[0] = sbox[temp[1]] ^ rcon[rconpointer++];
            temp[1] = sbox[temp[2]];
            temp[2] = sbox[temp[3]];
            temp[3] = sbox[t];
        } else if (KC > 6 && i % KC == 4) {
            temp[0] = sbox[temp[0]];
            temp[1] = sbox[temp[1]];
            temp[2] = sbox[temp[2]];
            temp[3] = sbox[temp[3]];
        }
        for (t = 0; t < 4; t++)
            tk[i % KC][t] ^= temp[t];
        memcpy(a->round_key[i >> 2].u8 + ((i & 3) << 2), tk[i % KC], 4);
    }

    if (decrypt) {
        for (i = 1; i < rounds; i++) {
            uint8_t tmp[3][16];
            memcpy(tmp[2], a->round_key[i].u8, 16);
            aes_crypt(a, 0, inv_sbox, dec_multbl);
            memcpy(tmp[0], a->state[0].u8, 16);
            memcpy(tmp[1], a->state[1].u8, 16);
            memcpy(a->round_key[i].u8, tmp[0], 16);
        }
    } else {
        for (i = 0; i < rounds / 2; i++) {
            FFSWAP(AVUnion128, a->round_key[i], a->round_key[rounds - i]);
        }
    }