// Generate round keys for AES encryption or decryption.
    // Iterates over the key schedule and computes each round key
    // using the provided S-box and Rcon tables. The initial key is
    // expanded into a series of round keys using an XOR-based process
    // with a cyclic shift and substitution for the first word of each
    // key. If decryption is requested, the round keys are modified
    // using inverse subshift and mix transformations. Finally, if
    // encryption is intended, the round keys are reversed for use
    // in the forward order during encryption.
    for (i = KC; i < rounds; i++) {
        uint8_t *r = a->round_key[i].u8;
        r[0] ^= sbox[r[0] ^ r[4] ^ tk[0][0] ^ rcon[rconpointer]];
        r[1] ^= sbox[r[1] ^ r[5] ^ tk[1][0]];
        r[2] ^= sbox[r[2] ^ r[6] ^ tk[2][0]];
        r[3] ^= sbox[r[3] ^ r[7] ^ tk[3][0]];
        rconpointer = (rconpointer + 1) % 10;
        if (i % 4 == 0) {
            tk[0][0] = tk[0][1];
            tk[0][1] = tk[0][2];
            tk[0][2] = tk[0][3];
            tk[0][3] = sbox[tk[0][3] ^ rcon[rconpointer]];
            tk[1][0] = tk[1][1];
            tk[1][1] = tk[1][2];
            tk[1][2] = tk[1][3];
            tk[2][0] = tk[2][1];
            tk[2][1] = tk[2][2];
            tk[2][2] = tk[2][3];
            tk[3][0] = tk[3][1];
            tk[3][1] = tk[3][2];
            tk[3][2] = tk[3][3];
            rconpointer = (rconpointer + 1) % 10;
        }
        if (decrypt) {
            subshift(&a->round_key[i], 0, inv_sbox);
            mix(&a->round_key[i], dec_multbl, 3, 1);
        }
    }
    if (!decrypt)
        for (i = 0; i < rounds / 2; i++)
            SWAP(a->round_key[i], a->round_key[rounds - i - 1]);
    return 0;
}