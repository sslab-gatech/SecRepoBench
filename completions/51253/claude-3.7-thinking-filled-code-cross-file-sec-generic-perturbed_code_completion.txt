for (i = KC; i < 4 * (rounds + 1); i++) {
    uint8_t temp[4];
    for (t = 0; t < 4; t++)
        temp[t] = a->round_key[(i - 1) / 4].u8[((i - 1) % 4) * 4 + t];

    if (i % KC == 0) {
        // Rotate left by one byte
        t = temp[0];
        temp[0] = temp[1];
        temp[1] = temp[2];
        temp[2] = temp[3];
        temp[3] = t;

        // Apply S-box
        for (t = 0; t < 4; t++)
            temp[t] = sbox[temp[t]];

        // XOR with a round constant (Rcon)
        temp[0] ^= (1 << rconpointer);
        rconpointer++;
    } else if (KC > 6 && i % KC == 4) {
        // For AES-256, apply S-box to the word if position is 4
        for (t = 0; t < 4; t++)
            temp[t] = sbox[temp[t]];
    }

    // XOR with word KC positions earlier
    for (t = 0; t < 4; t++)
        temp[t] ^= a->round_key[(i - KC) / 4].u8[((i - KC) % 4) * 4 + t];

    // Store in round key
    for (t = 0; t < 4; t++)
        a->round_key[i / 4].u8[(i % 4) * 4 + t] = temp[t];
}

// For decryption, apply inverse mix columns to all round keys except first and last
if (decrypt) {
    for (i = 1; i < rounds; i++) {
        for (t = 0; t < 4; t++) {
            uint32_t tmp = a->round_key[i].u32[t];
            a->round_key[i].u32[t] =
                dec_multbl[0][(tmp >> 24) & 0xFF] ^
                dec_multbl[1][(tmp >> 16) & 0xFF] ^
                dec_multbl[2][(tmp >>  8) & 0xFF] ^
                dec_multbl[3][(tmp      ) & 0xFF];
        }
    }
}