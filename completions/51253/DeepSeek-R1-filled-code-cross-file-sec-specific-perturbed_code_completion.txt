for (i = KC; i < (rounds + 1) * 4; i++) {
    memcpy(t, tk[(i - 1) % KC], 4);
    if (i % KC == 0) {
        uint8_t tmp = t[0];
        t[0] = t[1];
        t[1] = t[2];
        t[2] = t[3];
        t[3] = tmp;
        for (int j = 0; j < 4; j++)
            t[j] = sbox[t[j]];
        t[0] ^= rcon[rconpointer++];
    } else if (KC > 6 && i % KC == 4) {
        for (int j = 0; j < 4; j++)
            t[j] = sbox[t[j]];
    }
    for (int j = 0; j < 4; j++)
        t[j] ^= tk[(i - KC) % KC][j];
    memcpy(tk[i % KC], t, 4);
    int round_key_idx = i / 4;
    int word_idx = i % 4;
    memcpy(a->round_key[round_key_idx].u8 + word_idx * 4, t, 4);
}

if (decrypt) {
    for (i = 1; i < rounds; i++) {
        for (int j = 0; j < 4; j++) {
            uint32_t v = AV_RN32(a->round_key[i].u8 + j * 4);
            v = dec_multbl[0][(v >> 24)       ] ^
                dec_multbl[1][(v >> 16) & 0xFF] ^
                dec_multbl[2][(v >>  8) & 0xFF] ^
                dec_multbl[3][ v        & 0xFF];
            AV_WN32(a->round_key[i].u8 + j * 4, v);
        }
    }
    for (i = 0; i < (rounds + 1) / 2; i++) {
        int j = rounds - i;
        struct { uint8_t u8[16]; } tmp = a->round_key[i];
        a->round_key[i] = a->round_key[j];
        a->round_key[j] = tmp;
    }
} else {
    for (i = 0; i < (rounds + 1) / 2; i++) {
        int j = rounds - i;
        struct { uint8_t u8[16]; } tmp = a->round_key[i];
        a->round_key[i] = a->round_key[j];
        a->round_key[j] = tmp;
    }
}