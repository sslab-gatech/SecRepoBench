for (i = KC; i < 4 * (rounds + 1); i++) {
    if (i % KC == 0) {
        // RotWord and SubWord with Rcon
        t = sbox[tk[(i - 1) % KC][1]] ^ rcon[rconpointer++];
        tk[i % KC][0] = t ^ tk[(i - KC) % KC][0];
        tk[i % KC][1] = sbox[tk[(i - 1) % KC][2]] ^ tk[(i - KC) % KC][1];
        tk[i % KC][2] = sbox[tk[(i - 1) % KC][3]] ^ tk[(i - KC) % KC][2];
        tk[i % KC][3] = sbox[tk[(i - 1) % KC][0]] ^ tk[(i - KC) % KC][3];
    } else if (KC > 6 && i % KC == 4) {
        // Additional SubWord for AES-256
        tk[i % KC][0] = sbox[tk[(i - 1) % KC][0]] ^ tk[(i - KC) % KC][0];
        tk[i % KC][1] = sbox[tk[(i - 1) % KC][1]] ^ tk[(i - KC) % KC][1];
        tk[i % KC][2] = sbox[tk[(i - 1) % KC][2]] ^ tk[(i - KC) % KC][2];
        tk[i % KC][3] = sbox[tk[(i - 1) % KC][3]] ^ tk[(i - KC) % KC][3];
    } else {
        // Simple XOR
        tk[i % KC][0] = tk[(i - 1) % KC][0] ^ tk[(i - KC) % KC][0];
        tk[i % KC][1] = tk[(i - 1) % KC][1] ^ tk[(i - KC) % KC][1];
        tk[i % KC][2] = tk[(i - 1) % KC][2] ^ tk[(i - KC) % KC][2];
        tk[i % KC][3] = tk[(i - 1) % KC][3] ^ tk[(i - KC) % KC][3];
    }
    
    // Store in round key
    a->round_key[i / 4].u8[(i % 4) * 4    ] = tk[i % KC][0];
    a->round_key[i / 4].u8[(i % 4) * 4 + 1] = tk[i % KC][1];
    a->round_key[i / 4].u8[(i % 4) * 4 + 2] = tk[i % KC][2];
    a->round_key[i / 4].u8[(i % 4) * 4 + 3] = tk[i % KC][3];
}

// For decryption, apply inverse transformations to round keys
if (decrypt) {
    av_aes_block tmp[2];
    
    for (i = 1; i < rounds; i++) {
        memcpy(tmp[1].u8, a->round_key[i].u8, 16);
        subshift(tmp, 0, inv_sbox);
        mix(tmp, dec_multbl, 3, 1);
        memcpy(a->round_key[i].u8, tmp[0].u8, 16);
    }
}