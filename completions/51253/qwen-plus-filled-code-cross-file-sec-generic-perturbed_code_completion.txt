for (i = 1; i < rounds + 1; i++) {
    uint8_t *rkey = a->round_key[i].u8;
    memcpy(tk[0], tk[KC - 1], 4);
    t = tk[0][0];
    tk[0][0] = sbox[(t << 1) ^ (t >> 7)];
    tk[0][1] = sbox[(tk[0][1] << 1) ^ (tk[0][1] >> 7)];
    tk[0][2] = sbox[(tk[0][2] << 1) ^ (tk[0][2] >> 7)];
    tk[0][3] = sbox[(tk[0][3] << 1) ^ (tk[0][3] >> 7) ^ rcon[rconpointer++]];
    for (int j = 1; j < KC; j++)
        for (int k = 0; k < 4; k++)
            tk[j][k] = tk[j - 1][k] ^ tk[(j + KC - 1) % KC][k];

    for (int j = 0; j < KC; j++)
        for (int k = 0; k < 4; k++)
            rkey[j * 4 + k] = tk[j][k];

    if (decrypt) {
        uint32_t temp[4];
        for (int j = 0; j < KC; j++) {
            temp[0] = enc_multbl[0][rkey[j * 4 + 0]] ^
                      enc_multbl[1][rkey[j * 4 + 1]] ^
                      enc_multbl[2][rkey[j * 4 + 2]] ^
                      enc_multbl[3][rkey[j * 4 + 3]];
            temp[1] = enc_multbl[0][rkey[j * 4 + 1]] ^
                      enc_multbl[1][rkey[j * 4 + 2]] ^
                      enc_multbl[2][rkey[j * 4 + 3]] ^
                      enc_multbl[3][rkey[j * 4 + 0]];
            temp[2] = enc_multbl[0][rkey[j * 4 + 2]] ^
                      enc_multbl[1][rkey[j * 4 + 3]] ^
                      enc_multbl[2][rkey[j * 4 + 0]] ^
                      enc_multbl[3][rkey[j * 4 + 1]];
            temp[3] = enc_multbl[0][rkey[j * 4 + 3]] ^
                      enc_multbl[1][rkey[j * 4 + 0]] ^
                      enc_multbl[2][rkey[j * 4 + 1]] ^
                      enc_multbl[3][rkey[j * 4 + 2]];

            rkey[j * 4 + 0] = inv_sbox[temp[0]];
            rkey[j * 4 + 1] = inv_sbox[temp[1]];
            rkey[j * 4 + 2] = inv_sbox[temp[2]];
            rkey[j * 4 + 3] = inv_sbox[temp[3]];
        }
    }
}

if (!decrypt) {
    for (i = 0; i <= rounds / 2; i++) {
        uint8_t *temp = a->round_key[i].u8;
        a->round_key[i].u8 = a->round_key[rounds - i].u8;
        a->round_key[rounds - i].u8 = temp;
    }
}