for (i = KC; i < rounds * 4; i += 4) {
    uint8_t t0 = tk[(i - KC) % KC][0];
    uint8_t t1 = tk[(i - KC + 1) % KC][1];
    uint8_t t2 = tk[(i - KC + 2) % KC][2];
    uint8_t t3 = tk[(i - KC + 3) % KC][3];

    if (i % KC == 0) {
        t0 = sbox[t0];
        t1 = sbox[t1];
        t2 = sbox[t2];
        t3 = sbox[t3];

        t0 ^= rcon[rconpointer++];
    }

    tk[i % KC][0] = tk[(i - KC) % KC][0] ^ t0;
    tk[i % KC][1] = tk[(i - KC + 1) % KC][1] ^ t1;
    tk[i % KC][2] = tk[(i - KC + 2) % KC][2] ^ t2;
    tk[i % KC][3] = tk[(i - KC + 3) % KC][3] ^ t3;

    memcpy(a->round_key[i / 4].u8, tk[i % KC], 4);
}

if (decrypt) {
    for (i = 0; i < rounds; i++) {
        uint8_t *rk = a->round_key[i].u8;
        uint8_t *rk2 = a->round_key[rounds - 1 - i].u8;

        rk2[0] = inv_sbox[rk[0]];
        rk2[1] = inv_sbox[rk[5]];
        rk2[2] = inv_sbox[rk[10]];
        rk2[3] = inv_sbox[rk[15]];
        rk2[4] = inv_sbox[rk[4]];
        rk2[5] = inv_sbox[rk[9]];
        rk2[6] = inv_sbox[rk[14]];
        rk2[7] = inv_sbox[rk[3]];
        rk2[8] = inv_sbox[rk[8]];
        rk2[9] = inv_sbox[rk[13]];
        rk2[10] = inv_sbox[rk[2]];
        rk2[11] = inv_sbox[rk[7]];
        rk2[12] = inv_sbox[rk[12]];
        rk2[13] = inv_sbox[rk[1]];
        rk2[14] = inv_sbox[rk[6]];
        rk2[15] = inv_sbox[rk[11]];
    }
}