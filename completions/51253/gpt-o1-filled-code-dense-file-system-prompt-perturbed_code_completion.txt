{
    static const uint8_t rcon[10] = {
        0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36
    };
    uint8_t temp[4];
    int round_idx, j;
    int total_rounds = rounds + 1;

    /* Expand the initial key into round keys */
    for (round_idx = 1; round_idx < total_rounds; round_idx++) {
        /* Copy the last word from the previous key block */
        memcpy(temp, tk[KC - 1], 4);

        /* Perform key schedule core once every KC words (Rcon XOR, S-box, rotate) */
        if ((round_idx % KC) == 0) {
            uint8_t t = temp[0];
            /* Rotate */
            temp[0] = temp[1];
            temp[1] = temp[2];
            temp[2] = temp[3];
            temp[3] = t;
            /* Substitute */
            temp[0] = sbox[temp[0]];
            temp[1] = sbox[temp[1]];
            temp[2] = sbox[temp[2]];
            temp[3] = sbox[temp[3]];
            /* XOR with Rcon */
            temp[0] ^= rcon[rconpointer++];
        } else if (KC == 8 && ((round_idx % KC) == 4)) {
            /* For AES-256, apply S-box to middle word */
            temp[0] = sbox[temp[0]];
            temp[1] = sbox[temp[1]];
            temp[2] = sbox[temp[2]];
            temp[3] = sbox[temp[3]];
        }

        /* XOR with the word KC positions before */
        for (j = 0; j < 4; j++)
            tk[0][j] ^= temp[j];

        /* For the remaining words, each is XOR of itself and the previous word */
        for (j = 1; j < KC; j++)
            for (t = 0; t < 4; t++)
                tk[j][t] ^= tk[j - 1][t];

        /* Copy expanded key material into round_key array */
        memcpy(a->round_key[round_idx].u8, tk, 16);
    }

    /* If decrypting, apply inverse mix-columns to all round keys except first/last */
    if (decrypt) {
        for (round_idx = 1; round_idx < rounds; round_idx++)
            inv_mix_columns(a->round_key[round_idx].u8);
    } else {
        /* For encryption, reverse the round keys (excluding the very first) */
        for (round_idx = 1; round_idx < (rounds + 1) / 2; round_idx++) {
            AVAESBLOCK tmp;
            tmp = a->round_key[round_idx];
            a->round_key[round_idx] = a->round_key[rounds - round_idx];
            a->round_key[rounds - round_idx] = tmp;
        }
    }
}