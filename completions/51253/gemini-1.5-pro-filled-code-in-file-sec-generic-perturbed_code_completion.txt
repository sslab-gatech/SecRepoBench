for (rconpointer = 0, i = KC; i < (rounds + 1) * 4; i++) {
        uint8_t tmp[4];
        uint8_t *rk_a = tk[i % KC];
        uint8_t *rk_b = tk[(i - 1) % KC];

        memcpy(tmp, rk_a, 4);

        if (!(i % KC)) {
            sidx = *tmp;
            t = tmp[0] = sbox[tmp[1]] ^ rcon[rconpointer++];
            tmp[1] = sbox[tmp[2]];
            tmp[2] = sbox[tmp[3]];
            tmp[3] = sbox[sidx];
        } else if (KC > 6 && i % KC == 4) {
            tmp[0] = sbox[tmp[0]];
            tmp[1] = sbox[tmp[1]];
            tmp[2] = sbox[tmp[2]];
            tmp[3] = sbox[tmp[3]];
        }

        for (t = 0; t < 4; t++)
            tk[i % KC][t] = rk_b[t] ^ tmp[t];

        memcpy(a->round_key[i / 4].u8 + i % 4 * 4, tk[i % KC], 4);
    }

    if (decrypt) {
        av_aes_block tmp;

        for (i = 1; i < rounds; i++) {
            subshift(&tmp, 0, inv_sbox);
            memcpy(&tmp, &a->round_key[i], sizeof(tmp));
            mix(&tmp, dec_multbl, 1, 3);
            memcpy(&a->round_key[i], &tmp, sizeof(tmp));
        }
    } else {
        for (i = 1; i < rounds / 2; i++) {
            tmp = a->round_key[i];
            a->round_key[i] = a->round_key[rounds - i];
            a->round_key[rounds - i] = tmp;
        }
    }