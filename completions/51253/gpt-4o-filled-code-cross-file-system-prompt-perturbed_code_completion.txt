for (i = 0; i < rounds; i++) {
        for (t = 0; t < KC; t++) {
            if (t == 0) {
                uint8_t temp[4];
                temp[0] = sbox[tk[KC - 1][1]] ^ rcon[rconpointer++];
                temp[1] = sbox[tk[KC - 1][2]];
                temp[2] = sbox[tk[KC - 1][3]];
                temp[3] = sbox[tk[KC - 1][0]];
                for (sidx = 0; sidx < 4; sidx++) {
                    a->round_key[i + 1].u8[t * 4 + sidx] = a->round_key[i].u8[t * 4 + sidx] ^ temp[sidx];
                    tk[t][sidx] = a->round_key[i + 1].u8[t * 4 + sidx];
                }
            } else if (KC > 6 && t == 4) {
                for (sidx = 0; sidx < 4; sidx++) {
                    a->round_key[i + 1].u8[t * 4 + sidx] = a->round_key[i].u8[t * 4 + sidx] ^ sbox[tk[t - 1][sidx]];
                    tk[t][sidx] = a->round_key[i + 1].u8[t * 4 + sidx];
                }
            } else {
                for (sidx = 0; sidx < 4; sidx++) {
                    a->round_key[i + 1].u8[t * 4 + sidx] = a->round_key[i].u8[t * 4 + sidx] ^ tk[t - 1][sidx];
                    tk[t][sidx] = a->round_key[i + 1].u8[t * 4 + sidx];
                }
            }
        }
    }

    if (decrypt) {
        for (i = 1; i < rounds; i++) {
            aes_crypt(a, i, inv_sbox, dec_multbl);
        }
    }