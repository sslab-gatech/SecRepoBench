for (i = KC; i < (rounds + 1) * 4; i++) {
    memcpy(tk[0], tk[KC - 1], 4);
    if (KC == 8 || KC == 4) {
        for (t = 0; t < 4; t++)
            tk[0][t] ^= sbox[tk[0][t]];
        tk[0][0] ^= rcon[rconpointer++];
    }
    if (KC == 8) {
        for (t = 0; t < 4; t++)
            tk[1][t] ^= sbox[tk[1][t]];
    }
    for (t = 0; t < (KC == 8 ? 2 : (KC == 4 ? 3 : 1)); t++)
        for (sidx = 0; sidx < 4; sidx++)
            tk[t][sidx] ^= tk[t + 1][sidx];
    memcpy(a->round_key[i / 4].u8 + 4 * (i % 4), tk[0], 4);
}

if (decrypt) {
    for (i = 1; i < rounds; i++) {
        av_aes_inv_mix_columns(&a->round_key[i]);
    }
}

if (!decrypt)
    for (i = 0; i < (rounds + 1) / 2; i++)
        FFSWAP(av_aes_block, a->round_key[i], a->round_key[rounds - i]);