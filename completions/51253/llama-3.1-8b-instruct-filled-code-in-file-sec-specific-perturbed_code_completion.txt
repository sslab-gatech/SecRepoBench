// Generate round keys for AES encryption or decryption.
// Iterates over the key schedule and computes each round key
// using the provided S-box and Rcon tables. The initial key is
// expanded into a series of round keys using an XOR-based process
// with a cyclic shift and substitution for the first word of each
// key. If decryption is requested, the round keys are modified
// using inverse subshift and mix transformations. Finally, if
// encryption is intended, the round keys are reversed for use
// in the forward order during encryption.
for (t = 1; t < rounds; t++) {
    if (decrypt) {
        subshift(&a->round_key[t - 1], 0, inv_sbox);
        mix(&a->round_key[t - 1], dec_multbl, 3, 1);
    } else {
        subshift(&a->round_key[t - 1], 2, sbox);
        mix(&a->round_key[t - 1], enc_multbl, 1, 3);
    }
    if (t < rounds - 1) {
        memcpy(tk[t % KC], a->round_key[t - 1].u8, 4);
    }
    if (t == rounds - 1) {
        memcpy(a->round_key[t].u8, tk[t % KC], 4);
    }
    if (decrypt) {
        a->round_key[t].u8[0] ^= rcon[rconpointer];
        rconpointer = (rconpointer + 1) % 10;
    } else {
        a->round_key[t].u8[0] ^= rcon[rconpointer];
        rconpointer = (rconpointer + 1) % 10;
    }
}
if (decrypt) {
    for (t = rounds - 1; t > 0; t--) {
        subshift(&a->round_key[t], 0, inv_sbox);
        mix(&a->round_key[t], dec_multbl, 3, 1);
    }
} else {
    for (t = rounds - 1; t > 0; t--) {
        subshift(&a->round_key[t], 2, sbox);
        mix(&a->round_key[t], enc_multbl, 1, 3);
    }
}