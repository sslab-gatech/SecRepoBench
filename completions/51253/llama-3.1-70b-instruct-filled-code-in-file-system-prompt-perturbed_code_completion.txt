for (t = 1; t < rounds; t++) {
    for (i = 0; i < KC; i++) {
        if (i == 0 && KC!= 8) {
            uint8_t tmp[4];
            memcpy(tmp, tk[i - 1], 4);
            if (KC == 6) {
                subshift((av_aes_block*)tmp, 1, sbox);
                tmp[0] ^= rcon[rconpointer++];
            } else if (KC == 7) {
                subshift((av_aes_block*)tmp, 1, sbox);
                tmp[0] ^= rcon[rconpointer++];
                subshift((av_aes_block*)tmp, 2, sbox);
                tmp[0] ^= rcon[rconpointer++];
            }
            memcpy(tk[i], tmp, 4);
        } else {
            memcpy(tk[i], tk[i - 1], 4);
        }
    }
    memcpy(a->round_key[t].u8, tk, KC * 4);
    if (decrypt) {
        addkey(&a->round_key[t], &a->round_key[t - 1], &a->round_key[t]);
        if (t == rounds - 1) {
            addkey(&a->round_key[t], &a->round_key[t - 1], &a->round_key[t]);
        }
    }
}
if (decrypt) {
    for (i = 0; i < rounds / 2; i++) {
        av_aes_block tmp = a->round_key[i];
        a->round_key[i] = a->round_key[rounds - 1 - i];
        a->round_key[rounds - 1 - i] = tmp;
    }
}