for (i = KC; i < (rounds + 1) * 4; i++) {
        int j;
        if (i % KC == 0) {
            rconpointer = (i / KC) - 1;
            if (rconpointer < FF_ARRAY_ELEMS(rcon)) { // Ensure rconpointer is within bounds
                t = sbox[tk[(i - 1) & 3][0] ^ rcon[rconpointer]];
            } else {
                return AVERROR(EINVAL); // Handle out-of-bounds rconpointer
            }

            for (j = 1; j < 4; j++) {
                int idx = (i - 1 + j) & 3;
                if (idx < 0 || idx >= 4) { // Check index bounds
                    return AVERROR(EINVAL);
                }
                t ^= sbox[tk[idx][0]];
            }

        } else if (KC > 6 && i % KC == 4) {
            for (j = 0; j < 4; j++) {
                int idx = (i - 4 + j) & 3;
                if (idx < 0 || idx >= 4) { // Check index bounds
                    return AVERROR(EINVAL);
                }
                t = sbox[tk[idx][0]];
                if (((i - 4 + j) & 3) < FF_ARRAY_ELEMS(tk) && ((i + j) & 3) < FF_ARRAY_ELEMS(tk)) {
                    tk[(i + j) & 3][0] = tk[(i - 4 + j) & 3][0] ^ t;
                }
            }
            continue;
        } else {
            t = tk[(i - 1) & 3][0];
        }

        for (j = 0; j < 4; j++) {
            int idx1 = (i - KC + j) & 3;
            int idx2 = (i + j) & 3;
            if (idx1 < 0 || idx1 >= 4 || idx2 < 0 || idx2 >= 4) { // Check index bounds
                return AVERROR(EINVAL);
            }
            tk[idx2][0] = tk[idx1][0] ^ t;
        }

        if (i < 4 * (rounds + 1)) {
            int round_idx = i / 4;
            if (round_idx >= 0 && round_idx < rounds + 1) {
                memcpy(a->round_key[round_idx].u8, tk, 16);
            }
        }
    }


    if (decrypt) {
        for (i = 1; i < rounds; i++) {
            inv_subshiftrows(a->round_key[i].u8);
            inv_mixcolumns(a->round_key[i].u8);
        }
    } else {
        for (i = 1; i < rounds; i++) {
            uint8_t tmp[16];
            memcpy(tmp, a->round_key[i].u8, 16);
            memcpy(a->round_key[i].u8, a->round_key[rounds - i].u8, 16);
            memcpy(a->round_key[rounds - i].u8, tmp, 16);
        }
    }