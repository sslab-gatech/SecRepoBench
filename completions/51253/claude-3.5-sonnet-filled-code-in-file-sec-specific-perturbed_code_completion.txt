for (i = KC; i < (rounds + 1) * 4; i++) {
    uint32_t temp = tk[i-1];
    if (i % KC == 0) {
        temp = (sbox[temp >> 24] << 24) |
               (sbox[(temp >> 16) & 0xff] << 16) |
               (sbox[(temp >>  8) & 0xff] <<  8) |
                sbox[temp & 0xff];
        temp ^= rcon[rconpointer++] << 24;
    } else if (KC > 6 && i % KC == 4) {
        temp = (sbox[temp >> 24] << 24) |
               (sbox[(temp >> 16) & 0xff] << 16) |
               (sbox[(temp >>  8) & 0xff] <<  8) |
                sbox[temp & 0xff];
    }

    tk[i % 8] = tk[(i - KC) % 8] ^ temp;
    
    if (i % 4 == 0 && i / 4 < FF_ARRAY_ELEMS(a->round_key)) {
        a->round_key[i / 4].u32[0] = AV_RB32(tk + (i % 8));
        a->round_key[i / 4].u32[1] = AV_RB32(tk + ((i + 1) % 8));
        a->round_key[i / 4].u32[2] = AV_RB32(tk + ((i + 2) % 8));
        a->round_key[i / 4].u32[3] = AV_RB32(tk + ((i + 3) % 8));
    }
}

if (decrypt) {
    for (i = 1; i < rounds; i++) {
        subshift(&a->round_key[i], 0, sbox);
        mix(a->round_key + i, dec_multbl, 1, 3);
    }
} else {
    for (i = 0; i < (rounds + 1) / 2; i++) {
        FFSWAP(av_aes_block, a->round_key[i], a->round_key[rounds - i]);
    }
}