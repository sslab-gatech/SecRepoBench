for (i = KC; i < (rounds + 1) * 4; i++) {
    uint32_t temp = tk[i-1];
    if (i % KC == 0) {
        temp = (sbox[temp >> 24] << 24) |
               (sbox[(temp >> 16) & 0xff] << 16) |
               (sbox[(temp >>  8) & 0xff] <<  8) |
                sbox[temp & 0xff];
        temp ^= rcon[rconpointer++] << 24;
    } else if (KC > 6 && i % KC == 4) {
        temp = (sbox[temp >> 24] << 24) |
               (sbox[(temp >> 16) & 0xff] << 16) |
               (sbox[(temp >>  8) & 0xff] <<  8) |
                sbox[temp & 0xff];
    }
    tk[i % KC] ^= temp;
    memcpy(a->round_key[i / 4].u8 + (i % 4) * 4, tk[i % KC], 4);
}

if (decrypt) {
    for (i = 1; i < rounds; i++) {
        subshift(&a->round_key[i], 0, sbox);
        mix(a->round_key + i, dec_multbl, 1, 3);
    }
} else {
    for (i = 0; i < (rounds + 1) / 2; i++) {
        FFSWAP(av_aes_block, a->round_key[i], a->round_key[rounds - i]);
    }
}