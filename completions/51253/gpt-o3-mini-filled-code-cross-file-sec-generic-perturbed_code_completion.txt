{
    int i, j;
    uint8_t rcon_val = 1;
    int total_words = (rounds + 1) * 4;

    /* Key expansion */
    for (i = KC; i < total_words; i++) {
        int idx = i % KC;
        if (i % KC == 0) {
            uint8_t temp[4];
            temp[0] = sbox[ tk[KC - 1][1] ];
            temp[1] = sbox[ tk[KC - 1][2] ];
            temp[2] = sbox[ tk[KC - 1][3] ];
            temp[3] = sbox[ tk[KC - 1][0] ];
            temp[0] ^= rcon_val;
            rcon_val = (uint8_t)((rcon_val << 1) ^ ((rcon_val & 0x80) ? 0x1B : 0));
            for (j = 0; j < 4; j++)
                tk[idx][j] ^= temp[j];
        } else if (KC > 6 && (i % KC == 4)) {
            for (j = 0; j < 4; j++)
                tk[idx][j] ^= sbox[ tk[idx][j] ];
        } else {
            for (j = 0; j < 4; j++)
                tk[idx][j] ^= tk[(i - KC) % KC][j];
        }
        memcpy(a->round_key[i / 4].u8 + ((i % 4) * 4), tk[idx], 4);
    }

    /* Define helper macros for multiplication in GF(2^8) */
#define xtime(x) ((uint8_t)(((x) << 1) ^ (((x) & 0x80) ? 0x1B : 0)))
#define MUL9(x)  ( xtime(xtime(xtime(x))) ^ (x) )
#define MUL11(x) ( xtime(xtime(xtime(x)) ^ (x)) ^ (x) )
#define MUL13(x) ( xtime(xtime(xtime(x)) ^ xtime(x)) ^ (x) )
#define MUL14(x) ( xtime(xtime(xtime(x)) ^ xtime(x) ^ (x)) )

    /* Adjust round keys */
    if (decrypt) {
        /* For decryption, transform round keys (except first and last) with the inverse mix columns */
        for (i = 1; i < rounds; i++) {
            for (j = 0; j < 4; j++) {
                uint8_t b0 = a->round_key[i].u8[j * 4 + 0];
                uint8_t b1 = a->round_key[i].u8[j * 4 + 1];
                uint8_t b2 = a->round_key[i].u8[j * 4 + 2];
                uint8_t b3 = a->round_key[i].u8[j * 4 + 3];
                a->round_key[i].u8[j * 4 + 0] = MUL14(b0) ^ MUL11(b1) ^ MUL13(b2) ^ MUL9(b3);
                a->round_key[i].u8[j * 4 + 1] = MUL9(b0)  ^ MUL14(b1) ^ MUL11(b2) ^ MUL13(b3);
                a->round_key[i].u8[j * 4 + 2] = MUL13(b0) ^ MUL9(b1)  ^ MUL14(b2) ^ MUL11(b3);
                a->round_key[i].u8[j * 4 + 3] = MUL11(b0) ^ MUL13(b1) ^ MUL9(b2)  ^ MUL14(b3);
            }
        }
    } else {
        /* For encryption, reverse the order of the round keys (except the first one) */
        for (i = 1; i < (rounds + 1) / 2; i++) {
            AVAESRoundKey temp = a->round_key[i];
            a->round_key[i] = a->round_key[rounds - i];
            a->round_key[rounds - i] = temp;
        }
    }
#undef xtime
#undef MUL9
#undef MUL11
#undef MUL13
#undef MUL14
}