for (t = 1; t < rounds; t++) {
        uint8_t *rk = a->round_key[t].u8;
        uint8_t *pk = a->round_key[t - 1].u8;
        if (decrypt) {
            rk[0] = sbox[pk[13]] ^ rcon[rconpointer++];
            rk[1] = sbox[pk[14]];
            rk[2] = sbox[pk[15]];
            rk[3] = sbox[pk[12]];
            rk[4] = pk[0] ^ rk[0];
            rk[5] = pk[1] ^ rk[1];
            rk[6] = pk[2] ^ rk[2];
            rk[7] = pk[3] ^ rk[3];
            rk[8] = pk[4] ^ rk[4];
            rk[9] = pk[5] ^ rk[5];
            rk[10] = pk[6] ^ rk[6];
            rk[11] = pk[7] ^ rk[7];
            rk[12] = pk[8] ^ rk[8];
            rk[13] = pk[9] ^ rk[9];
            rk[14] = pk[10] ^ rk[10];
            rk[15] = pk[11] ^ rk[11];
        } else {
            rk[0] = sbox[pk[13]] ^ rcon[rconpointer++];
            rk[1] = sbox[pk[14]];
            rk[2] = sbox[pk[15]];
            rk[3] = sbox[pk[12]];
            rk[4] = pk[0] ^ rk[0];
            rk[5] = pk[1] ^ rk[1];
            rk[6] = pk[2] ^ rk[2];
            rk[7] = pk[3] ^ rk[3];
            rk[8] = pk[4] ^ rk[4];
            rk[9] = pk[5] ^ rk[5];
            rk[10] = pk[6] ^ rk[6];
            rk[11] = pk[7] ^ rk[7];
            rk[12] = pk[8] ^ rk[8];
            rk[13] = pk[9] ^ rk[9];
            rk[14] = pk[10] ^ rk[10];
            rk[15] = pk[11] ^ rk[11];
        }
    }
    if (decrypt) {
        for (t = 0; t < rounds; t++) {
            memcpy(a->round_key[t].u8, a->round_key[rounds - 1 - t].u8, 16);
        }
    }