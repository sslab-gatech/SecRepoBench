for (i = 1; i <= rounds; i++) {
        uint8_t *rkey = a->round_key[i].u8;
        rkey[0] = sbox[tk[KC - 1][1]] ^ tk[0][0] ^ rcon[rconpointer++];
        rkey[1] = sbox[tk[KC - 1][2]] ^ tk[0][1];
        rkey[2] = sbox[tk[KC - 1][3]] ^ tk[0][2];
        rkey[3] = sbox[tk[KC - 1][0]] ^ tk[0][3];
        for (t = 4; t < KC * 4; t++)
            rkey[t] = tk[t >> 2][t & 3] ^= rkey[t - 4];
        if (KC == 8) {
            for (t = 0; t < 4; t++)
                tk[4][t] ^= sbox[tk[3][t]];
            for (t = 4; t < 8; t++)
                tk[4][t] ^= tk[4][t - 4];
        }
        memcpy(tk, rkey, KC * 4);
    }

    if (decrypt) {
        for (i = 1; i < rounds; i++) {
            subshift(&a->round_key[i], 0, inv_sbox);
            mix(&a->round_key[i], dec_multbl, 1, 3);
        }
    } else {
        for (i = 0; i < rounds / 2; i++) {
            av_aes_block tmp = a->round_key[i];
            a->round_key[i] = a->round_key[rounds - i];
            a->round_key[rounds - i] = tmp;
        }
    }