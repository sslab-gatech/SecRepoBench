for (i = 1; i <= rounds; i++) {
        av_aes_block *round_key = &a->round_key[i];
        memcpy(round_key, &a->round_key[i - 1], sizeof(av_aes_block));

        // Perform the key schedule transformation
        if (i % KC == 0) {
            uint8_t temp[4];
            memcpy(temp, &round_key->u8[12], 4);
            // Rotate and substitute
            uint8_t t = temp[0];
            temp[0] = sbox[temp[1]] ^ rcon[i / KC - 1];
            temp[1] = sbox[temp[2]];
            temp[2] = sbox[temp[3]];
            temp[3] = sbox[t];
            for (int j = 0; j < 4; j++) {
                round_key->u8[j] ^= round_key->u8[j + 4];
                round_key->u8[j + 4] = round_key->u8[j + 4] ^ temp[j];
            }
        } else if (KC > 6 && i % KC == 4) {
            for (int j = 0; j < 4; j++) {
                round_key->u8[j] ^= sbox[round_key->u8[j]];
            }
        }
    }