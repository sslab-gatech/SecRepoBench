for (i = KC; i < (rounds + 1) * 4; i++) {
        int j;
        uint8_t *rk = a->round_key[i].u8;

        memcpy(rk, a->round_key[i - 1].u8, 16);
        if ((i % KC) == 0) {
            t = rk[0];
            for (j = 0; j < 3; j++)
                rk[j] = sbox[rk[j + 1]];
            rk[3] = sbox[t];
            rk[0] ^= rcon[rconpointer++];
        } else if (KC > 6 && (i % KC) == 4) {
            for (j = 0; j < 4; j++)
                rk[j] = sbox[rk[j]];
        }
        for (j = 0; j < 4; j++)
            rk[j] ^= tk[j][i % KC];
    }

    if (decrypt) {
        for (i = 1; i < rounds; i++) {
            uint8_t *rk = a->round_key[i].u8;
            inv_subshiftrows(rk);
            inv_mixcolumns(rk, inv_sbox, dec_multbl);
        }
    } else {
        for (i = 1; i <= rounds; i++)
            a->round_key[i] = a->round_key[rounds * 4 + 4 - 4 * i];
    }