for (i = 0; i < rounds; i++) {
        int j;
        uint8_t tmp[4];
        if (i) {
            for (j = 0; j < 4; j++) {
                tmp[j] = tk[(i - 1) * 4 + j];
            }
            if (i & 3) {
                uint32_t t = AV_RL32(tmp);
                t = sbox[t >> 24] | (sbox[(t >> 16) & 0xFF] << 8) |
                    (sbox[(t >> 8) & 0xFF] << 16) | (sbox[t & 0xFF] << 24);
                memcpy(tmp, &t, 4);
            } else {
                uint8_t rcon = rcon[rconpointer++];
                if (rconpointer > 10)
                    rconpointer = 10;
                tmp[0] ^= rcon;
                tmp[1] ^= 0;
                tmp[2] ^= 0;
                tmp[3] ^= 0;
                for (j = 0; j < 4; j++) {
                    tmp[j] = sbox[tmp[j]];
                }
            }
        }
        for (j = 0; j < 4; j++) {
            tk[i * 4 + j] = tk[(i - 1) * 4 + j] ^ tk[(i - 4) * 4 + j] ^ tmp[j];
        }
        memcpy(a->round_key[i].u8, tk[i * 4], 16);
    }
    if (!decrypt) {
        for (i = 0; i < rounds / 2; i++) {
            uint8_t *t = a->round_key[i].u8;
            a->round_key[i].u8 = a->round_key[rounds - 1 - i].u8;
            a->round_key[rounds - 1 - i].u8 = t;
        }
    }