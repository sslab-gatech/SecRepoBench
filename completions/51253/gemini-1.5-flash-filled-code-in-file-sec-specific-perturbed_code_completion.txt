for (i = KC; i < 4 * rounds; i++) {
        memcpy(&tk[i % KC], &tk[(i - 1) % KC + 1], 3);
        t = tk[i % KC][0];
        tk[i % KC][0] = sbox[tk[i % KC][1]] ^ rcon[rconpointer++];
        tk[i % KC][1] = sbox[tk[i % KC][2]];
        tk[i % KC][2] = sbox[tk[i % KC][3]];
        tk[i % KC][3] = sbox[t];
        for (sidx = 0; sidx < KC; sidx++) {
            a->round_key[i / KC].u8[sidx * 4 + 0] ^= tk[i % KC][0] ^ tk[(i - KC) % KC + sidx][0];
            a->round_key[i / KC].u8[sidx * 4 + 1] ^= tk[i % KC][1] ^ tk[(i - KC) % KC + sidx][1];
            a->round_key[i / KC].u8[sidx * 4 + 2] ^= tk[i % KC][2] ^ tk[(i - KC) % KC + sidx][2];
            a->round_key[i / KC].u8[sidx * 4 + 3] ^= tk[i % KC][3] ^ tk[(i - KC) % KC + sidx][3];
        }
    }
    if (!decrypt) {
        for (i = 0; i < rounds; i++) {
            av_aes_block tmp = a->round_key[i];
            a->round_key[i] = a->round_key[rounds - 1 - i];
            a->round_key[rounds - 1 - i] = tmp;
        }
    }