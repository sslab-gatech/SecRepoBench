for (i = KC; i < 4 * rounds; i++) {
        memcpy(&a->round_key[i / 4].u8[i % 4 * 4], tk[i % KC], 4);
        if (i % KC == 0) {
            t = tk[0][0];
            tk[0][0] = tk[3][0] ^ sbox[t >> 24] ^ rcon[rconpointer++];
            tk[0][1] = tk[3][1] ^ sbox[tk[0][0] >> 24];
            tk[0][2] = tk[3][2] ^ sbox[tk[0][1] >> 24];
            tk[0][3] = tk[3][3] ^ sbox[tk[0][2] >> 24];
        } else if (KC > 6 && i % KC == 4) {
            tk[0][0] = sbox[tk[0][0] >> 24];
            tk[0][1] = sbox[tk[0][1] >> 24];
            tk[0][2] = sbox[tk[0][2] >> 24];
            tk[0][3] = sbox[tk[0][3] >> 24];
        }
        tk[i % KC][0] ^= tk[(i - 1) % KC][0];
        tk[i % KC][1] ^= tk[(i - 1) % KC][1];
        tk[i % KC][2] ^= tk[(i - 1) % KC][2];
        tk[i % KC][3] ^= tk[(i - 1) % KC][3];
    }
    if (!decrypt) {
        for (i = 0; i < rounds; i++) {
            av_aes_block tmp = a->round_key[i];
            a->round_key[i] = a->round_key[rounds - 1 - i];
            a->round_key[rounds - 1 - i] = tmp;
        }
    }