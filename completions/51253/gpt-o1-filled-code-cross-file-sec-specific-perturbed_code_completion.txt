{
    static const uint8_t rcon[15] = {
        0x01, 0x02, 0x04, 0x08, 0x10,
        0x20, 0x40, 0x80, 0x1B, 0x36,
        0x6C, 0xD8, 0xAB, 0x4D, 0x9A
    };

    // Expand the key into round keys
    for (i = KC; i < (rounds + 1) * 4; i++) {
        uint8_t temp[4];
        memcpy(temp, tk[(i - 1) % KC], 4);

        if (!(i % KC)) {
            // Rotate and apply S-box plus Rcon
            uint8_t t0 = temp[0];
            temp[0] = sbox[temp[1]] ^ rcon[rconpointer++];
            temp[1] = sbox[temp[2]];
            temp[2] = sbox[temp[3]];
            temp[3] = sbox[t0];
        } else if (KC == 8 && ((i % KC) == 4)) {
            // Apply S-box for AES-256
            temp[0] = sbox[temp[0]];
            temp[1] = sbox[temp[1]];
            temp[2] = sbox[temp[2]];
            temp[3] = sbox[temp[3]];
        }

        // XOR with word KC away
        tk[i % KC][0] ^= temp[0];
        tk[i % KC][1] ^= temp[1];
        tk[i % KC][2] ^= temp[2];
        tk[i % KC][3] ^= temp[3];

        // Store the result into the round key
        memcpy(a->round_key[i >> 2].u8 + (i & 3) * 4, tk[i % KC], 4);
    }

    // If decryption is requested, modify keys with inverse transformations
    if (decrypt) {
        // Apply inverse mix+sub+shift for each round key except the first and last
        for (i = 1; i < rounds; i++)
            av_aes_inv_round_key(a->round_key[i].u8, sbox, dec_multbl);
    } else {
        // Reverse round key order for forward encryption
        for (i = 1; i < rounds; i++) {
            AVAESBlock tmp = a->round_key[i];
            a->round_key[i] = a->round_key[rounds - i];
            a->round_key[rounds - i] = tmp;
        }
    }
}