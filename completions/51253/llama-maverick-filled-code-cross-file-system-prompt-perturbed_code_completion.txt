for (t = KC; t < (rounds + 1) * 4; t++) {
    uint32_t tmp = AV_RL32(tk + (t - 1) * 4);
    if (t % KC == 0) {
        tmp = AV_RL32(tk + (t - KC) * 4);
        tmp = sbox[tmp & 0xFF] | (sbox[(tmp >> 8) & 0xFF] << 8) |
              (sbox[(tmp >> 16) & 0xFF] << 16) | (sbox[tmp >> 24] << 24);
        tmp = rotl32(tmp, 8) ^ rcon[rconpointer++];
    } else if (KC == 8 && t % KC == 4) {
        tmp = sbox[tmp & 0xFF] | (sbox[(tmp >> 8) & 0xFF] << 8) |
              (sbox[(tmp >> 16) & 0xFF] << 16) | (sbox[tmp >> 24] << 24);
    }
    AV_WL32(tk + t * 4, AV_RL32(tk + (t - KC) * 4) ^ tmp);
}

for (i = 0; i < (rounds + 1) * 4; i++) {
    memcpy(a->round_key[i].u8, tk + i * 4, 4);
}

if (decrypt) {
    for (i = 1; i < rounds; i++) {
        uint8_t *rk = a->round_key[i].u8;
        inv_subshift(rk);
        inv_mix(rk, dec_multbl);
    }
} else {
    for (i = 0; i < (rounds + 1) >> 1; i++) {
        FFSWAP(AVAES_RoundKey, a->round_key[i], a->round_key[rounds - i]);
    }
}