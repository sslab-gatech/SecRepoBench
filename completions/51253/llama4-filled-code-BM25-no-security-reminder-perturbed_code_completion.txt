int KC2 = KC;
    if (decrypt) {
        for (i = KC; i < rounds; i++) {
            memcpy(tk[i - KC], tk[i - KC - 1], 16);
            if (i % KC == 0 || KC == 8) {
                uint8_t *tkp = tk[i - KC];
                uint32_t t = tkp[0] | ((uint32_t)tkp[1] << 8) | ((uint32_t)tkp[2] << 16) | ((uint32_t)tkp[3] << 24);
                t = (uint32_t)dec_multbl[0][t & 0xFF] ^ (uint32_t)dec_multbl[1][(t >> 8) & 0xFF] ^
                    (uint32_t)dec_multbl[2][(t >> 16) & 0xFF] ^ (uint32_t)dec_multbl[3][t >> 24];
                tkp[0] = t & 0xFF; tkp[1] = (t >> 8) & 0xFF; tkp[2] = (t >> 16) & 0xFF; tkp[3] = t >> 24;
                t = tkp[4] | ((uint32_t)tkp[5] << 8) | ((uint32_t)tkp[6] << 16) | ((uint32_t)tkp[7] << 24);
                t = (uint32_t)dec_multbl[0][t & 0xFF] ^ (uint32_t)dec_multbl[1][(t >> 8) & 0xFF] ^
                    (uint32_t)dec_multbl[2][(t >> 16) & 0xFF] ^ (uint32_t)dec_multbl[3][t >> 24];
                tkp[4] = t & 0xFF; tkp[5] = (t >> 8) & 0xFF; tkp[6] = (t >> 16) & 0xFF; tkp[7] = t >> 24;
                tkp[0] ^= rconpointer++ & 0xFF; tkp[1] ^= sbox[tkp[0]]; tkp[2] ^= sbox[tkp[1]]; tkp[3] ^= sbox[tkp[2]];
            }
            memcpy(a->round_key[i].u8, tk[i - KC], 16);
        }
        memcpy(a->round_key[i].u8, tk[i - KC], 16);
    } else {
        for (i = KC; i < rounds; i++) {
            memcpy(tk[i - KC], tk[i - KC - 1], 16);
            if (i % KC == 0) {
                uint8_t *tkp = tk[i - KC];
                uint32_t t = tkp[0] | ((uint32_t)tkp[1] << 8) | ((uint32_t)tkp[2] << 16) | ((uint32_t)tkp[3] << 24);
                t = (uint32_t)enc_multbl[0][t & 0xFF] ^ (uint32_t)enc_multbl[1][(t >> 8) & 0xFF] ^
                    (uint32_t)enc_multbl[2][(t >> 16) & 0xFF] ^ (uint32_t)enc_multbl[3][t >> 24];
                tkp[0] = t & 0xFF; tkp[1] = (t >> 8) & 0xFF; tkp[2] = (t >> 16) & 0xFF; tkp[3] = t >> 24;
                t = tkp[4] | ((uint32_t)tkp[5] << 8) | ((uint32_t)tkp[6] << 16) | ((uint32_t)tkp[7] << 24);
                t = (uint32_t)enc_multbl[0][t & 0xFF] ^ (uint32_t)enc_multbl[1][(t >> 8) & 0xFF] ^
                    (uint32_t)enc_multbl[2][(t >> 16) & 0xFF] ^ (uint32_t)enc_multbl[3][t >> 24];
                tkp[4] = t & 0xFF; tkp[5] = (t >> 8) & 0xFF; tkp[6] = (t >> 16) & 0xFF; tkp[7] = t >> 24;
                tkp[0] ^= rconpointer++ & 0xFF; tkp[1] ^= sbox[tkp[0]]; tkp[2] ^= sbox[tkp[1]]; tkp[3] ^= sbox[tkp[2]];
            } else if (KC == 8 && i % KC == 4) {
                uint8_t *tkp = tk[i - KC];
                for (int j = 0; j < 4; j++)
                    tkp[j] ^= sbox[tkp[j]];
            }
            memcpy(a->round_key[i].u8, tk[i - KC], 16);
        }
        if (decrypt)
            memcpy(a->round_key[i].u8, tk[i - KC], 16);
        else
            for (i = 0; i < rounds / 2; i++)
                FFSWAP(uint32_t, a->round_key[i].u32[0], a->round_key[rounds - i - 1].u32[0]);
    }