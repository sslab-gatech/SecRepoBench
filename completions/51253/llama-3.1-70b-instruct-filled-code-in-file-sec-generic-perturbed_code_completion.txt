for (t = 1; t < rounds; t++) {
    for (i = 0; i < KC; i++) {
        if (i == 0 && t > 1 && KC!= 8) {
            uint8_t tmp[4];
            memcpy(tmp, tk[i - 1], 4);
            subshift((av_aes_block*)tmp, 1, sbox);
            tk[i - 1][0] ^= rcon[rconpointer++];
            memcpy(a->round_key[t].u8 + i * 4, tmp, 4);
        } else {
            memcpy(a->round_key[t].u8 + i * 4, tk[i - 1], 4);
        }
    }
    for (i = KC; i < 4; i++) {
        memcpy(a->round_key[t].u8 + i * 4, a->round_key[t - 1].u8 + (i - KC) * 4, 4);
    }
    if (decrypt) {
        for (i = 0; i < 4; i++) {
            uint8_t tmp[4];
            memcpy(tmp, a->round_key[t].u8 + i * 4, 4);
            subshift((av_aes_block*)tmp, 0, inv_sbox);
            mix((av_aes_block*)tmp, dec_multbl, 1, 3);
            memcpy(a->round_key[t].u8 + i * 4, tmp, 4);
        }
    }
}
if (!decrypt) {
    for (t = 1; t < rounds; t++) {
        av_aes_block tmp;
        memcpy(&tmp, &a->round_key[t], sizeof(tmp));
        memcpy(&a->round_key[t], &a->round_key[rounds - t], sizeof(tmp));
        memcpy(&a->round_key[rounds - t], &tmp, sizeof(tmp));
    }
}