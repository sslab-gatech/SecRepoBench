for (i = KC; i < 4 * (rounds + 1); i++) {
    uint32_t temp = AV_RN32(tk[i - 1]);
    if (i % KC == 0) {
        temp = AV_RB32(sbox + AV_RL32(temp)) ^ rcon[rconpointer++];
    } else if (KC > 6 && i % KC == 4) {
        temp = AV_RB32(sbox + AV_RL32(temp));
    }
    AV_WN32(tk[i % KC], AV_RN32(tk[i - KC]) ^ temp);
    memcpy(a->round_key[i / 4].u8 + 4 * (i % 4), tk[i % KC], 4);
}

if (decrypt) {
    for (i = 1; i < rounds; i++) {
        subshift(&a->round_key[i], 0, inv_sbox);
        mix(a->round_key + i, dec_multbl, 1, 3);
    }
} else {
    for (i = 0; i <= rounds; i++)
        subshift(&a->round_key[i], 2, sbox);
}

for (i = 0; i < (rounds + 1) / 2; i++) {
    FFSWAP(av_aes_block, a->round_key[i], a->round_key[rounds - i]);
}