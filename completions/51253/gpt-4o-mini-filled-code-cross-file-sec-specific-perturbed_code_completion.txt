for (i = 0; i < rounds; i++) {
        // Ensure the index is within bounds before accessing the array
        if (i < MAX_ROUNDS) {
            // Perform key schedule transformation
            uint8_t temp[4];
            memcpy(temp, &tk[(i - 1) * 4], 4);
            if (decrypt) {
                // Inverse key schedule transformation for decryption
                // Apply inverse S-box and cyclic shift
                temp[0] = sbox[temp[1]];
                temp[1] = sbox[temp[2]];
                temp[2] = sbox[temp[3]];
                temp[3] = sbox[temp[0]];
            } else {
                // Key schedule transformation for encryption
                // Apply S-box and cyclic shift
                temp[0] = inv_sbox[temp[1]];
                temp[1] = inv_sbox[temp[2]];
                temp[2] = inv_sbox[temp[3]];
                temp[3] = inv_sbox[temp[0]];
            }
            // XOR with Rcon
            temp[0] ^= rcon[rconpointer++];
            memcpy(&a->round_key[i + 1].u8, &tk[i * 4], 4);
            for (t = 0; t < 4; t++) {
                tk[i * 4 + t] = tk[(i - KC) * 4 + t] ^ temp[t];
            }
        }
    }