for (i = KC; i <= rounds; i++) {
        t = tk[KC - 1][0];
        tk[i][0] = tk[i - KC][0] ^ sbox[tk[KC - 1][1]] ^ rconpointer;
        tk[i][1] = tk[i - KC][1] ^ sbox[tk[KC - 1][2]];
        tk[i][2] = tk[i - KC][2] ^ sbox[tk[KC - 1][3]];
        tk[i][3] = tk[i - KC][3] ^ sbox[t];
        if (KC == 8) {
            t = tk[i][0];
            tk[i][0] ^= sbox[tk[i][0]];
            tk[i][1] ^= sbox[tk[i][1]];
            tk[i][2] ^= sbox[tk[i][2]];
            tk[i][3] ^= sbox[tk[i][3]];
            tk[i][0] ^= t;
        }
        rconpointer = (rconpointer + 1) & 255;
        a->round_key[i].u32[0] = AV_NE(MKTAG(tk[i][0], tk[i][1], tk[i][2], tk[i][3]),
                                       MKBETAG(tk[i][0], tk[i][1], tk[i][2], tk[i][3]));
        a->round_key[i].u32[1] = AV_NE(MKTAG(tk[i][1], tk[i][2], tk[i][3], tk[i][0]),
                                       MKBETAG(tk[i][1], tk[i][2], tk[i][3], tk[i][0]));
        a->round_key[i].u32[2] = AV_NE(MKTAG(tk[i][2], tk[i][3], tk[i][0], tk[i][1]),
                                       MKBETAG(tk[i][2], tk[i][3], tk[i][0], tk[i][1]));
        a->round_key[i].u32[3] = AV_NE(MKTAG(tk[i][3], tk[i][0], tk[i][1], tk[i][2]),
                                       MKBETAG(tk[i][3], tk[i][0], tk[i][1], tk[i][2]));
    }

    if (decrypt) {
        for (i = 1; i < rounds; i++) {
            subshift(&a->round_key[i]);
            mix(&a->round_key[i], dec_multbl);
        }
    }

    if (a->crypt == aes_encrypt) {
        for (i = 1; i <= rounds / 2; i++) {
            AES_union tmp = a->round_key[i];
            a->round_key[i] = a->round_key[rounds - i];
            a->round_key[rounds - i] = tmp;
        }
    }