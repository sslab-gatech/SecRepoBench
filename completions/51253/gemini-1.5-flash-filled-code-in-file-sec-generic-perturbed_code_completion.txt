for (i = 1; i < rounds; i++) {
        memcpy(&tk[i][0], &tk[i - 1][0], 4);
        if (i % KC == 0) {
            t = tk[i][0] ^ sbox[tk[i][1]] ^ rcon[rconpointer++];
            tk[i][1] = sbox[tk[i][2]];
            tk[i][2] = sbox[tk[i][3]];
            tk[i][3] = sbox[t];
        } else if (KC > 6 && i % KC == 4) {
            t = sbox[tk[i][0]];
            tk[i][1] = sbox[tk[i][1]];
            tk[i][2] = sbox[tk[i][2]];
            tk[i][3] = sbox[tk[i][3]];
        } else {
            t = tk[i][0];
        }
        tk[i][0] = tk[i - 1][0] ^ t;
        tk[i][1] ^= tk[i - 1][1];
        tk[i][2] ^= tk[i - 1][2];
        tk[i][3] ^= tk[i - 1][3];
        memcpy(a->round_key[i].u8, tk[i], 4 * 4);
    }
    if (!decrypt) {
        for (i = 0; i < rounds; i++) {
            av_aes_block tmp;
            memcpy(&tmp, &a->round_key[i], sizeof(tmp));
            memcpy(&a->round_key[i], &a->round_key[rounds - 1 - i], sizeof(tmp));
            memcpy(&a->round_key[rounds - 1 - i], &tmp, sizeof(tmp));
        }
    }