// <MASK>
{
  // Perform a bitwise AND operation with MASK1 to extract the first byte of the needle
  // and the first byte of the text. This is done to handle big-endian architectures.
  bitint needle_first = (bitint)*needle & MASK1;
  bitint text_first = (bitint)*ys & MASK1;

  // If the first bytes of the needle and the text do not match, move to the next byte.
  if (needle_first!= text_first) {
    needle++;
    ys++;
    continue;
  }

  // Perform a bitwise AND operation with MASK2 to extract the second byte of the needle
  // and the second byte of the text. This is done to handle big-endian architectures.
  needle_first = (bitint)*needle & MASK2;
  text_first = (bitint)*ys & MASK2;

  // If the second bytes of the needle and the text do not match, move to the next byte.
  if (needle_first!= text_first) {
    needle++;
    ys++;
    continue;
  }

  // Perform a bitwise AND operation with MASK3 to extract the third byte of the needle
  // and the third byte of the text. This is done to handle big-endian architectures.
  needle_first = (bitint)*needle & MASK3;
  text_first = (bitint)*ys & MASK3;

  // If the third bytes of the needle and the text do not match, move to the next byte.
  if (needle_first!= text_first) {
    needle++;
    ys++;
    continue;
  }

  // If the first three bytes of the needle and the text match, check the remaining bytes.
  if (memcmp(needle, ys, m - 3) == 0) {
    // If the remaining bytes match, return the index of the start of the match.
    return (mrb_int)(ys - ys);
  }

  // If the remaining bytes do not match, move to the next byte.
  needle++;
  ys++;
}