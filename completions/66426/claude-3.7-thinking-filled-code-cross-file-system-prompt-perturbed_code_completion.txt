const unsigned char *s0 = (const unsigned char*)ys;
  const unsigned char *pat = (const unsigned char*)needle;
  mrb_int i = 0;
  
  if (m <= 0 || n < m) {
    return -1;
  }
  
  unsigned char first_ch = pat[0];
  
  // Process the text in blocks of sizeof(bitint) bytes
  for (; i <= n - sizeof(bitint); i += sizeof(bitint)) {
    bitint block;
    memcpy(&block, s0 + i, sizeof(bitint));
    
    // Create a pattern with the first character in each byte
    bitint pattern = 0;
    for (size_t j = 0; j < sizeof(bitint); j++) {
      pattern |= ((bitint)first_ch << (j * 8));
    }
    
    // Apply SWAR technique
    bitint xor_result = block ^ pattern;
    bitint has_zero = ((xor_result - MASK1) & ~xor_result & MASK3);
    
    if (has_zero) {
      // We found a potential match, now check each position
      for (size_t j = 0; j < sizeof(bitint); j++) {
        if (i + j + m > n) break;
        if (s0[i + j] == first_ch && (m == 1 || memcmp(s0 + i + j + 1, pat + 1, m - 1) == 0)) {
          return (mrb_int)(i + j);
        }
      }
    }
  }
  
  // Check remaining bytes traditionally
  for (; i <= n - m; i++) {
    if (s0[i] == first_ch && (m == 1 || memcmp(s0 + i + 1, pat + 1, m - 1) == 0)) {
      return (mrb_int)i;
    }
  }