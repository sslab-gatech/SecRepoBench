// <MASK>
  bitint *x = (bitint*)ys;
  bitint *e = (bitint*)(ys + n - m + 1);
  bitint *p = (bitint*)needle;
  bitint *q = (bitint*)needle;
  bitint needle_bit = *p++;
  needle_bit |= (*p++) << 8;
  needle_bit |= (*p++) << 16;
  needle_bit |= (*p++) << 24;
  if (MRB_64BIT) {
    needle_bit |= (*p++) << 32;
    needle_bit |= (*p++) << 40;
    needle_bit |= (*p++) << 48;
    needle_bit |= (*p++) << 56;
  }

  bitint mask = MASK1;
  bitint mask2 = MASK2;
  bitint mask3 = MASK3;
  bitint mask4 = MASK4;

  if (MRB_ENDIAN_BIG) {
    if (MRB_64BIT) {
      mask4 = 0x0000000000000080ull;
    } else {
      mask4 = 0x00000080ul;
    }
  }

  for (; x < e; x++) {
    bitint y = *x;
    if ((y & mask3) == (needle_bit & mask3)) {
      bitint z = y ^ needle_bit;
      if ((z & mask2) == 0 && ((y | mask2) == (needle_bit | mask2))) {
        const char *match = (const char*)x;
        if (memcmp(match, needle, m) == 0) {
          return (mrb_int)(match - ys);
        }
      }
    }
  }

  return -1;
}