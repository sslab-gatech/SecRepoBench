if (m <= 0) return 0;
if (m > n) return -1;

// Set up variables for the fallback algorithm
size_t i = 0;
const char *s0 = ys;

// Only use SWAR for small patterns
if (m <= sizeof(bitint)) {
  // First character of the needle
  unsigned char first = (unsigned char)needle[0];
  
  // Process haystack in chunks of bitint size
  while (i + sizeof(bitint) <= n) {
    bitint chunk;
    memcpy(&chunk, ys + i, sizeof(bitint));
    
    // SWAR technique to identify potential matches
    bitint v = chunk ^ (MASK1 * first);
    v = ((v & MASK2) + MASK2) & MASK3;
    
    if (v) {
      // Found potential matches, check each one
      unsigned int j;
      for (j = 0; j < sizeof(bitint); j++) {
        if (ys[i + j] == first && i + j + m <= n) {
          if (memcmp(ys + i + j, needle, m) == 0) {
            return (mrb_int)(i + j);
          }
        }
      }
    }
    
    i += sizeof(bitint);
  }
  
  // Move s0 to the position after the chunks processed by SWAR
  s0 = ys + i;
}