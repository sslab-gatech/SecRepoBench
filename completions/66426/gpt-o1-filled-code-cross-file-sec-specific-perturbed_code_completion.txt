mrb_int i;
  const char *s0 = ys;
  mrb_int limit;

  /* Validate inputs to avoid out-of-bounds issues */
  if (m <= 0 || n < m) {
    return -1;
  }

  /* Quick check for single-byte needle */
  if (m == 1) {
    const char *pos = (const char *)memchr(ys, needle[0], n);
    if (pos) return (mrb_int)(pos - ys);
    return -1;
  }

  /* Use SWAR technique on chunks of text if pattern length > 1 */
  limit = n - m;
  for (i = 0; i + (mrb_int)sizeof(bitint) <= n; i += (mrb_int)sizeof(bitint)) {
    bitint block;
    /* Safely copy a chunk into 'block' */
    memcpy(&block, s0 + i, sizeof(block));

#if defined(MRB_ENDIAN_BIG)
    /* For big-endian, convert to host order if needed */
  #ifdef MRB_64BIT
    block = __builtin_bswap64(block);
  #else
    block = __builtin_bswap32(block);
  #endif
#endif

    /* XOR with repeated first character of needle to find potential matches */
    block ^= ((bitint)(unsigned char)needle[0]) * MASK1;
    /* Apply SWAR mask to isolate matching bytes */
    bitint eq = ~(((block & MASK2) + MASK1) | block | MASK3);

    /* Check each potential match within this chunk */
    while (eq) {
      bitint bitpos = eq & -eq; /* isolate lowest set bit */
#if defined(MRB_64BIT)
      int offset = __builtin_ctzll(bitpos) / 8;
#else
      int offset = __builtin_ctz(bitpos) / 8;
#endif

#if defined(MRB_ENDIAN_BIG)
      /* adjust offset for big-endian: highest byte is offset 0 */
      offset = (int)(sizeof(bitint) - 1 - offset);
#endif

      mrb_int pos = i + offset;
      if (pos + m <= n && memcmp(s0 + pos, needle, m) == 0) {
        return pos;
      }
      eq ^= bitpos; /* clear the bit we just processed */
    }

    /* If the remaining text is too short for another full chunk, break */
    if (i + m >= n) break;
  }