mrb_int i = 0;

if (m <= 0) return 0;
if (n < m) return -1;

// If the pattern is too long, skip SWAR and go to the fallback
if (m > sizeof(bitint)) goto fallback;

// For single-character patterns, use a simple search
if (m == 1) {
  const char *p = (const char *)memchr(ys, *needle, n);
  if (p) return (mrb_int)(p - ys);
  return -1;
}

// For patterns of length 2 to sizeof(bitint), use SWAR
const unsigned char first_char = (unsigned char)needle[0];
const bitint *aligned_data = (const bitint *)ys;
const size_t aligned_length = n / sizeof(bitint);

// Create a word with first_char repeated
bitint first_char_word = 0;
for (size_t j = 0; j < sizeof(bitint); j++) {
  first_char_word = (first_char_word << 8) | first_char;
}

// Process full words
for (i = 0; i < aligned_length; i++) {
  bitint word = aligned_data[i];
  
  // Check for bytes that match the first character
  bitint xor_result = word ^ first_char_word;
  bitint has_match = ((xor_result - MASK1) & ~xor_result & MASK3);
  
  if (has_match) {  // At least one byte matches first_char
    for (size_t j = 0; j < sizeof(bitint); j++) {
      size_t idx = i * sizeof(bitint) + j;
      if (idx + m <= n && 
          ys[idx] == first_char && 
          memcmp(ys + idx + 1, needle + 1, m - 1) == 0) {
        return (mrb_int)idx;
      }
    }
  }
}

fallback: