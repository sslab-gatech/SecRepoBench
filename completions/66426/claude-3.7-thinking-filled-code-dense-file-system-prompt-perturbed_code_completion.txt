const char *s0 = ys;
  mrb_int i = 0;

  // Early return conditions
  if (m > n) return -1;
  
  // For patterns that fit within a bitint
  if (m <= sizeof(bitint)) {
    uint8_t first = (uint8_t)needle[0];
    
    // Process in chunks of sizeof(bitint)
    for (; i <= n - sizeof(bitint); i += sizeof(bitint)) {
      bitint chunk;
      memcpy(&chunk, ys + i, sizeof(bitint));
      
      // Create a mask with the first byte repeated in every byte position
      bitint firstMask = first * MASK1;
      
      // XOR each byte with the first byte of the needle
      // If a byte matches, the XOR result will be 0 for that byte
      bitint xor_result = chunk ^ firstMask;
      
      // Check if any byte in the chunk is equal to the first byte
      bitint has_zero = (xor_result - MASK1) & (~xor_result) & MASK3;
      
      if (has_zero) {
        // Determine the position of the matching byte
        for (mrb_int j = 0; j < sizeof(bitint); j++) {
          if (i + j + m <= n && *(ys + i + j) == first) {
            if (memcmp(ys + i + j + 1, needle + 1, m - 1) == 0) {
              return i + j;
            }
          }
        }
      }
    }
  }

  // Set the starting point for the fallback method
  s0 = ys + i;