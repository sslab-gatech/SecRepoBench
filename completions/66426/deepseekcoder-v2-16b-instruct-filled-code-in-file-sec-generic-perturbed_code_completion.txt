char *p = RSTR_PTR(s);

  if (len > 0) {
    if (ISLOWER(p[0])) {
      p[0] = toupper(p[0]);
      modify = TRUE;
    }
    for (int i = 1; i < len; i++) {
      if (ISUPPER(p[i])) {
        p[i] = tolower(p[i]);
        modify = TRUE;
      }
    }
  }
  return modify ? str : mrb_nil_value();
}

/* 15.2.10.5.9  */
/*
 *  call-seq:
 *     str.capitalize   => new_str
 *
 *  Returns a copy of <i>str</i> with the first character converted to
 *  uppercase and the remainder to lowercase.
 *
 *     "hello".capitalize   #=> "Hello"
 *     "HELLO".capitalize   #=> "Hello"
 *     "123ABC".capitalize  #=> "123abc"
 */
static mrb_value
mrb_str_capitalize(mrb_state *mrb, mrb_value str)
{
  struct RString *s = mrb_str_ptr(str);
  struct RString *dup = str_new(mrb, 0, 0);

  if (RSTR_LEN(s) > 0) {
    char *p = RSTR_PTR(s);
    char *dp = RSTR_PTR(dup);
    if (ISLOWER(p[0])) {
      dp[0] = toupper(p[0]);
    }
    else {
      dp[0] = tolower(p[0]);
    }
    memcpy(dp+1, p+1, RSTR_LEN(s));
    RSTR_SET_LEN(dup, RSTR_LEN(s));
    dp[RSTR_LEN(dup)] = '\0';
  }
  RSTR_COPY_SINGLE_BYTE_FLAG(dup, s);
  return mrb_obj_value(dup);
}

/* 15.2.10.5.10 */
/*
 *  call-seq:
 *     str.casecmp(other_str)   => -1, 0, 1
 *
 *  Case-insensitive comparison of <i>str</i> with <i>other_str</i>.
 *
 *  If <i>str</i> <code><=></code> <i>other_str</i> returns <code>0</code>, so
 *  would this method. If returning <code>0</code> is not appropriate for your
 *  usage, you should use <code>String#casecmp?</code> instead and compare the
 *  return value with <code>0</code> yourself.
 *
 *     "abcdef".casecmp("abcde")     #=> 1
 *     "aBcDeF".casecmp("abcdef")    #=> 0
 *     "abcdef".casecmp("abcdefg")   #=> -1
 *     "abcdef".casecmp("ABCDEF")    #=> 0
 */
static mrb_value
mrb_str_casecmp(mrb_state *mrb, mrb_value str1)
{
  mrb_value str2 = mrb_get_arg1(mrb);
  int result;

  if (!mrb_string_p(str2)) {
    return mrb_nil_value();
  }
  else {
    result = strcasecmp(RSTRING_PTR(str1), RSTRING_PTR(str2));
  }
  if (result < 0) return mrb_int_value(mrb, -1);
  if (result > 0) return mrb_int_value(mrb, 1);
  return mrb_int_value(mrb, 0);
}

/* 15.2.10.5.11 */
/*
 *  call-seq:
 *     str.casecmp?(other_str)   => true or false
 *
 *  Case-insensitive comparison of <i>str</i> with <i>other_str</i>.
 *  Returns <code>true</code> if <i>str</i> and <i>other_str</i> are
 *  equal, case-insensitively.
 *
 *     "abcdef".casecmp?("abcde")     #=> false
 *     "aBcDeF".casecmp?("abcdef")    #=> true
 *     "abcdef".casecmp?("abcdefg")   #=> false
 *     "abcdef".casecmp?("ABCDEF")    #=> true
 */
static mrb_value
mrb_str_casecmp_p(mrb_state *mrb, mrb_value str1)
{
  mrb_value str2 = mrb_get_arg1(mrb);

  if (!mrb_string_p(str2)) {
    return mrb_false_value();
  }
  else {
    return mrb_bool_value(strcasecmp(RSTRING_PTR(str1), RSTRING_PTR(str2)) == 0);
  }
}

/* 15.2.10.5.12 */
/*
 *  call-seq:
 *     str.center(width, padstr=' ')   => new_str
 *
 *  Centers <i>str</i> in <i>width</i>.  If <i>width</i> is greater than the
 *  length of <i>str</i>, pads with <i>padstr</i>; otherwise, returns <i>str</i>.
 *
 *     "hello".center(4)         #=> "hello"
 *     "hello".center(20)        #=> "       hello        "
 *     "hello".center(20, '123') #=> "1231231hello12312312"
 */
static mrb_value
mrb_str_center(mrb_state *mrb, mrb_value str, mrb_value width, mrb_value padstr)
{
  mrb_int w, plen;
  struct RString *s = mrb_str_ptr(str);
  const char *pstr = RSTRING_PTR(padstr);
  mrb_int slen = RSTR_LEN(s);

  w = mrb_as_int(mrb, width);
  if (w <= slen) {
    return mrb_str_dup(mrb, str);
  }
  plen = w - slen;
  struct RString *dup = str_new(mrb, 0, w);
  char *dp = RSTR_PTR(dup);
  mrb_int i;

  for (i = 0; i < plen / 2; i++) {
    dp[i] = pstr[i % RSTR_LEN(padstr)];
  }
  memcpy(dp + i, RSTRING_PTR(s), slen);
  i += slen;
  for (; i < w; i++) {
    dp[i] = pstr[i - slen - plen / 2];
  }
  dp[w] = '\0';
  RSTR_SET_LEN(dup, w);
  RSTR_COPY_SINGLE_BYTE_FLAG(dup, s);
  return mrb_obj_value(dup);
}

/* 15.2.10.5.13 */
/*
 *  call-seq:
 *     str.chars   => array
 *
 *  Returns an array of the characters in <i>str</i>.
 *
 *     "hello".chars   #=> ["h", "e", "l", "l", "o"]
 */
static mrb_value
mrb_str_chars(mrb_state *mrb, mrb_value str)
{
  struct RString *s = mrb_str_ptr(str);
  mrb_int len = RSTR_LEN(s);
  mrb_value *ary;
  mrb_int i;

  ary = (mrb_value*)mrb_malloc(mrb, len * sizeof(mrb_value));
  for (i = 0; i < len; i++) {
    ary[i] = mrb_str_new_cstr(mrb, s->as.heap.ptr + i, 1);
  }
  return mrb_ary_new_from_values(mrb, len, ary);
}

/* 15.2.10.5.14 */
/*
 *  call-seq:
 *     str.chomp([separator=$/])   => new_str
 *
 *  Returns a new <code>String</code> with the given record separator removed
 *  from the end of <i>str</i> (if present). If <code>$/</code> has not been
 *  changed from the default, then it removes carriage return followed by
 *  newline (`\r\n`).
 *
 *     "hello".chomp         #=> "hello"
 *     "hello\n".chomp       #=> "hello"
 *     "hello\r\n".chomp     #=> "hello"
 *     "hello\n\r".chomp     #=> "hello\n"
 *     "hello\r".chomp       #=> "hello"
 *     "hello \n".chomp      #=> "hello "
 *     "hello \r\n".chomp    #=> "hello "
 *
 *  If <i>separator</i> is given and is not a newline character, then
 *  <i>separator</i> is removed from the end of the string.
 *
 *     "hello".chomp("llo")  #=> "he"
 */
static mrb_value
mrb_str_chomp(mrb_state *mrb, mrb_value str, mrb_value sep)
{
  struct RString *s = mrb_str_ptr(str);
  const char *sepstr = RSTRING_PTR(sep);
  mrb_int seplen = RSTR_LEN(sep);
  mrb_int len = RSTR_LEN(s);
  const char *p = RSTR_PTR(s) + len - seplen;

  if (seplen == 0) {
    if (len > 0 && s->as.heap.ptr[len - 1] == '\n') {
      if (len > 1 && s->as.heap.ptr[len - 2] == '\r') {
        len -= 2;
      }
      else {
        len -= 1;
      }
    }
  }
  else {
    if (len >= seplen && memcmp(p, sepstr, seplen) == 0) {
      len -= seplen;
    }
  }
  struct RString *dup = str_new(mrb, 0, len);
  memcpy(RSTR_PTR(dup), RSTR_PTR(s), len);
  RSTR_SET_LEN(dup, len);
  RSTR_COPY_SINGLE_BYTE_FLAG(dup, s);
  return mrb_obj_value(dup);
}

/* 15.2.10.5.15 */
/*
 *  call-seq:
 *     str.chomp!([separator=$/])   => str or nil
 *
 *  Modifies <i>str</i> in place as described for <code>String#chomp</code>,
 *  returning <i>str</i>, or <code>nil</code> if no modifications were made.
 */
static mrb_value
mrb_str_chomp_bang(mrb_state *mrb, mrb_value str, mrb_value sep)
{
  struct RString *s = mrb_str_ptr(str);
  const char *sepstr = RSTRING_PTR(sep);
  mrb_int seplen = RSTR_LEN(sep);
  mrb_int len = RSTR_LEN(s);
  const char *p = RSTR_PTR(s) + len - seplen;

  if (seplen == 0) {
    if (len > 0 && s->as.heap.ptr[len - 1] == '\n') {
      if (len > 1 && s->as.heap.ptr[len - 2] == '\r') {
        len -= 2;
      }
      else {
        len -= 1;
      }
      if (len == 0) return mrb_nil_value();
    }
  }
  else {
    if (len >= seplen && memcmp(p, sepstr, seplen) == 0) {
      len -= seplen;
    }
    if