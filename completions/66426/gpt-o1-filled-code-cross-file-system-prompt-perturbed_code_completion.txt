long i;
  const char *s0 = ys;

  if (m <= 0) return -1;
  if (n < m) return -1;

  /* Prepare a repeated pattern for the first byte of the needle */
  bitint c = (unsigned char)needle[0];
#if defined(MRB_64BIT)
  c |= (c << 8);
  c |= (c << 16);
  c |= (c << 32);
#else
  c |= (c << 8);
  c |= (c << 16);
#endif

  /* SWAR-based scanning over the text in chunks */
  for (i = 0; i + (long)sizeof(bitint) <= n; i += sizeof(bitint)) {
    bitint v = *(const bitint*)(ys + i);
    bitint x = v ^ c;
    x = (x - MASK1) & ~x & MASK2;
    if (x) {
      /* Check each byte within the chunk for a potential match */
      for (int shift = 0; shift < (int)sizeof(bitint); shift++) {
#if defined(MRB_ENDIAN_BIG)
        int idx = (int)sizeof(bitint) - 1 - shift;
#else
        int idx = shift;
#endif
        if (x & (MASK4 << (8 * idx))) {
          long pos = i + idx;
          /* Verify the full needle match if there's enough room */
          if (pos + m <= n && memcmp(ys + pos, needle, m) == 0) {
            return pos;
          }
        }
      }
    }
  }