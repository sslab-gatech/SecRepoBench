long i = 0;
  if (m <= 0 || m > n) return -1;

  bitint pat_c = (unsigned char)needle[0];
  bitint pattern = pat_c * MASK1;

  while (i + (long)sizeof(bitint) <= n - m + 1) {
    bitint block;
    memcpy(&block, ys + i, sizeof(block));
#if defined(MRB_ENDIAN_BIG)
#if defined(MRB_64BIT)
    /* 64-bit byte swap for big-endian */
    block = ((block & 0x00000000FFFFFFFFULL) << 32) | ((block & 0xFFFFFFFF00000000ULL) >> 32);
    block = ((block & 0x0000FFFF0000FFFFULL) << 16) | ((block & 0xFFFF0000FFFF0000ULL) >> 16);
    block = ((block & 0x00FF00FF00FF00FFULL) << 8)  | ((block & 0xFF00FF00FF00FF00ULL) >> 8);
#else
    /* 32-bit byte swap for big-endian */
    block = ((block & 0x0000FFFFUL) << 16) | ((block & 0xFFFF0000UL) >> 16);
    block = ((block & 0x00FF00FFUL) << 8)  | ((block & 0xFF00FF00UL) >> 8);
#endif
#endif

    bitint tmp = block ^ pattern;
    tmp = (tmp - MASK1) & ~tmp & MASK3;
    if (tmp != 0) {
      /* Check each possible match within this chunk */
      for (int off = 0; off < (int)sizeof(block); off++) {
        if (i + off + m > n) break;
        if (ys[i + off] == needle[0] &&
            memcmp(ys + i + off + 1, needle + 1, m - 1) == 0) {
          return i + off;
        }
      }
    }
    i += sizeof(block);
  }