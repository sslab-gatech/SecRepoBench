bitint *s0 = (bitint*)ys;
bitint *s1 = (bitint*)(ys + (n & ~(sizeof(bitint) - 1)));
bitint *e = (bitint*)(ys + n);
bitint x = 0;
int i;

for (i = 0; i < m; i++) {
  x |= (MASK1 * (needle[i] & 0xff)) >> (i * 8);
}

for (; s0 < s1; s0++) {
  bitint y = *s0;
  bitint z = ((y & MASK2) - x) & MASK3;
  if ((z & MASK4)!= 0) {
    // Check if the pattern matches at the current position
    int j;
    for (j = 0; j < sizeof(bitint); j++) {
      if ((z >> (j * 8)) & 0x80) {
        if (memcmp(ys + (s0 - (bitint*)ys) * sizeof(bitint) + j, needle, m) == 0) {
          return (mrb_int)((s0 - (bitint*)ys) * sizeof(bitint) + j - ys);
        }
      }
    }
  }
}