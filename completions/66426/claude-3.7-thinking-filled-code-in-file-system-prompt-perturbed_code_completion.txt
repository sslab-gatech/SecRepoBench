// Implement a function that performs a search within a byte array using
  // a method inspired by "SIMD within a register" (SWAR) technique.
  // The function takes a pattern and a text, represented as byte arrays, 
  // and tries to find the first occurrence of the pattern in the text.
  // It accounts for both big-endian and little-endian architectures 
  // when processing the bitwise logic to ensure compatibility.
  // The function will return the index of the start of the match if found,
  // or -1 if the pattern is not found within the text.
  const char *s0 = ys;
  
  // Special cases
  if (m == 0) return 0;
  if (n < m) return -1;
  
  // For single-byte needle, use memchr
  if (m == 1) {
    const char *p = (const char*)memchr(ys, *needle, n);
    if (p) return (mrb_int)(p - ys);
    return -1;
  }
  
  // For needles of length 2, use a simple loop
  if (m == 2) {
    for (long i = 0; i <= n - m; i++) {
      if (ys[i] == needle[0] && ys[i+1] == needle[1]) {
        return i;
      }
    }
    return -1;
  }
  
  // For longer needles, use SWAR technique
  // Create a pattern with the first byte repeated
  bitint first = (unsigned char)needle[0];
  first = first * MASK1;
  
  for (long i = 0; i <= n - m && i + sizeof(bitint) <= n; i++) {
    // Load a chunk of text
    bitint chunk;
    memcpy(&chunk, ys + i, sizeof(bitint));
    
    // XOR with the pattern (zeros indicate matches)
    bitint xord = chunk ^ first;
    
    // Check for potential matches using SWAR technique
    if (((xord - MASK1) & ~xord & MASK3) != 0) {
      // Found potential match, check each position
      for (long j = 0; j < sizeof(bitint) && i + j <= n - m; j++) {
        if (ys[i + j] == needle[0] && 
            memcmp(ys + i + j + 1, needle + 1, m - 1) == 0) {
          return i + j;
        }
      }
    }
  }

  // Fallback: check remaining bytes
  i = n - m + 1 - (n - m +