// Implement a function that performs a search within a byte array using
  // a method inspired by "SIMD within a register" (SWAR) technique.
  // The function takes a pattern and a text, represented as byte arrays, 
  // and tries to find the first occurrence of the pattern in the text.
  // It accounts for both big-endian and little-endian architectures 
  // when processing the bitwise logic to ensure compatibility.
  // The function will return the index of the start of the match if found,
  // or -1 if the pattern is not found within the text.

  // <MASK>
  const bitint *needle_u = (const bitint *)needle;
  const bitint *ys_u = (const bitint *)ys;
  const char *s0 = ys;

  if (n >= m) {
    bitint needle_u1 = needle_u[0] ^ ~MASK1;
    bitint needle_u2 = needle_u[1] ^ ~MASK1;
    bitint needle_u3 = needle_u[2] ^ ~MASK1;
    bitint needle_u4 = needle_u[3] ^ ~MASK1;
    if (m == 1) {
      for (const char *p = s0; p + m <= ys + n; p++) {
        if (ys[p] == needle[0]) return (mrb_int)(p - ys);
      }
    } else if (m == 2) {
      for (const char *p = s0; p + m <= ys + n; p++) {
        if (ys[p] == needle[0] && ys[p + 1] == needle[1]) return (mrb_int)(p - ys);
      }
    } else if (m == 3) {
      for (const char *p = s0; p + m <= ys + n; p++) {
        if (ys[p] == needle[0] && ys[p + 1] == needle[1] && ys[p + 2] == needle[2]) return (mrb_int)(p - ys);
      }
    } else if (m == 4) {
      for (const char *p = s0; p + m <= ys + n; p++) {
        if (ys[p] == needle[0] && ys[p + 1] == needle[1] && ys[p + 2] == needle[2] && ys[p + 3] == needle[3]) return (mrb_int)(p - ys);
      }
    } else {
      bitint mask = (bitint)MASK3 >> ((m - 1) * 8);
      bitint needle_u_last = needle_u[m / bitint_size - 1] ^ ~MASK1;
      for (const char *p = s0; p + m <= ys + n; p += bitint_size) {
        bitint ys_u_val = *(const bitint *)(p);
        if ((ys_u_val & mask) == needle_u_last) {
          const char *q = p;
          int match = 1;
          for (int i = 0; i < m; i++) {
            if (ys[q + i] != needle[i]) {
              match = 0;
              break;
            }
          }
          if (match) return (mrb_int)(q - ys);
        }
      }
    }
  }

  return -1;