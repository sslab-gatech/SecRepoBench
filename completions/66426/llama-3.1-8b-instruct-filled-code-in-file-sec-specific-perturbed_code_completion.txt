static inline mrb_int
memsearch_swar(const char *needle, long m, const char *ys, long n)
{
#ifdef MRB_64BIT
#define bitint uint64_t
#define MASK1 0x0101010101010101ull
#define MASK2 0x7f7f7f7f7f7f7f7full
#define MASK3 0x8080808080808080ull
#else
#define bitint uint32_t
#define MASK1 0x01010101ul
#define MASK2 0x7f7f7f7ful
#define MASK3 0x80808080ul
#endif
#if defined(MRB_ENDIAN_BIG)
#ifdef MRB_64BIT
#define MASK4 0x8000000000000000ull
#else
#define MASK4 0x80000000ul
#endif
#else
#define MASK4 0x80
#endif

  // Implement a function that performs a search within a byte array using
  // a method inspired by "SIMD within a register" (SWAR) technique.
  // The function takes a pattern and a text, represented as byte arrays, 
  // and tries to find the first occurrence of the pattern in the text.
  // It accounts for both big-endian and little-endian architectures 
  // when processing the bitwise logic to ensure compatibility.
  // The function will return the index of the start of the match if found,
  // or -1 if the pattern is not found within the text.
  // <MASK>

  if (m > n) return -1;
  else if (m == n) {
    return memcmp(needle, ys, m) == 0? 0 : -1;
  }
  else if (m < 1) {
    return 0;
  }
  else if (m == 1) {
    const char *p = (const char*)memchr(ys, *needle, n);

    if (p) return (mrb_int)(p - ys);
    return -1;
  }

  const char *s0 = ys;
  const char *s1 = ys + (n - m);
  const char *s2 = ys + (n - m + 1);
  const char *s3 = ys + (n - m + 2);
  const char *s4 = ys + (n - m + 3);
  const char *s5 = ys + (n - m + 4);
  const char *s6 = ys + (n - m + 5);
  const char *s7 = ys + (n - m + 6);
  const char *s8 = ys + (n - m + 7);
  const char *s9 = ys + (n - m + 8);
  const char *s10 = ys + (n - m + 9);
  const char *s11 = ys + (n - m + 10);
  const char *s12 = ys + (n - m + 11);
  const char *s13 = ys + (n - m + 12);
  const char *s14 = ys + (n - m + 13);
  const char *s15 = ys + (n - m + 14);

  const char *p = s0;
  const char *e = ys + n;
  for (;p<e;) {
    size_t len = e-p;
    p = (const char*)memchr(p, *needle, len);
    if (p == NULL || len < m) break;
    if (memcmp(p+1, needle+1, m-1) == 0) return (mrb_int)(p - ys);
    p++;
  }

  if (m <= 8) {
    p = s0;
    e = ys + n;
    for (;p<e;) {
      size_t len = e-p;
      p = (const char*)memchr(p, *needle, len);
      if (p == NULL || len < m) break;
      if (memcmp(p+1, needle+1, m-1) == 0) return (mrb_int)(p - ys);
      p++;
    }
  }
  else if (m <= 16) {
    p = s0;
    e = ys + n;
    for (;p<e;) {
      size_t len = e-p;
      p = (const char*)memchr(p, *needle, len);
      if (p == NULL || len < m) break;
      if (memcmp(p+1, needle+1, m-1) == 0) return (mrb_int)(p - ys);
      p++;
    }
    p = s1;
    e = ys + n;
    for (;p<e;) {
      size_t len = e-p;
      p = (const char*)memchr(p, *needle, len);
      if (p == NULL || len < m) break;
      if (memcmp(p+1, needle+1, m-1) == 0) return (mrb_int)(p - ys);
      p++;
    }
  }
  else if (m <= 24) {
    p = s0;
    e = ys + n;
    for (;p<e;) {
      size_t len = e-p;
      p = (const char*)memchr(p, *needle, len);
      if (p == NULL || len < m) break;
      if (memcmp(p+1, needle+1, m-1) == 0) return (mrb_int)(p - ys);
      p++;
    }
    p = s2;
    e = ys + n;
    for (;p<e;) {
      size_t len = e-p;
      p = (const char*)memchr(p, *needle, len);
      if (p == NULL || len < m) break;
      if (memcmp(p+1, needle+1, m-1) == 0) return (mrb_int)(p - ys);
      p++;
    }
  }
  else if (m <= 32) {
    p = s0;
    e = ys + n;
    for (;p<e;) {
      size_t len = e-p;
      p = (const char*)memchr(p, *needle, len);
      if (p == NULL || len < m) break;
      if (memcmp(p+1, needle+1, m-1) == 0) return (mrb_int)(p - ys);
      p++;
    }
    p = s3;
    e = ys + n;
    for (;p<e;) {
      size_t len = e-p;
      p = (const char*)memchr(p, *needle, len);
      if (p == NULL || len < m) break;
      if (memcmp(p+1, needle+1, m-1) == 0) return (mrb_int)(p - ys);
      p++;
    }
  }
  else if (m <= 40) {
    p = s0;
    e = ys + n;
    for (;p<e;) {
      size_t len = e-p;
      p = (const char*)memchr(p, *needle, len);
      if (p == NULL || len < m) break;
      if (memcmp(p+1, needle+1, m-1) == 0) return (mrb_int)(p - ys);
      p++;
    }
    p = s4;
    e = ys + n;
    for (;p<e;) {
      size_t len = e-p;
      p = (const char*)memchr(p, *needle, len);
      if (p == NULL || len < m) break;
      if (memcmp(p+1, needle+1, m-1) == 0) return (mrb_int)(p - ys);
      p++;
    }
  }
  else if (m <= 48) {
    p = s0;
    e = ys + n;
    for (;p<e;) {
      size_t len = e-p;
      p = (const char*)memchr(p, *needle, len);
      if (p == NULL || len < m) break;
      if (memcmp(p+1, needle+1, m-1) == 0) return (mrb_int)(p - ys);
      p++;
    }
    p = s5;
    e = ys + n;
    for (;p<e;) {
      size_t len = e-p;
      p = (const char*)memchr(p, *needle, len);
      if (p == NULL || len < m) break;
      if (memcmp(p+1, needle+1, m-1) == 0) return (mrb_int)(p - ys);
      p++;
    }
  }
  else if (m <= 56) {
    p = s0;
    e = ys + n;
    for (;p<e;) {
      size_t len = e-p;
      p = (const char*)memchr(p, *needle, len);
      if (p == NULL || len < m) break;
      if (memcmp(p+1, needle+1, m-1) == 0) return (mrb_int)(p - ys);
      p++;
    }
    p = s6;
    e = ys + n;
    for (;p<e;) {
      size_t len = e-p;
      p = (const char*)memchr(p, *needle, len);
      if (p == NULL || len < m) break;
      if (memcmp(p+1, needle+1, m-1) == 0) return (mrb_int)(p - ys);
      p++;
    }
  }
  else if (m <= 64) {
    p = s0;
    e = ys + n;
    for (;p<e;) {
      size_t len = e-p;
      p = (const char*)memchr(p, *needle, len);
      if (p == NULL || len < m) break;
      if (memcmp(p+1, needle+1, m-1) == 0) return (mrb_int)(p - ys);
      p++;
    }
    p = s7;
    e = ys + n;
    for (;p<e;) {
      size_t len = e-p;
      p = (const char*)memchr(p, *needle, len);
      if (p == NULL || len < m) break;
      if (memcmp(p+1, needle+1, m-1) == 0) return (mrb_int)(p - ys);
      p++;
    }
  }
  else if (m <= 72) {
    p = s0;
    e = ys + n;
    for (;p<e;) {
      size_t len = e-p;
      p = (const char*)memchr(p, *needle, len);
      if (p == NULL || len < m) break;
      if (memcmp(p+1, needle+1, m-1) == 0) return (mrb_int)(p - ys);
      p++;
    }
    p = s8;
    e = ys + n;
    for (;p<e;) {
      size_t len = e-p;
      p = (const char*)memchr(p, *needle, len);
      if (p == NULL || len < m) break;
      if (memcmp(p+1, needle+1, m-1) == 0) return (mrb_int)(p - ys);
      p++;
    }
  }
  else if (m <= 80) {
    p = s0;
    e = ys + n;
    for (;p<e;) {
      size_t len = e-p;
      p = (const char*)memchr(p, *needle, len);
      if (p == NULL || len < m) break;
      if (memcmp(p+1, needle+1, m-1) == 0) return (mrb_int)(p - ys);
      p++;
    }
    p = s9;
    e = ys + n;
    for (;p<e;) {
      size_t len = e-p;
      p = (const char*)memchr(p, *needle, len);
      if (p == NULL || len < m) break;
      if (memcmp(p+1, needle+1, m-1) == 0) return (mrb_int)(p - ys);
      p++;
    }
  }
  else if (m <= 96) {
    p = s0;
    e = ys + n;
    for (;p<e;) {
      size_t len = e-p;
      p = (const char*)memchr(p, *needle, len);
      if (p == NULL || len < m) break;
      if (memcmp(p+1, needle+1, m-1) == 0) return (mrb_int)(p - ys);
      p++;
    }
    p = s10;
    e = ys + n;
    for (;p<e;) {
      size_t len = e-p;
      p = (const char*)memchr(p, *needle, len);
      if (p == NULL || len < m) break;
      if (memcmp(p+1, needle+1, m-1) == 0) return (mrb_int)(p - ys);
      p++;
    }
  }
  else if (m <= 112) {
    p = s0;
    e = ys + n;
    for (;p<e;) {
      size_t len = e-p;
      p = (const char*)memchr(p, *needle, len);
      if (p == NULL || len < m) break;
      if (memcmp(p+1, needle+1, m-1) == 0) return (mrb_int)(p - ys);
      p++;
    }
    p = s11;
    e = ys + n;
    for (;p<e;) {
      size_t len = e-p;
      p = (const char*)memchr(p, *needle, len);
      if (p == NULL || len < m) break;
      if (memcmp(p+1, needle+1, m-1) == 0) return (mrb_int)(p - y