{
  char *newstr = NULL;
  size_t len = 0;
  // Free previous string if any
  if (*(char **)old)
    free (*(char **)old);

  if (strEQc (f->type, "TFv"))
    {
      // Fixed-length string, allocate f->size and copy at most f->size-1 chars
      newstr = (char *)calloc (f->size, 1);
      if (newstr)
        {
          strncpy (newstr, *(char **)value, f->size - 1);
          newstr[f->size - 1] = '\0';
        }
    }
  else if (strEQc (f->type, "TV"))
    {
      // Variable-length ASCII string
      if (*(char **)value)
        {
          len = strlen (*(char **)value);
          newstr = (char *)malloc (len + 1);
          if (newstr)
            strcpy (newstr, *(char **)value);
        }
    }
  else if (strEQc (f->type, "TU"))
    {
      // Variable-length Unicode string (UTF-16/32)
      if (*(char **)value)
        {
          if (is_utf8)
            {
              // Convert from UTF-8 to wide string
              size_t wlen = utf8_to_ucs2_len (*(char **)value);
              newstr = (char *)calloc (wlen + 1, sizeof (BITCODE_TU));
              if (newstr)
                utf8_to_ucs2 ((BITCODE_TU *)newstr, *(char **)value, wlen + 1);
            }
          else
            {
              // Already wide string, just copy
              len = wcslen ((const BITCODE_TU *)*(char **)value);
              newstr = (char *)calloc (len + 1, sizeof (BITCODE_TU));
              if (newstr)
                memcpy (newstr, *(char **)value, (len + 1) * sizeof (BITCODE_TU));
            }
        }
    }
  else
    {
      // Fallback: treat as variable-length ASCII string
      if (*(char **)value)
        {
          len = strlen (*(char **)value);
          newstr = (char *)malloc (len + 1);
          if (newstr)
            strcpy (newstr, *(char **)value);
        }
    }
  // Set the pointer in old to the new string
  memcpy (old, &newstr, sizeof (char *));
}