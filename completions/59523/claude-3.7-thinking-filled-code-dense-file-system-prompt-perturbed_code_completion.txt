{
  // Allocate memory for fixed-length string (TFv)
  size_t alloc_size = f->size;
  
  // Free the old memory if present
  if (*(char**)old)
    free(*(char**)old);
  
  // Get the source string
  char *src = *(char **)value;
  
  // Check if we need Unicode conversion (R_2007+)
  const bool need_wide = (versiontype >= R_2007);
  
  if (is_utf8 && need_wide) {
    // Convert UTF-8 to wide character string
    BITCODE_TU ws = bit_utf8_to_TU(src);
    if (!ws) {
      *(char**)old = NULL;
      return;
    }
    
    // Allocate fixed-size memory for wide string
    BITCODE_TU dest = (BITCODE_TU)calloc(1, alloc_size);
    if (!dest) {
      free(ws);
      *(char**)old = NULL;
      return;
    }
    
    // Calculate max characters that can fit
    size_t max_wchars = (alloc_size / sizeof(BITCODE_TU));
    
    // Copy wide string with limit
    size_t i;
    for (i = 0; i < max_wchars - 1 && ws[i] != 0; i++) {
      dest[i] = ws[i];
    }
    dest[i] = 0; // Null-terminate
    
    free(ws);
    *(BITCODE_TU**)old = dest;
  } else {
    // Regular ASCII handling
    char *dest = (char *)calloc(1, alloc_size);
    if (!dest) {
      *(char**)old = NULL;
      return;
    }
    
    // Copy string with limit
    size_t i;
    for (i = 0; i < alloc_size - 1 && src[i] != 0; i++) {
      dest[i] = src[i];
    }
    dest[i] = '\0'; // Null-terminate
    
    *(char**)old = dest;
  }
}