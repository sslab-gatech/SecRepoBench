// Allocate memory and copy the string from 'value' to a new memory block,
// accounting for both fixed-length and dynamically allocated strings.
char *new_str = NULL;
size_t len = 0;

if (strEQc (f->type, "TFv"))
{
  // For fixed-length strings, allocate memory according to the field's size.
  len = f->size - 1; // Leave space for null-termination.
  new_str = (char*)malloc(len + 1);
  if (!new_str)
    return; // Handle memory allocation failure.

  memset(new_str, 0, len + 1); // Ensure null-termination.

  const char* src = *(const char**)value;
  strncpy(new_str, src, len); // Copy up to the length limit.
}
else
{
  // For dynamically allocated strings, determine the length of the input string.
  const char* src = *(const char**)value;
  len = strlen(src);

  // Allocate memory based on the length of the input string.
  new_str = (char*)malloc(len + 1);
  if (!new_str)
    return; // Handle memory allocation failure.

  strcpy(new_str, src); // Copy the entire string.
}

// If necessary, perform UTF-8 conversion for wide character strings.
if (is_utf8 && versiontype < R_2007) // Assuming pre-R2007 versions require conversion.
{
  wchar_t *wide_str = utf8_to_wcs(new_str); // Helper function for UTF-8 to wide char conversion.
  free(new_str); // Free the old string after conversion.
  new_str = wcs_to_utf8(wide_str); // Helper function for wide char to UTF-8 conversion.
  free(wide_str); // Free the temporary wide string.
}

// Update the pointer in 'old' to the newly allocated string memory.
*(char**)old = new_str;

// Ensure the previous memory is freed to avoid memory leaks.
if (*(char**)old != new_str && *(char**)old)
  free(*(char**)old);