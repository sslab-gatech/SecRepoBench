{
          size_t len = f->size;
          char *new_str = (char *)malloc(len + 1);
          if (!new_str) {
            // Handle allocation failure
            return;
          }
          strncpy(new_str, (const char *)value, len);
          new_str[len] = '\0'; // Ensure null-termination
          memcpy(old, &new_str, sizeof(char *));
        }
      else if (strEQc (f->type, "T") && versiontype == R_2000)
        {
          size_t len = strlen((const char *)value);
          char *new_str = (char *)malloc(len + 1);
          if (!new_str) {
            // Handle allocation failure
            return;
          }
          strcpy(new_str, (const char *)value);
          memcpy(old, &new_str, sizeof(char *));
        }
      else if (strEQc (f->type, "T") && versiontype >= R_2010)
        {
          size_t len = strlen((const char *)value);
          wchar_t *new_wstr = (wchar_t *)malloc((len + 1) * sizeof(wchar_t));
          if (!new_wstr) {
            // Handle allocation failure
            return;
          }
          mbstowcs(new_wstr, (const char *)value, len + 1);
          memcpy(old, &new_wstr, sizeof(wchar_t *));
        }