/* Check if time resolution is needed by examining the parser's time format.
 * Determine the time key to be used, defaulting to "time" if not specified.
 * Calculate the length of the time key string.
 * Iterate over the map's key-value pairs to find the time key.
 * Compare each key's size and content to the desired time key.
 * If the key matches and time should not be kept, note the index to skip.
 * If no match is found, set pointers to NULL and continue the search.
 */
if (parser->time_keep == FLB_FALSE) {
    time_key = "time";
    time_key_len = strlen(time_key);
}
else {
    time_key = parser->time_key;
    time_key_len = strlen(time_key);
}

skip = -1;
for (i = 0; i < map_size; i++) {
    k = map.via.map.ptr[i].key;
    if (k.type!= MSGPACK_OBJECT_STR) {
        continue;
    }

    if (flb_sds_cmp(k.via.str.ptr, time_key, time_key_len) == 0) {
        if (parser->time_keep == FLB_FALSE) {
            skip = i;
        }
        else {
            time_value = &map.via.map.ptr[i].val;
            break;
        }
    }
}

if (time_value == NULL) {
    time_value = &map.via.map.ptr[0].val;
}

/* Ensure we have an accurate type */
if (time_value->type!= MSGPACK_OBJECT_STR) {
    msgpack_unpacked_destroy(&result);
    return *out_size;
}

/* Lookup time */
ret = flb_parser_time_lookup(time_value->via.str.ptr, time_value->via.str.size,
                             0, parser, &tm, &tmfrac);
if (ret == -1) {
    len = time_value->via.str.size;
    if (len > sizeof(tmp) - 1) {
        len = sizeof(tmp) - 1;
    }
    memcpy(tmp, time_value->via.str.ptr, len);
    tmp[len] = '\0';
    flb_warn("[parser:%s] invalid time format %s for '%s'",
             parser->name, parser->time_fmt_full, tmp);
    time_lookup = 0;
}
else {
    time_lookup = flb_parser_tm2time(&tm);
}

/* Compose a new map without the time_key field */
msgpack_sbuffer_init(&mp_sbuf);
msgpack_packer_init(&mp_pck, &mp_sbuf, msgpack_sbuffer_write);

if (parser->time_keep == FLB_FALSE) {
    msgpack_pack_map(&mp_pck, map_size - 1);
}
else {
    msgpack_pack_map(&mp_pck, map_size);
}

for (i = 0; i < map_size; i++) {
    if (i == skip) {
        continue;
    }
    msgpack_pack_object(&mp_pck, map.via.map.ptr[i].key);
    msgpack_pack_object(&mp_pck, map.via.map.ptr[i].val);
}