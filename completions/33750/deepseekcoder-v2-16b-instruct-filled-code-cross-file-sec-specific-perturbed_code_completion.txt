// Determine the time key to be used, defaulting to "time" if not specified.
    time_key = parser->time_key ? parser->time_key : "time";
    time_key_len = strlen(time_key);

    // Calculate the length of the time key string.
    time_key_len = strlen(time_key);

    // Initialize the time lookup variable.
    time_lookup = 0;

    // Count the number of key-value pairs in the input buffer.
    map_size = 0;
    ret = ltsv_parser(parser, in_buf, in_size, NULL,
                      time_key, time_key_len,
                      &time_lookup, &tmfrac, &map_size);
    if (ret < 0) {
        return ret;
    }

    // Prepare a new outgoing buffer.
    msgpack_sbuffer_init(&tmp_sbuf);
    msgpack_packer_init(&tmp_pck, &tmp_sbuf, msgpack_sbuffer_write);
    msgpack_pack_map(&tmp_pck, map_size);

    // Parse the input buffer and populate the MessagePack buffer.
    last_byte = ltsv_parser(parser, in_buf, in_size, &tmp_pck,
                            time_key, time_key_len,
                            &time_lookup, &tmfrac, &map_size);
    if (last_byte < 0) {
        msgpack_sbuffer_destroy(&tmp_sbuf);
        return last_byte;
    }

    // Export the results.
    *out_buf = tmp_sbuf.data;
    *out_size = tmp_sbuf.size;

    // Set the output time.
    t = out_time;
    t->tm.tv_sec  = time_lookup;
    t->tm.tv_nsec = (tmfrac * 1000000000);

    // Check if some decoder was specified.
    if (parser->decoders) {
        ret = flb_parser_decoder_do(parser->decoders,
                                    tmp_sbuf.data, tmp_sbuf.size,
                                    &dec_out_buf, &dec_out_size);
        if (ret == 0) {
            *out_buf = dec_out_buf;
            *out_size = dec_out_size;
            msgpack_sbuffer_destroy(&tmp_sbuf);
        }
    } else {
        msgpack_sbuffer_destroy(&tmp_sbuf);
    }

    return last_byte;