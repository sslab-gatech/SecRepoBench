// Check if time resolution is needed by examining the parser's time format.
// Determine the time key to be used, defaulting to "time" if not specified.
// Calculate the length of the time key string.
// Iterate over the map's key-value pairs to find the time key.
// Compare each key's size and content to the desired time key.
// If the key matches and time should not be kept, note the index to skip.
// If no match is found, set pointers to NULL and continue the search.
if (parser->time_keep == FLB_FALSE) {
    time_key = "time";
    len = strlen(time_key);
}
else {
    len = 0;
}

for (i = 0; i < map_size; i++) {
    k = map.via.map.ptr[i].key;
    if (k->type == MSGPACK_OBJECT_STR && k->via.str.size == len &&!memcmp(k->via.str.ptr, time_key, len)) {
        if (parser->time_keep == FLB_FALSE) {
            skip = i;
        }
        else {
            time_value = map.via.map.ptr[i].val;
            break;
        }
    }
}