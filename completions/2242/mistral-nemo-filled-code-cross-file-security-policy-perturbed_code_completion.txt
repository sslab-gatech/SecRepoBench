// <MASK>
uint32_t bytecnt = 0, linecnt = 0;
const char *buf, *end, *last;
uint64_t lines;

if (m->flags & REGEX_BYTECOUNT) {
	bytecnt = cvt_id3(ms, m->vallen);
	if (bytecnt == 0 || bytecnt > nbytes - offset)
		bytecnt = nbytes - offset;
	if (bytecnt > ms->regex_max)
		bytecnt = ms->regex_max;
} else if (m->flags & REGEX_LINECNT) {
	linecnt = cvt_id3(ms, m->vallen);
	if (linecnt == 0 || linecnt > (nbytes - offset) / ms->line_max)
		linecnt = (nbytes - offset) / ms->line_max;
}

buf = RCAST(const char *, source) + offset;
end = last = RCAST(const char *, source) + (bytecnt ? bytecnt : nbytes) + offset;
if (bytecnt == 0)
	last = RCAST(const char *, source) + nbytes;

if (linecnt) {
	/* Calculate the byte count by multiplying the line count by a constant. */
	bytecnt = linecnt * ms->line_max;
	if (bytecnt > nbytes - offset)
		bytecnt = nbytes - offset;
	if (bytecnt > ms->regex_max)
		bytecnt = ms->regex_max;
}

for (lines = linecnt, b = buf; lines && b < end &&
     ((b = CAST(const char *, memchr(c = b, '\n', CAST(size_t, (end - b)))))
      || (b = CAST(const char *, memchr(c, '\r', CAST(size_t, (end - c))))));
     lines--, b++) {
	last = b;
	if (b < end - 1 && b[0] == '\r' && b[1] == '\n')
		b++;
}

if (lines)
	last = RCAST(const char *, source) + bytecnt;

ms->search.s = buf;
ms->search.s_len = last - buf;
ms->search.offset = offset;
ms->search.rm_len = 0;
return 0;