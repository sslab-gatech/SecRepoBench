case FILE_REGEX: {
    // Check if the source string is valid and initialize the search length and pointer accordingly.
    if (source[offset] == '\0') {
        ms->search.s = NULL;
        ms->search.s_len = 0;
        ms->search.offset = 0;
        return 0;
    }

    // Determine the byte count and line count for the search based on the flags and range in'm'.
    uint32_t bytecnt = m->vallen;
    uint32_t linecnt = 0;
    if (m->str_flags & REGEX_LINECOUNT) {
        linecnt = cvt_id3(ms, m->vallen);
        if (linecnt == 0) {
            ms->search.s = NULL;
            ms->search.s_len = 0;
            ms->search.offset = 0;
            return 0;
        }
        bytecnt = linecnt * 2; // Assuming 2 bytes per line
    }

    // If a line count flag is set, calculate the byte count by multiplying the line count by a constant.
    // Otherwise, set the byte count to the specified range without line counting.
    if (bytecnt == 0 || bytecnt > nbytes - offset)
        bytecnt = nbytes - offset;
    if (bytecnt > ms->regex_max)
        bytecnt = ms->regex_max;

    // Initialize the search region in the data.
    buf = RCAST(const char *, source) + offset;
    end = last = RCAST(const char *, source) + bytecnt + offset;
    /* mget() guarantees buf <= last */
    for (lines = linecnt, b = buf; lines && b < end &&
         ((b = CAST(const char *,
             memchr(c = b, '\n', CAST(size_t, (end - b)))))
         || (b = CAST(const char *,
             memchr(c, '\r', CAST(size_t, (end - c))))));
         lines--, b++) {
        last = b;
        if (b < end - 1 && b[0] == '\r' && b[1] == '\n')
            b++;
    }
    if (lines)
        last = RCAST(const char *, source) + bytecnt;

    // Initialize the search structure.
    ms->search.s = buf;
    ms->search.s_len = last - buf;
    ms->search.offset = offset;
    ms->search.rm_len = 0;
    return 0;
}