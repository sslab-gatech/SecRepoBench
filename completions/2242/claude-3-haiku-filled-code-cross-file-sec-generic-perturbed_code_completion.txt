const char *buf, *end, *last;
size_t bytecnt, linecnt;

// Check if the source string is valid and initialize the search length and pointer accordingly.
if (source == NULL || nbytes == 0) {
    ms->search.s = NULL;
    ms->search.s_len = 0;
    ms->search.offset = 0;
    return 0;
}
ms->search.s = RCAST(const char *, source);
ms->search.s_len = nbytes;
ms->search.offset = offset;

// Determine the byte count and line count for the search based on the flags and range in 'm'.
if ((m->str_flags & REGEX_LINE_COUNT) != 0) {
    linecnt = m->str_range;
    bytecnt = linecnt * 80; // Assume an average line length of 80 bytes
} else {
    linecnt = 0;
    bytecnt = m->str_range;
}

if (bytecnt == 0 || bytecnt > nbytes - offset)
    bytecnt = nbytes - offset;
if (bytecnt > ms->regex_max)
    bytecnt = ms->regex_max;

buf = RCAST(const char *, source) + offset;
end = last = RCAST(const char *, source) + bytecnt + offset;
/* mget() guarantees buf <= last */
for (lines = linecnt, b = buf; lines && b < end &&
     ((b = CAST(const char *,
         memchr(c = b, '\n', CAST(size_t, (end - b)))))
     || (b = CAST(const char *,
         memchr(c, '\r', CAST(size_t, (end - c))))));
     lines--, b++) {
    last = b;
    if (b < end - 1 && b[0] == '\r' && b[1] == '\n')
        b++;
}
if (lines)
    last = RCAST(const char *, source) + bytecnt;

ms->search.s = buf;
ms->search.s_len = last - buf;
ms->search.offset = offset;
ms->search.rm_len = 0;
return 0;