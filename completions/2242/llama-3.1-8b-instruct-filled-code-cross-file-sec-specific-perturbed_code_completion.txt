case FILE_REGEX: {
    // Declare pointers and size variables to define the search region in the data.
    const unsigned char *src = source + offset;
    const unsigned char *esrc = source + nbytes;
    char *buf = NULL;
    char *end = NULL;
    char *last = NULL;
    size_t lines = 0;
    char *b = NULL;
    const char *c = NULL;
    size_t bytecnt = 0;
    size_t linecnt = 0;

    // Check if the source string is valid and initialize the search length and pointer accordingly.
    if (nbytes == 0) {
        return 0;
    }

    // Determine the byte count and line count for the search based on the flags and range in'm'.
    if (m->str_flags & REGEX_OFFSET_START) {
        bytecnt = nbytes - offset;
    } else {
        bytecnt = m->vallen;
    }
    if (bytecnt == 0 || bytecnt > nbytes - offset)
        bytecnt = nbytes - offset;
    if (bytecnt > ms->regex_max)
        bytecnt = ms->regex_max;

    // If a line count flag is set, calculate the byte count by multiplying the line count by a constant.
    // Otherwise, set the byte count to the specified range without line counting.
    if (m->str_flags & REGEX_LINE_COUNT) {
        linecnt = m->vallen;
        bytecnt = linecnt * 64;
    }

    // Initialize the search region pointers.
    buf = RCAST(const char *, source) + offset;
    end = last = RCAST(const char *, source) + bytecnt + offset;

    // Iterate over the search region to find the end of the search string.
    for (lines = linecnt, b = buf; lines && b < end &&
         ((b = CAST(const char *,
            memchr(c = b, '\n', CAST(size_t, (end - b)))))
         || (b = CAST(const char *,
            memchr(c, '\r', CAST(size_t, (end - c))))));
         lines--, b++) {
        last = b;
        if (b < end - 1 && b[0] == '\r' && b[1] == '\n')
            b++;
    }
    if (lines)
        last = RCAST(const char *, source) + bytecnt;

    // Initialize the search region.
    ms->search.s = buf;
    ms->search.s_len = last - buf;
    ms->search.offset = offset;
    ms->search.rm_len = 0;
    return 0;
}