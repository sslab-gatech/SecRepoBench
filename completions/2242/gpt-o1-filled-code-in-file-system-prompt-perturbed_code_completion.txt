size_t linecnt, lines, bytecnt;
const char *buf, *b, *c, *end, *last;

/* 1. Determine if we are using line-based or byte-based scanning. */
if (m->str_flags & STRING_LINES) {
    linecnt = m->str_range;
    bytecnt = nbytes - offset;
} else {
    linecnt = 0;
    bytecnt = m->str_range;
}

/* 2. Clip the byte count to the available data and to ms->regex_max. */
if (bytecnt == 0 || bytecnt > nbytes - offset)
    bytecnt = nbytes - offset;
if (bytecnt > ms->regex_max)
    bytecnt = ms->regex_max;

/* 3. Set up our search pointers. */
buf = RCAST(const char *, source) + offset;
end = last = RCAST(const char *, source) + bytecnt + offset;

/* 4. If line-based, find the last line boundary within bytecnt. */
for (lines = linecnt, b = buf; lines && b < end &&
     ((b = CAST(const char *, memchr((c = b), '\n', CAST(size_t, (end - b)))))
      || (b = CAST(const char *, memchr(c, '\r', CAST(size_t, (end - c))))));
     lines--, b++) {
    last = b;
    if (b < end - 1 && b[0] == '\r' && b[1] == '\n')
        b++;
}
if (lines)
    last = RCAST(const char *, source) + bytecnt;

/* 5. Store the search region in ms->search. */
ms->search.s = buf;
ms->search.s_len = last - buf;
ms->search.offset = offset;
ms->search.rm_len = 0;
return 0;