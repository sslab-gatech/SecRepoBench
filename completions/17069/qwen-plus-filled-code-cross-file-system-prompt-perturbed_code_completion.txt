do {
	/* Handle the case where there are unconsumed words left to process. */
	if(ucbits == 0) {
		cwords++;
		FLAC__ASSERT(cwords < wordcount);
		b = br->buffer[cwords];
		ucbits = FLAC__BITS_PER_WORD;
	}

	/* read the unary MSBs and end bit */
	x = y = COUNT_ZERO_MSBS2(b);
	if(x >= ucbits) {
		x = ucbits;
		do {
			/* didn't find stop bit yet, have to keep going... */
			cwords++;
			FLAC__ASSERT(cwords < wordcount);
			b = br->buffer[cwords];
			y = COUNT_ZERO_MSBS2(b);
			x += y;
		} while(y == FLAC__BITS_PER_WORD);
	}
	b <<= x;
	b <<= 1; /* account for stop bit */
	ucbits -= (x + 1);
	msbs = x;

	/* read the binary LSBs */
	x = (FLAC__uint32)(b >> (FLAC__BITS_PER_WORD - parameter)); /* parameter < 32, so we can cast to 32-bit uint32_t */
	if(parameter <= ucbits) {
		ucbits -= parameter;
		b <<= parameter;
	} else {
		/* there are still bits left to read, they will all be in the next word */
		cwords++;
		FLAC__ASSERT(cwords < wordcount);
		b = br->buffer[cwords];
		ucbits += FLAC__BITS_PER_WORD - parameter;
		x |= (FLAC__uint32)(b >> ucbits);
		b <<= FLAC__BITS_PER_WORD - ucbits;
	}
	lsbs = x;

	/* compose the value */
	x = (msbs << parameter) | lsbs;
	*val++ = (int)(x >> 1) ^ -(int)(x & 1);

} while(val < end && cwords < wordcount);