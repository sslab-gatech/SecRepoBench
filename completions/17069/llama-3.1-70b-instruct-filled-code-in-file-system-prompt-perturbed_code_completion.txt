do {
    // Handle the case where there are unconsumed words left to process.
    // Read the unary most significant bits (MSBs) and update the consumed words and bits count.
    // Continue by reading the binary least significant bits (LSBs) if necessary.
    // Compose the signed value by combining MSBs and LSBs, and store it in the output array.
    // Update the internal state of the bitreader, ensuring the buffer is positioned correctly for subsequent reads.
    if (br->bytes * 8 > br->consumed_bits) {
        const uint32_t end = br->bytes * 8;
        b = (br->buffer[cwords] & (FLAC__WORD_ALL_ONES << (FLAC__BITS_PER_WORD - end))) << br->consumed_bits;
        x = y = COUNT_ZERO_MSBS2(b);
        if (x == FLAC__BITS_PER_WORD) {
            x = end - br->consumed_bits;
            do {
                // didn't find stop bit yet, have to keep going...
                cwords++;
                if (cwords >= wordcount)
                    goto incomplete_msbs;
                b = br->buffer[cwords];
                y = COUNT_ZERO_MSBS2(b);
                x += y;
            } while (y == FLAC__BITS_PER_WORD);
        }
        b <<= y;
        b <<= 1; // account for stop bit
        msbs = x;
        // read the binary LSBs
        x = (FLAC__uint32)(b >> (FLAC__BITS_PER_WORD - parameter)); // parameter < 32, so we can cast to 32-bit uint32_t
        if (parameter <= end - br->consumed_bits - x - 1) {
            lsbs = x;
        } else {
            // there are still bits left to read, they will all be in the next word
            cwords++;
            if (cwords >= wordcount)
                goto incomplete_lsbs;
            b = br->buffer[cwords];
            x = (FLAC__uint32)(b >> (FLAC__BITS_PER_WORD - parameter));
            lsbs = x;
        }
        // compose the value
        x = (msbs << parameter) | lsbs;
        *val++ = (int)(x >> 1) ^ -(int)(x & 1);
        br->consumed_bits += x + 1 + parameter;
        if (br->consumed_bits >= FLAC__BITS_PER_WORD) { // faster way of testing if(br->consumed_bits == FLAC__BITS_PER_WORD)
            cwords++;
            br->consumed_bits = 0;
        }
    } else {
        // didn't find stop bit yet, have to keep going...
        cwords++;
        if (cwords >= wordcount)
            goto incomplete_msbs;
    }
} while (cwords >= wordcount && val < end);