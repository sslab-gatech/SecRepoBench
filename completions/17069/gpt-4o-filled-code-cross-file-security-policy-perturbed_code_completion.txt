/* Handle the case where there are unconsumed words left to process. */
			if (cwords < wordcount) {
				b = br->buffer[cwords];
				ucbits = FLAC__BITS_PER_WORD;
			} else {
				/* No more words to process, set default values */
				msbs = 0;
				lsbs = 0;
				*val++ = 0;
				break;
			}

			/* Read the unary MSBs and end bit */
			x = y = COUNT_ZERO_MSBS2(b);
			if (x == FLAC__BITS_PER_WORD) {
				x = ucbits;
				do {
					/* Didn't find stop bit yet, have to keep going... */
					cwords++;
					if (cwords >= wordcount) {
						msbs = x;
						lsbs = 0;
						*val++ = (int)(msbs >> 1) ^ -(int)(msbs & 1);
						break;
					}
					b = br->buffer[cwords];
					y = COUNT_ZERO_MSBS2(b);
					x += y;
				} while (y == FLAC__BITS_PER_WORD);
			}
			b <<= y;
			b <<= 1; /* Account for stop bit */
			ucbits = (ucbits - x - 1) % FLAC__BITS_PER_WORD;
			msbs = x;

			/* Read the binary LSBs */
			x = (FLAC__uint32)(b >> (FLAC__BITS_PER_WORD - parameter));
			if (parameter <= ucbits) {
				ucbits -= parameter;
				b <<= parameter;
			} else {
				/* There are still bits left to read, they will all be in the next word */
				cwords++;
				if (cwords >= wordcount) {
					msbs = x;
					lsbs = 0;
					*val++ = (int)(msbs >> 1) ^ -(int)(msbs & 1);
					break;
				}
				b = br->buffer[cwords];
				ucbits += FLAC__BITS_PER_WORD - parameter;
				x |= (FLAC__uint32)(b >> ucbits);
				b <<= FLAC__BITS_PER_WORD - ucbits;
			}
			lsbs = x;

			/* Compose the value */
			x = (msbs << parameter) | lsbs;
			*val++ = (int)(x >> 1) ^ -(int)(x & 1);