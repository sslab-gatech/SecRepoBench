static FLAC__bool bitreader_read_from_client_(FLAC__BitReader *br)
{
    uint32_t start, end;
    size_t bytes;
    FLAC__byte *target;

    // first shift the unconsumed buffer data toward the front as much as possible
    if(br->consumed_words > 0) {
        crc16_update_block_(br); // CRC consumed words

        start = br->consumed_words;
        end = br->words + (br->bytes? 1:0);
        memmove(br->buffer, br->buffer+start, FLAC__BYTES_PER_WORD * (end - start));

        br->words -= start;
        br->consumed_words = 0;
    }

    /*
     * set the target for reading, taking into account word alignment and endianness
     */
    bytes = (br->capacity - br->words) * FLAC__BYTES_PER_WORD - br->bytes;
    if(bytes == 0)
        return false; // no space left, buffer is too small; see note for FLAC__BITREADER_DEFAULT_CAPACITY

    target = ((FLAC__byte*)(br->buffer+br->words)) + br->bytes;

    // before reading, if the existing reader looks like this (say brword is 32 bits wide)
    //   bitstream :  11 22 33 44 55            br->words=1 br->bytes=1 (partial tail word is left-justified)
    //   buffer[BE]:  11 22 33 44 55 ?? ?? ??   (shown laid out as bytes sequentially in memory)
    //   buffer[LE]:  44 33 22 11 ?? ?? ?? 55   (?? being don't-care)
    //                               ^^-------target, bytes=3
    // on LE machines, have to byteswap the odd tail word so nothing is
    // overwritten:
    //
#if WORDS_BIGENDIAN
#else
    if(br->bytes)
        br->buffer[br->words] = SWAP_BE_WORD_TO_HOST(br->buffer[br->words]);
#endif

    // now it looks like:
    //   bitstream :  11 22 33 44 55            br->words=1 br->bytes=1
    //   buffer[BE]:  11 22 33 44 55 ?? ?? ??
    //   buffer[LE]:  44 33 22 11 55 ?? ?? ??
    //                               ^^-------target, bytes=3

    // read in the data; note that the callback may return a smaller number of bytes
    if(!br->read_callback(target, &bytes, br->client_data))
        return false;

    // after reading bytes 66 77 88 99 AA BB CC DD EE FF from the client:
    //   bitstream :  11 22 33 44 55 66 77 88 99 AA BB CC DD EE FF
    //   buffer[BE]:  11 22 33 44 55 66 77 88 99 AA BB CC DD EE FF ??
    //   buffer[LE]:  44 33 22 11 88 77 66 55 CC BB AA 99 ?? FF EE DD
    // now have to byteswap on LE machines:
    //
#if WORDS_BIGENDIAN
#else
    end = (br->words*FLAC__BYTES_PER_WORD + br->bytes + (uint32_t)bytes + (FLAC__BYTES_PER_WORD-1)) / FLAC__BYTES_PER_WORD;
    for(start = br->words; start < end; start++)
        br->buffer[start] = SWAP_BE_WORD_TO_HOST(br->buffer[start]);
#endif

    // finally we'll update the reader values:
    end = br->words*FLAC__BYTES_PER_WORD + br->bytes + (uint32_t)bytes;
    br->words = end / FLAC__BYTES_PER_WORD;
    br->bytes = end % FLAC__BYTES_PER_WORD;

    return true;
}