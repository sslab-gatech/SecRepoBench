// Initialize the contour points based on the end points of the contours.
// Retrieve the end points of the contours from the header and validate the range.
// Allocate memory for the contour points, including space for phantom points.
// Set the end points of each contour in the points array.
// If phantom_only is true, skip the process of reading the actual points.
unsigned int num_contours = header.numberOfContours;
if (unlikely (num_contours > contour_points.allocated)) return false;

contour_point_vector_t::item_t *points = contour_points.arrayZ;
for (unsigned int i = 0; i < num_contours; i++)
{
  unsigned int end_point = StructAtOffset<HBUINT16> (&bytes, GlyphHeader::static_size + 2 * i);
  if (unlikely (end_point >= contour_points.length)) return false;
  points[end_point].flag = FLAG_CONTOUR_END;
}

if (phantom_only)
  return true;

const HBUINT8 *p = &StructAtOffset<HBUINT8> (&bytes, GlyphHeader::static_size + 2 * num_contours);