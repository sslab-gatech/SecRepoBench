if (phantom_only)
{
    // Allocate memory for the phantom points
    contour_points.resize(num_contours + 1);

    // Set the end points of each contour in the points array
    for (unsigned int i = 0; i < num_contours; i++)
    {
        contour_points[i].x = 0;
        contour_points[i].y = 0;
    }
    contour_points[num_contours].x = 0;
    contour_points[num_contours].y = 0;
}
else
{
    // Allocate memory for the actual points
    contour_points.resize(endPtsOfContours[num_contours] + 1);

    // Set the end points of each contour in the points array
    for (unsigned int i = 0; i < num_contours; i++)
    {
        contour_points[endPtsOfContours[i]].x = 0;
        contour_points[endPtsOfContours[i]].y = 0;
    }
    contour_points[endPtsOfContours[num_contours]].x = 0;
    contour_points[endPtsOfContours[num_contours]].y = 0;

    // Read the actual points
    const HBUINT8 *p = &StructAtOffset<HBUINT8>(&endPtsOfContours[num_contours + 1],
                                               endPtsOfContours[num_contours]);

    if (unlikely((const char *)p < bytes.arrayZ)) return false; /* Unlikely overflow */
    const HBUINT8 *end = (const HBUINT8 *)(bytes.arrayZ + bytes.length);
    if (unlikely(p >= end)) return false;

    if (!read_flags(p, contour_points, end) ||
        !read_points(p, contour_points, end, &contour_point_t::x,
                     FLAG_X_SHORT, FLAG_X_SAME) ||
        !read_points(p, contour_points, end, &contour_point_t::y,
                     FLAG_Y_SHORT, FLAG_Y_SAME))
    {
        return false;
    }
}