{
  // Determine total points from the last entry (the end point of the last contour) plus 1.
  unsigned total_points = endPtsOfContours[num_contours] + 1;

  // Add space for phantom points (typically 4).
  total_points += 4;

  // Ensure we can hold all points, then set length.
  if (!contour_points.ensure(total_points))
    return false;
  contour_points.length = total_points;

  // Initialize all points so that flags/coordinates are not left uninitialized.
  memset(contour_points.arrayZ, 0, total_points * sizeof(contour_point_t));

  // Validate and mark the end of each contour (if needed).
  for (unsigned c = 0; c < num_contours; c++)
  {
    if (unlikely(endPtsOfContours[c] >= total_points - 4))
      return false;
    // Here one could set a special flag in contour_points.arrayZ[endPtsOfContours[c]] if desired.
  }

  // If only phantom points are needed, skip reading actual contour data.
  if (phantom_only)
    return true;
}