unsigned int num_contours = header.numberOfContours;
    if (num_contours == 0) {
      // No contours, only phantom points
      contour_points.length = 4;
      contour_points.arrayZ[0].x = 0;
      contour_points.arrayZ[0].y = 0;
      contour_points.arrayZ[1].x = 0;
      contour_points.arrayZ[1].y = 0;
      contour_points.arrayZ[2].x = 0;
      contour_points.arrayZ[2].y = 0;
      contour_points.arrayZ[3].x = 0;
      contour_points.arrayZ[3].y = 0;
      return true;
    }

    const HBUINT16 *endPtsOfContours = &StructAtOffset<HBUINT16>(&bytes, GlyphHeader::static_size);
    if (unlikely((const char *)endPtsOfContours < bytes.arrayZ)) return false; // Unlikely overflow

    unsigned int num_points = endPtsOfContours[num_contours - 1] + 1;
    if (unlikely(num_points + 4 > contour_points.capacity)) return false; // Ensure capacity

    contour_points.length = num_points + 4; // Include phantom points

    for (unsigned int i = 0; i < num_contours; i++) {
      contour_points.arrayZ[endPtsOfContours[i]].on_curve = true;
    }

    if (phantom_only) {
      // Skip reading actual points if phantom_only is true
      contour_points.arrayZ[num_points].x = 0;
      contour_points.arrayZ[num_points].y = 0;
      contour_points.arrayZ[num_points + 1].x = 0;
      contour_points.arrayZ[num_points + 1].y = 0;
      contour_points.arrayZ[num_points + 2].x = 0;
      contour_points.arrayZ[num_points + 2].y = 0;
      contour_points.arrayZ[num_points + 3].x = 0;
      contour_points.arrayZ[num_points + 3].y = 0;
      return true;
    }