unsigned numEndpoints = endPtsOfContours[num_contours];
unsigned phantomCount = 4;
unsigned totalPoints = numEndpoints + phantomCount;

// Validate that the endpoint count does not exceed any reasonable limit.
// (Assuming bytes.length is the total size of available data, and that a rough upper bound is defined.)
if (totalPoints > bytes.length)
  return false;

// Allocate the contour points vector.
contour_points.length = totalPoints;
contour_points.arrayZ = new contour_point_t[totalPoints];
if (!contour_points.arrayZ)
  return false;

// Initialize all points to default values.
for (unsigned i = 0; i < totalPoints; i++) {
  contour_points.arrayZ[i].x = 0;
  contour_points.arrayZ[i].y = 0;
  contour_points.arrayZ[i].flag = 0;
}

// Mark the end points of each contour using the values from endPtsOfContours.
// Verify that each contour endpoint index is within the allocated range.
for (unsigned i = 0; i < num_contours; i++) {
  unsigned ptIndex = endPtsOfContours[i];
  if (ptIndex >= totalPoints)
    return false;
  // Mark the point as an end‐of‐contour.
  contour_points.arrayZ[ptIndex].flag |= 0x80; // 0x80 is used here as an end‐of‐contour flag.
}

// If only phantom points should be processed, skip reading the remaining coordinate data.
if (phantom_only)
  return true;