if (unlikely (num_contours >= 0xFFFF)) return false;
if (unlikely (num_contours > bytes.length)) return false;

unsigned int num_points = 0;
if (num_contours > 0)
{
  if (unlikely (!bytes.check_range (&endPtsOfContours[num_contours]))) return false;
  num_points = endPtsOfContours[num_contours - 1] + 1;
  if (unlikely (num_points > bytes.length)) return false;
}

if (phantom_only)
{
  contour_points.resize (num_points);
  for (unsigned int i = 0; i < num_contours; i++)
  {
    unsigned int end_point = endPtsOfContours[i];
    if (i > 0)
    {
      unsigned int start_point = endPtsOfContours[i - 1] + 1;
      if (unlikely (end_point < start_point)) return false;
    }
    contour_points.arrayZ[end_point].is_end_point = true;
  }
  return true;
}