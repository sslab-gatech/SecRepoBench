unsigned int num_contours = header.numberOfContours;
    if (unlikely (!num_contours)) return false;

    unsigned int num_points = 0;
    const HBUINT16 *endPtsOfContours = &StructAtOffset<HBUINT16> (&bytes, GlyphHeader::static_size);
    for (unsigned int i = 0; i < num_contours; i++)
    {
      if (unlikely (GlyphHeader::static_size + 2 * (i + 1) > bytes.length)) return false;
      num_points = hb_max (num_points, endPtsOfContours[i]);
    }
    num_points++;

    if (phantom_only)
    {
      contour_points.resize (4);
      contour_point_t *p = contour_points.arrayZ;
      p->x = header.xMin; p->y = header.yMin; p++;
      p->x = header.xMax; p->y = header.yMin; p++;
      p->x = header.xMax; p->y = header.yMax; p++;
      p->x = header.xMin; p->y = header.yMax; p++;
      return true;
    }

    contour_points.resize (num_points + 4); /* + phantom points */
    for (unsigned int i = 0; i < num_contours; i++)
      contour_points.arrayZ[endPtsOfContours[i]].flag |= FLAG_ON_CURVE;