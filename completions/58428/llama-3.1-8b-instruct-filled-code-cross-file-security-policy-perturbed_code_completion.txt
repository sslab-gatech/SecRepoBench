// <MASK>
if (phantom_only) {
  // If phantom_only is true, allocate memory for phantom points and set the end points of each contour in the points array.
  contour_points.resize(num_contours);
  for (size_t i = 0; i < num_contours; ++i) {
    contour_points[i].x = endPtsOfContours[i].x;
    contour_points[i].y = endPtsOfContours[i].y;
  }
} else {
  // If phantom_only is false, read the actual points from the header and set the end points of each contour in the points array.
  contour_points.resize(num_contours + num_phantom_points);
  for (size_t i = 0; i < num_contours; ++i) {
    const HBUINT8 *p = &StructAtOffset<HBUINT8> (&endPtsOfContours[i + 1],
						 endPtsOfContours[i]);
    if (unlikely ((const char *) p < bytes.arrayZ)) return false; /* Unlikely overflow */
    const HBUINT8 *end = (const HBUINT8 *) (bytes.arrayZ + bytes.length);
    if (unlikely (p >= end)) return false;

    /* Read x & y coordinates */
    if (!read_flags (p, contour_points, end)
        ||!read_points (p, contour_points, end, &contour_point_t::x,
			FLAG_X_SHORT, FLAG_X_SAME)
	||!read_points (p, contour_points, end, &contour_point_t::y,
			FLAG_Y_SHORT, FLAG_Y_SAME)) {
      return false;
    }
  }
  // Add phantom points to the contour points array.
  for (size_t i = num_contours; i < num_contours + num_phantom_points; ++i) {
    contour_points[i].x = endPtsOfContours[i].x;
    contour_points[i].y = endPtsOfContours[i].y;
  }
}