unsigned num_contours = header.numberOfContours;
    if (num_contours == 0) return false; // No contours to process

    // Allocate memory for contour points
    if (!contour_points.alloc(num_contours + (phantom_only ? 0 : 4), true)) return false;

    // Set end points of each contour
    for (unsigned i = 0; i < num_contours; i++)
    {
        contour_points.arrayZ[i].x = 0; // Placeholder for x-coordinate
        contour_points.arrayZ[i].y = 0; // Placeholder for y-coordinate
        contour_points.arrayZ[i].flag = FLAG_ON_CURVE; // Set default flag
    }

    if (phantom_only) return true; // If only phantom points are needed, return early

    // Read actual points if not phantom only
    const HBUINT8 *p = &StructAtOffset<HBUINT8>(&endPtsOfContours[num_contours + 1], endPtsOfContours[num_contours]);
    if (unlikely((const char *)p < bytes.arrayZ)) return false; // Unlikely overflow
    const HBUINT8 *end = (const HBUINT8 *)(bytes.arrayZ + bytes.length);
    if (unlikely(p >= end)) return false;

    // Read x & y coordinates
    return read_flags(p, contour_points, end)
        && read_points(p, contour_points, end, &contour_point_t::x, FLAG_X_SHORT, FLAG_X_SAME)
        && read_points(p, contour_points, end, &contour_point_t::y, FLAG_Y_SHORT, FLAG_Y_SAME);