// <MASK>
if (phantom_only) {
  // If phantom_only is true, skip the process of reading the actual points.
  // Initialize the contour points with phantom points.
  for (unsigned i = 0; i < num_contours; i++) {
    contour_points.arrayZ[i].x = 0;
    contour_points.arrayZ[i].y = 0;
  }
  return true;
}

// Allocate memory for the contour points, including space for phantom points.
contour_points.resize(num_contours + 1);

// Set the end points of each contour in the points array.
for (unsigned i = 0; i < num_contours; i++) {
  contour_points.arrayZ[i].x = endPtsOfContours[i].x;
  contour_points.arrayZ[i].y = endPtsOfContours[i].y;
}

// Read the actual points from the header.
const HBUINT8 *p = &StructAtOffset<HBUINT8> (&endPtsOfContours[num_contours + 1],
                                            endPtsOfContours[num_contours]);

if (unlikely ((const char *) p < bytes.arrayZ)) return false; /* Unlikely overflow */
const HBUINT8 *end = (const HBUINT8 *) (bytes.arrayZ + bytes.length);
if (unlikely (p >= end)) return false;

// Read the x and y coordinates.
return read_flags (p, contour_points, end)
        && read_points (p, contour_points, end, &contour_point_t::x,
                        FLAG_X_SHORT, FLAG_X_SAME)
        && read_points (p, contour_points, end, &contour_point_t::y,
                        FLAG_Y_SHORT, FLAG_Y_SAME);