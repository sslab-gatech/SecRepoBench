contour_point_vector_t contour_points;
if (unlikely (!contour_points.alloc (num_contours + 1, true))) return false;

// Initialize the contour points based on the end points of the contours.
// Retrieve the end points of the contours from the header and validate the range.
for (unsigned int i = 0; i < num_contours; i++)
{
  contour_points.arrayZ[i].x = endPtsOfContours[i];
  contour_points.arrayZ[i].y = endPtsOfContours[i + 1];
}

// Set the end points of each contour in the points array.
contour_points.arrayZ[num_contours].x = endPtsOfContours[num_contours];
contour_points.arrayZ[num_contours].y = endPtsOfContours[num_contours + 1];

// If phantom_only is true, skip the process of reading the actual points.
if (phantom_only) return true;

// Read the actual points from the glyph data.
const HBUINT8 *p = &StructAtOffset<HBUINT8> (&bytes, instruction_len_offset ());
if (unlikely ((const char *) p < bytes.arrayZ)) return false; /* Unlikely overflow */
const HBUINT8 *end = (const HBUINT8 *) (bytes.arrayZ + bytes.length);
if (unlikely (p >= end)) return false;

/* Read x & y coordinates */
return read_flags (p, contour_points, end)
    && read_points (p, contour_points, end, &contour_point_t::x,
			FLAG_X_SHORT, FLAG_X_SAME)
	&& read_points (p, contour_points, end, &contour_point_t::y,
			FLAG_Y_SHORT, FLAG_Y_SAME);