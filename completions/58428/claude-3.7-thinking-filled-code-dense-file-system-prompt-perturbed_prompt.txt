Below is the content of a C/C++ function where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
bool get_contour_points (contour_point_vector_t &contour_points /* OUT */,
			   bool phantom_only = false) const
  {
    // Initialize the contour points based on the end points of the contours.
    // Retrieve the end points of the contours from the header and validate the range.
    // Allocate memory for the contour points, including space for phantom points.
    // Set the end points of each contour in the points array.
    // If phantom_only is true, skip the process of reading the actual points.
    // <MASK>
    const HBUINT8 *p = &StructAtOffset<HBUINT8> (&endPtsOfContours[num_contours + 1],
						 endPtsOfContours[num_contours]);

    if (unlikely ((const char *) p < bytes.arrayZ)) return false; /* Unlikely overflow */
    const HBUINT8 *end = (const HBUINT8 *) (bytes.arrayZ + bytes.length);
    if (unlikely (p >= end)) return false;

    /* Read x & y coordinates */
    return read_flags (p, contour_points, end)
        && read_points (p, contour_points, end, &contour_point_t::x,
			FLAG_X_SHORT, FLAG_X_SAME)
	&& read_points (p, contour_points, end, &contour_point_t::y,
			FLAG_Y_SHORT, FLAG_Y_SAME);
  }
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/OT/glyf/VarCompositeGlyph.hh
bool get_points (contour_point_vector_t &points) const
  {
    unsigned num_points = get_num_points ();

    if (unlikely (!points.resize (points.length + num_points, false))) return false;
    contour_point_t *rec_points = points.as_array ().sub_array (points.length - num_points).arrayZ;
    memset (rec_points, 0, num_points * sizeof (rec_points[0]));

    unsigned fl = flags;

    unsigned num_axes = numAxes;
    unsigned axis_width = (fl & AXIS_INDICES_ARE_SHORT) ? 2 : 1;
    unsigned axes_size = num_axes * axis_width;

    const F2DOT14 *q = (const F2DOT14 *) (axes_size +
					  (fl & GID_IS_24BIT ? 3 : 2) +
					  &StructAfter<const HBUINT8> (numAxes));

    unsigned count = num_axes;
    if (fl & AXES_HAVE_VARIATION)
    {
      for (unsigned i = 0; i < count; i++)
	rec_points++->x = q++->to_int ();
    }
    else
      q += count;

    const HBUINT16 *p = (const HBUINT16 *) q;

    if (fl & (HAVE_TRANSLATE_X | HAVE_TRANSLATE_Y))
    {
      int translateX = (fl & HAVE_TRANSLATE_X) ? * (const FWORD *) p++ : 0;
      int translateY = (fl & HAVE_TRANSLATE_Y) ? * (const FWORD *) p++ : 0;
      rec_points->x = translateX;
      rec_points->y = translateY;
      rec_points++;
    }
    if (fl & HAVE_ROTATION)
    {
      int rotation = (fl & HAVE_ROTATION) ? ((const F4DOT12 *) p++)->to_int () : 0;
      rec_points->x = rotation;
      rec_points++;
    }
    if (fl & (HAVE_SCALE_X | HAVE_SCALE_Y))
    {
      int scaleX = (fl & HAVE_SCALE_X) ? ((const F6DOT10 *) p++)->to_int () : 1 << 10;
      int scaleY = (fl & HAVE_SCALE_Y) ? ((const F6DOT10 *) p++)->to_int () : 1 << 10;
      if ((fl & UNIFORM_SCALE) && !(fl & HAVE_SCALE_Y))
	scaleY = scaleX;
      rec_points->x = scaleX;
      rec_points->y = scaleY;
      rec_points++;
    }
    if (fl & (HAVE_SKEW_X | HAVE_SKEW_Y))
    {
      int skewX = (fl & HAVE_SKEW_X) ? ((const F4DOT12 *) p++)->to_int () : 0;
      int skewY = (fl & HAVE_SKEW_Y) ? ((const F4DOT12 *) p++)->to_int () : 0;
      rec_points->x = skewX;
      rec_points->y = skewY;
      rec_points++;
    }
    if (fl & (HAVE_TCENTER_X | HAVE_TCENTER_Y))
    {
      int tCenterX = (fl & HAVE_TCENTER_X) ? * (const FWORD *) p++ : 0;
      int tCenterY = (fl & HAVE_TCENTER_Y) ? * (const FWORD *) p++ : 0;
      rec_points->x = tCenterX;
      rec_points->y = tCenterY;
      rec_points++;
    }

    return true;
  }

// the below code fragment can be found in:
// src/OT/glyf/CompositeGlyph.hh
bool get_points (contour_point_vector_t &points) const
  {
    float matrix[4];
    contour_point_t trans;
    get_transformation (matrix, trans);
    if (unlikely (!points.resize (points.length + 1))) return false;
    points[points.length - 1] = trans;
    return true;
  }

// the below code fragment can be found in:
// src/OT/glyf/SimpleGlyph.hh
static bool read_points (const HBUINT8 *&p /* IN/OUT */,
			   contour_point_vector_t &points_ /* IN/OUT */,
			   const HBUINT8 *end,
			   float contour_point_t::*m,
			   const simple_glyph_flag_t short_flag,
			   const simple_glyph_flag_t same_flag)
  {
    int v = 0;

    unsigned count = points_.length;
    for (unsigned i = 0; i < count; i++)
    {
      unsigned flag = points_.arrayZ[i].flag;
      if (flag & short_flag)
      {
	if (unlikely (p + 1 > end)) return false;
	if (flag & same_flag)
	  v += *p++;
	else
	  v -= *p++;
      }
      else
      {
	if (!(flag & same_flag))
	{
	  if (unlikely (p + HBINT16::static_size > end)) return false;
	  v += *(const HBINT16 *) p;
	  p += HBINT16::static_size;
	}
      }
      points_.arrayZ[i].*m = v;
    }
    return true;
  }

// the below code fragment can be found in:
// src/OT/glyf/SimpleGlyph.hh
static bool read_flags (const HBUINT8 *&p /* IN/OUT */,
			  contour_point_vector_t &points_ /* IN/OUT */,
			  const HBUINT8 *end)
  {
    unsigned count = points_.length;
    for (unsigned int i = 0; i < count;)
    {
      if (unlikely (p + 1 > end)) return false;
      uint8_t flag = *p++;
      points_.arrayZ[i++].flag = flag;
      if (flag & FLAG_REPEAT)
      {
	if (unlikely (p + 1 > end)) return false;
	unsigned int repeat_count = *p++;
	unsigned stop = hb_min (i + repeat_count, count);
	for (; i < stop; i++)
	  points_.arrayZ[i].flag = flag;
      }
    }
    return true;
  }

// the below code fragment can be found in:
// src/OT/glyf/SimpleGlyph.hh
bool compile_bytes_with_deltas (const contour_point_vector_t &all_points,
                                  bool no_hinting,
                                  hb_bytes_t &dest_bytes /* OUT */)
  {
    if (header.numberOfContours == 0 || all_points.length <= 4)
    {
      dest_bytes = hb_bytes_t ();
      return true;
    }
    unsigned num_points = all_points.length - 4;

    hb_vector_t<uint8_t> flags, x_coords, y_coords;
    if (unlikely (!flags.alloc (num_points, true))) return false;
    if (unlikely (!x_coords.alloc (2*num_points, true))) return false;
    if (unlikely (!y_coords.alloc (2*num_points, true))) return false;

    uint8_t lastflag = 255, repeat = 0;
    int prev_x = 0, prev_y = 0;

    for (unsigned i = 0; i < num_points; i++)
    {
      uint8_t flag = all_points.arrayZ[i].flag;
      flag &= FLAG_ON_CURVE + FLAG_OVERLAP_SIMPLE;

      int cur_x = roundf (all_points.arrayZ[i].x);
      int cur_y = roundf (all_points.arrayZ[i].y);
      encode_coord (cur_x - prev_x, flag, FLAG_X_SHORT, FLAG_X_SAME, x_coords);
      encode_coord (cur_y - prev_y, flag, FLAG_Y_SHORT, FLAG_Y_SAME, y_coords);
      encode_flag (flag, repeat, lastflag, flags);

      prev_x = cur_x;
      prev_y = cur_y;
      lastflag = flag;
    }

    unsigned len_before_instrs = 2 * header.numberOfContours + 2;
    unsigned len_instrs = instructions_length ();
    unsigned total_len = len_before_instrs + flags.length + x_coords.length + y_coords.length;

    if (!no_hinting)
      total_len += len_instrs;

    char *p = (char *) hb_malloc (total_len);
    if (unlikely (!p)) return false;

    const char *src = bytes.arrayZ + GlyphHeader::static_size;
    char *cur = p;
    hb_memcpy (p, src, len_before_instrs);

    cur += len_before_instrs;
    src += len_before_instrs;

    if (!no_hinting)
    {
      hb_memcpy (cur, src, len_instrs);
      cur += len_instrs;
    }

    hb_memcpy (cur, flags.arrayZ, flags.length);
    cur += flags.length;

    hb_memcpy (cur, x_coords.arrayZ, x_coords.length);
    cur += x_coords.length;

    hb_memcpy (cur, y_coords.arrayZ, y_coords.length);

    dest_bytes = hb_bytes_t (p, total_len);
    return true;
  }
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).