// Initialize the contour points based on the end points of the contours.
    contour_points.length = num_contours + 1;
    contour_points.arrayZ = (contour_point_t *) hb_malloc (contour_points.length * sizeof (contour_point_t));
    if (unlikely (!contour_points.arrayZ)) return false;

    for (unsigned i = 0; i < num_contours; i++)
    {
      contour_points.arrayZ[i].x = header.endPtsOfContours[i];
      contour_points.arrayZ[i].y = 0;
      contour_points.arrayZ[i].flag = 0;
    }

    contour_points.arrayZ[num_contours].x = header.endPtsOfContours[num_contours];
    contour_points.arrayZ[num_contours].y = 0;
    contour_points.arrayZ[num_contours].flag = 0;

    if (phantom_only) return true;

    // Allocate memory for the points array, including space for phantom points.
    contour_points.length = 2 * header.numberOfContours + 4;
    contour_points.arrayZ = (contour_point_t *) hb_realloc (contour_points.arrayZ, contour_points.length * sizeof (contour_point_t));
    if (unlikely (!contour_points.arrayZ)) return false;

    // Set the end points of each contour in the points array.
    for (unsigned i = 0; i < num_contours; i++)
    {
      contour_points.arrayZ[i + 1].x = header.endPtsOfContours[i];
      contour_points.arrayZ[i + 1].y = 0;
      contour_points.arrayZ[i + 1].flag = 0;
    }

    contour_points.arrayZ[0].x = header.endPtsOfContours[num_contours];
    contour_points.arrayZ[0].y = 0;
    contour_points.arrayZ[0].flag = 0;

    contour_points.arrayZ[num_contours + 1].x = header.endPtsOfContours[0];
    contour_points.arrayZ[num_contours + 1].y = 0;
    contour_points.arrayZ[num_contours + 1].flag = 0;

    contour_points.arrayZ[num_contours + 2].x = header.endPtsOfContours[num_contours];
    contour_points.arrayZ[num_contours + 2].y = 0;
    contour_points.arrayZ[num_contours + 2].flag = 0;

    contour_points.arrayZ[num_contours + 3].x = header.endPtsOfContours[0];
    contour_points.arrayZ[num_contours + 3].y = 0;
    contour_points.arrayZ[num_contours + 3].flag = 0;

    return true;