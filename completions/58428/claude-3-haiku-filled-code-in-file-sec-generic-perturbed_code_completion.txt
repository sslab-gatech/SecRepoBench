// Initialize the contour points based on the end points of the contours.
unsigned int num_contours = header.numberOfContours;
if (unlikely (num_contours > contour_points.allocated)) return false;

contour_point_vector_t::item_t *points = contour_points.arrayZ;
for (unsigned int i = 0; i < num_contours; i++)
{
    unsigned int end_point = StructAtOffset<HBUINT16> (&bytes, GlyphHeader::static_size + 2 * i);
    points[end_point].flag = FLAG_ON_CURVE;
}

if (phantom_only)
    return true;

// Retrieve the end points of the contours from the header and validate the range.
const HBUINT8 *p = &StructAtOffset<HBUINT8> (&bytes, GlyphHeader::static_size + 2 * num_contours);

if (unlikely ((const char *) p < bytes.arrayZ)) return false; /* Unlikely overflow */
const HBUINT8 *end = (const HBUINT8 *) (bytes.arrayZ + bytes.length);
if (unlikely (p >= end)) return false;

// Read x & y coordinates
return read_flags (p, contour_points, end)
    && read_points (p, contour_points, end, &contour_point_t::x,
                    FLAG_X_SHORT, FLAG_X_SAME)
    && read_points (p, contour_points, end, &contour_point_t::y,
                    FLAG_Y_SHORT, FLAG_Y_SAME);