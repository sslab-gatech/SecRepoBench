// Validate the number of contours and allocate memory for contour points
    if (unlikely(num_contours == 0 || num_contours > MAX_CONTOURS)) return false;

    contour_points.resize(endPtsOfContours[num_contours] + 1);
    if (unlikely(contour_points.length != endPtsOfContours[num_contours] + 1)) return false;

    // Initialize contour points and set flags
    for (unsigned i = 0; i < num_contours; i++) {
        unsigned start = (i == 0) ? 0 : endPtsOfContours[i - 1] + 1;
        unsigned end = endPtsOfContours[i];
        for (unsigned j = start; j <= end; j++) {
            contour_points.arrayZ[j].flag = 0; // Initialize flags to 0
        }
    }

    // If phantom_only is true, skip reading actual points
    if (phantom_only) {
        for (unsigned i = 0; i < 4; i++) {
            contour_points.arrayZ[contour_points.length - 4 + i].flag = 0;
        }
        return true;
    }