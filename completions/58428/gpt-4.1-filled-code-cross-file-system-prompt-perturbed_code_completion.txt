unsigned num_contours = header.numberOfContours;
if (unlikely (!num_contours)) return false;

// Validate endPtsOfContours array
if (unlikely (endPtsOfContours[num_contours - 1] >= header.numPoints)) return false;

// Allocate memory for contour points, including phantom points
unsigned num_points = endPtsOfContours[num_contours - 1] + 1;
unsigned total_points = num_points + 4; // 4 phantom points
if (!contour_points.resize (total_points)) return false;

// Set the end points of each contour in the points array
unsigned pt = 0;
for (unsigned c = 0; c < num_contours; c++)
{
  unsigned end_pt = endPtsOfContours[c];
  for (; pt <= end_pt; pt++)
    contour_points.arrayZ[pt].contour_end = (pt == end_pt);
}

// If phantom_only is true, skip the process of reading the actual points.
if (phantom_only)
  return true;