if (strstr(time_fmt, "%Y") || strstr(time_fmt, "%y")) {
    /* The time format already includes a year specifier */
}
else if (strstr(time_fmt, "%s")) {
    /* If the format contains epoch seconds, consider it contains year info */
    is_epoch = FLB_TRUE;
}
else {
    /* Prepend a year specifier to the provided time format */
    len = strlen(time_fmt) + 3; /* 2 for "%Y" and 1 for null terminator */
    p->time_fmt_year = flb_malloc(len);
    if (!p->time_fmt_year) {
        flb_errno();
        flb_free(p->time_fmt);
        flb_free(p->time_fmt_full);
        flb_free(p);
        return NULL;
    }
    snprintf(p->time_fmt_year, len, "%%Y%s", time_fmt);
}

/* Check for timezone indicators in the format */
if (strstr(time_fmt, "%z") || strstr(time_fmt, "%Z")) {
    /* Timezone information is included in the format */
    p->has_tz = FLB_TRUE;
}
else {
#ifdef HAVE_TZSET
    /* Platform supports tzset, so we assume a default timezone behavior */
    p->has_tz = FLB_TRUE;
#else
    flb_error("[parser:%s] Timezone information missing in time format and not supported on this platform", name);
    flb_free(p->time_fmt);
    flb_free(p->time_fmt_full);
    if (p->time_fmt_year) {
        flb_free(p->time_fmt_year);
    }
    flb_free(p);
    return NULL;
#endif
}

/* Handle fractional seconds: if "%L" is present, truncate the format there and keep pointer */
tmp = strstr(p->time_fmt, "%L");
if (tmp) {
    *tmp = '\0';
    p->time_frac = tmp + 2;
}
else {
    p->time_frac = NULL;
}

/* Process an optional fixed timezone offset if one is provided */
if (time_offset) {
    p->time_offset = flb_strdup(time_offset);
    if (!p->time_offset) {
        flb_errno();
        flb_free(p->time_fmt);
        flb_free(p->time_fmt_full);
        if (p->time_fmt_year) {
            flb_free(p->time_fmt_year);
        }
        flb_free(p);
        return NULL;
    }
}