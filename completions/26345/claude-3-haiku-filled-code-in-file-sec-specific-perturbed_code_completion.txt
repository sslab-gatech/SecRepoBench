// <MASK>
    // Check if the time format string contains a year specifier ("%Y" or "%y").
    // If found, set a flag indicating the presence of a year in the format.
    p->time_with_year = FLB_FALSE;
    if (strstr(time_fmt, "%Y") || strstr(time_fmt, "%y")) {
        p->time_with_year = FLB_TRUE;
    }

    // If the format contains "%s", set it as an epoch format and indicate it includes a year.
    if (strstr(time_fmt, "%s")) {
        p->time_fmt_year = flb_strdup(time_fmt);
        p->time_with_year = FLB_TRUE;
        p->time_as_epoch = FLB_TRUE;
    }
    else {
        // Otherwise, allocate memory to prepend a year ("%Y") to the time format string.
        len = strlen(time_fmt) + 3;
        p->time_fmt_year = flb_malloc(len);
        snprintf(p->time_fmt_year, len, "%%Y %s", time_fmt);
    }

    // Check if the time format contains timezone indicators ("%z", "%Z", etc.).
    p->time_with_tz = FLB_FALSE;
    if (strstr(time_fmt, "%z") || strstr(time_fmt, "%Z")) {
#ifdef FLB_HAVE_GMTOFF
        p->time_with_tz = FLB_TRUE;
#else
        flb_error("[parser:%s] time format '%s' contains timezone information, "
                  "but the platform does not support it", p->name, time_fmt);
        flb_free(p->time_fmt_full);
        flb_free(p->time_fmt_year);
        flb_free(p);
        return NULL;
#endif
    }

    // Determine the correct format string to use for fractional seconds handling.
    p->time_frac_secs = NULL;
    p->time_fmt_len = strlen(p->time_fmt_year);
    for (i = 0; i < p->time_fmt_len - 1; i++) {
        if (p->time_fmt_year[i] == '%' && p->time_fmt_year[i + 1] == 'L') {
            p->time_frac_secs = p->time_fmt_year + i + 2;
            p->time_fmt_year[i] = '\0';
            break;
        }
    }

    // Process an optional fixed timezone offset if provided, adjusting the offset variable.
    if (time_offset) {
        ret = flb_parser_tzone_offset(time_offset, strlen(time_offset), &p->time_offset);
        if (ret != 0) {
            flb_error("[parser:%s] invalid time offset '%s'", p->name, time_offset);
            flb_free(p->time_fmt_full);
            flb_free(p->time_fmt_year);
            flb_free(p->time_key);
            flb_free(p);
            flb_sds_destroy(time_offset);
            return NULL;
        }
        flb_sds_destroy(time_offset);
    }
    else {
        p->time_offset = 0;
    }

    return p;