/* Check if the time format string contains a year specifier ("%Y" or "%y").
     * If found, set a flag indicating the presence of a year in the format.
     * If the format contains "%s", set it as an epoch format and indicate it includes a year.
     * If neither is found, allocate memory to prepend a year ("%Y") to the time format string.
     * Check if the time format contains timezone indicators ("%z", "%Z", etc.).
     * If timezone support is enabled, set a flag indicating timezone is included.
     * Otherwise, log an error and clean up if the platform does not support timezone parsing.
     * Determine the correct format string to use for fractional seconds handling.
     * If fractional seconds ("%L") are found, truncate the format string at that position
     * and store a pointer to the location where fractional seconds should start.
     * Process an optional fixed timezone offset if provided, adjusting the offset variable.
     * Return NULL on failure and perform necessary cleanup in case of errors.
     */
    if (time_fmt) {
        parser->time_fmt_year = NULL;
        parser->time_with_year = FLB_FALSE;
        parser->time_with_tz = FLB_FALSE;
        parser->time_frac_secs = NULL;
        parser->time_frac_secs_len = 0;
        parser->time_offset = 0;

        if (strchr(time_fmt, '%')) {
            if (strchr(time_fmt, 'Y') || strchr(time_fmt, 'y')) {
                parser->time_with_year = FLB_TRUE;
            }
            else if (strchr(time_fmt, 's')) {
                parser->time_with_year = FLB_TRUE;
                parser->time_fmt_year = flb_strdup("%Y%m%d%H%M%S");
            }
            else {
                parser->time_fmt_year = flb_strdup("%Y%m%d%H%M%S");
            }

            if (strchr(time_fmt, 'z') || strchr(time_fmt, 'Z')) {
                if (flb_timezone_supported()) {
                    parser->time_with_tz = FLB_TRUE;
                }
                else {
                    flb_error("[parser:%s] Timezone parsing is not supported on this platform", name);
                    goto error;
                }
            }

            if (strchr(time_fmt, 'L')) {
                parser->time_frac_secs = strchr(time_fmt, 'L');
                parser->time_frac_secs_len = strlen(parser->time_frac_secs);
            }
        }
        else {
            flb_error("[parser:%s] Invalid time format '%s'", name, time_fmt);
            goto error;
        }

        if (time_offset) {
            if (flb_parser_tzone_offset(time_offset, strlen(time_offset), &parser->time_offset) < 0) {
                flb_error("[parser:%s] Invalid timezone offset '%s'", name, time_offset);
                goto error;
            }
        }
    }

    return NULL;

error:
    if (parser->time_fmt_year) {
        flb_free(parser->time_fmt_year);
    }
    if (parser->time_frac_secs) {
        flb_free(parser->time_frac_secs);
    }
    return NULL;