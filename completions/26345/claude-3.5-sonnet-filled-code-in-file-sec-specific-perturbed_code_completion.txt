if (strstr(time_fmt, "%Y") || strstr(time_fmt, "%y")) {
    p->time_with_year = FLB_TRUE;
} else if (strstr(time_fmt, "%s")) {
    is_epoch = FLB_TRUE;
    p->time_with_year = FLB_TRUE;
} else {
    p->time_with_year = FLB_FALSE;
    tmp = flb_malloc(strlen(time_fmt) + 3);
    if (!tmp) {
        flb_errno();
        flb_interim_parser_destroy(p);
        return NULL;
    }
    sprintf(tmp, "%%Y %s", time_fmt);
    p->time_fmt_year = tmp;
}

p->time_with_tz = FLB_FALSE;
if (strstr(time_fmt, "%z") || strstr(time_fmt, "%Z")) {
#if !defined(FLB_HAVE_GMTOFF) && !defined(FLB_HAVE_TIMEZONE)
    flb_warn("[parser] timezone parsing not supported in this platform");
#else
    p->time_with_tz = FLB_TRUE;
#endif
}

if ((tmp = strstr(time_fmt, "%L")) != NULL) {
    tmp[0] = '\0';
    p->time_frac_secs = tmp + 1;
}

if (time_offset) {
    diff = 0;
    len = strlen(time_offset);
    ret = flb_parser_tzone_offset(time_offset, len, &diff);
    if (ret == -1) {
        flb_interim_parser_destroy(p);
        return NULL;
    }
    p->time_offset = diff;
}

size = strlen(p->time_fmt);
p->time_fmt_full = flb_malloc(size + 1);
if (!p->time_fmt_full) {
    flb_errno();
    flb_interim_parser_destroy(p);
    return NULL;
}
strcpy(p->time_fmt_full, p->time_fmt);