{
        int found_year = FLB_FALSE;
        char *ptr;

        /* Check if time format is epoch ("%s") */
        ptr = strstr(p->time_fmt, "%s");
        if (ptr) {
            is_epoch = FLB_TRUE;
            found_year = FLB_TRUE;
        }
        else {
            /* Check if year specifier is present ("%Y" or "%y") */
            if (strstr(p->time_fmt, "%Y") || strstr(p->time_fmt, "%y")) {
                found_year = FLB_TRUE;
            }
        }

        /* Prepend %Y if no year or epoch specifier found */
        if (!found_year) {
            size = strlen(p->time_fmt) + 3; /* +3 for "%Y" + null terminator */
            p->time_fmt_year = flb_malloc(size);
            if (!p->time_fmt_year) {
                flb_errno();
                flb_free(p->time_fmt);
                flb_free(p->time_fmt_full);
                flb_free(p);
                return NULL;
            }
            snprintf(p->time_fmt_year, size, "%%Y%s", p->time_fmt);
            p->time_fmt = p->time_fmt_year;
        }

        /* Check for timezone indicators */
        if (strstr(p->time_fmt, "%z") || strstr(p->time_fmt, "%Z")) {
#ifdef FLB_HAVE_REGEX
            p->time_with_tz = FLB_TRUE;
#else
            flb_error("[parser:%s] timezone indicators %%z/%%Z are not supported on this platform", name);
            flb_free(p->time_fmt);
            flb_free(p->time_fmt_full);
            if (p->time_fmt_year) {
                flb_free(p->time_fmt_year);
            }
            flb_free(p);
            return NULL;
#endif
        }

        /* Handle fractional seconds ("%L") */
        timeptr = strstr(p->time_fmt, "%L");
        if (timeptr) {
            len = timeptr - p->time_fmt;
            tmp = flb_calloc(1, len + 1);
            if (!tmp) {
                flb_errno();
                flb_free(p->time_fmt_full);
                if (p->time_fmt_year) {
                    flb_free(p->time_fmt_year);
                }
                flb_free(p->time_fmt);
                flb_free(p);
                return NULL;
            }
            memcpy(tmp, p->time_fmt, len);
            tmp[len] = '\0';
            flb_free(p->time_fmt);
            p->time_fmt = tmp;
            p->time_with_frac = FLB_TRUE;
        }

        /* Process optional fixed timezone offset */
        if (time_offset) {
            /* Parse the numeric offset */
            diff = atoi(time_offset);
            /* If needed, validate or adjust 'diff' here */
        }
    }