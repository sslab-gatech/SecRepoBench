// <MASK>
    if (time_fmt) {
        // Check if the time format string contains a year specifier ("%Y" or "%y").
        if (strstr(time_fmt, "%Y") || strstr(time_fmt, "%y")) {
            p->time_with_year = FLB_TRUE;
        }
        // If the format contains "%s", set it as an epoch format and indicate it includes a year.
        if (strstr(time_fmt, "%s")) {
            p->time_with_year = FLB_TRUE;
            p->time_as_epoch = FLB_TRUE;
        }
        // If neither is found, allocate memory to prepend a year ("%Y") to the time format string.
        else {
            size_t len = strlen(time_fmt) + 3;
            p->time_fmt_year = flb_malloc(len);
            snprintf(p->time_fmt_year, len, "%%Y %s", time_fmt);
            p->time_with_year = FLB_FALSE;
        }

        // Check if the time format contains timezone indicators ("%z", "%Z", etc.).
        if (strstr(time_fmt, "%z") || strstr(time_fmt, "%Z")) {
            p->time_with_tz = FLB_TRUE;
        }
        else {
            p->time_with_tz = FLB_FALSE;
        }

        // Determine the correct format string to use for fractional seconds handling.
        p->time_frac_secs = strstr(time_fmt, "%L");
        if (p->time_frac_secs) {
            *p->time_frac_secs = '\0';
            p->time_frac_secs++;
        }

        // Process an optional fixed timezone offset if provided, adjusting the offset variable.
        if (time_offset) {
            if (flb_parser_tzone_offset(time_offset, strlen(time_offset), &p->time_offset) != 0) {
                flb_error("[parser:%s] invalid time offset '%s'", p->name, time_offset);
                flb_free(p->time_fmt_full);
                flb_free(p->time_fmt);
                flb_free(p);
                flb_sds_destroy(time_offset);
                return NULL;
            }
            flb_sds_destroy(time_offset);
        }
    }
    return p;