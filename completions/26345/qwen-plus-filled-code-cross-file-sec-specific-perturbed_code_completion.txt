if (strstr(time_fmt, "%Y") || strstr(time_fmt, "%y")) {
    p->time_has_year = FLB_TRUE;
}
else if (strstr(time_fmt, "%s")) {
    is_epoch = FLB_TRUE;
    p->time_has_year = FLB_TRUE;
}
else {
    /* Prepend year to the format */
    size = strlen(time_fmt) + 4; /* 4 = "%Y " + null byte */
    tmp = flb_malloc(size);
    if (!tmp) {
        flb_errno();
        flb_free(p->time_fmt_full);
        flb_free(p->time_fmt);
        flb_free(p);
        return NULL;
    }
    snprintf(tmp, size, "%%Y %s", time_fmt);
    p->time_fmt_year = tmp;
}

/* Check for timezone indicators */
if (strstr(time_fmt, "%z") || strstr(time_fmt, "%Z")) {
    p->time_has_timezone = FLB_TRUE;
}
else {
#ifdef HAVE_TIMEZONE
    if (time_offset) {
        diff = parse_time_offset(time_offset);
        if (diff < 0) {
            flb_error("[parser:%s] Invalid time offset: %s", name, time_offset);
            flb_free(p->time_fmt_full);
            flb_free(p->time_fmt);
            if (p->time_fmt_year) {
                flb_free(p->time_fmt_year);
            }
            flb_free(p);
            return NULL;
        }
        p->time_offset = diff;
    }
    else {
        flb_warn("[parser:%s] Timezone not specified and not supported on this platform.", name);
    }
#else
    flb_error("[parser:%s] Timezone parsing not supported on this platform.", name);
    flb_free(p->time_fmt_full);
    flb_free(p->time_fmt);
    if (p->time_fmt_year) {
        flb_free(p->time_fmt_year);
    }
    flb_free(p);
    return NULL;
#endif
}

/* Handle fractional seconds */
if ((timeptr = strstr(time_fmt, "%L"))) {
    *timeptr = '\0'; /* Truncate at the fractional specifier */
    p->time_frac_ptr = timeptr;
}

if (is_epoch) {
    p->time_is_epoch = FLB_TRUE;
}