/* Check for year in the time format */
        if (strstr(time_fmt, "%Y") || strstr(time_fmt, "%y")) {
            p->time_with_year = FLB_TRUE;
        }
        else if (strstr(time_fmt, "%s")) {
            /* Epoch time */
            is_epoch = FLB_TRUE;
            p->time_with_year = FLB_TRUE;
        }
        else {
            /* No year, prepend %Y */
            size = strlen(time_fmt) + 4;
            tmp = flb_malloc(size);
            if (!tmp) {
                flb_errno();
                flb_free(p->time_fmt);
                flb_free(p->time_fmt_full);
                flb_free(p);
                return NULL;
            }
            snprintf(tmp, size, "%%Y %s", time_fmt);
            p->time_fmt_year = tmp;
        }

        /* Check for timezone in the time format */
        if (strstr(time_fmt, "%z") || strstr(time_fmt, "%Z") ||
            strstr(time_fmt, "%:z") || strstr(time_fmt, "%::z")) {
#ifdef FLB_HAVE_GMTOFF
            p->time_with_tz = FLB_TRUE;
#else
            flb_error("[parser:%s] time format includes timezone but platform "
                      "does not support timezone parsing", name);
            flb_free(p->time_fmt);
            flb_free(p->time_fmt_full);
            if (p->time_fmt_year) {
                flb_free(p->time_fmt_year);
            }
            flb_free(p);
            return NULL;
#endif
        }

        /* Handle fractional seconds: look for %L */
        timeptr = strstr(time_fmt, "%L");
        if (timeptr) {
            /* Truncate at %L for the main format, store pointer for frac */
            len = timeptr - time_fmt;
            tmp = flb_malloc(len + 1);
            if (!tmp) {
                flb_errno();
                flb_free(p->time_fmt);
                flb_free(p->time_fmt_full);
                if (p->time_fmt_year) {
                    flb_free(p->time_fmt_year);
                }
                flb_free(p);
                return NULL;
            }
            memcpy(tmp, time_fmt, len);
            tmp[len] = '\0';
            flb_free(p->time_fmt);
            p->time_fmt = tmp;
            p->time_frac = timeptr;
        }
        else {
            p->time_frac = NULL;
        }

        /* Handle fixed time offset if provided */
        if (time_offset) {
            diff = flb_parser_time_offset_seconds(time_offset);
            if (diff == -1) {
                flb_error("[parser:%s] invalid time_offset '%s'", name, time_offset);
                flb_free(p->time_fmt);
                flb_free(p->time_fmt_full);
                if (p->time_fmt_year) {
                    flb_free(p->time_fmt_year);
                }
                flb_free(p);
                return NULL;
            }
            p->time_offset = diff;
        }
        else {
            p->time_offset = 0;
        }

        p->time_is_epoch = is_epoch;