{
    char *s;
    int year_found = FLB_FALSE;

    /* Check if format includes year specifier or epoch */
    s = strstr(p->time_fmt, "%Y");
    if (!s) {
        s = strstr(p->time_fmt, "%y");
    }
    if (s) {
        year_found = FLB_TRUE;
    }
    s = strstr(p->time_fmt, "%s");
    if (s) {
        is_epoch = FLB_TRUE;
        year_found = FLB_TRUE;
    }

    /* If no year specifier found (and not epoch), prepend YEAR */
    if (!year_found) {
        len = strlen(p->time_fmt) + 3; /* space for "%Y" + original + null */
        p->time_fmt_year = flb_malloc(len);
        if (!p->time_fmt_year) {
            flb_free(p->time_fmt);
            flb_free(p->time_fmt_full);
            mk_list_del(&p->_head);
            flb_free(p);
            return NULL;
        }
        snprintf(p->time_fmt_year, len, "%%Y%s", p->time_fmt);
    }
    else {
        p->time_fmt_year = NULL;
    }

    /* Check for fractional seconds indicator "%L" */
    s = strstr(p->time_fmt, "%L");
    if (s) {
        /* handle fractional seconds if needed */
    }

    /* Check for timezone indicators, e.g. "%z" */
    s = strstr(p->time_fmt, "%z");
    if (s) {
#ifdef FLB_HAVE_STRPTIME_TZ
        /* Platform supports timezone parsing */
#else
        flb_error("[parser:%s] timezone format (%%z) not supported", name);
        flb_free(p->time_fmt);
        flb_free(p->time_fmt_full);
        if (p->time_fmt_year) {
            flb_free(p->time_fmt_year);
        }
        mk_list_del(&p->_head);
        flb_free(p);
        return NULL;
#endif
    }

    /* Process optional time offset if given */
    if (time_offset) {
        /* Example of validating/parsing offset; actual logic not shown */
        /* If invalid, free allocations and return NULL */
    }
}