if (strstr(time_fmt, "%Y") || strstr(time_fmt, "%y")) {
    p->time_with_year = FLB_TRUE;
} else if (strstr(time_fmt, "%s")) {
    is_epoch = FLB_TRUE;
    p->time_with_year = FLB_TRUE;
} else {
    tmp = flb_malloc(strlen(time_fmt) + 3);
    if (!tmp) {
        flb_errno();
        flb_interim_parser_destroy(p);
        return NULL;
    }
    sprintf(tmp, "%%Y %s", time_fmt);
    p->time_with_year = FLB_FALSE;
    p->time_fmt_year = flb_strdup(tmp);
    flb_free(tmp);
}

if (strstr(time_fmt, "%z") || strstr(time_fmt, "%Z")) {
#ifdef FLB_HAVE_GMTOFF
    p->time_with_tz = FLB_TRUE;
#else
    flb_error("[parser] timezone parsing is not supported on this platform");
    flb_interim_parser_destroy(p);
    return NULL;
#endif
}

if ((timeptr = strstr(time_fmt, "%L")) != NULL) {
    tmp = flb_malloc(strlen(time_fmt) + 1);
    if (!tmp) {
        flb_errno();
        flb_interim_parser_destroy(p);
        return NULL;
    }
    p->time_frac_secs = flb_strdup(timeptr + 2);
    if (!p->time_frac_secs) {
        flb_errno();
        flb_free(tmp);
        flb_interim_parser_destroy(p);
        return NULL;
    }
    len = timeptr - time_fmt;
    memcpy(tmp, time_fmt, len);
    tmp[len] = '\0';
    flb_free(p->time_fmt);
    p->time_fmt = tmp;
}

if (is_epoch == FLB_FALSE) {
    p->time_fmt_full = flb_strdup(p->time_fmt);
}

if (time_offset) {
    diff = 0;
    len = strlen(time_offset);
    ret = flb_parser_tzone_offset(time_offset, len, &diff);
    if (ret == -1) {
        flb_error("[parser] Invalid time offset %s", time_offset);
        flb_interim_parser_destroy(p);
        return NULL;
    }
    p->time_offset = diff;
}