// Check if the time format string contains a year specifier ("%Y" or "%y").
    // If found, set a flag indicating the presence of a year in the format.
    if (strstr(time_fmt, "%Y") || strstr(time_fmt, "%y")) {
        p->time_with_year = FLB_TRUE;
    }
    else {
        p->time_with_year = FLB_FALSE;
    }

    // If the format contains "%s", set it as an epoch format and indicate it includes a year.
    if (strstr(time_fmt, "%s")) {
        p->time_with_year = FLB_TRUE;
        p->time_as_epoch = FLB_TRUE;
    }
    else {
        p->time_as_epoch = FLB_FALSE;
    }

    // If neither year specifier nor epoch format is found, allocate memory to prepend a year ("%Y") to the time format string.
    if (p->time_with_year == FLB_FALSE && p->time_as_epoch == FLB_FALSE) {
        size_t len = strlen(time_fmt) + 3;
        p->time_fmt_year = flb_malloc(len);
        if (!p->time_fmt_year) {
            flb_errno();
            flb_interim_parser_destroy(p);
            return NULL;
        }
        snprintf(p->time_fmt_year, len, "%%Y %s", time_fmt);
    }

    // Check if the time format contains timezone indicators ("%z", "%Z", etc.).
    if (strstr(time_fmt, "%z") || strstr(time_fmt, "%Z")) {
        p->time_with_tz = FLB_TRUE;
    }
    else {
        p->time_with_tz = FLB_FALSE;
    }

#ifdef FLB_HAVE_GMTOFF
    // If timezone support is enabled, set a flag indicating timezone is included.
    p->time_with_tz = FLB_TRUE;
#else
    // Otherwise, log an error and clean up if the platform does not support timezone parsing.
    if (p->time_with_tz == FLB_TRUE) {
        flb_error("[parser:%s] time format contains timezone specifiers, but the platform does not support it", name);
        flb_interim_parser_destroy(p);
        return NULL;
    }
#endif

    // Determine the correct format string to use for fractional seconds handling.
    p->time_frac_secs = strstr(time_fmt, "%L");
    if (p->time_frac_secs) {
        *p->time_frac_secs = '\0';
        p->time_frac_secs++;
    }

    // Process an optional fixed timezone offset if provided, adjusting the offset variable.
    if (time_offset) {
        if (flb_parser_tzone_offset(time_offset, strlen(time_offset), &p->time_offset) != 0) {
            flb_error("[parser:%s] invalid time_offset value '%s'", name, time_offset);
            flb_interim_parser_destroy(p);
            return NULL;
        }
    }

    return p;