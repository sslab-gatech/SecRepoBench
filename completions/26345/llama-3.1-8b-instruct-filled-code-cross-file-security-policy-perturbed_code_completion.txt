if (time_fmt) {
    p->time_fmt_full = flb_strdup(time_fmt);
    p->time_fmt = flb_strdup(time_fmt);

    /* Check if the format is considering the year */
    is_epoch = FLB_FALSE;
    if (strchr(time_fmt, '%Y')!= NULL || strchr(time_fmt, '%y')!= NULL) {
        is_epoch = FLB_TRUE;
    }
    if (strchr(time_fmt, '%s')!= NULL) {
        is_epoch = FLB_TRUE;
    }
    if (!is_epoch) {
        tmp = flb_malloc(strlen(time_fmt) + 3);
        if (!tmp) {
            flb_errno();
            return NULL;
        }
        sprintf(tmp, "%s%%Y", time_fmt);
        p->time_fmt_year = tmp;
    }

    /* Check if the time format contains timezone indicators */
    if (strchr(time_fmt, '%z')!= NULL || strchr(time_fmt, '%Z')!= NULL) {
        p->time_fmt_has_timezone = FLB_TRUE;
    }
    else {
        if (!flb_timezone_supported()) {
            flb_error("[parser:%s] Timezone support is not enabled on this platform", name);
            flb_free(p->time_fmt_year);
            flb_free(p->time_fmt);
            flb_free(p->time_fmt_full);
            flb_free(p);
            return NULL;
        }
    }

    /* Determine the correct format string to use for fractional seconds handling */
    timeptr = strchr(time_fmt, '%L');
    if (timeptr!= NULL) {
        p->time_fmt_frac = timeptr - time_fmt;
        p->time_fmt = flb_strndup(time_fmt, p->time_fmt_frac);
    }

    /* Process an optional fixed timezone offset if provided, adjusting the offset variable */
    if (time_offset) {
        p->time_offset = flb_strdup(time_offset);
    }
}