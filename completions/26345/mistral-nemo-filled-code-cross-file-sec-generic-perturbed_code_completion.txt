/* Check if the time format string contains a year specifier ("%Y" or "%y").
     * If found, set a flag indicating the presence of a year in the format.
     * If the format contains "%s", set it as an epoch format and indicate it includes a year.
     * If neither is found, allocate memory to prepend a year ("%Y") to the time format string.
     * Check if the time format contains timezone indicators ("%z", "%Z", etc.).
     * If timezone support is enabled, set a flag indicating timezone is included.
     * Otherwise, log an error and clean up if the platform does not support timezone parsing.
     * Determine the correct format string to use for fractional seconds handling.
     * If fractional seconds ("%L") are found, truncate the format string at that position
     * and store a pointer to the location where fractional seconds should start.
     * Process an optional fixed timezone offset if provided, adjusting the offset variable.
     * Return NULL on failure and perform necessary cleanup in case of errors.
     */
    if (strstr(p->time_fmt, "%Y") || strstr(p->time_fmt, "%y")) {
        p->time_fmt_year = FLB_TRUE;
    }
    else if (strstr(p->time_fmt, "%s")) {
        p->time_fmt_year = FLB_TRUE;
        p->type = FLB_PARSER_EPOCH;
    }
    else {
        size_t len = strlen(p->time_fmt) + 5; /* +5 for "%Y " */
        p->time_fmt_year = FLB_FALSE;
        p->time_fmt_year = flb_malloc(len);
        snprintf(p->time_fmt_year, len, "%Y %s", p->time_fmt);
    }

    if (strstr(p->time_fmt, "%z") || strstr(p->time_fmt, "%Z")) {
        p->time_fmt_tz = FLB_TRUE;
    }
    else if (flb_timezone_supported() && flb_timezone_enabled()) {
        flb_error("[parser:%s] Timezone support is enabled but not found in time format",
                  name);
        flb_free(p);
        return NULL;
    }

    if (strstr(p->time_fmt, "%L")) {
        p->time_fmt_frac = FLB_TRUE;
        p->time_fmt_frac_ptr = strstr(p->time_fmt, "%L");
    }

    if (time_offset) {
        p->time_offset = atoi(time_offset);
    }