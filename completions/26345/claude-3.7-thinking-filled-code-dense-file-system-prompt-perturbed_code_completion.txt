if (strstr(p->time_fmt, "%Y") || strstr(p->time_fmt, "%y")) {
    p->time_with_year = FLB_TRUE;
}
else if (strstr(p->time_fmt, "%s")) {
    /* epoch */
    is_epoch = FLB_TRUE;
    p->time_with_year = FLB_TRUE;
}
else {
    size = strlen(p->time_fmt);
    p->time_with_year = FLB_FALSE;
    
    /* Prepare new format */
    p->time_fmt_year = flb_malloc(size + 4);
    if (!p->time_fmt_year) {
        flb_free(p->time_fmt);
        flb_free(p->time_fmt_full);
        flb_free(p->name);
        if (p->regex) {
            flb_regex_destroy(p->regex);
        }
        if (p->p_regex) {
            flb_free(p->p_regex);
        }
        flb_free(p);
        return NULL;
    }
    
    /* Append the year at the beginning */
    tmp = p->time_fmt_year;
    tmp[0] = '%';
    tmp[1] = 'Y';
    tmp[2] = ' ';
    memcpy(tmp + 3, p->time_fmt, size);
    tmp[size + 3] = '\0';
}

/* Check if the format contains timezone info */
if (strstr(p->time_fmt, "%z") || strstr(p->time_fmt, "%Z") ||
    strstr(p->time_fmt, "%SZ") || strstr(p->time_fmt, "%ISO")) {
#ifdef FLB_HAVE_GMTOFF
    p->time_with_tz = FLB_TRUE;
#else
    flb_error("[parser:%s] timezone in format string '%s' but not supported", 
              name, p->time_fmt);
    flb_free(p->time_fmt);
    flb_free(p->time_fmt_full);
    if (p->time_fmt_year) {
        flb_free(p->time_fmt_year);
    }
    flb_free(p->name);
    if (p->regex) {
        flb_regex_destroy(p->regex);
    }
    if (p->p_regex) {
        flb_free(p->p_regex);
    }
    flb_free(p);
    return NULL;
#endif
}

/* Check for fractional seconds */
if ((timeptr = strstr(p->time_fmt, "%L")) != NULL) {
    *timeptr = '\0';
    p->time_frac_secs = FLB_TRUE;
}

/* Optional fixed timezone offset */
if (time_offset) {
    diff = atoi(time_offset);
    p->time_offset = diff;
}