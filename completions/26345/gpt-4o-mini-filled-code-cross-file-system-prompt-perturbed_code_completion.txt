if (strstr(time_fmt, "%Y") || strstr(time_fmt, "%y")) {
            // Year specifier found
            p->time_fmt_year = flb_strdup(time_fmt);
        } else if (strstr(time_fmt, "%s")) {
            // Epoch format
            is_epoch = FLB_TRUE;
            p->time_fmt_year = flb_strdup("%Y %s");
        } else {
            // Prepend year to the time format
            size = strlen(time_fmt) + 3; // 3 for "%Y "
            p->time_fmt_year = flb_calloc(1, size);
            if (!p->time_fmt_year) {
                flb_free(p->time_fmt);
                flb_free(p->time_fmt_full);
                flb_free(p);
                return NULL;
            }
            snprintf(p->time_fmt_year, size, "%s %s", "%Y", time_fmt);
        }

        // Check for timezone indicators
        if (strstr(time_fmt, "%z") || strstr(time_fmt, "%Z")) {
            // Timezone support enabled
            p->time_has_timezone = FLB_TRUE;
        } else {
            flb_error("[parser:%s] Timezone support not enabled", name);
            flb_free(p->time_fmt);
            flb_free(p->time_fmt_full);
            flb_free(p->time_fmt_year);
            flb_free(p);
            return NULL;
        }

        // Handle fractional seconds
        char *frac_ptr = strstr(time_fmt, "%L");
        if (frac_ptr) {
            *frac_ptr = '\0'; // Truncate the format string
            p->time_fmt_frac = flb_strdup(frac_ptr);
        }

        // Process fixed timezone offset if provided
        if (time_offset) {
            // Adjust the offset variable accordingly
            // (Assuming time_offset is a valid string representation of the offset)
            p->time_offset = flb_strdup(time_offset);
        }