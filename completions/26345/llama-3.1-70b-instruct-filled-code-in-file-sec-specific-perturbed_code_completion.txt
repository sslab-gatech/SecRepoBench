// Check if the time format string contains a year specifier ("%Y" or "%y").
// If found, set a flag indicating the presence of a year in the format.
// If the format contains "%s", set it as an epoch format and indicate it includes a year.
// If neither is found, allocate memory to prepend a year ("%Y") to the time format string.
// Check if the time format contains timezone indicators ("%z", "%Z", etc.).
// If timezone support is enabled, set a flag indicating timezone is included.
// Otherwise, log an error and clean up if the platform does not support timezone parsing.
// Determine the correct format string to use for fractional seconds handling.
// If fractional seconds ("%L") are found, truncate the format string at that position
// and store a pointer to the location where fractional seconds should start.
// Process an optional fixed timezone offset if provided, adjusting the offset variable.
// Return NULL on failure and perform necessary cleanup in case of errors.

p->time_with_year = FLB_FALSE;
p->time_with_tz = FLB_FALSE;
p->time_frac_secs = NULL;

if (time_fmt) {
    if (strstr(time_fmt, "%Y")!= NULL || strstr(time_fmt, "%y")!= NULL) {
        p->time_with_year = FLB_TRUE;
    }
    else if (strstr(time_fmt, "%s")!= NULL) {
        p->time_with_year = FLB_TRUE;
        p->type = FLB_PARSER_EPOCH;
    }
    else {
        p->time_fmt_year = flb_malloc(strlen(time_fmt) + 6);
        if (!p->time_fmt_year) {
            flb_errno();
            flb_free(p->time_fmt);
            flb_free(p->time_fmt_full);
            return NULL;
        }
        sprintf(p->time_fmt_year, "%%Y %s", time_fmt);
    }

    if (strstr(time_fmt, "%z")!= NULL || strstr(time_fmt, "%Z")!= NULL) {
        p->time_with_tz = FLB_TRUE;
    }
    else if (strstr(time_fmt, "%:z")!= NULL || strstr(time_fmt, "%::z")!= NULL) {
        p->time_with_tz = FLB_TRUE;
    }
    else if (strstr(time_fmt, "%#z")!= NULL) {
        p->time_with_tz = FLB_TRUE;
    }

    if (p->time_with_tz == FLB_FALSE) {
        if (time_offset) {
            int tmdiff;
            if (flb_parser_tzone_offset(time_offset, strlen(time_offset), &tmdiff)!= 0) {
                flb_error("[parser] invalid time offset '%s'", time_offset);
                flb_free(p->time_fmt);
                flb_free(p->time_fmt_full);
                if (p->time_fmt_year) {
                    flb_free(p->time_fmt_year);
                }
                return NULL;
            }
            p->time_offset = tmdiff;
        }
    }
    else {
#ifdef FLB_HAVE_GMTOFF
        p->time_offset = 0;
#else
        flb_error("[parser] timezone support is not available in this platform");
        flb_free(p->time_fmt);
        flb_free(p->time_fmt_full);
        if (p->time_fmt_year) {
            flb_free(p->time_fmt_year);
        }
        return NULL;
#endif
    }

    p->time_frac_secs = strstr(time_fmt, "%L");
    if (p->time_frac_secs!= NULL) {
        *p->time_frac_secs = '\0';
    }
}