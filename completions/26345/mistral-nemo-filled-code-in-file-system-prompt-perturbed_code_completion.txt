/* Check if the time format string contains a year specifier ("%Y" or "%y").
       If found, set a flag indicating the presence of a year in the format.
       If the format contains "%s", set it as an epoch format and indicate it includes a year.
       If neither is found, allocate memory to prepend a year ("%Y") to the time format string.
       Check if the time format contains timezone indicators ("%z", "%Z", etc.).
       If timezone support is enabled, set a flag indicating timezone is included.
       Otherwise, log an error and clean up if the platform does not support timezone parsing.
       Determine the correct format string to use for fractional seconds handling.
       If fractional seconds ("%L") are found, truncate the format string at that position
       and store a pointer to the location where fractional seconds should start.
       Process an optional fixed timezone offset if provided, adjusting the offset variable.
       Return NULL on failure and perform necessary cleanup in case of errors.
       <MASK>
       {
           int year_specified = 0;
           int epoch_format = 0;
           int timezone_included = 0;
           char *year_ptr = NULL;
           char *tz_ptr = NULL;
           char *frac_ptr = NULL;
           char *tmp_fmt = NULL;
           char *tmp_fmt_year = NULL;
           int tmdiff = 0;
           int tmdiff_len = 0;
           int tmdiff_neg = 0;
           int tmdiff_hour = 0;
           int tmdiff_min = 0;

           if (time_fmt) {
               if (strstr(time_fmt, "%Y") || strstr(time_fmt, "%y")) {
                   year_specified = 1;
               }
               if (strstr(time_fmt, "%s")) {
                   epoch_format = 1;
               }
               if (strstr(time_fmt, "%z") || strstr(time_fmt, "%Z")) {
                   timezone_included = 1;
               }
               if (strstr(time_fmt, "%L")) {
                   frac_ptr = strstr(time_fmt, "%L");
               }
           }

           if (!year_specified && !epoch_format) {
               tmp_fmt_year = flb_malloc(strlen(time_fmt) + 5);
               if (!tmp_fmt_year) {
                   flb_error("[parser:%s] failed to allocate memory for time format with year", name);
                   goto error;
               }
               snprintf(tmp_fmt_year, strlen(time_fmt) + 5, "%Y %s", time_fmt);
               time_fmt_year = tmp_fmt_year;
           }

           if (time_offset) {
               tmdiff_len = flb_parser_tzone_offset(time_offset, strlen(time_offset), &tmdiff);
               if (tmdiff_len < 0) {
                   flb_error("[parser:%s] invalid timezone offset '%s'", name, time_offset);
                   goto error;
               }
               tmdiff_neg = (tmdiff < 0);
               tmdiff_hour = labs(tmdiff / 3600);
               tmdiff_min = labs((tmdiff % 3600) / 60);
           }

           if (time_fmt && timezone_included) {
               if (!flb_timezone_supported()) {
                   flb_error("[parser:%s] timezone parsing is not supported on this platform", name);
                   goto error;
               }
               tz_ptr = strstr(time_fmt, "%z");
               if (!tz_ptr) {
                   tz_ptr = strstr(time_fmt, "%Z");
               }
               if (tz_ptr) {
                   tmp_fmt = flb_malloc(strlen(time_fmt) + 1);
                   if (!tmp_fmt) {
                       flb_error("[parser:%s] failed to allocate memory for time format with timezone", name);
                       goto error;
                   }
                   memcpy(tmp_fmt, time_fmt, tz_ptr - time_fmt);
                   tmp_fmt[tz_ptr - time_fmt] = '\0';
                   if (tmdiff_neg) {
                       snprintf(tmp_fmt + (tz_ptr - time_fmt), strlen(time_fmt) - (tz_ptr - time_fmt) + 1, "+%02d%02d", tmdiff_hour, tmdiff_min);
                   }
                   else {
                       snprintf(tmp_fmt + (tz_ptr - time_fmt), strlen(time_fmt) - (tz_ptr - time_fmt) + 1, "-%02d%02d", tmdiff_hour, tmdiff_min);
                   }
                   time_fmt = tmp_fmt;
               }
           }

           if (frac_ptr) {
               tmp_fmt = flb_malloc(strlen(time_fmt) + 1);
               if (!tmp_fmt) {
                   flb_error("[parser:%s] failed to allocate memory for time format with fractional seconds", name);
                   goto error;
               }
               memcpy(tmp_fmt, time_fmt, frac_ptr - time_fmt);
               tmp_fmt[frac_ptr - time_fmt] = '\0';
               time_frac_secs = tmp_fmt + (frac_ptr - time_fmt);
           }
       }
       return NULL;

       error:
           if (tmp_fmt_year) {
               flb_free(tmp_fmt_year);
           }
           if (tmp_fmt) {
               flb_free(tmp_fmt);
           }
           return NULL;
       }