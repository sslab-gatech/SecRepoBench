if (strstr(p->time_fmt, "%Y") || strstr(p->time_fmt, "%y")) {
            p->time_with_year = FLB_TRUE;
        }
        else if (strstr(p->time_fmt, "%s")) {
            is_epoch = FLB_TRUE;
            p->time_with_year = FLB_TRUE;
        } else {
            size = strlen(p->time_fmt);
            p->time_fmt_year = flb_malloc(size + 6);
            if (!p->time_fmt_year) {
                flb_errno();
                flb_interim_parser_destroy(p);
                return NULL;
            }
            memcpy(p->time_fmt_year, "%Y ", 4);
            memcpy(p->time_fmt_year + 4, p->time_fmt, size + 1);
        }

        /* Check if the format contains timezone indicators */
        if (strstr(p->time_fmt, "%z") || strstr(p->time_fmt, "%Z") || is_epoch) {
#ifdef FLB_HAVE_TZSET
            p->time_with_tz = FLB_TRUE;
#else
            flb_error("[parser] timezone parsing not supported on this platform");
            flb_interim_parser_destroy(p);
            return NULL;
#endif
        }

        /*
         * Check if fractional seconds are included in the format.
         * If so, truncate the format string at the position of "%L"
         * and store a pointer to the location where fractional seconds
         * should start.
         */
        if ((timeptr = strstr(p->time_fmt, "%L"))) {
            diff = timeptr - p->time_fmt + 2;
            p->time_frac_secs = flb_strdup(p->time_fmt + diff);
            p->time_fmt[diff - 2] = '\0';
        }

        /* Timezone offset */
        if (time_offset) {
            len = flb_sds_len(time_offset);
            if (flb_parser_tzone_offset(time_offset, len, &p->time_offset) == -1) {
                flb_error("[parser] invalid Time_Offset '%s'", time_offset);
                flb_sds_destroy(time_offset);
                flb_interim_parser_destroy(p);
                return NULL;
            }
            flb_sds_destroy(time_offset);
        }