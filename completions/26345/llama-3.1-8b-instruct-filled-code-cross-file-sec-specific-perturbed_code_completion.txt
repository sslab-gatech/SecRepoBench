if (time_fmt) {
    p->time_fmt_full = flb_strdup(time_fmt);
    p->time_fmt = flb_strdup(time_fmt);

    /* Check if the format is considering the year */
    is_epoch = FLB_FALSE;
    if (strchr(time_fmt, '%Y')!= NULL || strchr(time_fmt, '%y')!= NULL) {
        is_epoch = FLB_TRUE;
    }
    if (strchr(time_fmt, '%s')!= NULL) {
        is_epoch = FLB_TRUE;
    }
    if (!is_epoch) {
        tmp = flb_malloc(strlen(time_fmt) + 3);
        if (!tmp) {
            flb_errno();
            return NULL;
        }
        sprintf(tmp, "%s%%Y", time_fmt);
        p->time_fmt_year = tmp;
    }

    /* Check if the time format contains timezone indicators */
    if (strchr(time_fmt, '%z')!= NULL || strchr(time_fmt, '%Z')!= NULL) {
        p->time_fmt_has_timezone = FLB_TRUE;
    } else {
        if (!flb_config_timezone_enabled()) {
            flb_error("[parser:%s] Timezone support is not enabled and the time format contains timezone indicators", name);
            flb_free(p->time_fmt_year);
            flb_free(p->time_fmt);
            flb_free(p->time_fmt_full);
            flb_free(p);
            return NULL;
        }
    }

    /* Determine the correct format string to use for fractional seconds handling */
    size_t frac_pos = strcspn(time_fmt, "%L");
    if (frac_pos!= strlen(time_fmt)) {
        tmp = flb_malloc(frac_pos + 1);
        if (!tmp) {
            flb_errno();
            return NULL;
        }
        strncpy(tmp, time_fmt, frac_pos);
        tmp[frac_pos] = '\0';
        p->time_fmt_frac = tmp;
    }

    /* Process an optional fixed timezone offset if provided, adjusting the offset variable */
    if (time_offset) {
        p->time_offset = flb_strdup(time_offset);
    }
}