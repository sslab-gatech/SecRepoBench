if (strstr(time_fmt, "%Y") || strstr(time_fmt, "%y")) {
    p->time_with_year = FLB_TRUE;
} else if (strstr(time_fmt, "%s")) {
    is_epoch = FLB_TRUE;
    p->time_with_year = FLB_TRUE;
} else {
    tmp = flb_malloc(strlen(time_fmt) + 3);
    if (!tmp) {
        flb_errno();
        flb_interim_parser_destroy(p);
        return NULL;
    }
    sprintf(tmp, "%%Y %s", time_fmt);
    p->time_with_year = FLB_FALSE;
    p->time_fmt_year = flb_strdup(tmp);
    flb_free(tmp);
}

if (strstr(time_fmt, "%z") || strstr(time_fmt, "%Z") ||
    strstr(time_fmt, "%SZ") || strstr(time_fmt, "%S.%LZ")) {
    p->time_with_tz = FLB_TRUE;
}
#if !defined(FLB_HAVE_GMTOFF) && !defined(FLB_HAVE_TIMEZONE)
else {
    flb_warn("[parser] timezone offset parsing is not supported on this platform");
}
#endif

if (is_epoch == FLB_FALSE) {
    int i;
    for (i = 0; i < strlen(time_fmt); ++i) {
        if (time_fmt[i] == '%' && time_fmt[i+1] == 'L') {
            p->time_frac_secs = flb_strdup(time_fmt + i + 2);
            tmp = flb_malloc(i + 2);
            memcpy(tmp, time_fmt, i);
            tmp[i] = '\0';
            timeptr = tmp;
            flb_free(p->time_fmt);
            p->time_fmt = tmp;
            break;
        }
    }
}

if (time_offset) {
    diff = 0;
    len = strlen(time_offset);
    ret = flb_parser_tzone_offset(time_offset, len, &diff);
    if (ret == -1) {
        flb_interim_parser_destroy(p);
        return NULL;
    }
    p->time_offset = diff;
}

return p;