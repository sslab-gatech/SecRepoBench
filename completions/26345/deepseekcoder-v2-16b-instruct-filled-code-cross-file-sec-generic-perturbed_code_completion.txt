// Check if the time format string contains a year specifier ("%Y" or "%y").
    // If found, set a flag indicating the presence of a year in the format.
    if (strstr(time_fmt, "%Y") || strstr(time_fmt, "%y")) {
        p->time_fmt_year = flb_strdup(time_fmt);
    }

    // Check if the format contains "%s", which is often used for epoch time.
    if (strstr(time_fmt, "%s")) {
        is_epoch = FLB_TRUE;
    }

    // Check if the time format contains timezone indicators ("%z", "%Z", etc.).
    if (strstr(time_fmt, "%z") || strstr(time_fmt, "%Z")) {
        p->timezone_included = FLB_TRUE;
    } else {
        // Log an error if the platform does not support timezone parsing.
        flb_error("[parser:%s] Timezone support is not available on this platform.", name);
        flb_free(p);
        return NULL;
    }

    // Determine the correct format string to use for fractional seconds handling.
    if (strstr(time_fmt, "%L")) {
        char *frac_pos = strstr(time_fmt, "%L");
        int frac_len = frac_pos - time_fmt;
        p->time_fmt_full = flb_strdup(time_fmt);
        p->time_fmt = flb_strdup(time_fmt);
        p->time_frac_start = frac_pos;
    } else {
        p->time_fmt_full = flb_strdup(time_fmt);
        p->time_fmt = flb_strdup(time_fmt);
    }

    // Process an optional fixed timezone offset if provided.
    if (time_offset) {
        // Adjust the offset variable.
        // This part depends on how the offset is handled in your code.
        // You may need to parse the offset and adjust the time_offset variable accordingly.
    }

    // Return NULL on failure and perform necessary cleanup in case of errors.
    if (is_epoch) {
        flb_error("[parser:%s] Time format includes epoch time, which is not supported.", name);
        flb_free(p);
        return NULL;
    }

    if (p->timezone_included == FLB_FALSE) {
        flb_error("[parser:%s] Time format does not include timezone information.", name);
        flb_free(p);
        return NULL;
    }

    return p;