{
    char *dup_fmt = p->time_fmt;
    char *frac_spec = NULL;

    /* Check for year indicators */
    if (strstr(dup_fmt, "%Y") || strstr(dup_fmt, "%y")) {
         p->time_fmt_year = flb_strdup(dup_fmt);
         if (!p->time_fmt_year) {
              flb_error("[parser:%s] memory allocation error", name);
              flb_free(p->time_fmt);
              flb_free(p->time_fmt_full);
              flb_free(p->name);
              flb_free(p);
              return NULL;
         }
    }
    else if (strstr(dup_fmt, "%s")) {
         /* Use epoch format which implies year information */
         is_epoch = FLB_TRUE;
    }
    else {
         /* Prepend "%Y" to the time format */
         len = strlen(dup_fmt) + 3; /* 2 extra chars for "%Y" */
         tmp = flb_malloc(len + 1);
         if (!tmp) {
              flb_error("[parser:%s] memory allocation error", name);
              flb_free(p->time_fmt);
              flb_free(p->time_fmt_full);
              flb_free(p->name);
              flb_free(p);
              return NULL;
         }
         snprintf(tmp, len + 1, "%%Y%s", dup_fmt);
         flb_free(p->time_fmt);
         p->time_fmt = tmp;
         p->time_fmt_year = flb_strdup("%%Y");
         if (!p->time_fmt_year) {
              flb_error("[parser:%s] memory allocation error", name);
              flb_free(p->time_fmt);
              flb_free(p->time_fmt_full);
              flb_free(p->name);
              flb_free(p);
              return NULL;
         }
    }

    /* Check for timezone indicators */
#ifdef FLB_HAVE_TZ_SUPPORT
    if (strstr(p->time_fmt, "%z") || strstr(p->time_fmt, "%Z")) {
         /* Mark that timezone information is present; assume p->has_tz is defined */
         p->has_tz = FLB_TRUE;
    }
#else
    if (strstr(p->time_fmt, "%z") || strstr(p->time_fmt, "%Z")) {
         flb_error("[parser:%s] timezone parsing not supported on this platform", name);
         flb_free(p->time_fmt_year);
         flb_free(p->time_fmt);
         flb_free(p->time_fmt_full);
         flb_free(p->name);
         flb_free(p);
         return NULL;
    }
#endif

    /* Handle fractional seconds: if "%L" is found, truncate format and store specifier */
    frac_spec = strstr(p->time_fmt, "%L");
    if (frac_spec) {
         *frac_spec = '\0';
         p->time_frac = flb_strdup("%L");
         if (!p->time_frac) {
              flb_error("[parser:%s] memory allocation error", name);
              flb_free(p->time_fmt_year);
              flb_free(p->time_fmt);
              flb_free(p->time_fmt_full);
              flb_free(p->name);
              flb_free(p);
              return NULL;
         }
    }
    else {
         p->time_frac = NULL;
    }

    /* Process an optional fixed timezone offset if provided */
    if (time_offset) {
         status = flb_parser_parse_tz_offset(time_offset, &p->time_offset);
         if (status != 0) {
              flb_error("[parser:%s] invalid timezone offset: %s", name, time_offset);
              if (p->time_frac) {
                   flb_free(p->time_frac);
              }
              flb_free(p->time_fmt_year);
              flb_free(p->time_fmt);
              flb_free(p->time_fmt_full);
              flb_free(p->name);
              flb_free(p);
              return NULL;
         }
    }
}