/* Check if the format is considering the year */
        if (strstr(time_fmt, "%Y") || strstr(time_fmt, "%y")) {
            p->time_with_year = FLB_TRUE;
        }
        else if (strstr(time_fmt, "%s")) {
            p->time_with_year = FLB_TRUE;
            is_epoch = FLB_TRUE;
        }
        else {
            len = strlen(time_fmt) + 3; /* 3 for "%Y" and null terminator */
            tmp = flb_malloc(len);
            if (!tmp) {
                flb_errno();
                flb_free(p->time_fmt);
                flb_free(p->time_fmt_full);
                flb_free(p);
                return NULL;
            }
            snprintf(tmp, len, "%%Y %s", time_fmt);
            flb_free(p->time_fmt);
            p->time_fmt = tmp;
        }

        /* Check for timezone indicators */
        if (strstr(time_fmt, "%z") || strstr(time_fmt, "%Z")) {
#ifdef FLB_HAVE_TIMESPEC
            p->time_with_tz = FLB_TRUE;
#else
            flb_error("[parser:%s] Timezone parsing not supported on this platform", name);
            flb_free(p->time_fmt);
            flb_free(p->time_fmt_full);
            flb_free(p);
            return NULL;
#endif
        }

        /* Handle fractional seconds */
        timeptr = strstr(p->time_fmt, "%L");
        if (timeptr) {
            diff = timeptr - p->time_fmt;
            size = strlen(p->time_fmt) - diff - 2; /* Exclude "%L" */
            tmp = flb_malloc(size + 1);
            if (!tmp) {
                flb_errno();
                flb_free(p->time_fmt);
                flb_free(p->time_fmt_full);
                flb_free(p);
                return NULL;
            }
            memcpy(tmp, p->time_fmt, diff);
            tmp[diff] = '\0';
            p->time_fmt_year = tmp;
        }
        else {
            p->time_fmt_year = flb_strdup(p->time_fmt);
        }

        /* Handle fixed timezone offset if provided */
        if (time_offset) {
            p->time_offset = atoi(time_offset);
        }
        else {
            p->time_offset = 0;
        }