if (strstr(time_fmt, "%Y") || strstr(time_fmt, "%y")) {
    diff = FLB_TRUE;
} else if (strstr(time_fmt, "%s")) {
    is_epoch = FLB_TRUE;
    diff = FLB_TRUE;
} else {
    size = strlen(time_fmt) + 32;
    p->time_fmt_year = flb_malloc(size);
    if (!p->time_fmt_year) {
        flb_errno();
        flb_parser_destroy(p);
        return NULL;
    }
    snprintf(p->time_fmt_year, size, "%%Y %s", time_fmt);
}

/* Check for timezone indicators */
if (strstr(time_fmt, "%z") || strstr(time_fmt, "%Z") || strstr(time_fmt, "%::z") || 
    strstr(time_fmt, "%:::z") || strstr(time_fmt, "%:z")) {
    /* Timezone is included */
    p->timezone_included = FLB_TRUE;
} else {
    /* If timezone support is not enabled, log an error and clean up */
#ifdef HAVE_PARSER_TIME_WITH_TIMEZONE
    if (time_offset && !p->timezone_included) {
        flb_error("[parser] Time format does not include timezone information, but offset is provided.");
        flb_parser_destroy(p);
        return NULL;
    }
#else
    if (time_offset) {
        flb_error("[parser] Parser does not support timezone parsing, but offset is provided.");
        flb_parser_destroy(p);
        return NULL;
    }
#endif
}

/* Handle fractional seconds */
timeptr = strstr(time_fmt, "%L");
if (timeptr) {
    len = timeptr - time_fmt;
    tmp = flb_malloc(len + 1);
    if (!tmp) {
        flb_errno();
        flb_parser_destroy(p);
        return NULL;
    }
    memcpy(tmp, time_fmt, len);
    tmp[len] = '\0';
    p->time_fmt_trunc = tmp;
}

/* Process optional fixed timezone offset */
if (time_offset) {
    if (flb_time_parse_offset(time_offset, &diff) < 0) {
        flb_error("[parser] Invalid timezone offset: %s", time_offset);
        flb_parser_destroy(p);
        return NULL;
    }
}