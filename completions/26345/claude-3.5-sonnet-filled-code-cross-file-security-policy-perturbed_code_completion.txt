timeptr = strstr(p->time_fmt, "%Y");
if (!timeptr) {
    timeptr = strstr(p->time_fmt, "%y");
}

if (timeptr) {
    p->time_with_year = FLB_TRUE;
} else if (strstr(p->time_fmt, "%s")) {
    p->time_with_year = FLB_TRUE;
    is_epoch = FLB_TRUE;
} else {
    tmp = flb_malloc(strlen(p->time_fmt) + 3);
    if (!tmp) {
        flb_errno();
        flb_free(p->name);
        flb_free(p->p_regex);
        flb_free(p->time_fmt_full);
        flb_free(p->time_fmt);
        flb_regex_destroy(p->regex);
        flb_free(p);
        return NULL;
    }
    sprintf(tmp, "%s%s", "%Y ", p->time_fmt);
    flb_free(p->time_fmt);
    p->time_fmt = tmp;
    p->time_with_year = FLB_TRUE;
}

if (strstr(p->time_fmt, "%z") || strstr(p->time_fmt, "%Z") ||
    strstr(p->time_fmt, "%SZ") || strstr(p->time_fmt, "%:z")) {
#if !defined(FLB_HAVE_GMTOFF) && !defined(FLB_HAVE_TIMEZONE)
    flb_warn("[parser] timezone offset not supported");
    flb_free(p->name);
    flb_free(p->p_regex);
    flb_free(p->time_fmt_full);
    flb_free(p->time_fmt);
    flb_regex_destroy(p->regex);
    flb_free(p);
    return NULL;
#else
    p->time_with_tz = FLB_TRUE;
#endif
}

if ((tmp = strstr(p->time_fmt, "%L")) != NULL) {
    tmp[1] = 'l';
    p->time_frac_secs = (tmp + 2);
}

if (p->time_frac_secs) {
    *p->time_frac_secs = '\0';
}

if (is_epoch == FLB_FALSE) {
    p->time_fmt_year = flb_strdup(p->time_fmt);
}

if (time_offset) {
    diff = 0;
    len = strlen(time_offset);
    size = sizeof(int) * len;
    status = flb_parser_tzone_offset(time_offset, len, &diff);
    if (status == -1) {
        flb_free(p->name);
        flb_free(p->p_regex);
        flb_free(p->time_fmt_full);
        flb_free(p->time_fmt);
        flb_free(p->time_fmt_year);
        flb_regex_destroy(p->regex);
        flb_free(p);
        return NULL;
    }
    p->time_offset = diff;
}