if (forbiddenword) {
                    struct hentry* forbidden_check = lookup(st.c_str(), i);
                    while (forbidden_check) {
                      if (forbidden_check->astr &&
                          TESTAFF(forbidden_check->astr, forbiddenword, forbidden_check->alen)) {
                        st[i + compound_result->blen] = r;
                        continue;
                      }
                      forbidden_check = forbidden_check->next_homonym;
                    }
                  }
                  st[i + compound_result->blen] = r;
                  if (compound_result->astr &&
                      TESTAFF(compound_result->astr, forbiddenword, compound_result->alen)) {
                    return NULL;
                  }
                }
              }
              return rv_first;
            }
          } while (striple && !checkedstriple);  // end of striple loop

          if (checkedstriple) {
            i++;
            checkedstriple = 0;
            striple = 0;
          }

        }  // first word is ok condition

        if (soldi != 0) {
          i = soldi;
          soldi = 0;
          len = oldlen;
          cmin = oldcmin;
          cmax = oldcmax;
        }
        scpd++;

      } while (!onlycpdrule && simplifiedcpd &&
               scpd <= checkcpdtable.size());  // end of simplifiedcpd loop

      scpd = 0;
      wordnum = oldwordnum;
      numsyllable = oldnumsyllable;

      if (soldi != 0) {
        i = soldi;
        st.assign(word);  // XXX add more optim.
        soldi = 0;
        len = oldlen;
        cmin = oldcmin;
        cmax = oldcmax;
      } else
        st[i] = ch;

    } while (!defcpdtable.empty() && oldwordnum == 0 &&
             onlycpdrule++ < 1);  // end of onlycpd loop
  }

  return NULL;
}