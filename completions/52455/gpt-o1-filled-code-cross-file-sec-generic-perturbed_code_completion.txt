{
  // Temporarily truncate the string at the end of the current compound piece
  char saved_char = st[i + compound_result->blen];
  st[i + compound_result->blen] = '\0';

  // Check for typical faults or forbidden word pairs
  if ((checkcompoundrep && cpdrep_check(st, st.size())) || cpdwordpair_check(st, st.size())) {
    // Restore the original character and revert to previous state
    st[i + compound_result->blen] = saved_char;
    i = soldi;
    st.assign(word);
    len = oldlen;
    cmin = oldcmin;
    cmax = oldcmax;
    continue;
  }

  // If the 'forbiddenword' flag is set, look up the truncated string
  // If found forbidden, return NULL to reject the compound
  if (forbiddenword) {
    struct hentry* hx = lookup(st.c_str(), st.size());
    while (hx) {
      if (hx->astr && TESTAFF(hx->astr, forbiddenword, hx->alen)) {
        // Restore the original character before returning
        st[i + compound_result->blen] = saved_char;
        return NULL;
      }
      hx = hx->next_homonym;
    }
  }

  // Restore the original character before continuing
  st[i + compound_result->blen] = saved_char;
}