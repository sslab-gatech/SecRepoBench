// Iterate over each axis in the 'axes' array.
  for (unsigned int i = 0; i < axes.length; i++)
  {
    hb_tag_t axis_tag = axes[i].axisTag;
    const hb_ot_var_axis_info_t *axis_info = hb_ot_var_get_axis_info (fontface->table.fvar, axis_tag);

    // Check if the axis is present in the user's axis location settings.
    if (plan->user_axes_location.get (axis_tag, 0.0f) == 0.0f)
    {
      // If the axis is not set by the user, mark it as not pinned and update the index map.
      plan->normalized_coords[i] = 0;
      axis_not_pinned = true;
    }
    else
    {
      // If the axis is set by the user, normalize its value using user settings.
      float user_value = plan->user_axes_location.get (axis_tag, 0.0f);
      plan->normalized_coords[i] = hb_ot_var_normalize_axis_value (fontface->table.fvar, i, user_value);

      // If 'avar' data is available, remap the normalized value using the segment maps.
      if (has_avar && seg_maps)
      {
        const OT::SegmentMap *segment_map = seg_maps->get_segment_map (axis_tag);
        if (segment_map)
        {
          float remapped_value = segment_map->apply (plan->normalized_coords[i]);
          plan->normalized_coords[i] = remapped_value;
        }
      }

      // Set the normalized value in the plan's axes location and coordinates.
      plan->axes_location[i] = user_value;
    }

    // If the normalized value is not zero, mark the plan as not pinned at default.
    if (plan->normalized_coords[i] != 0)
    {
      plan->all_axes_pinned = false;
    }
  }

  // Update segment maps for 'avar' for the next axis, if applicable.
  if (has_avar && seg_maps)
  {
    seg_maps = nullptr; // This should be updated based on the actual implementation
  }