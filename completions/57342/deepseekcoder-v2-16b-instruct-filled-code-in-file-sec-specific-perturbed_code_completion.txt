hb_set_t cmap_unicodes_storage;
  const hb_map_t* unicode_glyphid_map = &unicode_glyphid_map_storage;

  if (!plan->accelerator) {
    cmap.collect_mapping (&cmap_unicodes_storage, &unicode_glyphid_map_storage);
    plan->unicode_to_new_gid_list.alloc (hb_min(unicodes->get_population ()
                                                + glyphs->get_population (),
                                                cmap_unicodes->get_population ()));
  } else {
    unicode_glyphid_map = &plan->accelerator->unicode_to_gid;
    cmap_unicodes = &plan->accelerator->unicodes;
  }

  if (plan->accelerator &&
      unicodes->get_population () < cmap_unicodes->get_population () &&
      glyphs->get_population () < cmap_unicodes->get_population ())
  {
    auto &gid_to_unicodes = plan->accelerator->gid_to_unicodes;
    for (hb_codepoint_t gid : *glyphs)
    {
      auto unicodes = gid_to_unicodes.get (gid);

      for (hb_codepoint_t cp : unicodes)
      {
        plan->codepoint_to_glyph->set (cp, gid);
        plan->unicode_to_new_gid_list.push (hb_pair (cp, gid));
      }
    }
    for (hb_codepoint_t cp : *unicodes)
    {
      /* Don't double-add entry. */
      if (plan->codepoint_to_glyph->has (cp))
        continue;

      hb_codepoint_t *gid;
      if (!unicode_glyphid_map->has(cp, &gid))
        continue;

      plan->codepoint_to_glyph->set (cp, *gid);
      plan->unicode_to_new_gid_list.push (hb_pair (cp, *gid));
    }
    plan->unicode_to_new_gid_list.qsort ();
  }
  else
  {
    for (hb_codepoint_t cp : *cmap_unicodes)
    {
      hb_codepoint_t gid = (*unicode_glyphid_map)[cp];
      if (!unicodes->has (cp) && !glyphs->has (gid))
        continue;

      plan->codepoint_to_glyph->set (cp, gid);
      plan->unicode_to_new_gid_list.push (hb_pair (cp, gid));
    }
  }

  /* Add gids which where requested, but not mapped in cmap */
  for (hb_codepoint_t gid : *glyphs)
  {
    if (gid >= plan->source->get_num_glyphs ())
      break;
    plan->_glyphset_gsub.add (gid);
  }