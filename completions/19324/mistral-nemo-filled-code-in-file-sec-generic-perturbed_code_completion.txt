if (packet->payload_length < MEMCACHED_MIN_LEN) {
  NDPI_LOG_INFO(ndpi_struct, "Packet too short for memcached\n");
  return;
}

if (packet->tcp) {
  if (packet->payload_length < MEMCACHED_MIN_LEN) {
    NDPI_LOG_INFO(ndpi_struct, "TCP packet too short for memcached\n");
    return;
  }
} else if (packet->udp) {
  if (packet->payload_length < MEMCACHED_MIN_UDP_LEN) {
    NDPI_LOG_INFO(ndpi_struct, "UDP packet too short for memcached\n");
    return;
  }
  offset += MEMCACHED_UDP_HDR_LEN;
  packet->payload_length -= MEMCACHED_UDP_HDR_LEN;
}

if (packet->payload_length < MCDR_END_LEN) {
  NDPI_LOG_INFO(ndpi_struct, "Packet too short for memcached END\n");
  return;
}

if (packet->payload[packet->payload_length - MCDR_END_LEN] != MCDR_END[0]) {
  NDPI_LOG_INFO(ndpi_struct, "Packet does not end with memcached END\n");
  return;
}

if (packet->payload[packet->payload_length - MCDR_END_LEN - 1] != MCDR_END[1]) {
  NDPI_LOG_INFO(ndpi_struct, "Packet does not end with memcached END\n");
  return;
}

*matches = 0;