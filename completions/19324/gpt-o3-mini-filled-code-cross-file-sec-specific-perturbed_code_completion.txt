#ifdef NDPI_ENABLE_LOG
  NDPI_LOG_INFO(ndpi_struct, "Performing memcached search");
#endif

/* Sanity check: ensure payload pointer is valid */
if(packet->payload == NULL)
  return;

u_int32_t *matches = NULL;

if(stream->l4_proto == IPPROTO_TCP) {
  /* For TCP packets, ensure the payload is long enough for memcached detection.
     (Assume 8 bytes as the minimum required length; adjust if needed.) */
  if(packet->payload_packet_len < 8)
    return;
  matches = &stream->memcached.tcp_matches;
} else if(stream->l4_proto == IPPROTO_UDP) {
  /* For UDP packets, ensure there's at least enough for the UDP header and memcached data.
     (Assume 8 bytes as the minimum memcached payload length; adjust if needed.) */
  if(packet->payload_packet_len < (sizeof(struct udphdr) + 8))
    return;

  /* Verify UDP header conditions */
  {
    struct udphdr *udp_hdr = (struct udphdr *)offset;
    /* Check that the UDP header's length field is sane */
    if(ntohs(udp_hdr->len) < (sizeof(struct udphdr) + 8))
      return;
  }

  /* Adjust offset and available payload length to skip the UDP header */
  offset += sizeof(struct udphdr);
  packet->payload_packet_len -= sizeof(struct udphdr);
  matches = &stream->memcached.udp_matches;
} else {
  return;
}