// Log that a memcached search is being performed.
NDPI_LOG_DBG2(ndpi_struct->ndpi_struct_pdump_file, "search memcached\n");

// Determine if the packet uses TCP or UDP.
if (packet->proto == IPPROTO_TCP) {
  // For TCP packets, check if the packet length meets the minimum required length.
  if (packet->payload_packet_len < 5) {
    NDPI_LOG_DBG2(ndpi_struct->ndpi_struct_pdump_file, "excluding memcached due to too short packet length\n");
    return;
  }
} else if (packet->proto == IPPROTO_UDP) {
  // For UDP packets, check if the packet length meets the minimum required length.
  if (packet->payload_packet_len < 8) {
    NDPI_LOG_DBG2(ndpi_struct->ndpi_struct_pdump_file, "excluding memcached due to too short packet length\n");
    return;
  }

  // If UDP, verify specific header conditions to determine protocol compliance.
  if (packet->payload[0]!= 0x80 || packet->payload[1]!= 0x00) {
    NDPI_LOG_DBG2(ndpi_struct->ndpi_struct_pdump_file, "excluding memcached due to non-compliant UDP header\n");
    return;
  }

  // Adjust the offset and length for UDP packets by skipping the UDP header length.
  offset += 8;
  packet->payload_packet_len -= 8;
}

// Update the `matches` pointer to point to the appropriate memcached matches counter
// within the flow structure based on the protocol type.
u_int *matches = (packet->proto == IPPROTO_TCP)? &stream->memcached_matches_tcp : &stream->memcached_matches_udp;

// If the packet does not meet the expected criteria, exclude the protocol and return.
if (packet->payload_packet_len < 5) {
  NDPI_LOG_DBG2(ndpi_struct->ndpi_struct_pdump_file, "excluding memcached due to too short packet length\n");
  return;
}