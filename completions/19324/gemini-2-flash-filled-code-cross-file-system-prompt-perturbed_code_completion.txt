u_int16_t udp_header_len = 8;
  u_int32_t *matches = &stream->memcached_matches;

  NDPI_LOG(3, "%s: search memcached\n", __FUNCTION__);

  if(packet->l4_proto == IPPROTO_TCP) {
    if(packet->payload_len < 4) {
      NDPI_LOG(4, "exclude memcached due to payload too small (%u < 4)\n",
	       packet->payload_len);
      NDPI_ADD_PROTOCOL_TO_BITMASK(stream->exclude_protocol_bitmask, NDPI_PROTOCOL_MEMCACHED);
      return;
    }
  } else if(packet->l4_proto == IPPROTO_UDP) {
    if(packet->payload_len < (4 + udp_header_len)) {
      NDPI_LOG(4, "exclude memcached due to payload too small (%u < %u)\n",
	       packet->payload_len, (4 + udp_header_len));
      NDPI_ADD_PROTOCOL_TO_BITMASK(stream->exclude_protocol_bitmask, NDPI_PROTOCOL_MEMCACHED);
      return;
    }

    /* RFC 6455, Section 4 */
    if((offset[0] & 0xF0) != 0x80) {
      NDPI_LOG(4, "exclude memcached due to invalid header\n");
      NDPI_ADD_PROTOCOL_TO_BITMASK(stream->exclude_protocol_bitmask, NDPI_PROTOCOL_MEMCACHED);
      return;
    }

    offset += udp_header_len;
  } else {
    NDPI_ADD_PROTOCOL_TO_BITMASK(stream->exclude_protocol_bitmask, NDPI_PROTOCOL_MEMCACHED);
    return;
  }

  matches = &stream->memcached_matches;
  *matches = 0;