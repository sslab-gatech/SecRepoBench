u_int16_t min_len;
  u_int32_t *matches;
  
  // Determine if the packet is TCP or UDP
  if(packet->detected_protocol_stack[0] == NDPI_PROTOCOL_TCP) {
    min_len = MEMCACHED_TCP_MIN_LEN;
    matches = &stream->memcached_tcp_matches;
  } else if(packet->detected_protocol_stack[0] == NDPI_PROTOCOL_UDP) {
    min_len = MEMCACHED_UDP_MIN_LEN;
    matches = &stream->memcached_udp_matches;
    
    // Check if the packet length is sufficient
    if(packet->payload_packet_len < min_len) {
      NDPI_EXCLUDE_PROTO(ndpi_struct, stream);
      return;
    }
    
    // Verify specific header conditions for UDP
    if(offset[0] != 0x00 || offset[1] != 0x00 || offset[2] != 0x00 || offset[3] != 0x00) {
      NDPI_EXCLUDE_PROTO(ndpi_struct, stream);
      return;
    }
    
    // Adjust offset and length for UDP
    offset += 8;
  } else {
    NDPI_EXCLUDE_PROTO(ndpi_struct, stream);
    return;
  }
  
  // Check if the packet length is sufficient for TCP
  if(packet->payload_packet_len < min_len) {
    NDPI_EXCLUDE_PROTO(ndpi_struct, stream);
    return;
  }