u_int8_t *matches = &stream->protos.memcached.matches;
  u_int16_t min_len = (packet->l4_proto == IPPROTO_TCP) ? MEMCACHED_MIN_LEN_TCP : MEMCACHED_MIN_LEN_UDP;

  // Log that a memcached search is being performed.
  NDPI_LOG_DBG2(ndpi_struct, "memcached search...");

  // Determine if the packet uses TCP or UDP.
  if(packet->l4_proto == IPPROTO_TCP) {
    // For TCP packets, check if the packet length meets the minimum required length.
    if(packet->payload_len < min_len) return;
  } else if(packet->l4_proto == IPPROTO_UDP) {
    // For UDP packets, check if the packet length meets the minimum required length.
    if(packet->payload_len < min_len + 8) return;

    // If UDP, verify specific header conditions to determine protocol compliance.
    if(offset[0] != 0x00 || offset[1] != 0x00) return;

    // Adjust the offset and length for UDP packets by skipping the UDP header length.
    offset += 4;
  } else {
    return;
  }

  // Update the `matches` pointer to point to the appropriate memcached matches counter
  // within the flow structure based on the protocol type.

  // If the packet does not meet the expected criteria, exclude the protocol and return.