if (packet->udp != NULL) {
    if (packet->payload_packet_len < MEMCACHED_MIN_UDP_LEN) {
      return;
    }
    offset += MEMCACHED_UDP_HDR_LEN;
    packet->payload_packet_len -= MEMCACHED_UDP_HDR_LEN;
  } else if (packet->tcp != NULL) {
    if (packet->payload_packet_len < MEMCACHED_MIN_LEN) {
      return;
    }
  } else {
    return;
  }

  if (packet->udp != NULL) {
    // Verify specific header conditions for UDP packets
    // This part is hypothetical and depends on the actual UDP header structure
    // For example, check if the first byte is a specific value indicating a memcached packet
    if (offset[0] != 0x80) { // Hypothetical condition, adjust as needed
      return;
    }
  }

  // Update the `matches` pointer to point to the appropriate memcached matches counter
  // within the flow structure based on the protocol type.
  if (packet->udp != NULL) {
    matches = &stream->detected_protocol_stack.udp[ndpi_struct->memcached_udp_matches];
  } else {
    matches = &stream->detected_protocol_stack.tcp[ndpi_struct->memcached_tcp_matches];
  }