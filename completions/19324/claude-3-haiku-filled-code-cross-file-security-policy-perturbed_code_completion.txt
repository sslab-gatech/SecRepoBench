// Adjust the offset and length for UDP packets by skipping the UDP header length.
if (packet->tcp_udp.udp.version == IPVERSION) {
  offset += sizeof(struct udphdr);
  packet->payload_packet_len -= sizeof(struct udphdr);
}

// Update the `matches` pointer to point to the appropriate memcached matches counter
// within the flow structure based on the protocol type.
if (packet->tcp_udp.udp.version == IPVERSION) {
  matches = &stream->memcached_udp_count;
} else {
  matches = &stream->memcached_tcp_count;
}

// If the packet does not meet the expected criteria, exclude the protocol and return.
if (packet->payload_packet_len < MEMCACHED_MIN_PAYLOAD_LEN) {
  NDPI_LOG_DBG2(ndpi_struct, "Memcached: Exclude due to insufficient payload length\n");
  NDPI_ADD_PROTOCOL_TO_BITMASK(stream->excluded_protocol_bitmask, NDPI_PROTOCOL_MEMCACHED);
  return;
}

if (packet->tcp_udp.udp.version == IPVERSION) {
  if (packet->payload_packet_len < sizeof(struct udphdr) + MEMCACHED_MIN_PAYLOAD_LEN) {
    NDPI_LOG_DBG2(ndpi_struct, "Memcached: Exclude UDP due to insufficient payload length\n");
    NDPI_ADD_PROTOCOL_TO_BITMASK(stream->excluded_protocol_bitmask, NDPI_PROTOCOL_MEMCACHED);
    return;
  }

  if (ntohs(packet->tcp_udp.udp.len) != packet->payload_packet_len) {
    NDPI_LOG_DBG2(ndpi_struct, "Memcached: Exclude UDP due to invalid length\n");
    NDPI_ADD_PROTOCOL_TO_BITMASK(stream->excluded_protocol_bitmask, NDPI_PROTOCOL_MEMCACHED);
    return;
  }
}