{
  u_int32_t *matches = NULL;
  u_int16_t length = packet->payload_packet_len;

  NDPI_LOG_DBG2(ndpi_struct, "memcached.c", "Performing memcached search\n");

  /* Determine if the packet uses TCP or UDP */
  if (packet->l4_protocol == IPPROTO_TCP) {
    /* For TCP packets, check if the packet length meets the minimum required */
    if (length < MEMCACHED_TCP_MIN_LEN) {
      NDPI_LOG_DBG2(ndpi_struct, "memcached.c", "TCP payload too small for memcached\n");
      NDPI_ADD_PROTOCOL_TO_BITMASK(stream->excluded_protocol_bitmask, NDPI_PROTOCOL_MEMCACHED);
      return;
    }
    /* Update the matches pointer to the memcached matches counter for TCP */
    matches = &stream->l4.tcp.memcached_matches;
  } else if (packet->l4_protocol == IPPROTO_UDP) {
    /* For UDP packets, check if the packet length meets the minimum required */
    if (length < MEMCACHED_UDP_MIN_LEN + UDP_HEADER_LEN) {
      NDPI_LOG_DBG2(ndpi_struct, "memcached.c", "UDP payload too small for memcached\n");
      NDPI_ADD_PROTOCOL_TO_BITMASK(stream->excluded_protocol_bitmask, NDPI_PROTOCOL_MEMCACHED);
      return;
    }
    /* Verify specific header conditions if needed before adjusting offset */
    /* Skip the UDP header */
    offset += UDP_HEADER_LEN;
    length -= UDP_HEADER_LEN;

    if (length < MEMCACHED_UDP_MIN_LEN) {
      NDPI_LOG_DBG2(ndpi_struct, "memcached.c", "Insufficient data after skipping UDP header\n");
      NDPI_ADD_PROTOCOL_TO_BITMASK(stream->excluded_protocol_bitmask, NDPI_PROTOCOL_MEMCACHED);
      return;
    }
    /* Update the matches pointer to the memcached matches counter for UDP */
    matches = &stream->l4.udp.memcached_matches;
  } else {
    NDPI_ADD_PROTOCOL_TO_BITMASK(stream->excluded_protocol_bitmask, NDPI_PROTOCOL_MEMCACHED);
    return;
  }
}