u_int16_t payload_len = packet->payload_packet_len;
  u_int16_t udp_header_len = 0;
  u_int16_t tcp_header_len = 0;

  if (packet->detected_l4_proto == IPPROTO_UDP) {
    if (payload_len < sizeof(struct udphdr)) {
      return;
    }
    udp_header_len = ntohs(((struct udphdr *)offset)->uh_ulen) - sizeof(struct udphdr);
    offset += udp_header_len;
    payload_len -= udp_header_len;
  } else if (packet->detected_l4_proto == IPPROTO_TCP) {
    if (payload_len < sizeof(struct tcphdr)) {
      return;
    }
    tcp_header_len = ntohs(((struct tcphdr *)offset)->doff) * 4;
    offset += tcp_header_len;
    payload_len -= tcp_header_len;
  } else {
    return;
  }

  if (payload_len < MIN_MEMCACHED_PACKET_LEN) {
    return;
  }

  const u_int8_t *end = offset + payload_len;
  while (offset < end) {
    unsigned long id;
    int rc = ndpi_match_string_id(ndpi_struct->ac_automata, (char *)offset, payload_len, &id);
    if (rc == 0 && id != NDPI_PROTOCOL_UNKNOWN) {
      *matches += 1;
      break;
    }
    offset++;
  }