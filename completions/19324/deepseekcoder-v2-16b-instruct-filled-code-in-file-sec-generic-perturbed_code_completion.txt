else if (packet->udp != NULL && packet->payload_packet_len >= MEMCACHED_MIN_UDP_LEN) {
    if (packet->payload_packet_len >= (MEMCACHED_MIN_UDP_LEN + 4) &&
        offset[MEMCACHED_MIN_UDP_LEN - 4] == 'E' &&
        offset[MEMCACHED_MIN_UDP_LEN - 3] == 'R' &&
        offset[MEMCACHED_MIN_UDP_LEN - 2] == 'R' &&
        offset[MEMCACHED_MIN_UDP_LEN - 1] == 'O' &&
        offset[MEMCACHED_MIN_UDP_LEN] == 'R') {
      *matches += 1;
    }
  } else if (packet->payload_packet_len >= MEMCACHED_MIN_LEN) {
    // For TCP packets, check if the packet length meets the minimum required length.
    // Adjust the offset and length for TCP packets by skipping the TCP header length.
    // Update the `matches` pointer to point to the appropriate memcached matches counter
    // within the flow structure based on the protocol type.
    // If the packet does not meet the expected criteria, exclude the protocol and return.
    // <MASK>
  } else {
    return;
  }