// Log that a memcached search is being performed.
NDPI_LOG_DBG2(ndpi_struct->ndpi_main->log, "Searching for memcached protocol\n");

// Determine if the packet uses TCP or UDP.
if (packet->proto == IPPROTO_TCP) {
  // For TCP packets, check if the packet length meets the minimum required length.
  if (packet->payload_packet_len < 5) {
    NDPI_LOG_DBG2(ndpi_struct->ndpi_main->log, "TCP packet length is too small for memcached\n");
    return;
  }
} else if (packet->proto == IPPROTO_UDP) {
  // For UDP packets, check if the packet length meets the minimum required length.
  if (packet->payload_packet_len < 8) {
    NDPI_LOG_DBG2(ndpi_struct->ndpi_main->log, "UDP packet length is too small for memcached\n");
    return;
  }

  // If UDP, verify specific header conditions to determine protocol compliance.
  if (packet->udp_src_port!= 11211 && packet->udp_dst_port!= 11211) {
    NDPI_LOG_DBG2(ndpi_struct->ndpi_main->log, "UDP packet does not match memcached port\n");
    return;
  }

  // Adjust the offset and length for UDP packets by skipping the UDP header length.
  offset += 8;
  packet->payload_packet_len -= 8;
}

// Update the `matches` pointer to point to the appropriate memcached matches counter
// within the flow structure based on the protocol type.
u_int *matches;
if (packet->proto == IPPROTO_TCP) {
  matches = &stream->protos.tcp.memcached_matches;
} else {
  matches = &stream->protos.udp.memcached_matches;
}

// If the packet does not meet the expected criteria, exclude the protocol and return.
if (packet->payload_packet_len < 5) {
  NDPI_LOG_DBG2(ndpi_struct->ndpi_main->log, "Packet length is too small for memcached\n");
  return;
}