// Determine if the packet uses TCP or UDP.
if (packet->tcp_udp == 1) { // TCP
    if (packet->payload_packet_len < MEMCACHED_MIN_LEN) {
        NDPI_EXCLUDE_PROTO(ndpi_struct, stream);
        return;
    }
} else { // UDP
    if (packet->payload_packet_len < MEMCACHED_MIN_UDP_LEN) {
        NDPI_EXCLUDE_PROTO(ndpi_struct, stream);
        return;
    }

    // Verify specific header conditions to determine protocol compliance.
    if (get_u_int16_t(packet->payload, 0) != htons(0x8000) ||
        get_u_int16_t(packet->payload, 2) != 0 ||
        get_u_int16_t(packet->payload, 4) != 0 ||
        get_u_int16_t(packet->payload, 6) != 0) {
        NDPI_EXCLUDE_PROTO(ndpi_struct, stream);
        return;
    }

    // Adjust the offset and length for UDP packets by skipping the UDP header length.
    offset += MEMCACHED_UDP_HDR_LEN;
    length -= MEMCACHED_UDP_HDR_LEN;
}

// Update the `matches` pointer to point to the appropriate memcached matches counter
// within the flow structure based on the protocol type.
u_int16_t *matches = (packet->tcp_udp == 1) ? &stream->memcached_tcp_count : &stream->memcached_udp_count;