// <MASK>
if (packet->l3.protocol == IPPROTO_TCP) {
  if (packet->payload_len >= 5) {
    // Check if the packet length meets the minimum required length for TCP packets.
    if (offset[0] == 0x80 && offset[1] == 0x00 && offset[2] == 0x00 && offset[3] == 0x00) {
      // Check for the Memcached protocol magic number.
      if (offset[4] == 0x10) {
        // Adjust the offset and length for TCP packets by skipping the Memcached protocol magic number.
        offset += 5;
        packet->payload_len -= 5;
        // Update the `matches` pointer to point to the appropriate memcached matches counter
        // within the flow structure based on the protocol type.
        matches = &stream->memcached_matches;
      }
    }
  }
} else if (packet->l3.protocol == IPPROTO_UDP) {
  if (packet->payload_len >= 8) {
    // Check if the packet length meets the minimum required length for UDP packets.
    if (offset[0] == 0x10 && offset[1] == 0x00 && offset[2] == 0x00 && offset[3] == 0x00) {
      // Check for the Memcached protocol magic number.
      if (offset[4] == 0x10 && offset[5] == 0x00 && offset[6] == 0x00 && offset[7] == 0x00) {
        // Adjust the offset and length for UDP packets by skipping the UDP header length.
        offset += 8;
        packet->payload_len -= 8;
        // Update the `matches` pointer to point to the appropriate memcached matches counter
        // within the flow structure based on the protocol type.
        matches = &stream->memcached_matches;
      }
    }
  }
}

if (*matches >= MEMCACHED_MIN_MATCH)
  ndpi_int_memcached_add_connection(ndpi_struct, stream);