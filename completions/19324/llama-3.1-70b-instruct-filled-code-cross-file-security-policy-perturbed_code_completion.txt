u_int16_t length = packet->payload_packet_len;
u_int8_t *matches = NULL;

if (packet->protocol == IPPROTO_TCP) {
  if (length < 5) {
    NDPI_LOG_DBG2(ndpi_str, "TCP packet length is too small\n");
    goto exclude_protocol;
  }
} else if (packet->protocol == IPPROTO_UDP) {
  if (length < 8) {
    NDPI_LOG_DBG2(ndpi_str, "UDP packet length is too small\n");
    goto exclude_protocol;
  }

  // Verify specific header conditions to determine protocol compliance
  if (offset[0]!= 0x80 || offset[1]!= 0x08) {
    NDPI_LOG_DBG2(ndpi_str, "UDP packet does not meet header conditions\n");
    goto exclude_protocol;
  }

  // Adjust the offset and length for UDP packets by skipping the UDP header length
  offset += 8;
  length -= 8;
}

if (packet->protocol == IPPROTO_TCP) {
  matches = &stream->protos.tcp.memcached_matches;
} else if (packet->protocol == IPPROTO_UDP) {
  matches = &stream->protos.udp.memcached_matches;
}

if (*matches >= MEMCACHED_MIN_MATCH) {
  ndpi_int_memcached_add_connection(ndpi_struct, stream);
  return;
}

exclude_protocol:
  NDPI_ADD_PROTOCOL_TO_BITMASK(ndpi_struct, stream, NDPI_PROTOCOL_MEMCACHED);
  return;