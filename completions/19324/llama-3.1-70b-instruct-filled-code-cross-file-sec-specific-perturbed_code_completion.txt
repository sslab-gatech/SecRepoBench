// Determine if the packet uses TCP or UDP
if (packet->proto == IPPROTO_TCP) {
  // For TCP packets, check if the packet length meets the minimum required length
  if (packet->payload_packet_len < 8) {
    NDPI_LOG_DBG2(ndpi_struct->ndpi_main, "packet too short for memcached\n");
    return;
  }
} else if (packet->proto == IPPROTO_UDP) {
  // For UDP packets, check if the packet length meets the minimum required length
  if (packet->payload_packet_len < 8 + 8) {
    NDPI_LOG_DBG2(ndpi_struct->ndpi_main, "packet too short for memcached\n");
    return;
  }
  // Verify specific header conditions to determine protocol compliance
  if (packet->payload[0]!= 0x80 || packet->payload[1]!= 0x01) {
    NDPI_LOG_DBG2(ndpi_struct->ndpi_main, "not a memcached packet\n");
    return;
  }
  // Adjust the offset and length for UDP packets by skipping the UDP header length
  offset += 8;
  packet->payload_packet_len -= 8;
}

// Update the `matches` pointer to point to the appropriate memcached matches counter
// within the flow structure based on the protocol type
u_int *matches = (packet->proto == IPPROTO_TCP)? &stream->l4.tcp.memcached_matches : &stream->l4.udp.memcached_matches;