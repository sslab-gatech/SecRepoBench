// Determine if the packet uses TCP or UDP.
  if (packet->protocol == IPPROTO_TCP) {
    // For TCP packets, check if the packet length meets the minimum required length.
    if (packet->payload_length < MEMCACHED_MIN_LEN) {
      return;
    }
  } else if (packet->protocol == IPPROTO_UDP) {
    // For UDP packets, check if the packet length meets the minimum required length.
    if (packet->payload_length < MEMCACHED_MIN_UDP_LEN) {
      return;
    }
    // If UDP, verify specific header conditions to determine protocol compliance.
    if (packet->payload_length < MEMCACHED_UDP_HDR_LEN) {
      return;
    }
    // Adjust the offset and length for UDP packets by skipping the UDP header length.
    offset += MEMCACHED_UDP_HDR_LEN;
    packet->payload_length -= MEMCACHED_UDP_HDR_LEN;
  }

  // Update the `matches` pointer to point to the appropriate memcached matches counter
  // within the flow structure based on the protocol type.
  struct ndpi_flow_struct *flow = stream->flow;
  if (flow->matches == NULL) {
    flow->matches = malloc(sizeof(struct ndpi_matches_struct));
  }
  struct ndpi_matches_struct *matches = flow->matches;

  // If the packet does not meet the expected criteria, exclude the protocol and return.
  if (packet->payload_length < MEMCACHED_MIN_LEN) {
    return;
  }

  // <MASK>