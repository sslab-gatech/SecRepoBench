// <MASK>
  if (packet->l3.protocol == IPPROTO_TCP) {
    if (packet->payload_len < MEMCACHED_MIN_LEN_TCP) {
      return;
    }
    offset = packet->payload;
  } else if (packet->l3.protocol == IPPROTO_UDP) {
    if (packet->payload_len < MEMCACHED_MIN_LEN_UDP) {
      return;
    }
    // Adjust the offset and length for UDP packets by skipping the UDP header length
    offset = packet->payload + 8;
    packet->payload_len -= 8;
  } else {
    return;
  }

  // Update the `matches` pointer to point to the appropriate memcached matches counter
  // within the flow structure based on the protocol type.
  if (packet->l3.protocol == IPPROTO_TCP) {
    *matches = 0;
  } else if (packet->l3.protocol == IPPROTO_UDP) {
    *matches = 0;
  }

  // If the packet does not meet the expected criteria, exclude the protocol and return.
  if (packet->payload_len < MEMCACHED_MIN_LEN) {
    return;
  }

  // Check for specific header conditions to determine protocol compliance
  if (packet->l3.protocol == IPPROTO_TCP) {
    // Check for TCP header conditions
  } else if (packet->l3.protocol == IPPROTO_UDP) {
    // Check for UDP header conditions
  }

  // If the packet meets the expected criteria, proceed with the memcached search
  //...