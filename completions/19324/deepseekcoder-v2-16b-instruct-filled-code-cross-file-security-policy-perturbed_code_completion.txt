u_int16_t udp_header_length = 0;
  u_int16_t packet_length = packet->payload_packet_len;

  if (packet->detected_l4_proto == IPPROTO_UDP) {
    // UDP header length is 8 bytes (source port, dest port, length, checksum)
    udp_header_length = 8;
    offset += udp_header_length;
    packet_length -= udp_header_length;
  }

  // Adjust the offset and length for UDP packets by skipping the UDP header length.
  // Update the `matches` pointer to point to the appropriate memcached matches counter
  // within the flow structure based on the protocol type.
  // If the packet does not meet the expected criteria, exclude the protocol and return.

  if (packet->detected_l4_proto == IPPROTO_TCP) {
    if (packet_length < 4) { // Minimum length for a TCP packet to have a valid header
      return;
    }
  } else if (packet->detected_l4_proto == IPPROTO_UDP) {
    if (packet_length < 8) { // Minimum length for a UDP packet to have a valid header
      return;
    }
  } else {
    return; // Not TCP or UDP, exclude the protocol
  }

  // Now you can proceed with the rest of the function to check for memcached patterns
  // based on the adjusted offset and length.