qmin, enc->qmax);
        }
        break;
    case AVMEDIA_TYPE_AUDIO:
        {
            char detail[256] = "(";

            av_strlcat(buf, separator, buf_size);

            snprintf(buf + strlen(buf), buf_size - strlen(buf),
                     "%s", av_get_sample_fmt_name(enc->sample_fmt));
            if (enc->sample_rate)
                av_strlcatf(detail, sizeof(detail), "%d Hz, ", enc->sample_rate);
            if (enc->channel_layout)
                av_strlcatf(detail, sizeof(detail), "%s, ",
                            av_get_channel_layout_string(NULL, enc->channel_layout));
            if (enc->bits_per_sample)
                av_strlcatf(detail, sizeof(detail), "%d bps, ", enc->bits_per_sample);

            if (strlen(detail) > 1) {
                detail[strlen(detail) - 2] = 0;
                av_strlcatf(buf, buf_size, "%s)", detail);
            }
        }
        if (enc->bit_rate) {
            av_strlcat(buf, new_line ? separator : ", ", buf_size);

            snprintf(buf + strlen(buf), buf_size - strlen(buf),
                     "%"PRId64" kb/s", enc->bit_rate / 1000);
        }
        break;
    case AVMEDIA_TYPE_SUBTITLE:
        if (enc->subtitle_header) {
            av_strlcat(buf, new_line ? separator : ", ", buf_size);
            snprintf(buf + strlen(buf), buf_size - strlen(buf),
                     "subtitle: header size=%zu", enc->subtitle_header_size);
        }
        break;
    case AVMEDIA_TYPE_DATA:
        if (enc->extradata_size) {
            av_strlcat(buf, new_line ? separator : ", ", buf_size);
            snprintf(buf + strlen(buf), buf_size - strlen(buf),
                     "data: size=%zu", enc->extradata_size);
        }
        break;
    case AVMEDIA_TYPE_ATTACHMENT:
        if (enc->extradata_size) {
            av_strlcat(buf, new_line ? separator : ", ", buf_size);
            snprintf(buf + strlen(buf), buf_size - strlen(buf),
                     "attachment: size=%zu", enc->extradata_size);
        }
        break;
    default:
        break;
    }
}

int avcodec_get_frame_defaults(AVFrame *frame)
{
    int ret;

    if (!frame)
        return AVERROR(EINVAL);

    memset(frame, 0, sizeof(*frame));

    frame->pts = AV_NOPTS_VALUE;

    if ((ret = av_image_alloc(frame->data, frame->linesize,
                              frame->width, frame->height,
                              frame->format, 32)) < 0)
        return ret;

    frame->extended_data = frame->data;

    return 0;
}

int avcodec_get_context_defaults3(AVCodecContext *s, const AVCodec *codec)
{
    int ret;

    if (!s)
        return AVERROR(EINVAL);

    memset(s, 0, sizeof(*s));

    s->codec_type = AVMEDIA_TYPE_UNKNOWN;
    s->codec_id   = AV_CODEC_ID_NONE;

    s->flags      = AV_CODEC_FLAG_UNALIGNED;
    s->flags2     = 0;
    s->flags2 |= AV_CODEC_FLAG2_FAST;

    s->workaround_bugs = FF_BUG_AUTODETECT;
    s->strict_std_compliance = FF_COMPLIANCE_UNOFFICIAL;

    s->error_concealment = FF_EC_GUESS_MVS | FF_EC_DEBLOCK;
    s->debug            |= FF_DEBUG_PICT_INFO;

    s->err_recognition  = AV_EF_CRCCHECK | AV_EF_BITSTREAM | AV_EF_BUFFER | AV_EF_EXPLODE;

    s->get_buffer2      = avcodec_default_get_buffer2;
    s->refcounted_frames= 0;

    s->bits_per_raw_sample = -1;

    s->channel_layout = 0;
    s->channels       = 0;

    s->sample_rate    = 0;
    s->sample_fmt     = AV_SAMPLE_FMT_NONE;

    s->frame_number   = 0;

    s->block_align    = 0;

    s->bits_per_coded_sample = -1;

    s->compression_level = -1;

    s->flags |= AV_CODEC_FLAG_LFRAME;

    s->thread_count   = 0;

    s->lowres         = 0;

    s->skip_samples   = 0;

    s->seek_preroll   = 0;

    s->initial_padding = 0;

    s->framerate      = (AVRational){ 0, 1 };

    s->pts_correction_numfound = 0;
    s->pts_correction_last = 0;

    s->pts_correction_last_for_given_field = 0;

    s->chroma_sample_location = AVCHROMA_LOC_UNSPECIFIED;

    s->video_delay = 0;

    s->request_channel_layout = 0;

    s->audio_service_type = AV_AUDIO_SERVICE_TYPE_MAIN;

    s->request_sample_fmt = AV_SAMPLE_FMT_NONE;

    s->strict_std_compliance = FF_COMPLIANCE_UNOFFICIAL;

    s->error_concealment = FF_EC_GUESS_MVS | FF_EC_DEBLOCK;

    s->debug |= FF_DEBUG_PICT_INFO;

    s->err_recognition = AV_EF_CRCCHECK | AV_EF_BITSTREAM | AV_EF_BUFFER | AV_EF_EXPLODE;

    s->get_buffer2 = avcodec_default_get_buffer2;

    s->refcounted_frames = 0;

    s->bits_per_raw_sample = -1;

    s->channel_layout = 0;
    s->channels = 0;

    s->sample_rate = 0;
    s->sample_fmt = AV_SAMPLE_FMT_NONE;

    s->frame_number = 0;

    s->block_align = 0;

    s->bits_per_coded_sample = -1;

    s->compression_level = -1;

    s->flags |= AV_CODEC_FLAG_LFRAME;

    s->thread_count = 0;

    s->lowres = 0;

    s->skip_samples = 0;

    s->seek_preroll = 0;

    s->initial_padding = 0;

    s->framerate = (AVRational){ 0, 1 };

    s->pts_correction_numfound = 0;
    s->pts_correction_last = 0;

    s->pts_correction_last_for_given_field = 0;

    s->chroma_sample_location = AVCHROMA_LOC_UNSPECIFIED;

    s->video_delay = 0;

    s->request_channel_layout = 0;

    s->audio_service_type = AV_AUDIO_SERVICE_TYPE_MAIN;

    s->request_sample_fmt = AV_SAMPLE_FMT_NONE;

    s->strict_std_compliance = FF_COMPLIANCE_UNOFFICIAL;

    s->error_concealment = FF_EC_GUESS_MVS | FF_EC_DEBLOCK;

    s->debug |= FF_DEBUG_PICT_INFO;

    s->err_recognition = AV_EF_CRCCHECK | AV_EF_BITSTREAM | AV_EF_BUFFER | AV_EF_EXPLODE;

    s->get_buffer2 = avcodec_default_get_buffer2;

    s->refcounted_frames = 0;

    s->bits_per_raw_sample = -1;

    s->channel_layout = 0;
    s->channels = 0;

    s->sample_rate = 0;
    s->sample_fmt = AV_SAMPLE_FMT_NONE;

    s->frame_number = 0;

    s->block_align = 0;

    s->bits_per_coded_sample = -1;

    s->compression_level = -1;

    s->flags |= AV_CODEC_FLAG_LFRAME;

    s->thread_count = 0;

    s->lowres = 0;

    s->skip_samples = 0;

    s->seek_preroll = 0;

    s->initial_padding = 0;

    s->framerate = (AVRational){ 0, 1 };

    s->pts_correction_numfound = 0;
    s->pts_correction_last = 0;

    s->pts_correction_last_for_given_field = 0;

    s->chroma_sample_location = AVCHROMA_LOC_UNSPECIFIED;

    s->video_delay = 0;

    s->request_channel_layout = 0;

    s->audio_service_type = AV_AUDIO_SERVICE_TYPE_MAIN;

    s->request_sample_fmt = AV_SAMPLE_FMT_NONE;

    s->strict_std_compliance = FF_COMPLIANCE_UNOFFICIAL;

    s->error_concealment = FF_EC_GUESS_MVS | FF_EC_DEBLOCK;

    s->debug |= FF_DEBUG_PICT_INFO;

    s->err_recognition = AV_EF_CRCCHECK | AV_EF_BITSTREAM | AV_EF_BUFFER | AV_EF_EXPLODE;

    s->get_buffer2 = avcodec_default_get_buffer2;

    s->refcounted_frames = 0;

    s->bits_per_raw_sample = -1;

    s->channel_layout = 0;
    s->channels = 0;

    s->sample_rate = 0;
    s->sample_fmt = AV_SAMPLE_FMT_NONE;

    s->frame_number = 0;

    s->block_align = 0;

    s->bits_per_coded_sample = -1;

    s->compression_level = -1;

    s->flags |= AV_CODEC_FLAG_LFRAME;

    s->thread_count = 0;

    s->lowres = 0;

    s->skip_samples = 0;

    s->seek_preroll = 0;

    s->initial_padding = 0;

    s->framerate = (AVRational){ 0, 1 };

    s->pts_correction_numfound = 0;
    s->pts_correction_last = 0;

    s->pts_correction_last_for_given_field = 0;

    s->chroma_sample_location = AVCHROMA_LOC_UNSPECIFIED;

    s->video_delay = 0;

    s->request_channel_layout = 0;

    s->audio_service_type = AV_AUDIO_SERVICE_TYPE_MAIN;

    s->request_sample_fmt = AV_SAMPLE_FMT_NONE;

    s->strict_std_compliance = FF_COMPLIANCE_UNOFFICIAL;

    s->error_concealment = FF_EC_GUESS_MVS | FF_EC_DEBLOCK;

    s->debug |= FF_DEBUG_PICT_INFO;

    s->err_recognition = AV_EF_CRCCHECK | AV_EF_BITSTREAM | AV_EF_BUFFER | AV_EF_EXPLODE;

    s->get_buffer2 = avcodec_default_get_buffer2;