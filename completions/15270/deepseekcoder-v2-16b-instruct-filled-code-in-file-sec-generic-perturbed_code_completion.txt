(buf), buf_size - strlen(buf),
                     ", %d fps, %"PRId64" tbr, %"PRId64" tbn, %"PRId64" tbc",
                     av_q2d(enc->framerate) * 1000,
                     enc->bit_rate,
                     enc->ticks_per_frame ? enc->time_base.num * enc->ticks_per_frame / enc->time_base.den : 0,
                     enc->ticks_per_frame);
        }
        break;
    case AVMEDIA_TYPE_AUDIO:
        {
            char detail[256] = "(";

            av_strlcat(buf, separator, buf_size);

            snprintf(buf + strlen(buf), buf_size - strlen(buf),
                     "%s", av_get_sample_fmt_name(enc->sample_fmt));
            if (enc->sample_rate)
                av_strlcatf(detail, sizeof(detail), "%d Hz, ", enc->sample_rate);
            if (enc->channel_layout)
                av_strlcatf(detail, sizeof(detail), "%s, ",
                            av_get_channel_layout_string(NULL, enc->channel_layout));
            if (enc->bits_per_sample)
                av_strlcatf(detail, sizeof(detail), "%d bps, ", enc->bits_per_sample);

            if (strlen(detail) > 1) {
                detail[strlen(detail) - 2] = 0;
                av_strlcatf(buf, buf_size, "%s)", detail);
            }
        }
        if (encode) {
            snprintf(buf + strlen(buf), buf_size - strlen(buf),
                     ", %d channels, %"PRId64" bps",
                     enc->channels, enc->bit_rate);
        }
        break;
    case AVMEDIA_TYPE_SUBTITLE:
        if (encode) {
            snprintf(buf + strlen(buf), buf_size - strlen(buf),
                     ", %d pts, %d dts, %d size",
                     enc->pts, enc->dts, enc->sub_header_size);
        }
        break;
    case AVMEDIA_TYPE_ATTACHMENT:
        if (encode) {
            snprintf(buf + strlen(buf), buf_size - strlen(buf),
                     ", %d size", enc->attachment_size);
        }
        break;
    default:
        break;
    }
}

int avcodec_default_execute_end(AVCodecContext *c, int *ret, int count)
{
    int i;

    for (i = 0; i < count; i++) {
        if (ret)
            ret[i] = 0;
    }
    emms_c();
    return 0;
}

int avcodec_default_get_buffer2(AVCodecContext *s, AVFrame *frame, int flags)
{
    int ret;

    ret = av_frame_get_buffer(frame, 32);
    if (ret < 0)
        return ret;

    if (s->get_buffer2)
        return s->get_buffer2(s, frame, flags);

    return 0;
}

int avcodec_default_reget_buffer(AVCodecContext *s, AVFrame *frame)
{
    av_freep(&frame->data[0]);
    return av_frame_get_buffer(frame, 32);
}

int avcodec_default_send_frame(AVCodecContext *s, const AVFrame *frame)
{
    if (s->send_frame)
        return s->send_frame(s, frame);
    return AVERROR(ENOSYS);
}

int avcodec_default_receive_packet(AVCodecContext *s, AVPacket *pkt)
{
    if (s->receive_packet)
        return s->receive_packet(s, pkt);
    return AVERROR(ENOSYS);
}

int avcodec_default_send_packet(AVCodecContext *s, const AVPacket *pkt)
{
    if (s->send_packet)
        return s->send_packet(s, pkt);
    return AVERROR(ENOSYS);
}

int avcodec_default_receive_frame(AVCodecContext *s, AVFrame *frame)
{
    if (s->receive_frame)
        return s->receive_frame(s, frame);
    return AVERROR(ENOSYS);
}

int avcodec_default_decode(AVCodecContext *c, AVFrame *frame, int *got_frame_ptr,
                           const AVPacket *pkt)
{
    int ret;

    if (*got_frame_ptr) {
        avcodec_frame_free(&frame);
        *got_frame_ptr = 0;
    }

    ret = avcodec_send_packet(c, pkt);
    if (ret < 0)
        return ret;

    ret = avcodec_receive_frame(c, frame);
    if (ret < 0)
        return ret;

    *got_frame_ptr = 1;
    return 0;
}

int avcodec_default_decode2(AVCodecContext *c, AVFrame *frame, int *got_frame_ptr,
                            AVPacket *pkt)
{
    int ret;

    if (*got_frame_ptr) {
        avcodec_frame_free(&frame);
        *got_frame_ptr = 0;
    }

    ret = avcodec_send_packet(c, pkt);
    if (ret < 0)
        return ret;

    ret = avcodec_receive_frame(c, frame);
    if (ret < 0)
        return ret;

    *got_frame_ptr = 1;
    return 0;
}

int avcodec_default_get_buffer(AVCodecContext *s, AVFrame *frame)
{
    return avcodec_default_get_buffer2(s, frame, 0);
}

int avcodec_default_end(AVCodecContext *s)
{
    if (s->codec && s->codec->close)
        s->codec->close(s);
    return 0;
}

int avcodec_default_init(AVCodecContext *s)
{
    if (s->codec && s->codec->init)
        return s->codec->init(s);
    return 0;
}

int avcodec_default_init2(AVCodecContext *s)
{
    if (s->codec && s->codec->init2)
        return s->codec->init2(s);
    return avcodec_default_init(s);
}

int avcodec_default_configure(AVCodecContext *s)
{
    if (s->codec && s->codec->configure)
        return s->codec->configure(s);
    return 0;
}

int avcodec_default_flush(AVCodecContext *s)
{
    if (s->codec && s->codec->flush)
        return s->codec->flush(s);
    return 0;
}

int avcodec_default_close(AVCodecContext *s)
{
    if (s->codec && s->codec->close)
        return s->codec->close(s);
    return 0;
}

int avcodec_default_free_context(AVCodecContext *s)
{
    if (s->codec && s->codec->free_context)
        return s->codec->free_context(s);
    return 0;
}

int avcodec_default_config_props(AVCodecContext *s)
{
    if (s->codec && s->codec->config_props)
        return s->codec->config_props(s);
    return 0;
}

int avcodec_default_init_static_data(AVCodecContext *s)
{
    if (s->codec && s->codec->init_static_data)
        return s->codec->init_static_data(s);
    return 0;
}

int avcodec_default_init_thread_copy(AVCodecContext *s)
{
    if (s->codec && s->codec->init_thread_copy)
        return s->codec->init_thread_copy(s);
    return 0;
}

int avcodec_default_update_thread_context(AVCodecContext *dst, const AVCodecContext *src)
{
    if (dst->codec && dst->codec->update_thread_context)
        return dst->codec->update_thread_context(dst, src);
    return 0;
}

int avcodec_default_get_frame_defaults(AVFrame *frame)
{
    if (frame) {
        frame->format = -1;
        frame->pts = AV_NOPTS_VALUE;
        frame->pkt_pts = AV_NOPTS_VALUE;
        frame->pkt_dts = AV_NOPTS_VALUE;
        frame->best_effort_timestamp = AV_NOPTS_VALUE;
        frame->pkt_duration = 0;
        frame->duration = 0;
        frame->pos = -1;
        frame->pkt_pos = -1;
        frame->pkt_size = -1;
        frame->key_frame = 0;
        frame->sample_rate = 0;
        frame->channel_layout = 0;
        frame->channels = 0;
        frame->nb_samples = 0;
        frame->block_align = 0;
        frame->bits_per_coded_sample = 0;
        frame->bits_per_raw_sample = 0;
        frame->reordered_opaque = AV_NOPTS_VALUE;
        frame->interlaced_frame = 0;
        frame->top_field_first = 0;
        frame->repeat_pict = 0;
        frame->pts_wrap_bits = 0;
        frame->color_primaries = AVCOL_PRI_UNSPECIFIED;
        frame->color_trc = AVCOL_TRC_UNSPECIFIED;
        frame->colorspace = AVCOL_SPC_UNSPECIFIED;
        frame->chroma_location = AVCHROMA_LOC_UNSPECIFIED;
        frame->best_effort_timestamp_tolerance = 0;
        frame->pts_reorder_error = 0;
        frame->overflow = 0;
        frame->video->width = 0;
        frame->video->height = 0;
        frame->video->format = -1;
        frame->video->key_frame = 0;
        frame->video->coded_picture_number = 0;
        frame->video->display_picture_number = 0;
        frame->video->interlaced_frame = 0;
        frame->video->top_field_first = 0;
        frame->video->repeat_pict = 0;
        frame->audio->channel_layout = 0;
        frame->audio->sample_rate = 0;
        frame->audio->format = AV_SAMPLE_FMT_NONE;
        frame->audio->nb_samples = 0;
        frame->audio->channel_layout_defined = 0;
        frame->audio->request_channel_layout = 0;
        frame->audio->bits_per_sample = 0;
        frame->audio->reserved[0] = 0;
        frame->audio->reserved[1] = 0;
        frame->audio->reserved[2] = 0;
        frame->audio->reserved[3] = 0;
        frame->audio->reserved[4] = 0;
        frame->audio->reserved[5] = 0;
        frame->audio->reserved[6] = 0;
        frame->audio->reserved[7] = 0;
        frame->audio->reserved[8] = 0;
        frame->audio->reserved[9] = 0;
        frame->audio->reserved[10] = 0;
        frame->audio->reserved[11] = 0;
        frame->audio->reserved[12] = 0;
        frame->audio->reserved[13] = 0;
        frame->audio->reserved[14] = 0;
        frame->audio->reserved[15] = 0;
        frame->audio->window_alignment = 0;
        frame->audio->channels = 0;
        frame->audio->sub_channel_layout = 0;
        frame->audio->request_channel_layout = 0;
        frame->audio->reserved2[0] =