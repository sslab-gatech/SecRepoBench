void avcodec_align_dimensions2(AVCodecContext *avctx, int *width, int *height,
                               int linesize_align[AV_NUM_DATA_POINTERS])
{
    int i;
    int w_align = 1;
    int h_align = 1;
    AVPixFmtDescriptor const *desc = av_pix_fmt_desc_get(avctx->pix_fmt);

    if (desc) {
        w_align = 1 << desc->log2_chroma_w;
        h_align = 1 << desc->log2_chroma_h;
    }

    switch (avctx->codec_id) {
    case AV_CODEC_ID_IFF_ILBM:
        w_align = FFMAX(w_align, 8);
        break;
    }

    *width  = FFALIGN(*width,  w_align);
    *height = FFALIGN(*height, h_align);
    if (avctx->codec_id == AV_CODEC_ID_H264 || avctx->lowres ||
        avctx->codec_id == AV_CODEC_ID_VP5  || avctx->codec_id == AV_CODEC_ID_VP6 ||
        avctx->codec_id == AV_CODEC_ID_VP6F || avctx->codec_id == AV_CODEC_ID_VP6A
    ) {
        // some of the optimized chroma MC reads one line too much
        // which is also done in mpeg decoders with lowres > 0
        *height += 2;

        // H.264 uses edge emulation for out of frame motion vectors, for this
        // it requires a temporary area large enough to hold a 21x21 block,
        // increasing witdth ensure that the temporary area is large enough,
        // the next rounded up width is 32
        *width = FFMAX(*width, 32);
    }

    for (i = 0; i < 4; i++)
        linesize_align[i] = STRIDE_ALIGN;
}