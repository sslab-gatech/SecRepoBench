int avcodec_parameters_from_context(AVCodecParameters *par,
                                    const AVCodecContext *codec)
{
    codec_parameters_reset(par);

    par->codec_type = codec->codec_type;
    par->codec_id   = codec->codec_id;
    par->codec_tag  = codec->codec_tag;

    par->bit_rate              = codec->bit_rate;
    par->bits_per_coded_sample = codec->bits_per_coded_sample;
    par->bits_per_raw_sample   = codec->bits_per_raw_sample;
    par->profile               = codec->profile;
    par->level                 = codec->level;

    switch (par->codec_type) {
    case AVMEDIA_TYPE_VIDEO:
        par->format              = codec->pix_fmt;
        par->width               = codec->width;
        par->height              = codec->height;
        par->field_order         = codec->field_order;
        par->color_range         = codec->color_range;
        par->color_primaries     = codec->color_primaries;
        par->color_trc           = codec->color_trc;
        par->color_space         = codec->colorspace;
        par->chroma_location     = codec->chroma_sample_location;
        par->sample_aspect_ratio = codec->sample_aspect_ratio;
        par->video_delay         = codec->has_b_frames;
        break;
    case AVMEDIA_TYPE_AUDIO:
        par->format           = codec->sample_fmt;
        par->channel_layout   = codec->channel_layout;
        par->channels         = codec->channels;
        par->sample_rate      = codec->sample_rate;
        par->block_align      = codec->block_align;
        par->frame_size       = codec->frame_size;
        par->initial_padding  = codec->initial_padding;
        par->trailing_padding = codec->trailing_padding;
        par->seek_preroll     = codec->seek_preroll;
        break;
    case AVMEDIA_TYPE_SUBTITLE:
        par->width  = codec->width;
        par->height = codec->height;
        break;
    }

    if (codec->extradata) {
        par->extradata = av_mallocz(codec->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
        if (!par->extradata)
            return AVERROR(ENOMEM);
        memcpy(par->extradata, codec->extradata, codec->extradata_size);
        par->extradata_size = codec->extradata_size;
    }

    // Check if subtitle character encoding is set and handle accordingly.
    // Ensure that character encoding is only used with subtitle codecs.
    // If the codec is bitmap-based, character encoding is ignored with a warning.
    // For text-based subtitle codecs, set the character encoding mode to pre-decoder
    // if it is in automatic mode and validate the input encoding using iconv if available.
    if (par->codec_type == AVMEDIA_TYPE_SUBTITLE) {
        if (codec->priv_data_size > 0 && codec->priv_class) {
            AVSubtitleEncoding *encoding = (AVSubtitleEncoding*)codec->priv_data;
            if (encoding->encoding == AV_SUBTITLE_ENCODING_AUTO) {
                encoding->encoding = AV_SUBTITLE_ENCODING_UTF8;
                if (HAVE_ICONV) {
                    int ret = av_iconv_codec_check(codec, encoding->encoding);
                    if (ret < 0) {
                        av_log(codec, AV_LOG_WARNING, "Invalid character encoding '%s' for subtitle codec '%s'\n",
                               av_get_subtitle_encoding_name(encoding->encoding), codec->name);
                        encoding->encoding = AV_SUBTITLE_ENCODING_NONE;
                    }
                }
            }
        }
    }

    return 0;
}