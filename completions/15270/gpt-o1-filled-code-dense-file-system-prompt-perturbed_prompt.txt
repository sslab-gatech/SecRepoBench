Below is the content of a C/C++ function where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
int attribute_align_arg avcodec_open2(AVCodecContext *codeccontext, const AVCodec *codec, AVDictionary **options)
{
    int ret = 0;
    AVDictionary *tmp = NULL;
    const AVPixFmtDescriptor *pixdesc;

    if (avcodec_is_open(codeccontext))
        return 0;

    if ((!codec && !codeccontext->codec)) {
        av_log(codeccontext, AV_LOG_ERROR, "No codec provided to avcodec_open2()\n");
        return AVERROR(EINVAL);
    }
    if ((codec && codeccontext->codec && codec != codeccontext->codec)) {
        av_log(codeccontext, AV_LOG_ERROR, "This AVCodecContext was allocated for %s, "
                                    "but %s passed to avcodec_open2()\n", codeccontext->codec->name, codec->name);
        return AVERROR(EINVAL);
    }
    if (!codec)
        codec = codeccontext->codec;

    if (codeccontext->extradata_size < 0 || codeccontext->extradata_size >= FF_MAX_EXTRADATA_SIZE)
        return AVERROR(EINVAL);

    if (options)
        av_dict_copy(&tmp, *options, 0);

    ff_lock_avcodec(codeccontext, codec);

    codeccontext->internal = av_mallocz(sizeof(*codeccontext->internal));
    if (!codeccontext->internal) {
        ret = AVERROR(ENOMEM);
        goto end;
    }

    codeccontext->internal->pool = av_mallocz(sizeof(*codeccontext->internal->pool));
    if (!codeccontext->internal->pool) {
        ret = AVERROR(ENOMEM);
        goto free_and_end;
    }

    codeccontext->internal->to_free = av_frame_alloc();
    if (!codeccontext->internal->to_free) {
        ret = AVERROR(ENOMEM);
        goto free_and_end;
    }

    codeccontext->internal->compat_decode_frame = av_frame_alloc();
    if (!codeccontext->internal->compat_decode_frame) {
        ret = AVERROR(ENOMEM);
        goto free_and_end;
    }

    codeccontext->internal->buffer_frame = av_frame_alloc();
    if (!codeccontext->internal->buffer_frame) {
        ret = AVERROR(ENOMEM);
        goto free_and_end;
    }

    codeccontext->internal->buffer_pkt = av_packet_alloc();
    if (!codeccontext->internal->buffer_pkt) {
        ret = AVERROR(ENOMEM);
        goto free_and_end;
    }

    codeccontext->internal->ds.in_pkt = av_packet_alloc();
    if (!codeccontext->internal->ds.in_pkt) {
        ret = AVERROR(ENOMEM);
        goto free_and_end;
    }

    codeccontext->internal->last_pkt_props = av_packet_alloc();
    if (!codeccontext->internal->last_pkt_props) {
        ret = AVERROR(ENOMEM);
        goto free_and_end;
    }

    codeccontext->internal->skip_samples_multiplier = 1;

    if (codec->priv_data_size > 0) {
        if (!codeccontext->priv_data) {
            codeccontext->priv_data = av_mallocz(codec->priv_data_size);
            if (!codeccontext->priv_data) {
                ret = AVERROR(ENOMEM);
                goto end;
            }
            if (codec->priv_class) {
                *(const AVClass **)codeccontext->priv_data = codec->priv_class;
                av_opt_set_defaults(codeccontext->priv_data);
            }
        }
        if (codec->priv_class && (ret = av_opt_set_dict(codeccontext->priv_data, &tmp)) < 0)
            goto free_and_end;
    } else {
        codeccontext->priv_data = NULL;
    }
    if ((ret = av_opt_set_dict(codeccontext, &tmp)) < 0)
        goto free_and_end;

    if (codeccontext->codec_whitelist && av_match_list(codec->name, codeccontext->codec_whitelist, ',') <= 0) {
        av_log(codeccontext, AV_LOG_ERROR, "Codec (%s) not on whitelist \'%s\'\n", codec->name, codeccontext->codec_whitelist);
        ret = AVERROR(EINVAL);
        goto free_and_end;
    }

    // only call ff_set_dimensions() for non H.264/VP6F/DXV codecs so as not to overwrite previously setup dimensions
    if (!(codeccontext->coded_width && codeccontext->coded_height && codeccontext->width && codeccontext->height &&
          (codeccontext->codec_id == AV_CODEC_ID_H264 || codeccontext->codec_id == AV_CODEC_ID_VP6F || codeccontext->codec_id == AV_CODEC_ID_DXV))) {
    if (codeccontext->coded_width && codeccontext->coded_height)
        ret = ff_set_dimensions(codeccontext, codeccontext->coded_width, codeccontext->coded_height);
    else if (codeccontext->width && codeccontext->height)
        ret = ff_set_dimensions(codeccontext, codeccontext->width, codeccontext->height);
    if (ret < 0)
        goto free_and_end;
    }

    if ((codeccontext->coded_width || codeccontext->coded_height || codeccontext->width || codeccontext->height)
        && (  av_image_check_size2(codeccontext->coded_width, codeccontext->coded_height, codeccontext->max_pixels, AV_PIX_FMT_NONE, 0, codeccontext) < 0
           || av_image_check_size2(codeccontext->width,       codeccontext->height,       codeccontext->max_pixels, AV_PIX_FMT_NONE, 0, codeccontext) < 0)) {
        av_log(codeccontext, AV_LOG_WARNING, "Ignoring invalid width/height values\n");
        ff_set_dimensions(codeccontext, 0, 0);
    }

    if (codeccontext->width > 0 && codeccontext->height > 0) {
        if (av_image_check_sar(codeccontext->width, codeccontext->height,
                               codeccontext->sample_aspect_ratio) < 0) {
            av_log(codeccontext, AV_LOG_WARNING, "ignoring invalid SAR: %u/%u\n",
                   codeccontext->sample_aspect_ratio.num,
                   codeccontext->sample_aspect_ratio.den);
            codeccontext->sample_aspect_ratio = (AVRational){ 0, 1 };
        }
    }

    /* if the decoder init function was already called previously,
     * free the already allocated subtitle_header before overwriting it */
    if (av_codec_is_decoder(codec))
        av_freep(&codeccontext->subtitle_header);

    if (codeccontext->channels > FF_SANE_NB_CHANNELS) {
        av_log(codeccontext, AV_LOG_ERROR, "Too many channels: %d\n", codeccontext->channels);
        ret = AVERROR(EINVAL);
        goto free_and_end;
    }

    codeccontext->codec = codec;
    if ((codeccontext->codec_type == AVMEDIA_TYPE_UNKNOWN || codeccontext->codec_type == codec->type) &&
        codeccontext->codec_id == AV_CODEC_ID_NONE) {
        codeccontext->codec_type = codec->type;
        codeccontext->codec_id   = codec->id;
    }
    if (codeccontext->codec_id != codec->id || (codeccontext->codec_type != codec->type
                                         && codeccontext->codec_type != AVMEDIA_TYPE_ATTACHMENT)) {
        av_log(codeccontext, AV_LOG_ERROR, "Codec type or id mismatches\n");
        ret = AVERROR(EINVAL);
        goto free_and_end;
    }
    codeccontext->frame_number = 0;
    codeccontext->codec_descriptor = avcodec_descriptor_get(codeccontext->codec_id);

    if ((codeccontext->codec->capabilities & AV_CODEC_CAP_EXPERIMENTAL) &&
        codeccontext->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {
        const char *codec_string = av_codec_is_encoder(codec) ? "encoder" : "decoder";
        AVCodec *codec2;
        av_log(codeccontext, AV_LOG_ERROR,
               "The %s '%s' is experimental but experimental codecs are not enabled, "
               "add '-strict %d' if you want to use it.\n",
               codec_string, codec->name, FF_COMPLIANCE_EXPERIMENTAL);
        codec2 = av_codec_is_encoder(codec) ? avcodec_find_encoder(codec->id) : avcodec_find_decoder(codec->id);
        if (!(codec2->capabilities & AV_CODEC_CAP_EXPERIMENTAL))
            av_log(codeccontext, AV_LOG_ERROR, "Alternatively use the non experimental %s '%s'.\n",
                codec_string, codec2->name);
        ret = AVERROR_EXPERIMENTAL;
        goto free_and_end;
    }

    if (codeccontext->codec_type == AVMEDIA_TYPE_AUDIO &&
        (!codeccontext->time_base.num || !codeccontext->time_base.den)) {
        codeccontext->time_base.num = 1;
        codeccontext->time_base.den = codeccontext->sample_rate;
    }

    if (!HAVE_THREADS)
        av_log(codeccontext, AV_LOG_WARNING, "Warning: not compiled with thread support, using thread emulation\n");

    if (CONFIG_FRAME_THREAD_ENCODER && av_codec_is_encoder(codeccontext->codec)) {
        ff_unlock_avcodec(codec); //we will instantiate a few encoders thus kick the counter to prevent false detection of a problem
        ret = ff_frame_thread_encoder_init(codeccontext, options ? *options : NULL);
        ff_lock_avcodec(codeccontext, codec);
        if (ret < 0)
            goto free_and_end;
    }

    if (av_codec_is_decoder(codeccontext->codec)) {
        ret = ff_decode_bsfs_init(codeccontext);
        if (ret < 0)
            goto free_and_end;
    }

    if (HAVE_THREADS
        && !(codeccontext->internal->frame_thread_encoder && (codeccontext->active_thread_type&FF_THREAD_FRAME))) {
        ret = ff_thread_init(codeccontext);
        if (ret < 0) {
            goto free_and_end;
        }
    }
    if (!HAVE_THREADS && !(codec->capabilities & AV_CODEC_CAP_AUTO_THREADS))
        codeccontext->thread_count = 1;

    if (codeccontext->codec->max_lowres < codeccontext->lowres || codeccontext->lowres < 0) {
        av_log(codeccontext, AV_LOG_WARNING, "The maximum value for lowres supported by the decoder is %d\n",
               codeccontext->codec->max_lowres);
        codeccontext->lowres = codeccontext->codec->max_lowres;
    }

    if (av_codec_is_encoder(codeccontext->codec)) {
        int i;
#if FF_API_CODED_FRAME
FF_DISABLE_DEPRECATION_WARNINGS
        codeccontext->coded_frame = av_frame_alloc();
        if (!codeccontext->coded_frame) {
            ret = AVERROR(ENOMEM);
            goto free_and_end;
        }
FF_ENABLE_DEPRECATION_WARNINGS
#endif

        if (codeccontext->time_base.num <= 0 || codeccontext->time_base.den <= 0) {
            av_log(codeccontext, AV_LOG_ERROR, "The encoder timebase is not set.\n");
            ret = AVERROR(EINVAL);
            goto free_and_end;
        }

        if (codeccontext->codec->sample_fmts) {
            for (i = 0; codeccontext->codec->sample_fmts[i] != AV_SAMPLE_FMT_NONE; i++) {
                if (codeccontext->sample_fmt == codeccontext->codec->sample_fmts[i])
                    break;
                if (codeccontext->channels == 1 &&
                    av_get_planar_sample_fmt(codeccontext->sample_fmt) ==
                    av_get_planar_sample_fmt(codeccontext->codec->sample_fmts[i])) {
                    codeccontext->sample_fmt = codeccontext->codec->sample_fmts[i];
                    break;
                }
            }
            if (codeccontext->codec->sample_fmts[i] == AV_SAMPLE_FMT_NONE) {
                char buf[128];
                snprintf(buf, sizeof(buf), "%d", codeccontext->sample_fmt);
                av_log(codeccontext, AV_LOG_ERROR, "Specified sample format %s is invalid or not supported\n",
                       (char *)av_x_if_null(av_get_sample_fmt_name(codeccontext->sample_fmt), buf));
                ret = AVERROR(EINVAL);
                goto free_and_end;
            }
        }
        if (codeccontext->codec->pix_fmts) {
            for (i = 0; codeccontext->codec->pix_fmts[i] != AV_PIX_FMT_NONE; i++)
                if (codeccontext->pix_fmt == codeccontext->codec->pix_fmts[i])
                    break;
            if (codeccontext->codec->pix_fmts[i] == AV_PIX_FMT_NONE
                && !((codeccontext->codec_id == AV_CODEC_ID_MJPEG || codeccontext->codec_id == AV_CODEC_ID_LJPEG)
                     && codeccontext->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL)) {
                char buf[128];
                snprintf(buf, sizeof(buf), "%d", codeccontext->pix_fmt);
                av_log(codeccontext, AV_LOG_ERROR, "Specified pixel format %s is invalid or not supported\n",
                       (char *)av_x_if_null(av_get_pix_fmt_name(codeccontext->pix_fmt), buf));
                ret = AVERROR(EINVAL);
                goto free_and_end;
            }
            if (codeccontext->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ420P ||
                codeccontext->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ411P ||
                codeccontext->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ422P ||
                codeccontext->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ440P ||
                codeccontext->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ444P)
                codeccontext->color_range = AVCOL_RANGE_JPEG;
        }
        if (codeccontext->codec->supported_samplerates) {
            for (i = 0; codeccontext->codec->supported_samplerates[i] != 0; i++)
                if (codeccontext->sample_rate == codeccontext->codec->supported_samplerates[i])
                    break;
            if (codeccontext->codec->supported_samplerates[i] == 0) {
                av_log(codeccontext, AV_LOG_ERROR, "Specified sample rate %d is not supported\n",
                       codeccontext->sample_rate);
                ret = AVERROR(EINVAL);
                goto free_and_end;
            }
        }
        if (codeccontext->sample_rate < 0) {
            av_log(codeccontext, AV_LOG_ERROR, "Specified sample rate %d is not supported\n",
                    codeccontext->sample_rate);
            ret = AVERROR(EINVAL);
            goto free_and_end;
        }
        if (codeccontext->codec->channel_layouts) {
            if (!codeccontext->channel_layout) {
                av_log(codeccontext, AV_LOG_WARNING, "Channel layout not specified\n");
            } else {
                for (i = 0; codeccontext->codec->channel_layouts[i] != 0; i++)
                    if (codeccontext->channel_layout == codeccontext->codec->channel_layouts[i])
                        break;
                if (codeccontext->codec->channel_layouts[i] == 0) {
                    char buf[512];
                    av_get_channel_layout_string(buf, sizeof(buf), -1, codeccontext->channel_layout);
                    av_log(codeccontext, AV_LOG_ERROR, "Specified channel layout '%s' is not supported\n", buf);
                    ret = AVERROR(EINVAL);
                    goto free_and_end;
                }
            }
        }
        if (codeccontext->channel_layout && codeccontext->channels) {
            int channels = av_get_channel_layout_nb_channels(codeccontext->channel_layout);
            if (channels != codeccontext->channels) {
                char buf[512];
                av_get_channel_layout_string(buf, sizeof(buf), -1, codeccontext->channel_layout);
                av_log(codeccontext, AV_LOG_ERROR,
                       "Channel layout '%s' with %d channels does not match number of specified channels %d\n",
                       buf, channels, codeccontext->channels);
                ret = AVERROR(EINVAL);
                goto free_and_end;
            }
        } else if (codeccontext->channel_layout) {
            codeccontext->channels = av_get_channel_layout_nb_channels(codeccontext->channel_layout);
        }
        if (codeccontext->channels < 0) {
            av_log(codeccontext, AV_LOG_ERROR, "Specified number of channels %d is not supported\n",
                    codeccontext->channels);
            ret = AVERROR(EINVAL);
            goto free_and_end;
        }
        if(codeccontext->codec_type == AVMEDIA_TYPE_VIDEO) {
            pixdesc = av_pix_fmt_desc_get(codeccontext->pix_fmt);
            if (    codeccontext->bits_per_raw_sample < 0
                || (codeccontext->bits_per_raw_sample > 8 && pixdesc->comp[0].depth <= 8)) {
                av_log(codeccontext, AV_LOG_WARNING, "Specified bit depth %d not possible with the specified pixel formats depth %d\n",
                    codeccontext->bits_per_raw_sample, pixdesc->comp[0].depth);
                codeccontext->bits_per_raw_sample = pixdesc->comp[0].depth;
            }
            if (codeccontext->width <= 0 || codeccontext->height <= 0) {
                av_log(codeccontext, AV_LOG_ERROR, "dimensions not set\n");
                ret = AVERROR(EINVAL);
                goto free_and_end;
            }
        }
        if (   (codeccontext->codec_type == AVMEDIA_TYPE_VIDEO || codeccontext->codec_type == AVMEDIA_TYPE_AUDIO)
            && codeccontext->bit_rate>0 && codeccontext->bit_rate<1000) {
            av_log(codeccontext, AV_LOG_WARNING, "Bitrate %"PRId64" is extremely low, maybe you mean %"PRId64"k\n", codeccontext->bit_rate, codeccontext->bit_rate);
        }

        if (!codeccontext->rc_initial_buffer_occupancy)
            codeccontext->rc_initial_buffer_occupancy = codeccontext->rc_buffer_size * 3LL / 4;

        if (codeccontext->ticks_per_frame && codeccontext->time_base.num &&
            codeccontext->ticks_per_frame > INT_MAX / codeccontext->time_base.num) {
            av_log(codeccontext, AV_LOG_ERROR,
                   "ticks_per_frame %d too large for the timebase %d/%d.",
                   codeccontext->ticks_per_frame,
                   codeccontext->time_base.num,
                   codeccontext->time_base.den);
            goto free_and_end;
        }

        if (codeccontext->hw_frames_ctx) {
            AVHWFramesContext *frames_ctx = (AVHWFramesContext*)codeccontext->hw_frames_ctx->data;
            if (frames_ctx->format != codeccontext->pix_fmt) {
                av_log(codeccontext, AV_LOG_ERROR,
                       "Mismatching AVCodecContext.pix_fmt and AVHWFramesContext.format\n");
                ret = AVERROR(EINVAL);
                goto free_and_end;
            }
            if (codeccontext->sw_pix_fmt != AV_PIX_FMT_NONE &&
                codeccontext->sw_pix_fmt != frames_ctx->sw_format) {
                av_log(codeccontext, AV_LOG_ERROR,
                       "Mismatching AVCodecContext.sw_pix_fmt (%s) "
                       "and AVHWFramesContext.sw_format (%s)\n",
                       av_get_pix_fmt_name(codeccontext->sw_pix_fmt),
                       av_get_pix_fmt_name(frames_ctx->sw_format));
                ret = AVERROR(EINVAL);
                goto free_and_end;
            }
            codeccontext->sw_pix_fmt = frames_ctx->sw_format;
        }
    }

    codeccontext->pts_correction_num_faulty_pts =
    codeccontext->pts_correction_num_faulty_dts = 0;
    codeccontext->pts_correction_last_pts =
    codeccontext->pts_correction_last_dts = INT64_MIN;

    if (   !CONFIG_GRAY && codeccontext->flags & AV_CODEC_FLAG_GRAY
        && codeccontext->codec_descriptor->type == AVMEDIA_TYPE_VIDEO)
        av_log(codeccontext, AV_LOG_WARNING,
               "gray decoding requested but not enabled at configuration time\n");

    if (   codeccontext->codec->init && (!(codeccontext->active_thread_type&FF_THREAD_FRAME)
        || codeccontext->internal->frame_thread_encoder)) {
        ret = codeccontext->codec->init(codeccontext);
        if (ret < 0) {
            goto free_and_end;
        }
    }

    ret=0;

    if (av_codec_is_decoder(codeccontext->codec)) {
        if (!codeccontext->bit_rate)
            codeccontext->bit_rate = get_bit_rate(codeccontext);
        /* validate channel layout from the decoder */
        if (codeccontext->channel_layout) {
            int channels = av_get_channel_layout_nb_channels(codeccontext->channel_layout);
            if (!codeccontext->channels)
                codeccontext->channels = channels;
            else if (channels != codeccontext->channels) {
                char buf[512];
                av_get_channel_layout_string(buf, sizeof(buf), -1, codeccontext->channel_layout);
                av_log(codeccontext, AV_LOG_WARNING,
                       "Channel layout '%s' with %d channels does not match specified number of channels %d: "
                       "ignoring specified channel layout\n",
                       buf, channels, codeccontext->channels);
                codeccontext->channel_layout = 0;
            }
        }
        if (codeccontext->channels && codeccontext->channels < 0 ||
            codeccontext->channels > FF_SANE_NB_CHANNELS) {
            ret = AVERROR(EINVAL);
            goto free_and_end;
        }
        // Check if subtitle character encoding is set and handle accordingly.
        // Ensure that character encoding is only used with subtitle codecs.
        // If the codec is bitmap-based, character encoding is ignored with a warning.
        // For text-based subtitle codecs, set the character encoding mode to pre-decoder
        // if it is in automatic mode and validate the input encoding using iconv if available.
        // <MASK>

#if FF_API_AVCTX_TIMEBASE
        if (codeccontext->framerate.num > 0 && codeccontext->framerate.den > 0)
            codeccontext->time_base = av_inv_q(av_mul_q(codeccontext->framerate, (AVRational){codeccontext->ticks_per_frame, 1}));
#endif
    }
    if (codec->priv_data_size > 0 && codeccontext->priv_data && codec->priv_class) {
        av_assert0(*(const AVClass **)codeccontext->priv_data == codec->priv_class);
    }

end:
    ff_unlock_avcodec(codec);
    if (options) {
        av_dict_free(options);
        *options = tmp;
    }

    return ret;
free_and_end:
    if (codeccontext->codec &&
        (codeccontext->codec->caps_internal & FF_CODEC_CAP_INIT_CLEANUP))
        codeccontext->codec->close(codeccontext);

    if (codec->priv_class && codec->priv_data_size)
        av_opt_free(codeccontext->priv_data);
    av_opt_free(codeccontext);

#if FF_API_CODED_FRAME
FF_DISABLE_DEPRECATION_WARNINGS
    av_frame_free(&codeccontext->coded_frame);
FF_ENABLE_DEPRECATION_WARNINGS
#endif

    av_dict_free(&tmp);
    av_freep(&codeccontext->priv_data);
    if (codeccontext->internal) {
        av_frame_free(&codeccontext->internal->to_free);
        av_frame_free(&codeccontext->internal->compat_decode_frame);
        av_frame_free(&codeccontext->internal->buffer_frame);
        av_packet_free(&codeccontext->internal->buffer_pkt);
        av_packet_free(&codeccontext->internal->last_pkt_props);

        av_packet_free(&codeccontext->internal->ds.in_pkt);
        ff_decode_bsfs_uninit(codeccontext);

        av_freep(&codeccontext->internal->pool);
    }
    av_freep(&codeccontext->internal);
    codeccontext->codec = NULL;
    goto end;
}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// libavcodec/utils.c
av_cold int avcodec_close(AVCodecContext *avctx)
{
    int i;

    if (!avctx)
        return 0;

    if (avcodec_is_open(avctx)) {
        FramePool *pool = avctx->internal->pool;
        if (CONFIG_FRAME_THREAD_ENCODER &&
            avctx->internal->frame_thread_encoder && avctx->thread_count > 1) {
            ff_frame_thread_encoder_free(avctx);
        }
        if (HAVE_THREADS && avctx->internal->thread_ctx)
            ff_thread_free(avctx);
        if (avctx->codec && avctx->codec->close)
            avctx->codec->close(avctx);
        avctx->internal->byte_buffer_size = 0;
        av_freep(&avctx->internal->byte_buffer);
        av_frame_free(&avctx->internal->to_free);
        av_frame_free(&avctx->internal->compat_decode_frame);
        av_frame_free(&avctx->internal->buffer_frame);
        av_packet_free(&avctx->internal->buffer_pkt);
        av_packet_free(&avctx->internal->last_pkt_props);

        av_packet_free(&avctx->internal->ds.in_pkt);

        for (i = 0; i < FF_ARRAY_ELEMS(pool->pools); i++)
            av_buffer_pool_uninit(&pool->pools[i]);
        av_freep(&avctx->internal->pool);

        if (avctx->hwaccel && avctx->hwaccel->uninit)
            avctx->hwaccel->uninit(avctx);
        av_freep(&avctx->internal->hwaccel_priv_data);

        ff_decode_bsfs_uninit(avctx);

        av_freep(&avctx->internal);
    }

    for (i = 0; i < avctx->nb_coded_side_data; i++)
        av_freep(&avctx->coded_side_data[i].data);
    av_freep(&avctx->coded_side_data);
    avctx->nb_coded_side_data = 0;

    av_buffer_unref(&avctx->hw_frames_ctx);
    av_buffer_unref(&avctx->hw_device_ctx);

    if (avctx->priv_data && avctx->codec && avctx->codec->priv_class)
        av_opt_free(avctx->priv_data);
    av_opt_free(avctx);
    av_freep(&avctx->priv_data);
    if (av_codec_is_encoder(avctx->codec)) {
        av_freep(&avctx->extradata);
#if FF_API_CODED_FRAME
FF_DISABLE_DEPRECATION_WARNINGS
        av_frame_free(&avctx->coded_frame);
FF_ENABLE_DEPRECATION_WARNINGS
#endif
    }
    avctx->codec = NULL;
    avctx->active_thread_type = 0;

    return 0;
}

// the below code fragment can be found in:
// libavcodec/libaomenc.c
static av_cold int aom_init(AVCodecContext *avctx,
                            const struct aom_codec_iface *iface)
{
    AOMContext *ctx = avctx->priv_data;
    struct aom_codec_enc_cfg enccfg = { 0 };
#ifdef AOM_FRAME_IS_INTRAONLY
    aom_codec_flags_t flags =
        (avctx->flags & AV_CODEC_FLAG_PSNR) ? AOM_CODEC_USE_PSNR : 0;
#else
    aom_codec_flags_t flags = 0;
#endif
    AVCPBProperties *cpb_props;
    int res;
    aom_img_fmt_t img_fmt;
    aom_codec_caps_t codec_caps = aom_codec_get_caps(iface);

    av_log(avctx, AV_LOG_INFO, "%s\n", aom_codec_version_str());
    av_log(avctx, AV_LOG_VERBOSE, "%s\n", aom_codec_build_config());

    if ((res = aom_codec_enc_config_default(iface, &enccfg, 0)) != AOM_CODEC_OK) {
        av_log(avctx, AV_LOG_ERROR, "Failed to get config: %s\n",
               aom_codec_err_to_string(res));
        return AVERROR(EINVAL);
    }

    if (set_pix_fmt(avctx, codec_caps, &enccfg, &flags, &img_fmt))
        return AVERROR(EINVAL);

    if(!avctx->bit_rate)
        if(avctx->rc_max_rate || avctx->rc_buffer_size || avctx->rc_initial_buffer_occupancy) {
            av_log( avctx, AV_LOG_ERROR, "Rate control parameters set without a bitrate\n");
            return AVERROR(EINVAL);
        }

    dump_enc_cfg(avctx, &enccfg);

    enccfg.g_w            = avctx->width;
    enccfg.g_h            = avctx->height;
    enccfg.g_timebase.num = avctx->time_base.num;
    enccfg.g_timebase.den = avctx->time_base.den;
    enccfg.g_threads      =
        FFMIN(avctx->thread_count ? avctx->thread_count : av_cpu_count(), 64);

    if (ctx->lag_in_frames >= 0)
        enccfg.g_lag_in_frames = ctx->lag_in_frames;

    if (avctx->flags & AV_CODEC_FLAG_PASS1)
        enccfg.g_pass = AOM_RC_FIRST_PASS;
    else if (avctx->flags & AV_CODEC_FLAG_PASS2)
        enccfg.g_pass = AOM_RC_LAST_PASS;
    else
        enccfg.g_pass = AOM_RC_ONE_PASS;

    if (avctx->rc_min_rate == avctx->rc_max_rate &&
        avctx->rc_min_rate == avctx->bit_rate && avctx->bit_rate) {
        enccfg.rc_end_usage = AOM_CBR;
    } else if (ctx->crf >= 0) {
        enccfg.rc_end_usage = AOM_CQ;
        if (!avctx->bit_rate)
            enccfg.rc_end_usage = AOM_Q;
    }

    if (avctx->bit_rate) {
        enccfg.rc_target_bitrate = av_rescale_rnd(avctx->bit_rate, 1, 1000,
                                                  AV_ROUND_NEAR_INF);
    } else if (enccfg.rc_end_usage != AOM_Q) {
        if (enccfg.rc_end_usage == AOM_CQ) {
            enccfg.rc_target_bitrate = 1000000;
        } else {
            avctx->bit_rate = enccfg.rc_target_bitrate * 1000;
            av_log(avctx, AV_LOG_WARNING,
                   "Neither bitrate nor constrained quality specified, using default bitrate of %dkbit/sec\n",
                   enccfg.rc_target_bitrate);
        }
    }

    if (avctx->qmin >= 0)
        enccfg.rc_min_quantizer = avctx->qmin;
    if (avctx->qmax >= 0)
        enccfg.rc_max_quantizer = avctx->qmax;

    if (enccfg.rc_end_usage == AOM_CQ || enccfg.rc_end_usage == AOM_Q) {
        if (ctx->crf < enccfg.rc_min_quantizer || ctx->crf > enccfg.rc_max_quantizer) {
            av_log(avctx, AV_LOG_ERROR,
                   "CQ level %d must be between minimum and maximum quantizer value (%d-%d)\n",
                   ctx->crf, enccfg.rc_min_quantizer, enccfg.rc_max_quantizer);
            return AVERROR(EINVAL);
        }
    }

    enccfg.rc_dropframe_thresh = ctx->drop_threshold;

    // 0-100 (0 => CBR, 100 => VBR)
    enccfg.rc_2pass_vbr_bias_pct       = round(avctx->qcompress * 100);
    if (ctx->minsection_pct >= 0)
        enccfg.rc_2pass_vbr_minsection_pct = ctx->minsection_pct;
    else if (avctx->bit_rate)
        enccfg.rc_2pass_vbr_minsection_pct =
            avctx->rc_min_rate * 100LL / avctx->bit_rate;
    if (ctx->maxsection_pct >= 0)
        enccfg.rc_2pass_vbr_maxsection_pct = ctx->maxsection_pct;
    else if (avctx->rc_max_rate)
        enccfg.rc_2pass_vbr_maxsection_pct =
            avctx->rc_max_rate * 100LL / avctx->bit_rate;

    if (avctx->rc_buffer_size)
        enccfg.rc_buf_sz =
            avctx->rc_buffer_size * 1000LL / avctx->bit_rate;
    if (avctx->rc_initial_buffer_occupancy)
        enccfg.rc_buf_initial_sz =
            avctx->rc_initial_buffer_occupancy * 1000LL / avctx->bit_rate;
    enccfg.rc_buf_optimal_sz = enccfg.rc_buf_sz * 5 / 6;

    if (ctx->rc_undershoot_pct >= 0)
        enccfg.rc_undershoot_pct = ctx->rc_undershoot_pct;
    if (ctx->rc_overshoot_pct >= 0)
        enccfg.rc_overshoot_pct = ctx->rc_overshoot_pct;

    // _enc_init() will balk if kf_min_dist differs from max w/AOM_KF_AUTO
    if (avctx->keyint_min >= 0 && avctx->keyint_min == avctx->gop_size)
        enccfg.kf_min_dist = avctx->keyint_min;
    if (avctx->gop_size >= 0)
        enccfg.kf_max_dist = avctx->gop_size;

    if (enccfg.g_pass == AOM_RC_FIRST_PASS)
        enccfg.g_lag_in_frames = 0;
    else if (enccfg.g_pass == AOM_RC_LAST_PASS) {
        int decode_size, ret;

        if (!avctx->stats_in) {
            av_log(avctx, AV_LOG_ERROR, "No stats file for second pass\n");
            return AVERROR_INVALIDDATA;
        }

        ctx->twopass_stats.sz = strlen(avctx->stats_in) * 3 / 4;
        ret                   = av_reallocp(&ctx->twopass_stats.buf, ctx->twopass_stats.sz);
        if (ret < 0) {
            av_log(avctx, AV_LOG_ERROR,
                   "Stat buffer alloc (%"SIZE_SPECIFIER" bytes) failed\n",
                   ctx->twopass_stats.sz);
            ctx->twopass_stats.sz = 0;
            return ret;
        }
        decode_size = av_base64_decode(ctx->twopass_stats.buf, avctx->stats_in,
                                       ctx->twopass_stats.sz);
        if (decode_size < 0) {
            av_log(avctx, AV_LOG_ERROR, "Stat buffer decode failed\n");
            return AVERROR_INVALIDDATA;
        }

        ctx->twopass_stats.sz      = decode_size;
        enccfg.rc_twopass_stats_in = ctx->twopass_stats;
    }

    /* 0-3: For non-zero values the encoder increasingly optimizes for reduced
     * complexity playback on low powered devices at the expense of encode
     * quality. */
    if (avctx->profile != FF_PROFILE_UNKNOWN)
        enccfg.g_profile = avctx->profile;

    enccfg.g_error_resilient = ctx->error_resilient;

    res = choose_tiling(avctx, &enccfg);
    if (res < 0)
        return res;

    dump_enc_cfg(avctx, &enccfg);
    /* Construct Encoder Context */
    res = aom_codec_enc_init(&ctx->encoder, iface, &enccfg, flags);
    if (res != AOM_CODEC_OK) {
        log_encoder_error(avctx, "Failed to initialize encoder");
        return AVERROR(EINVAL);
    }

    // codec control failures are currently treated only as warnings
    av_log(avctx, AV_LOG_DEBUG, "aom_codec_control\n");
    codecctl_int(avctx, AOME_SET_CPUUSED, ctx->cpu_used);
    if (ctx->auto_alt_ref >= 0)
        codecctl_int(avctx, AOME_SET_ENABLEAUTOALTREF, ctx->auto_alt_ref);
    if (ctx->arnr_max_frames >= 0)
        codecctl_int(avctx, AOME_SET_ARNR_MAXFRAMES,   ctx->arnr_max_frames);
    if (ctx->arnr_strength >= 0)
        codecctl_int(avctx, AOME_SET_ARNR_STRENGTH,    ctx->arnr_strength);
    if (ctx->enable_cdef >= 0)
        codecctl_int(avctx, AV1E_SET_ENABLE_CDEF, ctx->enable_cdef);
    codecctl_int(avctx, AOME_SET_STATIC_THRESHOLD, ctx->static_thresh);
    if (ctx->crf >= 0)
        codecctl_int(avctx, AOME_SET_CQ_LEVEL,          ctx->crf);

    codecctl_int(avctx, AV1E_SET_COLOR_PRIMARIES, avctx->color_primaries);
    codecctl_int(avctx, AV1E_SET_MATRIX_COEFFICIENTS, avctx->colorspace);
    codecctl_int(avctx, AV1E_SET_TRANSFER_CHARACTERISTICS, avctx->color_trc);
    if (ctx->aq_mode >= 0)
        codecctl_int(avctx, AV1E_SET_AQ_MODE, ctx->aq_mode);
    if (ctx->frame_parallel >= 0)
        codecctl_int(avctx, AV1E_SET_FRAME_PARALLEL_DECODING, ctx->frame_parallel);
    set_color_range(avctx);

    codecctl_int(avctx, AV1E_SET_SUPERBLOCK_SIZE, ctx->superblock_size);
    if (ctx->uniform_tiles) {
        codecctl_int(avctx, AV1E_SET_TILE_COLUMNS, ctx->tile_cols_log2);
        codecctl_int(avctx, AV1E_SET_TILE_ROWS,    ctx->tile_rows_log2);
    }

#ifdef AOM_CTRL_AV1E_SET_DENOISE_NOISE_LEVEL
    if (ctx->denoise_noise_level >= 0)
        codecctl_int(avctx, AV1E_SET_DENOISE_NOISE_LEVEL, ctx->denoise_noise_level);
#endif
#ifdef AOM_CTRL_AV1E_SET_DENOISE_BLOCK_SIZE
    if (ctx->denoise_block_size >= 0)
        codecctl_int(avctx, AV1E_SET_DENOISE_BLOCK_SIZE, ctx->denoise_block_size);
#endif
#ifdef AOM_CTRL_AV1E_SET_ENABLE_GLOBAL_MOTION
    if (ctx->enable_global_motion >= 0)
        codecctl_int(avctx, AV1E_SET_ENABLE_GLOBAL_MOTION, ctx->enable_global_motion);
#endif
#ifdef AOM_CTRL_AV1E_SET_MAX_REFERENCE_FRAMES
    if (avctx->refs >= 3) {
        codecctl_int(avctx, AV1E_SET_MAX_REFERENCE_FRAMES, avctx->refs);
    }
#endif
#ifdef AOM_CTRL_AV1E_SET_ROW_MT
    if (ctx->row_mt >= 0)
        codecctl_int(avctx, AV1E_SET_ROW_MT, ctx->row_mt);
#endif
#ifdef AOM_CTRL_AV1E_SET_ENABLE_INTRABC
    if (ctx->enable_intrabc >= 0)
        codecctl_int(avctx, AV1E_SET_ENABLE_INTRABC, ctx->enable_intrabc);
#endif

    // provide dummy value to initialize wrapper, values will be updated each _encode()
    aom_img_wrap(&ctx->rawimg, img_fmt, avctx->width, avctx->height, 1,
                 (unsigned char*)1);

    if (codec_caps & AOM_CODEC_CAP_HIGHBITDEPTH)
        ctx->rawimg.bit_depth = enccfg.g_bit_depth;

    cpb_props = ff_add_cpb_side_data(avctx);
    if (!cpb_props)
        return AVERROR(ENOMEM);

    if (avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER) {
        const AVBitStreamFilter *filter = av_bsf_get_by_name("extract_extradata");
        int ret;

        if (!filter) {
            av_log(avctx, AV_LOG_ERROR, "extract_extradata bitstream filter "
                   "not found. This is a bug, please report it.\n");
            return AVERROR_BUG;
        }
        ret = av_bsf_alloc(filter, &ctx->bsf);
        if (ret < 0)
            return ret;

        ret = avcodec_parameters_from_context(ctx->bsf->par_in, avctx);
        if (ret < 0)
           return ret;

        ret = av_bsf_init(ctx->bsf);
        if (ret < 0)
           return ret;
    }

    if (enccfg.rc_end_usage == AOM_CBR ||
        enccfg.g_pass != AOM_RC_ONE_PASS) {
        cpb_props->max_bitrate = avctx->rc_max_rate;
        cpb_props->min_bitrate = avctx->rc_min_rate;
        cpb_props->avg_bitrate = avctx->bit_rate;
    }
    cpb_props->buffer_size = avctx->rc_buffer_size;

    return 0;
}

// the below code fragment can be found in:
// libavcodec/alsdec.c
static av_cold int decode_init(AVCodecContext *avctx)
{
    unsigned int c;
    unsigned int channel_size;
    int num_buffers, ret;
    ALSDecContext *ctx = avctx->priv_data;
    ALSSpecificConfig *sconf = &ctx->sconf;
    ctx->avctx = avctx;

    if (!avctx->extradata) {
        av_log(avctx, AV_LOG_ERROR, "Missing required ALS extradata.\n");
        return AVERROR_INVALIDDATA;
    }

    if ((ret = read_specific_config(ctx)) < 0) {
        av_log(avctx, AV_LOG_ERROR, "Reading ALSSpecificConfig failed.\n");
        goto fail;
    }

    if ((ret = check_specific_config(ctx)) < 0) {
        goto fail;
    }

    if (sconf->bgmc) {
        ret = ff_bgmc_init(avctx, &ctx->bgmc_lut, &ctx->bgmc_lut_status);
        if (ret < 0)
            goto fail;
    }
    if (sconf->floating) {
        avctx->sample_fmt          = AV_SAMPLE_FMT_FLT;
        avctx->bits_per_raw_sample = 32;
    } else {
        avctx->sample_fmt          = sconf->resolution > 1
                                     ? AV_SAMPLE_FMT_S32 : AV_SAMPLE_FMT_S16;
        avctx->bits_per_raw_sample = (sconf->resolution + 1) * 8;
        if (avctx->bits_per_raw_sample > 32) {
            av_log(avctx, AV_LOG_ERROR, "Bits per raw sample %d larger than 32.\n",
                   avctx->bits_per_raw_sample);
            ret = AVERROR_INVALIDDATA;
            goto fail;
        }
    }

    // set maximum Rice parameter for progressive decoding based on resolution
    // This is not specified in 14496-3 but actually done by the reference
    // codec RM22 revision 2.
    ctx->s_max = sconf->resolution > 1 ? 31 : 15;

    // set lag value for long-term prediction
    ctx->ltp_lag_length = 8 + (avctx->sample_rate >=  96000) +
                              (avctx->sample_rate >= 192000);

    // allocate quantized parcor coefficient buffer
    num_buffers = sconf->mc_coding ? avctx->channels : 1;

    ctx->quant_cof        = av_malloc_array(num_buffers, sizeof(*ctx->quant_cof));
    ctx->lpc_cof          = av_malloc_array(num_buffers, sizeof(*ctx->lpc_cof));
    ctx->quant_cof_buffer = av_malloc_array(num_buffers * sconf->max_order,
                                            sizeof(*ctx->quant_cof_buffer));
    ctx->lpc_cof_buffer   = av_malloc_array(num_buffers * sconf->max_order,
                                            sizeof(*ctx->lpc_cof_buffer));
    ctx->lpc_cof_reversed_buffer = av_malloc_array(sconf->max_order,
                                                   sizeof(*ctx->lpc_cof_buffer));

    if (!ctx->quant_cof              || !ctx->lpc_cof        ||
        !ctx->quant_cof_buffer       || !ctx->lpc_cof_buffer ||
        !ctx->lpc_cof_reversed_buffer) {
        av_log(avctx, AV_LOG_ERROR, "Allocating buffer memory failed.\n");
        ret = AVERROR(ENOMEM);
        goto fail;
    }

    // assign quantized parcor coefficient buffers
    for (c = 0; c < num_buffers; c++) {
        ctx->quant_cof[c] = ctx->quant_cof_buffer + c * sconf->max_order;
        ctx->lpc_cof[c]   = ctx->lpc_cof_buffer   + c * sconf->max_order;
    }

    // allocate and assign lag and gain data buffer for ltp mode
    ctx->const_block     = av_malloc_array(num_buffers, sizeof(*ctx->const_block));
    ctx->shift_lsbs      = av_malloc_array(num_buffers, sizeof(*ctx->shift_lsbs));
    ctx->opt_order       = av_malloc_array(num_buffers, sizeof(*ctx->opt_order));
    ctx->store_prev_samples = av_malloc_array(num_buffers, sizeof(*ctx->store_prev_samples));
    ctx->use_ltp         = av_mallocz_array(num_buffers, sizeof(*ctx->use_ltp));
    ctx->ltp_lag         = av_malloc_array(num_buffers, sizeof(*ctx->ltp_lag));
    ctx->ltp_gain        = av_malloc_array(num_buffers, sizeof(*ctx->ltp_gain));
    ctx->ltp_gain_buffer = av_malloc_array(num_buffers * 5, sizeof(*ctx->ltp_gain_buffer));

    if (!ctx->const_block || !ctx->shift_lsbs ||
        !ctx->opt_order || !ctx->store_prev_samples ||
        !ctx->use_ltp  || !ctx->ltp_lag ||
        !ctx->ltp_gain || !ctx->ltp_gain_buffer) {
        av_log(avctx, AV_LOG_ERROR, "Allocating buffer memory failed.\n");
        ret = AVERROR(ENOMEM);
        goto fail;
    }

    for (c = 0; c < num_buffers; c++)
        ctx->ltp_gain[c] = ctx->ltp_gain_buffer + c * 5;

    // allocate and assign channel data buffer for mcc mode
    if (sconf->mc_coding) {
        ctx->chan_data_buffer  = av_mallocz_array(num_buffers * num_buffers,
                                                 sizeof(*ctx->chan_data_buffer));
        ctx->chan_data         = av_mallocz_array(num_buffers,
                                                 sizeof(*ctx->chan_data));
        ctx->reverted_channels = av_malloc_array(num_buffers,
                                                 sizeof(*ctx->reverted_channels));

        if (!ctx->chan_data_buffer || !ctx->chan_data || !ctx->reverted_channels) {
            av_log(avctx, AV_LOG_ERROR, "Allocating buffer memory failed.\n");
            ret = AVERROR(ENOMEM);
            goto fail;
        }

        for (c = 0; c < num_buffers; c++)
            ctx->chan_data[c] = ctx->chan_data_buffer + c * num_buffers;
    } else {
        ctx->chan_data         = NULL;
        ctx->chan_data_buffer  = NULL;
        ctx->reverted_channels = NULL;
    }

    channel_size      = sconf->frame_length + sconf->max_order;

    ctx->prev_raw_samples = av_malloc_array(sconf->max_order, sizeof(*ctx->prev_raw_samples));
    ctx->raw_buffer       = av_mallocz_array(avctx->channels * channel_size, sizeof(*ctx->raw_buffer));
    ctx->raw_samples      = av_malloc_array(avctx->channels, sizeof(*ctx->raw_samples));

    if (sconf->floating) {
        ctx->acf               = av_malloc_array(avctx->channels, sizeof(*ctx->acf));
        ctx->shift_value       = av_malloc_array(avctx->channels, sizeof(*ctx->shift_value));
        ctx->last_shift_value  = av_malloc_array(avctx->channels, sizeof(*ctx->last_shift_value));
        ctx->last_acf_mantissa = av_malloc_array(avctx->channels, sizeof(*ctx->last_acf_mantissa));
        ctx->raw_mantissa      = av_mallocz_array(avctx->channels, sizeof(*ctx->raw_mantissa));

        ctx->larray = av_malloc_array(ctx->cur_frame_length * 4, sizeof(*ctx->larray));
        ctx->nbits  = av_malloc_array(ctx->cur_frame_length, sizeof(*ctx->nbits));
        ctx->mlz    = av_mallocz(sizeof(*ctx->mlz));

        if (!ctx->mlz || !ctx->acf || !ctx->shift_value || !ctx->last_shift_value
            || !ctx->last_acf_mantissa || !ctx->raw_mantissa) {
            av_log(avctx, AV_LOG_ERROR, "Allocating buffer memory failed.\n");
            ret = AVERROR(ENOMEM);
            goto fail;
        }

        ff_mlz_init_dict(avctx, ctx->mlz);
        ff_mlz_flush_dict(ctx->mlz);

        for (c = 0; c < avctx->channels; ++c) {
            ctx->raw_mantissa[c] = av_mallocz_array(ctx->cur_frame_length, sizeof(**ctx->raw_mantissa));
        }
    }

    // allocate previous raw sample buffer
    if (!ctx->prev_raw_samples || !ctx->raw_buffer|| !ctx->raw_samples) {
        av_log(avctx, AV_LOG_ERROR, "Allocating buffer memory failed.\n");
        ret = AVERROR(ENOMEM);
        goto fail;
    }

    // assign raw samples buffers
    ctx->raw_samples[0] = ctx->raw_buffer + sconf->max_order;
    for (c = 1; c < avctx->channels; c++)
        ctx->raw_samples[c] = ctx->raw_samples[c - 1] + channel_size;

    // allocate crc buffer
    if (HAVE_BIGENDIAN != sconf->msb_first && sconf->crc_enabled &&
        (avctx->err_recognition & (AV_EF_CRCCHECK|AV_EF_CAREFUL))) {
        ctx->crc_buffer = av_malloc_array(ctx->cur_frame_length *
                                          avctx->channels *
                                          av_get_bytes_per_sample(avctx->sample_fmt),
                                          sizeof(*ctx->crc_buffer));
        if (!ctx->crc_buffer) {
            av_log(avctx, AV_LOG_ERROR, "Allocating buffer memory failed.\n");
            ret = AVERROR(ENOMEM);
            goto fail;
        }
    }

    ff_bswapdsp_init(&ctx->bdsp);

    return 0;

fail:
    decode_end(avctx);
    return ret;
}

// the below code fragment can be found in:
// libavcodec/h264_slice.c
int ff_h264_update_thread_context(AVCodecContext *dst,
                                  const AVCodecContext *src)
{
    H264Context *h = dst->priv_data, *h1 = src->priv_data;
    int inited = h->context_initialized, err = 0;
    int need_reinit = 0;
    int i, ret;

    if (dst == src)
        return 0;

    // We can't fail if SPS isn't set at it breaks current skip_frame code
    //if (!h1->ps.sps)
    //    return AVERROR_INVALIDDATA;

    if (inited &&
        (h->width                 != h1->width                 ||
         h->height                != h1->height                ||
         h->mb_width              != h1->mb_width              ||
         h->mb_height             != h1->mb_height             ||
         !h->ps.sps                                            ||
         h->ps.sps->bit_depth_luma    != h1->ps.sps->bit_depth_luma    ||
         h->ps.sps->chroma_format_idc != h1->ps.sps->chroma_format_idc ||
         h->ps.sps->colorspace        != h1->ps.sps->colorspace)) {
        need_reinit = 1;
    }

    /* copy block_offset since frame_start may not be called */
    memcpy(h->block_offset, h1->block_offset, sizeof(h->block_offset));

    // SPS/PPS
    for (i = 0; i < FF_ARRAY_ELEMS(h->ps.sps_list); i++) {
        av_buffer_unref(&h->ps.sps_list[i]);
        if (h1->ps.sps_list[i]) {
            h->ps.sps_list[i] = av_buffer_ref(h1->ps.sps_list[i]);
            if (!h->ps.sps_list[i])
                return AVERROR(ENOMEM);
        }
    }
    for (i = 0; i < FF_ARRAY_ELEMS(h->ps.pps_list); i++) {
        av_buffer_unref(&h->ps.pps_list[i]);
        if (h1->ps.pps_list[i]) {
            h->ps.pps_list[i] = av_buffer_ref(h1->ps.pps_list[i]);
            if (!h->ps.pps_list[i])
                return AVERROR(ENOMEM);
        }
    }

    av_buffer_unref(&h->ps.pps_ref);
    av_buffer_unref(&h->ps.sps_ref);
    h->ps.pps = NULL;
    h->ps.sps = NULL;
    if (h1->ps.pps_ref) {
        h->ps.pps_ref = av_buffer_ref(h1->ps.pps_ref);
        if (!h->ps.pps_ref)
            return AVERROR(ENOMEM);
        h->ps.pps = (const PPS*)h->ps.pps_ref->data;
    }
    if (h1->ps.sps_ref) {
        h->ps.sps_ref = av_buffer_ref(h1->ps.sps_ref);
        if (!h->ps.sps_ref)
            return AVERROR(ENOMEM);
        h->ps.sps = (const SPS*)h->ps.sps_ref->data;
    }

    if (need_reinit || !inited) {
        h->width     = h1->width;
        h->height    = h1->height;
        h->mb_height = h1->mb_height;
        h->mb_width  = h1->mb_width;
        h->mb_num    = h1->mb_num;
        h->mb_stride = h1->mb_stride;
        h->b_stride  = h1->b_stride;
        h->x264_build = h1->x264_build;

        if (h->context_initialized || h1->context_initialized) {
            if ((err = h264_slice_header_init(h)) < 0) {
                av_log(h->avctx, AV_LOG_ERROR, "h264_slice_header_init() failed");
                return err;
            }
        }

        /* copy block_offset since frame_start may not be called */
        memcpy(h->block_offset, h1->block_offset, sizeof(h->block_offset));
    }

    h->avctx->coded_height  = h1->avctx->coded_height;
    h->avctx->coded_width   = h1->avctx->coded_width;
    h->avctx->width         = h1->avctx->width;
    h->avctx->height        = h1->avctx->height;
    h->width_from_caller    = h1->width_from_caller;
    h->height_from_caller   = h1->height_from_caller;
    h->coded_picture_number = h1->coded_picture_number;
    h->first_field          = h1->first_field;
    h->picture_structure    = h1->picture_structure;
    h->mb_aff_frame         = h1->mb_aff_frame;
    h->droppable            = h1->droppable;

    for (i = 0; i < H264_MAX_PICTURE_COUNT; i++) {
        ff_h264_unref_picture(h, &h->DPB[i]);
        if (h1->DPB[i].f->buf[0] &&
            (ret = ff_h264_ref_picture(h, &h->DPB[i], &h1->DPB[i])) < 0)
            return ret;
    }

    h->cur_pic_ptr = REBASE_PICTURE(h1->cur_pic_ptr, h, h1);
    ff_h264_unref_picture(h, &h->cur_pic);
    if (h1->cur_pic.f->buf[0]) {
        ret = ff_h264_ref_picture(h, &h->cur_pic, &h1->cur_pic);
        if (ret < 0)
            return ret;
    }

    h->enable_er       = h1->enable_er;
    h->workaround_bugs = h1->workaround_bugs;
    h->droppable       = h1->droppable;

    // extradata/NAL handling
    h->is_avc = h1->is_avc;
    h->nal_length_size = h1->nal_length_size;

    memcpy(&h->poc,        &h1->poc,        sizeof(h->poc));

    memcpy(h->short_ref,   h1->short_ref,   sizeof(h->short_ref));
    memcpy(h->long_ref,    h1->long_ref,    sizeof(h->long_ref));
    memcpy(h->delayed_pic, h1->delayed_pic, sizeof(h->delayed_pic));
    memcpy(h->last_pocs,   h1->last_pocs,   sizeof(h->last_pocs));

    h->next_output_pic   = h1->next_output_pic;
    h->next_outputed_poc = h1->next_outputed_poc;

    memcpy(h->mmco, h1->mmco, sizeof(h->mmco));
    h->nb_mmco         = h1->nb_mmco;
    h->mmco_reset      = h1->mmco_reset;
    h->explicit_ref_marking = h1->explicit_ref_marking;
    h->long_ref_count  = h1->long_ref_count;
    h->short_ref_count = h1->short_ref_count;

    copy_picture_range(h->short_ref, h1->short_ref, 32, h, h1);
    copy_picture_range(h->long_ref, h1->long_ref, 32, h, h1);
    copy_picture_range(h->delayed_pic, h1->delayed_pic,
                       MAX_DELAYED_PIC_COUNT + 2, h, h1);

    h->frame_recovered       = h1->frame_recovered;

    av_buffer_unref(&h->sei.a53_caption.buf_ref);
    if (h1->sei.a53_caption.buf_ref) {
        h->sei.a53_caption.buf_ref = av_buffer_ref(h1->sei.a53_caption.buf_ref);
        if (!h->sei.a53_caption.buf_ref)
            return AVERROR(ENOMEM);
    }

    if (!h->cur_pic_ptr)
        return 0;

    if (!h->droppable) {
        err = ff_h264_execute_ref_pic_marking(h);
        h->poc.prev_poc_msb = h->poc.poc_msb;
        h->poc.prev_poc_lsb = h->poc.poc_lsb;
    }
    h->poc.prev_frame_num_offset = h->poc.frame_num_offset;
    h->poc.prev_frame_num        = h->poc.frame_num;

    h->recovery_frame        = h1->recovery_frame;

    return err;
}

// the below code fragment can be found in:
// libavcodec/dnxhdenc.c
static av_cold int dnxhd_encode_init(AVCodecContext *avctx)
{
    DNXHDEncContext *ctx = avctx->priv_data;
    int i, index, ret;

    switch (avctx->pix_fmt) {
    case AV_PIX_FMT_YUV422P:
        ctx->bit_depth = 8;
        break;
    case AV_PIX_FMT_YUV422P10:
    case AV_PIX_FMT_YUV444P10:
    case AV_PIX_FMT_GBRP10:
        ctx->bit_depth = 10;
        break;
    default:
        av_log(avctx, AV_LOG_ERROR,
               "pixel format is incompatible with DNxHD\n");
        return AVERROR(EINVAL);
    }

    if ((ctx->profile == FF_PROFILE_DNXHR_444 && (avctx->pix_fmt != AV_PIX_FMT_YUV444P10 &&
                                                  avctx->pix_fmt != AV_PIX_FMT_GBRP10)) ||
        (ctx->profile != FF_PROFILE_DNXHR_444 && (avctx->pix_fmt == AV_PIX_FMT_YUV444P10 ||
                                                  avctx->pix_fmt == AV_PIX_FMT_GBRP10))) {
        av_log(avctx, AV_LOG_ERROR,
               "pixel format is incompatible with DNxHD profile\n");
        return AVERROR(EINVAL);
    }

    if (ctx->profile == FF_PROFILE_DNXHR_HQX && avctx->pix_fmt != AV_PIX_FMT_YUV422P10) {
        av_log(avctx, AV_LOG_ERROR,
               "pixel format is incompatible with DNxHR HQX profile\n");
        return AVERROR(EINVAL);
    }

    if ((ctx->profile == FF_PROFILE_DNXHR_LB ||
         ctx->profile == FF_PROFILE_DNXHR_SQ ||
         ctx->profile == FF_PROFILE_DNXHR_HQ) && avctx->pix_fmt != AV_PIX_FMT_YUV422P) {
        av_log(avctx, AV_LOG_ERROR,
               "pixel format is incompatible with DNxHR LB/SQ/HQ profile\n");
        return AVERROR(EINVAL);
    }

    ctx->is_444 = ctx->profile == FF_PROFILE_DNXHR_444;
    avctx->profile = ctx->profile;
    ctx->cid = ff_dnxhd_find_cid(avctx, ctx->bit_depth);
    if (!ctx->cid) {
        av_log(avctx, AV_LOG_ERROR,
               "video parameters incompatible with DNxHD. Valid DNxHD profiles:\n");
        ff_dnxhd_print_profiles(avctx, AV_LOG_ERROR);
        return AVERROR(EINVAL);
    }
    av_log(avctx, AV_LOG_DEBUG, "cid %d\n", ctx->cid);

    if (ctx->cid >= 1270 && ctx->cid <= 1274)
        avctx->codec_tag = MKTAG('A','V','d','h');

    if (avctx->width < 256 || avctx->height < 120) {
        av_log(avctx, AV_LOG_ERROR,
               "Input dimensions too small, input must be at least 256x120\n");
        return AVERROR(EINVAL);
    }

    index = ff_dnxhd_get_cid_table(ctx->cid);
    av_assert0(index >= 0);

    ctx->cid_table = &ff_dnxhd_cid_table[index];

    ctx->m.avctx    = avctx;
    ctx->m.mb_intra = 1;
    ctx->m.h263_aic = 1;

    avctx->bits_per_raw_sample = ctx->bit_depth;

    ff_blockdsp_init(&ctx->bdsp, avctx);
    ff_fdctdsp_init(&ctx->m.fdsp, avctx);
    ff_mpv_idct_init(&ctx->m);
    ff_mpegvideoencdsp_init(&ctx->m.mpvencdsp, avctx);
    ff_pixblockdsp_init(&ctx->m.pdsp, avctx);
    ff_dct_encode_init(&ctx->m);

    if (ctx->profile != FF_PROFILE_DNXHD)
        ff_videodsp_init(&ctx->m.vdsp, ctx->bit_depth);

    if (!ctx->m.dct_quantize)
        ctx->m.dct_quantize = ff_dct_quantize_c;

    if (ctx->is_444 || ctx->profile == FF_PROFILE_DNXHR_HQX) {
        ctx->m.dct_quantize     = dnxhd_10bit_dct_quantize_444;
        ctx->get_pixels_8x4_sym = dnxhd_10bit_get_pixels_8x4_sym;
        ctx->block_width_l2     = 4;
    } else if (ctx->bit_depth == 10) {
        ctx->m.dct_quantize     = dnxhd_10bit_dct_quantize;
        ctx->get_pixels_8x4_sym = dnxhd_10bit_get_pixels_8x4_sym;
        ctx->block_width_l2     = 4;
    } else {
        ctx->get_pixels_8x4_sym = dnxhd_8bit_get_pixels_8x4_sym;
        ctx->block_width_l2     = 3;
    }

    if (ARCH_X86)
        ff_dnxhdenc_init_x86(ctx);

    ctx->m.mb_height = (avctx->height + 15) / 16;
    ctx->m.mb_width  = (avctx->width  + 15) / 16;

    if (avctx->flags & AV_CODEC_FLAG_INTERLACED_DCT) {
        ctx->interlaced   = 1;
        ctx->m.mb_height /= 2;
    }

    if (ctx->interlaced && ctx->profile != FF_PROFILE_DNXHD) {
        av_log(avctx, AV_LOG_ERROR,
               "Interlaced encoding is not supported for DNxHR profiles.\n");
        return AVERROR(EINVAL);
    }

    ctx->m.mb_num = ctx->m.mb_height * ctx->m.mb_width;

    if (ctx->cid_table->frame_size == DNXHD_VARIABLE) {
        ctx->frame_size = avpriv_dnxhd_get_hr_frame_size(ctx->cid,
                                                     avctx->width, avctx->height);
        av_assert0(ctx->frame_size >= 0);
        ctx->coding_unit_size = ctx->frame_size;
    } else {
        ctx->frame_size = ctx->cid_table->frame_size;
        ctx->coding_unit_size = ctx->cid_table->coding_unit_size;
    }

    if (ctx->m.mb_height > 68)
        ctx->data_offset = 0x170 + (ctx->m.mb_height << 2);
    else
        ctx->data_offset = 0x280;

    // XXX tune lbias/cbias
    if ((ret = dnxhd_init_qmat(ctx, ctx->intra_quant_bias, 0)) < 0)
        return ret;

    /* Avid Nitris hardware decoder requires a minimum amount of padding
     * in the coding unit payload */
    if (ctx->nitris_compat)
        ctx->min_padding = 1600;

    if ((ret = dnxhd_init_vlc(ctx)) < 0)
        return ret;
    if ((ret = dnxhd_init_rc(ctx)) < 0)
        return ret;

    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->slice_size,
                      ctx->m.mb_height * sizeof(uint32_t), fail);
    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->slice_offs,
                      ctx->m.mb_height * sizeof(uint32_t), fail);
    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->mb_bits,
                      ctx->m.mb_num * sizeof(uint16_t), fail);
    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->mb_qscale,
                      ctx->m.mb_num * sizeof(uint8_t), fail);

#if FF_API_CODED_FRAME
FF_DISABLE_DEPRECATION_WARNINGS
    avctx->coded_frame->key_frame = 1;
    avctx->coded_frame->pict_type = AV_PICTURE_TYPE_I;
FF_ENABLE_DEPRECATION_WARNINGS
#endif

    if (avctx->active_thread_type == FF_THREAD_SLICE) {
        if (avctx->thread_count > MAX_THREADS) {
            av_log(avctx, AV_LOG_ERROR, "too many threads\n");
            return AVERROR(EINVAL);
        }
    }

    if (avctx->qmax <= 1) {
        av_log(avctx, AV_LOG_ERROR, "qmax must be at least 2\n");
        return AVERROR(EINVAL);
    }

    ctx->thread[0] = ctx;
    if (avctx->active_thread_type == FF_THREAD_SLICE) {
        for (i = 1; i < avctx->thread_count; i++) {
            ctx->thread[i] = av_malloc(sizeof(DNXHDEncContext));
            memcpy(ctx->thread[i], ctx, sizeof(DNXHDEncContext));
        }
    }

    return 0;
fail:  // for FF_ALLOCZ_OR_GOTO
    return AVERROR(ENOMEM);
}
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).