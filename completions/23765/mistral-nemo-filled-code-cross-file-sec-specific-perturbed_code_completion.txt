if (ctxt->instate == XML_PARSER_START_TAG) {
    // Check if the current character is the start of a name
    if (!xmlIsNameStartChar(ctxt, CUR)) {
        htmlParseErr(ctxt, XML_ERR_NAME_CHAR, "Invalid character in element name", NULL, NULL);
        ctxt->instate = XML_PARSER_CONTENT;
        break;
    }

    // Parse the element name
    htmlParseName(ctxt);
    if (ctxt->name == NULL) {
        htmlParseErr(ctxt, XML_ERR_NAME_CHAR, "Invalid element name", NULL, NULL);
        ctxt->instate = XML_PARSER_CONTENT;
        break;
    }

    // Check if the element is a known tag
    const htmlElemDesc *info = htmlTagLookup(ctxt->name);
    if (info == NULL) {
        htmlParseErr(ctxt, XML_HTML_UNKNOWN_TAG, "Unknown element %s", ctxt->name, NULL);
        ctxt->instate = XML_PARSER_CONTENT;
        break;
    }

    // Check for an empty element
    if (info->empty && (CUR == '/') && (NXT(1) == '>')) {
        SKIP(2);
        if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))
            ctxt->sax->endElement(ctxt->userData, ctxt->name);
        htmlnamePop(ctxt);
        ctxt->instate = XML_PARSER_CONTENT;
        break;
    }

    // Check for attribute values
    while (CUR != '>' && CUR != '/') {
        if (CUR == ' ') {
            SKIP_BLANKS;
            continue;
        }
        if (CUR == '=') {
            htmlParseAttribute(ctxt);
            if (ctxt->name == NULL) {
                htmlParseErr(ctxt, XML_ERR_NAME_CHAR, "Invalid attribute name", NULL, NULL);
                ctxt->instate = XML_PARSER_CONTENT;
                break;
            }
            if (ctxt->value == NULL) {
                htmlParseErr(ctxt, XML_ERR_NAME_CHAR, "Invalid attribute value", NULL, NULL);
                ctxt->instate = XML_PARSER_CONTENT;
                break;
            }
        } else if (CUR == '/') {
            ctxt->instate = XML_PARSER_END_TAG;
            ctxt->checkIndex = 0;
            break;
        } else {
            htmlParseErr(ctxt, XML_ERR_NAME_CHAR, "Invalid character in element name", NULL, NULL);
            ctxt->instate = XML_PARSER_CONTENT;
            break;
        }
    }

    if (CUR == '>') {
        NEXT;
    } else {
        htmlParseErr(ctxt, XML_ERR_GT_REQUIRED, "Couldn't find end of Start Tag %s", ctxt->name, NULL);
        ctxt->instate = XML_PARSER_CONTENT;
        break;
    }
}