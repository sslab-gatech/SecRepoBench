before calling this function.
 */
void
htmlInitAutoClose(void) {
    int i;

    if (htmlStartCloseIndexinitialized)
        return;
    for (i = 0; i < 100; i++)
        htmlStartCloseIndex[i] = NULL;
    for (i = 0; htmlStartClose[i] != NULL; i++) {
        const char *tag = htmlStartClose[i];
        int idx = xmlStringLen(BAD_CAST tag);
        if (idx >= 100)
            idx = 99;
        if (htmlStartCloseIndex[idx] == NULL)
            htmlStartCloseIndex[idx] = (const char **)
                xmlMalloc(sizeof(char *));
        htmlStartCloseIndex[idx][0] = tag;
        htmlStartCloseIndex[idx] = (const char **)
            xmlRealloc(htmlStartCloseIndex[idx],
                       (i + 2) * sizeof(char *));
        htmlStartCloseIndex[idx][i + 1] = NULL;
    }
    htmlStartCloseIndexinitialized = 1;
}

/**
 * htmlIsScriptAttribute:
 * @name:  the attribute name
 *
 * Check if the attribute name is a script attribute
 *
 * Returns 1 if it is, 0 otherwise
 */
int
htmlIsScriptAttribute(const char *name) {
    int i;

    for (i = 0; htmlScriptAttributes[i] != NULL; i++) {
        if (xmlStrncasecmp(BAD_CAST name, BAD_CAST htmlScriptAttributes[i], 2) == 0)
            return(1);
    }
    return(0);
}

/**
 * htmlIsNoContentElement:
 * @name:  the element name
 *
 * Check if the element name is a no content element
 *
 * Returns 1 if it is, 0 otherwise
 */
int
htmlIsNoContentElement(const char *name) {
    int i;

    for (i = 0; htmlNoContentElements[i] != NULL; i++) {
        if (xmlStrcasecmp(BAD_CAST name, BAD_CAST htmlNoContentElements[i]) == 0)
            return(1);
    }
    return(0);
}

/**
 * htmlIsEmptyElement:
 * @name:  the element name
 *
 * Check if the element name is an empty element
 *
 * Returns 1 if it is, 0 otherwise
 */
int
htmlIsEmptyElement(const char *name) {
    int i;

    for (i = 0; html40ElementTable[i].name != NULL; i++) {
        if (xmlStrcasecmp(BAD_CAST name, BAD_CAST html40ElementTable[i].name) == 0)
            return(html40ElementTable[i].empty);
    }
    return(0);
}

/**
 * htmlIsInlineElement:
 * @name:  the element name
 *
 * Check if the element name is an inline element
 *
 * Returns 1 if it is, 0 otherwise
 */
int
htmlIsInlineElement(const char *name) {
    int i;

    for (i = 0; html40ElementTable[i].name != NULL; i++) {
        if (xmlStrcasecmp(BAD_CAST name, BAD_CAST html40ElementTable[i].name) == 0)
            return(html40ElementTable[i].inline);
    }
    return(0);
}

/**
 * htmlIsBlockElement:
 * @name:  the element name
 *
 * Check if the element name is a block element
 *
 * Returns 1 if it is, 0 otherwise
 */
int
htmlIsBlockElement(const char *name) {
    int i;

    for (i = 0; html40ElementTable[i].name != NULL; i++) {
        if (xmlStrcasecmp(BAD_CAST name, BAD_CAST html40ElementTable[i].name) == 0)
            return(!html40ElementTable[i].inline);
    }
    return(0);
}

/**
 * htmlIsStylisticElement:
 * @name:  the element name
 *
 * Check if the element name is a stylistic element
 *
 * Returns 1 if it is, 0 otherwise
 */
int
htmlIsStylisticElement(const char *name) {
    int i;

    for (i = 0; html40ElementTable[i].name != NULL; i++) {
        if (xmlStrcasecmp(BAD_CAST name, BAD_CAST html40ElementTable[i].name) == 0)
            return(html40ElementTable[i].stylistic);
    }
    return(0);
}

/**
 * htmlIsDeprecatedElement:
 * @name:  the element name
 *
 * Check if the element name is a deprecated element
 *
 * Returns 1 if it is, 0 otherwise
 */
int
htmlIsDeprecatedElement(const char *name) {
    int i;

    for (i = 0; html40ElementTable[i].name != NULL; i++) {
        if (xmlStrcasecmp(BAD_CAST name, BAD_CAST html40ElementTable[i].name) == 0)
            return(html40ElementTable[i].deprecated);
    }
    return(0);
}

/**
 * htmlIsLooseElement:
 * @name:  the element name
 *
 * Check if the element name is valid in the Loose DTD
 *
 * Returns 1 if it is, 0 otherwise
 */
int
htmlIsLooseElement(const char *name) {
    int i;

    for (i = 0; html40ElementTable[i].name != NULL; i++) {
        if (xmlStrcasecmp(BAD_CAST name, BAD_CAST html40ElementTable[i].name) == 0)
            return(html40ElementTable[i].dtd == 1);
    }
    return(0);
}

/**
 * htmlIsFramesetElement:
 * @name:  the element name
 *
 * Check if the element name is valid in the Frameset DTD
 *
 * Returns 1 if it is, 0 otherwise
 */
int
htmlIsFramesetElement(const char *name) {
    int i;

    for (i = 0; html40ElementTable[i].name != NULL; i++) {
        if (xmlStrcasecmp(BAD_CAST name, BAD_CAST html40ElementTable[i].name) == 0)
            return(html40ElementTable[i].dtd == 2);
    }
    return(0);
}

/**
 * htmlIsSpecialElement:
 * @name:  the element name
 *
 * Check if the element name is a special element
 *
 * Returns 1 if it is, 0 otherwise
 */
int
htmlIsSpecialElement(const char *name) {
    int i;

    for (i = 0; html40ElementTable[i].name != NULL; i++) {
        if (xmlStrcasecmp(BAD_CAST name, BAD_CAST html40ElementTable[i].name) == 0)
            return(html40ElementTable[i].special);
    }
    return(0);
}

/**
 * htmlIsFormElement:
 * @name:  the element name
 *
 * Check if the element name is a form element
 *
 * Returns 1 if it is, 0 otherwise
 */
int
htmlIsFormElement(const char *name) {
    int i;

    for (i = 0; html40ElementTable[i].name != NULL; i++) {
        if (xmlStrcasecmp(BAD_CAST name, BAD_CAST html40ElementTable[i].name) == 0)
            return(html40ElementTable[i].form);
    }
    return(0);
}

/**
 * htmlIsHeadingElement:
 * @name:  the element name
 *
 * Check if the element name is a heading element
 *
 * Returns 1 if it is, 0 otherwise
 */
int
htmlIsHeadingElement(const char *name) {
    int i;

    for (i = 0; html40ElementTable[i].name != NULL; i++) {
        if (xmlStrcasecmp(BAD_CAST name, BAD_CAST html40ElementTable[i].name) == 0)
            return(html40ElementTable[i].heading);
    }
    return(0);
}

/**
 * htmlIsListElement:
 * @name:  the element name
 *
 * Check if the element name is a list element
 *
 * Returns 1 if it is, 0 otherwise
 */
int
htmlIsListElement(const char *name) {
    int i;

    for (i = 0; html40ElementTable[i].name != NULL; i++) {
        if (xmlStrcasecmp(BAD_CAST name, BAD_CAST html40ElementTable[i].name) == 0)
            return(html40ElementTable[i].list);
    }
    return(0);
}

/**
 * htmlIsModifierElement:
 * @name:  the element name
 *
 * Check if the element name is a modifier element
 *
 * Returns 1 if it is, 0 otherwise
 */
int
htmlIsModifierElement(const char *name) {
    int i;

    for (i = 0; html40ElementTable[i].name != NULL; i++) {
        if (xmlStrcasecmp(BAD_CAST name, BAD_CAST html40ElementTable[i].name) == 0)
            return(html40ElementTable[i].modifier);
    }
    return(0);
}

/**
 * htmlIsFlowElement:
 * @name:  the element name
 *
 * Check if the element name is a flow element
 *
 * Returns 1 if it is, 0 otherwise
 */
int
htmlIsFlowElement(const char *name) {
    int i;

    for (i = 0; html40ElementTable[i].name != NULL; i++) {
        if (xmlStrcasecmp(BAD_CAST name, BAD_CAST html40ElementTable[i].name) == 0)
            return(html40ElementTable[i].flow);
    }
    return(0);
}

/**
 * htmlIsCellAlignAttr:
 * @name:  the attribute name
 *
 * Check if the attribute name is a cell align attribute
 *
 * Returns 1 if it is, 0 otherwise
 */
int
htmlIsCellAlignAttr(const char *name) {
    int i;

    for (i = 0; html_attrs[i] != NULL; i++) {
        if (xmlStrcasecmp(BAD_CAST name, BAD_CAST html_attrs[i]) == 0)
            return(html_attrs[i] == CELLHALIGN || html_attrs[i] == CELLVALIGN);
    }
    return(0);
}

/**
 * htmlIsCellAttr:
 * @name:  the attribute name
 *
 * Check if the attribute name is a cell attribute
 *
 * Returns 1 if it is, 0 otherwise
 */
int
htmlIsCellAttr(const char *name) {
    int i;

    for (i = 0; html_attrs[i] != NULL; i++) {
        if (xmlStrcasecmp(BAD_CAST name, BAD_CAST html_attrs[i]) == 0)
            return(html_attrs[i] == CELLHALIGN || html_attrs[i] == CELLVALIGN ||
                   html_attrs[i] == "align" || html_attrs[i] == "valign");
    }
    return(0);
}

/**
 * htmlIsCoreAttr:
 * @name:  the attribute name
 *
 * Check if the attribute name is a core attribute
 *
 * Returns 1 if it is, 0 otherwise
 */
int
htmlIsCoreAttr(const char *name) {
    int i;

    for (i = 0; html_attrs[i] != NULL; i++) {
        if (xmlStrcasecmp(BAD_CAST name, BAD_CAST html_attrs[i]) == 0)
            return(html_attrs[i] == COREATTRS);
    }
    return(0);
}

/**
 * htmlIsI18nAttr:
 * @name:  the attribute name
 *
 * Check if the attribute name is a i18n attribute
 *
 * Returns 1 if it is, 0 otherwise
 */
int
htmlIsI18nAttr(const char *name) {
    int i;

    for (i = 0; html_attrs[i] != NULL; i++) {
        if (xmlStrcasecmp(BAD_CAST