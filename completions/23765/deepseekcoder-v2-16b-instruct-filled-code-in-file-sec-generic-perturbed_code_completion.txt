table
 */
static void
htmlInitAutoClose(void) {
    int i;
    const char **cur;

    if (htmlStartCloseIndexinitialized)
        return;
    for (i = 0; i < 100; i++)
        htmlStartCloseIndex[i] = NULL;
    for (cur = htmlStartClose; *cur != NULL; cur++) {
        int idx = xmlStringLen(*cur) - 1;
        if (idx < 0) idx = 0;
        htmlStartCloseIndex[idx] = cur;
    }
    htmlStartCloseIndexinitialized = 1;
}

/**
 * htmlIsScriptAttribute:
 * @name:  the attribute name
 *
 * Check if the attribute name is a script attribute
 *
 * Returns 1 if it is, 0 otherwise
 */
static int
htmlIsScriptAttribute(const char *name) {
    int i;

    for (i = 0; htmlScriptAttributes[i] != NULL; i++) {
        if (xmlStrncasecmp(BAD_CAST htmlScriptAttributes[i],
                           BAD_CAST name, 2) == 0)
            return(1);
    }
    return(0);
}

/**
 * htmlIsNoContentElement:
 * @name:  the element name
 *
 * Check if the element name is a no content element
 *
 * Returns 1 if it is, 0 otherwise
 */
static int
htmlIsNoContentElement(const char *name) {
    int i;

    for (i = 0; htmlNoContentElements[i] != NULL; i++) {
        if (xmlStrcasecmp(BAD_CAST htmlNoContentElements[i],
                          BAD_CAST name) == 0)
            return(1);
    }
    return(0);
}

/**
 * htmlIsAutoCloseTag:
 * @name:  the element name
 *
 * Check if the element name is an auto close tag
 *
 * Returns 1 if it is, 0 otherwise
 */
static int
htmlIsAutoCloseTag(const char *name) {
    int idx;

    htmlInitAutoClose();
    idx = xmlStringLen(BAD_CAST name) - 1;
    if (idx < 0) idx = 0;
    if (htmlStartCloseIndex[idx] != NULL) {
        const char **cur;
        for (cur = htmlStartCloseIndex[idx]; *cur != NULL; cur++) {
            if (xmlStrcasecmp(BAD_CAST name, BAD_CAST *cur) == 0)
                return(1);
        }
    }
    return(0);
}

/**
 * htmlIsEmptyElem:
 * @name:  the element name
 *
 * Check if the element name is an empty element
 *
 * Returns 1 if it is, 0 otherwise
 */
static int
htmlIsEmptyElem(const char *name) {
    int i;

    for (i = 0; html40ElementTable[i].name != NULL; i++) {
        if (xmlStrcasecmp(BAD_CAST name, BAD_CAST html40ElementTable[i].name) == 0)
            return(html40ElementTable[i].empty);
    }
    return(0);
}

/**
 * htmlIsInline:
 * @name:  the element name
 *
 * Check if the element name is an inline element
 *
 * Returns 1 if it is, 0 otherwise
 */
static int
htmlIsInline(const char *name) {
    int i;

    for (i = 0; html40ElementTable[i].name != NULL; i++) {
        if (xmlStrcasecmp(BAD_CAST name, BAD_CAST html40ElementTable[i].name) == 0)
            return(html40ElementTable[i].inline);
    }
    return(0);
}

/**
 * htmlIsStylisticElem:
 * @name:  the element name
 *
 * Check if the element name is a stylistic element
 *
 * Returns 1 if it is, 0 otherwise
 */
static int
htmlIsStylisticElem(const char *name) {
    int i;

    for (i = 0; html40ElementTable[i].name != NULL; i++) {
        if (xmlStrcasecmp(BAD_CAST name, BAD_CAST html40ElementTable[i].name) == 0)
            return(html40ElementTable[i].saveEnd);
    }
    return(0);
}

/**
 * htmlIsDeprecatedElem:
 * @name:  the element name
 *
 * Check if the element name is a deprecated element
 *
 * Returns 1 if it is, 0 otherwise
 */
static int
htmlIsDeprecatedElem(const char *name) {
    int i;

    for (i = 0; html40ElementTable[i].name != NULL; i++) {
        if (xmlStrcasecmp(BAD_CAST name, BAD_CAST html40ElementTable[i].name) == 0)
            return(html40ElementTable[i].depr);
    }
    return(0);
}

/**
 * htmlIsLooseElem:
 * @name:  the element name
 *
 * Check if the element name is valid in the Loose DTD
 *
 * Returns 1 if it is, 0 otherwise
 */
static int
htmlIsLooseElem(const char *name) {
    int i;

    for (i = 0; html40ElementTable[i].name != NULL; i++) {
        if (xmlStrcasecmp(BAD_CAST name, BAD_CAST html40ElementTable[i].name) == 0)
            return(html40ElementTable[i].DTD == 1);
    }
    return(0);
}

/**
 * htmlIsFramesetElem:
 * @name:  the element name
 *
 * Check if the element name is valid in the Frameset DTD
 *
 * Returns 1 if it is, 0 otherwise
 */
static int
htmlIsFramesetElem(const char *name) {
    int i;

    for (i = 0; html40ElementTable[i].name != NULL; i++) {
        if (xmlStrcasecmp(BAD_CAST name, BAD_CAST html40ElementTable[i].name) == 0)
            return(html40ElementTable[i].DTD == 2);
    }
    return(0);
}

/**
 * htmlIsFlowElem:
 * @name:  the element name
 *
 * Check if the element name is a flow element
 *
 * Returns 1 if it is, 0 otherwise
 */
static int
htmlIsFlowElem(const char *name) {
    int i;

    for (i = 0; html_flow[i] != NULL; i++) {
        if (xmlStrcasecmp(BAD_CAST name, BAD_CAST html_flow[i]) == 0)
            return(1);
    }
    return(0);
}

/**
 * htmlIsBlockElem:
 * @name:  the element name
 *
 * Check if the element name is a block element
 *
 * Returns 1 if it is, 0 otherwise
 */
static int
htmlIsBlockElem(const char *name) {
    return(!htmlIsFlowElem(name));
}

/**
 * htmlIsInlineElem:
 * @name:  the element name
 *
 * Check if the element name is an inline element
 *
 * Returns 1 if it is, 0 otherwise
 */
static int
htmlIsInlineElem(const char *name) {
    int i;

    for (i = 0; html_inline[i] != NULL; i++) {
        if (xmlStrcasecmp(BAD_CAST name, BAD_CAST html_inline[i]) == 0)
            return(1);
    }
    return(0);
}

/**
 * htmlIsPcdataElem:
 * @name:  the element name
 *
 * Check if the element name is a PCDATA element
 *
 * Returns 1 if it is, 0 otherwise
 */
static int
htmlIsPcdataElem(const char *name) {
    int i;

    for (i = 0; html_pcdata[i] != NULL; i++) {
        if (xmlStrcasecmp(BAD_CAST name, BAD_CAST html_pcdata[i]) == 0)
            return(1);
    }
    return(0);
}

/**
 * htmlIsCdataElem:
 * @name:  the element name
 *
 * Check if the element name is a CDATA element
 *
 * Returns 1 if it is, 0 otherwise
 */
static int
htmlIsCdataElem(const char *name) {
    return(htmlIsPcdataElem(name));
}

/**
 * htmlIsAttr:
 * @name:  the attribute name
 *
 * Check if the attribute name is a valid HTML attribute
 *
 * Returns 1 if it is, 0 otherwise
 */
static int
htmlIsAttr(const char *name) {
    int i;

    for (i = 0; html_attrs[i] != NULL; i++) {
        if (xmlStrcasecmp(BAD_CAST html_attrs[i], BAD_CAST name) == 0)
            return(1);
    }
    return(0);
}

/**
 * htmlIsCoreAttr:
 * @name:  the attribute name
 *
 * Check if the attribute name is a valid HTML core attribute
 *
 * Returns 1 if it is, 0 otherwise
 */
static int
htmlIsCoreAttr(const char *name) {
    int i;

    for (i = 0; core_attrs[i] != NULL; i++) {
        if (xmlStrcasecmp(BAD_CAST core_attrs[i], BAD_CAST name) == 0)
            return(1);
    }
    return(0);
}

/**
 * htmlIsI18nAttr:
 * @name:  the attribute name
 *
 * Check if the attribute name is a valid HTML i18n attribute
 *
 * Returns 1 if it is, 0 otherwise
 */
static int
htmlIsI18nAttr(const char *name) {
    int i;

    for (i = 0; i18n_attrs[i] != NULL; i++) {
        if (xmlStrcasecmp(BAD_CAST i18n_attrs[i], BAD_CAST name) == 0)
            return(1);
    }
    return(0);
}

/**
 * htmlIsEventAttr:
 * @name:  the attribute name
 *
 * Check if the attribute name is a valid HTML event attribute
 *
 * Returns 1 if it is, 0 otherwise
 */
static int
htmlIsEventAttr(const char *name) {
    int i;

    for (i = 0; events[i] != NULL; i++) {
        if (xmlStrcasecmp(BAD_CAST events[i], BAD_CAST name) == 0)
            return(1);
    }
    return(0);
}

/**
 * htmlIsCellHAlignAttr:
 * @name:  the attribute name
 *
 * Check if the attribute name is a valid HTML cell horizontal alignment attribute
 *
 * Returns 1 if it is, 0 otherwise
 */
static int
htmlIsCellHAlignAttr(const char *name) {
    int i;

    for (i = 0; cellHAlignAttrs[i] != NULL; i++) {
        if (xmlStrcasecmp(BAD_CAST cellHAlignAttrs[i], BAD_CAST name) == 0)
            return(1);
    }
    return(0);
}

/**
 * htmlIsCellVAlignAttr:
 * @name:  the attribute name
 *
 * Check if the attribute name is a valid HTML cell vertical alignment attribute
 *
 * Returns 1 if it is, 0 otherwise
 */
static int
htmlIsCellVAlignAttr(const char *name) {
    int i;

    for (i = 0; cellVAlignAttrs[i] != NULL; i++) {
        if (xmlStrcasecmp(BAD_CAST cellVAlignAttrs[i], BAD_CAST name) == 0)
            return(1);
    }
    return(0);
}

/**
 * htmlIsCellAttr:
 * @name:  the attribute name
 *
 * Check if the attribute name is a valid HTML cell attribute
 *
 * Returns 1 if it is, 0 otherwise
 */
static int
htmlIsCellAttr(const char *name) {
    return(htmlIsCellHAlignAttr(name) || htmlIsCellVAlignAttr(name));
}

/**
 * htmlIsCellContent:
 * @name:  the element name
 *
 * Check if the element name is a valid HTML cell