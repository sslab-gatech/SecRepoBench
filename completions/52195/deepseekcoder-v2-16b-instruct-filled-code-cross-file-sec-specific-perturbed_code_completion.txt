if (wordnum + 2 < maxwordnum) {
  rv = compound_check(st.substr(i), wordnum + 1,
                      numsyllable, maxwordnum, wnum + 1, compound_words, rwords, 0,
                      is_sug, info);

  if (rv && !checkcpdtable.empty() &&
      ((scpd == 0 &&
        cpdpat_check(word.c_str(), i, rv_first, rv, affixed)) ||
       (scpd != 0 &&
        !cpdpat_check(word.c_str(), i, rv_first, rv, affixed))))
    rv = NULL;
} else {
  rv = NULL;
}
if (rv) {
  // forbid compound word, if it is a non-compound word with typical
  // fault, or a dictionary word pair

  if (cpdwordpair_check(word, len))
      return NULL;

  if (checkcompoundrep || forbiddenword) {

    if (checkcompoundrep && cpdrep_check(word, len))
      return NULL;

    // check first part
    if (word.compare(i, rv->blen, rv->word, rv->blen) == 0) {
      char r = st[i + rv->blen];
      st[i + rv->blen] = '\0';

      if ((checkcompoundrep && cpdrep_check(st, i + rv->blen)) ||
          cpdwordpair_check(st, i + rv->blen)) {
        st[i + rv->blen] = r;
        continue;
      }

      if (forbiddenword) {
        struct hentry* rv2 = lookup(word.c_str(), word.size());
        if (!rv2)
          rv2 = affix_check(word, 0, len);
        if (rv2 && rv2->astr &&
            TESTAFF(rv2->astr, forbiddenword, rv2->alen) &&
            (strncmp(rv2->word, st.c_str(), i + rv->blen) == 0)) {
          return NULL;
        }
      }
      st[i + rv->blen] = r;
    }
  }
  return rv_first;
}