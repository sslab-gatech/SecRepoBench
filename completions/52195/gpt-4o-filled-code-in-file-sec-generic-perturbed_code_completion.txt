if (simplifiedtriple && !checkedstriple) {
            if (i > 1 && word[i - 1] == word[i] && word[i - 1] == word[i - 2]) {
              striple = 1;
              checkedstriple = 1;
              i--;
              continue;
            }
          }

          // lookup for the current substring starting from the adjusted index
          rv = lookup(word.c_str() + i, word.size() - i);

          // iterate over homonyms of the current entry
          while (rv) {
            if ((compoundflag && TESTAFF(rv->astr, compoundflag, rv->alen)) ||
                (compoundend && TESTAFF(rv->astr, compoundend, rv->alen))) {
              if (((cpdwordmax == -1) || (wordnum + 1 < cpdwordmax)) ||
                  ((cpdmaxsyllable != 0) &&
                   (numsyllable + get_syllable(std::string(HENTRY_WORD(rv), rv->blen)) <=
                    cpdmaxsyllable))) {
                if (checkcpdtable.empty() || scpd != 0 ||
                    !cpdpat_check(word.c_str(), i, rv_first, rv, 0)) {
                  if (!checkcompounddup || (rv != rv_first)) {
                    return rv_first;
                  }
                }
              }
            }
            rv = rv->next_homonym;
          }