// Check for compound word conditions
            if (rv && (rv->astr) && 
                (TESTAFF(rv->astr, forbiddenword, rv->alen) || 
                 TESTAFF(rv->astr, needaffix, rv->alen) || 
                 TESTAFF(rv->astr, ONLYUPCASEFLAG, rv->alen) || 
                 (is_sug && nosuggest && TESTAFF(rv->astr, nosuggest, rv->alen)))) {
                return NULL;
            }

            // Check if the current entry has the compound root flag
            if (rv && compoundroot && TESTAFF(rv->astr, compoundroot, rv->alen)) {
                wordnum++;
            }

            // Check if the second word is acceptable as a root
            if (rv && 
                ((compoundflag && TESTAFF(rv->astr, compoundflag, rv->alen)) || 
                 (compoundend && TESTAFF(rv->astr, compoundend, rv->alen))) && 
                (((cpdwordmax == -1) || (wordnum + 1 < cpdwordmax)) || 
                 ((cpdmaxsyllable != 0) && 
                  (numsyllable + get_syllable(std::string(HENTRY_WORD(rv), rv->blen)) <= cpdmaxsyllable))) && 
                (scpd == 0 || checkcpdtable[scpd - 1].cond2 == FLAG_NULL || 
                 TESTAFF(rv->astr, checkcpdtable[scpd - 1].cond2, rv->alen)))) {
                // Check for compound word faults
                if ((checkcompoundrep && cpdrep_check(word, len)) || 
                    cpdwordpair_check(word, len)) {
                    return NULL;
                }
                return rv_first;
            }