// Handle simplified triple letter checking.
// If a simplified triple pattern is detected, adjust the index to re-evaluate
// a specific character sequence for compound word formation.
// Perform a lookup for the current substring starting from the adjusted index.
// Iterate over homonyms of the current entry to check for matching compound
// conditions, ensuring the entry has the correct affix flags for compound formation
// as per predefined rules or tables.
if (simplifiedcpd && scpd > 0 && !checkedstriple) {
    striple = 1;
    checkedstriple = 1;
    int soldi = i;
    i = i - checkcpdtable[scpd - 1].pattern3.size() + checkcpdtable[scpd - 1].pattern.size();
    rv = lookup(st.c_str() + i, st.size() - i);
    while (rv) {
        // forbid dictionary stems with COMPOUNDFORBIDFLAG in
        // compound words, overriding the effect of COMPOUNDPERMITFLAG
        if (compoundforbidflag && TESTAFF(rv->astr, compoundforbidflag, rv->alen) && !hu_mov_rule)
            break;

        // search homonym with compound flag
        while (rv && !hu_mov_rule &&
               ((needaffix && TESTAFF(rv->astr, needaffix, rv->alen)) ||
                !((compoundflag && !compound_words && !onlycpdrule &&
                   TESTAFF(rv->astr, compoundflag, rv->alen)) ||
                  (compoundbegin && !wordnum && !onlycpdrule &&
                   TESTAFF(rv->astr, compoundbegin, rv->alen)) ||
                  (compoundmiddle && wordnum && !compound_words && !onlycpdrule &&
                   TESTAFF(rv->astr, compoundmiddle, rv->alen)) ||
                  (!defcpdtable.empty() && onlycpdrule &&
                   ((!compound_words && !wordnum &&
                     defcpd_check(&compound_words, wnum, rv, rwords, 0)) ||
                    (compound_words &&
                     defcpd_check(&compound_words, wnum, rv, rwords, 0))))) ||
                (scpd != 0 && checkcpdtable[scpd - 1].cond != FLAG_NULL &&
                 !TESTAFF(rv->astr, checkcpdtable[scpd - 1].cond, rv->alen)))) {
            rv = rv->next_homonym;
        }

        if (rv) {
            // check non_compound flag in suffix and prefix
            if ((rv) && !hu_mov_rule &&
                ((pfx && pfx->getCont() &&
                  TESTAFF(pfx->getCont(), compoundforbidflag, pfx->getContLen())) ||
                 (sfx && sfx->getCont() &&
                  TESTAFF(sfx->getCont(), compoundforbidflag, sfx->getContLen())))) {
                rv = NULL;
            }

            // check compoundend flag in suffix and prefix
            if ((rv) && compoundend && !hu_mov_rule &&
                ((pfx && pfx->getCont() &&
                  TESTAFF(pfx->getCont(), compoundend, pfx->getContLen())) ||
                 (sfx && sfx->getCont() &&
                  TESTAFF(sfx->getCont(), compoundend, sfx->getContLen())))) {
                rv = NULL;
            }

            // check compoundmiddle flag in suffix and prefix
            if ((rv) && (wordnum == 0) && compoundmiddle && !hu_mov_rule &&
                ((pfx && pfx->getCont() &&
                  TESTAFF(pfx->getCont(), compoundmiddle, pfx->getContLen())) ||
                 (sfx && sfx->getCont() &&
                  TESTAFF(sfx->getCont(), compoundmiddle, sfx->getContLen())))) {
                rv = NULL;
            }

            // check forbiddenwords
            if ((rv) && (rv->astr) &&
                (TESTAFF(rv->astr, forbiddenword, rv->alen) ||
                 TESTAFF(rv->astr, ONLYUPCASEFLAG, rv->alen))) {
                break;
            }

            // increment word number, if the second root has a compoundroot flag
            if ((rv) && (compoundroot) &&
                (TESTAFF(rv->astr, compoundroot, rv->alen))) {
                wordnum++;
            }

            // first word is acceptable in compound words?
            if (((rv) &&
                 (checked_prefix || (compound_words && compound_words[wnum]) ||
                  (compoundflag && TESTAFF(rv->astr, compoundflag, rv->alen)) ||
                  ((oldwordnum == 0) && compoundbegin &&
                   TESTAFF(rv->astr, compoundbegin, rv->alen)) ||
                  ((oldwordnum > 0) && compoundmiddle &&
                   TESTAFF(rv->astr, compoundmiddle, rv->alen))

                  // LANG_hu section: spec. Hungarian rule
                  || ((langnum == LANG_hu) && hu_mov_rule &&
                      (TESTAFF(rv->astr, 'F', rv->alen) ||
                       TESTAFF(rv->astr, 'G', rv->alen) ||
                       TESTAFF(rv->astr, 'H', rv->alen)))
                  // END of LANG_hu section
                  ) &&
                 (
                     // test CHECKCOMPOUNDPATTERN conditions
                     scpd == 0 || checkcpdtable[scpd - 1].cond == FLAG_NULL ||
                     TESTAFF(rv->astr, checkcpdtable[scpd - 1].cond, rv->alen)) &&
                 !((checkcompoundtriple && scpd == 0 &&
                    !compound_words &&  // test triple letters
                    (word[i - 1] == word[i]) &&
                    (((i > 1) && (word[i - 1] == word[i - 2])) ||
                     ((word[i - 1] == word[i + 1]))  // may be word[i+1] == '\0'
                     )) ||
                   (checkcompoundcase && scpd == 0 && !compound_words &&
                    cpdcase_check(word.c_str(), i)))) {
                rv_first = rv;
                st[i] = ch;
                break;
            }
        }
        i++;
    }
    i = soldi;
    st.assign(word);
}