onlyincompound,
                                           sptr->getContLen()))))) &&
           // needaffix on prefix or first suffix
           (cclass ||
           !(sptr->getCont() &&
              TESTAFF(sptr->getCont(), needaffix, sptr->getContLen())) ||
            (ppfx &&
            !((ep->getCont()) &&
               TESTAFF(ep->getCont(), needaffix, ep->getContLen()))))))
        rv = sptr->checkword(word, start, len, sfxopts, ppfx, cclass,
                             needflag, FLAG_NULL);
      while (rv) {
        if (ppfx) {
          if (ppfx->getMorph()) {
            result.append(ppfx->getMorph());
            result.push_back(MSEP_FLD);
          } else
            debugflag(result, ppfx->getFlag());
        }
        if (complexprefixes && HENTRY_DATA(rv))
          result.append(HENTRY_DATA2(rv));
        if (!HENTRY_FIND(rv, MORPH_STEM)) {
          result.push_back(MSEP_FLD);
          result.append(MORPH_STEM);
          result.append(HENTRY_WORD(rv));
        }

        if (!complexprefixes && HENTRY_DATA(rv)) {
          result.push_back(MSEP_FLD);
          result.append(HENTRY_DATA2(rv));
        }
        if (sptr->getMorph()) {
          result.push_back(MSEP_FLD);
          result.append(sptr->getMorph());
        } else
          debugflag(result, sptr->getFlag());
        result.push_back(MSEP_REC);
        rv = sptr->get_next_homonym(rv, sfxopts, ppfx, cclass, needflag);
      }
    }
    sptr = sptr->getNextEQ();
  }

  return result;
}

// the below code fragment can be found in:
// src/hunspell/affixmgr.cxx
struct hentry* AffixMgr::prefix_check(const std::string& word,
                                      int start,
                                      int len,
                                      char in_compound,
                                      const FLAG needflag) {
  struct hentry* rv = NULL;
  PfxEntry* ep = pStart[word[start]];

  while (ep) {
    if (isRevSubset(ep->getKey(), word.c_str() + start, len)) {
      // prefixes are not allowed in end of compounds
      if (((in_compound!= IN_CPD_END) ||  // &&!needflag
           // except when signed with compoundpermitflag flag
           (ep->getCont() && compoundpermitflag &&
            TESTAFF(ep->getCont(), compoundpermitflag, ep->getContLen()))) &&
          (!circumfix ||
           // no circumfix flag in prefix and suffix
           (!(ep->getCont()) ||
           !TESTAFF(ep->getCont(), circumfix, ep->getContLen())) ||
           // circumfix flag in prefix AND suffix
           (sfx && sfx->getCont() &&
            TESTAFF(sfx->getCont(), circumfix, sfx->getContLen()))) &&
          // fogemorpheme
          (in_compound ||
          !((ep->getCont() && (TESTAFF(ep->getCont(), onlyincompound,
                                        ep->getContLen()))))) &&
          // needaffix on prefix or first suffix
          (needflag ||
          !(ep->getCont() &&
             TESTAFF(ep->getCont(), needaffix, ep->getContLen())))) {
        rv = ep->checkword(word, start, len, 0, NULL, needflag, FLAG_NULL,
                           in_compound);
        if (rv) {
          pfx = ep;  // BUG: pfx not stateless
          pfxappnd = ep->getKey();  // BUG: pfxappnd not stateless
          return rv;
        }
      }
    }
    ep = ep->getNextEQ();
  }

  return NULL;
}

// the below code fragment can be found in:
// src/hunspell/affixmgr.cxx
std::string AffixMgr::prefix_check_morph(const std::string& word,
                                         int start,
                                         int len,
                                         char in_compound,
                                         const FLAG needflag) {
  std::string result;

  struct hentry* rv = NULL;

  PfxEntry* ep = pStart[word[start]];

  while (ep) {
    if (isRevSubset(ep->getKey(), word.c_str() + start, len)) {
      // prefixes are not allowed in end of compounds
      if (((in_compound!= IN_CPD_END) ||  // &&!needflag
           // except when signed with compoundpermitflag flag
           (ep->getCont() && compoundpermitflag &&
            TESTAFF(ep->getCont(), compoundpermitflag, ep->getContLen()))) &&
          (!circumfix ||
           // no circumfix flag in prefix and suffix
           (!(ep->getCont()) ||
           !TESTAFF(ep->getCont(), circumfix, ep->getContLen())) ||
           // circumfix flag in prefix AND suffix
           (sfx && sfx->getCont() &&
            TESTAFF(sfx->getCont(), circumfix, sfx->getContLen()))) &&
          // fogemorpheme
          (in_compound ||
          !((ep->getCont() && (TESTAFF(ep->getCont(), onlyincompound,
                                        ep->getContLen()))))) &&
          // needaffix on prefix or first suffix
          (needflag ||
          !(ep->getCont() &&
             TESTAFF(ep->getCont(), needaffix, ep->getContLen())))) {
        rv = ep->checkword(word, start, len, 0, NULL, needflag, FLAG_NULL,
                           in_compound);
        while (rv) {
          if (ep->getMorph()) {
            result.append(ep->getMorph());
            result.push_back(MSEP_FLD);
          } else
            debugflag(result, ep->getFlag());
          if (complexprefixes && HENTRY_DATA(rv))
            result.append(HENTRY_DATA2(rv));
          if (!HENTRY_FIND(rv, MORPH_STEM)) {
            result.push_back(MSEP_FLD);
            result.append(MORPH_STEM);
            result.append(HENTRY_WORD(rv));
          }

          if (!complexprefixes && HENTRY_DATA(rv)) {
            result.push_back(MSEP_FLD);
            result.append(HENTRY_DATA2(rv));
          }
          result.push_back(MSEP_REC);
          rv = ep->get_next_homonym(rv, 0, NULL, needflag, FLAG_NULL);
        }
      }
    }
    ep = ep->getNextEQ();
  }

  return result;
}

// the below code fragment can be found in:
// src/hunspell/affixmgr.cxx
struct hentry* AffixMgr::affix_check(const std::string& word,
                                     int start,
                                     int len,
                                     const FLAG needflag,
                                     char in_compound) {
  struct hentry* rv = NULL;

  // check prefix
  rv = prefix_check(word, start, len, in_compound, needflag);
  if (rv)
    return rv;

  // check suffix
  rv = suffix_check(word, start, len, 0, NULL, needflag, FLAG_NULL,
                    in_compound);
  if (rv)
    return rv;

  // check prefix + suffix
  rv = suffix_check(word, start, len, 0, NULL, needflag, FLAG_NULL,
                    in_compound);
  if (rv)
    return rv;

  return NULL;
}

// the below code fragment can be found in:
// src/hunspell/affixmgr.cxx
std::string AffixMgr::affix_check_morph(const std::string& word,
                                        int start,
                                        int len,
                                        const FLAG needflag,
                                        char in_compound) {
  std::string result;

  struct hentry* rv = NULL;

  // check prefix
  rv = prefix_check(word, start, len, in_compound, needflag);
  if (rv) {
    if (pfx->getMorph()) {
      result.append(pfx->getMorph());
      result.push_back(MSEP_FLD);
    } else
      debugflag(result, pfx->getFlag());
    if (complexprefixes && HENTRY_DATA(rv))
      result.append(HENTRY_DATA2(rv));
    if (!HENTRY_FIND(rv, MORPH_STEM)) {
      result.push_back(MSEP_FLD);
      result.append(MORPH_STEM);
      result.append(HENTRY_WORD(rv));
    }

    if (!complexprefixes && HENTRY_DATA(rv)) {
      result.push_back(MSEP_FLD);
      result.append(HENTRY_DATA2(rv));
    }
    result.push_back(MSEP_REC);
    return result;
  }

  // check suffix
  rv = suffix_check(word, start, len, 0, NULL, needflag, FLAG_NULL,
                    in_compound);
  if (rv) {
    if (sfx->getMorph()) {
      result.append(sfx->getMorph());
      result.push_back(MSEP_FLD);
    } else
      debugflag(result, sfx->getFlag());
    if (complexprefixes && HENTRY_DATA(rv))
      result.append(HENTRY_DATA2(rv));
    if (!HENTRY_FIND(rv, MORPH_STEM)) {
      result.push_back(MSEP_FLD);
      result.append(MORPH_STEM);
      result.append(HENTRY_WORD(rv));
    }

    if (!complexprefixes && HENTRY_DATA(rv)) {
      result.push_back(MSEP_FLD);
      result.append(HENTRY_DATA2(rv));
    }
    result.push_back(MSEP_REC);
    return result;
  }

  // check prefix + suffix
  rv = suffix_check(word, start, len, 0, NULL, needflag, FLAG_NULL,
                    in_compound);
  if (rv) {
    if (sfx->getMorph()) {
      result.append(sfx->getMorph());
      result.push_back(MSEP_FLD);
    } else
      debugflag(result, sfx->getFlag());
    if (complexprefixes && HENTRY_DATA(rv))
      result.append(HENTRY_DATA2(rv));
    if (!HENTRY_FIND(rv, MORPH_STEM)) {
      result.push_back(MSEP_FLD);
      result.append(MORPH_STEM);
      result.append(HENTRY_WORD(rv));
    }

    if (!complexprefixes && HENTRY_DATA(rv)) {
      result.push_back(MSEP_FLD);
      result.append(HENTRY_DATA2(rv));
    }
    result.push_back(MSEP_REC);
    return result;
  }

  return std::string();
}

// the below code fragment can be found in:
// src/hunspell/affixmgr.cxx
struct hentry* AffixMgr::affix_check(const std::string& word,
                                     int start,
                                     int len,
                                     const FLAG needflag,
                                     char in_compound,
                                     int sfxopts) {
  struct hentry* rv = NULL;

  // check prefix
  rv = prefix_check(word, start, len, in_compound, needflag);
  if (rv)
    return rv;

  // check suffix
  rv = suffix_check(word, start, len, sfxopts, NULL, needflag, FLAG_NULL,
                    in_compound);
  if (rv)
    return rv;

  // check prefix + suffix
  rv = suffix_check(word, start, len, sfxopts, NULL, needflag, FLAG_NULL,
                    in_compound);
  if (rv)
    return rv;

  return NULL;
}

// the below code fragment can be found in:
// src/hunspell/affixmgr.cxx
std::string AffixMgr::affix_check_morph(const std::string& word,
                                        int start,
                                        int len,
                                        const FLAG needflag,
                                        char in_compound,
                                        int sfxopts) {
  std::string result;

  struct hentry* rv = NULL;

  // check prefix
  rv = prefix_check(word, start, len, in_compound, needflag);
  if (rv) {
    if (pfx->getMorph()) {
      result.append(pfx->getMorph());
      result.push_back(MSEP_FLD);
    } else
      debugflag(result, pfx->getFlag());
    if (complexprefixes && HENTRY_DATA(rv))
      result.append(HENTRY_DATA2(rv));
    if (!HENTRY_FIND(rv, MORPH_STEM)) {
      result.push_back(MSEP_FLD);
      result.append(MORPH_STEM);
      result.append(HENTRY_WORD(rv));
    }

    if (!complexprefixes && HENTRY_DATA(rv)) {
      result.push_back(MSEP_FLD);
      result.append(HENTRY_DATA2(rv));
    }
    result.push_back(MSEP_REC);
    return result;
  }

  // check suffix
  rv = suffix_check(word, start, len, sfxopts, NULL, needflag, FLAG_NULL,
                    in_compound);
  if (rv) {
    if (sfx->getMorph()) {
      result.append(sfx->getMorph());
      result.push_back(MSEP_FLD);
    } else
      debugflag(result, sfx->getFlag());
    if (complexprefixes && HENTRY_DATA(rv))
      result.append(HENTRY_DATA2(rv));
    if (!HENTRY_FIND(rv, MORPH_STEM)) {
      result.push_back(MSEP_FLD);
      result.append(MORPH_STEM);
      result.append(HENTRY_WORD(rv));
    }

    if (!complexprefixes && HENTRY_DATA(rv)) {
      result.push_back(MSEP_FLD);
      result.append(HENTRY_DATA2(rv));
    }
    result.push_back(MSEP_REC);
    return result;
  }

  // check prefix + suffix
  rv = suffix_check(word, start, len, sfxopts, NULL, needflag, FLAG_NULL,
                    in_compound);
  if (rv) {
    if (sfx->getMorph()) {
      result.append(sfx->getMorph());
      result.push_back(MSEP_FLD);
    } else
      debugflag(result, sfx->getFlag());
    if (complexprefixes && HENTRY_DATA(rv))
      result.append(HENTRY_DATA2(rv));
    if (!HENTRY_FIND(rv, MORPH_STEM)) {
      result.push_back(MSEP_FLD);
      result.append(MORPH_STEM);
      result.append(HENTRY_WORD(rv));
    }

    if