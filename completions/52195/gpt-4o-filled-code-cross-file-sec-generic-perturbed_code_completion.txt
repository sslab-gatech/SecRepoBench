// Handle simplified triple letter checking.
          if (checkcompoundtriple && !compound_words && scpd == 0 &&
              (word[i - 1] == word[i]) &&
              (((i > 1) && (word[i - 1] == word[i - 2])) ||
               ((word[i - 1] == word[i + 1])))) {
            if (!checkedstriple) {
              striple = 1;
              checkedstriple = 1;
              i--;
              continue;
            }
          }

          // Perform a lookup for the current substring starting from the adjusted index.
          rv = lookup(st.c_str() + i, st.size() - i);

          // Iterate over homonyms of the current entry to check for matching compound
          // conditions, ensuring the entry has the correct affix flags for compound formation
          // as per predefined rules or tables.
          while (rv) {
            if ((compoundflag && TESTAFF(rv->astr, compoundflag, rv->alen)) ||
                (compoundend && TESTAFF(rv->astr, compoundend, rv->alen))) {
              if (((cpdwordmax == -1) || (wordnum + 1 < cpdwordmax)) ||
                  ((cpdmaxsyllable != 0) &&
                   (numsyllable + get_syllable(std::string(HENTRY_WORD(rv), rv->blen)) <=
                    cpdmaxsyllable))) {
                if (checkcpdtable.empty() || scpd != 0 ||
                    !cpdpat_check(word.c_str(), i, rv_first, rv, 0)) {
                  if (!checkcompounddup || (rv != rv_first)) {
                    if (scpd == 0 || checkcpdtable[scpd - 1].cond2 == FLAG_NULL ||
                        TESTAFF(rv->astr, checkcpdtable[scpd - 1].cond2, rv->alen)) {
                      if ((checkcompoundrep && cpdrep_check(word, len)) ||
                          cpdwordpair_check(word, len)) {
                        return NULL;
                      }
                      return rv_first;
                    }
                  }
                }
              }
            }
            rv = rv->next_homonym;
          }