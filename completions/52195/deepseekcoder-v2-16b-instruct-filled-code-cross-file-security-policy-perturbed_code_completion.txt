// Handle simplified triple letter checking.
// If a simplified triple pattern is detected, adjust the index to re-evaluate
// a specific character sequence for compound word formation.
// Perform a lookup for the current substring starting from the adjusted index.
// Iterate over homonyms of the current entry to check for matching compound
// conditions, ensuring the entry has the correct affix flags for compound formation
// as per predefined rules or tables.

// Check for simplified triple letter pattern
if (checkcompoundtriple && scpd == 0 && !compound_words &&  // test triple letters
    (word[i - 1] == word[i]) &&
    (((i > 1) && (word[i - 1] == word[i - 2])) ||
     ((word[i - 1] == word[i + 1]))  // may be word[i+1] == '\0'
    )) {
  // Adjust the index to re-evaluate the character sequence
  i -= 2;  // Adjusting the index to check the previous character again
  if (i < 0) i = 0;  // Ensure the index does not go out of bounds

  // Perform a lookup for the current substring starting from the adjusted index
  rv = lookup(st.c_str() + i, st.size() - i);  // perhaps without prefix

  // Iterate over homonyms of the current entry to check for matching compound
  // conditions
  while ((rv) && !hu_mov_rule &&
         ((needaffix && TESTAFF(rv->astr, needaffix, rv->alen)) ||
          !((compoundflag && !compound_words && !onlycpdrule &&
             TESTAFF(rv->astr, compoundflag, rv->alen)) ||
            (compoundbegin && !wordnum && !onlycpdrule &&
             TESTAFF(rv->astr, compoundbegin, rv->alen)) ||
            (compoundmiddle && wordnum && !compound_words && !onlycpdrule &&
             TESTAFF(rv->astr, compoundmiddle, rv->alen)) ||
            (!defcpdtable.empty() && onlycpdrule &&
             ((!compound_words && !wordnum &&
               defcpd_check(&compound_words, wnum, rv, rwords, 0)) ||
              (compound_words &&
               defcpd_check(&compound_words, wnum, rv, rwords, 0))))) ||
          (scpd != 0 && checkcpdtable[scpd - 1].cond != FLAG_NULL &&
           !TESTAFF(rv->astr, checkcpdtable[scpd - 1].cond, rv->alen)))) {
    rv = rv->next_homonym;
  }

  if (rv)
    affixed = 0;

  if (!rv) {
    if (onlycpdrule)
      break;
    if (compoundflag &&
        !(rv = prefix_check(st, 0, i,
                            hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN,
                            compoundflag))) {
      if (((rv = suffix_check(
                st, 0, i, 0, NULL, FLAG_NULL, compoundflag,
                hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN)) ||
           (compoundmoresuffixes &&
            (rv = suffix_check_twosfx(st, 0, i, 0, NULL, compoundflag)))) &&
          !hu_mov_rule && sfx->getCont() &&
          ((compoundforbidflag &&
            TESTAFF(sfx->getCont(), compoundforbidflag,
                    sfx->getContLen())) ||
           (compoundend &&
            TESTAFF(sfx->getCont(), compoundend, sfx->getContLen())))) {
        rv = NULL;
      }
    }

    if (rv ||
        (((wordnum == 0) && compoundbegin &&
          ((rv = suffix_check(
                st, 0, i, 0, NULL, FLAG_NULL, compoundbegin,
                hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN)) ||
           (compoundmoresuffixes &&
            (rv = suffix_check_twosfx(
                 st, 0, i, 0, NULL,
                 compoundbegin))) ||  // twofold suffixes + compound
           (rv = prefix_check(st, 0, i,
                              hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN,
                              compoundbegin)))) ||
         ((wordnum > 0) && compoundmiddle &&
          ((rv = suffix_check(
                st, 0, i, 0, NULL, FLAG_NULL, compoundmiddle,
                hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN)) ||
           (compoundmoresuffixes &&
            (rv = suffix_check_twosfx(
                 st, 0, i, 0, NULL,
                 compoundmiddle))) ||  // twofold suffixes + compound
           (rv = prefix_check(st, 0, i,
                              hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN,
                              compoundmiddle))))))
      checked_prefix = 1;
    // else check forbiddenwords and needaffix
  } else if (rv->astr && (TESTAFF(rv->astr, forbiddenword, rv->alen) ||
                          TESTAFF(rv->astr, needaffix, rv->alen) ||
                          TESTAFF(rv->astr, ONLYUPCASEFLAG, rv->alen) ||
                          (is_sug && nosuggest &&
                           TESTAFF(rv->astr, nosuggest, rv->alen)))) {
    st[i] = ch;
    // continue;
    break;
  }

  // check non_compound flag in suffix and prefix
  if ((rv) && !hu_mov_rule &&
      ((pfx && pfx->getCont() &&
        TESTAFF(pfx->getCont(), compoundforbidflag, pfx->getContLen())) ||
       (sfx && sfx->getCont() &&
        TESTAFF(sfx->getCont(), compoundforbidflag,
                sfx->getContLen())))) {
    rv = NULL;
  }

  // check compoundend flag in suffix and prefix
  if ((rv) && !checked_prefix && compoundend && !hu_mov_rule &&
      ((pfx && pfx->getCont() &&
        TESTAFF(pfx->getCont(), compoundend, pfx->getContLen())) ||
       (sfx && sfx->getCont() &&
        TESTAFF(sfx->getCont(), compoundend, sfx->getContLen())))) {
    rv = NULL;
  }

  // check compoundmiddle flag in suffix and prefix
  if ((rv) && !checked_prefix && (wordnum == 0) && compoundmiddle &&
      !hu_mov_rule &&
      ((pfx && pfx->getCont() &&
        TESTAFF(pfx->getCont(), compoundmiddle, pfx->getContLen())) ||
       (sfx && sfx->getCont() &&
        TESTAFF(sfx->getCont(), compoundmiddle, sfx->getContLen())))) {
    rv = NULL;
  }

  // check forbiddenwords
  if ((rv) && (rv->astr) &&
      (TESTAFF(rv->astr, forbiddenword, rv->alen) ||
       TESTAFF(rv->astr, ONLYUPCASEFLAG, rv->alen) ||
       (is_sug && nosuggest && TESTAFF(rv->astr, nosuggest, rv->alen)))) {
    return NULL;
  }

  // increment word number, if the second root has a compoundroot flag
  if ((rv) && compoundroot &&
      (TESTAFF(rv->astr, compoundroot, rv->alen))) {
    wordnum++;
  }

  // first word is acceptable in compound words?
  if (((rv) &&
       (checked_prefix || (compound_words && compound_words[wnum]) ||
        (compoundflag && TESTAFF(rv->astr, compoundflag, rv->alen)) ||
        ((oldwordnum == 0) && compoundbegin &&
         TESTAFF(rv->astr, compoundbegin, rv->alen)) ||
        ((oldwordnum > 0) && compoundmiddle &&
         TESTAFF(rv->astr, compoundmiddle, rv->alen))

        // LANG_hu section: spec. Hungarian rule
        || ((langnum == LANG_hu) && hu_mov_rule &&
            (TESTAFF(
                 rv->astr, 'F',
                 rv->alen) ||  // XXX hardwired Hungarian dictionary codes
             TESTAFF(rv->astr, 'G', rv->alen) ||
             TESTAFF(rv->astr, 'H', rv->alen)))
        // END of LANG_hu section
        ) &&
       (
           // test CHECKCOMPOUNDPATTERN conditions
           scpd == 0 || checkcpdtable[scpd - 1].cond == FLAG_NULL ||
           TESTAFF(rv->astr, checkcpdtable[scpd - 1].cond, rv->alen)) &&
       !((checkcompoundtriple && scpd == 0 &&
          !compound_words &&  // test triple letters
          (word[i - 1] == word[i]) &&
          (((i > 1) && (word[i - 1] == word[i - 2])) ||
           ((word[i - 1] == word[i + 1]))  // may be word[i+1] == '\0'
           )) ||
         (checkcompoundcase && scpd == 0 && !compound_words &&
          cpdcase_check(word.c_str(), i))))
      // LANG_hu section: spec. Hungarian rule
      || ((!rv) && (langnum == LANG_hu) && hu_mov_rule &&
          (rv = affix_check(st, 0, i)) &&
          (sfx && sfx->getCont() &&
           (  // XXX hardwired Hungarian dic. codes
               TESTAFF(sfx->getCont(), (unsigned short)'x',
                       sfx->getContLen()) ||
               TESTAFF(
                   sfx->getCont(), (unsigned short)'%',
                   sfx->getContLen()))))) {  // first word is ok condition

    // LANG_hu section: spec. Hungarian rule
    if (langnum == LANG_hu) {
      // calculate syllable number of the word
      numsyllable += get_syllable(st.substr(0, i));
      // + 1 word, if syllable number of the prefix > 1 (hungarian
      // convention)
      if (pfx && (get_syllable(pfx->getKey()) > 1))
        wordnum++;
    }
    // END of LANG_hu section

    // NEXT WORD(S)
    rv_first = rv;
    st[i] = ch;

    do {  
    // Handle simplified triple letter checking.
    // If a simplified triple pattern is detected, adjust the index to re-evaluate
    // a specific character sequence for compound word formation.
    // Perform a lookup for the current substring starting from the adjusted index.
    // Iterate over homonyms of the current entry to check for matching compound
    // conditions, ensuring the entry has the correct affix flags for compound formation
    // as per predefined rules or tables.

      // Check for simplified triple letter pattern
      if (checkcompoundtriple && scpd == 0 && !compound_words &&  // test triple letters
          (word[i - 1] == word[i]) &&
          (((i > 1) && (word[i - 1] == word[i - 2])) ||
           ((word[i - 1] == word[i + 1]))  // may be word[i+1] == '\0'
          )) {
        // Adjust the index to re-evaluate the character sequence
        i -= 2;  // Adjusting the index to check the previous character again
        if (i < 0) i = 0;  // Ensure the index does not go out of bounds

        // Perform a lookup for the current substring starting from the adjusted index
        rv = lookup(st.c_str() + i, st.size() - i);  // perhaps without prefix

        // Iterate over homonyms of the current entry to check for matching compound
        // conditions
        while ((rv) && !hu_mov_rule &&
               ((needaffix && TESTAFF(rv->astr, needaffix, rv->alen)) ||
                !((compoundflag && !compound_words && !onlycpdrule &&
                   TESTAFF(rv->astr, compoundflag, rv->alen)) ||
                  (compoundbegin && !wordnum && !onlycpdrule &&
                   TESTAFF(rv->astr, compoundbegin, rv->alen)) ||
                  (compoundmiddle && wordnum && !compound_words && !onlycpdrule &&