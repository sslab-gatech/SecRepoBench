if (checkcompoundtriple && scpd == 0 && !compound_words &&
              (word[i - 1] == word[i]) &&
              (((i > 1) && (word[i - 1] == word[i - 2])) ||
               ((word[i - 1] == word[i + 1])))) {
            // Adjust index to re-evaluate the character sequence
            striple = 1;
            checkedstriple = 1;
            i--;
            continue;
          }

          // Perform a lookup for the current substring starting from the adjusted index
          rv = lookup(st.c_str(), i);

          // Iterate over homonyms of the current entry
          while (rv) {
            // Check for matching compound conditions
            if ((compoundflag && TESTAFF(rv->astr, compoundflag, rv->alen)) ||
                (compoundend && TESTAFF(rv->astr, compoundend, rv->alen))) {
              // Ensure the entry has the correct affix flags for compound formation
              if (((cpdwordmax == -1) || (wordnum + 1 < cpdwordmax)) ||
                  ((cpdmaxsyllable != 0) &&
                   (numsyllable + get_syllable(std::string(HENTRY_WORD(rv), rv->blen)) <=
                    cpdmaxsyllable))) {
                return rv_first;
              }
            }
            rv = rv->next_homonym;
          }