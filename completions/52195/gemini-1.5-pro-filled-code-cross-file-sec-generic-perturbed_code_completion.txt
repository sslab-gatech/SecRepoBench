if (checkcompoundtriple && scpd == 0 && !compound_words && i > 0 && i < st.size() -1) { // test triple letters, simplified version
              if (st[i - 1] == st[i] && (st[i - 1] == st[i + 1])) {
                striple = 1;
              } else if (st[i-1] == st[i]) {
                i++;
                checkedstriple = 1;
                striple = 1;
              }
            }

            if (rv && !striple) {
              struct hentry *rv_tmp = rv;
              while (rv_tmp) {
                if (!((compoundflag && !compound_words && !onlycpdrule &&
                       TESTAFF(rv_tmp->astr, compoundflag, rv_tmp->alen)) ||
                      (compoundbegin && !wordnum && !onlycpdrule &&
                       TESTAFF(rv_tmp->astr, compoundbegin, rv_tmp->alen)) ||
                      (compoundmiddle && wordnum && !compound_words && !onlycpdrule &&
                       TESTAFF(rv_tmp->astr, compoundmiddle, rv_tmp->alen)) ||
                      (!defcpdtable.empty() && onlycpdrule &&
                       ((!compound_words && !wordnum &&
                         defcpd_check(&compound_words, wnum, rv_tmp, rwords, 0)) ||
                        (compound_words &&
                         defcpd_check(&compound_words, wnum, rv_tmp, rwords, 0))))) ||
                    (scpd != 0 && checkcpdtable[scpd - 1].cond != FLAG_NULL &&
                     !TESTAFF(rv_tmp->astr, checkcpdtable[scpd - 1].cond, rv_tmp->alen)))
                  break;
                rv_tmp = rv_tmp->next_homonym;
              }
              if (!rv_tmp) continue;
            }