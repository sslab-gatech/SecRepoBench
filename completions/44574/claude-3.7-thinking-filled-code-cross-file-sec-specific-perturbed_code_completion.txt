else if (!strncmp("null", str_val, str_len)) {
    primitive_value = plist_new_null();
} else {
    // Try to parse as a number
    // Check if it's safe to allocate memory for this token
    if (str_len > 1024) {  // Set a reasonable limit for primitive value length
        PLIST_JSON_ERR("%s: primitive value too long\n", __func__);
        return NULL;
    }
    
    // Safely create a null-terminated copy of the token
    char* token_copy = malloc(str_len + 1);
    if (!token_copy) {
        PLIST_JSON_ERR("%s: Out of memory\n", __func__);
        return NULL;
    }
    
    // Copy the token string and explicitly null-terminate it
    memcpy(token_copy, str_val, str_len);
    token_copy[str_len] = '\0';
    
    char* endptr = NULL;
    // First try parsing as an integer
    errno = 0;  // Reset errno before calling strtoll
    int64_t int_val = strtoll(token_copy, &endptr, 10);
    
    if (endptr == token_copy + str_len && errno == 0) {
        // Successful integer parse with no overflow
        if (int_val < 0) {
            primitive_value = plist_new_int(int_val);
        } else {
            primitive_value = plist_new_uint(int_val);
        }
    } else {
        // Try parsing as a float
        errno = 0;  // Reset errno before calling strtod
        double float_val = strtod(token_copy, &endptr);
        
        if (endptr == token_copy + str_len && errno == 0) {
            // Successful float parse with no overflow/underflow
            primitive_value = plist_new_real(float_val);
        } else {
            PLIST_JSON_ERR("%s: failed to parse primitive value\n", __func__);
        }
    }
    
    free(token_copy);
}