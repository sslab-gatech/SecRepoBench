else if (!strncmp("null", str_val, str_len)) {
    primitive_value = plist_new_null();
} else {
    // Assume it's a number - create a null-terminated copy for parsing
    char* num_str = malloc(str_len + 1);
    if (!num_str) {
        PLIST_JSON_ERR("%s: Out of memory\n", __func__);
        return NULL;
    }
    strncpy(num_str, str_val, str_len);
    num_str[str_len] = '\0';
    
    // Check if it's an integer by checking for decimal point or 'e'/'E'
    int has_decimal_or_exp = 0;
    for (size_t i = 0; i < str_len; i++) {
        if (str_val[i] == '.' || str_val[i] == 'e' || str_val[i] == 'E') {
            has_decimal_or_exp = 1;
            break;
        }
    }
    
    if (!has_decimal_or_exp) {
        // Try parsing as integer
        char* end_ptr = NULL;
        errno = 0;
        long long int_val = strtoll(num_str, &end_ptr, 10);
        if (end_ptr == num_str + str_len && errno == 0) {
            // Successfully parsed as integer
            if (int_val < 0) {
                primitive_value = plist_new_int(int_val);
            } else {
                primitive_value = plist_new_uint((uint64_t)int_val);
            }
        } else {
            PLIST_JSON_ERR("%s: Invalid integer value '%s'\n", __func__, num_str);
        }
    } else {
        // Has decimal point or exponent, parse as double
        char* end_ptr = NULL;
        errno = 0;
        double real_val = strtod(num_str, &end_ptr);
        if (end_ptr == num_str + str_len && errno == 0) {
            primitive_value = plist_new_real(real_val);
        } else {
            PLIST_JSON_ERR("%s: Invalid real value '%s'\n", __func__, num_str);
        }
    }
    
    free(num_str);
}