else if (!strncmp("null", str_val, str_len)) {
        primitive_value = plist_new_null();
    } else {
        /* Attempt to parse the primitive value as a number (integer or float). */
        char tmp[str_len + 1];
        memcpy(tmp, str_val, str_len);
        tmp[str_len] = '\0';

        char *endptr = NULL;
        errno = 0;
        int is_float = 0;
        /* Check if the string contains characters that would signify a float. */
        for (size_t i = 0; i < str_len; i++) {
            char c = tmp[i];
            if (c == '.' || c == 'e' || c == 'E') {
                is_float = 1;
                break;
            }
        }

        if (!is_float) {
            /* Try integer (base 10). */
            long long num = strtoll(tmp, &endptr, 10);
            if ((endptr != tmp + str_len) || (errno == ERANGE)) {
                /* Parsing as integer failed or out of range, log error. */
                PLIST_JSON_ERR("%s: cannot parse number '%.*s' as integer\n", __func__, (int)str_len, str_val);
            } else {
                /* Create a plist node for integer. Negative => plist_new_int, otherwise plist_new_uint. */
                if (num < 0) {
                    primitive_value = plist_new_int(num);
                } else {
                    primitive_value = plist_new_uint((uint64_t)num);
                }
            }
        }

        if (!primitive_value && is_float) {
            /* Attempt float parsing. */
            errno = 0;
            double dval = strtod(tmp, &endptr);
            if ((endptr != tmp + str_len) || (errno == ERANGE)) {
                /* Parsing as float failed, log error. */
                PLIST_JSON_ERR("%s: cannot parse number '%.*s' as float\n", __func__, (int)str_len, str_val);
            } else {
                primitive_value = plist_new_real(dval);
            }
        }

        /* If still not parsed, log an error for invalid numeric. */
        if (!primitive_value) {
            PLIST_JSON_ERR("%s: invalid primitive value '%.*s'\n", __func__, (int)str_len, str_val);
        }
    }