} else if (!strncmp("null", str_val, str_len)) {
    /* Create a NULL node */
    primitive_value = plist_new_null();
} else {
    /* Attempt to parse the primitive as a number */
    char numbuf[str_len + 1];
    memcpy(numbuf, str_val, str_len);
    numbuf[str_len] = '\0';

    errno = 0;
    char *endptr = NULL;
    double dval = strtod(numbuf, &endptr);

    /* Check for parsing errors */
    if ((endptr == numbuf) || (errno == ERANGE)) {
        PLIST_JSON_ERR("%s: invalid or out-of-range number '%s'\n", __func__, numbuf);
    } else if (*endptr != '\0') {
        PLIST_JSON_ERR("%s: trailing characters after number '%s'\n", __func__, numbuf);
    } else {
        /* Successfully parsed the number, decide if it's integer or real */
        if (strchr(numbuf, '.') || strchr(numbuf, 'e') || strchr(numbuf, 'E')) {
            primitive_value = plist_new_real(dval);
        } else {
            /* Check if the double value fits exactly into a 64-bit integer */
            double floor_val = floor(dval);
            if ((dval < LLONG_MIN) || (dval > LLONG_MAX) || (floor_val != dval)) {
                /* Treat as double if it can't be an integer */
                primitive_value = plist_new_real(dval);
            } else {
                primitive_value = plist_new_int((int64_t)dval);
            }
        }
    }
}