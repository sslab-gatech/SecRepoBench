else if (!strncmp("null", str_val, str_len)) {
    primitive_value = plist_new_null();
} else {
    // Must be a number
    // Create a null-terminated string for parsing
    char* num_str = malloc(str_len + 1);
    if (!num_str) {
        PLIST_JSON_ERR("%s: out of memory\n", __func__);
        return NULL;
    }
    memcpy(num_str, str_val, str_len);
    num_str[str_len] = '\0';
    
    // Check if it contains a decimal point or 'e'/'E' for scientific notation
    bool is_float = false;
    for (size_t i = 0; i < str_len; i++) {
        if (num_str[i] == '.' || num_str[i] == 'e' || num_str[i] == 'E') {
            is_float = true;
            break;
        }
    }
    
    char* endptr = NULL;
    errno = 0;
    
    if (is_float) {
        // Parse as float
        double real_val = strtod(num_str, &endptr);
        if (endptr == num_str + str_len && errno == 0) {
            primitive_value = plist_new_real(real_val);
        } else {
            PLIST_JSON_ERR("%s: error parsing float value '%s'\n", __func__, num_str);
            free(num_str);
            return NULL;
        }
    } else {
        // Check if it's a negative number
        bool is_negative = (num_str[0] == '-');
        
        if (is_negative) {
            int64_t int_val = strtoll(num_str, &endptr, 10);
            if (endptr == num_str + str_len && errno == 0) {
                primitive_value = plist_new_int(int_val);
            } else {
                PLIST_JSON_ERR("%s: error parsing integer value '%s'\n", __func__, num_str);
                free(num_str);
                return NULL;
            }
        } else {
            uint64_t uint_val = strtoull(num_str, &endptr, 10);
            if (endptr == num_str + str_len && errno == 0) {
                primitive_value = plist_new_uint(uint_val);
            } else {
                PLIST_JSON_ERR("%s: error parsing unsigned integer value '%s'\n", __func__, num_str);
                free(num_str);
                return NULL;
            }
        }
    }
    free(num_str);
}