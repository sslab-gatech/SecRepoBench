Below is the content of a C/C++ function where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
static plist_t parse_primitive(const char* js, jsmntok_info_t* ti, int* index)
{
    if (ti->tokens[*index].type != JSMN_PRIMITIVE) {
        PLIST_JSON_ERR("%s: token type != JSMN_PRIMITIVE\n", __func__);
        return NULL;
    }
    plist_t primitive_value = NULL;
    const char* str_val = js + ti->tokens[*index].start;
    const char* str_end = js + ti->tokens[*index].end;
    size_t str_len = ti->tokens[*index].end - ti->tokens[*index].start;
    if (!strncmp("false", str_val, str_len)) {
        primitive_value = plist_new_bool(0);
    } else if (!strncmp("true", str_val, str_len)) {
        primitive_value = plist_new_bool(1);
    } else 
    // Check if the primitive value is "null" and create a corresponding plist node for it.
    // If the value represents a number, parse it as an integer or floating point number.
    // Handle potential representations of negative numbers and scientific notation.
    // If the value is an integer, create a plist node for it.
    // If the value is a floating-point number, parse the fractional and exponential parts
    // and create a plist node for the real number.
    // Log an error if any parsing errors occur or if the value cannot be represented.
    // <MASK>
    (*index)++;
    return primitive_value;
}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/jplist.c
static plist_t parse_string(const char* js, jsmntok_info_t* ti, int* index)
{
    if (ti->tokens[*index].type != JSMN_STRING) {
        PLIST_JSON_ERR("%s: token type != JSMN_STRING\n", __func__);
        return NULL;
    }

    size_t str_len = 0; ;
    char* strval = unescape_string(js + ti->tokens[*index].start, ti->tokens[*index].end - ti->tokens[*index].start, &str_len);
    if (!strval) {
        return NULL;
    }
    plist_t node;

    plist_data_t data = plist_new_plist_data();
    data->type = PLIST_STRING;
    data->strval = strval;
    data->length = str_len;
    node = plist_new_node(data);

    (*index)++;
    return node;
}

// the below code fragment can be found in:
// src/jplist.c
static plist_t parse_object(const char* js, jsmntok_info_t* ti, int* index)
{
    if (ti->tokens[*index].type != JSMN_OBJECT) {
        PLIST_JSON_ERR("%s: token type != JSMN_OBJECT\n", __func__);
        return NULL;
    }
    int num_tokens = ti->tokens[*index].size;
    int num;
    int j = (*index)+1;
    if (num_tokens % 2 != 0) {
        PLIST_JSON_ERR("%s: number of children must be even\n", __func__);
        return NULL;
    }
    plist_t obj = plist_new_dict();
    for (num = 0; num < num_tokens; num++) {
        if (j+1 >= ti->count) {
            PLIST_JSON_ERR("%s: token index out of valid range\n", __func__);
            plist_free(obj);
            return NULL;
        }
        if (ti->tokens[j].type == JSMN_STRING) {
            char* key = unescape_string(js + ti->tokens[j].start, ti->tokens[j].end - ti->tokens[j].start, NULL);
            if (!key) {
                plist_free(obj);
                return NULL;
            }
            plist_t val = NULL;
            j++;
            num++;
            switch (ti->tokens[j].type) {
                case JSMN_OBJECT:
                    val = parse_object(js, ti, &j);
                    break;
                case JSMN_ARRAY:
                    val = parse_array(js, ti, &j);
                    break;
                case JSMN_STRING:
                    val = parse_string(js, ti, &j);
                    break;
                case JSMN_PRIMITIVE:
                    val = parse_primitive(js, ti, &j);
                    break;
                default:
                    break;
            }
            if (val) {
                plist_dict_set_item(obj, key, val);
            } else {
                free(key);
                plist_free(obj);
                return NULL;
            }
            free(key);
        } else {
            PLIST_JSON_ERR("%s: keys must be of type STRING\n", __func__);
            plist_free(obj);
            return NULL;
        }
    }
    (*index) = j;
    return obj;
}

// the below code fragment can be found in:
// src/jplist.c
static plist_t parse_array(const char* js, jsmntok_info_t* ti, int* index)
{
    if (ti->tokens[*index].type != JSMN_ARRAY) {
        PLIST_JSON_ERR("%s: token type != JSMN_ARRAY\n", __func__);
        return NULL;
    }
    plist_t arr = plist_new_array();
    int num_tokens = ti->tokens[*index].size;
    int num;
    int j = (*index)+1;
    for (num = 0; num < num_tokens; num++) {
        if (j >= ti->count) {
            PLIST_JSON_ERR("%s: token index out of valid range\n", __func__);
            plist_free(arr);
            return NULL;
        }
        plist_t val = NULL;
        switch (ti->tokens[j].type) {
            case JSMN_OBJECT:
                val = parse_object(js, ti, &j);
                break;
            case JSMN_ARRAY:
                val = parse_array(js, ti, &j);
                break;
            case JSMN_STRING:
                val = parse_string(js, ti, &j);
                break;
            case JSMN_PRIMITIVE:
                val = parse_primitive(js, ti, &j);
                break;
            default:
                break;
        }
        if (val) {
            plist_array_append_item(arr, val);
        } else {
            plist_free(arr);
            return NULL;
        }
    }
    *(index) = j;
    return arr;
}

// the below code fragment can be found in:
// src/jsmn.c
static jsmnerr_t jsmn_parse_primitive(jsmn_parser *parser, const char *js,
		jsmntok_t *tokens, int num_tokens) {
	jsmntok_t *token;
	int start;

	start = parser->pos;

	for (; (parser->end > 0 && parser->pos < parser->end) && js[parser->pos] != '\0'; parser->pos++) {
		switch (js[parser->pos]) {
#ifndef JSMN_STRICT
			/* In strict mode primitive must be followed by "," or "}" or "]" */
			case ':':
#endif
			case '\t' : case '\r' : case '\n' : case ' ' :
			case ','  : case ']'  : case '}' :
				goto found;
			default:
				break;
		}
		if (js[parser->pos] < 32 || js[parser->pos] >= 127) {
			parser->pos = start;
			return JSMN_ERROR_INVAL;
		}
	}
#ifdef JSMN_STRICT
	/* In strict mode primitive must be followed by a comma/object/array */
	parser->pos = start;
	return JSMN_ERROR_PART;
#endif

found:
	token = jsmn_alloc_token(parser, tokens, num_tokens);
	if (token == NULL) {
		parser->pos = start;
		return JSMN_ERROR_NOMEM;
	}
	jsmn_fill_token(token, JSMN_PRIMITIVE, start, parser->pos);
#ifdef JSMN_PARENT_LINKS
	token->parent = parser->toksuper;
#endif
	parser->pos--;
	return JSMN_SUCCESS;
}

// the below code fragment can be found in:
// src/jplist.c
PLIST_API int plist_from_json(const char *json, uint32_t length, plist_t * plist)
{
    if (!plist) {
        return PLIST_ERR_INVALID_ARG;
    }
    *plist = NULL;
    if (!json || (length == 0)) {
        return PLIST_ERR_INVALID_ARG;
    }

    jsmn_parser parser;
    jsmn_init(&parser);
    int maxtoks = 256;
    int curtoks = 0;
    int r = 0;
    jsmntok_t *tokens = NULL;

    do {
        jsmntok_t* newtokens = realloc(tokens, sizeof(jsmntok_t)*maxtoks);
        if (!newtokens) {
            PLIST_JSON_ERR("%s: Out of memory\n", __func__);
            return PLIST_ERR_NO_MEM;
        }
        memset((unsigned char*)newtokens + sizeof(jsmntok_t)*curtoks, '\0', sizeof(jsmntok_t)*(maxtoks-curtoks));
        tokens = newtokens;
        curtoks = maxtoks;

        r = jsmn_parse(&parser, json, length, tokens, maxtoks);
        if (r == JSMN_ERROR_NOMEM) {
            maxtoks+=16;
            continue;
        }
    } while (r == JSMN_ERROR_NOMEM);

    switch(r) {
        case JSMN_ERROR_NOMEM:
            PLIST_JSON_ERR("%s: Out of memory...\n", __func__);
            free(tokens);
            return PLIST_ERR_NO_MEM;
        case JSMN_ERROR_INVAL:
            PLIST_JSON_ERR("%s: Invalid character inside JSON string\n", __func__);
            free(tokens);
            return PLIST_ERR_PARSE;
        case JSMN_ERROR_PART:
            PLIST_JSON_ERR("%s: Incomplete JSON, more bytes expected\n", __func__);
            free(tokens);
            return PLIST_ERR_PARSE;
        default:
            break;
    }

    int startindex = 0;
    jsmntok_info_t ti = { tokens, parser.toknext };
    switch (tokens[startindex].type) {
        case JSMN_PRIMITIVE:
            *plist = parse_primitive(json, &ti, &startindex);
            break;
        case JSMN_STRING:
            *plist = parse_string(json, &ti, &startindex);
            break;
        case JSMN_ARRAY:
            *plist = parse_array(json, &ti, &startindex);
            break;
        case JSMN_OBJECT:
            *plist = parse_object(json, &ti, &startindex);
            break;
        default:
            break;
    }
    free(tokens);
    return PLIST_ERR_SUCCESS;
}
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).