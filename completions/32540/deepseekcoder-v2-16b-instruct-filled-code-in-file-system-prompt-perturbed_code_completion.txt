_context.collect_data);

  for (unsigned int i = 0; i < lookupCount; i++)
  {
    unsigned seqIndex = lookupRecord[i].sequenceIndex;
    if (seqIndex >= inputCount) continue;

    const void *input_data = input;
    unsigned input_value = seqIndex;
    if (lookup_context.context_format != ContextFormat::SimpleContext)
    {
      input_data = lookup_context.collect_data;
      input_value = input[seqIndex];
    }

    (data + lookupRecord[i].lookupListIndex).collect (c->input, input_value, input_data);
  }
}

static inline bool context_apply_lookup (hb_ot_apply_context_t *c,
					 unsigned int inputCount, /* Including the first glyph (not matched) */
					 const HBUINT16 input[], /* Array of input values--start with second glyph */
					 unsigned int lookupCount,
					 const LookupRecord lookupRecord[],
					 ContextApplyLookupContext &lookup_context)
{
  unsigned int match_positions[HB_MAX_CONTEXT_LENGTH];
  unsigned int match_length;
  if (!match_input (c,
		    inputCount, input,
		    lookup_context.funcs.match,
		    lookup_context.match_data,
		    &match_length,
		    match_positions))
    return false;

  return apply_lookup (c,
		       inputCount, match_positions,
		       lookupCount, lookupRecord,
		       match_length);
}



/* Ligature caret lookups */

struct LigCaretApplyLookupContext
{
  LigCaretApplyLookupContext (hb_font_t *font_,
			      hb_buffer_t *buffer_,
			      const GDEF &gdef_,
			      const VariationStore &var_store_,
			      bool has_glyph_classes_,
			      bool auto_zwnj_,
			      bool auto_zwj_) :
			      font (font_),
			      buffer (buffer_),
			      gdef (gdef_),
			      var_store (var_store_),
			      has_glyph_classes (has_glyph_classes_),
			      auto_zwnj (auto_zwnj_),
			      auto_zwj (auto_zwj_) {}

  hb_font_t *font;
  hb_buffer_t *buffer;
  const GDEF &gdef;
  const VariationStore &var_store;
  bool has_glyph_classes;
  bool auto_zwnj;
  bool auto_zwj;
};

static inline bool lig_caret_apply_lookup (hb_ot_apply_context_t *c,
					   unsigned int lookup_index,
					   LigCaretApplyLookupContext &lookup_context)
{
  TRACE_APPLY (nullptr);

  hb_buffer_t *buffer = c->buffer;

  if (unlikely (buffer->idx >= buffer->len))
    return_trace (false);

  hb_codepoint_t glyph = buffer->info[buffer->idx].codepoint;
  const GDEF::LigCaretList &lig_carets = gdef.get_lig_carets ();
  if (unlikely (!lig_carets.has (glyph)))
    return_trace (false);

  const LigCaretRecord &lig_caret = lig_carets.get (glyph);
  if (lig_caret.caret_value == 0)
    return_trace (false);

  buffer->idx++;
  c->replace_glyph (lig_caret.lig_glyph);

  return_trace (true);
}



/* Mark position lookups */

struct MarkPositionApplyLookupContext
{
  MarkPositionApplyLookupContext (hb_font_t *font_,
				  hb_buffer_t *buffer_,
				  const GDEF &gdef_,
				  const VariationStore &var_store_,
				  bool has_glyph_classes_,
				  bool auto_zwnj_,
				  bool auto_zwj_) :
				  font (font_),
				  buffer (buffer_),
				  gdef (gdef_),
				  var_store (var_store_),
				  has_glyph_classes (has_glyph_classes_),
				  auto_zwnj (auto_zwnj_),
				  auto_zwj (auto_zwj_) {}

  hb_font_t *font;
  hb_buffer_t *buffer;
  const GDEF &gdef;
  const VariationStore &var_store;
  bool has_glyph_classes;
  bool auto_zwnj;
  bool auto_zwj;
};

static inline bool mark_position_apply_lookup (hb_ot_apply_context_t *c,
					       unsigned int lookup_index,
					       MarkPositionApplyLookupContext &lookup_context)
{
  TRACE_APPLY (nullptr);

  hb_buffer_t *buffer = c->buffer;

  if (unlikely (buffer->idx >= buffer->len))
    return_trace (false);

  hb_codepoint_t glyph = buffer->info[buffer->idx].codepoint;
  const GDEF::MarkArray &marks = gdef.get_marks ();
  if (unlikely (!marks.has (glyph)))
    return_trace (false);

  const MarkRecord &mark = marks.get (glyph);
  if (mark.mark_value == 0)
    return_trace (false);

  buffer->idx++;
  c->replace_glyph (mark.base_glyph);

  return_trace (true);
}



/* Chaining lookups */

struct ChainingContextClosureFuncs
{
  intersects_func_t intersects;
  intersected_glyphs_func_t intersected_glyphs;
  match_func_t match;
};

struct ChainingContextCollectGlyphsFuncs
{
  collect_glyphs_func_t collect;
};

struct ChainingContextApplyFuncs
{
  match_func_t match;
};

struct ChainingLookupContext
{
  ChainingContextClosureFuncs funcs;
  const void *intersects_data;
};

struct ChainingCollectGlyphsLookupContext
{
  ChainingContextCollectGlyphsFuncs funcs;
  const void *collect_data;
};

struct ChainingApplyLookupContext
{
  ChainingContextApplyFuncs funcs;
  const void *match_data;
};

static inline bool chaining_intersects (const hb_set_t *glyphs,
					const HBUINT16 &value,
					ChainingLookupContext &lookup_context)
{
  return lookup_context.funcs.intersects (glyphs, value, lookup_context.intersects_data);
}

static inline void chaining_closure_lookup (hb_closure_context_t *c,
					    unsigned int inputCount, /* Including the first glyph (not matched) */
					    const HBUINT16 input[], /* Array of input values--start with second glyph */
					    unsigned int lookupCount,
					    const LookupRecord lookupRecord[],
					    ChainingLookupContext &lookup_context)
{
  if (chaining_intersects (c->glyphs,
			   input[0],
			   lookup_context))
    context_closure_recurse_lookups (c,
				     inputCount, input,
				     lookupCount, lookupRecord,
				     0,
				     ContextFormat::SimpleContext,
				     nullptr,
				     lookup_context.funcs.intersected_glyphs);
}

static inline void chaining_collect_glyphs_lookup (hb_collect_glyphs_context_t *c,
						   unsigned int inputCount, /* Including the first glyph (not matched) */
						   const HBUINT16 input[], /* Array of input values--start with second glyph */
						   unsigned int lookupCount,
						   const LookupRecord lookupRecord[],
						   ChainingCollectGlyphsLookupContext &lookup_context)
{
  collect_array (c, c->input,
		 inputCount ? inputCount - 1 : 0, input,
		 lookup_context.funcs.collect, lookup_context.collect_data);

  for (unsigned int i = 0; i < lookupCount; i++)
  {
    unsigned seqIndex = lookupRecord[i].sequenceIndex;
    if (seqIndex >= inputCount) continue;

    const void *input_data = input;
    unsigned input_value = seqIndex;
    if (lookup_context.context_format != ContextFormat::SimpleContext)
    {
      input_data = lookup_context.collect_data;
      input_value = input[seqIndex];
    }

    (data + lookupRecord[i].lookupListIndex).collect (c->input, input_value, input_data);
  }
}

static inline bool chaining_apply_lookup (hb_ot_apply_context_t *c,
					  unsigned int inputCount, /* Including the first glyph (not matched) */
					  const HBUINT16 input[], /* Array of input values--start with second glyph */
					  unsigned int lookupCount,
					  const LookupRecord lookupRecord[],
					  ChainingApplyLookupContext &lookup_context)
{
  unsigned int match_positions[HB_MAX_CONTEXT_LENGTH];
  unsigned int match_length;
  if (!match_input (c,
		    inputCount, input,
		    lookup_context.funcs.match,
		    lookup_context.match_data,
		    &match_length,
		    match_positions))
    return false;

  return apply_lookup (c,
		       inputCount, match_positions,
		       lookupCount, lookupRecord,
		       match_length);
}



/* Reverse Chaining lookups */

struct ReverseChainingContextClosureFuncs
{
  intersects_func_t intersects;
  intersected_glyphs_func_t intersected_glyphs;
  match_func_t match;
};

struct ReverseChainingContextCollectGlyphsFuncs
{
  collect_glyphs_func_t collect;
};

struct ReverseChainingContextApplyFuncs
{
  match_func_t match;
};

struct ReverseChainingLookupContext
{
  ReverseChainingContextClosureFuncs funcs;
  const void *intersects_data;
};

struct ReverseChainingCollectGlyphsLookupContext
{
  ReverseChainingContextCollectGlyphsFuncs funcs;
  const void *collect_data;
};

struct ReverseChainingApplyLookupContext
{
  ReverseChainingContextApplyFuncs funcs;
  const void *match_data;
};

static inline bool reverse_chaining_intersects (const hb_set_t *glyphs,
						const HBUINT16 &value,
						ReverseChainingLookupContext &lookup_context)
{
  return lookup_context.funcs.intersects (glyphs, value, lookup_context.intersects_data);
}

static inline void reverse_chaining_closure_lookup (hb_closure_context_t *c,
						    unsigned int inputCount, /* Including the first glyph (not matched) */
						    const HBUINT16 input[], /* Array of input values--start with second glyph */
						    unsigned int lookupCount,
						    const LookupRecord lookupRecord[],
						    ReverseChainingLookupContext &lookup_context)
{
  if (reverse_chaining_intersects (c->glyphs,
				   input[inputCount - 1],
				   lookup_context))
    context_closure_recurse_lookups (c,
				     inputCount, input,
				     lookupCount, lookupRecord,
				     inputCount - 1,
				     ContextFormat::SimpleContext,
				     nullptr,
				     lookup_context.funcs.intersected_glyphs);
}

static inline void reverse_chaining_collect_glyphs_lookup (hb_collect_glyphs_context_t *c,
							   unsigned int inputCount, /* Including the first glyph (not matched) */
							   const HBUINT16 input[], /* Array of input values--start with second glyph */
							   unsigned int lookupCount,
							   const LookupRecord lookupRecord[],
							   ReverseChainingCollectGlyphsLookupContext &lookup_context)
{
  collect_array (c, c->input,
		 inputCount ? inputCount - 1 : 0, input,
		 lookup_context.funcs.collect, lookup_context.collect_data);

  for (unsigned int i = 0; i < lookupCount; i++)
  {
    unsigned seqIndex = lookupRecord[i].sequenceIndex;
    if (seqIndex >= inputCount) continue;

    const void *input_data = input;
    unsigned input_value = seqIndex;
    if (lookup_context.context_format != ContextFormat::SimpleContext)
    {
      input_data = lookup_context.collect_data;