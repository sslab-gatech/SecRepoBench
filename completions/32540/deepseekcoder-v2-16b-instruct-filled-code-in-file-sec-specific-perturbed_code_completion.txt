&lookup_context)
{
  for (unsigned int i = 0; i < lookupCount; i++)
  {
    unsigned int seqIndex = lookupRecord[i].sequenceIndex;
    if (seqIndex >= inputCount) continue;

    if (context_intersects (c->input,
			    inputCount, input,
			    lookup_context))
    {
      const void *input_data = input;
      unsigned input_value = seqIndex;
      if (lookup_context.context_format != ContextFormat::SimpleContext)
      {
	input_data = lookup_context.collect_data;
	input_value = input[seqIndex];
      }

      lookup_context.funcs.collect (c->output, input_value, input_data);
    }
  }
}

static inline bool context_apply_lookup (hb_ot_apply_context_t *c,
					 unsigned int inputCount, /* Including the first glyph (not matched) */
					 const HBUINT16 input[], /* Array of input values--start with second glyph */
					 unsigned int lookupCount,
					 const LookupRecord lookupRecord[],
					 unsigned int match_length,
					 ContextApplyLookupContext &lookup_context)
{
  unsigned int match_positions[HB_MAX_CONTEXT_LENGTH];
  if (!match_input (c,
		    inputCount, input,
		    lookup_context.funcs.match,
		    lookup_context.match_data,
		    &match_length,
		    match_positions))
    return false;

  return apply_lookup (c,
		      inputCount, match_positions,
		      lookupCount, lookupRecord,
		      match_length);
}