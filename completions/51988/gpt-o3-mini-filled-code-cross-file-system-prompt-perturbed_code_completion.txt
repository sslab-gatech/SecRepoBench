int cp1, cp2;
if (utf8) {
    const unsigned char* p = reinterpret_cast<const unsigned char*>(word) + index;
    // Decode first UTF-8 character
    if (*p < 0x80) {
        cp1 = *p;
    } else if ((*p & 0xE0) == 0xC0) {
        cp1 = ((p[0] & 0x1F) << 6) | (p[1] & 0x3F);
    } else if ((*p & 0xF0) == 0xE0) {
        cp1 = ((p[0] & 0x0F) << 12) | ((p[1] & 0x3F) << 6) | (p[2] & 0x3F);
    } else if ((*p & 0xF8) == 0xF0) {
        cp1 = ((p[0] & 0x07) << 18) | ((p[1] & 0x3F) << 12) | ((p[2] & 0x3F) << 6) | (p[3] & 0x3F);
    } else {
        return 0; // invalid UTF-8 sequence
    }
    int len1 = (*p < 0x80) ? 1 : ((*p & 0xE0) == 0xC0 ? 2 : ((*p & 0xF0) == 0xE0 ? 3 : 4));
    const unsigned char* p2 = reinterpret_cast<const unsigned char*>(word) + index + len1;
    // Decode second UTF-8 character
    if (*p2 < 0x80) {
        cp2 = *p2;
    } else if ((*p2 & 0xE0) == 0xC0) {
        cp2 = ((p2[0] & 0x1F) << 6) | (p2[1] & 0x3F);
    } else if ((*p2 & 0xF0) == 0xE0) {
        cp2 = ((p2[0] & 0x0F) << 12) | ((p2[1] & 0x3F) << 6) | (p2[2] & 0x3F);
    } else if ((*p2 & 0xF8) == 0xF0) {
        cp2 = ((p2[0] & 0x07) << 18) | ((p2[1] & 0x3F) << 12) | ((p2[2] & 0x3F) << 6) | (p2[3] & 0x3F);
    } else {
        return 0; // invalid UTF-8 sequence
    }
} else {
    cp1 = static_cast<unsigned char>(word[index]);
    cp2 = static_cast<unsigned char>(word[index+1]);
}
// Ensure neither character is a hyphen
if (cp1 == '-' || cp2 == '-')
    return 0;
// Simple uppercase conversion for basic characters
auto toUpper = [](int ch) -> int {
    if (ch >= 'a' && ch <= 'z')
        return ch - ('a' - 'A');
    return ch;
};
// If either character is already uppercase, we have a match.
if (toUpper(cp1) == cp1 || toUpper(cp2) == cp2)
    return 1;