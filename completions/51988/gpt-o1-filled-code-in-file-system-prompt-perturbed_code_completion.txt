if (index <= 0 || !word[index]) {
    return 0;
  }

  // Don't check if either character is a hyphen.
  if (word[index - 1] == '-' || word[index] == '-') {
    return 0;
  }

  // For non-UTF-8 (simple 8-bit) handling, use the csconv table to see if
  // characters remain uppercase/lowercase when transformed.
  if (!utf8) {
    const unsigned char ch1 = static_cast<unsigned char>(word[index - 1]);
    const unsigned char ch2 = static_cast<unsigned char>(word[index]);

    bool ch1_is_upper = (csconv[ch1].cupper == ch1) && (ch1 != csconv[ch1].clower);
    bool ch1_is_lower = (csconv[ch1].clower == ch1) && (ch1 != csconv[ch1].cupper);
    bool ch2_is_upper = (csconv[ch2].cupper == ch2) && (ch2 != csconv[ch2].clower);
    bool ch2_is_lower = (csconv[ch2].clower == ch2) && (ch2 != csconv[ch2].cupper);

    // If one is uppercase and the other is lowercase, forbid compounding.
    if ((ch1_is_upper && ch2_is_lower) || (ch1_is_lower && ch2_is_upper)) {
      return 1;
    }
  } else {
    // For UTF-8, we can do a simplified check by converting both
    // code points and determining uppercase vs. lowercase in Unicode.
    // This is a simplified placeholder: a real implementation would parse
    // the full UTF-8 code points at [index - 1] and [index].
    //
    // In practice, we'd extract codepoints, then check if their uppercase
    // or lowercase transformations differ. Here, do a naive quick check.

    // If either position inside UTF-8 encodes a hyphen, or there's a mismatch
    // of upper-lower, forbid the compound.

    // Naive ASCII-based fallback for short demonstration:
    const unsigned char ch1 = static_cast<unsigned char>(word[index - 1]);
    const unsigned char ch2 = static_cast<unsigned char>(word[index]);
    bool ch1_is_upper = (ch1 >= 'A' && ch1 <= 'Z');
    bool ch1_is_lower = (ch1 >= 'a' && ch1 <= 'z');
    bool ch2_is_upper = (ch2 >= 'A' && ch2 <= 'Z');
    bool ch2_is_lower = (ch2 >= 'a' && ch2 <= 'z');
    if ((ch1_is_upper && ch2_is_lower) || (ch1_is_lower && ch2_is_upper)) {
      return 1;
    }
  }

  return 0;