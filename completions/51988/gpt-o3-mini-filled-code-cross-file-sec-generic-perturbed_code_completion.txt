if (!word)
  return 0;
size_t word_len = strlen(word);
if ((size_t)index >= word_len)
  return 0;

unsigned int cp1 = 0, cp2 = 0, up1 = 0, up2 = 0;
int len1 = 1, len2 = 1;
 
if (utf8) {
  // Decode first UTF-8 code point at word[index]
  unsigned char c1 = static_cast<unsigned char>(word[index]);
  if (c1 < 0x80) {
    cp1 = c1;
    len1 = 1;
  } else if ((c1 & 0xE0) == 0xC0) {
    if (index + 1 >= (int)word_len) return 0;
    cp1 = ((c1 & 0x1F) << 6) | (static_cast<unsigned char>(word[index+1]) & 0x3F);
    len1 = 2;
  } else if ((c1 & 0xF0) == 0xE0) {
    if (index + 2 >= (int)word_len) return 0;
    cp1 = ((c1 & 0x0F) << 12) |
          ((static_cast<unsigned char>(word[index+1]) & 0x3F) << 6) |
          (static_cast<unsigned char>(word[index+2]) & 0x3F);
    len1 = 3;
  } else if ((c1 & 0xF8) == 0xF0) {
    if (index + 3 >= (int)word_len) return 0;
    cp1 = ((c1 & 0x07) << 18) |
          ((static_cast<unsigned char>(word[index+1]) & 0x3F) << 12) |
          ((static_cast<unsigned char>(word[index+2]) & 0x3F) << 6) |
          (static_cast<unsigned char>(word[index+3]) & 0x3F);
    len1 = 4;
  } else {
    return 0; // invalid UTF-8
  }
  // Ensure there is another code point following cp1
  if ((size_t)index + len1 >= word_len)
    return 0;
  unsigned char c2 = static_cast<unsigned char>(word[index + len1]);
  if (c2 < 0x80) {
    cp2 = c2;
    len2 = 1;
  } else if ((c2 & 0xE0) == 0xC0) {
    if (index + len1 + 1 >= (int)word_len) return 0;
    cp2 = ((c2 & 0x1F) << 6) | (static_cast<unsigned char>(word[index+len1+1]) & 0x3F);
    len2 = 2;
  } else if ((c2 & 0xF0) == 0xE0) {
    if (index + len1 + 2 >= (int)word_len) return 0;
    cp2 = ((c2 & 0x0F) << 12) |
          ((static_cast<unsigned char>(word[index+len1+1]) & 0x3F) << 6) |
          (static_cast<unsigned char>(word[index+len1+2]) & 0x3F);
    len2 = 3;
  } else if ((c2 & 0xF8) == 0xF0) {
    if (index + len1 + 3 >= (int)word_len) return 0;
    cp2 = ((c2 & 0x07) << 18) |
          ((static_cast<unsigned char>(word[index+len1+1]) & 0x3F) << 12) |
          ((static_cast<unsigned char>(word[index+len1+2]) & 0x3F) << 6) |
          (static_cast<unsigned char>(word[index+len1+3]) & 0x3F);
    len2 = 4;
  } else {
    return 0; // invalid UTF-8
  }
} else {
  if ((size_t)index + 1 >= word_len)
    return 0;
  cp1 = static_cast<unsigned char>(word[index]);
  cp2 = static_cast<unsigned char>(word[index+1]);
}

// Check for hyphen
if (cp1 == '-' || cp2 == '-')
  return 0;

// Convert to uppercase.
// For UTF-8, a full Unicode case mapping is complex. Here we handle basic Latin letters.
if (utf8) {
  if (cp1 >= 'a' && cp1 <= 'z')
    up1 = cp1 - ('a' - 'A');
  else
    up1 = cp1;
  if (cp2 >= 'a' && cp2 <= 'z')
    up2 = cp2 - ('a' - 'A');
  else
    up2 = cp2;
} else {
  up1 = static_cast<unsigned char>(toupper(static_cast<int>(cp1)));
  up2 = static_cast<unsigned char>(toupper(static_cast<int>(cp2)));
}

// Return 1 if either character is already uppercase.
if (up1 == cp1 || up2 == cp2)
  return 1;