// masked region
struct hentry* AffixMgr::prefix_check(const std::string& word,
                                      int start,
                                      int len,
                                      char in_compound,
                                      const FLAG needflag) {
  struct hentry* rv = NULL;
  PfxEntry* ep = pfx;
  pfxappnd = NULL;
  sfxappnd = NULL;
  sfxextra = 0;

  // first handle the special case of 0 length prefixes
  PfxEntry* pe = pStart[0];
  while (pe) {
    if (ep && (ep->getCont() && TESTAFF(ep->getCont(), onlyincompound, ep->getContLen()))) {
      rv = NULL;
      break;
    }
    if (ep && (ep->getCont() && TESTAFF(ep->getCont(), compoundforbidflag, ep->getContLen()))) {
      rv = NULL;
      break;
    }
    if (ep && (ep->getCont() && TESTAFF(ep->getCont(), compoundpermitflag, ep->getContLen()))) {
      rv = ep->checkword(word, start, len, in_compound, needflag);
      if (rv) {
        pfx = ep;  // BUG: pfx not stateless
        return rv;
      }
    }
    pe = pe->getNext();
  }

  // now handle the general case
  if (len == 0)
    return NULL;  // FULLSTRIP
  unsigned char sp = word[start + len - 1];
  PfxEntry* pptr = pStart[sp];

  while (pptr) {
    if (isSubset(pptr->getKey(), word.c_str() + start, len)) {
      if (ep && (ep->getCont() && TESTAFF(ep->getCont(), compoundforbidflag, ep->getContLen()))) {
        rv = NULL;
        break;
      }
      if (ep && (ep->getCont() && TESTAFF(ep->getCont(), compoundpermitflag, ep->getContLen()))) {
        rv = pptr->checkword(word, start, len, in_compound, needflag);
        if (rv) {
          pfx = pptr;  // BUG: pfx not stateless
          return rv;
        }
      }
      pptr = pptr->getNextEQ();
    } else {
      pptr = pptr->getNextNE();
    }
  }

  return NULL;
}