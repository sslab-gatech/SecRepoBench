if((i < (packet->payload_packet_len - 1))
   && ((i + packet->payload[i + 1] + 2) < packet->payload_packet_len)) {
  u_int8_t len = packet->payload[i + 1];
  char dNSName[256];
  memcpy(dNSName, &packet->payload[i + 2], len);
  dNSName[len] = '\0';

  if(ndpi_is_printable_string(dNSName, len) == 0) {
    ndpi_set_risk(ndpi_struct, connection, NDPI_INVALID_CHARACTERS);
  }

  if(!strcmp(dNSName, connection->host_server_name)) {
    matched_name = 1;
    if(connection->protos.tls_quic.server_names == NULL) {
      connection->protos.tls_quic.server_names = ndpi_strdup(dNSName);
    } else {
      char *tmp = connection->protos.tls_quic.server_names;
      int tmp_len = strlen(tmp);
      connection->protos.tls_quic.server_names = ndpi_realloc(connection->protos.tls_quic.server_names, tmp_len + len + 2);
      memcpy(connection->protos.tls_quic.server_names + tmp_len, dNSName, len + 1);
    }
    ndpi_detect_subprotocol_by_dns_name(ndpi_struct, connection, dNSName);
  }

  i += len + 2;
} else {
#if DEBUG_TLS
  printf("[TLS] Leftover %u bytes", packet->payload_packet_len - i);
#endif
  ndpi_set_risk(ndpi_struct, connection, NDPI_TLS_SUSPICIOUS_EXTENSION);
  break;
}