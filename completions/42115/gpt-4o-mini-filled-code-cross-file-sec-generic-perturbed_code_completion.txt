len = packet->payload[i + 1];
          if (len < sizeof(dNSName)) {
            memcpy(dNSName, &packet->payload[i + 2], len);
            dNSName[len] = '\0'; // Null-terminate the string

            // Ensure the DNS name is printable
            if (ndpi_is_printable_string(dNSName, len) == 0) {
              ndpi_set_risk(ndpi_struct, connection, NDPI_INVALID_CHARACTERS);
            } else {
              // Check if the extracted DNS name matches the host server name
              if (strcmp(dNSName, connection->host_server_name) == 0) {
                matched_name = 1;
                // Update the server names list in the flow structure
                if (connection->protos.tls_quic.server_names == NULL) {
                  connection->protos.tls_quic.server_names = ndpi_strdup(dNSName);
                } else {
                  char *new_server_names = malloc(strlen(connection->protos.tls_quic.server_names) + strlen(dNSName) + 2);
                  if (new_server_names) {
                    sprintf(new_server_names, "%s,%s", connection->protos.tls_quic.server_names, dNSName);
                    free(connection->protos.tls_quic.server_names);
                    connection->protos.tls_quic.server_names = new_server_names;
                  }
                }
                // Attempt to detect a subprotocol based on the DNS name
                ndpi_check_subprotocol_risk(ndpi_struct, connection, NDPI_PROTOCOL_TLS);
              }
            }
          }