if((i < (packet->payload_len - 1)) && (packet->payload[i + 1] == 0x00)) {
            // Extract the DNS name or IP address
            u_int8_t len = packet->payload[i + 2];
            char dNSName[256];

            if((i + 3 + len) <= packet->payload_len) {
              memcpy(dNSName, &packet->payload[i + 3], len);
              dNSName[len] = '\0';

              // Clean up the extracted DNS name
              cleanupServerName(dNSName, len);

              // Check if the extracted DNS name matches the host server name
              if(strcmp(dNSName, flow->host_server_name) == 0) {
                matched_name = 1;
              }

              // If the server names list is not initialized, create a new entry
              if(connection->host_server_name[0] == '\0') {
                snprintf(connection->host_server_name, sizeof(connection->host_server_name), "%s", dNSName);
              } else {
                // If the server names list already exists, append the current DNS name
                strncat(connection->host_server_name, ",", sizeof(connection->host_server_name) - strlen(connection->host_server_name) - 1);
                strncat(connection->host_server_name, dNSName, sizeof(connection->host_server_name) - strlen(connection->host_server_name) - 1);
              }

              // Attempt to detect a subprotocol based on the DNS name
              if(ndpi_match_hostname_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TLS, dNSName, len)) {
                flow->protos.tls_quic.subprotocol_detected = 1;
              }
            }
          }