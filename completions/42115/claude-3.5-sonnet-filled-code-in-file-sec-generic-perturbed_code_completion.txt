if(len < (sizeof(dNSName)-1)) {
  strncpy(dNSName, (const char*)&packet->payload[cipher_offset+i], len);
  dNSName[len] = '\0';
  
  if(general_name_type == 0x87) { // IP address
    struct in_addr addr;
    struct in6_addr addr6;
    
    if(len == 4) { // IPv4
      memcpy(&addr.s_addr, dNSName, 4);
      inet_ntop(AF_INET, &addr, dNSName, sizeof(dNSName));
    } else if(len == 16) { // IPv6
      memcpy(&addr6.s6_addr, dNSName, 16);
      inet_ntop(AF_INET6, &addr6, dNSName, sizeof(dNSName));
    }
  }
  
  cleanupServerName(dNSName, len);
  
  if(ndpi_is_printable_string((uint8_t*)dNSName, len) == 0) {
    ndpi_set_risk(ndpi_struct, flow, NDPI_INVALID_CHARACTERS);
  }
  
  if(strcmp(dNSName, flow->host_server_name) == 0) {
    matched_name = 1;
  }
  
  if(flow->protos.tls_quic.server_names == NULL) {
    flow->protos.tls_quic.server_names = ndpi_strdup(dNSName);
  } else {
    u_int len = strlen(flow->protos.tls_quic.server_names);
    flow->protos.tls_quic.server_names = (char*)ndpi_realloc(flow->protos.tls_quic.server_names, len + strlen(dNSName) + 2);
    if(flow->protos.tls_quic.server_names) {
      flow->protos.tls_quic.server_names[len] = ',';
      strcpy(&flow->protos.tls_quic.server_names[len+1], dNSName);
    }
  }
  
  if(flow->protos.tls_quic.server_names) {
    if(ndpi_match_hostname_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TLS, dNSName, strlen(dNSName)))
      flow->protos.tls_quic.subprotocol_detected = 1;
  }
}