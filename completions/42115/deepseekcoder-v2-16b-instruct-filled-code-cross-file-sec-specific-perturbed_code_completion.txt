// Parse the payload to extract the DNS name or IP address from the subjectAltName extension.
// Convert the extracted address to a string format for IPv4 and IPv6.
// Clean up the extracted DNS name and ensure it is printable.
// Check if the extracted DNS name matches the host server name.
// If a match is found, set the matched_name flag and update the server names list in the flow structure.
// If the server names list is not initialized, create a new entry for the current DNS name.
// If the server names list already exists, append the current DNS name to it with a comma separator.
// Attempt to detect a subprotocol based on the DNS name and update the flow structure accordingly.

char dNSName[256];
u_int8_t *payload = &packet->payload[i];
u_int len = packet->payload[i + 1];
u_int offset = i + 2;

if (len > sizeof(dNSName) - 1) {
  len = sizeof(dNSName) - 1;
}

memcpy(dNSName, payload, len);
dNSName[len] = '\0';

if (ndpi_is_printable_string(dNSName, len) == 0) {
  ndpi_set_risk(ndpi_struct, connection, NDPI_INVALID_CHARACTERS);
  return;
}

if (strcmp(dNSName, connection->host_server_name) == 0) {
  matched_name = 1;

  if (connection->protos.tls_quic.server_names == NULL) {
    connection->protos.tls_quic.server_names = ndpi_strdup(dNSName);
  } else {
    char *temp = connection->protos.tls_quic.server_names;
    connection->protos.tls_quic.server_names = ndpi_strdup_printf("%s,%s", temp, dNSName);
    free(temp);
  }

  // Attempt to detect a subprotocol based on the DNS name
  // This part is simplified and should be expanded based on actual subprotocol detection logic
  if (strstr(dNSName, "example.com") != NULL) {
    ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_HTTP, NDPI_PROTOCOL_UNKNOWN);
  }
}