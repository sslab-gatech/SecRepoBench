if(len > sizeof(dNSName) - 1)
  len = sizeof(dNSName) - 1;

if(general_name_type == 0x82 || general_name_type == 0x81) { /* dNSName or rfc822Name */
  memcpy(dNSName, &packet->payload[i+2], len);
  dNSName[len] = '\0';
  ndpi_cleanup_name((unsigned char*)dNSName, len);
  if(ndpi_is_printable_string((unsigned char*)dNSName, len) == 0)
    ndpi_set_risk(ndpi_struct, connection, NDPI_INVALID_CHARACTERS);
} else if(general_name_type == 0x87) { /* ipAddress */
  if(len == 4 || len == 16) {
    char ip_str[INET6_ADDRSTRLEN];
    const char *res = inet_ntop(len == 4 ? AF_INET : AF_INET6, 
                               &packet->payload[i+2], ip_str, sizeof(ip_str));
    if(res) snprintf(dNSName, sizeof(dNSName), "%s", ip_str);
    else dNSName[0] = '\0';
  } else {
    snprintf(dNSName, sizeof(dNSName), "INVALID_IP_LEN_%u", len);
    ndpi_set_risk(ndpi_struct, connection, NDPI_TLS_SUSPICIOUS_EXTENSION);
  }
}

if(connection->host_server_name[0] && dNSName[0] &&
   strcasecmp(dNSName, connection->host_server_name) == 0)
  matched_name = 1;

if(dNSName[0]) {
  if(connection->server_names == NULL) {
    connection->server_names = ndpi_strdup(dNSName);
  } else {
    char *new_name = ndpi_malloc(strlen(connection->server_names) + strlen(dNSName) + 2);
    if(new_name) {
      sprintf(new_name, "%s,%s", connection->server_names, dNSName);
      ndpi_free(connection->server_names);
      connection->server_names = new_name;
    }
  }
  ndpi_match_host_subprotocol(ndpi_struct, flow, (u_int8_t*)dNSName, strlen(dNSName), 0);
}