{
  char dnsName[256] = {0};
  if(len < sizeof(dnsName)) {
    memcpy(dnsName, &packet->payload[i+2], len);
    dnsName[len] = '\0';

    /* Ensure the DNS name contains only printable characters */
    if(ndpi_is_printable_string(dnsName, strlen(dnsName)) == 0) {
      ndpi_set_risk(ndpi_struct, connection, NDPI_TLS_SUSPICIOUS_EXTENSION);
    }

    /* Check if the extracted DNS name matches the host server name */
    if(connection->host_server_name[0] != '\0' && strcmp(connection->host_server_name, dnsName) == 0) {
      matched_name = 1;
    }

    /* Update the host server name list in the flow structure */
    if(connection->host_server_name[0] == '\0') {
      strncpy(connection->host_server_name, dnsName, sizeof(connection->host_server_name) - 1);
      connection->host_server_name[sizeof(connection->host_server_name) - 1] = '\0';
    } else {
      strncat(connection->host_server_name, ",", sizeof(connection->host_server_name) - strlen(connection->host_server_name) - 1);
      strncat(connection->host_server_name, dnsName, sizeof(connection->host_server_name) - strlen(connection->host_server_name) - 1);
    }

    /* Optionally, detect a subprotocol based on the DNS name here.
       (Implementation-specific logic can be inserted if necessary.) */
  }
}