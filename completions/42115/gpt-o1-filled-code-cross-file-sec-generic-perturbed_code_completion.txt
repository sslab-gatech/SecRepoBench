{
  /* Safely copy the subjectAltName data into a local buffer. */
  u_int8_t maxLen = (len < sizeof(dNSName) - 1) ? len : (sizeof(dNSName) - 1);
  memset(dNSName, 0, sizeof(dNSName));

  if(general_name_type == 0x87) {
    /* ipAddress case (RFC5280) */
    if(len == 4) { /* IPv4 */
      snprintf(dNSName, sizeof(dNSName), "%u.%u.%u.%u",
               packet->payload[i+2], packet->payload[i+3],
               packet->payload[i+4], packet->payload[i+5]);
    } else if(len == 16) { /* IPv6 */
      snprintf(dNSName, sizeof(dNSName),
               "%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:"
               "%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x",
               packet->payload[i+2],  packet->payload[i+3],
               packet->payload[i+4],  packet->payload[i+5],
               packet->payload[i+6],  packet->payload[i+7],
               packet->payload[i+8],  packet->payload[i+9],
               packet->payload[i+10], packet->payload[i+11],
               packet->payload[i+12], packet->payload[i+13],
               packet->payload[i+14], packet->payload[i+15],
               packet->payload[i+16], packet->payload[i+17]);
    } else {
      /* Unrecognized IP length, skip safely. */
      break;
    }
  } else {
    /* dNSName, rfc822Name, etc. */
    memcpy(dNSName, &packet->payload[i+2], maxLen);
    dNSName[maxLen] = '\0';
    /* Optionally ensure the extracted string is printable. */
    if(ndpi_is_printable_string(dNSName, maxLen) == 0) {
      ndpi_set_risk(ndpi_struct, connection, NDPI_INVALID_CHARACTERS);
    }
  }

  /* Check if we have a valid name to process. */
  if(dNSName[0] != '\0') {
    /* Check for matching server name (SNI). */
    if(!matched_name && connection->host_server_name[0] != '\0'
       && ndpi_strcasecmp(dNSName, connection->host_server_name) == 0) {
      matched_name = 1;
    }

    /* Update the serverNames list in the flow structure. */
    if(connection->protos.tls_quic.serverNames == NULL) {
      connection->protos.tls_quic.serverNames = ndpi_strdup(dNSName);
    } else {
      size_t old_len = strlen(connection->protos.tls_quic.serverNames);
      size_t new_len = old_len + strlen(dNSName) + 2; /* +1 for comma, +1 for null terminator */
      char *temp = ndpi_malloc(new_len);
      if(temp) {
        snprintf(temp, new_len, "%s,%s", connection->protos.tls_quic.serverNames, dNSName);
        ndpi_free(connection->protos.tls_quic.serverNames);
        connection->protos.tls_quic.serverNames = temp;
      }
    }

    /* Attempt to detect a subprotocol based on this name. */
    {
      u_int32_t val;
      if(ndpi_match_string_value(ndpi_struct->tls_cert_subject_automa.ac_automa,
                                 dNSName, strlen(dNSName), &val) == 0) {
        /* Match found */
        u_int16_t proto_id = (u_int16_t)val;
        if(connection->detected_protocol_stack[1] == NDPI_PROTOCOL_UNKNOWN) {
          ndpi_protocol ret = { NDPI_PROTOCOL_TLS, proto_id, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED };
          connection->detected_protocol_stack[0] = proto_id;
          connection->detected_protocol_stack[1] = NDPI_PROTOCOL_TLS;
          connection->category = ndpi_get_proto_category(ndpi_struct, ret);
          ndpi_check_subprotocol_risk(ndpi_struct, connection, proto_id);
        }
      }
    }
  }
}