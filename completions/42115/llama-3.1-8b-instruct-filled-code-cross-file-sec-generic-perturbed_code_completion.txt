// Parse the payload to extract the DNS name or IP address from the subjectAltName extension.
// Convert the extracted address to a string format for IPv4 and IPv6.
// Clean up the extracted DNS name and ensure it is printable.
// Check if the extracted DNS name matches the host server name.
// If a match is found, set the matched_name flag and update the server names list in the flow structure.
// If the server names list is not initialized, create a new entry for the current DNS name.
// If the server names list already exists, append the current DNS name to it with a comma separator.
// Attempt to detect a subprotocol based on the DNS name and update the flow structure accordingly.
// <MASK>
if((general_name_type == 0x81)    /* rfc822Name */
   || (general_name_type == 0x82) /* dNSName    */
   || (general_name_type == 0x87) /* ipAddress  */
   )
{
  if((i < (packet->payload_packet_len - 1))
     && ((i + packet->payload[i + 1] + 2) < packet->payload_packet_len)) {
    u_int8_t len = packet->payload[i + 1];
    char dNSName[256];
    char ipAddr[INET6_ADDRSTRLEN];
    struct in6_addr ip6Addr;
    struct in_addr ip4Addr;
    int matched_name = 0;

    if(general_name_type == 0x81) { /* rfc822Name */
      // Parse the payload to extract the DNS name from the subjectAltName extension.
      // Convert the extracted address to a string format for IPv4 and IPv6.
      // Clean up the extracted DNS name and ensure it is printable.
      // Check if the extracted DNS name matches the host server name.
      // If a match is found, set the matched_name flag and update the server names list in the flow structure.
      // If the server names list is not initialized, create a new entry for the current DNS name.
      // If the server names list already exists, append the current DNS name to it with a comma separator.
      // Attempt to detect a subprotocol based on the DNS name and update the flow structure accordingly.
      // <MASK>
      if(ndpi_is_printable_string((char*)&packet->payload[i + 2], len)) {
        if(strcmp(connection->host_server_name, (char*)&packet->payload[i + 2]) == 0) {
          matched_name = 1;
        }
        if(connection->protos.tls_quic.server_names == NULL) {
          connection->protos.tls_quic.server_names = ndpi_strdup((char*)&packet->payload[i + 2]);
        } else {
          if(strchr(connection->protos.tls_quic.server_names, ',') == NULL) {
            strcat(connection->protos.tls_quic.server_names, ",");
          }
          strcat(connection->protos.tls_quic.server_names, (char*)&packet->payload[i + 2]);
        }
      }
    } else if(general_name_type == 0x82) { /* dNSName */
      // Parse the payload to extract the DNS name from the subjectAltName extension.
      // Convert the extracted address to a string format for IPv4 and IPv6.
      // Clean up the extracted DNS name and ensure it is printable.
      // Check if the extracted DNS name matches the host server name.
      // If a match is found, set the matched_name flag and update the server names list in the flow structure.
      // If the server names list is not initialized, create a new entry for the current DNS name.
      // If the server names list already exists, append the current DNS name to it with a comma separator.
      // Attempt to detect a subprotocol based on the DNS name and update the flow structure accordingly.
      // <MASK>
      if(ndpi_is_printable_string((char*)&packet->payload[i + 2], len)) {
        if(strcmp(connection->host_server_name, (char*)&packet->payload[i + 2]) == 0) {
          matched_name = 1;
        }
        if(connection->protos.tls_quic.server_names == NULL) {
          connection->protos.tls_quic.server_names = ndpi_strdup((char*)&packet->payload[i + 2]);
        } else {
          if(strchr(connection->protos.tls_quic.server_names, ',') == NULL) {
            strcat(connection->protos.tls_quic.server_names, ",");
          }
          strcat(connection->protos.tls_quic.server_names, (char*)&packet->payload[i + 2]);
        }
      }
    } else if(general_name_type == 0x87) { /* ipAddress */
      // Parse the payload to extract the IP address from the subjectAltName extension.
      // Convert the extracted address to a string format for IPv4 and IPv6.
      // Clean up the extracted DNS name and ensure it is printable.
      // Check if the extracted DNS name matches the host server name.
      // If a match is found, set the matched_name flag and update the server names list in the flow structure.
      // If the server names list is not initialized, create a new entry for the current DNS name.
      // If the server names list already exists, append the current DNS name to it with a comma separator.
      // Attempt to detect a subprotocol based on the DNS name and update the flow structure accordingly.
      // <MASK>
      if(packet->payload[i + 2] == 0x00) {
        // IPv4 address
        memcpy(&ip4Addr, (char*)&packet->payload[i + 3], sizeof(struct in_addr));
        inet_ntop(AF_INET, &ip4Addr, ipAddr, INET_ADDRSTRLEN);
        if(strcmp(connection->host_server_name, ipAddr) == 0) {
          matched_name = 1;
        }
        if(connection->protos.tls_quic.server_names == NULL) {
          connection->protos.tls_quic.server_names = ndpi_strdup(ipAddr);
        } else {
          if(strchr(connection->protos.tls_quic.server_names, ',') == NULL) {
            strcat(connection->protos.tls_quic.server_names, ",");
          }
          strcat(connection->protos.tls_quic.server_names, ipAddr);
        }
      } else {
        // IPv6 address
        memcpy(&ip6Addr, (char*)&packet->payload[i + 3], sizeof(struct in6_addr));
        inet_ntop(AF_INET6, &ip6Addr, ipAddr, INET6_ADDRSTRLEN);
        if(strcmp(connection->host_server_name, ipAddr) == 0) {
          matched_name = 1;
        }
        if(connection->protos.tls_quic.server_names == NULL) {
          connection->protos.tls_quic.server_names = ndpi_strdup(ipAddr);
        } else {
          if(strchr(connection->protos.tls_quic.server_names, ',') == NULL) {
            strcat(connection->protos.tls_quic.server_names, ",");
          }
          strcat(connection->protos.tls_quic.server_names, ipAddr);
        }
      }
    }

    i += len;
  } else {
#if DEBUG_TLS
    printf("[TLS] Leftover %u bytes", packet->payload_packet_len - i);
#endif
    ndpi_set_risk(ndpi_struct, connection, NDPI_TLS_SUSPICIOUS_EXTENSION);
    break;
  }

  if(!matched_name)
    ndpi_set_risk(ndpi_struct, connection, NDPI_TLS_CERTIFICATE_MISMATCH); /* Certificate mismatch */
}