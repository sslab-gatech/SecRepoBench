if((i < (packet->payload_packet_len - 1))
   && ((i + packet->payload[i + 1] + 2) < packet->payload_packet_len)) {
  u_int8_t len = packet->payload[i + 1];
  char dNSName[256];
  memcpy(dNSName, &packet->payload[i + 2], len);
  dNSName[len] = '\0';

  if(ndpi_is_printable_string(dNSName, len) == 0) {
    ndpi_set_risk(ndpi_struct, connection, NDPI_INVALID_CHARACTERS);
  }

  if(strcmp(dNSName, connection->host_server_name) == 0) {
    matched_name = 1;
    if(connection->protos.tls_quic.server_names == NULL) {
      connection->protos.tls_quic.server_names = ndpi_strdup(dNSName);
    } else {
      char *tmp = connection->protos.tls_quic.server_names;
      int tmp_len = strlen(tmp);
      tmp = realloc(tmp, tmp_len + len + 2);
      if(tmp) {
        connection->protos.tls_quic.server_names = tmp;
        tmp[tmp_len] = ',';
        tmp[tmp_len + 1] = '\0';
        memcpy(&tmp[tmp_len + 2], dNSName, len + 1);
      }
    }

    if(ndpi_match_string_value(ndpi_struct->tls_cert_subject_automa.ac_automa,
                               dNSName, strlen(dNSName), &val) == 0) {
      u_int16_t proto_id = (u_int16_t)val;
      ndpi_protocol ret = { NDPI_PROTOCOL_TLS, proto_id, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED };
      connection->detected_protocol_stack[0] = proto_id;
      connection->detected_protocol_stack[1] = NDPI_PROTOCOL_TLS;
      connection->category = ndpi_get_proto_category(ndpi_struct, ret);
      ndpi_check_subprotocol_risk(ndpi_struct, connection, proto_id);
    }
  }

  i += len + 2;
} else {
#if DEBUG_TLS
  printf("[TLS] Leftover %u bytes", packet->payload_packet_len - i);
#endif
  ndpi_set_risk(ndpi_struct, connection, NDPI_TLS_SUSPICIOUS_EXTENSION);
  break;
}