switch(general_name_type) {
  case 0x81: /* rfc822Name */
    snprintf(dNSName, sizeof(dNSName), "%.*s", len, &packet->payload[i + 2]);
    break;
  case 0x82: /* dNSName */
    snprintf(dNSName, sizeof(dNSName), "%.*s", len, &packet->payload[i + 2]);
    break;
  case 0x87: /* iPAddress */
    if(len == 4) { /* IPv4 */
      struct in_addr ipv4;
      memcpy(&ipv4.s_addr, &packet->payload[i + 2], len);
      inet_ntop(AF_INET, &ipv4, dNSName, sizeof(dNSName));
    } else if(len == 16) { /* IPv6 */
      struct in6_addr ipv6;
      memcpy(&ipv6, &packet->payload[i + 2], len);
      inet_ntop(AF_INET6, &ipv6, dNSName, sizeof(dNSName));
    } else {
      dNSName[0] = '\0';
    }
    break;
  default:
    dNSName[0] = '\0';
    break;
}

if(dNSName[0] != '\0') {
  if(ndpi_is_printable_string(dNSName, strlen(dNSName))) {
    if(connection->host_server_name[0] != '\0' && strcmp(connection->host_server_name, dNSName) == 0) {
      matched_name = 1;
    }

    if(connection->protos.tls_quic.server_names == NULL) {
      connection->protos.tls_quic.server_names = ndpi_strdup(dNSName);
    } else {
      char *new_server_names = ndpi_malloc(strlen(connection->protos.tls_quic.server_names) + strlen(dNSName) + 2);
      if(new_server_names != NULL) {
        snprintf(new_server_names, strlen(connection->protos.tls_quic.server_names) + strlen(dNSName) + 2, "%s,%s", connection->protos.tls_quic.server_names, dNSName);
        ndpi_free(connection->protos.tls_quic.server_names);
        connection->protos.tls_quic.server_names = new_server_names;
      }
    }

    ndpi_check_for_subprotocol(ndpi_struct, connection, dNSName);
  } else {
    ndpi_set_risk(ndpi_struct, connection, NDPI_INVALID_CHARACTERS);
  }
}