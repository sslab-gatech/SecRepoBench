if(len < (sizeof(dNSName)-1)) {
  strncpy(dNSName, (const char*)&packet->payload[cipher_offset+i], len);
  dNSName[len] = '\0';
  
  cleanupServerName(dNSName, len);

  if(ndpi_is_printable_string(dNSName, len) == 0) {
    ndpi_set_risk(ndpi_struct, flow, NDPI_INVALID_CHARACTERS);
  }

  if(general_name_type == 0x82) { // dNSName
    if(strcmp(dNSName, connection->host_server_name) == 0) {
      matched_name = 1;
    }
  } else if(general_name_type == 0x87) { // ipAddress
    if(len == 4) { // IPv4
      char ipv4_str[INET_ADDRSTRLEN];
      inet_ntop(AF_INET, dNSName, ipv4_str, INET_ADDRSTRLEN);
      if(strcmp(ipv4_str, connection->host_server_name) == 0) {
        matched_name = 1;
      }
    } else if(len == 16) { // IPv6
      char ipv6_str[INET6_ADDRSTRLEN];
      inet_ntop(AF_INET6, dNSName, ipv6_str, INET6_ADDRSTRLEN);
      if(strcmp(ipv6_str, connection->host_server_name) == 0) {
        matched_name = 1;
      }
    }
  }

  if(!connection->protos.tls_quic.server_names) {
    connection->protos.tls_quic.server_names = ndpi_strdup(dNSName);
  } else {
    u_int len = strlen(connection->protos.tls_quic.server_names);
    char *newstr = (char*)ndpi_realloc(connection->protos.tls_quic.server_names, len + strlen(dNSName) + 2);
    if(newstr) {
      connection->protos.tls_quic.server_names = newstr;
      snprintf(&newstr[len], strlen(dNSName) + 2, ",%s", dNSName);
    }
  }

  if(ndpi_match_hostname_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TLS, dNSName, strlen(dNSName)))
    flow->protos.tls_quic.subprotocol_detected = 1;
}