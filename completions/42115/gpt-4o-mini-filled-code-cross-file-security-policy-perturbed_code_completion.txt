dNSName[0] = '\0'; // Initialize the DNS name buffer
		  strncpy(dNSName, (const char*)&packet->payload[i + 2], len); // Extract the DNS name
		  dNSName[len] = '\0'; // Null-terminate the DNS name

		  // Clean up the extracted DNS name
		  if (ndpi_is_printable_string(dNSName, len) == 0) {
		    ndpi_set_risk(ndpi_struct, connection, NDPI_INVALID_CHARACTERS);
		  }

		  // Check if the extracted DNS name matches the host server name
		  if (strcmp(dNSName, connection->host_server_name) == 0) {
		    matched_name = 1;
		    // Update the server names list in the flow structure
		    if (connection->protos.tls_quic.server_names == NULL) {
		      connection->protos.tls_quic.server_names = ndpi_strdup(dNSName);
		    } else {
		      char *new_server_names = malloc(strlen(connection->protos.tls_quic.server_names) + strlen(dNSName) + 2);
		      sprintf(new_server_names, "%s,%s", connection->protos.tls_quic.server_names, dNSName);
		      free(connection->protos.tls_quic.server_names);
		      connection->protos.tls_quic.server_names = new_server_names;
		    }
		    // Attempt to detect a subprotocol based on the DNS name
		    ndpi_check_subprotocol_risk(ndpi_struct, connection, 0); // Assuming 0 is the protocol ID for the subprotocol
		  }