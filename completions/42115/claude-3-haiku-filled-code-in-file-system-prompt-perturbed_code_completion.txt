if((s_offset + packet->payload[s_offset+1] + 2) <= packet->payload_packet_len) {
  char dNSName[256];
  u_int8_t len = packet->payload[s_offset+1];
  strncpy(dNSName, (const char*)&packet->payload[s_offset+2], len);
  dNSName[len] = '\0';
  cleanupServerName(dNSName, len);

  if(ndpi_is_printable_string(dNSName, len) == 0) {
    ndpi_set_risk(ndpi_struct, flow, NDPI_INVALID_CHARACTERS);
  }

  if(strcmp(flow->host_server_name, dNSName) != 0) {
    matched_name = 1;
    if(flow->server_names == NULL) {
      flow->server_names = ndpi_strdup(dNSName);
    } else {
      char *new_server_names = ndpi_malloc(strlen(flow->server_names) + len + 2);
      sprintf(new_server_names, "%s,%s", flow->server_names, dNSName);
      ndpi_free(flow->server_names);
      flow->server_names = new_server_names;
    }

    if(ndpi_match_hostname_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TLS, dNSName, len))
      flow->protos.tls_quic.subprotocol_detected = 1;
  }
}