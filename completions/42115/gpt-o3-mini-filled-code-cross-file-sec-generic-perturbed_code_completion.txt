{
  size_t name_len = len;
  if(name_len >= sizeof(dNSName))
    name_len = sizeof(dNSName) - 1;
  memcpy(dNSName, &packet->payload[i+2], name_len);
  dNSName[name_len] = '\0';

  /* Clean up the extracted name: ensure it is printable */
  if(ndpi_is_printable_string(dNSName, name_len) == 0) {
    ndpi_set_risk(ndpi_struct, connection, NDPI_TLS_SUSPICIOUS_EXTENSION);
  }

  /* Check if the extracted DNS name matches the host server name */
  if(connection->host_server_name[0] != '\0' && strcmp(dNSName, connection->host_server_name) == 0)
    matched_name = 1;

  /* Update the host_server_name list:
   * If not initialized, copy the DNS name. Otherwise, append with a comma separator.
   */
  if(connection->host_server_name[0] == '\0') {
    strncpy(connection->host_server_name, dNSName, sizeof(connection->host_server_name) - 1);
    connection->host_server_name[sizeof(connection->host_server_name)-1] = '\0';
  } else {
    size_t curr_len = strlen(connection->host_server_name);
    if(curr_len + 1 + strlen(dNSName) < sizeof(connection->host_server_name)) {
      connection->host_server_name[curr_len] = ',';
      strcpy(connection->host_server_name + curr_len + 1, dNSName);
    }
  }

  /* Attempt to detect a subprotocol based on the DNS name.
   * This call is a placeholder for any subprotocol detection logic that might be required.
   */
  ndpi_detect_subprotocol_from_dns(ndpi_struct, connection, dNSName);
}