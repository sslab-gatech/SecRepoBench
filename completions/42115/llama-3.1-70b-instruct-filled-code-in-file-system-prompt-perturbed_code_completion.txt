// Parse the payload to extract the DNS name or IP address from the subjectAltName extension.
// Convert the extracted address to a string format for IPv4 and IPv6.
// Clean up the extracted DNS name and ensure it is printable.
// Check if the extracted DNS name matches the host server name.
// If a match is found, set the matched_name flag and update the server names list in the flow structure.
// If the server names list is not initialized, create a new entry for the current DNS name.
// If the server names list already exists, append the current DNS name to it with a comma separator.
// Attempt to detect a subprotocol based on the DNS name and update the flow structure accordingly.
if((general_name_type == 0x81)    /* rfc822Name */
   || (general_name_type == 0x82) /* dNSName    */
   || (general_name_type == 0x87) /* ipAddress  */
   )
{
  u_int8_t len = packet->payload[i + 1];
  char dNSName[256];
  char *dns_name = NULL;

  if((i + len + 2) <= packet->payload_packet_len) {
    if(general_name_type == 0x81) { /* rfc822Name */
      dns_name = ndpi_hostname_sni_set(flow, &packet->payload[i + 2], len);
    } else if(general_name_type == 0x82) { /* dNSName */
      dns_name = ndpi_hostname_sni_set(flow, &packet->payload[i + 2], len);
    } else if(general_name_type == 0x87) { /* ipAddress */
      if(len == 4) { /* IPv4 */
        sprintf(dNSName, "%u.%u.%u.%u", packet->payload[i + 2], packet->payload[i + 3], packet->payload[i + 4], packet->payload[i + 5]);
        dns_name = dNSName;
      } else if(len == 16) { /* IPv6 */
        sprintf(dNSName, "%02X%02X:%02X%02X:%02X%02X:%02X%02X:%02X%02X:%02X%02X:%02X%02X:%02X%02X",
                packet->payload[i + 2], packet->payload[i + 3], packet->payload[i + 4], packet->payload[i + 5],
                packet->payload[i + 6], packet->payload[i + 7], packet->payload[i + 8], packet->payload[i + 9],
                packet->payload[i + 10], packet->payload[i + 11], packet->payload[i + 12], packet->payload[i + 13],
                packet->payload[i + 14], packet->payload[i + 15], packet->payload[i + 16], packet->payload[i + 17]);
        dns_name = dNSName;
      }
    }

    if(dns_name) {
      int dns_len = strlen(dns_name);
      cleanupServerName(dns_name, dns_len);

      if(ndpi_is_printable_string(dns_name, dns_len) == 0) {
        ndpi_set_risk(ndpi_struct, connection, NDPI_INVALID_CHARACTERS);
      }

      if(flow->host_server_name[0] == '\0') {
        matched_name = 1;
      } else {
        if(strcmp(flow->host_server_name, dns_name) == 0) {
          matched_name = 1;
        }
      }

      if(flow->server_names == NULL) {
        flow->server_names = ndpi_strdup(dns_name);
      } else {
        char *new_server_names = (char *)ndpi_malloc(strlen(flow->server_names) + strlen(dns_name) + 2);
        sprintf(new_server_names, "%s, %s", flow->server_names, dns_name);
        ndpi_free(flow->server_names);
        flow->server_names = new_server_names;
      }

      if(ndpi_match_hostname_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TLS, dns_name, dns_len)) {
        flow->protos.tls_quic.subprotocol_detected = 1;
      }
    }
  } else {
    ndpi_set_risk(ndpi_struct, connection, NDPI_TLS_SUSPICIOUS_EXTENSION);
  }

  i += len;
}