{
        ndpi_serialize_string_string(serializer, "version", version);
      }

      if(flow->protos.tls_quic.alpn)
        ndpi_serialize_string_string(serializer, "alpn", flow->protos.tls_quic.alpn);

      if(flow->protos.tls_quic.ja3_client)
        ndpi_serialize_string_string(serializer, "ja3", flow->protos.tls_quic.ja3_client);

      if(flow->protos.tls_quic.tls_supported_versions)
        ndpi_serialize_string_string(serializer, "tls_supported_versions", flow->protos.tls_quic.tls_supported_versions);

      if(flow->protos.tls_quic.server_cipher)
        ndpi_serialize_string_uint32(serializer, "server_cipher", flow->protos.tls_quic.server_cipher);

      if(flow->protos.tls_quic.server_unsafe_cipher)
        ndpi_serialize_string_uint32(serializer, "server_unsafe_cipher", flow->protos.tls_quic.server_unsafe_cipher);

      if(flow->protos.tls_quic.subjectDN)
        ndpi_serialize_string_string(serializer, "subjectDN", flow->protos.tls_quic.subjectDN);

      if(flow->protos.tls_quic.issuerDN)
        ndpi_serialize_string_string(serializer, "issuerDN", flow->protos.tls_quic.issuerDN);

      if(flow->protos.tls_quic.sha1_certificate_fingerprint[0]!= '\0') {
        ndpi_serialize_start_of_block(serializer, "sha1_certificate_fingerprint");
        for(i=0; i<20; i++) {
          off = i*2;
          ndpi_serialize_string_string(serializer, "byte", &flow->protos.tls_quic.sha1_certificate_fingerprint[off]);
        }
        ndpi_serialize_end_of_block(serializer);
      }

      if(flow->protos.tls_quic.notBefore) {
        strftime(notBefore, sizeof(notBefore), "%Y-%m-%d %H:%M:%S", before);
        ndpi_serialize_string_string(serializer, "notBefore", notBefore);
      }

      if(flow->protos.tls_quic.notAfter) {
        strftime(notAfter, sizeof(notAfter), "%Y-%m-%d %H:%M:%S", after);
        ndpi_serialize_string_string(serializer, "notAfter", notAfter);
      }

      if(flow->protos.tls_quic.server_names) {
        ndpi_serialize_start_of_block(serializer, "server_names");
        for(i=0; i<flow->protos.tls_quic.num_server_names; i++) {
          ndpi_serialize_string_string(serializer, "name", &flow->protos.tls_quic.server_names[i*256]);
        }
        ndpi_serialize_end_of_block(serializer);
      }
    }
    break;

  case NDPI_PROTOCOL_TLS_QUIC:
    if(flow->protos.tls_quic.ssl_version) {
      char notBefore[32], notAfter[32];
      struct tm a, b, *before = NULL, *after = NULL;
      u_int i, off;
      u_int8_t unknown_tls_version;
      char *version = ndpi_ssl_version2str(flow, flow->protos.tls_quic.ssl_version, &unknown_tls_version);

      if(flow->protos.tls_quic.notBefore)
        before = gmtime_r((const time_t *)&flow->protos.tls_quic.notBefore, &a);
      if(flow->protos.tls_quic.notAfter)
        after  = gmtime_r((const time_t *)&flow->protos.tls_quic.notAfter, &b);

      if(!unknown_tls_version) {
        ndpi_serialize_string_string(serializer, "version", version);
      }

      if(flow->protos.tls_quic.alpn)
        ndpi_serialize_string_string(serializer, "alpn", flow->protos.tls_quic.alpn);

      if(flow->protos.tls_quic.ja3_client)
        ndpi_serialize_string_string(serializer, "ja3", flow->protos.tls_quic.ja3_client);

      if(flow->protos.tls_quic.tls_supported_versions)
        ndpi_serialize_string_string(serializer, "tls_supported_versions", flow->protos.tls_quic.tls_supported_versions);

      if(flow->protos.tls_quic.server_cipher)
        ndpi_serialize_string_uint32(serializer, "server_cipher", flow->protos.tls_quic.server_cipher);

      if(flow->protos.tls_quic.server_unsafe_cipher)
        ndpi_serialize_string_uint32(serializer, "server_unsafe_cipher", flow->protos.tls_quic.server_unsafe_cipher);

      if(flow->protos.tls_quic.subjectDN)
        ndpi_serialize_string_string(serializer, "subjectDN", flow->protos.tls_quic.subjectDN);

      if(flow->protos.tls_quic.issuerDN)
        ndpi_serialize_string_string(serializer, "issuerDN", flow->protos.tls_quic.issuerDN);

      if(flow->protos.tls_quic.sha1_certificate_fingerprint[0]!= '\0') {
        ndpi_serialize_start_of_block(serializer, "sha1_certificate_fingerprint");
        for(i=0; i<20; i++) {
          off = i*2;
          ndpi_serialize_string_string(serializer, "byte", &flow->protos.tls_quic.sha1_certificate_fingerprint[off]);
        }
        ndpi_serialize_end_of_block(serializer);
      }

      if(flow->protos.tls_quic.notBefore) {
        strftime(notBefore, sizeof(notBefore), "%Y-%m-%d %H:%M:%S", before);
        ndpi_serialize_string_string(serializer, "notBefore", notBefore);
      }

      if(flow->protos.tls_quic.notAfter) {
        strftime(notAfter, sizeof(notAfter), "%Y-%m-%d %H:%M:%S", after);
        ndpi_serialize_string_string(serializer, "notAfter", notAfter);
      }

      if(flow->protos.tls_quic.server_names) {
        ndpi_serialize_start_of_block(serializer, "server_names");
        for(i=0; i<flow->protos.tls_quic.num_server_names; i++) {
          ndpi_serialize_string_string(serializer, "name", &flow->protos.tls_quic.server_names[i*256]);
        }
        ndpi_serialize_end_of_block(serializer);
      }
    }
    break;

  case NDPI_PROTOCOL_TLS_QUIC:
    if(flow->protos.tls_quic.ssl_version) {
      char notBefore[32], notAfter[32];
      struct tm a, b, *before = NULL, *after = NULL;
      u_int i, off;
      u_int8_t unknown_tls_version;
      char *version = ndpi_ssl_version2str(flow, flow->protos.tls_quic.ssl_version, &unknown_tls_version);

      if(flow->protos.tls_quic.notBefore)
        before = gmtime_r((const time_t *)&flow->protos.tls_quic.notBefore, &a);
      if(flow->protos.tls_quic.notAfter)
        after  = gmtime_r((const time_t *)&flow->protos.tls_quic.notAfter, &b);

      if(!unknown_tls_version) {
        ndpi_serialize_string_string(serializer, "version", version);
      }

      if(flow->protos.tls_quic.alpn)
        ndpi_serialize_string_string(serializer, "alpn", flow->protos.tls_quic.alpn);

      if(flow->protos.tls_quic.ja3_client)
        ndpi_serialize_string_string(serializer, "ja3", flow->protos.tls_quic.ja3_client);

      if(flow->protos.tls_quic.tls_supported_versions)
        ndpi_serialize_string_string(serializer, "tls_supported_versions", flow->protos.tls_quic.tls_supported_versions);

      if(flow->protos.tls_quic.server_cipher)
        ndpi_serialize_string_uint32(serializer, "server_cipher", flow->protos.tls_quic.server_cipher);

      if(flow->protos.tls_quic.server_unsafe_cipher)
        ndpi_serialize_string_uint32(serializer, "server_unsafe_cipher", flow->protos.tls_quic.server_unsafe_cipher);

      if(flow->protos.tls_quic.subjectDN)
        ndpi_serialize_string_string(serializer, "subjectDN", flow->protos.tls_quic.subjectDN);

      if(flow->protos.tls_quic.issuerDN)
        ndpi_serialize_string_string(serializer, "issuerDN", flow->protos.tls_quic.issuerDN);

      if(flow->protos.tls_quic.sha1_certificate_fingerprint[0]!= '\0') {
        ndpi_serialize_start_of_block(serializer, "sha1_certificate_fingerprint");
        for(i=0; i<20; i++) {
          off = i*2;
          ndpi_serialize_string_string(serializer, "byte", &flow->protos.tls_quic.sha1_certificate_fingerprint[off]);
        }
        ndpi_serialize_end_of_block(serializer);
      }

      if(flow->protos.tls_quic.notBefore) {
        strftime(notBefore, sizeof(notBefore), "%Y-%m-%d %H:%M:%S", before);
        ndpi_serialize_string_string(serializer, "notBefore", notBefore);
      }

      if(flow->protos.tls_quic.notAfter) {
        strftime(notAfter, sizeof(notAfter), "%Y-%m-%d %H:%M:%S", after);
        ndpi_serialize_string_string(serializer, "notAfter", notAfter);
      }

      if(flow->protos.tls_quic.server_names) {
        ndpi_serialize_start_of_block(serializer, "server_names");
        for(i=0; i<flow->protos.tls_quic.num_server_names; i++) {
          ndpi_serialize_string_string(serializer, "name", &flow->protos.tls_quic.server_names[i*256]);
        }
        ndpi_serialize_end_of_block(serializer);
      }
    }
    break;

  default:
    break;
  }

  return(0);
}

// the below code fragment can be found in:
// src/lib/protocols/tls.c
static int checkExtensions(struct ndpi_detection_module_struct *ndpi_struct,
			   struct ndpi_flow_struct *flow,
			   int is_dtls,
			   u_int16_t extension_id,
			   u_int16_t extension_len,
			   u_int16_t offset) {
  struct ndpi_packet_struct *packet = &ndpi_struct->packet;

  if(extension_id == 0 /* server name */) {
    u_int16_t len;

#ifdef DEBUG_TLS
    printf("[TLS] Extensions: found server name\n");
#endif
    if((offset+4) < packet->payload_packet_len) {

      len = (packet->payload[offset+3] << 8) + packet->payload[offset+4];

      if((offset+5+len) <= packet->payload_packet_len) {

	char *sni = ndpi_hostname_sni_set(flow, &packet->payload[offset+5], len);
	int sni_len = strlen(sni);
#ifdef DEBUG_TLS
	printf("[TLS] SNI: [%s]\n", sni);
#endif
	if(ndpi_is_printable_string(sni, sni_len) == 0)
	{
	  ndpi_set_risk(ndpi_struct, flow, NDPI_INVALID_CHARACTERS);
	}

	if(!is_dtls) {
	  if(ndpi_match_hostname_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TLS, sni, sni_len))
	    flow->protos.tls_quic.subprotocol_detected = 1;
	} else {
	  if(ndpi_match_hostname_protocol(ndpi_struct, flow, NDPI_PROTOCOL_DTLS, sni, sni_len))
	    flow->protos.tls_quic.subprotocol_detected = 1;
	}

	if(ndpi_check_dga_name(ndpi_struct, flow,
			       sni, 1)) {
#ifdef DEBUG_TLS
	  printf("[TLS] SNI: (DGA) [%s]\n", sni);
#endif

	  if((sni_len >= 4)
	     /* Check if it ends in.com or.net */
	     && ((strcmp(&sni[sni_len-4], ".com") == 0) || (strcmp(&sni[sni_len-4], ".net") == 0))
	     && (strncmp(sni, "www.", 4) == 0)) /* Not starting with www.... */
	    ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TOR, NDPI_PROTOCOL_TLS);
	} else {
#ifdef DEBUG_TLS
	  printf("[TLS] SNI: (NO DGA) [%s]\n", sni);
#endif
	}
      } else {
#ifdef DEBUG_TLS
	printf("[TLS] Extensions server len too short: %u vs %u\n",
	       offset+5+len,
	       packet->payload_packet_len);
#endif
      }
    }
  } else if(extension_id == 10 /* supported groups */) {
    u_int16_t s_offset = offset + 2;

#ifdef DEBUG_TLS
    printf("Client TLS [EllipticCurveGroups: len=%u]\n", extension_len);
#endif

    if((s_offset+extension_len-2) <= packet->payload_packet_len) {
      u_int16_t i;

      for(i=0; i<(u_int32_t)extension_len-2 && s_offset + i + 1 < packet->payload_packet_len; i += 2) {
	u_int16_t s_group = ntohs(*((u_int16_t*)&packet->payload[s_offset+i]));

#ifdef DEBUG_TLS
	printf("Client TLS [EllipticCurve: %u/0x%04X]\n", s_group, s_group);
#endif
      }
    } else {
#ifdef DEBUG_TLS
      printf("Client TLS Invalid len %u vs %u\n", (s_offset+extension_len-1), packet->payload_packet_len);
#endif
    }
  } else if(extension_id == 11 /* ec_point_formats groups */) {
    u_int16_t s_offset = offset + 1;

#ifdef DEBUG_TLS
    printf("Client TLS [EllipticCurveFormat: len=%u]\n", extension_len);
#endif

    if((s_offset+extension_len-1) <= packet->payload_packet_len) {
      u_int16_t i;

      for(i=0; i<(u_int32_t)extension_len-1 && s_offset+i <