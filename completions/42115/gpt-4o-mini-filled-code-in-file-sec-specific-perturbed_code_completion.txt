if (packet->payload[i + 1] == 0x01) { // Check for the type of the block
            // Extract the length of the DNS name
            uint8_t dns_name_len = packet->payload[i + 2];
            if (dns_name_len > 0 && (i + 3 + dns_name_len) <= packet->payload_len) {
              // Allocate memory for the DNS name
              char *dns_name = (char *)malloc(dns_name_len + 1);
              if (dns_name) {
                memcpy(dns_name, &packet->payload[i + 3], dns_name_len);
                dns_name[dns_name_len] = '\0'; // Null-terminate the string

                // Check if the DNS name is printable
                if (ndpi_is_printable_string(dns_name, dns_name_len)) {
                  // Process the DNS name (e.g., store it, check against known values, etc.)
                  // Example: Add to flow structure or perform matching
                  if (ndpi_match_hostname_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TLS, dns_name, dns_name_len)) {
                    flow->protos.tls_quic.subprotocol_detected = 1;
                  }
                } else {
                  ndpi_set_risk(ndpi_struct, connection, NDPI_INVALID_CHARACTERS);
                }
                free(dns_name); // Free the allocated memory
              }
            }
          }