if(len < sizeof(dNSName) - 1) {
  memcpy(dNSName, &packet->payload[i + 2], len);
  dNSName[len] = '\0';

  // Clean up the DNS name and make sure it's printable
  if(general_name_type == 0x87) { // IP Address
    if(len == 4) { // IPv4
      struct in_addr addr;
      char ip_str[INET_ADDRSTRLEN];
      
      memcpy(&addr.s_addr, dNSName, 4);
      inet_ntop(AF_INET, &addr, ip_str, sizeof(ip_str));
      snprintf(dNSName, sizeof(dNSName), "%s", ip_str);
    } else if(len == 16) { // IPv6
      struct in6_addr addr6;
      char ip_str[INET6_ADDRSTRLEN];
      
      memcpy(&addr6, dNSName, 16);
      inet_ntop(AF_INET6, &addr6, ip_str, sizeof(ip_str));
      snprintf(dNSName, sizeof(dNSName), "%s", ip_str);
    }
  } else {
    // For DNS names and RFC822 names, make sure they're properly formatted
    for(u_int8_t j = 0; j < len; j++) {
      if(!ndpi_isprint(dNSName[j])) {
        dNSName[j] = '.';
      }
    }
  }

#ifdef DEBUG_TLS
  printf("[TLS] subjectAltName %s [%s]\n", 
         (general_name_type == 0x81) ? "rfc822Name" : 
         (general_name_type == 0x82) ? "dNSName" : "ipAddress", 
         dNSName);
#endif

  // Check if this name matches the requested host server name
  if(connection->host_server_name[0] != '\0') {
    if((general_name_type == 0x82) && // dNSName
       (strcasecmp(connection->host_server_name, dNSName) == 0)) {
      matched_name = 1;
    }
  }

  // Update server_names
  if(connection->protos.tls_quic.server_names == NULL) {
    connection->protos.tls_quic.server_names = ndpi_strdup(dNSName);
  } else {
    u_int newlen = strlen(connection->protos.tls_quic.server_names) + strlen(dNSName) + 2;
    char *newstr = ndpi_malloc(newlen);
    
    if(newstr) {
      snprintf(newstr, newlen, "%s,%s", connection->protos.tls_quic.server_names, dNSName);
      ndpi_free(connection->protos.tls_quic.server_names);
      connection->protos.tls_quic.server_names = newstr;
    }
  }

  // Try to detect subprotocol based on domain name
  if(general_name_type == 0x82 && // dNSName
     connection->detected_protocol_stack[1] == NDPI_PROTOCOL_UNKNOWN) {
    u_int32_t val;
    int rc = ndpi_match_string_value(ndpi_struct->tls_cert_subject_automa.ac_automa,
                                    dNSName, strlen(dNSName), &val);
    
    if(rc == 0) { // Match found
      u_int16_t proto_id = (u_int16_t)val;
      ndpi_protocol ret = { NDPI_PROTOCOL_TLS, proto_id, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED };
      
      connection->detected_protocol_stack[0] = proto_id;
      connection->detected_protocol_stack[1] = NDPI_PROTOCOL_TLS;
      
      connection->category = ndpi_get_proto_category(ndpi_struct, ret);
      ndpi_check_subprotocol_risk(ndpi_struct, connection, proto_id);

      if(ndpi_struct->tls_cert_cache == NULL)
        ndpi_struct->tls_cert_cache = ndpi_lru_cache_init(1024);

      if(ndpi_struct->tls_cert_cache && packet->iph) {
        u_int32_t key = packet->iph->saddr + packet->tcp->source; /* Server */
        
        ndpi_lru_add_to_cache(ndpi_struct->tls_cert_cache, key, proto_id);
      }
    }
  }
}