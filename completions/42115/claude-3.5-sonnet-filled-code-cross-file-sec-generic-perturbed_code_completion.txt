if(len > sizeof(dNSName) - 1)
  len = sizeof(dNSName) - 1;

memcpy(dNSName, &packet->payload[i + 2], len);
dNSName[len] = '\0';

if(general_name_type == 0x87) {
  char ip_str[INET6_ADDRSTRLEN];
  if(len == 4) {
    inet_ntop(AF_INET, dNSName, ip_str, sizeof(ip_str));
  } else if(len == 16) {
    inet_ntop(AF_INET6, dNSName, ip_str, sizeof(ip_str));
  } else {
    ndpi_set_risk(ndpi_struct, connection, NDPI_TLS_SUSPICIOUS_EXTENSION);
    break;
  }
  snprintf(dNSName, sizeof(dNSName), "%s", ip_str);
} else {
  u_int j, valid = 1;

  for(j=0; j<len; j++) {
    if(!ndpi_isprint(dNSName[j])) {
      valid = 0;
      break;
    }
  }

  if(!valid) {
    ndpi_set_risk(ndpi_struct, connection, NDPI_TLS_SUSPICIOUS_EXTENSION);
    break;
  }
}

if(connection->host_server_name[0] != '\0') {
  u_int8_t matched = (strcasecmp(dNSName, connection->host_server_name) == 0);

  if(matched) {
    matched_name = 1;
  }
}

if(connection->protos.tls_quic.server_names == NULL)
  connection->protos.tls_quic.server_names = ndpi_strdup(dNSName);
else {
  u_int len = strlen(connection->protos.tls_quic.server_names);
  char *new_name = ndpi_malloc(len + strlen(dNSName) + 2);

  if(new_name) {
    sprintf(new_name, "%s,%s", connection->protos.tls_quic.server_names, dNSName);
    ndpi_free(connection->protos.tls_quic.server_names);
    connection->protos.tls_quic.server_names = new_name;
  }
}

if(ndpi_match_hostname_protocol(ndpi_struct, connection, dNSName, strlen(dNSName)) != NDPI_PROTOCOL_UNKNOWN)
  break;