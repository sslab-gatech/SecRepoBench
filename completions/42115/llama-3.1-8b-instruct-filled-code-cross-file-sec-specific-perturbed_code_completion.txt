// Parse the payload to extract the DNS name or IP address from the subjectAltName extension.
// Convert the extracted address to a string format for IPv4 and IPv6.
// Clean up the extracted DNS name and ensure it is printable.
// Check if the extracted DNS name matches the host server name.
// If a match is found, set the matched_name flag and update the server names list in the flow structure.
// If the server names list is not initialized, create a new entry for the current DNS name.
// If the server names list already exists, append the current DNS name to it with a comma separator.
// Attempt to detect a subprotocol based on the DNS name and update the flow structure accordingly.
// <MASK>
if((general_name_type == 0x81)    /* rfc822Name */
   || (general_name_type == 0x82) /* dNSName    */
   || (general_name_type == 0x87) /* ipAddress  */
   )
{
  if((i < (packet->payload_packet_len - 1))
     && ((i + packet->payload[i + 1] + 2) < packet->payload_packet_len)) {
    u_int8_t len = packet->payload[i + 1];
    char dNSName[256];
    char ipAddr[INET6_ADDRSTRLEN];
    struct in6_addr ip6Addr;
    struct in_addr ip4Addr;
    int matched_name = 0;

    if(general_name_type == 0x81) { /* rfc822Name */
      // Parse the payload to extract the DNS name from the subjectAltName extension.
      // Convert the extracted address to a string format for IPv4 and IPv6.
      // Clean up the extracted DNS name and ensure it is printable.
      // Check if the extracted DNS name matches the host server name.
      // If a match is found, set the matched_name flag and update the server names list in the flow structure.
      // If the server names list is not initialized, create a new entry for the current DNS name.
      // If the server names list already exists, append the current DNS name to it with a comma separator.
      // Attempt to detect a subprotocol based on the DNS name and update the flow structure accordingly.
      if(connection->host_server_name[0] == '\0') {
        matched_name = 1;
      }
      strncpy(dNSName, (const char*)&packet->payload[i + 2], len);
      dNSName[len] = '\0';
      if(ndpi_is_printable_string(dNSName, len) == 0) {
        ndpi_set_risk(ndpi_struct, connection, NDPI_INVALID_CHARACTERS);
      }
      if(strcmp(dNSName, connection->host_server_name) == 0) {
        matched_name = 1;
      }
      if(connection->detected_protocol_stack[1] == NDPI_PROTOCOL_UNKNOWN) {
        // Attempt to detect a subprotocol based on the DNS name and update the flow structure accordingly.
        if(ndpi_match_string_value(ndpi_struct->tls_cert_subject_automa.ac_automa,
                                   dNSName, strlen(dNSName), &val)) {
          // Match found
          u_int16_t proto_id = (u_int16_t)val;
          ndpi_protocol ret = { NDPI_PROTOCOL_TLS, proto_id, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED};
          connection->detected_protocol_stack[0] = proto_id,
            connection->detected_protocol_stack[1] = NDPI_PROTOCOL_TLS;
          connection->category = ndpi_get_proto_category(ndpi_struct, ret);
          ndpi_check_subprotocol_risk(ndpi_struct, connection, proto_id);
        }
      }
    } else if(general_name_type == 0x82) { /* dNSName */
      // Parse the payload to extract the DNS name from the subjectAltName extension.
      // Convert the extracted address to a string format for IPv4 and IPv6.
      // Clean up the extracted DNS name and ensure it is printable.
      // Check if the extracted DNS name matches the host server name.
      // If a match is found, set the matched_name flag and update the server names list in the flow structure.
      // If the server names list is not initialized, create a new entry for the current DNS name.
      // If the server names list already exists, append the current DNS name to it with a comma separator.
      // Attempt to detect a subprotocol based on the DNS name and update the flow structure accordingly.
      if(connection->host_server_name[0] == '\0') {
        matched_name = 1;
      }
      strncpy(dNSName, (const char*)&packet->payload[i + 2], len);
      dNSName[len] = '\0';
      if(ndpi_is_printable_string(dNSName, len) == 0) {
        ndpi_set_risk(ndpi_struct, connection, NDPI_INVALID_CHARACTERS);
      }
      if(strcmp(dNSName, connection->host_server_name) == 0) {
        matched_name = 1;
      }
      if(connection->detected_protocol_stack[1] == NDPI_PROTOCOL_UNKNOWN) {
        // Attempt to detect a subprotocol based on the DNS name and update the flow structure accordingly.
        if(ndpi_match_string_value(ndpi_struct->tls_cert_subject_automa.ac_automa,
                                   dNSName, strlen(dNSName), &val)) {
          // Match found
          u_int16_t proto_id = (u_int16_t)val;
          ndpi_protocol ret = { NDPI_PROTOCOL_TLS, proto_id, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED};
          connection->detected_protocol_stack[0] = proto_id,
            connection->detected_protocol_stack[1] = NDPI_PROTOCOL_TLS;
          connection->category = ndpi_get_proto_category(ndpi_struct, ret);
          ndpi_check_subprotocol_risk(ndpi_struct, connection, proto_id);
        }
      }
    } else if(general_name_type == 0x87) { /* ipAddress */
      // Parse the payload to extract the IP address from the subjectAltName extension.
      // Convert the extracted address to a string format for IPv4 and IPv6.
      // Clean up the extracted IP address and ensure it is printable.
      // Check if the extracted IP address matches the host server IP address.
      // If a match is found, set the matched_name flag and update the server names list in the flow structure.
      // If the server names list is not initialized, create a new entry for the current IP address.
      // If the server names list already exists, append the current IP address to it with a comma separator.
      // Attempt to detect a subprotocol based on the IP address and update the flow structure accordingly.
      if(connection->host_server_ip[0] == '\0') {
        matched_name = 1;
      }
      if(len < sizeof(ip4Addr)) {
        memcpy(&ip4Addr, (const struct in_addr*)&packet->payload[i + 2], len);
        if(ndpi_is_printable_string(inet_ntoa(ip4Addr), len) == 0) {
          ndpi_set_risk(ndpi_struct, connection, NDPI_INVALID_CHARACTERS);
        }
        if(strcmp(inet_ntoa(ip4Addr), connection->host_server_ip) == 0) {
          matched_name = 1;
        }
      } else {
        memcpy(&ip6Addr, (const struct in6_addr*)&packet->payload[i + 2], len);
        if(ndpi_is_printable_string(inet_ntop(AF_INET6, &ip6Addr, ipAddr, INET6_ADDRSTRLEN), len) == 0) {
          ndpi_set_risk(ndpi_struct, connection, NDPI_INVALID_CHARACTERS);
        }
        if(strcmp(inet_ntop(AF_INET6, &ip6Addr, ipAddr, INET6_ADDRSTRLEN), connection->host_server_ip) == 0) {
          matched_name = 1;
        }
      }
      if(connection->detected_protocol_stack[1] == NDPI_PROTOCOL_UNKNOWN) {
        // Attempt to detect a subprotocol based on the IP address and update the flow structure accordingly.
        if(ndpi_match_string_value(ndpi_struct->tls_cert_subject_automa.ac_automa,
                                   connection->host_server_ip, strlen(connection->host_server_ip), &val)) {
          // Match found
          u_int16_t proto_id = (u_int16_t)val;
          ndpi_protocol ret = { NDPI_PROTOCOL_TLS, proto_id, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED};
          connection->detected_protocol_stack[0] = proto_id,
            connection->detected_protocol_stack[1] = NDPI_PROTOCOL_TLS;
          connection->category = ndpi_get_proto_category(ndpi_struct, ret);
          ndpi_check_subprotocol_risk(ndpi_struct, connection, proto_id);
        }
      }
    }
    if(matched_name) {
      if(connection->server_names == NULL) {
        connection->server_names = ndpi_strdup(dNSName);
      } else {
        char *new_server_names = ndpi_realloc(connection->server_names, strlen(connection->server_names) + strlen(dNSName) + 2);
        if(new_server_names!= NULL) {
          strcat(new_server_names, ",");
          strcat(new_server_names, dNSName);
          connection->server_names = new_server_names;
        }
      }
    }
    i += len;
  } else {
#if DEBUG_TLS
    printf("[TLS] Leftover %u bytes", packet->payload_packet_len - i);
#endif
    ndpi_set_risk(ndpi_struct, connection, NDPI_TLS_SUSPICIOUS_EXTENSION);
    break;
  }
}