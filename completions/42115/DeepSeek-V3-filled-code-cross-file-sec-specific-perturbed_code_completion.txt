if(len < sizeof(dNSName)) {
  strncpy(dNSName, (const char*)&packet->payload[i+2], len);
  dNSName[len] = '\0';

  if(ndpi_is_printable_string(dNSName, len)) {
    if(connection->host_server_name[0] != '\0') {
      if(strcasecmp(dNSName, connection->host_server_name) == 0)
        matched_name = 1;
    }

    if(connection->protos.tls_quic.server_names == NULL) {
      connection->protos.tls_quic.server_names = ndpi_strdup(dNSName);
    } else {
      char *new_server_names;
      u_int new_len = strlen(connection->protos.tls_quic.server_names) + 1 + len + 1;

      if((new_server_names = (char*)ndpi_malloc(new_len)) != NULL) {
        snprintf(new_server_names, new_len, "%s,%s", connection->protos.tls_quic.server_names, dNSName);
        ndpi_free(connection->protos.tls_quic.server_names);
        connection->protos.tls_quic.server_names = new_server_names;
      }
    }

    if(connection->detected_protocol_stack[1] == NDPI_PROTOCOL_UNKNOWN) {
      u_int32_t val;
      int rc = ndpi_match_string_value(ndpi_struct->tls_cert_subject_automa.ac_automa,
                                      dNSName, strlen(dNSName), &val);

      if(rc == 0) {
        u_int16_t proto_id = (u_int16_t)val;
        ndpi_protocol ret = { NDPI_PROTOCOL_TLS, proto_id, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED };

        connection->detected_protocol_stack[0] = proto_id;
        connection->detected_protocol_stack[1] = NDPI_PROTOCOL_TLS;
        connection->category = ndpi_get_proto_category(ndpi_struct, ret);
        ndpi_check_subprotocol_risk(ndpi_struct, connection, proto_id);
      }
    }
  }
}
i += 2 + len;