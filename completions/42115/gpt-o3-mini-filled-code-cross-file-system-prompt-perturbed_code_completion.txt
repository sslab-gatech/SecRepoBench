{
  if(len < sizeof(dNSName)) {
    memcpy(dNSName, &packet->payload[i+2], len);
    dNSName[len] = '\0';

    /* Ensure the extracted name is printable */
    if(ndpi_is_printable_string(dNSName, len) == 0) {
      ndpi_set_risk(ndpi_struct, connection, NDPI_TLS_SUSPICIOUS_EXTENSION);
    } else {
      /* If the host server name was already set and matches the extracted DNS name, mark as a match */
      if(connection->host_server_name[0] != '\0' && strcmp(connection->host_server_name, dNSName) == 0)
        matched_name = 1;

      /* Update the server names list in the flow structure.
         If not initialized, set it; otherwise append with a comma separator. */
      if(connection->host_server_name[0] == '\0') {
        connection->host_server_name = ndpi_strdup(dNSName);
      } else {
        char tmp[512];
        snprintf(tmp, sizeof(tmp), "%s,%s", connection->host_server_name, dNSName);
        free(connection->host_server_name);
        connection->host_server_name = ndpi_strdup(tmp);
      }

      /* Attempt to detect a subprotocol based on the DNS name.
         For example, if the DNS name contains "xmpp" or "sip", update the detected protocol. */
      if(strstr(dNSName, "xmpp") != NULL) {
        connection->detected_protocol_stack[0] = NDPI_PROTOCOL_XMPP;
      } else if(strstr(dNSName, "sip") != NULL) {
        connection->detected_protocol_stack[0] = NDPI_PROTOCOL_SIP;
      }
    }
  }
}