// Parse the payload to extract the DNS name or IP address from the subjectAltName extension.
if(general_name_type == 0x81) { /* rfc822Name */
  u_int8_t len = packet->payload[i + 1];
  char rfc822Name[256] = { '\0' };

  if(len < (sizeof(rfc822Name)-1)) {
    strncpy(rfc822Name, (const char*)&packet->payload[i + 2], len);
    rfc822Name[len] = '\0';

    // Clean up the extracted DNS name and ensure it is printable.
    if(ndpi_is_printable_string(rfc822Name, len) == 0) {
      ndpi_set_risk(ndpi_struct, connection, NDPI_INVALID_CHARACTERS);
    }

    // Check if the extracted DNS name matches the host server name.
    if(strcmp(connection->host_server_name, rfc822Name) == 0) {
      matched_name = 1;
    }

    // Update the server names list in the flow structure.
    if(connection->protos.tls_quic.server_names == NULL) {
      connection->protos.tls_quic.server_names = ndpi_strdup(rfc822Name);
    } else {
      char *new_server_names = (char*)ndpi_calloc(strlen(connection->protos.tls_quic.server_names) + strlen(rfc822Name) + 2, sizeof(char));
      sprintf(new_server_names, "%s, %s", connection->protos.tls_quic.server_names, rfc822Name);
      ndpi_free(connection->protos.tls_quic.server_names);
      connection->protos.tls_quic.server_names = new_server_names;
    }

    // Attempt to detect a subprotocol based on the DNS name and update the flow structure accordingly.
    if(ndpi_struct->tls_cert_subject_automa.ac_automa!= NULL) {
      u_int32_t val;
      int rc = ndpi_match_string_value(ndpi_struct->tls_cert_subject_automa.ac_automa,
				       rfc822Name, strlen(rfc822Name), &val);

      if(rc == 0) {
	/* Match found */
	u_int16_t proto_id = (u_int16_t)val;
	ndpi_protocol ret = { NDPI_PROTOCOL_TLS, proto_id, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED};

	connection->detected_protocol_stack[0] = proto_id,
	  connection->detected_protocol_stack[1] = NDPI_PROTOCOL_TLS;

	connection->category = ndpi_get_proto_category(ndpi_struct, ret);
	ndpi_check_subprotocol_risk(ndpi_struct, connection, proto_id);
      }
    }
  }
} else if(general_name_type == 0x82) { /* dNSName */
  u_int8_t len = packet->payload[i + 1];
  char dNSName[256] = { '\0' };

  if(len < (sizeof(dNSName)-1)) {
    strncpy(dNSName, (const char*)&packet->payload[i + 2], len);
    dNSName[len] = '\0';

    // Clean up the extracted DNS name and ensure it is printable.
    if(ndpi_is_printable_string(dNSName, len) == 0) {
      ndpi_set_risk(ndpi_struct, connection, NDPI_INVALID_CHARACTERS);
    }

    // Check if the extracted DNS name matches the host server name.
    if(strcmp(connection->host_server_name, dNSName) == 0) {
      matched_name = 1;
    }

    // Update the server names list in the flow structure.
    if(connection->protos.tls_quic.server_names == NULL) {
      connection->protos.tls_quic.server_names = ndpi_strdup(dNSName);
    } else {
      char *new_server_names = (char*)ndpi_calloc(strlen(connection->protos.tls_quic.server_names) + strlen(dNSName) + 2, sizeof(char));
      sprintf(new_server_names, "%s, %s", connection->protos.tls_quic.server_names, dNSName);
      ndpi_free(connection->protos.tls_quic.server_names);
      connection->protos.tls_quic.server_names = new_server_names;
    }

    // Attempt to detect a subprotocol based on the DNS name and update the flow structure accordingly.
    if(ndpi_struct->tls_cert_subject_automa.ac_automa!= NULL) {
      u_int32_t val;
      int rc = ndpi_match_string_value(ndpi_struct->tls_cert_subject_automa.ac_automa,
				       dNSName, strlen(dNSName), &val);

      if(rc == 0) {
	/* Match found */
	u_int16_t proto_id = (u_int16_t)val;
	ndpi_protocol ret = { NDPI_PROTOCOL_TLS, proto_id, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED};

	connection->detected_protocol_stack[0] = proto_id,
	  connection->detected_protocol_stack[1] = NDPI_PROTOCOL_TLS;

	connection->category = ndpi_get_proto_category(ndpi_struct, ret);
	ndpi_check_subprotocol_risk(ndpi_struct, connection, proto_id);
      }
    }
  }
} else if(general_name_type == 0x87) { /* ipAddress */
  u_int8_t len = packet->payload[i + 1];
  char ipAddress[64] = { '\0' };

  if(len == 4) { /* IPv4 */
    sprintf(ipAddress, "%u.%u.%u.%u",
	    packet->payload[i + 2], packet->payload[i + 3],
	    packet->payload[i + 4], packet->payload[i + 5]);
  } else if(len == 16) { /* IPv6 */
    sprintf(ipAddress, "%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x",
	    packet->payload[i + 2], packet->payload[i + 3],
	    packet->payload[i + 4], packet->payload[i + 5],
	    packet->payload[i + 6], packet->payload[i + 7],
	    packet->payload[i + 8], packet->payload[i + 9],
	    packet->payload[i + 10], packet->payload[i + 11],
	    packet->payload[i + 12], packet->payload[i + 13],
	    packet->payload[i + 14], packet->payload[i + 15],
	    packet->payload[i + 16], packet->payload[i + 17]);
  }

  // Check if the extracted IP address matches the host server IP address.
  if(strcmp(connection->host_server_ip, ipAddress) == 0) {
    matched_name = 1;
  }

  // Update the server names list in the flow structure.
  if(connection->protos.tls_quic.server_names == NULL) {
    connection->protos.tls_quic.server_names = ndpi_strdup(ipAddress);
  } else {
    char *new_server_names = (char*)ndpi_calloc(strlen(connection->protos.tls_quic.server_names) + strlen(ipAddress) + 2, sizeof(char));
    sprintf(new_server_names, "%s, %s", connection->protos.tls_quic.server_names, ipAddress);
    ndpi_free(connection->protos.tls_quic.server_names);
    connection->protos.tls_quic.server_names = new_server_names;
  }
}