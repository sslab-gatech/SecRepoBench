// Parse the payload to extract the DNS name or IP address from the subjectAltName extension.
// Convert the extracted address to a string format for IPv4 and IPv6.
// Clean up the extracted DNS name and ensure it is printable.
// Check if the extracted DNS name matches the host server name.
// If a match is found, set the matched_name flag and update the server names list in the flow structure.
// If the server names list is not initialized, create a new entry for the current DNS name.
// If the server names list already exists, append the current DNS name to it with a comma separator.
// Attempt to detect a subprotocol based on the DNS name and update the flow structure accordingly.
// <MASK>
if((general_name_type == 0x81)    /* rfc822Name */
   || (general_name_type == 0x82) /* dNSName    */
   || (general_name_type == 0x87) /* ipAddress  */
   )
{
  if((i < (packet->payload_packet_len - 1))
     && ((i + packet->payload[i + 1] + 2) < packet->payload_packet_len)) {
    u_int8_t len = packet->payload[i + 1];
    char dNSName[256];
    char ipAddr[INET6_ADDRSTRLEN];
    char *serverName = NULL;
    int matched_name = 0;

    if(general_name_type == 0x81) { /* rfc822Name */
      // Parse the payload to extract the email address from the subjectAltName extension.
      // Clean up the extracted email address and ensure it is printable.
      // Check if the extracted email address matches the host server name.
      // If a match is found, set the matched_name flag and update the server names list in the flow structure.
      // If the server names list is not initialized, create a new entry for the current email address.
      // If the server names list already exists, append the current email address to it with a comma separator.
      // Attempt to detect a subprotocol based on the email address and update the flow structure accordingly.
      // <MASK>
    } else if(general_name_type == 0x82) { /* dNSName */
      // Parse the payload to extract the DNS name from the subjectAltName extension.
      // Convert the extracted DNS name to a string format.
      // Clean up the extracted DNS name and ensure it is printable.
      // Check if the extracted DNS name matches the host server name.
      // If a match is found, set the matched_name flag and update the server names list in the flow structure.
      // If the server names list is not initialized, create a new entry for the current DNS name.
      // If the server names list already exists, append the current DNS name to it with a comma separator.
      // Attempt to detect a subprotocol based on the DNS name and update the flow structure accordingly.
      // <MASK>
      if(packet->payload[i + 2] == 0x00) {
        // IPv4 address
        struct in_addr ip;
        inet_pton(AF_INET, (char*)&packet->payload[i + 3], &ip);
        inet_ntop(AF_INET, &ip, ipAddr, INET_ADDRSTRLEN);
      } else {
        // IPv6 address
        struct in6_addr ip;
        inet_pton(AF_INET6, (char*)&packet->payload[i + 3], &ip);
        inet_ntop(AF_INET6, &ip, ipAddr, INET6_ADDRSTRLEN);
      }
      serverName = ipAddr;
    } else if(general_name_type == 0x87) { /* ipAddress */
      // Parse the payload to extract the IP address from the subjectAltName extension.
      // Convert the extracted IP address to a string format.
      // Clean up the extracted IP address and ensure it is printable.
      // Check if the extracted IP address matches the host server name.
      // If a match is found, set the matched_name flag and update the server names list in the flow structure.
      // If the server names list is not initialized, create a new entry for the current IP address.
      // If the server names list already exists, append the current IP address to it with a comma separator.
      // Attempt to detect a subprotocol based on the IP address and update the flow structure accordingly.
      // <MASK>
    }

    if(serverName!= NULL) {
      if(flow->host_server_name[0] == '\0') {
        matched_name = 1;
        flow->host_server_name = ndpi_strdup(serverName);
      } else {
        if(strstr(flow->host_server_name, serverName) == NULL) {
          if(flow->server_names == NULL) {
            flow->server_names = ndpi_strdup(serverName);
          } else {
            char *new_server_names = ndpi_realloc(flow->server_names, strlen(flow->server_names) + strlen(serverName) + 2);
            if(new_server_names!= NULL) {
              strcat(new_server_names, ",");
              strcat(new_server_names, serverName);
              flow->server_names = new_server_names;
            }
          }
        }
      }

      if(matched_name) {
        if(flow->detected_protocol_stack[1] == NDPI_PROTOCOL_UNKNOWN) {
          // Attempt to detect a subprotocol based on the DNS name and update the flow structure accordingly.
          // <MASK>
        }
      }
    }

    i += len;
  } else {
#if DEBUG_TLS
    printf("[TLS] Leftover %u bytes", packet->payload_packet_len - i);
#endif
    ndpi_set_risk(ndpi_struct, connection, NDPI_TLS_SUSPICIOUS_EXTENSION);
    break;
  }
}