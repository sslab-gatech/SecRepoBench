if (general_name_type == 0x82) { // dNSName
  u_int8_t len = packet->payload[i + 1];
  char dNSName[256];
  
  if (len < sizeof(dNSName) - 1) {
    memcpy(dNSName, &packet->payload[i + 2], len);
    dNSName[len] = '\0';
    
    // Check if the DNS name is printable
    if (ndpi_is_printable_string(dNSName, len) == 0) {
      ndpi_set_risk(ndpi_struct, flow, NDPI_INVALID_CHARACTERS);
    } else {
      // Clean up the DNS name
      cleanupServerName(dNSName, strlen(dNSName));
      
      // Check if the DNS name matches the host server name
      if (dNSName[0] != '\0' && flow->host_server_name[0] != '\0') {
        if (strcasecmp(dNSName, flow->host_server_name) == 0) {
          matched_name = 1;
        }
      }
      
      // Update server names list
      if (flow->protos.tls_quic.server_names == NULL) {
        flow->protos.tls_quic.server_names = ndpi_strdup(dNSName);
      } else {
        u_int len = strlen(flow->protos.tls_quic.server_names) + strlen(dNSName) + 2;
        char *newstr = ndpi_malloc(len);
        
        if (newstr) {
          snprintf(newstr, len, "%s,%s", flow->protos.tls_quic.server_names, dNSName);
          ndpi_free(flow->protos.tls_quic.server_names);
          flow->protos.tls_quic.server_names = newstr;
        }
      }
      
      // Try to detect a subprotocol
      if (!flow->protos.tls_quic.subprotocol_detected) {
        if (ndpi_match_hostname_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TLS, dNSName, strlen(dNSName)))
          flow->protos.tls_quic.subprotocol_detected = 1;
      }
    }
  }
} else if (general_name_type == 0x87) { // ipAddress
  u_int8_t len = packet->payload[i + 1];
  char ipAddress[INET6_ADDRSTRLEN]; // Large enough for IPv6
  
  if (len == 4) { // IPv4
    struct in_addr addr;
    memcpy(&addr, &packet->payload[i + 2], 4);
    inet_ntop(AF_INET, &addr, ipAddress, sizeof(ipAddress));
  } else if (len == 16) { // IPv6
    struct in6_addr addr;
    memcpy(&addr, &packet->payload[i + 2], 16);
    inet_ntop(AF_INET6, &addr, ipAddress, sizeof(ipAddress));
  } else {
    // Invalid length for IP address
    ipAddress[0] = '\0';
  }
  
  if (ipAddress[0] != '\0') {
    // Check if the IP address matches the host server name
    if (flow->host_server_name[0] != '\0') {
      if (strcmp(ipAddress, flow->host_server_name) == 0) {
        matched_name = 1;
      }
    }
    
    // Update server names list
    if (flow->protos.tls_quic.server_names == NULL) {
      flow->protos.tls_quic.server_names = ndpi_strdup(ipAddress);
    } else {
      u_int len = strlen(flow->protos.tls_quic.server_names) + strlen(ipAddress) + 2;
      char *newstr = ndpi_malloc(len);
      
      if (newstr) {
        snprintf(newstr, len, "%s,%s", flow->protos.tls_quic.server_names, ipAddress);
        ndpi_free(flow->protos.tls_quic.server_names);
        flow->protos.tls_quic.server_names = newstr;
      }
    }
  }
} else if (general_name_type == 0x81) { // rfc822Name (email)
  u_int8_t len = packet->payload[i + 1];
  char rfc822Name[256];
  
  if (len < sizeof(rfc822Name) - 1) {
    memcpy(rfc822Name, &packet->payload[i + 2], len);
    rfc822Name[len] = '\0';
    
    // Check if the email is printable
    if (ndpi_is_printable_string(rfc822Name, len) == 0) {
      ndpi_set_risk(ndpi_struct, flow, NDPI_INVALID_CHARACTERS);
    } else {
      // Update server names list
      if (flow->protos.tls_quic.server_names == NULL) {
        flow->protos.tls_quic.server_names = ndpi_strdup(rfc822Name);
      } else {
        u_int len = strlen(flow->protos.tls_quic.server_names) + strlen(rfc822Name) + 2;
        char *newstr = ndpi_malloc(len);
        
        if (newstr) {
          snprintf(newstr, len, "%s,%s", flow->protos.tls_quic.server_names, rfc822Name);
          ndpi_free(flow->protos.tls_quic.server_names);
          flow->protos.tls_quic.server_names = newstr;
        }
      }
    }
  }
}