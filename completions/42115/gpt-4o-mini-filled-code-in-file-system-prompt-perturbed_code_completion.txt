if((i < (packet->payload_len - 1)) && (packet->payload[i + 1] != 0x00)) {
            u_int8_t len = packet->payload[i + 1];
            char dNSName[256];

            if((i + 2 + len) <= packet->payload_len) {
              memcpy(dNSName, &packet->payload[i + 2], len);
              dNSName[len] = '\0';

              // Clean up the extracted DNS name
              cleanupServerName(dNSName, len);

              // Check if the extracted DNS name matches the host server name
              if(strcmp(dNSName, flow->host_server_name) == 0) {
                matched_name = 1;
              }

              // If the server names list is not initialized, create a new entry
              if(flow->protos.tls_quic.server_names == NULL) {
                flow->protos.tls_quic.server_names = ndpi_strdup(dNSName);
              } else {
                // If the server names list already exists, append the current DNS name
                char *new_names = (char *)ndpi_malloc(strlen(flow->protos.tls_quic.server_names) + strlen(dNSName) + 2);
                sprintf(new_names, "%s,%s", flow->protos.tls_quic.server_names, dNSName);
                ndpi_free(flow->protos.tls_quic.server_names);
                flow->protos.tls_quic.server_names = new_names;
              }
            }
          }