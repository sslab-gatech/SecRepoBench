/* Parse the payload to extract the DNS name or IP address from the subjectAltName extension.
 * Convert the extracted address to a string format for IPv4 and IPv6.
 * Clean up the extracted DNS name and ensure it is printable.
 * Check if the extracted DNS name matches the host server name.
 * If a match is found, set the matched_name flag and update the server names list in the flow structure.
 * If the server names list is not initialized, create a new entry for the current DNS name.
 * If the server names list already exists, append the current DNS name to it with a comma separator.
 * Attempt to detect a subprotocol based on the DNS name and update the flow structure accordingly.
 */
if((general_name_type == 0x82) /* dNSName */) {
    u_int8_t len = packet->payload[i + 1];
    char dNSName[256];
    if(len < sizeof(dNSName)) {
        strncpy(dNSName, (const char*)&packet->payload[i + 2], len);
        dNSName[len] = '\0';
        cleanupServerName(dNSName, len);
        if(ndpi_is_printable_string(dNSName, len)) {
            if(strcmp(dNSName, flow->host_server_name) == 0) {
                matched_name = 1;
            }
            if(flow->server_names == NULL) {
                flow->server_names = ndpi_strdup(dNSName);
            } else {
                char *new_server_names = ndpi_malloc(strlen(flow->server_names) + len + 2);
                sprintf(new_server_names, "%s,%s", flow->server_names, dNSName);
                ndpi_free(flow->server_names);
                flow->server_names = new_server_names;
            }
            if(!is_quic) {
                if(ndpi_match_hostname_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TLS, dNSName, len))
                    flow->protos.tls_quic.subprotocol_detected = 1;
            } else {
                if(ndpi_match_hostname_protocol(ndpi_struct, flow, NDPI_PROTOCOL_QUIC, dNSName, len))
                    flow->protos.tls_quic.subprotocol_detected = 1;
            }
        } else {
            ndpi_set_risk(ndpi_struct, connection, NDPI_INVALID_CHARACTERS);
        }
    }
    i += len;
} else if((general_name_type == 0x87) /* ipAddress */) {
    u_int8_t len = packet->payload[i + 1];
    char ipAddress[46];
    if(len == 4) {
        /* IPv4 */
        sprintf(ipAddress, "%u.%u.%u.%u",
                packet->payload[i + 2],
                packet->payload[i + 3],
                packet->payload[i + 4],
                packet->payload[i + 5]);
    } else if(len == 16) {
        /* IPv6 */
        sprintf(ipAddress, "%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x",
                packet->payload[i + 2], packet->payload[i + 3],
                packet->payload[i + 4], packet->payload[i + 5],
                packet->payload[i + 6], packet->payload[i + 7],
                packet->payload[i + 8], packet->payload[i + 9],
                packet->payload[i + 10], packet->payload[i + 11],
                packet->payload[i + 12], packet->payload[i + 13],
                packet->payload[i + 14], packet->payload[i + 15],
                packet->payload[i + 16], packet->payload[i + 17]);
    } else {
        ndpi_set_risk(ndpi_struct, connection, NDPI_TLS_SUSPICIOUS_EXTENSION);
    }
    if(strcmp(ipAddress, flow->host_server_name) == 0) {
        matched_name = 1;
    }
    if(flow->server_names == NULL) {
        flow->server_names = ndpi_strdup(ipAddress);
    } else {
        char *new_server_names = ndpi_malloc(strlen(flow->server_names) + strlen(ipAddress) + 2);
        sprintf(new_server_names, "%s,%s", flow->server_names, ipAddress);
        ndpi_free(flow->server_names);
        flow->server_names = new_server_names;
    }
    i += len;
} else {
    ndpi_set_risk(ndpi_struct, connection, NDPI_TLS_SUSPICIOUS_EXTENSION);
    break;
}