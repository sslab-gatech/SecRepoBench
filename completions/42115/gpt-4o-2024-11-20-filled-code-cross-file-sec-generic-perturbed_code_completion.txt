if(len < sizeof(dNSName)) {
		    strncpy(dNSName, (const char*)&packet->payload[i + 2], len);
		    dNSName[len] = '\0';

		    /* Ensure the extracted name is printable */
		    if(ndpi_is_printable_string(dNSName, len)) {
		      /* Check if the extracted name matches the host server name */
		      if(strcasecmp(dNSName, connection->host_server_name) == 0) {
		        matched_name = 1;
		      }

		      /* Update the server names list in the flow structure */
		      if(connection->protos.tls_quic.server_names == NULL) {
		        connection->protos.tls_quic.server_names = ndpi_strdup(dNSName);
		      } else {
		        char *new_server_names = ndpi_strcat(connection->protos.tls_quic.server_names, ",");
		        if(new_server_names) {
		          connection->protos.tls_quic.server_names = ndpi_strcat(new_server_names, dNSName);
		        }
		      }

		      /* Attempt to detect a subprotocol based on the DNS name */
		      checkTLSSubprotocol(ndpi_struct, connection, 0);
		    } else {
		      ndpi_set_risk(ndpi_struct, connection, NDPI_INVALID_CHARACTERS);
		    }
		  }