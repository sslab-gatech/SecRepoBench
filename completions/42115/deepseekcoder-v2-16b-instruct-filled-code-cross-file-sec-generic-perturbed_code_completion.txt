// Parse the payload to extract the DNS name or IP address from the subjectAltName extension.
// Convert the extracted address to a string format for IPv4 and IPv6.
// Clean up the extracted DNS name and ensure it is printable.
// Check if the extracted DNS name matches the host server name.
// If a match is found, set the matched_name flag and update the server names list in the flow structure.
// If the server names list is not initialized, create a new entry for the current DNS name.
// If the server names list already exists, append the current DNS name to it with a comma separator.
// Attempt to detect a subprotocol based on the DNS name and update the flow structure accordingly.

char dNSName[256];
u_int8_t *payload = &packet->payload[i];
u_int len = packet->payload[i + 1];
u_int offset = i + 2;

if (len > sizeof(dNSName) - 1) {
  len = sizeof(dNSName) - 1;
}

memcpy(dNSName, payload, len);
dNSName[len] = '\0';

if (ndpi_is_printable_string(dNSName, len) == 0) {
  ndpi_set_risk(ndpi_struct, connection, NDPI_INVALID_CHARACTERS);
  return;
}

if (strcmp(dNSName, connection->host_server_name) == 0) {
  matched_name = 1;
}

if (connection->protos.tls_quic.server_names == NULL) {
  connection->protos.tls_quic.server_names = ndpi_strdup(dNSName);
} else {
  char *temp = connection->protos.tls_quic.server_names;
  connection->protos.tls_quic.server_names = ndpi_strcat(temp, ",");
  connection->protos.tls_quic.server_names = ndpi_strcat(connection->protos.tls_quic.server_names, dNSName);
  free(temp);
}

// Attempt to detect a subprotocol based on the DNS name and update the flow structure accordingly.
// This part is simplified and may need further implementation based on actual subprotocol detection logic.
if (matched_name) {
  // Update the flow structure with the detected subprotocol.
  // This is a placeholder for actual subprotocol detection logic.
  // Example:
  // ndpi_protocol ret = detect_subprotocol(dNSName);
  // if (ret != NDPI_PROTOCOL_UNKNOWN) {
  //   flow->detected_subprotocol = ret;
  // }
}