if(general_name_type == 0x82) {
  if(len > sizeof(dNSName)-1) len = sizeof(dNSName)-1;
  strncpy(dNSName, (const char*)&packet->payload[i+2], len);
  dNSName[len] = '\0';

  if(ndpi_normalize_extracted_hostname(dNSName, sizeof(dNSName), dNSName) == NULL) {
    ndpi_set_risk(ndpi_struct, connection, NDPI_TLS_SUSPICIOUS_EXTENSION);
    break;
    /* Something invalid: let's stop here */
  }

  if(ndpi_is_printable_string(dNSName, len) == 0) {
    ndpi_set_risk(ndpi_struct, connection, NDPI_INVALID_CHARACTERS);
  }

  if(!matched_name && (connection->host_server_name[0] != '\0')) {
    if(ndpi_match_hostname_protocol(ndpi_struct, connection,
				     NDPI_PROTOCOL_TLS,
				     dNSName, strlen(dNSName)) != NDPI_PROTOCOL_TLS) {
      if(strcasecmp(dNSName, connection->host_server_name) == 0)
	matched_name = 1;
    } else
      matched_name = 1; /* Wildcard */
  }

  if(ndpi_is_good_certificate_name(ndpi_struct, connection, dNSName) == 0 /* Bad */)
    ndpi_set_risk(ndpi_struct, connection, NDPI_TLS_SUSPICIOUS_CERTIFICATE);

  if(connection->protos.tls_quic.server_names_len == 0) {
    connection->protos.tls_quic.server_names = ndpi_strdup(dNSName);
    if(!connection->protos.tls_quic.server_names) {
      ndpi_set_risk(ndpi_struct, connection, NDPI_TLS_CERTIFICATE_MISMATCH);
      break;
    }
    connection->protos.tls_quic.server_names_len = strlen(dNSName);
  } else {
    u_int16_t dNSName_len = strlen(dNSName);
    char *old = connection->protos.tls_quic.server_names;
    u_int16_t old_len = connection->protos.tls_quic.server_names_len;
    u_int16_t new_len = old_len + dNSName_len + 1;

    if((new_len > 256 /* Arbitrary limit */)
       || ((connection->protos.tls_quic.server_names = ndpi_realloc(old, old_len+1, new_len)) == NULL)) {
      ndpi_free(old);
      ndpi_set_risk(ndpi_struct, connection, NDPI_TLS_CERTIFICATE_MISMATCH);
      break;
    } else {
      snprintf(&connection->protos.tls_quic.server_names[old_len], new_len,
	       ",%s", dNSName);
      connection->protos.tls_quic.server_names_len = new_len-1;
    }
  }

  ndpi_check_dga_name(ndpi_struct, connection,
		      dNSName, 1 /* Check also subdomains */ );

  checkTLSSubprotocol(ndpi_struct, connection, 0);
} else if(general_name_type == 0x87) { /* IP Address */
  char buf[48];
  u_int8_t buf_len = sizeof(buf);

  if((len == 4) || (len == 16)) {
    ndpi_network_ntoa((struct sockaddr *)&packet->payload[i+2], buf, &buf_len);

    if(ndpi_is_printable_string(buf, buf_len) == 0) {
      ndpi_set_risk(ndpi_struct, connection, NDPI_INVALID_CHARACTERS);
    }

    if(!matched_name) {
      if(strcmp(buf, connection->host_server_name) == 0)
	matched_name = 1;
    }
  }
}