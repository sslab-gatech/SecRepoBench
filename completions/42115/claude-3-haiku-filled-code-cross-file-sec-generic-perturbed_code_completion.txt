// Parse the payload to extract the DNS name or IP address from the subjectAltName extension.
char dNSName[256];
int dNSNameLen = 0;
int i = 0;
while (i < packet->payload_packet_len) {
    u_int8_t general_name_type = packet->payload[i];
    if (general_name_type == 0x82) { // dNSName
        i++;
        u_int8_t len = packet->payload[i++];
        if ((i + len) <= packet->payload_packet_len) {
            strncpy(dNSName, (const char*)&packet->payload[i], len);
            dNSName[len] = '\0';
            dNSNameLen = len;
            i += len;
        } else {
            ndpi_set_risk(ndpi_struct, connection, NDPI_TLS_SUSPICIOUS_EXTENSION);
            break;
        }
    } else {
        break;
    }
}

// Convert the extracted address to a string format for IPv4 and IPv6.
char addressStr[INET6_ADDRSTRLEN];
if (general_name_type == 0x87) { // ipAddress
    i++;
    u_int8_t len = packet->payload[i++];
    if ((i + len) <= packet->payload_packet_len) {
        if (len == 4) { // IPv4
            struct in_addr addr;
            memcpy(&addr, &packet->payload[i], len);
            inet_ntop(AF_INET, &addr, addressStr, sizeof(addressStr));
        } else if (len == 16) { // IPv6
            struct in6_addr addr;
            memcpy(&addr, &packet->payload[i], len);
            inet_ntop(AF_INET6, &addr, addressStr, sizeof(addressStr));
        } else {
            ndpi_set_risk(ndpi_struct, connection, NDPI_TLS_SUSPICIOUS_EXTENSION);
            break;
        }
        i += len;
    } else {
        ndpi_set_risk(ndpi_struct, connection, NDPI_TLS_SUSPICIOUS_EXTENSION);
        break;
    }
}

// Clean up the extracted DNS name and ensure it is printable.
if (dNSNameLen > 0) {
    if (!ndpi_is_printable_string(dNSName, dNSNameLen)) {
        ndpi_set_risk(ndpi_struct, connection, NDPI_INVALID_CHARACTERS);
    }
    ndpi_normalize_string(dNSName, dNSNameLen);
}

// Check if the extracted DNS name matches the host server name.
if (connection->host_server_name[0] != '\0' && strcasecmp(connection->host_server_name, dNSName) == 0) {
    matched_name = 1;
    if (connection->server_names == NULL) {
        connection->server_names = ndpi_strdup(dNSName);
    } else {
        char* temp = ndpi_malloc(strlen(connection->server_names) + strlen(dNSName) + 2);
        sprintf(temp, "%s,%s", connection->server_names, dNSName);
        ndpi_free(connection->server_names);
        connection->server_names = temp;
    }
}

// Attempt to detect a subprotocol based on the DNS name and update the flow structure accordingly.
if (matched_name) {
    u_int32_t val;
    int rc = ndpi_match_string_value(ndpi_struct->tls_cert_subject_automa.ac_automa, dNSName, strlen(dNSName), &val);
    if (rc == 0) {
        u_int16_t proto_id = (u_int16_t)val;
        ndpi_protocol ret = { NDPI_PROTOCOL_TLS, proto_id, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED };
        connection->detected_protocol_stack[0] = proto_id;
        connection->detected_protocol_stack[1] = NDPI_PROTOCOL_TLS;
        connection->category = ndpi_get_proto_category(ndpi_struct, ret);
        ndpi_check_subprotocol_risk(ndpi_struct, connection, proto_id);
    }
}