// Parse the payload to extract the DNS name or IP address from the subjectAltName extension.
u_int8_t len = packet->payload[i + 1];
char dNSName[256];
strncpy(dNSName, (const char*)&packet->payload[i + 2], len);
dNSName[len] = '\0';

// Convert the extracted address to a string format for IPv4 and IPv6.
if(general_name_type == 0x87) {
  struct in_addr ipv4;
  struct in6_addr ipv6;
  if(len == 4) {
    ipv4.s_addr = *(u_int32_t*)&packet->payload[i + 2];
    inet_ntop(AF_INET, &ipv4, dNSName, sizeof(dNSName));
  } else if(len == 16) {
    inet_ntop(AF_INET6, &ipv6, dNSName, sizeof(dNSName));
  }
}

// Clean up the extracted DNS name and ensure it is printable.
for(u_int j = 0; j < len; j++) {
  if(!isprint(dNSName[j])) {
    dNSName[j] = '.';
  }
}

// Check if the extracted DNS name matches the host server name.
if(strcmp(dNSName, connection->host_server_name) == 0) {
  matched_name = 1;
}

// Update the server names list in the flow structure.
if(connection->protos.tls_quic.server_names == NULL) {
  connection->protos.tls_quic.server_names = ndpi_strdup(dNSName);
} else {
  char* new_server_names = (char*)ndpi_calloc(strlen(connection->protos.tls_quic.server_names) + strlen(dNSName) + 2, sizeof(char));
  sprintf(new_server_names, "%s, %s", connection->protos.tls_quic.server_names, dNSName);
  ndpi_free(connection->protos.tls_quic.server_names);
  connection->protos.tls_quic.server_names = new_server_names;
}

// Attempt to detect a subprotocol based on the DNS name and update the flow structure accordingly.
if(ndpi_struct->tls_cert_subject_automa.ac_automa!= NULL) {
  u_int32_t val;
  int rc = ndpi_match_string_value(ndpi_struct->tls_cert_subject_automa.ac_automa,
                                   dNSName, strlen(dNSName), &val);
  if(rc == 0) {
    u_int16_t proto_id = (u_int16_t)val;
    ndpi_protocol ret = { NDPI_PROTOCOL_TLS, proto_id, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED };

    connection->detected_protocol_stack[0] = proto_id,
      connection->detected_protocol_stack[1] = NDPI_PROTOCOL_TLS;

    connection->category = ndpi_get_proto_category(ndpi_struct, ret);
    ndpi_check_subprotocol_risk(ndpi_struct, connection, proto_id);
  }
}