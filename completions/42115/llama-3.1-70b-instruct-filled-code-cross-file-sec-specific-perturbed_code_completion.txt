// Parse the payload to extract the DNS name or IP address from the subjectAltName extension.
u_int8_t len = packet->payload[i + 1];
char dNSName[256];
strncpy(dNSName, (const char*)&packet->payload[i + 2], len);
dNSName[len] = '\0';

// Convert the extracted address to a string format for IPv4 and IPv6.
if (general_name_type == 0x87) { // ipAddress
  struct in_addr ipv4;
  struct in6_addr ipv6;
  if (len == 4) { // IPv4
    ipv4.s_addr = *(u_int32_t*)&packet->payload[i + 2];
    inet_ntop(AF_INET, &ipv4, dNSName, sizeof(dNSName));
  } else if (len == 16) { // IPv6
    ipv6 = *(struct in6_addr*)&packet->payload[i + 2];
    inet_ntop(AF_INET6, &ipv6, dNSName, sizeof(dNSName));
  }
}

// Clean up the extracted DNS name and ensure it is printable.
for (u_int j = 0; j < len; j++) {
  if (!isprint(dNSName[j])) {
    dNSName[j] = '.';
  }
}

// Check if the extracted DNS name matches the host server name.
if (strcmp(dNSName, connection->host_server_name) == 0) {
  matched_name = 1;
}

// Update the server names list in the flow structure.
if (connection->protos.tls_quic.server_names == NULL) {
  connection->protos.tls_quic.server_names = ndpi_strdup(dNSName);
} else {
  char* new_server_names = (char*)malloc(strlen(connection->protos.tls_quic.server_names) + strlen(dNSName) + 2);
  sprintf(new_server_names, "%s, %s", connection->protos.tls_quic.server_names, dNSName);
  free(connection->protos.tls_quic.server_names);
  connection->protos.tls_quic.server_names = new_server_names;
}

// Attempt to detect a subprotocol based on the DNS name and update the flow structure accordingly.
if (matched_name) {
  // Detect subprotocol based on DNS name
  //...
}