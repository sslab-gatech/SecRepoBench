if(extension_id == 43 /* supported versions */) {
		u_int16_t s_offset = offset+extension_offset + 1;
		u_int16_t tot_supported_versions_len = packet->payload[s_offset-1];

#ifdef DEBUG_TLS
		printf("Client TLS [SUPPORTED_VERSIONS: block_len=%u/len=%u]\n", extension_len, tot_supported_versions_len);
#endif

		if((s_offset+tot_supported_versions_len) <= total_len) {
		  for(i=0; i<tot_supported_versions_len && s_offset+i<total_len; i+=2) {
		    u_int16_t tls_version = ntohs(*((u_int16_t*)&packet->payload[s_offset+i]));

#ifdef DEBUG_TLS
		    printf("Client TLS [SUPPORTED_VERSIONS: %u/0x%04X]\n", tls_version, tls_version);
#endif

		    if((tls_version == 0) || (packet->payload[s_offset+i] != packet->payload[s_offset+i+1])) {
		      /* Skip GREASE */
		      if(ja3.client.supported_versions[0] != '\0')
			strncat(ja3.client.supported_versions, "-", sizeof(ja3.client.supported_versions) - strlen(ja3.client.supported_versions) - 1);

		      char version_str[6];
		      snprintf(version_str, sizeof(version_str), "%u", tls_version);
		      strncat(ja3.client.supported_versions, version_str, sizeof(ja3.client.supported_versions) - strlen(ja3.client.supported_versions) - 1);
		    }
		  }
		} else {
		  invalid_ja3 = 1;
#ifdef DEBUG_TLS
		  printf("Client TLS Invalid len %u vs %u\n", (s_offset+tot_supported_versions_len), total_len);
#endif
		}
	      } else if(extension_id == 65486 /* encrypted server name */) {
		flow->protos.tls_quic.encrypted_sni.esni = ndpi_malloc(extension_len);
		if(flow->protos.tls_quic.encrypted_sni.esni) {
		  memcpy(flow->protos.tls_quic.encrypted_sni.esni, &packet->payload[offset+extension_offset], extension_len);
		  flow->protos.tls_quic.encrypted_sni.esni_len = extension_len;
#ifdef DEBUG_TLS
		  printf("Client TLS [ENCRYPTED_SERVER_NAME: len=%u]\n", extension_len);
#endif
		}
	      } else if(extension_id == 65445 /* quic transport parameters */) {
		u_int16_t s_offset = offset+extension_offset;
		u_int16_t tot_quic_transport_params_len = extension_len;

#ifdef DEBUG_TLS
		printf("Client TLS [QUIC_TRANSPORT_PARAMS: block_len=%u/len=%u]\n", extension_len, tot_quic_transport_params_len);
#endif

		if((s_offset+tot_quic_transport_params_len) <= total_len) {
		  u_int16_t ua_len = 0;
		  const u_int8_t *ua_ptr = NULL;

		  for(i=0; i<tot_quic_transport_params_len && s_offset+i<total_len; i++) {
		    if((s_offset+i+1) < total_len) {
		      u_int16_t param_id = packet->payload[s_offset+i];
		      u_int16_t param_len = packet->payload[s_offset+i+1];

		      if((s_offset+i+2+param_len) <= total_len) {
			if(param_id == 0x00) { /* user_agent */
			  ua_len = param_len;
			  ua_ptr = &packet->payload[s_offset+i+2];
			}
			i += 1 + param_len;
		      } else {
			break;
		      }
		    }
		  }

		  if(ua_ptr && ua_len) {
		    http_process_user_agent(ndpi_struct, flow, ua_ptr, ua_len);
		  }
		}
	      }