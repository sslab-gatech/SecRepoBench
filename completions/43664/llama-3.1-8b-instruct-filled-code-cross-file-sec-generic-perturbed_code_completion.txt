} else if(extension_id == 16 /* application_layer_protocol_negotiation */ &&
          offset+extension_offset+1 < total_len) {
  u_int16_t s_offset = offset+extension_offset;
  u_int16_t tot_alpn_len = ntohs(*((u_int16_t*)&packet->payload[s_offset]));
  char alpn_str[256];
  u_int8_t alpn_str_len = 0, i;

#ifdef DEBUG_TLS
  printf("Client TLS [ALPN: block_len=%u/len=%u]\n", extension_len, tot_alpn_len);
#endif
  s_offset += 2;
  tot_alpn_len += s_offset;

  while(s_offset < tot_alpn_len && s_offset < total_len) {
    u_int8_t alpn_i, alpn_len = packet->payload[s_offset++];

    if((s_offset + alpn_len) <= tot_alpn_len &&
       (s_offset + alpn_len) <= total_len) {
#ifdef DEBUG_TLS
      printf("Client TLS [ALPN: %u]\n", alpn_len);
#endif

      if(((uint32_t)alpn_str_len+alpn_len+1) < (sizeof(alpn_str)-1)) {
        if(alpn_str_len > 0) {
          alpn_str[alpn_str_len] = ',';
          alpn_str_len++;
        }

        for(alpn_i=0; alpn_i<alpn_len; alpn_i++)
          alpn_str[alpn_str_len+alpn_i] = packet->payload[s_offset+alpn_i];

        s_offset += alpn_len, alpn_str_len += alpn_len;;
      } else
        break;
    } else
      break;
  } /* while */

  alpn_str[alpn_str_len] = '\0';

#ifdef DEBUG_TLS
  printf("Client TLS [ALPN: %s][len: %u]\n", alpn_str, alpn_str_len);
#endif
  if(flow->protos.tls_quic.alpn == NULL)
    flow->protos.tls_quic.alpn = ndpi_strdup(alpn_str);

  snprintf(ja3.client.alpn, sizeof(ja3.client.alpn), "%s", alpn_str);

  /* Replace, with - as in JA3 */
  for(i=0; ja3.client.alpn[i]!= '\0'; i++)
    if(ja3.client.alpn[i] == ',') ja3.client.alpn[i] = '-';

  // Process the TLS extensions in the client's "Client Hello" message.
  // For the "supported versions" extension, extract and store the supported TLS versions in the flow structure.
  // For the "encrypted server name" extension, extract and store the encrypted SNI details if present.
  // For the "QUIC transport parameters" extension, extract transport parameters and process the user agent if available.
  // Continue processing any additional extensions that are part of the Client Hello message.
  if(extension_id == 5 /* supported_versions */) {
    u_int16_t s_offset = offset+extension_offset + 2;

#ifdef DEBUG_TLS
    printf("Client TLS [SupportedVersions: len=%u]\n", extension_len);
#endif

    if((s_offset+extension_len-2) <= total_len) {
      for(i=0; i<(u_int32_t)extension_len-2 && s_offset + i + 1 < total_len; i += 2) {
        u_int16_t s_version = ntohs(*((u_int16_t*)&packet->payload[s_offset+i]));

#ifdef DEBUG_TLS
        printf("Client TLS [SupportedVersion: %u/0x%04X]\n", s_version, s_version);
#endif
        if((s_version == 0) || (packet->payload[s_offset+i]!= packet->payload[s_offset+i+1])) {
          /* Skip GREASE */
          if(ja3.client.num_supported_versions < MAX_NUM_JA3)
            ja3.client.supported_versions[ja3.client.num_supported_versions++] = s_version;
          else {
            invalid_ja3 = 1;
#ifdef DEBUG_TLS
            printf("Client TLS Invalid num supported versions %u\n", ja3.client.num_supported_versions);
#endif
          }
        }
      }
    } else {
      invalid_ja3 = 1;
#ifdef DEBUG_TLS
      printf("Client TLS Invalid len %u vs %u\n", (s_offset+extension_len-1), total_len);
#endif
    }
  } else if(extension_id == 42 /* encrypted_server_name */) {
    u_int16_t s_offset = offset+extension_offset + 2;

#ifdef DEBUG_TLS
    printf("Client TLS [EncryptedServerName: len=%u]\n", extension_len);
#endif

    if((s_offset+extension_len-2) <= total_len) {
      for(i=0; i<(u_int32_t)extension_len-2 && s_offset + i + 1 < total_len; i += 2) {
        u_int16_t s_len = ntohs(*((u_int16_t*)&packet->payload[s_offset+i]));

#ifdef DEBUG_TLS
        printf("Client TLS [EncryptedServerName: %u/0x%04X]\n", s_len, s_len);
#endif
        if((s_len == 0) || (packet->payload[s_offset+i]!= packet->payload[s_offset+i+1])) {
          /* Skip GREASE */
          if(ja3.client.num_encrypted_sni < MAX_NUM_JA3)
            ja3.client.encrypted_sni[ja3.client.num_encrypted_sni++] = s_len;
          else {
            invalid_ja3 = 1;
#ifdef DEBUG_TLS
            printf("Client TLS Invalid num encrypted sni %u\n", ja3.client.num_encrypted_sni);
#endif
          }
        }
      }
    } else {
      invalid_ja3 = 1;
#ifdef DEBUG_TLS
      printf("Client TLS Invalid len %u vs %u\n", (s_offset+extension_len-1), total_len);
#endif
    }
  } else if(extension_id == 0x00FF /* QUIC transport parameters */) {
    u_int16_t s_offset = offset+extension_offset + 2;

#ifdef DEBUG_TLS
    printf("Client TLS [QUICTransportParameters: len=%u]\n", extension_len);
#endif

    if((s_offset+extension_len-2) <= total_len) {
      for(i=0; i<(u_int32_t)extension_len-2 && s_offset + i + 1 < total_len; i += 2) {
        u_int16_t s_param = ntohs(*((u_int16_t*)&packet->payload[s_offset+i]));

#ifdef DEBUG_TLS
        printf("Client TLS [QUICTransportParameter: %u/0x%04X]\n", s_param, s_param);
#endif
        if((s_param == 0) || (packet->payload[s_offset+i]!= packet->payload[s_offset+i+1])) {
          /* Skip GREASE */
          if(ja3.client.num_quic_transport_params < MAX_NUM_JA3)
            ja3.client.quic_transport_params[ja3.client.num_quic_transport_params++] = s_param;
          else {
            invalid_ja3 = 1;
#ifdef DEBUG_TLS
            printf("Client TLS Invalid num quic transport params %u\n", ja3.client.num_quic_transport_params);
#endif
          }
        }
      }
    } else {
      invalid_ja3 = 1;
#ifdef DEBUG_TLS
      printf("Client TLS Invalid len %u vs %u\n", (s_offset+extension_len-1), total_len);
#endif
    }
  } else if(extension_id == 0x00FE /* user_agent */) {
    u_int16_t s_offset = offset+extension_offset + 2;

#ifdef DEBUG_TLS
    printf("Client TLS [UserAgent: len=%u]\n", extension_len);
#endif

    if((s_offset+extension_len-2) <= total_len) {
      for(i=0; i<(u_int32_t)extension_len-2 && s_offset + i + 1 < total_len; i += 2) {
        u_int16_t s_len = ntohs(*((u_int16_t*)&packet->payload[s_offset+i]));

#ifdef DEBUG_TLS
        printf("Client TLS [UserAgent: %u/0x%04X]\n", s_len, s_len);
#endif
        if((s_len == 0) || (packet->payload[s_offset+i]!= packet->payload[s_offset+i+1])) {
          /* Skip GREASE */
          if(ja3.client.num_user_agent < MAX_NUM_JA3)
            ja3.client.user_agent[ja3.client.num_user_agent++] = s_len;
          else {
            invalid_ja3 = 1;
#ifdef DEBUG_TLS
            printf("Client TLS Invalid num user agent %u\n", ja3.client.num_user_agent);
#endif
          }
        }
      }
    } else {
      invalid_ja3 = 1;
#ifdef DEBUG_TLS
      printf("Client TLS Invalid len %u vs %u\n", (s_offset+extension_len-1), total_len);
#endif
    }
  } else {
    // Process the TLS extensions in the client's "Client Hello" message.
    // For the "supported versions" extension, extract and store the supported TLS versions in the flow structure.
    // For the "encrypted server name" extension, extract and store the encrypted SNI details if present.
    // For the "QUIC transport parameters" extension, extract transport parameters and process the user agent if available.
    // Continue processing any additional extensions that are part of the Client Hello message.
    // <MASK>
  }