else if(extension_id == 43 /* supported versions */) {
  u_int16_t s_offset = offset+extension_offset;
  
  if((s_offset+2) < packet->payload_packet_len) {
    u_int8_t tot_version_len = packet->payload[s_offset+2];
    
#ifdef DEBUG_TLS
    printf("Client TLS [SUPPORTED_VERSIONS: block_len=%u/len=%u]\n", extension_len, tot_version_len);
#endif

    s_offset += 3; /* Skip header and length */
    
    if((tot_version_len > 0) && ((s_offset+tot_version_len) <= packet->payload_packet_len)) {
      ja3.client.supported_versions[0] = '\0'; /* Initialize to empty string */
      
      for(i=0; i < tot_version_len && (s_offset+i+1) < packet->payload_packet_len; i += 2) {
        u_int16_t tls_version = ntohs(*((u_int16_t*)&packet->payload[s_offset+i]));
        
#ifdef DEBUG_TLS
        printf("Client TLS [TLS version: 0x%04X]\n", tls_version);
#endif

        /* Record the highest supported TLS version */
        if(flow->protos.tls_quic.ssl_version < tls_version)
          flow->protos.tls_quic.ssl_version = tls_version;
          
        /* Format for JA3+ */
        if(strlen(ja3.client.supported_versions) == 0) {
          int rc = snprintf(ja3.client.supported_versions, 
                           sizeof(ja3.client.supported_versions), 
                           "%04X", tls_version);
          if(rc <= 0) break;
        } else {
          int rc = snprintf(&ja3.client.supported_versions[strlen(ja3.client.supported_versions)], 
                           sizeof(ja3.client.supported_versions)-strlen(ja3.client.supported_versions), 
                           "-%04X", tls_version);
          if(rc <= 0) break;
        }
      }
      
#ifdef DEBUG_TLS
      printf("Client TLS [SUPPORTED_VERSIONS: %s]\n", ja3.client.supported_versions);
#endif
    }
  }
}
else if(extension_id == 0xFFCE /* encrypted_server_name */) {
  u_int16_t s_offset = offset+extension_offset;
  
  /* ESNI (Encrypted SNI) detection */
  if(s_offset < packet->payload_packet_len) {
    flow->protos.tls_quic.encrypted_sni.esni = 1;
    
#ifdef DEBUG_TLS
    printf("Client TLS [EncryptedSNI: len=%u]\n", extension_len);
#endif

    if(extension_len >= 4 && (s_offset+4) <= packet->payload_packet_len) {
      flow->protos.tls_quic.encrypted_sni.esni_len = extension_len;
      /* Could store more ESNI details if needed */
    }
  }
}
else if(extension_id == 0x2B /* quic_transport_parameters */) {
  u_int16_t s_offset = offset+extension_offset;
  
  if(s_offset < packet->payload_packet_len) {
#ifdef DEBUG_TLS
    printf("Client TLS [QUIC Transport Parameters: len=%u]\n", extension_len);
#endif

    /* Process QUIC transport parameters if needed */
    if(extension_len > 0 && (s_offset+extension_len) <= packet->payload_packet_len) {
      /* QUIC parameters extraction could be done here if needed */
      
      /* For example, check if the extension contains a User-Agent (some QUIC implementations include this) */
      for(i=0; i < extension_len-4 && (s_offset+i+4) < packet->payload_packet_len; i++) {
        if(packet->payload[s_offset+i] == 'U' && 
           packet->payload[s_offset+i+1] == 'A' &&
           packet->payload[s_offset+i+2] == ':' && 
           packet->payload[s_offset+i+3] == ' ') {
          
          u_int16_t ua_offset = s_offset+i+4;
          u_int16_t max_ua_len = extension_len - (i+4);
          u_int16_t ua_len = 0;
          
          /* Find end of UA string */
          while((ua_offset+ua_len) < packet->payload_packet_len && 
                ua_len < max_ua_len && 
                packet->payload[ua_offset+ua_len] != 0) {
            ua_len++;
          }
          
          if(ua_len > 0 && ua_len < 256) {
            char ua_str[256];
            size_t k;
            
            /* Safely copy the user agent string */
            for(k=0; k < ua_len && k < sizeof(ua_str)-1; k++) {
              ua_str[k] = packet->payload[ua_offset+k];
            }
            ua_str[k] = '\0';
            
#ifdef DEBUG_TLS
            printf("Client TLS [QUIC User-Agent: %s]\n", ua_str);
#endif
            /* Could store this information in the flow structure if needed */
          }
          break;
        }
      }
    }
  }
}