else if(extension_id == 43 /* Supported Versions */) {
  /* The extension data starts 4 bytes after the extension header */
  if(extension_len >= 2 && (offset+extension_offset+4+extension_len) <= total_len) {
    u_int16_t supported_version = ntohs(*((u_int16_t*)&packet->payload[offset+extension_offset+4]));
    /* Store the supported version string, appending if already present */
    if(ja3.client.supported_versions[0] == '\0') {
      snprintf(ja3.client.supported_versions, sizeof(ja3.client.supported_versions), "%u", supported_version);
    } else {
      size_t len = strlen(ja3.client.supported_versions);
      if(len < sizeof(ja3.client.supported_versions)-16)
        snprintf(&ja3.client.supported_versions[len], sizeof(ja3.client.supported_versions)-len, "-%u", supported_version);
    }
  }
} else if(extension_id == 0xffce /* Encrypted Server Name */) {
  /* Encrypted SNI extension: copy the extension data securely */
  if(extension_len > 0 && (offset+extension_offset+4+extension_len) <= total_len) {
    /* Allocate and store the ESNI data if not already done */
    if(flow->protos.tls_quic.encrypted_sni.esni == NULL) {
      flow->protos.tls_quic.encrypted_sni.esni = (char *)malloc(extension_len + 1);
      if(flow->protos.tls_quic.encrypted_sni.esni != NULL) {
        memcpy(flow->protos.tls_quic.encrypted_sni.esni, &packet->payload[offset+extension_offset+4], extension_len);
        flow->protos.tls_quic.encrypted_sni.esni[extension_len] = '\0';
      }
    }
  }
} else if(extension_id == 0xffa5 /* QUIC Transport Parameters */) {
  /* QUIC transport parameters: process the extension data */
  if(extension_len > 0 && (offset+extension_offset+4+extension_len) <= total_len) {
    /* Assuming a helper function exists to process QUIC transport parameters */
    process_quic_transport_parameters(ndpi_struct, flow, &packet->payload[offset+extension_offset+4], extension_len);
  }
}