else if(extension_id == 43) { /* Supported Versions extension */
            u_int16_t s_offset = offset + 4;
            if(s_offset + 2 <= total_len) {
              /* The first two bytes specify the length of the versions list */
              u_int16_t versions_length = ntohs(*((u_int16_t*)&packet->payload[s_offset]));
              s_offset += 2;
              char versions_str[128] = "";
              int first = 1;
              while(versions_length >= 2 && (s_offset+1) < total_len) {
                u_int16_t ver = ntohs(*((u_int16_t*)&packet->payload[s_offset]));
                char ver_buf[10];
                snprintf(ver_buf, sizeof(ver_buf), "%s0x%04X", first ? "" : "-", ver);
                strncat(versions_str, ver_buf, sizeof(versions_str)-strlen(versions_str)-1);
                first = 0;
                s_offset += 2;
                versions_length -= 2;
              }
              strncpy(ja3.client.supported_versions, versions_str, sizeof(ja3.client.supported_versions)-1);
              ja3.client.supported_versions[sizeof(ja3.client.supported_versions)-1] = '\0';
            }
          } else if(extension_id == 0xffce) { /* Encrypted Server Name (ESNI) extension */
            u_int16_t s_offset = offset + 4;
            if(s_offset + extension_len <= total_len) {
              /* Allocate and store the ESNI data in the flow structure */
              flow->protos.tls_quic.encrypted_sni.esni = ndpi_malloc(extension_len + 1);
              if(flow->protos.tls_quic.encrypted_sni.esni != NULL) {
                memcpy(flow->protos.tls_quic.encrypted_sni.esni, &packet->payload[s_offset], extension_len);
                flow->protos.tls_quic.encrypted_sni.esni[extension_len] = '\0';
                flow->protos.tls_quic.encrypted_sni.esni_len = extension_len;
              }
            }
          } else if(extension_id == 0xffa5) { /* QUIC Transport Parameters extension */
            u_int16_t s_offset = offset + 4;
            if(s_offset + extension_len <= total_len) {
              /* For demonstration purposes, store the raw QUIC transport parameters.
                 In a real implementation you might parse out specific parameters such as user agent hints. */
              flow->protos.tls_quic.quic_transport_parameters_len = extension_len;
              memcpy(flow->protos.tls_quic.quic_transport_parameters,
                     &packet->payload[s_offset], extension_len);
            }
          } else {
            /* Unhandled extension: simply skip */
          }