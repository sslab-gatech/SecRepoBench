else if(extension_id == 43 /* supported versions */) {
  u_int16_t supported_versions_len = ntohs(*((u_int16_t*)&packet->payload[offset+extension_offset]));
  u_int8_t *versions_ptr = &packet->payload[offset + extension_offset + 2];
  u_int16_t versions_idx;

  if((offset + extension_offset + 2 + supported_versions_len) > total_len) {
    invalid_ja3 = 1;
#ifdef DEBUG_TLS
    printf("Client TLS [Invalid supported versions len: %u vs %u]\n", (offset + extension_offset + 2 + supported_versions_len), total_len);
#endif
    break;
  }

  for(versions_idx = 0; versions_idx < supported_versions_len && versions_idx + 1 < supported_versions_len; versions_idx += 2) {
    u_int16_t version = (versions_ptr[versions_idx] << 8) | versions_ptr[versions_idx + 1];

    if(ja3.client.num_tls_extension < MAX_NUM_JA3) {
      ja3.client.supported_versions[ja3.client.num_supported_versions++] = version;
    } else {
      invalid_ja3 = 1;
#ifdef DEBUG_TLS
      printf("Client TLS [Too many supported versions]\n");
#endif
      break;
    }
  }
}
else if(extension_id == 51 /* encrypted server name */) {
  u_int16_t esni_len = ntohs(*((u_int16_t*)&packet->payload[offset+extension_offset]));

  if((offset + extension_offset + esni_len) > total_len) {
    invalid_ja3 = 1;
#ifdef DEBUG_TLS
    printf("Client TLS [Invalid ESNI len: %u vs %u]\n", (offset + extension_offset + esni_len), total_len);
#endif
    break;
  }

  // Store the ESNI data or details as required.
  flow->protos.tls_quic.encrypted_sni.esni = ndpi_malloc(esni_len);
  if(flow->protos.tls_quic.encrypted_sni.esni != NULL) {
    memcpy(flow->protos.tls_quic.encrypted_sni.esni, &packet->payload[offset + extension_offset + 2], esni_len);
    flow->protos.tls_quic.encrypted_sni.len = esni_len;
  }
}
else if(extension_id == 57 /* QUIC transport parameters */) {
  u_int16_t quic_params_len = ntohs(*((u_int16_t*)&packet->payload[offset+extension_offset]));

  if((offset + extension_offset + quic_params_len) > total_len) {
    invalid_ja3 = 1;
#ifdef DEBUG_TLS
    printf("Client TLS [Invalid QUIC params len: %u vs %u]\n", (offset + extension_offset + quic_params_len), total_len);
#endif
    break;
  }

  // Process QUIC transport parameters and extract user agent if present.
  processQUICParameters(ndpi_struct, flow, &packet->payload[offset + extension_offset + 2], quic_params_len);
}