/* Process the TLS extensions in the client's "Client Hello" message.
   For the "supported versions" extension, extract and store the supported TLS versions in the flow structure.
   For the "encrypted server name" extension, extract and store the encrypted SNI details if present.
   For the "QUIC transport parameters" extension, extract transport parameters and process the user agent if available.
   Continue processing any additional extensions that are part of the Client Hello message.
 */
for (i = 0; i < ja3.client.num_tls_extension; i++) {
  u_int16_t extension_id = ja3.client.tls_extension[i];
  u_int32_t extension_len = 0;
  u_int16_t extension_payload_offset = 0;

  if (extension_id == 43 /* supported versions */) {
    if (extension_len >= 2) {
      u_int16_t tls_version = ntohs(*((u_int16_t*)&packet->payload[offset + 4]));

#ifdef DEBUG_TLS
      printf("Client TLS [TLS version: 0x%04X]\n", tls_version);
#endif

      flow->protos.tls_quic.ssl_version = ja3.server.tls_supported_version = tls_version;
    }
  } else if (extension_id == 16 /* application_layer_protocol_negotiation (ALPN) */) {
    u_int16_t s_offset = offset + 4;
    u_int16_t tot_alpn_len = ntohs(*((u_int16_t*)&packet->payload[s_offset]));
    char alpn_str[256];
    u_int8_t alpn_str_len = 0, i;

#ifdef DEBUG_TLS
    printf("Client TLS [ALPN: block_len=%u/len=%u]\n", extension_len, tot_alpn_len);
#endif
    s_offset += 2;
    tot_alpn_len += s_offset;

    while (s_offset < tot_alpn_len && s_offset < total_len) {
      u_int8_t alpn_i, alpn_len = packet->payload[s_offset++];

      if ((s_offset + alpn_len) <= tot_alpn_len && (s_offset + alpn_len) <= total_len) {
#ifdef DEBUG_TLS
        printf("Client TLS [ALPN: %u]\n", alpn_len);
#endif

        if (((uint32_t)alpn_str_len + alpn_len + 1) < (sizeof(alpn_str) - 1)) {
          if (alpn_str_len > 0) {
            alpn_str[alpn_str_len] = ',';
            alpn_str_len++;
          }

          for (alpn_i = 0; alpn_i < alpn_len; alpn_i++)
            alpn_str[alpn_str_len + alpn_i] = packet->payload[s_offset + alpn_i];

          s_offset += alpn_len, alpn_str_len += alpn_len;
        } else
          break;
      } else
        break;
    } /* while */

    alpn_str[alpn_str_len] = '\0';

#ifdef DEBUG_TLS
    printf("Client TLS [ALPN: %s][len: %u]\n", alpn_str, alpn_str_len);
#endif
    if (flow->protos.tls_quic.alpn == NULL)
      flow->protos.tls_quic.alpn = ndpi_strdup(alpn_str);

    snprintf(ja3.client.alpn, sizeof(ja3.client.alpn), "%s", alpn_str);

    /* Replace, with - as in JA3 */
    for (i = 0; ja3.client.alpn[i]!= '\0'; i++)
      if (ja3.client.alpn[i] == ',') ja3.client.alpn[i] = '-';
  } else if (extension_id == 35 /* encrypted_server_name */) {
    u_int16_t s_offset = offset + 4;
    u_int16_t tot_esni_len = ntohs(*((u_int16_t*)&packet->payload[s_offset]));
    char esni_str[256];
    u_int8_t esni_str_len = 0, i;

#ifdef DEBUG_TLS
    printf("Client TLS [ESNI: block_len=%u/len=%u]\n", extension_len, tot_esni_len);
#endif
    s_offset += 2;
    tot_esni_len += s_offset;

    while (s_offset < tot_esni_len && s_offset < total_len) {
      u_int8_t esni_i, esni_len = packet->payload[s_offset++];

      if ((s_offset + esni_len) <= tot_esni_len && (s_offset + esni_len) <= total_len) {
#ifdef DEBUG_TLS
        printf("Client TLS [ESNI: %u]\n", esni_len);
#endif

        if (((uint32_t)esni_str_len + esni_len + 1) < (sizeof(esni_str) - 1)) {
          if (esni_str_len > 0) {
            esni_str[esni_str_len] = ',';
            esni_str_len++;
          }

          for (esni_i = 0; esni_i < esni_len; esni_i++)
            esni_str[esni_str_len + esni_i] = packet->payload[s_offset + esni_i];

          s_offset += esni_len, esni_str_len += esni_len;
        } else
          break;
      } else
        break;
    } /* while */

    esni_str[esni_str_len] = '\0';

#ifdef DEBUG_TLS
    printf("Client TLS [ESNI: %s][len: %u]\n", esni_str, esni_str_len);
#endif
    if (flow->protos.tls_quic.encrypted_sni.esni == NULL)
      flow->protos.tls_quic.encrypted_sni.esni = ndpi_strdup(esni_str);

    flow->protos.tls_quic.encrypted_sni.esni_len = esni_str_len;
  } else if (extension_id == 45 /* QUIC transport parameters */) {
    u_int16_t s_offset = offset + 4;
    u_int16_t tot_quic_len = ntohs(*((u_int16_t*)&packet->payload[s_offset]));
    char quic_str[256];
    u_int8_t quic_str_len = 0, i;

#ifdef DEBUG_TLS
    printf("Client TLS [QUIC: block_len=%u/len=%u]\n", extension_len, tot_quic_len);
#endif
    s_offset += 2;
    tot_quic_len += s_offset;

    while (s_offset < tot_quic_len && s_offset < total_len) {
      u_int8_t quic_i, quic_len = packet->payload[s_offset++];

      if ((s_offset + quic_len) <= tot_quic_len && (s_offset + quic_len) <= total_len) {
#ifdef DEBUG_TLS
        printf("Client TLS [QUIC: %u]\n", quic_len);
#endif

        if (((uint32_t)quic_str_len + quic_len + 1) < (sizeof(quic_str) - 1)) {
          if (quic_str_len > 0) {
            quic_str[quic_str_len] = ',';
            quic_str_len++;
          }

          for (quic_i = 0; quic_i < quic_len; quic_i++)
            quic_str[quic_str_len + quic_i] = packet->payload[s_offset + quic_i];

          s_offset += quic_len, quic_str_len += quic_len;
        } else
          break;
      } else
        break;
    } /* while */

    quic_str[quic_str_len] = '\0';

#ifdef DEBUG_TLS
    printf("Client TLS [QUIC: %s][len: %u]\n", quic_str, quic_str_len);
#endif
    if (flow->protos.tls_quic.quic_params == NULL)
      flow->protos.tls_quic.quic_params = ndpi_strdup(quic_str);

    flow->protos.tls_quic.quic_params_len = quic_str_len;
  } else {
    /* Process the TLS extensions in the client's "Client Hello" message.
       For the "supported versions" extension, extract and store the supported TLS versions in the flow structure.
       For the "encrypted server name" extension, extract and store the encrypted SNI details if present.
       For the "QUIC transport parameters" extension, extract transport parameters and process the user agent if available.
       Continue processing any additional extensions that are part of the Client Hello message.
     */
    if (extension_id == 0 || packet->payload[offset]!= packet->payload[offset + 1]) {
      /* Skip GREASE */

      if (ja3.client.num_tls_extension < MAX_NUM_JA3)
        ja3.client.tls_extension[ja3.client.num_tls_extension++] = extension_id;
      else {
        invalid_ja3 = 1;
#ifdef DEBUG_TLS
        printf("Client TLS Invalid extensions %u\n", ja3.client.num_tls_extension);
#endif
      }
    }

    if (extension_id == 10 /* supported groups */) {
      u_int16_t s_offset = offset + extension_offset + 2;

#ifdef DEBUG_TLS
      printf("Client TLS [EllipticCurveGroups: len=%u]\n", extension_len);
#endif

      if ((s_offset + extension_len - 2) <= total_len) {
        for (i = 0; i < (u_int32_t)extension_len - 2 && s_offset + i + 1 < total_len; i += 2) {
          u_int16_t s_group = ntohs(*((u_int16_t*)&packet->payload[s_offset + i]));

#ifdef DEBUG_TLS
          printf("Client TLS [EllipticCurve: %u/0x%04X]\n", s_group, s_group);
#endif
          if ((s_group == 0) || (packet->payload[s_offset + i]!= packet->payload[s_offset + i + 1])) {
            /* Skip GREASE */
            if (ja3.client.num_elliptic_curve < MAX_NUM_JA3)
              ja3.client.elliptic_curve[ja3.client.num_elliptic_curve++] = s_group;
            else {
              invalid_ja3 = 1;
#ifdef DEBUG_TLS
              printf("Client TLS Invalid num elliptic %u\n", ja3.client.num_elliptic_curve);
#endif
            }
          }
        }
      } else {
        invalid_ja3 = 1;
#ifdef DEBUG_TLS
        printf("Client TLS Invalid len %u vs %u\n", (s_offset + extension_len - 1), total_len);
#endif
      }
    } else if (extension_id == 11 /* ec_point_formats groups */) {
      u_int16_t s_offset = offset + extension_offset + 1;

#ifdef DEBUG_TLS
      printf("Client TLS [EllipticCurveFormat: len=%u]\n", extension_len);
#endif
      if ((s_offset + extension_len - 1) <= total_len) {
        for (i = 0; i < (u_int32_t)extension_len - 1 && s_offset + i < total_len; i++) {
          u_int8_t s_group = packet->payload[s_offset + i];

#ifdef DEBUG_TLS
          printf("Client TLS [EllipticCurveFormat: %u]\n", s_group);
#endif

          if (ja3.client.num_elliptic_curve_point_format < MAX_NUM_JA3)
            ja3.client.elliptic_curve_point_format[ja3.client.num_elliptic_curve_point_format++] = s_group;
          else {
            invalid_ja3 = 1;
#ifdef DEBUG_TLS
            printf("Client TLS Invalid num elliptic %u\n", ja3.client.num_elliptic_curve_point_format);
#endif
          }
        }
      } else {
        invalid_ja3 = 1;
#ifdef DEBUG_TLS
        printf("Client TLS Invalid len %u vs %u\n", s_offset + extension_len, total_len);
#endif
      }
    } else if (extension_id == 13 /* signature algorithms */) {
      int s_offset = offset + extension_offset, safari_signature_algorithms = 0, chrome_signature_algorithms = 0,
        duplicate_found = 0, last_signature = 0;
      u_int16_t tot_signature_algorithms_len = ntohs(*((u_int16_t*)&packet->payload[s_offset]));

#ifdef DEBUG_TLS
      printf("Client TLS [SIGNATURE_ALGORITHMS: block_len=%u/len=%u]\n", extension_len, tot_signature_algorithms_len);
#endif

      s_offset += 2;
      tot_signature_algorithms_len = ndpi_min((sizeof(ja3.client.signature_algorithms) / 2) - 1, tot_signature_algorithms_len);

#ifdef TLS_HANDLE_SIGNATURE_ALGORITMS
      flow->protos.tls_quic.num_tls_signature_algorithms = ndpi_min(tot_signature_algorithms_len / 2, MAX_NUM_TLS_SIGNATURE_ALGORITHMS);

      memcpy(flow->protos.tls_quic.client_signature_algorithms,
             &packet->payload[s_offset], 2 /* 16 bit */ * flow->protos.tls_quic.num_tls_signature_algorithms);
#endif

      for (i = 0; i < tot_signature_algorithms_len && s_offset + i < total_len; i++) {
        int rc = snprintf(&ja3.client.signature_algorithms[i * 2], sizeof(ja3.client.signature_algorithms) - i * 2, "%02X", packet->payload[s_offset + i]);

        if (rc < 0) break;
      }

      for (i = 0; i < tot_signature_algorithms_len && s_offset + (int)i + 2 < packet->payload_packet_len; i += 2) {
        u_int16_t signature_algo = (u_int16_t)ntohs(*((u_int16_t*)&packet->payload[s_offset + i]));

        if (last_signature == signature_algo) {
          /* Consecutive duplication */
          duplicate_found = 1;
          continue;
        } else {
          /* Check for other duplications */
          u_int all_ok = 1;

          for (md5_index = 0; md5_index < tot_signature_algorithms_len; md5_index += 2) {
            if (md5_index!= i && s_offset + (int)md