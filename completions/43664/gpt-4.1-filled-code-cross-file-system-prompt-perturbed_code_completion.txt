if(extension_id == 43 /* supported versions */) {
  u_int16_t s_offset = offset+extension_offset+2;
  u_int16_t supported_versions_len = packet->payload[offset+extension_offset];
  u_int8_t sv_idx = 0;

#ifdef DEBUG_TLS
  printf("Client TLS [Supported Versions: len=%u]\n", supported_versions_len);
#endif

  if((s_offset+supported_versions_len-1) <= total_len) {
    char sv_str[64];
    u_int8_t sv_str_len = 0;
    sv_str[0] = '\0';

    for(i=0; i<supported_versions_len && s_offset+i+1 < total_len; i+=2) {
      u_int16_t sv = ntohs(*((u_int16_t*)&packet->payload[s_offset+i]));
      if(sv_idx > 0 && sv_str_len < sizeof(sv_str)-1) {
        sv_str[sv_str_len++] = '-';
      }
      int rc = snprintf(&sv_str[sv_str_len], sizeof(sv_str)-sv_str_len, "%u", sv);
      if(rc > 0 && sv_str_len + rc < sizeof(sv_str)) sv_str_len += rc; else break;
      sv_idx++;
    }
    sv_str[sv_str_len] = '\0';
    snprintf(ja3.client.supported_versions, sizeof(ja3.client.supported_versions), "%s", sv_str);

#ifdef DEBUG_TLS
    printf("Client TLS [Supported Versions: %s]\n", ja3.client.supported_versions);
#endif
    /* Save the highest supported version as the flow version if not already set */
    if(sv_idx > 0 && flow->protos.tls_quic.ssl_version == 0)
      flow->protos.tls_quic.ssl_version = ntohs(*((u_int16_t*)&packet->payload[s_offset]));
  }
} else if(extension_id == 0xFFCE /* encrypted server name (ESNI/ESNI2) */) {
  /* Encrypted SNI (ESNI/ESNI2) extension */
  u_int16_t s_offset = offset+extension_offset;
  u_int16_t esni_len = extension_len;
  if(esni_len > 0 && s_offset+esni_len <= total_len) {
    if(flow->protos.tls_quic.encrypted_sni.esni == NULL) {
      flow->protos.tls_quic.encrypted_sni.esni = ndpi_malloc(esni_len+1);
      if(flow->protos.tls_quic.encrypted_sni.esni) {
        memcpy(flow->protos.tls_quic.encrypted_sni.esni, &packet->payload[s_offset], esni_len);
        flow->protos.tls_quic.encrypted_sni.esni[esni_len] = '\0';
      }
    }
#ifdef DEBUG_TLS
    printf("Client TLS [Encrypted SNI: len=%u]\n", esni_len);
#endif
  }
} else if(extension_id == 0x39 /* quic_transport_parameters */) {
  /* QUIC transport parameters extension */
  u_int16_t s_offset = offset+extension_offset;
  u_int16_t tp_len = extension_len;
  if(tp_len > 0 && s_offset+tp_len <= total_len) {
    /* Try to extract user agent if present in transport parameters */
    /* This is a best effort, as the format is not standardized for user agent */
    for(i=0; i+1<tp_len; ) {
      u_int16_t param_id = ntohs(*((u_int16_t*)&packet->payload[s_offset+i]));
      u_int16_t param_len = ntohs(*((u_int16_t*)&packet->payload[s_offset+i+2]));
      if(i+4+param_len > tp_len) break;
      if(param_id == 0x2a /* user_agent_id, draft-ietf-quic-transport-34 */) {
        if(flow->protos.tls_quic.user_agent == NULL) {
          flow->protos.tls_quic.user_agent = ndpi_malloc(param_len+1);
          if(flow->protos.tls_quic.user_agent) {
            memcpy(flow->protos.tls_quic.user_agent, &packet->payload[s_offset+i+4], param_len);
            flow->protos.tls_quic.user_agent[param_len] = '\0';
          }
        }
#ifdef DEBUG_TLS
        printf("QUIC Transport Parameter: user_agent: %.*s\n", param_len, &packet->payload[s_offset+i+4]);
#endif
      }
      i += 4 + param_len;
    }
  }
}