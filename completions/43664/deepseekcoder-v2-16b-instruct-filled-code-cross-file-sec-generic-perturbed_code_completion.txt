// Process the TLS extensions in the client's "Client Hello" message.
// For the "supported versions" extension, extract and store the supported TLS versions in the flow structure.
// For the "encrypted server name" extension, extract and store the encrypted SNI details if present.
// For the "QUIC transport parameters" extension, extract transport parameters and process the user agent if available.
// Continue processing any additional extensions that are part of the Client Hello message.

if(extension_id == 0 /* server name */) {
  u_int16_t len;

#ifdef DEBUG_TLS
  printf("[TLS] Extensions: found server name\n");
#endif
  if((offset+extension_offset+4) < packet->payload_packet_len) {

    len = (packet->payload[offset+extension_offset+3] << 8) + packet->payload[offset+extension_offset+4];

    if((offset+extension_offset+5+len) <= packet->payload_packet_len) {

      char *sni = ndpi_hostname_sni_set(flow, &packet->payload[offset+extension_offset+5], len);
      int sni_len = strlen(sni);
#ifdef DEBUG_TLS
      printf("[TLS] SNI: [%s]\n", sni);
#endif
      if(ndpi_is_printable_string(sni, sni_len) == 0)
      {
         ndpi_set_risk(ndpi_struct, flow, NDPI_INVALID_CHARACTERS);
      }

      if(!is_quic) {
        if(ndpi_match_hostname_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TLS, sni, sni_len))
          flow->protos.tls_quic.subprotocol_detected = 1;
      } else {
        if(ndpi_match_hostname_protocol(ndpi_struct, flow, NDPI_PROTOCOL_QUIC, sni, sni_len))
          flow->protos.tls_quic.subprotocol_detected = 1;
      }

      if(ndpi_check_dga_name(ndpi_struct, flow,
                             sni, 1)) {
#ifdef DEBUG_TLS
        printf("[TLS] SNI: (DGA) [%s]\n", sni);
#endif

        if((sni_len >= 4)
           /* Check if it ends in .com or .net */
           && ((strcmp(&sni[sni_len-4], ".com") == 0) || (strcmp(&sni[sni_len-4], ".net") == 0))
           && (strncmp(sni, "www.", 4) == 0)) /* Not starting with www.... */
          ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TOR, NDPI_PROTOCOL_TLS, NDPI_CONFIDENCE_DPI);
      } else {
#ifdef DEBUG_TLS
        printf("[TLS] SNI: (NO DGA) [%s]\n", sni);
#endif
      }
    } else {
#ifdef DEBUG_TLS
      printf("[TLS] Extensions server len too short: %u vs %u\n",
             offset+extension_offset+5+len,
             packet->payload_packet_len);
#endif
    }
  }
} else if(extension_id == 43 /* supported versions */) {
  if(extension_len >= 2) {
    u_int16_t tls_version = ntohs(*((u_int16_t*)&packet->payload[offset+4]));

#ifdef DEBUG_TLS
    printf("[TLS] Server [TLS version: 0x%04X]\n", tls_version);
#endif

    flow->protos.tls_quic.ssl_version = ja3.server.tls_supported_version = tls_version;
  }
} else if(extension_id == 16 /* application_layer_protocol_negotiation (ALPN) */ &&
          offset + 6 < packet->payload_packet_len) {
  u_int16_t s_offset = offset+4;
  u_int16_t tot_alpn_len = ntohs(*((u_int16_t*)&packet->payload[s_offset]));
  char alpn_str[256];
  u_int8_t alpn_str_len = 0, i;

#ifdef DEBUG_TLS
  printf("Server TLS [ALPN: block_len=%u/len=%u]\n", extension_len, tot_alpn_len);
#endif
  s_offset += 2;
  tot_alpn_len += s_offset;

  if(tot_alpn_len > packet->payload_packet_len)
    return 0;

  while(s_offset < tot_alpn_len && s_offset < total_len) {
    u_int8_t alpn_i, alpn_len = packet->payload[s_offset++];

    if((s_offset + alpn_len) <= tot_alpn_len) {
#ifdef DEBUG_TLS
      printf("Server TLS [ALPN: %u]\n", alpn_len);
#endif

      if(((uint32_t)alpn_str_len+alpn_len+1) < (sizeof(alpn_str)-1)) {
        if(alpn_str_len > 0) {
          alpn_str[alpn_str_len] = ',';
          alpn_str_len++;
        }

        for(alpn_i=0; alpn_i<alpn_len; alpn_i++)
        {
          alpn_str[alpn_str_len+alpn_i] = packet->payload[s_offset+alpn_i];
        }

        s_offset += alpn_len, alpn_str_len += alpn_len;;
      } else {
        ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_UNCOMMON_ALPN);
        break;
      }
    } else {
      ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_UNCOMMON_ALPN);
      break;
    }
  } /* while */

  alpn_str[alpn_str_len] = '\0';

#ifdef DEBUG_TLS
  printf("Server TLS [ALPN: %s][len: %u]\n", alpn_str, alpn_str_len);
#endif
  if(ndpi_is_printable_string(alpn_str, alpn_str_len) == 0)
    ndpi_set_risk(ndpi_struct, flow, NDPI_INVALID_CHARACTERS);

  if(flow->protos.tls_quic.alpn == NULL)
    flow->protos.tls_quic.alpn = ndpi_strdup(alpn_str);

  if(flow->protos.tls_quic.alpn != NULL)
    tlsCheckUncommonALPN(ndpi_struct, flow);

  snprintf(ja3.server.alpn, sizeof(ja3.server.alpn), "%s", alpn_str);

  /* Replace , with - as in JA3 */
  for(i=0; ja3.server.alpn[i] != '\0'; i++)
    if(ja3.server.alpn[i] == ',') ja3.server.alpn[i] = '-';
} else if(extension_id == 11 /* ec_point_formats groups */) {
  u_int16_t s_offset = offset+4 + 1;

#ifdef DEBUG_TLS
  printf("Server TLS [EllipticCurveFormat: len=%u]\n", extension_len);
#endif
  if((s_offset+extension_len-1) <= total_len) {
    for(i=0; i<extension_len-1 && s_offset+i<packet->payload_packet_len; i++) {
      u_int8_t s_group = packet->payload[s_offset+i];

#ifdef DEBUG_TLS
      printf("Server TLS [EllipticCurveFormat: %u]\n", s_group);
#endif

      if(ja3.server.num_elliptic_curve_point_format < MAX_NUM_JA3)
        ja3.server.elliptic_curve_point_format[ja3.server.num_elliptic_curve_point_format++] = s_group;
      else {
        invalid_ja3 = 1;
#ifdef DEBUG_TLS
        printf("Server TLS Invalid num elliptic %u\n", ja3.server.num_elliptic_curve_point_format);
#endif
      }
    }
  } else {
    invalid_ja3 = 1;
#ifdef DEBUG_TLS
    printf("Server TLS Invalid len %u vs %u\n", s_offset+extension_len, total_len);
#endif
  }
}

extension_offset += 4 + extension_len; /* Move to the next extension */

#ifdef DEBUG_TLS
printf("Server TLS [extension_offset/len: %u/%u]\n", extension_offset, extension_len);
#endif