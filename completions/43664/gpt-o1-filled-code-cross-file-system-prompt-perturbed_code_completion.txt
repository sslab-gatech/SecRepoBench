} else if(extension_id == 43 /* supported versions */) {
  /* Parse the 'supported versions' extension and store it in ja3.client.supported_versions */
  u_int16_t s_offset = offset + extension_offset;
  if(extension_len >= 1 && (s_offset + extension_len) <= total_len) {
    u_int8_t sv_len = packet->payload[s_offset++];
    if(sv_len == (extension_len - 1) && (s_offset + sv_len) <= total_len) {
      int pos = 0;
      for(i = 0; i < sv_len && (s_offset + i) < total_len; i++) {
        /* Store each byte as hex, similar to the signature_algorithms approach */
        if((pos + 2) < sizeof(ja3.client.supported_versions)) {
          int rc = snprintf(&ja3.client.supported_versions[pos], 
                            sizeof(ja3.client.supported_versions) - pos, "%02X",
                            packet->payload[s_offset + i]);
          if(rc < 0) break;
          pos += rc;
        } else {
          break;
        }
      }
      ja3.client.supported_versions[pos] = '\0';
    }
  }
} else if(extension_id == 0xFFCE /* encrypted server name (ESNI/ECH) */) {
  /* Mark that encrypted SNI was detected */
  flow->protos.tls_quic.encrypted_sni.esni = (void*)1;
#ifdef DEBUG_TLS
  printf("Client TLS [Encrypted SNI/ECH detected, extension_len=%u]\n", extension_len);
#endif
} else if(extension_id == 57 /* QUIC transport parameters */) {
  /* Parse QUIC transport parameters and potentially extract a user agent */
#ifdef DEBUG_TLS
  printf("Client TLS [QUIC transport parameters, extension_len=%u]\n", extension_len);
#endif
  /* A real implementation would parse the transport parameters here */
} else {
  /* Nothing special for other extensions */
}