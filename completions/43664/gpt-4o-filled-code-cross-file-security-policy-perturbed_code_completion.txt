else if(extension_id == 43 /* supported versions */) {
		u_int16_t s_offset = offset+extension_offset;

		if((s_offset+extension_len) <= total_len) {
		  for(i=0; i<(u_int32_t)extension_len && s_offset+i < total_len; i+=2) {
		    u_int16_t version = ntohs(*((u_int16_t*)&packet->payload[s_offset+i]));

		    if(ja3.client.num_supported_versions < MAX_NUM_JA3)
		      ja3.client.supported_versions[ja3.client.num_supported_versions++] = version;
		    else {
		      invalid_ja3 = 1;
#ifdef DEBUG_TLS
		      printf("Client TLS Invalid num supported versions %u\n", ja3.client.num_supported_versions);
#endif
		    }
		  }
		} else {
		  invalid_ja3 = 1;
#ifdef DEBUG_TLS
		  printf("Client TLS Invalid len %u vs %u\n", s_offset+extension_len, total_len);
#endif
		}
	      } else if(extension_id == 51 /* encrypted server name */) {
		u_int16_t s_offset = offset+extension_offset;

		if((s_offset+extension_len) <= total_len) {
		  flow->protos.tls_quic.encrypted_sni.esni = ndpi_malloc(extension_len);
		  if(flow->protos.tls_quic.encrypted_sni.esni != NULL) {
		    memcpy(flow->protos.tls_quic.encrypted_sni.esni, &packet->payload[s_offset], extension_len);
		    flow->protos.tls_quic.encrypted_sni.esni_len = extension_len;
		  }
		} else {
		  invalid_ja3 = 1;
#ifdef DEBUG_TLS
		  printf("Client TLS Invalid len %u vs %u\n", s_offset+extension_len, total_len);
#endif
		}
	      } else if(extension_id == 57 /* quic transport parameters */) {
		u_int16_t s_offset = offset+extension_offset;

		if((s_offset+extension_len) <= total_len) {
		  // Process QUIC transport parameters
		  // Example: Extract user agent if available
		  // This is a placeholder for actual processing logic
		  // You can add specific logic to handle QUIC transport parameters here
		} else {
		  invalid_ja3 = 1;
#ifdef DEBUG_TLS
		  printf("Client TLS Invalid len %u vs %u\n", s_offset+extension_len, total_len);
#endif
		}
	      }