else if(extension_id == 43 /* supported versions */) {
  u_int16_t s_offset = offset+extension_offset;
  u_int8_t tot_supported_versions_len = packet->payload[s_offset];
  char tls_supported_versions[64] = {'\0'};
  u_int8_t tls_supported_versions_len = 0;

  #ifdef DEBUG_TLS
  printf("Client TLS [SUPPORTED_VERSIONS: block_len=%u/len=%u]\n", extension_len, tot_supported_versions_len);
  #endif

  s_offset += 1; // Skip length

  if(s_offset + tot_supported_versions_len <= total_len) {
    int rc = 0;
    u_int16_t version;
    u_int i;

    for(i=0; i<tot_supported_versions_len && s_offset+i+1 < total_len; i+=2) {
      version = ntohs(*((u_int16_t*)&packet->payload[s_offset+i]));
      
      if(tls_supported_versions_len == 0) {
        flow->protos.tls_quic.tls_supported_version = version;
      }
      
      if((tls_supported_versions_len+5) < sizeof(tls_supported_versions)) {
        if(tls_supported_versions_len > 0) {
          tls_supported_versions[tls_supported_versions_len] = ',';
          tls_supported_versions_len++;
        }
        
        rc = snprintf(&tls_supported_versions[tls_supported_versions_len], 
                      sizeof(tls_supported_versions)-tls_supported_versions_len, "%04X", version);
        
        if(rc > 0) tls_supported_versions_len += rc;
      }
    }
    
    if(tls_supported_versions_len > 0) {
      tls_supported_versions[tls_supported_versions_len] = '\0';
      snprintf(ja3.client.supported_versions, sizeof(ja3.client.supported_versions), "%s", tls_supported_versions);
      flow->protos.tls_quic.tls_supported_versions = ndpi_strdup(tls_supported_versions);
    }
  }
}
else if(extension_id == 0xFEE0 /* encrypted server name */) {
  if(extension_len > 0) {
    char esni[256];
    u_int16_t s_offset = offset+extension_offset;
    u_int esni_len = 0;
    u_int i;

    #ifdef DEBUG_TLS
    printf("Client TLS [ESNI: block_len=%u]\n", extension_len);
    #endif

    // Limit the ESNI data to copy
    u_int max_len = ndpi_min(extension_len, sizeof(esni)-1);
    
    for(i=0; i<max_len; i++) {
      if(s_offset+i < packet->payload_packet_len) {
        esni[esni_len++] = packet->payload[s_offset+i];
      } else {
        break;
      }
    }
    
    esni[esni_len] = '\0';
    
    if(esni_len > 0) {
      flow->protos.tls_quic.encrypted_sni.esni = ndpi_strdup(esni);
      
      if(extension_len >= 4) {
        flow->protos.tls_quic.encrypted_sni.cipher_suite = 
          ntohs(*((u_int16_t*)&packet->payload[s_offset+2]));
      }
    }
  }
}
else if(extension_id == 0x0039 /* QUIC transport parameters */) {
  if(is_quic && extension_len > 0) {
    u_int16_t s_offset = offset+extension_offset;
    
    #ifdef DEBUG_TLS
    printf("Client TLS [QUIC Transport Parameters: block_len=%u]\n", extension_len);
    #endif
    
    if((s_offset + extension_len) <= total_len) {
      // Process QUIC transport parameters
      u_int param_offset = 0;
      
      while(param_offset + 4 <= extension_len) {
        if(s_offset + param_offset + 4 <= total_len) {
          u_int16_t param_type = ntohs(*((u_int16_t*)&packet->payload[s_offset+param_offset]));
          u_int16_t param_len = ntohs(*((u_int16_t*)&packet->payload[s_offset+param_offset+2]));
          
          param_offset += 4;
          
          if((param_type == 0x0000) && (param_len > 0)) {
            if((s_offset + param_offset + param_len) <= total_len) {
              char user_agent[256];
              u_int user_agent_len = ndpi_min(param_len, sizeof(user_agent)-1);
              
              memcpy(user_agent, &packet->payload[s_offset+param_offset], user_agent_len);
              user_agent[user_agent_len] = '\0';
              
              if(flow->http.user_agent == NULL)
                flow->http.user_agent = ndpi_strdup(user_agent);
            }
          }
          
          if(param_offset + param_len > extension_len)
            break;
            
          param_offset += param_len;
        } else {
          break;
        }
      }
    }
  }
}