} else if(extension_id == 43 /* supported_versions */) {
  u_int16_t s_offset = offset + extension_offset;
  if((s_offset + 2) <= total_len) {
    u_int16_t versions_len = ntohs(*((u_int16_t*)&packet->payload[s_offset]));
    s_offset += 2;
    if((s_offset + versions_len) <= total_len) {
      /* Parse each 2-byte version and store in ja3.client.supported_versions */
      u_int16_t idx = 0;
      for(i = 0; (i + 1) < versions_len && (s_offset + i + 1) < total_len; i += 2) {
        u_int16_t v = ntohs(*((u_int16_t*)&packet->payload[s_offset + i]));
        if(idx < (sizeof(ja3.client.supported_versions) - 6)) {
          if(idx > 0) {
            ja3.client.supported_versions[idx++] = '-';
          }
          /* Write the version as a decimal number (e.g., 772 for 0x0304). */
          int rc = snprintf(&ja3.client.supported_versions[idx],
                            sizeof(ja3.client.supported_versions) - idx,
                            "%u", v);
          if(rc < 0) break;
          idx += rc;
        }
      }
      ja3.client.supported_versions[idx] = '\0';
#ifdef DEBUG_TLS
      printf("Client TLS [SUPPORTED_VERSIONS: %s]\n", ja3.client.supported_versions);
#endif
    } else {
      invalid_ja3 = 1;
    }
  }
} else if(extension_id == 0xFFCE /* Encrypted SNI (ESNI) */) {
  u_int16_t s_offset = offset + extension_offset;
  if((s_offset + extension_len) <= total_len) {
    /* Store a simple flag or copy as needed */
    if(flow->protos.tls_quic.encrypted_sni.esni == NULL) {
      flow->protos.tls_quic.encrypted_sni.esni_len = extension_len;
      flow->protos.tls_quic.encrypted_sni.esni = ndpi_calloc(1, extension_len + 1);
      if(flow->protos.tls_quic.encrypted_sni.esni != NULL) {
        memcpy(flow->protos.tls_quic.encrypted_sni.esni,
               &packet->payload[s_offset],
               extension_len);
      } else {
        /* Allocation error; mark invalid to avoid further processing */
        invalid_ja3 = 1;
      }
    }
#ifdef DEBUG_TLS
    printf("Client TLS [Encrypted SNI extension: length %u]\n", extension_len);
#endif
  } else {
    invalid_ja3 = 1;
  }
} else if(extension_id == 0x0039 /* quic_transport_parameters */) {
  u_int16_t s_offset = offset + extension_offset;
  if((s_offset + extension_len) <= total_len) {
#ifdef DEBUG_TLS
    printf("Client TLS [QUIC transport parameters found, length: %u]\n", extension_len);
#endif
    /* Parse transport parameters if needed; ensure no overflow */
    /* For example, store them or look for user agent info here. */
  } else {
    invalid_ja3 = 1;
  }
} else {
  /* Unknown extension, no special handling */
}