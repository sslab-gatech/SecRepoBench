else if(extension_id == 43 /* supported versions */) {
		u_int16_t s_offset = offset+extension_offset + 2;
		char supported_versions_str[256] = {0};
		u_int8_t supported_versions_str_len = 0;

#ifdef DEBUG_TLS
		printf("Client TLS [Supported Versions: len=%u]\n", extension_len);
#endif

		if((s_offset+extension_len-2) <= total_len) {
		  for(i=0; i<(u_int32_t)extension_len-2 && s_offset + i + 1 < total_len; i += 2) {
		    u_int16_t version = ntohs(*((u_int16_t*)&packet->payload[s_offset+i]));
		    int rc;

		    if(supported_versions_str_len > 0) {
		      rc = snprintf(&supported_versions_str[supported_versions_str_len],
				    sizeof(supported_versions_str) - supported_versions_str_len,
				    "-%04X", version);
		    } else {
		      rc = snprintf(&supported_versions_str[supported_versions_str_len],
				    sizeof(supported_versions_str) - supported_versions_str_len,
				    "%04X", version);
		    }

		    if(rc > 0) {
		      supported_versions_str_len += rc;
		    }

#ifdef DEBUG_TLS
		    printf("Client TLS [Supported Version: 0x%04X]\n", version);
#endif
		  }
		}

		snprintf(ja3.client.supported_versions, sizeof(ja3.client.supported_versions), "%s", supported_versions_str);
#ifdef DEBUG_TLS
		printf("Client TLS [Supported Versions String: %s]\n", ja3.client.supported_versions);
#endif
	      } else if (extension_id == 51 /* encrypted_server_name */) {
		/* https://datatracker.ietf.org/doc/html/rfc8446#section-3 */
		/* https://datatracker.ietf.org/doc/html/draft-ietf-tls-esni */
		flow->protos.tls_quic.encrypted_sni.esni = 1;
#ifdef DEBUG_TLS
		printf("Client TLS [Encrypted Server Name]\n");
#endif
	      } else if (extension_id == 7726 /* QUIC transport parameters */) {
		/* https://datatracker.ietf.org/doc/html/draft-ietf-quic-tls-34#section-8.2 */
		u_int16_t s_offset = offset+extension_offset;
		u_int16_t tot_transport_params_len = extension_len;
		u_int16_t transport_params_len = ntohs(*((u_int16_t*)&packet->payload[s_offset]));

#ifdef DEBUG_TLS
		printf("Client TLS [QUIC transport parameters: block_len=%u/len=%u]\n", extension_len, transport_params_len);
#endif
		s_offset += 2;

		if(transport_params_len <= tot_transport_params_len) {
		  /* https://www.iana.org/assignments/quic/quic.xhtml#transport-parameter-values */
		  u_int16_t param_offset = s_offset;
		  u_int16_t param_end = s_offset + transport_params_len;

		  while(param_offset < param_end && param_offset < total_len) {
		    u_int16_t param_id = ntohs(*((u_int16_t*)&packet->payload[param_offset]));
		    u_int16_t param_len = ntohs(*((u_int16_t*)&packet->payload[param_offset+2]));

#ifdef DEBUG_TLS
		    printf("Client TLS [QUIC transport parameter: id=%u/len=%u]\n", param_id, param_len);
#endif

		    if(param_id == 65533 /* User Agent */) {
		      if(param_len < sizeof(flow->protos.quic.user_agent)) {
			memcpy(flow->protos.quic.user_agent, &packet->payload[param_offset+4], param_len);
			flow->protos.quic.user_agent[param_len] = '\0';

#ifdef DEBUG_TLS
			printf("Client TLS [QUIC transport parameter: User Agent=%s]\n", flow->protos.quic.user_agent);
#endif
		      }
		    }

		    param_offset += 4 + param_len;
		  }
		}
	      } else if (extension_id == 0xffa5 /* Unknown extension used by discord */) {
#ifdef DEBUG_TLS
		printf("Client TLS [Unknown extension used by discord]\n");
#endif
	      }