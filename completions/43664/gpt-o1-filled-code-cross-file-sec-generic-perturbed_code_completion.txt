} else if(extension_id == 43 /* supported versions */) {
  /*
   * Parse the "supported versions" extension for the client.
   * Reference:
   * https://tools.ietf.org/html/rfc8446#section-4.2.1
   */
  if((offset + extension_offset + 1) <= total_len) {
    u_int8_t version_list_len = packet->payload[offset + extension_offset];
    /* Ensure the length does not exceed our boundaries and that it has an even number of bytes (each version is 2 bytes). */
    if(((offset + extension_offset + 1 + version_list_len) <= total_len) && (version_list_len % 2 == 0)) {
      u_int8_t num_versions = version_list_len / 2;
      u_int16_t parse_off = offset + extension_offset + 1;
      u_int16_t str_off = 0;

      for(i = 0; i < num_versions && parse_off + 1 < total_len; i++) {
        u_int16_t ver = ntohs(*((u_int16_t*)&packet->payload[parse_off]));
        /* Append each version in decimal to ja3.client.supported_versions, separated by '-'. */
        int rc = snprintf(&ja3.client.supported_versions[str_off],
                          sizeof(ja3.client.supported_versions) - str_off,
                          (i > 0) ? "-%u" : "%u", ver);
        if(rc < 0) break; /* snprintf error */
        str_off += rc;
        parse_off += 2;
        /* Avoid overruns in ja3.client.supported_versions */
        if(str_off >= sizeof(ja3.client.supported_versions)) break;
      }

#ifdef DEBUG_TLS
      printf("Client TLS [SUPPORTED_VERSIONS: %s]\n", ja3.client.supported_versions);
#endif
    }
  }
  extension_offset += extension_len;
} else if(extension_id == 0xffce /* encrypted server name (ESNI) */) {
  /*
   * Parse the "encrypted_server_name" extension if present.
   * This is a draft extension: see https://datatracker.ietf.org/doc/draft-ietf-tls-esni/
   */
  if((offset + extension_offset + extension_len) <= total_len) {
    /* Allocate and store the ESNI bytes. */
    flow->protos.tls_quic.encrypted_sni.esni_len = extension_len;
    flow->protos.tls_quic.encrypted_sni.esni = ndpi_calloc(1, extension_len);
    if(flow->protos.tls_quic.encrypted_sni.esni != NULL) {
      memcpy(flow->protos.tls_quic.encrypted_sni.esni,
             &packet->payload[offset + extension_offset],
             extension_len);
#ifdef DEBUG_TLS
      printf("Client TLS [ESNI: length=%u]\n", extension_len);
#endif
    }
  }
  extension_offset += extension_len;
} else if(extension_id == 0xffa5 /* QUIC transport parameters */) {
  /*
   * Parse the "QUIC transport parameters" extension if present.
   * Ref: https://datatracker.ietf.org/doc/html/rfc9001#section-8
   */
  if((offset + extension_offset + extension_len) <= total_len) {
#ifdef DEBUG_TLS
    printf("Client TLS [QUIC transport parameters, len=%u]\n", extension_len);
#endif
    /*
     * If needed, parse the transport parameters here and extract any user agent
     * or other relevant information. For this example, we simply note that it's present.
     * Actual parsing of QUIC transport parameters would go here.
     */
  }
  extension_offset += extension_len;
} else {
  /* Process any other extensions in the Client Hello message. */
  extension_offset += extension_len;
}