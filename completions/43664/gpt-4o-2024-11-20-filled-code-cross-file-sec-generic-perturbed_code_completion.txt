else if (extension_id == 43 /* supported versions */) {
		u_int16_t s_offset = offset + extension_offset;

		if (extension_len >= 2 && s_offset + 2 < total_len) {
		  u_int16_t supported_versions_len = ntohs(*((u_int16_t *)&packet->payload[s_offset]));
		  s_offset += 2;

		  if (s_offset + supported_versions_len <= total_len) {
		    for (i = 0; i < supported_versions_len; i += 2) {
		      if (s_offset + i + 1 < total_len) {
			u_int16_t version = ntohs(*((u_int16_t *)&packet->payload[s_offset + i]));

			if (ja3.client.num_supported_versions < MAX_NUM_JA3) {
			  ja3.client.supported_versions[ja3.client.num_supported_versions++] = version;
			} else {
			  invalid_ja3 = 1;
#ifdef DEBUG_TLS
			  printf("Client TLS Invalid supported versions %u\n", ja3.client.num_supported_versions);
#endif
			  break;
			}
		      }
		    }
		  }
		}
	      } else if (extension_id == 65445 /* encrypted server name */) {
		u_int16_t s_offset = offset + extension_offset;

		if (extension_len > 0 && s_offset + extension_len <= total_len) {
		  flow->protos.tls_quic.encrypted_sni.esni = ndpi_malloc(extension_len);
		  if (flow->protos.tls_quic.encrypted_sni.esni != NULL) {
		    memcpy(flow->protos.tls_quic.encrypted_sni.esni, &packet->payload[s_offset], extension_len);
		    flow->protos.tls_quic.encrypted_sni.esni_len = extension_len;
#ifdef DEBUG_TLS
		    printf("Client TLS [Encrypted SNI: len=%u]\n", extension_len);
#endif
		  } else {
		    ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_MEMORY_ALLOCATION_FAILURE);
		  }
		}
	      } else if (extension_id == 57 /* QUIC transport parameters */) {
		u_int16_t s_offset = offset + extension_offset;

		if (extension_len > 0 && s_offset + extension_len <= total_len) {
		  processQuicTransportParameters(ndpi_struct, flow, &packet->payload[s_offset], extension_len);
#ifdef DEBUG_TLS
		  printf("Client TLS [QUIC Transport Parameters: len=%u]\n", extension_len);
#endif
		}
	      }