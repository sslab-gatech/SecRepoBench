if (parser_ctxt->freeElems != NULL) {
        // Reuse an existing xmlNode from the parser context's free elements list.
        // Update the free elements list and decrement the free elements counter.
        // Clear the node's memory to reset its state.
        // Set the node type to XML_ELEMENT_NODE.
        // Assign the local name to the node's name, using either the dictionary or a duplicate string.
        // Handle memory allocation errors by reporting an error if the name cannot be set.
        // <MASK>
        ret = parser_ctxt->freeElems;
        parser_ctxt->freeElems = ret->next;
        parser_ctxt->nbFreeElems--;
        ret->name = NULL;
        ret->children = NULL;
        ret->last = NULL;
        ret->type = XML_ELEMENT_NODE;
        if (parser_ctxt->dictNames) {
            ret->name = xmlDictQLookup(parser_ctxt->dict, localname, prefix);
            if (ret->name == NULL) {
                xmlSAX2ErrMemory(parser_ctxt, "xmlSAX2StartElementNs");
                return;
            }
        } else if (lname == NULL) {
            ret->name = xmlStrdup(localname);
            if (ret->name == NULL) {
                xmlSAX2ErrMemory(parser_ctxt, "xmlSAX2StartElementNs");
                return;
            }
        } else {
            ret->name = lname;
        }
        if (ret->name == NULL) {
            xmlSAX2ErrMemory(parser_ctxt, "xmlSAX2StartElementNs");
            return;
        }
        if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
            xmlRegisterNodeDefaultValue(ret);
    } else {
        if (parser_ctxt->dictNames)
            ret = xmlNewDocNodeEatName(parser_ctxt->myDoc, NULL, (xmlChar *) localname, NULL);
        else if (lname == NULL)
            ret = xmlNewDocNode(parser_ctxt->myDoc, NULL, localname, NULL);
        else
            ret = xmlNewDocNodeEatName(parser_ctxt->myDoc, NULL, (xmlChar *) lname, NULL);
        if (ret == NULL) {
            xmlSAX2ErrMemory(parser_ctxt, "xmlSAX2StartElementNs");
            return;
        }
    }