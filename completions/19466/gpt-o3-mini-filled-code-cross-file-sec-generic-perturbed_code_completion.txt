{
  if (i + 4 >= packet->payload_packet_len)
    break; // Not enough data for length and value

  u_int8_t name_len = packet->payload[i + 3];
  if (i + 4 + name_len > packet->payload_packet_len)
    break; // Not enough data for the complete name

  char server_name[256];
  u_int extract_len = name_len < sizeof(server_name) - 1 ? name_len : sizeof(server_name) - 1;
  memcpy(server_name, &packet->payload[i + 4], extract_len);
  server_name[extract_len] = '\0';

  // Validate that the server name is composed entirely of printable characters.
  int valid = 1;
  for (u_int j = 0; j < extract_len; j++) {
    if (!ndpi_isprint(server_name[j])) {
      valid = 0;
      break;
    }
  }
  if (!valid)
    break;

  // Optionally check that the string contains at least one alphabetical character
  int has_alpha = 0;
  for (u_int j = 0; j < extract_len; j++) {
    if (isalpha((unsigned char)server_name[j])) {
      has_alpha = 1;
      break;
    }
  }
  if (!has_alpha)
    break;

  // Remove any certificate trailer if applicable.
  stripCertificateTrailer(server_name, sizeof(server_name));

  // Store the extracted server name securely
  snprintf(flow->protos.stun_ssl.ssl.server_certificate, sizeof(flow->protos.stun_ssl.ssl.server_certificate),
           "%s", server_name);

  // Optionally, if matching to a known protocol is desired, insert additional code here.
  // For example:
  // if (strstr(server_name, "example.com") != NULL) {
  //   flow->detected_protocol = NDPI_PROTOCOL_EXAMPLE;
  // }

  return 3; // Indicate success in extracting server certificate information.
}