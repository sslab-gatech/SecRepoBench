if((packet->payload[i] == 0x04) && (packet->payload[i+1] == 0x03) && (packet->payload[i+2] == 0x0c)
     || ((packet->payload[i] == 0x04) && (packet->payload[i+1] == 0x03) && (packet->payload[i+2] == 0x13)
     || ((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x04) && (packet->payload[i+2] == 0x03))) {
    // Extract the server name from the TLS certificate payload.
    // Check if the extracted server name appears to be a valid host name or IP address.
    // If valid, store the server name in the flow's `server_certificate` field.
    // Optionally, attempt to match the extracted server name to a known protocol.
    // If a subprotocol is detected, set the flow's detected protocol accordingly.
    // If a valid server name is extracted and optionally matched, return indicating success.
    // <MASK>

    // Extract server name
    u_int16_t server_name_len = packet->payload[i+3] + (packet->payload[i+4] << 8);
    char *server_name = (char *)&packet->payload[i+5];

    // Check if server name is valid
    if (is_valid_hostname(server_name, server_name_len)) {
      // Store server name in flow's `server_certificate` field
      strncpy(flow->protos.stun_ssl.ssl.server_certificate, server_name, server_name_len);
      flow->protos.stun_ssl.ssl.server_certificate[server_name_len] = '\0';

      // Optionally, attempt to match the extracted server name to a known protocol
      if (match_server_name_to_protocol(ndpi_struct, flow, server_name, server_name_len)) {
        // If a subprotocol is detected, set the flow's detected protocol accordingly
        // ...
      }

      return 1; // Indicating success
    }
  }