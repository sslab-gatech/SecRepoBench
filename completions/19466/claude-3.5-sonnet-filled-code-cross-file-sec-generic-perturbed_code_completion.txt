u_int16_t len = (packet->payload[i+3] << 8) + packet->payload[i+4];
len = (u_int)ndpi_min(len, buffer_len-1);

if((i+5+len) <= packet->payload_packet_len) {
  strncpy(buffer, (char*)&packet->payload[i+5], len);
  buffer[len] = '\0';

  stripCertificateTrailer(buffer, buffer_len);

  // Check if the extracted server name is a valid hostname or IP address
  if(ndpi_valid_hostname(buffer, len) || ndpi_is_ip_address(buffer)) {
    if(!ndpi_struct->disable_metadata_export) {
      snprintf(flow->protos.stun_ssl.ssl.server_certificate,
               sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", buffer);
    }

    // Attempt to match the server name to a known protocol
    u_int16_t subprotocol_id = ndpi_match_host_subprotocol(ndpi_struct, flow, buffer, len, NDPI_PROTOCOL_TLS);
    if(subprotocol_id != NDPI_PROTOCOL_UNKNOWN) {
      ndpi_set_detected_protocol(ndpi_struct, flow, subprotocol_id, NDPI_PROTOCOL_TLS);
    }

    return(1); // Indicate success
  }
}