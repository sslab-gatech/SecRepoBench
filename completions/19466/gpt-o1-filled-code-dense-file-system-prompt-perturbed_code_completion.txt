{
  u_int8_t name_len = packet->payload[i+3];

  if ((i + 3 + name_len) < packet->payload_packet_len && (name_len < buffer_len)) {
    strncpy(buffer, (char*)&packet->payload[i+4], name_len);
    buffer[name_len] = '\0';

    stripCertificateTrailer(buffer, buffer_len);

    /* Check for printable characters only */
    {
      u_int8_t is_printable = 1;
      for (j = 0; j < name_len; j++) {
        if (!ndpi_isprint(buffer[j])) {
          is_printable = 0;
          break;
        }
      }

      if (is_printable) {
        /* Store the extracted server name */
        snprintf(flow->protos.stun_ssl.ssl.server_certificate,
                 sizeof(flow->protos.stun_ssl.ssl.server_certificate),
                 "%s", buffer);

        if (!ndpi_struct->disable_metadata_export) {
          /* Optionally store or log the extracted name here */
        }

        /* Attempt to match the extracted server name to a known protocol */
        {
          ndpi_protocol_match_result ret_match;
          u_int16_t subproto = ndpi_match_host_subprotocol(ndpi_struct, flow,
                                                          buffer, strlen(buffer),
                                                          &ret_match,
                                                          NDPI_PROTOCOL_TLS);
          if (subproto != NDPI_PROTOCOL_UNKNOWN) {
            ndpi_set_detected_protocol(ndpi_struct, flow, subproto,
                                       ndpi_tls_refine_master_protocol(ndpi_struct, flow,
                                                                       NDPI_PROTOCOL_TLS));
          }
        }

        /* Indicate we successfully extracted a valid server name */
        return(2);
      }
    }
  }
}