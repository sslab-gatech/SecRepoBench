// Extract the server name from the TLS certificate payload
	    u_int8_t server_name_len = packet->payload[i + 3];
	    if (i + 3 + server_name_len < packet->payload_packet_len) {
	      char server_name[256]; // Ensure the buffer is large enough
	      u_int len = (u_int)ndpi_min(server_name_len, sizeof(server_name) - 1);

	      // Copy the server name into the buffer and null-terminate it
	      strncpy(server_name, (char *)&packet->payload[i + 4], len);
	      server_name[len] = '\0';

	      // Validate the server name (check if it's a valid hostname or IP address)
	      if (ndpi_is_valid_hostname_or_ip(server_name)) {
	        // Store the server name in the flow's server_certificate field
	        snprintf(flow->protos.stun_ssl.ssl.server_certificate,
	                 sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", server_name);

	        // Optionally, attempt to match the extracted server name to a known protocol
	        if (ndpi_match_protocol_by_hostname(ndpi_struct, flow, server_name)) {
	          // If a subprotocol is detected, set the flow's detected protocol
	          flow->detected_protocol = ndpi_get_protocol_id_by_hostname(ndpi_struct, server_name);
	        }

	        // Return indicating success
	        return 1;
	      }
	    }