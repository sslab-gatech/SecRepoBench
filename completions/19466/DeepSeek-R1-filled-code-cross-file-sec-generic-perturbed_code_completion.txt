u_int16_t len;
char *server_name;
int j;

if (packet->payload[i] == 0x55) {  // Common Name OID (2.5.4.3)
    if (i+5 >= packet->payload_packet_len) break;
    len = packet->payload[i+4];
    server_name = (char*)&packet->payload[i+5];
} else {  // SAN entries
    if (i+3 >= packet->payload_packet_len) break;
    len = (packet->payload[i+1] << 8) | packet->payload[i+2];
    server_name = (char*)&packet->payload[i+3];
}

if (i + len + (packet->payload[i] == 0x55 ? 5 : 3) > packet->payload_packet_len) break;

len = ndpi_min(len, buffer_len-1);
strncpy(buffer, server_name, len);
buffer[len] = '\0';
stripCertificateTrailer(buffer, buffer_len);

u_int8_t valid = 1;
for(j=0; j<len; j++) {
    if(!ndpi_isprint(buffer[j])) {
        valid = 0;
        break;
    }
}

if(valid) {
    if(!ndpi_struct->disable_metadata_export) {
        snprintf(flow->protos.stun_ssl.ssl.server_certificate,
               sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", buffer);
    }
    
    if(ndpi_match_host_subprotocol(ndpi_struct, flow, buffer, strlen(buffer)) != 0)
        return 1;

    if(strcasestr(buffer, "kerberos") || strcasestr(buffer, "_kerberos"))
        ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_KERBEROS, NDPI_PROTOCOL_UNKNOWN);

    return 1;
}