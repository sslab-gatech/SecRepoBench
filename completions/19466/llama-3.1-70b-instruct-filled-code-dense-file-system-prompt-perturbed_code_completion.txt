// Extract the server name from the TLS certificate payload.
// Check if the extracted server name appears to be a valid host name or IP address.
// If valid, store the server name in the flow's `server_certificate` field.
// Optionally, attempt to match the extracted server name to a known protocol.
// If a subprotocol is detected, set the flow's detected protocol accordingly.
// If a valid server name is extracted and optionally matched, return indicating success.
u_int8_t server_len = packet->payload[i+4];

if(i+4+server_len >= packet->payload_packet_len) {
  // packet is truncated... further inspection is not needed
  break;
}

char *server_name = (char*)&packet->payload[i+5];

u_int len = (u_int)ndpi_min(server_len, buffer_len-1);
strncpy(buffer, server_name, len);
buffer[len] = '\0';

// check if organization string are all printable
u_int8_t is_printable = 1;
for (j = 0; j < len; j++) {
  if(!ndpi_isprint(buffer[j])) {
    is_printable = 0;
    break;
  }
}

if(is_printable == 1) {
  snprintf(flow->protos.stun_ssl.ssl.server_certificate,
           sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", buffer);
#ifdef DEBUG_TLS
  printf("Certificate organization: %s\n", flow->protos.stun_ssl.ssl.server_certificate);
#endif
}

// Optionally, attempt to match the extracted server name to a known protocol.
// If a subprotocol is detected, set the flow's detected protocol accordingly.
ndpi_protocol_match_result ret_match;
u_int16_t subproto;

if(buffer[0] == '\0')
  subproto = NDPI_PROTOCOL_UNKNOWN;
else
  subproto = ndpi_match_host_subprotocol(ndpi_struct, flow, buffer,
                                         strlen(buffer),
                                         &ret_match,
                                         NDPI_PROTOCOL_TLS);

if(subproto!= NDPI_PROTOCOL_UNKNOWN) {
  ndpi_set_detected_protocol(ndpi_struct, flow, subproto,
                             ndpi_tls_refine_master_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TLS));
  return(1);
}

// If a valid server name is extracted and optionally matched, return indicating success.
return(1);