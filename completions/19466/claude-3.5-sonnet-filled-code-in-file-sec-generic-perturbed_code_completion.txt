if((packet->payload[i+3] == 0x00) && (packet->payload[i+4] < packet->payload_packet_len - i - 4)) {
  u_int8_t len = packet->payload[i+4];
  char *server_name = (char*)&packet->payload[i+5];
  
  if(len > 0 && len < packet->payload_packet_len - i - 5) {
    u_int8_t is_valid = 1;
    for(int j = 0; j < len; j++) {
      if(!ndpi_isprint(server_name[j])) {
        is_valid = 0;
        break;
      }
    }
    
    if(is_valid) {
      int name_len = ndpi_min(len, buffer_len - 1);
      strncpy(buffer, server_name, name_len);
      buffer[name_len] = '\0';
      
      stripCertificateTrailer(buffer, name_len);
      
      if(!ndpi_struct->disable_metadata_export) {
        snprintf(flow->protos.stun_ssl.ssl.server_certificate,
                 sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", buffer);
      }
      
      u_int16_t subprotocol = 
        ndpi_match_host_subprotocol(ndpi_struct, flow, buffer, 
                                    strlen(buffer), 
                                    &flow->host_server_name_match,
                                    NDPI_PROTOCOL_TLS);
      
      if(subprotocol != NDPI_PROTOCOL_UNKNOWN) {
        ndpi_set_detected_protocol(ndpi_struct, flow, subprotocol, NDPI_PROTOCOL_TLS);
      }
      
      return(1); // Valid server name found
    }
  }
}