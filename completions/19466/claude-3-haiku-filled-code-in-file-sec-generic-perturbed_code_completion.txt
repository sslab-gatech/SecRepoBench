// <MASK>
  char *server_name = NULL;
  int server_name_len = 0;

  for (i = 9; i < packet->payload_packet_len-3; i++) {
    if (((packet->payload[i] == 0x04) && (packet->payload[i+1] == 0x03) && (packet->payload[i+2] == 0x0c))
        || ((packet->payload[i] == 0x04) && (packet->payload[i+1] == 0x03) && (packet->payload[i+2] == 0x13))
        || ((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x04) && (packet->payload[i+2] == 0x03))) {
      // Extract the server name from the TLS certificate payload
      int name_len = packet->payload[i+4];
      server_name = (char*)&packet->payload[i+5];
      server_name_len = (int)ndpi_min(name_len, buffer_len-1);
      strncpy(buffer, server_name, server_name_len);
      buffer[server_name_len] = '\0';

      // Check if the extracted server name appears to be a valid host name or IP address
      if (ndpi_is_valid_hostname(buffer, server_name_len)) {
        // Store the server name in the flow's `server_certificate` field
        snprintf(flow->protos.stun_ssl.ssl.server_certificate, sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", buffer);

        // Attempt to match the extracted server name to a known protocol
        ndpi_protocol_match_result ret_match;
        u_int16_t subproto = ndpi_match_host_subprotocol(ndpi_struct, flow, buffer, server_name_len, &ret_match, NDPI_PROTOCOL_TLS);
        if (subproto != NDPI_PROTOCOL_UNKNOWN) {
          // If a subprotocol is detected, set the flow's detected protocol accordingly
          ndpi_set_detected_protocol(ndpi_struct, flow, subproto, ndpi_tls_refine_master_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TLS));
        }

        // Indicate that a valid server name was extracted and optionally matched
        return 2;
      }
    }
  }