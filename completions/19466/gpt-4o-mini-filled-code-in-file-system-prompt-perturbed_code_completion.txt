// Extract the server name from the TLS certificate payload.
            u_int16_t server_name_len = (packet->payload[i + 3] << 8) + packet->payload[i + 4];
            if (server_name_len > 0 && (i + 5 + server_name_len) < packet->payload_packet_len) {
                strncpy(flow->protos.stun_ssl.ssl.server_certificate, (char*)&packet->payload[i + 5], server_name_len);
                flow->protos.stun_ssl.ssl.server_certificate[server_name_len] = '\0';
                stripCertificateTrailer(flow->protos.stun_ssl.ssl.server_certificate, sizeof(flow->protos.stun_ssl.ssl.server_certificate));

                // Check if the extracted server name appears to be a valid host name or IP address.
                if (is_valid_hostname(flow->protos.stun_ssl.ssl.server_certificate)) {
                    // Optionally, attempt to match the extracted server name to a known protocol.
                    ndpi_protocol_match_result ret_match;
                    u_int16_t subproto = ndpi_match_host_subprotocol(ndpi_struct, flow, flow->protos.stun_ssl.ssl.server_certificate,
                                                                      strlen(flow->protos.stun_ssl.ssl.server_certificate), &ret_match, NDPI_PROTOCOL_TLS);
                    if (subproto != NDPI_PROTOCOL_UNKNOWN) {
                        // If a subprotocol is detected, set the flow's detected protocol accordingly.
                        ndpi_set_detected_protocol(ndpi_struct, flow, subproto, NDPI_PROTOCOL_TLS);
                    }
                    return 1; // Indicate success
                }
            }