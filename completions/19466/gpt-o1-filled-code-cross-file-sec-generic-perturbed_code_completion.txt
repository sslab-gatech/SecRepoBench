{
  /* Attempt to extract the subject's Common Name (CN) from the certificate */
  u_int8_t cn_len = packet->payload[i+4];

  /* Prevent buffer overflow and ensure there's enough data left in the packet */
  if((cn_len < buffer_len) && ((i + 5 + cn_len) < packet->payload_packet_len)) {
    char cn_buf[64];
    u_int8_t j;
    memset(cn_buf, 0, sizeof(cn_buf));

    /* Copy the CN into a temporary buffer */
    if(cn_len >= sizeof(cn_buf)) {
      cn_len = sizeof(cn_buf) - 1;
    }
    memcpy(cn_buf, &packet->payload[i + 5], cn_len);
    cn_buf[cn_len] = '\0';

    /* Remove trailing certificates data if any (similar logic as in client cert) */
    stripCertificateTrailer(cn_buf, sizeof(cn_buf));

    /* Check if this CN is printable and looks valid enough to be a hostname or IP */
    for(j = 0; j < cn_len; j++) {
      if(!ndpi_isprint(cn_buf[j])) {
        break;
      }
    }

    /* If all characters are printable, store in flow->protos.stun_ssl.ssl.server_certificate */
    if(j == cn_len) {
      if(!ndpi_struct->disable_metadata_export) {
        snprintf(flow->protos.stun_ssl.ssl.server_certificate,
                 sizeof(flow->protos.stun_ssl.ssl.server_certificate),
                 "%s", cn_buf);
      }

      /* Optionally match against subprotocol or known patterns here
         if(strstr(cn_buf, "kerberos") != NULL) {
           flow->detected_protocol = NDPI_PROTOCOL_KERBEROS;
         } else if(...) {
           ...
         }
      */

      return(1); /* Indicate we've extracted a valid server certificate name */
    }
  }
}