{
  if (i + 5 < packet->payload_packet_len) {
    u_int8_t asn1_tag = packet->payload[i+3];
    u_int8_t name_length = packet->payload[i+4];
    if (name_length > 0 && (i + 5 + name_length) <= packet->payload_packet_len && name_length < (unsigned)buffer_len) {
      memcpy(buffer, &packet->payload[i+5], name_length);
      buffer[name_length] = '\0';

      int is_valid = 1;
      for (int k = 0; k < name_length; k++) {
        if (!ndpi_isprint(buffer[k])) {
          is_valid = 0;
          break;
        }
      }
      if (is_valid) {
        /* Store the server certificate name in the appropriate field */
        strncpy(flow->protos.stun_ssl.ssl.server_certificate,
                buffer,
                sizeof(flow->protos.stun_ssl.ssl.server_certificate) - 1);
        flow->protos.stun_ssl.ssl.server_certificate[sizeof(flow->protos.stun_ssl.ssl.server_certificate) - 1] = '\0';

        /* Optionally, here one could add protocol matching logic on the extracted server name */

        return 1; /* Indicate success in extracting a valid server certificate name */
      }
    }
  }
}