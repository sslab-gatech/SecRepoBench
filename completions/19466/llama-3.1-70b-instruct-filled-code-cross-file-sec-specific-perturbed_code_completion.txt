// Extract the server name from the TLS certificate payload.
// Check if the extracted server name appears to be a valid host name or IP address.
// If valid, store the server name in the flow's `server_certificate` field.
// Optionally, attempt to match the extracted server name to a known protocol.
// If a subprotocol is detected, set the flow's detected protocol accordingly.
// If a valid server name is extracted and optionally matched, return indicating success.

u_int16_t cert_len = (packet->payload[i+1] << 8) + packet->payload[i+2];
u_int offset = i + 3;

if((offset + cert_len) < packet->payload_packet_len) {
  u_int8_t cert_type = packet->payload[offset];

  if(cert_type == 0x03 /* X.509 certificate */) {
    offset += 1;

    if((offset + 1) < packet->payload_packet_len) {
      u_int8_t cert_len2 = packet->payload[offset];

      offset += 1;

      if((offset + cert_len2) < packet->payload_packet_len) {
        u_int8_t cert_type2 = packet->payload[offset];

        if(cert_type2 == 0x30 /* SEQUENCE */) {
          offset += 1;

          if((offset + 1) < packet->payload_packet_len) {
            u_int8_t cert_len3 = packet->payload[offset];

            offset += 1;

            if((offset + cert_len3) < packet->payload_packet_len) {
              u_int8_t cert_type3 = packet->payload[offset];

              if(cert_type3 == 0x02 /* INTEGER */) {
                offset += 1;

                if((offset + 1) < packet->payload_packet_len) {
                  u_int8_t cert_len4 = packet->payload[offset];

                  offset += 1;

                  if((offset + cert_len4) < packet->payload_packet_len) {
                    // Extract the server name from the TLS certificate payload.
                    u_int16_t server_name_len = (packet->payload[offset+1] << 8) + packet->payload[offset+2];
                    offset += 3;

                    if((offset + server_name_len) < packet->payload_packet_len) {
                      char server_name[64];

                      memset(server_name, 0, sizeof(server_name));
                      strncpy(server_name, (char*)&packet->payload[offset], server_name_len);
                      server_name[server_name_len] = '\0';

                      // Check if the extracted server name appears to be a valid host name or IP address.
                      if(ndpi_is_valid_hostname_or_ip(server_name)) {
                        // Store the server name in the flow's `server_certificate` field.
                        snprintf(flow->protos.stun_ssl.ssl.server_certificate,
                                 sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", server_name);

                        // Optionally, attempt to match the extracted server name to a known protocol.
                        // If a subprotocol is detected, set the flow's detected protocol accordingly.
                        if(ndpi_match_subprotocol(ndpi_struct, flow, server_name)) {
                          // If a valid server name is extracted and optionally matched, return indicating success.
                          return 1;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}