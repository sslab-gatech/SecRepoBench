if(((packet->payload[i] == 0x04) && (packet->payload[i+1] == 0x03) && (packet->payload[i+2] == 0x0c))
   || ((packet->payload[i] == 0x04) && (packet->payload[i+1] == 0x03) && (packet->payload[i+2] == 0x13))
   || ((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x04) && (packet->payload[i+2] == 0x03))) {
  // Extract the server name from the TLS certificate payload.
  // Check if the extracted server name appears to be a valid host name or IP address.
  // If valid, store the server name in the flow's `server_certificate` field.
  // Optionally, attempt to match the extracted server name to a known protocol.
  // If a subprotocol is detected, set the flow's detected protocol accordingly.
  // If a valid server name is extracted and optionally matched, return indicating success.
  // If a valid server name is extracted but not matched, continue to the next iteration.
  // If an invalid server name is extracted, break out of the loop.
  u_int16_t server_name_len = (packet->payload[i+5] << 8) + packet->payload[i+6];
  server_name_len = (u_int)ndpi_min(server_name_len, buffer_len-1);

  if((i+7+server_name_len) < packet->payload_packet_len) {
    strncpy(buffer, (char*)&packet->payload[i+7], server_name_len);
    buffer[server_name_len] = '\0';

    stripCertificateTrailer(buffer, buffer_len);

    if(!ndpi_struct->disable_metadata_export) {
      snprintf(flow->protos.stun_ssl.ssl.server_certificate,
               sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", buffer);
    }

    // Check if the extracted server name appears to be a valid host name or IP address.
    if(ndpi_is_valid_hostname(buffer) || ndpi_is_valid_ip_address(buffer)) {
      // If valid, store the server name in the flow's `server_certificate` field.
      // Optionally, attempt to match the extracted server name to a known protocol.
      // If a subprotocol is detected, set the flow's detected protocol accordingly.
      u_int16_t subproto = ndpi_match_host_subprotocol(ndpi_struct, flow, buffer, server_name_len, NULL, NDPI_PROTOCOL_TLS);
      if(subproto!= NDPI_PROTOCOL_UNKNOWN) {
        ndpi_set_detected_protocol(ndpi_struct, flow, subproto, NDPI_PROTOCOL_TLS);
      }
      return 1; // Return indicating success.
    } else {
      // If an invalid server name is extracted, break out of the loop.
      break;
    }
  }
}