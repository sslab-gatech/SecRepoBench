u_int8_t server_len = packet->payload[i+4];
if(i+4+server_len < packet->payload_packet_len) {
  char *server_name = (char*)&packet->payload[i+5];
  u_int len = (u_int)ndpi_min(server_len, buffer_len-1);
  strncpy(buffer, server_name, len);
  buffer[len] = '\0';

  // check if server name is printable and looks like a hostname or IP
  u_int8_t is_printable = 1;
  for (j = 0; j < len; j++) {
    if(!ndpi_isprint(buffer[j])) {
      is_printable = 0;
      break;
    }
  }

  if(is_printable == 1 && !ndpi_struct->disable_metadata_export) {
    snprintf(flow->protos.stun_ssl.ssl.server_certificate,
             sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", buffer);

    // Optionally, try to match the extracted server name to a known protocol
    // (This is a placeholder, actual implementation may vary)
    // ndpi_match_server_name_to_protocol(ndpi_struct, flow, buffer);

    return 1; // Found and stored server certificate
  }
}