// Extract the server name from the TLS certificate payload.
char server_name[64];
int server_name_len = 0;

// Check for the server name in the certificate payload
if(((packet->payload[i] == 0x04) && (packet->payload[i+1] == 0x03) && (packet->payload[i+2] == 0x0c))
   || ((packet->payload[i] == 0x04) && (packet->payload[i+1] == 0x03) && (packet->payload[i+2] == 0x13))
   || ((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x04) && (packet->payload[i+2] == 0x03))) {
  // Found a potential server name
  server_name_len = packet->payload[i+3];
  if (server_name_len > 0 && i + 4 + server_name_len <= packet->payload_packet_len) {
    strncpy(server_name, (char*)&packet->payload[i+4], server_name_len);
    server_name[server_name_len] = '\0';

    // Check if the extracted server name appears to be a valid host name or IP address
    if(ndpi_is_valid_hostname(server_name, server_name_len) || ndpi_is_ip_address(server_name, server_name_len)) {
      // Store the server name in the flow's `server_certificate` field
      snprintf(flow->protos.stun_ssl.ssl.server_certificate,
               sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", server_name);

      // Optionally, attempt to match the extracted server name to a known protocol
      // ...
      // If a subprotocol is detected, set the flow's detected protocol accordingly
      // ...

      // If a valid server name is extracted and optionally matched, return indicating success
      flow->l4.tcp.tls_seen_server_cert = 1;
      return 1;
    }
  }
}