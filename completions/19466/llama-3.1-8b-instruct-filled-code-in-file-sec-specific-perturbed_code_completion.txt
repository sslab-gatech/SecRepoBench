if((packet->payload[i] == 0x04) && (packet->payload[i+1] == 0x03) && (packet->payload[i+2] == 0x0c))
  || ((packet->payload[i] == 0x04) && (packet->payload[i+1] == 0x03) && (packet->payload[i+2] == 0x13))
  || ((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x04) && (packet->payload[i+2] == 0x03))) {
  // Extract the server name from the TLS certificate payload.
  // Check if the extracted server name appears to be a valid host name or IP address.
  // If valid, store the server name in the flow's `server_certificate` field.
  // Optionally, attempt to match the extracted server name to a known protocol.
  // If a subprotocol is detected, set the flow's detected protocol accordingly.
  // If a valid server name is extracted and optionally matched, return indicating success.
  // <MASK>
  {
    u_int16_t server_name_len = (packet->payload[i+3] << 8) + packet->payload[i+4];
    u_int16_t server_name_offset = i+5;

    if((server_name_offset+server_name_len) < packet->payload_packet_len) {
      char server_name[server_name_len];
      server_name[server_name_len] = '\0';

      strncpy(server_name, (char*)&packet->payload[server_name_offset], server_name_len);

      if(ndpi_is_valid_hostname(server_name)) {
        if(!ndpi_struct->disable_metadata_export) {
          snprintf(flow->protos.stun_ssl.ssl.server_certificate,
                   sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", server_name);
        }

        if(ndpi_match_host_subprotocol(ndpi_struct, flow, server_name, strlen(server_name), NULL, NDPI_PROTOCOL_TLS)!= NDPI_PROTOCOL_UNKNOWN) {
          ndpi_set_detected_protocol(ndpi_struct, flow, ndpi_match_host_subprotocol(ndpi_struct, flow, server_name, strlen(server_name), NULL, NDPI_PROTOCOL_TLS), NDPI_PROTOCOL_TLS);
        }
      }
    }
  }
}