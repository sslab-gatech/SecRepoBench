u_int8_t server_len = packet->payload[i+3];

/* Ensure we don't read beyond the packet */
if((i+4+server_len) > packet->payload_packet_len) {
  break;
}

char *server_name = (char*)&packet->payload[i+4];

/* Copy the server name with bounds checking */
u_int name_len = (u_int)ndpi_min(server_len, buffer_len-1);
strncpy(buffer, server_name, name_len);
buffer[name_len] = '\0';

/* Ensure the name doesn't have unprintable characters */
u_int8_t is_printable = 1;
for(j = 0; j < name_len; j++) {
  if(!ndpi_isprint(buffer[j])) {
    is_printable = 0;
    break;
  }
}

if(is_printable) {
  /* Store the server certificate */
  stripCertificateTrailer(buffer, buffer_len);
  
  if(!ndpi_struct->disable_metadata_export) {
    snprintf(flow->protos.stun_ssl.ssl.server_certificate,
             sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", buffer);
  }
  
  /* Try to match the server name with known protocols */
  if(flow->protos.stun_ssl.ssl.server_certificate[0] != '\0') {
    ndpi_match_host_subprotocol(ndpi_struct, flow,
                                flow->protos.stun_ssl.ssl.server_certificate,
                                strlen(flow->protos.stun_ssl.ssl.server_certificate));
  }
  
  certificate_count++;
  
  /* Return 1 to indicate success */
  return(1 /* Server Certificate */);
}