u_int8_t server_len = packet->payload[i + 3];

// Make sure the length is valid and server name would be within packet bounds
if((server_len > 0) && ((i + 4 + server_len) <= packet->payload_packet_len)) {
  u_int8_t len = ndpi_min(server_len, buffer_len-1);
  
  strncpy(buffer, (char*)&packet->payload[i + 4], len);
  buffer[len] = '\0';
  
  stripCertificateTrailer(buffer, buffer_len);
  
  if(buffer[0] != '\0') {
    /* We found a domain name in the certificate */
    if(!ndpi_struct->disable_metadata_export) {
      snprintf(flow->protos.stun_ssl.ssl.server_certificate, 
               sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", buffer);
    }
    
    NDPI_LOG_DBG2(ndpi_struct, "TLS Certificate CN: %s\n", buffer);
    
    /* Try to match the name with a known protocol */
    ndpi_protocol_match_result ret_match;
    u_int16_t subprotocol = ndpi_match_host_subprotocol(ndpi_struct, flow, 
                                                       buffer, strlen(buffer),
                                                       &ret_match,
                                                       NDPI_PROTOCOL_TLS);
    
    if(subprotocol != NDPI_PROTOCOL_UNKNOWN) {
      ndpi_set_detected_protocol(ndpi_struct, flow, subprotocol, NDPI_PROTOCOL_TLS);
    }
    
    certificate_count++;
    flow->l4.tcp.tls_seen_certificate = 1;
    flow->l4.tcp.tls_seen_server_cert = 1;
    
    return(1); /* Valid server name found */
  }
}