{
  u_int8_t name_len = packet->payload[i+3];
  u_int offset = i + 4;

  if(offset + name_len < packet->payload_packet_len) {
    int cpy_len = (name_len < buffer_len - 1) ? name_len : (buffer_len - 1);
    strncpy(buffer, (char *)&packet->payload[offset], cpy_len);
    buffer[cpy_len] = '\0';

    stripCertificateTrailer(buffer, buffer_len);

    if(!ndpi_struct->disable_metadata_export) {
      snprintf(flow->protos.stun_ssl.ssl.server_certificate,
               sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", buffer);
    }

    /* Attempt to match the extracted server name to a known protocol */
    {
      ndpi_protocol_match_result ret_match;
      u_int16_t subproto = ndpi_match_host_subprotocol(ndpi_struct, flow, buffer,
                                                      strlen(buffer),
                                                      &ret_match,
                                                      NDPI_PROTOCOL_TLS);
      if(subproto != NDPI_PROTOCOL_UNKNOWN) {
        ndpi_set_detected_protocol(ndpi_struct, flow, subproto,
                                   ndpi_tls_refine_master_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TLS));
      }
    }

    flow->l4.tcp.tls_seen_server_cert = 1;
    return 1;
  }
}