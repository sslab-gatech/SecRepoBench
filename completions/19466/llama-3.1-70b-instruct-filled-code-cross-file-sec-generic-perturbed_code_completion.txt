// Extract the server name from the TLS certificate payload.
// Check if the extracted server name appears to be a valid host name or IP address.
// If valid, store the server name in the flow's `server_certificate` field.
// Optionally, attempt to match the extracted server name to a known protocol.
// If a subprotocol is detected, set the flow's detected protocol accordingly.
// If a valid server name is extracted and optionally matched, return indicating success.

u_int16_t server_len = (packet->payload[i+2] << 8) + packet->payload[i+3];
server_len = (u_int)ndpi_min(server_len, buffer_len-1);

if((i+4+server_len) < packet->payload_packet_len) {
  strncpy(buffer, (char*)&packet->payload[i+4], server_len);
  buffer[server_len] = '\0';

  stripCertificateTrailer(buffer, buffer_len);

  if(!ndpi_struct->disable_metadata_export) {
    snprintf(flow->protos.stun_ssl.ssl.server_certificate,
             sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", buffer);
  }

  // Check if the extracted server name appears to be a valid host name or IP address.
  if(ndpi_is_valid_hostname(buffer) || ndpi_is_valid_ip_address(buffer)) {
    // Optionally, attempt to match the extracted server name to a known protocol.
    // If a subprotocol is detected, set the flow's detected protocol accordingly.
    if(ndpi_match_subprotocol(ndpi_struct, flow, buffer) == NDPI_IS_SUBPROTOCOL) {
      // If a valid server name is extracted and optionally matched, return indicating success.
      return(1 /* Server Certificate */);
    }
  }
}