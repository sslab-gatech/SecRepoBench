// Extract the length of the server name
            u_int16_t server_name_len = (packet->payload[i+3] << 8) + packet->payload[i+4];
            // Ensure the length does not exceed the buffer length
            server_name_len = (u_int16_t)ndpi_min(server_name_len, buffer_len - 1);

            // Check if the server name length is within the packet bounds
            if (i + 5 + server_name_len < packet->payload_packet_len) {
              // Copy the server name into the buffer
              strncpy(buffer, (char*)&packet->payload[i+5], server_name_len);
              buffer[server_name_len] = '\0';

              // Strip any trailing characters from the server name
              stripCertificateTrailer(buffer, buffer_len);

              // If metadata export is not disabled, store the server certificate
              if (!ndpi_struct->disable_metadata_export) {
                snprintf(flow->protos.stun_ssl.ssl.server_certificate,
                         sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", buffer);
              }

              // Attempt to match the server name to a known protocol
              ndpi_protocol_match_result ret_match;
              u_int16_t subproto = ndpi_match_host_subprotocol(ndpi_struct, flow, buffer,
                                                               strlen(buffer), &ret_match,
                                                               NDPI_PROTOCOL_TLS);

              // If a subprotocol is detected, set the detected protocol
              if (subproto != NDPI_PROTOCOL_UNKNOWN) {
                ndpi_set_detected_protocol(ndpi_struct, flow, subproto,
                                           ndpi_tls_refine_master_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TLS));
              }

              // Return indicating success
              return 1;
            }