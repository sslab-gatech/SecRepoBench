if((packet->payload[i] == 0x04) && (packet->payload[i+1] == 0x03) && (packet->payload[i+2] == 0x0c)) {
    // Extract the server name from the TLS certificate payload.
    u_int16_t server_name_len = packet->payload[i+3] + (packet->payload[i+4] << 8);
    u_int16_t server_name_offset = i + 5;

    if((server_name_offset + server_name_len) <= packet->payload_packet_len) {
      char *server_name = (char*)&packet->payload[server_name_offset];

      // Check if the extracted server name appears to be a valid host name or IP address.
      if(ndpi_is_valid_hostname(server_name, server_name_len)) {
        // If valid, store the server name in the flow's `server_certificate` field.
        strncpy(flow->protos.stun_ssl.ssl.server_certificate, server_name, server_name_len);
        flow->protos.stun_ssl.ssl.server_certificate[server_name_len] = '\0';

        // Optionally, attempt to match the extracted server name to a known protocol.
        // If a subprotocol is detected, set the flow's detected protocol accordingly.
        // For example, if the server name matches a known Kerberos realm, set the flow's detected protocol to Kerberos.
        if(ndpi_struct->kerberos_dissector != NULL) {
          ndpi_struct->kerberos_dissector(ndpi_struct, flow);
        }

        // If a valid server name is extracted and optionally matched, return indicating success.
        return 1;
      }
    }
  }