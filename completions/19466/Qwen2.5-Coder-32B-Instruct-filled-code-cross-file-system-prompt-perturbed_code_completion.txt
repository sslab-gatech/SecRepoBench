u_int16_t server_name_len = ntohs(*((u_int16_t*)&packet->payload[i+3]));
u_int16_t server_name_offset = i + 5;

if((server_name_offset + server_name_len) < packet->payload_packet_len) {
  char server_name[256];
  strncpy(server_name, (char*)&packet->payload[server_name_offset], server_name_len);
  server_name[server_name_len] = '\0';

  stripCertificateTrailer(server_name, sizeof(server_name));

  if(!ndpi_struct->disable_metadata_export) {
    snprintf(flow->protos.stun_ssl.ssl.server_certificate, sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", server_name);
  }

  // Optionally, attempt to match the extracted server name to a known protocol.
  // If a subprotocol is detected, set the flow's detected protocol accordingly.
  // For example:
  // if(ndpi_match_known_server_name(ndpi_struct, server_name)) {
  //   flow->detected_protocol = ndpi_match_known_server_name(ndpi_struct, server_name);
  // }

  return 1; // Indicate success
}