n", cert_start);
      if(cert_start < packet->payload_packet_len) {
	return 1;
      }
    }
  }

  return 0;
}

/* **************************************** */

static u_int8_t ndpi_search_tlsv1_direction1(struct ndpi_detection_module_struct *ndpi_struct,
					     struct ndpi_flow_struct *flow) {
  struct ndpi_packet_struct *packet = &flow->packet;

  if((packet->payload_packet_len >= 5)
     && (packet->payload[0] == 0x16)
     && (packet->payload[1] == 0x03)
     && ((packet->payload[2] == 0x01) || (packet->payload[2] == 0x02) ||
         (packet->payload[2] == 0x03))) {
    u_int32_t temp;
    NDPI_LOG_DBG2(ndpi_struct, "search sslv1\n");
    // SSLv1 Record
    if(packet->payload_packet_len >= 1300) {
      return 1;
    }
    temp = ntohs(get_u_int16_t(packet->payload, 3)) + 5;
    NDPI_LOG_DBG2(ndpi_struct, "temp = %u\n", temp);
    if(packet->payload_packet_len == temp
       || (temp < packet->payload_packet_len && packet->payload_packet_len > 500)) {
      return 1;
    }

    if(packet->payload_packet_len < temp && temp < 5000 && packet->payload_packet_len > 9) {
      /* the server hello may be split into small packets */
      u_int32_t cert_start;

      NDPI_LOG_DBG2(ndpi_struct,
		    "maybe SSLv1 server hello split into smaller packets\n");

      /* lets hope at least the server hello and the start of the certificate block are in the first packet */
      cert_start = ntohs(get_u_int16_t(packet->payload, 7)) + 5 + 4;
      NDPI_LOG_DBG2(ndpi_struct, "suspected start of certificate: %u\n", cert_start);
      if(cert_start < packet->payload_packet_len) {
	return 1;
      }
    }
  }

  return 0;
}

/* **************************************** */

static u_int8_t ndpi_search_tlsv1_2_direction1(struct ndpi_detection_module_struct *ndpi_struct,
					       struct ndpi_flow_struct *flow) {
  struct ndpi_packet_struct *packet = &flow->packet;

  if((packet->payload_packet_len >= 5)
     && (packet->payload[0] == 0x16)
     && (packet->payload[1] == 0x03)
     && ((packet->payload[2] == 0x03) || (packet->payload[2] == 0x02))) {
    u_int32_t temp;
    NDPI_LOG_DBG2(ndpi_struct, "search sslv1.2\n");
    // SSLv1.2 Record
    if(packet->payload_packet_len >= 1300) {
      return 1;
    }
    temp = ntohs(get_u_int16_t(packet->payload, 3)) + 5;
    NDPI_LOG_DBG2(ndpi_struct, "temp = %u\n", temp);
    if(packet->payload_packet_len == temp
       || (temp < packet->payload_packet_len && packet->payload_packet_len > 500)) {
      return 1;
    }

    if(packet->payload_packet_len < temp && temp < 5000 && packet->payload_packet_len > 9) {
      /* the server hello may be split into small packets */
      u_int32_t cert_start;

      NDPI_LOG_DBG2(ndpi_struct,
		    "maybe SSLv1.2 server hello split into smaller packets\n");

      /* lets hope at least the server hello and the start of the certificate block are in the first packet */
      cert_start = ntohs(get_u_int16_t(packet->payload, 7)) + 5 + 4;
      NDPI_LOG_DBG2(ndpi_struct, "suspected start of certificate: %u\n", cert_start);
      if(cert_start < packet->payload_packet_len) {
	return 1;
      }
    }
  }

  return 0;
}

/* **************************************** */

static u_int8_t ndpi_search_dtls_direction1(struct ndpi_detection_module_struct *ndpi_struct,
					    struct ndpi_flow_struct *flow) {
  struct ndpi_packet_struct *packet = &flow->packet;

  if((packet->payload_packet_len >= 5)
     && (packet->payload[0] == 0x16)
     && (packet->payload[1] == 0x03)
     && ((packet->payload[2] == 0x00) || (packet->payload[2] == 0x01) ||
         (packet->payload[2] == 0x02) || (packet->payload[2] == 0x03))) {
    u_int32_t temp;
    NDPI_LOG_DBG2(ndpi_struct, "search dtls\n");
    // DTLS Record
    if(packet->payload_packet_len >= 1300) {
      return 1;
    }
    temp = ntohs(get_u_int16_t(packet->payload, 3)) + 5;
    NDPI_LOG_DBG2(ndpi_struct, "temp = %u\n", temp);
    if(packet->payload_packet_len == temp
       || (temp < packet->payload_packet_len && packet->payload_packet_len > 500)) {
      return 1;
    }

    if(packet->payload_packet_len < temp && temp < 5000 && packet->payload_packet_len > 9) {
      /* the server hello may be split into small packets */
      u_int32_t cert_start;

      NDPI_LOG_DBG2(ndpi_struct,
		    "maybe DTLS server hello split into smaller packets\n");

      /* lets hope at least the server hello and the start of the certificate block are in the first packet */
      cert_start = ntohs(get_u_int16_t(packet->payload, 7)) + 5 + 4;
      NDPI_LOG_DBG2(ndpi_struct, "suspected start of certificate: %u\n", cert_start);
      if(cert_start < packet->payload_packet_len) {
	return 1;
      }
    }
  }

  return 0;
}

/* **************************************** */

static u_int8_t ndpi_search_tls_direction1(struct ndpi_detection_module_struct *ndpi_struct,
					   struct ndpi_flow_struct *flow) {
  struct ndpi_packet_struct *packet = &flow->packet;

  if(packet->payload_packet_len >= 5) {
    if(packet->payload[0] == 0x16) {
      if(packet->payload[1] == 0x03) {
	if(packet->payload[2] == 0x01 || packet->payload[2] == 0x02 || packet->payload[2] == 0x03) {
	  return ndpi_search_tlsv1_direction1(ndpi_struct, flow);
	} else if(packet->payload[2] == 0x03) {
	  return ndpi_search_tlsv1_2_direction1(ndpi_struct, flow);
	}
      } else if(packet->payload[1] == 0x16) {
	return ndpi_search_dtls_direction1(ndpi_struct, flow);
      }
    }
  }

  return 0;
}

/* **************************************** */

static u_int8_t ndpi_search_tls_direction(struct ndpi_detection_module_struct *ndpi_struct,
					  struct ndpi_flow_struct *flow) {
  struct ndpi_packet_struct *packet = &flow->packet;

  if(packet->payload_packet_len >= 5) {
    if(packet->payload[0] == 0x16) {
      if(packet->payload[1] == 0x03) {
	if(packet->payload[2] == 0x01 || packet->payload[2] == 0x02 || packet->payload[2] == 0x03) {
	  return ndpi_search_tlsv1_direction1(ndpi_struct, flow);
	} else if(packet->payload[2] == 0x03) {
	  return ndpi_search_tlsv1_2_direction1(ndpi_struct, flow);
	}
      } else if(packet->payload[1] == 0x16) {
	return ndpi_search_dtls_direction1(ndpi_struct, flow);
      }
    }
  }

  return 0;
}

/* **************************************** */

static void ndpi_search_tls_payload(struct ndpi_detection_module_struct *ndpi_struct,
				    struct ndpi_flow_struct *flow) {
  struct ndpi_packet_struct *packet = &flow->packet;

  if(packet->payload_packet_len >= 5) {
    if(packet->payload[0] == 0x16) {
      if(packet->payload[1] == 0x03) {
	if(packet->payload[2] == 0x01 || packet->payload[2] == 0x02 || packet->payload[2] == 0x03) {
	  if(ndpi_search_tlsv1_direction1(ndpi_struct, flow)) {
	    tls_mark_and_payload_search(ndpi_struct, flow, 0);
	    return;
	  }
	} else if(packet->payload[2] == 0x03) {
	  if(ndpi_search_tlsv1_2_direction1(ndpi_struct, flow)) {
	    tls_mark_and_payload_search(ndpi_struct, flow, 0);
	    return;
	  }
	}
      } else if(packet->payload[1] == 0x16) {
	if(ndpi_search_dtls_direction1(ndpi_struct, flow)) {
	  tls_mark_and_payload_search(ndpi_struct, flow, 0);
	  return;
	}
      }
    }
  }

  tls_mark_and_payload_search(ndpi_struct, flow, 1);
}

/* **************************************** */

static void ndpi_search_tls_payload_no_cert(struct ndpi_detection_module_struct *ndpi_struct,
					    struct ndpi_flow_struct *flow) {
  struct ndpi_packet_struct *packet = &flow->packet;

  if(packet->payload_packet_len >= 5) {
    if(packet->payload[0] == 0x16) {
      if(packet->payload[1] == 0x03) {
	if(packet->payload[2] == 0x01 || packet->payload[2] == 0x02 || packet->payload[2] == 0x03) {
	  if(ndpi_search_tlsv1_direction1(ndpi_struct, flow)) {
	    tls_mark_and_payload_search(ndpi_struct, flow, 1);
	    return;
	  }
	} else if(packet->payload[2] == 0x03) {
	  if(ndpi_search_tlsv1_2_direction1(ndpi_struct, flow)) {
	    tls_mark_and_payload_search(ndpi_struct, flow, 1);
	    return;
	  }
	}
      } else if(packet->payload[1] == 0x16) {
	if(ndpi_search_dtls_direction1(ndpi_