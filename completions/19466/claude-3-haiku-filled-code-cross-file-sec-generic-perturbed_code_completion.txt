// Extract the server name from the TLS certificate payload.
u_int16_t len;
len = (packet->payload[i+4] << 8) + packet->payload[i+5];
len = (u_int)ndpi_min(len, buffer_len-1);

if((i+6+len) < packet->payload_packet_len) {
  char *server_name = (char*)&packet->payload[i+6];
  strncpy(buffer, server_name, len);
  buffer[len] = '\0';

  // Check if the extracted server name appears to be a valid host name or IP address.
  if(ndpi_is_valid_hostname(buffer) || ndpi_is_valid_ip_address(buffer)) {
    // Store the server name in the flow's `server_certificate` field.
    snprintf(flow->protos.stun_ssl.ssl.server_certificate, sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", buffer);

    // Attempt to match the extracted server name to a known protocol.
    ndpi_protocol_match_result match_result;
    ndpi_match_host_subprotocol(ndpi_struct, flow, buffer, strlen(buffer), &match_result);
    if(match_result.protocol_id != NDPI_PROTOCOL_UNKNOWN) {
      // Set the flow's detected protocol accordingly.
      flow->detected_protocol_stack[0] = match_result.protocol_id;
      flow->detected_protocol_stack[1] = match_result.protocol_id;
    }

    // Indicate success
    return 1;
  }
}