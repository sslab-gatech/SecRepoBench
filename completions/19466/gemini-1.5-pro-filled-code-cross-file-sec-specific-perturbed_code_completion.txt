int offset = i + 3;
                    u_int16_t server_name_len;

                    if (offset + 2 > packet->payload_packet_len) {
                        break;
                    }

                    server_name_len = ntohs(*((u_int16_t *)&packet->payload[offset]));
                    offset += 2;

                    if (offset + server_name_len > packet->payload_packet_len) {
                        break;
                    }
                    if (server_name_len < buffer_len) {
                        memcpy(buffer, &packet->payload[offset], server_name_len);
                        buffer[server_name_len] = '\0';

                        if (!ndpi_struct->disable_metadata_export) {
                            // check if server_name is valid
                            if (isValidHostNameOrIP(buffer)) {
                                snprintf(flow->protos.stun_ssl.ssl.server_certificate,
                                         sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", buffer);
                                return 1;
                            }
                        }
                    }