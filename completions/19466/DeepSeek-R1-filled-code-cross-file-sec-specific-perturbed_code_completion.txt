u_int16_t len = (packet->payload[i+3] << 8) | packet->payload[i+4];
len = ndpi_min(len, buffer_len - 1);

if(i + 5 + len <= packet->payload_packet_len) {
    strncpy(buffer, (char*)&packet->payload[i+5], len);
    buffer[len] = '\0';
    stripCertificateTrailer(buffer, buffer_len);

    u_int8_t valid = 1;
    for(int j = 0; j < len; j++) {
        if(!ndpi_isprint(buffer[j])) {
            valid = 0;
            break;
        }
    }

    if(valid) {
        if(!ndpi_struct->disable_metadata_export) {
            snprintf(flow->protos.stun_ssl.ssl.server_certificate,
                    sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", buffer);
        }

        if(ndpi_match_host_subprotocol(ndpi_struct, flow, buffer, strlen(buffer))) {
            ndpi_set_detected_protocol(ndpi_struct, flow, flow->detected_protocol_stack[0], flow->detected_protocol_stack[1]);
        }

        return 1;
    }
}