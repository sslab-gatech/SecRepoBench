u_int16_t server_name_len, server_name_offset;

// Ensure there is enough data to safely extract the length of the server name.
if ((i + 3) >= packet->payload_packet_len) {
  break;
}

server_name_len = (packet->payload[i+3] << 8) + packet->payload[i+4];
server_name_offset = i + 5;

// Check if the remaining payload is sufficient to hold the server name.
if ((server_name_offset + server_name_len) > packet->payload_packet_len) {
  break;
}

// Limit the length of the server name to avoid buffer overflow.
server_name_len = (u_int16_t)ndpi_min(server_name_len, (u_int16_t)(buffer_len - 1));

// Extract and copy the server name into the provided buffer.
memcpy(buffer, &packet->payload[server_name_offset], server_name_len);
buffer[server_name_len] = '\0';

// Validate that the extracted server name appears to be a valid host name or IP address.
if (ndpi_is_valid_hostname_or_ip(buffer)) {
  // Store the server name in the flow's `server_certificate` field.
  if (!ndpi_struct->disable_metadata_export) {
    snprintf(flow->protos.stun_ssl.ssl.server_certificate,
             sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", buffer);
  }

  // Optionally, attempt to match the extracted server name to a known protocol.
  if (ndpi_match_subprotocol(ndpi_struct, flow, buffer)) {
    // If a subprotocol is detected, set the flow's detected protocol accordingly.
    flow->guessed_protocol_id = NDPI_PROTOCOL_TLS_SUBPROTOCOL;
  }

  // Return indicating success if a valid server name is extracted and optionally matched.
  return 1;
}