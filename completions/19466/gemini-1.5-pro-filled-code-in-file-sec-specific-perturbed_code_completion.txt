int offset = i + 3;
                    u_int16_t server_name_len;

                    if (offset + 1 > packet->payload_packet_len) {
                        break;
                    }
                    server_name_len = ntohs(*((u_int16_t *)&packet->payload[offset]));

                    offset += 2;
                    if (offset + server_name_len > packet->payload_packet_len) {
                        break;
                    }

                    int len = ndpi_min((int)server_name_len, buffer_len - 1);
                    if (len > 0) {
                        strncpy(buffer, (char *)&packet->payload[offset], len);
                        buffer[len] = '\0';

                        stripCertificateTrailer(buffer, buffer_len);

                        if (!ndpi_struct->disable_metadata_export) {
                            snprintf(flow->protos.stun_ssl.ssl.server_certificate,
                                     sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", buffer);
                        }

                        ndpi_protocol_match_result ret_match;
                        u_int16_t subproto = ndpi_match_host_subprotocol(ndpi_struct, flow, buffer,
                                                                        strlen(buffer),
                                                                        &ret_match,
                                                                        NDPI_PROTOCOL_TLS);

                        if (subproto != NDPI_PROTOCOL_UNKNOWN) {
                            ndpi_set_detected_protocol(ndpi_struct, flow, subproto,
                                                    ndpi_tls_refine_master_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TLS));
                        }
                        return 1; // Indicate success
                    }