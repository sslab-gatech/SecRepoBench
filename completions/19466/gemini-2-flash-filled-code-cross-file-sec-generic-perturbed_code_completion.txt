u_int16_t server_name_len = packet->payload[i+3];

	    if((i + 5 + server_name_len) <= packet->payload_packet_len) {
	      char *server_name = (char*)&packet->payload[i+5];
	      u_int len = ndpi_min(server_name_len, (u_int)(buffer_len - 1));

	      strncpy(buffer, server_name, len);
	      buffer[len] = '\0';

	      stripCertificateTrailer(buffer, buffer_len);

	      if(ndpi_is_valid_hostname(buffer) || ndpi_is_valid_ipv4(buffer)
		 || ndpi_is_valid_ipv6(buffer)) {
		if(!ndpi_struct->disable_metadata_export) {
		  snprintf(flow->protos.stun_ssl.ssl.server_certificate,
			   sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", buffer);
		}

		/* Sub protocol detection based on certificate */
		ndpi_match_certificate(ndpi_struct, flow, buffer);

#ifdef NDPI_PROTOCOL_DNS
		if(flow->detected_protocol->master_protocol == NDPI_PROTOCOL_DNS) {
		  NDPI_LOG_INFO(ndpi_struct, "Detected DNS over TLS based on certificate\n");
		  return 1;
		}
#endif
		return 1;
	      }
	    }