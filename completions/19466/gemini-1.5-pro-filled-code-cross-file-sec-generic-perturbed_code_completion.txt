int offset = i + 3;
                    u_int16_t server_name_len;

                    if (offset + 2 < packet->payload_packet_len) {
                        server_name_len = (packet->payload[offset + 1] << 8) + packet->payload[offset + 2];
                        offset += 3;
                    } else {
                        break;
                    }


                    if (offset + server_name_len < packet->payload_packet_len) {
                        int name_len = ndpi_min((int)server_name_len, buffer_len - 1);

                        if (name_len > 0) {
                            memcpy(buffer, &packet->payload[offset], name_len);
                            buffer[name_len] = '\0';

                            stripCertificateTrailer(buffer, buffer_len);

                            if (!ndpi_struct->disable_metadata_export) {
                                snprintf(flow->protos.stun_ssl.ssl.server_certificate,
                                    sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", buffer);
                            }

#ifdef DEBUG_TLS
                            printf("Server certificate: %s\n", flow->protos.stun_ssl.ssl.server_certificate);
#endif

                            return 1; // Indicate that a server name was extracted
                        }
                    }