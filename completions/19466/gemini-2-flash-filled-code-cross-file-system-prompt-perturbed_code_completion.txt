u_int16_t server_name_len = (packet->payload[i+3] << 8) + packet->payload[i+4];

	    if((i + 5 + server_name_len) <= packet->payload_packet_len) {
	      char *server_name = (char*)&packet->payload[i+5];
	      u_int len = (u_int)ndpi_min(server_name_len, buffer_len-1);

	      strncpy(buffer, server_name, len);
	      buffer[len] = '\0';

	      if(ndpi_is_valid_hostname(buffer, 0) || ndpi_is_valid_ipv4(buffer)) {
		snprintf(flow->protos.stun_ssl.ssl.server_certificate,
			 sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", buffer);

		/* Subprotocol detection based on server name */
		ndpi_match_subprotocol(ndpi_struct, flow, buffer);

#ifdef NDPI_PROTOCOL_DNS
		if(flow->detected_protocol->master_protocol == NDPI_PROTOCOL_DNS) {
		  /* Force DNS detection */
		  NDPI_ADD_PROTOCOL_TO_BITMASK(flow->detected_protocol_stack, NDPI_PROTOCOL_DNS);
		  return 1;
		}
#endif

		return 1;
	      }
	    }