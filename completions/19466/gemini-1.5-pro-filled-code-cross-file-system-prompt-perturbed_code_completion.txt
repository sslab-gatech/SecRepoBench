int offset = i + 3;
                    u_int16_t server_name_len;

                    if (offset + 1 >= packet->payload_packet_len) {
                      break;
                    }

                    server_name_len = (packet->payload[offset] << 8) + packet->payload[offset + 1];
                    offset += 2;

                    if (offset + server_name_len >= packet->payload_packet_len) {
                      break;
                    }
                    if (server_name_len < buffer_len) {
                      memcpy(buffer, packet->payload + offset, server_name_len);
                      buffer[server_name_len] = 0;

                      if (ndpi_is_valid_server_name(buffer, server_name_len)) {
                        if (!ndpi_struct->disable_metadata_export) {
                          snprintf(flow->protos.stun_ssl.ssl.server_certificate,
                              sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", buffer);
                        }

                        // Optionally attempt subprotocol detection based on the server name.
                        // Example:
                        // if (strstr(buffer, "example.com")) {
                        //   ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_EXAMPLE, NDPI_PROTOCOL_UNKNOWN);
                        // }

                        return 1; // Indicate success
                      }
                    }