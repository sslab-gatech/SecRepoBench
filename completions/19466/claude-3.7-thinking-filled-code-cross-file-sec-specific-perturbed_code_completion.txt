if((i+4) < packet->payload_packet_len) {
  u_int8_t len = packet->payload[i+3];
  
  if((len > 0) && ((i+5+len) <= packet->payload_packet_len)) {
    char *server_name = (char*)&packet->payload[i+5];
    
    /* Size-1 to ensure null termination */
    u_int name_len = (u_int)ndpi_min(len, buffer_len-1);
    
    if(name_len > 0) {
      strncpy(buffer, server_name, name_len);
      buffer[name_len] = '\0';
      
      /* Check if the string contains printable characters */
      u_int8_t is_printable = 1;
      u_int j;
      
      for(j = 0; j < name_len; j++) {
        if(!ndpi_isprint(buffer[j])) {
          is_printable = 0;
          break;
        }
      }
      
      if(is_printable) {
        stripCertificateTrailer(buffer, buffer_len);
        
        if(!ndpi_struct->disable_metadata_export) {
          snprintf(flow->protos.stun_ssl.ssl.server_certificate,
                  sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", buffer);
        }
        
        certificate_count++;
        
        /* Try to match the server name with known protocols */
        if(certificate_count == 1) {
          flow->l4.tcp.tls_certificate_detected++;
          return(1); /* Server certificate detected and extracted */
        }
      }
    }
  }
}