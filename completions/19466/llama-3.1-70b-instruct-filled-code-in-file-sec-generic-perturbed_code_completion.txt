// Extract the server name from the TLS certificate payload.
// Check if the extracted server name appears to be a valid host name or IP address.
// If valid, store the server name in the flow's `server_certificate` field.
// Optionally, attempt to match the extracted server name to a known protocol.
// If a subprotocol is detected, set the flow's detected protocol accordingly.
// If a valid server name is extracted and optionally matched, return indicating success.
// If a valid server name is extracted and optionally matched, return indicating success.
if ((packet->payload[i] == 0x04) && (packet->payload[i+1] == 0x03) && (packet->payload[i+2] == 0x0c)) {
    u_int8_t server_len = packet->payload[i+4];

    if (server_len < (sizeof(buffer)-1)) {
        strncpy(buffer, (char*)&packet->payload[i+5], server_len);
        buffer[server_len] = '\0';

        stripCertificateTrailer(buffer, buffer_len);

        if (!ndpi_struct->disable_metadata_export) {
            snprintf(flow->protos.stun_ssl.ssl.server_certificate,
                     sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", buffer);
        }

        // Check if the extracted server name appears to be a valid host name or IP address.
        if (ndpi_is_valid_hostname(buffer) || ndpi_is_valid_ip_address(buffer)) {
            // Optionally, attempt to match the extracted server name to a known protocol.
            u_int16_t subproto = ndpi_match_host_subprotocol(ndpi_struct, flow, buffer, strlen(buffer),
                                                             NULL, NDPI_PROTOCOL_TLS);

            if (subproto!= NDPI_PROTOCOL_UNKNOWN) {
                // If a subprotocol is detected, set the flow's detected protocol accordingly.
                ndpi_set_detected_protocol(ndpi_struct, flow, subproto, NDPI_PROTOCOL_TLS);
            }
        }
    }
}