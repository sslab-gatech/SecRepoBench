{
  if(i + 5 < packet->payload_packet_len) {
    u_int8_t name_len = packet->payload[i+4];
    if(i + 5 + name_len <= packet->payload_packet_len && name_len > 0) {
      char server_name[256];
      u_int name_size = (u_int)ndpi_min(name_len, sizeof(server_name) - 1);
      memcpy(server_name, &packet->payload[i+5], name_size);
      server_name[name_size] = '\0';

      // Check that the server name is printable
      int is_valid = 1;
      for (int k = 0; k < (int)name_size; k++) {
        if(!ndpi_isprint(server_name[k])) {
          is_valid = 0;
          break;
        }
      }

      if(is_valid) {
        // Store the extracted server name in the flow's server_certificate field.
        strncpy(flow->protos.stun_ssl.ssl.server_certificate, server_name,
                sizeof(flow->protos.stun_ssl.ssl.server_certificate) - 1);
        flow->protos.stun_ssl.ssl.server_certificate[sizeof(flow->protos.stun_ssl.ssl.server_certificate) - 1] = '\0';

        // Optionally match the server name to a known protocol
        if(strstr(server_name, "smtp") != NULL) {
          flow->detected_protocol = NDPI_PROTOCOL_SMTP;
        }
        // Return indicating successful extraction.
        return 1;
      }
    }
  }
}