// Extract the length of the server name
	    u_int16_t server_name_len = (packet->payload[i+3] << 8) + packet->payload[i+4];
	    if (i + 5 + server_name_len < packet->payload_packet_len) {
	      // Copy the server name into the buffer
	      strncpy(buffer, (char*)&packet->payload[i+5], server_name_len);
	      buffer[server_name_len] = '\0';

	      // Validate the server name
	      if (ndpi_is_valid_hostname(buffer)) {
	        // Store the server name in the flow's server_certificate field
	        snprintf(flow->protos.stun_ssl.ssl.server_certificate,
	                 sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", buffer);

	        // Attempt to match the server name to a known protocol
	        ndpi_protocol_match_result ret_match;
	        u_int16_t subproto = ndpi_match_host_subprotocol(ndpi_struct, flow, buffer,
	                                                         strlen(buffer), &ret_match,
	                                                         NDPI_PROTOCOL_TLS);

	        // If a subprotocol is detected, set the flow's detected protocol
	        if (subproto != NDPI_PROTOCOL_UNKNOWN) {
	          ndpi_set_detected_protocol(ndpi_struct, flow, subproto,
	                                     ndpi_tls_refine_master_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TLS));
	        }

	        return 1; // Indicate success
	      }
	    }