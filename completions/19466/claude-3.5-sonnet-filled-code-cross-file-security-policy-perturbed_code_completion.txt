u_int16_t len = (packet->payload[i+3] << 8) + packet->payload[i+4];
len = (u_int)ndpi_min(len, buffer_len-1);

if((i+5+len) <= packet->payload_packet_len) {
  strncpy(buffer, (char*)&packet->payload[i+5], len);
  buffer[len] = '\0';

  stripCertificateTrailer(buffer, buffer_len);

  if(ndpi_is_valid_hostname(buffer, len) || ndpi_is_valid_ip(buffer, len)) {
    if(!ndpi_struct->disable_metadata_export) {
      snprintf(flow->protos.stun_ssl.ssl.server_certificate,
               sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", buffer);
    }

    u_int16_t subprotocol_id = ndpi_match_hostname_to_protocol(ndpi_struct, buffer, len);
    if(subprotocol_id != NDPI_PROTOCOL_UNKNOWN) {
      flow->detected_protocol_stack[1] = subprotocol_id;
    }

    return(1); // Server Certificate found
  }
}