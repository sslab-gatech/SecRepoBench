{
  /* The next byte after the OID bytes typically contains the length of the server name string */
  u_int8_t name_len = packet->payload[i+3];

  /* Ensure we don't go out of bounds */
  if((i + 4 + name_len) <= packet->payload_packet_len) {
    char tmp[256];
    u_int copy_len = (name_len < (sizeof(tmp) - 1)) ? name_len : (sizeof(tmp) - 1);
    u_int j;

    /* Copy the server name */
    memcpy(tmp, &packet->payload[i + 4], copy_len);
    tmp[copy_len] = '\0';

    /* Strip possible trailing characters/spaces */
    stripCertificateTrailer(tmp, sizeof(tmp));

    /* Check that the extracted name is printable */
    {
      u_int8_t is_printable = 1;
      for(j = 0; j < copy_len; j++) {
        if(!ndpi_isprint(tmp[j])) {
          is_printable = 0;
          break;
        }
      }
      if(is_printable) {
        /* Store the server name if metadata export is not disabled */
        if(!ndpi_struct->disable_metadata_export) {
          snprintf(flow->protos.stun_ssl.ssl.server_certificate,
                   sizeof(flow->protos.stun_ssl.ssl.server_certificate),
                   "%s", tmp);
        }

        /* Optionally match the extracted name to known subprotocols here */
        /* e.g., if(strstr(tmp, "some_subproto") != NULL) { ... } */

        /* If a valid server name is found, return success */
        return(1);
      }
    }
  }
}