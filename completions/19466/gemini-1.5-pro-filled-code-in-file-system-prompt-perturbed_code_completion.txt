int subproto = NDPI_PROTOCOL_UNKNOWN;
u_int server_name_len;
char *server_name = (char*)&packet->payload[i+3];

server_name_len = packet->payload[i+3];

if((i+4+server_name_len) < packet->payload_packet_len) {
  u_int len = (u_int)ndpi_min(server_name_len, buffer_len-1);
  strncpy(buffer, server_name, len);
  buffer[len] = '\0';

  stripCertificateTrailer(buffer, buffer_len);

  if(!ndpi_struct->disable_metadata_export) {
    snprintf(flow->protos.stun_ssl.ssl.server_certificate,
	     sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", buffer);
  }

#ifdef DEBUG_TLS
  NDPI_LOG_DBG2(ndpi_struct, "***** [SSL] %s\n", buffer);
#endif

  ndpi_protocol_match_result ret_match;
  subproto = ndpi_match_host_subprotocol(ndpi_struct, flow, buffer,
					 strlen(buffer),
					 &ret_match,
					 NDPI_PROTOCOL_TLS);
  if(subproto != NDPI_PROTOCOL_UNKNOWN) {
    ndpi_set_detected_protocol(ndpi_struct, flow, subproto,
			       ndpi_tls_refine_master_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TLS));
  }

  if(ndpi_is_tls_tor(ndpi_struct, flow, buffer) != 0)
    return 1; /* We're good */
}

if(subproto != NDPI_PROTOCOL_UNKNOWN) {
  return 1;
}