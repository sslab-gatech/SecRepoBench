u_int16_t server_name_len = ntohs(*(u_int16_t*)&packet->payload[i+3]);
if(i+5+server_name_len <= packet->payload_packet_len) {
  char server_name[256];
  u_int len = ndpi_min(server_name_len, sizeof(server_name)-1);
  
  strncpy(server_name, (char*)&packet->payload[i+5], len);
  server_name[len] = '\0';
  
  stripCertificateTrailer(server_name, len);
  
  if(ndpi_isprint(server_name[0])) {
    snprintf(flow->protos.stun_ssl.ssl.server_certificate,
             sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", server_name);
    
    u_int16_t subproto = ndpi_match_host_subprotocol(ndpi_struct, flow, 
                                                     server_name, strlen(server_name),
                                                     &flow->host_server_name_match,
                                                     NDPI_PROTOCOL_TLS);
    if(subproto != NDPI_PROTOCOL_UNKNOWN) {
      ndpi_set_detected_protocol(ndpi_struct, flow, subproto, NDPI_PROTOCOL_TLS);
    }
    
    return 1; // Valid server name found
  }
}