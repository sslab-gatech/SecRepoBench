{
  /* Safely extract the length of the server name following the matched OID bytes */
  u_int8_t name_len_offset = (packet->payload[i] == 0x55) ? (i + 4) : (i + 3);
  if((name_len_offset < (packet->payload_packet_len - 1))) {
    u_int8_t name_len = packet->payload[name_len_offset];
    /* Prevent reading out of bounds and ensure we have room for a null terminator */
    if((name_len_offset + 1 + name_len) <= packet->payload_packet_len) {
      u_int8_t copy_len = (name_len < (buffer_len - 1)) ? name_len : (buffer_len - 1);
      strncpy(buffer, (char*)&packet->payload[name_len_offset + 1], copy_len);
      buffer[copy_len] = '\0';

      /* Strip trailing non-printable characters if any */
      stripCertificateTrailer(buffer, buffer_len);

      /* Check if the extracted name is printable (as a rudimentary validity check) */
      {
        u_int8_t is_printable = 1;
        for(u_int8_t k = 0; k < copy_len; k++) {
          if(!ndpi_isprint(buffer[k])) {
            is_printable = 0;
            break;
          }
        }
        /* If valid, store it */
        if(is_printable) {
          snprintf(flow->protos.stun_ssl.ssl.server_certificate,
                   sizeof(flow->protos.stun_ssl.ssl.server_certificate),
                   "%s", buffer);

          /* Optionally match extracted name to a known protocol if desired:
             e.g., ndpi_match_host_protocol(ndpi_struct, flow, buffer);
             If a match is found, set flow->detected_protocol accordingly.
          */

          /* Indicate success in extracting the server name */
          return(1);
        }
      }
    }
  }
}