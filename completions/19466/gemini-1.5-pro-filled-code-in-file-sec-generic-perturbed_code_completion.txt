#include <ctype.h>
#include <string.h>

	    int j;
	    u_int server_name_len;
	    char server_name[256]; // Increased buffer size

	    memset(server_name, 0, sizeof(server_name));

	    server_name_len = (packet->payload[i + 3] << 8) + packet->payload[i + 4];
	    if (server_name_len > 0 && server_name_len < sizeof(server_name)) {
	      memcpy(server_name, &packet->payload[i + 5], server_name_len);
	      server_name[server_name_len] = '\0';

	      // Basic validation: printable characters only
	      for (j = 0; j < server_name_len; j++) {
		if (!isprint(server_name[j])) {
		  memset(server_name, 0, sizeof(server_name));
		  break;
		}
	      }
	    }

	    if (server_name[0] != '\0') {
	      stripCertificateTrailer(server_name, sizeof(server_name));

	      if (!ndpi_struct->disable_metadata_export) {
		snprintf(flow->protos.stun_ssl.ssl.server_certificate,
			 sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", server_name);
	      }

	      ndpi_protocol_match_result ret_match;
	      u_int16_t subproto = ndpi_match_host_subprotocol(ndpi_struct, flow, server_name,
							    strlen(server_name),
							    &ret_match,
							    NDPI_PROTOCOL_TLS);

	      if (subproto != NDPI_PROTOCOL_UNKNOWN) {
		ndpi_set_detected_protocol(ndpi_struct, flow, subproto,
					   ndpi_tls_refine_master_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TLS));
	      }

	      flow->l4.tcp.tls_seen_server_cert = 1;
	      return 1; // Indicate success
	    }