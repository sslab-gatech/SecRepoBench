if((i + 3) < packet->payload_packet_len) {
  u_int8_t len = packet->payload[i + 3];
  if((i + 4 + len) <= packet->payload_packet_len) {
    char *server_name = (char*)&packet->payload[i + 4];
    u_int8_t is_valid = 1;
    u_int16_t j;

    for(j = 0; j < len; j++) {
      if(!ndpi_isprint(server_name[j])) {
        is_valid = 0;
        break;
      }
    }

    if(is_valid) {
      if(len > sizeof(flow->protos.stun_ssl.ssl.server_certificate) - 1)
        len = sizeof(flow->protos.stun_ssl.ssl.server_certificate) - 1;

      strncpy(flow->protos.stun_ssl.ssl.server_certificate, server_name, len);
      flow->protos.stun_ssl.ssl.server_certificate[len] = '\0';

      stripCertificateTrailer(flow->protos.stun_ssl.ssl.server_certificate, sizeof(flow->protos.stun_ssl.ssl.server_certificate));

      ndpi_protocol_match_result ret_match;
      u_int16_t subproto = ndpi_match_host_subprotocol(ndpi_struct, flow, 
                                                       flow->protos.stun_ssl.ssl.server_certificate,
                                                       strlen(flow->protos.stun_ssl.ssl.server_certificate),
                                                       &ret_match,
                                                       NDPI_PROTOCOL_TLS);

      if(subproto != NDPI_PROTOCOL_UNKNOWN) {
        ndpi_set_detected_protocol(ndpi_struct, flow, subproto, NDPI_PROTOCOL_TLS);
      }

      return 1;
    }
  }
}