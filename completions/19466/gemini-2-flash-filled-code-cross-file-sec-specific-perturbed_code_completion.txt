u_int16_t server_name_len = packet->payload[i+3];
	    if (i + 4 + server_name_len <= packet->payload_packet_len && server_name_len > 0) {
	      char *server_name = (char*)&packet->payload[i+4];
	      u_int len = (u_int)ndpi_min(server_name_len, (u_int)buffer_len - 1);

		  /* Check for potential heap overflow before copying */
		  if (len > 0 && len < buffer_len) {
			strncpy(buffer, server_name, len);
			buffer[len] = '\0';

			if (ndpi_check_hostname(buffer) || ndpi_check_ipv4(buffer) || ndpi_check_ipv6(buffer)) {
			  snprintf(flow->protos.stun_ssl.ssl.server_certificate,
				   sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", buffer);

			  /* Check if the extracted server name matches a known protocol */
			  ndpi_match_protocol_from_server_name(ndpi_struct, flow, buffer);

			  return 1;
			}
		  }
	    }