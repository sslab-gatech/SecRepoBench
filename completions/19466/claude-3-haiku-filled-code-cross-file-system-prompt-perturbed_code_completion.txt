// Extract the server name from the TLS certificate payload.
// Check if the extracted server name appears to be a valid host name or IP address.
// If valid, store the server name in the flow's `server_certificate` field.
// Optionally, attempt to match the extracted server name to a known protocol.
// If a subprotocol is detected, set the flow's detected protocol accordingly.
// If a valid server name is extracted and optionally matched, return indicating success.
u_int8_t server_name_len = packet->payload[i+4];
if((i+4+server_name_len) < packet->payload_packet_len) {
  char server_name[256];
  strncpy(server_name, (char*)&packet->payload[i+5], server_name_len);
  server_name[server_name_len] = '\0';

  if(ndpi_is_valid_hostname(server_name) || ndpi_is_valid_ip_address(server_name)) {
    snprintf(flow->protos.stun_ssl.ssl.server_certificate, sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", server_name);

    // Attempt to match the server name to a known protocol
    ndpi_protocol_match_result match_result;
    ndpi_match_host_subprotocol(ndpi_struct, flow, server_name, strlen(server_name), &match_result);
    if(match_result.protocol_id != NDPI_PROTOCOL_UNKNOWN) {
      flow->detected_protocol_stack[0] = match_result.protocol_id;
      flow->detected_protocol_stack[1] = match_result.protocol_id;
    }

    return 1; // Indicate success
  }
}