if(i+5 < packet->payload_packet_len) { /* Make sure we can read server length byte */
  u_int8_t server_len = packet->payload[i+4];
  
  if(i+5+server_len <= packet->payload_packet_len) { /* Make sure the full server name is within the packet */
    char *server_name = (char*)&packet->payload[i+5];
    u_int len = (u_int)ndpi_min(server_len, buffer_len-1);
    
    strncpy(buffer, server_name, len);
    buffer[len] = '\0';
    
    stripCertificateTrailer(buffer, buffer_len);
    
    /* Check if the server name contains only printable characters */
    u_int8_t is_printable = 1;
    for(u_int j = 0; j < len; j++) {
      if(!ndpi_isprint(buffer[j])) {
        is_printable = 0;
        break;
      }
    }
    
    if(is_printable) {
      if(!ndpi_struct->disable_metadata_export) {
        snprintf(flow->protos.stun_ssl.ssl.server_certificate,
                sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", buffer);
      }

#ifdef DEBUG_TLS
      printf("TLS Certificate found: %s\n", buffer);
#endif
      
      /* Try to match the server name with a known protocol */
      if(buffer[0] != '\0') {
        ndpi_protocol_match_result ret_match;
        u_int16_t subproto = ndpi_match_host_subprotocol(ndpi_struct, flow, 
                                                      buffer,
                                                      strlen(buffer),
                                                      &ret_match,
                                                      NDPI_PROTOCOL_TLS);
        
        if(subproto != NDPI_PROTOCOL_UNKNOWN) {
          ndpi_set_detected_protocol(ndpi_struct, flow, subproto, 
                                    ndpi_tls_refine_master_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TLS));
        }
      }
      
      return(1); /* Found a valid server name */
    }
  }
}