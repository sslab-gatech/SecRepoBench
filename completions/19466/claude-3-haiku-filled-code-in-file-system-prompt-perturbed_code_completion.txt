if((packet->payload[i] == 0x04) && (packet->payload[i+1] == 0x03) && (packet->payload[i+2] == 0x0c))
{
    // Extract the server name from the TLS certificate payload
    u_int16_t len = packet->payload[i+4];
    if((i+5+len) < packet->payload_packet_len) {
        char server_name[64];
        strncpy(server_name, (char*)&packet->payload[i+5], len);
        server_name[len] = '\0';

        // Check if the extracted server name appears to be a valid host name or IP address
        if(ndpi_is_valid_hostname(server_name, len)) {
            // Store the server name in the flow's `server_certificate` field
            snprintf(flow->protos.stun_ssl.ssl.server_certificate, sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", server_name);

            // Optionally, attempt to match the extracted server name to a known protocol
            ndpi_protocol_match_result ret_match;
            u_int16_t subproto = ndpi_match_host_subprotocol(ndpi_struct, flow, server_name, len, &ret_match, NDPI_PROTOCOL_TLS);
            if(subproto != NDPI_PROTOCOL_UNKNOWN) {
                ndpi_set_detected_protocol(ndpi_struct, flow, subproto, NDPI_PROTOCOL_TLS);
                return;
            }
        }
    }
}
else if((packet->payload[i] == 0x04) && (packet->payload[i+1] == 0x03) && (packet->payload[i+2] == 0x13))
{
    // Extract the server name from the TLS certificate payload
    u_int16_t len = packet->payload[i+5];
    if((i+6+len) < packet->payload_packet_len) {
        char server_name[64];
        strncpy(server_name, (char*)&packet->payload[i+6], len);
        server_name[len] = '\0';

        // Check if the extracted server name appears to be a valid host name or IP address
        if(ndpi_is_valid_hostname(server_name, len)) {
            // Store the server name in the flow's `server_certificate` field
            snprintf(flow->protos.stun_ssl.ssl.server_certificate, sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", server_name);

            // Optionally, attempt to match the extracted server name to a known protocol
            ndpi_protocol_match_result ret_match;
            u_int16_t subproto = ndpi_match_host_subprotocol(ndpi_struct, flow, server_name, len, &ret_match, NDPI_PROTOCOL_TLS);
            if(subproto != NDPI_PROTOCOL_UNKNOWN) {
                ndpi_set_detected_protocol(ndpi_struct, flow, subproto, NDPI_PROTOCOL_TLS);
                return;
            }
        }
    }
}
else if((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x04) && (packet->payload[i+2] == 0x03))
{
    // Extract the server name from the TLS certificate payload
    u_int16_t len = packet->payload[i+4];
    if((i+5+len) < packet->payload_packet_len) {
        char server_name[64];
        strncpy(server_name, (char*)&packet->payload[i+5], len);
        server_name[len] = '\0';

        // Check if the extracted server name appears to be a valid host name or IP address
        if(ndpi_is_valid_hostname(server_name, len)) {
            // Store the server name in the flow's `server_certificate` field
            snprintf(flow->protos.stun_ssl.ssl.server_certificate, sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", server_name);

            // Optionally, attempt to match the extracted server name to a known protocol
            ndpi_protocol_match_result ret_match;
            u_int16_t subproto = ndpi_match_host_subprotocol(ndpi_struct, flow, server_name, len, &ret_match, NDPI_PROTOCOL_TLS);
            if(subproto != NDPI_PROTOCOL_UNKNOWN) {
                ndpi_set_detected_protocol(ndpi_struct, flow, subproto, NDPI_PROTOCOL_TLS);
                return;
            }
        }
    }
}