// Extract the length of the server name
	    u_int8_t server_name_len = packet->payload[i+3];
	    // Ensure the length does not exceed the buffer length
	    if (server_name_len < buffer_len - 1) {
	      // Copy the server name into the buffer
	      strncpy(buffer, (char*)&packet->payload[i+4], server_name_len);
	      buffer[server_name_len] = '\0';
	      // Strip any trailing characters from the server name
	      stripCertificateTrailer(buffer, server_name_len);
	      // Check if the server name is a valid host name or IP address
	      if (ndpi_is_valid_host(buffer)) {
	        // Store the server name in the flow's server_certificate field
	        snprintf(flow->protos.stun_ssl.ssl.server_certificate,
	                 sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", buffer);
	        // Attempt to match the server name to a known protocol
	        ndpi_protocol_match_result ret_match;
	        u_int16_t subproto = ndpi_match_host_subprotocol(ndpi_struct, flow, buffer,
	                                                         strlen(buffer), &ret_match,
	                                                         NDPI_PROTOCOL_TLS);
	        // If a subprotocol is detected, set the flow's detected protocol
	        if (subproto != NDPI_PROTOCOL_UNKNOWN) {
	          ndpi_set_detected_protocol(ndpi_struct, flow, subproto, NDPI_PROTOCOL_TLS);
	        }
	        return 1; // Indicate success
	      }
	    }