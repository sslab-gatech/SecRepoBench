// Extract the server name from the TLS certificate payload.
u_int16_t len;
len = (packet->payload[i+4] << 8) + packet->payload[i+5];
len = (u_int)ndpi_min(len, buffer_len-1);

if((i+6+len) < packet->payload_packet_len) {
  strncpy(buffer, (char*)&packet->payload[i+6], len);
  buffer[len] = '\0';

  stripCertificateTrailer(buffer, buffer_len);

  if(!ndpi_struct->disable_metadata_export) {
    snprintf(flow->protos.stun_ssl.ssl.server_certificate,
             sizeof(flow->protos.stun_ssl.ssl.server_certificate), "%s", buffer);
  }

  // Check if the extracted server name appears to be a valid host name or IP address.
  if(ndpi_is_valid_hostname(buffer, len)) {
    // Optionally, attempt to match the extracted server name to a known protocol.
    ndpi_protocol_match_result match_result;
    ndpi_match_host_protocol_name(ndpi_struct, flow, buffer, &match_result);
    if(match_result.protocol_id != NDPI_PROTOCOL_UNKNOWN) {
      flow->detected_protocol_stack[0] = match_result.protocol_id;
    }
    return 1; // Indicate success
  }
}
return 0; // Indicate failure