/**
 * xmlLoadEntityContent:
 * @ctxt:  an XML parser context
 * @entity: an unloaded system entity
 *
 * Load the original content of the given system entity from the
 * ExternalID/SystemID given. This is to be used for Included in Literal
 * http://www.w3.org/TR/REC-xml/#inliteral processing of entities references
 *
 * Returns 0 in case of success and -1 in case of failure
 */
static int
xmlLoadEntityContent(xmlParserCtxtPtr ctxt, xmlEntityPtr entity) {
    xmlParserInputPtr input;
    xmlBufferPtr buf;
    int l, c;
    int count = 0;

    if ((ctxt == NULL) || (entity == NULL) ||
        ((entity->etype != XML_EXTERNAL_PARAMETER_ENTITY) &&
         (entity->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY)) ||
        (entity->content != NULL)) {
        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
                    "xmlLoadEntityContent parameter error");
        return(-1);
    }

    if (xmlParserDebugEntities)
        xmlGenericError(xmlGenericErrorContext,
                "Reading %s entity content input\n", entity->name);

    buf = xmlBufferCreate();
    if (buf == NULL) {
        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
                    "xmlLoadEntityContent parameter error");
        return(-1);
    }
    xmlBufferSetAllocationScheme(buf, XML_BUFFER_ALLOC_DOUBLEIT);

    input = xmlNewEntityInputStream(ctxt, entity);
    if (input == NULL) {
        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
                    "xmlLoadEntityContent input error");
        xmlBufferFree(buf);
        return(-1);
    }

    /*
     * Push the entity as the current input, read char by char
     * saving to the buffer until the end of the entity or an error
     */
    if (xmlPushInput(ctxt, input) < 0) {
        xmlBufferFree(buf);
        return(-1);
    }

    GROW;
    c = CUR_CHAR(l);
    while ((ctxt->input == input) && (ctxt->input->cur < ctxt->input->end) &&
           (IS_CHAR(c))) {
        xmlBufferAdd(buf, ctxt->input->cur, l);
        if (count++ > XML_PARSER_CHUNK_SIZE) {
            count = 0;
            GROW;
            if (ctxt->instate == XML_PARSER_EOF) {
                xmlBufferFree(buf);
                return(-1);
            }
        }
        NEXTL(l);
        c = CUR_CHAR(l);
        if (c == 0) {
            count = 0;
            GROW;
            if (ctxt->instate == XML_PARSER_EOF) {
                xmlBufferFree(buf);
                return(-1);
            }
            c = CUR_CHAR(l);
        }
    }

    if ((ctxt->input == input) && (ctxt->input->cur >= ctxt->input->end)) {
        xmlPopInput(ctxt);
    } else if (!IS_CHAR(c)) {
        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
                          "xmlLoadEntityContent: invalid char value %d\n",
                          c);
        xmlBufferFree(buf);
        return(-1);
    }
    entity->content = buf->content;
    buf->content = NULL;
    xmlBufferFree(buf);

    return(0);
}