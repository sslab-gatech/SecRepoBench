ret = ctxt->inputTab[--ctxt->inputNr];
    if (ctxt->inputNr == 0) {
        ctxt->input = NULL;
    } else {
        ctxt->input = ctxt->inputTab[ctxt->inputNr - 1];
    }
    return (ret);
}

/**
 * xmlParseStringEntityRef:
 * @ctxt:  an XML parser context
 * @str:  the string to parse
 *
 * Parse a string entity reference
 *
 * Returns the entity or NULL in case of error
 */
static xmlEntityPtr
xmlParseStringEntityRef(xmlParserCtxtPtr ctxt, const xmlChar **str)
{
    xmlEntityPtr ret;
    const xmlChar *cur;
    int len;

    if (ctxt == NULL)
        return(NULL);
    cur = *str;
    if ((cur == NULL) || (*cur == 0))
        return(NULL);
    if (cur[0] != '&')
        return(NULL);
    cur++;
    if ((cur[0] == '#') && (cur[1] == 'x')) {
        cur += 2;
        len = 0;
        while ((*cur >= '0') && (*cur <= '9')) {
            len = (len << 4) + (*cur - '0');
            cur++;
        }
        while ((*cur >= 'a') && (*cur <= 'f')) {
            len = (len << 4) + (*cur - 'a' + 10);
            cur++;
        }
        while ((*cur >= 'A') && (*cur <= 'F')) {
            len = (len << 4) + (*cur - 'A' + 10);
            cur++;
        }
        if ((*cur == ';') && (len <= 0xFFFF)) {
            ret = xmlNewEntity(ctxt->dict, NULL, len, 0);
            if (ret == NULL)
                return(NULL);
            *str = cur + 1;
            return(ret);
        }
    } else {
        len = 0;
        while ((*cur >= '0') && (*cur <= '9')) {
            len = len * 10 + (*cur - '0');
            cur++;
        }
        if ((*cur == ';') && (len <= 0xFFFF)) {
            ret = xmlNewEntity(ctxt->dict, NULL, len, 0);
            if (ret == NULL)
                return(NULL);
            *str = cur + 1;
            return(ret);
        }
    }
    return(NULL);
}

/**
 * xmlParseCharData:
 * @ctxt:  an XML parser context
 * @maxlen:  the maximum length of the data to parse
 *
 * Parse a chunk of character data
 *
 * Returns the number of characters parsed or -1 in case of error
 */
static int
xmlParseCharData(xmlParserCtxtPtr ctxt, int maxlen)
{
    int len;
    const xmlChar *cur;

    if (ctxt == NULL)
        return(-1);
    cur = ctxt->input->cur;
    if (cur == NULL)
        return(-1);
    len = 0;
    while ((len < maxlen) && (cur[0] != 0) && (cur[0] != '<')) {
        len++;
        cur++;
    }
    if (len == 0)
        return(-1);
    if (xmlStrncmp(ctxt->input->base, cur - len, len) != 0)
        return(-1);
    ctxt->input->cur = cur;
    ctxt->input->col++;
    ctxt->input->consumed += len;
    ctxt->size += len;
    return(len);
}

/**
 * xmlParseChunk:
 * @ctxt:  an XML parser context
 * @chunk:  the chunk of data to parse
 * @len:  the length of the chunk
 *
 * Parse a chunk of data
 *
 * Returns the number of characters parsed or -1 in case of error
 */
static int
xmlParseChunk(xmlParserCtxtPtr ctxt, const char *chunk, int len)
{
    int ret;

    if (ctxt == NULL)
        return(-1);
    ret = xmlParseChunkInternal(ctxt, chunk, len);
    if (ret < 0)
        return(-1);
    return(ret);
}

/**
 * xmlParseChunkInternal:
 * @ctxt:  an XML parser context
 * @chunk:  the chunk of data to parse
 * @len:  the length of the chunk
 *
 * Parse a chunk of data
 *
 * Returns the number of characters parsed or -1 in case of error
 */
static int
xmlParseChunkInternal(xmlParserCtxtPtr ctxt, const char *chunk, int len)
{
    int ret;

    if (ctxt == NULL)
        return(-1);
    if (ctxt->input == NULL)
        return(-1);
    if (ctxt->input->base == NULL)
        return(-1);
    if (ctxt->input->cur == NULL)
        return(-1);
    if (ctxt->input->end == NULL)
        return(-1);
    if (chunk == NULL)
        return(-1);
    if (len <= 0)
        return(0);

    ret = xmlParseInNodeContext(ctxt, chunk, len);
    if (ret < 0)
        return(-1);
    return(ret);
}

/**
 * xmlParseInNodeContext:
 * @ctxt:  an XML parser context
 * @chunk:  the chunk of data to parse
 * @len:  the length of the chunk
 *
 * Parse a chunk of data in the context of a node
 *
 * Returns the number of characters parsed or -1 in case of error
 */
static int
xmlParseInNodeContext(xmlParserCtxtPtr ctxt, const char *chunk, int len)
{
    int ret;

    if (ctxt == NULL)
        return(-1);
    if (ctxt->input == NULL)
        return(-1);
    if (ctxt->input->base == NULL)
        return(-1);
    if (ctxt->input->cur == NULL)
        return(-1);
    if (ctxt->input->end == NULL)
        return(-1);
    if (chunk == NULL)
        return(-1);
    if (len <= 0)
        return(0);

    if (ctxt->node != NULL) {
        ret = xmlParseInNode(ctxt, chunk, len, ctxt->node);
    } else {
        ret = xmlParseChunk(ctxt, chunk, len);
    }
    if (ret < 0)
        return(-1);
    return(ret);
}

/**
 * xmlParseEntityRef:
 * @ctxt:  an XML parser context
 *
 * Parse an entity reference
 *
 * Returns the entity or NULL in case of error
 */
static xmlEntityPtr
xmlParseEntityRef(xmlParserCtxtPtr ctxt)
{
    const xmlChar *cur;
    xmlEntityPtr ret;

    if (ctxt == NULL)
        return(NULL);
    cur = ctxt->input->cur;
    if (cur == NULL)
        return(NULL);
    if (cur[0] != '&')
        return(NULL);
    cur++;
    ret = xmlParseStringEntityRef(ctxt, &cur);
    if (ret == NULL)
        return(NULL);
    if (cur != NULL) {
        ctxt->input->cur = (xmlChar *) cur;
        ctxt->input->col++;
        ctxt->input->consumed += (cur - (ctxt->input->base +
                                         (ctxt->input->cur - ctxt->input->base)));
    }
    return(ret);
}

/**
 * xmlParseCharRef:
 * @ctxt:  an XML parser context
 *
 * Parse a character reference
 *
 * Returns the character or -1 in case of error
 */
static int
xmlParseCharRef(xmlParserCtxtPtr ctxt)
{
    const xmlChar *cur;
    int ret;

    if (ctxt == NULL)
        return(-1);
    cur = ctxt->input->cur;
    if (cur == NULL)
        return(-1);
    if (cur[0] != '&')
        return(-1);
    cur++;
    if ((cur[0] == '#') && (cur[1] == 'x')) {
        cur += 2;
        ret = 0;
        while ((*cur >= '0') && (*cur <= '9')) {
            ret = (ret << 4) + (*cur - '0');
            cur++;
        }
        while ((*cur >= 'a') && (*cur <= 'f')) {
            ret = (ret << 4) + (*cur - 'a' + 10);
            cur++;
        }
        while ((*cur >= 'A') && (*cur <= 'F')) {
            ret = (ret << 4) + (*cur - 'A' + 10);
            cur++;
        }
        if (*cur == ';') {
            cur++;
            ctxt->input->cur = (xmlChar *) cur;
            ctxt->input->col++;
            ctxt->input->consumed += (cur - (ctxt->input->base +
                                             (ctxt->input->cur - ctxt->input->base)));
            return(ret);
        }
    } else {
        ret = 0;
        while ((*cur >= '0') && (*cur <= '9')) {
            ret = ret * 10 + (*cur - '0');
            cur++;
        }
        if (*cur == ';') {
            cur++;
            ctxt->input->cur = (xmlChar *) cur;
            ctxt->input->col++;
            ctxt->input->consumed += (cur - (ctxt->input->base +
                                             (ctxt->input->cur - ctxt->input->base)));
            return(ret);
        }
    }
    return(-1);
}

/**
 * xmlParsePI:
 * @ctxt:  an XML parser context
 *
 * Parse a processing instruction
 *
 * Returns the target or NULL in case of error
 */
static const xmlChar *
xmlParsePI(xmlParserCtxtPtr ctxt)
{
    const xmlChar *cur;
    const xmlChar *target;

    if (ctxt == NULL)
        return(NULL);
    cur = ctxt->input->cur;
    if (cur == NULL)
        return(NULL);
    if ((cur[0] != '<') || (cur[1] != '?'))
        return(NULL);
    cur += 2;
    target = cur;
    while ((*cur != 0) && (*cur != ' '))
        cur++;
    if (*cur == ' ')
        cur++;
    if (*cur != '?')
        return(NULL);
    cur++;
    if (*cur != '>')
        return(NULL);
    cur++;
    ctxt->input->cur = cur;
    ctxt->input->col++;
    ctxt->input->consumed += (cur - (ctxt->input->base +
                                     (ctxt->input->cur - ctxt->input->base)));
    return(target);
}

/**
 * xmlParseComment:
 * @ctxt:  an XML parser context
 *
 * Parse a comment
 *
 * Returns the content of the comment or NULL in case of error
 */
static const xmlChar *
xmlParseComment(xmlParserCtxtPtr ctxt)
{
    const xmlChar *cur;

    if (ctxt == NULL)
        return(NULL);
    cur = ctxt->input->cur;
    if (cur == NULL)
        return(NULL);
    if ((cur[0] != '<') || (cur[1] != '!') || (cur[2] != '-') ||
        (cur[3] != '-'))
        return(NULL);
    cur += 4;
    while ((*cur != 0) && (*cur != '-') && (*cur != '-') && (*cur != '>'))
        cur++;
    if (*cur == '-')
        cur++;
    if (*cur == '-')
        cur++;
    if (*cur == '>')
        cur++;
    ctxt->input->cur = cur;
    ctxt->input->col++;
    ctxt->input->consumed += (cur - (ctxt->input->base +
                                     (ctxt->input->cur - ctxt->input->base)));
    return(cur);
}

/**
 * xmlParseElementDecl:
 * @ctxt:  an XML parser context
 *
 * Parse an element declaration
 *
 * Returns the content of the element declaration or NULL in case of error
 */
static const xmlChar *
xmlParseElementDecl(xmlParserCtxtPtr ctxt)
{
    const xmlChar *cur;