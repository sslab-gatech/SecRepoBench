// Parse the entity reference from the XML parser context.
// Check if the entity is null and return if it is.
// Store the entity's checked status for later use.
// Handle the special case for predefined entities:
//  - Retrieve the content of the entity.
//  - Check if the content is null and return if it is.
//  - Inline the entity content using the SAX character handler if available.
ent = xmlGetPredefinedEntity(ent->name);
if (ent!= NULL) {
    if (ent->content!= NULL) {
        if ((ctxt->sax!= NULL) && (ctxt->sax->characters!= NULL) &&
            (!ctxt->disableSAX))
            ctxt->sax->characters(ctxt->userData, ent->content);
        return;
    }
    ent = NULL;
}

// If the entity is not predefined, check if it's null and return if it is.
if (ent == NULL) {
    ent = xmlParseStringEntityRef(ctxt, &ctxt->input->cur);
    if (ent == NULL)
        return;
}

// Store the entity's checked status for later use.
ent->checked = 1;

// Check if the entity is well formed
if (ent->etype == XML_INTERNAL_GENERAL_ENTITY) {
    ctxt->depth++;
    ret = xmlParseBalancedChunkMemoryInternal(ctxt, ent->content,
                                              ctxt->userData, &list);
    ctxt->depth--;
} else if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY) {
    ctxt->depth++;
    ret = xmlParseExternalEntityPrivate(ctxt->myDoc, ctxt, ctxt->sax,
                                   ctxt->userData, ctxt->depth, ent->URI,
                                   ent->ExternalID, &list);
    ctxt->depth--;
} else {
    ret = XML_ERR_ENTITY_PE_INTERNAL;
    xmlErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR,
                 "invalid entity type found\n", NULL);
}

// Store the number of entities needing parsing for this entity content and do checkings
diff = ctxt->nbentities - oldnbent + 1;
if (diff > INT_MAX / 2)
    diff = INT_MAX / 2;
ent->checked = diff * 2;
if ((ent->content!= NULL) && (xmlStrchr(ent->content, '<')))
    ent->checked |= 1;
if (ret == XML_ERR_ENTITY_LOOP) {
    xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
    xmlHaltParser(ctxt);
    xmlFreeNodeList(list);
    return;
}
if (xmlParserEntityCheck(ctxt, 0, ent, 0)) {
    xmlFreeNodeList(list);
    return;
}

// If the entity content has been gathered, provide it to the application
if ((ret == XML_ERR_OK) && (list!= NULL)) {
    if (((ent->etype == XML_INTERNAL_GENERAL_ENTITY) ||
         (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)) &&
        (ent->children == NULL)) {
        ent->children = list;
        // Prune the entity content directly in the generated document
        // except for single text nodes.
        if ((ctxt->replaceEntities == 0) ||
            (ctxt->parseMode == XML_PARSE_READER) ||
            ((list->type == XML_TEXT_NODE) &&
             (list->next == NULL))) {
            ent->owner = 1;
            while (list!= NULL) {
                list->parent = (xmlNodePtr) ent;
                xmlSetTreeDoc(list, ent->doc);
                if (list->next == NULL)
                    ent->last = list;
                list = list->next;
            }
            list = NULL;
        } else {
            ent->owner = 0;
            while (list!= NULL) {
                list->parent = (xmlNodePtr) ctxt->node;
                list->doc = ctxt->myDoc;
                if (list->next == NULL)
                    ent->last = list;
                list = list->next;
            }
            list = ent->children;
#ifdef LIBXML_LEGACY_ENABLED
            if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)
                xmlAddEntityReference(ent, list, NULL);
#endif /* LIBXML_LEGACY_ENABLED */
        }
    } else {
        xmlFreeNodeList(list);
        list = NULL;
    }
} else if ((ret!= XML_ERR_OK) &&
           (ret!= XML_WAR_UNDECLARED_ENTITY)) {
    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
                     "Entity '%s' failed to parse\n", ent->name);
    if (ent->content!= NULL)
        ent->content[0] = 0;
    xmlParserEntityCheck(ctxt, 0, ent, 0);
} else if (list!= NULL) {
    xmlFreeNodeList(list);
    list = NULL;
}
if (ent->checked == 0)
    ent->checked = 2;

// Prevent entity from being parsed and expanded twice (Bug 760367).
entity_checked_status = 0;