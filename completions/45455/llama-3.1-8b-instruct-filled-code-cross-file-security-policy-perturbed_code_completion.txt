// <MASK>
if (ent->etype == XML_INTERNAL_GENERAL_ENTITY) {
    ctxt->depth++;
    ret = xmlParseBalancedChunkMemoryInternal(ctxt, ent->content,
                                              user_data, &list);
    ctxt->depth--;
} else if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY) {
    ctxt->depth++;
    ret = xmlParseExternalEntityPrivate(ctxt->myDoc, ctxt, ctxt->sax,
                                   user_data, ctxt->depth, ent->URI,
					   ent->ExternalID, &list);
    ctxt->depth--;
} else {
    ret = XML_ERR_ENTITY_PE_INTERNAL;
    xmlErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR,
                 "invalid entity type found\n", NULL);
}

/*
 * Store the number of entities needing parsing for this entity
 * content and do checkings
 */
diff = ctxt->nbentities - oldnbent + 1;
if (diff > INT_MAX / 2)
    diff = INT_MAX / 2;
ent->checked = diff * 2;
if ((ent->content!= NULL) && (xmlStrchr(ent->content, '<')))
    ent->checked |= 1;
if (ret == XML_ERR_ENTITY_LOOP) {
    xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
    xmlHaltParser(ctxt);
    xmlFreeNodeList(list);
    return;
}
if (xmlParserEntityCheck(ctxt, 0, ent, 0)) {
    xmlFreeNodeList(list);
    return;
}

if ((ret == XML_ERR_OK) && (list!= NULL)) {
    if (((ent->etype == XML_INTERNAL_GENERAL_ENTITY) ||
         (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)) &&
        (ent->children == NULL)) {
        ent->children = list;
        /*
         * Prune it directly in the generated document
         * except for single text nodes.
         */
        if ((ctxt->replaceEntities == 0) ||
            (ctxt->parseMode == XML_PARSE_READER) ||
            ((list->type == XML_TEXT_NODE) &&
             (list->next == NULL))) {
            ent->owner = 1;
            while (list!= NULL) {
                list->parent = (xmlNodePtr) ent;
                xmlSetTreeDoc(list, ent->doc);
                if (list->next == NULL)
                    ent->last = list;
                list = list->next;
            }
            list = NULL;
        } else {
            ent->owner = 0;
            while (list!= NULL) {
                list->parent = (xmlNodePtr) ctxt->node;
                list->doc = ctxt->myDoc;
                if (list->next == NULL)
                    ent->last = list;
                list = list->next;
            }
            list = ent->children;
#ifdef LIBXML_LEGACY_ENABLED
            if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)
                xmlAddEntityReference(ent, list, NULL);
#endif /* LIBXML_LEGACY_ENABLED */
        }
    } else {
        xmlFreeNodeList(list);
        list = NULL;
    }
} else if ((ret!= XML_ERR_OK) &&
           (ret!= XML_WAR_UNDECLARED_ENTITY)) {
    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
                     "Entity '%s' failed to parse\n", ent->name);
    if (ent->content!= NULL)
        ent->content[0] = 0;
    xmlParserEntityCheck(ctxt, 0, ent, 0);
} else if (list!= NULL) {
    xmlFreeNodeList(list);
    list = NULL;
}
if (ent->checked == 0)
    ent->checked = 2;

/* Prevent entity from being parsed and expanded twice (Bug 760367). */
entity_checked_status = 0;