const xmlChar *name;
    xmlChar *content = NULL;

    // Parse the entity reference from the XML parser context
    name = xmlParseStringName(ctxt, &ctxt->input->cur);
    if (name == NULL) {
        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED, "xmlParseReference: no name\n");
        return;
    }

    // Check if the entity is null and return if it is
    ent = xmlGetPredefinedEntity(name);
    if (ent == NULL) {
        ent = xmlSAX2GetEntity(ctxt, name);
    }
    if (ent == NULL) {
        xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY, "Entity '%s' not defined\n", name);
        return;
    }

    // Store the entity's checked status for later use
    entity_checked_status = ent->checked;

    // Handle the special case for predefined entities
    if (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY) {
        // Retrieve the content of the entity
        content = ent->content;
        // Check if the content is null and return if it is
        if (content == NULL) {
            xmlFatalErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR, "Predefined entity '%s' has no content\n", name);
            return;
        }
        // Inline the entity content using the SAX character handler if available
        if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) && (!ctxt->disableSAX)) {
            ctxt->sax->characters(ctxt->userData, content, xmlStrlen(content));
        }
        return;
    }