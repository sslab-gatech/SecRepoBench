switch (method)
{
  case ReadSingleSampleMethod:
  {
    /*
      Convert TIFF image to PseudoClass MIFF image.
    */
    quantum_type=IndexQuantum;
    pad=(size_t) MagickMax((ssize_t) samples_per_pixel-1,0);
    if (tiff_image->alpha_trait != UndefinedPixelTrait)
      {
        if (tiff_image->storage_class != PseudoClass)
          {
            quantum_type=samples_per_pixel == 1 ? AlphaQuantum :
              GrayAlphaQuantum;
            pad=(size_t) MagickMax((ssize_t) samples_per_pixel-2,0);
          }
        else
          {
            quantum_type=IndexAlphaQuantum;
            pad=(size_t) MagickMax((ssize_t) samples_per_pixel-2,0);
          }
      }
    else
      if (tiff_image->storage_class != PseudoClass)
        {
          quantum_type=GrayQuantum;
          pad=(size_t) MagickMax((ssize_t) samples_per_pixel-1,0);
        }
    status=SetQuantumPad(tiff_image,quantum_info,pad*pow(2,ceil(log(
      bits_per_sample)/log(2))));
    if (status == MagickFalse)
      ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
    for (y=0; y < (ssize_t) tiff_image->rows; y++)
    {
      int
        status;

      register Quantum
        *magick_restrict q;

      status=TIFFReadPixels(tiff,bits_per_sample,0,y,(char *) tiff_pixels);
      if (status == -1)
        break;
      q=QueueAuthenticPixels(tiff_image,0,y,tiff_image->columns,1,exception);
      if (q == (Quantum *) NULL)
        break;
      (void) ImportQuantumPixels(tiff_image,(CacheView *) NULL,quantum_info,
        quantum_type,tiff_pixels,exception);
      if (SyncAuthenticPixels(tiff_image,exception) == MagickFalse)
        break;
      if (tiff_image->previous == (Image *) NULL)
        {
          status=SetImageProgress(tiff_image,LoadImageTag,(MagickOffsetType) y,
            tiff_image->rows);
          if (status == MagickFalse)
            break;
        }
    }
    break;
  }
  case ReadRGBAMethod:
  {
    /*
      Convert TIFF image to DirectClass MIFF image.
    */
    pad=(size_t) MagickMax((size_t) samples_per_pixel-3,0);
    quantum_type=RGBQuantum;
    if (tiff_image->alpha_trait != UndefinedPixelTrait)
      {
        quantum_type=RGBAQuantum;
        pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);
      }
    if (tiff_image->colorspace == CMYKColorspace)
      {
        pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);
        quantum_type=CMYKQuantum;
        if (tiff_image->alpha_trait != UndefinedPixelTrait)
          {
            quantum_type=CMYKAQuantum;
            pad=(size_t) MagickMax((size_t) samples_per_pixel-5,0);
          }
      }
    status=SetQuantumPad(tiff_image,quantum_info,pad*((bits_per_sample+7) >> 3));
    if (status == MagickFalse)
      ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
    for (y=0; y < (ssize_t) tiff_image->rows; y++)
    {
      int
        status;

      register Quantum
        *magick_restrict q;

      register ssize_t
        x;

      unsigned char
        *p;

      status=TIFFReadPixels(tiff,bits_per_sample,0,y,(char *) tiff_pixels);
      if (status == -1)
        break;
      q=QueueAuthenticPixels(tiff_image,0,y,tiff_image->columns,1,exception);
      if (q == (Quantum *) NULL)
        break;
      p=tiff_pixels;
      for (x=0; x < (ssize_t) tiff_image->columns; x++)
      {
        SetPixelRed(tiff_image,ScaleCharToQuantum(ClampYCC((double) *p+
          (1.402*(double) *(p+2))-179.456)),q);
        SetPixelGreen(tiff_image,ScaleCharToQuantum(ClampYCC((double) *p-
          (0.34414*(double) *(p+1))-(0.71414*(double ) *(p+2))+
          135.45984)),q);
        SetPixelBlue(tiff_image,ScaleCharToQuantum(ClampYCC((double) *p+
          (1.772*(double) *(p+1))-226.816)),q);
        if (tiff_image->alpha_trait != UndefinedPixelTrait)
          SetPixelAlpha(tiff_image,ScaleCharToQuantum((unsigned char) *(p+3)),q);
        p+=4;
        q+=GetPixelChannels(tiff_image);
      }
      if (SyncAuthenticPixels(tiff_image,exception) == MagickFalse)
        break;
      if (tiff_image->previous == (Image *) NULL)
        {
          status=SetImageProgress(tiff_image,LoadImageTag,(MagickOffsetType) y,
            tiff_image->rows);
          if (status == MagickFalse)
            break;
        }
    }
    break;
  }
  case ReadCMYKAMethod:
  {
    /*
      Convert TIFF image to DirectClass MIFF image.
    */
    for (i=0; i < (ssize_t) samples_per_pixel; i++)
    {
      for (y=0; y < (ssize_t) tiff_image->rows; y++)
      {
        register Quantum
          *magick_restrict q;

        int
          status;

        status=TIFFReadPixels(tiff,bits_per_sample,(tsample_t) i,y,(char *)
          tiff_pixels);
        if (status == -1)
          break;
        q=GetAuthenticPixels(tiff_image,0,y,tiff_image->columns,1,exception);
        if (q == (Quantum *) NULL)
          break;
        if (tiff_image->colorspace != CMYKColorspace)
          switch (i)
          {
            case 0: quantum_type=RedQuantum; break;
            case 1: quantum_type=GreenQuantum; break;
            case 2: quantum_type=BlueQuantum; break;
            case 3: quantum_type=AlphaQuantum; break;
            default: quantum_type=UndefinedQuantum; break;
          }
        else
          switch (i)
          {
            case 0: quantum_type=CyanQuantum; break;
            case 1: quantum_type=MagentaQuantum; break;
            case 2: quantum_type=YellowQuantum; break;
            case 3: quantum_type=BlackQuantum; break;
            case 4: quantum_type=AlphaQuantum; break;
            default: quantum_type=UndefinedQuantum; break;
          }
        (void) ImportQuantumPixels(tiff_image,(CacheView *) NULL,quantum_info,
          quantum_type,tiff_pixels,exception);
        if (SyncAuthenticPixels(tiff_image,exception) == MagickFalse)
          break;
      }
      if (tiff_image->previous == (Image *) NULL)
        {
          status=SetImageProgress(tiff_image,LoadImageTag,(MagickOffsetType) y,
            tiff_image->rows);
          if (status == MagickFalse)
            break;
        }
    }
    break;
  }
  case ReadYCCKMethod:
  {
    for (y=0; y < (ssize_t) tiff_image->rows; y++)
    {
      int
        status;

      register Quantum
        *magick_restrict q;

      register ssize_t
        x;

      unsigned char
        *p;

      status=TIFFReadPixels(tiff,bits_per_sample,0,y,(char *) tiff_pixels);
      if (status == -1)
        break;
      q=QueueAuthenticPixels(tiff_image,0,y,tiff_image->columns,1,exception);
      if (q == (Quantum *) NULL)
        break;
      p=tiff_pixels;
      for (x=0; x < (ssize_t) tiff_image->columns; x++)
      {
        SetPixelCyan(tiff_image,ScaleCharToQuantum(ClampYCC((double) *p+
          (1.402*(double) *(p+2))-179.456)),q);
        SetPixelMagenta(tiff_image,ScaleCharToQuantum(ClampYCC((double) *p-
          (0.34414*(double) *(p+1))-(0.71414*(double ) *(p+2))+
          135.45984)),q);
        SetPixelYellow(tiff_image,ScaleCharToQuantum(ClampYCC((double) *p+
          (1.772*(double) *(p+1))-226.816)),q);
        SetPixelBlack(tiff_image,ScaleCharToQuantum((unsigned char) *(p+3)),q);
        p+=4;
        q+=GetPixelChannels(tiff_image);
      }
      if (SyncAuthenticPixels(tiff_image,exception) == MagickFalse)
        break;
      if (tiff_image->previous == (Image *) NULL)
        {
          status=SetImageProgress(tiff_image,LoadImageTag,(MagickOffsetType) y,
            tiff_image->rows);
          if (status == MagickFalse)
            break;
        }
    }
    break;
  }
  case ReadStripMethod:
  {
    register uint32
      *p;

    /*
      Convert stripped TIFF image to DirectClass MIFF image.
    */
    i=0;
    p=(uint32 *) NULL;
    for (y=0; y < (ssize_t) tiff_image->rows; y++)
    {
      register ssize_t
        x;

      register Quantum
        *magick_restrict q;

      q=QueueAuthenticPixels(tiff_image,0,y,tiff_image->columns,1,exception);
      if (q == (Quantum *) NULL)
        break;
      if (i == 0)
        {
          if (TIFFReadRGBAStrip(tiff,(uint32) x,(uint32) y,tile_pixels) == 0)
            break;
          i=(ssize_t) MagickMin((ssize_t) rows_per_strip,(ssize_t)
            tiff_image->rows-y);
        }
      i--;
      p=((uint32 *) tiff_pixels)+tiff_image->columns*i;
      for (x=0; x < (ssize_t) tiff_image->columns; x++)
      {
        SetPixelRed(tiff_image,ScaleCharToQuantum((unsigned char)
          TIFFGetR(*p)),q);
        SetPixelGreen(tiff_image,ScaleCharToQuantum((unsigned char)
          TIFFGetG(*p)),q);
        SetPixelBlue(tiff_image,ScaleCharToQuantum((unsigned char)
          TIFFGetB(*p)),q);
        if (tiff_image->alpha_trait != UndefinedPixelTrait)
          SetPixelAlpha(tiff_image,ScaleCharToQuantum((unsigned char)
            TIFFGetA(*p)),q);
        p++;
        q+=GetPixelChannels(tiff_image);
      }
      if (SyncAuthenticPixels(tiff_image,exception) == MagickFalse)
        break;
      if (tiff_image->previous == (Image *) NULL)
        {
          status=SetImageProgress(tiff_image,LoadImageTag,(MagickOffsetType) y,
            tiff_image->rows);
          if (status == MagickFalse)
            break;
        }
    }
    break;
  }
  case ReadTileMethod:
  {
    register uint32
      *p;

    uint32
      *tile_pixels,
      columns,
      rows;

    /*
      Convert tiled TIFF image to DirectClass MIFF image.
    */
    if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||
        (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))
      ThrowTIFFException(CoderError,"ImageIsNotTiled");
    if ((AcquireMagickResource(WidthResource,columns) == MagickFalse) ||
        (AcquireMagickResource(HeightResource,rows) == MagickFalse))
      ThrowTIFFException(ImageError,"WidthOrHeightExceedsLimit");
    (void) SetImageStorageClass(tiff_image,DirectClass,exception);
    number_pixels=(MagickSizeType) columns*rows;
    if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels)) != MagickFalse)
      ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
    tile_pixels=(uint32 *) AcquireQuantumMemory(columns,rows*
      sizeof(*tile_pixels));
    if (tile_pixels == (uint32 *) NULL)
      ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
    for (y=0; y < (ssize_t) tiff_image->rows; y+=rows)
    {
      register ssize_t
        x;

      register Quantum
        *magick_restrict q;

      size_t
        columns_remaining,
        rows_remaining;

      rows_remaining=tiff_image->rows-y;
      if ((ssize_t) (y+rows) < (ssize_t) tiff_image->rows)
        rows_remainin