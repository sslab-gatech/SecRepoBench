yanQuantum; break;
                case 1: quantum_type=MagentaQuantum; break;
                case 2: quantum_type=YellowQuantum; break;
                case 3: quantum_type=BlackQuantum; break;
                case 4: quantum_type=AlphaQuantum; break;
                default: quantum_type=UndefinedQuantum; break;
              }
            (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
              quantum_type,tiff_pixels,exception);
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                  image->rows);
                if (status == MagickFalse)
                  break;
              }
          }
        }
        break;
      }
      case ReadYCCKMethod:
      {
        /*
          Convert TIFF image to DirectClass MIFF image.
        */
        pad=(size_t) MagickMax((size_t) items_in_pix-4,0);
        quantum_type=YCbCrQuantum;
        if (image->alpha_trait!= UndefinedPixelTrait)
          {
            quantum_type=YCbCrAQuantum;
            pad=(size_t) MagickMax((size_t) items_in_pix-5,0);
          }
        status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7) >> 3));
        if (status == MagickFalse)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          int
            status;

          register Quantum
            *magick_restrict q;

          status=TIFFReadPixels(tiff,bits_per_sample,0,y,(char *) tiff_pixels);
          if (status == -1)
            break;
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
            quantum_type,tiff_pixels,exception);
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case ReadStripMethod:
      {
        /*
          Convert TIFF image to DirectClass MIFF image.
        */
        pad=(size_t) MagickMax((size_t) items_in_pix-1,0);
        quantum_type=RGBQuantum;
        if (image->alpha_trait!= UndefinedPixelTrait)
          {
            quantum_type=RGBAQuantum;
            pad=(size_t) MagickMax((size_t) items_in_pix-2,0);
          }
        if (image->colorspace == CMYKColorspace)
          {
            pad=(size_t) MagickMax((size_t) items_in_pix-4,0);
            quantum_type=CMYKQuantum;
            if (image->alpha_trait!= UndefinedPixelTrait)
              {
                quantum_type=CMYKAQuantum;
                pad=(size_t) MagickMax((size_t) items_in_pix-5,0);
              }
          }
        status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7) >> 3));
        if (status == MagickFalse)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          int
            status;

          register Quantum
            *magick_restrict q;

          status=TIFFReadPixels(tiff,bits_per_sample,0,y,(char *) tiff_pixels);
          if (status == -1)
            break;
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
            quantum_type,tiff_pixels,exception);
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case ReadTileMethod:
      {
        /*
          Convert TIFF image to DirectClass MIFF image.
        */
        pad=(size_t) MagickMax((size_t) items_in_pix-1,0);
        quantum_type=RGBQuantum;
        if (image->alpha_trait!= UndefinedPixelTrait)
          {
            quantum_type=RGBAQuantum;
            pad=(size_t) MagickMax((size_t) items_in_pix-2,0);
          }
        if (image->colorspace == CMYKColorspace)
          {
            pad=(size_t) MagickMax((size_t) items_in_pix-4,0);
            quantum_type=CMYKQuantum;
            if (image->alpha_trait!= UndefinedPixelTrait)
              {
                quantum_type=CMYKAQuantum;
                pad=(size_t) MagickMax((size_t) items_in_pix-5,0);
              }
          }
        status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7) >> 3));
        if (status == MagickFalse)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          int
            status;

          register Quantum
            *magick_restrict q;

          status=TIFFReadPixels(tiff,bits_per_sample,0,y,(char *) tiff_pixels);
          if (status == -1)
            break;
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
            quantum_type,tiff_pixels,exception);
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case ReadGenericMethod:
      {
        /*
          Convert TIFF image to DirectClass MIFF image.
        */
        pad=(size_t) MagickMax((size_t) items_in_pix-1,0);
        quantum_type=RGBQuantum;
        if (image->alpha_trait!= UndefinedPixelTrait)
          {
            quantum_type=RGBAQuantum;
            pad=(size_t) MagickMax((size_t) items_in_pix-2,0);
          }
        if (image->colorspace == CMYKColorspace)
          {
            pad=(size_t) MagickMax((size_t) items_in_pix-4,0);
            quantum_type=CMYKQuantum;
            if (image->alpha_trait!= UndefinedPixelTrait)
              {
                quantum_type=CMYKAQuantum;
                pad=(size_t) MagickMax((size_t) items_in_pix-5,0);
              }
          }
        status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7) >> 3));
        if (status == MagickFalse)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          int
            status;

          register Quantum
            *magick_restrict q;

          status=TIFFReadPixels(tiff,bits_per_sample,0,y,(char *) tiff_pixels);
          if (status == -1)
            break;
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
            quantum_type,tiff_pixels,exception);
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      default:
        break;
    }
    if (status == MagickFalse)
      ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
    if (image->storage_class == PseudoClass)
      {
        if (image->alpha_trait!= UndefinedPixelTrait)
          {
            if (image->colorspace == CMYKColorspace)
              {
                image->alpha_trait=BlendPixelTrait;
                image->colorspace=RGBColorspace;
              }
            else
              {
                image->alpha_trait=BlendPixelTrait;
                image->colorspace=RGBColorspace;
              }
          }
        else
          if (image->colorspace == CMYKColorspace)
            image->colorspace=RGBColorspace;
      }
    if (image->colorspace == CMYKColorspace)
      {
        if (image->alpha_trait == BlendPixelTrait)
          image->colorspace=CMYKAColorspace;
      }
    if (image->colorspace == LabColorspace)
      {
        if (DecodeLabImage(image,exception) == MagickFalse)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
      }
    if (image->alpha_trait == BlendPixelTrait)
      {
        if (image->colorspace == RGBColorspace)
          image->colorspace=RGBAColorspace;
        if (image->colorspace == CMYKColorspace)
          image->colorspace=CMYKAColorspace;
      }
    if (image->alpha_trait == UndefinedPixelTrait)
      {
        if (image->colorspace == RGBAColorspace)
          image->colorspace=RGBColorspace;
        if (image->colorspace == CMYKAColorspace)
          image->colorspace=CMYKColorspace;
      }
    if (image->storage_class == PseudoClass)
      {
        if (image->alpha_trait == BlendPixelTrait)
          {
            image->alpha_trait=UndefinedPixelTrait;
            image->colorspace=RGBColorspace;
          }
        else
          if (image->colorspace == CMYKColorspace)
            image->colorspace=RGBColorspace;
      }
    if (image->storage_class == PseudoClass)
      {
        if (image->alpha_trait == BlendPixelTrait)
          {
            image->alpha_trait=UndefinedPixelTrait;
            image->colorspace=RGBColorspace;
          }
        else
          if (image->colorspace == CMYKColorspace)
            image->colorspace=RGBColorspace;
      }
    if (image->storage_class == PseudoClass)
      {
        if (image->alpha_trait == BlendPixelTrait)
          {
            image->alpha_trait=UndefinedPixelTrait;
            image->colorspace=RGBColorspace;
          }
        else
          if (image->colorspace == CMYKColorspace)
            image->colorspace=RGBColorspace;
      }
    if (image->storage_class == PseudoClass)
      {
        if (image->alpha_trait == BlendPixelTrait)
          {
            image->alpha_trait=UndefinedPixelTrait;
            image->colorspace=RGBColorspace;
          }
        else
          if (image->colorspace == CMYKColorspace)
            image->colorspace=RGBColorspace;
      }
    if (image->storage_class == PseudoClass)
      {
        if (image->alpha_trait == BlendPixelTrait)
          {
            image->alpha_trait=UndefinedPixelTrait;
            image->colorspace=RGBColorspace;
          }
        else
          if (image->colorspace == CMYKColorspace)
            image->colorspace=RGBColorspace;
      }
    if (image->storage_class == PseudoClass)
      {
        if (image->alpha_trait == BlendPixelTrait)
          {
            image->alpha_trait=UndefinedPixelTrait;
            image->colorspace=RGBColorspace;
          }
        else
          if (image->colorspace == CMYKColorspace)
            image->colorspace=RGBColorspace;
      }
    if (image->storage_class == PseudoClass)
      {
        if (image->alpha_trait == BlendPixelTrait)
          {
            image->alpha_trait=UndefinedPixelTrait;
            image->colorspace=RGBColorspace;
          }
        else
          if (image->colorspace == CMYKColorspace)
            image->colorspace=RGBColorspace;
      }
    if (image->storage_class == PseudoClass)
      {
        if (image->alpha_trait == BlendPixelTrait)
          {
            image->alpha_trait=UndefinedPixelTrait;
            image->colorspace=RGBColorspace;
          }
        else
          if (image->colorspace == CMYKColorspace)
            image->colorspace=RGBColorspace;
      }
    if (image->storage_class == PseudoClass)
      {
        if (image->alpha_trait == BlendPixelTrait)
          {
            image->alpha_trait=UndefinedPixelTrait;
            image->colorspace=RGBColorspace;
          }
        else
          if (image->colorspace == CMYKColorspace)
            image->colorspace=RGBColorspace;
      }
    if (image->storage_class == PseudoClass)
      {
        if (image->alpha_trait == BlendPixelTrait)
          {
            image->alpha_trait=UndefinedPixelTrait;
            image->colorspace=RGBColorspace;
          }
        else
          if (image->colorspace == CMYKColorspace)
            image->colorspace=RGBColorspace;
      }
    if (image->storage_class == PseudoClass)
      {
        if (image->alpha_trait == BlendPixelTrait)
          {
            image->alpha_trait=UndefinedPixelTrait;
            image->colorspace=RGBColorspace;
          }
        else
          if (image->colorspace == CMYKColorspace)
            image->