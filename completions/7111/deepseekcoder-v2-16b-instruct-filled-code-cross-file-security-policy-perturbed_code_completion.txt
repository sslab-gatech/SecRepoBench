,TIFFTAG_YPOSITION,(float) image->page.y/
              image->resolution.y);
          }
      }
    if (image->chromaticity.white_point.x != 0.0)
      {
        float
          chromaticity[6];

        chromaticity[0]=image->chromaticity.white_point.x;
        chromaticity[1]=image->chromaticity.white_point.y;
        chromaticity[2]=image->chromaticity.red_primary.x;
        chromaticity[3]=image->chromaticity.red_primary.y;
        chromaticity[4]=image->chromaticity.green_primary.x;
        chromaticity[5]=image->chromaticity.green_primary.y;
        (void) TIFFSetField(tiff,TIFFTAG_WHITEPOINT,chromaticity);
      }
    if (image->chromaticity.red_primary.x != 0.0)
      {
        float
          chromaticity[6];

        chromaticity[0]=image->chromaticity.white_point.x;
        chromaticity[1]=image->chromaticity.white_point.y;
        chromaticity[2]=image->chromaticity.red_primary.x;
        chromaticity[3]=image->chromaticity.red_primary.y;
        chromaticity[4]=image->chromaticity.green_primary.x;
        chromaticity[5]=image->chromaticity.green_primary.y;
        (void) TIFFSetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,chromaticity);
      }
    if (image->debug != MagickFalse)
      {
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),"Geometry: %ux%u",
          (unsigned int) image->columns,(unsigned int) image->rows);
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),"Interlace: %u",
          image->interlace);
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          "Bits per sample: %u",image->depth);
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          "Min sample value: %u",quantum_info->minimum);
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          "Max sample value: %u",quantum_info->maximum);
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),"Photometric "
          "interpretation: %s",GetImageProperty(image,"tiff:photometric",
          exception));
      }
    pixels=(unsigned char *) image->blob;
    length=GetBlobSize(image);
    if (image->storage_class == PseudoClass)
      {
        size_t
          depth;

        uint16
          *blue_colormap,
          *green_colormap,
          *red_colormap;

        depth=1;
        while ((GetQuantumRange(depth)+1) < image->colors)
          depth<<=1;
        if (AcquireQuantumMemory(image->colors,sizeof(*red_colormap)) == MagickFalse)
          ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
        red_colormap=(uint16 *) AcquireQuantumMemory(image->colors,
          sizeof(*red_colormap)*depth);
        if (red_colormap == (uint16 *) NULL)
          {
            red_colormap=(uint16 *) RelinquishMagickMemory(red_colormap);
            ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
          }
        green_colormap=(uint16 *) AcquireQuantumMemory(image->colors,
          sizeof(*green_colormap)*depth);
        if (green_colormap == (uint16 *) NULL)
          {
            green_colormap=(uint16 *) RelinquishMagickMemory(green_colormap);
            red_colormap=(uint16 *) RelinquishMagickMemory(red_colormap);
            ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
          }
        blue_colormap=(uint16 *) AcquireQuantumMemory(image->colors,
          sizeof(*blue_colormap)*depth);
        if (blue_colormap == (uint16 *) NULL)
          {
            blue_colormap=(uint16 *) RelinquishMagickMemory(blue_colormap);
            green_colormap=(uint16 *) RelinquishMagickMemory(green_colormap);
            red_colormap=(uint16 *) RelinquishMagickMemory(red_colormap);
            ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
          }
        for (i=0; i < (ssize_t) image->colors; i++)
          {
            red_colormap[i]=ScaleQuantumToShort(image->colormap[i].red);
            green_colormap[i]=ScaleQuantumToShort(image->colormap[i].green);
            blue_colormap[i]=ScaleQuantumToShort(image->colormap[i].blue);
          }
        (void) TIFFSetField(tiff,TIFFTAG_COLORMAP,red_colormap,
          green_colormap,blue_colormap);
        red_colormap=(uint16 *) RelinquishMagickMemory(red_colormap);
        green_colormap=(uint16 *) RelinquishMagickMemory(green_colormap);
        blue_colormap=(uint16 *) RelinquishMagickMemory(blue_colormap);
      }
    if (image->storage_class == DirectClass)
      {
        if (image->depth == 1)
          {
            if (image->alpha_trait == UndefinedPixelTrait)
              {
                for (y=0; y < (ssize_t) image->rows; y++)
                {
                  register Quantum
                    *magick_restrict q;

                  q=GetAuthenticPixels(image,0,y,image->columns,1,exception);
                  if (q == (Quantum *) NULL)
                    break;
                  for (i=0; i < (ssize_t) image->columns; i++)
                    {
                      Quantum
                        red,
                        green,
                        blue;

                      red=GetPixelRed(image,q);
                      green=GetPixelGreen(image,q);
                      blue=GetPixelBlue(image,q);
                      if (quantum_info->min_is_white != MagickFalse)
                        {
                          if (red == 0)
                            SetPixelGray(image,QuantumRange,q);
                          else
                            SetPixelGray(image,0,q);
                        }
                      else
                        {
                          if (red == QuantumRange)
                            SetPixelGray(image,0,q);
                          else
                            SetPixelGray(image,QuantumRange,q);
                        }
                      q+=GetPixelChannels(image);
                    }
                  if (SyncAuthenticPixels(image,exception) == MagickFalse)
                    break;
                }
              }
            else
              {
                for (y=0; y < (ssize_t) image->rows; y++)
                {
                  register Quantum
                    *magick_restrict q;

                  q=GetAuthenticPixels(image,0,y,image->columns,1,exception);
                  if (q == (Quantum *) NULL)
                    break;
                  for (i=0; i < (ssize_t) image->columns; i++)
                    {
                      Quantum
                        red,
                        green,
                        blue,
                        alpha;

                      red=GetPixelRed(image,q);
                      green=GetPixelGreen(image,q);
                      blue=GetPixelBlue(image,q);
                      alpha=GetPixelAlpha(image,q);
                      if (quantum_info->min_is_white != MagickFalse)
                        {
                          if (red == 0)
                            SetPixelGrayAlpha(image,QuantumRange,alpha,q);
                          else
                            SetPixelGrayAlpha(image,0,alpha,q);
                        }
                      else
                        {
                          if (red == QuantumRange)
                            SetPixelGrayAlpha(image,0,alpha,q);
                          else
                            SetPixelGrayAlpha(image,QuantumRange,alpha,q);
                        }
                      q+=GetPixelChannels(image);
                    }
                  if (SyncAuthenticPixels(image,exception) == MagickFalse)
                    break;
                }
              }
          }
        else
          {
            if (image->alpha_trait == UndefinedPixelTrait)
              {
                for (y=0; y < (ssize_t) image->rows; y++)
                {
                  register Quantum
                    *magick_restrict q;

                  q=GetAuthenticPixels(image,0,y,image->columns,1,exception);
                  if (q == (Quantum *) NULL)
                    break;
                  for (i=0; i < (ssize_t) image->columns; i++)
                    {
                      Quantum
                        red,
                        green,
                        blue;

                      red=GetPixelRed(image,q);
                      green=GetPixelGreen(image,q);
                      blue=GetPixelBlue(image,q);
                      if (quantum_info->min_is_white != MagickFalse)
                        SetPixelRGB(image,0,0,0,q);
                      else
                        SetPixelRGB(image,QuantumRange,QuantumRange,QuantumRange,q);
                      q+=GetPixelChannels(image);
                    }
                  if (SyncAuthenticPixels(image,exception) == MagickFalse)
                    break;
                }
              }
            else
              {
                for (y=0; y < (ssize_t) image->rows; y++)
                {
                  register Quantum
                    *magick_restrict q;

                  q=GetAuthenticPixels(image,0,y,image->columns,1,exception);
                  if (q == (Quantum *) NULL)
                    break;
                  for (i=0; i < (ssize_t) image->columns; i++)
                    {
                      Quantum
                        red,
                        green,
                        blue,
                        alpha;

                      red=GetPixelRed(image,q);
                      green=GetPixelGreen(image,q);
                      blue=GetPixelBlue(image,q);
                      alpha=GetPixelAlpha(image,q);
                      if (quantum_info->min_is_white != MagickFalse)
                        SetPixelRGBA(image,0,0,0,alpha,q);
                      else
                        SetPixelRGBA(image,QuantumRange,QuantumRange,QuantumRange,alpha,q);
                      q+=GetPixelChannels(image);
                    }
                  if (SyncAuthenticPixels(image,exception) == MagickFalse)
                    break;
                }
              }
          }
      }
    if (image->storage_class == PseudoClass)
      {
        if (image->depth == 1)
          {
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              register Quantum
                *magick_restrict q;

              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);
              if (q == (Quantum *) NULL)
                break;
              for (i=0; i < (ssize_t) image->columns; i++)
                {
                  Quantum
                    index;

                  index=GetPixelIndex(image,q);
                  if (quantum_info->min_is_white != MagickFalse)
                    SetPixelGray(image,index,q);
                  else
                    SetPixelGray(image,QuantumRange-index,q);
                  q+=GetPixelChannels(image);
                }
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
            }
          }
        else
          {
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              register Quantum
                *magick_restrict q;

              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);
              if (q == (Quantum *) NULL)
                break;
              for (i=0; i < (ssize_t) image->columns; i++)
                {
                  Quantum
                    index;

                  index=GetPixelIndex(image,q);
                  if (quantum_info->min_is_white != MagickFalse)
                    SetPixelRGB(image,index,index,index,q);
                  else
                    SetPixelRGB(image,QuantumRange-index,QuantumRange-index,
                      QuantumRange-index,q);
                  q+=GetPixelChannels(image);
                }
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
            }
          }
      }
    if (image->storage_class == PaletteType)
      {
        if (image->depth