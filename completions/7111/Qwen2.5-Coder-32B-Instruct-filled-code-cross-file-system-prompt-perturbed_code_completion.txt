entry->mime_type=ConstantString("image/x-portable-floatmap");
  (void) RegisterMagickInfo(entry);
  entry=AcquireMagickInfo("PNM","PGM","Portable graymap format (gray scale)");
  entry->decoder=(DecodeImageHandler *) ReadPNMImage;
  entry->encoder=(EncodeImageHandler *) WritePNMImage;
  entry->mime_type=ConstantString("image/x-portable-graymap");
  (void) RegisterMagickInfo(entry);
  entry=AcquireMagickInfo("PNM","PPM","Portable pixmap format (color)");
  entry->decoder=(DecodeImageHandler *) ReadPNMImage;
  entry->encoder=(EncodeImageHandler *) WritePNMImage;
  entry->mime_type=ConstantString("image/x-portable-pixmap");
  (void) RegisterMagickInfo(entry);
  entry=AcquireMagickInfo("PNM","PSD","Adobe Photoshop bitmap");
  entry->decoder=(DecodeImageHandler *) ReadPSDImage;
  entry->encoder=(EncodeImageHandler *) WritePSDImage;
  entry->mime_type=ConstantString("image/vnd.adobe.photoshop");
  (void) RegisterMagickInfo(entry);
  return(MagickImageCoderSignature);
}

// the below code fragment can be found in:
// coders/png.c
static Image *ReadPNGImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  char
    im_version[32],
    libpng_version[32],
    zlib_version[32];

  const char
    *value;

  Image
    *image;

  int
    logging,
    number_colors,
    num_passes,
    pass,
    ping_background_active,
    ping_color_type,
    ping_interlace_method,
    ping_compression_method,
    ping_filter_method,
    ping_need_colortype_warning,
    ping_progressive,
    ping_preserve_iptc,
    ping_sanitize_ids,
    status;

  MagickBooleanType
    ignore_crc,
    ping_found_bkgd,
    ping_found_gama,
    ping_found_iccp,
    ping_found_srgb,
    ping_preserve_bkgd,
    ping_preserve_iptc_from_bkgd,
    ping_read_to_end;

  MemoryInfo
    *ping_pixels;

  png_byte
     *ping_trans_alpha;

  png_color_16
    ping_background,
    ping_trans_color;

  png_structp
    ping;

  png_infop
    end_info,
    info_ptr;

  png_text
    *text;

  png_uint_32
    ping_height,
    ping_width,
    x_resolution,
    y_resolution;

  ssize_t
    y;

  register unsigned char
    *p;

  register ssize_t
    i,
    x;

  size_t
    one_authentic,
    one_cache,
    one_truecolors,
    length,
    ping_rowbytes;

  ssize_t
    j;

  unsigned int
    intent,
    num_text;

  unsigned short
    ping_colortype,
    ping_bit_depth,
    ping_compression_info,
    ping_exif_block,
    ping_green_added,
    ping_have_blob,
    ping_have_tRNS,
    ping_interlace_method_aux,
    ping_is_grayscale,
    ping_num_text,
    ping_pHYs_unit_type,
    ping_rowbytes,
    ping_trans_red,
    ping_trans_blue,
    ping_trans_green;

  volatile int
    image_matte;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Determine PNG properties.
  */
  ping=png_create_read_struct(PNG_LIBPNG_VER_STRING,(png_voidp) NULL,
    PingErrorHandler,(png_voidp) NULL);
  if (ping == (png_structp) NULL)
    ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
  info_ptr=png_create_info_struct(ping);
  if (info_ptr == (png_infop) NULL)
    {
      png_destroy_read_struct(&ping,(png_infopp) NULL,(png_infopp) NULL);
      ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
    }
  png_set_error_fn(ping,(png_voidp) image,PngErrorHandler,PngWarningHandler);
  end_info=png_create_info_struct(ping);
  if (end_info == (png_infop) NULL)
    {
      png_destroy_read_struct(&ping,&info_ptr,(png_infopp) NULL);
      ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
    }
  png_set_error_fn(ping,(png_voidp) image,PngErrorHandler,PngWarningHandler);
  /*
    Set image attributes.
  */
  image->depth=8;
  image->endianness=MSBEndian;
  image->matte=MagickFalse;
  image->rendering_intent=UndefinedIntent;
  image->units=UndefinedResolution;
  image->columns=0;
  image->rows=0;
  image->colors=0;
  image->colorspace=sRGBColorspace;
  image->compression=NoCompression;
  image->delay=0;
  image->iterations=1;
  image->montage=NULL;
  image->directory=NULL;
  image->attributes=(AttributeInfo *) NULL;
  image->profiles=(StringInfo **) NULL;
  image->profile_lengths=(size_t *) NULL;
  image->number_profiles=0;
  image->taint=MagickTrue;
  image->progress_monitor=(MagickProgressMonitor) NULL;
  image->client_data=(void *) NULL;
  image->logging=MagickFalse;
  image->debug=IsEventLogging();
  image->timer=AcquireTimer();
  image->ticks_per_second=100;
  image->total_ticks=0;
  image->start_time=GetTimeInTicks();
  image->stop_time=0;
  image->signature=MagickCoreSignature;
  image->next=NULL;
  image->previous=NULL;
  image->exception=exception;
  image->blob=ReferenceBlob(image_info->blob);
  image->cache=CloneCache(image_info->cache);
  image->columns=0;
  image->rows=0;
  image->depth=8;
  image->colors=0;
  image->colorspace=sRGBColorspace;
  image->compression=NoCompression;
  image->delay=0;
  image->iterations=1;
  image->montage=NULL;
  image->directory=NULL;
  image->attributes=(AttributeInfo *) NULL;
  image->profiles=(StringInfo **) NULL;
  image->profile_lengths=(size_t *) NULL;
  image->number_profiles=0;
  image->taint=MagickTrue;
  image->progress_monitor=(MagickProgressMonitor) NULL;
  image->client_data=(void *) NULL;
  image->logging=MagickFalse;
  image->debug=IsEventLogging();
  image->timer=AcquireTimer();
  image->ticks_per_second=100;
  image->total_ticks=0;
  image->start_time=GetTimeInTicks();
  image->stop_time=0;
  image->signature=MagickCoreSignature;
  image->next=NULL;
  image->previous=NULL;
  image->exception=exception;
  image->blob=ReferenceBlob(image_info->blob);
  image->cache=CloneCache(image_info->cache);
  image->columns=0;
  image->rows=0;
  image->depth=8;
  image->colors=0;
  image->colorspace=sRGBColorspace;
  image->compression=NoCompression;
  image->delay=0;
  image->iterations=1;
  image->montage=NULL;
  image->directory=NULL;
  image->attributes=(AttributeInfo *) NULL;
  image->profiles=(StringInfo **) NULL;
  image->profile_lengths=(size_t *) NULL;
  image->number_profiles=0;
  image->taint=MagickTrue;
  image->progress_monitor=(MagickProgressMonitor) NULL;
  image->client_data=(void *) NULL;
  image->logging=MagickFalse;
  image->debug=IsEventLogging();
  image->timer=AcquireTimer();
  image->ticks_per_second=100;
  image->total_ticks=0;
  image->start_time=GetTimeInTicks();
  image->stop_time=0;
  image->signature=MagickCoreSignature;
  image->next=NULL;
  image->previous=NULL;
  image->exception=exception;
  image->blob=ReferenceBlob(image_info->blob);
  image->cache=CloneCache(image_info->cache);
  image->columns=0;
  image->rows=0;
  image->depth=8;
  image->colors=0;
  image->colorspace=sRGBColorspace;
  image->compression=NoCompression;
  image->delay=0;
  image->iterations=1;
  image->montage=NULL;
  image->directory=NULL;
  image->attributes=(AttributeInfo *) NULL;
  image->profiles=(StringInfo **) NULL;
  image->profile_lengths=(size_t *) NULL;
  image->number_profiles=0;
  image->taint=MagickTrue;
  image->progress_monitor=(MagickProgressMonitor) NULL;
  image->client_data=(void *) NULL;
  image->logging=MagickFalse;
  image->debug=IsEventLogging();
  image->timer=AcquireTimer();
  image->ticks_per_second=100;
  image->total_ticks=0;
  image->start_time=GetTimeInTicks();
  image->stop_time=0;
  image->signature=MagickCoreSignature;
  image->next=NULL;
  image->previous=NULL;
  image->exception=exception;
  image->blob=ReferenceBlob(image_info->blob);
  image->cache=CloneCache(image_info->cache);
  /*
    Initialize several variables.
  */
  one_truecolors=0;
  one_cache=0;
  one_authentic=0;
  ping_rowbytes=0;
  ping_rows=0;
  ping_height=0;
  ping_width=0;
  ping_interlace_method=0;
  ping_interlace_method_aux=0;
  ping_compression_method=0;
  ping_filter_method=0;
  ping_colortype=0;
  ping_bit_depth=0;
  ping_compression_info=0;
  ping_progressive=0;
  ping_background_active=0;
  ping_preserve_bkgd=1;
  ping_preserve_iptc=1;
  ping_preserve_iptc_from_bkgd=1;
  ping_sanitize_ids=0;
  ping_read_to_end=1;
  ping_need_colortype_warning=0;
  ping_exif_block=0;
  ping_green_added=1;
  ping_have_blob=0;
  ping_have_tRNS=0;
  ping_is_grayscale=0;
  ping_num_text=0;
  ping_pHYs_unit_type=0;
  ping_trans_red=0;
  ping_trans_green=0;
  ping_trans_blue=0;
  ping_trans_alpha=(png_byte *) NULL;
  ping_background.red=0;
  ping_background.green=0;
  ping_background.blue=0;
  ping_background.gray=0;
  ping_background.index=0;
  ping_trans_color.red=0;
  ping_trans_color.green=0;
  ping_trans_color.blue=0;
  ping_trans_color.gray=0;
  ping_trans_color.index=0;
  ping_found_bkgd=MagickFalse;
  ping_found_gama=MagickFalse;
  ping_found_iccp=MagickFalse;
  ping_found_srgb=MagickFalse;
  ignore_crc=MagickFalse;
  logging=MagickFalse;
  num_passes=1;
  number_colors=256;
  num_text=0;
  text=(png_text *) NULL;
  intent=UndefinedIntent;
  x_resolution=0;
  y_resolution=0;
  /*
    Set user-defined chunk caching.
  */
  value=GetImageOption(image_info,"png:cache");
  if (value != (const char *) NULL)
    {
      one_cache=(size_t) StringToLong(value);
      if (one_cache > 0)
        png_set_chunk_cache_max(ping,one_cache);
    }
  /*
    Set user-defined chunk memory usage.
  */
  value=GetImageOption(image_info,"png:memory");
  if (value != (const char *) NULL)
    {
      one_authentic=(size_t) StringToLong(value);
      if (one_authentic > 0)
        png_set_chunk_malloc_max(ping,one_authentic);
    }
  /*
    Set user-defined number of colors.
  */
  value=GetImageOption(image_info,"png:number-colors");
  if (value != (const char *) NULL)
    number_colors=(int) StringToLong(value);
  /*
    Set user-defined image resolution.
  */
  value=GetImageOption(image_info,"png:resolution");
  if (value != (const char *) NULL)
    {
      GeometryInfo
        geometry_info;

      MagickStatusType
        flags;

      flags=ParseGeometry(value,&geometry_info);
      x_resolution=(png_uint_32) geometry_info.rho;
      y_resolution=(png_uint_32) geometry_info.sigma;
      if ((flags & SigmaValue) == 0)
        y_resolution=x_resolution;
    }
  /*
    Set user-defined image rendering intent.
  */
  value=GetImageOption(image_info,"png:rendering-intent");
  if (value != (const char *) NULL)
    {
      if (LocaleCompare(value,"saturation") == 0)
        intent=SaturationIntent;
      if (LocaleCompare(value,"perceptual") == 0)
        intent=PerceptualIntent;
      if (LocaleCompare(value,"absolute") == 0)
        intent=AbsoluteIntent;
      if (LocaleCompare(value,"relative") == 0)
        intent=RelativeIntent;