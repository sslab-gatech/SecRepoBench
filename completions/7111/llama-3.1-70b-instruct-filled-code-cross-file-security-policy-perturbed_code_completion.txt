mime_type=ConstantString("image/x-portable-graymap");
  (void) RegisterMagickInfo(entry);
  entry=AcquireMagickInfo("PNM","PPM","Portable pixmap format (color)");
  entry->decoder=(DecodeImageHandler *) ReadPNMImage;
  entry->encoder=(EncodeImageHandler *) WritePNMImage;
  entry->mime_type=ConstantString("image/x-portable-pixmap");
  (void) RegisterMagickInfo(entry);
  return(MagickImageCoderSignature);
}

// the below code fragment can be found in:
// magick/quantum.h
typedef enum
{
  UndefinedQuantumFormat,
  SignedQuantumFormat,
  UnsignedQuantumFormat,
  FloatingPointQuantumFormat
} QuantumFormatType;

typedef enum
{
  UndefinedQuantum,
  IndexQuantum,
  GrayQuantum,
  GrayAlphaQuantum,
  CyanQuantum,
  MagentaQuantum,
  YellowQuantum,
  BlackQuantum,
  RedQuantum,
  GreenQuantum,
  BlueQuantum,
  AlphaQuantum,
  RGBQuantum,
  RGBAQuantum,
  CMYKQuantum,
  CMYKAQuantum,
  YCbCrQuantum,
  YCCKQuantum,
  CIELabQuantum
} QuantumType;

typedef struct _QuantumInfo
{
  QuantumFormatType
    format;

  QuantumType
    type;

  size_t
    depth,
    pad;

  ssize_t
    minimum,
    maximum;

  MagickBooleanType
    min_is_white;

  QuantumAlphaType
    alpha_type;

  EndianType
    endian;
} QuantumInfo;

// the below code fragment can be found in:
// magick/quantum-private.h
static inline size_t GetQuantumDepth(const QuantumInfo *quantum_info)
{
  return(quantum_info->depth);
}

static inline size_t GetQuantumPad(const QuantumInfo *quantum_info)
{
  return(quantum_info->pad);
}

static inline QuantumFormatType GetQuantumFormat(const QuantumInfo *quantum_info)
{
  return(quantum_info->format);
}

static inline QuantumType GetQuantumType(const QuantumInfo *quantum_info)
{
  return(quantum_info->type);
}

static inline ssize_t GetQuantumMin(const QuantumInfo *quantum_info)
{
  return(quantum_info->minimum);
}

static inline ssize_t GetQuantumMax(const QuantumInfo *quantum_info)
{
  return(quantum_info->maximum);
}

static inline MagickBooleanType IsQuantumMinIsWhite(const QuantumInfo *quantum_info)
{
  return(quantum_info->min_is_white);
}

static inline QuantumAlphaType GetQuantumAlphaType(const QuantumInfo *quantum_info)
{
  return(quantum_info->alpha_type);
}

static inline EndianType GetQuantumEndian(const QuantumInfo *quantum_info)
{
  return(quantum_info->endian);
}

static inline size_t GetQuantumRange(size_t depth)
{
  return((size_t) ((1ULL << (depth < 64? (size_t) depth : 64))-1));
}

static inline size_t GetQuantumScale(size_t depth)
{
  return(GetQuantumRange(depth)+1);
}

static inline size_t GetQuantumScaleString(const QuantumInfo *quantum_info,
  char *string)
{
  (void) FormatLocaleString(string,MaxTextExtent,"%g",
    (double) GetQuantumScale(GetQuantumDepth(quantum_info)));
  return(strlen(string));
}

static inline size_t GetQuantumRangeString(const QuantumInfo *quantum_info,
  char *string)
{
  (void) FormatLocaleString(string,MaxTextExtent,"%g",
    (double) GetQuantumRange(GetQuantumDepth(quantum_info)));
  return(strlen(string));
}

static inline size_t GetQuantumDepthString(const QuantumInfo *quantum_info,
  char *string)
{
  (void) FormatLocaleString(string,MaxTextExtent,"%g",
    (double) GetQuantumDepth(quantum_info));
  return(strlen(string));
}

static inline size_t GetQuantumFormatString(const QuantumInfo *quantum_info,
  char *string)
{
  (void) FormatLocaleString(string,MaxTextExtent,"%s",
    CommandOptionToMnemonic(MagickQuantumFormatOptions,
      (ssize_t) GetQuantumFormat(quantum_info)));
  return(strlen(string));
}

static inline size_t GetQuantumTypeString(const QuantumInfo *quantum_info,
  char *string)
{
  (void) FormatLocaleString(string,MaxTextExtent,"%s",
    CommandOptionToMnemonic(MagickQuantumTypeOptions,
      (ssize_t) GetQuantumType(quantum_info)));
  return(strlen(string));
}

static inline size_t GetQuantumMinString(const QuantumInfo *quantum_info,
  char *string)
{
  (void) FormatLocaleString(string,MaxTextExtent,"%g",
    (double) GetQuantumMin(quantum_info));
  return(strlen(string));
}

static inline size_t GetQuantumMaxString(const QuantumInfo *quantum_info,
  char *string)
{
  (void) FormatLocaleString(string,MaxTextExtent,"%g",
    (double) GetQuantumMax(quantum_info));
  return(strlen(string));
}

static inline size_t GetQuantumMinIsWhiteString(const QuantumInfo *quantum_info,
  char *string)
{
  (void) FormatLocaleString(string,MaxTextExtent,"%s",
    IsQuantumMinIsWhite(quantum_info)!= MagickFalse? "True" : "False");
  return(strlen(string));
}

static inline size_t GetQuantumAlphaTypeString(const QuantumInfo *quantum_info,
  char *string)
{
  (void) FormatLocaleString(string,MaxTextExtent,"%s",
    CommandOptionToMnemonic(MagickQuantumAlphaOptions,
      (ssize_t) GetQuantumAlphaType(quantum_info)));
  return(strlen(string));
}

static inline size_t GetQuantumEndianString(const QuantumInfo *quantum_info,
  char *string)
{
  (void) FormatLocaleString(string,MaxTextExtent,"%s",
    CommandOptionToMnemonic(MagickEndianOptions,
      (ssize_t) GetQuantumEndian(quantum_info)));
  return(strlen(string));
}

static inline size_t GetQuantumInfoString(const QuantumInfo *quantum_info,
  char *string)
{
  (void) FormatLocaleString(string,MaxTextExtent,
    "depth=%s,format=%s,type=%s,min-is-white=%s,min=%s,max=%s,alpha-type=%s,"
    "endian=%s,pad=%s",
    GetQuantumDepthString(quantum_info,string),
    GetQuantumFormatString(quantum_info,string),
    GetQuantumTypeString(quantum_info,string),
    GetQuantumMinIsWhiteString(quantum_info,string),
    GetQuantumMinString(quantum_info,string),
    GetQuantumMaxString(quantum_info,string),
    GetQuantumAlphaTypeString(quantum_info,string),
    GetQuantumEndianString(quantum_info,string),
    GetQuantumPadString(quantum_info,string));
  return(strlen(string));
}

static inline size_t GetQuantumPadString(const QuantumInfo *quantum_info,
  char *string)
{
  (void) FormatLocaleString(string,MaxTextExtent,"%g",
    (double) GetQuantumPad(quantum_info));
  return(strlen(string));
}

static inline size_t GetQuantumDepthString(const QuantumInfo *quantum_info,
  char *string)
{
  (void) FormatLocaleString(string,MaxTextExtent,"%g",
    (double) GetQuantumDepth(quantum_info));
  return(strlen(string));
}

static inline size_t GetQuantumFormatString(const QuantumInfo *quantum_info,
  char *string)
{
  (void) FormatLocaleString(string,MaxTextExtent,"%s",
    CommandOptionToMnemonic(MagickQuantumFormatOptions,
      (ssize_t) GetQuantumFormat(quantum_info)));
  return(strlen(string));
}

static inline size_t GetQuantumTypeString(const QuantumInfo *quantum_info,
  char *string)
{
  (void) FormatLocaleString(string,MaxTextExtent,"%s",
    CommandOptionToMnemonic(MagickQuantumTypeOptions,
      (ssize_t) GetQuantumType(quantum_info)));
  return(strlen(string));
}

static inline size_t GetQuantumMinString(const QuantumInfo *quantum_info,
  char *string)
{
  (void) FormatLocaleString(string,MaxTextExtent,"%g",
    (double) GetQuantumMin(quantum_info));
  return(strlen(string));
}

static inline size_t GetQuantumMaxString(const QuantumInfo *quantum_info,
  char *string)
{
  (void) FormatLocaleString(string,MaxTextExtent,"%g",
    (double) GetQuantumMax(quantum_info));
  return(strlen(string));
}

static inline size_t GetQuantumMinIsWhiteString(const QuantumInfo *quantum_info,
  char *string)
{
  (void) FormatLocaleString(string,MaxTextExtent,"%s",
    IsQuantumMinIsWhite(quantum_info)!= MagickFalse? "True" : "False");
  return(strlen(string));
}

static inline size_t GetQuantumAlphaTypeString(const QuantumInfo *quantum_info,
  char *string)
{
  (void) FormatLocaleString(string,MaxTextExtent,"%s",
    CommandOptionToMnemonic(MagickQuantumAlphaOptions,
      (ssize_t) GetQuantumAlphaType(quantum_info)));
  return(strlen(string));
}

static inline size_t GetQuantumEndianString(const QuantumInfo *quantum_info,
  char *string)
{
  (void) FormatLocaleString(string,MaxTextExtent,"%s",
    CommandOptionToMnemonic(MagickEndianOptions,
      (ssize_t) GetQuantumEndian(quantum_info)));
  return(strlen(string));
}

static inline size_t GetQuantumInfoString(const QuantumInfo *quantum_info,
  char *string)
{
  (void) FormatLocaleString(string,MaxTextExtent,
    "depth=%s,format=%s,type=%s,min-is-white=%s,min=%s,max=%s,alpha-type=%s,"
    "endian=%s,pad=%s",
    GetQuantumDepthString(quantum_info,string),
    GetQuantumFormatString(quantum_info,string),
    GetQuantumTypeString(quantum_info,string),
    GetQuantumMinIsWhiteString(quantum_info,string),
    GetQuantumMinString(quantum_info,string),
    GetQuantumMaxString(quantum_info,string),
    GetQuantumAlphaTypeString(quantum_info,string),
    GetQuantumEndianString(quantum_info,string),
    GetQuantumPadString(quantum_info,string));
  return(strlen(string));
}

static inline size_t GetQuantumPadString(const QuantumInfo *quantum_info,
  char *string)
{
  (void) FormatLocaleString(string,MaxTextExtent,"%g",
    (double) GetQuantumPad(quantum_info));
  return(strlen(string));
}

static inline size_t GetQuantumDepthString(const QuantumInfo *quantum_info,
  char *string)
{
  (void) FormatLocaleString(string,MaxTextExtent,"%g",
    (double) GetQuantumDepth(quantum_info));
  return(strlen(string));
}

static inline size_t GetQuantumFormatString(const QuantumInfo *quantum_info,
  char *string)
{
  (void) FormatLocaleString(string,MaxTextExtent,"%s",
    CommandOptionToMnemonic(MagickQuantumFormatOptions,
      (ssize_t) GetQuantumFormat(quantum_info)));
  return(strlen(string));
}

static inline size_t GetQuantumTypeString(const QuantumInfo *quantum_info,
  char *string)
{
  (void) FormatLocaleString(string,MaxTextExtent,"%s",
    CommandOptionToMnemonic(MagickQuantumTypeOptions,
      (ssize_t) GetQuantumType(quantum_info)));
  return(strlen(string));
}

static inline size_t GetQuantumMinString(const QuantumInfo *quantum_info,
  char *string)
{
  (void) FormatLocaleString(string,MaxTextExtent,"%g",
    (double) GetQuantumMin(quantum_info));
  return(strlen(string));
}

static inline size_t GetQuantumMaxString(const QuantumInfo *quantum_info,
  char *string)
{
  (void) FormatLocaleString(string,MaxTextExtent,"%g",
    (double) GetQuantumMax(quantum_info));
  return(strlen(string));
}

static inline size_t GetQuantumMinIsWhiteString(const QuantumInfo *quantum_info,
  char *string)
{
  (void) FormatLocaleString(string,MaxTextExtent,"%s",
    IsQuantumMinIsWhite(quantum_info)!= MagickFalse? "True" : "False");
  return(strlen(string));
}

static inline size_t GetQuantumAlphaTypeString(const QuantumInfo *quantum_info,
  char *string)
{
  (void) FormatLocaleString(string,MaxTextExtent,"%s",
    CommandOptionToMnemonic(MagickQuantumAlphaOptions,
      (ssize_t) GetQuantumAlphaType(quantum_info)));
  return(strlen(string));
}

static inline size_t GetQuantumEndianString(const QuantumInfo *quantum_info,
  char *string)
{
  (void) FormatLocaleString(string,MaxTextExtent,"%s",
    CommandOptionToMnemonic(MagickEndianOptions,
      (ssize_t) GetQuantumEndian(quantum_info)));
  return(strlen(string));
}

static inline size_t GetQuantumInfoString(const QuantumInfo *quantum_info,
  char *string)
{
  (void) FormatLocaleString(string,MaxTextExtent,
    "depth=%s,format=%s,type=%s,min-is-white=%s,min=%s,max=%s,alpha-type=%s,"
    "endian=%s,pad=%s",
    GetQuantumDepthString(quantum_info,string),
    GetQuantumFormatString(quantum_info,string),
    GetQuantumTypeString(quantum_info,string),
    GetQuantumMinIsWhiteString(quantum_info,string),
    GetQuantumMinString(quantum_info,string),
    GetQuantumMaxString(quantum_info,string),
    GetQuantumAlphaTypeString(quantum_info,string),
    GetQuantumEndianString(quantum_info,string),
    GetQuantumPadString(quant