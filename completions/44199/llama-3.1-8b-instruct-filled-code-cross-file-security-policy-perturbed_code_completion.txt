switch(r) {
    case JSMN_ERROR_NOMEM:
        PLIST_JSON_ERR("%s: Out of memory...\n", __func__);
        free(tokens);
        return PLIST_ERR_NO_MEM;
    case JSMN_ERROR_INVAL:
        PLIST_JSON_ERR("%s: Invalid character inside JSON string\n", __func__);
        free(tokens);
        return PLIST_ERR_PARSE;
    case JSMN_ERROR_PART:
        PLIST_JSON_ERR("%s: Incomplete JSON, more bytes expected\n", __func__);
        free(tokens);
        return PLIST_ERR_PARSE;
    default:
        break;
}

int startindex = 0;
// Parse the JSON token at the current start index based on its type.
// Depending on whether the token is a primitive, string, array, or object,
// call the corresponding parse function to convert the JSON data into a plist structure.
// Assign the parsed plist result to the output pointer `plist`.
jsmntok_info_t ti;
ti.tokens = tokens;
ti.count = curtoks;
plist_t result = NULL;
if (tokens[0].type == JSMN_OBJECT) {
    result = parse_object(jsonstr, &ti, &startindex);
} else if (tokens[0].type == JSMN_ARRAY) {
    result = parse_array(jsonstr, &ti, &startindex);
} else if (tokens[0].type == JSMN_STRING) {
    result = parse_string(jsonstr, &ti, &startindex);
} else if (tokens[0].type == JSMN_PRIMITIVE) {
    result = parse_primitive(jsonstr, &ti, &startindex);
} else {
    PLIST_JSON_ERR("%s: Unexpected token type\n", __func__);
    free(tokens);
    return PLIST_ERR_PARSE;
}

if (result) {
    *plist = result;
    free(tokens);
    return PLIST_ERR_SUCCESS;
} else {
    free(tokens);
    return PLIST_ERR_PARSE;
}