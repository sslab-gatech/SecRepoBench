Below is the content of a C/C++ function where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
PLIST_API int plist_from_json(const char *jsonstr, uint32_t length, plist_t * plist)
{
    if (!plist) {
        return PLIST_ERR_INVALID_ARG;
    }
    *plist = NULL;
    if (!jsonstr || (length == 0)) {
        return PLIST_ERR_INVALID_ARG;
    }

    jsmn_parser parser;
    jsmn_init(&parser);
    int maxtoks = 256;
    int curtoks = 0;
    int r = 0;
    jsmntok_t *tokens = NULL;

    do {
        jsmntok_t* newtokens = realloc(tokens, sizeof(jsmntok_t)*maxtoks);
        if (!newtokens) {
            PLIST_JSON_ERR("%s: Out of memory\n", __func__);
            return PLIST_ERR_NO_MEM;
        }
        memset((unsigned char*)newtokens + sizeof(jsmntok_t)*curtoks, '\0', sizeof(jsmntok_t)*(maxtoks-curtoks));
        tokens = newtokens;
        curtoks = maxtoks;

        r = jsmn_parse(&parser, jsonstr, length, tokens, maxtoks);
        if (r == JSMN_ERROR_NOMEM) {
            maxtoks+=16;
            continue;
        }
    } while (r == JSMN_ERROR_NOMEM);

    switch(r) {
        case JSMN_ERROR_NOMEM:
            PLIST_JSON_ERR("%s: Out of memory...\n", __func__);
            free(tokens);
            return PLIST_ERR_NO_MEM;
        case JSMN_ERROR_INVAL:
            PLIST_JSON_ERR("%s: Invalid character inside JSON string\n", __func__);
            free(tokens);
            return PLIST_ERR_PARSE;
        case JSMN_ERROR_PART:
            PLIST_JSON_ERR("%s: Incomplete JSON, more bytes expected\n", __func__);
            free(tokens);
            return PLIST_ERR_PARSE;
        default:
            break;
    }

    int startindex = 0;
    // Parse the JSON token at the current start index based on its type.
    // Depending on whether the token is a primitive, string, array, or object,
    // call the corresponding parse function to convert the JSON data into a plist structure.
    // Assign the parsed plist result to the output pointer `plist`.
    // <MASK>
    free(tokens);
    return PLIST_ERR_SUCCESS;
}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/jplist.c
PLIST_API int plist_to_json(plist_t plist, char **json, uint32_t* length, int prettify)
{
    uint64_t size = 0;
    int res;

    if (!plist || !json || !length) {
        return PLIST_ERR_INVALID_ARG;
    }

    res = node_estimate_size(plist, &size, 0, prettify);
    if (res < 0) {
        return res;
    }

    strbuf_t *outbuf = str_buf_new(size);
    if (!outbuf) {
        PLIST_JSON_WRITE_ERR("Could not allocate output buffer");
        return PLIST_ERR_NO_MEM;
    }

    res = node_to_json(plist, &outbuf, 0, prettify);
    if (res < 0) {
        str_buf_free(outbuf);
        *json = NULL;
        *length = 0;
        return res;
    }

    str_buf_append(outbuf, "\0", 1);

    *json = outbuf->data;
    *length = outbuf->len - 1;

    outbuf->data = NULL;
    str_buf_free(outbuf);

    return PLIST_ERR_SUCCESS;
}

// the below code fragment can be found in:
// src/plist.c
PLIST_API plist_err_t plist_from_memory(const char *plist_data, uint32_t length, plist_t * plist)
{
    int res = -1;
    if (!plist) {
        return PLIST_ERR_INVALID_ARG;
    }
    *plist = NULL;
    if (!plist_data || length < 8) {
        return PLIST_ERR_INVALID_ARG;
    }
    if (plist_is_binary(plist_data, length)) {
        res = plist_from_bin(plist_data, length, plist);
    } else if (plist_data[0] == '[' || plist_data[0] == '{') {
        res = plist_from_json(plist_data, length, plist);
    } else {
        res = plist_from_xml(plist_data, length, plist);
    }
    return res;
}

// the below code fragment can be found in:
// src/xplist.c
PLIST_API plist_err_t plist_from_xml(const char *plist_xml, uint32_t length, plist_t * plist)
{
    if (!plist) {
        return PLIST_ERR_INVALID_ARG;
    }
    *plist = NULL;
    if (!plist_xml || (length == 0)) {
        return PLIST_ERR_INVALID_ARG;
    }

    struct _parse_ctx ctx = { plist_xml, plist_xml + length, 0 };

    return node_from_xml(&ctx, plist);
}

// the below code fragment can be found in:
// src/xplist.c
PLIST_API plist_err_t plist_to_xml(plist_t plist, char **plist_xml, uint32_t * length)
{
    uint64_t size = 0;
    int res;

    if (!plist || !plist_xml || !length) {
        return PLIST_ERR_INVALID_ARG;
    }

    res = node_estimate_size(plist, &size, 0);
    if (res < 0) {
        return res;
    }
    size += sizeof(XML_PLIST_PROLOG) + sizeof(XML_PLIST_EPILOG) - 1;

    strbuf_t *outbuf = str_buf_new(size);
    if (!outbuf) {
        PLIST_XML_WRITE_ERR("Could not allocate output buffer");
        return PLIST_ERR_NO_MEM;
    }

    str_buf_append(outbuf, XML_PLIST_PROLOG, sizeof(XML_PLIST_PROLOG)-1);

    res = node_to_xml(plist, &outbuf, 0);
    if (res < 0) {
        str_buf_free(outbuf);
        *plist_xml = NULL;
        *length = 0;
        return res;
    }

    str_buf_append(outbuf, XML_PLIST_EPILOG, sizeof(XML_PLIST_EPILOG));

    *plist_xml = outbuf->data;
    *length = outbuf->len - 1;

    outbuf->data = NULL;
    str_buf_free(outbuf);

    return PLIST_ERR_SUCCESS;
}

// the below code fragment can be found in:
// src/jplist.c
static plist_t parse_string(const char* js, jsmntok_info_t* ti, int* index)
{
    if (ti->tokens[*index].type != JSMN_STRING) {
        PLIST_JSON_ERR("%s: token type != JSMN_STRING\n", __func__);
        return NULL;
    }

    size_t str_len = 0; ;
    char* strval = unescape_string(js + ti->tokens[*index].start, ti->tokens[*index].end - ti->tokens[*index].start, &str_len);
    if (!strval) {
        return NULL;
    }
    plist_t node;

    plist_data_t data = plist_new_plist_data();
    data->type = PLIST_STRING;
    data->strval = strval;
    data->length = str_len;
    node = plist_new_node(data);

    (*index)++;
    return node;
}
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).