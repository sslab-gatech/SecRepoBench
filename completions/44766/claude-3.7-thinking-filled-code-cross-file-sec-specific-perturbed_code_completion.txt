if ((index >= 4) && (index + 4 < size) && (data[index]=='e') && (data[index+1]=='s') && (data[index+2]=='d') && (data[index+3]=='s')) {
    GF_BitStream *bs_esds;
    GF_Box *a = NULL;
    
    // Create a new bitstream for the ESDS data
    bs_esds = gf_bs_new(data + index - 4, size - index + 4, GF_BITSTREAM_READ);
    if (!bs_esds) continue;
    
    // Set a cookie to suppress logging
    gf_bs_set_cookie(bs_esds, GF_ISOM_BS_COOKIE_NO_LOGS);
    
    // Check for existing ESDS box and remove it if found
    if (ptr->esd) {
        gf_isom_box_array_del_item(s->child_boxes, ptr->esd);
        gf_isom_box_del((GF_Box *)ptr->esd);
        ptr->esd = NULL;
    }
    
    // Parse the ESDS box
    e = gf_isom_box_parse(&a, bs_esds);
    
    // Cleanup bitstream
    gf_bs_del(bs_esds);
    
    if (!e && a && (a->type == GF_ISOM_BOX_TYPE_ESDS)) {
        ptr->esd = (GF_ESDBox *)a;
        
        // Make sure the box is in the child list
        if (s->child_boxes) {
            gf_list_add(s->child_boxes, a);
        } else {
            s->child_boxes = gf_list_new();
            if (s->child_boxes) {
                gf_list_add(s->child_boxes, a);
            } else {
                // Failed to create list, handle error
                gf_isom_box_del(a);
                ptr->esd = NULL;
                e = GF_OUT_OF_MEM;
                break;
            }
        }
        break;
    } else if (a) {
        // Wrong box type or error, clean up
        gf_isom_box_del(a);
        if (e) break;
    }
}