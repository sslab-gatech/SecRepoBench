if ((index >= 4) && (index + 4 < size) &&
    (data[index] == 'e') && (data[index+1] == 's') && 
    (data[index+2] == 'd') && (data[index+3] == 's')) {
    
    GF_BitStream *esds_bs;
    GF_Box *a = NULL;
    u32 box_start = index - 4;
    u32 box_size = size - box_start; // Size from box start to end of buffer
    
    // Create a new bitstream starting at the box beginning (includes size field)
    esds_bs = gf_bs_new(data + box_start, box_size, GF_BITSTREAM_READ);
    if (!esds_bs) continue;
    
    // Set a cookie to suppress logging
    gf_bs_set_cookie(esds_bs, GF_ISOM_BS_COOKIE_NO_LOGS);
    
    // Remove existing ESDS box if any
    if (ptr->esd) {
        gf_isom_box_del_parent(&s->child_boxes, (GF_Box *)ptr->esd);
        ptr->esd = NULL;
    }
    
    // Parse a new ESDS box
    e = gf_isom_box_parse(&a, esds_bs);
    gf_bs_del(esds_bs);
    
    if (!e && a && (a->type == GF_ISOM_BOX_TYPE_ESDS)) {
        ptr->esd = (GF_ESDBox *)a;
        // Add to child_boxes if not already there
        if (!s->child_boxes) {
            s->child_boxes = gf_list_new();
            if (!s->child_boxes) {
                gf_isom_box_del(a);
                return GF_OUT_OF_MEM;
            }
        }
        gf_list_add(s->child_boxes, a);
    } else if (a) {
        gf_isom_box_del(a);
    }
    break;
}