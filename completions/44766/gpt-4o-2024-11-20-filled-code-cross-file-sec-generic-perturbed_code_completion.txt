// Search for the 'esds' box type in the data buffer
		if (data[index] == 'e' && data[index + 1] == 's' && data[index + 2] == 'd' && data[index + 3] == 's') {
			GF_BitStream *esds_bs;
			GF_ESDBox *esds_box = NULL;

			// Create a new bitstream starting at the identified location
			esds_bs = gf_bs_new((unsigned char *)(data + index), size - index, GF_BITSTREAM_READ);
			if (!esds_bs) {
				gf_free(data);
				return GF_OUT_OF_MEM;
			}

			// Set a cookie on the new bitstream to suppress logging
			gf_bs_set_cookie(esds_bs, GF_ISOM_BS_COOKIE_SUPPRESS_LOG);

			// Check if an ESDS box already exists and clean it up
			if (ptr->esds) {
				gf_isom_box_del((GF_Box *)ptr->esds);
				ptr->esds = NULL;
			}

			// Parse a new ESDS box from the bitstream
			if (gf_isom_box_parse((GF_Box **)&esds_box, esds_bs) == GF_OK) {
				// Ensure the box type matches 'esds'
				if (esds_box && esds_box->type == GF_ISOM_BOX_TYPE_ESDS) {
					ptr->esds = esds_box;

					// Add the ESDS box to the list of child boxes
					gf_list_add(ptr->child_boxes, esds_box);
				} else {
					// Clean up if the box type does not match
					if (esds_box) gf_isom_box_del((GF_Box *)esds_box);
				}
			}

			// Clean up the created bitstream
			gf_bs_del(esds_bs);
			break; // Exit the loop after processing the 'esds' box
		}