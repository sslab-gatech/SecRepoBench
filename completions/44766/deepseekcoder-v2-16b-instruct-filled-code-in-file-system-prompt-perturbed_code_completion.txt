gf_free(ptr);
}

GF_Box *gnrv_box_new()
{
	ISOM_DECL_BOX_ALLOC(GF_GenericVisualSampleEntryBox, GF_ISOM_BOX_TYPE_GNRA);

	gf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);
	return (GF_Box *)tmp;
}

//dummy
GF_Err gnrv_box_read(GF_Box *s, GF_BitStream *bs)
{
	return GF_OK;
}

#ifndef GPAC_DISABLE_ISOM_WRITE

GF_Err gnrv_box_write(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	GF_GenericVisualSampleEntryBox *ptr = (GF_GenericVisualSampleEntryBox *)s;

	//careful we are not writing the box type but the entry type so switch for write
	if (ptr->EntryType == GF_ISOM_BOX_TYPE_UUID) return GF_BAD_PARAM;
	ptr->type = ptr->EntryType;
	e = gf_isom_box_write_header(s, bs);
	if (e) return e;
	ptr->type = GF_ISOM_BOX_TYPE_GNRA;
	gf_bs_write_data(bs, ptr->reserved, 6);
	gf_bs_write_u16(bs, ptr->dataReferenceIndex);
	gf_bs_write_data(bs,  ptr->data, ptr->data_size);
	return GF_OK;
}

GF_Err gnrv_box_size(GF_Box *s)
{
	GF_GenericVisualSampleEntryBox *ptr = (GF_GenericVisualSampleEntryBox *)s;
	s->type = GF_ISOM_BOX_TYPE_GNRA;
	ptr->size += 8+ptr->data_size;
	return GF_OK;
}

#endif /*GPAC_DISABLE_ISOM_WRITE*/


void hdlr_box_del(GF_Box *s)
{
	GF_HandlerBox *ptr = (GF_HandlerBox *)s;
	if (ptr->name) gf_free(ptr->name);
	gf_free(ptr);
}

GF_Box *hdlr_box_new()
{
	ISOM_DECL_BOX_ALLOC(GF_HandlerBox, GF_ISOM_BOX_TYPE_HDLR);
	return (GF_Box *)tmp;
}

GF_Err hdlr_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_HandlerBox *ptr = (GF_HandlerBox *)s;

	ISOM_DECREASE_SIZE(ptr, 24);
	ptr->pre_defined = gf_bs_read_u32(bs);
	ptr->handler_type = gf_bs_read_u32(bs);
	ptr->reserved = gf_bs_read_u32(bs);
	gf_bs_read_data(bs, ptr->name, 256);
	ptr->name[255] = 0;
	return GF_OK;
}

#ifndef GPAC_DISABLE_ISOM_WRITE

GF_Err hdlr_box_write(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	GF_HandlerBox *ptr = (GF_HandlerBox *)s;

	e = gf_isom_box_write_header(s, bs);
	if (e) return e;
	gf_bs_write_u32(bs, ptr->pre_defined);
	gf_bs_write_u32(bs, ptr->handler_type);
	gf_bs_write_u32(bs, ptr->reserved);
	gf_bs_write_data(bs, ptr->name, 256);
	return GF_OK;
}

GF_Err hdlr_box_size(GF_Box *s)
{
	GF_HandlerBox *ptr = (GF_HandlerBox *)s;

	ptr->size += 24 + 256;
	return GF_OK;
}

#endif /*GPAC_DISABLE_ISOM_WRITE*/

void hinf_box_del(GF_Box *s)
{
	GF_HintInformationBox *ptr = (GF_HintInformationBox *)s;
	if (ptr->hints) gf_free(ptr->hints);
	gf_free(ptr);
}

GF_Box *hinf_box_new()
{
	ISOM_DECL_BOX_ALLOC(GF_HintInformationBox, GF_ISOM_BOX_TYPE_HINF);
	return (GF_Box *)tmp;
}

GF_Err hinf_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_HintInformationBox *ptr = (GF_HintInformationBox *)s;

	ISOM_DECREASE_SIZE(ptr, 4);
	ptr->nb_hints = gf_bs_read_u32(bs);

	if (ptr->nb_hints > ptr->size / 8) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[iso file] Invalid number of hints %d in hinf\n", ptr->nb_hints));
		return GF_ISOM_INVALID_FILE;
	}

	ptr->hints = (GF_HintEntry *)gf_malloc(sizeof(GF_HintEntry) * ptr->nb_hints);
	if (ptr->hints == NULL) return GF_OUT_OF_MEM;

	for (u32 i = 0; i < ptr->nb_hints; i++) {
		ISOM_DECREASE_SIZE(ptr, 8);
		ptr->hints[i].hint_type = gf_bs_read_u32(bs);
		ptr->hints[i].hint_version = gf_bs_read_u32(bs);
		ptr->hints[i].hint_id = gf_bs_read_u32(bs);
		ptr->hints[i].data_reference_index = gf_bs_read_u32(bs);
		ptr->hints[i].hint_size = gf_bs_read_u32(bs);
		if (ptr->hints[i].hint_size > ptr->size) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[iso file] Invalid hint size %d in hinf\n", ptr->hints[i].hint_size));
			return GF_ISOM_INVALID_FILE;
		}
		ptr->hints[i].hint_data = (u8 *)gf_malloc(ptr->hints[i].hint_size);
		if (ptr->hints[i].hint_data == NULL) return GF_OUT_OF_MEM;
		gf_bs_read_data(bs, ptr->hints[i].hint_data, ptr->hints[i].hint_size);
	}
	return GF_OK;
}

#ifndef GPAC_DISABLE_ISOM_WRITE

GF_Err hinf_box_write(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	GF_HintInformationBox *ptr = (GF_HintInformationBox *)s;

	e = gf_isom_box_write_header(s, bs);
	if (e) return e;
	gf_bs_write_u32(bs, ptr->nb_hints);
	for (u32 i = 0; i < ptr->nb_hints; i++) {
		gf_bs_write_u32(bs, ptr->hints[i].hint_type);
		gf_bs_write_u32(bs, ptr->hints[i].hint_version);
		gf_bs_write_u32(bs, ptr->hints[i].hint_id);
		gf_bs_write_u32(bs, ptr->hints[i].data_reference_index);
		gf_bs_write_u32(bs, ptr->hints[i].hint_size);
		gf_bs_write_data(bs, ptr->hints[i].hint_data, ptr->hints[i].hint_size);
	}
	return GF_OK;
}

GF_Err hinf_box_size(GF_Box *s)
{
	GF_HintInformationBox *ptr = (GF_HintInformationBox *)s;

	ptr->size += 4 + (4 * 4 * ptr->nb_hints) + (ptr->nb_hints * 4);
	for (u32 i = 0; i < ptr->nb_hints; i++) {
		ptr->size += ptr->hints[i].hint_size;
	}
	return GF_OK;
}

#endif /*GPAC_DISABLE_ISOM_WRITE*/

void iinf_box_del(GF_Box *s)
{
	GF_ItemInformationBox *ptr = (GF_ItemInformationBox *)s;
	if (ptr->items) gf_free(ptr->items);
	gf_free(ptr);
}

GF_Box *iinf_box_new()
{
	ISOM_DECL_BOX_ALLOC(GF_ItemInformationBox, GF_ISOM_BOX_TYPE_IINF);
	return (GF_Box *)tmp;
}

GF_Err iinf_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_ItemInformationBox *ptr = (GF_ItemInformationBox *)s;

	ISOM_DECREASE_SIZE(ptr, 4);
	ptr->nb_items = gf_bs_read_u32(bs);

	if (ptr->nb_items > ptr->size / 16) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[iso file] Invalid number of items %d in iinf\n", ptr->nb_items));
		return GF_ISOM_INVALID_FILE;
	}

	ptr->items = (GF_ItemInformationEntry *)gf_malloc(sizeof(GF_ItemInformationEntry) * ptr->nb_items);
	if (ptr->items == NULL) return GF_OUT_OF_MEM;

	for (u32 i = 0; i < ptr->nb_items; i++) {
		ISOM_DECREASE_SIZE(ptr, 16);
		ptr->items[i].item_ID = gf_bs_read_u32(bs);
		ptr->items[i].item_protection_index = gf_bs_read_u32(bs);
		ptr->items[i].item_type = gf_bs_read_u32(bs);
		ptr->items[i].item_description_index = gf_bs_read_u32(bs);
	}
	return GF_OK;
}

#ifndef GPAC_DISABLE_ISOM_WRITE

GF_Err iinf_box_write(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	GF_ItemInformationBox *ptr = (GF_ItemInformationBox *)s;

	e = gf_isom_box_write_header(s, bs);
	if (e) return e;
	gf_bs_write_u32(bs, ptr->nb_items);
	for (u32 i = 0; i < ptr->nb_items; i++) {
		gf_bs_write_u32(bs, ptr->items[i].item_ID);
		gf_bs_write_u32(bs, ptr->items[i].item_protection_index);
		gf_bs_write_u32(bs, ptr->items[i].item_type);
		gf_bs_write_u32(bs, ptr->items[i].item_description_index);
	}
	return GF_OK;
}

GF_Err iinf_box_size(GF_Box *s)
{
	GF_ItemInformationBox *ptr = (GF_ItemInformationBox *)s;

	ptr->size += 4 + (16 * ptr->nb_items);
	return GF_OK;
}

#endif /*GPAC_DISABLE_ISOM_WRITE*/

void iloc_box_del(GF_Box *s)
{
	GF_ItemLocationBox *ptr = (GF_ItemLocationBox *)s;
	if (ptr->entries) gf_free(ptr->entries);
	gf_free(ptr);
}

GF_Box *iloc_box_new()
{
	ISOM_DECL_BOX_ALLOC(GF_ItemLocationBox, GF_ISOM_BOX_TYPE_ILOC);
	return (GF_Box *)tmp;
}

GF_Err il