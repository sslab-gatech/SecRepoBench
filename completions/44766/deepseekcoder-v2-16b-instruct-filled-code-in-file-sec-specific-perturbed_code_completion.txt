}

#endif /*GPAC_DISABLE_ISOM_WRITE*/

void hdlr_box_del(GF_Box *s)
{
	GF_HandlerBox *ptr = (GF_HandlerBox *) s;
	if (ptr->name) gf_free(ptr->name);
	gf_free(ptr);
}

GF_Box *hdlr_box_new()
{
	ISOM_DECL_BOX_ALLOC(GF_HandlerBox, GF_ISOM_BOX_TYPE_HDLR);
	return (GF_Box *)tmp;
}

GF_Err hdlr_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_HandlerBox *ptr = (GF_HandlerBox *)s;

	ISOM_DECREASE_SIZE(ptr, 24);
	ptr->pre_defined = gf_bs_read_u32(bs);
	ptr->handler_type = gf_bs_read_u32(bs);
	ptr->reserved = gf_bs_read_u32(bs);
	if (ptr->size) {
		u32 bytesToRead = (u32) ptr->size;
		ptr->name = (char*)gf_malloc(bytesToRead * sizeof(char));
		if (!ptr->name) return GF_OUT_OF_MEM;
		gf_bs_read_data(bs, ptr->name, bytesToRead);
		ptr->name[bytesToRead-1] = 0;
	}
	return GF_OK;
}

#ifndef GPAC_DISABLE_ISOM_WRITE

GF_Err hdlr_box_write(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	GF_HandlerBox *ptr = (GF_HandlerBox *)s;

	e = gf_isom_full_box_write(s, bs);
	if (e) return e;
	gf_bs_write_u32(bs, ptr->pre_defined);
	gf_bs_write_u32(bs, ptr->handler_type);
	gf_bs_write_u32(bs, ptr->reserved);
	if (ptr->name) {
		gf_bs_write_data(bs, ptr->name, (u32)strlen(ptr->name) + 1);
	} else {
		gf_bs_write_u8(bs, 0);
	}
	return GF_OK;
}

GF_Err hdlr_box_size(GF_Box *s)
{
	GF_HandlerBox *ptr = (GF_HandlerBox *)s;

	ptr->size += 24;
	if (ptr->name) {
		ptr->size += strlen(ptr->name) + 1;
	}
	return GF_OK;
}

#endif /*GPAC_DISABLE_ISOM_WRITE*/

void hinf_box_del(GF_Box *s)
{
	gf_free(s);
}

GF_Err hinf_box_read(GF_Box *s, GF_BitStream *bs)
{
	return gf_isom_box_array_read(s, bs);
}

GF_Box *hinf_box_new()
{
	ISOM_DECL_BOX_ALLOC(GF_HandlerInformationBox, GF_ISOM_BOX_TYPE_HINF);
	return (GF_Box *)tmp;
}

#ifndef GPAC_DISABLE_ISOM_WRITE

GF_Err hinf_box_write(GF_Box *s, GF_BitStream *bs)
{
	return gf_isom_box_write_header(s, bs);
}

GF_Err hinf_box_size(GF_Box *s)
{
	return GF_OK;
}

#endif /*GPAC_DISABLE_ISOM_WRITE*/

void iinf_box_del(GF_Box *s)
{
	gf_free(s);
}

GF_Err iinf_box_read(GF_Box *s, GF_BitStream *bs)
{
	return gf_isom_box_array_read(s, bs);
}

GF_Box *iinf_box_new()
{
	ISOM_DECL_BOX_ALLOC(GF_ItemInformationBox, GF_ISOM_BOX_TYPE_IINF);
	return (GF_Box *)tmp;
}

#ifndef GPAC_DISABLE_ISOM_WRITE

GF_Err iinf_box_write(GF_Box *s, GF_BitStream *bs)
{
	return gf_isom_box_write_header(s, bs);
}

GF_Err iinf_box_size(GF_Box *s)
{
	return GF_OK;
}

#endif /*GPAC_DISABLE_ISOM_WRITE*/

void iloc_box_del(GF_Box *s)
{
	GF_ItemLocationBox *ptr = (GF_ItemLocationBox *)s;
	if (ptr->entries) gf_free(ptr->entries);
	gf_free(ptr);
}

GF_Err iloc_box_read(GF_Box *s, GF_BitStream *bs)
{
	u32 i;
	u32 entries;
	GF_ItemLocationBox *ptr = (GF_ItemLocationBox *)s;

	ISOM_DECREASE_SIZE(ptr, 4);
	ptr->item_ID = gf_bs_read_u32(bs);
	ptr->base_offset = gf_bs_read_u64(bs);
	ptr->extent_count = gf_bs_read_u32(bs);

	if (ptr->extent_count > ptr->size / 16) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[iso file] Invalid number of entries %d in iloc\n", ptr->extent_count));
		return GF_ISOM_INVALID_FILE;
	}

	ptr->entries = (GF_ItemExtentEntry *)gf_malloc(sizeof(GF_ItemExtentEntry) * ptr->extent_count);
	if (!ptr->entries) return GF_OUT_OF_MEM;

	for (i = 0; i < ptr->extent_count; i++) {
		ISOM_DECREASE_SIZE(ptr, 16);
		ptr->entries[i].extent_index = gf_bs_read_u32(bs);
		ptr->entries[i].extent_offset = gf_bs_read_u64(bs);
		ptr->entries[i].extent_length = gf_bs_read_u32(bs);
	}
	return GF_OK;
}

GF_Box *iloc_box_new()
{
	ISOM_DECL_BOX_ALLOC(GF_ItemLocationBox, GF_ISOM_BOX_TYPE_ILOC);
	return (GF_Box *)tmp;
}

#ifndef GPAC_DISABLE_ISOM_WRITE

GF_Err iloc_box_write(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	u32 i;
	GF_ItemLocationBox *ptr = (GF_ItemLocationBox *)s;

	e = gf_isom_full_box_write(s, bs);
	if (e) return e;
	gf_bs_write_u32(bs, ptr->item_ID);
	gf_bs_write_u64(bs, ptr->base_offset);
	gf_bs_write_u32(bs, ptr->extent_count);
	for (i = 0; i < ptr->extent_count; i++) {
		gf_bs_write_u32(bs, ptr->entries[i].extent_index);
		gf_bs_write_u64(bs, ptr->entries[i].extent_offset);
		gf_bs_write_u32(bs, ptr->entries[i].extent_length);
	}
	return GF_OK;
}

GF_Err iloc_box_size(GF_Box *s)
{
	GF_ItemLocationBox *ptr = (GF_ItemLocationBox *)s;

	ptr->size += 4 + 16 * ptr->extent_count;
	return GF_OK;
}

#endif /*GPAC_DISABLE_ISOM_WRITE*/

void iprp_box_del(GF_Box *s)
{
	GF_ItemPropertyBox *ptr = (GF_ItemPropertyBox *)s;
	if (ptr->properties) gf_free(ptr->properties);
	gf_free(ptr);
}

GF_Err iprp_box_read(GF_Box *s, GF_BitStream *bs)
{
	u32 i;
	u32 properties_count;
	GF_ItemPropertyBox *ptr = (GF_ItemPropertyBox *)s;

	ISOM_DECREASE_SIZE(ptr, 4);
	properties_count = gf_bs_read_u32(bs);

	if (properties_count > ptr->size / 8) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[iso file] Invalid number of properties %d in iprp\n", properties_count));
		return GF_ISOM_INVALID_FILE;
	}

	ptr->properties = (GF_ItemPropertyEntry *)gf_malloc(sizeof(GF_ItemPropertyEntry) * properties_count);
	if (!ptr->properties) return GF_OUT_OF_MEM;

	for (i = 0; i < properties_count; i++) {
		ISOM_DECREASE_SIZE(ptr, 8);
		ptr->properties[i].property_id = gf_bs_read_u32(bs);
		ptr->properties[i].property_length = gf_bs_read_u32(bs);
		if (ptr->properties[i].property_length > ptr->size) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[iso file] Invalid property length %d in iprp\n", ptr->properties[i].property_length));
			return GF_ISOM_INVALID_FILE;
		}
		ptr->properties[i].property_data = (char *)gf_malloc(ptr->properties[i].property_length);
		if (!ptr->properties[i].property_data) return GF_OUT_OF_MEM;
		gf_bs_read_data(bs, ptr->properties[i].property_data, ptr->properties[i].property_length);
	}
	return GF_OK;
}

GF_Box *iprp_box_new()
{
	ISOM_DECL_BOX_ALLOC(GF_ItemPropertyBox, GF_ISOM_BOX_TYPE_IPRP);
	return (GF_Box *)tmp;
}

#ifndef GPAC_DISABLE_ISOM_WRITE

GF_Err iprp_box_write(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	u32 i;
	GF_ItemPropertyBox *ptr = (GF_ItemPropertyBox *)s;

	e = gf_isom_full_box_write(s, bs);
	if (e) return e;
	gf_bs_write_u32(bs, ptr->properties_count);
	for (i = 0; i < ptr->properties_count; i++) {
		gf_bs_write_u32(bs, ptr->properties[i].property_id);
		gf_bs_write_u32(bs, ptr->properties[i].property_length);
		gf_bs_write_data(bs, ptr->properties[i].property_data, ptr->properties[i].property_length);
	}
	return GF_OK;
}

GF_Err iprp_box_size(GF_Box *s)
{
	GF_ItemPropertyBox *ptr = (GF_ItemPropertyBox *)s;

	ptr->size += 4 + 8 * ptr->properties_count;
	for (u32 i = 0; i < ptr->properties_count; i++) {
		ptr->size += ptr->properties[i].property_length;
	}
	return GF_OK;
}

#endif /*GPAC_DISABLE_ISOM_WRITE*/

void iprp_box_add_property(GF_Box *s, u32 property_id, const char *property_data, u32 property_length)
{
	GF_ItemPropertyBox *ptr = (GF_ItemPropertyBox *)s;
	if (ptr->properties_count >= ptr->properties_alloc_size) {
		ptr->properties_alloc_size = (ptr->properties_alloc_size ? ptr->properties_alloc_