// Search the data buffer for a specific four-character code indicating an ESDS box type.
for (index = 0; index < size - 8; index++) {
    if (data[index] == 'e' && data[index + 1] == 's' && data[index + 2] == 'd' && data[index + 3] == 's') {
        // Create a new bitstream starting at the identified location in the data buffer.
        GF_BitStream* esds_bs = gf_bs_new(data + index, size - index, GF_BITSTREAM_READ);
        // Set a cookie on the new bitstream to suppress logging for the operations that follow.
        gf_bs_set_cookie(esds_bs, GF_ISOM_BS_COOKIE_SILENCE);

        // If an ESDS box already exists in the current box structure, remove its reference from the parent-child hierarchy and delete it.
        GF_Box* esds_box = NULL;
        gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_ESDS, &esds_box);
        if (esds_box) {
            gf_isom_box_del_parent(&s->child_boxes, esds_box);
            gf_isom_box_del(esds_box);
        }

        // Parse a new ESDS box from the bitstream and update the ESDS box reference in the current box structure.
        esds_box = NULL;
        gf_isom_box_parse(&esds_box, esds_bs);
        if (esds_box && esds_box->type == GF_ISOM_BOX_TYPE_ESDS) {
            gf_list_add(s->child_boxes, esds_box);
        }

        // Clean up by deleting the created bitstream.
        gf_bs_del(esds_bs);
        break;
    }
}