// Search the data buffer for a specific four-character code indicating an ESDS box type.
for (index=0; index<size-8; index++) {
    if (data[index] == 'e' && data[index+1] == 's' && data[index+2] == 'd' && data[index+3] == 's') {
        // Create a new bitstream starting at the identified location in the data buffer.
        GF_BitStream* new_bs = gf_bs_new(data + index, size - index, GF_BITSTREAM_READ);
        // Set a cookie on the new bitstream to suppress logging for the operations that follow.
        gf_bs_set_cookie(new_bs, GF_ISOM_BS_COOKIE_SILENCE);

        // If an ESDS box already exists in the current box structure, remove its reference from the parent-child hierarchy and delete it.
        GF_Box* esds_box = gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_ESDS);
        if (esds_box) {
            gf_list_del_item(s->child_boxes, esds_box);
            gf_isom_box_del(esds_box);
        }

        // Parse a new ESDS box from the bitstream and update the ESDS box reference in the current box structure.
        GF_Box* new_esds_box;
        gf_isom_box_parse(&new_esds_box, new_bs);
        gf_list_add(s->child_boxes, new_esds_box);

        // If the parsing is successful and the box type matches ESDS, ensure the box is added to the list of child boxes.
        if (new_esds_box->type == GF_ISOM_BOX_TYPE_ESDS) {
            gf_list_add(s->child_boxes, new_esds_box);
        }

        // Clean up by deleting the created bitstream and handle any memory management necessary for ESDS box references.
        gf_bs_del(new_bs);
        break;
    }
}