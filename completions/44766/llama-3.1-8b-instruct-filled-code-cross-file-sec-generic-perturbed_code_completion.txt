// <MASK>
ESDS_Box *esds_box = NULL;
GF_Box *child = NULL;
GF_Box *parent = (GF_Box *)s;
GF_Box *esds_parent = NULL;
GF_Err e = GF_OK;

// Search the data buffer for a specific four-character code indicating an ESDS box type.
for (index=0; index<size-8; index++) {
    if (data[index] == 'E' && data[index+1] == 'S' && data[index+2] == 'D' && data[index+3] == 'S') {
        // Create a new bitstream starting at the identified location in the data buffer.
        GF_BitStream *esds_bs = gf_bs_new();
        if (!esds_bs) return GF_OUT_OF_MEM;
        gf_bs_set_cookie(esds_bs, GF_ISOM_BS_COOKIE_SUPPRESS_LOGGING);
        gf_bs_seek(esds_bs, pos + index + 4);

        // If an ESDS box already exists in the current box structure, remove its reference from the parent-child hierarchy and delete it.
        child = gf_isom_box_find_child(parent->child_boxes, GF_ISOM_BOX_TYPE_ESDS);
        if (child) {
            gf_isom_box_remove_child(parent->child_boxes, child);
            gf_free(child);
        }

        // Parse a new ESDS box from the bitstream and update the ESDS box reference in the current box structure.
        e = gf_isom_box_parse_ex(&esds_box, esds_bs, 0, GF_TRUE, 0);
        if (e) {
            gf_bs_delete(esds_bs);
            return e;
        }

        // If the parsing is successful and the box type matches ESDS, ensure the box is added to the list of child boxes.
        esds_parent = gf_isom_box_find_parent(esds_box, GF_ISOM_BOX_TYPE_AUDIO_SAMPLE_ENTRY);
        if (esds_parent) {
            gf_isom_box_add_child(esds_parent->child_boxes, esds_box);
        } else {
            gf_isom_box_add_child(parent->child_boxes, esds_box);
        }

        // Clean up by deleting the created bitstream and handle any memory management necessary for ESDS box references.
        gf_bs_delete(esds_bs);
        break;
    }
}

gf_free(data);
return e;