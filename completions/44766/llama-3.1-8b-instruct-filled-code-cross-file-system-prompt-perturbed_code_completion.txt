// Search the data buffer for a specific four-character code indicating an ESDS box type.
// If found, create a new bitstream starting at the identified location in the data buffer.
// Set a cookie on the new bitstream to suppress logging for the operations that follow.
// If an ESDS box already exists in the current box structure, remove its reference from the parent-child hierarchy and delete it.
// Parse a new ESDS box from the bitstream and update the ESDS box reference in the current box structure.
// If the parsing is successful and the box type matches ESDS, ensure the box is added to the list of child boxes.
// Clean up by deleting the created bitstream and handle any memory management necessary for ESDS box references.
ESDS_Box *esds_box = NULL;
u32 esds_box_size = 0;
u32 esds_box_offset = 0;
GF_BitStream *esds_bs = NULL;
GF_Err e = GF_OK;

for (index = 0; index < size - 8; index++) {
    u32 code = ((u32*)data)[index];
    if (code == 0x0000006D) { // ESDS box type
        esds_box_size = ((u32*)data)[index + 1];
        esds_box_offset = index + 8;
        break;
    }
}

if (esds_box_size > 0) {
    esds_bs = gf_bs_new();
    if (!esds_bs) return GF_OUT_OF_MEM;
    gf_bs_set_cookie(esds_bs, GF_ISOM_BS_COOKIE_SUPPRESS_LOG);
    gf_bs_seek(esds_bs, esds_box_offset);
    e = gf_isom_box_parse(&esds_box, esds_bs);
    if (e) {
        gf_bs_delete(esds_bs);
        return e;
    }
    if (esds_box->type == GF_ISOM_BOX_TYPE_ESDS) {
        GF_Box *esds_parent = s;
        GF_Box *esds_child = gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_ESDS);
        if (esds_child) {
            gf_isom_box_remove_child(esds_parent, esds_child);
            gf_box_delete(esds_child);
        }
        gf_isom_box_add_child(esds_parent, esds_box);
    }
    gf_bs_delete(esds_bs);
}
gf_free(data);
return e;