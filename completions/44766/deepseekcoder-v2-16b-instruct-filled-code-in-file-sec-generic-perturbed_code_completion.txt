SampleEntryBox *)ptr);
	if (ptr->data) gf_free(ptr->data);
	gf_free(ptr);
}

GF_Box *gnrv_box_new()
{
	ISOM_DECL_BOX_ALLOC(GF_GenericVisualSampleEntryBox, GF_ISOM_BOX_TYPE_GNRA);

	gf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);
	return (GF_Box *)tmp;
}

//dummy
GF_Err gnrv_box_read(GF_Box *s, GF_BitStream *bs)
{
	return GF_OK;
}

#ifndef GPAC_DISABLE_ISOM_WRITE

GF_Err gnrv_box_write(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	GF_GenericVisualSampleEntryBox *ptr = (GF_GenericVisualSampleEntryBox *)s;

	//careful we are not writing the box type but the entry type so switch for write
	if (ptr->EntryType == GF_ISOM_BOX_TYPE_UUID) return GF_BAD_PARAM;
	ptr->type = ptr->EntryType;
	e = gf_isom_box_write_header(s, bs);
	if (e) return e;
	ptr->type = GF_ISOM_BOX_TYPE_GNRA;
	gf_bs_write_data(bs, ptr->reserved, 6);
	gf_bs_write_u16(bs, ptr->dataReferenceIndex);
	gf_bs_write_data(bs,  ptr->data, ptr->data_size);
	return GF_OK;
}

GF_Err gnrv_box_size(GF_Box *s)
{
	GF_GenericVisualSampleEntryBox *ptr = (GF_GenericVisualSampleEntryBox *)s;
	s->type = GF_ISOM_BOX_TYPE_GNRA;
	ptr->size += 8+ptr->data_size;
	return GF_OK;
}

#endif /*GPAC_DISABLE_ISOM_WRITE*/

void hdlr_box_del(GF_Box *s)
{
	GF_HandlerBox *ptr = (GF_HandlerBox *) s;
	if (ptr->name) gf_free(ptr->name);
	gf_free(ptr);
}

GF_Box *hdlr_box_new()
{
	ISOM_DECL_BOX_ALLOC(GF_HandlerBox, GF_ISOM_BOX_TYPE_HDLR);
	return (GF_Box *)tmp;
}

GF_Err hdlr_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_HandlerBox *ptr = (GF_HandlerBox *)s;

	ISOM_DECREASE_SIZE(ptr, 24);
	ptr->pre_defined = gf_bs_read_u32(bs);
	ptr->handler_type = gf_bs_read_u32(bs);
	ptr->reserved = gf_bs_read_u32(bs);
	gf_bs_read_data(bs, ptr->name, 256);
	ptr->name[255] = 0;
	return GF_OK;
}

#ifndef GPAC_DISABLE_ISOM_WRITE

GF_Err hdlr_box_write(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	GF_HandlerBox *ptr = (GF_HandlerBox *) s;

	e = gf_isom_full_box_write(s, bs);
	if (e) return e;
	gf_bs_write_u32(bs, ptr->pre_defined);
	gf_bs_write_u32(bs, ptr->handler_type);
	gf_bs_write_u32(bs, ptr->reserved);
	gf_bs_write_data(bs, ptr->name, 256);
	return GF_OK;
}

GF_Err hdlr_box_size(GF_Box *s)
{
	GF_HandlerBox *ptr = (GF_HandlerBox *) s;

	ptr->size += 24 + 256;
	return GF_OK;
}

#endif /*GPAC_DISABLE_ISOM_WRITE*/

void hinf_box_del(GF_Box *s)
{
	GF_HintInformationBox *ptr = (GF_HintInformationBox *) s;
	if (ptr->hintData) gf_free(ptr->hintData);
	gf_free(ptr);
}

GF_Box *hinf_box_new()
{
	ISOM_DECL_BOX_ALLOC(GF_HintInformationBox, GF_ISOM_BOX_TYPE_HINF);
	return (GF_Box *)tmp;
}

GF_Err hinf_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_HintInformationBox *ptr = (GF_HintInformationBox *)s;

	ISOM_DECREASE_SIZE(ptr, 4);
	ptr->hintCount = gf_bs_read_u32(bs);
	if (ptr->hintCount > ptr->size / 4) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[iso file] Invalid number of hints %d in hinf\n", ptr->hintCount));
		return GF_ISOM_INVALID_FILE;
	}
	ptr->hintData = (u8 *)gf_malloc(ptr->hintCount * 4);
	if (!ptr->hintData) return GF_OUT_OF_MEM;
	for (u32 i = 0; i < ptr->hintCount; i++) {
		ptr->hintData[i] = gf_bs_read_u8(bs);
	}
	return GF_OK;
}

#ifndef GPAC_DISABLE_ISOM_WRITE

GF_Err hinf_box_write(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	GF_HintInformationBox *ptr = (GF_HintInformationBox *)s;

	e = gf_isom_full_box_write(s, bs);
	if (e) return e;
	gf_bs_write_u32(bs, ptr->hintCount);
	for (u32 i = 0; i < ptr->hintCount; i++) {
		gf_bs_write_u8(bs, ptr->hintData[i]);
	}
	return GF_OK;
}

GF_Err hinf_box_size(GF_Box *s)
{
	GF_HintInformationBox *ptr = (GF_HintInformationBox *)s;

	ptr->size += 4 + ptr->hintCount * 4;
	return GF_OK;
}

#endif /*GPAC_DISABLE_ISOM_WRITE*/

void iinf_box_del(GF_Box *s)
{
	GF_ItemInformationBox *ptr = (GF_ItemInformationBox *) s;
	if (ptr->itemInfos) gf_free(ptr->itemInfos);
	gf_free(ptr);
}

GF_Box *iinf_box_new()
{
	ISOM_DECL_BOX_ALLOC(GF_ItemInformationBox, GF_ISOM_BOX_TYPE_IINF);
	return (GF_Box *)tmp;
}

GF_Err iinf_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_ItemInformationBox *ptr = (GF_ItemInformationBox *)s;

	ISOM_DECREASE_SIZE(ptr, 4);
	ptr->itemCount = gf_bs_read_u32(bs);
	if (ptr->itemCount > ptr->size / 16) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[iso file] Invalid number of items %d in iinf\n", ptr->itemCount));
		return GF_ISOM_INVALID_FILE;
	}
	ptr->itemInfos = (GF_ItemInfo *)gf_malloc(ptr->itemCount * sizeof(GF_ItemInfo));
	if (!ptr->itemInfos) return GF_OUT_OF_MEM;
	for (u32 i = 0; i < ptr->itemCount; i++) {
		ISOM_DECREASE_SIZE(ptr, 16);
		ptr->itemInfos[i].itemID = gf_bs_read_u32(bs);
		ptr->itemInfos[i].itemProtectionIndex = gf_bs_read_u32(bs);
		ptr->itemInfos[i].itemType = gf_bs_read_u32(bs);
		ptr->itemInfos[i].itemName = NULL;
		if (ptr->itemInfos[i].itemType != 0) {
			u32 itemNameLength = gf_bs_read_u32(bs);
			if (itemNameLength > 0) {
				ptr->itemInfos[i].itemName = (char *)gf_malloc(itemNameLength + 1);
				if (!ptr->itemInfos[i].itemName) return GF_OUT_OF_MEM;
				gf_bs_read_data(bs, ptr->itemInfos[i].itemName, itemNameLength);
				ptr->itemInfos[i].itemName[itemNameLength] = 0;
			}
		}
	}
	return GF_OK;
}

#ifndef GPAC_DISABLE_ISOM_WRITE

GF_Err iinf_box_write(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	GF_ItemInformationBox *ptr = (GF_ItemInformationBox *)s;

	e = gf_isom_full_box_write(s, bs);
	if (e) return e;
	gf_bs_write_u32(bs, ptr->itemCount);
	for (u32 i = 0; i < ptr->itemCount; i++) {
		gf_bs_write_u32(bs, ptr->itemInfos[i].itemID);
		gf_bs_write_u32(bs, ptr->itemInfos[i].itemProtectionIndex);
		gf_bs_write_u32(bs, ptr->itemInfos[i].itemType);
		if (ptr->itemInfos[i].itemType != 0) {
			u32 itemNameLength = strlen(ptr->itemInfos[i].itemName);
			gf_bs_write_u32(bs, itemNameLength);
			if (itemNameLength > 0) {
				gf_bs_write_data(bs, ptr->itemInfos[i].itemName, itemNameLength);
			}
		} else {
			gf_bs_write_u32(bs, 0);
		}
	}
	return GF_OK;
}

GF_Err iinf_box_size(GF_Box *s)
{
	GF_ItemInformationBox *ptr = (GF_ItemInformationBox *)s;

	ptr->size += 4;
	for (u32 i = 0; i < ptr->itemCount; i++) {
		ptr->size += 16;
		if (ptr->itemInfos[i].itemType != 0) {
			ptr->size += strlen(ptr->itemInfos[i].itemName) + 1;
		}
	}
	return GF_OK;
}

#endif /*GPAC_DISABLE_ISOM_WRITE*/

void iloc_box_del(GF_Box *s)
{
	GF_ItemLocationBox *ptr = (GF_ItemLocationBox *)s;
	if (ptr->itemLocations) gf_free(ptr->itemLocations);
	gf_free(ptr);
}

GF_Box *iloc_box_new()
{
	ISOM_DECL_BOX_ALLOC(GF_ItemLocationBox, GF_ISOM_BOX_TYPE_ILOC);
	return (GF_Box *)tmp;
}

GF_Err iloc_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_ItemLocationBox *ptr = (GF_ItemLocationBox *)s;

	ISOM_DECREASE_SIZE(ptr, 4);
	ptr->itemCount = gf_bs_read_u32(bs);
	if (ptr->itemCount > ptr->size / 20) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[iso file] Invalid number of items %d in iloc\n", ptr->itemCount));
		return GF_ISOM_INVALID_FILE;
	}
	ptr->itemLocations = (GF_ItemLocation *)gf_malloc(ptr->itemCount * sizeof(GF_ItemLocation));
	if (!ptr->item