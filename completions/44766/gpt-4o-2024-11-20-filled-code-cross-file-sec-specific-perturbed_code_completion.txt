// Check for the 'esds' box type (0x65736473 in ASCII)
		if (data[index] == 'e' && data[index + 1] == 's' && data[index + 2] == 'd' && data[index + 3] == 's') {
			GF_BitStream *new_bs = gf_bs_new((unsigned char *)(data + index), size - index, GF_BITSTREAM_READ);
			if (!new_bs) {
				gf_free(data);
				return GF_OUT_OF_MEM;
			}

			// Suppress logging for operations on the new bitstream
			gf_bs_set_cookie(new_bs, GF_ISOM_BS_COOKIE_SUPPRESS_LOG);

			// Remove existing ESDS box if present
			GF_ESDBox *esds = (GF_ESDBox *)gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_ESDS);
			if (esds) {
				gf_list_rem(s->child_boxes, esds);
				gf_isom_box_del((GF_Box *)esds);
			}

			// Parse a new ESDS box from the bitstream
			GF_Box *new_box = NULL;
			e = gf_isom_box_parse(&new_box, new_bs);
			if (e == GF_OK && new_box && new_box->type == GF_ISOM_BOX_TYPE_ESDS) {
				// Add the new ESDS box to the list of child boxes
				gf_list_add(s->child_boxes, new_box);
			} else {
				// Clean up if parsing failed
				if (new_box) gf_isom_box_del(new_box);
			}

			// Delete the created bitstream
			gf_bs_del(new_bs);

			// Break the loop as we have processed the 'esds' box
			break;
		}