if (child->type == RE_NODE_RANGE_ANY &&
   !child->greedy &&
    child->start == 0 &&
    child->end > RE_MAX_SPLIT_THRESHOLD)
{
  RE_AST* new_re_ast;
  RE_AST* new_remainder_re_ast;
  int32_t min_gap;
  int32_t max_gap;

  FAIL_ON_ERROR(yr_re_ast_create(&new_re_ast));
  FAIL_ON_ERROR(yr_re_ast_create(&new_remainder_re_ast));

  yr_re_node_prepend_child(new_re_ast->root_node, re_ast->root_node->children_head);
  yr_re_node_prepend_child(new_remainder_re_ast->root_node, child->next_sibling);

  *result_re_ast = new_re_ast;
  *remainder_re_ast = new_remainder_re_ast;
  *min_gap = child->start;
  *max_gap = child->end;

  yr_re_node_destroy(re_ast->root_node);
  re_ast->root_node = child;

  return ERROR_SUCCESS;
}