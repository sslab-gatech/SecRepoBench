if (
    child->type == RE_NODE_RANGE &&
    child->children_head != NULL &&
    child->children_head->type == RE_NODE_ANY &&
    !child->greedy &&
    child->start < child->end
)
{
  RE_AST* new_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
  if (new_ast == NULL)
    return ERROR_INSUFFICIENT_MEMORY;

  memset(new_ast, 0, sizeof(RE_AST));
  new_ast->flags = re_ast->flags;

  RE_NODE* new_root = (RE_NODE*) yr_malloc(sizeof(RE_NODE));
  if (new_root == NULL)
  {
    yr_free(new_ast);
    return ERROR_INSUFFICIENT_MEMORY;
  }

  memset(new_root, 0, sizeof(RE_NODE));
  new_root->type = RE_NODE_CONCAT;
  new_ast->root_node = new_root;

  // Detach everything after (and including) this child from the original AST
  if (child->prev_sibling != NULL)
  {
    child->prev_sibling->next_sibling = NULL;
    re_ast->root_node->children_tail = child->prev_sibling;
  }
  else
  {
    re_ast->root_node->children_head = NULL;
    re_ast->root_node->children_tail = NULL;
  }

  // Build the remainder AST starting from this child
  child->prev_sibling = NULL;
  new_root->children_head = child;

  // Find the new tail
  while (child->next_sibling != NULL)
    child = child->next_sibling;

  new_root->children_tail = child;

  *remainder_re_ast = new_ast;
  *min_gap = child->start;
  *maximumgap = child->end;

  return ERROR_SUCCESS;
}