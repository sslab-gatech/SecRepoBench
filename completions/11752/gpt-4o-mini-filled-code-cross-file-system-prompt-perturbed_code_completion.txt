if (child->type == RE_NODE_RANGE && child->is_non_greedy && 
        child->range_max > SOME_THRESHOLD) // Replace SOME_THRESHOLD with the actual threshold value
    {
        // Create a new AST for the remainder
        RE_AST* new_re_ast = (RE_AST*)malloc(sizeof(RE_AST));
        new_re_ast->root_node = child; // Assuming child is the node to split at

        // Update the current AST to remove the child node
        if (child->prev_sibling != NULL)
            child->prev_sibling->next_sibling = child->next_sibling;
        if (child->next_sibling != NULL)
            child->next_sibling->prev_sibling = child->prev_sibling;

        if (re_ast->root_node->children_head == child)
            re_ast->root_node->children_head = child->next_sibling;
        if (re_ast->root_node->children_tail == child)
            re_ast->root_node->children_tail = child->prev_sibling;

        // Update min and max gap
        *min_gap = child->range_min;
        *maximumgap = child->range_max;

        // Set the result and remainder ASTs
        *result_re_ast = re_ast;
        *remainder_re_ast = new_re_ast;

        return ERROR_SUCCESS;
    }