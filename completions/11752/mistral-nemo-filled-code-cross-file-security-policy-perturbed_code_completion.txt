if (child->type == RE_NODE_NON_GREEDY_RANGE_ANY &&
    child->range > THRESHOLD) {
  RE_AST* new_re_ast = yr_re_ast_create();
  RE_NODE* new_node = yr_re_node_create(RE_NODE_CONCAT);

  // Update the min and max gap with the range values of the current node.
  *min_gap = child->range_min;
  *maximumgap = child->range_max;

  // Create a new AST for the remainder.
  yr_re_node_append_child(new_node, child->next_sibling);
  new_re_ast->root_node = new_node;

  // Update the current AST to separate the nodes before and after the point of splitting.
  if (child->prev_sibling != NULL) {
    child->prev_sibling->next_sibling = NULL;
  } else {
    re_ast->root_node = child->next_sibling;
  }
  if (child->next_sibling != NULL) {
    child->next_sibling->prev_sibling = NULL;
  }

  *remainder_re_ast = new_re_ast;

  // Ensure the child node is properly removed.
  yr_re_node_destroy(child);

  return ERROR_SUCCESS;
}