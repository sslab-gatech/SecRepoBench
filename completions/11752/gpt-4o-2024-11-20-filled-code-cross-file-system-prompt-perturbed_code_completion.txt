(child->type == RE_NODE_RANGE_ANY && child->greedy == false &&
     child->value > SOME_THRESHOLD) // Replace SOME_THRESHOLD with the actual threshold value
    {
      *min_gap = child->start;
      *maximumgap = child->end;

      // Create a new AST for the remainder
      *remainder_re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
      if (*remainder_re_ast == NULL)
        return ERROR_INSUFFICIENT_MEMORY;

      (*remainder_re_ast)->root_node = re_ast->root_node;
      re_ast->root_node = yr_re_node_create(RE_NODE_CONCAT);
      if (re_ast->root_node == NULL)
      {
        yr_re_ast_destroy(*remainder_re_ast);
        *remainder_re_ast = NULL;
        return ERROR_INSUFFICIENT_MEMORY;
      }

      // Update the current AST to separate nodes before the splitting point
      concat = re_ast->root_node;
      while (re_ast->root_node->children_head != child)
      {
        RE_NODE* temp = re_ast->root_node->children_head;
        re_ast->root_node->children_head = temp->next_sibling;

        if (re_ast->root_node->children_head != NULL)
          re_ast->root_node->children_head->prev_sibling = NULL;

        yr_re_node_append_child(concat, temp);
      }

      // Update the remainder AST to start from the splitting point
      (*remainder_re_ast)->root_node->children_head = child;
      child->prev_sibling = NULL;

      return ERROR_SUCCESS;
    }