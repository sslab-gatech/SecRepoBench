if (child->type == RE_NODE_ANY && 
    child->quantifier != NULL && 
    !child->quantifier->greedy && 
    (child->quantifier->min == 0 && child->quantifier->max > 10))
{
  *result_re_ast = yr_re_ast_create();
  if (*result_re_ast == NULL)
    return ERROR_INSUFFICIENT_MEMORY;

  (*result_re_ast)->root_node = yr_re_node_create(RE_NODE_CONCAT);
  if ((*result_re_ast)->root_node == NULL)
  {
    yr_re_ast_destroy(*result_re_ast);
    *result_re_ast = NULL;
    return ERROR_INSUFFICIENT_MEMORY;
  }

  RE_NODE* new_concat = (*result_re_ast)->root_node;
  RE_NODE* prev_child = child->prev_sibling;

  if (prev_child != NULL)
    prev_child->next_sibling = NULL;
  else
    re_ast->root_node->children_head = NULL;

  re_ast->root_node->children_tail = prev_child;

  yr_re_node_append_child(new_concat, child);

  *remainder_re_ast = re_ast;
  *min_gap = child->quantifier->min;
  *maximumgap = child->quantifier->max;

  return ERROR_SUCCESS;
}