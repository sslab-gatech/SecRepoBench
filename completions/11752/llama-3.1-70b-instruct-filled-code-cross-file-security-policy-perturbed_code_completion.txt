(child->type == RE_NODE_RANGE_ANY &&
  child->greedy == false &&
  child->range.min > MAX_GAP_THRESHOLD &&
  child->range.max > MAX_GAP_THRESHOLD)
{
  RE_NODE* new_root_node;
  RE_AST* new_re_ast;

  FAIL_ON_ERROR(yr_re_node_create(RE_NODE_CONCAT, &new_root_node));

  if (child->prev_sibling!= NULL)
  {
    child->prev_sibling->next_sibling = NULL;
    new_root_node->children_head = child;
    new_root_node->children_tail = child;
    child->prev_sibling = NULL;
  }
  else
  {
    new_root_node->children_head = NULL;
    new_root_node->children_tail = NULL;
  }

  FAIL_ON_ERROR(yr_re_ast_create(new_root_node, &new_re_ast));

  *remainder_re_ast = new_re_ast;
  *min_gap = child->range.min;
  *maximumgap = child->range.max;

  if (child->next_sibling!= NULL)
  {
    re_ast->root_node->children_head = child->next_sibling;
    child->next_sibling->prev_sibling = NULL;
  }
  else
  {
    re_ast->root_node->children_head = NULL;
    re_ast->root_node->children_tail = NULL;
  }

  yr_re_node_destroy(child);

  return ERROR_SUCCESS;
}