(child->type == RE_NODE_RANGE_ANY && !child->greedy && (child->start > 0 || child->end > 0))
    {
        RE_NODE* prev_child = child->prev_sibling;
        RE_NODE* original_concat = re_ast->root_node;
        RE_NODE* original_tail = original_concat->children_tail;

        original_concat->children_tail = prev_child;

        if (prev_child != NULL)
            prev_child->next_sibling = NULL;
        else
            original_concat->children_head = NULL;

        RE_NODE* remainder_concat = yr_re_node_create(RE_NODE_CONCAT);
        if (remainder_concat == NULL)
            return ERROR_INSUFFICIENT_MEMORY;

        remainder_concat->children_head = child;
        remainder_concat->children_tail = original_tail;
        child->prev_sibling = NULL;

        *remainder_re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
        if (*remainder_re_ast == NULL)
        {
            yr_re_node_destroy(remainder_concat);
            return ERROR_INSUFFICIENT_MEMORY;
        }

        (*remainder_re_ast)->root_node = remainder_concat;

        *min_gap = child->start;
        *maximumgap = child->end;

        return ERROR_SUCCESS;
    }