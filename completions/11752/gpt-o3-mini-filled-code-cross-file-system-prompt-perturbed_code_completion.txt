if (child->non_greedy &&
    child->type == RE_NODE_ANY &&
    child->min > 0)  // adjust the threshold condition as needed
{
    *min_gap = child->min;
    *maximumgap = child->max;

    // Detach the remainder of the child list from the current AST.
    if (child->prev_sibling != NULL)
    {
        child->prev_sibling->next_sibling = NULL;
        re_ast->root_node->children_tail = child->prev_sibling;
        child->prev_sibling = NULL;
    }
    else
    {
        // The chaining point is the first child. Clear the list.
        re_ast->root_node->children_head = NULL;
        re_ast->root_node->children_tail = NULL;
    }

    // Create a new AST for the remainder.
    RE_AST* new_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
    if (new_ast == NULL)
        return ERROR_INSUFFICIENT_MEMORY;

    // Allocate a new concat root node for the remainder AST.
    new_ast->root_node = (RE_NODE*) yr_malloc(sizeof(RE_NODE));
    if (new_ast->root_node == NULL)
    {
        yr_free(new_ast);
        return ERROR_INSUFFICIENT_MEMORY;
    }

    new_ast->root_node->type = RE_NODE_CONCAT;
    new_ast->root_node->children_head = child;

    // Find the tail of the remainder child list.
    RE_NODE* tail = child;
    while (tail->next_sibling != NULL)
        tail = tail->next_sibling;
    new_ast->root_node->children_tail = tail;

    *remainder_re_ast = new_ast;
    return ERROR_SUCCESS;
}