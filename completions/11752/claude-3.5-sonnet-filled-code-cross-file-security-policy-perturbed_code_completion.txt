((child->type == RE_NODE_RANGE_ANY && !child->greedy &&
  child->start > YR_RE_SCAN_LIMIT))
{
  *min_gap = child->start;
  *maximumgap = child->end;

  // Create a new AST for the remainder
  FAIL_ON_ERROR(yr_re_ast_create(&re_ast->arena, remainder_re_ast));

  // Set the root node of the remainder AST
  (*remainder_re_ast)->root_node = child->next_sibling;

  // Update the current AST
  re_ast->root_node->children_tail = child->prev_sibling;

  if (child->prev_sibling != NULL)
  {
    child->prev_sibling->next_sibling = NULL;
  }
  else
  {
    re_ast->root_node->children_head = NULL;
  }

  // Remove the child node from the current AST
  child->prev_sibling = NULL;
  child->next_sibling = NULL;
  yr_re_node_destroy(child);

  return ERROR_SUCCESS;
}