if (child->type == RE_NODE_RANGE && child->range_max > 100) {
  RE_AST* new_ast = yr_re_ast_create();
  if (new_ast == NULL) {
    return ERROR_INSUFFICIENT_MEMORY;
  }

  new_ast->root_node = yr_re_node_create(RE_NODE_CONCAT);
  if (new_ast->root_node == NULL) {
    yr_free(new_ast);
    return ERROR_INSUFFICIENT_MEMORY;
  }

  RE_NODE* new_node = yr_re_node_create(RE_NODE_RANGE);
  if (new_node == NULL) {
    yr_re_ast_destroy(new_ast);
    return ERROR_INSUFFICIENT_MEMORY;
  }

  new_node->range_min = re_ast->root_node->children_head->range_min;
  new_node->range_max = 100;
  yr_re_node_append_child(new_ast->root_node, new_node);

  RE_NODE* remaining_node = yr_re_node_create(RE_NODE_RANGE);
  if (remaining_node == NULL) {
    yr_re_ast_destroy(new_ast);
    return ERROR_INSUFFICIENT_MEMORY;
  }

  remaining_node->range_min = 101;
  remaining_node->range_max = re_ast->root_node->children_head->range_max;
  yr_re_node_append_child(new_ast->root_node, remaining_node);

  *min_gap = re_ast->root_node->children_head->range_min;
  *maximumgap = re_ast->root_node->children_head->range_max;

  *result_re_ast = new_ast;
  *remainder_re_ast = re_ast;
  *remainder_re_ast->root_node->children_head = remaining_node;
  *remainder_re_ast->root_node->children_head->prev_sibling = NULL;

  return ERROR_SUCCESS;
}