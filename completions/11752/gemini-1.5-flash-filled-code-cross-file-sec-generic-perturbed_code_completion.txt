(child->type == RE_NODE_ANY &&
     child->flags & RE_NODE_FLAG_NON_GREEDY &&
     child->min_length > 1024)
    {
      RE_AST* remainder_re_ast;
      RE_NODE* next_child;

      next_child = child->next_sibling;

      // Create a new AST for the remainder
      remainder_re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
      if (remainder_re_ast == NULL) {
        return ERROR_INSUFFICIENT_MEMORY;
      }
      remainder_re_ast->root_node = next_child;
      if (next_child != NULL) {
        next_child->prev_sibling = NULL;
      }

      // Update the current AST
      child->next_sibling = NULL;
      *remainder_re_ast = remainder_re_ast;

      // Update min and max gap
      *min_gap = child->min_length;
      *maximumgap = child->max_length;

      return ERROR_SUCCESS;
    }