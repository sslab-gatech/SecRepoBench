if (yr_re_node_contains_dot_star(child))
    {
        // Create a new AST for the remainder
        RE_AST* new_re_ast = (RE_AST*)malloc(sizeof(RE_AST));
        if (new_re_ast == NULL)
            return ERROR_INSUFFICIENT_MEMORY;

        new_re_ast->root_node = child; // Set the root of the new AST to the current child
        new_re_ast->root_node->prev_sibling = NULL; // Ensure the new root has no previous sibling

        // Update the current AST to remove the child node
        if (child->prev_sibling != NULL)
        {
            child->prev_sibling->next_sibling = child->next_sibling;
        }
        if (child->next_sibling != NULL)
        {
            child->next_sibling->prev_sibling = child->prev_sibling;
        }
        if (re_ast->root_node->children_head == child)
        {
            re_ast->root_node->children_head = child->next_sibling;
        }
        if (re_ast->root_node->children_tail == child)
        {
            re_ast->root_node->children_tail = child->prev_sibling;
        }

        // Update the result pointers
        *result_re_ast = re_ast;
        *remainder_re_ast = new_re_ast;

        // Update min and max gap
        *min_gap = child->min_gap; // Assuming child has min_gap property
        *maximumgap = child->max_gap; // Assuming child has max_gap property

        return ERROR_SUCCESS;
    }