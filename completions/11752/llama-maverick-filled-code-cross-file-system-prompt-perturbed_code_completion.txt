if (child->type == RE_NODE_STAR || child->type == RE_NODE_PLUS)
{
  RE_NODE* child_node = child->children_head;

  if (child_node->type == RE_NODE_ANY && !child->greedy)
  {
    int32_t low = child->repeats_low;
    int32_t high = child->repeats_high;

    if (high >= RE_SPLIT_TRESHOLD || high == INT32_MAX)
    {
      RE_AST* remainder_re_ast;

      // Create a new AST for the remainder
      FAIL_ON_ERROR(yr_re_ast_create(&remainder_re_ast));

      // Copy the nodes after the current child to the new AST
      remainder_re_ast->root_node = yr_re_node_create(RE_NODE_CONCAT);

      if (remainder_re_ast->root_node == NULL)
      {
        yr_re_ast_destroy(remainder_re_ast);
        return ERROR_INSUFFICIENT_MEMORY;
      }

      RE_NODE* remainder_concat = remainder_re_ast->root_node;

      RE_NODE* next_sibling = child->next_sibling;

      while (next_sibling != NULL)
      {
        RE_NODE* next_next_sibling = next_sibling->next_sibling;

        yr_re_node_append_child(remainder_concat, next_sibling);

        next_sibling->prev_sibling = NULL;
        next_sibling->next_sibling = NULL;

        next_sibling = next_next_sibling;
      }

      // Update the current AST to separate the nodes before the split point
      child->next_sibling = NULL;
      re_ast->root_node->children_tail = child;

      // Update the min and max gap
      *min_gap = low;
      *maximumgap = high;

      // Update the result and remainder ASTs
      *result_re_ast = re_ast;
      *remainder_re_ast = remainder_re_ast;

      return ERROR_SUCCESS;
    }
  }
}