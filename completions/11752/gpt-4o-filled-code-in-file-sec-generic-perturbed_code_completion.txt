if (child->type == RE_NODE_RANGE_ANY &&
        child->start == 0 &&
        child->end > 1000 &&
        !child->greedy)
    {
      *min_gap = child->start;
      *maximumgap = child->end;

      // Create a new AST for the remainder
      FAIL_ON_ERROR(yr_re_ast_create(remainder_re_ast));

      // Create a new root node for the remainder AST
      (*remainder_re_ast)->root_node = yr_re_node_create(RE_NODE_CONCAT);

      if ((*remainder_re_ast)->root_node == NULL)
        return ERROR_INSUFFICIENT_MEMORY;

      // Move the children after the current node to the new AST
      concat = yr_re_node_create(RE_NODE_CONCAT);

      if (concat == NULL)
        return ERROR_INSUFFICIENT_MEMORY;

      concat->children_head = child->next_sibling;
      concat->children_tail = re_ast->root_node->children_tail;

      (*remainder_re_ast)->root_node->children_head = concat;
      (*remainder_re_ast)->root_node->children_tail = concat;

      // Update the current AST to end at the current node
      re_ast->root_node->children_tail = child->prev_sibling;

      if (child->prev_sibling != NULL)
        child->prev_sibling->next_sibling = NULL;

      child->next_sibling = NULL;

      return ERROR_SUCCESS;
    }