if (child->type == RE_NODE_RANGE_ANY &&
    !child->greedy &&
    child->end >= 1000 &&
    child->next_sibling != NULL)
{
  // We found a splitting point: a non-greedy, range-any node
  // with a large repetition range. Create an AST for the 'remainder'.

  *min_gap = child->start;
  *maximumgap = child->end;

  FAIL_ON_ERROR(yr_re_ast_create(remainder_re_ast));

  (*remainder_re_ast)->root_node = yr_re_node_create(RE_NODE_CONCAT);
  if ((*remainder_re_ast)->root_node == NULL)
    return ERROR_INSUFFICIENT_MEMORY;

  // Move the nodes following 'child' into the remainder's AST.
  (*remainder_re_ast)->root_node->children_head = child->next_sibling;
  (*remainder_re_ast)->root_node->children_tail = re_ast->root_node->children_tail;
  (*remainder_re_ast)->flags = re_ast->flags;

  if (child->next_sibling != NULL)
    child->next_sibling->prev_sibling = NULL;

  // Truncate the original AST at 'child->prev_sibling'.
  re_ast->root_node->children_tail = child->prev_sibling;
  if (child->prev_sibling != NULL)
    child->prev_sibling->next_sibling = NULL;
  else
    re_ast->root_node->children_head = NULL;

  // Remove and destroy the splitting node.
  yr_re_node_destroy(child);

  return ERROR_SUCCESS;
}