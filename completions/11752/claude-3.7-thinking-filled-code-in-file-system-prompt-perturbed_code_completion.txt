if (child->type == RE_NODE_RANGE_ANY && 
    !child->greedy && 
    child->end > 100)  // Use 100 as a threshold for a "large" repetition
{
  RE_AST* remainder;
  RE_NODE* next_child = child->next_sibling;
  
  // If there are no nodes after this one, no need to split
  if (next_child == NULL)
  {
    child = child->next_sibling;
    continue;
  }
  
  // Create a new AST for the remainder
  FAIL_ON_ERROR(yr_re_ast_create(&remainder));
  
  // Create a concatenation node for the remainder
  remainder->root_node = yr_re_node_create(RE_NODE_CONCAT);
  
  if (remainder->root_node == NULL)
  {
    yr_re_ast_destroy(remainder);
    return ERROR_INSUFFICIENT_MEMORY;
  }
  
  // Add all subsequent nodes to the remainder AST
  while (next_child != NULL)
  {
    RE_NODE* temp = next_child;
    next_child = next_child->next_sibling;
    
    // Remove from original AST
    temp->prev_sibling->next_sibling = next_child;
    if (next_child != NULL)
      next_child->prev_sibling = temp->prev_sibling;
    else
      re_ast->root_node->children_tail = temp->prev_sibling;
    
    // Reset sibling pointers
    temp->prev_sibling = NULL;
    temp->next_sibling = NULL;
    
    // Add to remainder
    yr_re_node_append_child(remainder->root_node, temp);
  }
  
  // Update min_gap and max_gap with the range values
  *min_gap = child->start;
  *max_gap = child->end;
  
  // Remove the child node from the original AST
  if (child->prev_sibling != NULL)
    child->prev_sibling->next_sibling = child->next_sibling;
  else
    re_ast->root_node->children_head = child->next_sibling;
  
  if (child->next_sibling != NULL)
    child->next_sibling->prev_sibling = child->prev_sibling;
  else
    re_ast->root_node->children_tail = child->prev_sibling;
  
  // Free the range-any node as it's no longer needed
  yr_re_node_destroy(child);
  
  // Set the result ASTs
  *result_re_ast = re_ast;
  *remainder_re_ast = remainder;
  
  return ERROR_SUCCESS;
}