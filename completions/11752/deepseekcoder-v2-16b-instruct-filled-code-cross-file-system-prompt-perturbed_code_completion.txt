if (child->type == RE_NODE_RANGE &&
    child->range.min > 1000 &&
    child->range.max > 1000 &&
    (child->type == RE_NODE_STAR || child->type == RE_NODE_PLUS))
{
  RE_AST* new_ast = yr_re_ast_create();
  RE_NODE* new_root = yr_re_node_create(RE_NODE_CONCAT);
  RE_NODE* before_split = re_ast->root_node;
  RE_NODE* after_split = child;

  // Remove the child from the current AST
  if (child->prev_sibling != NULL)
    child->prev_sibling->next_sibling = child->next_sibling;
  else
    re_ast->root_node = child->next_sibling;

  if (child->next_sibling != NULL)
    child->next_sibling->prev_sibling = child->prev_sibling;

  // Create new AST for the remainder
  new_ast->root_node = after_split;

  // Update the min and max gap
  *min_gap = child->range.min;
  *maximumgap = child->range.max;

  // Update the current AST to separate the nodes before and after the point of splitting
  new_root->children_head = before_split;
  new_root->children_tail = before_split;
  while (new_root->children_tail->next_sibling != NULL)
    new_root->children_tail = new_root->children_tail->next_sibling;

  re_ast->root_node = new_root;

  // Append the new AST as a child of the current AST
  yr_re_node_append_child(re_ast->root_node, new_ast->root_node);

  *result_re_ast = re_ast;
  *remainder_re_ast = new_ast;

  return ERROR_SUCCESS;
}