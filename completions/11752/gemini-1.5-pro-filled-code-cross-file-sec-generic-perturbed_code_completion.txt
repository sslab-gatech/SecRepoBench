(child->type == RE_NODE_RANGE_ANY && child->greedy == FALSE && child->start > RE_SCAN_CHAINING_THRESHOLD)
    {
      concat = re_ast->root_node;

      *min_gap = child->start;
      *maximumgap = child->end;

      *remainder_re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));

      if (*remainder_re_ast == NULL)
        return ERROR_INSUFFICIENT_MEMORY;

      (*remainder_re_ast)->root_node = child->next_sibling;

      if ((*remainder_re_ast)->root_node != NULL)
      {
        (*remainder_re_ast)->root_node->prev_sibling = NULL;
        (*remainder_re_ast)->flags = re_ast->flags;
        (*remainder_re_ast)->flags |= RE_AST_FLAG_DOT_STAR_ANCHOR;
      }
      else
      {
        yr_free(*remainder_re_ast);
        *remainder_re_ast = NULL;
      }

      // If the current child node has a previous sibling, update the next sibling
      // pointer of the previous sibling to NULL. Otherwise, update the root node
      // of the current AST to NULL.
      if (child->prev_sibling != NULL)
        child->prev_sibling->next_sibling = NULL;
      else
        re_ast->root_node = NULL;

      concat->children_tail = child->prev_sibling;
      child->prev_sibling = NULL;
      child->next_sibling = NULL;
      yr_re_node_destroy(child);

      if (concat->children_tail != NULL)
        yr_re_ast_calculate_size(re_ast);
      else
      {
        yr_re_node_destroy(concat);
        re_ast->root_node = NULL;
      }

      return ERROR_SUCCESS;
    }