//
// yr_re_ast_split_at_chaining_point
//
// In some cases splitting a regular expression in two is more efficient that
// having a single regular expression. This happens when the regular expression
// contains a large repetition of any character, for example: /foo.{0,1000}bar/
// In this case the regexp is split in /foo/ and /bar/ where /bar/ is "chained"
// to /foo/. This means that /foo/ and /bar/ are handled as individual regexps
// and when both matches YARA verifies if the distance between the matches
// complies with the {0,1000} restriction.

// This function traverses the regexp's tree looking for nodes where the regxp
// should be split.
//

int yr_re_ast_split_at_chaining_point(
    RE_AST* re_ast,
    RE_AST** result_re_ast,
    RE_AST** remainder_re_ast,
    int32_t* min_gap,
    int32_t* maximumgap)
{
  RE_NODE* child;
  RE_NODE* concat;

  int result;

  *result_re_ast = re_ast;
  *remainder_re_ast = NULL;
  *min_gap = 0;
  *maximumgap = 0;

  if (re_ast->root_node->type!= RE_NODE_CONCAT)
    return ERROR_SUCCESS;

  child = re_ast->root_node->children_head;

  while (child!= NULL)
  {
    if (child->type == RE_NODE_RANGE)
    {
      RE_REPEAT_ARGS* repeat_args = (RE_REPEAT_ARGS*) child->value;
      if (repeat_args->max > RE_REPEAT_THRESHOLD)
      {
        // Check if the current child node is a non-greedy, range-any node with a
        // range that exceeds a specified threshold. If so, split the AST at this
        // point. Create a new AST for the remainder and update the current AST
        // to separate the nodes before and after the point of splitting.
        // Update the min and max gap with the range values of the current node.
        // Ensure the child node is properly removed, and return success after
        // successfully splitting the AST.

        RE_NODE* new_node = yr_re_node_create(RE_NODE_CONCAT);
        new_node->greedy = false;
        new_node->children_head = child->children_head;
        new_node->children_tail = child->children_tail;
        new_node->prev_sibling = NULL;
        new_node->next_sibling = NULL;

        if (child->prev_sibling!= NULL)
          child->prev_sibling->next_sibling = new_node;

        if (child->next_sibling!= NULL)
          new_node->next_sibling = child->next_sibling;

        if (child->prev_sibling == NULL)
          re_ast->root_node->children_head = new_node;

        if (child->next_sibling == NULL)
          re_ast->root_node->children_tail = new_node;

        *remainder_re_ast = yr_re_node_create(RE_NODE_CONCAT);
        *remainder_re_ast->root_node = child;
        *remainder_re_ast->root_node->prev_sibling = new_node;
        *remainder_re_ast->root_node->next_sibling = NULL;

        *min_gap = repeat_args->min;
        *maximumgap = repeat_args->max;

        return ERROR_SUCCESS;
      }
    }

    child = child->next_sibling;
  }

  return ERROR_SUCCESS;
}