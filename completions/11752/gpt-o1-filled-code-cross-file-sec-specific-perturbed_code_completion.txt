if (child->type == RE_NODE_RANGE_ANY &&
    !child->greedy &&
    child->end > SOME_THRESHOLD)
{
    RE_AST* new_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
    RE_NODE* new_root;
    RE_NODE* sibling;

    if (new_ast == NULL)
        return ERROR_INSUFFICIENT_MEMORY;

    new_root = (RE_NODE*) yr_malloc(sizeof(RE_NODE));
    if (new_root == NULL)
    {
        yr_free(new_ast);
        return ERROR_INSUFFICIENT_MEMORY;
    }

    memset(new_root, 0, sizeof(RE_NODE));
    new_root->type = RE_NODE_CONCAT;
    new_root->children_head = child->next_sibling;
    new_root->children_tail = re_ast->root_node->children_tail;
    new_root->parent = NULL;
    new_ast->root_node = new_root;

    sibling = new_root->children_head;
    while (sibling != NULL)
    {
        sibling->parent = new_root;
        if (sibling->next_sibling == NULL)
            break;
        sibling = sibling->next_sibling;
    }
    new_root->children_tail = sibling;

    re_ast->root_node->children_tail = child->prev_sibling;
    if (child->prev_sibling != NULL)
        child->prev_sibling->next_sibling = NULL;
    else
        re_ast->root_node->children_head = NULL;

    *remainder_re_ast = new_ast;
    *min_gap = child->start;
    *maximumgap = (child->end == RE_INFINITY) ? INT32_MAX : child->end;

    child->prev_sibling = NULL;
    child->next_sibling = NULL;
    yr_re_node_destroy(child);

    return ERROR_SUCCESS;
}