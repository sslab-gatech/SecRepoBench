if (child->type == RE_NODE_RANGE && 
        child->is_non_greedy && 
        child->range_max > SOME_THRESHOLD) // Replace SOME_THRESHOLD with the actual threshold value
    {
        // Create a new AST for the remainder
        RE_AST* new_re_ast = (RE_AST*)malloc(sizeof(RE_AST));
        if (new_re_ast == NULL) {
            return ERROR_INSUFFICIENT_MEMORY; // Handle memory allocation failure
        }

        new_re_ast->root_node = child; // Set the new AST's root to the current child
        new_re_ast->root_node->prev_sibling = NULL; // Ensure the new root has no previous sibling

        // Update the current AST to remove the child node
        if (child->prev_sibling != NULL) {
            child->prev_sibling->next_sibling = child->next_sibling;
        }
        if (child->next_sibling != NULL) {
            child->next_sibling->prev_sibling = child->prev_sibling;
        }
        if (re_ast->root_node->children_head == child) {
            re_ast->root_node->children_head = child->next_sibling;
        }
        if (re_ast->root_node->children_tail == child) {
            re_ast->root_node->children_tail = child->prev_sibling;
        }

        // Update min and max gap
        *min_gap = child->range_min; // Assuming range_min is defined in the child node
        *maximumgap = child->range_max; // Assuming range_max is defined in the child node

        // Set the result pointers
        *result_re_ast = re_ast;
        *remainder_re_ast = new_re_ast;

        return ERROR_SUCCESS; // Successfully split the AST
    }