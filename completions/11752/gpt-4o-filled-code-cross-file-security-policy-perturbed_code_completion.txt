(child->type == RE_NODE_RANGE_ANY && child->greedy == false && child->range.max > SOME_THRESHOLD)
    {
      // Create a new AST for the remainder
      *remainder_re_ast = yr_re_ast_create();
      if (*remainder_re_ast == NULL)
        return ERROR_INSUFFICIENT_MEMORY;

      // Set the root node of the new AST
      (*remainder_re_ast)->root_node = yr_re_node_create(RE_NODE_CONCAT);
      if ((*remainder_re_ast)->root_node == NULL)
      {
        yr_re_ast_destroy(*remainder_re_ast);
        *remainder_re_ast = NULL;
        return ERROR_INSUFFICIENT_MEMORY;
      }

      // Update the min and max gap
      *min_gap = child->range.min;
      *maximumgap = child->range.max;

      // Remove the child node from the current AST
      if (child->prev_sibling != NULL)
        child->prev_sibling->next_sibling = child->next_sibling;
      else
        re_ast->root_node->children_head = child->next_sibling;

      if (child->next_sibling != NULL)
        child->next_sibling->prev_sibling = child->prev_sibling;
      else
        re_ast->root_node->children_tail = child->prev_sibling;

      // Append the remaining nodes to the new AST
      while (child != NULL)
      {
        RE_NODE* next_child = child->next_sibling;
        yr_re_node_append_child((*remainder_re_ast)->root_node, child);
        child = next_child;
      }

      return ERROR_SUCCESS;
    }