(child->type == RE_NODE_RANGE_ANY &&
        !child->greedy &&
        child->range_max > YR_MAX_CHAINING_GAP)
    {
      // Create the new AST for the remainder of the expression.
      *remainder_re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
      if (*remainder_re_ast == NULL)
        return ERROR_INSUFFICIENT_MEMORY;

      (*remainder_re_ast)->root_node = re_node_clone(child);
      (*remainder_re_ast)->flags = re_ast->flags;

      // Update the gap values.
      *min_gap = child->range_min;
      *maximumgap = child->range_max;

      // Remove the child from the original AST.
      if (child->prev_sibling != NULL)
        child->prev_sibling->next_sibling = child->next_sibling;
      else
        re_ast->root_node->children_head = child->next_sibling;

      if (child->next_sibling != NULL)
        child->next_sibling->prev_sibling = child->prev_sibling;
      else
        re_ast->root_node->children_tail = child->prev_sibling;

      // Free the node, as it's now part of the new AST.
      yr_free(child);

      // The original AST now ends at the splitting point, so we need to
      // terminate the concatenation.
      if (re_ast->root_node->children_tail != NULL)
        re_ast->root_node->children_tail->next_sibling = NULL;

      result = ERROR_SUCCESS;
      return result;
    }