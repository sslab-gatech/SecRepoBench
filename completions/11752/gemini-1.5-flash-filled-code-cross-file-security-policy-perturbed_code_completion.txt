{
      if (child->type == RE_NODE_RANGE_ANY &&
          child->flags & RE_FLAG_NON_GREEDY &&
          child->range_max > 1024)
      {
        RE_AST* remainder_ast;
        RE_NODE* next = child->next_sibling;

        // Create a new AST for the remainder
        remainder_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
        if (!remainder_ast) return ERROR_INSUFFICIENT_MEMORY;
        remainder_ast->root_node = next;
        if (next) {
          next->prev_sibling = NULL;
        }

        // Update the current AST
        if (child->prev_sibling) {
          child->prev_sibling->next_sibling = NULL;
        } else {
          re_ast->root_node->children_head = NULL;
        }
        re_ast->root_node->children_tail = child->prev_sibling;
        child->prev_sibling = NULL;
        child->next_sibling = NULL;

        *remainder_re_ast = remainder_ast;
        *min_gap = child->range_min;
        *maximumgap = child->range_max;

        //Remove child node
        yr_re_node_destroy(child);

        return ERROR_SUCCESS;
      }
    }