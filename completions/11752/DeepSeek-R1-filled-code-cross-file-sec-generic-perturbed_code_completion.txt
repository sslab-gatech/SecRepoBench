if (child->type == RE_NODE_RANGE_ANY && !child->greedy)
{
    RE_NODE* prev_child = child->prev_sibling;
    RE_NODE* original_tail = re_ast->root_node->children_tail;

    if (prev_child != NULL)
    {
        prev_child->next_sibling = NULL;
        re_ast->root_node->children_tail = prev_child;
    }
    else
    {
        re_ast->root_node->children_head = NULL;
        re_ast->root_node->children_tail = NULL;
    }

    RE_NODE* remainder_concat = yr_re_node_create(RE_NODE_CONCAT);
    if (remainder_concat == NULL)
        return ERROR_INSUFFICIENT_MEMORY;

    remainder_concat->children_head = child;
    remainder_concat->children_tail = original_tail;

    RE_NODE* current = child;
    RE_NODE* prev = NULL;
    while (current != NULL)
    {
        current->prev_sibling = prev;
        prev = current;
        current = current->next_sibling;
    }

    *remainder_re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
    if (*remainder_re_ast == NULL)
    {
        yr_re_node_destroy(remainder_concat);
        return ERROR_INSUFFICIENT_MEMORY;
    }

    (*remainder_re_ast)->root_node = remainder_concat;

    *min_gap = child->start;
    *maximumgap = child->end;

    return ERROR_SUCCESS;
}