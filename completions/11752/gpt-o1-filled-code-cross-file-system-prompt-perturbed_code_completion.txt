if ((child->type == RE_NODE_STAR || child->type == RE_NODE_PLUS) &&
    child->children_head != NULL &&
    child->children_head->type == RE_NODE_ANY &&
    !child->greedy)
{
    // Use 0 as min_gap for RE_NODE_STAR and 1 for RE_NODE_PLUS.
    *min_gap = (child->type == RE_NODE_PLUS) ? 1 : 0;
    // Set maximumgap to something that indicates an unbounded match
    // (e.g. RE_QUANTIFIER_INFINITE if defined).
    *maximumgap = RE_QUANTIFIER_INFINITE;

    // Allocate and initialize a new AST for the remainder.
    *remainder_re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
    if (*remainder_re_ast == NULL)
      return ERROR_INSUFFICIENT_MEMORY;

    (*remainder_re_ast)->root_node = (RE_NODE*) yr_malloc(sizeof(RE_NODE));
    if ((*remainder_re_ast)->root_node == NULL)
    {
      yr_free(*remainder_re_ast);
      *remainder_re_ast = NULL;
      return ERROR_INSUFFICIENT_MEMORY;
    }

    // Set up the remainder AST's root node as a RE_NODE_CONCAT.
    (*remainder_re_ast)->root_node->type = RE_NODE_CONCAT;
    (*remainder_re_ast)->root_node->children_head = child->next_sibling;
    (*remainder_re_ast)->root_node->children_tail = re_ast->root_node->children_tail;
    (*remainder_re_ast)->root_node->prev_sibling = NULL;
    (*remainder_re_ast)->root_node->next_sibling = NULL;
    (*remainder_re_ast)->root_node->quantifier.min = 1;
    (*remainder_re_ast)->root_node->quantifier.max = 1;
    (*remainder_re_ast)->root_node->greedy = true;
    (*remainder_re_ast)->flags = 0;
    (*remainder_re_ast)->error = ERROR_SUCCESS;

    // Detach child->next_sibling from the original AST.
    if (child->next_sibling != NULL)
      child->next_sibling->prev_sibling = NULL;

    // Fix the tail of the original AST so it ends at child->prev_sibling.
    re_ast->root_node->children_tail = child->prev_sibling;
    if (child->prev_sibling != NULL)
      child->prev_sibling->next_sibling = NULL;
    else
      // If there's no prev_sibling, that means child was the first and only node
      // in the original AST's concat list, so it becomes empty after removal.
      re_ast->root_node->children_head = NULL;

    // Destroy the splitting node itself.
    yr_re_node_destroy(child);

    return ERROR_SUCCESS;
}