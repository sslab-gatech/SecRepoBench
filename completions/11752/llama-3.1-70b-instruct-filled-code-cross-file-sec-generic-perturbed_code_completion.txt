if (child->type == RE_NODE_RANGE_ANY &&
    child->range_any.greedy == false &&
    child->range_any.max > MAX_GAP_THRESHOLD)
{
  RE_NODE* new_root_node;
  RE_AST* new_re_ast;

  FAIL_ON_ERROR(yr_arena_allocate_struct(
      re_ast->arena,
      sizeof(RE_NODE),
      (void**) &new_root_node,
      offsetof(RE_NODE, type),
      offsetof(RE_NODE, children_head),
      offsetof(RE_NODE, children_tail),
      EOL));

  new_root_node->type = RE_NODE_CONCAT;
  new_root_node->children_head = child->next_sibling;
  new_root_node->children_tail = re_ast->root_node->children_tail;

  if (new_root_node->children_head!= NULL)
    new_root_node->children_head->prev_sibling = NULL;

  re_ast->root_node->children_tail = child;
  child->next_sibling = NULL;

  FAIL_ON_ERROR(yr_arena_allocate_struct(
      re_ast->arena,
      sizeof(RE_AST),
      (void**) &new_re_ast,
      offsetof(RE_AST, root_node),
      offsetof(RE_AST, arena),
      EOL));

  new_re_ast->root_node = new_root_node;
  new_re_ast->arena = re_ast->arena;

  *remainder_re_ast = new_re_ast;
  *result_re_ast = re_ast;
  *min_gap = child->range_any.min;
  *maximumgap = child->range_any.max;

  return ERROR_SUCCESS;
}