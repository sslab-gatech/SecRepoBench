// <MASK>
FAIL_ON_ERROR(_yr_re_emit(
    &emit_context,
    re_node->children_head,
    flags,
    NULL,
    &branch_size));

*code_size += branch_size;

if (re_node->greedy)
{
  FAIL_ON_ERROR(_yr_emit_inst_arg_uint16(
      &emit_context,
      RE_OPCODE_REPEAT_ANY_GREEDY,
      repeat_args.min,
      NULL,
      NULL,
      &inst_size));

  *code_size += inst_size;
}
else
{
  FAIL_ON_ERROR(_yr_emit_inst_arg_uint16(
      &emit_context,
      RE_OPCODE_REPEAT_ANY_UNGREEDY,
      repeat_args.min,
      NULL,
      NULL,
      &inst_size));

  *code_size += inst_size;
}

FAIL_ON_ERROR(_yr_emit_inst_arg_uint16(
    &emit_context,
    RE_OPCODE_JUMP,
    -((uint16_t) branch_size),
    NULL,
    NULL,
    &jmp_size));

*code_size += jmp_size;

if (branch_size + inst_size + jmp_size >= INT16_MAX)
  return ERROR_REGULAR_EXPRESSION_TOO_LARGE;

// Update repeat_args.offset.
repeat_args.offset = -((int32_t) (branch_size + inst_size + jmp_size));

// Update jmp_offset_addr.
*jmp_offset_addr = (int16_t) (branch_size + inst_size + jmp_size);