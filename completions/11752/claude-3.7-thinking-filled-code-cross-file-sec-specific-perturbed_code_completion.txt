(child->type == RE_NODE_RANGE_ANY &&
 !child->greedy &&
 child->start > YR_RE_CHAINING_THRESHOLD)
{
    // Create a new AST for the remainder
    *remainder_re_ast = yr_malloc(sizeof(RE_AST));
    
    if (*remainder_re_ast == NULL)
        return ERROR_INSUFFICIENT_MEMORY;
    
    // Initialize the new AST
    (*remainder_re_ast)->flags = re_ast->flags;
    
    // Create a concat node for the new AST
    concat = yr_malloc(sizeof(RE_NODE));
    
    if (concat == NULL)
    {
        yr_free(*remainder_re_ast);
        *remainder_re_ast = NULL;
        return ERROR_INSUFFICIENT_MEMORY;
    }
    
    // Initialize the concat node
    concat->type = RE_NODE_CONCAT;
    concat->children_head = NULL;
    concat->children_tail = NULL;
    concat->prev_sibling = NULL;
    concat->next_sibling = NULL;
    
    (*remainder_re_ast)->root_node = concat;
    
    // Update min and max gap values
    *min_gap = child->start;
    *maximumgap = child->end;
    
    // Move all siblings after the chaining node to the new AST
    if (child->next_sibling != NULL)
    {
        // Detach from original AST and move to new AST
        concat->children_head = child->next_sibling;
        child->next_sibling->prev_sibling = NULL;
        
        // Find the last sibling for the new AST
        RE_NODE* last = child->next_sibling;
        while (last->next_sibling != NULL)
            last = last->next_sibling;
        
        concat->children_tail = last;
        
        // Detach from original AST
        child->next_sibling = NULL;
    }
    
    // Update the original AST's tail
    re_ast->root_node->children_tail = child;
    
    return ERROR_SUCCESS;
}