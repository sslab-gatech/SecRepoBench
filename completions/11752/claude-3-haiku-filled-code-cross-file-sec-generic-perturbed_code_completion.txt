// Check if the current child node is a non-greedy, range-any node with a
// range that exceeds a specified threshold. If so, split the AST at this
// point. Create a new AST for the remainder and update the current AST
// to separate the nodes before and after the point of splitting.
// Update the min and max gap with the range values of the current node.
// Ensure the child node is properly removed, and return success after
// successfully splitting the AST.
if (child->type == RE_NODE_RANGE && child->greedy == false && child->start > 100)
{
    // Create a new AST for the remainder
    RE_AST* remainder_ast = (RE_AST*)yr_malloc(sizeof(RE_AST));
    remainder_ast->root_node = child;

    // Update the current AST to separate the nodes before and after the point of splitting
    if (child->prev_sibling != NULL)
        child->prev_sibling->next_sibling = NULL;
    re_ast->root_node->children_head = child;
    re_ast->root_node->children_tail = child;

    // Update the min and max gap with the range values of the current node
    *min_gap = child->start;
    *maximumgap = child->end;

    // Remove the child node from the current AST
    yr_re_node_destroy(child);

    // Update the result and remainder ASTs
    *result_re_ast = re_ast;
    *remainder_re_ast = remainder_ast;

    return ERROR_SUCCESS;
}