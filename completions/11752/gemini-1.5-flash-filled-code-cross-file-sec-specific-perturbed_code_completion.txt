(child->flags & RE_NODE_FLAG_NON_GREEDY) &&
        (child->type == RE_NODE_RANGE_ANY) &&
        (child->range.max - child->range.min) > 1024)
    {
      RE_AST* remainder_ast;
      RE_NODE* next_child;

      // Create a new AST for the remainder of the nodes.
      remainder_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
      if (remainder_ast == NULL)
        return ERROR_INSUFFICIENT_MEMORY;
      remainder_ast->root_node = NULL;

      // Remove the current child node from the original AST.
      next_child = child->next_sibling;
      if (child->prev_sibling != NULL)
        child->prev_sibling->next_sibling = next_child;
      else
        re_ast->root_node->children_head = next_child;
      if (next_child != NULL)
        next_child->prev_sibling = child->prev_sibling;
      else
        re_ast->root_node->children_tail = child->prev_sibling;

      // Append the remaining nodes to the remainder AST.
      if (next_child != NULL) {
        remainder_ast->root_node = next_child;
        remainder_ast->root_node->prev_sibling = NULL;
      }

      // Update the min and max gap.
      *min_gap = child->range.min;
      *maximumgap = child->range.max;

      // Set the result and remainder ASTs.
      *remainder_re_ast = remainder_ast;
      (*result_re_ast)->root_node->children_tail = child->prev_sibling;
      if ((*result_re_ast)->root_node->children_tail == NULL)
          (*result_re_ast)->root_node->children_head = NULL;

      // Free the child node.
      yr_re_node_destroy(child);

      return ERROR_SUCCESS;
    }