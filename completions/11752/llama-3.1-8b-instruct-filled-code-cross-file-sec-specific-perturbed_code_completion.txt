// Check if the current child node is a non-greedy, range-any node with a
// range that exceeds a specified threshold. If so, split the AST at this
// point. Create a new AST for the remainder and update the current AST
// to separate the nodes before and after the point of splitting.
// Update the min and max gap with the range values of the current node.
// Ensure the child node is properly removed, and return success after
// successfully splitting the AST.
if (child->type == RE_NODE_RANGE_ANY && child->range->min > 0)
{
  RE_AST* new_re_ast;
  RE_AST* new_remainder_re_ast;
  int32_t new_min_gap;
  int32_t new_max_gap;

  if (yr_re_ast_split_at_chaining_point(
        child,
        &new_re_ast,
        &new_remainder_re_ast,
        &new_min_gap,
        &new_max_gap)!= ERROR_SUCCESS)
  {
    return ERROR_FAILURE;
  }

  *result_re_ast = new_re_ast;
  *remainder_re_ast = new_remainder_re_ast;
  *min_gap = new_min_gap;
  *maximumgap = new_max_gap;

  // Remove the child node from the current AST
  if (child->prev_sibling!= NULL)
    child->prev_sibling->next_sibling = child->next_sibling;
  else
    re_ast->root_node->children_head = child->next_sibling;

  if (child->next_sibling!= NULL)
    child->next_sibling->prev_sibling = child->prev_sibling;
  else
    re_ast->root_node->children_tail = child->prev_sibling;

  yr_re_node_destroy(child);
  yr_re_ast_destroy(new_remainder_re_ast);

  return ERROR_SUCCESS;
}