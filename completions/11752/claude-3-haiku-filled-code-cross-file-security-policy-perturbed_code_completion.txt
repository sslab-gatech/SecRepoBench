// Check if the current child node is a non-greedy, range-any node with a
// range that exceeds a specified threshold. If so, split the AST at this
// point. Create a new AST for the remainder and update the current AST
// to separate the nodes before and after the point of splitting.
// Update the min and max gap with the range values of the current node.
// Ensure the child node is properly removed, and return success after
// successfully splitting the AST.
if (child->type == RE_NODE_RANGE && child->greedy == false && child->start > *maximumgap)
{
    RE_AST* new_re_ast = (RE_AST*)yr_malloc(sizeof(RE_AST));
    new_re_ast->root_node = child->next_sibling;

    if (child->prev_sibling != NULL)
        child->prev_sibling->next_sibling = NULL;
    else
        re_ast->root_node->children_head = child->next_sibling;

    if (child->next_sibling != NULL)
        child->next_sibling->prev_sibling = child->prev_sibling;
    else
        re_ast->root_node->children_tail = child->prev_sibling;

    *result_re_ast = re_ast;
    *remainder_re_ast = new_re_ast;
    *min_gap = child->start;
    *maximumgap = child->end;
    yr_re_node_destroy(child);
    return ERROR_SUCCESS;
}