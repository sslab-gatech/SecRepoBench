if (child->type == RE_NODE_RANGE_ANY && 
    !child->greedy && 
    child->start > YR_RE_CHAINING_THRESHOLD)
{
  // Create a new AST for the remainder
  *remainder_re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
  
  if (*remainder_re_ast == NULL)
    return ERROR_INSUFFICIENT_MEMORY;
  
  // Initialize the remainder AST
  (*remainder_re_ast)->root_node = NULL;
  
  // Create a concatenation node for the remainder AST
  result = yr_re_node_create(RE_NODE_CONCAT, &concat);
  
  if (result != ERROR_SUCCESS)
  {
    yr_free(*remainder_re_ast);
    *remainder_re_ast = NULL;
    return result;
  }
  
  (*remainder_re_ast)->root_node = concat;
  
  // Set min_gap and maximumgap based on the range values of the child node
  *min_gap = child->start;
  *maximumgap = child->end;
  
  // Move all subsequent siblings of child to the remainder AST
  RE_NODE* sibling = child->next_sibling;
  
  if (sibling != NULL)
  {
    // Detach the siblings from the original AST
    if (child->prev_sibling != NULL)
      child->prev_sibling->next_sibling = NULL;
    else
      re_ast->root_node->children_head = NULL;
    
    re_ast->root_node->children_tail = child->prev_sibling;
    
    // Attach them to the remainder AST
    concat->children_head = sibling;
    sibling->prev_sibling = NULL;
    
    RE_NODE* last_sibling = sibling;
    while (last_sibling->next_sibling != NULL)
      last_sibling = last_sibling->next_sibling;
    
    concat->children_tail = last_sibling;
  }
  
  // Free the child node
  yr_re_node_destroy(child);
  
  return ERROR_SUCCESS;
}