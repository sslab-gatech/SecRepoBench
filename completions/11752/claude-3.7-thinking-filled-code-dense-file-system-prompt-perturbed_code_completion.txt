if (child->type == RE_NODE_RANGE_ANY &&
    child->greedy == 0 &&
    (child->start > 0 || child->end > YR_STRING_CHAINING_THRESHOLD))
{
  RE_NODE* next_child = child->next_sibling;
  
  // Create a new AST for the remainder
  result = yr_re_ast_create(remainder_re_ast);
  if (result != ERROR_SUCCESS)
    return result;
  
  // Create a new concatenation node for the remainder AST
  concat = (RE_NODE*) yr_malloc(sizeof(RE_NODE));
  if (concat == NULL)
  {
    yr_re_ast_destroy(*remainder_re_ast);
    *remainder_re_ast = NULL;
    return ERROR_INSUFFICIENT_MEMORY;
  }
  
  // Initialize the concatenation node
  concat->type = RE_NODE_CONCAT;
  concat->children_head = next_child;
  concat->children_tail = re_ast->root_node->children_tail;
  concat->prev_sibling = NULL;
  concat->next_sibling = NULL;
  
  (*remainder_re_ast)->root_node = concat;
  
  // If there are nodes to move to the remainder
  if (next_child != NULL)
  {
    next_child->prev_sibling = NULL;  // Detach from original AST
  }
  
  // Update the original AST to remove the chaining node and subsequent siblings
  if (child->prev_sibling != NULL)
  {
    child->prev_sibling->next_sibling = NULL;
    re_ast->root_node->children_tail = child->prev_sibling;
  }
  else
  {
    // If the chaining node is the first child, the original concatenation becomes empty
    re_ast->root_node->children_head = NULL;
    re_ast->root_node->children_tail = NULL;
  }
  
  // Update the gap values from the chaining node
  *min_gap = child->start;
  *maximumgap = child->end;
  
  return ERROR_SUCCESS;
}