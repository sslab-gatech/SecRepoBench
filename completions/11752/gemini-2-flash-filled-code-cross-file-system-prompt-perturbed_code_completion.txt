(child->type == RE_NODE_RANGE_ANY &&
        !child->greedy &&
        child->range.max > YR_MAX_GAP_LENGTH)
    {
      RE_NODE* new_concat;
      RE_AST* new_re_ast;

      // Create a new AST for the remainder of the expression.
      new_re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));

      if (new_re_ast == NULL)
        return ERROR_INSUFFICIENT_MEMORY;

      new_concat = yr_re_node_create(RE_NODE_CONCAT);

      if (new_concat == NULL)
      {
        yr_free(new_re_ast);
        return ERROR_INSUFFICIENT_MEMORY;
      }

      new_re_ast->root_node = new_concat;

      // Move all children after the current child to the new AST.
      while (child->next_sibling != NULL)
      {
        RE_NODE* next_child = child->next_sibling;

        // Remove next_child from the original AST.
        child->next_sibling = next_child->next_sibling;
        if (next_child->next_sibling != NULL)
          next_child->next_sibling->prev_sibling = child;
        else
          re_ast->root_node->children_tail = child;

        next_child->next_sibling = NULL;
        next_child->prev_sibling = NULL;

        yr_re_node_append_child(new_concat, next_child);
      }

      *remainder_re_ast = new_re_ast;

      // Update the range values for the gap.
      *min_gap = child->range.min;
      *maximumgap = child->range.max;

      // Remove the child from the original AST.
      if (child->prev_sibling != NULL)
        child->prev_sibling->next_sibling = NULL;
      else
        re_ast->root_node->children_head = NULL;

      re_ast->root_node->children_tail = child->prev_sibling;

      child->prev_sibling = NULL;

      yr_re_node_destroy(child);

      return ERROR_SUCCESS;
    }