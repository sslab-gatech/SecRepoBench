if (child->type == RE_NODE_RANGE_ANY &&
    !child->greedy &&
    child->start < child->end)
{
  *min_gap = child->start;
  *maximumgap = child->end;

  // Create a new AST for the remainder
  result = yr_re_ast_create(remainder_re_ast);
  if (result != ERROR_SUCCESS)
    return result;

  concat = (RE_NODE*) yr_malloc(sizeof(RE_NODE));
  if (concat == NULL)
    return ERROR_INSUFFICIENT_MEMORY;

  memset(concat, 0, sizeof(RE_NODE));
  concat->type = RE_NODE_CONCAT;
  (*remainder_re_ast)->root_node = concat;

  // Move all siblings after this node to the new AST
  concat->children_head = child->next_sibling;
  concat->children_tail = re_ast->root_node->children_tail;

  if (concat->children_head != NULL)
    concat->children_head->prev_sibling = NULL;

  re_ast->root_node->children_tail = child;
  child->next_sibling = NULL;

  return ERROR_SUCCESS;
}