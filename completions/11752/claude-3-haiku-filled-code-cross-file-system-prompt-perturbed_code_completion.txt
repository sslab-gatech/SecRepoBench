// Check if the current child node is a non-greedy, range-any node with a
// range that exceeds a specified threshold. If so, split the AST at this
// point. Create a new AST for the remainder and update the current AST
// to separate the nodes before and after the point of splitting.
// Update the min and max gap with the range values of the current node.
// Ensure the child node is properly removed, and return success after
// successfully splitting the AST.
if (child->type == RE_NODE_RANGE && child->greedy == false && child->start > 0)
{
    RE_AST* new_re_ast = (RE_AST*)yr_malloc(sizeof(RE_AST));
    new_re_ast->root_node = NULL;

    // Create a new AST for the remainder
    RE_NODE* new_root = (RE_NODE*)yr_malloc(sizeof(RE_NODE));
    new_root->type = RE_NODE_CONCAT;
    new_root->children_head = child->next_sibling;
    new_root->children_tail = re_ast->root_node->children_tail;
    new_re_ast->root_node = new_root;

    // Update the current AST to separate the nodes before and after the point of splitting
    re_ast->root_node->children_tail = child->prev_sibling;
    if (child->prev_sibling != NULL)
        child->prev_sibling->next_sibling = NULL;
    else
        re_ast->root_node->children_head = NULL;

    // Update the min and max gap with the range values of the current node
    *min_gap = child->start;
    *maximumgap = child->end;

    // Remove the child node
    yr_re_node_destroy(child);

    // Return the new AST and the remainder AST
    *result_re_ast = re_ast;
    *remainder_re_ast = new_re_ast;
    return ERROR_SUCCESS;
}