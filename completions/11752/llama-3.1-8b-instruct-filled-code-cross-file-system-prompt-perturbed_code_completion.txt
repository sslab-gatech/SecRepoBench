if (re_ast->root_node->type == RE_NODE_CONCAT)
{
  child = re_ast->root_node->children_head;

  while (child!= NULL)
  {
    if (child->type == RE_NODE_RANGE_ANY && child->range->max > MAX_THRESHOLD)
    {
      RE_NODE* new_root = NULL;
      RE_NODE* new_tail = NULL;
      RE_NODE* new_head = NULL;

      if (child->prev_sibling!= NULL)
      {
        new_root = child->prev_sibling;
        new_tail = new_root->children_tail;
        new_head = new_root->children_head;
      }
      else
      {
        new_root = re_ast->root_node;
        new_tail = new_root->children_tail;
        new_head = new_root->children_head;
      }

      if (child->next_sibling!= NULL)
      {
        RE_NODE* next_child = child->next_sibling;
        next_child->prev_sibling = NULL;
        new_tail->next_sibling = next_child;
      }
      else
      {
        new_tail->next_sibling = NULL;
      }

      if (new_head == child)
      {
        new_head = child->next_sibling;
      }

      *result_re_ast = re_ast;
      *remainder_re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
      (*remainder_re_ast)->root_node = new_root;
      (*remainder_re_ast)->root_node->children_head = new_head;
      (*remainder_re_ast)->root_node->children_tail = new_tail;

      *min_gap = child->range->min;
      *maximumgap = child->range->max;

      return ERROR_SUCCESS;
    }

    child = child->next_sibling;
  }
}