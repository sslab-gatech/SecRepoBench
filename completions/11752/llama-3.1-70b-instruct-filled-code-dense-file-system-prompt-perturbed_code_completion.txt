if (child->type == RE_NODE_RANGE_ANY &&
    child->greedy == false &&
    child->start > MAX_GAP_THRESHOLD)
{
  RE_AST* new_re_ast;
  RE_NODE* new_concat;

  FAIL_ON_ERROR(yr_re_ast_create(&new_re_ast));

  new_concat = (RE_NODE*) yr_malloc(sizeof(RE_NODE));
  FAIL_ON_NULL(new_concat);

  new_concat->type = RE_NODE_CONCAT;
  new_concat->children_head = child->next_sibling;
  new_concat->children_tail = re_ast->root_node->children_tail;

  new_re_ast->root_node = new_concat;

  re_ast->root_node->children_tail = child->prev_sibling;
  if (re_ast->root_node->children_tail!= NULL)
    re_ast->root_node->children_tail->next_sibling = NULL;
  else
    re_ast->root_node->children_head = NULL;

  *remainder_re_ast = new_re_ast;
  *min_gap = child->start;
  *maximumgap = child->end;

  yr_free(child);

  return ERROR_SUCCESS;
}