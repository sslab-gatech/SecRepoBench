{
    if (child->type == RE_NODE_RANGE &&
        child->children_head->type == RE_NODE_ANY &&
        !child->greedy &&
        ((RE_NODE_RANGE*)child)->from > MAX_THRESHOLD)
    {
        RE_AST* new_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
        if (new_ast == NULL)
            return ERROR_INSUFFICIENT_MEMORY;

        new_ast->root_node = child->next_sibling;
        child->next_sibling = NULL;

        *remainder_re_ast = new_ast;

        *min_gap = ((RE_NODE_RANGE*)child)->from;
        *maximumgap = ((RE_NODE_RANGE*)child)->to;

        yr_re_node_destroy(child);
        return ERROR_SUCCESS;
    }
}