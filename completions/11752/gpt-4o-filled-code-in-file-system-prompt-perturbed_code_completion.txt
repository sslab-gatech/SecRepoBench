if (child->type == RE_NODE_RANGE_ANY &&
        child->start == 0 &&
        child->greedy == false &&
        child->end > YR_RE_FAST_HEURISTIC_THRESHOLD)
    {
      *result_re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
      *remainder_re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));

      if (*result_re_ast == NULL || *remainder_re_ast == NULL)
      {
        yr_free(*result_re_ast);
        yr_free(*remainder_re_ast);
        return ERROR_INSUFFICIENT_MEMORY;
      }

      (*result_re_ast)->flags = re_ast->flags;
      (*result_re_ast)->root_node = yr_re_node_create(RE_NODE_CONCAT);

      if ((*result_re_ast)->root_node == NULL)
      {
        yr_free(*result_re_ast);
        yr_free(*remainder_re_ast);
        return ERROR_INSUFFICIENT_MEMORY;
      }

      (*remainder_re_ast)->flags = re_ast->flags;
      (*remainder_re_ast)->root_node = yr_re_node_create(RE_NODE_CONCAT);

      if ((*remainder_re_ast)->root_node == NULL)
      {
        yr_re_ast_destroy(*result_re_ast);
        yr_free(*remainder_re_ast);
        return ERROR_INSUFFICIENT_MEMORY;
      }

      concat = (*result_re_ast)->root_node;
      concat->children_head = re_ast->root_node->children_head;
      concat->children_tail = child->prev_sibling;

      if (concat->children_tail != NULL)
        concat->children_tail->next_sibling = NULL;

      concat = (*remainder_re_ast)->root_node;
      concat->children_head = child->next_sibling;
      concat->children_tail = re_ast->root_node->children_tail;

      if (concat->children_head != NULL)
        concat->children_head->prev_sibling = NULL;

      *min_gap = 0;
      *maximumgap = child->end;

      yr_re_node_destroy(child);
      return ERROR_SUCCESS;
    }