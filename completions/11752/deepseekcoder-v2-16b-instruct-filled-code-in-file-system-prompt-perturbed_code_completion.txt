match = !match;

          action = match ? ACTION_NONE : ACTION_KILL;
          fiber->ip += 1;
          break;

        case RE_OPCODE_DIGIT:
          prolog;
          match = isdigit(*input);
          action = match ? ACTION_NONE : ACTION_KILL;
          fiber->ip += 1;
          break;

        case RE_OPCODE_NON_DIGIT:
          prolog;
          match = !isdigit(*input);
          action = match ? ACTION_NONE : ACTION_KILL;
          fiber->ip += 1;
          break;

        case RE_OPCODE_WORD_BOUNDARY:
          prolog;
          match = _yr_re_is_word_char(input, character_size) &&
                  (!_yr_re_is_word_char(input - character_size, character_size));
          action = match ? ACTION_NONE : ACTION_KILL;
          fiber->ip += 1;
          break;

        case RE_OPCODE_NON_WORD_BOUNDARY:
          prolog;
          match = !_yr_re_is_word_char(input, character_size) &&
                  (_yr_re_is_word_char(input - character_size, character_size));
          action = match ? ACTION_NONE : ACTION_KILL;
          fiber->ip += 1;
          break;

        case RE_OPCODE_MATCH_AT_START:
          prolog;
          match = (input == input_data);
          action = match ? ACTION_NONE : ACTION_KILL;
          fiber->ip += 1;
          break;

        case RE_OPCODE_MATCH_AT_END:
          prolog;
          match = (input + bytes_matched == input_data + max_bytes_matched);
          action = match ? ACTION_NONE : ACTION_KILL;
          fiber->ip += 1;
          break;

        case RE_OPCODE_MATCH:
          prolog;
          match = (input + bytes_matched == input_data + max_bytes_matched);
          action = match ? ACTION_CONTINUE : ACTION_KILL;
          fiber->ip += 1;
          break;

        case RE_OPCODE_SPLIT_A:
        case RE_OPCODE_SPLIT_B:
          prolog;
          action = ACTION_CONTINUE;
          break;

        case RE_OPCODE_JUMP:
          fiber->ip += *(int16_t*)(fiber->ip + 1);
          break;

        default:
          return ERROR_INVALID_REGULAR_EXPRESSION;
      }

      if (action == ACTION_CONTINUE)
      {
        if (flags & RE_FLAGS_BACKWARDS)
        {
          if (input + input_incr >= input_data)
          {
            input += input_incr;
            bytes_matched++;
          }
          else
          {
            action = ACTION_KILL;
          }
        }
        else
        {
          if (input + input_incr <= input_data + max_bytes_matched)
          {
            input += input_incr;
            bytes_matched++;
          }
          else
          {
            action = ACTION_KILL;
          }
        }
      }

      if (action == ACTION_KILL)
      {
        _yr_re_fiber_kill(&fibers, &context->re_fiber_pool, fiber);
      }
      else if (action == ACTION_KILL_TAIL)
      {
        _yr_re_fiber_kill_tail(&fibers, &context->re_fiber_pool, fiber);
      }
    }

    if (matches != NULL)
      *matches = bytes_matched;

    if (flags & RE_FLAGS_EXHAUSTIVE)
    {
      if (fibers.head == NULL)
        break;
    }
    else
    {
      if (fibers.head == NULL || (flags & RE_FLAGS_BACKWARDS && input == input_data) ||
          (!(flags & RE_FLAGS_BACKWARDS) && input + input_incr == input_data + max_bytes_matched))
        break;
    }
  }

  return ERROR_SUCCESS;
}


//
// yr_re_match_callback
//
// Callback function used by yr_re_exec to notify the caller about matches.
//

int yr_re_match_callback(
    YR_SCAN_CONTEXT* context,
    RE* re,
    const uint8_t* target,
    size_t target_length,
    int offset,
    void* callback_args)
{
  RE_MATCH_CALLBACK_FUNC callback = (RE_MATCH_CALLBACK_FUNC) callback_args;

  if (callback != NULL)
  {
    return callback(
        context,
        re,
        target,
        target_length,
        offset,
        callback_args);
  }

  return ERROR_SUCCESS;
}


//
// yr_re_get_error_string
//
// Returns a string representation of the error code.
//

const char* yr_re_get_error_string(
    int error_code)
{
  switch (error_code)
  {
    case ERROR_SUCCESS:
      return "No error";

    case ERROR_INSUFFICIENT_MEMORY:
      return "Insufficient memory";

    case ERROR_INVALID_REGULAR_EXPRESSION:
      return "Invalid regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_COMPLEX:
      return "Regular expression too complex";

    case ERROR_REGULAR_EXPRESSION_TOO_LARGE:
      return "Regular expression too large";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_RE_FIBERS:
      return "Too many regular expression fibers";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_SPLITS:
      return "Too many splits in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_JUMPS:
      return "Too many jumps in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_REPEATS:
      return "Too many repeats in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_ANY_REPEATS:
      return "Too many any repeats in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_LITERALS:
      return "Too many literals in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_CLASSES:
      return "Too many character classes in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_WORD_CHARS:
      return "Too many word characters in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_NON_WORD_CHARS:
      return "Too many non-word characters in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_SPACE_CHARS:
      return "Too many space characters in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_NON_SPACE_CHARS:
      return "Too many non-space characters in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_DIGIT_CHARS:
      return "Too many digit characters in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_NON_DIGIT_CHARS:
      return "Too many non-digit characters in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_ANY_CHARS:
      return "Too many any characters in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_ANCHORS:
      return "Too many anchors in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_CONCAT:
      return "Too many concatenations in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_ALTERNATIVES:
      return "Too many alternatives in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_BRANCHES:
      return "Too many branches in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_REPEATS:
      return "Too many repeats in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_ANY_REPEATS:
      return "Too many any repeats in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_LITERALS:
      return "Too many literals in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_CLASSES:
      return "Too many character classes in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_WORD_CHARS:
      return "Too many word characters in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_NON_WORD_CHARS:
      return "Too many non-word characters in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_SPACE_CHARS:
      return "Too many space characters in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_NON_SPACE_CHARS:
      return "Too many non-space characters in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_DIGIT_CHARS:
      return "Too many digit characters in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_NON_DIGIT_CHARS:
      return "Too many non-digit characters in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_ANY_CHARS:
      return "Too many any characters in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_ANCHORS:
      return "Too many anchors in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_CONCAT:
      return "Too many concatenations in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_ALTERNATIVES:
      return "Too many alternatives in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_BRANCHES:
      return "Too many branches in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_REPEATS:
      return "Too many repeats in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_ANY_REPEATS:
      return "Too many any repeats in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_LITERALS:
      return "Too many literals in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_CLASSES:
      return "Too many character classes in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_WORD_CHARS:
      return "Too many word characters in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_NON_WORD_CHARS:
      return "Too many non-word characters in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_SPACE_CHARS:
      return "Too many space characters in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_NON_SPACE_CHARS:
      return "Too many non-space characters in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_DIGIT_CHARS:
      return "Too many digit characters in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_NON_DIGIT_CHARS:
      return "Too many non-digit characters in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_ANY_CHARS:
      return "Too many any characters in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_ANCHORS:
      return "Too many anchors in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_CONCAT:
      return "Too many concatenations in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_ALTERNATIVES:
      return "Too many alternatives in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_BRANCHES:
      return "Too many branches in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_REPEATS:
      return "Too many repeats in regular expression";

    case ERROR_REGULAR_EXPRESSION_TOO_MANY_ANY_REPEATS:
      return "Too many any repeats in regular