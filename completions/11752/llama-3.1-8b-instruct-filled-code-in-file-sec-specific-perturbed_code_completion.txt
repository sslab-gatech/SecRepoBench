int yr_re_ast_split_at_chaining_point(
    RE_AST* re_ast,
    RE_AST** result_re_ast,
    RE_AST** remainder_re_ast,
    int32_t* min_gap,
    int32_t* maximumgap)
{
  RE_NODE* child;
  RE_NODE* concat;

  int result;

  *result_re_ast = re_ast;
  *remainder_re_ast = NULL;
  *min_gap = 0;
  *maximumgap = 0;

  if (re_ast->root_node->type!= RE_NODE_CONCAT)
    return ERROR_SUCCESS;

  child = re_ast->root_node->children_head;

  while (child!= NULL)
  {
    if (child->type == RE_NODE_RANGE_ANY)
    {
      RE_REPEAT_ANY_ARGS* repeat_any_args = (RE_REPEAT_ANY_ARGS*) child->value;

      if (repeat_any_args->max > RE_REPEAT_ANY_THRESHOLD)
      {
        RE_AST* new_re_ast = NULL;
        RE_AST* new_remainder_re_ast = NULL;
        int32_t new_min_gap = 0;
        int32_t new_maximumgap = 0;

        FAIL_ON_ERROR(yr_re_ast_split_at_chaining_point(
            child,
            &new_re_ast,
            &new_remainder_re_ast,
            &new_min_gap,
            &new_maximumgap));

        *result_re_ast = re_ast;
        *remainder_re_ast = new_remainder_re_ast;
        *min_gap = new_min_gap;
        *maximumgap = new_maximumgap;

        return ERROR_SUCCESS;
      }
    }

    child = child->next_sibling;
  }

  return ERROR_SUCCESS;
}