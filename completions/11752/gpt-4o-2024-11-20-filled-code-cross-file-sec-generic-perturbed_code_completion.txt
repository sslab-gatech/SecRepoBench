if (child->type == RE_NODE_RANGE_ANY && !child->greedy &&
        child->value.range.min > SOME_THRESHOLD)
    {
      // Create a new AST for the remainder
      *remainder_re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
      if (*remainder_re_ast == NULL)
        return ERROR_INSUFFICIENT_MEMORY;

      (*remainder_re_ast)->root_node = re_ast->root_node;
      re_ast->root_node = (RE_NODE*) yr_malloc(sizeof(RE_NODE));
      if (re_ast->root_node == NULL)
      {
        yr_re_ast_destroy(*remainder_re_ast);
        return ERROR_INSUFFICIENT_MEMORY;
      }

      // Initialize the new root node for the current AST
      re_ast->root_node->type = RE_NODE_CONCAT;
      re_ast->root_node->children_head = NULL;
      re_ast->root_node->children_tail = NULL;

      // Update the min and max gap
      *min_gap = child->value.range.min;
      *maximumgap = child->value.range.max;

      // Detach the child node and append it to the remainder AST
      if (child->prev_sibling != NULL)
        child->prev_sibling->next_sibling = NULL;
      else
        re_ast->root_node->children_head = NULL;

      if (child->next_sibling != NULL)
        child->next_sibling->prev_sibling = NULL;
      else
        re_ast->root_node->children_tail = NULL;

      (*remainder_re_ast)->root_node->children_head = child;
      (*remainder_re_ast)->root_node->children_tail = re_ast->root_node->children_tail;

      // Return success after splitting
      return ERROR_SUCCESS;
    }