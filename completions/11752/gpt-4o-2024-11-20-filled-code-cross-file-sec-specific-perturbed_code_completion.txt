if (child->type == RE_NODE_RANGE_ANY && child->greedy == false)
    {
      // Check if the range exceeds the threshold for splitting
      if (child->start > SOME_THRESHOLD || child->end > SOME_THRESHOLD)
      {
        // Create a new AST for the remainder
        *remainder_re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
        if (*remainder_re_ast == NULL)
          return ERROR_INSUFFICIENT_MEMORY;

        (*remainder_re_ast)->root_node = re_ast->root_node;
        re_ast->root_node = (RE_NODE*) yr_malloc(sizeof(RE_NODE));
        if (re_ast->root_node == NULL)
        {
          yr_re_ast_destroy(*remainder_re_ast);
          return ERROR_INSUFFICIENT_MEMORY;
        }

        // Initialize the new root node for the current AST
        re_ast->root_node->type = RE_NODE_CONCAT;
        re_ast->root_node->children_head = NULL;
        re_ast->root_node->children_tail = NULL;

        // Update the min and max gap
        *min_gap = child->start;
        *maximumgap = child->end;

        // Detach the child node and append it to the new AST
        if (child->prev_sibling != NULL)
          child->prev_sibling->next_sibling = NULL;

        if (child->next_sibling != NULL)
          child->next_sibling->prev_sibling = NULL;

        yr_re_node_append_child(re_ast->root_node, child);

        // Update the remainder AST to start from the next sibling
        (*remainder_re_ast)->root_node->children_head = child->next_sibling;
        if (child->next_sibling != NULL)
          child->next_sibling->prev_sibling = NULL;

        return ERROR_SUCCESS;
      }
    }