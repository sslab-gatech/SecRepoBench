if (child->type == RE_NODE_RANGE && child->range.min > 100) {
  RE_AST* new_ast = yr_re_ast_create();
  if (new_ast == NULL) {
    return ERROR_INSUFFICIENT_MEMORY;
  }

  RE_NODE* split_point = child->prev_sibling;
  if (split_point == NULL) {
    split_point = re_ast->root_node;
  }

  new_ast->root_node = yr_re_node_create(RE_NODE_CONCAT);
  if (new_ast->root_node == NULL) {
    yr_re_ast_destroy(new_ast);
    return ERROR_INSUFFICIENT_MEMORY;
  }

  RE_NODE* new_child = yr_re_node_create(RE_NODE_CONCAT);
  if (new_child == NULL) {
    yr_re_ast_destroy(new_ast);
    return ERROR_INSUFFICIENT_MEMORY;
  }

  new_child->children_head = split_point->next_sibling;
  new_child->children_tail = re_ast->root_node->children_tail;
  new_child->children_tail->next_sibling = NULL;

  if (split_point->next_sibling != NULL) {
    split_point->next_sibling->prev_sibling = NULL;
  }

  split_point->next_sibling = NULL;

  new_ast->root_node->children_head = re_ast->root_node;
  new_ast->root_node->children_tail = split_point;

  re_ast->root_node = new_child;
  *result_re_ast = new_ast;
  *remainder_re_ast = re_ast;
  *min_gap = child->range.min;
  *maximumgap = child->range.max;

  return ERROR_SUCCESS;
}