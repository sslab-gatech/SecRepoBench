if (child->type == RE_NODE_RANGE &&
    child->children_head != NULL &&
    child->children_head->type == RE_NODE_ANY &&
    child->greedy == false)
{
    *min_gap = child->range_min;
    *maximumgap = child->range_max;

    // Detach the remainder of the children starting at 'child'
    if (child->prev_sibling != NULL)
    {
        child->prev_sibling->next_sibling = NULL;
        re_ast->root_node->children_tail = child->prev_sibling;
    }
    else
    {
        // The split point is at the head: clear the children list.
        re_ast->root_node->children_head = NULL;
        re_ast->root_node->children_tail = NULL;
    }
    child->prev_sibling = NULL;

    // Allocate a new AST for the remainder.
    RE_AST* new_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
    if (new_ast == NULL)
        return ERROR_INSUFFICIENT_MEMORY;
    memset(new_ast, 0, sizeof(RE_AST));

    // Create a new root concat node for the remainder AST.
    RE_NODE* new_root = (RE_NODE*) yr_malloc(sizeof(RE_NODE));
    if (new_root == NULL)
    {
        yr_free(new_ast);
        return ERROR_INSUFFICIENT_MEMORY;
    }
    memset(new_root, 0, sizeof(RE_NODE));
    new_root->type = RE_NODE_CONCAT;
    new_root->children_head = child;

    // Find the last sibling for children_tail.
    RE_NODE* temp = child;
    while (temp->next_sibling)
        temp = temp->next_sibling;
    new_root->children_tail = temp;

    new_ast->root_node = new_root;
    *remainder_re_ast = new_ast;

    return ERROR_SUCCESS;
}