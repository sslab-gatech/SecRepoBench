if (child->type == RE_NODE_ANY && child->min_range > SOME_THRESHOLD)
    {
        // Create a new AST for the remainder
        RE_AST* new_re_ast = (RE_AST*)malloc(sizeof(RE_AST));
        new_re_ast->root_node = child;

        // Update the current AST to separate the nodes before and after the point of splitting
        if (child->prev_sibling != NULL)
        {
            child->prev_sibling->next_sibling = child->next_sibling;
        }
        if (child->next_sibling != NULL)
        {
            child->next_sibling->prev_sibling = child->prev_sibling;
        }

        // Update the min and max gap with the range values of the current node
        *min_gap = child->min_range;
        *maximumgap = child->max_range;

        // Set the result and remainder ASTs
        *result_re_ast = re_ast;
        *remainder_re_ast = new_re_ast;

        // Free the child node if necessary
        free(child);

        return ERROR_SUCCESS;
    }