{
      RE_AST* new_re_ast;
      RE_AST* remainder_re_ast;

      RE_NODE* new_node;
      RE_NODE* next_child;

      if (child->type == RE_NODE_RANGE_ANY && !child->greedy &&
          child->end > RE_CHAINING_POINT)
      {
        result = yr_re_ast_create(&new_re_ast);
        if (result != ERROR_SUCCESS)
          return result;

        new_node = yr_re_node_create(RE_NODE_CONCAT);
        if (new_node == NULL)
        {
          yr_re_ast_destroy(new_re_ast);
          return ERROR_INSUFFICIENT_MEMORY;
        }

        next_child = child->next_sibling;

        while (next_child != NULL)
        {
          yr_re_node_append_child(new_node, next_child);
          next_child = next_child->next_sibling;
        }

        new_re_ast->root_node = new_node;
        remainder_re_ast = new_re_ast;

        child->next_sibling = NULL;
        *min_gap = child->start;
        *maximumgap = child->end;

        *result_re_ast = re_ast;
        *remainder_re_ast = remainder_re_ast;

        return ERROR_SUCCESS;
      }
    }