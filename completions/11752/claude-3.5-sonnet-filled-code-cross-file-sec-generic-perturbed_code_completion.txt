(child->type == RE_NODE_RANGE_ANY &&
 !child->greedy &&
 child->start > YR_RE_CHAINING_THRESHOLD)
{
  *min_gap = child->start;
  *maximumgap = child->end;

  // Create a new AST for the remainder
  FAIL_ON_ERROR(yr_re_ast_create(&(*remainder_re_ast)));

  // Set up the new root for the remainder AST
  (*remainder_re_ast)->root_node = yr_re_node_create(RE_NODE_CONCAT);
  if ((*remainder_re_ast)->root_node == NULL)
  {
    yr_re_ast_destroy(*remainder_re_ast);
    return ERROR_INSUFFICIENT_MEMORY;
  }

  // Move all subsequent siblings to the new AST
  RE_NODE* next = child->next_sibling;
  while (next != NULL)
  {
    RE_NODE* temp = next->next_sibling;
    yr_re_node_append_child((*remainder_re_ast)->root_node, next);
    next = temp;
  }

  // Remove the range-any node and all subsequent nodes from the original AST
  if (child->prev_sibling != NULL)
  {
    child->prev_sibling->next_sibling = NULL;
    re_ast->root_node->children_tail = child->prev_sibling;
  }
  else
  {
    re_ast->root_node->children_head = NULL;
    re_ast->root_node->children_tail = NULL;
  }

  // Clean up the range-any node
  yr_re_node_destroy(child);

  return ERROR_SUCCESS;
}