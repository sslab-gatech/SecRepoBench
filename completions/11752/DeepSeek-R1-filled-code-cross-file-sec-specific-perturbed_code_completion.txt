(child->type == RE_NODE_RANGE_ANY && !child->greedy)
    {
        *min_gap = child->start;
        *maximumgap = child->end;

        RE_NODE* prev_child = child->prev_sibling;
        RE_NODE* original_tail = re_ast->root_node->children_tail;

        if (prev_child != NULL)
        {
            prev_child->next_sibling = NULL;
            re_ast->root_node->children_tail = prev_child;
        }
        else
        {
            re_ast->root_node->children_head = NULL;
            re_ast->root_node->children_tail = NULL;
        }

        *remainder_re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
        if (*remainder_re_ast == NULL)
            return ERROR_INSUFFICIENT_MEMORY;

        (*remainder_re_ast)->root_node = yr_re_node_create(RE_NODE_CONCAT);
        if ((*remainder_re_ast)->root_node == NULL)
        {
            yr_free(*remainder_re_ast);
            *remainder_re_ast = NULL;
            return ERROR_INSUFFICIENT_MEMORY;
        }

        (*remainder_re_ast)->root_node->children_head = child;
        (*remainder_re_ast)->root_node->children_tail = original_tail;

        RE_NODE* current = child;
        while (current != NULL)
        {
            current->parent = (*remainder_re_ast)->root_node;
            current = current->next_sibling;
        }

        child->prev_sibling = NULL;
        break;
    }