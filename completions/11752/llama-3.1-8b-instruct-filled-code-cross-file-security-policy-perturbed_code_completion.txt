if (child->type == RE_NODE_RANGE_ANY && child->range->max > MAX_THRESHOLD)
{
  RE_AST* new_re_ast;
  RE_AST* new_remainder_re_ast;
  int32_t new_min_gap;
  int32_t new_max_gap;

  *result_re_ast = re_ast;
  *remainder_re_ast = re_ast;
  *remainder_re_ast = yr_re_ast_split_at_chaining_point(
      re_ast,
      &new_re_ast,
      &new_remainder_re_ast,
      &new_min_gap,
      &new_max_gap);

  if (*remainder_re_ast == NULL)
  {
    *result_re_ast = new_re_ast;
    *remainder_re_ast = new_remainder_re_ast;
    *min_gap = new_min_gap;
    *maximumgap = new_max_gap;
  }
  else
  {
    RE_NODE* new_concat;
    RE_NODE* new_child;

    new_concat = yr_re_node_create(RE_NODE_CONCAT);
    yr_re_node_append_child(new_concat, re_ast->root_node);

    new_child = yr_re_node_create(RE_NODE_RANGE_ANY);
    new_child->range = child->range;
    yr_re_node_append_child(new_concat, new_child);

    *result_re_ast = yr_re_ast_create(new_concat);
    *remainder_re_ast = new_remainder_re_ast;
    *min_gap = new_min_gap;
    *maximumgap = new_max_gap;
  }

  if (child->prev_sibling!= NULL)
    child->prev_sibling->next_sibling = child->next_sibling;

  if (child->next_sibling!= NULL)
    child->next_sibling->prev_sibling = child->prev_sibling;

  yr_re_node_destroy(child);

  return ERROR_SUCCESS;
}