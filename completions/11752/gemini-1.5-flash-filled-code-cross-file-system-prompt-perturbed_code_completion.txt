(child->type == RE_NODE_RANGE_ANY &&
     !child->greedy &&
     child->range.max - child->range.min >= 1000)
    {
      RE_AST* remainder_re_ast;
      RE_NODE* next_child;

      remainder_re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
      if (remainder_re_ast == NULL)
        return ERROR_INSUFFICIENT_MEMORY;

      remainder_re_ast->root_node = child->next_sibling;
      if (remainder_re_ast->root_node != NULL)
        remainder_re_ast->root_node->prev_sibling = NULL;

      next_child = child->next_sibling;
      child->next_sibling = NULL;

      if (child->prev_sibling != NULL)
        child->prev_sibling->next_sibling = NULL;
      else
        re_ast->root_node->children_head = NULL;

      *remainder_re_ast = remainder_re_ast;
      *min_gap = child->range.min;
      *maximumgap = child->range.max;

      return ERROR_SUCCESS;
    }