(
      child->type == RE_NODE_RANGE_ANY &&
      child->greedy == false &&
      child->start > 0
    )
    {
      // Split at this point

      // Create a new AST for the remainder
      RE_AST* new_re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
      if (new_re_ast == NULL)
        return ERROR_INSUFFICIENT_MEMORY;

      // Create a new concat node for the remainder
      concat = (RE_NODE*) yr_malloc(sizeof(RE_NODE));
      if (concat == NULL)
      {
        yr_free(new_re_ast);
        return ERROR_INSUFFICIENT_MEMORY;
      }

      memset(concat, 0, sizeof(RE_NODE));
      concat->type = RE_NODE_CONCAT;

      // Move all nodes after 'child' to the new concat node
      RE_NODE* next = child->next_sibling;
      while (next != NULL)
      {
        RE_NODE* tmp = next->next_sibling;
        next->prev_sibling = NULL;
        next->next_sibling = NULL;
        yr_re_node_append_child(concat, next);
        next = tmp;
      }

      // Detach the remainder from the original concat node
      re_ast->root_node->children_tail = child;
      child->next_sibling = NULL;

      // Set up the new AST
      new_re_ast->root_node = concat;
      *remainder_re_ast = new_re_ast;

      // Set min_gap and maximumgap
      *min_gap = child->start;
      *maximumgap = child->end;

      return ERROR_SUCCESS;
    }