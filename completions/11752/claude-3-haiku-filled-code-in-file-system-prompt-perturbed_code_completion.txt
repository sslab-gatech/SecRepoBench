// Check if the current child node is a non-greedy, range-any node with a
// range that exceeds a specified threshold. If so, split the AST at this
// point. Create a new AST for the remainder and update the current AST
// to separate the nodes before and after the point of splitting.
// Update the min and max gap with the range values of the current node.
// Ensure the child node is properly removed, and return success after
// successfully splitting the AST.
if (child->type == RE_NODE_RANGE_ANY && !child->greedy &&
    child->end - child->start > RE_SPLIT_THRESHOLD)
{
    RE_AST* remainder_re_ast;
    int32_t min_gap = child->start;
    int32_t max_gap = child->end;

    FAIL_ON_ERROR(yr_re_ast_split_at_chaining_point(
        re_ast, result_re_ast, &remainder_re_ast, &min_gap, &max_gap));

    *remainder_re_ast = *re_ast;
    re_ast->root_node = child;
    re_ast->root_node->next_sibling = remainder_re_ast->root_node;
    *min_gap = child->start;
    *maximumgap = child->end;

    // Remove the current child node from the AST
    child->prev_sibling->next_sibling = child->next_sibling;
    if (child->next_sibling != NULL)
        child->next_sibling->prev_sibling = child->prev_sibling;
    yr_re_node_destroy(child);

    return ERROR_SUCCESS;
}