(child->type == RE_NODE_RANGE_ANY && child->greedy == FALSE &&
        child->start > RE_RANGE_ANY_THRESHOLD)
    {
      *remainder_re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));

      if (*remainder_re_ast == NULL)
        return ERROR_INSUFFICIENT_MEMORY;

      (*remainder_re_ast)->root_node = NULL;

      // Move child and all subsequent siblings from re_ast to remainder_re_ast.
      (*remainder_re_ast)->root_node = child;

      if (child->prev_sibling != NULL)
      {
        child->prev_sibling->next_sibling = NULL;
        re_ast->root_node->children_tail = child->prev_sibling;
        child->prev_sibling = NULL;
      }
      else
      {
        re_ast->root_node->children_head = NULL;
        re_ast->root_node->children_tail = NULL;
      }

      *min_gap = child->start;
      *maximumgap = child->end;

      // If the original root node has no children left, replace it with an empty
      // string node.
      if (re_ast->root_node->children_head == NULL)
      {
        RE_NODE* empty_string_node = yr_re_node_create(RE_NODE_STRING);
        if (empty_string_node == NULL) {
          yr_re_ast_destroy(*remainder_re_ast);
          return ERROR_INSUFFICIENT_MEMORY;
        }
        empty_string_node->value = yr_strdup("");
        if (empty_string_node->value == NULL) {
          yr_re_node_destroy(empty_string_node);
          yr_re_ast_destroy(*remainder_re_ast);
          return ERROR_INSUFFICIENT_MEMORY;
        }
        empty_string_node->length = 0;

        re_ast->root_node = empty_string_node;
      }

      return ERROR_SUCCESS;
    }