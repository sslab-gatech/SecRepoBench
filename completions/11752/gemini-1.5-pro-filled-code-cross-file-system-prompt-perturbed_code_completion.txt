(child->type == RE_NODE_RANGE_ANY && child->greedy == FALSE && child->start > RE_RANGE_ANY_THRESHOLD)
    {
      concat = re_ast->root_node;

      *remainder_re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));

      if (*remainder_re_ast == NULL)
        return ERROR_INSUFFICIENT_MEMORY;

      (*remainder_re_ast)->root_node = (RE_NODE*) yr_malloc(sizeof(RE_NODE));

      if ((*remainder_re_ast)->root_node == NULL)
      {
        yr_re_ast_destroy(*remainder_re_ast);
        return ERROR_INSUFFICIENT_MEMORY;
      }

      (*remainder_re_ast)->root_node->type = RE_NODE_CONCAT;
      (*remainder_re_ast)->root_node->children_head = child->next_sibling;
      (*remainder_re_ast)->root_node->children_tail = concat->children_tail;
      (*remainder_re_ast)->root_node->greedy = FALSE;

      if (child->next_sibling != NULL)
        child->next_sibling->prev_sibling = NULL;

      concat->children_tail = child;
      child->next_sibling = NULL;

      *min_gap = child->start;
      *maximumgap = child->end;

      yr_re_node_destroy(child);
      concat->children_tail = child->prev_sibling;

      if (child->prev_sibling != NULL)
        child->prev_sibling->next_sibling = NULL;
      else
        concat->children_head = NULL;

      yr_free(child);

      return ERROR_SUCCESS;
    }