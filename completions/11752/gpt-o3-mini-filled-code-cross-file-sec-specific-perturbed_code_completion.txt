if (child->type == RE_NODE_RANGE_ANY &&
    !child->greedy &&
    (child->min_gap > 0))
{
    *min_gap = child->min_gap;
    *maximumgap = child->max_gap;

    // Detach the remainder of the list starting at this child.
    if (child->prev_sibling != NULL)
    {
        child->prev_sibling->next_sibling = NULL;
        re_ast->root_node->children_tail = child->prev_sibling;
        child->prev_sibling = NULL;
    }
    else
    {
        // If the child is the first (and possibly only) child then
        // empty the children list of the current root.
        re_ast->root_node->children_head = NULL;
        re_ast->root_node->children_tail = NULL;
    }

    // Create a new AST for the remainder.
    RE_AST* remainder = (RE_AST*) yr_malloc(sizeof(RE_AST));
    if (remainder == NULL)
        return ERROR_INSUFFICIENT_MEMORY;

    // Create a new concatenation node to serve as the root of the remainder AST.
    remainder->root_node = yr_re_node_create(RE_NODE_CONCAT);
    if (remainder->root_node == NULL)
    {
        yr_free(remainder);
        return ERROR_INSUFFICIENT_MEMORY;
    }

    // Append the detached child (and its siblings) to the new AST.
    remainder->root_node->children_head = child;
    {
        RE_NODE* temp = child;
        while (temp->next_sibling != NULL)
            temp = temp->next_sibling;
        remainder->root_node->children_tail = temp;
    }

    *remainder_re_ast = remainder;
    return ERROR_SUCCESS;
}