(child->type == RE_NODE_RANGE_ANY &&
 !child->greedy &&
 child->start > 0)  // Some threshold for splitting
{
  // Set the min and max gap to the range values of the current node
  *min_gap = child->start;
  *maximumgap = child->end;
  
  // Create a new AST for the remainder
  *remainder_re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
  
  if (*remainder_re_ast == NULL)
    return ERROR_INSUFFICIENT_MEMORY;
  
  (*remainder_re_ast)->flags = re_ast->flags;
  (*remainder_re_ast)->root_node = yr_re_node_create(RE_NODE_CONCAT);
  
  if ((*remainder_re_ast)->root_node == NULL)
  {
    yr_free(*remainder_re_ast);
    *remainder_re_ast = NULL;
    return ERROR_INSUFFICIENT_MEMORY;
  }
  
  // Get the next node after the chaining point
  RE_NODE* next = child->next_sibling;
  
  // Update the original AST to end at the node before the chaining point
  if (child->prev_sibling != NULL)
  {
    child->prev_sibling->next_sibling = NULL;
    re_ast->root_node->children_tail = child->prev_sibling;
  }
  else
  {
    // The child is the first node in the list
    re_ast->root_node->children_head = NULL;
    re_ast->root_node->children_tail = NULL;
  }
  
  // Move remaining nodes to the remainder AST
  while (next != NULL)
  {
    RE_NODE* sibling = next;
    next = next->next_sibling;
    
    sibling->prev_sibling = NULL;
    sibling->next_sibling = NULL;
    
    yr_re_node_append_child((*remainder_re_ast)->root_node, sibling);
  }
  
  // Destroy the chaining point node
  yr_re_node_destroy(child);
  
  return ERROR_SUCCESS;
}