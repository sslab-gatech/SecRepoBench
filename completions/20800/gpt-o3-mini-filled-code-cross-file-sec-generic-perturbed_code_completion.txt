if (available_space(pe, codeview_header) < 4)
  continue;

if (memcmp(codeview_header, "RSDS", 4) == 0)
{
  // RSDS format: 4 bytes signature + 16 bytes GUID + 4 bytes Age,
  // followed by a null-terminated PDB file name.
  if (available_space(pe, codeview_header) < (4 + 16 + 4))
    continue;

  // Cast to the RSDS structure.
  PCV_INFO_PDB70 pdb70 = (PCV_INFO_PDB70) codeview_header;

  // Calculate maximum possible length for the PDB file name.
  size_t fixed_size = 4 + 16 + 4;
  size_t max_pdb_len = pe->data_size > (size_t)(pcv_hdr_offset + fixed_size) ?
                       pe->data_size - (pcv_hdr_offset + fixed_size) : 0;
  if (max_pdb_len == 0)
    continue;

  size_t pdb_len = strnlen(pdb70->PdbFileName, max_pdb_len);
  if (pdb_len == max_pdb_len)
    continue;

  pdb_path = yr_malloc(pdb_len + 1);
  if (pdb_path == NULL)
    break;
  memcpy(pdb_path, pdb70->PdbFileName, pdb_len);
  pdb_path[pdb_len] = '\0';

  set_string(pdb_path, pe->object, "pdb_path");
  yr_free(pdb_path);
  break;
}
else if (memcmp(codeview_header, "NB10", 4) == 0)
{
  // NB10 format: 4 bytes signature + 4 bytes offset + 4 bytes Age,
  // followed by a null-terminated PDB file name.
  if (available_space(pe, codeview_header) < (4 + 4 + 4))
    continue;

  // Cast to the NB10 structure.
  PCV_INFO_PDB20 pdb20 = (PCV_INFO_PDB20) codeview_header;

  // Calculate maximum possible length for the PDB file name.
  size_t fixed_size = 4 + 4 + 4;
  size_t max_pdb_len = pe->data_size > (size_t)(pcv_hdr_offset + fixed_size) ?
                       pe->data_size - (pcv_hdr_offset + fixed_size) : 0;
  if (max_pdb_len == 0)
    continue;

  size_t pdb_len = strnlen(pdb20->PdbFileName, max_pdb_len);
  if (pdb_len == max_pdb_len)
    continue;

  pdb_path = yr_malloc(pdb_len + 1);
  if (pdb_path == NULL)
    break;
  memcpy(pdb_path, pdb20->PdbFileName, pdb_len);
  pdb_path[pdb_len] = '\0';

  set_string(pdb_path, pe->object, "pdb_path");
  yr_free(pdb_path);
  break;
}