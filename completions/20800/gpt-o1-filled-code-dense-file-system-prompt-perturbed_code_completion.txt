{
    DWORD signature = yr_le32toh(codeview_header->Signature);
    const char* pdb_file_name = NULL;

    // Check for the CodeView signatures we recognize, "RSDS" or "NB10".
    if (signature == 0x53445352) // "RSDS"
    {
        PRSDS_HEADER rsds_hdr = (PRSDS_HEADER) codeview_header;

        if (!struct_fits_in_pe(pe, rsds_hdr, RSDS_HEADER))
            continue;

        pdb_file_name = (const char*) rsds_hdr->PdbFileName;
    }
    else if (signature == 0x3031424E) // "NB10"
    {
        PNB10_HEADER nb10_hdr = (PNB10_HEADER) codeview_header;

        if (!struct_fits_in_pe(pe, nb10_hdr, NB10_HEADER))
            continue;

        pdb_file_name = (const char*) nb10_hdr->PdbFileName;
    }
    else
    {
        continue;
    }

    // If we have a pointer to the PDB filename, verify it fits in the PE.
    if (pdb_file_name == NULL ||
        !fits_in_pe(pe, (void*) pdb_file_name, 1))
    {
        continue;
    }

    // Calculate the PDB path length, ensuring it's within reasonable limits.
    pdb_path_len = strnlen(pdb_file_name, 512);
    if (pdb_path_len > 0 && pdb_path_len < 512 &&
        fits_in_pe(pe, (void*) pdb_file_name, pdb_path_len))
    {
        // Allocate stored PDB path
        pdb_path = (char*) yr_malloc(pdb_path_len + 1);
        if (pdb_path != NULL)
        {
            memcpy(pdb_path, pdb_file_name, pdb_path_len);
            pdb_path[pdb_path_len] = '\0';
            set_string(pdb_path, pe->object, "pdb_path");
            yr_free(pdb_path);
        }

        // Stop processing after finding a valid PDB path.
        break;
    }
}