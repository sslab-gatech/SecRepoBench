if (available_space(pe, codeview_header) < 4)
  continue;

if (memcmp(&codeview_header->signature, "RSDS", 4) == 0)
{
  // RSDS format: 4 bytes signature ("RSDS"), 16 bytes GUID, 4 bytes age, then a null‐terminated PDB file name.
  // Ensure we have enough bytes for the fixed part.
  if (available_space(pe, codeview_header) < (4 + 16 + 4))
    continue;
  // The PDB file name starts after the fixed header.
  char* pdb = (char*)codeview_header + 24;
  if (!fits_in_pe(pe, pdb, 1))
    continue;
  pdb_path_len = strnlen(pdb, MAX_PDB_PATH_LENGTH);
  if (pdb_path_len > 0 && pdb_path_len < MAX_PDB_PATH_LENGTH)
  {
    set_string(pdb, pe->object, "pdb");
    break;
  }
}
else if (memcmp(&codeview_header->signature, "NB10", 4) == 0)
{
  // NB10 format: 4 bytes signature ("NB10"), 4 bytes offset, 4 bytes timestamp, then a null‐terminated PDB file name.
  if (available_space(pe, codeview_header) < (4 + 4 + 4))
    continue;
  char* pdb = (char*)codeview_header + 12;
  if (!fits_in_pe(pe, pdb, 1))
    continue;
  pdb_path_len = strnlen(pdb, MAX_PDB_PATH_LENGTH);
  if (pdb_path_len > 0 && pdb_path_len < MAX_PDB_PATH_LENGTH)
  {
    set_string(pdb, pe->object, "pdb");
    break;
  }
}