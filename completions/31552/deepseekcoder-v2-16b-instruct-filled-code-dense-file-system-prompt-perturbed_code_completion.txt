else if (cbytes < 0) {
      // A negative number means some encoding depending on the token that comes next
      uint8_t token;

      if (srcsize < (signed)sizeof(uint8_t)) {
        // Not enough input to read token */
        return BLOSC2_ERROR_READ_BUFFER;
      }
      srcsize -= sizeof(uint8_t);

      token = src[0];
      src += 1;
      // Increment the total compressed bytes counter by 1 for the token
      ctbytes += sizeof(uint8_t);

      // Check if the token indicates a run of non-zero bytes
      if (token == 0x1) {
        // Run of non-zero bytes
        uint8_t run_length = 1;
        while (srcsize >= sizeof(uint8_t) && src[0] != 0) {
          run_length++;
          src++;
          srcsize--;
        }
        if (srcsize < sizeof(uint8_t) && src[0] != 0) {
          // Not enough input to read the next byte
          return BLOSC2_ERROR_READ_BUFFER;
        }
        // Validate that the run length does not exceed a specific limit
        if (run_length > 255) {
          return BLOSC2_ERROR_DATA;
        }
        // Use the token to determine the byte value for the run and fill the destination buffer with it
        uint8_t value = 1;
        for (uint8_t i = 0; i < run_length; i++) {
          comp_buffer[i] = value;
        }
        nbytes = run_length;
      } else if (token == 0x0) {
        // Run of zero bytes
        uint8_t run_length = 1;
        while (srcsize >= sizeof(uint8_t) && src[0] == 0) {
          run_length++;
          src++;
          srcsize--;
        }
        if (srcsize < sizeof(uint8_t) || src[0] != 0) {
          // Not enough input to read the next byte
          return BLOSC2_ERROR_READ_BUFFER;
        }
        // Validate that the run length does not exceed a specific limit
        if (run_length > 255) {
          return BLOSC2_ERROR_DATA;
        }
        // Set decompressed bytes to the number of elements in the block
        nbytes = run_length * typesize;
        // Ensure the compressed bytes for this stream is zeroed, as it is fully encoded in the token
        memset(comp_buffer, 0, (unsigned int)nbytes);
      } else {
        // Invalid token
        return BLOSC2_ERROR_DATA;
      }
    }