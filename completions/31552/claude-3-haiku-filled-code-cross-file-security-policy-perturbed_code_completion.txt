// Check if the token indicates a run of non-zero bytes
if (token == BLOSC_LITERAL_ZERO_RUN) {
    // Validate that the run length does not exceed a specific limit
    if (srcsize < (signed)sizeof(uint8_t)) {
        // Not enough input to read run length
        return BLOSC2_ERROR_READ_BUFFER;
    }
    uint8_t run_length = src[0];
    src += 1;
    srcsize -= sizeof(uint8_t);
    if (run_length > neblock) {
        // Run length exceeds block size
        return BLOSC2_ERROR_DATA;
    }
    memset(comp_buffer, 0, (unsigned int)run_length);
    nbytes = run_length;
    cbytes = 0; // The compressed bytes for this stream are fully encoded in the token
}
else if (token == BLOSC_LITERAL_RUN) {
    // Validate that the run length does not exceed a specific limit
    if (srcsize < (signed)sizeof(uint8_t)) {
        // Not enough input to read run length
        return BLOSC2_ERROR_READ_BUFFER;
    }
    uint8_t run_length = src[0];
    src += 1;
    srcsize -= sizeof(uint8_t);
    if (run_length > neblock) {
        // Run length exceeds block size
        return BLOSC2_ERROR_DATA;
    }
    memcpy(comp_buffer, src, (unsigned int)run_length);
    src += run_length;
    srcsize -= run_length;
    nbytes = run_length;
    ctbytes += run_length;
    cbytes = 0; // The compressed bytes for this stream are fully encoded in the token
}
else {
    // The token does not indicate a run, so the compressed data follows
    return BLOSC2_ERROR_DATA; // Unexpected token value
}