pipeline_d(context, bsize, dest, dest_offset, tmp, tmp2, tmp3, last_filter_index);
    if (errcode != 0) {
      return errcode;
    }
  }

  return ntbytes;
}


/* Compress a single block */
static int blosc_compress_block(blosc2_context* context, int32_t bsize,
                                int32_t leftoverblock, int32_t ntbytes,
                                const uint8_t* src, int32_t offset,
                                uint8_t* dest, uint8_t* tmp, uint8_t* tmp2) {
  int32_t destsize = context->destsize;
  int32_t ctbytes = 0;
  int32_t typesize = context->typesize;
  int32_t nstreams;
  int32_t neblock;
  int32_t cbytes;
  int32_t maxout;
  int32_t accel;
  const char* compname;

  /* Calculate acceleration for different compressors */
  accel = get_accel(context);

  /* The number of compressed data streams for this block */
  if (leftoverblock == 0) {
    nstreams = (int32_t)typesize;
  }
  else {
    nstreams = 1;
  }
  neblock = bsize / nstreams;
  for (int j = 0; j < nstreams; j++) {
    maxout = neblock;
  #if defined(HAVE_SNAPPY)
    if (context->compcode == BLOSC_SNAPPY) {
      maxout = (int32_t)snappy_max_compressed_length((size_t)neblock);
    }
  #endif /*  HAVE_SNAPPY */
    if (ntbytes + maxout > destsize) {
      /* avoid buffer overrun */
      maxout = (int32_t)destsize - (int32_t)ntbytes;
      if (maxout <= 0) {
        return 0;                  /* non-compressible block */
      }
    }
    if (context->compcode == BLOSC_BLOSCLZ) {
      cbytes = blosclz_compress(context->clevel, src + j * neblock,
                                (int)neblock, dest, (int)maxout);
    }
  #if defined(HAVE_LZ4)
    else if (context->compcode == BLOSC_LZ4) {
      void *hash_table = NULL;
    #ifdef HAVE_IPP
      hash_table = (void*)context->lz4_hash_table;
    #endif
      cbytes = lz4_wrap_compress((char*)src + j * neblock, (size_t)neblock,
                                 (char*)dest, (size_t)maxout, accel, hash_table);
    }
    else if (context->compcode == BLOSC_LZ4HC) {
      cbytes = lz4hc_wrap_compress((char*)src + j * neblock, (size_t)neblock,
                                   (char*)dest, (size_t)maxout, context->clevel);
    }
  #endif /* HAVE_LZ4 */
  #if defined(HAVE_SNAPPY)
    else if (context->compcode == BLOSC_SNAPPY) {
      cbytes = snappy_wrap_compress((char*)src + j * neblock, (size_t)neblock,
                                    (char*)dest, (size_t)maxout);
    }
  #endif /* HAVE_SNAPPY */
  #if defined(HAVE_ZLIB)
    else if (context->compcode == BLOSC_ZLIB) {
      cbytes = zlib_wrap_compress((char*)src + j * neblock, (size_t)neblock,
                                  (char*)dest, (size_t)maxout, context->clevel);
    }
  #endif /* HAVE_ZLIB */
  #if defined(HAVE_ZSTD)
    else if (context->compcode == BLOSC_ZSTD) {
      cbytes = zstd_wrap_compress(context,
                                  (char*)src + j * neblock, (size_t)neblock,
                                  (char*)dest, (size_t)maxout, context->clevel);
    }
  #endif /* HAVE_ZSTD */

    else {
      compname = clibcode_to_clibname(context->compcode);
      BLOSC_TRACE_ERROR("Blosc has not been compiled with '%s' compression support."
                        "Please use one having it.", compname);
      return BLOSC2_ERROR_CODEC_SUPPORT;
    }

    if (cbytes > maxout) {
      /* Buffer overrun caused by compression (should never happen) */
      return BLOSC2_ERROR_WRITE_BUFFER;
    }
    if (cbytes < 0) {
      /* cbytes should never be negative */
      return BLOSC2_ERROR_DATA;
    }
    if (cbytes == 0 || cbytes == neblock) {
      /* The compressor has been unable to compress data at all. */
      memcpy(dest, src + j * neblock, (unsigned int)neblock);
      cbytes = neblock;
    }
    dest += cbytes;
    ntbytes += cbytes;
    ctbytes += cbytes;
  }  /* Closes j < nstreams */

  return ctbytes;
}


/* Decompress a single block */
static int blosc_decompress_block(blosc2_context* context, int32_t bsize,
                                  const uint8_t* src, int32_t srcsize,
                                  uint8_t* dest, uint8_t* tmp, uint8_t* tmp2) {
  int32_t typesize = context->typesize;
  int32_t nstreams;
  int32_t neblock;
  int32_t nbytes;                /* number of decompressed bytes in split */
  int32_t cbytes;                /* number of compressed bytes in split */
  int32_t ctbytes = 0;           /* number of compressed bytes in block */
  int32_t ntbytes = 0;           /* number of uncompressed bytes in block */
  uint8_t* comp_buffer;
  const char* compname;

  // In some situations (lazychunks) the context can arrive uninitialized
  // (but BITSHUFFLE needs it for accessing the format of the chunk)
  if (context->src == NULL) {
    context->src = src;
  }

  // If the chunk is memcpyed, we just have to copy the block to dest and return
  if (context->header_flags & (uint8_t)BLOSC_MEMCPYED) {
    if (srcsize < bsize) {
      /* Not enough input to read compressed bytes */
      return BLOSC2_ERROR_READ_BUFFER;
    }
    memcpy(dest, src, bsize);
    return bsize;
  }

  nstreams = (int32_t)typesize;
  neblock = bsize / nstreams;
  if (neblock == 0) {
    /* Not enough space to output bytes */
    return -1;
  }
  for (int j = 0; j < nstreams; j++) {
    if (srcsize < (signed)sizeof(int32_t)) {
      /* Not enough input to read compressed size */
      return BLOSC2_ERROR_READ_BUFFER;
    }
    srcsize -= sizeof(int32_t);
    cbytes = sw32_(src);      /* amount of compressed bytes */
    if (cbytes > 0) {
      if (srcsize < cbytes) {
        /* Not enough input to read compressed bytes */
        return BLOSC2_ERROR_READ_BUFFER;
      }
      srcsize -= cbytes;
    }
    src += sizeof(int32_t);
    ctbytes += (signed)sizeof(int32_t);

    /* Uncompress */
    if (cbytes == 0) {
      // A run of 0's
      memset(dest, 0, (unsigned int)neblock);
      nbytes = neblock;
    }
    else if (cbytes < 0) {
      // A negative number means some encoding depending on the token that comes next
      uint8_t token;

      if (srcsize < (signed)sizeof(uint8_t)) {
        // Not enough input to read token */
        return BLOSC2_ERROR_READ_BUFFER;
      }
      srcsize -= sizeof(uint8_t);

      token = src[0];
      src += 1;
      // Increment the total compressed bytes counter by 1 for the token
      // Check if the token indicates a run of non-zero bytes
      // If so, validate that the run length does not exceed a specific limit
      // Use the token to determine the byte value for the run and fill the destination buffer with it
      // Set decompressed bytes to the number of elements in the block
      // Ensure the compressed bytes for this stream is zeroed, as it is fully encoded in the token
      // <MASK>
    }
    else if (cbytes == neblock) {
      memcpy(dest, src, (unsigned int)neblock);
      nbytes = (int32_t)neblock;
    }
    else {
      if (compformat == BLOSC_BLOSCLZ_FORMAT) {
        nbytes = blosclz_decompress(src, cbytes, dest, (int)neblock);
      }
  #if defined(HAVE_LZ4)
      else if (compformat == BLOSC_LZ4_FORMAT) {
        nbytes = lz4_wrap_decompress((char*)src, (size_t)cbytes,
                                     (char*)dest, (size_t)neblock);
      }
  #endif /*  HAVE_LZ4 */
  #if defined(HAVE_SNAPPY)
      else if (compformat == BLOSC_SNAPPY_FORMAT) {
        nbytes = snappy_wrap_decompress((char*)src, (size_t)cbytes,
                                        (char*)dest, (size_t)neblock);
      }
  #endif /*  HAVE_SNAPPY */
  #if defined(HAVE_ZLIB)
      else if (compformat == BLOSC_ZLIB_FORMAT) {
        nbytes = zlib_wrap_decompress((char*)src, (size_t)cbytes,
                                      (char*)dest, (size_t)neblock);
      }
  #endif /*  HAVE_ZLIB */
  #if defined(HAVE_ZSTD)
      else if (compformat == BLOSC_ZSTD_FORMAT) {
        nbytes = zstd_wrap_decompress(context,
                                      (char*)src, (size_t)cbytes,
                                      (char*)dest, (size_t)neblock);
      }
  #endif /*  HAVE_ZSTD */
      else {
        compname = clibcode_to_clibname(compformat);
        BLOSC_TRACE_ERROR(
                "Blosc has not been compiled with decompression "
                "support for '%s' format.  "
                "Please recompile for adding this support.", compname);
        return BLOSC2_ERROR_CODEC_SUPPORT;
      }

      /* Check that decompressed bytes number is correct */
      if (nbytes != neblock) {
        return BLOSC2_ERROR_DATA;
      }

    }
    src += cbytes;
    ctbytes += cbytes;
    dest += nbytes;
    ntbytes += nbytes;
  } /* Closes j < nstreams */

  return ntbytes;
}


/* Compress a single chunk */
static int blosc_compress_chunk(blosc2_context* context, int32_t bsize,
                                int32_t leftoverblock, int32_t ntbytes,
                                const uint8_t* src, uint8_t* dest,
                                uint8_t* tmp, uint8_t* tmp2) {
  int32_t destsize = context->destsize;
  int32_t ctbytes = 0;
  int32_t typesize = context->typesize;
  int32_t nstreams;
  int32_t neblock;
  int32_t cbytes;
  int32_t maxout;
  int32_t accel;
  const char* compname;

  /* Calculate acceleration for different compressors */
  accel = get_accel(context);

  /* The number of compressed data streams for this