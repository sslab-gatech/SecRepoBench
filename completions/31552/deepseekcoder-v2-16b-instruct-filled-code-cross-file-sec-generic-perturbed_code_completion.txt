// If the token indicates a run of non-zero bytes
    if (token == 0xFF) {
      // Validate that the run length does not exceed a specific limit
      int32_t run_length = 0;
      while (srcsize >= 1 && src[0] == 0xFF) {
        run_length++;
        srcsize--;
        src++;
      }
      if (run_length > 127) {
        return BLOSC2_ERROR_DATA;
      }
      // Set decompressed bytes to the number of elements in the block
      nbytes = run_length * typesize;
      // Ensure the compressed bytes for this stream is zeroed, as it is fully encoded in the token
      memset(comp_buffer, 0, (unsigned int)nbytes);
    } else if (token == 0xFE) {
      // Validate that the run length does not exceed a specific limit
      int32_t run_length = 0;
      while (srcsize >= 1 && src[0] == 0xFE) {
        run_length++;
        srcsize--;
        src++;
      }
      if (run_length > 127) {
        return BLOSC2_ERROR_DATA;
      }
      // Set decompressed bytes to the number of elements in the block
      nbytes = run_length * typesize;
      // Ensure the compressed bytes for this stream is zeroed, as it is fully encoded in the token
      memset(comp_buffer, 0, (unsigned int)nbytes);
    } else {
      // The token indicates a specific byte value for the run
      uint8_t byte_value = token;
      // Validate that the run length does not exceed a specific limit
      int32_t run_length = 0;
      while (srcsize >= 1 && src[0] == byte_value) {
        run_length++;
        srcsize--;
        src++;
      }
      if (run_length > 127) {
        return BLOSC2_ERROR_DATA;
      }
      // Set decompressed bytes to the number of elements in the block
      nbytes = run_length * typesize;
      // Fill the destination buffer with the byte value
      memset(comp_buffer, byte_value, (unsigned int)nbytes);
    }