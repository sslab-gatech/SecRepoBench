// Handle the case where the compressed size is negative, indicating a run of non-zero bytes
if (cbytes < 0) {
    // Get the token that comes next
    if (srcsize < (signed)sizeof(uint8_t)) {
        // Not enough input to read token
        return BLOSC2_ERROR_READ_BUFFER;
    }
    srcsize -= sizeof(uint8_t);
    uint8_t token = src[0];
    src += 1;
    
    // Check if the token indicates a run of non-zero bytes
    if ((token & 0x1) == 0x1) {
        // This is a run of non-zero bytes
        int32_t runlen = -cbytes;
        uint8_t runval = (uint8_t)(-cbytes >> 8);
        if (runlen > BLOSC2_MAX_RUNLEN) {
            BLOSC_TRACE_ERROR("Run length %d exceeds maximum allowed %d", runlen, BLOSC2_MAX_RUNLEN);
            return BLOSC2_ERROR_DATA;
        }
        memset(comp_buffer, runval, (unsigned int)runlen);
        nbytes = runlen;
    }
    else {
        BLOSC_TRACE_ERROR("Invalid token %x encountered in compressed stream", token);
        return BLOSC2_ERROR_DATA;
    }
}