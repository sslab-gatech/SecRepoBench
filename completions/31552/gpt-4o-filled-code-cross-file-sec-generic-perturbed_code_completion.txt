// Increment the total compressed bytes counter by 1 for the token
      ctbytes += 1;

      // Check if the token indicates a run of non-zero bytes
      if (token & 0x80) {
        // The token indicates a run of non-zero bytes
        int run_length = token & 0x7F;  // Extract the run length from the token

        // Validate that the run length does not exceed the block size
        if (run_length > neblock) {
          return BLOSC2_ERROR_DATA;
        }

        // Use the token to determine the byte value for the run
        uint8_t run_value = src[0];
        src += 1;
        srcsize -= 1;
        ctbytes += 1;

        // Fill the destination buffer with the run value
        memset(comp_buffer, run_value, (unsigned int)run_length);
        nbytes = run_length;
      } else {
        // The token indicates a run of zeros
        int run_length = token;

        // Validate that the run length does not exceed the block size
        if (run_length > neblock) {
          return BLOSC2_ERROR_DATA;
        }

        // Fill the destination buffer with zeros
        memset(comp_buffer, 0, (unsigned int)run_length);
        nbytes = run_length;
      }

      // Ensure the compressed bytes for this stream is zeroed, as it is fully encoded in the token
      cbytes = 0;