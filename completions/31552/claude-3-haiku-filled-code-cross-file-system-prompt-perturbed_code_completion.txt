// Check if the token indicates a run of non-zero bytes
if (token == BLOSC_LITERAL_RUN) {
  // Validate that the run length does not exceed a specific limit
  if (srcsize < (signed)sizeof(uint8_t)) {
    // Not enough input to read run length
    return BLOSC2_ERROR_READ_BUFFER;
  }
  int32_t run_length = src[0];
  src += 1;
  srcsize -= sizeof(uint8_t);
  if (run_length > neblock) {
    // Run length exceeds block size
    return BLOSC2_ERROR_DATA;
  }
  // Use the token to determine the byte value for the run and fill the destination buffer with it
  uint8_t run_value = src[0];
  src += 1;
  srcsize -= sizeof(uint8_t);
  memset(comp_buffer, run_value, (unsigned int)run_length);
  nbytes = run_length;
  // Ensure the compressed bytes for this stream is zeroed, as it is fully encoded in the token
  cbytes = 0;
}
// Check if the token indicates a run of zero bytes
else if (token == BLOSC_ZERO_RUN) {
  // Validate that the run length does not exceed a specific limit
  if (srcsize < (signed)sizeof(uint8_t)) {
    // Not enough input to read run length
    return BLOSC2_ERROR_READ_BUFFER;
  }
  int32_t run_length = src[0];
  src += 1;
  srcsize -= sizeof(uint8_t);
  if (run_length > neblock) {
    // Run length exceeds block size
    return BLOSC2_ERROR_DATA;
  }
  // Fill the destination buffer with zeros
  memset(comp_buffer, 0, (unsigned int)run_length);
  nbytes = run_length;
  // Ensure the compressed bytes for this stream is zeroed, as it is fully encoded in the token
  cbytes = 0;
}
else {
  // The token is not recognized, return an error
  return BLOSC2_ERROR_DATA;
}