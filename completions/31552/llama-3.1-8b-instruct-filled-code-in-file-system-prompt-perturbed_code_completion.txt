// Return the value of the token that comes next
uint8_t token = src[0];
src += 1;
// Increment the total compressed bytes counter by 1 for the token
ctbytes += 1;
// Check if the token indicates a run of non-zero bytes
// If so, validate that the run length does not exceed a specific limit
// Use the token to determine the byte value for the run and fill the destination buffer with it
// Set decompressed bytes to the number of elements in the block
// Ensure the compressed bytes for this stream is zeroed, as it is fully encoded in the token
if (token == 0) {
  // A run of 0's
  memset(comp_buffer, 0, (unsigned int)neblock);
  nbytes = neblock;
}
else {
  // A run of non-zero bytes
  if (token > 0) {
    // Mark the encoding as a run-length (== 0 is always a 0's run)
    ntbytes += 1;
    ctbytes += 1;
  }
  else {
    // Mark the encoding as a run-length (== 0 is always a 0's run)
    ntbytes += 1;
    ctbytes += 1;
  }
  // Set MSB bit (sign) to 1 (not really necessary here, but for demonstration purposes)
  // dest[-1] |= 0x80;
  dest[0] = 0x1;   // set run-length bit (0) in token
  dest += 1;
  // Fill the destination buffer with the repeated byte
  for (int i = 0; i < neblock; i++) {
    comp_buffer[i] = token;
  }
  nbytes = neblock;
}