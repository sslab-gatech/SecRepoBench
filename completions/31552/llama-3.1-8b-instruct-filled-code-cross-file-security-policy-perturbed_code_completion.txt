} else if (cbytes < 0) {
  // A negative number means some encoding depending on the token that comes next
  uint8_t token;

  if (srcsize < (signed)sizeof(uint8_t)) {
    // Not enough input to read token */
    return BLOSC2_ERROR_READ_BUFFER;
  }
  srcsize -= sizeof(uint8_t);

  token = src[0];
  src += 1;
  // Increment the total compressed bytes counter by 1 for the token
  // Check if the token indicates a run of non-zero bytes
  // If so, validate that the run length does not exceed a specific limit
  // Use the token to determine the byte value for the run and fill the destination buffer with it
  // Set decompressed bytes to the number of elements in the block
  // Ensure the compressed bytes for this stream is zeroed, as it is fully encoded in the token
  if (token == BLOSC_RUN_TOKEN) {
    // Run of non-zero bytes
    int run_length = -cbytes;
    if (run_length > BLOSC_MAX_RUN_LENGTH) {
      // Run length exceeds the limit
      return BLOSC2_ERROR_DATA;
    }
    uint8_t byte_value = src[0];
    src += 1;
    srcsize -= 1;
    memset(comp_buffer, byte_value, (unsigned int)neblock);
    nbytes = neblock;
  } else if (token == BLOSC_RUN_STOP_TOKEN) {
    // Run of zero bytes
    memset(comp_buffer, 0, (unsigned int)neblock);
    nbytes = neblock;
  } else if (token == BLOSC_RUN_REPEAT_TOKEN) {
    // Run of repeated bytes
    int run_length = -cbytes;
    if (run_length > BLOSC_MAX_RUN_LENGTH) {
      // Run length exceeds the limit
      return BLOSC2_ERROR_DATA;
    }
    uint8_t byte_value = src[0];
    src += 1;
    srcsize -= 1;
    memset(comp_buffer, byte_value, (unsigned int)neblock);
    nbytes = neblock;
  } else {
    // Invalid token
    return BLOSC2_ERROR_DATA;
  }
  // Increment the total compressed bytes counter by 1 for the token
  ctbytes += 1;
  // Ensure the compressed bytes for this stream is zeroed, as it is fully encoded in the token
  cbytes = 0;
}