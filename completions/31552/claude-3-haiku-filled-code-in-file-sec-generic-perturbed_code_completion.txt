// Handle runlen
if (cbytes < 0) {
  // A negative number means some encoding depending on the token that comes next
  uint8_t token;

  if (srcsize < (signed)sizeof(uint8_t)) {
    // Not enough input to read token
    return BLOSC2_ERROR_READ_BUFFER;
  }
  srcsize -= sizeof(uint8_t);

  token = src[0];
  src += 1;
  // Increment the total compressed bytes counter by 1 for the token
  ctbytes += 1;

  // Check if the token indicates a run of non-zero bytes
  if ((token & 0x1) == 0x1) {
    // A run of non-zero bytes
    int32_t runlen = -cbytes;
    uint8_t runval = src[0];
    src += 1;
    srcsize -= 1;
    ctbytes += 1;

    // Validate that the run length does not exceed a specific limit
    if (runlen > BLOSC2_MAX_RUNLEN) {
      BLOSC_TRACE_ERROR("Run length %d exceeds maximum allowed.", runlen);
      return BLOSC2_ERROR_DATA;
    }

    // Use the token to determine the byte value for the run and fill the destination buffer with it
    memset(comp_buffer, runval, (unsigned int)runlen);
    nbytes = runlen;
  }
  else {
    // A run of zeros
    int32_t runlen = -cbytes;

    // Validate that the run length does not exceed a specific limit
    if (runlen > BLOSC2_MAX_RUNLEN) {
      BLOSC_TRACE_ERROR("Run length %d exceeds maximum allowed.", runlen);
      return BLOSC2_ERROR_DATA;
    }

    memset(comp_buffer, 0, (unsigned int)runlen);
    nbytes = runlen;
  }
  // Set decompressed bytes to the number of elements in the block
  cbytes = 0;
}