ctbytes += 1;  // Increment for the token byte

// Check if token indicates a run of non-zero bytes
if (token != 0) {
  // The run length is encoded in the negative cbytes value
  int runlen = -cbytes;  

  // Validate that run length doesn't exceed buffer limits
  if (runlen > neblock) {
    return BLOSC2_ERROR_WRITE_BUFFER;
  }

  // Fill destination with token value repeated runlen times
  memset(comp_buffer, token, (unsigned int)runlen);
  nbytes = runlen;
} else {
  // Token 0 is invalid in this context
  return BLOSC2_ERROR_DATA;
}

// Reset cbytes as it's fully encoded in the token
cbytes = 0;