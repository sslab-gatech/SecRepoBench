// Check if the token indicates a run of non-zero bytes
// If so, validate that the run length does not exceed a specific limit
// Use the token to determine the byte value for the run and fill the destination buffer with it
// Set decompressed bytes to the number of elements in the block
// Ensure the compressed bytes for this stream is zeroed, as it is fully encoded in the token
if (token >= 128) {
  int runlength = token & 0x3f;  // 6 least significant bits
  if (runlength == 0) {
    // runlength is extended
    if (srcsize < (signed)sizeof(uint8_t)) {
      // Not enough input to read extended token */
      return BLOSC2_ERROR_READ_BUFFER;
    }
    srcsize -= sizeof(uint8_t);
    uint8_t ext_token = src[0];
    src += 1;
    runlength = 64 + (token & 0x3f) + ext_token;
  }
  if (runlength > neblock) {
    return BLOSC2_ERROR_DATA;
  }
  uint8_t bytevalue = token >> 6;  // 2 most significant bits
  memset(comp_buffer, bytevalue, (unsigned int)runlength);
  nbytes = runlength;
  ctbytes = 0;  // all the compressed bytes are encoded in the token
}