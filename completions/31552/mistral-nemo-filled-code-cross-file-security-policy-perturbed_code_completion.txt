if (cbytes < 0) {
    // A negative number means some encoding depending on the token that comes next
    uint8_t token;

    if (srcsize < (signed)sizeof(uint8_t)) {
      // Not enough input to read token */
      return BLOSC2_ERROR_READ_BUFFER;
    }
    srcsize -= sizeof(uint8_t);

    token = src[0];
    src += 1;
    // Increment the total compressed bytes counter by 1 for the token
    // Check if the token indicates a run of non-zero bytes
    if (token == BLOSC_RUN_TOKEN) {
      if (srcsize < (signed)sizeof(int32_t)) {
        // Not enough input to read run length
        return BLOSC2_ERROR_READ_BUFFER;
      }
      srcsize -= sizeof(int32_t);
      int32_t run_length = sw32_(src);
      src += sizeof(int32_t);
      if (run_length < 0 || run_length > neblock) {
        // Invalid run length
        return BLOSC2_ERROR_DATA;
      }
      uint8_t run_value = src[0];
      src += 1;
      memset(comp_buffer, run_value, (unsigned int)run_length);
      nbytes = run_length;
      // Ensure the compressed bytes for this stream is zeroed, as it is fully encoded in the token
      cbytes = 0;
    }
    else if (token == BLOSC_ZERO_TOKEN) {
      // A run of zero bytes
      memset(comp_buffer, 0, (unsigned int)neblock);
      nbytes = neblock;
      // Ensure the compressed bytes for this stream is zeroed, as it is fully encoded in the token
      cbytes = 0;
    }
    else {
      // Invalid token
      return BLOSC2_ERROR_DATA;
    }
  }