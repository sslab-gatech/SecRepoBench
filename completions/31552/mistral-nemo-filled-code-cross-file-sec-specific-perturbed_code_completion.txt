if (cbytes < 0) {
    // A negative number means some encoding depending on the token that comes next
    uint8_t token;

    if (srcsize < (signed)sizeof(uint8_t)) {
      // Not enough input to read token
      return BLOSC2_ERROR_READ_BUFFER;
    }
    srcsize -= sizeof(uint8_t);

    token = src[0];
    src += 1;
    // Increment the total compressed bytes counter by 1 for the token
    // Check if the token indicates a run of non-zero bytes
    if ((token & 0x80) != 0) {
      // If so, validate that the run length does not exceed a specific limit
      int run_length = token & 0x7F;
      if (run_length > neblock) {
        return BLOSC2_ERROR_DATA;
      }
      // Use the token to determine the byte value for the run and fill the destination buffer with it
      uint8_t byte_value = token & 0x0F;
      memset(comp_buffer, byte_value, (unsigned int)run_length);
      nbytes = run_length;
    }
    else {
      // The token indicates a run of zero bytes
      memset(comp_buffer, 0, (unsigned int)neblock);
      nbytes = neblock;
    }
    // Ensure the compressed bytes for this stream is zeroed, as it is fully encoded in the token
    cbytes = 0;
  }