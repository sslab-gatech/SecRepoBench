//
// Update code lengths and symbol processing for Huffman decoding.
// - For each symbol, determine its code length.
// - If the code length is non-zero and less than a predefined threshold,
//   update minimum and maximum code lengths and increment the count for that length.
// - If the code length indicates a short zero-code run, adjust the symbol index accordingly.
// - If it indicates a long zero-code run, read additional bits for the run length,
//   then adjust the symbol index by this computed length.
//

uint64_t codeLength =
    fasthuf_read_bits (6, &currBits, &currBitCount, &currByte);

if (codeLength < (uint64_t) 64) // predefined threshold
{
    if (codeLength > 0)
    {
        if (codeLength < fhd->_minCodeLength)
        {
            fhd->_minCodeLength = codeLength;
        }

        if (codeLength > fhd->_maxCodeLength)
        {
            fhd->_maxCodeLength = codeLength;
        }

        codeCount[codeLength]++;
    }
    else
    {
        if (codeLength == 0)
        {
            if (rleSymbol == 0)
            {
                symbol -= 1;
            }
            else
            {
                symbol += fasthuf_read_bits (8, &currBits, &currBitCount, &currByte);
            }
        }
        else
        {
            if (codeLength == 59)
            {
                symbol -= 1;
            }
            else if (codeLength == 60)
            {
                symbol -= 2;
            }
            else if (codeLength == 61)
            {
                symbol -= 3;
            }
            else if (codeLength == 62)
            {
                symbol -= 4;
            }
            else if (codeLength == 63)
            {
                symbol -= fasthuf_read_bits (8, &currBits, &currBitCount, &currByte) + 4;
            }
        }
    }
}
else
{
    symbol += codeLength - 63;
}