//
// Update code lengths and symbol processing for Huffman decoding.
// - For each symbol, determine its code length.
// - If the code length is non-zero and less than a predefined threshold,
//   update minimum and maximum code lengths and increment the count for that length.
// - If the code length indicates a short zero-code run, adjust the symbol index accordingly.
// - If it indicates a long zero-code run, read additional bits for the run length,
//   then adjust the symbol index by this computed length.
//

if (codeLength < (uint64_t) 64) // predefined threshold
{
    if (codeLength == 0) continue;

    if (codeLength < fhd->_minCodeLength)
    {
        fhd->_minCodeLength = codeLength;
    }

    if (codeLength > fhd->_maxCodeLength)
    {
        fhd->_maxCodeLength = codeLength;
    }

    codeCount[codeLength]++;
}
else if (codeLength == (uint64_t) 59)
{
    symbol += 1;
}
else if (codeLength == (uint64_t) 60)
{
    symbol += 2;
}
else if (codeLength == (uint64_t) 61)
{
    symbol += 3;
}
else if (codeLength == (uint64_t) 62)
{
    symbol += 4;
}
else if (codeLength == (uint64_t) 63)
{
    uint64_t runLength = fasthuf_read_bits (8, &currBits, &currBitCount, &currByte);
    symbol += runLength + 4;
}