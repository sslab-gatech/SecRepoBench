// Update code lengths and symbol processing for Huffman decoding.
// - For each symbol, determine its code length.
// - If the code length is non-zero and less than a predefined threshold,
//   update minimum and maximum code lengths and increment the count for that length.
// - If the code length indicates a short zero-code run, adjust the symbol index accordingly.
// - If it indicates a long zero-code run, read additional bits for the run length,
//   then adjust the symbol index by this computed length.
if (codeLength < (uint64_t) SHORT_ZEROCODE_RUN)
{
    if (codeLength == 0) continue;

    if (codeLength < fhd->_minCodeLength)
        fhd->_minCodeLength = (unsigned char) codeLength;
    if (codeLength > fhd->_maxCodeLength)
        fhd->_maxCodeLength = (unsigned char) codeLength;
    codeCount[codeLength]++;
    fhd->_idToSymbol[mapping[codeLength]] = symbol;
    mapping[codeLength]++;
}
else if (codeLength == (uint64_t) LONG_ZEROCODE_RUN)
{
    uint64_t runLength = fasthuf_read_bits(8, &currBits, &currBitCount, &currByte) + SHORTEST_LONG_RUN;
    symbol += runLength - 1;
}
else
{
    symbol += codeLength - SHORT_ZEROCODE_RUN + 1;
}