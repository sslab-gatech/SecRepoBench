// Update code lengths and symbol processing for Huffman decoding.
        // - For each symbol, determine its code length.
        // - If the code length is non-zero and less than a predefined threshold,
        //   update minimum and maximum code lengths and increment the count for that length.
        // - If the code length indicates a short zero-code run, adjust the symbol index accordingly.
        // - If it indicates a long zero-code run, read additional bits for the run length,
        //   then adjust the symbol index by this computed length.

        if (codeLength == 0)
        {
            if (codeLength < fhd->_minCodeLength) fhd->_minCodeLength = codeLength;
            if (codeLength > fhd->_maxCodeLength) fhd->_maxCodeLength = codeLength;
            codeCount[codeLength]++;
        }
        else if (codeLength < SHORT_ZEROCODE_RUN)
        {
            if (codeLength < fhd->_minCodeLength) fhd->_minCodeLength = codeLength;
            if (codeLength > fhd->_maxCodeLength) fhd->_maxCodeLength = codeLength;
            codeCount[codeLength]++;
        }
        else if (codeLength == LONG_ZEROCODE_RUN)
        {
            uint64_t runLength = fasthuf_read_bits (8, &currBits, &currBitCount, &currByte) + SHORTEST_LONG_RUN - 1;
            symbol += runLength;
        }
        else
        {
            symbol += codeLength - SHORT_ZEROCODE_RUN + 1;
        }