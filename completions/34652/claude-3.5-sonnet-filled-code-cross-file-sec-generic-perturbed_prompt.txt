Below is the content of a C/C++ function where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
int
mrb_format_float(mrb_float f, char *buf, size_t buf_size, char fmt, int prec, char sign) {
  char *s = buf;
  int buf_remaining = buf_size - 1;
  int alt_form = 0;

  if ((uint8_t)fmt & 0x80) {
    fmt &= 0x7f;  /* turn off alt_form flag */
    alt_form = 1;
  }
  if (buf_size <= FLT_MIN_BUF_SIZE) {
    // Smallest exp notion is -9e+99 (-9e+199) which is 6 (7) chars plus terminating
    // null.

    if (buf_size >= 2) {
      *s++ = '?';
    }
    if (buf_size >= 1) {
      *s++ = '\0';
    }
    return buf_size >= 2;
  }
  if (signbit(f)) {
    *s++ = '-';
    f = -f;
  } else if (sign) {
    *s++ = sign;
  }
  buf_remaining -= (s - buf); // Adjust for sign

  {
    char uc = fmt & 0x20;
    if (isinf(f)) {
      *s++ = 'I' ^ uc;
      *s++ = 'N' ^ uc;
      *s++ = 'F' ^ uc;
      goto ret;
    } else if (isnan(f)) {
      *s++ = 'N' ^ uc;
      *s++ = 'A' ^ uc;
      *s++ = 'N' ^ uc;
    ret:
      *s = '\0';
      return s - buf;
    }
  }

  if (prec < 0) {
    prec = 6;
  }
  char e_char = 'E' | (fmt & 0x20);   // e_char will match case of fmt
  fmt |= 0x20; // Force fmt to be lowercase
  char originalformat = fmt;
  if (fmt == 'g' && prec == 0) {
    prec = 1;
  }
  int e, e1;
  int dec = 0;
  char e_sign = '\0';
  int num_digits = 0;
  const mrb_float *pos_pow = g_pos_pow;
  const mrb_float *neg_pow = g_neg_pow;

  if (f == 0.0) {
    e = 0;
    if (fmt == 'e') {
      e_sign = '+';
    } else if (fmt == 'f') {
      num_digits = prec + 1;
    }
  } else if (f < 1.0) { // f < 1.0
    char first_dig = '0';
    if (f >= FLT_ROUND_TO_ONE) {
      first_dig = '1';
    }

    // Build negative exponent
    for (e = 0, e1 = FLT_DECEXP; e1; e1 >>= 1, pos_pow++, neg_pow++) {
      if (*neg_pow > f) {
        e += e1;
        f *= *pos_pow;
      }
    }
    char e_sign_char = '-';
    if (f < 1.0) {
      if (f >= FLT_ROUND_TO_ONE) {
        f = 1.0;
        if (e == 0) {
          e_sign_char = '+';
        }
      } else {
        e++;
        f *= 10.0;
      }
    }

    // If the user specified 'g' format, and e is <= 4, then we'll switch
    // to the fixed format ('f')

    if (fmt == 'f' || (fmt == 'g' && e <= 4)) {
      fmt = 'f';
      dec = -1;
      *s++ = first_dig;

      // Adjust the precision to prevent buffer overflow while formatting a float.
      // Depending on the original format ('g'), it modifies precision based on the
      // exponent value 'e'. If the format is 'g', increases precision by (e - 1).
      // <MASK>
      num_digits = prec;
      if (num_digits || alt_form) {
        *s++ = '.';
        while (--e && num_digits) {
          *s++ = '0';
          num_digits--;
        }
      }
    } else {
      // For e & g formats, we'll be printing the exponent, so set the
      // sign.
      e_sign = e_sign_char;
      dec = 0;

      if (prec > (buf_remaining - FLT_MIN_BUF_SIZE)) {
        prec = buf_remaining - FLT_MIN_BUF_SIZE;
        if (fmt == 'g') {
          prec++;
        }
      }
    }
  } else {
    // Build positive exponent
    for (e = 0, e1 = FLT_DECEXP; e1; e1 >>= 1, pos_pow++, neg_pow++) {
      if (*pos_pow <= f) {
        e += e1;
        f *= *neg_pow;
      }
    }

    // If the user specified fixed format (fmt == 'f') and e makes the
    // number too big to fit into the available buffer, then we'll
    // switch to the 'e' format.

    if (fmt == 'f') {
      if (e >= buf_remaining) {
        fmt = 'e';
      } else if ((e + prec + 2) > buf_remaining) {
        prec = buf_remaining - e - 2;
        if (prec < 0) {
          // This means no decimal point, so we can add one back
          // for the decimal.
          prec++;
        }
      }
    }
    if (fmt == 'e' && prec > (buf_remaining - 6)) {
      prec = buf_remaining - 6;
    }
    // If the user specified 'g' format, and e is < prec, then we'll switch
    // to the fixed format.

    if (fmt == 'g' && e < prec) {
      fmt = 'f';
      prec -= (e + 1);
    }
    if (fmt == 'f') {
      dec = e;
      num_digits = prec + e + 1;
    } else {
      e_sign = '+';
    }
  }
  if (prec < 0) {
    // This can happen when the prec is trimmed to prevent buffer overflow
    prec = 0;
  }

  // We now have f as a floating point number between >= 1 and < 10
  // (or equal to zero), and e contains the absolute value of the power of
  // 10 exponent. and (dec + 1) == the number of dgits before the decimal.

  // For e, prec is # digits after the decimal
  // For f, prec is # digits after the decimal
  // For g, prec is the max number of significant digits
  //
  // For e & g there will be a single digit before the decimal
  // for f there will be e digits before the decimal

  if (fmt == 'e') {
    num_digits = prec + 1;
  } else if (fmt == 'g') {
    if (prec == 0) {
      prec = 1;
    }
    num_digits = prec;
  }

  // Print the digits of the mantissa
  for (int i = 0; i < num_digits; ++i, --dec) {
    int8_t d = f;
    *s++ = '0' + d;
    if (dec == 0 && (prec > 0 || alt_form)) {
      *s++ = '.';
    }
    f -= (mrb_float)d;
    f *= 10.0;
  }

  // Round
  if (f >= 5.0) {
    char *rs = s;
    rs--;
    while (1) {
      if (*rs == '.') {
        rs--;
        continue;
      }
      if (*rs < '0' || *rs > '9') {
        // + or -
        rs++; // So we sit on the digit to the right of the sign
        break;
      }
      if (*rs < '9') {
        (*rs)++;
        break;
      }
      *rs = '0';
      if (rs == buf) {
        break;
      }
      rs--;
    }
    if (*rs == '0') {
      // We need to insert a 1
      if (rs[1] == '.' && fmt != 'f') {
        // We're going to round 9.99 to 10.00
        // Move the decimal point
        rs[0] = '.';
        rs[1] = '0';
        if (e_sign == '-') {
          e--;
        } else {
          e++;
        }
      }
      s++;
      char *ss = s;
      while (ss > rs) {
        *ss = ss[-1];
        ss--;
      }
      *rs = '1';
      if (f < 1.0 && fmt == 'f') {
        // We rounded up to 1.0
        prec--;
      }
    }
  }

  if (originalformat == 'g' && prec > 0 && !alt_form) {
    // Remove trailing zeros and a trailing decimal point
    while (s[-1] == '0') {
      s--;
    }
    if (s[-1] == '.') {
      s--;
    }
  }
  // Append the exponent
  if (e_sign) {
    *s++ = e_char;
    *s++ = e_sign;
    if (e >= 100) {
      *s++ = '0' + (e / 100);
      e %= 100;
    }
    *s++ = '0' + (e / 10);
    *s++ = '0' + (e % 10);
  }
  *s = '\0';

  return s - buf;
}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// mrbgems/mruby-sprintf/src/sprintf.c
static void
check_next_arg(mrb_state *mrb, int posarg, int nextarg)
{
  switch (posarg) {
  case -1:
    mrb_raisef(mrb, E_ARGUMENT_ERROR, "unnumbered(%d) mixed with numbered", nextarg);
    break;
  case -2:
    mrb_raisef(mrb, E_ARGUMENT_ERROR, "unnumbered(%d) mixed with named", nextarg);
    break;
  default:
    break;
  }
}

// the below code fragment can be found in:
// mrbgems/mruby-sprintf/src/sprintf.c
void
mrb_mruby_sprintf_gem_init(mrb_state *mrb)
{
  struct RClass *krn = mrb->kernel_module;
  mrb_define_module_function(mrb, krn, "sprintf", mrb_f_sprintf, MRB_ARGS_ANY());
  mrb_define_module_function(mrb, krn, "format",  mrb_f_sprintf, MRB_ARGS_ANY());
}

// the below code fragment can be found in:
// src/fmt_fp.c
MRB_API mrb_value
mrb_float_to_str(mrb_state *mrb, mrb_value flo)
{
  char buf[25];
#ifdef MRB_USE_FLOAT32
  const int prec =  7;
#else
  const int prec =  15;
#endif

  mrb_format_float(mrb_float(flo), buf, sizeof(buf), 'g', prec, '\0');
  for (char *p = buf; *p; p++) {
    if (*p == '.') goto exit;
    if (*p == 'e') {
      memmove(p+2, p, strlen(p)+1);
      memcpy(p, ".0", 2);
      goto exit;
    }
  }
  strcat(buf, ".0");
 exit:
  return mrb_str_new_cstr(mrb, buf);
}

// the below code fragment can be found in:
// src/strtod.c
MRB_API double
mrb_float_read(const char *str, char **end)
{
  double d = 0.0;
  int sign;
  int n = 0;
  const char *p, *a;

  a = p = str;
  while (ISSPACE(*p))
    ++p;

  /* decimal part */
  sign = 1;
  if (*p == '-') {
    sign = -1;
    ++p;
  } else if (*p == '+')
    ++p;
  if (ISDIGIT(*p)) {
    d = (double)(*p++ - '0');
    while (*p && ISDIGIT(*p)) {
      d = d * 10.0 + (double)(*p - '0');
      ++p;
      ++n;
    }
    a = p;
  } else if (*p != '.')
    goto done;
  d *= sign;

  /* fraction part */
  if (*p == '.') {
    double f = 0.0;
    double base = 0.1;
    ++p;

    if (ISDIGIT(*p))
      {
        while (*p && ISDIGIT(*p)) {
          f += base * (*p - '0') ;
          base /= 10.0;
          ++p;
          ++n;
        }
      }
    d += f * sign;
    a = p;
  }

  /* exponential part */
  if ((*p == 'E') || (*p == 'e')) {
    int e = 0;
    ++p;

    sign = 1;
    if (*p == '-') {
      sign = -1;
      ++p;
    } else if (*p == '+')
      ++p;

    if (ISDIGIT(*p)) {
      while (*p == '0')
        ++p;
      if (*p == '\0') --p;
      e = (int)(*p++ - '0');
      for (; *p && ISDIGIT(*p); p++) {
        if (e < 10000)
          e = e * 10 + (*p - '0');
      }
      e *= sign;
    }
    else if (!ISDIGIT(*(a-1))) {
      a = str;
      goto done;
    }
    else if (*p == 0)
      goto done;
    d *= pow(10.0, (double) e);
    a = p;
  }
  else if (p > str && !ISDIGIT(*(p-1))) {
    a = str;
    goto done;
  }

done:
  if (end)
    *end = (char*)a;
  return d;
}

// the below code fragment can be found in:
// mrbgems/mruby-string-ext/src/string.c
static mrb_value
mrb_str_succ(mrb_state *mrb, mrb_value self)
{
  mrb_value str;

  str = mrb_str_dup(mrb, self);
  mrb_str_succ_bang(mrb, str);
  return str;
}
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).