if (LocaleNCompare("hex:",lookup_pattern,4) == 0)
  {
    // Retrieve pixel information from the image.
    // Acquire a new FxInfo instance using the specified pattern starting after the prefix "hex:".
    // Evaluate the red, green, and blue channel expressions, storing the results in respective pixel channels.
    // Scale the evaluated channel values to the QuantumRange and assign them to the pixel structure.
    // <MASK>
    const char
      *string;

    Image
      *image;

    PixelInfo
      pixel;

    ssize_t
      x,
      y;

    assert(image!= (Image *) NULL);
    assert(image->signature == MagickCoreSignature);
    if (image->debug!= MagickFalse)
      (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
    image=AcquireImageByUUID(image_info->image,exception);
    if (image == (Image *) NULL)
      {
        (void) ThrowMagickException(exception,GetMagickModule(),ResourceLimitError,
          "MemoryAllocationFailed","`%s'",lookup_pattern);
        return((char *) NULL);
      }
    GetPixelInfo(image,&pixel);
    string=GetImageProperty(image,lookup_pattern+4,exception);
    if (string == (char *) NULL)
      {
        (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
          "UnknownImageProperty","\"%%[%s]\"",lookup_pattern);
        return((char *) NULL);
      }
    if (LocaleCompare("red",string) == 0)
      {
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            pixel.red=(double) QuantumRange*GetPixelRed(image,x,y,exception);
          }
        }
      }
    else
      if (LocaleCompare("green",string) == 0)
        {
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              pixel.green=(double) QuantumRange*GetPixelGreen(image,x,y,exception);
            }
          }
        }
      else
        if (LocaleCompare("blue",string) == 0)
          {
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              for (x=0; x < (ssize_t) image->columns; x++)
              {
                pixel.blue=(double) QuantumRange*GetPixelBlue(image,x,y,exception);
              }
            }
          }
        else
          if (LocaleCompare("alpha",string) == 0)
            {
              for (y=0; y < (ssize_t) image->rows; y++)
              {
                for (x=0; x < (ssize_t) image->columns; x++)
                {
                  pixel.alpha=(double) QuantumRange*GetPixelAlpha(image,x,y,exception);
                }
              }
            }
          else
            if (LocaleCompare("all",string) == 0)
              {
                for (y=0; y < (ssize_t) image->rows; y++)
                {
                  for (x=0; x < (ssize_t) image->columns; x++)
                  {
                    pixel.red=(double) QuantumRange*GetPixelRed(image,x,y,exception);
                    pixel.green=(double) QuantumRange*GetPixelGreen(image,x,y,exception);
                    pixel.blue=(double) QuantumRange*GetPixelBlue(image,x,y,exception);
                    pixel.alpha=(double) QuantumRange*GetPixelAlpha(image,x,y,exception);
                  }
                }
              }
            else
              {
                (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
                  "UnknownImageProperty","\"%%[%s]\"",lookup_pattern);
                return((char *) NULL);
              }
    string=FormatLocaleString((char *) NULL,MagickPathExtent,"%02x%02x%02x%02x",
      (unsigned int) (pixel.red/QuantumRange*255),
      (unsigned int) (pixel.green/QuantumRange*255),
      (unsigned int) (pixel.blue/QuantumRange*255),
      (unsigned int) (pixel.alpha/QuantumRange*255));
    AppendString2Text(string);
    image=DestroyImage(image);
    return((char *) NULL);
  }