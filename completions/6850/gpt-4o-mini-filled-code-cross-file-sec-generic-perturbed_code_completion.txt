double red, green, blue;
          FxInfo *fx_info;

          // Acquire a new FxInfo instance using the specified pattern starting after the prefix "hex:".
          fx_info = AcquireFxInfo(image, lookup_pattern + 4, exception);
          if (fx_info == (FxInfo *) NULL)
            continue; // Handle error in acquiring FxInfo

          // Evaluate the red, green, and blue channel expressions, storing the results in respective pixel channels.
          MagickBooleanType status = MagickTrue;
          status &= FxEvaluateChannelExpression(fx_info, RedPixelChannel, 0, 0, &red, exception);
          status &= FxEvaluateChannelExpression(fx_info, GreenPixelChannel, 0, 0, &green, exception);
          status &= FxEvaluateChannelExpression(fx_info, BluePixelChannel, 0, 0, &blue, exception);

          // Scale the evaluated channel values to the QuantumRange and assign them to the pixel structure.
          if (status != MagickFalse)
          {
            PixelInfo pixel;
            pixel.red = (double)QuantumRange * red;
            pixel.green = (double)QuantumRange * green;
            pixel.blue = (double)QuantumRange * blue;
            pixel.alpha = QuantumRange; // Assuming full opacity

            char name[MagickPathExtent];
            (void)QueryColorname(image, &pixel, SVGCompliance, name, exception);
            AppendString2Text(name);
          }
          fx_info = DestroyFxInfo(fx_info); // Clean up FxInfo