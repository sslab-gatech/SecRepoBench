// <MASK>
  if (LocaleCompare("hex:",lookup_pattern,4) == 0)
    {
      // Retrieve pixel information from the image.
      // Acquire a new FxInfo instance using the specified pattern starting after the prefix "hex:".
      // Evaluate the red, green, and blue channel expressions, storing the results in respective pixel channels.
      // Scale the evaluated channel values to the QuantumRange and assign them to the pixel structure.
      // <MASK>
      FxInfo
        *fx_info;

      MagickStatusType
        status;

      PixelInfo
        pixel;

      register const Quantum
        *p;

      register ssize_t
        x,
        y;

      if (image == (Image *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),
            OptionWarning,"NoImageForProperty","\"%%[%s]\"",lookup_pattern);
          continue; /* else no image to retrieve artifact */
        }
      fx_info=AcquireFxInfo(image,lookup_pattern+4,exception);
      if (fx_info == (FxInfo *) NULL)
        continue;
      p=GetCacheViewVirtualPixels(image_view,0,0,image->columns,image->rows,exception);
      if (p == (const Quantum *) NULL)
        {
          fx_info=DestroyFxInfo(fx_info);
          continue;
        }
      for (y=0; y < (ssize_t) image->rows; y++)
      {
        for (x=0; x < (ssize_t) image->columns; x++)
        {
          status=FxEvaluateChannelExpression(fx_info,RedPixelChannel,x,y,
            &pixel.red,exception);
          if (status == MagickFalse)
            break;
          status&=FxEvaluateChannelExpression(fx_info,GreenPixelChannel,x,y,
            &pixel.green,exception);
          if (status == MagickFalse)
            break;
          status&=FxEvaluateChannelExpression(fx_info,BluePixelChannel,x,y,
            &pixel.blue,exception);
          if (status == MagickFalse)
            break;
          pixel.red=(double) QuantumRange*pixel.red;
          pixel.green=(double) QuantumRange*pixel.green;
          pixel.blue=(double) QuantumRange*pixel.blue;
          if (image->colorspace == CMYKColorspace)
            {
              status&=FxEvaluateChannelExpression(fx_info,BlackPixelChannel,x,y,
                &pixel.black,exception);
              if (status == MagickFalse)
                break;
              pixel.black=(double) QuantumRange*pixel.black;
            }
          p+=GetPixelChannels(image);
        }
        if (x < (ssize_t) image->columns)
          break;
      }
      fx_info=DestroyFxInfo(fx_info);
      if (status == MagickFalse)
        continue;
      if (image->colorspace == CMYKColorspace)
        {
          (void) ConcatenateMagickString(value,"k",MagickPathExtent);
          (void) FormatLocaleString(value+strlen(value),MagickPathExtent,"%.*g",
            GetMagickPrecision(),(double) pixel.black);
        }
      (void) FormatLocaleString(value+strlen(value),MagickPathExtent,"%.*g",
        GetMagickPrecision(),(double) pixel.red);
      (void) ConcatenateMagickString(value,",",MagickPathExtent);
      (void) FormatLocaleString(value+strlen(value),MagickPathExtent,"%.*g",
        GetMagickPrecision(),(double) pixel.green);
      (void) ConcatenateMagickString(value,",",MagickPathExtent);
      (void) FormatLocaleString(value+strlen(value),MagickPathExtent,"%.*g",
        GetMagickPrecision(),(double) pixel.blue);
      continue;
    }