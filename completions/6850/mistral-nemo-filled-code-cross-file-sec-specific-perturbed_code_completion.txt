// <MASK>
  if (LocaleCompare("hex:",lookup_pattern,4) == 0)
    {
      // Retrieve pixel information from the image.
      // Acquire a new FxInfo instance using the specified pattern starting after the prefix "hex:".
      // Evaluate the red, green, and blue channel expressions, storing the results in respective pixel channels.
      // Scale the evaluated channel values to the QuantumRange and assign them to the pixel structure.
      FxInfo
        *fx_info;

      MagickStatusType
        status;

      PixelInfo
        pixel;

      register const Quantum
        *p;

      register ssize_t
        x,
        y;

      fx_info=AcquireFxInfo(image,lookup_pattern+4,exception);
      if (fx_info == (FxInfo *) NULL)
        break;
      p=GetCacheViewVirtualPixels(image_view,0,0,image->columns,image->rows,exception);
      if (p == (const Quantum *) NULL)
        break;
      for (y=0; y < (ssize_t) image->rows; y++)
      {
        for (x=0; x < (ssize_t) image->columns; x++)
        {
          status=FxEvaluateChannelExpression(fx_info,RedPixelChannel,x,y,&pixel.red,exception);
          if (status == MagickFalse)
            break;
          status&=FxEvaluateChannelExpression(fx_info,GreenPixelChannel,x,y,&pixel.green,exception);
          if (status == MagickFalse)
            break;
          status&=FxEvaluateChannelExpression(fx_info,BluePixelChannel,x,y,&pixel.blue,exception);
          if (status == MagickFalse)
            break;
          if (image->colorspace == CMYKColorspace)
            status&=FxEvaluateChannelExpression(fx_info,BlackPixelChannel,x,y,&pixel.black,exception);
          if (status == MagickFalse)
            break;
          status&=FxEvaluateChannelExpression(fxInfo,AlphaPixelChannel,x,y,&pixel.alpha,exception);
          if (status == MagickFalse)
            break;
          pixel.red=(double) QuantumRange*pixel.red;
          pixel.green=(double) QuantumRange*pixel.green;
          pixel.blue=(double) QuantumRange*pixel.blue;
          if (image->colorspace == CMYKColorspace)
            pixel.black=(double) QuantumRange*pixel.black;
          pixel.alpha=(double) QuantumRange*pixel.alpha;
          p+=GetPixelChannels(image);
        }
        if (x < (ssize_t) image->columns)
          break;
      }
      fx_info=DestroyFxInfo(fx_info);
      if (status == MagickFalse)
        break;
      if (image->colorspace == CMYKColorspace)
        {
          (void) FormatLocaleString(value,MagickPathExtent,"%.*g%.*g%.*g%.*g%.*g",
            GetMagickPrecision(),(double) pixel.red,GetMagickPrecision(),
            (double) pixel.green,GetMagickPrecision(),(double) pixel.blue,
            GetMagickPrecision(),(double) pixel.black,GetMagickPrecision(),
            (double) pixel.alpha);
        }
      else
        {
          (void) FormatLocaleString(value,MagickPathExtent,"%.*g%.*g%.*g%.*g",
            GetMagickPrecision(),(double) pixel.red,GetMagickPrecision(),
            (double) pixel.green,GetMagickPrecision(),(double) pixel.blue,
            GetMagickPrecision(),(double) pixel.alpha);
        }
      break;
    }
// </MASK>