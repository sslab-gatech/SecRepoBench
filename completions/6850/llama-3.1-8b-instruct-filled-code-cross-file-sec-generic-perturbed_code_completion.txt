if (LocaleNCompare("hex:",lookup_pattern,4) == 0)
{
  // Retrieve pixel information from the image.
  // Acquire a new FxInfo instance using the specified pattern starting after the prefix "hex:".
  // Evaluate the red, green, and blue channel expressions, storing the results in respective pixel channels.
  // <MASK>
  const char
    *string;

  Image
    *image;

  ExceptionInfo
    *exception;

  PixelInfo
    pixel;

  ssize_t
    x,
    y;

  assert(image!= (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug!= MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
  image=AcquireImageByUUID(image_info->image,exception);
  if (image == (Image *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),ResourceLimitError,
        "MemoryAllocationFailed","`%s'",lookup_pattern);
      return((char *) NULL);
    }
  GetPixelInfo(image,&pixel);
  string=AcquireString(image->filename);
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    for (x=0; x < (ssize_t) image->columns; x++)
    {
      PixelPacket
        pixel_packet;

      pixel_packet.red=GetPixelRed(image,x,y);
      pixel_packet.green=GetPixelGreen(image,x,y);
      pixel_packet.blue=GetPixelBlue(image,x,y);
      pixel_packet.alpha=GetPixelAlpha(image,x,y);
      (void) FormatLocaleString(string,MagickPathExtent,"%02x%02x%02x%02x",
        (unsigned int) pixel_packet.red,
        (unsigned int) pixel_packet.green,
        (unsigned int) pixel_packet.blue,
        (unsigned int) pixel_packet.alpha);
    }
  }
  image=DestroyImage(image);
  return(string);
}