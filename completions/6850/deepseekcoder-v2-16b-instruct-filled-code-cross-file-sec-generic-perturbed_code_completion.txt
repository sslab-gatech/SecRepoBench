if (LocaleNCompare("hex:",lookup_pattern,4) == 0)
        {
          // Retrieve pixel information from the image.
          // Acquire a new FxInfo instance using the specified pattern starting after the prefix "hex:".
          // Evaluate the red, green, and blue channel expressions, storing the results in respective pixel channels.
          // Scale the evaluated channel values to the QuantumRange and assign them to the pixel structure.
          FxInfo *fx_info;
          MagickStatusType status;
          PixelInfo pixel;

          p++;  // advance p to just inside the opening brace
          depth = 1;
          if (*p == ']')
          {
            (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
              "UnknownImageProperty","\"%%[]\"");
            break;
          }
          for (len = 0; len < (MagickPathExtent - 1L) && (*p != '\0');)
          {
            if ((*p == '\\') && (*(p + 1) != '\0'))
            {
              // Skip escaped braces within braced pattern.
              lookup_pattern[len++] = (*p++);
              lookup_pattern[len++] = (*p++);
              continue;
            }
            if (*p == '[')
              depth++;
            if (*p == ']')
              depth--;
            if (depth <= 0)
              break;
            lookup_pattern[len++] = (*p++);
          }
          lookup_pattern[len] = '\0';
          if (depth != 0)
          {
            // Check for unmatched final ']' for "%[...]".
            if (len >= 64)
            {
              lookup_pattern[61] = '.';  // truncate string for error message
              lookup_pattern[62] = '.';
              lookup_pattern[63] = '.';
              lookup_pattern[64] = '\0';
            }
            (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
              "UnbalancedBraces","\"%%[%s\"",lookup_pattern);
            interpret_text = DestroyString(interpret_text);
            return((char *) NULL);
          }
          // Special Lookup Prefixes %[prefix:...].
          if (LocaleNCompare("fx:", lookup_pattern, 3) == 0)
          {
            // FX - value calculator.
            if (image == (Image *) NULL)
            {
              (void) ThrowMagickException(exception,GetMagickModule(),
                OptionWarning, "NoImageForProperty", "\"%%[%s]\"", lookup_pattern);
              continue; // else no image to retrieve artifact
            }
            fx_info = AcquireFxInfo(image, lookup_pattern + 3, exception);
            status = FxEvaluateChannelExpression(fx_info, IntensityPixelChannel, 0, 0,
              &value, exception);
            fx_info = DestroyFxInfo(fx_info);
            if (status != MagickFalse)
            {
              char result[MagickPathExtent];
              (void) FormatLocaleString(result, MagickPathExtent, "%.*g",
                GetMagickPrecision(), (double) value);
              AppendString2Text(result);
            }
            continue;
          }
          if (LocaleNCompare("pixel:", lookup_pattern, 6) == 0)
          {
            double value;
            FxInfo *fx_info;
            MagickStatusType status;
            PixelInfo pixel;

            if (image == (Image *) NULL)
            {
              (void) ThrowMagickException(exception, GetMagickModule(),
                OptionWarning, "NoImageForProperty", "\"%%[%s]\"", lookup_pattern);
              continue; // else no image to retrieve artifact
            }
            GetPixelInfo(image, &pixel);
            fx_info = AcquireFxInfo(image, lookup_pattern + 6, exception);
            status = FxEvaluateChannelExpression(fx_info, RedPixelChannel, 0, 0,
              &value, exception);
            pixel.red = (double) QuantumRange * value;
            status &= FxEvaluateChannelExpression(fx_info, GreenPixelChannel, 0, 0,
              &value, exception);
            pixel.green = (double) QuantumRange * value;
            status &= FxEvaluateChannelExpression(fx_info, BluePixelChannel, 0, 0,
              &value, exception);
            pixel.blue = (double) QuantumRange * value;
            if (image->colorspace == CMYKColorspace)
            {
              status &= FxEvaluateChannelExpression(fx_info, BlackPixelChannel, 0, 0,
                &value, exception);
              pixel.black = (double) QuantumRange * value;
            }
            status &= FxEvaluateChannelExpression(fx_info, AlphaPixelChannel, 0, 0,
              &value, exception);
            pixel.alpha = (double) QuantumRange * value;
            fx_info = DestroyFxInfo(fx_info);
            if (status != MagickFalse)
            {
              char name[MagickPathExtent];
              (void) QueryColorname(image, &pixel, SVGCompliance, name, exception);
              AppendString2Text(name);
            }
            continue;
          }
        }