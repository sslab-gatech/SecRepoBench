if (LocaleNCompare("hex:",lookup_pattern,4) == 0)
{
  // Retrieve pixel information from the image.
  // Acquire a new FxInfo instance using the specified pattern starting after the prefix "hex:".
  FxInfo
    *fx_info;

  MagickBooleanType
    status;

  PixelInfo
    pixel;

  register const char
    *q;

  register ssize_t
    x;

  /*
    Hex - pixel color calculator.
  */
  if (image == (Image *) NULL )
    {
      (void) ThrowMagickException(exception,GetMagickModule(),
        OptionWarning,"NoImageForProperty","\"%%[%s]\"",lookup_pattern);
      continue; /* else no image to retrieve artifact */
    }
  GetPixelInfo(image,&pixel);
  fx_info=AcquireFxInfo(image,lookup_pattern+4,exception);
  status=MagickTrue;
#if defined(MAGICKCORE_OPENMP_SUPPORT)
  #pragma omp parallel for schedule(static,4) shared(status,pixel) \
    magick_number_threads(image,image,image->rows,1)
#endif
  for (x=0; x < (ssize_t) image->columns; x++)
  {
    double
      value;

    if (status == MagickFalse)
      continue;
    value=0.0;
    if (FxEvaluateChannelExpression(fx_info,RedPixelChannel,(ssize_t) x,(ssize_t) 0,&value,exception) != MagickFalse)
      pixel.red=(double) QuantumRange*value;
    else
      status=MagickFalse;
    value=0.0;
    if (FxEvaluateChannelExpression(fx_info,GreenPixelChannel,(ssize_t) x,(ssize_t) 0,&value,exception) != MagickFalse)
      pixel.green=(double) QuantumRange*value;
    else
      status=MagickFalse;
    value=0.0;
    if (FxEvaluateChannelExpression(fx_info,BluePixelChannel,(ssize_t) x,(ssize_t) 0,&value,exception) != MagickFalse)
      pixel.blue=(double) QuantumRange*value;
    else
      status=MagickFalse;
    if (image->colorspace == CMYKColorspace)
      {
        value=0.0;
        if (FxEvaluateChannelExpression(fx_info,BlackPixelChannel,(ssize_t) x,(ssize_t) 0,&value,exception) != MagickFalse)
          pixel.black=(double) QuantumRange*value;
        else
          status=MagickFalse;
      }
    value=0.0;
    if (FxEvaluateChannelExpression(fx_info,AlphaPixelChannel,(ssize_t) x,(ssize_t) 0,&value,exception) != MagickFalse)
      pixel.alpha=(double) QuantumRange*value;
    else
      status=MagickFalse;
    if (q != interpret_text)
      {
        char
          name[MagickPathExtent];

        (void) QueryColorname(image,&pixel,SVGCompliance,name,exception);
        q=AppendString2Text(q,name);
      }
  }
  fx_info=DestroyFxInfo(fx_info);
  if (status != MagickFalse)
    continue;
}