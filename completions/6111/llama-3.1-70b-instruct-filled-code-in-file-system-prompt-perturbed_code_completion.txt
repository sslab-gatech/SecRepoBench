// Initialize necessary variables and structures for processing Postscript images.
// Open the input image file and create a symbolic link to it for processing.
// Initialize an array to map hex characters to their integer values.
// Set the page density for the image based on the provided resolution or default values.
// Determine the page geometry using the Postscript bounding box comments.
// Initialize various variables including color space, resolution, and page dimensions.
// Create a control file for Ghostscript to render the Postscript image.
// Use the Ghostscript delegate to render the Postscript into a raster format.
// Read the rendered images and append them to the image list, handling profiles if necessary.
// Clean up and return the processed image list, handling any errors that occur.

// Initialize necessary variables and structures for processing Postscript images.
int
  columns,
  rows,
  scene,
  x,
  y;

const char
  *density,
  *options;

const DelegateInfo
  *delegate_info;

double
  x_resolution,
  y_resolution;

Image
  *image,
  *next,
  *postscript_image;

ImageInfo
  *read_info;

MagickBooleanType
  status;

MagickOffsetType
  offset;

MagickStatusType
  flags;

short int
  hex_digits[256];

// Open the input image file and create a symbolic link to it for processing.
status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
if (status == MagickFalse)
  return(MagickFalse);

// Initialize an array to map hex characters to their integer values.
for (x=0; x < 256; x++)
  hex_digits[x]=0;
for (x='0'; x <= '9'; x++)
  hex_digits[x]=x-'0';
for (x='A'; x <= 'F'; x++)
  hex_digits[x]=x-'A'+10;
for (x='a'; x <= 'f'; x++)
  hex_digits[x]=x-'a'+10;

// Set the page density for the image based on the provided resolution or default values.
density=image_info->density;
if (density == (const char *) NULL)
  density=PSDensityGeometry;
flags=ParseGeometry(density,&geometry_info);
x_resolution=geometry_info.rho;
y_resolution=geometry_info.sigma;
if ((flags & SigmaValue) == 0)
  y_resolution=x_resolution;

// Determine the page geometry using the Postscript bounding box comments.
columns=0;
rows=0;
while ((c=ReadBlobByte(image))!= EOF)
{
  if (c == '%')
    {
      (void) ReadBlobString(image,buffer,MagickPathExtent);
      if ((LocaleCompare(buffer,"%%BoundingBox:") == 0) ||
          (LocaleCompare(buffer,"%%HiResBoundingBox:") == 0))
        {
          (void) ReadBlobString(image,buffer,MagickPathExtent);
          (void) sscanf(buffer,"%lg %lg %lg %lg",&bounds.x1,&bounds.y1,&bounds.x2,
            &bounds.y2);
          columns=(int) floor(bounds.x2-bounds.x1+0.5);
          rows=(int) floor(bounds.y2-bounds.y1+0.5);
          break;
        }
    }
}

// Initialize various variables including color space, resolution, and page dimensions.
if (columns == 0)
  columns=image->columns;
if (rows == 0)
  rows=image->rows;
if (image->colorspace == CMYKColorspace)
  {
    (void) TransformImageColorspace(image,sRGBColorspace,exception);
    image->colorspace=sRGBColorspace;
  }
if ((x_resolution == 0.0) || (y_resolution == 0.0))
  {
    x_resolution=image->resolution.x;
    y_resolution=image->resolution.y;
  }
if (image->units == PixelsPerCentimeterResolution)
  {
    x_resolution=(double) ((size_t) (100.0*2.54*x_resolution+0.5)/100.0);
    y_resolution=(double) ((size_t) (100.0*2.54*y_resolution+0.5)/100.0);
  }

// Create a control file for Ghostscript to render the Postscript image.
offset=TellBlob(image);
if (offset == 0)
  {
    (void) CopyMagickString(command,MagickPathExtent,"gs -q -dBATCH -dNOPAUSE -r");
    (void) FormatLocaleString(buffer,MagickPathExtent,"%.20gx%.20g",x_resolution,
      y_resolution);
    (void) ConcatenateMagickString(command,buffer,MagickPathExtent);
    (void) ConcatenateMagickString(command," -sDEVICE=png16m -sOutputFile=%02d.png",
      MagickPathExtent);
  }
else
  {
    (void) CopyMagickString(command,MagickPathExtent,"gs -q -dBATCH -dNOPAUSE -r");
    (void) FormatLocaleString(buffer,MagickPathExtent,"%.20gx%.20g",x_resolution,
      y_resolution);
    (void) ConcatenateMagickString(command,buffer,MagickPathExtent);
    (void) ConcatenateMagickString(command," -sDEVICE=png16m -sOutputFile=%02d.png",
      MagickPathExtent);
    (void) ConcatenateMagickString(command," -dFirstPage=",MagickPathExtent);
    (void) FormatLocaleString(buffer,MagickPathExtent,"%lu",(unsigned long)
      (offset/72));
    (void) ConcatenateMagickString(command,buffer,MagickPathExtent);
    (void) ConcatenateMagickString(command," -dLastPage=",MagickPathExtent);
    (void) FormatLocaleString(buffer,MagickPathExtent,"%lu",(unsigned long)
      ((offset+rows*72-1)/72));
    (void) ConcatenateMagickString(command,buffer,MagickPathExtent);
  }
(void) ConcatenateMagickString(command," -sPAPERSIZE=",MagickPathExtent);
(void) ConcatenateMagickString(command,PSPageGeometry,MagickPathExtent);
(void) ConcatenateMagickString(command," -f ",MagickPathExtent);
(void) ConcatenateMagickString(command,filename,MagickPathExtent);

// Use the Ghostscript delegate to render the Postscript into a raster format.
status=InvokePostscriptDelegate(MagickFalse,command,message,exception);
if (status == MagickFalse)
  return(MagickFalse);

// Read the rendered images and append them to the image list, handling profiles if necessary.
postscript_image=(Image *) NULL;
for (x=0; x < rows; x++)
{
  (void) FormatLocaleString(input_filename,MagickPathExtent,"%02d.png",x);
  read_info=CloneImageInfo(image_info);
  (void) CopyMagickString(read_info->filename,input_filename,MagickPathExtent);
  read_info->compression=NoCompression;
  read_info->quality=100;
  image=ReadImage(read_info,exception);
  if (image == (Image *) NULL)
    {
      read_info=DestroyImageInfo(read_info);
      return(MagickFalse);
    }
  read_info=DestroyImageInfo(read_info);
  if (IsPostscriptRendered(input_filename) == MagickFalse)
    {
      image=DestroyImage(image);
      return(MagickFalse);
    }
  (void) RemoveFile(input_filename);
  if (postscript_image == (Image *) NULL)
    postscript_image=image;
  else
    {
      next=GetNextImageInList(postscript_image);
      if (next == (Image *) NULL)
        {
          next=image;
          postscript_image->next=next;
        }
      else
        {
          while (GetNextImageInList(next)!= (Image *) NULL)
            next=GetNextImageInList(next);
          next->next=image;
        }
    }
}

// Clean up and return the processed image list, handling any errors that occur.
do
{
  (void) CopyMagickString(postscript_image->filename,filename,
    MagickPathExtent);
  (void) CopyMagickString(postscript_image->magick,image->magick,
    MagickPathExtent);
  if (columns!= 0)
    postscript_image->magick_columns=columns;
  if (rows!= 0)
    postscript_image->magick_rows=rows;
  postscript_image->page=page;
  (void) CloneImageProfiles(postscript_image,image);
  (void) CloneImageProperties(postscript_image,image);
  next=SyncNextImageInList(postscript_image);
  if (next!= (Image *) NULL)
    postscript_image=next;
} while (next!= (Image *) NULL);
image=DestroyImageList(image);
scene=0;
for (next=GetFirstImageInList(postscript_image); next!= (Image *) NULL; )
{
  next->scene=scene++;
  next=GetNextImageInList(next);
}
return(GetFirstImageInList(postscript_image));