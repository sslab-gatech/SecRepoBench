// Initialize necessary variables and structures for processing Postscript images.
// Open the input image file and create a symbolic link to it for processing.
// Initialize an array to map hex characters to their integer values.
// Set the page density for the image based on the provided resolution or default values.
// Determine the page geometry using the Postscript bounding box comments.
// Initialize various variables including color space, resolution, and page dimensions.
// Create a control file for Ghostscript to render the Postscript image.
// Use the Ghostscript delegate to render the Postscript into a raster format.
// Read the rendered images and append them to the image list, handling profiles if necessary.
// Clean up and return the processed image list, handling any errors that occur.

// Initialize necessary variables and structures for processing Postscript images.
int
  columns,
  rows,
  scene,
  status;

size_t
  page;

// Open the input image file and create a symbolic link to it for processing.
status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
if (status == MagickFalse)
  return(MagickFalse);

// Initialize an array to map hex characters to their integer values.
short int
  hex_digits[256];

for (i=0; i < 256; i++)
  hex_digits[i]=-1;
for (i=0; i < 16; i++)
{
  hex_digits[(int) ('0'+i)]=i;
  hex_digits[(int) ('A'+i)]=i;
  hex_digits[(int) ('a'+i)]=i;
}

// Set the page density for the image based on the provided resolution or default values.
const char
  *density;

density=image_info->density;
if (density == (const char *) NULL)
  density=PSDensityGeometry;

// Determine the page geometry using the Postscript bounding box comments.
const char
  *option;

option=GetImageOption(image_info,"page");
if (option == (const char *) NULL)
  option=PSPageGeometry;

// Initialize various variables including color space, resolution, and page dimensions.
Image
  *postscript_image;

postscript_image=image;
columns=0;
rows=0;
page=1;
scene=0;

// Create a control file for Ghostscript to render the Postscript image.
char
  command[MagickPathExtent],
  filename[MagickPathExtent],
  geometry[MagickPathExtent],
  input_filename[MagickPathExtent],
  message[MagickPathExtent],
  *options,
  postscript_filename[MagickPathExtent];

(void) CopyMagickString(filename,image_info->filename,MagickPathExtent);
(void) CopyMagickString(input_filename,filename,MagickPathExtent);
(void) CopyMagickString(postscript_filename,filename,MagickPathExtent);
(void) ConcatenateMagickString(postscript_filename,".ps",MagickPathExtent);
(void) CopyMagickString(geometry,option,MagickPathExtent);
(void) ConcatenateMagickString(geometry,">",MagickPathExtent);
(void) ParseMetaGeometry(geometry,&postscript_image->page.x,&postscript_image->page.y,
  &postscript_image->page.width,&postscript_image->page.height);
(void) FormatLocaleString(command,MagickPathExtent,
  "gswin64c -q -dNOPAUSE -dBATCH -dSAFER -sDEVICE=png16m -dTextAlphaBits=%d "
  "-dGraphicsAlphaBits=%d -r%d -sOutputFile=%s %s -c \"%%dBCPPDF resourcefile "
  "where { pop } { %%dBCPPDF resourcefile /#defineresource where { pop } "
  "def  } ifelse %%dBCPPDF startjasper -dNOPAUSE -dBATCH -dSAFER -sDEVICE=inkcov "
  "-dTextAlphaBits=%d -dGraphicsAlphaBits=%d -r%d -sOutputFile=%s -f %%dBCPPDF "
  "endjasper %%dBCPPDF resourcefile where { pop } { %%dBCPPDF resourcefile /#defineresource "
  "where { pop } def  } ifelse %%dBCPPDF startjasper -dNOPAUSE -dBATCH -dSAFER "
  "-sDEVICE=inkcov -dTextAlphaBits=%d -dGraphicsAlphaBits=%d -r%d -sOutputFile=%s "
  "-f %%dBCPPDF endjasper %%dBCPPDF resourcefile where { pop } { %%dBCPPDF "
  "resourcefile /#defineresource where { pop } def  } ifelse %%dBCPPDF startjasper "
  "-dNOPAUSE -dBATCH -dSAFER -sDEVICE=inkcov -dTextAlphaBits=%d -dGraphicsAlphaBits=%d "
  "-r%d -sOutputFile=%s -f %%dBCPPDF endjasper %%dBCPPDF resourcefile where { pop } "
  "{ %%dBCPPDF resourcefile /#defineresource where { pop } def  } ifelse %%dBCPPDF "
  "startjasper -dNOPAUSE -dBATCH -dSAFER -sDEVICE=inkcov -dTextAlphaBits=%d "
  "-dGraphicsAlphaBits=%d -r%d -sOutputFile=%s -f %%dBCPPDF endjasper quit",
  image->matte!= MagickFalse? 4 : 1,image->matte!= MagickFalse? 4 : 1,
  image_info->resolution,image->filename,density,image->matte!= MagickFalse? 4 : 1,
  image->matte!= MagickFalse? 4 : 1,image_info->resolution,input_filename,
  image->matte!= MagickFalse? 4 : 1,image->matte!= MagickFalse? 4 : 1,
  image_info->resolution,input_filename,image->matte!= MagickFalse? 4 : 1,
  image->matte!= MagickFalse? 4 : 1,image_info->resolution,input_filename,
  image->matte!= MagickFalse? 4 : 1,image->matte!= MagickFalse? 4 : 1,
  image_info->resolution,input_filename);

// Use the Ghostscript delegate to render the Postscript into a raster format.
status=InvokePostscriptDelegate(MagickFalse,command,message,exception);
if (status == MagickFalse)
  return(MagickFalse);

// Read the rendered images and append them to the image list, handling profiles if necessary.
do
{
  (void) CopyMagickString(postscript_image->filename,filename,
    MagickPathExtent);
  (void) CopyMagickString(postscript_image->magick,image->magick,
    MagickPathExtent);
  if (columns!= 0)
    postscript_image->magick_columns=columns;
  if (rows!= 0)
    postscript_image->magick_rows=rows;
  postscript_image->page=page;
  (void) CloneImageProfiles(postscript_image,image);
  (void) CloneImageProperties(postscript_image,image);
  next=SyncNextImageInList(postscript_image);
  if (next!= (Image *) NULL)
    postscript_image=next;
} while (next!= (Image *) NULL);

// Clean up and return the processed image list, handling any errors that occur.
image=DestroyImageList(image);
scene=0;
for (next=GetFirstImageInList(postscript_image); next!= (Image *) NULL; )
{
  next->scene=scene++;
  next=GetNextImageInList(next);
}
return(GetFirstImageInList(postscript_image));