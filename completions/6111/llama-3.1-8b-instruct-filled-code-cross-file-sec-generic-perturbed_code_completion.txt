// <MASK>
do
{
  (void) CopyMagickString(postscript_image->filename,filename,
    MagickPathExtent);
  (void) CopyMagickString(postscript_image->magick,image->magick,
    MagickPathExtent);
  if (columns!= 0)
    postscript_image->magick_columns=columns;
  if (rows!= 0)
    postscript_image->magick_rows=rows;
  postscript_image->page=page;
  (void) CloneImageProfiles(postscript_image,image);
  (void) CloneImageProperties(postscript_image,image);
  next=SyncNextImageInList(postscript_image);
  if (next!= (Image *) NULL)
    postscript_image=next;
} while (next!= (Image *) NULL);
image=DestroyImageList(image);
scene=0;
for (next=GetFirstImageInList(postscript_image); next!= (Image *) NULL; )
{
  next->scene=scene++;
  next=GetNextImageInList(next);
}
// Register the Postscript image format
MagickInfo
  *entry;

entry=AcquireMagickInfo("PS","PS","PostScript");
entry->decoder=(DecodeImageHandler *) ReadPSImage;
entry->encoder=(EncodeImageHandler *) WritePSImage;
entry->magick=(IsImageFormatHandler *) IsPS;
entry->flags^=CoderBlobSupportFlag;
entry->flags^=CoderDecoderThreadSupportFlag;
(void) RegisterMagickInfo(entry);
// Register the EPS image format
entry=AcquireMagickInfo("EPS","EPS","Encapsulated PostScript");
entry->decoder=(DecodeImageHandler *) ReadPSImage;
entry->encoder=(EncodeImageHandler *) WritePSImage;
entry->magick=(IsImageFormatHandler *) IsEPS;
entry->flags^=CoderBlobSupportFlag;
entry->flags^=CoderDecoderThreadSupportFlag;
(void) RegisterMagickInfo(entry);
return(GetFirstImageInList(postscript_image));