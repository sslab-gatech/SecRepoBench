#define BoundingBoxPattern  "%*s %lf %lf %lf %lf"
#define HiresBoundingBoxPattern  "%*s %lf %lf %lf %lf"

  char
    command[MagickPathExtent],
    *density,
    filename[MagickPathExtent],
    geometry[MagickPathExtent],
    input_filename[MagickPathExtent],
    message[MagickPathExtent],
    *options,
    postscript_filename[MagickPathExtent];

  const char
    *option;

  const DelegateInfo
    *delegate_info;

  GeometryInfo
    geometry_info;

  Image
    *image,
    *next,
    *postscript_image;

  ImageInfo
    *read_info;

  int
    c,
    filedescriptor;

  MagickBooleanType
    status;

  MagickStatusType
    flags;

  PointInfo
    delta,
    resolution,
    scale;

  RectangleInfo
    page;

  ssize_t
    i;

  short int
    hex_digits[256];

  size_t
    columns,
    height,
    rows,
    scene,
    width;

  ssize_t
    count;

  unsigned long
    lsb_first;

  double
    bounding_box[4];

  size_t
    magick_size;

  FILE
    *file;

  MagickOffsetType
    file_offset;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image_info->filename);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);
  if (status == MagickFalse)
    {
      ThrowFileException(exception,FileOpenError,"UnableToCreateTemporaryFile",
        image_info->filename);
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Initialize hex values.
  */
  for (i=0; i < 256; i++)
    hex_digits[i]=(short) (-1);
  for (i=0; i <= 9; i++)
    hex_digits['0' + i]=(short) i;
  for (i=10; i <= 15; i++)
    {
      hex_digits['A' + i - 10]=(short) i;
      hex_digits['a' + i - 10]=(short) i;
    }
  /*
    Set the page density.
  */
  delta.x=DefaultResolution;
  delta.y=DefaultResolution;
  if (image_info->density != (char *) NULL)
    {
      flags=ParseGeometry(image_info->density,&geometry_info);
      resolution.x=geometry_info.rho;
      resolution.y=geometry_info.sigma;
      if ((flags & SigmaValue) == 0)
        resolution.y=resolution.x;
    }
  else
    {
      resolution.x=72.0;
      resolution.y=72.0;
    }
  /*
    Determine page geometry from the Postscript bounding box.
  */
  (void) ResetMagickMemory(bounding_box,0,sizeof(bounding_box));
  (void) ResetMagickMemory(&page,0,sizeof(page));
  (void) ResetMagickMemory(command,0,sizeof(command));
  count=0;
  file_offset=0;
  c=0;
  columns=0;
  rows=0;
  for (i=0; i < 2048; i++)
  {
    c=ReadBlobByte(image);
    if (c == EOF)
      break;
    if (c != (int) '%')
      continue;
    count=(ssize_t) ReadBlob(image,sizeof(command)-1,(unsigned char *) command);
    if (count <= 0)
      break;
    command[count]='\0';
    if (LocaleNCompare(command,"BoundingBox:",11) == 0)
      {
        count=(ssize_t) sscanf(command+11,"%lf %lf %lf %lf",&bounding_box[0],
          &bounding_box[1],&bounding_box[2],&bounding_box[3]);
        if (count != 4)
          count=0;
      }
    else
      if (LocaleNCompare(command,"HiResBoundingBox:",16) == 0)
        {
          count=(ssize_t) sscanf(command+16,"%lf %lf %lf %lf",&bounding_box[0],
            &bounding_box[1],&bounding_box[2],&bounding_box[3]);
          if (count != 4)
            count=0;
        }
    if (count != 0)
      break;
  }
  if ((count != 4) || (fabs(bounding_box[2]-bounding_box[0]) < MagickEpsilon) ||
      (fabs(bounding_box[3]-bounding_box[1]) < MagickEpsilon))
    {
      bounding_box[0]=0.0;
      bounding_box[1]=0.0;
      bounding_box[2]=612.0;
      bounding_box[3]=792.0;
    }
  /*
    Create Ghostscript control file.
  */
  file=AcquireUniqueFileResource(postscript_filename);
  if (file == (FILE *) NULL)
    {
      (void) RelinquishUniqueFileResource(input_filename);
      ThrowReaderException(FileOpenError,"UnableToCreateTemporaryFile");
    }
  (void) fprintf(file,"%%!PS-Adobe-3.0\n");
  (void) fprintf(file,"/ReencodeType\n");
  (void) fprintf(file,"{\n");
  (void) fprintf(file,"  findfont dup length 5 add dict begin\n");
  (void) fprintf(file,"  { 1 index /FID ne { def } { pop pop } ifelse }\n");
  (void) fprintf(file,"  forall /Encoding exch def currentdict end\n");
  (void) fprintf(file,"  definefont pop\n");
  (void) fprintf(file,"} bind def\n");
  (void) fprintf(file,"/Resolution %g def\n",resolution.x);
  (void) fprintf(file,"/Prologue {\n");
  (void) fprintf(file,"  /Latin1 ISOLatin1Encoding /Times-Roman ReencodeType\n");
  (void) fprintf(file,"  /Times-Roman findfont\n");
  (void) fprintf(file,"  currentdict /PaintType known {/PaintType 0 def} if\n");
  (void) fprintf(file,"  setfont newpath moveto\n");
  (void) fprintf(file,"} bind def\n");
  (void) fprintf(file,"%g %g translate\n",
    -bounding_box[0],-bounding_box[1]);
  (void) fprintf(file,"%%%%BoundingBox: %g %g %g %g\n",0.0,0.0,
    bounding_box[2]-bounding_box[0],bounding_box[3]-bounding_box[1]);
  (void) fprintf(file,"%%%%EndComments\n");
  (void) fprintf(file,"%%%%BeginProlog\n");
  (void) fprintf(file,"%%%%EndProlog\n");
  if (GetBlobSize(image) <= 0x00ffffff)
    {
      unsigned char
        *blob;

      blob=GetBlobStreamData(image);
      if (blob != (unsigned char *) NULL)
        (void) fwrite(blob,GetBlobSize(image),1,file);
      else
        {
          (void) CloseBlob(image);
          RelinquishUniqueFileResource(postscript_filename);
          RelinquishUniqueFileResource(input_filename);
          ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
        }
    }
  else
    {
      ssize_t
        count;

      unsigned char
        buffer[MagickMinBufferExtent];

      (void) SeekBlob(image,0,SEEK_SET);
      while ((count=ReadBlob(image,sizeof(buffer),buffer)) > 0)
        (void) fwrite(buffer,(size_t) count,1,file);
    }
  (void) fprintf(file,"\nshowpage\n");
  (void) fprintf(file,"%%%%Trailer\n");
  if (ferror(file) != 0)
    {
      (void) fclose(file);
      (void) CloseBlob(image);
      RelinquishUniqueFileResource(postscript_filename);
      RelinquishUniqueFileResource(input_filename);
      ThrowReaderException(FileOpenError,"UnableToWriteFile");
    }
  (void) fclose(file);
  (void) CloseBlob(image);
  /*
    Use Ghostscript to convert Postscript image.
  */
  (void) AcquireUniqueFilename(filename);
  /*
    Render Postscript with the Ghostscript delegate.
  */
  read_info=CloneImageInfo(image_info);
  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,
    (void *) NULL);
  (void) CopyMagickString(read_info->magick,"PS",MagickPathExtent);
  page.width=(size_t) ((bounding_box[2]-bounding_box[0])*
    resolution.x/delta.x+0.5);
  page.height=(size_t) ((bounding_box[3]-bounding_box[1])*
    resolution.y/delta.y+0.5);
  if (page.width == 0)
    page.width=1;
  if (page.height == 0)
    page.height=1;
  (void) FormatLocaleString(geometry,MagickPathExtent,"%.20gx%.20g",
    (double) page.width,(double) page.height);
  (void) CloneString(&read_info->size,geometry);
  density=AcquireString("");
  (void) FormatLocaleString(density,MagickPathExtent,"%gx%g",
    resolution.x,resolution.y);
  (void) CloneString(&read_info->density,density);
  density=DestroyString(density);
  read_info->page=page;
  if (read_info->text == MagickFalse)
    (void) FormatLocaleString(command,MagickPathExtent,
      "-sDEVICE=ppmraw -dTextAlphaBits=%d -dGraphicsAlphaBits=%d "
      "-r%.20gx%.20g ",image_info->texture == 0 ? 4 : (int) image_info->texture,
      image_info->texture == 0 ? 4 : (int) image_info->texture,resolution.x,
      resolution.y);
  else
    (void) FormatLocaleString(command,MagickPathExtent,
      "-sDEVICE=pnmraw -r%.20gx%.20g ",resolution.x,resolution.y);
  options=StringInfoToString(GetBlobSignature(image));
  if (options != (char *) NULL)
    {
      char
        *value;

      value=GetPolicyValue("ghostscript/thread-limit");
      if (value != (char *) NULL)
        {
          (void) FormatLocaleString(command+strlen(command),
            MagickPathExtent,"-dNumRenderingThreads=%s ",value);
          value=DestroyString(value);
        }
      options=DestroyString(options);
    }
  delegate_info=GetDelegateInfo("ps:alpha",(char *) NULL,exception);
  if (delegate_info != (const DelegateInfo *) NULL)
    {
      (void) FormatLocaleString(command+strlen(command),MagickPathExtent,
        "-dGraphicsAlphaBits=%d -dTextAlphaBits=%d ",image_info->texture == 0 ?
        4 : (int) image_info->texture,image_info->texture == 0 ? 4 : (int)
        image_info->texture);
    }
  option=GetImageOption(image_info,"ps:use-cropbox");
  if ((option != (const char *) NULL) &&
      (IsStringTrue(option) != MagickFalse))
    (void) ConcatenateMagickString(command,"-dEPSCrop ",MagickPathExtent);
  else
    {
      option=GetImageOption(image_info,"ps:use-trimbox");
      if ((option != (const char *) NULL) &&
          (IsStringTrue(option) != MagickFalse))
        (void) ConcatenateMagickString(command,"-dPSTrimBox ",
          MagickPathExtent);
      else
        {
          option=GetImageOption(image_info,"ps:use-bleedbox");
          if ((option != (const char *) NULL) &&
              (IsStringTrue(option) != MagickFalse))
            (void) ConcatenateMagickString(command,"-dPSBleedBox ",
              MagickPathExtent);
          else
            {
              option=GetImageOption(image_info,"ps:use-artbox");
              if ((option != (const char *) NULL) &&
                  (IsStringTrue(option) != MagickFalse))
                (void) ConcatenateMagickString(command,"-dPSArtBox ",
                  MagickPathExtent);
            }
        }
    }
  (void) FormatLocaleString(command+strlen(command),MagickPathExtent,
    "-sOutputFile=%s -f%s",filename,postscript_filename);
  status=InvokePostscriptDelegate(read_info->verbose,command,message,exception);
  (void) RelinquishUniqueFileResource(postscript_filename);
  postscript_image=(Image *) NULL;
  if (status == MagickFalse)
    {
      (void) RelinquishUniqueFileResource(filename);
      read_info=DestroyImageInfo(read_info);
      (void) RelinquishUniqueFileResource(input_filename);
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Read Ghostscript output.
  */
  (void) CopyMagickString(read_info->filename,filename,MagickPathExtent);
  postscript_image=ReadImage(read_info,exception);
  (void) RelinquishUniqueFileResource(filename);
  (void) RelinquishUniqueFileResource(input_filename);
  read_info=DestroyImageInfo(read_info);
  if (postscript_image == (Image *) NULL)
    {
      image=DestroyImageList(image);
      return(postscript_image);
    }
  (void) CopyMagickString(postscript_image->filename,image_info->filename,
    MagickPathExtent);
  (void) CopyMagickString(postscript_image->magick,image->magick,
    MagickPathExtent)