MagickStatusType
    status;

  register ssize_t
    i;

  ssize_t
    columns,
    rows;

  unsigned char
    hex[256];

  /*
    Allocate image structure.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",
      image_info->filename);
  image=AcquireImage(image_info,exception);
  postscript_image=image;
  (void) CopyMagickString(postscript_filename,image_info->filename,
    MagickPathExtent);
  if (*image_info->magick == '\0')
    (void) CopyMagickString(image->magick,"PS",MagickPathExtent);
  /*
    Convert Postscript to image via Ghostscript delegate.
  */
  delegate_info=GetDelegateInfo("ps:decode",(char *) NULL,exception);
  if (delegate_info == (const DelegateInfo *) NULL)
    ThrowReaderException(CoderError,"NoPostscriptDelegateForThisPlatform");
  read_info=CloneImageInfo(image_info);
  (void) CopyMagickString(read_info->magick,DelegateToModuleMnemonic(
    delegate_info),MagickPathExtent);
  (void) CopyMagickString(read_info->filename,postscript_filename,
    MagickPathExtent);
  (void) SetImageOption(read_info,"ps:size",geometry);
  if (image_info->density == (char *) NULL)
    (void) SetImageOption(read_info,"ps:density","72x72");
  else
    (void) SetImageOption(read_info,"ps:density",image_info->density);
  postscript_image=ReadImage(read_info,exception);
  read_info=DestroyImageInfo(read_info);
  if (postscript_image == (Image *) NULL)
    return(DestroyImageList(image));
  /*
    Transfer Postscript attributes to image.
  */
  for (i=0; i < 256; i++)
    hex[i]=0;
  for (i=0; i < 10; i++)
    hex[(int) ('0'+i)]=(unsigned char) i;
  for (i=0; i < 6; i++)
  {
    hex[(int) ('A'+i)]=(unsigned char) (10+i);
    hex[(int) ('a'+i)]=(unsigned char) (10+i);
  }
  columns=postscript_image->magick_columns;
  rows=postscript_image->magick_rows;