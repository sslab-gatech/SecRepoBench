line.clear();

bool foundEndOfLine = false;
bool hasData = false;

while (!foundEndOfLine) {
    if (m_cachePos >= m_cache.size()) {
        if (!readNextBlock()) {
            break; // End of stream reached
        }
        m_cachePos = 0;
    }

    T c = m_cache[m_cachePos++];

    if (c == static_cast<T>('\r')) {
        foundEndOfLine = true;
        
        // Handle \r\n sequence
        if (m_cachePos < m_cache.size()) {
            if (m_cache[m_cachePos] == static_cast<T>('\n')) {
                m_cachePos++;
            }
        } else if (readNextBlock()) {
            m_cachePos = 0;
            if (!m_cache.empty() && m_cache[0] == static_cast<T>('\n')) {
                m_cachePos = 1;
            }
        }
    } else if (c == static_cast<T>('\n')) {
        foundEndOfLine = true;
    } else {
        line.push_back(c);
        hasData = true;
    }
}

return hasData;