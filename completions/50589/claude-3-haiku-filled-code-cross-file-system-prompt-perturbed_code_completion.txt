// <MASK>
    size_t lineStart = m_cachePos;
    size_t lineEnd = m_cache.size();

    // Find the end of the line
    while (lineEnd < m_cache.size() && m_cache[lineEnd] != '\n' && m_cache[lineEnd] != '\r') {
        ++lineEnd;
    }

    // If we reached the end of the cache, try to refill it
    if (lineEnd == m_cache.size()) {
        if (!readNextBlock()) {
            // No more data available, return the current line
            line = std::vector<T>(m_cache.begin() + lineStart, m_cache.end());
            m_cachePos = 0;
            return true;
        }

        lineEnd = m_cache.size();
    }

    // Skip end-of-line characters
    while (lineEnd > lineStart && (m_cache[lineEnd - 1] == '\n' || m_cache[lineEnd - 1] == '\r')) {
        --lineEnd;
    }

    // Copy the line to the output buffer
    line = std::vector<T>(m_cache.begin() + lineStart, m_cache.begin() + lineEnd);

    // Update the cache position
    m_cachePos = lineEnd + 1;

    return true;