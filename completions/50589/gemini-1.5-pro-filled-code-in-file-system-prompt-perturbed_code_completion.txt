line.resize(m_cacheSize); // Resize the buffer to the cache size initially

    if (m_cachePos >= m_cacheSize || 0 == m_filePos) {
        if (!readNextBlock()) { // Refill the cache if necessary
            return false; // Return false if end of file is reached
        }
    }

    size_t i = 0;
    for (;;) {
        if (IsLineEnd(m_cache[m_cachePos])) {
            ++m_cachePos; // Skip the end-of-line character
            break;
        }

        line[i] = m_cache[m_cachePos];
        ++m_cachePos;
        ++i;

        // Resize the buffer if needed
        if (i == line.size()) {
            line.resize(line.size() * 2);
        }

        // Check for end of cache or file
        if (m_cachePos >= size()) {
            break;
        }
        if (m_cachePos >= m_cacheSize) {
            if (!readNextBlock()) {
                return false; // Return false if end of file is reached
            }
        }
    }

    // Null-terminate the line if it's a string
    if constexpr (std::is_same_v<T, char>) {
        line[i] = '\0';
    }

    // Check if any data was read before returning
    return i > 0 ? true : false;