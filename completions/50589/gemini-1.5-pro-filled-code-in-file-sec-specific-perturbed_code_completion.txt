line.clear();
    if (m_cachePos >= m_cacheSize && m_blockIdx >= m_numBlocks) {
        return false;
    }

    if (m_cachePos >= m_cacheSize) {
        if (!readNextBlock()) {
            return false;
        }
    }

    line.reserve(m_cacheSize - m_cachePos); // Reserve space to avoid reallocations

    while (m_cachePos < m_cacheSize) {
        T c = m_cache[m_cachePos++];
        if (IsLineEnd(c)) {
            // Check for binary end-of-line characters
            if ('\r' == c && m_cachePos < m_cacheSize && '\n' == m_cache[m_cachePos]) {
                ++m_cachePos;
            }
            line.push_back('\n'); // Append newline character for consistency
            return true;
        }
        line.push_back(c);
    }

    // If we reach here, the cache has been exhausted without finding a newline.
    // Read the next block and continue.
    if (m_blockIdx < m_numBlocks) {
        if (!readNextBlock()) {
            line.push_back('\n'); // Append newline character for consistency
            return !line.empty(); // Return true if any data was read before EOF
        }
        return getNextLine(line); // Recursively call getNextLine to process the next block
    }

    line.push_back('\n'); // Append newline character for consistency
    return !line.empty(); // Return true if any data was read before EOF