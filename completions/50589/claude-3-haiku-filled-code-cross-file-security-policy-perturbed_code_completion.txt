// <MASK>
    size_t lineStart = m_cachePos;
    size_t lineEnd = m_cache.size();

    // Find the end of the line
    while (lineEnd < m_cache.size() && m_cache[lineEnd] != '\n' && m_cache[lineEnd] != '\r') {
        ++lineEnd;
    }

    // If we reached the end of the cache, try to refill it
    if (lineEnd == m_cache.size()) {
        if (!readNextBlock()) {
            // No more data available, return the current line
            line.assign(m_cache.begin() + lineStart, m_cache.end());
            m_cachePos = 0;
            return true;
        }

        // Retry finding the end of the line
        lineEnd = m_cache.size();
        while (lineEnd < m_cache.size() && m_cache[lineEnd] != '\n' && m_cache[lineEnd] != '\r') {
            ++lineEnd;
        }
    }

    // Skip any trailing newline characters
    while (lineEnd > lineStart && (m_cache[lineEnd - 1] == '\n' || m_cache[lineEnd - 1] == '\r')) {
        --lineEnd;
    }

    // Resize the output buffer if necessary
    if (line.capacity() < lineEnd - lineStart) {
        line.resize(lineEnd - lineStart);
    }

    // Copy the line to the output buffer
    std::copy(m_cache.begin() + lineStart, m_cache.begin() + lineEnd, line.begin());
    line.resize(lineEnd - lineStart);

    // Update the cache position
    m_cachePos = lineEnd;

    return true;