line.clear();
    if (m_cache.empty()) {
        if (!readNextBlock()) {
            return false;
        }
    }

    while (!m_cache.empty()) {
        auto it = std::find(m_cache.begin() + m_cachePos, m_cache.end(), '\n');
        if (it != m_cache.end()) {

            // check for carriage return
            size_t dist = std::distance(m_cache.begin() + m_cachePos, it);
            if (dist > 0 && m_cache[m_cachePos + dist - 1] == '\r') {
                line.insert(line.end(), m_cache.begin() + m_cachePos, it - 1);
            } else {
                line.insert(line.end(), m_cache.begin() + m_cachePos, it);
            }

            m_cachePos += dist + 1; // skip the newline character

            // Handle CRLF and LF line endings.
            if (m_cachePos < m_cache.size() && m_cache[m_cachePos] == '\n') {
                ++m_cachePos;
            }
            if (m_cachePos < m_cache.size() && m_cache[m_cachePos] == '\r') {
                ++m_cachePos;
            }

            return true;
        } else {
            // Append the remaining cache to the line.
            line.insert(line.end(), m_cache.begin() + m_cachePos, m_cache.end());
            m_cache.clear();
            m_cachePos = 0;

            // Read the next block to continue searching for a newline.
            if (!readNextBlock()) {
                // If no more data is available, return the current line.
                return !line.empty();
            }
        }
    }

    // No newline found, return false if the line is empty, true otherwise.
    return !line.empty();