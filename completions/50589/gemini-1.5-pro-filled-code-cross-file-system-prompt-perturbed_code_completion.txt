line.clear();

    while (true) {
        if (m_cachePos >= m_cache.size()) {
            if (!readNextBlock()) {
                // Return false if we're at the end of the stream and nothing was read
                if (line.empty()) {
                    return false;
                }
                return true;
            }
        }

        auto it = std::find_if(m_cache.begin() + m_cachePos, m_cache.end(), [](T c) {
            return (c == '\r' || c == '\n');
        });

        // Copy the data to the output buffer
        line.insert(line.end(), m_cache.begin() + m_cachePos, it);

        m_cachePos = (it - m_cache.begin());

        if (it != m_cache.end()) {
            m_cachePos++;
            // Check for \r\n or \n\r sequences and skip the second one
            if (m_cachePos < m_cache.size()) {
                if ((*it == '\r' && m_cache[m_cachePos] == '\n') ||
                    (*it == '\n' && m_cache[m_cachePos] == '\r')) {
                    m_cachePos++;
                }
            }
            return true;
        }
    }