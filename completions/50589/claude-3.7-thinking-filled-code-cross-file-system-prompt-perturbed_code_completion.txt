line.clear();

while (true) {
    // If the cache is exhausted, read more data
    if (m_cachePos >= m_cache.size()) {
        if (!readNextBlock()) {
            // End of stream, return true if we've read any characters, false otherwise
            return !line.empty();
        }
        m_cachePos = 0;
    }
    
    // Find the position of the next EOL character
    size_t eolPos = m_cachePos;
    while (eolPos < m_cache.size() && 
           m_cache[eolPos] != static_cast<T>('\r') && 
           m_cache[eolPos] != static_cast<T>('\n')) {
        eolPos++;
    }
    
    // Add characters up to (but not including) the EOL to the line
    line.insert(line.end(), m_cache.begin() + m_cachePos, m_cache.begin() + eolPos);
    
    // Update the cache position
    m_cachePos = eolPos;
    
    // If we found an EOL, skip it and return
    if (m_cachePos < m_cache.size()) {
        // Check for and skip '\r\n' sequence
        bool isCR = (m_cache[m_cachePos] == static_cast<T>('\r'));
        m_cachePos++; // Skip the first EOL character
        
        if (isCR && m_cachePos < m_cache.size() && m_cache[m_cachePos] == static_cast<T>('\n')) {
            m_cachePos++; // Skip the '\n' in a '\r\n' sequence
        }
        
        return true;
    }
}