bool IOStreamBuffer<T>::getNextLine(std::vector<T> &line) {
    line.clear();

    while (true) {
        // If we've consumed the current cache, try to fill it again
        if (m_cachePos >= m_cache.size()) {
            if (!readNextBlock()) {
                // End of stream; return false if nothing read so far
                return !line.empty();
            }
        }

        // Read the next character from the cache
        T c = m_cache[m_cachePos++];

        // Check for end-of-line characters
        if (c == T('\n')) {
            // A single LF ends the line
            return true;
        } else if (c == T('\r')) {
            // On CR, check if the next character is LF; skip it if so
            if (m_cachePos < m_cache.size()) {
                if (m_cache[m_cachePos] == T('\n')) {
                    m_cachePos++;
                }
            } else {
                // We reached the end of the cache; try refilling to see if LF follows
                if (readNextBlock() && m_cachePos < m_cache.size() && m_cache[m_cachePos] == T('\n')) {
                    m_cachePos++;
                }
            }
            return true;
        }

        // Otherwise, accumulate the character into the current line
        line.push_back(c);
    }

    // Fallback; should be unreachable
    return !line.empty();
}