template <class T>
AI_FORCE_INLINE bool IOStreamBuffer<T>::getNextLine(std::vector<T> &line) {
    line.resize(m_cacheSize);
    
    // If the cache is empty or we're at the beginning, read the next block
    if (m_cachePos >= m_cacheSize || 0 == m_filePos) {
        if (!readNextBlock()) {
            return false;
        }
    }
    
    size_t i = 0;
    for (;;) {
        // Break if we find a line ending
        if (IsLineEnd(m_cache[m_cachePos])) {
            break;
        }
        
        // Add character to line
        line[i] = m_cache[m_cachePos];
        ++m_cachePos;
        ++i;
        
        // Resize line if necessary
        if (i == line.size()) {
            line.resize(line.size() * 2);
        }
        
        // Check if we've reached the end of the cache
        if (m_cachePos >= m_cacheSize) {
            if (!readNextBlock()) {
                // End of file reached
                line.resize(i);
                return i > 0;  // Return true if we read anything
            }
        }
    }
    
    // Skip line ending characters
    if (m_cache[m_cachePos] == '\r') {
        ++m_cachePos;
        // If the next character is a newline, skip it too
        if (m_cachePos < m_cacheSize && m_cache[m_cachePos] == '\n') {
            ++m_cachePos;
        } else if (m_cachePos >= m_cacheSize) {
            // If we've reached the end of the cache, try to read the next block
            if (readNextBlock() && m_cache[0] == '\n') {
                ++m_cachePos;
            }
        }
    } else if (m_cache[m_cachePos] == '\n') {
        ++m_cachePos;
    }
    
    // Resize line to actual size
    line.resize(i);
    
    return true;
}