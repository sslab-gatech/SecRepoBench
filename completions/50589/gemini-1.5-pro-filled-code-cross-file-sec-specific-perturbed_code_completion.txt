line.clear();

    while (true) {
        if (m_cachePos >= m_cache.size()) {
            if (!readNextBlock()) {
                // Return false if the cache is empty and no more blocks can be read
                return !line.empty();
            }
        }

        auto it = std::find_if(m_cache.begin() + m_cachePos, m_cache.end(), [](const T& c) {
            return c == '\n' || c == '\r' || c == '\0';
        });

        // Append the characters from the cache to the line buffer
        line.insert(line.end(), m_cache.begin() + m_cachePos, it);

        if (it != m_cache.end()) {
            m_cachePos = (it - m_cache.begin()) + 1;
            // Skip over any immediately following \r or \n characters
            while (m_cachePos < m_cache.size() && (*it == '\n' || *it == '\r')) {
                ++it;
                ++m_cachePos;
            }
            return true;
        }

        m_cachePos = m_cache.size();
    }