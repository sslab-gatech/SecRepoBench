line.clear();

    if (m_cache.empty()) {
        if (!readNextBlock()) {
            return false;
        }
    }

    while (!m_cache.empty()) {
        auto it = std::find(m_cache.begin() + m_cachePos, m_cache.end(), '\n');
        if (it != m_cache.end()) {
            line.insert(line.end(), m_cache.begin() + m_cachePos, it);
            m_cachePos = std::distance(m_cache.begin(), it) + 1;
            if (m_cachePos < m_cache.size() && m_cache[m_cachePos] == '\r') {
                ++m_cachePos;
            }

            // Erase the consumed part from cache
            if (m_cachePos >= m_cache.size()) {
                m_cache.clear();
                m_cachePos = 0;
            }

            return true;
        }

        line.insert(line.end(), m_cache.begin() + m_cachePos, m_cache.end());
        m_cache.clear();
        m_cachePos = 0;

        if (!readNextBlock()) {
            // if we reached EOF before finding a newline, return what we have
            // even if it's an empty line.
            return !line.empty();
        }
    }

    return !line.empty();