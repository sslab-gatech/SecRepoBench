// Clear the output line buffer
line.clear();

// Loop until we either find a line or reach end of stream
while (true) {
    // If cache is exhausted or not initialized, read the next block
    if (m_cachePos >= m_cache.size()) {
        if (!readNextBlock()) {
            // End of file - return true if we read any data, otherwise false
            return !line.empty();
        }
        m_cachePos = 0;
    }

    // Check if the block is empty (shouldn't happen if readNextBlock returned true)
    if (m_cache.empty()) {
        return !line.empty();
    }

    // Find the end of line in current block
    size_t lineEnd = m_cachePos;
    while (lineEnd < m_cache.size()) {
        if (m_cache[lineEnd] == '\r' || m_cache[lineEnd] == '\n') {
            break;
        }
        ++lineEnd;
    }

    // Add the current segment to the output line
    line.insert(line.end(), m_cache.begin() + m_cachePos, m_cache.begin() + lineEnd);

    // If we haven't reached the end of the block, we found an EOL character
    if (lineEnd < m_cache.size()) {
        // Skip EOL character(s)
        m_cachePos = lineEnd;
        
        // Handle CRLF sequence
        if (m_cache[m_cachePos] == '\r' && m_cachePos + 1 < m_cache.size() && m_cache[m_cachePos + 1] == '\n') {
            m_cachePos += 2;
        } else {
            // Handle CR or LF alone
            ++m_cachePos;
        }
        
        // Line successfully read
        return true;
    }
    
    // We've reached the end of the block without finding EOL
    // Update position and continue to next block
    m_cachePos = lineEnd;
}