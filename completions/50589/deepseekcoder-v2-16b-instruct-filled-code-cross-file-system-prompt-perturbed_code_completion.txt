// <MASK>
    // Initialize the buffer if it's empty
    if (buffer.empty()) {
        buffer.reserve(m_bufferSize); // Reserve space for the buffer
    }

    // Read characters until a newline character is encountered
    while (true) {
        // Check if the cache is exhausted
        if (m_cachePos >= m_cache.size()) {
            if (!readNextBlock()) {
                // If no more blocks can be read and the buffer is still empty, return false
                if (buffer.empty()) {
                    return false;
                }
                // If the buffer is not empty, return true as we have read at least something
                return !buffer.empty();
            }
        }

        // Read characters from the cache
        const char* cacheStart = m_cache.data() + m_cachePos;
        const char* cacheEnd = m_cache.data() + m_cache.size();
        const char* lineEnd = std::find(cacheStart, cacheEnd, '\n');

        // Append the characters to the buffer
        buffer.insert(buffer.end(), cacheStart, lineEnd);

        // Update the cache position
        m_cachePos = lineEnd - m_cache.data() + 1; // Move to the next line

        // Check if a newline character was found
        if (lineEnd != cacheEnd) {
            // Remove any trailing end-of-line characters
            while (!buffer.empty() && (buffer.back() == '\r' || buffer.back() == '\n')) {
                buffer.pop_back();
            }
            return true;
        }
    }
}