// <MASK>
    // Clear the line buffer
    line.clear();

    // If the cache is empty, refill it
    if (m_cache.empty()) {
        if (!readNextBlock()) {
            return false;
        }
    }

    // Find the end of the line in the cache
    auto newlinePos = std::find(m_cache.begin() + m_cachePos, m_cache.end(), T('\n'));
    if (newlinePos == m_cache.end()) {
        // If no newline is found, add all available characters to the line
        line.insert(line.end(), m_cache.begin() + m_cachePos, m_cache.end());
        m_cachePos = m_cache.size();
        // Refill the cache if it's exhausted
        if (m_cachePos == m_cache.size()) {
            if (!readNextBlock()) {
                // If the end of the stream is reached, return false
                return line.size() > 0;
            }
            // Retry finding the newline
            newlinePos = std::find(m_cache.begin(), m_cache.end(), T('\n'));
            if (newlinePos == m_cache.end()) {
                line.insert(line.end(), m_cache.begin(), m_cache.end());
                m_cachePos = m_cache.size();
                m_cache.clear();
                return line.size() > 0;
            }
        } else {
            // Add characters up to the newline to the line
            line.insert(line.end(), m_cache.begin() + m_cachePos, newlinePos);
            m_cachePos = newlinePos - m_cache.begin() + 1;
            return true;
        }
    } else {
        // Add characters up to the newline to the line
        line.insert(line.end(), m_cache.begin() + m_cachePos, newlinePos);
        m_cachePos = newlinePos - m_cache.begin() + 1;
        return true;
    }