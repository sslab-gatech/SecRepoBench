// <MASK>
    // Ensure the buffer is large enough to hold the next line
    line.clear();
    bool eof = false;
    while (true) {
        // Read characters from the buffer until an end-of-line character is encountered
        size_t pos = m_cachePos;
        while (pos < m_cache.size() && m_cache[pos] != '\n' && m_cache[pos] != '\r') {
            ++pos;
        }

        // Copy the line from the buffer to the output vector
        line.insert(line.end(), m_cache.begin() + m_cachePos, m_cache.begin() + pos);
        m_cachePos = pos;

        // If we reached the end of the buffer and need more data, read the next block
        if (pos == m_cache.size()) {
            if (!readNextBlock()) {
                if (line.empty()) {
                    return false;
                }
                eof = true;
                break;
            }
            m_cachePos = 0;
        } else {
            // If we found an end-of-line character, skip it and break the loop
            if (m_cache[pos] == '\n') {
                ++m_cachePos;
            } else { // If it was a '\r', check for '\n' following it
                if (pos + 1 < m_cache.size() && m_cache[pos + 1] == '\n') {
                    m_cachePos = pos + 2;
                } else {
                    m_cachePos = pos + 1;
                }
            }
            break;
        }
    }

    return !eof;
}