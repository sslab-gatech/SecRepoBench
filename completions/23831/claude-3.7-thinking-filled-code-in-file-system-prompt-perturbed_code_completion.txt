if (packet->payload_packet_len == 12) {
  NDPI_LOG_INFO(ndpi_struct, "found IAX\n");
  ndpi_int_iax_add_connection(ndpi_struct, flow);
  return;
}

packetlength = 12;  // Start after the header (12 bytes)

for (i = 0; i < NDPI_IAX_MAX_INFORMATION_ELEMENTS; i++) {
  if (packetlength >= packet->payload_packet_len) {
    break;
  }
  
  // Check if there's enough space for the information element type and length
  if (packetlength + 2 > packet->payload_packet_len) {
    break;
  }
  
  // Get the information element length
  u_int8_t ie_len = packet->payload[packetlength + 1];
  
  // Calculate the next position
  packetlength += 2 + ie_len;  // 2 bytes for type and length + element length
  
  // If we've reached the end of the packet exactly, it's a valid IAX packet
  if (packetlength == packet->payload_packet_len) {
    NDPI_LOG_INFO(ndpi_struct, "found IAX\n");
    ndpi_int_iax_add_connection(ndpi_struct, flow);
    return;
  }
}