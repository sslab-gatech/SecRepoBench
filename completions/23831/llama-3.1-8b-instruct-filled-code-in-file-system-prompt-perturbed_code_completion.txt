// Check if the payload length equals 12, log detection of IAX, and add the connection if true.
  // Otherwise, iterate through information elements in the payload.
  // For each element, calculate the next element's starting position based on its length.
  // If the calculated position equals the total payload length, log detection of IAX and add the connection.
  if (packet->payload_packet_len == 12) {
    ndpi_log_detection(ndpi_struct, flow, "IAX");
    ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_IAX, NDPI_PROTOCOL_UNKNOWN);
  } else {
    u_int16_t i;
    for (i = 12; i < packet->payload_packet_len; i++) {
      if (packet->payload[i] == 0x00) {
        break;
      }
      // Check if the current element is a valid information element
      if (packet->payload[i] >= 0x01 && packet->payload[i] <= 0x0F) {
        // Calculate the next element's starting position
        u_int16_t next_element_start = i + 1 + (packet->payload[i] * 2);
        // Check if the calculated position equals the total payload length
        if (next_element_start == packet->payload_packet_len) {
          ndpi_log_detection(ndpi_struct, flow, "IAX");
          ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_IAX, NDPI_PROTOCOL_UNKNOWN);
          break;
        }
      }
    }
  }