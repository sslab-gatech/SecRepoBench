if (packet->payload_packet_len == 12) {
  NDPI_LOG_INFO(ndpi_struct, "found IAX\n");
  ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_IAX, NDPI_PROTOCOL_UNKNOWN);
  return;
} else {
  /* We need to parse information elements */
  packetlength = 12; /* Start position after IAX header */
  
  while (packetlength < packet->payload_packet_len) {
    /* Check if we have at least 2 more bytes (type and length) */
    if (packetlength + 2 > packet->payload_packet_len) {
      break;
    }
    
    /* Get element length */
    u_int8_t element_len = packet->payload[packetlength + 1];
    
    /* Sanity check for element length */
    if (packetlength + 2 + element_len > packet->payload_packet_len) {
      break; /* Malformed packet, element too long */
    }
    
    /* Move to next element */
    packetlength += 2 + element_len; /* type (1) + len (1) + content (len) */
    
    /* Check if we reached exactly the end of the packet */
    if (packetlength == packet->payload_packet_len) {
      NDPI_LOG_INFO(ndpi_struct, "found IAX\n");
      ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_IAX, NDPI_PROTOCOL_UNKNOWN);
      return;
    }
  }
}