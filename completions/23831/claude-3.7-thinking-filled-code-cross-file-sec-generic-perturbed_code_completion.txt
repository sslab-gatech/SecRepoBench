if (packet->payload_packet_len == 12) {
  NDPI_LOG_INFO(ndpi_struct, "found IAX\n");
  ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_IAX, NDPI_PROTOCOL_UNKNOWN);
  return;
} else {
  // IAX messages can have optional information elements after the header
  // Each IE is structured as: 1 byte type, 1 byte length, followed by data
  u_int16_t position = 12; // Start after the standard header
  
  while (position + 2 <= packet->payload_packet_len) {
    // Each IE has a 1-byte type and 1-byte length
    u_int8_t ie_type = packet->payload[position];
    u_int8_t ie_len = packet->payload[position + 1];
    
    // Check if the IE length is valid
    if (position + 2 + ie_len > packet->payload_packet_len)
      break; // IE goes beyond packet boundary
    
    // Move to the next IE
    position += 2 + ie_len;
    
    // If we've reached the end of the packet, we have a valid IAX packet
    if (position == packet->payload_packet_len) {
      NDPI_LOG_INFO(ndpi_struct, "found IAX\n");
      ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_IAX, NDPI_PROTOCOL_UNKNOWN);
      return;
    }
  }
}