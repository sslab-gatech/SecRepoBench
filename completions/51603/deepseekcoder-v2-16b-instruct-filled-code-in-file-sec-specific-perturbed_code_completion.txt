return FILE_OPXOR;
	case '!':
		return FILE_OPNOT;
	case '=':
		return FILE_OPEQ;
	case '>':
		return FILE_OPGT;
	case '<':
		return FILE_OPLT;
	default:
		return FILE_INVALID;
	}
}

private int
parse_mime(struct magic_set *ms, struct magic_entry *me, const char *l,
    size_t len)
{
	const char *p;
	size_t i;

	if (len == 0) {
		file_error(ms, 0, "empty mime type");
		return -1;
	}

	for (p = l; p < l + len; p++) {
		if (isspace(CAST(unsigned char, *p)))
			break;
	}
	if (p == l + len) {
		file_error(ms, 0, "no mime type");
		return -1;
	}

	for (i = 0; i < MAGIC_SETS; i++) {
		me[i].mp->mimetype = strndup(l, p - l);
		if (me[i].mp->mimetype == NULL) {
			file_oomem(ms, p - l);
			return -1;
		}
		me[i].mp->flag |= TEXTTEST;
	}
	return 0;
}

private int
parse_strength(struct magic_set *ms, struct magic_entry *me, const char *l,
    size_t len)
{
	const char *p;
	int op;
	size_t i;

	if (len == 0) {
		file_error(ms, 0, "empty strength value");
		return -1;
	}

	for (p = l; p < l + len; p++) {
		if (isspace(CAST(unsigned char, *p)))
			break;
	}
	if (p == l + len) {
		file_error(ms, 0, "no strength value");
		return -1;
	}

	op = get_op(*p);
	if (op == FILE_INVALID) {
		file_error(ms, 0, "invalid strength operator `%c'", *p);
		return -1;
	}

	for (i = 0; i < MAGIC_SETS; i++) {
		me[i].mp->factor_op = op;
		me[i].mp->factor = strtoull(l, CAST(char **, &p), 10);
		if (p == l) {
			file_error(ms, 0, "invalid strength value `%s'", l);
			return -1;
		}
		me[i].mp->flag |= TEXTTEST;
	}
	return 0;
}

private int
parse_apple(struct magic_set *ms, struct magic_entry *me, const char *l,
    size_t len)
{
	const char *p;
	size_t i;

	if (len == 0) {
		file_error(ms, 0, "empty apple value");
		return -1;
	}

	for (p = l; p < l + len; p++) {
		if (isspace(CAST(unsigned char, *p)))
			break;
	}
	if (p == l + len) {
		file_error(ms, 0, "no apple value");
		return -1;
	}

	for (i = 0; i < MAGIC_SETS; i++) {
		me[i].mp->value.us = strndup(l, p - l);
		if (me[i].mp->value.us == NULL) {
			file_oomem(ms, p - l);
			return -1;
		}
		me[i].mp->flag |= TEXTTEST;
	}
	return 0;
}

private int
parse_ext(struct magic_set *ms, struct magic_entry *me, const char *l,
    size_t len)
{
	const char *p;
	size_t i;

	if (len == 0) {
		file_error(ms, 0, "empty extension value");
		return -1;
	}

	for (p = l; p < l + len; p++) {
		if (isspace(CAST(unsigned char, *p)))
			break;
	}
	if (p == l + len) {
		file_error(ms, 0, "no extension value");
		return -1;
	}

	for (i = 0; i < MAGIC_SETS; i++) {
		me[i].mp->value.us = strndup(l, p - l);
		if (me[i].mp->value.us == NULL) {
			file_oomem(ms, p - l);
			return -1;
		}
		me[i].mp->flag |= TEXTTEST;
	}
	return 0;
}

private int
parse(struct magic_set *ms, struct magic_entry *me, const char *l,
    size_t lineno, int action)
{
	const char *p;
	size_t i, len;
	int type, ret = -1;

	if (l == NULL || *l == '\0')
		return 0;

	len = strlen(l);

	if (len == 0)
		return 0;

	EATAB;

	if (isspace(CAST(unsigned char, *l))) {
		file_error(ms, 0, "empty line at line %zu", lineno);
		return -1;
	}

	if (*l == '!') {
		if (len < 2 || l[1] != ':') {
			file_error(ms, 0, "invalid !: entry `%s'", l);
			return -1;
		}
		return 0;
	}

	if (*l == '#')
		return 0;

	if (*l == '@') {
		if (len < 2 || l[1] != '{') {
			file_error(ms, 0, "invalid @ entry `%s'", l);
			return -1;
		}
		p = l + 2;
		for (i = 0; i < MAGIC_SETS; i++) {
			me[i].mp->desc = strndup(p, len - 2);
			if (me[i].mp->desc == NULL) {
				file_oomem(ms, len - 2);
				return -1;
			}
			me[i].mp->flag |= TEXTTEST;
		}
		return 0;
	}

	if (*l == '|') {
		if (len < 2 || l[1] != '|') {
			file_error(ms, 0, "invalid || entry `%s'", l);
			return -1;
		}
		p = l + 2;
		for (i = 0; i < MAGIC_SETS; i++) {
			me[i].mp->mimetype = strndup(p, len - 2);
			if (me[i].mp->mimetype == NULL) {
				file_oomem(ms, len - 2);
				return -1;
			}
			me[i].mp->flag |= TEXTTEST;
		}
		return 0;
	}

	if (*l == '=') {
		if (len < 2 || l[1] != '=') {
			file_error(ms, 0, "invalid == entry `%s'", l);
			return -1;
		}
		p = l + 2;
		for (i = 0; i < MAGIC_SETS; i++) {
			me[i].mp->value.s = strndup(p, len - 2);
			if (me[i].mp->value.s == NULL) {
				file_oomem(ms, len - 2);
				return -1;
			}
			me[i].mp->flag |= TEXTTEST;
		}
		return 0;
	}

	if (*l == '>') {
		if (len < 2 || l[1] != '>') {
			file_error(ms, 0, "invalid >> entry `%s'", l);
			return -1;
		}
		p = l + 2;
		for (i = 0; i < MAGIC_SETS; i++) {
			me[i].mp->value.s = strndup(p, len - 2);
			if (me[i].mp->value.s == NULL) {
				file_oomem(ms, len - 2);
				return -1;
			}
			me[i].mp->flag |= TEXTTEST;
		}
		return 0;
	}

	if (*l == '<') {
		if (len < 2 || l[1] != '<') {
			file_error(ms, 0, "invalid << entry `%s'", l);
			return -1;
		}
		p = l + 2;
		for (i = 0; i < MAGIC_SETS; i++) {
			me[i].mp->value.s = strndup(p, len - 2);
			if (me[i].mp->value.s == NULL) {
				file_oomem(ms, len - 2);
				return -1;
			}
			me[i].mp->flag |= TEXTTEST;
		}
		return 0;
	}

	if (*l == '~') {
		if (len < 2 || l[1] != '~') {
			file_error(ms, 0, "invalid ~~ entry `%s'", l);
			return -1;
		}
		p = l + 2;
		for (i = 0; i < MAGIC_SETS; i++) {
			me[i].mp->value.s = strndup(p, len - 2);
			if (me[i].mp->value.s == NULL) {
				file_oomem(ms, len - 2);
				return -1;
			}
			me[i].mp->flag |= TEXTTEST;
		}
		return 0;
	}

	if (*l == '?') {
		if (len < 2 || l[1] != '?') {
			file_error(ms, 0, "invalid ?? entry `%s'", l);
			return -1;
		}
		p = l + 2;
		for (i = 0; i < MAGIC_SETS; i++) {
			me[i].mp->value.s = strndup(p, len - 2);
			if (me[i].mp->value.s == NULL) {
				file_oomem(ms, len - 2);
				return -1;
			}
			me[i].mp->flag |= TEXTTEST;
		}
		return 0;
	}

	if (*l == '*') {
		if (len < 2 || l[1] != '*') {
			file_error(ms, 0, "invalid ** entry `%s'", l);
			return -1;
		}
		p = l + 2;
		for (i = 0; i < MAGIC_SETS; i++) {
			me[i].mp->value.s = strndup(p, len - 2);
			if (me[i].mp->value.s == NULL) {
				file_oomem(ms, len - 2);
				return -1;
			}
			me[i].mp->flag |= TEXTTEST;
		}
		return 0;
	}

	if (*l == '!') {
		if (len < 2 || l[1] != '!') {
			file_error(ms, 0, "invalid !! entry `%s'", l);
			return -1;
		}
		p = l + 2;
		for (i = 0; i < MAGIC_SETS; i++) {
			me[i].mp->value.s = strndup(p, len - 2);
			if (me[i].mp->value.s == NULL) {
				file_oomem(ms, len - 2);
				return -1;
			}
			me[i].mp->flag |= TEXTTEST;
		}
		return 0;
	}

	if (*l == '|') {
		if (len < 2 || l[1] != '|') {
			file_error(ms, 0, "invalid || entry `%s'", l);
			return -1;
		}
		p = l + 2;
		for (i