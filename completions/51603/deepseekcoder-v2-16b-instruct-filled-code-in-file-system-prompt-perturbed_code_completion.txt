FILE_OPMODULO;
	case '=':
		return FILE_OPEQUAL;
	case '!':
		return FILE_OPNOT;
	case '<':
		return FILE_OPLESSTHAN;
	case '>':
		return FILE_OPGREATERTHAN;
	case '(':
		return FILE_OPLPAREN;
	case ')':
		return FILE_OPRPAREN;
	case '[':
		return FILE_OPLBRACKET;
	case ']':
		return FILE_OPRBRACKET;
	case '{':
		return FILE_OPLCURLY;
	case '}':
		return FILE_OPRCURLY;
	case ',':
		return FILE_OPCOMMA;
	case ':':
		return FILE_OPCOLON;
	case ';':
		return FILE_OPSEMICOLON;
	case '?':
		return FILE_OPQUESTION;
	case '@':
		return FILE_OPAT;
	case '#':
		return FILE_OPHASH;
	case '$':
		return FILE_OPDOLLAR;
	case '~':
		return FILE_OPTILDE;
	case '\\':
		return FILE_OPBACKSLASH;
	case '\'':
		return FILE_OPAPOSTROPHE;
	case '\"':
		return FILE_OPQUOTE;
	case '`':
		return FILE_OPBACKQUOTE;
	case ' ':
		return FILE_OPSPACE;
	case '\t':
		return FILE_OPTAB;
	case '\n':
		return FILE_OPNEWLINE;
	case '\r':
		return FILE_OPRETURN;
	case '\f':
		return FILE_OPFORMFEED;
	case '\v':
		return FILE_OPVERTICALTAB;
	default:
		return FILE_OPINVALID;
	}
}

private int
parse_mime(struct magic_set *ms, struct magic_entry *me, const char *l,
    size_t len)
{
	const char *p;
	size_t i;

	if (len == 0) {
		file_error(ms, 0, "empty mime type");
		return -1;
	}

	for (p = l; p < l + len; p++) {
		if (isspace(CAST(unsigned char, *p)))
			break;
	}
	if (p == l + len) {
		file_error(ms, 0, "no mime type");
		return -1;
	}

	for (i = 0; i < MAGIC_SETS; i++) {
		if (me[i].mp == NULL)
			continue;
		if (me[i].mp->mimetype[0] != '\0') {
			file_error(ms, 0, "multiple mime types");
			return -1;
		}
		if (strncpy(me[i].mp->mimetype, l, len) == NULL) {
			file_oomem(ms, len);
			return -1;
		}
		me[i].mp->mimetype[len] = '\0';
		me[i].mp->flag |= TEXTTEST;
		break;
	}
	return 0;
}

private int
parse_strength(struct magic_set *ms, struct magic_entry *me, const char *l,
    size_t len)
{
	const char *p;
	int val;

	if (len == 0) {
		file_error(ms, 0, "empty strength value");
		return -1;
	}

	val = atoi(l);
	for (p = l; *p && *p != ' '; p++)
		;
	if (*p)
		*p++ = '\0';

	for (int i = 0; i < MAGIC_SETS; i++) {
		if (me[i].mp == NULL)
			continue;
		if (me[i].mp->factor != 0) {
			file_error(ms, 0, "multiple strength values");
			return -1;
		}
		me[i].mp->factor = val;
		me[i].mp->factor_op = FILE_FACTOR_OP_NONE;
		if (p && *p) {
			switch (*p) {
			case '+':
				me[i].mp->factor_op = FILE_FACTOR_OP_PLUS;
				break;
			case '-':
				me[i].mp->factor_op = FILE_FACTOR_OP_MINUS;
				break;
			case '*':
				me[i].mp->factor_op = FILE_FACTOR_OP_TIMES;
				break;
			case '/':
				me[i].mp->factor_op = FILE_FACTOR_OP_DIV;
				break;
			default:
				file_error(ms, 0, "invalid factor_op `%c'", *p);
				return -1;
			}
		}
		break;
	}
	return 0;
}

private int
parse_apple(struct magic_set *ms, struct magic_entry *me, const char *l,
    size_t len)
{
	const char *p;
	int val;

	if (len == 0) {
		file_error(ms, 0, "empty apple value");
		return -1;
	}

	val = atoi(l);
	for (p = l; *p && *p != ' '; p++)
		;
	if (*p)
		*p++ = '\0';

	for (int i = 0; i < MAGIC_SETS; i++) {
		if (me[i].mp == NULL)
			continue;
		if (me[i].mp->apple != 0) {
			file_error(ms, 0, "multiple apple values");
			return -1;
		}
		me[i].mp->apple = val;
		if (p && *p) {
			switch (*p) {
			case '+':
				me[i].mp->apple_op = FILE_FACTOR_OP_PLUS;
				break;
			case '-':
				me[i].mp->apple_op = FILE_FACTOR_OP_MINUS;
				break;
			case '*':
				me[i].mp->apple_op = FILE_FACTOR_OP_TIMES;
				break;
			case '/':
				me[i].mp->apple_op = FILE_FACTOR_OP_DIV;
				break;
			default:
				file_error(ms, 0, "invalid apple_op `%c'", *p);
				return -1;
			}
		}
		break;
	}
	return 0;
}

private int
parse_ext(struct magic_set *ms, struct magic_entry *me, const char *l,
    size_t len)
{
	const char *p;

	if (len == 0) {
		file_error(ms, 0, "empty extension");
		return -1;
	}

	for (int i = 0; i < MAGIC_SETS; i++) {
		if (me[i].mp == NULL)
			continue;
		if (me[i].mp->ext[0] != '\0') {
			file_error(ms, 0, "multiple extensions");
			return -1;
		}
		if (strncpy(me[i].mp->ext, l, len) == NULL) {
			file_oomem(ms, len);
			return -1;
		}
		me[i].mp->ext[len] = '\0';
		break;
	}
	return 0;
}

private int
parse(struct magic_set *ms, struct magic_entry *me, const char *l,
    size_t lineno, int action)
{
	const char *p;
	int type, op, val, ret = 0;
	uint32_t i;
	struct magic *m;

	if (string_modifier_check(ms, me->mp) == -1)
		return -1;

	if (me->mp->type == FILE_DEFAULT) {
		file_error(ms, 0, "default entry at line %zu", lineno);
		return -1;
	}

	if (me->mp->type == FILE_NAME || me->mp->type == FILE_USE ||
	    me->mp->type == FILE_CLEAR) {
		file_error(ms, 0, "invalid type %d at line %zu",
		    me->mp->type, lineno);
		return -1;
	}

	if (me->mp->type == FILE_REGEX && (me->mp->str_flags & REGEX_LINE_COUNT) != 0) {
		file_error(ms, 0, "regex line count modifier at line %zu", lineno);
		return -1;
	}

	if (me->mp->type == FILE_SEARCH && me->mp->str_range == 0) {
		file_error(ms, 0, "missing range at line %zu", lineno);
		return -1;
	}

	if (me->mp->type == FILE_REGEX && (me->mp->str_flags & STRING_COMPACT_WHITESPACE) != 0) {
		file_error(ms, 0, "compact whitespace modifier at line %zu", lineno);
		return -1;
	}

	if (me->mp->type == FILE_REGEX && (me->mp->str_flags & STRING_COMPACT_OPTIONAL_WHITESPACE) != 0) {
		file_error(ms, 0, "compact optional whitespace modifier at line %zu", lineno);
		return -1;
	}

	if (me->mp->type == FILE_BESTRING16 || me->mp->type == FILE_LESTRING16) {
		file_error(ms, 0, "16-bit string modifiers at line %zu", lineno);
		return -1;
	}

	if (me->mp->type == FILE_STRING || me->mp->type == FILE_PSTRING) {
		if ((me->mp->str_flags & STRING_COMPACT_WHITESPACE) != 0) {
			file_error(ms, 0, "compact whitespace modifier at line %zu", lineno);
			return -1;
		}
		if ((me->mp->str_flags & STRING_COMPACT_OPTIONAL_WHITESPACE) != 0) {
			file_error(ms, 0, "compact optional whitespace modifier at line %zu", lineno);
			return -1;
		}
	}

	if (me->mp->type == FILE_SEARCH && me->mp->str_range == 0) {
		file_error(ms, 0, "missing range at line %zu", lineno);
		return -1;
	}

	if (me->mp->type == FILE_REGEX && (me->mp->str_flags & REGEX_LINE_COUNT) != 0) {
		file_error(ms, 0, "regex line count modifier at line %zu", lineno);
		return -1;
	}

	if (me->mp->type == FILE_REGEX && (me->mp->str_flags & STRING_COMPACT_WHITESPACE) != 0) {
		file_error(ms, 0, "compact whitespace modifier at line %zu", lineno);
		return -1;
	}

	if (me->mp->type == FILE_REGEX && (me->mp->str_flags & STRING_COMPACT_OPTIONAL_WHITESPACE) != 0) {
		file_error(ms, 0, "compact optional whitespace modifier at line %zu", lineno);
		return -1;
	}

	if (me->mp->type == FILE_BESTRING16 || me->mp->type == FILE_LESTRING16) {
		file_error(ms, 0, "16-bit string modifiers at line %zu", lineno);
		return -1;
	}

	if (me->mp->type == FILE_STRING || me->mp->type == FILE_PSTRING) {
		if ((me->mp->str_flags & STRING_COMPACT_WHITESPACE) != 0) {
			file_error(ms, 0, "compact whitespace modifier at line %zu", lineno);
			return -1;
		}
		if ((me->mp->str_flags & STRING_COMPACT_OPTIONAL_WHITESPACE) != 0) {
			file_error(ms, 0, "compact optional whitespace modifier at line %zu", lineno);
			return -1;
		}
	}

	if (me->mp->type == FILE_SEARCH && me->mp->str_range == 0) {
		file_error(ms, 0, "missing range at line %zu", lineno);
		return -1;
	}

	if (me->mp->type == FILE_REGEX && (me