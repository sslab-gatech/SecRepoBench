private int
parse_regex(struct magic_set *ms, struct magic_entry *me, const char **lp)
{
	const char *l = *lp;
	char *t;
	int have_range = 0;

	while (!isspace(CAST(unsigned char, *++l))) {
		switch (*l) {
		case '0':  case '1':  case '2':
		case '3':  case '4':  case '5':
		case '6':  case '7':  case '8':
		case '9':
			if (have_range && (ms->flags & MAGIC_CHECK))
				file_magwarn(ms, "multiple ranges");
			have_range = 1;
			me->str_range = CAST(uint32_t, strtoul(l, &t, 0));
			if (me->str_range == 0)
				file_magwarn(ms, "zero range");
			l = t - 1;
			break;
		case CHAR_REGEX_OFFSET_START:
			me->str_flags |= REGEX_OFFSET_START;
			break;
		case CHAR_BINTEST:
			me->str_flags |= STRING_BINTEST;
			break;
		case CHAR_TEXTTEST:
			me->str_flags |= STRING_TEXTTEST;
			break;
		case CHAR_TRIM:
			me->str_flags |= STRING_TRIM;
			break;
		case CHAR_FULL_WORD:
			me->str_flags |= STRING_FULL_WORD;
			break;
		case CHAR_PSTRING_1_LE:
#define SET_LENGTH(a) me->str_flags = (me->str_flags & ~PSTRING_LEN) | (a)
			if (me->type!= FILE_PSTRING)
				goto bad;
			SET_LENGTH(PSTRING_1_LE);
			break;
		case CHAR_PSTRING_2_BE:
			if (me->type!= FILE_PSTRING)
				goto bad;
			SET_LENGTH(PSTRING_2_BE);
			break;
		case CHAR_PSTRING_2_LE:
			if (me->type!= FILE_PSTRING)
				goto bad;
			SET_LENGTH(PSTRING_2_LE);
			break;
		case CHAR_PSTRING_4_BE:
			if (me->type!= FILE_PSTRING)
				goto bad;
			SET_LENGTH(PSTRING_4_BE);
			break;
		case CHAR_PSTRING_4_LE:
			switch (me->type) {
			case FILE_PSTRING:
			case FILE_REGEX:
				break;
			default:
				goto bad;
			}
			SET_LENGTH(PSTRING_4_LE);
			break;
		case CHAR_PSTRING_LENGTH_INCLUDES_ITSELF:
			if (me->type!= FILE_PSTRING)
				goto bad;
			me->str_flags |= PSTRING_LENGTH_INCLUDES_ITSELF;
			break;
		default:
		bad:
			if (ms->flags & MAGIC_CHECK)
				file_magwarn(ms, "regex modifier `%c' "
					"invalid", *l);
			goto out;
		}
		/* allow multiple '/' for readability */
		if (l[1] == '/' &&!isspace(CAST(unsigned char, l[2])))
			l++;
	}
	if (string_modifier_check(ms, me) == -1)
		goto out;
	*lp = l;
	return 0;
out:
	*lp = l;
	return -1;
}