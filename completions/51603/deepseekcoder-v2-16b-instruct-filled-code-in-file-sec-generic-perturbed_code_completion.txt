LY;
	case '/':
		return FILE_OPDIVIDE;
	case '%':
		return FILE_OPMODULO;
	case '=':
		return FILE_OPEQUAL;
	case '!':
		return FILE_OPNOT;
	case '<':
		return FILE_OPLESSTHAN;
	case '>':
		return FILE_OPGREATERTHAN;
	case '(':
		return FILE_OPLPAREN;
	case ')':
		return FILE_OPRPAREN;
	case '[':
		return FILE_OPLBRACKET;
	case ']':
		return FILE_OPRBRACKET;
	case '{':
		return FILE_OPLCURLY;
	case '}':
		return FILE_OPRCURLY;
	case ',':
		return FILE_OPCOMMA;
	case ':':
		return FILE_OPCOLON;
	case ';':
		return FILE_OPSEMICOLON;
	case '?':
		return FILE_OPQUESTION;
	case '@':
		return FILE_OPAT;
	case '#':
		return FILE_OPHASH;
	case '$':
		return FILE_OPDOLLAR;
	case '~':
		return FILE_OPTILDE;
	case '\\':
		return FILE_OPBACKSLASH;
	default:
		return FILE_OPINVALID;
	}
}

private int
parse_mime(struct magic_set *ms, struct magic_entry *me, const char *l,
    size_t len)
{
	const char *p;
	size_t i;

	for (i = 0, p = l; i < len; i++, p++) {
		if (*p == '\0')
			break;
		if (*p == ';' || *p == ',') {
			me->mimetype[i] = '\0';
			return 0;
		}
		me->mimetype[i] = *p;
	}
	me->mimetype[i] = '\0';
	return 0;
}

private int
parse_strength(struct magic_set *ms, struct magic_entry *me, const char *l,
    size_t len)
{
	const char *p;
	int val;

	for (p = l; p < l + len && isdigit(CAST(unsigned char, *p)); p++)
		;
	if (p == l)
		return -1;
	val = atoi(l);
	if (val < 0)
		return -1;
	me->factor = val;
	if (p < l + len && *p == '%') {
		p++;
		val = atoi(p);
		if (val < 0 || val > 100)
			return -1;
		me->factor_op = FILE_FACTOR_OP_TIMES;
		me->factor = val;
	} else
		me->factor_op = FILE_FACTOR_OP_NONE;
	return 0;
}

private int
parse_apple(struct magic_set *ms, struct magic_entry *me, const char *l,
    size_t len)
{
	const char *p;
	int val;

	for (p = l; p < l + len && isdigit(CAST(unsigned char, *p)); p++)
		;
	if (p == l)
		return -1;
	val = atoi(l);
	if (val < 0)
		return -1;
	me->factor = val;
	if (p < l + len && *p == '%') {
		p++;
		val = atoi(p);
		if (val < 0 || val > 100)
			return -1;
		me->factor_op = FILE_FACTOR_OP_TIMES;
		me->factor = val;
	} else
		me->factor_op = FILE_FACTOR_OP_NONE;
	return 0;
}

private int
parse_ext(struct magic_set *ms, struct magic_entry *me, const char *l,
    size_t len)
{
	const char *p;
	size_t i;

	for (i = 0, p = l; i < len; i++, p++) {
		if (*p == '\0')
			break;
		if (*p == ';' || *p == ',') {
			me->ext[i] = '\0';
			return 0;
		}
		me->ext[i] = *p;
	}
	me->ext[i] = '\0';
	return 0;
}

private int
parse(struct magic_set *ms, struct magic_entry *me, const char *l,
    size_t lineno, int action)
{
	const char *p;
	int op, val, type, ret = 0;
	size_t i;

	EATAB;

	if (*l == '\0')
		return 0;

	if (me->mp == NULL) {
		if ((me->mp = CAST(struct magic *, malloc(sizeof(*me->mp)))) == NULL) {
			file_oomem(ms, sizeof(*me->mp));
			return -1;
		}
		memset(me->mp, 0, sizeof(*me->mp));
		me->mp->lineno = lineno;
		me->mp->cont_level = 0;
		me->mp->flag = 0;
		me->mp->str_flags = 0;
		me->mp->str_range = STRING_DEFAULT_RANGE;
		me->mp->factor_op = FILE_FACTOR_OP_NONE;
		me->mp->factor = 0;
		me->mp->type = FILE_DEFAULT;
		me->mp->vallen = 0;
		me->mp->val = 0;
		me->mp->reln = '=';
		me->mp->value.s = NULL;
		me->mp->cont_count = 0;
		me->mp->max_count = 0;
	}

	if (*l == '!') {
		l++;
		if (*l == ':') {
			l++;
			for (i = 0; bang[i].name != NULL; i++) {
				if (strncmp(l, bang[i].name, bang[i].len) == 0) {
					if (bang[i].fun(ms, me, l + bang[i].len,
					    CAST(size_t, strlen(l + bang[i].len))) != 0) {
						return -1;
					}
					return 1;
				}
			}
			file_error(ms, 0, "Unknown !: entry `%s'", l);
			return -1;
		}
	}

	if (*l == ':') {
		l++;
		if (*l == '!') {
			l++;
			for (i = 0; bang[i].name != NULL; i++) {
				if (strncmp(l, bang[i].name, bang[i].len) == 0) {
					if (bang[i].fun(ms, me, l + bang[i].len,
					    CAST(size_t, strlen(l + bang[i].len))) != 0) {
						return -1;
					}
					return 1;
				}
			}
			file_error(ms, 0, "Unknown !: entry `%s'", l);
			return -1;
		}
	}

	if (*l == ' ') {
		l++;
		EATAB;
	}

	if (*l == '\0')
		return 0;

	if (isalpha(CAST(unsigned char, *l))) {
		const char *t;
		type = get_type(type_tbl, l, &t);
		if (type == FILE_INVALID) {
			file_error(ms, 0, "Unknown type `%s'", l);
			return -1;
		}
		me->mp->type = type;
		l = t;
		EATAB;
	}

	if (*l == ' ') {
		l++;
		EATAB;
	}

	if (*l == '\0')
		return 0;

	if (*l == '[') {
		l++;
		if (*l == '!') {
			me->mp->reln = '!';
			l++;
		}
		if (*l == '=') {
			me->mp->reln = '=';
			l++;
		}
		if (*l == '<') {
			me->mp->reln = '<';
			l++;
		}
		if (*l == '>') {
			me->mp->reln = '>';
			l++;
		}
		if (*l == '^') {
			me->mp->reln = '^';
			l++;
		}
		if (*l == '&') {
			me->mp->reln = '&';
			l++;
		}
		if (*l == ' ') {
			l++;
			EATAB;
		}
		if (*l == '\0')
			return -1;
		if (isdigit(CAST(unsigned char, *l))) {
			val = atoi(l);
			me->mp->val = file_signextend(ms, me->mp, val);
			while (isdigit(CAST(unsigned char, *l)))
				l++;
		} else if (*l == '0' && (l[1] == 'x' || l[1] == 'X')) {
			val = strtol(l, CAST(char **, &l), 16);
			me->mp->val = file_signextend(ms, me->mp, val);
		} else if (*l == '0') {
			val = strtol(l, CAST(char **, &l), 8);
			me->mp->val = file_signextend(ms, me->mp, val);
		} else {
			file_error(ms, 0, "Bad value `%s'", l);
			return -1;
		}
		if (*l == ']')
			l++;
		else
			return -1;
		EATAB;
	}

	if (*l == ' ') {
		l++;
		EATAB;
	}

	if (*l == '\0')
		return 0;

	if (*l == '{') {
		l++;
		if (*l == '!') {
			me->mp->reln = '!';
			l++;
		}
		if (*l == '=') {
			me->mp->reln = '=';
			l++;
		}
		if (*l == '<') {
			me->mp->reln = '<';
			l++;
		}
		if (*l == '>') {
			me->mp->reln = '>';
			l++;
		}
		if (*l == '^') {
			me->mp->reln = '^';
			l++;
		}
		if (*l == '&') {
			me->mp->reln = '&';
			l++;
		}
		if (*l == ' ') {
			l++;
			EATAB;
		}
		if (*l == '\0')
			return -1;
		if (isdigit(CAST(unsigned char, *l))) {
			val = atoi(l);
			me->mp->val = file_signextend(ms, me->mp, val);
			while (isdigit(CAST(unsigned char, *l)))
				l++;
		} else if (*l == '0' && (l[1] == 'x' || l[1] == 'X')) {
			val = strtol(l, CAST(char **, &l), 16);
			me->mp->val = file_signextend(ms, me->mp, val);
		} else if (*l == '0') {
			val = strtol(l, CAST(char **, &l), 8);
			me->mp->val = file_signextend(ms, me->mp, val);
		} else {
			file_error(ms, 0, "Bad value `%s'", l);
			return -1;
		}
		if (*l == '}')
			l++;
		else
			return -1;
		EATAB;
	}

	if (*l == ' ') {
		l++;
		EATAB;
	}

	if (*l == '\0')
		return 0;

	if (*l == '(') {
		l++;
		if (*l == '!') {
			me->mp->reln = '!';
			l++;
		}
		if (*l == '=') {
			me->mp->reln = '=';
			l++;
		}
		if (*l == '<') {