private size_t
apprentice_magic_strength(const struct magic *m, size_t nmagic)
{
	ssize_t val = apprentice_magic_strength_1(m);

#ifdef notyet
	if (m->desc[0] == '\0') {
		size_t i;
		/*
		 * Magic entries with no description get their continuations
		 * added
		 */
		for (i = 1; m[i].cont_level != 0 && i < MIN(nmagic, 3); i++) {
			ssize_t v = apprentice_magic_strength_1(&m[i]) >>
			    (i + 1);
			val += v;
			if (m[i].desc[0] != '\0')
				break;
		}
	}
#endif

	switch (m->factor_op) {
	case FILE_FACTOR_OP_NONE:
		break;
	case FILE_FACTOR_OP_PLUS:
		val += m->factor;
		break;
	case FILE_FACTOR_OP_MINUS:
		val -= m->factor;
		break;
	case FILE_FACTOR_OP_TIMES:
		val *= m->factor;
		break;
	case FILE_FACTOR_OP_DIV:
		val /= m->factor;
		break;
	default:
		(void)fprintf(stderr, "Bad factor_op %u\n", m->factor_op);
		abort();
	}

	if (val <= 0)	/* ensure we only return 0 for FILE_DEFAULT */
		val = 1;

#ifndef notyet
	/*
	 * Magic entries with no description get a bonus because they depend
	 * on subsequent magic entries to print something.
	 */
	if (m->desc[0] == '\0')
		val++;
#endif

	return val;
}