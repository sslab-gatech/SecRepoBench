xmlFreeAttributeTable(xmlAttributeTablePtr table) {
    xmlHashFree(table, xmlFreeAttributeTableEntry);
}

#ifdef LIBXML_TREE_ENABLED
/**
 * xmlCopyAttribute:
 * @attr:  An attribute
 *
 * Build a copy of an attribute.
 *
 * Returns the new xmlAttributePtr or NULL in case of error.
 */
static void *
xmlCopyAttribute(void *payload, const xmlChar *name ATTRIBUTE_UNUSED) {
    xmlAttributePtr attr = (xmlAttributePtr) payload;
    xmlAttributePtr cur;

    cur = (xmlAttributePtr) xmlMalloc(sizeof(xmlAttribute));
    if (cur == NULL)
	return(NULL);
    memset(cur, 0, sizeof(xmlAttribute));
    cur->type = XML_ATTRIBUTE_DECL;
    cur->atype = attr->atype;
    cur->def = attr->def;
    cur->doc = attr->doc;
    cur->name = xmlStrdup(attr->name);
    if (cur->name == NULL)
        goto error;
    cur->elem = xmlStrdup(attr->elem);
    if (cur->elem == NULL)
        goto error;
    if (attr->prefix != NULL) {
	cur->prefix = xmlStrdup(attr->prefix);
        if (cur->prefix == NULL)
            goto error;
    }
    if (attr->tree != NULL) {
        cur->tree = xmlCopyEnumeration(attr->tree);
        if (cur->tree == NULL)
            goto error;
    }
    if (attr->defaultValue != NULL) {
	cur->defaultValue = xmlStrdup(attr->defaultValue);
        if (cur->defaultValue == NULL)
            goto error;
    }

    return(cur);

error:
    xmlFreeAttribute(cur);
    return(NULL);
}

/**
 * xmlCopyAttributeTable:
 * @table:  An attribute table
 *
 * Build a copy of an attribute table.
 *
 * Returns the new xmlAttributeTablePtr or NULL in case of error.
 */
xmlAttributeTablePtr
xmlCopyAttributeTable(xmlAttributeTablePtr table) {
    return(xmlHashCopySafe(table, xmlCopyAttribute, xmlFreeAttributeTableEntry));
}
#endif /* LIBXML_TREE_ENABLED */

#ifdef LIBXML_OUTPUT_ENABLED
/**
 * xmlDumpAttributeDecl:
 * @buf:  the XML buffer output
 * @attr:  An attribute table
 *
 * This will dump the content of the attribute declaration as an XML
 * DTD definition
 */
void
xmlDumpAttributeDecl(xmlBufferPtr buf, xmlAttributePtr attr) {
    xmlSaveCtxtPtr save;

    if ((buf == NULL) || (attr == NULL))
        return;

    save = xmlSaveToBuffer(buf, NULL, 0);
    xmlSaveTree(save, (xmlNodePtr) attr);
    xmlSaveClose(save);
}

/**
 * xmlDumpAttributeDeclScan:
 * @attr:  An attribute table
 * @buf:  the XML buffer output
 *
 * This routine is used by the hash scan function.  It just reverses
 * the arguments.
 */
static void
xmlDumpAttributeDeclScan(void *attr, void *buf,
                         const xmlChar *name ATTRIBUTE_UNUSED) {
    xmlDumpAttributeDecl((xmlBufferPtr) buf, (xmlAttributePtr) attr);
}

/**
 * xmlDumpAttributeTable:
 * @buf:  the XML buffer output
 * @table:  An attribute table
 *
 * This will dump the content of the attribute table as an XML DTD definition
 */
void
xmlDumpAttributeTable(xmlBufferPtr buf, xmlAttributeTablePtr table) {
    if ((buf == NULL) || (table == NULL))
        return;
    xmlHashScan(table, xmlDumpAttributeDeclScan, buf);
}
#endif /* LIBXML_OUTPUT_ENABLED */

#ifdef LIBXML_VALID_ENABLED
/**
 * xmlValidateAttribute:
 * @ctxt:  the validation context
 * @elem:  the element name
 * @attr:  the attribute name
 * @value:  the attribute value
 *
 * Validate an attribute value against the DTD.
 *
 * Returns 1 if the value is valid, 0 otherwise.
 */
int
xmlValidateAttribute(xmlValidCtxtPtr ctxt,
                     xmlElementPtr elem, const xmlChar *attr,
                     const xmlChar *value) {
    xmlAttributePtr attrDef;
    int ret = 0;

    if ((ctxt == NULL) || (elem == NULL) || (attr == NULL) || (value == NULL))
        return(0);

    attrDef = xmlGetDtdElementDesc2(ctxt, elem->parent, elem->name);
    if (attrDef == NULL)
        return(0);

    while (attrDef != NULL) {
        xmlAttributePtr cur = attrDef->attributes;

        while (cur != NULL) {
            if ((cur->atype == XML_ATTRIBUTE_ENUMERATION) &&
                xmlStrEqual(cur->name, attr)) {
                xmlEnumerationPtr tree = cur->tree;

                while (tree != NULL) {
                    if (xmlStrEqual(tree->name, value)) {
                        ret = 1;
                        goto done;
                    }
                    tree = tree->next;
                }
            }
            cur = cur->nexth;
        }
        attrDef = attrDef->next;
    }

done:
    return(ret);
}
#endif /* LIBXML_VALID_ENABLED */

#ifdef LIBXML_SCHEMAS_ENABLED
/**
 * xmlValidateAttributeAgainstSchema:
 * @ctxt:  the validation context
 * @elem:  the element name
 * @attr:  the attribute name
 * @value:  the attribute value
 * @schema:  the schema to validate against
 *
 * Validate an attribute value against the schema.
 *
 * Returns 1 if the value is valid, 0 otherwise.
 */
int
xmlValidateAttributeAgainstSchema(xmlValidCtxtPtr ctxt,
                                  xmlElementPtr elem, const xmlChar *attr,
                                  const xmlChar *value, xmlSchemaPtr schema) {
    xmlSchemaAttributePtr attrSchema;
    int ret = 0;

    if ((ctxt == NULL) || (elem == NULL) || (attr == NULL) || (value == NULL) || (schema == NULL))
        return(0);

    attrSchema = xmlSchemaGetAttributeByName(schema, elem->name, attr);
    if (attrSchema == NULL)
        return(0);

    if (attrSchema->attrType == XML_SCHEMA_ATTRIBUTE_TYPE_ENUMERATION) {
        xmlSchemaValue valueTmp;

        valueTmp.simpleType = attrSchema->attrValue.enumeration.simpleType;
        valueTmp.simpleValue = value;
        valueTmp.simpleList = NULL;
        ret = xmlSchemaValidateEnumeration(ctxt, &valueTmp);
    }

    return(ret);
}
#endif /* LIBXML_SCHEMAS_ENABLED */

#ifdef LIBXML_TREE_ENABLED
/**
 * xmlCopyAttributeTableEntry:
 * @attr:  An attribute
 *
 * Build a copy of an attribute table entry.
 *
 * Returns the new xmlAttributePtr or NULL in case of error.
 */
static void *
xmlCopyAttributeTableEntry(void *payload, const xmlChar *name ATTRIBUTE_UNUSED) {
    xmlAttributePtr attr = (xmlAttributePtr) payload;
    xmlAttributePtr cur;

    cur = (xmlAttributePtr) xmlMalloc(sizeof(xmlAttribute));
    if (cur == NULL)
	return(NULL);
    memset(cur, 0, sizeof(xmlAttribute));
    cur->type = XML_ATTRIBUTE_DECL;
    cur->atype = attr->atype;
    cur->def = attr->def;
    cur->doc = attr->doc;
    cur->name = xmlStrdup(attr->name);
    if (cur->name == NULL)
        goto error;
    cur->elem = xmlStrdup(attr->elem);
    if (cur->elem == NULL)
        goto error;
    if (attr->prefix != NULL) {
	cur->prefix = xmlStrdup(attr->prefix);
        if (cur->prefix == NULL)
            goto error;
    }
    if (attr->tree != NULL) {
        cur->tree = xmlCopyEnumeration(attr->tree);
        if (cur->tree == NULL)
            goto error;
    }
    if (attr->defaultValue != NULL) {
	cur->defaultValue = xmlStrdup(attr->defaultValue);
        if (cur->defaultValue == NULL)
            goto error;
    }

    return(cur);

error:
    xmlFreeAttribute(cur);
    return(NULL);
}

/**
 * xmlCopyAttributeTableEntrySafe:
 * @attr:  An attribute
 * @name:  The attribute name
 *
 * Build a copy of an attribute table entry.
 *
 * Returns the new xmlAttributePtr or NULL in case of error.
 */
static void *
xmlCopyAttributeTableEntrySafe(void *payload, const xmlChar *name) {
    xmlAttributePtr attr = (xmlAttributePtr) payload;
    xmlAttributePtr cur;

    cur = (xmlAttributePtr) xmlMalloc(sizeof(xmlAttribute));
    if (cur == NULL)
	return(NULL);
    memset(cur, 0, sizeof(xmlAttribute));
    cur->type = XML_ATTRIBUTE_DECL;
    cur->atype = attr->atype;
    cur->def = attr->def;
    cur->doc = attr->doc;
    cur->name = xmlStrdup(name);
    if (cur->name == NULL)
        goto error;
    cur->elem = xmlStrdup(attr->elem);
    if (cur->elem == NULL)
        goto error;
    if (attr->prefix != NULL) {
	cur->prefix = xmlStrdup(attr->prefix);
        if (cur->prefix == NULL)
            goto error;
    }
    if (attr->tree != NULL) {
        cur->tree = xmlCopyEnumeration(attr->tree);
        if (cur->tree == NULL)
            goto error;
    }
    if (attr->defaultValue != NULL) {
	cur->defaultValue = xmlStrdup(attr->defaultValue);
        if (cur->defaultValue == NULL)
            goto error;
    }

    return(cur);

error:
    xmlFreeAttribute(cur);
    return(NULL);
}

/**
 * xmlCopyAttributeTableSafe:
 * @table:  An attribute table
 *
 * Build a copy of an attribute table.
 *
 * Returns the new xmlAttributeTablePtr or NULL in case of error.
 */
xmlAttributeTablePtr
xmlCopyAttributeTableSafe(xmlAttributeTablePtr table) {
    return(xmlHashCopySafe(table, xmlCopyAttributeTableEntrySafe, xmlFreeAttributeTableEntry));
}
#endif /* LIBXML_TREE_ENABLED */

#ifdef LIBXML_OUTPUT_ENABLED
/**
 * xmlSaveAttributeDecl:
 * @buf:  the XML buffer output
 * @attr:  An attribute table
 *
 * This will dump the content of the attribute declaration as an XML
 * DTD definition
 */
void
xmlSaveAttributeDecl(xmlBufferPtr buf, xmlAttributePtr attr) {
    xmlSaveCtxtPtr save;

    if ((buf == NULL) || (attr == NULL))
        return;

    save = xmlSaveToBuffer(buf, NULL, 0);
    xmlSaveTree(save, (xmlNodePtr) attr);
    xmlSaveClose(save);
}

/**
 * xmlSaveAttributeDeclScan:
 * @attr:  An attribute table
 * @buf:  the XML buffer output
 *
 * This routine is used by the hash scan function.  It just reverses
 * the arguments.
 */
static void
xmlSaveAttributeDeclScan(void *attr, void *buf,
                         const xmlChar *name ATTRIBUTE_UNUSED) {
    xmlSaveAttributeDecl((xmlBufferPtr) buf, (xmlAttributePtr) attr);
}

/**
 * xmlSaveAttributeTable:
 * @buf:  the XML buffer output
 * @table:  An attribute table
 *
 * This will dump the content of the attribute table as an XML DTD definition
 */
void
xmlSaveAttributeTable(xmlBufferPtr buf, xmlAttributeTablePtr table) {
    if ((buf == NULL) || (table == NULL))
        return;
    xmlHashScan(table, xmlSaveAttributeDeclScan, buf);
}
#endif /* LIBXML_OUTPUT_ENABLED */

#ifdef LIBXML_VALID_ENABLED
/**
 * xmlValidateElementDecl:
 * @ctxt:  the validation context
 * @dtd:  pointer to the DTD
 * @name:  the element name
 * @type:  the element type
 * @content:  the element content tree or NULL
 *
 * Register a new element declaration
 *
 * Returns NULL if not, otherwise the entity
 */
xmlElementPtr
xmlValidateElementDecl(xmlValidCtxtPtr ctxt,
                       xmlDtdPtr dtd, const xmlChar *