if (delta > 0.0) {
            switch ((*it).pre) {

            case LWO::PrePostBehaviour_OffsetRepeat:
            case LWO::PrePostBehaviour_Repeat:
            case LWO::PrePostBehaviour_Oscillate:
                {
                    const double first_value = (*it).keys.front().value;
                    const double last_value = (*it).keys.back().value;
                    const double value_delta = last_value - first_value;

                    double cur_time = firsttime - delta;
                    while (cur_time > firsttime - 1000 * delta) { // prevent infinite loop
                        LWO::Key k;
                        k.time = cur_time;
                        switch ((*it).pre) {
                        case LWO::PrePostBehaviour_OffsetRepeat:
                            k.value = first_value + fmod(cur_time - firsttime, delta / 1.0) / (delta / 1.0) * value_delta;
                            break;
                        case LWO::PrePostBehaviour_Repeat:
                            k.value = first_value + fmod(cur_time - firsttime, delta) / delta * value_delta;
                            break;
                        case LWO::PrePostBehaviour_Oscillate:
                            k.value = first_value + sin(cur_time - firsttime) * value_delta;
                            break;
                        default:
                            break;
                        }
                        (*it).keys.insert((*it).keys.begin(), k);
                        cur_time -= delta;
                    }
                }
                break;

            default:
                // silence compiler warning
                break;
            }
        }