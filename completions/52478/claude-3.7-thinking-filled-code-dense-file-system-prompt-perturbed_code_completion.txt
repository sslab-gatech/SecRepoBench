// process pre behavior
switch ((*it).pre) {
case LWO::PrePostBehaviour_OffsetRepeat:
case LWO::PrePostBehaviour_Repeat:
case LWO::PrePostBehaviour_Oscillate:
    if (firsttime > first) {
        // Need to add keys before the start of the animation
        std::vector<LWO::Key> add;
        
        // Calculate how many cycles we need
        double duration = delta;
        double need = firsttime - first;
        int cycles = static_cast<int>(std::ceil(need / duration));
        
        for (int c = 0; c < cycles; ++c) {
            // Time offset for this cycle
            double offset = duration * (c + 1);
            
            // For each key in the original set
            for (std::vector<LWO::Key>::iterator it2 = (*it).keys.begin(); 
                 it2 != (*it).keys.end(); ++it2) {
                
                // Calculate new key time
                double time = (*it2).time - offset;
                
                // Skip if the key would be out of range
                if (time < first)
                    continue;
                
                // Create a new key
                LWO::Key nk = *it2;
                nk.time = time;
                
                // Adjust value based on pre-behavior
                if ((*it).pre == LWO::PrePostBehaviour_OffsetRepeat) {
                    // For OffsetRepeat, offset by the delta value for each cycle
                    const float delta_value = (*it).keys.back().value - (*it).keys.front().value;
                    nk.value -= delta_value * (c + 1);
                }
                else if ((*it).pre == LWO::PrePostBehaviour_Oscillate && (c & 1)) {
                    // For Oscillate in odd cycles, reverse the value calculation
                    const float rel_pos = ((*it2).time - firsttime) / duration;
                    nk.value = (*it).keys.back().value + 
                              ((*it).keys.front().value - (*it).keys.back().value) * rel_pos;
                }
                
                add.push_back(nk);
            }
        }
        
        // Sort the added keys by time
        std::sort(add.begin(), add.end());
        
        // Insert the new keys at the beginning
        (*it).keys.insert((*it).keys.begin(), add.begin(), add.end());
        
        // Update the old_first marker
        (*it).old_first = add.size();
    }
    break;

default:
    // silence compiler warning
    break;
}