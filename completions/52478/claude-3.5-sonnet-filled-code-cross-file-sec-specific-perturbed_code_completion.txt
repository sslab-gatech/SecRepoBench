// process pre behavior
switch ((*it).pre) {
    case LWO::PrePostBehaviour_OffsetRepeat:
    case LWO::PrePostBehaviour_Repeat:
    case LWO::PrePostBehaviour_Oscillate:
        {
            double time = firsttime;
            while (time > 0.0) {
                LWO::Key new_key;
                new_key.time = time;

                if ((*it).pre == LWO::PrePostBehaviour_OffsetRepeat) {
                    new_key.value = (*it).keys.front().value + ((*it).keys.back().value - (*it).keys.front().value) * 
                                    static_cast<float>((firsttime - time) / delta);
                } else if ((*it).pre == LWO::PrePostBehaviour_Repeat) {
                    size_t index = static_cast<size_t>(std::fmod(firsttime - time, delta) / delta * ((*it).keys.size() - 1));
                    new_key.value = (*it).keys[index].value;
                } else { // Oscillate
                    double cycle = std::fmod(firsttime - time, 2.0 * delta);
                    if (cycle > delta) {
                        cycle = 2.0 * delta - cycle;
                    }
                    size_t index = static_cast<size_t>(cycle / delta * ((*it).keys.size() - 1));
                    new_key.value = (*it).keys[index].value;
                }

                (*it).keys.insert((*it).keys.begin(), new_key);
                time -= delta;
            }
        }
        break;

    default:
        // No pre-behavior or unsupported type, do nothing
        break;
}