switch ((*it).pre) {
        case LWO::PrePostBehaviour_OffsetRepeat:
        {
            if (delta == 0.0) break;
            const double d = firsttime - first;
            double num_repeats = std::floor(d / delta);
            double offset = d - num_repeats * delta;

            LWO::Key k = (*it).keys.front();
            k.time = first;
            k.value -= (float)num_repeats * ((*it).keys.back().value - (*it).keys.front().value);

            (*it).keys.insert((*it).keys.begin(), k);
            (*it).old_first++;
            break;
        }

        case LWO::PrePostBehaviour_Repeat:
        {
            if (delta == 0.0) break;
            LWO::Key k = (*it).keys.front();
            k.time = first;
            //k.value = k.value;  // Value remains the same for repeat
            (*it).keys.insert((*it).keys.begin(), k);
            (*it).old_first++;
            break;
        }

        case LWO::PrePostBehaviour_Oscillate:
        {
            // Oscillate: The animation sequence is repeated, alternating between forward and backward playback.
            if (delta == 0.0) break;

            const double d = firsttime - first;
            double num_repeats = std::floor(d / delta);
            double offset = d - num_repeats * delta;

            LWO::Key k = (*it).keys.front();
            k.time = first;

            if (static_cast<int>(num_repeats) % 2 == 0) {
                // Even number of repeats: start from the beginning
                //k.value = (*it).keys.front().value; // Value remains the same
            } else {
                // Odd number of repeats: start from the end (reversed)
                k.value = (*it).keys.back().value - (*it).keys.front().value;
            }

            (*it).keys.insert((*it).keys.begin(), k);
            (*it).old_first++;
            break;
        }

        default:
            // silence compiler warning
            break;
        }