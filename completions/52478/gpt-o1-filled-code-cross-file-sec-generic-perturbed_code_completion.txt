(*it).old_first = 0;
(*it).old_last = (*it).keys.size() - 1;

// Handle pre-behavior by inserting additional keyframes for OffsetRepeat, Repeat, or Oscillate.
switch ((*it).pre) {

    case LWO::PrePostBehaviour_OffsetRepeat:
    case LWO::PrePostBehaviour_Repeat:
    case LWO::PrePostBehaviour_Oscillate:
    {
        // Only proceed if there's a positive time span to repeat
        if (delta > 0.0 && first < firsttime) {

            // Calculate how far we need to extend for the pre-behavior
            const double neededRange = firsttime - first;
            // Determine how many "cycles" fit into the range
            size_t cycles = static_cast<size_t>(std::floor(neededRange / delta));

            // Simple safety clamp to prevent potential over-allocation
            const size_t MAX_CYCLES = 10000;
            if (cycles > MAX_CYCLES) {
                cycles = MAX_CYCLES;
            }

            // Insert repeated or offset keyframes in front
            for (size_t c = 0; c < cycles; ++c) {
                for (size_t k = 0; k < (*it).old_last + 1; ++k) {
                    LWO::Key newKey = (*it).keys[k];
                    newKey.time -= (c + 1) * delta;

                    // OffsetRepeat shifts the value by the difference between last and first
                    if ((*it).pre == LWO::PrePostBehaviour_OffsetRepeat) {
                        newKey.value += static_cast<float>((c + 1) * 
                                          ((*it).keys.back().value - (*it).keys.front().value));
                    }
                    // Oscillate can invert the shift for alternate cycles (simple example)
                    else if ((*it).pre == LWO::PrePostBehaviour_Oscillate && (c % 2 == 1)) {
                        newKey.value = (*it).keys.back().value 
                                       - (newKey.value - (*it).keys.front().value);
                    }

                    // Only insert if it remains in our desired [first..last] range
                    if (newKey.time >= first) {
                        (*it).keys.insert((*it).keys.begin(), newKey);
                    }
                }
            }

            // Update old_first and old_last so ClearAnimRangeSetup() can revert these insertions
            (*it).old_first = cycles * ((*it).old_last + 1);
            (*it).old_last += (*it).old_first;
        }
        break;
    }

    default:
        // Pre-behavior isn't one of the repeating types, so do nothing
        break;
}