// Save the original key range to allow for cleanup later.
        (*it).old_first = 0;
        (*it).old_last = (*it).keys.size() - 1;

        // Handle pre-behavior by inserting extra keyframes for the segment preceding the first key
        switch ((*it).pre) {
        case LWO::PrePostBehaviour_OffsetRepeat:
        {
            // Use the difference in value between first and last as offset
            float offsetVal = (*it).keys.back().value - (*it).keys.front().value;
            LWO::Key newKey = (*it).keys.front();
            newKey.time = firsttime - delta;
            newKey.value -= offsetVal;
            (*it).keys.insert((*it).keys.begin(), newKey);
        }
        break;

        case LWO::PrePostBehaviour_Repeat:
        {
            // Re-insert the first key at an earlier time
            LWO::Key newKey = (*it).keys.front();
            newKey.time = firsttime - delta;
            (*it).keys.insert((*it).keys.begin(), newKey);
        }
        break;

        case LWO::PrePostBehaviour_Oscillate:
        {
            // Mirror the front key's value around the last key's value
            float valDelta = (*it).keys.back().value - (*it).keys.front().value;
            LWO::Key newKey = (*it).keys.front();
            newKey.time = firsttime - delta;
            newKey.value = (*it).keys.back().value + valDelta;
            (*it).keys.insert((*it).keys.begin(), newKey);
        }
        break;

        default:
            // No extra key insertion needed for other behaviors
            break;
        }