// Handles the pre-behavior of LightWave envelopes by inserting additional keyframes
// for pre-defined behaviors such as OffsetRepeat, Repeat, and Oscillate. This involves
// calculating the time delta between keys and adjusting keyframe values accordingly.
// The logic uses the start time, end time, and value delta to calculate new keyframe
// positions and values, adapting to the pre-behavior type.
void AnimResolver::UpdateAnimRangeSetup() {
    for (std::list<LWO::Envelope>::iterator it = envelopes.begin(); it!= envelopes.end(); ++it) {
        if ((*it).keys.empty()) continue;

        const double firsttime = (*it).keys.front().time;
        const double my_last = (*it).keys.back().time;

        const double delta = my_last - firsttime;
        switch ((*it).pre) {
        case LWO::PrePostBehaviour_OffsetRepeat:
            // Insert additional keyframes for OffsetRepeat behavior
            for (std::vector<LWO::Key>::iterator d = (*it).keys.begin(); d!= (*it).keys.end(); ++d) {
                if (d == (*it).keys.begin()) {
                    // First keyframe, no need to adjust
                    continue;
                }
                const double prev_time = (*d).time;
                const double prev_value = (*d).value;
                const double time_diff = prev_time - firsttime;
                const double value_diff = prev_value - (*d).keys[0].value;
                const double repeat_time = time_diff / delta;
                const double repeat_value = value_diff * repeat_time;
                (*it).keys.insert((*d).keys.begin(), LWO::Key(prev_time - repeat_time, (*d).keys[0].value + repeat_value));
            }
            break;

        case LWO::PrePostBehaviour_Repeat:
            // Insert additional keyframes for Repeat behavior
            for (std::vector<LWO::Key>::iterator d = (*it).keys.begin(); d!= (*it).keys.end(); ++d) {
                if (d == (*it).keys.begin()) {
                    // First keyframe, no need to adjust
                    continue;
                }
                const double prev_time = (*d).time;
                const double prev_value = (*d).value;
                const double time_diff = prev_time - firsttime;
                const double value_diff = prev_value - (*d).keys[0].value;
                const double repeat_time = time_diff / delta;
                const double repeat_value = value_diff * repeat_time;
                (*it).keys.insert((*d).keys.begin(), LWO::Key(prev_time - repeat_time, (*d).keys[0].value + repeat_value));
                (*it).keys.insert((*d).keys.begin(), LWO::Key(prev_time - repeat_time, (*d).keys[0].value + repeat_value));
            }
            break;

        case LWO::PrePostBehaviour_Oscillate:
            // Insert additional keyframes for Oscillate behavior
            for (std::vector<LWO::Key>::iterator d = (*it).keys.begin(); d!= (*it).keys.end(); ++d) {
                if (d == (*it).keys.begin()) {
                    // First keyframe, no need to adjust
                    continue;
                }
                const double prev_time = (*d).time;
                const double prev_value = (*d).value;
                const double time_diff = prev_time - firsttime;
                const double value_diff = prev_value - (*d).keys[0].value;
                const double repeat_time = time_diff / delta;
                const double repeat_value = value_diff * repeat_time;
                (*it).keys.insert((*d).keys.begin(), LWO::Key(prev_time - repeat_time, (*d).keys[0].value + repeat_value));
                (*it).keys.insert((*d).keys.begin(), LWO::Key(prev_time - repeat_time, (*d).keys[0].value + repeat_value));
            }
            break;

        default:
            // Silence compiler warning
            break;
        }
    }
}