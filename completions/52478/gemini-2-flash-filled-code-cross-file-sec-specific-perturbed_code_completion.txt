switch ((*it).pre) {
        case LWO::PrePostBehaviour_OffsetRepeat:
        {
            if (delta == 0.0) break;
            const double d = first - firsttime;
            double num_repeats = std::floor(d / delta);
            double offset = d - num_repeats * delta;

            LWO::Key k = (*it).keys.front();
            k.time = first;
            k.value += (float)num_repeats * ((*it).keys.back().value - (*it).keys.front().value);

            (*it).keys.insert((*it).keys.begin(), k);
            (*it).old_first++;
            break;
        }
        case LWO::PrePostBehaviour_Repeat:
        {
            if (delta == 0.0) break;
            LWO::Key k = (*it).keys.front();
            k.time = first;
            //k.value += (float)num_repeats * ((*it).keys.back().value - (*it).keys.front().value);

            (*it).keys.insert((*it).keys.begin(), k);
            (*it).old_first++;
            break;
        }
        case LWO::PrePostBehaviour_Oscillate:
        {
            // not quite sure if this is correct
            if (delta == 0.0) break;

            const double d = first - firsttime;
            double num_repeats = std::floor(d / delta);
            double offset = d - num_repeats * delta;

            LWO::Key k = (*it).keys.front();
            k.time = first;
            if (((int)num_repeats) & 1) {
                k.value = (*it).keys.back().value - (float)offset / (float)delta * ((*it).keys.back().value - (*it).keys.front().value);
            }
            //k.value += (float)num_repeats * ((*it).keys.back().value - (*it).keys.front().value);

            (*it).keys.insert((*it).keys.begin(), k);
            (*it).old_first++;
            break;
        }
        default:
            // silence compiler warning
            break;
        }