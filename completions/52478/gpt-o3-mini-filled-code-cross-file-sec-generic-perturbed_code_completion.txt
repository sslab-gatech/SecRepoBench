{
    LWO::Envelope &env = *it;
    // By default, no pre- or post- keys inserted.
    env.old_first = 0;
    env.old_last = env.keys.size() - 1;

    // Check if we need to handle pre-behavior (i.e. extend the envelope backward)
    if (first < firsttime) {
        // Calculate how many full periods are needed so that a key at time 'first' falls
        // into the envelope cycle. For a time T before the first key (firsttime), we
        // compute n = ceil((firsttime - T)/delta)
        double diff = firsttime - first;
        int n = static_cast<int>(std::ceil(diff / delta));

        // Compute an effective time within the envelope cycle for interpolation.
        // Start by mapping the global time 'first' forward n cycles.
        double eff_time = first + n * delta;
        float extraOffset = 0.f; // used for OffsetRepeat behavior

        switch (env.pre) {
            case LWO::PrePostBehaviour_Repeat:
                // For Repeat, no additional value offset is applied.
                break;
            case LWO::PrePostBehaviour_OffsetRepeat:
                // For OffsetRepeat, add an offset per cycle.
                extraOffset = static_cast<float>(n * (env.keys.back().value - env.keys.front().value));
                break;
            case LWO::PrePostBehaviour_Oscillate:
                // For Oscillate, if n is odd, mirror the effective time.
                if (n & 1)
                    eff_time = 2 * my_last - eff_time;
                break;
            default:
                // For behaviors such as Constant or Reset, simply use the first key's value.
                {
                    LWO::Key key;
                    key.time = first;
                    key.value = env.keys.front().value;
                    key.inter = env.keys.front().inter;
                    for (int i = 0; i < 5; ++i)
                        key.params[i] = env.keys.front().params[i];
                    env.keys.insert(env.keys.begin(), key);
                    env.old_first = 1;
                    env.old_last += 1;
                }
                // We are done with pre-behavior handling.
                break;
        }

        // Only (Repeat, OffsetRepeat, Oscillate) continue here.
        if (env.pre == LWO::PrePostBehaviour_Repeat ||
            env.pre == LWO::PrePostBehaviour_OffsetRepeat ||
            env.pre == LWO::PrePostBehaviour_Oscillate)
        {
            // Determine the interpolated value at the effective time.
            float interpValue = 0.f;
            if (eff_time <= env.keys.front().time) {
                interpValue = env.keys.front().value;
            } else if (eff_time >= env.keys.back().time) {
                interpValue = env.keys.back().value;
            } else {
                // Linear interpolation: search for the two surrounding keys.
                for (size_t i = 0; i < env.keys.size() - 1; ++i) {
                    if (env.keys[i].time <= eff_time && eff_time <= env.keys[i+1].time) {
                        double seg = env.keys[i+1].time - env.keys[i].time;
                        if (seg > 0.0)
                        {
                            float t = static_cast<float>((eff_time - env.keys[i].time) / seg);
                            interpValue = env.keys[i].value + t * (env.keys[i+1].value - env.keys[i].value);
                        }
                        else {
                            interpValue = env.keys[i].value;
                        }
                        break;
                    }
                }
            }
            interpValue += extraOffset;

            LWO::Key newKey;
            newKey.time = first;
            newKey.value = interpValue;
            newKey.inter = env.keys.front().inter;
            for (int i = 0; i < 5; ++i)
                newKey.params[i] = env.keys.front().params[i];

            env.keys.insert(env.keys.begin(), newKey);
            env.old_first = 1;
            env.old_last += 1;
        }
    }
}