// Handles the pre-behavior of LightWave envelopes by inserting additional keyframes
// for pre-defined behaviors such as OffsetRepeat, Repeat, and Oscillate. This involves
// calculating the time delta between keys and adjusting keyframe values accordingly.
// The logic uses the start time, end time, and value delta to calculate new keyframe
// positions and values, adapting to the pre-behavior type.
void AnimResolver::UpdateAnimRangeSetup() {
    for (std::list<LWO::Envelope>::iterator it = envelopes.begin(); it!= envelopes.end(); ++it) {
        if ((*it).keys.empty()) continue;

        const double firsttime = (*it).keys.front().time;
        const double my_last = (*it).keys.back().time;

        const double delta = my_last - firsttime;
        switch ((*it).pre) {
        case LWO::PrePostBehaviour_OffsetRepeat:
            // Insert keyframes for offset repeat behavior
            for (std::vector<LWO::Key>::iterator d = (*it).keys.begin(); d!= (*it).keys.end(); ++d) {
                if (d == (*it).keys.begin()) {
                    // First keyframe is already set, so we can start from the second one
                    continue;
                }
                const double prev_time = (*d).time;
                const double prev_value = (*d).value;
                const double next_time = (*d).time + delta;
                const double next_value = (*d).value + (*d).value * 2;
                (*it).keys.insert((*d).keys.begin() + 1, LWO::Key(next_time, next_value));
            }
            break;

        case LWO::PrePostBehaviour_Repeat:
            // Insert keyframes for repeat behavior
            for (std::vector<LWO::Key>::iterator d = (*it).keys.begin(); d!= (*it).keys.end(); ++d) {
                if (d == (*it).keys.begin()) {
                    // First keyframe is already set, so we can start from the second one
                    continue;
                }
                const double prev_time = (*d).time;
                const double prev_value = (*d).value;
                const double next_time = (*d).time + delta;
                const double next_value = (*d).value;
                (*it).keys.insert((*d).keys.begin() + 1, LWO::Key(next_time, next_value));
            }
            break;

        case LWO::PrePostBehaviour_Oscillate:
            // Insert keyframes for oscillate behavior
            for (std::vector<LWO::Key>::iterator d = (*it).keys.begin(); d!= (*it).keys.end(); ++d) {
                if (d == (*it).keys.begin()) {
                    // First keyframe is already set, so we can start from the second one
                    continue;
                }
                const double prev_time = (*d).time;
                const double prev_value = (*d).value;
                const double next_time = (*d).time + delta;
                const double next_value = (*d).value + (*d).value * 2;
                (*it).keys.insert((*d).keys.begin() + 1, LWO::Key(next_time, next_value));
            }
            break;

        default:
            // Silence compiler warning
            break;
        }
    }
}