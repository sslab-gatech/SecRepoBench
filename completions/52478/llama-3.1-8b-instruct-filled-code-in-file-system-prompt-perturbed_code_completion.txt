// Handles the pre-behavior of LightWave envelopes by inserting additional keyframes
// for pre-defined behaviors such as OffsetRepeat, Repeat, and Oscillate. This involves
// calculating the time delta between keys and adjusting keyframe values accordingly.
// The logic uses the start time, end time, and value delta to calculate new keyframe
// positions and values, adapting to the pre-behavior type.
switch ((*it).pre) {
case LWO::PrePostBehaviour_OffsetRepeat:
    {
        const double firsttime = (*it).keys.front().time;
        const double my_last = (*it).keys.back().time;
        const double delta = my_last - firsttime;
        const double offset = (*it).keys.back().value - (*it).keys.front().value;
        const double repeat = delta / (*it).keys.size();
        for (std::vector<LWO::Key>::iterator d = (*it).keys.begin(); d!= (*it).keys.end(); ++d) {
            if ((*d).time < firsttime) {
                (*d).time = firsttime;
                (*d).value = (*it).keys.front().value;
            } else if ((*d).time > my_last) {
                (*d).time = my_last;
                (*d).value = (*it).keys.back().value;
            } else {
                (*d).time = (*d).time - firsttime;
                (*d).value = (*it).keys.front().value + ((*d).time / delta) * offset;
            }
        }
    }
    break;

case LWO::PrePostBehaviour_Repeat:
    {
        const double firsttime = (*it).keys.front().time;
        const double my_last = (*it).keys.back().time;
        const double delta = my_last - firsttime;
        const double repeat = delta / (*it).keys.size();
        for (std::vector<LWO::Key>::iterator d = (*it).keys.begin(); d!= (*it).keys.end(); ++d) {
            if ((*d).time < firsttime) {
                (*d).time = firsttime;
                (*d).value = (*it).keys.front().value;
            } else if ((*d).time > my_last) {
                (*d).time = my_last;
                (*d).value = (*it).keys.back().value;
            } else {
                (*d).time = (*d).time - firsttime;
                (*d).value = (*it).keys.front().value + ((*d).time / delta) * repeat;
            }
        }
    }
    break;

case LWO::PrePostBehaviour_Oscillate:
    {
        const double firsttime = (*it).keys.front().time;
        const double my_last = (*it).keys.back().time;
        const double delta = my_last - firsttime;
        const double repeat = delta / (*it).keys.size();
        for (std::vector<LWO::Key>::iterator d = (*it).keys.begin(); d!= (*it).keys.end(); ++d) {
            if ((*d).time < firsttime) {
                (*d).time = firsttime;
                (*d).value = (*it).keys.front().value;
            } else if ((*d).time > my_last) {
                (*d).time = my_last;
                (*d).value = (*it).keys.back().value;
            } else {
                (*d).time = (*d).time - firsttime;
                (*d).value = (*it).keys.front().value + sin((*d).time / repeat) * repeat;
            }
        }
    }
    break;

default:
    // silence compiler warning
    break;
}