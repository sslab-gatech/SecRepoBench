// process pre behavior
switch ((*it).pre) {
case LWO::PrePostBehaviour_OffsetRepeat:
case LWO::PrePostBehaviour_Repeat:
case LWO::PrePostBehaviour_Oscillate: {
    // time delta between the first and the last key
    const double delta = my_last - firsttime;

    // value delta between the first and the last key
    const double val_delta = (*it).keys.back().value - (*it).keys.front().value;

    // insert a new keyframe at the very beginning with the value
    // of the last keyframe minus the value delta between the
    // first and the last keyframe.
    if (firsttime > first) {
        Key k = (*it).keys.back();
        k.time = firsttime - delta;
        k.value -= val_delta;
        (*it).keys.insert((*it).keys.begin(), k);
    }

    // insert additional keyframes before the first keyframe
    // according to the pre behavior.
    double f = firsttime;
    while (f > first) {
        f -= delta;
        if (LWO::PrePostBehaviour_Oscillate == (*it).pre) {
            Key k = (*it).keys.front();
            k.time = f;
            k.value += val_delta;
            (*it).keys.insert((*it).keys.begin(), k);
        } else {
            Key k = (*it).keys.back();
            k.time = f;
            (*it).keys.insert((*it).keys.begin(), k);
        }
    }

    // update firsttime and my_last after inserting new keyframes.
    (*it).old_first = (*it).keys.size() - 1;
    firsttime = (*it).keys.front().time;
    my_last = (*it).keys.back().time;
    break;
}

case LWO::PrePostBehaviour_Constant:
    // insert a copy of the first keyframe before the first keyframe
    // until we reach the start time.
    while (firsttime > first) {
        Key k = (*it).keys.front();
        k.time = firsttime - (my_last - firsttime);
        (*it).keys.insert((*it).keys.begin(), k);

        firsttime = k.time;
    }
    (*it).old_first = (*it).keys.size() - 1;
    break;

case LWO::PrePostBehaviour_Linear:
    // insert a new keyframe before the first keyframe with the
    // interpolated value at the start time.
    if (firsttime > first) {
        float result;
        std::vector<LWO::Key>::const_iterator it2 = (*it).keys.begin();
        DoInterpolation2(it2, it2 + 1, first, result);

        Key k = (*it).keys.front();
        k.value = result;
        k.time = first;
        (*it).keys.insert((*it).keys.begin(), k);
        (*it).old_first = (*it).keys.size() - 1;
    }
    break;

default:
    // silence compiler warning
    break;
}