// Process pre behavior
switch ((*it).pre) {
    case LWO::PrePostBehaviour_OffsetRepeat:
    case LWO::PrePostBehaviour_Repeat:
    case LWO::PrePostBehaviour_Oscillate:
    {
        std::vector<LWO::Key> add;
        const size_t old = (*it).keys.size();
        (*it).old_first = 0;
        (*it).old_last = old - 1;

        // Prevent excessive iterations
        const int MAX_ITERATIONS = 1000;
        
        for (int i = 0; i < MAX_ITERATIONS && firsttime - i * delta > first; ++i) {
            for (size_t n = 0; n < old; ++n) {
                // Calculate source index based on behavior and iteration
                size_t src_idx = n;
                if ((*it).pre == LWO::PrePostBehaviour_Oscillate && (i & 0x1) == 0) {
                    // For oscillate, even iterations go backward
                    src_idx = old - 1 - n;
                }
                
                LWO::Key k;
                k.time = firsttime - (i + 1) * delta + ((*it).keys[src_idx].time - firsttime);

                // Skip if before animation start
                if (k.time < first) {
                    continue;
                }

                // Value calculation based on behavior
                if ((*it).pre == LWO::PrePostBehaviour_OffsetRepeat) {
                    // For OffsetRepeat, adjust the value
                    const float vdelta = (*it).keys.back().value - (*it).keys.front().value;
                    k.value = (*it).keys[src_idx].value - (i + 1) * vdelta;
                } else {
                    // For Repeat and Oscillate, use value as is
                    k.value = (*it).keys[src_idx].value;
                }
                
                // Copy interpolation type and parameters
                k.inter = (*it).keys[src_idx].inter;
                for (size_t a = 0; a < 5; ++a) {
                    k.params[a] = (*it).keys[src_idx].params[a];
                }

                add.push_back(k);
            }
        }

        // Insert at the beginning
        if (!add.empty()) {
            (*it).keys.insert((*it).keys.begin(), add.begin(), add.end());
            (*it).old_first += add.size();
            (*it).old_last += add.size();
        }
        break;
    }
    default:
        // Other behaviors like Reset, Constant, Linear
        (*it).old_first = 0;
        (*it).old_last = (*it).keys.size() - 1;
        break;
}