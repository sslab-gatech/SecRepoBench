// process pre behavior
    switch ((*it).pre) {

    case LWO::PrePostBehaviour_OffsetRepeat:
    case LWO::PrePostBehaviour_Repeat:
    case LWO::PrePostBehaviour_Oscillate:
        // Calculate the time delta between keys and adjust keyframe values accordingly
        double delta = (*it).keys.back().time - (*it).keys.front().time;
        double valueDelta = (*it).keys.back().value - (*it).keys.front().value;

        // Insert additional keyframes for pre-defined behaviors
        if ((*it).pre == LWO::PrePostBehaviour_OffsetRepeat) {
            // Insert keyframes for offset repeat behavior
            for (size_t i = 1; i < (*it).keys.size(); ++i) {
                double newTime = (*it).keys[i - 1].time + delta;
                double newValue = (*it).keys[i - 1].value + valueDelta;
                (*it).keys.insert((*it).keys.begin() + i, LWO::Key(newTime, newValue));
            }
        } else if ((*it).pre == LWO::PrePostBehaviour_Repeat) {
            // Insert keyframes for repeat behavior
            for (size_t i = 1; i < (*it).keys.size(); ++i) {
                double newTime = (*it).keys[i - 1].time + delta;
                double newValue = (*it).keys[i - 1].value;
                (*it).keys.insert((*it).keys.begin() + i, LWO::Key(newTime, newValue));
            }
        } else if ((*it).pre == LWO::PrePostBehaviour_Oscillate) {
            // Insert keyframes for oscillate behavior
            for (size_t i = 1; i < (*it).keys.size(); ++i) {
                double newTime = (*it).keys[i - 1].time + delta / 2.0;
                double newValue = (*it).keys[i - 1].value + valueDelta / 2.0;
                (*it).keys.insert((*it).keys.begin() + i, LWO::Key(newTime, newValue));
            }
        }
        break;

    default:
        // silence compiler warning
        break;
    }