switch ((*it).pre) {
    case LWO::PrePostBehaviour_OffsetRepeat:
    case LWO::PrePostBehaviour_Repeat:
    case LWO::PrePostBehaviour_Oscillate: {
        // Save the original range for later removal
        (*it).old_first = 0;
        (*it).old_last = (*it).keys.size() - 1;

        // Only insert if the animation range is larger than the envelope's key range
        if (first < firsttime) {
            // How many times do we need to repeat/offset/oscillate to cover the pre-range?
            int num = static_cast<int>((firsttime - first) / delta);
            if ((firsttime - first) - num * delta > 1e-6) {
                ++num;
            }
            // Insert keys at the front
            for (int i = num; i > 0; --i) {
                for (size_t k = 0; k < (*it).keys.size(); ++k) {
                    LWO::Key key = (*it).keys[k];
                    key.time -= i * delta;
                    if ((*it).pre == LWO::PrePostBehaviour_OffsetRepeat) {
                        float offset = (*it).keys.back().value - (*it).keys.front().value;
                        key.value += offset * i;
                    }
                    else if ((*it).pre == LWO::PrePostBehaviour_Oscillate && (i % 2) == 1) {
                        // Oscillate: reverse the key order and interpolate
                        key.value = (*it).keys[(*it).keys.size() - 1 - k].value;
                    }
                    (*it).keys.insert((*it).keys.begin(), key);
                    ++(*it).old_first;
                    ++(*it).old_last;
                }
            }
        }
        break;
    }
    default:
        // silence compiler warning
        break;
}