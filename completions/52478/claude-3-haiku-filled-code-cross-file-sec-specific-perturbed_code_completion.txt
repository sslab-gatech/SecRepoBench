// Handles the pre-behavior of LightWave envelopes by inserting additional keyframes
// for pre-defined behaviors such as OffsetRepeat, Repeat, and Oscillate. This involves
// calculating the time delta between keys and adjusting keyframe values accordingly.
// The logic uses the start time, end time, and value delta to calculate new keyframe
// positions and values, adapting to the pre-behavior type.
switch ((*it).pre) {
case LWO::PrePostBehaviour_OffsetRepeat:
    {
        double offset = firsttime;
        double repeat_time = delta;
        while (offset < time) {
            offset += repeat_time;
        }
        double new_time = offset - repeat_time;
        double value_delta = (*it).keys.back().value - (*it).keys.front().value;
        LWO::Key new_key;
        new_key.time = new_time;
        new_key.value = (*it).keys.front().value + fmod(time - new_time, repeat_time) / repeat_time * value_delta;
        new_key.inter = LWO::IT_LINE;
        (*it).keys.insert((*it).keys.begin(), new_key);
    }
    break;
case LWO::PrePostBehaviour_Repeat:
    {
        double repeat_time = delta;
        double new_time = fmod(time, repeat_time);
        double value_delta = (*it).keys.back().value - (*it).keys.front().value;
        LWO::Key new_key;
        new_key.time = new_time;
        new_key.value = (*it).keys.front().value + new_time / repeat_time * value_delta;
        new_key.inter = LWO::IT_LINE;
        (*it).keys.insert((*it).keys.begin(), new_key);
    }
    break;
case LWO::PrePostBehaviour_Oscillate:
    {
        double repeat_time = 2 * delta;
        double new_time = fmod(time, repeat_time);
        double value_delta = (*it).keys.back().value - (*it).keys.front().value;
        LWO::Key new_key;
        new_key.time = new_time;
        if (new_time < delta) {
            new_key.value = (*it).keys.front().value + new_time / delta * value_delta;
        } else {
            new_key.value = (*it).keys.back().value - (new_time - delta) / delta * value_delta;
        }
        new_key.inter = LWO::IT_LINE;
        (*it).keys.insert((*it).keys.begin(), new_key);
    }
    break;
default:
    // silence compiler warning
    break;
}