// process pre behavior
        switch ((*it).pre) {
        case LWO::PrePostBehaviour_OffsetRepeat:
        case LWO::PrePostBehaviour_Repeat:
        case LWO::PrePostBehaviour_Oscillate: {
            double current_time = firsttime;
            while (current_time > first) {
                double value_delta = (*it).keys.back().value - (*it).keys.front().value;
                double time_delta = my_last - firsttime;

                LWO::Key new_key;
                new_key.time = current_time - time_delta;

                if ((*it).pre == LWO::PrePostBehaviour_OffsetRepeat) {
                    new_key.value = (*it).keys.front().value - value_delta;
                } else if ((*it).pre == LWO::PrePostBehaviour_Repeat) {
                    new_key.value = (*it).keys.front().value;
                } else if ((*it).pre == LWO::PrePostBehaviour_Oscillate) {
                    new_key.value = (*it).keys.front().value;
                    value_delta = -value_delta; // reverse direction for oscillation
                }

                (*it).keys.insert((*it).keys.begin(), new_key);
                current_time = new_key.time;
            }
            break;
        }
        default:
            // silence compiler warning
            break;
        }