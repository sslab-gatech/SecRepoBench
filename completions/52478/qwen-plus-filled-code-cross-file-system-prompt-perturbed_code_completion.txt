switch ((*it).pre) {

    case LWO::PrePostBehaviour_OffsetRepeat:
    case LWO::PrePostBehaviour_Repeat:
    case LWO::PrePostBehaviour_Oscillate: {
        double cycle_duration = delta;
        double current_time = firsttime - std::fmod(firsttime, cycle_duration);

        while (current_time >= firsttime - delta && current_time > 0) {
            LWO::Key new_key = (*it).keys.front();
            new_key.time = current_time;

            if ((*it).pre == LWO::PrePostBehaviour_OffsetRepeat) {
                // Calculate the offset for OffsetRepeat behavior
                double offset = std::fmod((*it).keys.front().value, (*it).keys.back().value);
                new_key.value += offset;
            } else if ((*it).pre == LWO::PrePostBehaviour_Oscillate) {
                // Reverse the value for Oscillate behavior
                new_key.value = (*it).keys.front().value - (new_key.time - firsttime) * ((*it).keys.back().value - (*it).keys.front().value) / cycle_duration;
            }

            (*it).keys.insert((*it).keys.begin(), new_key);
            current_time -= cycle_duration;
        }
        break;
    }

    default:
        // silence compiler warning
        break;
}