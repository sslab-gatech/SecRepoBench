// process pre behavior
        switch ((*it).pre) {

        case LWO::PrePostBehaviour_OffsetRepeat:
        case LWO::PrePostBehaviour_Repeat:
        case LWO::PrePostBehaviour_Oscillate:
        {
            const size_t oldsize = (*it).keys.size();
            (*it).old_first = 0;
            (*it).old_last = static_cast<size_t>(oldsize - 1);


            // compute the time range of the animation
            double range = delta;
            if (delta < 0.0001) {
                if (!oldsize) {
                    continue;
                }
                range = (*it).keys[oldsize - 1].time - (*it).keys[0].time;
                if (range < 0.0001) {
                    if (1 == oldsize) {
                        continue;
                    }
                    range = (*it).keys[1].time - (*it).keys[0].time;
                    if (range < 0.0001) {
                        continue;
                    }
                }
            }

            const double start_time = firsttime - range;
            const double end_time = my_last;

            const double value_delta = (*it).keys.back().value - (*it).keys.front().value;

            if (delta > 0.0) {
                size_t num_add = (size_t)(std::fabs(start_time - (*it).keys.front().time) / delta);
                if ((*it).pre == LWO::PrePostBehaviour_OffsetRepeat) {
                    double v = (*it).keys.front().value - value_delta;
                    for (size_t i = 0; i < num_add; ++i) {
                        LWO::Key k = (*it).keys.front();
                        k.time -= (i + 1) * range;
                        k.value = v - (i * value_delta);
                        (*it).keys.insert((*it).keys.begin(), k);
                    }
                } else if ((*it).pre == LWO::PrePostBehaviour_Repeat) {
                    size_t i = 0;
                    for (; i < num_add; ++i) {
                        LWO::Key k = (*it).keys[oldsize - 1];
                        k.time -= (i + 1) * range;
                        (*it).keys.insert((*it).keys.begin(), k);
                    }
                } else if ((*it).pre == LWO::PrePostBehaviour_Oscillate) {
                    bool reverse = false;
                    for (size_t i = 0; i < num_add; ++i) {
                        size_t n = (reverse ? oldsize - 2 : 1);
                        for (size_t m = 0; m < oldsize - 1; ++m) {
                            LWO::Key k = (*it).keys[n];
                            k.time -= (i + 1) * range;
                            (*it).keys.insert((*it).keys.begin(), k);
                            if (reverse) {
                                if (n == 0) break;
                                --n;
                            } else {
                                ++n;
                                if (n >= oldsize - 1) break;
                            }
                        }
                        reverse = !reverse;
                    }
                }
            }
        }
            break;

        default:
            // silence compiler warning
            break;
        }