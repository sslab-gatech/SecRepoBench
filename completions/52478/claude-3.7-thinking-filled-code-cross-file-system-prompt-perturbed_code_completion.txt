// process pre behavior
switch ((*it).pre) {
    case LWO::PrePostBehaviour_OffsetRepeat:
    case LWO::PrePostBehaviour_Repeat:
    case LWO::PrePostBehaviour_Oscillate:
        {
            // Store the original range before modifications
            (*it).old_first = 0;
            (*it).old_last = (*it).keys.size() - 1;
            
            // Only proceed if animation should start before the first key
            if (first < firsttime) {
                std::vector<LWO::Key> pre_keys;
                
                // Calculate how many cycles we need
                int cycles = static_cast<int>((firsttime - first) / delta) + 1;
                
                for (int i = 0; i < cycles; ++i) {
                    // For oscillate, every other cycle is reversed
                    bool reverse = ((*it).pre == LWO::PrePostBehaviour_Oscillate && i % 2 == 1);
                    
                    for (size_t j = 0; j <= (*it).old_last; ++j) {
                        size_t idx = reverse ? ((*it).old_last - j) : j;
                        LWO::Key src_key = (*it).keys[idx];
                        
                        // Calculate new time position
                        double time_offset = reverse ? (my_last - src_key.time) : (src_key.time - firsttime);
                        double new_time = firsttime - (i + 1) * delta + time_offset;
                        
                        // Skip keys that would be before animation start
                        if (new_time < first) continue;
                        
                        // Create new key with adjusted time
                        LWO::Key new_key = src_key;
                        new_key.time = new_time;
                        
                        // For OffsetRepeat, offset the value as well
                        if ((*it).pre == LWO::PrePostBehaviour_OffsetRepeat && !reverse) {
                            float value_delta = (*it).keys.back().value - (*it).keys.front().value;
                            new_key.value -= (i + 1) * value_delta;
                        }
                        
                        pre_keys.push_back(new_key);
                    }
                }
                
                // Sort keys by time and insert at beginning
                std::sort(pre_keys.begin(), pre_keys.end(), 
                    [](const LWO::Key& a, const LWO::Key& b) { return a.time < b.time; });
                
                (*it).keys.insert((*it).keys.begin(), pre_keys.begin(), pre_keys.end());
                (*it).old_first = pre_keys.size();
            }
        }
        break;
        
    default:
        // silence compiler warning
        break;
}