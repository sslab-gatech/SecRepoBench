// process pre behavior
switch ((*it).pre) {

case LWO::PrePostBehaviour_OffsetRepeat:
case LWO::PrePostBehaviour_Repeat: {
    if (firsttime > first) {
        std::vector<LWO::Key> add;
        
        // Calculate how many repetitions we need to fill the gap
        int repetitions = static_cast<int>(std::ceil((firsttime - first) / delta));
        
        for (int i = 0; i < repetitions; ++i) {
            // Time offset for this repetition
            double timeOffset = (i + 1) * delta;
            
            // Value offset for OffsetRepeat
            float valueOffset = 0.0f;
            if ((*it).pre == LWO::PrePostBehaviour_OffsetRepeat) {
                valueOffset = ((*it).keys.back().value - (*it).keys.front().value) * (i + 1);
            }
            
            // Create duplicate keys for this repetition
            for (const LWO::Key& key : (*it).keys) {
                LWO::Key newKey = key;
                newKey.time -= timeOffset;
                
                if ((*it).pre == LWO::PrePostBehaviour_OffsetRepeat) {
                    newKey.value -= valueOffset;
                }
                
                // Only add keys within animation range
                if (newKey.time >= first) {
                    add.push_back(newKey);
                }
            }
        }
        
        // Insert the new keys at the beginning
        if (!add.empty()) {
            (*it).keys.insert((*it).keys.begin(), add.begin(), add.end());
            (*it).old_first += static_cast<unsigned int>(add.size());
            (*it).old_last += static_cast<unsigned int>(add.size());
        }
    }
    break;
}

case LWO::PrePostBehaviour_Oscillate: {
    if (firsttime > first) {
        std::vector<LWO::Key> add;
        
        // Oscillation cycle is twice the normal duration
        double oscDelta = delta * 2;
        int oscillations = static_cast<int>(std::ceil((firsttime - first) / oscDelta));
        
        for (int i = 0; i < oscillations; ++i) {
            double timeOffset = (i + 1) * oscDelta;
            
            // Add reversed keys (backward pass)
            for (auto it2 = (*it).keys.rbegin(); it2 != (*it).keys.rend(); ++it2) {
                LWO::Key newKey = *it2;
                
                // Reverse time mapping
                double normalizedTime = (newKey.time - firsttime);
                newKey.time = firsttime - timeOffset - normalizedTime;
                
                if (newKey.time >= first) {
                    add.push_back(newKey);
                }
            }
            
            // Add forward pass if needed
            if ((i % 2) == 0 && i + 1 < oscillations) {
                for (const LWO::Key& key : (*it).keys) {
                    LWO::Key newKey = key;
                    newKey.time -= timeOffset + delta;
                    
                    if (newKey.time >= first) {
                        add.push_back(newKey);
                    }
                }
            }
        }
        
        if (!add.empty()) {
            (*it).keys.insert((*it).keys.begin(), add.begin(), add.end());
            (*it).old_first += static_cast<unsigned int>(add.size());
            (*it).old_last += static_cast<unsigned int>(add.size());
        }
    }
    break;
}

default:
    // silence compiler warning
    break;
}