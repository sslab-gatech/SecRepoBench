// Handles the pre-behavior of LightWave envelopes by inserting additional keyframes
switch ((*it).pre) {

    case LWO::PrePostBehaviour_OffsetRepeat:
    case LWO::PrePostBehaviour_Repeat:
        // For Repeat and OffsetRepeat, calculate the number of repetitions and add keys accordingly
        if (first < firsttime) {
            double repeat_time = firsttime - delta;
            while (repeat_time >= first) {
                Key new_key = (*it).keys.front();
                new_key.time = repeat_time;
                if ((*it).pre == LWO::PrePostBehaviour_OffsetRepeat) {
                    // Adjust value for OffsetRepeat behavior
                    double offset = (new_key.time - firsttime) / delta;
                    new_key.value += static_cast<float>(offset * (new_key.value - (*it).keys.back().value));
                }
                (*it).keys.insert((*it).keys.begin(), new_key);
                repeat_time -= delta;
            }
        }
        break;

    case LWO::PrePostBehaviour_Oscillate:
        // For Oscillate, alternate between the first and last key values
        if (first < firsttime) {
            bool use_first = true;
            double oscillate_time = firsttime - delta;
            while (oscillate_time >= first) {
                Key new_key = use_first ? (*it).keys.front() : (*it).keys.back();
                new_key.time = oscillate_time;
                (*it).keys.insert((*it).keys.begin(), new_key);
                use_first = !use_first;
                oscillate_time -= delta;
            }
        }
        break;

    case LWO::PrePostBehaviour_Linear:
        // For Linear, extrapolate linearly before the first key
        if (first < firsttime) {
            double slope = ((*it).keys[1].value - (*it).keys[0].value) / ((*it).keys[1].time - (*it).keys[0].time);
            double current_time = first;
            while (current_time < firsttime) {
                Key new_key = (*it).keys.front();
                new_key.time = current_time;
                new_key.value = static_cast<float>((*it).keys.front().value + slope * (current_time - (*it).keys.front().time));
                (*it).keys.insert((*it).keys.begin(), new_key);
                current_time += delta;
            }
        }
        break;

    default:
        // No action for other behaviors (e.g., Reset, Constant)
        break;
}