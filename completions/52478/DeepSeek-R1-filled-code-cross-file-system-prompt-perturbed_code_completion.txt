switch ((*it).pre) {
            case LWO::PrePostBehaviour_OffsetRepeat:
            case LWO::PrePostBehaviour_Repeat:
            case LWO::PrePostBehaviour_Oscillate: {
                const float firstval = (*it).keys.front().value;
                const float lastval = (*it).keys.back().value;
                const float delta_value = lastval - firstval;
                const double delta_time = delta;

                std::vector<LWO::Key> new_keys;
                new_keys.reserve((*it).keys.size());

                if ((*it).pre == LWO::PrePostBehaviour_OffsetRepeat) {
                    for (const auto& key : (*it).keys) {
                        LWO::Key new_key = key;
                        new_key.time -= delta_time;
                        new_key.value -= delta_value;
                        new_keys.push_back(new_key);
                    }
                }
                else if ((*it).pre == LWO::PrePostBehaviour_Repeat) {
                    for (const auto& key : (*it).keys) {
                        LWO::Key new_key = key;
                        new_key.time -= delta_time;
                        new_keys.push_back(new_key);
                    }
                }
                else if ((*it).pre == LWO::PrePostBehaviour_Oscillate) {
                    for (auto rit = (*it).keys.rbegin(); rit != (*it).keys.rend(); ++rit) {
                        LWO::Key new_key = *rit;
                        new_key.time = 2 * firsttime - new_key.time - delta_time;
                        new_keys.push_back(new_key);
                    }
                }

                (*it).keys.insert((*it).keys.begin(), new_keys.begin(), new_keys.end());
                (*it).old_first += new_keys.size();
                break;
            }
            default:
                break;
        }