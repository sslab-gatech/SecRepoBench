switch ((*it).pre) {

        case LWO::PrePostBehaviour_OffsetRepeat:
        case LWO::PrePostBehaviour_Repeat: {
            const double val_delta = (*it).keys.back().value - (*it).keys.front().value;

            size_t old_size = (*it).keys.size();
            double post_time = firsttime;
            while (post_time > first) {
                post_time -= delta;
                for (size_t n = 0; n < old_size; ++n) {
                    LWO::Key k = (*it).keys[n];
                    k.time = post_time + (k.time - firsttime);
                    if ((*it).pre == LWO::PrePostBehaviour_OffsetRepeat) {
                        k.value -= val_delta;
                    }
                    (*it).keys.insert((*it).keys.begin(), k);
                }
            }
            break;
        }
        case LWO::PrePostBehaviour_Oscillate: {
            const size_t old_size = (*it).keys.size();
            double post_time = firsttime;
            bool reverse = false;
            while (post_time > first) {
                post_time -= delta;
                for (size_t n = 0; n < old_size; ++n) {
                    LWO::Key k = (*it).keys[old_size - 1 - n];
                    k.time = post_time + (k.time - firsttime);
                    if (reverse) {
                        k.value = 2 * (*it).keys.front().value - k.value;
                    }
                    (*it).keys.insert((*it).keys.begin(), k);
                }
                reverse = !reverse;
            }
            break;
        }
        default:
            // silence compiler warning
            break;
        }