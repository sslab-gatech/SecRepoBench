switch ((*it).pre) {
case LWO::PrePostBehaviour_OffsetRepeat:
case LWO::PrePostBehaviour_Repeat:
case LWO::PrePostBehaviour_Oscillate:
    {
        double offset = 0.0;
        double repeat = 1.0;
        double osc = 0.0;

        switch ((*it).pre) {
        case LWO::PrePostBehaviour_OffsetRepeat:
            offset = (*it).keys.front().value;
            repeat = delta;
            break;
        case LWO::PrePostBehaviour_Repeat:
            repeat = delta;
            break;
        case LWO::PrePostBehaviour_Oscillate:
            osc = delta;
            break;
        }

        double new_time = first - delta;
        while (new_time < first) {
            LWO::Key new_key;
            new_key.time = new_time;
            new_key.value = (*it).keys.front().value;

            if ((*it).pre == LWO::PrePostBehaviour_OffsetRepeat) {
                new_key.value += offset;
            } else if ((*it).pre == LWO::PrePostBehaviour_Oscillate) {
                new_key.value = (*it).keys.front().value + (new_key.time - first) / osc * ((*it).keys.back().value - (*it).keys.front().value);
            }

            (*it).keys.insert((*it).keys.begin(), new_key);
            new_time += repeat;
        }
    }
    break;
default:
    break;
}