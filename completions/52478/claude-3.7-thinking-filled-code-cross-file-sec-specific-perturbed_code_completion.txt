// process pre behavior
(*it).old_first = 0; // Default value

switch ((*it).pre) {
    case LWO::PrePostBehaviour_OffsetRepeat:
    case LWO::PrePostBehaviour_Repeat:
    case LWO::PrePostBehaviour_Oscillate:
        if (firsttime > first && delta > 0.0) {
            std::vector<LWO::Key> new_keys;
            const size_t original_size = (*it).keys.size();
            if (original_size == 0) break; // Avoid division by zero
            
            // Calculate how many complete cycles we need to insert
            const int cycles = static_cast<int>((firsttime - first) / delta);
            
            // Pre-calculate total number of keys to add
            size_t keys_to_add = 0;
            const double remain = firsttime - first - cycles * delta;
            
            // Full cycles
            keys_to_add += cycles * original_size;
            
            // Partial cycle
            if (remain > 0.0) {
                for (size_t i = 0; i < original_size; ++i) {
                    if ((*it).keys[i].time - firsttime <= remain) {
                        keys_to_add++;
                    } else {
                        break;
                    }
                }
            }
            
            // Reserve space for all the new keys
            new_keys.reserve(keys_to_add);
            
            // Add keys for full cycles
            for (int i = cycles; i > 0; --i) {
                for (size_t k = 0; k < original_size; ++k) {
                    LWO::Key new_key = (*it).keys[k];
                    
                    // Adjust time
                    new_key.time -= delta * i;
                    
                    // Adjust value based on behavior
                    if ((*it).pre == LWO::PrePostBehaviour_OffsetRepeat) {
                        new_key.value -= ((*it).keys.back().value - (*it).keys.front().value) * i;
                    } else if ((*it).pre == LWO::PrePostBehaviour_Oscillate && (i & 1)) {
                        // Reverse value for oscillate on odd cycles
                        const float front_value = (*it).keys.front().value;
                        const float back_value = (*it).keys.back().value;
                        new_key.value = back_value - (new_key.value - front_value);
                    }
                    
                    // Add to new keys
                    new_keys.push_back(new_key);
                }
            }
            
            // Handle partial cycle if needed
            if (remain > 0.0) {
                for (size_t i = 0; i < original_size; ++i) {
                    if ((*it).keys[i].time - firsttime <= remain) {
                        LWO::Key new_key = (*it).keys[i];
                        
                        // Adjust time
                        new_key.time -= (cycles + 1) * delta;
                        
                        // Adjust value based on behavior
                        if ((*it).pre == LWO::PrePostBehaviour_OffsetRepeat) {
                            new_key.value -= ((*it).keys.back().value - (*it).keys.front().value) * (cycles + 1);
                        } else if ((*it).pre == LWO::PrePostBehaviour_Oscillate && ((cycles + 1) & 1)) {
                            // Reverse value for oscillate on odd cycles
                            const float front_value = (*it).keys.front().value;
                            const float back_value = (*it).keys.back().value;
                            new_key.value = back_value - (new_key.value - front_value);
                        }
                        
                        // Add to new keys
                        new_keys.push_back(new_key);
                    } else {
                        break;
                    }
                }
            }
            
            // Insert all new keys at the beginning
            if (!new_keys.empty()) {
                (*it).keys.insert((*it).keys.begin(), new_keys.begin(), new_keys.end());
                (*it).old_first = new_keys.size();
            }
        }
        break;
        
    default:
        // Nothing to do for other behaviors
        break;
}

// Track last key position for later cleanup
(*it).old_last = (*it).keys.size() - 1;