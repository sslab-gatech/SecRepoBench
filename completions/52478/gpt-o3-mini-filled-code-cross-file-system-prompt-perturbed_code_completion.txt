{
    // Backup the original keys and clear the vector so we can prepend extra keys.
    std::vector<LWO::Key> original = (*it).keys;
    (*it).keys.clear();
    size_t preKeysCount = 0;

    // Insert extra keys for pre-range behaviors if needed.
    switch ((*it).pre) {
    case LWO::PrePostBehaviour_OffsetRepeat:
    case LWO::PrePostBehaviour_Repeat:
    case LWO::PrePostBehaviour_Oscillate:
    {
        // Repeat backwards until the first generated key is not after the global start time.
        int rep = 1;
        // Generate repeated segments while the first key of the repeated segment is still later than the global start time.
        while (original.front().time - rep * delta > first) {
            // For each key in the original envelope, create a new key for the pre-range.
            for (size_t j = 0, n = original.size(); j < n; ++j) {
                LWO::Key key = original[j];
                key.time -= rep * delta;
                if ((*it).pre == LWO::PrePostBehaviour_OffsetRepeat) {
                    // For OffsetRepeat, subtract an offset proportional to the repetition count.
                    key.value -= rep * (original.back().value - original.front().value);
                } else if ((*it).pre == LWO::PrePostBehaviour_Oscillate) {
                    // For Oscillate, mirror the key values on every odd repetition.
                    if (rep & 1)
                        key.value = original.front().value + (original.back().value - key.value);
                }
                (*it).keys.push_back(key);
                ++preKeysCount;
            }
            ++rep;
        }
    }
        break;
    default:
        // If no special pre-behavior, do nothing.
        break;
    }

    // Append the original keys.
    const size_t origSize = original.size();
    (*it).old_first = preKeysCount;
    (*it).old_last = preKeysCount + origSize - 1;
    (*it).keys.insert((*it).keys.end(), original.begin(), original.end());
}