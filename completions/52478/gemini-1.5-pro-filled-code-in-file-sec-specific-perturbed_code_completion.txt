switch ((*it).pre) {

        case LWO::PrePostBehaviour_OffsetRepeat:
        case LWO::PrePostBehaviour_Repeat: {
            const size_t old_size = (*it).keys.size();
            (*it).keys.reserve(old_size * 3);

            double start_time = (*it).keys[0].time;
            double end_time = (*it).keys.back().time;
            double value_delta = (*it).keys.back().value - (*it).keys[0].value;

            (*it).keys.insert((*it).keys.begin(), (*it).keys.rbegin(), (*it).keys.rend() - 1);
            for (size_t n = 0; n < old_size - 1; ++n) {
                (*it).keys[n].time -= delta;
            }

            (*it).keys.insert((*it).keys.end(), (*it).keys.begin() + 1, (*it).keys.begin() + old_size - 1);
            for (size_t n = 0; n < old_size - 1; ++n) {
                (*it).keys[n + old_size + old_size - 1].time += delta;
            }

            if ((*it).pre == LWO::PrePostBehaviour_OffsetRepeat) {
                for (size_t n = 0; n < old_size; ++n) {
                    (*it).keys[n + old_size - 1].value -= value_delta;
                }
                for (size_t n = 0; n < old_size; ++n) {
                    (*it).keys[n + old_size + old_size - 1].value += value_delta;
                }
            }
            break;
        }

        case LWO::PrePostBehaviour_Oscillate: {
            const size_t old_size = (*it).keys.size();
            (*it).keys.reserve(old_size * 3);
            (*it).keys.insert((*it).keys.begin(), (*it).keys.rbegin(), (*it).keys.rend() - 1);
            for (size_t n = 0; n < old_size - 1; ++n)
                (*it).keys[n].time -= delta;

            for (size_t n = 0; n < old_size - 1; ++n) {
                Key k = (*it).keys[n + 1];
                k.time = (*it).keys.back().time + ((*it).keys.back().time - k.time);
                (*it).keys.push_back(k);
            }
            break;
        }
        default:
            // silence compiler warning
            break;
        }