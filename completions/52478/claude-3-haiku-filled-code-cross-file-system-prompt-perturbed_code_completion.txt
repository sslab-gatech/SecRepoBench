// Handles the pre-behavior of LightWave envelopes by inserting additional keyframes
// for pre-defined behaviors such as OffsetRepeat, Repeat, and Oscillate. This involves
// calculating the time delta between keys and adjusting keyframe values accordingly.
// The logic uses the start time, end time, and value delta to calculate new keyframe
// positions and values, adapting to the pre-behavior type.
switch ((*it).pre) {
case LWO::PrePostBehaviour_OffsetRepeat:
case LWO::PrePostBehaviour_Repeat:
case LWO::PrePostBehaviour_Oscillate:
    {
        double start_time = (*it).keys.front().time;
        double end_time = (*it).keys.back().time;
        double value_delta = (*it).keys.back().value - (*it).keys.front().value;

        // Calculate the time delta between the first and last keyframes
        double time_delta = end_time - start_time;

        // Adjust the keyframe values and positions based on the pre-behavior type
        switch ((*it).pre) {
        case LWO::PrePostBehaviour_OffsetRepeat:
            {
                // Offset the keyframe values by the value delta
                for (std::vector<LWO::Key>::iterator key_it = (*it).keys.begin(); key_it != (*it).keys.end(); ++key_it) {
                    key_it->value += value_delta * static_cast<int>((key_it->time - start_time) / time_delta);
                }
            }
            break;
        case LWO::PrePostBehaviour_Repeat:
            {
                // Repeat the keyframe values within the time delta
                for (std::vector<LWO::Key>::iterator key_it = (*it).keys.begin(); key_it != (*it).keys.end(); ++key_it) {
                    key_it->time = fmod(key_it->time - start_time, time_delta) + start_time;
                }
            }
            break;
        case LWO::PrePostBehaviour_Oscillate:
            {
                // Oscillate the keyframe values within the time delta
                for (std::vector<LWO::Key>::iterator key_it = (*it).keys.begin(); key_it != (*it).keys.end(); ++key_it) {
                    double relative_time = key_it->time - start_time;
                    double oscillation_time = fmod(relative_time, 2 * time_delta);
                    if (oscillation_time > time_delta) {
                        oscillation_time = 2 * time_delta - oscillation_time;
                    }
                    key_it->time = oscillation_time + start_time;
                    key_it->value = (*it).keys.front().value + value_delta * (oscillation_time / time_delta);
                }
            }
            break;
        default:
            // silence compiler warning
            break;
        }
    }
    break;

default:
    // silence compiler warning
    break;
}