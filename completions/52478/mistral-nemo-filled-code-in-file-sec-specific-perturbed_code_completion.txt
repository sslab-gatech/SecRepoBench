// process pre behavior
    switch ((*it).pre) {

    case LWO::PrePostBehaviour_OffsetRepeat:
    case LWO::PrePostBehaviour_Repeat:
    case LWO::PrePostBehaviour_Oscillate:
        // Calculate the time delta between keys and adjust keyframe values accordingly
        double delta = (*it).keys.back().time - (*it).keys.front().time;
        double valueDelta = (*it).keys.back().value - (*it).keys.front().value;

        // Insert additional keyframes for pre-defined behaviors
        if ((*it).pre == LWO::PrePostBehaviour_OffsetRepeat) {
            // Insert keyframes for offset repeat behavior
            for (size_t i = 0; i < (*it).keys.size() - 1; ++i) {
                double newTime = (*it).keys[i].time + delta;
                double newValue = (*it).keys[i].value + valueDelta;
                (*it).keys.insert((*it).keys.begin() + i + 1, LWO::Key(newTime, newValue));
            }
        } else if ((*it).pre == LWO::PrePostBehaviour_Repeat) {
            // Insert keyframes for repeat behavior
            for (size_t i = 0; i < (*it).keys.size() - 1; ++i) {
                double newTime = (*it).keys[i].time + delta;
                double newValue = (*it).keys[i].value;
                (*it).keys.insert((*it).keys.begin() + i + 1, LWO::Key(newTime, newValue));
            }
        } else if ((*it).pre == LWO::PrePostBehaviour_Oscillate) {
            // Insert keyframes for oscillate behavior
            for (size_t i = 0; i < (*it).keys.size() - 1; ++i) {
                double newTime = (*it).keys[i].time + delta / 2.0;
                double newValue = (*it).keys[i].value + (valueDelta / 2.0);
                (*it).keys.insert((*it).keys.begin() + i + 1, LWO::Key(newTime, newValue));
            }
        }
        break;

    default:
        // silence compiler warning
        break;
    }