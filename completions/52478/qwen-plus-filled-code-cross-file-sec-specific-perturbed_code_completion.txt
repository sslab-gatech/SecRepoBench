// Handles the pre-behavior of LightWave envelopes by inserting additional keyframes
// for pre-defined behaviors such as OffsetRepeat, Repeat, and Oscillate.

switch ((*it).pre) {
    case LWO::PrePostBehaviour_OffsetRepeat: {
        double repeat_time = delta;
        double offset = firsttime - repeat_time;

        // Ensure that the new keys will not overflow the vector capacity.
        size_t old_size = (*it).keys.size();
        size_t estimated_new_keys = static_cast<size_t>((firsttime - offset) / repeat_time);
        (*it).keys.reserve(old_size + estimated_new_keys);

        for (size_t i = 0; i < estimated_new_keys; ++i) {
            for (const auto& key : (*it).keys) {
                LWO::Key new_key = key;
                new_key.time += offset;
                if (new_key.time >= firsttime) break; // Stop if new key is beyond the start time.
                (*it).keys.emplace_back(new_key);
            }
            offset -= repeat_time;
        }

        std::sort((*it).keys.begin(), (*it).keys.end(), [](const LWO::Key& a, const LWO::Key& b) {
            return a.time < b.time;
        });
        break;
    }

    case LWO::PrePostBehaviour_Repeat: {
        double repeat_time = delta;
        double offset = firsttime - repeat_time;

        size_t old_size = (*it).keys.size();
        size_t estimated_new_keys = static_cast<size_t>((firsttime - offset) / repeat_time);
        (*it).keys.reserve(old_size + estimated_new_keys);

        for (size_t i = 0; i < estimated_new_keys; ++i) {
            for (const auto& key : (*it).keys) {
                LWO::Key new_key = key;
                new_key.time += offset;
                if (new_key.time >= firsttime) break; // Stop if new key is beyond the start time.
                (*it).keys.emplace_back(new_key);
            }
            offset -= repeat_time;
        }

        std::sort((*it).keys.begin(), (*it).keys.end(), [](const LWO::Key& a, const LWO::Key& b) {
            return a.time < b.time;
        });
        break;
    }

    case LWO::PrePostBehaviour_Oscillate: {
        double oscillate_time = delta * 2;
        double offset = firsttime - oscillate_time;

        size_t old_size = (*it).keys.size();
        size_t estimated_new_keys = static_cast<size_t>((firsttime - offset) / oscillate_time);
        (*it).keys.reserve(old_size + estimated_new_keys * (*it).keys.size());

        for (size_t i = 0; i < estimated_new_keys; ++i) {
            bool reverse = (i % 2 == 1);
            for (const auto& key : (*it).keys) {
                LWO::Key new_key = key;
                new_key.time += offset;
                if (reverse) new_key.value = (*it).keys.front().value + ((*it).keys.back().value - (*it).keys.front().value) - (new_key.value - (*it).keys.front().value);
                if (new_key.time >= firsttime) break; // Stop if new key is beyond the start time.
                (*it).keys.emplace_back(new_key);
            }
            offset -= oscillate_time;
        }

        std::sort((*it).keys.begin(), (*it).keys.end(), [](const LWO::Key& a, const LWO::Key& b) {
            return a.time < b.time;
        });
        break;
    }

    default:
        // No action needed for other pre-behaviors.
        break;
}