const float first_value = (*it).keys.front().value;
        const float last_value = (*it).keys.back().value;
        const float value_delta = last_value - first_value;

        switch ((*it).pre) {
            case LWO::PrePostBehaviour_OffsetRepeat: {
                if (delta > 0.0) {
                    const int num_cycles = static_cast<int>((firsttime - first) / delta);
                    std::vector<LWO::Key> new_keys;
                    for (int i = 1; i <= num_cycles; ++i) {
                        for (const auto& key : (*it).keys) {
                            LWO::Key new_key = key;
                            new_key.time = key.time - i * delta;
                            new_key.value = key.value - i * value_delta;
                            new_keys.push_back(new_key);
                        }
                    }
                    (*it).keys.insert((*it).keys.begin(), new_keys.begin(), new_keys.end());
                    (*it).old_first += new_keys.size();
                }
                break;
            }
            case LWO::PrePostBehaviour_Repeat: {
                if (delta > 0.0) {
                    const int num_cycles = static_cast<int>((firsttime - first) / delta);
                    std::vector<LWO::Key> new_keys;
                    for (int i = 1; i <= num_cycles; ++i) {
                        for (const auto& key : (*it).keys) {
                            LWO::Key new_key = key;
                            new_key.time = key.time - i * delta;
                            new_keys.push_back(new_key);
                        }
                    }
                    (*it).keys.insert((*it).keys.begin(), new_keys.begin(), new_keys.end());
                    (*it).old_first += new_keys.size();
                }
                break;
            }
            case LWO::PrePostBehaviour_Oscillate: {
                if (delta > 0.0) {
                    const int num_cycles = static_cast<int>((firsttime - first) / delta);
                    const float value_offset = first_value + last_value;
                    std::vector<LWO::Key> new_keys;
                    for (int i = 1; i <= num_cycles; ++i) {
                        if (i % 2 == 1) {
                            for (auto it_key = (*it).keys.rbegin(); it_key != (*it).keys.rend(); ++it_key) {
                                LWO::Key new_key = *it_key;
                                new_key.time = firsttime - i * delta - (new_key.time - firsttime);
                                new_key.value = value_offset - new_key.value;
                                new_keys.push_back(new_key);
                            }
                        } else {
                            for (const auto& key : (*it).keys) {
                                LWO::Key new_key = key;
                                new_key.time = key.time - i * delta;
                                new_keys.push_back(new_key);
                            }
                        }
                    }
                    (*it).keys.insert((*it).keys.begin(), new_keys.begin(), new_keys.end());
                    (*it).old_first += new_keys.size();
                }
                break;
            }
            default:
                break;
        }