switch ((*it).pre) {
        case LWO::PrePostBehaviour_OffsetRepeat: {
            if (delta == 0.0) break;
            const double time_diff = first - firsttime;
            double num_repeats = time_diff / delta;
            num_repeats = floor(num_repeats);
            const double offset = (my_last - firsttime) * (float)num_repeats;

            LWO::Key k = (*it).keys.front();
            k.time = first;
            k.value -= (float)offset;
            (*it).keys.insert((*it).keys.begin(), k);
            (*it).old_first++;
            break;
        }
        case LWO::PrePostBehaviour_Repeat: {
            if (delta == 0.0) break;
            const double time_diff = first - firsttime;
            double num_repeats = time_diff / delta;
            num_repeats = floor(num_repeats);
            const double offset = delta * (float)num_repeats;

            LWO::Key k = (*it).keys.front();
            k.time = first;
            k.value = k.value;
            (*it).keys.insert((*it).keys.begin(), k);
            (*it).old_first++;
            break;
        }
        case LWO::PrePostBehaviour_Oscillate: {
            // not yet implemented
            if (delta == 0.0) break;
            const double time_diff = first - firsttime;
            double num_repeats = time_diff / delta;
            num_repeats = floor(num_repeats);
            const double offset = delta * (float)num_repeats;

            LWO::Key k = (*it).keys.front();
            k.time = first;
            k.value = k.value;
            (*it).keys.insert((*it).keys.begin(), k);
            (*it).old_first++;
            break;
        }
        default:
            // silence compiler warning
            break;
        }