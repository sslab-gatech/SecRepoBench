switch ((*it).pre) {
    case LWO::PrePostBehaviour_OffsetRepeat:
    case LWO::PrePostBehaviour_Repeat:
    case LWO::PrePostBehaviour_Oscillate:
    {
        // Example logic for handling pre-behavior by inserting an extra "cycle" of keys
        // (placeholder implementation â€” adjust as needed)
        const double offsetValue = (*it).keys.back().value - (*it).keys.front().value;
        // For demonstration, insert a single "cycle" before the first key
        std::vector<LWO::Key> newKeys;
        newKeys.reserve((*it).keys.size());
        for (size_t k = 0; k < (*it).keys.size(); ++k) {
            const LWO::Key &origKey = (*it).keys[k];
            LWO::Key copyKey = origKey;
            copyKey.time = firsttime - (my_last - origKey.time);
            switch ((*it).pre) {
            case LWO::PrePostBehaviour_OffsetRepeat:
                copyKey.value += offsetValue;
                break;
            case LWO::PrePostBehaviour_Oscillate:
                // If we wanted an oscillation, we could invert the ordering here,
                // but for a simple example just reuse the existing key values
                break;
            default:
                break;
            }
            newKeys.push_back(copyKey);
        }
        // Insert them at the beginning
        (*it).keys.insert((*it).keys.begin(), newKeys.begin(), newKeys.end());
        break;
    }
    default:
        break;
}