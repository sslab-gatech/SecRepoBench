SpeedHQContext *s = codec_context->priv_data;
    const uint8_t *buf = avpkt->data;
    int buf_size = avpkt->size;
    int ret;
    int second_field_offset;

    if (buf_size < 4) {
        return AVERROR_INVALIDDATA;
    }

    if (avpkt->size < 12) {
        av_log(codec_context, AV_LOG_ERROR, "Packet size too small\n");
        return AVERROR_INVALIDDATA;
    }

    s->quality = buf[0];
    if (s->quality > 100) {
        av_log(codec_context, AV_LOG_ERROR, "Invalid quality parameter\n");
        return AVERROR_INVALIDDATA;
    }

    s->width = AV_RL16(buf + 2);
    s->height = AV_RL16(buf + 4);

    if (s->width <= 0 || s->height <= 0) {
        av_log(codec_context, AV_LOG_ERROR, "Invalid width or height\n");
        return AVERROR_INVALIDDATA;
    }

    if (s->width > codec_context->width || s->height > codec_context->height) {
        av_log(codec_context, AV_LOG_ERROR, "Decoded frame dimensions exceed codec context dimensions\n");
        return AVERROR_INVALIDDATA;
    }

    codec_context->width = s->width;
    codec_context->height = s->height;

    ff_speedhq_calculate_qmatrix(s);