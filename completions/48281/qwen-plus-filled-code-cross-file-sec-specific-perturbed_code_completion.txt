SpeedHQContext *s = codec_context->priv_data;
const uint8_t *buf = avpkt->data;
int buf_size = avpkt->size;
int ret;

if (buf_size < 12) {
    av_log(codec_context, AV_LOG_ERROR, "Packet is too small to contain valid frame data.\n");
    return AVERROR_INVALIDDATA;
}

if (codec_context->width <= 0 || codec_context->height <= 0) {
    av_log(codec_context, AV_LOG_ERROR, "Invalid video dimensions.\n");
    return AVERROR_INVALIDDATA;
}

// Ensure the buffer size is sufficient for at least one field
if (buf_size < second_field_offset + 3) {
    av_log(codec_context, AV_LOG_ERROR, "Insufficient data for decoding fields.\n");
    return AVERROR_INVALIDDATA;
}

// Extract quality parameter and calculate quantization matrix
int quality_param = AV_RL24(buf);
if (quality_param < 0 || quality_param > MAX_QUALITY_PARAMETER) {
    av_log(codec_context, AV_LOG_WARNING, "Quality parameter out of expected range, clamping.\n");
    quality_param = av_clip(quality_param, 0, MAX_QUALITY_PARAMETER);
}
speedhq_calculate_qmatrix(s, quality_param);

// Allocate internal buffers if necessary (ensure heap allocations are safe)
if (!s->internal_buffer || s->allocated_size < buf_size) {
    uint8_t *new_buffer = av_realloc(s->internal_buffer, buf_size);
    if (!new_buffer) {
        av_log(codec_context, AV_LOG_ERROR, "Failed to reallocate internal buffer.\n");
        return AVERROR(ENOMEM);
    }
    s->internal_buffer = new_buffer;
    s->allocated_size = buf_size;
}
memcpy(s->internal_buffer, buf, buf_size);