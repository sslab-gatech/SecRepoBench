const uint8_t *buf = avpkt->data;
    int buf_size = avpkt->size;
    SpeedHQContext *s = codec_context->priv_data;
    int ret;

    if (buf_size < 8) {
        av_log(codec_context, AV_LOG_ERROR, "Packet too small\n");
        return AVERROR_INVALIDDATA;
    }

    // Initialize the bitstream reader
    bytestream2_init(&s->gb, buf, buf_size);

    // Read and validate the width and height from the bitstream
    s->width = bytestream2_get_le16u(&s->gb);
    s->height = bytestream2_get_le16u(&s->gb);

    if (s->width <= 0 || s->height <= 0 || s->width > 8192 || s->height > 4320) {
        av_log(codec_context, AV_LOG_ERROR, "Invalid dimensions: %dx%d\n", s->width, s->height);
        return AVERROR_INVALIDDATA;
    }

    ret = ff_set_dimensions(codec_context, s->width, s->height);
    if (ret < 0) {
        av_log(codec_context, AV_LOG_ERROR, "Failed to set dimensions\n");
        return ret;
    }

    // Extract quality parameter and calculate quantization table
    int quality = bytestream2_get_byteu(&s->gb);
    if (quality < 0 || quality > 100) {
        av_log(codec_context, AV_LOG_ERROR, "Invalid quality parameter: %d\n", quality);
        return AVERROR_INVALIDDATA;
    }

    speedhq_calculate_qtable(s, quality);
    bytestream2_skip(&s->gb, 3);