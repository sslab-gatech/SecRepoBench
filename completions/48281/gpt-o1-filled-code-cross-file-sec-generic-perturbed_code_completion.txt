SpeedHQContext *s = codec_context->priv_data;
    const uint8_t *buf = avpkt->data;
    int buf_size = avpkt->size;
    int ret;

    /* Ensure the packet has enough data to read at least the quality byte
       plus the bytes needed for the second_field_offset calculation. */
    if (buf_size < 4) {
        av_log(codec_context, AV_LOG_ERROR, "Packet too small\n");
        return AVERROR_INVALIDDATA;
    }

    /* Extract a quality parameter from the first byte. */
    int quality = buf[0];
    /* Clamp quality to a reasonable range. */
    if (quality < 1) {
        av_log(codec_context, AV_LOG_WARNING, "Quality too low, clamping to 1\n");
        quality = 1;
    } else if (quality > 100) {
        av_log(codec_context, AV_LOG_WARNING, "Quality too high, clamping to 100\n");
        quality = 100;
    }

    /* Use the quality parameter to calculate the quantization tables. */
    speedhq_calculate_qtable(s, quality);