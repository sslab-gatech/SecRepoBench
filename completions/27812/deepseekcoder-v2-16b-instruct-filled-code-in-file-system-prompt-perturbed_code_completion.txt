ize;
    if (leftover_block > 0) {
      nblocks++;
    }
    lazychunk_cbytes = nblocks * chunk_blocksize;
    *chunk = malloc(lazychunk_cbytes);
    fseek(fp, header_len + offset, SEEK_SET);
    rbytes = fread(*chunk, 1, lazychunk_cbytes, fp);
    if (rbytes != lazychunk_cbytes) {
      BLOSC_TRACE_ERROR("Cannot read the chunk out of the fileframe.");
      return -6;
    }
    fclose(fp);
    *needs_free = true;
  } else {
    // The chunk is in memory and just one pointer away
    *chunk = frame->sdata + header_len + offset;
    size_t chunk_cbytes;
    size_t chunk_blocksize;
    uint8_t header[BLOSC_MIN_HEADER_LENGTH];
    memcpy(header, *chunk, BLOSC_MIN_HEADER_LENGTH);
    blosc_cbuffer_sizes(header, NULL, &chunk_cbytes, &chunk_blocksize);
    lazychunk_cbytes = chunk_cbytes;
  }

  return lazychunk_cbytes;
}


int frame_get_chunk_nbytes(blosc2_frame *frame, int nchunk) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int32_t chunksize;
  int32_t nchunks;

  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get meta info from frame.");
    return -1;
  }

  if (nchunk >= nchunks) {
    BLOSC_TRACE_ERROR("nchunk ('%d') exceeds the number of chunks "
                      "('%d') in frame.", nchunk, nchunks);
    return -2;
  }

  // Get the offset to nchunk
  int64_t offset = get_coffset(frame, header_len, cbytes, nchunk);

  int32_t chunk_cbytes;
  if (frame->sdata == NULL) {
    FILE* fp = fopen(frame->fname, "rb");
    fseek(fp, header_len + offset + BLOSC2_CHUNK_CBYTES, SEEK_SET);
    size_t rbytes = fread(&chunk_cbytes, 1, sizeof(chunk_cbytes), fp);
    if (rbytes != sizeof(chunk_cbytes)) {
      BLOSC_TRACE_ERROR("Cannot read the cbytes for chunk in the fileframe.");
      return -5;
    }
    chunk_cbytes = sw32_(&chunk_cbytes);
    fclose(fp);
  } else {
    // The chunk is in memory and just one pointer away
    chunk_cbytes = sw32_(frame->sdata + header_len + offset + BLOSC2_CHUNK_CBYTES);
  }

  return chunk_cbytes;
}


int frame_get_chunk_cbytes(blosc2_frame *frame, int nchunk) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int32_t chunksize;
  int32_t nchunks;

  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get meta info from frame.");
    return -1;
  }

  if (nchunk >= nchunks) {
    BLOSC_TRACE_ERROR("nchunk ('%d') exceeds the number of chunks "
                      "('%d') in frame.", nchunk, nchunks);
    return -2;
  }

  // Get the offset to nchunk
  int64_t offset = get_coffset(frame, header_len, cbytes, nchunk);

  int32_t chunk_cbytes;
  if (frame->sdata == NULL) {
    FILE* fp = fopen(frame->fname, "rb");
    fseek(fp, header_len + offset + BLOSC2_CHUNK_CBYTES, SEEK_SET);
    size_t rbytes = fread(&chunk_cbytes, 1, sizeof(chunk_cbytes), fp);
    if (rbytes != sizeof(chunk_cbytes)) {
      BLOSC_TRACE_ERROR("Cannot read the cbytes for chunk in the fileframe.");
      return -5;
    }
    chunk_cbytes = sw32_(&chunk_cbytes);
    fclose(fp);
  } else {
    // The chunk is in memory and just one pointer away
    chunk_cbytes = sw32_(frame->sdata + header_len + offset + BLOSC2_CHUNK_CBYTES);
  }

  return chunk_cbytes;
}


int frame_get_chunk_nbytes_lazy(blosc2_frame *frame, int nchunk) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int32_t chunksize;
  int32_t nchunks;

  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get meta info from frame.");
    return -1;
  }

  if (nchunk >= nchunks) {
    BLOSC_TRACE_ERROR("nchunk ('%d') exceeds the number of chunks "
                      "('%d') in frame.", nchunk, nchunks);
    return -2;
  }

  // Get the offset to nchunk
  int64_t offset = get_coffset(frame, header_len, cbytes, nchunk);

  size_t chunk_nbytes;
  size_t chunk_cbytes;
  size_t chunk_blocksize;
  uint8_t header[BLOSC_MIN_HEADER_LENGTH];
  if (frame->sdata == NULL) {
    FILE* fp = fopen(frame->fname, "rb");
    fseek(fp, header_len + offset, SEEK_SET);
    size_t rbytes = fread(header, 1, BLOSC_MIN_HEADER_LENGTH, fp);
    if (rbytes != BLOSC_MIN_HEADER_LENGTH) {
      BLOSC_TRACE_ERROR("Cannot read the header for chunk in the fileframe.");
      return -5;
    }
    blosc_cbuffer_sizes(header, &chunk_nbytes, &chunk_cbytes, &chunk_blocksize);
    fclose(fp);
  } else {
    // The chunk is in memory and just one pointer away
    memcpy(header, frame->sdata + header_len + offset, BLOSC_MIN_HEADER_LENGTH);
    blosc_cbuffer_sizes(header, &chunk_nbytes, &chunk_cbytes, &chunk_blocksize);
  }

  return chunk_nbytes;
}


int frame_get_chunk_cbytes_lazy(blosc2_frame *frame, int nchunk) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int32_t chunksize;
  int32_t nchunks;

  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get meta info from frame.");
    return -1;
  }

  if (nchunk >= nchunks) {
    BLOSC_TRACE_ERROR("nchunk ('%d') exceeds the number of chunks "
                      "('%d') in frame.", nchunk, nchunks);
    return -2;
  }

  // Get the offset to nchunk
  int64_t offset = get_coffset(frame, header_len, cbytes, nchunk);

  size_t chunk_cbytes;
  size_t chunk_blocksize;
  uint8_t header[BLOSC_MIN_HEADER_LENGTH];
  if (frame->sdata == NULL) {
    FILE* fp = fopen(frame->fname, "rb");
    fseek(fp, header_len + offset, SEEK_SET);
    size_t rbytes = fread(header, 1, BLOSC_MIN_HEADER_LENGTH, fp);
    if (rbytes != BLOSC_MIN_HEADER_LENGTH) {
      BLOSC_TRACE_ERROR("Cannot read the header for chunk in the fileframe.");
      return -5;
    }
    blosc_cbuffer_sizes(header, NULL, &chunk_cbytes, &chunk_blocksize);
    fclose(fp);
  } else {
    // The chunk is in memory and just one pointer away
    memcpy(header, frame->sdata + header_len + offset, BLOSC_MIN_HEADER_LENGTH);
    blosc_cbuffer_sizes(header, NULL, &chunk_cbytes, &chunk_blocksize);
  }

  return chunk_cbytes;
}


int frame_get_chunk_blocksize(blosc2_frame *frame, int nchunk) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int32_t chunksize;
  int32_t nchunks;

  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get meta info from frame.");
    return -1;
  }

  if (nchunk >= nchunks) {
    BLOSC_TRACE_ERROR("nchunk ('%d') exceeds the number of chunks "
                      "('%d') in frame.", nchunk, nchunks);
    return -2;
  }

  // Get the offset to nchunk
  int64_t offset = get_coffset(frame, header_len, cbytes, nchunk);

  int32_t chunk_blocksize;
  if (frame->sdata == NULL) {
    FILE* fp = fopen(frame->fname, "rb");
    fseek(fp, header_len + offset + BLOSC2_CHUNK_BLOCKSIZE, SEEK_SET);
    size_t rbytes = fread(&chunk_blocksize, 1, sizeof(chunk_blocksize), fp);
    if (rbytes != sizeof(chunk_blocksize)) {
      BLOSC_TRACE_ERROR("Cannot read the blocksize for chunk in the fileframe.");
      return -5;
    }
    chunk_blocksize = sw32_(&chunk_blocksize);
    fclose(fp);
  } else {
    // The chunk is in memory and just one pointer away
    chunk_blocksize = sw32_(frame->sdata + header_len + offset + BLOSC2_CHUNK_BLOCKSIZE);
  }

  return chunk_blocksize;
}


int frame_get_chunk_type(blosc2_frame *frame, int nchunk) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int32_t chunksize;
  int32_t nchunks;

  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
  if (ret < 0