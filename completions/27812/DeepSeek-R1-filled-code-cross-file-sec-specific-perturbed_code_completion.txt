if (ret != 0) {
    return ret;
}

int64_t trailer_offset = header_len + cbytes;
if (trailer_offset < 0 || (frame_struct->sdata && trailer_offset > (int64_t)frame_struct->len)) {
    BLOSC_TRACE_ERROR("Invalid trailer offset.");
    return -1;
}

uint32_t trailer_len;
if (frame_struct->sdata != NULL) {
    if (trailer_offset + FRAME_TRAILER_MINLEN > frame_struct->len) {
        BLOSC_TRACE_ERROR("Trailer exceeds frame bounds.");
        return -1;
    }
    const uint8_t* trailer = frame_struct->sdata + trailer_offset;
    if (trailer[FRAME_TRAILER_LEN_OFFSET - 1] != 0xCE) {
        BLOSC_TRACE_ERROR("Invalid trailer magic byte.");
        return -1;
    }
    swap_store(&trailer_len, trailer + FRAME_TRAILER_LEN_OFFSET, sizeof(trailer_len));
} else {
    FILE* fp = fopen(frame_struct->fname, "rb");
    if (fp == NULL) {
        BLOSC_TRACE_ERROR("Cannot open file for trailer access.");
        return -1;
    }
    if (fseek(fp, trailer_offset, SEEK_SET) != 0) {
        BLOSC_TRACE_ERROR("Cannot seek to trailer position.");
        fclose(fp);
        return -1;
    }
    uint8_t magic;
    if (fread(&magic, 1, 1, fp) != 1 || magic != 0xCE) {
        BLOSC_TRACE_ERROR("Invalid trailer magic byte.");
        fclose(fp);
        return -1;
    }
    uint32_t trailer_len_network;
    if (fread(&trailer_len_network, 1, sizeof(uint32_t), fp) != sizeof(uint32_t)) {
        BLOSC_TRACE_ERROR("Cannot read trailer length.");
        fclose(fp);
        return -1;
    }
    swap_store(&trailer_len, &trailer_len_network, sizeof(trailer_len));
    fclose(fp);
}

if (trailer_len < FRAME_TRAILER_MINLEN) {
    BLOSC_TRACE_ERROR("Corrupted trailer length.");
    return -1;
}