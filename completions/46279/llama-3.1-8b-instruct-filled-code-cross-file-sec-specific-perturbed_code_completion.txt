// <MASK>
if (filters->stack->blockstartpos < end)
  return 0;

// Allocate memory for the filter's global data if it doesn't exist
if (!filters->stack->globaldata)
{
  filters->stack->globaldata = calloc(1, filters->stack->globaldatalen);
  if (!filters->stack->globaldata)
    return 0;
}

// Read the filter's global data from the archive
if (!rar_decode_byte(archivereadptr, &filters->stack->globaldata[0]))
  return 0;

// Initialize the filter's registers
filters->stack->registers[0] = filters->stack->globaldata[0];

// Initialize the filter's program code
filters->stack->prog = create_filter(filters->stack->prog, filters->stack->globaldata, filters->stack->globaldatalen, filters->stack->registers, filters->stack->blockstartpos, filters->stack->blocklength);

// Execute the filter
if (!execute_filter(archivereadptr, filters->stack, filters->vm, rar->offset))
  return 0;

// Update the filter's starting position
filters->stack->blockstartpos = filters->stack->filteredblockaddress;

// Update the filter's length
filters->stack->blocklength = filters->stack->filteredblocklength;

// Update the filter's next pointer
filters->stack->next = NULL;

// Delete the filter
delete_filter(filters->stack);

// Update the filter stack
filters->stack = filters->stack->next;

// Update the last filter address
lastfilteraddress = filters->stack->filteredblockaddress;

// Update the last filter length
lastfilterlength = filters->stack->filteredblocklength;

// Update the filter start position
filters->filterstart = filters->stack->blockstartpos;

// Update the last end position
filters->lastend = end;

// Update the bytes pointer
filters->bytes = &filters->vm->memory[lastfilteraddress];

// Update the bytes ready
filters->bytes_ready = lastfilterlength;