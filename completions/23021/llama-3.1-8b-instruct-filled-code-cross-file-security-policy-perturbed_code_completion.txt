} else if(msg_type == 0x0c) /* TGS-REQ */ {
#ifdef KERBEROS_DEBUG
  printf("[Kerberos] Processing TGS-REQ\n");
#endif

  if(body_offset < packet->payload_packet_len) {
    // Initialize offsets for name parsing, starting after the body offset with a padding adjustment.
    // Iterate through the payload to locate a specific ASN.1 identifier.
    // If the name offset is within the valid payload length, proceed to extract the realm length.
    // Adjust the offset to point to the realm string and ensure it fits within a predefined buffer size.
    // Convert the realm string to lowercase and store it in the flow's Kerberos domain.
    // If a packet buffer exists, free it and restore the packet's original payload and length.
    // Set the packet buffer to NULL after processing.
    u_int16_t name_offset = body_offset + 13;
    
    for(i=0; (i<20) && (name_offset < packet->payload_packet_len); i++) {
      if(packet->payload[name_offset]!= 0x1b)
	name_offset++; /* ASN.1 */
    }
    
#ifdef KERBEROS_DEBUG
    printf("name_offset=%u [%02X %02X] [byte 0 must be 0x1b]\n", name_offset, packet->payload[name_offset], packet->payload[name_offset+1]);
#endif

    if(name_offset < packet->payload_packet_len) {
      u_int8_t name_len;
      
      name_offset += 1;
      if(packet->payload[name_offset+1] <'') /* Isn't printable? */
	name_offset++;

      if(packet->payload[name_offset+1] == 0x1b)
	name_offset += 2;
      
      name_len = packet->payload[name_offset];

      if((name_offset+name_len) < packet->payload_packet_len) {
	char name_str[48];
	u_int8_t num_name = 0;

	while(++num_name <= 2) {
	  if(name_len > sizeof(name_str)-1)
	    name_len = sizeof(name_str)-1;

	  strncpy(name_str, (char*)&packet->payload[name_offset+1], name_len);
	  name_str[name_len] = '\0';
	  for(i=0; i<name_len; i++) name_str[i] = tolower(name_str[i]);

#ifdef KERBEROS_DEBUG
	  printf("[TGS-REQ][s/dport: %u/%u][Kerberos Name][len: %u][%s]\n", sport, destport, name_len, name_str);
#endif

	  if(((strcmp(name_str, "host") == 0) || (strcmp(name_str, "ldap") == 0)) && (packet->payload[name_offset+1+name_len] == 0x1b)) {
	    name_offset += name_len + 2;
	    name_len = packet->payload[name_offset];
	  } else
	    break;
	}

	realm_offset = name_len + name_offset + 3;

	/* if name does not end with a $ then it's a username */
	if(name_len && name_str[name_len-1] == '$') {
	  name_str[name_len-1] = '\0';
	  snprintf(flow->protos.kerberos.hostname, sizeof(flow->protos.kerberos.hostname), "%s", name_str);
	} else
	  snprintf(flow->protos.kerberos.username, sizeof(flow->protos.kerberos.username), "%s", name_str);

	for(i=0; (i < 14) && (realm_offset <  packet->payload_packet_len); i++) {
	  if(packet->payload[realm_offset]!= 0x1b)
	    realm_offset++; /* ASN.1 */
	}
	
#ifdef KERBEROS_DEBUG
	printf("realm_offset=%u [%02X %02X] [byte 0 must be 0x1b]\n", realm_offset,
	       packet->payload[realm_offset], packet->payload[realm_offset+1]);
#endif
	
	realm_offset += 1;
	//if(num_name == 2) realm_offset++;
	if(realm_offset  < packet->payload_packet_len) {
	  u_int8_t realm_len;
	  
	  realm_len = packet->payload[realm_offset];

	  if((realm_offset+realm_len) < packet->payload_packet_len) {
	    char realm_str[48];
	    
	    if(realm_len > sizeof(realm_str)-1)
	      realm_len = sizeof(realm_str)-1;

	    realm_offset += 1;

	    strncpy(realm_str, (char*)&packet->payload[realm_offset], realm_len);
	    realm_str[realm_len] = '\0';
	    for(i=0; i<realm_len; i++) realm_str[i] = tolower(realm_str[i]);

#ifdef KERBEROS_DEBUG
	    printf("[TGS-REQ][Kerberos Realm][len: %u][%s]\n", realm_len, realm_str);
#endif
	    snprintf(flow->protos.kerberos.domain, sizeof(flow->protos.kerberos.domain), "%s", realm_str);
	  }
	}
      }
    }
  }

  if(packet->udp)
    ndpi_int_kerberos_add_connection(ndpi_struct, flow);

  /* We set the protocol in the response */
  if(flow->kerberos_buf.pktbuf!= NULL) {
    ndpi_free(flow->kerberos_buf.pktbuf);
    packet->payload = original_packet_payload;
    packet->payload_packet_len = original_payload_packet_len;
    flow->kerberos_buf.pktbuf = NULL;
  }
  
  return;
}