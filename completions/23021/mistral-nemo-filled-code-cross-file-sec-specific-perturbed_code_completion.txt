if(body_offset < packet->payload_packet_len) {
  // Initialize offsets for name parsing, starting after the body offset with a padding adjustment.
  u_int16_t name_offset = body_offset + 13;

  // Iterate through the payload to locate a specific ASN.1 identifier.
  for(i=0; (i<20) && (name_offset < packet->payload_packet_len); i++) {
    if(packet->payload[name_offset] != 0x1b)
      name_offset++; /* ASN.1 */
  }

  // If the name offset is within the valid payload length, proceed to extract the realm length.
  if(name_offset < packet->payload_packet_len) {
    u_int realm_len, realm_offset;
    char realm_str[48];

    name_offset += 1;
    if(packet->payload[name_offset+1] < ' ') /* Isn't printable ? */
      name_offset++;

    if(packet->payload[name_offset+1] == 0x1b)
      name_offset += 2;

    realm_len = packet->payload[name_offset];

    // Adjust the offset to point to the realm string and ensure it fits within a predefined buffer size.
    if((realm_len+name_offset) < packet->payload_packet_len) {
      realm_offset = name_offset + 1;

      // Convert the realm string to lowercase and store it in the flow's Kerberos domain.
      strncpy(realm_str, (char*)&packet->payload[realm_offset], realm_len);
      realm_str[realm_len] = '\0';
      for(i=0; i<realm_len; i++) realm_str[i] = tolower(realm_str[i]);

#ifdef KERBEROS_DEBUG
      printf("[TGS-REQ][s/dport: %u/%u][Kerberos Realm][len: %u][%s]\n", sport, destport, realm_len, realm_str);
#endif
      snprintf(flow->protos.kerberos.domain, sizeof(flow->protos.kerberos.domain), "%s", realm_str);
    }
  }
}