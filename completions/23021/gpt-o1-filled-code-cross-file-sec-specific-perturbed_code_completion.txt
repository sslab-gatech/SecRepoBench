if(body_offset < packet->payload_packet_len) {
  /* Initialize offsets for name parsing, starting after the body offset */
  u_int16_t name_offset = body_offset + 13;
  for(i = 0; (i < 20) && (name_offset < packet->payload_packet_len); i++) {
    /* Locate a specific ASN.1 identifier (0x1b) */
    if(packet->payload[name_offset] != 0x1b)
      name_offset++;
    else
      break;
  }

  /* Check if the offset is still within valid packet length */
  if(name_offset < packet->payload_packet_len) {
    /* Move offset forward to read realm length */
    u_int16_t realm_offset = name_offset + 1;
    if(realm_offset < packet->payload_packet_len) {
      u_int16_t realm_len = packet->payload[realm_offset];
      realm_offset++;

      /* Make sure the entire realm fits in the packet */
      if((realm_offset + realm_len) <= packet->payload_packet_len) {
        char realm_str[48];
        if(realm_len > sizeof(realm_str) - 1)
          realm_len = sizeof(realm_str) - 1;

        strncpy(realm_str, (char*)&packet->payload[realm_offset], realm_len);
        realm_str[realm_len] = '\0';

        /* Convert realm to lowercase */
        for(i = 0; i < realm_len; i++)
          realm_str[i] = tolower(realm_str[i]);

#ifdef KERBEROS_DEBUG
        printf("[TGS-REQ][Kerberos Realm][len: %u][%s]\n", realm_len, realm_str);
#endif
        snprintf(flow->protos.kerberos.domain, sizeof(flow->protos.kerberos.domain), "%s", realm_str);
      }
    }
  }
}