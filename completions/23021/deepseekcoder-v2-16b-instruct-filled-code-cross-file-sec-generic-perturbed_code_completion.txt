if(msg_type == 0x0A) /* AS-REQ */ {
#ifdef KERBEROS_DEBUG
        printf("[Kerberos] Processing AS-REQ\n");
#endif

        if(body_offset < packet->payload_packet_len) {
          u_int16_t name_offset = body_offset + 13;
          
          for(i=0; (i<20) && (name_offset < packet->payload_packet_len); i++) {
            if(packet->payload[name_offset] != 0x1b)
              name_offset++; /* ASN.1 */
          }
          
#ifdef KERBEROS_DEBUG
          printf("name_offset=%u [%02X %02X] [byte 0 must be 0x1b]\n", name_offset, packet->payload[name_offset], packet->payload[name_offset+1]);
#endif

          if(name_offset < packet->payload_packet_len) {
            u_int cname_len;

            name_offset += 1;
            if(packet->payload[name_offset+1] < ' ') /* Isn't printable ? */
              name_offset++;

            if(packet->payload[name_offset+1] == 0x1b)
              name_offset += 2;
          
            cname_len = packet->payload[name_offset];

            if((cname_len+name_offset) < packet->payload_packet_len) {
              u_int realm_len, realm_offset;
              char cname_str[48];
              u_int8_t num_cname = 0;

              while(++num_cname <= 2) {
                if(cname_len > sizeof(cname_str)-1)
                  cname_len = sizeof(cname_str)-1;

                strncpy(cname_str, (char*)&packet->payload[name_offset+1], cname_len);
                cname_str[cname_len] = '\0';
                for(i=0; i<cname_len; i++) cname_str[i] = tolower(cname_str[i]);

#ifdef KERBEROS_DEBUG
                printf("[AS-REQ][s/dport: %u/%u][Kerberos Cname][len: %u][%s]\n", sport, destport, cname_len, cname_str);
#endif

                if(((strcmp(cname_str, "host") == 0) || (strcmp(cname_str, "ldap") == 0)) && (packet->payload[name_offset+1+cname_len] == 0x1b)) {
                  name_offset += cname_len + 2;
                  cname_len = packet->payload[name_offset];
                } else
                  break;
              }

              realm_offset = cname_len + name_offset + 3;

              /* if cname does not end with a $ then it's a username */
              if(cname_len && cname_str[cname_len-1] == '$') {
                cname_str[cname_len-1] = '\0';
                snprintf(flow->protos.kerberos.hostname, sizeof(flow->protos.kerberos.hostname), "%s", cname_str);
              } else
                snprintf(flow->protos.kerberos.username, sizeof(flow->protos.kerberos.username), "%s", cname_str);

              for(i=0; (i < 14) && (realm_offset <  packet->payload_packet_len); i++) {
                if(packet->payload[realm_offset] != 0x1b)
                  realm_offset++; /* ASN.1 */
              }
              
#ifdef KERBEROS_DEBUG
              printf("realm_offset=%u [%02X %02X] [byte 0 must be 0x1b]\n", realm_offset,
                     packet->payload[realm_offset], packet->payload[realm_offset+1]);
#endif
              
              realm_offset += 1;
              //if(num_cname == 2) realm_offset++;
              if(realm_offset  < packet->payload_packet_len) {
                realm_len = packet->payload[realm_offset];

                if((realm_offset+realm_len) < packet->payload_packet_len) {
                  char realm_str[48];

                  if(realm_len > sizeof(realm_str)-1)
                    realm_len = sizeof(realm_str)-1;

                  realm_offset += 1;

                  strncpy(realm_str, (char*)&packet->payload[realm_offset], realm_len);
                  realm_str[realm_len] = '\0';
                  for(i=0; i<realm_len; i++) realm_str[i] = tolower(realm_str[i]);

#ifdef KERBEROS_DEBUG
                  printf("[AS-REQ][Kerberos Realm][len: %u][%s]\n", realm_len, realm_str);
#endif
                  snprintf(flow->protos.kerberos.domain, sizeof(flow->protos.kerberos.domain), "%s", realm_str);
                }
              }
            }
          }
        } 
      } else if(msg_type == 0x0c) /* TGS-REQ */ {
#ifdef KERBEROS_DEBUG
        printf("[Kerberos] Processing TGS-REQ\n");
#endif

        if(body_offset < packet->payload_packet_len) {
          // Initialize offsets for name parsing, starting after the body offset with a padding adjustment.
          // Iterate through the payload to locate a specific ASN.1 identifier.
          // If the name offset is within the valid payload length, proceed to extract the realm length.
          // Adjust the offset to point to the realm string and ensure it fits within a predefined buffer size.
          // Convert the realm string to lowercase and store it in the flow's Kerberos domain.
          // If a packet buffer exists, free it and restore the packet's original payload and length.
          // Set the packet buffer to NULL after processing.
          // <MASK>
        }

        if(packet->udp)
          ndpi_int_kerberos_add_connection(ndpi_struct, flow);

        /* We set the protocol in the response */
        if(flow->kerberos_buf.pktbuf != NULL) {
          ndpi_free(flow->kerberos_buf.pktbuf);
          packet->payload = original_packet_payload;
          packet->payload_packet_len = original_payload_packet_len;
          flow->kerberos_buf.pktbuf = NULL;
        }
        
        return;
      } else if(msg_type == 0x0d) /* TGS-REP */ {
        u_int16_t pad_data_len, cname_offset;
        
#ifdef KERBEROS_DEBUG
        printf("[Kerberos] Processing TGS-REP\n");
#endif

        koffsetp = koffset + 4;
        pad_data_len = packet->payload[koffsetp];
        /* Skip realm already filled in request */
        cname_offset = pad_data_len + koffsetp + 15;

        if(cname_offset < packet->payload_packet_len) {
          u_int8_t cname_len = packet->payload[cname_offset];

          if((cname_offset+cname_offset) < packet->payload_packet_len) {
            char cname_str[48];
            
            if(cname_len > sizeof(cname_str)-1)
              cname_len = sizeof(cname_str)-1;

            strncpy(cname_str, (char*)&packet->payload[cname_offset+1], cname_len);
            cname_str[cname_len] = '\0';
            for(i=0; i<cname_len; i++) cname_str[i] = tolower(cname_str[i]);

#ifdef KERBEROS_DEBUG
            printf("[TGS-REP][s/dport: %u/%u][Kerberos Cname][len: %u][%s]\n",
                   sport, destport, cname_len, cname_str);
#endif

            if(cname_len && cname_str[cname_len-1] == '$') {
              cname_str[cname_len-1] = '\0';
              snprintf(flow->protos.kerberos.hostname, sizeof(flow->protos.kerberos.hostname), "%s", cname_str);
            } else
              snprintf(flow->protos.kerberos.username, sizeof(flow->protos.kerberos.username), "%s", cname_str);

            ndpi_int_kerberos_add_connection(ndpi_struct, flow);
          }
        }
      }

      return;
    }