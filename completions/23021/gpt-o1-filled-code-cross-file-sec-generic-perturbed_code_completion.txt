if(body_offset < packet->payload_packet_len) {
  u_int16_t name_offset = body_offset + 13;
  u_int16_t realm_len;

  /* Search for a 0x1b ASN.1 tag within the next 20 bytes */
  for(i = 0; (i < 20) && (name_offset < packet->payload_packet_len); i++) {
    if(packet->payload[name_offset] != 0x1b)
      name_offset++;
    else
      break;
  }

  if(name_offset < packet->payload_packet_len) {
    /* Move past the 0x1b identifier */
    name_offset++;

    if(name_offset < packet->payload_packet_len) {
      realm_len = packet->payload[name_offset];

      /* Make sure the realm string fits in the payload */
      if((name_offset + realm_len) < packet->payload_packet_len) {
	char realm_str[48];
	u_int16_t safe_realm_len = (realm_len < sizeof(realm_str)-1) ? realm_len : (sizeof(realm_str)-1);

	name_offset++;
	strncpy(realm_str, (char*)&packet->payload[name_offset], safe_realm_len);
	realm_str[safe_realm_len] = '\0';

	/* Convert to lowercase */
	for(i = 0; i < safe_realm_len; i++)
	  realm_str[i] = tolower((unsigned char)realm_str[i]);

#ifdef KERBEROS_DEBUG
	printf("[TGS-REQ][Kerberos Realm][len: %u][%s]\n", safe_realm_len, realm_str);
#endif

	snprintf(flow->protos.kerberos.domain,
		 sizeof(flow->protos.kerberos.domain), "%s", realm_str);
      }
    }
  }
}