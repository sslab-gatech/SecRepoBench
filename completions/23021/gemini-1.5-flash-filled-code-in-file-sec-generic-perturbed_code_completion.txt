u_int16_t name_offset = body_offset + 13;
		
		for(i=0; (i<20) && (name_offset < packet->payload_packet_len); i++) {
		  if(packet->payload[name_offset] != 0x1b)
		    name_offset++; /* ASN.1 */
		}
		
#ifdef KERBEROS_DEBUG
		printf("name_offset=%u [%02X %02X] [byte 0 must be 0x1b]\n", name_offset, packet->payload[name_offset], packet->payload[name_offset+1]);
#endif

		if(name_offset < packet->payload_packet_len) {
		  u_int cname_len;

		  name_offset += 1;
		  if(packet->payload[name_offset+1] < ' ') /* Isn't printable ? */
		    name_offset++;

		  if(packet->payload[name_offset+1] == 0x1b)
		    name_offset += 2;
		  
		  cname_len = packet->payload[name_offset];

		  if((cname_len+name_offset) < packet->payload_packet_len) {
		    char cname_str[48];

		    if(cname_len > sizeof(cname_str)-1)
		      cname_len = sizeof(cname_str)-1;

		    strncpy(cname_str, (char*)&packet->payload[name_offset+1], cname_len);
		    cname_str[cname_len] = '\0';
		    for(i=0; i<cname_len; i++) cname_str[i] = tolower(cname_str[i]);

#ifdef KERBEROS_DEBUG
		    printf("[TGS-REQ][s/dport: %u/%u][Kerberos Cname][len: %u][%s]\n", sport, destport, cname_len, cname_str);
#endif

		    snprintf(flow->protos.kerberos.username, sizeof(flow->protos.kerberos.username), "%s", cname_str);
		  }
		}
	      }

	      if(packet->udp)
		ndpi_int_kerberos_add_connection(ndpi_struct, flow);

	      /* We set the protocol in the response */
	      if(flow->kerberos_buf.pktbuf != NULL) {
		ndpi_free(flow->kerberos_buf.pktbuf);
		packet->payload = original_packet_payload;
		packet->payload_packet_len = original_payload_packet_len;
		flow->kerberos_buf.pktbuf = NULL;
	      }