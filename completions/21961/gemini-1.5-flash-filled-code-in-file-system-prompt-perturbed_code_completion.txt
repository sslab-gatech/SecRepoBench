case ReadStripMethod:
      {
        size_t
          strip_size;

        unsigned char
          *strip;

        /*
          Convert strip-based TIFF image.
        */
        strip_size=(size_t) TIFFStripSize(tiff);
        strip=(unsigned char *) AcquireQuantumMemory(strip_size,
          sizeof(*strip));
        if (strip == (unsigned char *) NULL)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        for (row_index=0; row_index < (ssize_t) image->rows; row_index+=rows_per_strip)
        {
          size_t
            length;

          ssize_t
            count;

          register Quantum
            *magick_restrict q;

          register ssize_t
            i;

          count=TIFFReadEncodedStrip(tiff,(uint32) (row_index/rows_per_strip),
            strip,strip_size);
          if (count < 0)
            break;
          length=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
            quantum_type,strip,(size_t) count,exception);
          if (length == 0)
            break;
          q=QueueAuthenticPixels(image,0,row_index,image->columns,
            MagickMin(rows_per_strip,(size_t) (image->rows-row_index)),
            exception);
          if (q == (Quantum *) NULL)
            break;
          for (i=0; i < (ssize_t) length; i++)
            *q++=strip[i];
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                row_index,image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        strip=(unsigned char *) RelinquishMagickMemory(strip);
        break;
      }
      case ReadTileMethod:
      {
        size_t
          tile_size;

        unsigned char
          *tile;

        uint32
          tile_columns,
          tile_rows;

        /*
          Convert tile-based TIFF image.
        */
        (void) TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&tile_columns);
        (void) TIFFGetField(tiff,TIFFTAG_TILELENGTH,&tile_rows);
        tile_size=(size_t) TIFFTileSize(tiff);
        tile=(unsigned char *) AcquireQuantumMemory(tile_size,sizeof(*tile));
        if (tile == (unsigned char *) NULL)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        for (row_index=0; row_index < (ssize_t) image->rows; row_index+=(ssize_t)
          tile_rows)
        {
          size_t
            length;

          ssize_t
            count,
            y;

          register Quantum
            *magick_restrict q;

          register ssize_t
            x;

          for (y=0; y < (ssize_t) tile_rows; y++)
          {
            ssize_t
              tile_row;

            tile_row=row_index+y;
            if (tile_row >= (ssize_t) image->rows)
              break;
            count=TIFFReadEncodedTile(tiff,(uint32) ((row_index/tile_rows)*
              image->columns+y),(uint32) tile_columns,(uint32) tile_rows,tile,
              tile_size);
            if (count < 0)
              break;
            length=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
              quantum_type,tile,(size_t) count,exception);
            if (length == 0)
              break;
            q=QueueAuthenticPixels(image,0,tile_row,image->columns,1,
              exception);
            if (q == (Quantum *) NULL)
              break;
            for (x=0; x < (ssize_t) image->columns; x++)
              *q++=tile[x];
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
          }
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                row_index,image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        tile=(unsigned char *) RelinquishMagickMemory(tile);
        break;
      }