case ReadStripMethod:
{
  /*
    Convert strip TIFF image.
  */
  size_t
    strip_size;

  ssize_t
    y;

  strip_size=(size_t) TIFFStripSize(tiff);
  if (strip_size <= 0)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  if ((1.0*strip_size) > (2.53*GetBlobSize(image)))
    ThrowTIFFException(CorruptImageError,"InsufficientImageDataInFile");
  pixel_info=AcquireVirtualMemory(strip_size,sizeof(uint32));
  if (pixel_info == (MemoryInfo *) NULL)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
  (void) memset(pixels,0,strip_size*sizeof(uint32));
  for (y=0; y < (ssize_t) image->rows; y+=rows_per_strip)
  {
    register Quantum
      *magick_restrict q;

    register ssize_t
      x;

    ssize_t
      strip_rows;

    strip_rows=(ssize_t) MagickMin(rows_per_strip,(size_t) image->rows-y);
    tiff_status=TIFFReadEncodedStrip(tiff,y,pixels,strip_size);
    if (tiff_status == -1)
      break;
    q=QueueAuthenticPixels(image,0,y,image->columns,strip_rows,exception);
    if (q == (Quantum *) NULL)
      break;
    for (x=0; x < (ssize_t) image->columns; x++)
    {
      SetPixelRed(image,ScaleCharToQuantum((unsigned char) TIFFGetR(*pixels)),q);
      SetPixelGreen(image,ScaleCharToQuantum((unsigned char) TIFFGetG(*pixels)),q);
      SetPixelBlue(image,ScaleCharToQuantum((unsigned char) TIFFGetB(*pixels)),q);
      if (image->alpha_trait!= UndefinedPixelTrait)
        SetPixelAlpha(image,ScaleCharToQuantum((unsigned char) TIFFGetA(*pixels)),q);
      pixels++;
      q+=GetPixelChannels(image);
    }
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  pixel_info=RelinquishVirtualMemory(pixel_info);
  break;
}
case ReadTileMethod:
{
  /*
    Convert tile TIFF image.
  */
  size_t
    tile_size;

  ssize_t
    x,
    y;

  tile_size=(size_t) TIFFTileSize(tiff);
  if (tile_size <= 0)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  if ((1.0*tile_size) > (2.53*GetBlobSize(image)))
    ThrowTIFFException(CorruptImageError,"InsufficientImageDataInFile");
  pixel_info=AcquireVirtualMemory(tile_size,sizeof(uint32));
  if (pixel_info == (MemoryInfo *) NULL)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
  (void) memset(pixels,0,tile_size*sizeof(uint32));
  for (y=0; y < (ssize_t) image->rows; y+=TIFFTileRowSize(tiff))
  {
    for (x=0; x < (ssize_t) image->columns; x+=TIFFTileColSize(tiff))
    {
      register Quantum
        *magick_restrict q;

      register ssize_t
        i;

      ssize_t
        tile_columns,
        tile_rows;

      tile_columns=(ssize_t) MagickMin(TIFFTileColSize(tiff),(size_t)
        image->columns-x);
      tile_rows=(ssize_t) MagickMin(TIFFTileRowSize(tiff),(size_t) image->rows-y);
      tiff_status=TIFFReadEncodedTile(tiff,x,y,pixels,tile_size);
      if (tiff_status == -1)
        break;
      q=QueueAuthenticPixels(image,x,y,tile_columns,tile_rows,exception);
      if (q == (Quantum *) NULL)
        break;
      for (i=0; i < (ssize_t) tile_rows; i++)
      {
        register ssize_t
          j;

        for (j=0; j < (ssize_t) tile_columns; j++)
        {
          SetPixelRed(image,ScaleCharToQuantum((unsigned char) TIFFGetR(*pixels)),q);
          SetPixelGreen(image,ScaleCharToQuantum((unsigned char) TIFFGetG(*pixels)),q);
          SetPixelBlue(image,ScaleCharToQuantum((unsigned char) TIFFGetB(*pixels)),q);
          if (image->alpha_trait!= UndefinedPixelTrait)
            SetPixelAlpha(image,ScaleCharToQuantum((unsigned char) TIFFGetA(*pixels)),q);
          pixels++;
          q+=GetPixelChannels(image);
        }
        q+=GetPixelChannels(image)*(image->columns-tile_columns);
      }
      if (SyncAuthenticPixels(image,exception) == MagickFalse)
        break;
      if (image->previous == (Image *) NULL)
        {
          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
            image->rows);
          if (status == MagickFalse)
            break;
        }
    }
  }
  pixel_info=RelinquishVirtualMemory(pixel_info);
  break;
}