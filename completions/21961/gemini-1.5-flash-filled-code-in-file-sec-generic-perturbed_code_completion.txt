case ReadStripMethod:
    {
      size_t
        strip_size;

      ssize_t
        strip_index;

      unsigned char
        *strip;

      /*
        Convert strip-based TIFF image.
      */
      strip_size=(size_t) TIFFStripSize(tiff);
      strip=(unsigned char *) AcquireQuantumMemory(strip_size,sizeof(*strip));
      if (strip == (unsigned char *) NULL)
        ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
      for (strip_index=0; strip_index < (ssize_t) TIFFNumberOfStrips(tiff); strip_index++)
      {
        register ssize_t
          row;

        register Quantum
          *magick_restrict q;

        ssize_t
          count;

        count=TIFFReadRawStrip(tiff,(uint32) strip_index,strip,strip_size);
        if (count < 0)
          break;
        for (row=0; row < (ssize_t) rows_per_strip; row++)
        {
          register const unsigned char
            *p;

          size_t
            length;

          p=strip+(row*TIFFScanlineSize(tiff));
          q=QueueAuthenticPixels(image,0,strip_index*rows_per_strip+row,
            image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          length=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
            quantum_type,p,exception);
          if (length != image->columns)
            break;
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                strip_index*rows_per_strip+row,image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        if (strip_index == (ssize_t) (TIFFNumberOfStrips(tiff)-1))
          break;
      }
      strip=(unsigned char *) RelinquishMagickMemory(strip);
      break;
    }
    case ReadTileMethod:
    {
      size_t
        tile_size;

      ssize_t
        tile_index;

      unsigned char
        *tile;

      /*
        Convert tile-based TIFF image.
      */
      tile_size=(size_t) TIFFTileSize(tiff);
      tile=(unsigned char *) AcquireQuantumMemory(tile_size,sizeof(*tile));
      if (tile == (unsigned char *) NULL)
        ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
      for (tile_index=0; tile_index < (ssize_t) TIFFNumberOfTiles(tiff); tile_index++)
      {
        register ssize_t
          row;

        register Quantum
          *magick_restrict q;

        ssize_t
          count;

        uint32
          tile_y;

        count=TIFFReadRawTile(tiff,(uint32) tile_index,tile,tile_size);
        if (count < 0)
          break;
        tile_y=(uint32) (tile_index/(ssize_t) (image->columns/
          tiff_info.tile_geometry.width))*tiff_info.tile_geometry.height;
        for (row=0; row < (ssize_t) tiff_info.tile_geometry.height; row++)
        {
          register const unsigned char
            *p;

          size_t
            length;

          p=tile+(row*TIFFScanlineSize(tiff));
          q=QueueAuthenticPixels(image,0,tile_y+row,
            tiff_info.tile_geometry.width,1,exception);
          if (q == (Quantum *) NULL)
            break;
          length=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
            quantum_type,p,exception);
          if (length != tiff_info.tile_geometry.width)
            break;
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                tile_index,TIFFNumberOfTiles(tiff));
              if (status == MagickFalse)
                break;
            }
        }
        if (tile_index == (ssize_t) (TIFFNumberOfTiles(tiff)-1))
          break;
      }
      tile=(unsigned char *) RelinquishMagickMemory(tile);
      break;
    }