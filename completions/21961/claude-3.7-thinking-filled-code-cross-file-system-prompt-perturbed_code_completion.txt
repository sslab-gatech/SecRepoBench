case ReadStripMethod:
{
  /*
    Read TIFF image as strips.
  */
  for (y=0; y < (ssize_t) image->rows; y+=rows_per_strip)
  {
    register Quantum
      *magick_restrict q;

    ssize_t
      count,
      row_index;

    size_t
      length;

    tiff_status=TIFFReadEncodedStrip(tiff,(uint32) TIFFComputeStrip(tiff,
      (uint32) y,0),pixels,(tsize_t) TIFFStripSize(tiff));
    if (tiff_status < 0)
      break;
    row_index=0;
    count=(ssize_t) MagickMin((ssize_t) rows_per_strip,(ssize_t) (image->rows-y));
    for (i=0; i < count; i++)
    {
      q=QueueAuthenticPixels(image,0,y+i,image->columns,1,exception);
      if (q == (Quantum *) NULL)
        break;
      length=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
        quantum_type,pixels+row_index,exception);
      if (SyncAuthenticPixels(image,exception) == MagickFalse)
        break;
      row_index+=(ssize_t) length;
    }
    if (i < count)
      break;
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
        image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  break;
}
case ReadTileMethod:
{
  /*
    Read TIFF image as tiles.
  */
  uint32
    tile_width,
    tile_height;

  register ssize_t
    x;

  tiff_status=TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&tile_width);
  if (tiff_status == 0)
    ThrowTIFFException(CoderError,"TileWidthNotSet");
  tiff_status=TIFFGetField(tiff,TIFFTAG_TILELENGTH,&tile_height);
  if (tiff_status == 0)
    ThrowTIFFException(CoderError,"TileLengthNotSet");
  for (y=0; y < (ssize_t) image->rows; y+=(ssize_t) tile_height)
  {
    for (x=0; x < (ssize_t) image->columns; x+=(ssize_t) tile_width)
    {
      register Quantum
        *magick_restrict q;

      size_t
        length;

      ssize_t
        tile_index;

      uint32
        tile_cols,
        tile_rows;

      /*
        Compute the actual size of the tile.
      */
      tile_cols=(uint32) MagickMin((ssize_t) tile_width,(ssize_t)
        (image->columns-x));
      tile_rows=(uint32) MagickMin((ssize_t) tile_height,(ssize_t)
        (image->rows-y));
      tiff_status=TIFFReadEncodedTile(tiff,TIFFComputeTile(tiff,(uint32) x,
        (uint32) y,0,0),pixels,(tsize_t) TIFFTileSize(tiff));
      if (tiff_status < 0)
        break;
      tile_index=0;
      for (i=0; i < (ssize_t) tile_rows; i++)
      {
        q=QueueAuthenticPixels(image,x,y+i,tile_cols,1,exception);
        if (q == (Quantum *) NULL)
          break;
        length=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
          quantum_type,pixels+tile_index,exception);
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
        tile_index+=(ssize_t) length;
      }
    }
    if (x < (ssize_t) image->columns)
      break;
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  break;
}