case ReadStripMethod:
      {
        size_t
          number_pixels;

        /*
          Convert strip TIFF image.
        */
        if (HeapOverflowSanityCheck(rows_per_strip,sizeof(*pixels)) != MagickFalse)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        number_pixels=rows_per_strip*image->columns;
        pixel_info=AcquireVirtualMemory((size_t) MagickMax(number_pixels,
          TIFFScanlineSize(tiff)),sizeof(uint32));
        if (pixel_info == (MemoryInfo *) NULL)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
        for (row_index=0; row_index < (ssize_t) image->rows; row_index+=rows_per_strip)
        {
          size_t
            rows;

          register ssize_t
            y;

          rows=rows_per_strip;
          if ((row_index+rows) > (ssize_t) image->rows)
            rows=image->rows-row_index;
          tiff_status=TIFFReadEncodedStrip(tiff,TIFFComputeStrip(tiff,(tstrip_t)
            row_index,0),pixels,(tsize_t) (rows*TIFFScanlineSize(tiff)));
          if (tiff_status == -1)
            break;
          for (y=0; y < (ssize_t) rows; y++)
          {
            register Quantum
              *magick_restrict q;

            register ssize_t
              x;

            q=QueueAuthenticPixels(image,0,row_index+y,image->columns,1,
              exception);
            if (q == (Quantum *) NULL)
              break;
            if (image->storage_class == PseudoClass)
              {
                register unsigned char
                  *magick_restrict p;

                p=pixels+(y*image->columns);
                for (x=0; x < (ssize_t) image->columns; x++)
                  SetPixelIndex(image,*p++,q);
              }
            else
              if (TIFFIsBigEndian(tiff))
                {
                  register uint32
                    *magick_restrict p;

                  p=(uint32 *) (pixels+(y*image->columns*sizeof(uint32)));
                  for (x=0; x < (ssize_t) image->columns; x++)
                  {
                    SetPixelRed(image,ScaleCharToQuantum((unsigned char)
                      TIFFGetR(*p)),q);
                    SetPixelGreen(image,ScaleCharToQuantum((unsigned char)
                      TIFFGetG(*p)),q);
                    SetPixelBlue(image,ScaleCharToQuantum((unsigned char)
                      TIFFGetB(*p)),q);
                    if (image->alpha_trait != UndefinedPixelTrait)
                      SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)
                        TIFFGetA(*p)),q);
                    p++;
                    q+=GetPixelChannels(image);
                  }
                }
              else
                {
                  register unsigned char
                    *magick_restrict p;

                  p=pixels+y*TIFFScanlineSize(tiff);
                  for (x=0; x < (ssize_t) image->columns; x++)
                  {
                    if (quantum_type == GrayQuantum)
                      SetPixelGray(image,ScaleCharToQuantum(*p),q);
                    else
                      SetPixelRed(image,ScaleCharToQuantum(*p),q);
                    if (samples_per_pixel > 1)
                      {
                        if (quantum_type == GrayAlphaQuantum)
                          SetPixelAlpha(image,ScaleCharToQuantum(*(p+1)),q);
                        else
                          SetPixelGreen(image,ScaleCharToQuantum(*(p+1)),q);
                      }
                    if (samples_per_pixel > 2)
                      SetPixelBlue(image,ScaleCharToQuantum(*(p+2)),q);
                    if (samples_per_pixel > 3)
                      SetPixelAlpha(image,ScaleCharToQuantum(*(p+3)),q);
                    p+=samples_per_pixel;
                    q+=GetPixelChannels(image);
                  }
                }
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
          }
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) row_index,image->rows);
              if (status == MagickFalse)
                break;
            }
          if (tiff_status == -1)
            break;
        }
        pixel_info=RelinquishVirtualMemory(pixel_info);
        break;
      }
      case ReadTileMethod:
      {
        uint32
          *tile_pixels,
          tile_width,
          tile_length;

        /*
          Convert tile TIFF image.
        */
        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&tile_width) != 1) ||
            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&tile_length) != 1))
          ThrowTIFFException(CoderError,"ImageTypeNotSupported");
        if (HeapOverflowSanityCheck(tile_width,sizeof(*tile_pixels)) != MagickFalse)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        if (HeapOverflowSanityCheck(tile_length,sizeof(*tile_pixels)) != MagickFalse)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");

        number_pixels=(MagickSizeType) tile_width*tile_length;
        pixel_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));
        if (pixel_info == (MemoryInfo *) NULL)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        tile_pixels=(uint32 *) GetVirtualMemoryBlob(pixel_info);
        for (row_index=0; row_index < (ssize_t) image->rows; row_index+=tile_length)
        {
          register ssize_t
            y;

          size_t
            rows;

          rows=tile_length;
          if ((row_index+rows) > (ssize_t) image->rows)
            rows=image->rows-row_index;
          for (i=0; i < (ssize_t) image->columns; i+=tile_width)
          {
            size_t
              columns;

            register ssize_t
              x;

            register Quantum
              *magick_restrict q;

            columns=tile_width;
            if ((i+columns) > (ssize_t) image->columns)
              columns=image->columns-i;
            tiff_status=TIFFReadTile(tiff,(tdata_t) tile_pixels,(ttile_t) i,
              (ttile_t) row_index,0,0);
            if (tiff_status == -1)
              break;
            for (y=0; y < (ssize_t) rows; y++)
            {
              if (image->alpha_trait == UndefinedPixelTrait)
                q=QueueAuthenticPixels(image,i,row_index+y,columns,1,
                  exception);
              else
                q=QueueAuthenticPixels(image,i,row_index+y,columns,1,
                  exception);
              if (q == (Quantum *) NULL)
                break;
              if (image->storage_class == PseudoClass)
                for (x=0; x < (ssize_t) columns; x++)
                {
                  SetPixelIndex(image,tile_pixels[y*tile_width+x],q);
                  q+=GetPixelChannels(image);
                }
              else
                for (x=0; x < (ssize_t) columns; x++)
                {
                  SetPixelRed(image,ScaleCharToQuantum((unsigned char)
                    TIFFGetR(tile_pixels[y*tile_width+x])),q);
                  SetPixelGreen(image,ScaleCharToQuantum((unsigned char)
                    TIFFGetG(tile_pixels[y*tile_width+x])),q);
                  SetPixelBlue(image,ScaleCharToQuantum((unsigned char)
                    TIFFGetB(tile_pixels[y*tile_width+x])),q);
                  if (image->alpha_trait != UndefinedPixelTrait)
                    SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)
                      TIFFGetA(tile_pixels[y*tile_width+x])),q);
                  q+=GetPixelChannels(image);
                }
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
            }
          }
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) row_index,
                image->rows);
              if (status == MagickFalse)
                break;
            }
          if (tiff_status == -1)
            break;
        }
        pixel_info=RelinquishVirtualMemory(pixel_info);
        break;
      }