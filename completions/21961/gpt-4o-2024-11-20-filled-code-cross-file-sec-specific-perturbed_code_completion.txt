case ReadStripMethod:
      {
        /*
          Read TIFF image using strip-based method.
        */
        tsize_t
          strip_size;

        tstrip_t
          strip;

        unsigned char
          *strip_data;

        strip_size=TIFFStripSize(tiff);
        if (strip_size <= 0)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        strip_data=(unsigned char *) AcquireQuantumMemory(strip_size,
          sizeof(*strip_data));
        if (strip_data == (unsigned char *) NULL)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        for (row_index=0; row_index < (ssize_t) image->rows; row_index += rows_per_strip)
        {
          register Quantum
            *magick_restrict q;

          register ssize_t
            x,
            row;

          tstrip_t
            strip_index;

          strip_index=(tstrip_t) (row_index/rows_per_strip);
          if (TIFFReadEncodedStrip(tiff,strip_index,strip_data,strip_size) == -1)
            break;
          for (row=0; row < (ssize_t) rows_per_strip; row++)
          {
            if ((row_index+row) >= (ssize_t) image->rows)
              break;
            q=QueueAuthenticPixels(image,0,row_index+row,image->columns,1,
              exception);
            if (q == (Quantum *) NULL)
              break;
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              SetPixelRed(image,ScaleCharToQuantum(strip_data[(row*image->columns+x)*samples_per_pixel+0]),q);
              if (samples_per_pixel > 1)
                SetPixelGreen(image,ScaleCharToQuantum(strip_data[(row*image->columns+x)*samples_per_pixel+1]),q);
              if (samples_per_pixel > 2)
                SetPixelBlue(image,ScaleCharToQuantum(strip_data[(row*image->columns+x)*samples_per_pixel+2]),q);
              if (image->alpha_trait != UndefinedPixelTrait && samples_per_pixel > 3)
                SetPixelAlpha(image,ScaleCharToQuantum(strip_data[(row*image->columns+x)*samples_per_pixel+3]),q);
              q+=GetPixelChannels(image);
            }
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
          }
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) row_index,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        strip_data=(unsigned char *) RelinquishMagickMemory(strip_data);
        break;
      }
      case ReadTileMethod:
      {
        /*
          Read TIFF image using tile-based method.
        */
        uint32
          tile_width,
          tile_length;

        tsize_t
          tile_size;

        unsigned char
          *tile_data;

        if (TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&tile_width) != 1 ||
            TIFFGetField(tiff,TIFFTAG_TILELENGTH,&tile_length) != 1)
          ThrowTIFFException(CorruptImageError,"ImproperImageHeader");
        tile_size=TIFFTileSize(tiff);
        if (tile_size <= 0)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        tile_data=(unsigned char *) AcquireQuantumMemory(tile_size,
          sizeof(*tile_data));
        if (tile_data == (unsigned char *) NULL)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        for (row_index=0; row_index < (ssize_t) image->rows; row_index += tile_length)
        {
          register ssize_t
            y;

          for (y=0; y < (ssize_t) image->columns; y += tile_width)
          {
            if (TIFFReadTile(tiff,tile_data,y,row_index,0,0) == -1)
              break;
            for (ssize_t tile_row=0; tile_row < (ssize_t) tile_length; tile_row++)
            {
              if ((row_index+tile_row) >= (ssize_t) image->rows)
                break;
              register Quantum
                *magick_restrict q;

              register ssize_t
                x;

              q=QueueAuthenticPixels(image,y,row_index+tile_row,
                MagickMin(tile_width,image->columns-y),1,exception);
              if (q == (Quantum *) NULL)
                break;
              for (x=0; x < (ssize_t) MagickMin(tile_width,image->columns-y); x++)
              {
                SetPixelRed(image,ScaleCharToQuantum(tile_data[(tile_row*tile_width+x)*samples_per_pixel+0]),q);
                if (samples_per_pixel > 1)
                  SetPixelGreen(image,ScaleCharToQuantum(tile_data[(tile_row*tile_width+x)*samples_per_pixel+1]),q);
                if (samples_per_pixel > 2)
                  SetPixelBlue(image,ScaleCharToQuantum(tile_data[(tile_row*tile_width+x)*samples_per_pixel+2]),q);
                if (image->alpha_trait != UndefinedPixelTrait && samples_per_pixel > 3)
                  SetPixelAlpha(image,ScaleCharToQuantum(tile_data[(tile_row*tile_width+x)*samples_per_pixel+3]),q);
                q+=GetPixelChannels(image);
              }
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
            }
          }
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) row_index,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        tile_data=(unsigned char *) RelinquishMagickMemory(tile_data);
        break;
      }