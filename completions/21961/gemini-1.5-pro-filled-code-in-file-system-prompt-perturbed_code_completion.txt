case ReadStripMethod:
      {
        register uint32
          *p;

        /*
          Convert strip TIFF image.
        */
        for (row_index=0; row_index < (ssize_t) image->rows; row_index++)
        {
          register ssize_t
            x;

          register Quantum
            *magick_restrict q;

          tiff_status=TIFFReadPixels(tiff,0,row_index,(char *) pixels);
          if (tiff_status == -1)
            break;
          q=QueueAuthenticPixels(image,0,row_index,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          p=(uint32 *) pixels;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            if (samples_per_pixel == 1)
              {
                SetPixelGray(image,ScaleCharToQuantum((unsigned char) *p),q);
                if (image->alpha_trait != UndefinedPixelTrait)
                  SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)
                    *(p+1)),q);
              }
            else
              if (image->storage_class == PseudoClass)
                SetPixelIndex(image,*p,q);
              else
                {
                  SetPixelRed(image,ScaleCharToQuantum((unsigned char)
                    TIFFGetR(*p)),q);
                  SetPixelGreen(image,ScaleCharToQuantum((unsigned char)
                    TIFFGetG(*p)),q);
                  SetPixelBlue(image,ScaleCharToQuantum((unsigned char)
                    TIFFGetB(*p)),q);
                  if (image->alpha_trait != UndefinedPixelTrait)
                    SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)
                      TIFFGetA(*p)),q);
                }
            p++;
            q+=GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                row_index,image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case ReadTileMethod:
      {
        register uint32
          *p;

        uint32
          columns,
          rows;

        /*
          Convert tile TIFF image.
        */
        if ((image->columns < tiff_info.tile_geometry.width) ||
            (image->rows < tiff_info.tile_geometry.height))
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        for (row_index=0; row_index < (ssize_t) image->rows; row_index+=
             tiff_info.tile_geometry.height)
        {
          register ssize_t
            x;

          rows=tiff_info.tile_geometry.height;
          if ((row_index+rows) > image->rows)
            rows=image->rows-row_index;
          for (i=0; i < (ssize_t) image->columns; i+=tiff_info.tile_geometry.width)
          {
            size_t
              tile_width;

            ssize_t
              y;

            register Quantum
              *magick_restrict q;

            tile_width=tiff_info.tile_geometry.width;
            if ((i+tile_width) > image->columns)
              tile_width=image->columns-i;
            tiff_status=TIFFReadTile(tiff,pixels,(uint32) i,(uint32) row_index,
              0,0);
            if (tiff_status == -1)
              break;
            for (y=0; y < (ssize_t) rows; y++)
            {
              q=GetAuthenticPixels(image,i,row_index+y,tile_width,1,exception);
              if (q == (Quantum *) NULL)
                break;
              p=(uint32 *) pixels+y*tiff_info.tile_geometry.width;
              for (x=0; x < (ssize_t) tile_width; x++)
              {
                if (samples_per_pixel == 1)
                  {
                    SetPixelGray(image,ScaleCharToQuantum((unsigned char) *p),
                      q);
                    if (image->alpha_trait != UndefinedPixelTrait)
                      SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)
                        *(p+1)),q);
                  }
                else
                  if (image->storage_class == PseudoClass)
                    SetPixelIndex(image,*p,q);
                  else
                    {
                      SetPixelRed(image,ScaleCharToQuantum((unsigned char)
                        TIFFGetR(*p)),q);
                      SetPixelGreen(image,ScaleCharToQuantum((unsigned char)
                        TIFFGetG(*p)),q);
                      SetPixelBlue(image,ScaleCharToQuantum((unsigned char)
                        TIFFGetB(*p)),q);
                      if (image->alpha_trait != UndefinedPixelTrait)
                        SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)
                          TIFFGetA(*p)),q);
                    }
                p++;
                q+=GetPixelChannels(image);
              }
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
            }
          }
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                row_index,image->rows);
              if (status == MagickFalse)
                break;
            }
          if (tiff_status == -1)
            break;
        }
        break;
      }