case ReadStripMethod:
      {
        uint32 strip_size = rows_per_strip * TIFFScanlineSize(tiff);
        MemoryInfo *strip_info = AcquireVirtualMemory(strip_size, sizeof(uint32));
        if (strip_info == (MemoryInfo *) NULL)
          ThrowTIFFException(ResourceLimitError, "MemoryAllocationFailed");
        
        for (row_index = 0; row_index < (ssize_t) image->rows; row_index += rows_per_strip)
        {
          uint32 rows_to_read = MagickMin(rows_per_strip, image->rows - row_index);
          tiff_status = TIFFReadEncodedStrip(tiff, row_index / rows_per_strip, GetVirtualMemoryBlob(strip_info), strip_size);
          if (tiff_status == -1)
            break;

          register Quantum *magick_restrict q = QueueAuthenticPixels(image, 0, row_index, image->columns, rows_to_read, exception);
          if (q == (Quantum *) NULL)
            break;

          for (ssize_t y = 0; y < rows_to_read; y++)
          {
            register ssize_t x;
            for (x = 0; x < (ssize_t) image->columns; x++)
            {
              SetPixelRed(image, ScaleCharToQuantum((unsigned char) TIFFGetR(pixels[y * image->columns + x])), q);
              SetPixelGreen(image, ScaleCharToQuantum((unsigned char) TIFFGetG(pixels[y * image->columns + x])), q);
              SetPixelBlue(image, ScaleCharToQuantum((unsigned char) TIFFGetB(pixels[y * image->columns + x])), q);
              if (image->alpha_trait != UndefinedPixelTrait)
                SetPixelAlpha(image, ScaleCharToQuantum((unsigned char) TIFFGetA(pixels[y * image->columns + x])), q);
              q += GetPixelChannels(image);
            }
          }
          if (SyncAuthenticPixels(image, exception) == MagickFalse)
            break;

          if (image->previous == (Image *) NULL)
          {
            status = SetImageProgress(image, LoadImageTag, (MagickOffsetType) row_index, image->rows);
            if (status == MagickFalse)
              break;
          }
        }
        strip_info = RelinquishVirtualMemory(strip_info);
        break;
      }
      case ReadTileMethod:
      {
        uint32 tile_width, tile_height;
        TIFFGetField(tiff, TIFFTAG_TILEWIDTH, &tile_width);
        TIFFGetField(tiff, TIFFTAG_TILELENGTH, &tile_height);
        size_t tile_size = tile_width * tile_height * samples_per_pixel * (bits_per_sample / 8);
        MemoryInfo *tile_info = AcquireVirtualMemory(tile_size, sizeof(uint32));
        if (tile_info == (MemoryInfo *) NULL)
          ThrowTIFFException(ResourceLimitError, "MemoryAllocationFailed");

        for (row_index = 0; row_index < (ssize_t) image->rows; row_index += tile_height)
        {
          for (ssize_t col_index = 0; col_index < (ssize_t) image->columns; col_index += tile_width)
          {
            tiff_status = TIFFReadTile(tiff, GetVirtualMemoryBlob(tile_info), col_index, row_index, 0, 0);
            if (tiff_status == -1)
              break;

            register Quantum *magick_restrict q = QueueAuthenticPixels(image, col_index, row_index, tile_width, tile_height, exception);
            if (q == (Quantum *) NULL)
              break;

            for (ssize_t y = 0; y < tile_height; y++)
            {
              for (ssize_t x = 0; x < tile_width; x++)
              {
                SetPixelRed(image, ScaleCharToQuantum((unsigned char) TIFFGetR(pixels[y * tile_width + x])), q);
                SetPixelGreen(image, ScaleCharToQuantum((unsigned char) TIFFGetG(pixels[y * tile_width + x])), q);
                SetPixelBlue(image, ScaleCharToQuantum((unsigned char) TIFFGetB(pixels[y * tile_width + x])), q);
                if (image->alpha_trait != UndefinedPixelTrait)
                  SetPixelAlpha(image, ScaleCharToQuantum((unsigned char) TIFFGetA(pixels[y * tile_width + x])), q);
                q += GetPixelChannels(image);
              }
            }
            if (SyncAuthenticPixels(image, exception) == MagickFalse)
              break;

            if (image->previous == (Image *) NULL)
            {
              status = SetImageProgress(image, LoadImageTag, (MagickOffsetType) row_index, image->rows);
              if (status == MagickFalse)
                break;
            }
          }
        }
        tile_info = RelinquishVirtualMemory(tile_info);
        break;
      }