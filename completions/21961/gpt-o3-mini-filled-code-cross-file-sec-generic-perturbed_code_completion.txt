case ReadStripMethod:
      case ReadTileMethod:
      {
        tsize_t scanline_size;
        unsigned char *buffer;
        ssize_t row, rows_to_read;
        const int is_tile = (method == ReadTileMethod);

        scanline_size = TIFFScanlineSize(tiff);
        if (scanline_size <= 0)
          ThrowTIFFException(ResourceLimitError, "MemoryAllocationFailed");

        if (!is_tile)
          {
            /* Strip‐based reading */
            buffer = (unsigned char *) AcquireQuantumMemory(rows_per_strip, scanline_size);
            if (buffer == (unsigned char *) NULL)
              ThrowTIFFException(ResourceLimitError, "MemoryAllocationFailed");

            for (row = 0; row < (ssize_t) image->rows; row += rows_per_strip)
            {
              rows_to_read = (ssize_t) MagickMin((ssize_t) rows_per_strip, (ssize_t) image->rows - row);
              {
                int strip = (int)(row / rows_per_strip);
                tiff_status = TIFFReadEncodedStrip(tiff, strip, buffer, rows_to_read * scanline_size);
                if (tiff_status == -1)
                  break;
              }
              for (ssize_t i = 0; i < rows_to_read; i++)
              {
                Quantum *magick_restrict q = QueueAuthenticPixels(image, 0, row + i, image->columns, 1, exception);
                if (q == (Quantum *) NULL)
                  break;
                (void) memcpy(q, buffer + i * scanline_size, scanline_size);
                if (SyncAuthenticPixels(image, exception) == MagickFalse)
                  break;
                status = SetImageProgress(image, LoadImageTag, row + i, image->rows);
                if (status == MagickFalse)
                  break;
              }
            }
            buffer = (unsigned char *) RelinquishVirtualMemory(buffer);
          }
        else
          {
            /* Tile‐based reading */
            uint32 tile_width, tile_length;
            if ((TIFFGetField(tiff, TIFFTAG_TILEWIDTH, &tile_width) != 1) ||
                (TIFFGetField(tiff, TIFFTAG_TILELENGTH, &tile_length) != 1))
              ThrowTIFFException(CorruptImageError, "ImproperImageHeader");
            {
              tsize_t tile_size = TIFFTileSize(tiff);
              buffer = (unsigned char *) AcquireQuantumMemory(1, tile_size);
              if (buffer == (unsigned char *) NULL)
                ThrowTIFFException(ResourceLimitError, "MemoryAllocationFailed");

              for (row = 0; row < (ssize_t) image->rows; row++)
              {
                for (ssize_t col = 0; col < (ssize_t) image->columns; col += tile_width)
                {
                  uint32 tile = TIFFComputeTile(tiff, (uint32) col, (uint32) row, 0, 0);
                  tiff_status = TIFFReadEncodedTile(tiff, tile, buffer, tile_size);
                  if (tiff_status == -1)
                    break;
                  for (ssize_t y = 0; y < (ssize_t) tile_length && (row + y) < (ssize_t) image->rows; y++)
                  {
                    size_t width = MagickMin((size_t) tile_width, image->columns - col);
                    Quantum *magick_restrict q = QueueAuthenticPixels(image, col, row + y, width, 1, exception);
                    if (q == (Quantum *) NULL)
                      break;
                    /* Copy the corresponding scanline data from the tile.
                       Ensure not to copy beyond the tile buffer. */
                    (void) memcpy(q, buffer + y * scanline_size,
                                  MagickMin(scanline_size, width * (scanline_size / tile_width)));
                    if (SyncAuthenticPixels(image, exception) == MagickFalse)
                      break;
                  }
                }
                status = SetImageProgress(image, LoadImageTag, row, image->rows);
                if (status == MagickFalse)
                  break;
              }
              buffer = (unsigned char *) RelinquishVirtualMemory(buffer);
            }
          }
        break;
      }