case ReadStripMethod:
      {
        /*
          Convert strip-based TIFF image.
        */
        for (row_index=0; row_index < (ssize_t) image->rows; row_index+=rows_per_strip)
        {
          register Quantum
            *magick_restrict q;

          size_t
            length;

          ssize_t
            count,
            scanlines;

          unsigned char
            *p;

          scanlines=(ssize_t) MagickMin((size_t) rows_per_strip,(size_t)
            image->rows-row_index);
          if (HeapOverflowSanityCheck(scanlines,TIFFScanlineSize(tiff)) != MagickFalse)
            ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
          length=(size_t) TIFFScanlineSize(tiff)*scanlines;
          if (length > number_pixels)
            ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
          count=TIFFReadEncodedStrip(tiff,(uint32) row_index/rows_per_strip,
            (tdata_t) pixels,length);
          if (count < 0)
            break;
          p=pixels;
          for (i=0; i < (ssize_t) scanlines; i++)
          {
            q=QueueAuthenticPixels(image,0,row_index+i,image->columns,1,
              exception);
            if (q == (Quantum *) NULL)
              break;
            ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
              quantum_type,p,exception);
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
            p+=TIFFScanlineSize(tiff);
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                  row_index+i,image->rows);
                if (status == MagickFalse)
                  break;
              }
          }
        }
        break;
      }
      case ReadTileMethod:
      {
        register ssize_t
          x;

        register Quantum
          *magick_restrict q;

        size_t
          tile_height,
          tile_width;

        ssize_t
          tile_y;

        uint32
          tile_height_uint32,
          tile_width_uint32;

        unsigned char
          *tile_pixels;

        /*
          Convert tile-based TIFF image.
        */
        if (TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&tile_width_uint32) != 1)
          ThrowTIFFException(CoderError,"UnableToReadTileWidth");
        if (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&tile_height_uint32) != 1)
          ThrowTIFFException(CoderError,"UnableToReadTileLength");
        tile_width=(size_t) tile_width_uint32;
        tile_height=(size_t) tile_height_uint32;
        if (HeapOverflowSanityCheck(tile_width,tile_height*TIFFScanlineSize(tiff)) != MagickFalse)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        length=(size_t) TIFFScanlineSize(tiff)*tile_height;
        if (length > number_pixels)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        tile_pixels=(unsigned char *) AcquireQuantumMemory(length,
          sizeof(*tile_pixels));
        if (tile_pixels == (unsigned char *) NULL)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        for (tile_y=0; tile_y < (ssize_t) image->rows; tile_y+=tile_height)
        {
          size_t
            scanlines;

          ssize_t
            count;

          unsigned char
            *p;

          scanlines=MagickMin(tile_height,(size_t) image->rows-tile_y);
          count=TIFFReadTile(tiff,tile_pixels,0,tile_y,0,0);
          if (count < 0)
            break;
          p=tile_pixels;
          for (i=0; i < (ssize_t) scanlines; i++)
          {
            q=QueueAuthenticPixels(image,0,tile_y+i,tile_width,1,exception);
            if (q == (Quantum *) NULL)
              break;
            ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
              quantum_type,p,exception);
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
            p+=TIFFScanlineSize(tiff);
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                  tile_y+i,image->rows);
                if (status == MagickFalse)
                  break;
              }
          }
        }
        tile_pixels=(unsigned char *) RelinquishMagickMemory(tile_pixels);
        break;
      }