case ReadStripMethod:
      {
        size_t
          strip_size;

        unsigned char
          *strip;

        /*
          Convert strip-based TIFF image.
        */
        strip_size=(size_t) TIFFStripSize(tiff);
        strip=(unsigned char *) AcquireQuantumMemory(strip_size,
          sizeof(*strip));
        if (strip == (unsigned char *) NULL)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        for (row_index=0; row_index < (ssize_t) image->rows; row_index++)
        {
          register Quantum
            *magick_restrict q;

          register ssize_t
            x;

          ssize_t
            count;

          unsigned char
            *p;

          count=TIFFReadPixels(tiff,0,row_index,(char *) strip);
          if (count == -1)
            break;
          q=QueueAuthenticPixels(image,0,row_index,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          p=strip;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            switch (quantum_type)
            {
              case GrayQuantum:
              {
                SetPixelGray(image,ScaleCharToQuantum(*p),q);
                break;
              }
              case GrayAlphaQuantum:
              {
                SetPixelGray(image,ScaleCharToQuantum(*p),q);
                SetPixelAlpha(image,ScaleCharToQuantum(*(p+1)),q);
                break;
              }
              case RGBQuantum:
              {
                SetPixelRed(image,ScaleCharToQuantum(*p),q);
                SetPixelGreen(image,ScaleCharToQuantum(*(p+1)),q);
                SetPixelBlue(image,ScaleCharToQuantum(*(p+2)),q);
                break;
              }
              case RGBAQuantum:
              {
                SetPixelRed(image,ScaleCharToQuantum(*p),q);
                SetPixelGreen(image,ScaleCharToQuantum(*(p+1)),q);
                SetPixelBlue(image,ScaleCharToQuantum(*(p+2)),q);
                SetPixelAlpha(image,ScaleCharToQuantum(*(p+3)),q);
                break;
              }
              case CMYKQuantum:
              {
                SetPixelCyan(image,ScaleCharToQuantum(*p),q);
                SetPixelMagenta(image,ScaleCharToQuantum(*(p+1)),q);
                SetPixelYellow(image,ScaleCharToQuantum(*(p+2)),q);
                SetPixelBlack(image,ScaleCharToQuantum(*(p+3)),q);
                break;
              }
              case CMYKAQuantum:
              {
                SetPixelCyan(image,ScaleCharToQuantum(*p),q);
                SetPixelMagenta(image,ScaleCharToQuantum(*(p+1)),q);
                SetPixelYellow(image,ScaleCharToQuantum(*(p+2)),q);
                SetPixelBlack(image,ScaleCharToQuantum(*(p+3)),q);
                SetPixelAlpha(image,ScaleCharToQuantum(*(p+4)),q);
                break;
              }
              default:
                break;
            }
            p+=samples_per_pixel;
            q+=GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) row_index,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        strip=(unsigned char *) RelinquishMagickMemory(strip);
        break;
      }
      case ReadTileMethod:
      {
        size_t
          tile_height,
          tile_width;

        uint32
          *tile;

        unsigned char
          *p;

        /*
          Convert tile-based TIFF image.
        */
        tile_width=(size_t) TIFFTileRowSize(tiff);
        tile_height=(size_t) TIFFTileSize(tiff)/tile_width;
        tile=(uint32 *) AcquireQuantumMemory(tile_width,sizeof(*tile));
        if (tile == (uint32 *) NULL)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        for (row_index=0; row_index < (ssize_t) image->rows; row_index++)
        {
          register Quantum
            *magick_restrict q;

          register ssize_t
            x;

          ssize_t
            count;

          uint32
            *t;

          count=TIFFReadPixels(tiff,0,row_index,(char *) tile);
          if (count == -1)
            break;
          q=QueueAuthenticPixels(image,0,row_index,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          t=tile;
          p=(unsigned char *) t;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            switch (quantum_type)
            {
              case GrayQuantum:
              {
                SetPixelGray(image,ScaleCharToQuantum(*p),q);
                break;
              }
              case GrayAlphaQuantum:
              {
                SetPixelGray(image,ScaleCharToQuantum(*p),q);
                SetPixelAlpha(image,ScaleCharToQuantum(*(p+1)),q);
                break;
              }
              case RGBQuantum:
              {
                SetPixelRed(image,ScaleCharToQuantum(*p),q);
                SetPixelGreen(image,ScaleCharToQuantum(*(p+1)),q);
                SetPixelBlue(image,ScaleCharToQuantum(*(p+2)),q);
                break;
              }
              case RGBAQuantum:
              {
                SetPixelRed(image,ScaleCharToQuantum(*p),q);
                SetPixelGreen(image,ScaleCharToQuantum(*(p+1)),q);
                SetPixelBlue(image,ScaleCharToQuantum(*(p+2)),q);
                SetPixelAlpha(image,ScaleCharToQuantum(*(p+3)),q);
                break;
              }
              case CMYKQuantum:
              {
                SetPixelCyan(image,ScaleCharToQuantum(*p),q);
                SetPixelMagenta(image,ScaleCharToQuantum(*(p+1)),q);
                SetPixelYellow(image,ScaleCharToQuantum(*(p+2)),q);
                SetPixelBlack(image,ScaleCharToQuantum(*(p+3)),q);
                break;
              }
              case CMYKAQuantum:
              {
                SetPixelCyan(image,ScaleCharToQuantum(*p),q);
                SetPixelMagenta(image,ScaleCharToQuantum(*(p+1)),q);
                SetPixelYellow(image,ScaleCharToQuantum(*(p+2)),q);
                SetPixelBlack(image,ScaleCharToQuantum(*(p+3)),q);
                SetPixelAlpha(image,ScaleCharToQuantum(*(p+4)),q);
                break;
              }
              default:
                break;
            }
            p+=samples_per_pixel;
            q+=GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) row_index,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        tile=(uint32 *) RelinquishMagickMemory(tile);
        break;
      }
    }