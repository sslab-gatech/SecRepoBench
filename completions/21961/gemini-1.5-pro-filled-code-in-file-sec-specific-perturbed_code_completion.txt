case ReadStripMethod:
      {
        register uint32
          *p;

        /*
          Convert strip TIFF image.
        */
        for (row_index=0; row_index < (ssize_t) image->rows; row_index++)
        {
          register Quantum
            *magick_restrict q;

          tiff_status=TIFFReadPixels(tiff,0,row_index,(char *) pixels);
          if (tiff_status == -1)
            break;
          q=QueueAuthenticPixels(image,0,row_index,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          p=(uint32 *) pixels;
          for (i=0; i < (ssize_t) image->columns; i++)
          {
            switch (quantum_type)
            {
              case IndexQuantum:
              {
                SetPixelIndex(image,*p++,q);
                break;
              }
              case IndexAlphaQuantum:
              {
                SetPixelIndex(image,*p++,q);
                SetPixelAlpha(image,*p++,q);
                break;
              }
              case GrayQuantum:
              {
                SetPixelGray(image,*p++,q);
                break;
              }
              case GrayAlphaQuantum:
              {
                SetPixelGray(image,*p++,q);
                SetPixelAlpha(image,*p++,q);
                break;
              }
              case AlphaQuantum:
              {
                SetPixelAlpha(image,*p++,q);
                break;
              }
              default:
              {
                SetPixelRed(image,GetPixelRed(image,p),q);
                SetPixelGreen(image,GetPixelGreen(image,p),q);
                SetPixelBlue(image,GetPixelBlue(image,p),q);
                if (image->alpha_trait != UndefinedPixelTrait)
                  SetPixelAlpha(image,GetPixelAlpha(image,p),q);
                p++;
                break;
              }
            }
            q+=GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                row_index,image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case ReadTileMethod:
      {
        register uint32
          *p;

        uint32
          columns,
          rows;

        /*
          Convert tile TIFF image.
        */
        columns=(uint32) tiff_info.tile_geometry.width;
        rows=(uint32) tiff_info.tile_geometry.height;
        for (row_index=0; row_index < (ssize_t) image->rows; row_index+=rows)
        {
          register ssize_t
            x;

          register Quantum
            *magick_restrict q;

          size_t
            number_pixels;

          ssize_t
            j,
            row;

          if (status == MagickFalse)
            continue;
          if (((row_index+rows) > image->rows) ||
              ((image_info->number_scenes != 0) &&
               (image->scene >= (image_info->scene+image_info->number_scenes-1))))
            rows=(uint32) (image->rows-row_index);
          number_pixels=(MagickSizeType) columns*rows;
          for (j=0; j < (ssize_t) number_pixels; j++)
            pixels[j]=0;
          tiff_status=TIFFReadRGBAImage(tiff,columns,rows,(uint32 *) pixels,0);
          if (tiff_status == -1)
            break;
          for (row=0; row < (ssize_t) rows; row++)
          {
            if (((row+row_index) >= (ssize_t) image->rows) || (status == MagickFalse))
              continue;
            q=QueueAuthenticPixels(image,0,row+row_index,columns,1,exception);
            if (q == (Quantum *) NULL)
              {
                status=MagickFalse;
                break;
              }
            p=(uint32 *) pixels+row*columns;
            q+=GetPixelChannels(image)*(columns-1);
            for (x=0; x < (ssize_t) columns; x++)
            {
              SetPixelRed(image,ScaleCharToQuantum((unsigned char)
                TIFFGetR(*p)),q);
              SetPixelGreen(image,ScaleCharToQuantum((unsigned char)
                TIFFGetG(*p)),q);
              SetPixelBlue(image,ScaleCharToQuantum((unsigned char)
                TIFFGetB(*p)),q);
              if (image->alpha_trait != UndefinedPixelTrait)
                SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)
                  TIFFGetA(*p)),q);
              p++;
              q-=GetPixelChannels(image);
            }
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              {
                status=MagickFalse;
                break;
              }
          }
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                row_index,image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }