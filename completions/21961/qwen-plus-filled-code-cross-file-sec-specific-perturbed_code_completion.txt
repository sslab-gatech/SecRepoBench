case ReadStripMethod:
      {
        /*
          Convert strip-based TIFF image.
        */
        uint32
          strip_size;

        MemoryInfo
          *strip_info = (MemoryInfo *) NULL;

        register uint32
          *p;

        strip_size=(uint32) TIFFStripSize(tiff);
        if (HeapOverflowSanityCheck((size_t) strip_size,sizeof(*pixels)) != MagickFalse)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        number_pixels=(MagickSizeType) image->columns*rows_per_strip;
        strip_info=AcquireVirtualMemory(number_pixels,strip_size*sizeof(uint32));
        if (strip_info == (MemoryInfo *) NULL)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        pixels=(unsigned char *) GetVirtualMemoryBlob(strip_info);
        for (row_index=0; row_index < (ssize_t) image->rows; row_index += (ssize_t) rows_per_strip)
        {
          size_t
            count;

          ssize_t
            rows;

          rows=(ssize_t) MagickMin((size_t) rows_per_strip,image->rows-row_index);
          count=TIFFReadEncodedStrip(tiff,(tstrip_t) row_index/(ssize_t) rows_per_strip,
            pixels,rows*image->columns*samples_per_pixel);
          if ((count == 0) || ((ssize_t) count < rows*image->columns*samples_per_pixel))
            break;
          p=pixels;
          for (y=0; y < rows; y++)
          {
            register Quantum
              *magick_restrict q;

            register ssize_t
              x;

            q=QueueAuthenticPixels(image,0,row_index+y,image->columns,1,exception);
            if (q == (Quantum *) NULL)
              continue;
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              SetPixelRed(image,ScaleShortToQuantum((unsigned short) TIFFGetR(*p)),q);
              SetPixelGreen(image,ScaleShortToQuantum((unsigned short) TIFFGetG(*p)),q);
              SetPixelBlue(image,ScaleShortToQuantum((unsigned short) TIFFGetB(*p)),q);
              if (image->alpha_trait != UndefinedPixelTrait)
                SetPixelAlpha(image,ScaleShortToQuantum((unsigned short) TIFFGetA(*p)),q);
              p++;
              q+=GetPixelChannels(image);
            }
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) row_index+y,
                  image->rows);
                if (status == MagickFalse)
                  break;
              }
          }
        }
        strip_info=RelinquishVirtualMemory(strip_info);
        break;
      }
      case ReadTileMethod:
      {
        /*
          Convert tile-based TIFF image.
        */
        uint32
          tile_size;

        MemoryInfo
          *tile_info = (MemoryInfo *) NULL;

        register uint32
          *p;

        uint32
          tiles_per_row,
          tiles_per_column;

        size_t
          tile_width,
          tile_length;

        /*
          Determine tile dimensions.
        */
        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&tile_width) != 1) ||
            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&tile_length) != 1))
          ThrowTIFFException(CorruptImageError,"ImproperImageHeader");
        tiles_per_row=(uint32) ceil((double) image->columns/tile_width);
        tiles_per_column=(uint32) ceil((double) image->rows/tile_length);
        tile_size=(uint32) TIFFTileSize(tiff);
        if (HeapOverflowSanityCheck((size_t) tile_size,sizeof(*pixels)) != MagickFalse)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        number_pixels=(MagickSizeType) tiles_per_row*tiles_per_column*tile_size;
        tile_info=AcquireVirtualMemory(number_pixels,tile_size*sizeof(uint32));
        if (tile_info == (MemoryInfo *) NULL)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        pixels=(unsigned char *) GetVirtualMemoryBlob(tile_info);
        for (y=0; y < (ssize_t) tiles_per_column; y++)
        {
          ssize_t
            tile_height;

          for (x=0; x < (ssize_t) tiles_per_row; x++)
          {
            size_t
              count;

            ssize_t
              i,
              j,
              tile_width;

            tile_width=(x != tiles_per_row-1) ? (ssize_t) tile_width :
              (ssize_t) image->columns-(tile_width*x);
            tile_height=(y != tiles_per_column-1) ? (ssize_t) tile_length :
              (ssize_t) image->rows-(tile_length*y);
            count=TIFFReadEncodedTile(tiff,x+y*tiles_per_row,pixels,
              tile_width*tile_height*samples_per_pixel);
            if ((count == 0) || ((ssize_t) count < tile_width*tile_height*samples_per_pixel))
              break;
            p=pixels;
            for (j=0; j < tile_height; j++)
            {
              register Quantum
                *magick_restrict q;

              q=QueueAuthenticPixels(image,x*tile_width,y*tile_length+j,
                tile_width,1,exception);
              if (q == (Quantum *) NULL)
                continue;
              for (i=0; i < tile_width; i++)
              {
                SetPixelRed(image,ScaleShortToQuantum((unsigned short) TIFFGetR(*p)),q);
                SetPixelGreen(image,ScaleShortToQuantum((unsigned short) TIFFGetG(*p)),q);
                SetPixelBlue(image,ScaleShortToQuantum((unsigned short) TIFFGetB(*p)),q);
                if (image->alpha_trait != UndefinedPixelTrait)
                  SetPixelAlpha(image,ScaleShortToQuantum((unsigned short) TIFFGetA(*p)),q);
                p++;
                q+=GetPixelChannels(image);
              }
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
            }
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y*tile_length+j,
                  image->rows);
                if (status == MagickFalse)
                  break;
              }
          }
        }
        tile_info=RelinquishVirtualMemory(tile_info);
        break;
      }