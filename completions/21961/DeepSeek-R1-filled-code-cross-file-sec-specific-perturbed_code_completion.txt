case ReadStripMethod:
      {
        tsize_t
          strip_size;

        uint32
          strip;

        strip_size=TIFFStripSize(tiff);
        if (strip_size <= 0)
          ThrowTIFFException(CorruptImageError,"InvalidStripSize");
        if (HeapOverflowSanityCheck(strip_size,1) != MagickFalse)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        for (strip=0; strip < TIFFNumberOfStrips(tiff); strip++)
        {
          ssize_t
            row;

          uint32
            strip_rows;

          strip_rows=(strip == (TIFFNumberOfStrips(tiff)-1)) ? (height % rows_per_strip) : rows_per_strip;
          if (strip_rows == 0)
            strip_rows=rows_per_strip;
          tiff_status=TIFFReadEncodedStrip(tiff,strip,pixels,(tsize_t) -1);
          if (tiff_status == -1)
            break;
          for (row=0; row < (ssize_t) strip_rows; row++)
          {
            row_index=(strip*rows_per_strip)+row;
            if (row_index >= (ssize_t) image->rows)
              break;
            q=QueueAuthenticPixels(image,0,row_index,image->columns,1,exception);
            if (q == (Quantum *) NULL)
              break;
            status=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
                quantum_type,pixels+row*TIFFScanlineSize(tiff),exception);
            if (status == MagickFalse)
              break;
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,LoadImageTag,row_index,
                  image->rows);
                if (status == MagickFalse)
                  break;
              }
          }
          if (tiff_status == -1)
            break;
        }
        break;
      }
      case ReadTileMethod:
      {
        uint32
          tile_width,
          tile_height;

        tsize_t
          tile_size;

        unsigned char
          *tile_pixels;

        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&tile_width) != 1) ||
            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&tile_height) != 1))
          ThrowTIFFException(CorruptImageError,"InvalidTileDimensions");
        tile_size=TIFFTileSize(tiff);
        if (tile_size <= 0)
          ThrowTIFFException(CorruptImageError,"InvalidTileSize");
        if (HeapOverflowSanityCheck(tile_size,1) != MagickFalse)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        tile_pixels=(unsigned char *) AcquireQuantumMemory(tile_size,
          sizeof(*tile_pixels));
        if (tile_pixels == (unsigned char *) NULL)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        for (row_index=0; row_index < (ssize_t) image->rows; row_index+=tile_height)
        {
          ssize_t
            x;

          for (x=0; x < (ssize_t) image->columns; x+=tile_width)
          {
            ssize_t
              y;

            tiff_status=TIFFReadTile(tiff,tile_pixels,x,row_index,0,0);
            if (tiff_status == -1)
              break;
            for (y=0; y < (ssize_t) tile_height; y++)
            {
              ssize_t
                current_row;

              current_row=row_index+y;
              if (current_row >= (ssize_t) image->rows)
                break;
              q=QueueAuthenticPixels(image,x,current_row,MagickMin(tile_width,
                (uint32) (image->columns-x)),1,exception);
              if (q == (Quantum *) NULL)
                break;
              status=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
                quantum_type,tile_pixels+y*TIFFTileRowSize(tiff),exception);
              if (status == MagickFalse)
                break;
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
            }
            if (tiff_status == -1)
              break;
          }
          if (tiff_status == -1)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,row_index,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        tile_pixels=(unsigned char *) RelinquishMagickMemory(tile_pixels);
        break;
      }