case ReadStripMethod:
      {
        register uint32
          *p;

        uint32
          *pixels;

        /*
          Convert strip TIFF image.
        */
        if (HeapOverflowSanityCheck(image->rows,sizeof(*pixels)) != MagickFalse)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        number_pixels=(MagickSizeType) image->columns*image->rows;
        pixel_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));
        if (pixel_info == (MemoryInfo *) NULL)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        pixels=(uint32 *) GetVirtualMemoryBlob(pixel_info);
        for (row_index=0; row_index < (ssize_t) image->rows; row_index++)
        {
          tiff_status=TIFFReadScanline(tiff,pixels+(row_index*image->columns),
            (uint32) row_index,0);
          if (tiff_status == -1)
            break;
        }
        p=pixels;
        for (row_index=0; row_index < (ssize_t) image->rows; row_index++)
        {
          register ssize_t
            x;

          register Quantum
            *magick_restrict q;

          q=QueueAuthenticPixels(image,0,row_index,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelRed(image,ScaleCharToQuantum((unsigned char)
              TIFFGetR(*p)),q);
            SetPixelGreen(image,ScaleCharToQuantum((unsigned char)
              TIFFGetG(*p)),q);
            SetPixelBlue(image,ScaleCharToQuantum((unsigned char)
              TIFFGetB(*p)),q);
            if (image->alpha_trait != UndefinedPixelTrait)
              SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)
                TIFFGetA(*p)),q);
            p++;
            q+=GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) row_index,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        pixel_info=RelinquishVirtualMemory(pixel_info);
        break;
      }
      case ReadTileMethod:
      {
        register uint32
          *p;

        uint32
          *pixels;

        uint32
          columns,
          rows,
          tile_columns,
          tile_rows;

        /*
          Convert tile TIFF image.
        */
        TIFFGetFieldDefaulted(tiff,TIFFTAG_TILEWIDTH,&tile_columns,sans);
        TIFFGetFieldDefaulted(tiff,TIFFTAG_TILELENGTH,&tile_rows,sans);
        if (HeapOverflowSanityCheck(tile_rows,sizeof(*pixels)) != MagickFalse)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        pixel_info=AcquireVirtualMemory((MagickSizeType) tile_columns*tile_rows,
          sizeof(uint32));
        if (pixel_info == (MemoryInfo *) NULL)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        pixels=(uint32 *) GetVirtualMemoryBlob(pixel_info);
        for (row_index=0; row_index < (ssize_t) image->rows; row_index+=(ssize_t) tile_rows)
        {
          for (i=0; i < (ssize_t) image->columns; i+=(ssize_t) tile_columns)
          {
            columns=tile_columns;
            if ((i+(ssize_t) columns) > (ssize_t) image->columns)
              columns=(uint32) (image->columns-i);
            rows=tile_rows;
            if ((row_index+(ssize_t) rows) > (ssize_t) image->rows)
              rows=(uint32) (image->rows-row_index);
            tiff_status=TIFFReadTile(tiff,pixels,i,row_index,0,0);
            if (tiff_status == -1)
              break;
            p=pixels;
            for (y=0; y < (ssize_t) rows; y++)
            {
              register ssize_t
                x;

              register Quantum
                *magick_restrict q;

              q=QueueAuthenticPixels(image,i,row_index+y,columns,1,exception);
              if (q == (Quantum *) NULL)
                break;
              for (x=0; x < (ssize_t) columns; x++)
              {
                SetPixelRed(image,ScaleCharToQuantum((unsigned char)
                  TIFFGetR(*p)),q);
                SetPixelGreen(image,ScaleCharToQuantum((unsigned char)
                  TIFFGetG(*p)),q);
                SetPixelBlue(image,ScaleCharToQuantum((unsigned char)
                  TIFFGetB(*p)),q);
                if (image->alpha_trait != UndefinedPixelTrait)
                  SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)
                    TIFFGetA(*p)),q);
                p++;
                q+=GetPixelChannels(image);
              }
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
            }
          }
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) row_index,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        pixel_info=RelinquishVirtualMemory(pixel_info);
        break;
      }