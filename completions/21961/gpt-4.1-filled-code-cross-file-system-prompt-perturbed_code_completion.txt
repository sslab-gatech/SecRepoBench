case ReadStripMethod:
      {
        /*
          Read TIFF image by strips.
        */
        tsize_t
          strip_size;

        uint32
          strip,
          strips_per_image;

        strip_size=TIFFStripSize(tiff);
        strips_per_image=TIFFNumberOfStrips(tiff);
        if ((strip_size <= 0) || (strips_per_image == 0))
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        {
          unsigned char
            *strip_buffer;

          strip_buffer=(unsigned char *) AcquireQuantumMemory(strip_size,
            sizeof(*strip_buffer));
          if (strip_buffer == (unsigned char *) NULL)
            ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
          row_index=0;
          for (strip=0; strip < strips_per_image; strip++)
          {
            tsize_t
              count;

            count=TIFFReadEncodedStrip(tiff,strip,strip_buffer,strip_size);
            if (count == -1)
              break;
            {
              ssize_t
                y,
                rows_in_strip;

              rows_in_strip=(ssize_t) TIFFComputeStrip(tiff,row_index,0);
              rows_in_strip=(ssize_t) MagickMin((size_t)rows_per_strip,
                image->rows-row_index);
              for (y=0; y < rows_in_strip; y++)
              {
                Quantum
                  *q;

                q=QueueAuthenticPixels(image,0,row_index,image->columns,1,exception);
                if (q == (Quantum *) NULL)
                  break;
                (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
                  quantum_type,strip_buffer+y*TIFFScanlineSize(tiff),exception);
                if (SyncAuthenticPixels(image,exception) == MagickFalse)
                  break;
                if (image->previous == (Image *) NULL)
                  {
                    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) row_index,
                      image->rows);
                    if (status == MagickFalse)
                      break;
                  }
                row_index++;
                if (row_index >= (ssize_t) image->rows)
                  break;
              }
            }
            if (row_index >= (ssize_t) image->rows)
              break;
          }
          strip_buffer=(unsigned char *) RelinquishMagickMemory(strip_buffer);
        }
        break;
      }
      case ReadTileMethod:
      {
        /*
          Read TIFF image by tiles.
        */
        uint32
          tile_width,
          tile_height,
          x,
          y;

        tsize_t
          tile_size;

        unsigned char
          *tile_buffer;

        tile_width=0;
        tile_height=0;
        (void) TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&tile_width);
        (void) TIFFGetField(tiff,TIFFTAG_TILELENGTH,&tile_height);
        tile_size=TIFFTileSize(tiff);
        if ((tile_width == 0) || (tile_height == 0) || (tile_size <= 0))
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        tile_buffer=(unsigned char *) AcquireQuantumMemory(tile_size,
          sizeof(*tile_buffer));
        if (tile_buffer == (unsigned char *) NULL)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        for (y=0; y < image->rows; y+=tile_height)
        {
          for (x=0; x < image->columns; x+=tile_width)
          {
            tsize_t
              count;

            count=TIFFReadEncodedTile(tiff,TIFFComputeTile(tiff,x,y,0,0),
              tile_buffer,tile_size);
            if (count == -1)
              continue;
            {
              ssize_t
                row,
                max_row;

              max_row=(ssize_t) MagickMin((size_t)tile_height,image->rows-y);
              for (row=0; row < max_row; row++)
              {
                Quantum
                  *q;

                ssize_t
                  col,
                  max_col;

                q=QueueAuthenticPixels(image,x,y+row,
                  MagickMin((size_t)tile_width,image->columns-x),1,exception);
                if (q == (Quantum *) NULL)
                  break;
                max_col=(ssize_t) MagickMin((size_t)tile_width,image->columns-x);
                (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
                  quantum_type,
                  tile_buffer+row*TIFFTileRowSize(tiff),exception);
                if (SyncAuthenticPixels(image,exception) == MagickFalse)
                  break;
                if (image->previous == (Image *) NULL)
                  {
                    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) (y+row),
                      image->rows);
                    if (status == MagickFalse)
                      break;
                  }
              }
            }
          }
        }
        tile_buffer=(unsigned char *) RelinquishMagickMemory(tile_buffer);
        break;
      }