case ReadStripMethod:
      {
        /*
          Convert TIFF image one strip at a time.
        */
        for (row_index=0; row_index < (ssize_t) image->rows; row_index+=
             (ssize_t) rows_per_strip)
        {
          MagickOffsetType
            progress;

          register Quantum
            *magick_restrict q;

          register ssize_t
            x,
            y;

          size_t
            quantum_bytes;

          /*
            Read a strip of pixels.
          */
          tiff_status=TIFFReadEncodedStrip(tiff,(tstrip_t) (row_index/
            rows_per_strip),pixels,(tsize_t) number_pixels);
          if (tiff_status == -1)
            break;
          quantum_bytes=GetQuantumBytes(image,quantum_info);
          for (y=0; y < (ssize_t) rows_per_strip; y++)
          {
            if ((row_index+y) >= (ssize_t) image->rows)
              break;
            q=QueueAuthenticPixels(image,0,row_index+y,image->columns,1,
              exception);
            if (q == (Quantum *) NULL)
              break;
            if ((image->storage_class == PseudoClass) &&
                (quantum_type == IndexQuantum))
              {
                unsigned char
                  *p;

                p=pixels+y*(image->columns*((quantum_info->depth+7)/8));
                for (x=0; x < (ssize_t) image->columns; x++)
                {
                  SetPixelIndex(image,(Quantum) (*p),q);
                  p++;
                  q+=GetPixelChannels(image);
                }
              }
            else
              if ((image->storage_class == PseudoClass) &&
                  (quantum_type == IndexAlphaQuantum))
                {
                  unsigned char
                    *p;

                  p=pixels+y*(image->columns*2);
                  for (x=0; x < (ssize_t) image->columns; x++)
                  {
                    SetPixelIndex(image,(Quantum) (*p),q);
                    SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)
                      *(p+1)),q);
                    p+=2;
                    q+=GetPixelChannels(image);
                  }
                }
              else
                if (quantum_type == GrayQuantum)
                  {
                    unsigned char
                      *p;

                    p=pixels+y*(image->columns*((quantum_info->depth+7)/8));
                    for (x=0; x < (ssize_t) image->columns; x++)
                    {
                      SetPixelGray(image,ScaleCharToQuantum((unsigned char)
                        *p),q);
                      p++;
                      q+=GetPixelChannels(image);
                    }
                  }
                else
                  if (quantum_type == GrayAlphaQuantum)
                    {
                      unsigned char
                        *p;

                      p=pixels+y*(image->columns*2);
                      for (x=0; x < (ssize_t) image->columns; x++)
                      {
                        SetPixelGray(image,ScaleCharToQuantum((unsigned char)
                          *p),q);
                        SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)
                          *(p+1)),q);
                        p+=2;
                        q+=GetPixelChannels(image);
                      }
                    }
                  else
                    if (quantum_type == RGBQuantum)
                      {
                        unsigned char
                          *p;

                        p=pixels+y*(image->columns*3);
                        for (x=0; x < (ssize_t) image->columns; x++)
                        {
                          SetPixelRed(image,ScaleCharToQuantum((unsigned char)
                            *p),q);
                          SetPixelGreen(image,ScaleCharToQuantum((unsigned char)
                            *(p+1)),q);
                          SetPixelBlue(image,ScaleCharToQuantum((unsigned char)
                            *(p+2)),q);
                          p+=3;
                          q+=GetPixelChannels(image);
                        }
                      }
                    else
                      if (quantum_type == RGBAQuantum)
                        {
                          unsigned char
                            *p;

                          p=pixels+y*(image->columns*4);
                          for (x=0; x < (ssize_t) image->columns; x++)
                          {
                            SetPixelRed(image,ScaleCharToQuantum((unsigned char)
                              *p),q);
                            SetPixelGreen(image,ScaleCharToQuantum((unsigned char)
                              *(p+1)),q);
                            SetPixelBlue(image,ScaleCharToQuantum((unsigned char)
                              *(p+2)),q);
                            SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)
                              *(p+3)),q);
                            p+=4;
                            q+=GetPixelChannels(image);
                          }
                        }
                      else
                        if (quantum_type == CMYKQuantum)
                          {
                            unsigned char
                              *p;

                            p=pixels+y*(image->columns*4);
                            for (x=0; x < (ssize_t) image->columns; x++)
                            {
                              SetPixelCyan(image,ScaleCharToQuantum((unsigned char)
                                *p),q);
                              SetPixelMagenta(image,ScaleCharToQuantum((unsigned char)
                                *(p+1)),q);
                              SetPixelYellow(image,ScaleCharToQuantum((unsigned char)
                                *(p+2)),q);
                              SetPixelBlack(image,ScaleCharToQuantum((unsigned char)
                                *(p+3)),q);
                              p+=4;
                              q+=GetPixelChannels(image);
                            }
                          }
                        else
                          if (quantum_type == CMYKAQuantum)
                            {
                              unsigned char
                                *p;

                              p=pixels+y*(image->columns*5);
                              for (x=0; x < (ssize_t) image->columns; x++)
                              {
                                SetPixelCyan(image,ScaleCharToQuantum((unsigned char)
                                  *p),q);
                                SetPixelMagenta(image,ScaleCharToQuantum((unsigned char)
                                  *(p+1)),q);
                                SetPixelYellow(image,ScaleCharToQuantum((unsigned char)
                                  *(p+2)),q);
                                SetPixelBlack(image,ScaleCharToQuantum((unsigned char)
                                  *(p+3)),q);
                                SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)
                                  *(p+4)),q);
                                p+=5;
                                q+=GetPixelChannels(image);
                              }
                            }
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
          }
          progress=(MagickOffsetType) row_index;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,progress,image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case ReadTileMethod:
      {
        uint32
          tile_height,
          tile_width;

        /*
          Convert TIFF image one tile at a time.
        */
        (void) TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&tile_width);
        (void) TIFFGetField(tiff,TIFFTAG_TILELENGTH,&tile_height);
        for (row_index=0; row_index < (ssize_t) image->rows; row_index+=
             (ssize_t) tile_height)
        {
          MagickOffsetType
            progress;

          register ssize_t
            x,
            y;

          ssize_t
            tile_col,
            tile_row;

          /*
            Read a tile of pixels.
          */
          for (tile_row=0; tile_row < (ssize_t) (image->rows/tile_height+1);
               tile_row++)
          {
            for (tile_col=0; tile_col < (ssize_t) (image->columns/tile_width+1);
                 tile_col++)
            {
              register Quantum
                *magick_restrict q;

              ssize_t
                i,
                j;

              tiff_status=TIFFReadEncodedTile(tiff,(tstrip_t) (tile_row*
                (image->columns/tile_width+1)+tile_col),pixels,(tsize_t)
                number_pixels);
              if (tiff_status == -1)
                break;
              for (y=0; y < (ssize_t) tile_height; y++)
              {
                if ((row_index+y) >= (ssize_t) image->rows)
                  break;
                q=QueueAuthenticPixels(image,tile_col*tile_width,row_index+y,
                  tile_width,1,exception);
                if (q == (Quantum *) NULL)
                  break;
                if ((image->storage_class == PseudoClass) &&
                    (quantum_type == IndexQuantum))
                  {
                    unsigned char
                      *p;

                    p=pixels+y*(tile_width*((quantum_info->depth+7)/8));
                    for (x=0; x < (ssize_t) tile_width; x++)
                    {
                      if (((tile_col*tile_width)+x) >= (ssize_t) image->columns)
                        break;
                      SetPixelIndex(image,(Quantum) (*p),q);
                      p++;
                      q+=GetPixelChannels(image);
                    }
                  }
                else
                  if ((image->storage_class == PseudoClass) &&
                      (quantum_type == IndexAlphaQuantum))
                    {
                      unsigned char
                        *p;

                      p=pixels+y*(tile_width*2);
                      for (x=0; x < (ssize_t) tile_width; x++)
                      {
                        if (((tile_col*tile_width)+x) >= (ssize_t) image->columns)
                          break;
                        SetPixelIndex(image,(Quantum) (*p),q);
                        SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)
                          *(p+1)),q);
                        p+=2;
                        q+=GetPixelChannels(image);
                      }
                    }
                  else
                    if (quantum_type == GrayQuantum)
                      {
                        unsigned char
                          *p;

                        p=pixels+y*(tile_width*((quantum_info->depth+7)/8));
                        for (x=0; x < (ssize_t) tile_width; x++)
                        {
                          if (((tile_col*tile_width)+x) >= (ssize_t) image->columns)
                            break;
                          SetPixelGray(image,ScaleCharToQuantum((unsigned char)
                            *p),q);
                          p++;
                          q+=GetPixelChannels(image);
                        }
                      }
                    else
                      if (quantum_type == GrayAlphaQuantum)
                        {
                          unsigned char
                            *p;

                          p=pixels+y*(tile_width*2);
                          for (x=0; x < (ssize_t) tile_width; x++)
                          {
                            if (((tile_col*tile_width)+x) >= (ssize_t) image->columns)
                              break;
                            SetPixelGray(image,ScaleCharToQuantum((unsigned char)
                              *p),q);
                            SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)
                              *(p+1)),q);
                            p+=2;
                            q+=GetPixelChannels(image);
                          }
                        }
                      else
                        if (quantum_type == RGBQuantum)
                          {
                            unsigned char
                              *p;

                            p=pixels+y*(tile_width*3);
                            for (x=0; x < (ssize_t) tile_width; x++)
                            {
                              if (((tile_col*tile_width)+x) >= (ssize_t) image->
                                  columns)
                                break;
                              SetPixelRed(image,ScaleCharToQuantum((unsigned char)
                                *p),q);
                              SetPixelGreen(image,ScaleCharToQuantum((unsigned char)
                                *(p+1)),q);
                              SetPixelBlue(image,ScaleCharToQuantum((unsigned char)
                                *(p+2)),q);
                              p+=3;
                              q+=GetPixelChannels(image);
                            }
                          }
                        else
                          if (quantum_type == RGBAQuantum)
                            {
                              unsigned char
                                *p;

                              p=pixels+y*(tile_width*4);
                              for (x=0; x < (ssize_t) tile_width; x++)
                              {
                                if (((tile_col*tile_width)+x) >= (ssize_t) image->
                                    columns)
                                  break;
                                SetPixelRed(image,ScaleCharToQuantum((unsigned char)
                                  *p),q)