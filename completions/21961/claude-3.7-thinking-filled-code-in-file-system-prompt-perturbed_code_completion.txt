case ReadStripMethod:
{
  /*
    Convert stripped TIFF image.
  */
  uint32
    *strip_offsets,
    *strip_sizes,
    strip_size,
    strips_per_image;

  if (TIFFGetField(tiff,TIFFTAG_STRIPOFFSETS,&strip_offsets) != 1)
    ThrowTIFFException(ResourceLimitError,"MissingStripOffsets");
  if (TIFFGetField(tiff,TIFFTAG_STRIPBYTECOUNTS,&strip_sizes) != 1)
    ThrowTIFFException(ResourceLimitError,"MissingStripByteCounts");
  strips_per_image=TIFFNumberOfStrips(tiff);
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    register Quantum
      *magick_restrict q;

    ssize_t
      j;

    tstrip_t
      strip;

    strip=(tstrip_t) (y/rows_per_strip);
    if (y == (ssize_t) (strip*rows_per_strip))
      {
        strip_size=strip_sizes[strip];
        if (((strip_size == 0) && (strip < strips_per_image)) ||
            (strip_size > pixel_info->extent))
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        if ((strip < strips_per_image) && (TIFFReadEncodedStrip(tiff,strip,
            pixels,strip_size) == -1))
          break;
      }
    j=y-strip*rows_per_strip;
    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
    if (q == (Quantum *) NULL)
      break;
    length=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
      quantum_type,pixels+j*TIFFScanlineSize(tiff),exception);
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  break;
}
case ReadTileMethod:
{
  /*
    Convert tiled TIFF image.
  */
  uint32
    tile_columns,
    tile_rows,
    tile_size;

  if (TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&tile_columns) != 1)
    ThrowTIFFException(ResourceLimitError,"MissingTileWidth");
  if (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&tile_rows) != 1)
    ThrowTIFFException(ResourceLimitError,"MissingTileLength");
  tile_size=TIFFTileSize(tiff);
  if (tile_size > pixel_info->extent)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  for (y=0; y < (ssize_t) image->rows; y+=tile_rows)
  {
    ssize_t
      tile_height;

    tile_height=(ssize_t) MagickMin(tile_rows,image->rows-y);
    for (x=0; x < (ssize_t) image->columns; x+=tile_columns)
    {
      register ssize_t
        j,
        k;

      register Quantum
        *magick_restrict q;

      ssize_t
        tile_width;

      ttile_t
        tile;

      tile_width=(ssize_t) MagickMin(tile_columns,image->columns-x);
      tile=TIFFComputeTile(tiff,(uint32) x,(uint32) y,0,0);
      if (TIFFReadEncodedTile(tiff,tile,pixels,tile_size) == -1)
        break;
      for (j=0; j < tile_height; j++)
      {
        q=QueueAuthenticPixels(image,x,y+j,tile_width,1,exception);
        if (q == (Quantum *) NULL)
          break;
        length=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
          quantum_type,pixels+j*TIFFTileRowSize(tiff),exception);
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
      }
    }
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  break;
}