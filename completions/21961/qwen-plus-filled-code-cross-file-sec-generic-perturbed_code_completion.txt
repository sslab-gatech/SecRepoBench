case ReadStripMethod:
{
  /*
    Convert strip-based TIFF image.
  */
  for (row_index=0; row_index < (ssize_t) image->rows; )
  {
    ssize_t
      rows_per_read;

    rows_per_read = MagickMin(rows_per_strip, (size_t)(image->rows - row_index));
    tiff_status = TIFFReadPixels(tiff, 0, row_index, (char *) pixels);
    if (tiff_status == -1)
      break;

    for (ssize_t strip_row = 0; strip_row < rows_per_read; strip_row++, row_index++)
    {
      register Quantum
        *magick_restrict q;

      register uint32
        *p;

      p = (uint32 *)pixels + strip_row * image->columns;
      q = QueueAuthenticPixels(image, 0, row_index, image->columns, 1, exception);
      if (q == (Quantum *) NULL)
        break;

      for (ssize_t x = 0; x < (ssize_t) image->columns; x++)
      {
        SetPixelRed(image, ScaleCharToQuantum((unsigned char)TIFFGetR(*p)), q);
        SetPixelGreen(image, ScaleCharToQuantum((unsigned char)TIFFGetG(*p)), q);
        SetPixelBlue(image, ScaleCharToQuantum((unsigned char)TIFFGetB(*p)), q);

        if (image->alpha_trait != UndefinedPixelTrait)
          SetPixelAlpha(image, ScaleCharToQuantum((unsigned char)TIFFGetA(*p)), q);

        p++;
        q += GetPixelChannels(image);
      }

      if (SyncAuthenticPixels(image, exception) == MagickFalse)
        break;

      if (image->previous == (Image *) NULL)
      {
        status = SetImageProgress(image, LoadImageTag, (MagickOffsetType)row_index, image->rows);
        if (status == MagickFalse)
          break;
      }
    }
  }
  break;
}

case ReadTileMethod:
{
  uint32
    tile_width,
    tile_height;

  /*
    Convert tile-based TIFF image.
  */
  TIFFGetField(tiff, TIFFTAG_TILEWIDTH, &tile_width);
  TIFFGetField(tiff, TIFFTAG_TILELENGTH, &tile_height);

  for (uint32 tile_row = 0; tile_row < (uint32)(image->rows / tile_height); tile_row++)
  {
    for (uint32 tile_col = 0; tile_col < (uint32)(image->columns / tile_width); tile_col++)
    {
      tiff_status = TIFFReadEncodedTile(tiff, TIFFComputeTile(tiff, tile_col, tile_row, 0, 0), pixels, (tmsize_t)(tile_width * tile_height * samples_per_pixel));
      if (tiff_status == -1)
        break;

      for (uint32 tile_y = 0; tile_y < tile_height; tile_y++)
      {
        uint32 row = tile_row * tile_height + tile_y;
        if (row >= image->rows)
          break;

        register Quantum
          *magick_restrict q;

        register uint32
          *p;

        p = (uint32 *)pixels + tile_y * tile_width;
        q = QueueAuthenticPixels(image, tile_col * tile_width, row, tile_width, 1, exception);
        if (q == (Quantum *) NULL)
          break;

        for (uint32 x = 0; x < tile_width; x++)
        {
          SetPixelRed(image, ScaleCharToQuantum((unsigned char)TIFFGetR(*p)), q);
          SetPixelGreen(image, ScaleCharToQuantum((unsigned char)TIFFGetG(*p)), q);
          SetPixelBlue(image, ScaleCharToQuantum((unsigned char)TIFFGetB(*p)), q);

          if (image->alpha_trait != UndefinedPixelTrait)
            SetPixelAlpha(image, ScaleCharToQuantum((unsigned char)TIFFGetA(*p)), q);

          p++;
          q += GetPixelChannels(image);
        }

        if (SyncAuthenticPixels(image, exception) == MagickFalse)
          break;

        if (image->previous == (Image *) NULL)
        {
          status = SetImageProgress(image, LoadImageTag, (MagickOffsetType)row, image->rows);
          if (status == MagickFalse)
            break;
        }
      }
    }
  }
  break;
}