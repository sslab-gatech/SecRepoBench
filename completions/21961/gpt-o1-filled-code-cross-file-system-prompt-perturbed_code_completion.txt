case ReadStripMethod:
{
  /*
    Read TIFF image data strip by strip.
  */
  tsize_t
    strip_size;

  tstrip_t
    strip,
    number_strips;

  uint32
    rows_in_strip,
    row_start,
    row_end;

  number_strips=TIFFNumberOfStrips(tiff);
  for (strip=0; strip < number_strips; strip++)
  {
    strip_size=TIFFReadEncodedStrip(tiff,strip,pixels,(tsize_t) -1);
    if (strip_size < 0)
      break;
    row_start=(uint32) (strip*rows_per_strip);
    row_end=row_start+(rows_per_strip > 0 ? rows_per_strip : (uint32) image->rows);
    if (row_end > (uint32) image->rows)
      row_end=(uint32) image->rows;
    rows_in_strip=row_end-row_start;
    /*
      Import each row from the strip into the image.
    */
    for (i=0; i < (ssize_t) rows_in_strip; i++)
    {
      register Quantum
        *magick_restrict q;

      ssize_t
        row=row_start+(ssize_t) i;

      q=QueueAuthenticPixels(image,0,row,image->columns,1,exception);
      if (q == (Quantum *) NULL)
        break;
      (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
        quantum_type,pixels + (i*(TIFFScanlineSize(tiff))),exception);
      if (SyncAuthenticPixels(image,exception) == MagickFalse)
        break;
      if (image->previous == (Image *) NULL)
        {
          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) row,
            image->rows);
          if (status == MagickFalse)
            break;
        }
    }
  }
  break;
}
case ReadTileMethod:
{
  /*
    Read TIFF image data tile by tile.
  */
  uint32
    tile_width,
    tile_height,
    row,
    col;

  tsize_t
    tile_area;

  tile_width=TIFFTileWidth(tiff);
  tile_height=TIFFTileLength(tiff);
  tile_area=tile_width*tile_height*samples_per_pixel*((bits_per_sample+7)/8);
  for (row=0; row < (uint32) image->rows; row+=tile_height)
  {
    for (col=0; col < (uint32) image->columns; col+=tile_width)
    {
      tsize_t
        count;

      count=TIFFReadEncodedTile(tiff,TIFFComputeTile(tiff,col,row,0,0),
        pixels,(tsize_t) tile_area);
      if (count < 0)
        break;
      /*
        Import each row from the tile block.
      */
      for (i=0; i < (ssize_t) tile_height; i++)
      {
        register Quantum
          *magick_restrict q;

        ssize_t
          offset_row=(ssize_t) row+(ssize_t) i;

        if ((offset_row < 0) || ((size_t) offset_row >= image->rows))
          continue;
        q=QueueAuthenticPixels(image,(ssize_t) col,offset_row,
          MagickMin(tile_width,image->columns-col),1,exception);
        if (q == (Quantum *) NULL)
          break;
        (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
          quantum_type,pixels + (i*(tile_width*samples_per_pixel*
          ((bits_per_sample+7)/8))),exception);
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
        if (image->previous == (Image *) NULL)
          {
            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
              offset_row,image->rows);
            if (status == MagickFalse)
              break;
          }
      }
    }
  }
  break;
}