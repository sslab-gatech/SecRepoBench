case ReadStripMethod:
      {
        register uint32
          *p;

        /*
          Convert strip TIFF image.
        */
        for (row_index=0; row_index < (ssize_t) image->rows; row_index++)
        {
          register ssize_t
            x;

          register Quantum
            *magick_restrict q;

          tiff_status=TIFFReadPixels(tiff,0,row_index,(char *) pixels);
          if (tiff_status == -1)
            break;
          q=QueueAuthenticPixels(image,0,row_index,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          p=(uint32 *) pixels;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            if (image->storage_class == PseudoClass)
              {
                SetPixelIndex(image,*p,q);
                p++;
                q+=GetPixelChannels(image);
                continue;
              }
            if (IsGrayColorspace(image->colorspace) != MagickFalse)
              {
                SetPixelGray(image,ScaleAnyToQuantum(*p,max_sample_value),q);
                p++;
                q+=GetPixelChannels(image);
                continue;
              }
            SetPixelRed(image,ScaleAnyToQuantum(TIFFGetR(*p),max_sample_value),
              q);
            SetPixelGreen(image,ScaleAnyToQuantum(TIFFGetG(*p),
              max_sample_value),q);
            SetPixelBlue(image,ScaleAnyToQuantum(TIFFGetB(*p),max_sample_value),
              q);
            if (image->alpha_trait != UndefinedPixelTrait)
              SetPixelAlpha(image,ScaleAnyToQuantum(TIFFGetA(*p),
                max_sample_value),q);
            p++;
            q+=GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                row_index,image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case ReadTileMethod:
      {
        register uint32
          *p;

        size_t
          number_pixels;

        /*
          Convert tile TIFF image.
        */
        number_pixels=(size_t) tiff_info.tile_geometry.width*
          tiff_info.tile_geometry.height;
        for (row_index=0; row_index < (ssize_t) image->rows; row_index+=(ssize_t)
             tiff_info.tile_geometry.height)
        {
          register ssize_t
            x;

          ssize_t
            columns,
            rows;

          rows=(ssize_t) MagickMin((ssize_t) tiff_info.tile_geometry.height,
            (ssize_t) image->rows-row_index);
          for (i=0; i < (ssize_t) ((image->columns+
               tiff_info.tile_geometry.width-1)/tiff_info.tile_geometry.width);
               i++)
          {
            register Quantum
              *magick_restrict q;

            /*
              Read a tile.
            */
            columns=(ssize_t) MagickMin((ssize_t) tiff_info.tile_geometry.width,
              (ssize_t) image->columns-(ssize_t) (i*
              tiff_info.tile_geometry.width));
            tiff_status=TIFFReadTile(tiff,pixels,(uint32) (i*
              tiff_info.tile_geometry.width),(uint32) row_index,0,0);
            if (tiff_status == -1)
              break;
            /*
              Convert tile to image pixels.
            */
            for (y=0; y < rows; y++)
            {
              q=GetAuthenticPixels(image,(ssize_t) (i*
                tiff_info.tile_geometry.width),row_index+y,columns,1,
                exception);
              if (q == (Quantum *) NULL)
                break;
              p=(uint32 *) pixels+y*tiff_info.tile_geometry.width;
              for (x=0; x < columns; x++)
              {
                if (image->storage_class == PseudoClass)
                  {
                    SetPixelIndex(image,*p,q);
                    p++;
                    q+=GetPixelChannels(image);
                    continue;
                  }
                if (IsGrayColorspace(image->colorspace) != MagickFalse)
                  {
                    SetPixelGray(image,ScaleAnyToQuantum(*p,max_sample_value),
                      q);
                    p++;
                    q+=GetPixelChannels(image);
                    continue;
                  }
                SetPixelRed(image,ScaleAnyToQuantum(TIFFGetR(*p),
                  max_sample_value),q);
                SetPixelGreen(image,ScaleAnyToQuantum(TIFFGetG(*p),
                  max_sample_value),q);
                SetPixelBlue(image,ScaleAnyToQuantum(TIFFGetB(*p),
                  max_sample_value),q);
                if (image->alpha_trait != UndefinedPixelTrait)
                  SetPixelAlpha(image,ScaleAnyToQuantum(TIFFGetA(*p),
                    max_sample_value),q);
                p++;
                q+=GetPixelChannels(image);
              }
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
            }
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                  row_index,image->rows);
                if (status == MagickFalse)
                  break;
              }
          }
        }
        break;
      }