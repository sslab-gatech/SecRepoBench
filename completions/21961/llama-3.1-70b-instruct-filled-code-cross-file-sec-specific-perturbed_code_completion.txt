case ReadStripMethod:
{
  /*
    Convert strip TIFF image.
  */
  size_t
    strip_size;

  strip_size=(size_t) TIFFStripSize(tiff);
  if (strip_size <= 0)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  if ((1.0*strip_size) > (2.53*GetBlobSize(image)))
    ThrowTIFFException(CorruptImageError,"InsufficientImageDataInFile");
  number_pixels=MagickMax(TIFFStripSize(tiff),MagickMax((ssize_t)
    image->columns*samples_per_pixel*pow(2.0,ceil(log(bits_per_sample)/
    log(2.0))),image->columns*rows_per_strip));
  pixel_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));
  if (pixel_info == (MemoryInfo *) NULL)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
  (void) memset(pixels,0,number_pixels*sizeof(uint32));
  for (row_index=0; row_index < (ssize_t) image->rows; row_index+=rows_per_strip)
  {
    register ssize_t
      y;

    register Quantum
      *magick_restrict q;

    tiff_status=TIFFReadEncodedStrip(tiff,row_index,(char *) pixels,strip_size);
    if (tiff_status == -1)
      break;
    for (y=0; y < (ssize_t) rows_per_strip; y++)
    {
      q=QueueAuthenticPixels(image,0,row_index+y,image->columns,1,exception);
      if (q == (Quantum *) NULL)
        break;
      length=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
        quantum_type,pixels,exception);
      (void) length;
      if (SyncAuthenticPixels(image,exception) == MagickFalse)
        break;
      if (image->previous == (Image *) NULL)
        {
          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) row_index,
            image->rows);
          if (status == MagickFalse)
            break;
        }
    }
  }
  break;
}
case ReadTileMethod:
{
  /*
    Convert tile TIFF image.
  */
  size_t
    tile_size;

  ssize_t
    x,
    y;

  tile_size=(size_t) TIFFTileSize(tiff);
  if (tile_size <= 0)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  if ((1.0*tile_size) > (2.53*GetBlobSize(image)))
    ThrowTIFFException(CorruptImageError,"InsufficientImageDataInFile");
  number_pixels=MagickMax(TIFFTileSize(tiff),MagickMax((ssize_t)
    image->columns*samples_per_pixel*pow(2.0,ceil(log(bits_per_sample)/
    log(2.0))),image->columns*rows_per_strip));
  pixel_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));
  if (pixel_info == (MemoryInfo *) NULL)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
  (void) memset(pixels,0,number_pixels*sizeof(uint32));
  for (y=0; y < (ssize_t) image->rows; y+=TIFFTileRowSize(tiff))
  {
    for (x=0; x < (ssize_t) image->columns; x+=TIFFTileColSize(tiff))
    {
      register Quantum
        *magick_restrict q;

      tiff_status=TIFFReadEncodedTile(tiff,x,y,(char *) pixels,tile_size);
      if (tiff_status == -1)
        break;
      q=QueueAuthenticPixels(image,x,y,TIFFTileColSize(tiff),TIFFTileRowSize(tiff),
        exception);
      if (q == (Quantum *) NULL)
        break;
      length=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
        quantum_type,pixels,exception);
      (void) length;
      if (SyncAuthenticPixels(image,exception) == MagickFalse)
        break;
      if (image->previous == (Image *) NULL)
        {
          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
            image->rows);
          if (status == MagickFalse)
            break;
        }
    }
  }
  break;
}