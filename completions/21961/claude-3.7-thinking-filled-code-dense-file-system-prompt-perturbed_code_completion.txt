case ReadStripMethod:
{
  /*
    Convert stripped TIFF image.
  */
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    register Quantum
      *magick_restrict q;

    tiff_status=TIFFReadScanline(tiff,(tdata_t) pixels,(uint32) y,0);
    if (tiff_status == -1)
      break;
    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
    if (q == (Quantum *) NULL)
      break;
    length=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
      quantum_type,pixels,exception);
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  break;
}
case ReadTileMethod:
{
  /*
    Convert tiled TIFF image.
  */
  uint32
    tile_width,
    tile_height;

  if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&tile_width) != 1) ||
      (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&tile_height) != 1))
    {
      TIFFClose(tiff);
      ThrowReaderException(CoderError,"ImageIsNotTiled");
    }
  for (y=0; y < (ssize_t) image->rows; y+=(ssize_t) tile_height)
  {
    for (x=0; x < (ssize_t) image->columns; x+=(ssize_t) tile_width)
    {
      ssize_t
        tile_y;

      size_t
        height,
        width;

      width=tile_width;
      if ((x+width) > image->columns)
        width=image->columns-x;
      height=tile_height;
      if ((y+height) > image->rows)
        height=image->rows-y;
      tiff_status=TIFFReadTile(tiff,(tdata_t) pixels,(uint32) x,(uint32) y,0,0);
      if (tiff_status == -1)
        break;
      for (tile_y=0; tile_y < (ssize_t) height; tile_y++)
      {
        register Quantum
          *magick_restrict q;

        q=QueueAuthenticPixels(image,x,y+tile_y,width,1,exception);
        if (q == (Quantum *) NULL)
          break;
        length=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
          quantum_type,pixels+tile_y*TIFFTileRowSize(tiff),exception);
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
      }
      if (tile_y < (ssize_t) height)
        break;
    }
    if (x < (ssize_t) image->columns)
      break;
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  break;
}