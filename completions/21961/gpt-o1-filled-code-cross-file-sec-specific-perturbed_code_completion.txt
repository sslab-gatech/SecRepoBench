case ReadStripMethod:
      {
        uint32 rows_remaining, rows_to_read;
        uint32 row_offset = 0;
        uint32 *strip_data = (uint32 *) NULL;
        MagickSizeType strip_area;
        tstrip_t s;
        tstrip_t number_strips = TIFFNumberOfStrips(tiff);

        for (s = 0; s < number_strips; s++)
        {
          rows_remaining = (uint32) (image->rows - row_offset);
          if (rows_remaining == 0)
            break;
          rows_to_read = (uint32) MagickMin(rows_per_strip, rows_remaining);
          strip_area = (MagickSizeType) image->columns * rows_to_read;
          if (HeapOverflowSanityCheck(rows_to_read,sizeof(*strip_data)) != MagickFalse)
            ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
          {
            MemoryInfo *strip_info = AcquireVirtualMemory(strip_area,sizeof(uint32));
            if (strip_info == (MemoryInfo *) NULL)
              ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
            strip_data = (uint32 *) GetVirtualMemoryBlob(strip_info);
            (void) memset(strip_data,0,strip_area*sizeof(uint32));
            if (TIFFReadRGBAStrip(tiff,row_offset,strip_data) == 0)
            {
              strip_info=RelinquishVirtualMemory(strip_info);
              break;
            }
            {
              register uint32 *p = strip_data + (strip_area-1);
              for (i = 0; i < (ssize_t) rows_to_read; i++)
              {
                register ssize_t x;
                register Quantum *magick_restrict q;
                const ssize_t row = row_offset + i;

                q = QueueAuthenticPixels(image,0,row,image->columns,1,exception);
                if (q == (Quantum *) NULL)
                  break;
                q += GetPixelChannels(image)*(image->columns-1);
                for (x = 0; x < (ssize_t) image->columns; x++)
                {
                  SetPixelRed(image,ScaleCharToQuantum((unsigned char) TIFFGetR(*p)),q);
                  SetPixelGreen(image,ScaleCharToQuantum((unsigned char) TIFFGetG(*p)),q);
                  SetPixelBlue(image,ScaleCharToQuantum((unsigned char) TIFFGetB(*p)),q);
                  if (image->alpha_trait != UndefinedPixelTrait)
                    SetPixelAlpha(image,ScaleCharToQuantum((unsigned char) TIFFGetA(*p)),q);
                  p--;
                  q -= GetPixelChannels(image);
                }
                if (SyncAuthenticPixels(image,exception) == MagickFalse)
                  break;
                if (image->previous == (Image *) NULL)
                {
                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) row,
                    image->rows);
                  if (status == MagickFalse)
                    break;
                }
              }
            }
            strip_info=RelinquishVirtualMemory(strip_info);
          }
          row_offset += rows_to_read;
        }
        break;
      }
      case ReadTileMethod:
      {
        uint32 tile_width, tile_height;
        uint32 x, y;
        if (TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&tile_width) != 1 ||
            TIFFGetField(tiff,TIFFTAG_TILELENGTH,&tile_height) != 1)
          ThrowTIFFException(CorruptImageError,"ImproperImageHeader");
        for (y = 0; y < (uint32) image->rows; y += tile_height)
        {
          for (x = 0; x < (uint32) image->columns; x += tile_width)
          {
            uint32 block_width=(uint32) MagickMin(tile_width,image->columns-x);
            uint32 block_height=(uint32) MagickMin(tile_height,image->rows-y);
            MagickSizeType tile_area=(MagickSizeType) block_width*block_height;
            uint32 *tile_data;
            MemoryInfo *tile_info;

            if (HeapOverflowSanityCheck(block_height,sizeof(*tile_data)) != MagickFalse)
              ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
            tile_info=AcquireVirtualMemory(tile_area,sizeof(uint32));
            if (tile_info == (MemoryInfo *) NULL)
              ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
            tile_data=(uint32 *) GetVirtualMemoryBlob(tile_info);
            (void) memset(tile_data,0,tile_area*sizeof(uint32));

            if (TIFFReadRGBATile(tiff,x,y,tile_data) == 0)
            {
              tile_info=RelinquishVirtualMemory(tile_info);
              continue;
            }
            {
              register uint32 *p = tile_data + (tile_area-1);
              ssize_t row_in_tile;
              for (row_in_tile = 0; row_in_tile < (ssize_t) block_height; row_in_tile++)
              {
                register Quantum *magick_restrict q;
                register ssize_t col_in_tile;
                const ssize_t row_index = y + row_in_tile;

                q=QueueAuthenticPixels(image,x,row_index,block_width,1,exception);
                if (q == (Quantum *) NULL)
                  break;
                q += GetPixelChannels(image)*(block_width-1);
                for (col_in_tile=0; col_in_tile < (ssize_t) block_width; col_in_tile++)
                {
                  SetPixelRed(image,ScaleCharToQuantum((unsigned char) TIFFGetR(*p)),q);
                  SetPixelGreen(image,ScaleCharToQuantum((unsigned char) TIFFGetG(*p)),q);
                  SetPixelBlue(image,ScaleCharToQuantum((unsigned char) TIFFGetB(*p)),q);
                  if (image->alpha_trait != UndefinedPixelTrait)
                    SetPixelAlpha(image,ScaleCharToQuantum((unsigned char) TIFFGetA(*p)),q);
                  p--;
                  q -= GetPixelChannels(image);
                }
                if (SyncAuthenticPixels(image,exception) == MagickFalse)
                  break;
                if (image->previous == (Image *) NULL)
                {
                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) row_index,
                    image->rows);
                  if (status == MagickFalse)
                    break;
                }
              }
            }
            tile_info=RelinquishVirtualMemory(tile_info);
          }
        }
        break;
      }