case ReadStripMethod:
{
  /*
    Convert strip-based TIFF image.
  */
  size_t
    strip;

  uint32
    strip_size;

  if (HeapOverflowSanityCheck(image->rows,sizeof(*pixels)) != MagickFalse)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  strip_size=(uint32) TIFFStripSize(tiff);
  if (strip_size == 0)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  for (strip=0; strip < (size_t) TIFFNumberOfStrips(tiff); strip++)
  {
    register Quantum
      *magick_restrict q;

    register ssize_t
      x;

    unsigned char
      *p;

    tiff_status=TIFFReadStrip(tiff,strip,(char *) pixels);
    if (tiff_status == -1)
      break;
    q=QueueAuthenticPixels(image,0,strip*rows_per_strip,image->columns,
      rows_per_strip,exception);
    if (q == (Quantum *) NULL)
      break;
    p=pixels;
    for (x=0; x < (ssize_t) image->columns; x++)
    {
      SetPixelRed(image,ScaleCharToQuantum(*p++),q);
      SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
      SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
      if (image->alpha_trait != UndefinedPixelTrait)
        SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);
      q+=GetPixelChannels(image);
    }
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    if (image->previous == (Image *) NULL)
    {
      status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) strip,
        TIFFNumberOfStrips(tiff));
      if (status == MagickFalse)
        break;
    }
  }
  break;
}
case ReadTileMethod:
{
  /*
    Convert tile-based TIFF image.
  */
  uint32
    tile_width,
    tile_height;

  TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&tile_width);
  TIFFGetField(tiff,TIFFTAG_TILEHEIGHT,&tile_height);

  for (row_index=0; row_index < (ssize_t) image->rows; row_index += (ssize_t) tile_height)
  {
    for (size_t x_offset=0; x_offset < image->columns; x_offset += tile_width)
    {
      register Quantum
        *magick_restrict q;

      register ssize_t
        x,
        y;

      unsigned char
        *p;

      tiff_status=TIFFReadTile(tiff,(char *) pixels,x_offset,row_index,0);
      if (tiff_status == -1)
        break;

      q=QueueAuthenticPixels(image,x_offset,row_index,tile_width,tile_height,exception);
      if (q == (Quantum *) NULL)
        break;

      p=pixels;
      for (y=0; y < (ssize_t) tile_height; y++)
      {
        for (x=0; x < (ssize_t) tile_width; x++)
        {
          SetPixelRed(image,ScaleCharToQuantum(*p++),q);
          SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
          SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
          if (image->alpha_trait != UndefinedPixelTrait)
            SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);
          q+=GetPixelChannels(image);
        }
        q+=image->columns - tile_width;
      }

      if (SyncAuthenticPixels(image,exception) == MagickFalse)
        break;

      if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) row_index,
          image->rows);
        if (status == MagickFalse)
          break;
      }
    }
  }
  break;
}