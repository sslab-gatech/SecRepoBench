case ReadStripMethod:
      {
        tmsize_t
          strip_size;

        uint32
          rows_per_strip,
          strip_index,
          num_strips;

        num_strips=TIFFNumberOfStrips(tiff);
        TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip);
        strip_size=TIFFStripSize(tiff);
        for (strip_index=0; strip_index < num_strips; strip_index++)
        {
          tmsize_t
            bytes_read;

          bytes_read=TIFFReadEncodedStrip(tiff,strip_index,pixels,strip_size);
          if (bytes_read == -1)
            break;
          for (row_index=0; row_index < (ssize_t) rows_per_strip; row_index++)
          {
            Quantum
              *q;

            ssize_t
              image_row;

            image_row=(ssize_t) (strip_index*rows_per_strip+row_index);
            if (image_row >= (ssize_t) image->rows)
              break;
            q=QueueAuthenticPixels(image,0,image_row,image->columns,1,exception);
            if (q == (Quantum *) NULL)
              break;
            (void) ImportQuantumPixels(image,quantum_info,quantum_type,
              pixels+row_index*TIFFScanlineSize(tiff),q,exception);
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,LoadImageTag,image_row,
                  image->rows);
                if (status == MagickFalse)
                  break;
              }
          }
          if (status == MagickFalse)
            break;
        }
        break;
      }
      case ReadTileMethod:
      {
        uint32
          tile_width,
          tile_height,
          tile_index,
          num_tiles;

        TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&tile_width);
        TIFFGetField(tiff,TIFFTAG_TILELENGTH,&tile_height);
        num_tiles=TIFFNumberOfTiles(tiff);
        for (tile_index=0; tile_index < num_tiles; tile_index++)
        {
          tmsize_t
            bytes_read;

          bytes_read=TIFFReadEncodedTile(tiff,tile_index,pixels,TIFFTileSize(tiff));
          if (bytes_read == -1)
            break;
          for (row_index=0; row_index < (ssize_t) tile_height; row_index++)
          {
            uint32
              x,
              y;

            TIFFComputeTile(tiff,0,(uint32) (tile_index*tile_height+row_index),0,0);
            TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&tile_width);
            TIFFGetField(tiff,TIFFTAG_TILELENGTH,&tile_height);
            x=(tile_index % (width/tile_width))*tile_width;
            y=(tile_index/(width/tile_width))*tile_height+row_index;
            if (y >= height)
              break;
            if (x < width)
            {
              Quantum
                *q;

              q=QueueAuthenticPixels(image,x,y,MagickMin(tile_width,width-x),1,
                exception);
              if (q == (Quantum *) NULL)
                break;
              (void) ImportQuantumPixels(image,quantum_info,quantum_type,
                pixels+row_index*TIFFTileRowSize(tiff),q,exception);
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
              if (image->previous == (Image *) NULL)
                {
                  status=SetImageProgress(image,LoadImageTag,y,image->rows);
                  if (status == MagickFalse)
                    break;
                }
            }
          }
          if (status == MagickFalse)
            break;
        }
        break;
      }