/*
          Read strip-based TIFF images.
        */
        for (row_index = 0; row_index < (ssize_t) image->rows; row_index += rows_per_strip)
        {
          size_t rows_to_read = MagickMin(rows_per_strip, image->rows - row_index);
          if (TIFFReadEncodedStrip(tiff, row_index / rows_per_strip, pixels, rows_to_read * TIFFScanlineSize(tiff)) < 0)
            break;

          register Quantum *magick_restrict q = QueueAuthenticPixels(image, 0, row_index, image->columns, rows_to_read, exception);
          if (q == (Quantum *) NULL)
            break;

          for (y = 0; y < (ssize_t) rows_to_read; y++)
          {
            for (size_t x = 0; x < image->columns; x++)
            {
              SetPixelRed(image, ScaleCharToQuantum(TIFFGetR(pixels[y * image->columns + x])), q);
              SetPixelGreen(image, ScaleCharToQuantum(TIFFGetG(pixels[y * image->columns + x])), q);
              SetPixelBlue(image, ScaleCharToQuantum(TIFFGetB(pixels[y * image->columns + x])), q);
              if (image->alpha_trait != UndefinedPixelTrait)
                SetPixelAlpha(image, ScaleCharToQuantum(TIFFGetA(pixels[y * image->columns + x])), q);
              q += GetPixelChannels(image);
            }
            if (SyncAuthenticPixels(image, exception) == MagickFalse)
              break;
            if (image->previous == (Image *) NULL)
            {
              status = SetImageProgress(image, LoadImageTag, (MagickOffsetType)(row_index + y), image->rows);
              if (status == MagickFalse)
                break;
            }
          }
        }