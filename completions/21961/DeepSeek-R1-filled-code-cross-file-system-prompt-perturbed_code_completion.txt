case ReadStripMethod:
      {
        uint32
          rows_per_strip,
          strip;

        tmsize_t
          strip_size;

        (void) TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip);
        for (strip=0; strip < TIFFNumberOfStrips(tiff); strip++)
        {
          strip_size=TIFFReadEncodedStrip(tiff,strip,pixels,(tmsize_t) -1);
          if (strip_size == -1)
            ThrowTIFFException(CorruptImageError,"UnableToReadStripData");
          for (row_index=0; row_index < (ssize_t) rows_per_strip; row_index++)
          {
            Quantum
              *q;

            ssize_t
              y;

            y=(ssize_t) (strip*rows_per_strip+row_index);
            if (y >= (ssize_t) image->rows)
              break;
            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
            if (q == (Quantum *) NULL)
              break;
            (void) ImportQuantumPixels(image,quantum_info,quantum_type,pixels+
              row_index*TIFFScanlineSize(tiff),q,exception);
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,LoadImageTag,y,image->rows);
                if (status == MagickFalse)
                  break;
              }
          }
        }
        break;
      }
      case ReadTileMethod:
      {
        uint32
          tile_width,
          tile_height,
          x,
          y;

        tmsize_t
          tile_size;

        TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&tile_width);
        TIFFGetField(tiff,TIFFTAG_TILELENGTH,&tile_height);
        tile_size=TIFFTileSize(tiff);
        if (tile_size > (tmsize_t) (number_pixels*sizeof(uint32)))
          ThrowTIFFException(CorruptImageError,"InsufficientImageDataInFile");
        for (y=0; y < height; y += tile_height)
        {
          for (x=0; x < width; x += tile_width)
          {
            tmsize_t
              bytes_read;

            bytes_read=TIFFReadTile(tiff,pixels,x,y,0,0);
            if (bytes_read == -1)
              ThrowTIFFException(CorruptImageError,"UnableToReadTileData");
            for (row_index=0; row_index < (ssize_t) tile_height; row_index++)
            {
              ssize_t
                current_y;

              Quantum
                *q;

              current_y=y+row_index;
              if (current_y >= (ssize_t) image->rows)
                break;
              q=QueueAuthenticPixels(image,x,current_y,MagickMin(tile_width,
                width-x),1,exception);
              if (q == (Quantum *) NULL)
                break;
              (void) ImportQuantumPixels(image,quantum_info,quantum_type,pixels+
                row_index*TIFFTileRowSize(tiff),q,exception);
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
              if (image->previous == (Image *) NULL)
                {
                  status=SetImageProgress(image,LoadImageTag,current_y,
                    image->rows);
                  if (status == MagickFalse)
                    break;
                }
            }
          }
        }
        break;
      }