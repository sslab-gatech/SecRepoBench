case ReadGenericMethod:
case ReadStripMethod:
case ReadTileMethod:
{
  MemoryInfo
    *strip_info = (MemoryInfo * ) NULL;

  register uint32
    *p;

  uint32
    *pixels;

  /*
    Convert generic TIFF image.
  */
  if (HeapOverflowSanityCheck(image->rows,sizeof(*pixels))!= MagickFalse)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  number_pixels=(MagickSizeType) image->columns*image->rows;
  strip_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));
  if (strip_info == (MemoryInfo *) NULL)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  pixels=(uint32 *) GetVirtualMemoryBlob(strip_info);
  (void) TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32)
    image->rows,(uint32 *) pixels,0);
  p=pixels+number_pixels-1;
  for (row_index=0; row_index < (ssize_t) image->rows; row_index++)
  {
    register ssize_t
      x;

    register Quantum
      *magick_restrict q;

    q=QueueAuthenticPixels(image,0,row_index,image->columns,1,exception);
    if (q == (Quantum *) NULL)
      break;
    q+=GetPixelChannels(image)*(image->columns-1);
    for (x=0; x < (ssize_t) image->columns; x++)
    {
      SetPixelRed(image,ScaleCharToQuantum((unsigned char)
        TIFFGetR(*p)),q);
      SetPixelGreen(image,ScaleCharToQuantum((unsigned char)
        TIFFGetG(*p)),q);
      SetPixelBlue(image,ScaleCharToQuantum((unsigned char)
        TIFFGetB(*p)),q);
      if (image->alpha_trait!= UndefinedPixelTrait)
        SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)
          TIFFGetA(*p)),q);
      p--;
      q-=GetPixelChannels(image);
    }
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) row_index,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  strip_info=RelinquishVirtualMemory(strip_info);
  break;
}