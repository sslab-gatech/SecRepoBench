case ReadStripMethod:
      {
        size_t
          number_pixels;

        /*
          Convert strip TIFF image.
        */
        if (HeapOverflowSanityCheck(rows_per_strip,sizeof(*pixels)) != MagickFalse)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        number_pixels=rows_per_strip*image->columns;
        for (row_index=0; row_index < (ssize_t) image->rows; row_index+=rows_per_strip)
        {
          register ssize_t
            y;

          size_t
            rows=MagickMin((ssize_t) rows_per_strip,(ssize_t) image->rows-row_index);

          tiff_status=TIFFReadEncodedStrip(tiff,TIFFComputeStrip(tiff,(tstrip_t)
            row_index,0),pixels,(tsize_t) number_pixels);
          if (tiff_status == -1)
            break;
          for (y=0; y < (ssize_t) rows; y++)
          {
            register Quantum
              *magick_restrict q;

            register ssize_t
              x;

            q=QueueAuthenticPixels(image,0,row_index+y,image->columns,1,
              exception);
            if (q == (Quantum *) NULL)
              break;
            if (image->storage_class == PseudoClass)
              {
                register unsigned char
                  *magick_restrict p;

                p=pixels+(y*image->columns);
                for (x=0; x < (ssize_t) image->columns; x++)
                  SetPixelIndex(image,*p++,q);
              }
            else
              if (IsGrayImage(image,exception) != MagickFalse)
                {
                  if (image->alpha_trait == UndefinedPixelTrait)
                    {
                      register unsigned char
                        *magick_restrict p;

                      p=pixels+(y*image->columns);
                      for (x=0; x < (ssize_t) image->columns; x++)
                        SetPixelGray(image,ScaleCharToQuantum(*p++),q);
                    }
                  else
                    {
                      register unsigned short
                        *magick_restrict p;

                      p=(unsigned short *) (pixels+((y*image->columns)*
                        sizeof(unsigned short)));
                      for (x=0; x < (ssize_t) image->columns; x++)
                      {
                        SetPixelGray(image,ScaleShortToQuantum(*p++),q);
                        SetPixelAlpha(image,ScaleShortToQuantum(*p++),q);
                      }
                    }
                }
              else
                if (image->alpha_trait == UndefinedPixelTrait)
                  (void) ImportQuantumPixels(image,(CacheView *) NULL,
                    quantum_info,quantum_type,pixels+(y*image->columns*
                    (image->depth > 8 ? 2 : 1)),exception);
                else
                  (void) ImportQuantumPixels(image,(CacheView *) NULL,
                    quantum_info,quantum_type,pixels+((y*image->columns)*
                    ((bits_per_sample > 8) ||
                    (quantum_type == CMYKAQuantum) ? 2 : 1)),exception);
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
          }
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                row_index,image->rows);
              if (status == MagickFalse)
                break;
            }
          if (y < (ssize_t) rows)
            break;
        }
        break;
      }
      case ReadTileMethod:
      {
        uint32
          *tile_pixels,
          columns,
          rows;

        /*
          Convert tile TIFF image.
        */
        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||
            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))
          ThrowTIFFException(CoderError,"ImageTypeNotSupported");

        if (HeapOverflowSanityCheck(columns,rows,sizeof(*tile_pixels)) != MagickFalse)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");

        tile_pixels=(uint32 *) AcquireQuantumMemory(columns*rows,sizeof(uint32));
        if (tile_pixels == (uint32 *) NULL)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        for (row_index=0; row_index < (ssize_t) image->rows; row_index+=rows)
        {
          register ssize_t
            y;

          size_t
            number_pixels;

          ssize_t
            rows_remaining;

          rows_remaining=(ssize_t) image->rows-row_index;
          number_pixels=MagickMin(rows, (uint32) rows_remaining)*columns;
          for (i=0; i < (ssize_t) image->columns; i+=columns)
          {
            size_t
              tile_columns;

            tile_columns=MagickMin(columns,(uint32) image->columns-i);
            tiff_status=TIFFReadTile(tiff,(tdata_t) tile_pixels,(ttile_t) i,
              (ttile_t) row_index,0,0);
            if (tiff_status == -1)
              break;
            for (y=0; y < (ssize_t) number_pixels; y+=columns)
            {
              register Quantum
                *magick_restrict q;

              register ssize_t
                x;

              q=QueueAuthenticPixels(image,i,row_index+(y/tile_columns),
                tile_columns,1,exception);
              if (q == (Quantum *) NULL)
                break;
              if (image->alpha_trait == UndefinedPixelTrait)
                (void) ImportQuantumPixels(image,(CacheView *) NULL,
                  quantum_info,quantum_type,tile_pixels+y,exception);
              else
                (void) ImportQuantumPixels(image,(CacheView *) NULL,
                  quantum_info,quantum_type,tile_pixels+(y*
                  ((bits_per_sample > 8) || (quantum_type == CMYKAQuantum) ?
                  2 : 1)),exception);
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
            }
          }
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                row_index,image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        tile_pixels=(uint32 *) RelinquishMagickMemory(tile_pixels);
        break;
      }