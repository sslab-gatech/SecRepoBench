case ReadStripMethod:
{
  /*
    Convert strip TIFF image.
  */
  size_t
    strip_size;

  strip_size=(size_t) TIFFStripSize(tiff);
  if (strip_size <= 0)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  if ((1.0*strip_size) > (2.53*GetBlobSize(image)))
    ThrowTIFFException(CorruptImageError,"InsufficientImageDataInFile");
  number_pixels=MagickMax(TIFFStripSize(tiff),MagickMax((ssize_t)
    image->columns*samples_per_pixel*pow(2.0,ceil(log(bits_per_sample)/
    log(2.0))),image->columns*rows_per_strip));
  pixel_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));
  if (pixel_info == (MemoryInfo *) NULL)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
  (void) memset(pixels,0,number_pixels*sizeof(uint32));
  for (row_index=0; row_index < (ssize_t) image->rows; row_index+=rows_per_strip)
  {
    register ssize_t
      y;

    register Quantum
      *magick_restrict q;

    tiff_status=TIFFReadEncodedStrip(tiff,row_index,(char *) pixels,strip_size);
    if (tiff_status == -1)
      break;
    q=QueueAuthenticPixels(image,0,row_index,image->columns,rows_per_strip,
      exception);
    if (q == (Quantum *) NULL)
      break;
    for (y=0; y < (ssize_t) rows_per_strip; y++)
    {
      register ssize_t
        x;

      q+=GetPixelChannels(image)*(image->columns-1);
      for (x=0; x < (ssize_t) image->columns; x++)
      {
        SetPixelRed(image,ScaleCharToQuantum((unsigned char) TIFFGetR(*pixels)),
          q);
        SetPixelGreen(image,ScaleCharToQuantum((unsigned char) TIFFGetG(*pixels)),
          q);
        SetPixelBlue(image,ScaleCharToQuantum((unsigned char) TIFFGetB(*pixels)),
          q);
        if (image->alpha_trait!= UndefinedPixelTrait)
          SetPixelAlpha(image,ScaleCharToQuantum((unsigned char) TIFFGetA(*pixels)),
            q);
        pixels++;
        q-=GetPixelChannels(image);
      }
      if (SyncAuthenticPixels(image,exception) == MagickFalse)
        break;
      if (image->previous == (Image *) NULL)
        {
          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) row_index,
            image->rows);
          if (status == MagickFalse)
            break;
        }
    }
  }
  break;
}
case ReadTileMethod:
{
  /*
    Convert tile TIFF image.
  */
  uint32
    tile_width,
    tile_length;

  TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&tile_width);
  TIFFGetField(tiff,TIFFTAG_TILELENGTH,&tile_length);
  if ((tile_width == 0) || (tile_length == 0))
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  if ((1.0*tile_width*tile_length*samples_per_pixel) > (2.53*GetBlobSize(image)))
    ThrowTIFFException(CorruptImageError,"InsufficientImageDataInFile");
  number_pixels=MagickMax(TIFFTileSize(tiff),MagickMax((ssize_t)
    image->columns*samples_per_pixel*pow(2.0,ceil(log(bits_per_sample)/
    log(2.0))),image->columns*rows_per_strip));
  pixel_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));
  if (pixel_info == (MemoryInfo *) NULL)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
  (void) memset(pixels,0,number_pixels*sizeof(uint32));
  for (row_index=0; row_index < (ssize_t) image->rows; row_index+=tile_length)
  {
    register ssize_t
      x,
      y;

    register Quantum
      *magick_restrict q;

    for (x=0; x < (ssize_t) image->columns; x+=tile_width)
    {
      tiff_status=TIFFReadTile(tiff,x,row_index,(char *) pixels,tile_width,
        tile_length);
      if (tiff_status == -1)
        break;
      q=QueueAuthenticPixels(image,x,row_index,tile_width,tile_length,exception);
      if (q == (Quantum *) NULL)
        break;
      for (y=0; y < (ssize_t) tile_length; y++)
      {
        register ssize_t
          i;

        q+=GetPixelChannels(image)*(tile_width-1);
        for (i=0; i < (ssize_t) tile_width; i++)
        {
          SetPixelRed(image,ScaleCharToQuantum((unsigned char) TIFFGetR(*pixels)),
            q);
          SetPixelGreen(image,ScaleCharToQuantum((unsigned char) TIFFGetG(*pixels)),
            q);
          SetPixelBlue(image,ScaleCharToQuantum((unsigned char) TIFFGetB(*pixels)),
            q);
          if (image->alpha_trait!= UndefinedPixelTrait)
            SetPixelAlpha(image,ScaleCharToQuantum((unsigned char) TIFFGetA(*pixels)),
              q);
          pixels++;
          q-=GetPixelChannels(image);
        }
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
        if (image->previous == (Image *) NULL)
          {
            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) row_index,
              image->rows);
            if (status == MagickFalse)
              break;
          }
      }
    }
  }
  break;
}