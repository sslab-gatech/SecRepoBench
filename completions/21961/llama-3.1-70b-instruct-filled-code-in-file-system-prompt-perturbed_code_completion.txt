case ReadStripMethod:
{
  /*
    Convert strip-based TIFF image.
  */
  uint32
    *strip_offsets,
    *strip_byte_counts;

  ssize_t
    i,
    j;

  strip_offsets=(uint32 *) NULL;
  strip_byte_counts=(uint32 *) NULL;
  if (TIFFGetField(tiff,TIFFTAG_STRIPOFFSETS,&strip_offsets)!= 1)
    ThrowTIFFException(CorruptImageError,"InsufficientImageDataInFile");
  if (TIFFGetField(tiff,TIFFTAG_STRIPBYTECOUNTS,&strip_byte_counts)!= 1)
    ThrowTIFFException(CorruptImageError,"InsufficientImageDataInFile");
  for (i=0; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)
  {
    register Quantum
      *magick_restrict q;

    register ssize_t
      x;

    if (strip_byte_counts[i] == 0)
      continue;
    q=QueueAuthenticPixels(image,0,(ssize_t) (i*rows_per_strip),image->columns,
      1,exception);
    if (q == (Quantum *) NULL)
      break;
    if (TIFFReadRawStrip(tiff,(uint32) i,pixels,strip_byte_counts[i]) == -1)
      break;
    for (j=0; j < (ssize_t) rows_per_strip; j++)
    {
      if ((i*rows_per_strip+j) >= (ssize_t) image->rows)
        break;
      for (x=0; x < (ssize_t) image->columns; x++)
      {
        SetPixelRed(image,ScaleCharToQuantum(pixels[x*3]),q);
        SetPixelGreen(image,ScaleCharToQuantum(pixels[x*3+1]),q);
        SetPixelBlue(image,ScaleCharToQuantum(pixels[x*3+2]),q);
        q+=GetPixelChannels(image);
      }
      pixels+=image->columns*3;
    }
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) (i*
          rows_per_strip),image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  strip_offsets=(uint32 *) RelinquishMagickMemory(strip_offsets);
  strip_byte_counts=(uint32 *) RelinquishMagickMemory(strip_byte_counts);
  break;
}
case ReadTileMethod:
{
  /*
    Convert tile-based TIFF image.
  */
  uint32
    tile_columns,
    tile_rows;

  ssize_t
    i,
    j,
    k;

  tile_columns=TIFFTileWidth(tiff);
  tile_rows=TIFFTileLength(tiff);
  for (i=0; i < (ssize_t) (image->rows/tile_rows); i++)
  {
    for (j=0; j < (ssize_t) (image->columns/tile_columns); j++)
    {
      register Quantum
        *magick_restrict q;

      register ssize_t
        x;

      q=QueueAuthenticPixels(image,(ssize_t) (j*tile_columns),(ssize_t) (i*
        tile_rows),tile_columns,tile_rows,exception);
      if (q == (Quantum *) NULL)
        break;
      if (TIFFReadTile(tiff,(uint32) (j*tile_columns),(uint32) (i*tile_rows),
        pixels,0) == -1)
        break;
      for (k=0; k < (ssize_t) tile_rows; k++)
      {
        for (x=0; x < (ssize_t) tile_columns; x++)
        {
          SetPixelRed(image,ScaleCharToQuantum(pixels[x*3]),q);
          SetPixelGreen(image,ScaleCharToQuantum(pixels[x*3+1]),q);
          SetPixelBlue(image,ScaleCharToQuantum(pixels[x*3+2]),q);
          q+=GetPixelChannels(image);
        }
        pixels+=tile_columns*3;
      }
      if (SyncAuthenticPixels(image,exception) == MagickFalse)
        break;
      if (image->previous == (Image *) NULL)
        {
          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) (i*
            tile_rows),image->rows);
          if (status == MagickFalse)
            break;
        }
    }
  }
  break;
}