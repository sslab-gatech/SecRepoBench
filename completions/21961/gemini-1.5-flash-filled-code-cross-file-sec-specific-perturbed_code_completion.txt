case ReadStripMethod:
      {
        size_t
          scanline_size;

        /*
          Convert strip-based TIFF image.
        */
        scanline_size=(size_t) TIFFScanlineSize(tiff);
        if (HeapOverflowSanityCheck(scanline_size,sizeof(*pixels)) != MagickFalse)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        pixel_info=AcquireVirtualMemory(scanline_size,sizeof(*pixels));
        if (pixel_info == (MemoryInfo *) NULL)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
        for (row_index=0; row_index < (ssize_t) image->rows; row_index++)
        {
          register Quantum
            *magick_restrict q;

          ssize_t
            count;

          tiff_status=TIFFReadScanline(tiff,pixels,row_index);
          if (tiff_status == -1)
            break;
          q=QueueAuthenticPixels(image,0,row_index,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          count=ImportQuantumPixels(image,quantum_info,quantum_type,pixels,q,
            exception);
          if (count != (ssize_t) image->columns)
            break;
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) row_index,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case ReadTileMethod:
      {
        uint32
          tile_height,
          tile_width;

        /*
          Convert tile-based TIFF image.
        */
        if (TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&tile_width) != 1)
          ThrowTIFFException(CoderError,"UnableToReadTileWidth");
        if (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&tile_height) != 1)
          ThrowTIFFException(CoderError,"UnableToReadTileHeight");
        scanline_size=(size_t) TIFFComputeTileSize(tiff);
        if (HeapOverflowSanityCheck(scanline_size,sizeof(*pixels)) != MagickFalse)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        pixel_info=AcquireVirtualMemory(scanline_size,sizeof(*pixels));
        if (pixel_info == (MemoryInfo *) NULL)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
        for (row_index=0; row_index < (ssize_t) image->rows; row_index++)
        {
          register Quantum
            *magick_restrict q;

          register ssize_t
            x;

          size_t
            tile_row;

          ssize_t
            count;

          uint32
            tile_column,
            tile_row_offset;

          tile_row=row_index/tile_height;
          tile_row_offset=row_index%tile_height;
          tile_column=0;
          q=QueueAuthenticPixels(image,0,row_index,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            uint32
              tile_column_offset;

            tile_column_offset=x%tile_width;
            if (tile_column_offset == 0)
              {
                toff_t
                  offset;

                offset=TIFFComputeTile(tiff,tile_column,tile_row,0,0);
                if (TIFFReadEncodedTile(tiff,(tsize_t) offset,pixels,
                    (tsize_t) scanline_size) == -1)
                  break;
                tile_column++;
              }
            count=ImportQuantumPixels(image,quantum_info,quantum_type,
              pixels+tile_row_offset*TIFFScanlineSize(tiff)+
              tile_column_offset*samples_per_pixel*((bits_per_sample+7) >> 3),
              q,exception);
            if (count != (ssize_t) image->columns)
              break;
            q+=GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) row_index,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }