case ReadStripMethod:
{
  for (y = 0; y < (ssize_t) image->rows; y += rows_per_strip)
  {
    size_t
      length;

    ssize_t
      count;

    rows = (size_t) MagickMin(rows_per_strip, image->rows-y);
    length = TIFFStripSize(tiff);
    count = TIFFReadEncodedStrip(tiff, TIFFComputeStrip(tiff, y, 0),
      pixels, length);
    if (count == -1)
      break;
    for (i = 0; i < (ssize_t) rows; i++)
    {
      register Quantum
        *q;

      q = QueueAuthenticPixels(image, 0, y + i, image->columns, 1, exception);
      if (q == (Quantum *) NULL)
        break;
      length = ImportQuantumPixels(image, (CacheView *) NULL, quantum_info,
        quantum_type, pixels + (i*TIFFScanlineSize(tiff)), exception);
      if (SyncAuthenticPixels(image, exception) == MagickFalse)
        break;
    }
    if (image->previous == (Image *) NULL)
      {
        status = SetImageProgress(image, LoadImageTag, y, image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  break;
}
case ReadTileMethod:
{
  uint32
    tile_width,
    tile_height;

  if ((TIFFGetField(tiff, TIFFTAG_TILEWIDTH, &tile_width) != 1) ||
      (TIFFGetField(tiff, TIFFTAG_TILELENGTH, &tile_height) != 1))
    ThrowReaderException(CoderError, "ImageIsNotTiled");

  for (y = 0; y < (ssize_t) image->rows; y += tile_height)
  {
    for (x = 0; x < (ssize_t) image->columns; x += tile_width)
    {
      size_t
        length;

      ssize_t
        count;

      count = TIFFReadTile(tiff, pixels, (uint32) x, (uint32) y, 0, 0);
      if (count == -1)
        break;

      for (i = 0; i < (ssize_t) tile_height; i++)
      {
        register Quantum
          *q;

        if ((y + i) >= (ssize_t) image->rows)
          break;
        q = QueueAuthenticPixels(image, x, y + i,
          MagickMin(tile_width, image->columns - x), 1, exception);
        if (q == (Quantum *) NULL)
          break;
        length = ImportQuantumPixels(image, (CacheView *) NULL, quantum_info,
          quantum_type, pixels + (i*TIFFTileRowSize(tiff)), exception);
        if (SyncAuthenticPixels(image, exception) == MagickFalse)
          break;
      }
    }
    if (image->previous == (Image *) NULL)
      {
        status = SetImageProgress(image, LoadImageTag, y, image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  break;
}