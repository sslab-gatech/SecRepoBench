case ReadStripMethod:
{
  /*
    Read TIFF image as strips.
  */
  number_pixels=(MagickSizeType) image->columns*rows_per_strip;
  if (HeapOverflowSanityCheck(image->columns,rows_per_strip) != MagickFalse)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  for (y=0; y < (ssize_t) image->rows; y+=rows_per_strip)
  {
    ssize_t
      count;

    size_t
      length;

    tsize_t
      strip_size;

    strip_size=TIFFStripSize(tiff);
    if (strip_size <= 0)
      ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
    length=(size_t) strip_size;
    count=TIFFReadEncodedStrip(tiff,(tstrip_t) TIFFComputeStrip(tiff,y,0),
      pixels,length);
    if (count <= 0)
      break;
    if ((y+rows_per_strip) > image->rows)
      rows_per_strip=image->rows-y;
    for (row_index=0; row_index < (ssize_t) rows_per_strip; row_index++)
    {
      register Quantum
        *magick_restrict q;

      q=QueueAuthenticPixels(image,0,y+row_index,image->columns,1,exception);
      if (q == (Quantum *) NULL)
        break;
      (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
        quantum_type,pixels+row_index*TIFFScanlineSize(tiff),exception);
      if (SyncAuthenticPixels(image,exception) == MagickFalse)
        break;
    }
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  break;
}
case ReadTileMethod:
{
  /*
    Read TIFF image as tiles.
  */
  uint32
    tile_height,
    tile_width;

  if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&tile_width) != 1) ||
      (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&tile_height) != 1))
    ThrowTIFFException(CoderError,"ImageIsNotTiled");
  number_pixels=(MagickSizeType) tile_width*tile_height;
  if (HeapOverflowSanityCheck(tile_width,tile_height) != MagickFalse)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  for (y=0; y < (ssize_t) image->rows; y+=tile_height)
  {
    for (x=0; x < (ssize_t) image->columns; x+=tile_width)
    {
      ssize_t
        count;

      size_t
        length;

      tsize_t
        tile_size;

      tile_size=TIFFTileSize(tiff);
      if (tile_size <= 0)
        ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
      length=(size_t) tile_size;
      count=TIFFReadTile(tiff,pixels,(uint32) x,(uint32) y,0,0);
      if (count <= 0)
        break;
      for (row_index=0; row_index < (ssize_t) tile_height; row_index++)
      {
        register Quantum
          *magick_restrict q;

        if ((y+row_index) >= (ssize_t) image->rows)
          break;
        q=QueueAuthenticPixels(image,x,y+row_index,
          MagickMin(tile_width,image->columns-x),1,exception);
        if (q == (Quantum *) NULL)
          break;
        (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
          quantum_type,pixels+row_index*TIFFTileRowSize(tiff),exception);
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
      }
    }
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  break;
}