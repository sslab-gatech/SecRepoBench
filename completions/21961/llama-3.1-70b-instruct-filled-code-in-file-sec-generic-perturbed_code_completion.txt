case ReadStripMethod:
{
  /*
    Convert strip-based TIFF image.
  */
  uint32
    *strip_offsets,
    *strip_byte_counts;

  ssize_t
    i,
    j;

  strip_offsets=(uint32 *) NULL;
  strip_byte_counts=(uint32 *) NULL;
  if (TIFFGetField(tiff,TIFFTAG_STRIPOFFSETS,&strip_offsets)!= 1)
    ThrowTIFFException(CorruptImageError,"UnableToReadTIFFImage");
  if (TIFFGetField(tiff,TIFFTAG_STRIPBYTECOUNTS,&strip_byte_counts)!= 1)
    ThrowTIFFException(CorruptImageError,"UnableToReadTIFFImage");
  for (i=0; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)
  {
    register Quantum
      *magick_restrict q;

    register ssize_t
      x;

    if (strip_byte_counts[i] == 0)
      continue;
    q=QueueAuthenticPixels(image,0,(ssize_t) (i*rows_per_strip),image->columns,
      1,exception);
    if (q == (Quantum *) NULL)
      break;
    if (TIFFReadRawStrip(tiff,(uint32) i,pixels,strip_byte_counts[i]) == -1)
      break;
    for (j=0; j < (ssize_t) rows_per_strip; j++)
    {
      if ((i*rows_per_strip+j) >= (ssize_t) image->rows)
        break;
      for (x=0; x < (ssize_t) image->columns; x++)
      {
        SetPixelRed(image,ScaleCharToQuantum(pixels[x*3]),q);
        SetPixelGreen(image,ScaleCharToQuantum(pixels[x*3+1]),q);
        SetPixelBlue(image,ScaleCharToQuantum(pixels[x*3+2]),q);
        q+=GetPixelChannels(image);
      }
      pixels+=image->columns*3;
    }
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) (i*
          rows_per_strip),image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  strip_offsets=(uint32 *) RelinquishMagickMemory(strip_offsets);
  strip_byte_counts=(uint32 *) RelinquishMagickMemory(strip_byte_counts);
  break;
}
case ReadTileMethod:
{
  /*
    Convert tile-based TIFF image.
  */
  uint32
    tile_columns,
    tile_rows;

  ssize_t
    i,
    j,
    k;

  tile_columns=TIFFTileSize(tiff)/(ssize_t) TIFFScanlineSize(tiff);
  tile_rows=TIFFTileSize(tiff)/(ssize_t) (tile_columns*TIFFScanlineSize(tiff));
  for (i=0; i < (ssize_t) TIFFNumberOfTiles(tiff); i++)
  {
    register Quantum
      *magick_restrict q;

    register ssize_t
      x;

    if (TIFFReadTile(tiff,tiff_info->pixels,(uint32) (i%tile_columns),
      (uint32) (i/tile_columns),0,0) == -1)
      break;
    for (j=0; j < (ssize_t) tile_rows; j++)
    {
      if ((i/tile_columns)*tile_rows+j >= (ssize_t) image->rows)
        break;
      q=QueueAuthenticPixels(image,0,(ssize_t) ((i/tile_columns)*tile_rows+j),
        image->columns,1,exception);
      if (q == (Quantum *) NULL)
        break;
      for (x=0; x < (ssize_t) image->columns; x++)
      {
        SetPixelRed(image,ScaleCharToQuantum(tiff_info->pixels[x*3]),q);
        SetPixelGreen(image,ScaleCharToQuantum(tiff_info->pixels[x*3+1]),q);
        SetPixelBlue(image,ScaleCharToQuantum(tiff_info->pixels[x*3+2]),q);
        q+=GetPixelChannels(image);
      }
      tiff_info->pixels+=image->columns*3;
    }
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) (i/
          tile_columns),image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  break;
}