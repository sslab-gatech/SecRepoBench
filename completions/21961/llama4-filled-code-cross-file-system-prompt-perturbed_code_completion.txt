case ReadStripMethod:
      {
        /*
          Convert strip-based TIFF image.
        */
        pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
        for (row_index=0; row_index < (ssize_t) image->rows; row_index+=
            (ssize_t) rows_per_strip)
        {
          register ssize_t
            y;

          register Quantum
            *magick_restrict q;

          tiff_status=TIFFReadPixels(tiff,0,row_index,(char *) pixels);
          if (tiff_status == -1)
            break;
          q=QueueAuthenticPixels(image,0,row_index,image->columns,
            (size_t) MagickMin((ssize_t) rows_per_strip,image->rows-row_index),
            exception);
          if (q == (Quantum *) NULL)
            break;
          for (y=0; y < (ssize_t) MagickMin((size_t) rows_per_strip,image->rows-
              row_index); y++)
          {
            register ssize_t
              x;

            p=pixels+(y*TIFFScanlineSize(tiff));
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              if (image->storage_class == PseudoClass)
                SetPixelIndex(image,ScaleCharToQuantum(*p),q);
              else
                {
                  switch (photometric)
                  {
                    case PHOTOMETRIC_RGB:
                    {
                      SetPixelRed(image,ScaleCharToQuantum(*p),q);
                      SetPixelGreen(image,ScaleCharToQuantum(*(p+1)),q);
                      SetPixelBlue(image,ScaleCharToQuantum(*(p+2)),q);
                      if (image->alpha_trait != UndefinedPixelTrait)
                        SetPixelAlpha(image,ScaleCharToQuantum(*(p+3)),q);
                      break;
                    }
                    case PHOTOMETRIC_CIELAB:
                    case PHOTOMETRIC_LOGLUV:
                    case PHOTOMETRIC_YCBCR:
                    {
                      SetPixelRed(image,ScaleCharToQuantum(*p),q);
                      SetPixelGreen(image,ScaleCharToQuantum(*(p+1)),q);
                      SetPixelBlue(image,ScaleCharToQuantum(*(p+2)),q);
                      break;
                    }
                    case PHOTOMETRIC_SEPARATED:
                    {
                      SetPixelCyan(image,ScaleCharToQuantum(*p),q);
                      SetPixelMagenta(image,ScaleCharToQuantum(*(p+1)),q);
                      SetPixelYellow(image,ScaleCharToQuantum(*(p+2)),q);
                      SetPixelBlack(image,ScaleCharToQuantum(*(p+3)),q);
                      break;
                    }
                    default:
                      break;
                  }
                }
              p+=samples_per_pixel;
              q+=GetPixelChannels(image);
            }
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
            if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) row_index,
                image->rows);
              if (status == MagickFalse)
                break;
            }
          }
        }
        break;
      }
      case ReadTileMethod:
      {
        /*
          Convert tile-based TIFF image.
        */
        uint32
          columns,
          rows,
          tile_columns,
          tile_rows;

        if (TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&tile_columns) != 1)
          tile_columns=image->columns;
        if (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&tile_rows) != 1)
          tile_rows=image->rows;
        pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
        columns=MagickMax((size_t) tile_columns,(size_t) image->columns);
        rows=MagickMax((size_t) tile_rows,(size_t) image->rows);
        number_pixels=MagickMax(columns*rows,tile_columns*tile_rows);
        generic_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));
        if (generic_info == (MemoryInfo *) NULL)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        pixels=(uint32 *) GetVirtualMemoryBlob(generic_info);
        for (row_index=0; row_index < (ssize_t) image->rows; row_index+=
            (ssize_t) tile_rows)
        {
          register ssize_t
            y;

          register Quantum
            *magick_restrict q;

          tiff_status=TIFFReadTile(tiff,pixels,row_index,0,0);
          if (tiff_status == -1)
            break;
          q=QueueAuthenticPixels(image,0,row_index,image->columns,
            (size_t) MagickMin((size_t) tile_rows,image->rows-row_index),
            exception);
          if (q == (Quantum *) NULL)
            break;
          for (y=0; y < (ssize_t) MagickMin((size_t) tile_rows,image->rows-
              row_index); y++)
          {
            register ssize_t
              x;

            p=pixels+y*tile_columns;
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              if (image->storage_class == PseudoClass)
                SetPixelIndex(image,ScaleCharToQuantum(*p),q);
              else
                {
                  switch (photometric)
                  {
                    case PHOTOMETRIC_RGB:
                    {
                      SetPixelRed(image,ScaleCharToQuantum(*p),q);
                      SetPixelGreen(image,ScaleCharToQuantum(*(p+1)),q);
                      SetPixelBlue(image,ScaleCharToQuantum(*(p+2)),q);
                      if (image->alpha_trait != UndefinedPixelTrait)
                        SetPixelAlpha(image,ScaleCharToQuantum(*(p+3)),q);
                      break;
                    }
                    case PHOTOMETRIC_CIELAB:
                    case PHOTOMETRIC_LOGLUV:
                    case PHOTOMETRIC_YCBCR:
                    {
                      SetPixelRed(image,ScaleCharToQuantum(*p),q);
                      SetPixelGreen(image,ScaleCharToQuantum(*(p+1)),q);
                      SetPixelBlue(image,ScaleCharToQuantum(*(p+2)),q);
                      break;
                    }
                    case PHOTOMETRIC_SEPARATED:
                    {
                      SetPixelCyan(image,ScaleCharToQuantum(*p),q);
                      SetPixelMagenta(image,ScaleCharToQuantum(*(p+1)),q);
                      SetPixelYellow(image,ScaleCharToQuantum(*(p+2)),q);
                      SetPixelBlack(image,ScaleCharToQuantum(*(p+3)),q);
                      break;
                    }
                    default:
                      break;
                  }
                }
              p+=samples_per_pixel;
              q+=GetPixelChannels(image);
            }
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
            if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) row_index,
                image->rows);
              if (status == MagickFalse)
                break;
            }
          }
        }
        generic_info=RelinquishVirtualMemory(generic_info);
        break;
      }