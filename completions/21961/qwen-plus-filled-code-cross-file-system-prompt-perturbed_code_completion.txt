case ReadStripMethod:
    {
        /*
          Convert strip-based TIFF image.
        */
        uint32
          *strip_pixels;

        MemoryInfo
          *strip_info;

        tsize_t
          strip_size;

        ssize_t
          number_strips,
          strip_index;

        /*
          Allocate memory for the strip size.
        */
        strip_size = TIFFStripSize(tiff);
        if (HeapOverflowSanityCheck((MagickSizeType) MagickMax(strip_size, 1), sizeof(uint32)) != MagickFalse)
          ThrowTIFFException(ResourceLimitError, "MemoryAllocationFailed");
        number_pixels = MagickMax(TIFFScanlineSize(tiff), MagickMax((ssize_t)image->columns * samples_per_pixel * ((bits_per_sample + 7) >> 3), image->columns * rows_per_strip));
        strip_info = AcquireVirtualMemory(number_pixels, sizeof(uint32));
        if (strip_info == (MemoryInfo *) NULL)
          ThrowTIFFException(ResourceLimitError, "MemoryAllocationFailed");

        strip_pixels = (uint32 *) GetVirtualMemoryBlob(strip_info);

        number_strips = TIFFNumberOfStrips(tiff);
        for (strip_index = 0; strip_index < number_strips; strip_index++)
        {
            tsize_t
              read_size;

            register Quantum
              *q;

            ssize_t
              y;

            /*
              Read each strip.
            */
            read_size = TIFFReadEncodedStrip(tiff, strip_index, strip_pixels, strip_size);
            if (read_size <= 0)
              break;

            y = TIFFComputeStrip(tiff, strip_index, rows_per_strip);
            for (; y < (ssize_t)(y + rows_per_strip) && y < (ssize_t)image->rows; y++)
            {
                q = QueueAuthenticPixels(image, 0, y, image->columns, 1, exception);
                if (q == (Quantum *)NULL)
                  break;

                ImportQuantumPixels(image, quantum_info, quantum_type, pixels + image->columns * (y - strip_index * rows_per_strip), exception);

                if (SyncAuthenticPixels(image, exception) == MagickFalse)
                  break;

                if (image->previous == (Image *)NULL)
                {
                    status = SetImageProgress(image, LoadImageTag, (MagickOffsetType)y, image->rows);
                    if (status == MagickFalse)
                      break;
                }
            }

            if (status == MagickFalse)
              break;
        }
        strip_info = RelinquishVirtualMemory(strip_info);
        break;
    }

    case ReadTileMethod:
    {
        /*
          Convert tile-based TIFF image.
        */
        uint32
          *tile_pixels;

        MemoryInfo
          *tile_info;

        tsize_t
          tile_size;

        uint32
          tile_width,
          tile_height;

        ssize_t
          x,
          y;

        /*
          Get tile dimensions and allocate memory.
        */
        if (TIFFGetField(tiff, TIFFTAG_TILEWIDTH, &tile_width) != 1 ||
            TIFFGetField(tiff, TIFFTAG_TILELENGTH, &tile_height) != 1)
          ThrowTIFFException(CorruptImageError, "ImproperImageHeader");

        tile_size = TIFFTileSize(tiff);
        if (HeapOverflowSanityCheck((MagickSizeType) MagickMax(tile_size, 1), sizeof(uint32)) != MagickFalse)
          ThrowTIFFException(ResourceLimitError, "MemoryAllocationFailed");

        number_pixels = MagickMax(TIFFTileRowSize(tiff), MagickMax((ssize_t) tile_width * samples_per_pixel * ((bits_per_sample + 7) >> 3), tile_width * tile_height));
        tile_info = AcquireVirtualMemory(number_pixels, sizeof(uint32));
        if (tile_info == (MemoryInfo *) NULL)
          ThrowTIFFException(ResourceLimitError, "MemoryAllocationFailed");

        tile_pixels = (uint32 *) GetVirtualMemoryBlob(tile_info);

        for (y = 0; y < (ssize_t)image->rows; y += (ssize_t)tile_height)
        {
            for (x = 0; x < (ssize_t)image->columns; x += (ssize_t)tile_width)
            {
                tsize_t
                  read_size;

                ssize_t
                  row_index,
                  column_index;

                /*
                  Read each tile.
                */
                read_size = TIFFReadEncodedTile(tiff, TIFFComputeTile(tiff, x, y, 0, 0), tile_pixels, tile_size);
                if (read_size <= 0)
                  break;

                for (row_index = 0; row_index < (ssize_t)tile_height && y + row_index < (ssize_t)image->rows; row_index++)
                {
                    register Quantum
                      *magick_restrict q;

                    q = QueueAuthenticPixels(image, x, y + row_index, tile_width, 1, exception);
                    if (q == (Quantum *)NULL)
                      break;

                    ImportQuantumPixels(image, quantum_info, quantum_type, tile_pixels + row_index * tile_width, exception);

                    if (SyncAuthenticPixels(image, exception) == MagickFalse)
                      break;

                    if (image->previous == (Image *)NULL)
                    {
                        status = SetImageProgress(image, LoadImageTag, (MagickOffsetType)(y + row_index), image->rows);
                        if (status == MagickFalse)
                          break;
                    }
                }
            }

            if (status == MagickFalse)
              break;
        }
        tile_info = RelinquishVirtualMemory(tile_info);
        break;
    }