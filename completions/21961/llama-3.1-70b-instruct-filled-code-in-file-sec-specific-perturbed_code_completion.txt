case ReadStripMethod:
{
  /*
    Convert strip-based TIFF image.
  */
  uint32
    *strip_offsets,
    *strip_byte_counts;

  ssize_t
    y;

  strip_offsets=(uint32 *) NULL;
  strip_byte_counts=(uint32 *) NULL;
  if (TIFFGetField(tiff,TIFFTAG_STRIPOFFSETS,&strip_offsets)!= 1)
    ThrowTIFFException(CorruptImageError,"UnableToReadTIFFImage");
  if (TIFFGetField(tiff,TIFFTAG_STRIPBYTECOUNTS,&strip_byte_counts)!= 1)
    ThrowTIFFException(CorruptImageError,"UnableToReadTIFFImage");
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    register Quantum
      *magick_restrict q;

    register ssize_t
      x;

    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
    if (q == (Quantum *) NULL)
      break;
    if (TIFFReadEncodedStrip(tiff,(uint32) y,pixels,strip_byte_counts[y]) == -1)
      break;
    for (x=0; x < (ssize_t) image->columns; x++)
    {
      SetPixelRed(image,ScaleCharToQuantum(*pixels),q);
      SetPixelGreen(image,ScaleCharToQuantum(*(pixels+1)),q);
      SetPixelBlue(image,ScaleCharToQuantum(*(pixels+2)),q);
      if (image->alpha_trait!= UndefinedPixelTrait)
        SetPixelAlpha(image,ScaleCharToQuantum(*(pixels+3)),q);
      pixels+=4;
      q+=GetPixelChannels(image);
    }
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  strip_offsets=(uint32 *) RelinquishMagickMemory(strip_offsets);
  strip_byte_counts=(uint32 *) RelinquishMagickMemory(strip_byte_counts);
  break;
}
case ReadTileMethod:
{
  /*
    Convert tile-based TIFF image.
  */
  uint32
    tile_columns,
    tile_rows;

  ssize_t
    x,
    y;

  TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&tile_columns);
  TIFFGetField(tiff,TIFFTAG_TILELENGTH,&tile_rows);
  for (y=0; y < (ssize_t) image->rows; y+=tile_rows)
  {
    register Quantum
      *magick_restrict q;

    register ssize_t
      i;

    for (x=0; x < (ssize_t) image->columns; x+=tile_columns)
    {
      q=QueueAuthenticPixels(image,x,y,tile_columns,tile_rows,exception);
      if (q == (Quantum *) NULL)
        break;
      for (i=0; i < tile_rows; i++)
      {
        if (TIFFReadTile(tiff,(uint32) x,(uint32) (y+i),pixels,0,0) == -1)
          break;
        for (i=0; i < tile_columns; i++)
        {
          SetPixelRed(image,ScaleCharToQuantum(*pixels),q);
          SetPixelGreen(image,ScaleCharToQuantum(*(pixels+1)),q);
          SetPixelBlue(image,ScaleCharToQuantum(*(pixels+2)),q);
          if (image->alpha_trait!= UndefinedPixelTrait)
            SetPixelAlpha(image,ScaleCharToQuantum(*(pixels+3)),q);
          pixels+=4;
          q+=GetPixelChannels(image);
        }
      }
      if (SyncAuthenticPixels(image,exception) == MagickFalse)
        break;
    }
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  break;
}