// Initialize the bytestream for tile-part headers using packed header streams if PPM is present.
if (decodercontext->has_ppm) {
    bytestream2_init(&tile->packed_headers_stream, decodercontext->packed_headers, decodercontext->packed_headers_size);
}

// Initialize the bytestream for packed packet headers if PPT is present and it's the first tile-part.
if (tile->tp_idx == 0 && decodercontext->ppt_data) {
    bytestream2_init(&tp->packed_packet_headers_stream, tp->ppt_data, tp->ppt_length);
}

// Set up the data stream for the current tile-part by calculating its size and skipping to its end in the buffer.
int tile_part_size = tp->tp_end - decodercontext->g.buffer;
if (tile_part_size > 0 && bytestream2_get_bytes_left(&decodercontext->g) >= tile_part_size) {
    bytestream2_skip(&decodercontext->g, tile_part_size);
} else {
    av_log(decodercontext->avctx, AV_LOG_ERROR, "Invalid tile part size or insufficient bytes left\n");
    return AVERROR_INVALIDDATA;
}

// Continue to the next iteration of the loop to process more headers or reach the end marker.
continue;