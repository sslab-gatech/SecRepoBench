// Initialize the bytestream for tile-part headers using packed header streams if PPM is present.
// Initialize the bytestream for packed packet headers if PPT is present and it's the first tile-part.
// Set up the data stream for the current tile-part by calculating its size and skipping to its end in the buffer.
// Continue to the next iteration of the loop to process more headers or reach the end marker.
if (decodercontext->has_ppm) {
    if (decodercontext->in_tile_headers) {
        bytestream2_init(&decodercontext->packed_headers_stream, decodercontext->packed_headers, decodercontext->packed_headers_size);
    }
    if (marker == JPEG2000_PPT) {
        if (!decodercontext->has_ppm) {
            av_log(decodercontext->avctx, AV_LOG_ERROR, "Cannot have PPT without PPM marker.\n");
            return AVERROR_INVALIDDATA;
        }
        if (decodercontext->curtileno == 0) {
            decodercontext->in_tile_headers = 1;
            bytestream2_init(&decodercontext->packed_packet_headers_stream, decodercontext->packed_packet_headers, decodercontext->packed_packet_headers_size);
        }
    }
}

// Calculate the size of the current tile-part
int tile_part_size = 0;
if (marker == JPEG2000_TLM) {
    tile_part_size = bytestream2_get_be32u(&decodercontext->g);
} else {
    tile_part_size = bytestream2_get_be16u(&decodercontext->g);
}

// Skip to the end of the current tile-part
bytestream2_skip(&decodercontext->g, tile_part_size);

// Update the current tile number
if (marker == JPEG2000_SOT) {
    decodercontext->curtileno++;
}

// Continue to the next iteration of the loop
continue;