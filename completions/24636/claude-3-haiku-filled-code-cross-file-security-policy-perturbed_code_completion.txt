// Initialize the bytestream for tile-part headers using packed header streams if PPM is present.
if (decodercontext->has_ppm) {
    bytestream2_init(&decodercontext->packed_headers_stream, decodercontext->packed_headers, decodercontext->packed_headers_size);
}

// Initialize the bytestream for packed packet headers if PPT is present and it's the first tile-part.
if (decodercontext->has_ppt && tile->tp_idx == 0) {
    bytestream2_init(&decodercontext->packed_headers_stream, tile->tile_part[0].packed_headers, tile->tile_part[0].packed_headers_size);
}

// Set up the data stream for the current tile-part by calculating its size and skipping to its end in the buffer.
if (tile->tp_idx < tile->num_tile_parts) {
    Jpeg2000TilePart *tp = &tile->tile_part[tile->tp_idx];
    int64_t tp_end = bytestream2_tell(&decodercontext->g) + tp->length;
    if (tp_end > decodercontext->g.buffer_end) {
        av_log(decodercontext->avctx, AV_LOG_ERROR, "Invalid tile-part length\n");
        return AVERROR_INVALIDDATA;
    }
    bytestream2_skip(&decodercontext->g, tp->length);
}

// Continue to the next iteration of the loop to process more headers or reach the end marker.