if (marker == JPEG2000_SOT) {
    Jpeg2000Tile *tile;
    Jpeg2000TilePart *tp;

    if (!decodercontext->tile) {
        av_log(decodercontext->avctx, AV_LOG_ERROR, "Missing SIZ\n");
        return AVERROR_INVALIDDATA;
    }
    if (decodercontext->curtileno < 0) {
        av_log(decodercontext->avctx, AV_LOG_ERROR, "Missing SOT\n");
        return AVERROR_INVALIDDATA;
    }

    tile = decodercontext->tile + decodercontext->curtileno;
    tp = tile->tile_part + tile->tp_idx;
    if (tp->tp_end < decodercontext->g.buffer) {
        av_log(decodercontext->avctx, AV_LOG_ERROR, "Invalid tpend\n");
        return AVERROR_INVALIDDATA;
    }

    // Initialize the bytestream for tile-part headers using packed header streams if PPM is present.
    // Initialize the bytestream for packed packet headers if PPT is present and it's the first tile-part.
    // Set up the data stream for the current tile-part by calculating its size and skipping to its end in the buffer.
    // Continue to the next iteration of the loop to process more headers or reach the end marker.
    if (decodercontext->has_ppm) {
        bytestream2_init(&decodercontext->packed_headers_stream, decodercontext->packed_headers, decodercontext->packed_headers_size);
    }
    if (decodercontext->has_ppt && decodercontext->curtileno == 0) {
        bytestream2_init(&decodercontext->packed_packet_headers_stream, decodercontext->packed_packet_headers, decodercontext->packed_packet_headers_size);
    }
    if (tp->tp_end - tp->tp_pos < 2) {
        av_log(decodercontext->avctx, AV_LOG_ERROR, "Invalid tile-part header\n");
        return AVERROR_INVALIDDATA;
    }
    if (bytestream2_get_bytes_left(&decodercontext->g) < tp->tp_end - tp->tp_pos) {
        av_log(decodercontext->avctx, AV_LOG_ERROR, "Not enough data for tile-part header\n");
        return AVERROR_INVALIDDATA;
    }
    bytestream2_init(&decodercontext->tile_part_stream, tp->tp_pos, tp->tp_end - tp->tp_pos);
    bytestream2_init(&decodercontext->tile_part_stream, tp->tp_pos, tp->tp_end - tp->tp_pos);
    decodercontext->tile_part_pos = 0;
    decodercontext->tile_part_size = tp->tp_end - tp->tp_pos;
    decodercontext->tile_part_end = tp->tp_end;
    decodercontext->in_tile_headers = 1;
    continue;
}