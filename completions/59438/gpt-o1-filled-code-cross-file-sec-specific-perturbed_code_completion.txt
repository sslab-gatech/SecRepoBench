{
    /* A helper macro to read a 32-bit little-endian value from the buffer. */
#define GETLEN(p) \
    ((uint32_t)((p)[0]) \
     | ((uint32_t)((p)[1]) << 8) \
     | ((uint32_t)((p)[2]) << 16) \
     | ((uint32_t)((p)[3]) << 24))

    /* Adjust this as needed or declare it externally if defined elsewhere. */
#ifndef SIMH_TAPEMARKS
#define SIMH_TAPEMARKS 100
#endif

    int tapemark_count = 0;

    while (uc + 4 <= end_pointer) {
        uint32_t length = GETLEN(uc);
        uc += 4;

        /* Check for End of Medium marker. */
        if (length == 0xFFFFFFFF)
            return 1;

        /* Ensure there's enough space to read the complementary length. */
        if (uc + 4 > end_pointer)
            return 0;
        uint32_t length_comp = GETLEN(uc);
        uc += 4;

        /* Validate complementary length. */
        if (length != (~length_comp))
            return 0;

        /* Check for tapemark (length == 0). */
        if (length == 0) {
            tapemark_count++;
            if (tapemark_count >= SIMH_TAPEMARKS)
                return 1;
            continue;
        }

        /* Ensure there's enough space for record data. */
        if ((size_t)(end_pointer - uc) < length)
            return 0;
        uc += length;

        /* Ensure space for the trailing lengths. */
        if (uc + 8 > end_pointer)
            return 0;
        uint32_t trailer_len = GETLEN(uc);
        uint32_t trailer_len_comp = GETLEN(uc + 4);
        uc += 8;

        /* Validate trailing complementary length and match with the first. */
        if (trailer_len != (~trailer_len_comp) || trailer_len != length)
            return 0;
    }

    /* If we exit the loop without finding a valid EOM marker, data is invalid. */
    return 0;
}