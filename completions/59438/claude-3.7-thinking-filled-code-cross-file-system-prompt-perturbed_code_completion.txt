const int SIMH_TAPEMARKS = 3;  // Assuming a common limit for tapemarks

// Helper to get a 32-bit value from byte array (big-endian)
static unsigned int getlen(const unsigned char *p)
{
    return (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3];
}

static int
simh_parse(const unsigned char *uc, const unsigned char *end_pointer)
{
    unsigned int length, complement_length;
    int records = 0, tapemarks = 0;
    
    // Check for NULL or empty data
    if (uc == NULL || uc >= end_pointer)
        return 0;
    
    while (uc + 4 <= end_pointer) {
        // Get record length
        length = getlen(uc);
        uc += 4;
        
        // Check for End of Medium (EOM) marker
        if (length == 0xFFFFFFFF)
            return 1;  // Found valid SIMH data
        
        // Check for tapemark (0)
        if (length == 0) {
            tapemarks++;
            if (tapemarks >= SIMH_TAPEMARKS)
                return 1;  // Found enough tapemarks to consider it valid
            continue;
        }
        
        // Ensure we have enough bytes for data record plus complementary length
        if (uc + length + 4 > end_pointer)
            return 0;
        
        // Skip record data
        uc += length;
        
        // Get complementary length
        complement_length = getlen(uc);
        uc += 4;
        
        // Validate that lengths match
        if (length != complement_length)
            return 0;
        
        records++;
    }
    
    // If we processed some records or tapemarks, consider it valid
    return (records > 0 || tapemarks > 0) ? 1 : 0;
}