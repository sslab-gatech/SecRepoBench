#define SIMH_TAPEMARKS 2

static inline uint32_t
getlen(const unsigned char *p)
{
    return ((uint32_t)p[0]) |
           ((uint32_t)p[1] << 8) |
           ((uint32_t)p[2] << 16) |
           ((uint32_t)p[3] << 24);
}

{
    size_t tapemarks = 0;
    int found_data = 0;

    while (uc + 4 <= end_pointer) {
        uint32_t length = getlen(uc);

        /* Check for tapemark (EOM) */
        if (length == 0xFFFFFFFF) {
            tapemarks++;
            found_data = 1;
            uc += 4;

            /* Stop if we've reached the tapemark limit */
            if (tapemarks >= SIMH_TAPEMARKS) {
                break;
            }
            continue;
        }

        /* We have a data record */
        found_data = 1;

        /* Ensure we have enough space for record data plus trailing length */
        size_t remaining = (size_t)(end_pointer - uc);
        if ((uint64_t)length + 8 > remaining) {
            return 0;
        }

        /* Check complementary length */
        if (getlen(uc + 4 + length) != length) {
            return 0;
        }

        /* Advance past this record */
        uc += 8 + length;
    }

    /* Return 1 if we encountered any valid data/tapemark, else 0 */
    return found_data ? 1 : 0;
}