if((x+10) > packet->payload_packet_len) {
  // Not enough data to read the response type and TTL
  break;
}

responsetype = get16(&x, packet->payload);

// Safely extract 32-bit TTL
rsp_ttl = 0;
if((x+4) <= packet->payload_packet_len) {
  rsp_ttl = (((u_int32_t)packet->payload[x]) << 24) |
            (((u_int32_t)packet->payload[x+1]) << 16) |
            (((u_int32_t)packet->payload[x+2]) << 8) |
            ((u_int32_t)packet->payload[x+3]);
  x += 4; // Move past the TTL field
}

if(rsp_ttl == 0) {
  ndpi_set_risk(ndpi_struct, flow, NDPI_SUSPICIOUS_SHORT_LIVED_DNS_TTL, "Zero TTL DNS Response");
}

#ifdef DNS_DEBUG
NDPI_LOG_DBG2(ndpi_struct, "TTL=%u, resp_type=%u\n", rsp_ttl, responsetype);
printf("[DNS] [response] TTL=%u, resp_type=%u\n", rsp_ttl, responsetype);
#endif

/* Check DNS response type */
if((responsetype != 0x01 /* A */) && 
   (responsetype != 0x05 /* CNAME */) && 
   (responsetype != 0x0c /* PTR */) && 
   (responsetype != 0x1c /* AAAA */)) {
  /* Not a common response type */
}