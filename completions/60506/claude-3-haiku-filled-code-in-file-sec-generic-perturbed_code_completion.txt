// Check if the version is EXPERIMENTAL_LINE_TABLES_VERSION.
if (version == EXPERIMENTAL_LINE_TABLES_VERSION) {
    // Verify that the line pointer matches the expected sequence of bytes for this version.
    if (line_cursor + 1 >= line_ptr_end) {
        _dwarf_error(dbg, err, DW_DLE_LINE_NUMBER_HEADER_ERROR);
        return DW_DLV_ERROR;
    }

    // Read the logicals_table_offset and actuals_table_offset from the data.
    Dwarf_Unsigned logicals_table_offset = 0;
    Dwarf_Unsigned actuals_table_offset = 0;
    int res = _dwarf_read_unaligned_ck_wrapper(dbg, &logicals_table_offset, line_cursor, DWARF_UNSIGNED_SIZE, line_ptr_end, err);
    if (res != DW_DLV_OK) {
        return res;
    }
    line_cursor += DWARF_UNSIGNED_SIZE;
    res = _dwarf_read_unaligned_ck_wrapper(dbg, &actuals_table_offset, line_cursor, DWARF_UNSIGNED_SIZE, line_ptr_end, err);
    if (res != DW_DLV_OK) {
        return res;
    }
    line_cursor += DWARF_UNSIGNED_SIZE;

    // Store these offsets in the line_context.
    line_context->lc_logicals_table_offset = logicals_table_offset;
    line_context->lc_actuals_table_offset = actuals_table_offset;

    // Update the line pointer to account for the read offsets.
    *updated_data_start_out = line_cursor;

    // Ensure that the line pointer does not exceed the line pointer end after the updates.
    if (*updated_data_start_out > line_ptr_end) {
        _dwarf_error(dbg, err, DW_DLE_LINE_NUMBER_HEADER_ERROR);
        return DW_DLV_ERROR;
    }
}