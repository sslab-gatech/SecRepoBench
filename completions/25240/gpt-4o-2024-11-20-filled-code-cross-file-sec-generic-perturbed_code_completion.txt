{
                // Advance the iterator to the next character
                ++m_DataIt;

                // Check for specific material properties
                if (m_DataIt != m_DataItEnd) {
                    switch (*m_DataIt) {
                        case 'a': // Ambient color
                            ++m_DataIt;
                            getColorRGBA(m_CurrentMaterial->Ambient);
                            break;

                        case 'd': // Diffuse color
                            ++m_DataIt;
                            getColorRGBA(m_CurrentMaterial->Diffuse);
                            break;

                        case 's': // Specular color
                            ++m_DataIt;
                            getColorRGBA(m_CurrentMaterial->Specular);
                            break;

                        case 'e': // Emissive color
                            ++m_DataIt;
                            getColorRGBA(m_CurrentMaterial->Emissive);
                            break;

                        case 't': // Transmission filter
                            ++m_DataIt;
                            getColorRGBA(m_CurrentMaterial->TransmissionFilter);
                            break;

                        case 'T': // Transparency or alpha value
                            ++m_DataIt;
                            m_CurrentMaterial->Alpha = getFloatValue(m_DataIt, m_DataItEnd);
                            break;

                        case 'N': // Specular exponent or Index of Refraction (IOR)
                            ++m_DataIt;
                            if (m_DataIt != m_DataItEnd && *m_DataIt == 's') {
                                ++m_DataIt;
                                m_CurrentMaterial->SpecularExponent = getFloatValue(m_DataIt, m_DataItEnd);
                            } else if (m_DataIt != m_DataItEnd && *m_DataIt == 'i') {
                                ++m_DataIt;
                                m_CurrentMaterial->IndexOfRefraction = getFloatValue(m_DataIt, m_DataItEnd);
                            }
                            break;

                        case 'm': // Map (texture)
                            ++m_DataIt;
                            if (m_DataIt != m_DataItEnd && *m_DataIt == 'a') {
                                ++m_DataIt;
                                std::string textureType = getNextToken<std::string>(m_DataIt, m_DataItEnd);
                                if (textureType == "Kd") {
                                    m_CurrentMaterial->DiffuseTexture = getNextToken<std::string>(m_DataIt, m_DataItEnd);
                                } else if (textureType == "Ka") {
                                    m_CurrentMaterial->AmbientTexture = getNextToken<std::string>(m_DataIt, m_DataItEnd);
                                } else if (textureType == "Ks") {
                                    m_CurrentMaterial->SpecularTexture = getNextToken<std::string>(m_DataIt, m_DataItEnd);
                                } else if (textureType == "Ke") {
                                    m_CurrentMaterial->EmissiveTexture = getNextToken<std::string>(m_DataIt, m_DataItEnd);
                                } else if (textureType == "bump" || textureType == "map_Bump") {
                                    m_CurrentMaterial->BumpTexture = getNextToken<std::string>(m_DataIt, m_DataItEnd);
                                }
                            }
                            break;

                        case 'i': // Illumination model
                            ++m_DataIt;
                            m_CurrentMaterial->IlluminationModel = getIntValue(m_DataIt, m_DataItEnd);
                            break;

                        default:
                            m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
                            break;
                    }
                }
            }