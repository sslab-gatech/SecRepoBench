case 'k':
case 'K': {
    ++m_DataIt;
    if (m_DataIt == m_DataItEnd) {
        break;
    }
    
    const char specifier = toupper(*m_DataIt);
    if ('A' == specifier) {
        // Ambient color (Ka)
        ++m_DataIt;
        getColorRGBA(m_pModel->m_pCurrentMaterial->ambient);
    } else if ('D' == specifier) {
        // Diffuse color (Kd)
        ++m_DataIt;
        getColorRGBA(m_pModel->m_pCurrentMaterial->diffuse);
    } else if ('S' == specifier) {
        // Specular color (Ks)
        ++m_DataIt;
        getColorRGBA(m_pModel->m_pCurrentMaterial->specular);
    } else if ('E' == specifier) {
        // Emissive color (Ke)
        ++m_DataIt;
        getColorRGBA(m_pModel->m_pCurrentMaterial->emissive);
    } else if ('T' == specifier) {
        // Transmission color (Kt)
        ++m_DataIt;
        getColorRGBA(m_pModel->m_pCurrentMaterial->transparent);
    } else {
        m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
    }
} break;

case 'd':
case 'D': {
    // Alpha value (d)
    if (*(m_DataIt+1) == ' ' || *(m_DataIt+1) == '\t') {
        ++m_DataIt;
        getFloatValue(m_pModel->m_pCurrentMaterial->alpha);
    } else {
        m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
    }
} break;

case 'T':
case 't': {
    // Transparency (Tr)
    if ('R' == toupper(*(m_DataIt+1))) {
        m_DataIt += 2;
        ai_real transparency;
        getFloatValue(transparency);
        m_pModel->m_pCurrentMaterial->alpha = 1.0f - transparency;
    } else {
        m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
    }
} break;

case 'n':
case 'N': {
    ++m_DataIt;
    if (m_DataIt == m_DataItEnd) {
        break;
    }
    
    const char specifier = toupper(*m_DataIt);
    if ('S' == specifier) {
        // Specular exponent (Ns)
        ++m_DataIt;
        getFloatValue(m_pModel->m_pCurrentMaterial->shineness);
    } else if ('I' == specifier) {
        // Index of refraction (Ni)
        ++m_DataIt;
        getFloatValue(m_pModel->m_pCurrentMaterial->ior);
    } else if ('E' == specifier && 'W' == toupper(*(m_DataIt+1))) {
        // New material (newmtl)
        createMaterial();
    } else {
        m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
    }
} break;

case 'i':
case 'I': {
    if ('L' == toupper(*(m_DataIt+1))) {
        // Illumination model (illum)
        m_DataIt += 5;
        getIlluminationModel(m_pModel->m_pCurrentMaterial->illumination_model);
    } else {
        m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
    }
} break;

case 'm':
case 'M': {
    if ('A' == toupper(*(m_DataIt+1)) && 'P' == toupper(*(m_DataIt+2)) && '_' == *(m_DataIt+3)) {
        // Texture map (map_)
        getTexture();
    } else {
        m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
    }
} break;

case 'b':
case 'B':
case 'r':
case 'R':
case 'e':
case 'E':
case 'p':
case 'P': {
    // bump, refl, etc. texture properties
    getTexture();
} break;