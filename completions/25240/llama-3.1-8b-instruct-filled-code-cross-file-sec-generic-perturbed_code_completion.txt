case 'k': {
    if (m_DataIt == m_DataItEnd) {
        m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
        break;
    }

    std::string strProperty = getNextToken<DataArrayIt>(m_DataIt, m_DataItEnd);
    if (strProperty.empty()) {
        m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
        break;
    }

    if (strProperty == "newmtl") {
        // Create a new material
        std::string strMatName = getNextToken<DataArrayIt>(m_DataIt, m_DataItEnd);
        if (strMatName.empty()) {
            m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
            break;
        }

        int mat_index = m_pModel->getMaterialIndex(strMatName);
        if (mat_index == -1) {
            mat_index = m_pModel->createMaterial(strMatName);
        }

        m_pModel->m_pCurrentMaterial = m_pModel->m_pMaterialLib[mat_index];
        m_pModel->m_pCurrentMesh->m_uiMaterialIndex = mat_index;
        m_pModel->m_pCurrentMesh->m_pMaterial = m_pModel->m_pCurrentMaterial;
    } else if (strProperty == "Ka") {
        // Ambient color
        aiColor3D v;
        getColorRGBA(v);
        m_pModel->m_pCurrentMaterial->m_Ka = v;
    } else if (strProperty == "Kd") {
        // Diffuse color
        aiColor3D v;
        getColorRGBA(v);
        m_pModel->m_pCurrentMaterial->m_Kd = v;
    } else if (strProperty == "Ks") {
        // Specular color
        aiColor3D v;
        getColorRGBA(v);
        m_pModel->m_pCurrentMaterial->m_Ks = v;
    } else if (strProperty == "Ke") {
        // Emissive color
        aiColor3D v;
        getColorRGBA(v);
        m_pModel->m_pCurrentMaterial->m_Ke = v;
    } else if (strProperty == "Kt") {
        // Transmission color
        aiColor3D v;
        getColorRGBA(v);
        m_pModel->m_pCurrentMaterial->m_Kt = v;
    } else if (strProperty == "Ns") {
        // Specular exponent
        float value;
        getValue(value);
        m_pModel->m_pCurrentMaterial->m_Ns = value;
    } else if (strProperty == "Ni") {
        // Index of refraction
        float value;
        getValue(value);
        m_pModel->m_pCurrentMaterial->m_Ni = value;
    } else if (strProperty == "d") {
        // Dissolve (transparency)
        float value;
        getValue(value);
        m_pModel->m_pCurrentMaterial->m_d = value;
    } else if (strProperty == "Tr") {
        // Transparency
        float value;
        getValue(value);
        m_pModel->m_pCurrentMaterial->m_Tr = value;
    } else if (strProperty == "illum") {
        // Illumination model
        int value;
        getValue(value);
        m_pModel->m_pCurrentMaterial->m_illum = value;
    } else if (strProperty == "map_Ka") {
        // Diffuse texture
        std::string strTextureName = getNextToken<DataArrayIt>(m_DataIt, m_DataItEnd);
        if (strTextureName.empty()) {
            m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
            break;
        }

        m_pModel->m_pCurrentMaterial->m_map_Ka = strTextureName;
    } else if (strProperty == "map_Kd") {
        // Diffuse texture
        std::string strTextureName = getNextToken<DataArrayIt>(m_DataIt, m_DataItEnd);
        if (strTextureName.empty()) {
            m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
            break;
        }

        m_pModel->m_pCurrentMaterial->m_map_Kd = strTextureName;
    } else if (strProperty == "map_Ks") {
        // Specular texture
        std::string strTextureName = getNextToken<DataArrayIt>(m_DataIt, m_DataItEnd);
        if (strTextureName.empty()) {
            m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
            break;
        }

        m_pModel->m_pCurrentMaterial->m_map_Ks = strTextureName;
    } else if (strProperty == "map_Bump") {
        // Bump texture
        std::string strTextureName = getNextToken<DataArrayIt>(m_DataIt, m_DataItEnd);
        if (strTextureName.empty()) {
            m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
            break;
        }

        m_pModel->m_pCurrentMaterial->m_map_Bump = strTextureName;
    } else if (strProperty == "map_D") {
        // Dissolve texture
        std::string strTextureName = getNextToken<DataArrayIt>(m_DataIt, m_DataItEnd);
        if (strTextureName.empty()) {
            m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
            break;
        }

        m_pModel->m_pCurrentMaterial->m_map_D = strTextureName;
    } else if (strProperty == "map_Ns") {
        // Specular exponent texture
        std::string strTextureName = getNextToken<DataArrayIt>(m_DataIt, m_DataItEnd);
        if (strTextureName.empty()) {
            m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
            break;
        }

        m_pModel->m_pCurrentMaterial->m_map_Ns = strTextureName;
    } else if (strProperty == "map_Ia") {
        // Anisotropy texture
        std::string strTextureName = getNextToken<DataArrayIt>(m_DataIt, m_DataItEnd);
        if (strTextureName.empty()) {
            m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
            break;
        }

        m_pModel->m_pCurrentMaterial->m_map_Ia = strTextureName;
    } else if (strProperty == "map_BumpSpec") {
        // Bump texture
        std::string strTextureName = getNextToken<DataArrayIt>(m_DataIt, m_DataItEnd);
        if (strTextureName.empty()) {
            m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
            break;
        }

        m_pModel->m_pCurrentMaterial->m_map_BumpSpec = strTextureName;
    } else if (strProperty == "map_Diffuse") {
        // Diffuse texture
        std::string strTextureName = getNextToken<DataArrayIt>(m_DataIt, m_DataItEnd);
        if (strTextureName.empty()) {
            m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
            break;
        }

        m_pModel->m_pCurrentMaterial->m_map_Diffuse = strTextureName;
    } else if (strProperty == "map_Specular") {
        // Specular texture
        std::string strTextureName = getNextToken<DataArrayIt>(m_DataIt, m_DataItEnd);
        if (strTextureName.empty()) {
            m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
            break;
        }

        m_pModel->m_pCurrentMaterial->m_map_Specular = strTextureName;
    } else if (strProperty == "map_Bump") {
        // Bump texture
        std::string strTextureName = getNextToken<DataArrayIt>(m_DataIt, m_DataItEnd);
        if (strTextureName.empty()) {
            m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
            break;
        }

        m_pModel->m_pCurrentMaterial->m_map_Bump = strTextureName;
    } else if (strProperty == "map_Normal") {
        // Normal texture
        std::string strTextureName = getNextToken<DataArrayIt>(m_DataIt, m_DataItEnd);
        if (strTextureName.empty()) {
            m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
            break;
        }

        m_pModel->m_pCurrentMaterial->m_map_Normal = strTextureName;
    } else if (strProperty == "map_Displacement") {
        // Displacement texture
        std::string strTextureName = getNextToken<DataArrayIt>(m_DataIt, m_DataItEnd);
        if (strTextureName.empty()) {
            m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
            break;
        }

        m_pModel->m_pCurrentMaterial->m_map_Displacement = strTextureName;
    } else if (strProperty == "map_Height") {
        // Height texture
        std::string strTextureName = getNextToken<DataArrayIt>(m_DataIt, m_DataItEnd);
        if (strTextureName.empty()) {
            m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
            break;
        }

        m_pModel->m_pCurrentMaterial->m_map_Height = strTextureName;
    } else if (strProperty == "map_SpecularLevel") {
        // Specular level texture
        std::string strTextureName = getNextToken<DataArrayIt>(m_DataIt, m_DataItEnd);
        if (strTextureName.empty()) {
            m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
            break;
        }

        m_pModel->m_pCurrentMaterial->m_map_SpecularLevel = strTextureName;
    } else if (strProperty == "map_SpecularRoughness") {
        // Specular roughness texture
        std::string strTextureName = getNextToken<DataArrayIt>(m_DataIt, m_DataItEnd);
        if (strTextureName.empty()) {
            m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
            break;
        }

        m_pModel->m_pCurrentMaterial->m_map_SpecularRoughness = strTextureName;
    } else if (strProperty == "map_Metallic") {
        // Metallic texture
        std::string strTextureName = getNextToken<DataArrayIt>(m_DataIt, m_DataItEnd);
        if (strTextureName.empty()) {
            m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
            break;
        }

        m_pModel->m_pCurrentMaterial->m_map_Metallic = strTextureName;
    } else if (strProperty == "map_Roughness") {
        // Roughness texture
        std::string strTextureName = getNextToken<DataArrayIt>(m_DataIt, m_DataItEnd);
        if (strTextureName.empty()) {
            m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
            break;
        }

        m_pModel->m_pCurrentMaterial->m_map_Roughness = strTextureName;
    } else if (strProperty == "map_NormalScale") {
        // Normal scale texture
        std::string strTextureName = getNextToken<DataArrayIt>(m_DataIt, m_DataItEnd);
        if (strTextureName.empty()) {
            m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
            break;
        }

        m_pModel->m_pCurrentMaterial->m_map_NormalScale = strTextureName;
    } else if (strProperty == "map_Sheen") {
        // Sheen texture
        std::string strTextureName = getNextToken<DataArrayIt>(m_DataIt, m_DataItEnd);
        if (strTextureName.empty()) {
            m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
            break;
        }

        m_pModel->m_pCurrentMaterial->m_map_Sheen = strTextureName;
    } else if (strProperty == "map_SheenColor") {
        // Sheen color texture
        std::string strTextureName = getNextToken<DataArrayIt>(m_DataIt, m_DataItEnd);
        if (strTextureName.empty()) {
            m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
            break;
        }

        m_pModel->m_pCurrentMaterial->m_map_SheenColor = strTextureName;
    } else if (strProperty == "map_SheenRoughness") {
        // Sheen roughness texture
        std::string strTextureName = getNextToken<DataArrayIt>(m_DataIt, m_DataItEnd);
        if (strTextureName.empty()) {
            m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
            break;
        }

        m_pModel->m_pCurrentMaterial->m_map_SheenRoughness = strTextureName;
    } else if (strProperty == "map_SheenColorRoughness") {
        // Sheen color roughness texture
        std::string strTextureName = getNextToken<DataArrayIt>(m_DataIt, m_DataItEnd);
        if (strTextureName.empty()) {
            m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
            break;
        }

        m_pModel->m_pCurrentMaterial->m_map_