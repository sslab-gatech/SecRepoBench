case 'K': // Ambient color
            case 'k': // Diffuse color
                {
                    aiColor3D color;
                    getColorRGBA(color);
                    if (*m_DataIt == 'K') {
                        m_CurrentMaterial->Ambient = color;
                    } else {
                        m_CurrentMaterial->Diffuse = color;
                    }
                }
                break;

            case 'S': // Specular color
                {
                    aiColor3D color;
                    getColorRGBA(color);
                    m_CurrentMaterial->Specular = color;
                }
                break;

            case 'E': // Emissive color
                {
                    aiColor3D color;
                    getColorRGBA(color);
                    m_CurrentMaterial->Emissive = color;
                }
                break;

            case 'T': // Transparency
                {
                    float alpha;
                    m_DataIt = getNextToken<DataArrayIt>(m_DataIt, m_DataItEnd);
                    if (m_DataIt != m_DataItEnd) {
                        alpha = std::stof(std::string(m_DataIt, m_DataItEnd));
                        m_CurrentMaterial->Transparency = alpha;
                    }
                }
                break;

            case 'N': // Specular exponent
                {
                    float shininess;
                    m_DataIt = getNextToken<DataArrayIt>(m_DataIt, m_DataItEnd);
                    if (m_DataIt != m_DataItEnd) {
                        shininess = std::stof(std::string(m_DataIt, m_DataItEnd));
                        m_CurrentMaterial->Shininess = shininess;
                    }
                }
                break;

            case 'I': // Index of Refraction
                {
                    float ior;
                    m_DataIt = getNextToken<DataArrayIt>(m_DataIt, m_DataItEnd);
                    if (m_DataIt != m_DataItEnd) {
                        ior = std::stof(std::string(m_DataIt, m_DataItEnd));
                        m_CurrentMaterial->IOR = ior;
                    }
                }
                break;

            case 'M': // Material name
                {
                    m_DataIt = getNextToken<DataArrayIt>(m_DataIt, m_DataItEnd);
                    if (m_DataIt != m_DataItEnd) {
                        m_CurrentMaterial->MaterialName = std::string(m_DataIt, m_DataItEnd);
                    }
                }
                break;

            case 'm': // Texture
                {
                    // Handle texture loading based on the type
                    // This would involve parsing the texture type and file name
                    // For example, diffuse texture, bump texture, etc.
                }
                break;

            // Add more cases as needed for other material properties