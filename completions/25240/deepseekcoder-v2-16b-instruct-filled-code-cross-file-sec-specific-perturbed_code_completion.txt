case 'k':
        // Parses material properties from a buffer when loading material files. The code processes
        // different material properties based on the current character in the buffer. It handles:
        // 1. Colors: Ambient, Diffuse, Specular, Emissive, and Transmission.
        // 2. Transparency and Alpha values.
        // 3. Specular exponent and Index of Refraction (IOR).
        // 4. Materials: Creates a new material when needed.
        // 5. Textures: Handles various texture types like diffuse, bump, etc.
        // 6. Illumination models and anisotropy.
        // The parsing is done by moving through the buffer character by character, determining
        // which property is being specified, and calling the appropriate function to parse
        // and assign the value to the current material being processed.

        // Check for material library directive
        if (std::string("newmtl").compare(0, 7, m_DataIt, 7) == 0) {
            m_DataIt += 7;
            if (m_DataIt == m_DataItEnd || IsLineEnd(*m_DataIt)) {
                ASSIMP_LOG_ERROR("OBJ: Invalid material name specified.");
                m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
                continue;
            }
            std::string matName(m_DataIt, m_DataItEnd);
            if (matName.empty()) {
                ASSIMP_LOG_ERROR("OBJ: Material name is empty.");
                m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
                continue;
            }
            m_DataIt = m_DataItEnd; // Skip to end of line

            // Create a new material
            ObjFile::Material* pMat = new ObjFile::Material;
            pMat->MaterialName = matName;
            m_pModel->m_pCurrentMaterial = pMat;
            m_pModel->m_Materials.push_back(pMat);
        } else if (std::string("Ka").compare(0, 2, m_DataIt, 2) == 0) {
            m_DataIt += 2;
            getColorRGBA(pMat->Ambient);
        } else if (std::string("Kd").compare(0, 2, m_DataIt, 2) == 0) {
            m_DataIt += 2;
            getColorRGBA(pMat->Diffuse);
        } else if (std::string("Ks").compare(0, 2, m_DataIt, 2) == 0) {
            m_DataIt += 2;
            getColorRGBA(pMat->Specular);
        } else if (std::string("Ke").compare(0, 2, m_DataIt, 2) == 0) {
            m_DataIt += 2;
            getColorRGBA(pMat->Emissive);
        } else if (std::string("Tf").compare(0, 2, m_DataIt, 2) == 0) {
            m_DataIt += 2;
            aiColor3D trans;
            getColorRGBA(trans);
            pMat->Transmission = trans.r;
            pMat->TransmissionFactor = trans.g;
        } else if (std::string("Ns").compare(0, 2, m_DataIt, 2) == 0) {
            m_DataIt += 2;
            float ns;
            m_DataIt = getFloat(m_DataIt, m_DataItEnd, ns);
            pMat->Shininess = ns;
        } else if (std::string("Ni").compare(0, 2, m_DataIt, 2) == 0) {
            m_DataIt += 2;
            float ni;
            m_DataIt = getFloat(m_DataIt, m_DataItEnd, ni);
            pMat->IndexOfRefraction = ni;
        } else if (std::string("d").compare(0, 1, m_DataIt, 1) == 0 || std::string("Tr").compare(0, 2, m_DataIt, 2) == 0) {
            m_DataIt += 1;
            float d;
            m_DataIt = getFloat(m_DataIt, m_DataItEnd, d);
            pMat->Dissolve = d;
        } else if (std::string("illum").compare(0, 5, m_DataIt, 5) == 0) {
            m_DataIt += 5;
            int illum;
            m_DataIt = getInt(m_DataIt, m_DataItEnd, illum);
            pMat->IlluminationModel = illum;
        } else if (std::string("map_").compare(0, 4, m_DataIt, 4) == 0) {
            m_DataIt += 4;
            std::string mapType(m_DataIt, m_DataItEnd);
            if (!mapType.empty()) {
                pMat->AddTexture(mapType, "");
            }
            while (!IsLineEnd(*m_DataIt) && !isDataDefinitionEnd(m_DataIt)) {
                ++m_DataIt;
            }
        } else {
            ASSIMP_LOG_WARN("OBJ: Unknown material property specified: ", std::string(m_DataIt, m_DataItEnd));
            m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
        }
        break;