case 'k': {
    m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
    break;
}

case 'N': {
    if (checkToken(m_DataIt, m_DataItEnd, "Ns")) {
        float f;
        getFloat(f);
        m_pModel->m_pCurrentMaterial->shininess = f;
    } else if (checkToken(m_DataIt, m_DataItEnd, "Ni")) {
        float f;
        getFloat(f);
        m_pModel->m_pCurrentMaterial->ior = f;
    }
    m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
    break;
}

case 'd': {
    if (checkToken(m_DataIt, m_DataItEnd, "d")) {
        float f;
        getFloat(f);
        m_pModel->m_pCurrentMaterial->opacity = f;
    } else if (checkToken(m_DataIt, m_DataItEnd, "disp")) {
        // Displacement texture
        std::string textureName;
        getString(textureName);
        m_pModel->m_pCurrentMaterial->AddTexture(TextureType::DISPLACEMENT, textureName);
    }
    m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
    break;
}

case 'T': {
    if (checkToken(m_DataIt, m_DataItEnd, "Tr")) {
        float f;
        getFloat(f);
        m_pModel->m_pCurrentMaterial->opacity = 1.0f - f;
    }
    m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
    break;
}

case 'a':
case 'A': {
    if (checkToken(m_DataIt, m_DataItEnd, "ambient")) {
        Maybe<aiColor3D> c;
        getColorRGBA(c);
        if (c.HasValue()) {
            m_pModel->m_pCurrentMaterial->ambient = c.Value();
        }
    } else if (checkToken(m_DataIt, m_DataItEnd, "anisotropy")) {
        float f;
        getFloat(f);
        m_pModel->m_pCurrentMaterial->anisotropy = f;
    } else if (checkToken(m_DataIt, m_DataItEnd, "alpha")) {
        float f;
        getFloat(f);
        m_pModel->m_pCurrentMaterial->opacity = f;
    }
    m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
    break;
}

case 'D': {
    if (checkToken(m_DataIt, m_DataItEnd, "diffuse")) {
        Maybe<aiColor3D> c;
        getColorRGBA(c);
        if (c.HasValue()) {
            m_pModel->m_pCurrentMaterial->diffuse = c.Value();
        }
    }
    m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
    break;
}

case 'S': {
    if (checkToken(m_DataIt, m_DataItEnd, "specular")) {
        Maybe<aiColor3D> c;
        getColorRGBA(c);
        if (c.HasValue()) {
            m_pModel->m_pCurrentMaterial->specular = c.Value();
        }
    } else if (checkToken(m_DataIt, m_DataItEnd, "shininess_strength")) {
        float f;
        getFloat(f);
        m_pModel->m_pCurrentMaterial->shininessStrength = f;
    }
    m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
    break;
}

case 'E': {
    if (checkToken(m_DataIt, m_DataItEnd, "emissive")) {
        Maybe<aiColor3D> c;
        getColorRGBA(c);
        if (c.HasValue()) {
            m_pModel->m_pCurrentMaterial->emissive = c.Value();
        }
    }
    m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
    break;
}

case 'b': {
    if (checkToken(m_DataIt, m_DataItEnd, "bump")) {
        std::string textureName;
        getString(textureName);
        m_pModel->m_pCurrentMaterial->AddTexture(TextureType::BUMP, textureName);
    }
    m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
    break;
}

case 'm': {
    if (checkToken(m_DataIt, m_DataItEnd, "map_Ka")) {
        std::string textureName;
        getString(textureName);
        m_pModel->m_pCurrentMaterial->AddTexture(TextureType::AMBIENT, textureName);
    } else if (checkToken(m_DataIt, m_DataItEnd, "map_Kd")) {
        std::string textureName;
        getString(textureName);
        m_pModel->m_pCurrentMaterial->AddTexture(TextureType::DIFFUSE, textureName);
    } else if (checkToken(m_DataIt, m_DataItEnd, "map_Ks")) {
        std::string textureName;
        getString(textureName);
        m_pModel->m_pCurrentMaterial->AddTexture(TextureType::SPECULAR, textureName);
    } else if (checkToken(m_DataIt, m_DataItEnd, "map_Ke")) {
        std::string textureName;
        getString(textureName);
        m_pModel->m_pCurrentMaterial->AddTexture(TextureType::EMISSIVE, textureName);
    } else if (checkToken(m_DataIt, m_DataItEnd, "map_Ns")) {
        std::string textureName;
        getString(textureName);
        m_pModel->m_pCurrentMaterial->AddTexture(TextureType::SHININESS, textureName);
    } else if (checkToken(m_DataIt, m_DataItEnd, "map_Ni")) {
        // Not supported
    } else if (checkToken(m_DataIt, m_DataItEnd, "map_d")) {
        std::string textureName;
        getString(textureName);
        m_pModel->m_pCurrentMaterial->AddTexture(TextureType::OPACITY, textureName);
    } else if (checkToken(m_DataIt, m_DataItEnd, "map_bump")) {
        std::string textureName;
        getString(textureName);
        m_pModel->m_pCurrentMaterial->AddTexture(TextureType::BUMP, textureName);
    } else if (checkToken(m_DataIt, m_DataItEnd, "material"))) {
        std::string materialName;
        getString(materialName);
        int matIndex = getMaterialIndex(materialName);
        if (matIndex >= 0) {
            m_pModel->m_pCurrentMaterial = m_pModel->m_MaterialLib[static_cast<size_t>(matIndex)].get();
        }
    }
    m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
    break;
}