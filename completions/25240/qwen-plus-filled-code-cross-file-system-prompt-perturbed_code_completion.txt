case 'K': {
    ++m_DataIt;
    if (m_DataIt == m_DataItEnd) {
        ASSIMP_LOG_WARN("OBJ: Unexpected end of line while parsing color.");
        break;
    }

    switch (*m_DataIt) {
        case 'a': { // Ka - Ambient color
            Maybe<aiColor3D> value;
            getColorRGBA(value);
            if (value.has_value()) {
                m_pModel->m_pCurrentMaterial->AmbientColor = value.value();
            }
        } break;

        case 'd': { // Kd - Diffuse color
            Maybe<aiColor3D> value;
            getColorRGBA(value);
            if (value.has_value()) {
                m_pModel->m_pCurrentMaterial->DiffuseColor = value.value();
            }
        } break;

        case 's': { // Ks - Specular color
            Maybe<aiColor3D> value;
            getColorRGBA(value);
            if (value.has_value()) {
                m_pModel->m_pCurrentMaterial->SpecularColor = value.value();
            }
        } break;

        default: {
            ASSIMP_LOG_WARN("OBJ: Unknown color property, skipping.");
            m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
        } break;
    }
} break;

case 'T': { // Tf - Transmission filter
    ++m_DataIt;
    if (*m_DataIt != 'f') {
        ASSIMP_LOG_WARN("OBJ: Unknown property starting with 'T', skipping.");
        m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
        break;
    }
    Maybe<aiColor3D> value;
    getColorRGBA(value);
    if (value.has_value()) {
        m_pModel->m_pCurrentMaterial->TransmitColor = value.value();
    }
} break;

case 'N': { // Ns - Specular exponent
    ++m_DataIt;
    if (*m_DataIt != 's') {
        ASSIMP_LOG_WARN("OBJ: Unknown property starting with 'N', skipping.");
        m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
        break;
    }
    float value;
    if (!getValue<float>(value)) {
        ASSIMP_LOG_WARN("OBJ: Unable to parse specular exponent, defaulting to 0.");
        value = 0.0f;
    }
    m_pModel->m_pCurrentMaterial->Shininess = value;
} break;

case 'd': { // d or Tr - Dissolve (transparency)
    ++m_DataIt;
    float alpha;
    if (!getValue<float>(alpha)) {
        ASSIMP_LOG_WARN("OBJ: Unable to parse transparency, defaulting to fully opaque.");
        alpha = 1.0f;
    }
    m_pModel->m_pCurrentMaterial->Opacity = alpha;
    m_pModel->m_pCurrentMaterial->IsTwoSided = (alpha < 1.0f);
} break;

case 'i': { // illum - Illumination model
    ++m_DataIt;
    if (*m_DataIt != 'l' || *(m_DataIt + 1) != 'l' || *(m_DataIt + 2) != 'u' || *(m_DataIt + 3) != 'm') {
        ASSIMP_LOG_WARN("OBJ: Unknown property starting with 'i', skipping.");
        m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
        break;
    }
    int illum;
    getValue<int>(illum);
    m_pModel->m_pCurrentMaterial->IlluminationModel = illum;
} break;

case 'map': { // Texture mapping
    std::string textureType;
    for (; m_DataIt != m_DataItEnd && !isspace(*m_DataIt); ++m_DataIt) {
        textureType += *m_DataIt;
    }

    if (textureType.empty()) {
        ASSIMP_LOG_WARN("OBJ: Texture type not specified, skipping.");
        break;
    }

    char *pStart = &(*m_DataIt);
    while (m_DataIt != m_DataItEnd && !IsLineEnd(*m_DataIt)) {
        ++m_DataIt;
    }

    const std::string texturePath(pStart, &(*m_DataIt));
    m_pModel->m_pCurrentMaterial->Textures.push_back(texturePath);

    ASSIMP_LOG_INFO("OBJ: Added texture ", texturePath, " for material ", m_pModel->m_pCurrentMaterial->MaterialName.data);
} break;

case 'newmtl': { // newmtl - New material definition
    ++m_DataIt;
    char *pStart = &(*m_DataIt);
    while (m_DataIt != m_DataItEnd && !IsLineEnd(*m_DataIt)) {
        ++m_DataIt;
    }

    const std::string materialName(pStart, &(*m_DataIt));
    m_pModel->m_pCurrentMaterial = new Material;
    m_pModel->m_pCurrentMaterial->MaterialName = materialName;
    m_pModel->m_MaterialLib.push_back(materialName);

    ASSIMP_LOG_INFO("OBJ: Created new material ", materialName);
} break;