case 'k': {
    // Parses material properties from a buffer when loading material files.
    // The code processes different material properties based on the current character in the buffer.
    // It handles:
    // 1. Colors: Ambient, Diffuse, Specular, Emissive, and Transmission.
    // 2. Transparency and Alpha values.
    // 3. Specular exponent and Index of Refraction (IOR).
    // 4. Materials: Creates a new material when needed.
    // 5. Textures: Handles various texture types like diffuse, bump, etc.
    // 6. Illumination models and anisotropy.
    // The parsing is done by moving through the buffer character by character, determining
    // which property is being specified, and calling the appropriate function to parse
    // and assign the value to the current material being processed.

    // Check if the current character is a valid material property
    if (isDataDefinitionEnd(&(*m_DataIt))) {
        m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
        continue;
    }

    // Get the material name
    std::string strMatName;
    m_DataIt = getNextToken<DataArrayIt>(m_DataIt, m_DataItEnd);
    if (m_DataIt == m_DataItEnd) {
        m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
        continue;
    }

    char *pStart = &(*m_DataIt);
    while (m_DataIt!= m_DataItEnd &&!IsLineEnd(*m_DataIt)) {
        ++m_DataIt;
    }

    strMatName = std::string(pStart, &(*m_DataIt));

    // Check if the material name is valid
    if (strMatName.empty()) {
        ASSIMP_LOG_WARN("OBJ: no name for material specified.");
        m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
        continue;
    }

    // Check if the material library has been loaded
    if (m_pModel->m_pCurrentMaterialLib.empty()) {
        // Load the material library
        ObjFileMtlImporter mtlImporter(m_pModel->m_pCurrent->m_strObjName, m_pModel.get());
        mtlImporter.load();
    }

    // Get the material index
    int mat_index = m_pModel->getMaterialIndex(strMatName);
    if (mat_index == -1) {
        // Create a new material
        m_pModel->createMaterial(strMatName);
        mat_index = m_pModel->getMaterialIndex(strMatName);
    }

    // Set the material index for the current object
    m_pModel->m_pCurrent->m_uiMaterialIndex = mat_index;

    // Parse the material properties
    switch (*m_DataIt) {
        case 'N': {
            // Parse the ambient color
            aiColor3D v;
            getColorRGBA(&v);
            m_pModel->m_pCurrent->m_pMaterial->m_Ambient = v;
            break;
        }
        case 'd': {
            // Parse the diffuse color
            aiColor3D v;
            getColorRGBA(&v);
            m_pModel->m_pCurrent->m_pMaterial->m_Diffuse = v;
            break;
        }
        case's': {
            // Parse the specular color
            aiColor3D v;
            getColorRGBA(&v);
            m_pModel->m_pCurrent->m_pMaterial->m_Specular = v;
            break;
        }
        case 'e': {
            // Parse the emissive color
            aiColor3D v;
            getColorRGBA(&v);
            m_pModel->m_pCurrent->m_pMaterial->m_Emissive = v;
            break;
        }
        case 'T': {
            // Parse the transmission color
            aiColor3D v;
            getColorRGBA(&v);
            m_pModel->m_pCurrent->m_pMaterial->m_Transmission = v;
            break;
        }
        case 'Tr': {
            // Parse the transparency value
            float v;
            getColorRGBA(&v);
            m_pModel->m_pCurrent->m_pMaterial->m_Transparency = v;
            break;
        }
        case 'Ni': {
            // Parse the index of refraction
            float v;
            getColorRGBA(&v);
            m_pModel->m_pCurrent->m_pMaterial->m_Ni = v;
            break;
        }
        case 'Ns': {
            // Parse the specular exponent
            float v;
            getColorRGBA(&v);
            m_pModel->m_pCurrent->m_pMaterial->m_Ns = v;
            break;
        }
        case 'Ka': {
            // Parse the ambient color
            aiColor3D v;
            getColorRGBA(&v);
            m_pModel->m_pCurrent->m_pMaterial->m_Ka = v;
            break;
        }
        case 'Kd': {
            // Parse the diffuse color
            aiColor3D v;
            getColorRGBA(&v);
            m_pModel->m_pCurrent->m_pMaterial->m_Kd = v;
            break;
        }
        case 'Ks': {
            // Parse the specular color
            aiColor3D v;
            getColorRGBA(&v);
            m_pModel->m_pCurrent->m_pMaterial->m_Ks = v;
            break;
        }
        case 'Ke': {
            // Parse the emissive color
            aiColor3D v;
            getColorRGBA(&v);
            m_pModel->m_pCurrent->m_pMaterial->m_Ke = v;
            break;
        }
        case 'Kt': {
            // Parse the transmission color
            aiColor3D v;
            getColorRGBA(&v);
            m_pModel->m_pCurrent->m_pMaterial->m_Kt = v;
            break;
        }
        case 'N': {
            // Parse the illumination model
            std::string strModel;
            m_DataIt = getNextToken<DataArrayIt>(m_DataIt, m_DataItEnd);
            if (m_DataIt == m_DataItEnd) {
                m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
                continue;
            }

            char *pStart = &(*m_DataIt);
            while (m_DataIt!= m_DataItEnd &&!IsLineEnd(*m_DataIt)) {
                ++m_DataIt;
            }

            strModel = std::string(pStart, &(*m_DataIt));

            // Set the illumination model
            m_pModel->m_pCurrent->m_pMaterial->m_IlluminationModel = strModel;
            break;
        }
        case 'D': {
            // Parse the diffuse texture
            std::string strTexture;
            m_DataIt = getNextToken<DataArrayIt>(m_DataIt, m_DataItEnd);
            if (m_DataIt == m_DataItEnd) {
                m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
                continue;
            }

            char *pStart = &(*m_DataIt);
            while (m_DataIt!= m_DataItEnd &&!IsLineEnd(*m_DataIt)) {
                ++m_DataIt;
            }

            strTexture = std::string(pStart, &(*m_DataIt));

            // Set the diffuse texture
            m_pModel->m_pCurrent->m_pMaterial->m_DiffuseTexture = strTexture;
            break;
        }
        case 'B': {
            // Parse the bump texture
            std::string strTexture;
            m_DataIt = getNextToken<DataArrayIt>(m_DataIt, m_DataItEnd);
            if (m_DataIt == m_DataItEnd) {
                m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
                continue;
            }

            char *pStart = &(*m_DataIt);
            while (m_DataIt!= m_DataItEnd &&!IsLineEnd(*m_DataIt)) {
                ++m_DataIt;
            }

            strTexture = std::string(pStart, &(*m_DataIt));

            // Set the bump texture
            m_pModel->m_pCurrent->m_pMaterial->m_BumpTexture = strTexture;
            break;
        }
        default: {
            m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
            break;
        }
    }

    break;
}