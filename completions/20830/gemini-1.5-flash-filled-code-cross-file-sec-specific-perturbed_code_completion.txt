size_t payload_len = flow_packet->payload_packet_len;
  char *payload_copy = (char *)malloc(payload_len + 1);
  if (payload_copy == NULL) {
    return; // Handle memory allocation failure
  }
  memcpy(payload_copy, flow_packet->payload, payload_len);
  payload_copy[payload_len] = '\0';

  char *username_start = strchr(payload_copy + command_start, '"');
  if (username_start == NULL) {
    free(payload_copy);
    return;
  }
  char *username_end = strchr(username_start + 1, '"');
  if (username_end == NULL) {
    free(payload_copy);
    return;
  }
  size_t username_len = username_end - username_start - 1;
  if (username_len > sizeof(flow->protos.ftp_imap_pop_smtp.username) - 1) {
    username_len = sizeof(flow->protos.ftp_imap_pop_smtp.username) - 1;
  }
  strncpy(flow->protos.ftp_imap_pop_smtp.username, username_start + 1, username_len);
  flow->protos.ftp_imap_pop_smtp.username[username_len] = '\0';

  char *password_start = strchr(username_end + 1, '"');
  if (password_start == NULL) {
    free(payload_copy);
    return;
  }
  char *password_end = strchr(password_start + 1, '"');
  if (password_end == NULL) {
    free(payload_copy);
    return;
  }
  size_t password_len = password_end - password_start - 1;
  if (password_len > sizeof(flow->protos.ftp_imap_pop_smtp.password) - 1) {
    password_len = sizeof(flow->protos.ftp_imap_pop_smtp.password) - 1;
  }
  strncpy(flow->protos.ftp_imap_pop_smtp.password, password_start + 1, password_len);
  flow->protos.ftp_imap_pop_smtp.password[password_len] = '\0';

  free(payload_copy);