char temp_buffer[flow_packet->payload_packet_len + 1];
if (flow_packet->payload_packet_len > sizeof(temp_buffer) - 1) {
  // Avoid buffer overflow by ensuring the payload fits within the temporary buffer.
  goto imap_excluded;
}

// Copy the packet payload into a temporary string buffer and ensure it's null-terminated.
memcpy(temp_buffer, flow_packet->payload, flow_packet->payload_packet_len);
temp_buffer[flow_packet->payload_packet_len] = '\0';

// Locate the first double quote character, marking the start of the username.
u_int16_t username_start = 0;
for (i = command_start; i < flow_packet->payload_packet_len; ++i) {
  if (temp_buffer[i] == '"') {
    username_start = i + 1;
    break;
  }
}
if (username_start == 0 || username_start >= flow_packet->payload_packet_len) {
  goto imap_excluded;
}

// Find the next double quote to identify the end of the username.
u_int16_t username_end = 0;
for (i = username_start; i < flow_packet->payload_packet_len; ++i) {
  if (temp_buffer[i] == '"') {
    username_end = i;
    break;
  }
}
if (username_end == 0 || username_end <= username_start) {
  goto imap_excluded;
}

// Extract the username from the payload.
size_t username_length = username_end - username_start;
if (username_length >= sizeof(flow->protos.ftp_imap_pop_smtp.username) - 1) {
  // Ensure the username does not exceed the storage capacity.
  goto imap_excluded;
}
memcpy(flow->protos.ftp_imap_pop_smtp.username, &temp_buffer[username_start], username_length);
flow->protos.ftp_imap_pop_smtp.username[username_length] = '\0';

// Locate the next pair of double quotes to extract the password.
u_int16_t password_start = 0;
for (i = username_end + 1; i < flow_packet->payload_packet_len; ++i) {
  if (temp_buffer[i] == '"') {
    password_start = i + 1;
    break;
  }
}
if (password_start == 0 || password_start >= flow_packet->payload_packet_len) {
  goto imap_excluded;
}

// Find the end of the password.
u_int16_t password_end = 0;
for (i = password_start; i < flow_packet->payload_packet_len; ++i) {
  if (temp_buffer[i] == '"') {
    password_end = i;
    break;
  }
}
if (password_end == 0 || password_end <= password_start) {
  goto imap_excluded;
}

// Extract the password from the payload.
size_t password_length = password_end - password_start;
if (password_length >= sizeof(flow->protos.ftp_imap_pop_smtp.password) - 1) {
  // Ensure the password does not exceed the storage capacity.
  goto imap_excluded;
}
memcpy(flow->protos.ftp_imap_pop_smtp.password, &temp_buffer[password_start], password_length);
flow->protos.ftp_imap_pop_smtp.password[password_length] = '\0';