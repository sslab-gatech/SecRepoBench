// Extract and store the "username" and "password" from the IMAP LOGIN command.
// Copy the packet payload into a temporary string buffer.
// Ensure the copied string is null-terminated.
char payload_copy[256];
u_int16_t max_copy_len = flow_packet->payload_packet_len > sizeof(payload_copy) - 1 ? 
                         sizeof(payload_copy) - 1 : flow_packet->payload_packet_len;

if (max_copy_len > 0) {
  memcpy(payload_copy, flow_packet->payload, max_copy_len);
  payload_copy[max_copy_len] = '\0';
  
  // Locate the first double quote character, marking the start of the username.
  u_int16_t username_start_pos = 0;
  for (u_int16_t i = command_start + 6; i < max_copy_len; i++) {
    if (payload_copy[i] == '"') {
      username_start_pos = i + 1;
      break;
    }
  }
  
  // Find the next double quote to identify the end of the username and store it.
  if (username_start_pos > 0 && username_start_pos < max_copy_len) {
    u_int16_t username_end_pos = 0;
    for (u_int16_t i = username_start_pos; i < max_copy_len; i++) {
      if (payload_copy[i] == '"') {
        username_end_pos = i;
        break;
      }
    }
    
    if (username_end_pos > username_start_pos) {
      u_int16_t username_len = username_end_pos - username_start_pos;
      if (username_len < sizeof(flow->protos.ftp_imap_pop_smtp.username) - 1) {
        memcpy(flow->protos.ftp_imap_pop_smtp.username, &payload_copy[username_start_pos], username_len);
        flow->protos.ftp_imap_pop_smtp.username[username_len] = '\0';
      } else {
        // Handle the case where username is too long
        memcpy(flow->protos.ftp_imap_pop_smtp.username, &payload_copy[username_start_pos], 
               sizeof(flow->protos.ftp_imap_pop_smtp.username) - 1);
        flow->protos.ftp_imap_pop_smtp.username[sizeof(flow->protos.ftp_imap_pop_smtp.username) - 1] = '\0';
      }
      
      // Locate the next pair of double quotes to extract the password and store it.
      u_int16_t password_start_pos = 0;
      for (u_int16_t i = username_end_pos + 1; i < max_copy_len; i++) {
        if (payload_copy[i] == '"') {
          password_start_pos = i + 1;
          break;
        }
      }
      
      if (password_start_pos > 0 && password_start_pos < max_copy_len) {
        u_int16_t password_end_pos = 0;
        for (u_int16_t i = password_start_pos; i < max_copy_len; i++) {
          if (payload_copy[i] == '"') {
            password_end_pos = i;
            break;
          }
        }
        
        if (password_end_pos > password_start_pos) {
          u_int16_t password_len = password_end_pos - password_start_pos;
          if (password_len < sizeof(flow->protos.ftp_imap_pop_smtp.password) - 1) {
            memcpy(flow->protos.ftp_imap_pop_smtp.password, &payload_copy[password_start_pos], password_len);
            flow->protos.ftp_imap_pop_smtp.password[password_len] = '\0';
          } else {
            // Handle the case where password is too long
            memcpy(flow->protos.ftp_imap_pop_smtp.password, &payload_copy[password_start_pos], 
                   sizeof(flow->protos.ftp_imap_pop_smtp.password) - 1);
            flow->protos.ftp_imap_pop_smtp.password[sizeof(flow->protos.ftp_imap_pop_smtp.password) - 1] = '\0';
          }
        }
      }
    }
  }
}