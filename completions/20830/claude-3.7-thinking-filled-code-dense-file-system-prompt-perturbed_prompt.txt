Below is the content of a C/C++ function where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
void ndpi_search_mail_imap_tcp(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow)
{
  struct ndpi_packet_struct *flow_packet = &flow->packet;       
  u_int16_t i = 0;
  u_int16_t space_pos = 0;
  u_int16_t command_start = 0;
  u_int8_t saw_command = 0;
  /* const u_int8_t *command = 0; */

  NDPI_LOG_DBG(ndpi_struct, "search IMAP_IMAP\n");

#ifdef IMAP_DEBUG
  printf("%s() [%s]\n", __FUNCTION__, flow_packet->payload);
#endif

  if(flow->l4.tcp.mail_imap_starttls == 2) {
    NDPI_LOG_DBG2(ndpi_struct, "starttls detected\n");
    NDPI_ADD_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, NDPI_PROTOCOL_MAIL_IMAP);
    NDPI_DEL_PROTOCOL_FROM_BITMASK(flow->excluded_protocol_bitmask, NDPI_PROTOCOL_TLS);
    return;
  }

  if(flow_packet->payload_packet_len >= 4 && ntohs(get_u_int16_t(flow_packet->payload, flow_packet->payload_packet_len - 2)) == 0x0d0a) {
    // the DONE command appears without a tag
    if(flow_packet->payload_packet_len == 6 && ((flow_packet->payload[0] == 'D' || flow_packet->payload[0] == 'd')
					    && (flow_packet->payload[1] == 'O' || flow_packet->payload[1] == 'o')
					    && (flow_packet->payload[2] == 'N' || flow_packet->payload[2] == 'n')
					    && (flow_packet->payload[3] == 'E' || flow_packet->payload[3] == 'e'))) {
      flow->l4.tcp.mail_imap_stage += 1;
      saw_command = 1;
    } else {

      if(flow->l4.tcp.mail_imap_stage < 4) {
	// search for the first space character (end of the tag)
	while (i < 20 && i < flow_packet->payload_packet_len) {
	  if(i > 0 && flow_packet->payload[i] == ' ') {
	    space_pos = i;
	    break;
	  }
	  if(!((flow_packet->payload[i] >= 'a' && flow_packet->payload[i] <= 'z') ||
		(flow_packet->payload[i] >= 'A' && flow_packet->payload[i] <= 'Z') ||
		(flow_packet->payload[i] >= '0' && flow_packet->payload[i] <= '9') || flow_packet->payload[i] == '*' || flow_packet->payload[i] == '.')) {
	    goto imap_excluded;
	  }
	  i++;
	}
	if(space_pos == 0 || space_pos == (flow_packet->payload_packet_len - 1)) {
	  goto imap_excluded;
	}
	// now walk over a possible mail number to the next space
	i++;
	if(i < flow_packet->payload_packet_len && (flow_packet->payload[i] >= '0' && flow_packet->payload[i] <= '9')) {
	  while (i < 20 && i < flow_packet->payload_packet_len) {
	    if(i > 0 && flow_packet->payload[i] == ' ') {
	      space_pos = i;
	      break;
	    }
	    if(!(flow_packet->payload[i] >= '0' && flow_packet->payload[i] <= '9')) {
	      goto imap_excluded;
	    }
	    i++;
	  }
	  if(space_pos == 0 || space_pos == (flow_packet->payload_packet_len - 1)) {
	    goto imap_excluded;
	  }
	}
	command_start = space_pos + 1;
	/* command = &(packet->payload[command_start]); */
      } else {
	command_start = 0;
	/* command = &(packet->payload[command_start]); */
      }

      if((command_start + 3) < flow_packet->payload_packet_len) {
	if((flow_packet->payload[command_start] == 'O' || flow_packet->payload[command_start] == 'o')
	    && (flow_packet->payload[command_start + 1] == 'K' || flow_packet->payload[command_start + 1] == 'k')
	    && flow_packet->payload[command_start + 2] == ' ') {
	  flow->l4.tcp.mail_imap_stage += 1;
	  if(flow->l4.tcp.mail_imap_starttls == 1)
	    flow->l4.tcp.mail_imap_starttls = 2;
	  saw_command = 1;
	} else if((flow_packet->payload[command_start] == 'U' || flow_packet->payload[command_start] == 'u')
		   && (flow_packet->payload[command_start + 1] == 'I' || flow_packet->payload[command_start + 1] == 'i')
		   && (flow_packet->payload[command_start + 2] == 'D' || flow_packet->payload[command_start + 2] == 'd')) {
	  flow->l4.tcp.mail_imap_stage += 1;
	  saw_command = 1;
	}
      }
      if((command_start + 10) < flow_packet->payload_packet_len) {
	if((flow_packet->payload[command_start] == 'C' || flow_packet->payload[command_start] == 'c')
	    && (flow_packet->payload[command_start + 1] == 'A' || flow_packet->payload[command_start + 1] == 'a')
	    && (flow_packet->payload[command_start + 2] == 'P' || flow_packet->payload[command_start + 2] == 'p')
	    && (flow_packet->payload[command_start + 3] == 'A' || flow_packet->payload[command_start + 3] == 'a')
	    && (flow_packet->payload[command_start + 4] == 'B' || flow_packet->payload[command_start + 4] == 'b')
	    && (flow_packet->payload[command_start + 5] == 'I' || flow_packet->payload[command_start + 5] == 'i')
	    && (flow_packet->payload[command_start + 6] == 'L' || flow_packet->payload[command_start + 6] == 'l')
	    && (flow_packet->payload[command_start + 7] == 'I' || flow_packet->payload[command_start + 7] == 'i')
	    && (flow_packet->payload[command_start + 8] == 'T' || flow_packet->payload[command_start + 8] == 't')
	    && (flow_packet->payload[command_start + 9] == 'Y' || flow_packet->payload[command_start + 9] == 'y')) {
	  flow->l4.tcp.mail_imap_stage += 1;
	  saw_command = 1;
	}
      }
      if((command_start + 8) < flow_packet->payload_packet_len) {
	if((flow_packet->payload[command_start] == 'S' || flow_packet->payload[command_start] == 's')
	    && (flow_packet->payload[command_start + 1] == 'T' || flow_packet->payload[command_start + 1] == 't')
	    && (flow_packet->payload[command_start + 2] == 'A' || flow_packet->payload[command_start + 2] == 'a')
	    && (flow_packet->payload[command_start + 3] == 'R' || flow_packet->payload[command_start + 3] == 'r')
	    && (flow_packet->payload[command_start + 4] == 'T' || flow_packet->payload[command_start + 4] == 't')
	    && (flow_packet->payload[command_start + 5] == 'T' || flow_packet->payload[command_start + 5] == 't')
	    && (flow_packet->payload[command_start + 6] == 'L' || flow_packet->payload[command_start + 6] == 'l')
	    && (flow_packet->payload[command_start + 7] == 'S' || flow_packet->payload[command_start + 7] == 's')) {
        flow->l4.tcp.mail_imap_stage += 1;
        flow->l4.tcp.mail_imap_starttls = 1;
        flow->detected_protocol_stack[0] = NDPI_PROTOCOL_MAIL_IMAPS;
        saw_command = 1;
	}
      }
      if((command_start + 5) < flow_packet->payload_packet_len) {
	if((flow_packet->payload[command_start] == 'L' || flow_packet->payload[command_start] == 'l')
	    && (flow_packet->payload[command_start + 1] == 'O' || flow_packet->payload[command_start + 1] == 'o')
	    && (flow_packet->payload[command_start + 2] == 'G' || flow_packet->payload[command_start + 2] == 'g')
	    && (flow_packet->payload[command_start + 3] == 'I' || flow_packet->payload[command_start + 3] == 'i')
	    && (flow_packet->payload[command_start + 4] == 'N' || flow_packet->payload[command_start + 4] == 'n')) {
	  // Extract and store the "username" and "password" from the IMAP LOGIN command.
	  // Copy the packet payload into a temporary string buffer.
	  // Ensure the copied string is null-terminated.
	  // Locate the first double quote character, marking the start of the username.
	  // Find the next double quote to identify the end of the username and store it.
	  // Locate the next pair of double quotes to extract the password and store it.
	  // The extracted username and password are stored within the flow structure.
	  // <MASK>
	  
	  flow->l4.tcp.mail_imap_stage += 1;
	  saw_command = 1;
	} else if((flow_packet->payload[command_start] == 'F' || flow_packet->payload[command_start] == 'f')
		   && (flow_packet->payload[command_start + 1] == 'E' || flow_packet->payload[command_start + 1] == 'e')
		   && (flow_packet->payload[command_start + 2] == 'T' || flow_packet->payload[command_start + 2] == 't')
		   && (flow_packet->payload[command_start + 3] == 'C' || flow_packet->payload[command_start + 3] == 'c')
		   && (flow_packet->payload[command_start + 4] == 'H' || flow_packet->payload[command_start + 4] == 'h')) {
	  flow->l4.tcp.mail_imap_stage += 1;
	  saw_command = 1;
	} else if((flow_packet->payload[command_start] == 'F' || flow_packet->payload[command_start] == 'f')
		   && (flow_packet->payload[command_start + 1] == 'L' || flow_packet->payload[command_start + 1] == 'l')
		   && (flow_packet->payload[command_start + 2] == 'A' || flow_packet->payload[command_start + 2] == 'a')
		   && (flow_packet->payload[command_start + 3] == 'G' || flow_packet->payload[command_start + 3] == 'g')
		   && (flow_packet->payload[command_start + 4] == 'S' || flow_packet->payload[command_start + 4] == 's')) {
	  flow->l4.tcp.mail_imap_stage += 1;
	  saw_command = 1;
	} else if((flow_packet->payload[command_start] == 'C' || flow_packet->payload[command_start] == 'c')
		   && (flow_packet->payload[command_start + 1] == 'H' || flow_packet->payload[command_start + 1] == 'h')
		   && (flow_packet->payload[command_start + 2] == 'E' || flow_packet->payload[command_start + 2] == 'e')
		   && (flow_packet->payload[command_start + 3] == 'C' || flow_packet->payload[command_start + 3] == 'c')
		   && (flow_packet->payload[command_start + 4] == 'K' || flow_packet->payload[command_start + 4] == 'k')) {
	  flow->l4.tcp.mail_imap_stage += 1;
	  saw_command = 1;
	} else if((flow_packet->payload[command_start] == 'S' || flow_packet->payload[command_start] == 's')
		   && (flow_packet->payload[command_start + 1] == 'T' || flow_packet->payload[command_start + 1] == 't')
		   && (flow_packet->payload[command_start + 2] == 'O' || flow_packet->payload[command_start + 2] == 'o')
		   && (flow_packet->payload[command_start + 3] == 'R' || flow_packet->payload[command_start + 3] == 'r')
		   && (flow_packet->payload[command_start + 4] == 'E' || flow_packet->payload[command_start + 4] == 'e')) {
	  flow->l4.tcp.mail_imap_stage += 1;
	  saw_command = 1;
	}
      }
      if((command_start + 12) < flow_packet->payload_packet_len) {
	if((flow_packet->payload[command_start] == 'A' || flow_packet->payload[command_start] == 'a')
	    && (flow_packet->payload[command_start + 1] == 'U' || flow_packet->payload[command_start + 1] == 'u')
	    && (flow_packet->payload[command_start + 2] == 'T' || flow_packet->payload[command_start + 2] == 't')
	    && (flow_packet->payload[command_start + 3] == 'H' || flow_packet->payload[command_start + 3] == 'h')
	    && (flow_packet->payload[command_start + 4] == 'E' || flow_packet->payload[command_start + 4] == 'e')
	    && (flow_packet->payload[command_start + 5] == 'N' || flow_packet->payload[command_start + 5] == 'n')
	    && (flow_packet->payload[command_start + 6] == 'T' || flow_packet->payload[command_start + 6] == 't')
	    && (flow_packet->payload[command_start + 7] == 'I' || flow_packet->payload[command_start + 7] == 'i')
	    && (flow_packet->payload[command_start + 8] == 'C' || flow_packet->payload[command_start + 8] == 'c')
	    && (flow_packet->payload[command_start + 9] == 'A' || flow_packet->payload[command_start + 9] == 'a')
	    && (flow_packet->payload[command_start + 10] == 'T' || flow_packet->payload[command_start + 10] == 't')
	    && (flow_packet->payload[command_start + 11] == 'E' || flow_packet->payload[command_start + 11] == 'e')) {
	  flow->l4.tcp.mail_imap_stage += 1;
	  saw_command = 1;
	}
      }
      if((command_start + 9) < flow_packet->payload_packet_len) {
	if((flow_packet->payload[command_start] == 'N' || flow_packet->payload[command_start] == 'n')
	    && (flow_packet->payload[command_start + 1] == 'A' || flow_packet->payload[command_start + 1] == 'a')
	    && (flow_packet->payload[command_start + 2] == 'M' || flow_packet->payload[command_start + 2] == 'm')
	    && (flow_packet->payload[command_start + 3] == 'E' || flow_packet->payload[command_start + 3] == 'e')
	    && (flow_packet->payload[command_start + 4] == 'S' || flow_packet->payload[command_start + 4] == 's')
	    && (flow_packet->payload[command_start + 5] == 'P' || flow_packet->payload[command_start + 5] == 'p')
	    && (flow_packet->payload[command_start + 6] == 'A' || flow_packet->payload[command_start + 6] == 'a')
	    && (flow_packet->payload[command_start + 7] == 'C' || flow_packet->payload[command_start + 7] == 'c')
	    && (flow_packet->payload[command_start + 8] == 'E' || flow_packet->payload[command_start + 8] == 'e')) {
	  flow->l4.tcp.mail_imap_stage += 1;
	  saw_command = 1;
	}
      }
      if((command_start + 4) < flow_packet->payload_packet_len) {
	if((flow_packet->payload[command_start] == 'L' || flow_packet->payload[command_start] == 'l')
	    && (flow_packet->payload[command_start + 1] == 'S' || flow_packet->payload[command_start + 1] == 's')
	    && (flow_packet->payload[command_start + 2] == 'U' || flow_packet->payload[command_start + 2] == 'u')
	    && (flow_packet->payload[command_start + 3] == 'B' || flow_packet->payload[command_start + 3] == 'b')) {
	  flow->l4.tcp.mail_imap_stage += 1;
	  saw_command = 1;
	} else if((flow_packet->payload[command_start] == 'L' || flow_packet->payload[command_start] == 'l')
		   && (flow_packet->payload[command_start + 1] == 'I' || flow_packet->payload[command_start + 1] == 'i')
		   && (flow_packet->payload[command_start + 2] == 'S' || flow_packet->payload[command_start + 2] == 's')
		   && (flow_packet->payload[command_start + 3] == 'T' || flow_packet->payload[command_start + 3] == 't')) {
	  flow->l4.tcp.mail_imap_stage += 1;
	  saw_command = 1;
	} else if((flow_packet->payload[command_start] == 'N' || flow_packet->payload[command_start] == 'n')
		   && (flow_packet->payload[command_start + 1] == 'O' || flow_packet->payload[command_start + 1] == 'o')
		   && (flow_packet->payload[command_start + 2] == 'O' || flow_packet->payload[command_start + 2] == 'o')
		   && (flow_packet->payload[command_start + 3] == 'P' || flow_packet->payload[command_start + 3] == 'p')) {
	  flow->l4.tcp.mail_imap_stage += 1;
	  saw_command = 1;
	} else if((flow_packet->payload[command_start] == 'I' || flow_packet->payload[command_start] == 'i')
		   && (flow_packet->payload[command_start + 1] == 'D' || flow_packet->payload[command_start + 1] == 'd')
		   && (flow_packet->payload[command_start + 2] == 'L' || flow_packet->payload[command_start + 2] == 'l')
		   && (flow_packet->payload[command_start + 3] == 'E' || flow_packet->payload[command_start + 3] == 'e')) {
	  flow->l4.tcp.mail_imap_stage += 1;
	  saw_command = 1;
	}
      }
      if((command_start + 6) < flow_packet->payload_packet_len) {
	if((flow_packet->payload[command_start] == 'S' || flow_packet->payload[command_start] == 's')
	    && (flow_packet->payload[command_start + 1] == 'E' || flow_packet->payload[command_start + 1] == 'e')
	    && (flow_packet->payload[command_start + 2] == 'L' || flow_packet->payload[command_start + 2] == 'l')
	    && (flow_packet->payload[command_start + 3] == 'E' || flow_packet->payload[command_start + 3] == 'e')
	    && (flow_packet->payload[command_start + 4] == 'C' || flow_packet->payload[command_start + 4] == 'c')
	    && (flow_packet->payload[command_start + 5] == 'T' || flow_packet->payload[command_start + 5] == 't')) {
	  flow->l4.tcp.mail_imap_stage += 1;
	  saw_command = 1;
	} else if((flow_packet->payload[command_start] == 'E' || flow_packet->payload[command_start] == 'e')
		   && (flow_packet->payload[command_start + 1] == 'X' || flow_packet->payload[command_start + 1] == 'x')
		   && (flow_packet->payload[command_start + 2] == 'I' || flow_packet->payload[command_start + 2] == 'i')
		   && (flow_packet->payload[command_start + 3] == 'S' || flow_packet->payload[command_start + 3] == 's')
		   && (flow_packet->payload[command_start + 4] == 'T' || flow_packet->payload[command_start + 4] == 't')
		   && (flow_packet->payload[command_start + 5] == 'S' || flow_packet->payload[command_start + 5] == 's')) {
	  flow->l4.tcp.mail_imap_stage += 1;
	  saw_command = 1;
	} else if((flow_packet->payload[command_start] == 'A' || flow_packet->payload[command_start] == 'a')
		   && (flow_packet->payload[command_start + 1] == 'P' || flow_packet->payload[command_start + 1] == 'p')
		   && (flow_packet->payload[command_start + 2] == 'P' || flow_packet->payload[command_start + 2] == 'p')
		   && (flow_packet->payload[command_start + 3] == 'E' || flow_packet->payload[command_start + 3] == 'e')
		   && (flow_packet->payload[command_start + 4] == 'N' || flow_packet->payload[command_start + 4] == 'n')
		   && (flow_packet->payload[command_start + 5] == 'D' || flow_packet->payload[command_start + 5] == 'd')) {
	  flow->l4.tcp.mail_imap_stage += 1;
	  saw_command = 1;
	}
      }

    }

    if(saw_command == 1) {
      if((flow->l4.tcp.mail_imap_stage == 3)
	 || (flow->l4.tcp.mail_imap_stage == 5)
	 || (flow->l4.tcp.mail_imap_stage == 7)
	 ) {
	if((flow->protos.ftp_imap_pop_smtp.username[0] != '\0')
	   || (flow->l4.tcp.mail_imap_stage >= 7)) {
	  NDPI_LOG_INFO(ndpi_struct, "found MAIL_IMAP\n");
	  ndpi_int_mail_imap_add_connection(ndpi_struct, flow);
	}
	
	return;
      }
    }
  }

  if(flow_packet->payload_packet_len > 1 && flow_packet->payload[flow_packet->payload_packet_len - 1] == ' ') {
    NDPI_LOG_DBG2(ndpi_struct,
	     "maybe a split imap command -> need next packet and imap_stage is set to 4.\n");
    flow->l4.tcp.mail_imap_stage = 4;
    return;
  }

 imap_excluded:

  // skip over possible authentication hashes etc. that cannot be identified as imap commands or responses
  // if the packet count is low enough and at least one command or response was seen before
  if((flow_packet->payload_packet_len >= 2 && ntohs(get_u_int16_t(flow_packet->payload, flow_packet->payload_packet_len - 2)) == 0x0d0a)
      && flow->packet_counter < 6 && flow->l4.tcp.mail_imap_stage >= 1) {
    NDPI_LOG_DBG2(ndpi_struct,
	     "no imap command or response but packet count < 6 and imap stage >= 1 -> skip\n");
    return;
  }

  NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/lib/protocols/mail_smtp.c
void ndpi_search_mail_smtp_tcp(struct ndpi_detection_module_struct *ndpi_struct,
			       struct ndpi_flow_struct *flow) {
  struct ndpi_packet_struct *packet = &flow->packet;

  NDPI_LOG_DBG(ndpi_struct, "search mail_smtp\n");

  if((packet->payload_packet_len > 2)
     && (packet->parsed_lines <  NDPI_MAX_PARSE_LINES_PER_PACKET)
     && (ntohs(get_u_int16_t(packet->payload, packet->payload_packet_len - 2)) == 0x0d0a)
     ) {
    u_int16_t a;
    u_int8_t bit_count = 0;

    NDPI_PARSE_PACKET_LINE_INFO(ndpi_struct, flow, packet);

    for(a = 0; a < packet->parsed_lines; a++) {
      // expected server responses
      if(packet->line[a].len >= 3) {
	if(memcmp(packet->line[a].ptr, "220", 3) == 0) {
	  flow->l4.tcp.smtp_command_bitmask |= SMTP_BIT_220;
	} else if(memcmp(packet->line[a].ptr, "250", 3) == 0) {
	  flow->l4.tcp.smtp_command_bitmask |= SMTP_BIT_250;
	} else if(memcmp(packet->line[a].ptr, "235", 3) == 0) {
	  flow->l4.tcp.smtp_command_bitmask |= SMTP_BIT_235;
	} else if(memcmp(packet->line[a].ptr, "334", 3) == 0) {
	  flow->l4.tcp.smtp_command_bitmask |= SMTP_BIT_334;
	} else if(memcmp(packet->line[a].ptr, "354", 3) == 0) {
	  flow->l4.tcp.smtp_command_bitmask |= SMTP_BIT_354;
	}
      }

      // expected client requests
      if(packet->line[a].len >= 5) {
	if((((packet->line[a].ptr[0] == 'H' || packet->line[a].ptr[0] == 'h')
	     && (packet->line[a].ptr[1] == 'E' || packet->line[a].ptr[1] == 'e'))
	    || ((packet->line[a].ptr[0] == 'E' || packet->line[a].ptr[0] == 'e')
		&& (packet->line[a].ptr[1] == 'H' || packet->line[a].ptr[1] == 'h')))
	   && (packet->line[a].ptr[2] == 'L' || packet->line[a].ptr[2] == 'l')
	   && (packet->line[a].ptr[3] == 'O' || packet->line[a].ptr[3] == 'o')
	   && packet->line[a].ptr[4] == ' ') {
	  flow->l4.tcp.smtp_command_bitmask |= SMTP_BIT_HELO_EHLO;
	  flow->protos.ftp_imap_pop_smtp.auth_found = 0;
	} else if((packet->line[a].ptr[0] == 'M' || packet->line[a].ptr[0] == 'm')
		  && (packet->line[a].ptr[1] == 'A' || packet->line[a].ptr[1] == 'a')
		  && (packet->line[a].ptr[2] == 'I' || packet->line[a].ptr[2] == 'i')
		  && (packet->line[a].ptr[3] == 'L' || packet->line[a].ptr[3] == 'l')
		  && packet->line[a].ptr[4] == ' ') {
	  flow->l4.tcp.smtp_command_bitmask |= SMTP_BIT_MAIL;
	  flow->protos.ftp_imap_pop_smtp.auth_found = 0;
	} else if((packet->line[a].ptr[0] == 'R' || packet->line[a].ptr[0] == 'r')
		  && (packet->line[a].ptr[1] == 'C' || packet->line[a].ptr[1] == 'c')
		  && (packet->line[a].ptr[2] == 'P' || packet->line[a].ptr[2] == 'p')
		  && (packet->line[a].ptr[3] == 'T' || packet->line[a].ptr[3] == 't')
		  && packet->line[a].ptr[4] == ' ') {
	  flow->l4.tcp.smtp_command_bitmask |= SMTP_BIT_RCPT;
	  flow->protos.ftp_imap_pop_smtp.auth_found = 0;
	} else if((packet->line[a].ptr[0] == 'A' || packet->line[a].ptr[0] == 'a')
		  && (packet->line[a].ptr[1] == 'U' || packet->line[a].ptr[1] == 'u')
		  && (packet->line[a].ptr[2] == 'T' || packet->line[a].ptr[2] == 't')
		  && (packet->line[a].ptr[3] == 'H' || packet->line[a].ptr[3] == 'h')
		  && packet->line[a].ptr[4] == ' ') {
#ifdef SMTP_DEBUG
	  printf("%s() AUTH [%s]\n", __FUNCTION__, packet->line[a].ptr);
#endif

	  flow->l4.tcp.smtp_command_bitmask |= SMTP_BIT_AUTH;
	  flow->protos.ftp_imap_pop_smtp.auth_found = 1;
	} else {
	  if(packet->line[a].ptr[3] != ' ') {
#ifdef SMTP_DEBUG
	    printf("%s() => [%s]\n", __FUNCTION__, packet->line[a].ptr);
#endif
	    
	    if(flow->protos.ftp_imap_pop_smtp.auth_found) {
	      if(flow->protos.ftp_imap_pop_smtp.username[0] == '\0') {
		/* Username */
		u_int8_t buf[48];
		u_char *out;
		size_t out_len;

		ndpi_user_pwd_payload_copy(buf, sizeof(buf), 0,
					   packet->line[a].ptr, packet->line[a].len);

#ifdef SMTP_DEBUG
		printf("%s() => [auth: %u] (username) [%s]\n", __FUNCTION__, flow->protos.ftp_imap_pop_smtp.auth_found, buf);
#endif

		out = ndpi_base64_decode((const u_char*)buf, (size_t)strlen((const char*)buf), &out_len);

		if(out) {
		  size_t len = ndpi_min(out_len, sizeof(flow->protos.ftp_imap_pop_smtp.username) - 1);

		  memcpy(flow->protos.ftp_imap_pop_smtp.username, out, len);
		  flow->protos.ftp_imap_pop_smtp.username[len] = '\0';
		  
		  ndpi_free(out);
		}
	      } else if(flow->protos.ftp_imap_pop_smtp.password[0] == '\0') {
		/* Password */
		u_int8_t buf[48];
		u_char *out;
		size_t out_len;

		ndpi_user_pwd_payload_copy(buf, sizeof(buf), 0,
					   packet->line[a].ptr, packet->line[a].len);

#ifdef SMTP_DEBUG
		printf("%s() => [auth: %u] (password) [%s]\n", __FUNCTION__, flow->protos.ftp_imap_pop_smtp.auth_found, buf);
#endif

		out = ndpi_base64_decode((const u_char*)buf, (size_t)strlen((const char*)buf), &out_len);

		if(out) {
		  size_t len = ndpi_min(out_len, sizeof(flow->protos.ftp_imap_pop_smtp.password) - 1);

		  memcpy(flow->protos.ftp_imap_pop_smtp.password, out, len);
		  flow->protos.ftp_imap_pop_smtp.password[len] = '\0';

		  ndpi_free(out);
		}
	      } else {
		NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
		return;
	      }
	    }
	  }
	}
      }

      if(packet->line[a].len >= 8) {
	if((packet->line[a].ptr[0] == 'S' || packet->line[a].ptr[0] == 's')
	   && (packet->line[a].ptr[1] == 'T' || packet->line[a].ptr[1] == 't')
	   && (packet->line[a].ptr[2] == 'A' || packet->line[a].ptr[2] == 'a')
	   && (packet->line[a].ptr[3] == 'R' || packet->line[a].ptr[3] == 'r')
	   && (packet->line[a].ptr[4] == 'T' || packet->line[a].ptr[4] == 't')
	   && (packet->line[a].ptr[5] == 'T' || packet->line[a].ptr[5] == 't')
	   && (packet->line[a].ptr[6] == 'L' || packet->line[a].ptr[6] == 'l')
	   && (packet->line[a].ptr[7] == 'S' || packet->line[a].ptr[7] == 's')) {
	  flow->l4.tcp.smtp_command_bitmask |= SMTP_BIT_STARTTLS;
	}
      }

      if(packet->line[a].len >= 4) {
	if((packet->line[a].ptr[0] == 'D' || packet->line[a].ptr[0] == 'd')
	   && (packet->line[a].ptr[1] == 'A' || packet->line[a].ptr[1] == 'a')
	   && (packet->line[a].ptr[2] == 'T' || packet->line[a].ptr[2] == 't')
	   && (packet->line[a].ptr[3] == 'A' || packet->line[a].ptr[3] == 'a')) {
	  flow->l4.tcp.smtp_command_bitmask |= SMTP_BIT_DATA;
	} else if((packet->line[a].ptr[0] == 'N' || packet->line[a].ptr[0] == 'n')
		  && (packet->line[a].ptr[1] == 'O' || packet->line[a].ptr[1] == 'o')
		  && (packet->line[a].ptr[2] == 'O' || packet->line[a].ptr[2] == 'o')
		  && (packet->line[a].ptr[3] == 'P' || packet->line[a].ptr[3] == 'p')) {
	  flow->l4.tcp.smtp_command_bitmask |= SMTP_BIT_NOOP;
	} else if((packet->line[a].ptr[0] == 'R' || packet->line[a].ptr[0] == 'r')
		  && (packet->line[a].ptr[1] == 'S' || packet->line[a].ptr[1] == 's')
		  && (packet->line[a].ptr[2] == 'E' || packet->line[a].ptr[2] == 'e')
		  && (packet->line[a].ptr[3] == 'T' || packet->line[a].ptr[3] == 't')) {
	  flow->l4.tcp.smtp_command_bitmask |= SMTP_BIT_RSET;
	}
      }
    }

    // now count the bits set in the bitmask
    if(flow->l4.tcp.smtp_command_bitmask != 0) {
      for(a = 0; a < 16; a++) {
	bit_count += (flow->l4.tcp.smtp_command_bitmask >> a) & 0x01;
      }
    }
    NDPI_LOG_DBG2(ndpi_struct, "seen smtp commands and responses: %u\n",
		  bit_count);

    if(bit_count >= 3) {
      NDPI_LOG_INFO(ndpi_struct, "mail smtp identified\n");

#ifdef SMTP_DEBUG
      printf("%s() [bit_count: %u][%s]\n", __FUNCTION__,
	     bit_count, flow->protos.ftp_imap_pop_smtp.password);
#endif

      ndpi_int_mail_smtp_add_connection(ndpi_struct, flow);
      smtpInitExtraPacketProcessing(flow);      
      return;
    }

    if(bit_count >= 1 && flow->packet_counter < 12) {
      return;
    }
  }

  /* when the first or second packets are split into two packets, those packets are ignored. */
  if(flow->packet_counter <= 4 &&
     packet->payload_packet_len >= 4 &&
     (ntohs(get_u_int16_t(packet->payload, packet->payload_packet_len - 2)) == 0x0d0a
      || memcmp(packet->payload, "220", 3) == 0 || memcmp(packet->payload, "EHLO", 4) == 0)) {
    NDPI_LOG_DBG2(ndpi_struct, "maybe SMTP, need next packet\n");
    return;
  }

  if(!flow->check_extra_packets)
    NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
}

// the below code fragment can be found in:
// src/lib/protocols/mail_pop.c
void ndpi_search_mail_pop_tcp(struct ndpi_detection_module_struct
			      *ndpi_struct, struct ndpi_flow_struct *flow)
{
  struct ndpi_packet_struct *packet = &flow->packet;
  u_int8_t a = 0;
  u_int8_t bit_count = 0;

  NDPI_LOG_DBG(ndpi_struct, "search mail_pop\n");

  if((packet->payload_packet_len > 3
       && (packet->payload[0] == '+' && (packet->payload[1] == 'O' || packet->payload[1] == 'o')
	   && (packet->payload[2] == 'K' || packet->payload[2] == 'k')))
      || (packet->payload_packet_len > 4
	  && (packet->payload[0] == '-' && (packet->payload[1] == 'E' || packet->payload[1] == 'e')
	      && (packet->payload[2] == 'R' || packet->payload[2] == 'r')
	      && (packet->payload[3] == 'R' || packet->payload[3] == 'r')))) {
    // +OK or -ERR seen
    flow->l4.tcp.mail_pop_stage += 1;
  } else if(!ndpi_int_mail_pop_check_for_client_commands(ndpi_struct, flow)) {
    goto maybe_split_pop;
  }

  if(packet->payload_packet_len > 2 && ntohs(get_u_int16_t(packet->payload, packet->payload_packet_len - 2)) == 0x0d0a) {
    // count the bits set in the bitmask
    if(flow->l4.tcp.pop_command_bitmask != 0) {
      for (a = 0; a < 16; a++) {
	bit_count += (flow->l4.tcp.pop_command_bitmask >> a) & 0x01;
      }
    }

    NDPI_LOG_DBG2(ndpi_struct,
		  "mail_pop +OK/-ERR responses: %u, unique commands: %u\n",
		  flow->l4.tcp.mail_pop_stage, bit_count);

    if((bit_count + flow->l4.tcp.mail_pop_stage) >= 3) {
      if(flow->l4.tcp.mail_pop_stage > 0) {
	NDPI_LOG_INFO(ndpi_struct, "mail_pop identified\n");
	
	if((flow->protos.ftp_imap_pop_smtp.password[0] != '\0')
	   || (flow->l4.tcp.mail_pop_stage > 3)) {
	  ndpi_int_mail_pop_add_connection(ndpi_struct, flow);
	  popInitExtraPacketProcessing(flow);
	}
      }
      
      return;      
    } else
      return;    
  } else {
    // first part of a split packet
    NDPI_LOG_DBG2(ndpi_struct,
		  "mail_pop command without line ending -> skip\n");
    return;
  }


 maybe_split_pop:

  if(((packet->payload_packet_len > 2 && ntohs(get_u_int16_t(packet->payload, packet->payload_packet_len - 2)) == 0x0d0a)
       || flow->l4.tcp.pop_command_bitmask != 0 || flow->l4.tcp.mail_pop_stage != 0) && flow->packet_counter < 12) {
    // maybe part of a split pop packet
    NDPI_LOG_DBG2(ndpi_struct,
		  "maybe part of split mail_pop packet -> skip\n");
    return;
  }

  NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
}

// the below code fragment can be found in:
// src/lib/protocols/mail_pop.c
static int ndpi_int_mail_pop_check_for_client_commands(struct ndpi_detection_module_struct
						       *ndpi_struct, struct ndpi_flow_struct *flow) {
  struct ndpi_packet_struct *packet = &flow->packet;
	
  if(packet->payload_packet_len > 4) {
    if((packet->payload[0] == 'A' || packet->payload[0] == 'a')
	&& (packet->payload[1] == 'U' || packet->payload[1] == 'u')
	&& (packet->payload[2] == 'T' || packet->payload[2] == 't')
	&& (packet->payload[3] == 'H' || packet->payload[3] == 'h')) {
      flow->l4.tcp.pop_command_bitmask |= POP_BIT_AUTH;
      return 1;
    } else if((packet->payload[0] == 'A' || packet->payload[0] == 'a')
	       && (packet->payload[1] == 'P' || packet->payload[1] == 'p')
	       && (packet->payload[2] == 'O' || packet->payload[2] == 'o')
	       && (packet->payload[3] == 'P' || packet->payload[3] == 'p')) {
      flow->l4.tcp.pop_command_bitmask |= POP_BIT_APOP;
      return 1;
    } else if((packet->payload[0] == 'U' || packet->payload[0] == 'u')
	       && (packet->payload[1] == 'S' || packet->payload[1] == 's')
	       && (packet->payload[2] == 'E' || packet->payload[2] == 'e')
	       && (packet->payload[3] == 'R' || packet->payload[3] == 'r')) {
      ndpi_user_pwd_payload_copy((u_int8_t*)flow->protos.ftp_imap_pop_smtp.username,
				 sizeof(flow->protos.ftp_imap_pop_smtp.username), 5,
				 packet->payload, packet->payload_packet_len);
      
      flow->l4.tcp.pop_command_bitmask |= POP_BIT_USER;
      return 1;
    } else if((packet->payload[0] == 'P' || packet->payload[0] == 'p')
	      && (packet->payload[1] == 'A' || packet->payload[1] == 'a')
	      && (packet->payload[2] == 'S' || packet->payload[2] == 's')
	      && (packet->payload[3] == 'S' || packet->payload[3] == 's')) {
      ndpi_user_pwd_payload_copy((u_int8_t*)flow->protos.ftp_imap_pop_smtp.password,
				 sizeof(flow->protos.ftp_imap_pop_smtp.password), 5,
				 packet->payload, packet->payload_packet_len);
      
      flow->l4.tcp.pop_command_bitmask |= POP_BIT_PASS;
      return 1;
    } else if((packet->payload[0] == 'C' || packet->payload[0] == 'c')
	       && (packet->payload[1] == 'A' || packet->payload[1] == 'a')
	       && (packet->payload[2] == 'P' || packet->payload[2] == 'p')
	       && (packet->payload[3] == 'A' || packet->payload[3] == 'a')) {
      flow->l4.tcp.pop_command_bitmask |= POP_BIT_CAPA;
      return 1;
    } else if((packet->payload[0] == 'L' || packet->payload[0] == 'l')
	       && (packet->payload[1] == 'I' || packet->payload[1] == 'i')
	       && (packet->payload[2] == 'S' || packet->payload[2] == 's')
	       && (packet->payload[3] == 'T' || packet->payload[3] == 't')) {
      flow->l4.tcp.pop_command_bitmask |= POP_BIT_LIST;
      return 1;
    } else if((packet->payload[0] == 'S' || packet->payload[0] == 's')
	       && (packet->payload[1] == 'T' || packet->payload[1] == 't')
	       && (packet->payload[2] == 'A' || packet->payload[2] == 'a')
	       && (packet->payload[3] == 'T' || packet->payload[3] == 't')) {
      flow->l4.tcp.pop_command_bitmask |= POP_BIT_STAT;
      return 1;
    } else if((packet->payload[0] == 'U' || packet->payload[0] == 'u')
	       && (packet->payload[1] == 'I' || packet->payload[1] == 'i')
	       && (packet->payload[2] == 'D' || packet->payload[2] == 'd')
	       && (packet->payload[3] == 'L' || packet->payload[3] == 'l')) {
      flow->l4.tcp.pop_command_bitmask |= POP_BIT_UIDL;
      return 1;
    } else if((packet->payload[0] == 'R' || packet->payload[0] == 'r')
	       && (packet->payload[1] == 'E' || packet->payload[1] == 'e')
	       && (packet->payload[2] == 'T' || packet->payload[2] == 't')
	       && (packet->payload[3] == 'R' || packet->payload[3] == 'r')) {
      flow->l4.tcp.pop_command_bitmask |= POP_BIT_RETR;
      return 1;
    } else if((packet->payload[0] == 'D' || packet->payload[0] == 'd')
	       && (packet->payload[1] == 'E' || packet->payload[1] == 'e')
	       && (packet->payload[2] == 'L' || packet->payload[2] == 'l')
	       && (packet->payload[3] == 'E' || packet->payload[3] == 'e')) {
      flow->l4.tcp.pop_command_bitmask |= POP_BIT_DELE;
      return 1;
    } else if((packet->payload[0] == 'S' || packet->payload[0] == 's')
	       && (packet->payload[1] == 'T' || packet->payload[1] == 't')
	       && (packet->payload[2] == 'L' || packet->payload[2] == 'l')
	       && (packet->payload[3] == 'S' || packet->payload[3] == 's')) {
      flow->l4.tcp.pop_command_bitmask |= POP_BIT_STLS;
      return 1;
    }
  }
  return 0;
}

// the below code fragment can be found in:
// src/lib/protocols/aimini.c
void ndpi_search_aimini(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow)
{
	struct ndpi_packet_struct *packet = &flow->packet;

	NDPI_LOG_DBG(ndpi_struct, "search aimini\n");

	if (packet->udp != NULL) {
		if (flow->l4.udp.aimini_stage == 0) {
			if (packet->payload_packet_len == 64 && ntohs(get_u_int16_t(packet->payload, 0)) == 0x010b) {
				flow->l4.udp.aimini_stage = 1;
				NDPI_LOG_DBG2(ndpi_struct, "stage = 1\n");
				return;
			}
			if (packet->payload_packet_len == 136
				&& (ntohs(get_u_int16_t(packet->payload, 0)) == 0x01c9 || ntohs(get_u_int16_t(packet->payload, 0)) == 0x0165)) {
				flow->l4.udp.aimini_stage = 4;
				NDPI_LOG_DBG2(ndpi_struct, "stage = 4\n");
				return;
			}
			if (packet->payload_packet_len == 88 && ntohs(get_u_int16_t(packet->payload, 0)) == 0x0101) {
				flow->l4.udp.aimini_stage = 7;
				NDPI_LOG_DBG2(ndpi_struct, "stage = 7\n");
				return;
			}
			if (packet->payload_packet_len == 104 && ntohs(get_u_int16_t(packet->payload, 0)) == 0x0102) {
				flow->l4.udp.aimini_stage = 10;
				NDPI_LOG_DBG2(ndpi_struct, "stage = 10\n");
				return;
			}
			if (packet->payload_packet_len == 32 && ntohs(get_u_int16_t(packet->payload, 0)) == 0x01ca) {
				flow->l4.udp.aimini_stage = 13;
				NDPI_LOG_DBG2(ndpi_struct, "stage = 13\n");
				return;
			}
			if (packet->payload_packet_len == 16 && ntohs(get_u_int16_t(packet->payload, 0)) == 0x010c) {
				flow->l4.udp.aimini_stage = 16;
				NDPI_LOG_DBG2(ndpi_struct, "stage = 16\n");
				return;
			}
		}
		/* first packet chronology: (len, value): (64, 0x010b), (>100, 0x0115), (16, 0x010c || 64, 0x010b || 88, 0x0115),
		 * (16, 0x010c || 64, 0x010b || >100, 0x0115)
		 */
		if (flow->l4.udp.aimini_stage == 1 && packet->payload_packet_len > 100
			&& ntohs(get_u_int16_t(packet->payload, 0)) == 0x0115) {
			flow->l4.udp.aimini_stage = 2;
			NDPI_LOG_DBG2(ndpi_struct, "stage = 2\n");
			return;
		}
		if (flow->l4.udp.aimini_stage == 2 &&
			((packet->payload_packet_len == 16 && get_u_int16_t(packet->payload, 0) == htons(0x010c)) ||
			 (packet->payload_packet_len == 64 && get_u_int16_t(packet->payload, 0) == htons(0x010b)) ||
			 (packet->payload_packet_len == 88 && get_u_int16_t(packet->payload, 0) == ntohs(0x0115)))) {
			flow->l4.udp.aimini_stage = 3;
			NDPI_LOG_DBG2(ndpi_struct, "stage = 3\n");
			return;
		}
		if (flow->l4.udp.aimini_stage == 3
			&& ((packet->payload_packet_len == 16 && ntohs(get_u_int16_t(packet->payload, 0)) == 0x010c)
				|| (packet->payload_packet_len == 64 && ntohs(get_u_int16_t(packet->payload, 0)) == 0x010b)
				|| (packet->payload_packet_len > 100 && ntohs(get_u_int16_t(packet->payload, 0)) == 0x0115))) {
			NDPI_LOG_INFO(ndpi_struct, "found aimini (64, 0x010b), (>300, 0x0115), "
					"(16, 0x010c || 64, 0x010b), (16, 0x010c || 64, 0x010b || >100, 0x0115).\n");
			ndpi_int_aimini_add_connection(ndpi_struct, flow);
			return;
		}

		/* second packet chronology: (len, value): (136, 0x01c9), (136, 0x01c9),(136, 0x01c9),(136, 0x01c9 || 32, 0x01ca) */

		if (flow->l4.udp.aimini_stage == 4 && packet->payload_packet_len == 136
			&& (ntohs(get_u_int16_t(packet->payload, 0)) == 0x01c9 || ntohs(get_u_int16_t(packet->payload, 0)) == 0x0165)) {
			flow->l4.udp.aimini_stage = 5;
			NDPI_LOG_DBG2(ndpi_struct, "stage = 5\n");
			return;
		}
		if (flow->l4.udp.aimini_stage == 5 && (packet->payload_packet_len == 136
											   && (ntohs(get_u_int16_t(packet->payload, 0)) == 0x01c9
												   || ntohs(get_u_int16_t(packet->payload, 0)) == 0x0165))) {
			flow->l4.udp.aimini_stage = 6;
			NDPI_LOG_DBG2(ndpi_struct, "stage = 6\n");
			return;
		}
		if (flow->l4.udp.aimini_stage == 6 && ((packet->payload_packet_len == 136
												&& ((ntohs(get_u_int16_t(packet->payload, 0)) == 0x0165)
													|| ntohs(get_u_int16_t(packet->payload, 0)) == 0x01c9))
											   || (packet->payload_packet_len == 32
												   && ntohs(get_u_int16_t(packet->payload, 0)) == 0x01ca))) {
			NDPI_LOG_INFO(ndpi_struct,
					"found aimini (136, 0x01c9), (136, 0x01c9)," "(136, 0x01c9),(136, 0x01c9 || 32, 0x01ca).\n");
			ndpi_int_aimini_add_connection(ndpi_struct, flow);
			return;
		}

		/* third packet chronology: (len, value): (88, 0x0101), (88, 0x0101),(88, 0x0101),(88, 0x0101) */

		if (flow->l4.udp.aimini_stage == 7 && packet->payload_packet_len == 88
			&& ntohs(get_u_int16_t(packet->payload, 0)) == 0x0101) {
			flow->l4.udp.aimini_stage = 8;
			NDPI_LOG_DBG2(ndpi_struct, "stage = 8\n");
			return;
		}
		if (flow->l4.udp.aimini_stage == 8
			&& (packet->payload_packet_len == 88 && ntohs(get_u_int16_t(packet->payload, 0)) == 0x0101)) {
			flow->l4.udp.aimini_stage = 9;
			NDPI_LOG_DBG2(ndpi_struct, "stage = 9\n");
			return;
		}
		if (flow->l4.udp.aimini_stage == 9
			&& (packet->payload_packet_len == 88 && ntohs(get_u_int16_t(packet->payload, 0)) == 0x0101)) {
			NDPI_LOG_INFO(ndpi_struct,
					"found aimini (88, 0x0101), (88, 0x0101)," "(88, 0x0101),(88, 0x0101).\n");
			ndpi_int_aimini_add_connection(ndpi_struct, flow);
			return;
		}

		/* fourth packet chronology: (len, value): (104, 0x0102), (104, 0x0102), (104, 0x0102), (104, 0x0102) */

		if (flow->l4.udp.aimini_stage == 10 && packet->payload_packet_len == 104
			&& ntohs(get_u_int16_t(packet->payload, 0)) == 0x0102) {
			flow->l4.udp.aimini_stage = 11;
			NDPI_LOG_DBG2(ndpi_struct, "stage = 11\n");
			return;
		}
		if (flow->l4.udp.aimini_stage == 11
			&& (packet->payload_packet_len == 104 && ntohs(get_u_int16_t(packet->payload, 0)) == 0x0102)) {
			flow->l4.udp.aimini_stage = 12;
			NDPI_LOG_DBG2(ndpi_struct, "stage = 12\n");
			return;
		}
		if (flow->l4.udp.aimini_stage == 12
			&& ((packet->payload_packet_len == 104 && ntohs(get_u_int16_t(packet->payload, 0)) == 0x0102)
				|| (packet->payload_packet_len == 32 && ntohs(get_u_int16_t(packet->payload, 0)) == 0x01ca))) {
			NDPI_LOG_INFO(ndpi_struct,
					"found aimini (104, 0x0102), (104, 0x0102), " "(104, 0x0102), (104, 0x0102).\n");
			ndpi_int_aimini_add_connection(ndpi_struct, flow);
			return;
		}

		/* fifth packet chronology (len, value): (32,0x01ca), (32,0x01ca), (32,0x01ca), ((136, 0x0166) || (32,0x01ca)) */

		if (flow->l4.udp.aimini_stage == 13 && packet->payload_packet_len == 32
			&& ntohs(get_u_int16_t(packet->payload, 0)) == 0x01ca) {
			flow->l4.udp.aimini_stage = 14;
			NDPI_LOG_DBG2(ndpi_struct, "stage = 14\n");
			return;
		}
		if (flow->l4.udp.aimini_stage == 14
			&& ((packet->payload_packet_len == 32 && ntohs(get_u_int16_t(packet->payload, 0)) == 0x01ca)
				|| (packet->payload_packet_len == 136 && ntohs(get_u_int16_t(packet->payload, 0)) == 0x0166))) {
			flow->l4.udp.aimini_stage = 15;
			NDPI_LOG_DBG2(ndpi_struct, "stage = 15\n");
			return;
		}
		if (flow->l4.udp.aimini_stage == 15
			&& ((packet->payload_packet_len == 136 && ntohs(get_u_int16_t(packet->payload, 0)) == 0x0166)
				|| (packet->payload_packet_len == 32 && ntohs(get_u_int16_t(packet->payload, 0)) == 0x01ca))) {
			NDPI_LOG_INFO(ndpi_struct,
					"found aimini (32,0x01ca), (32,0x01ca), (32,0x01ca), ((136, 0x0166)||(32,0x01ca)).\n");
			ndpi_int_aimini_add_connection(ndpi_struct, flow);
			return;
		}

		/* sixth packet chronology (len, value): (16, 0x010c), (16, 0x010c), (16, 0x010c), (16, 0x010c) */

		if (flow->l4.udp.aimini_stage == 16 && packet->payload_packet_len == 16
			&& ntohs(get_u_int16_t(packet->payload, 0)) == 0x010c) {
			flow->l4.udp.aimini_stage = 17;
			NDPI_LOG_DBG2(ndpi_struct, "stage = 17\n");
			return;
		}
		if (flow->l4.udp.aimini_stage == 17
			&& (packet->payload_packet_len == 16 && ntohs(get_u_int16_t(packet->payload, 0)) == 0x010c)) {
			flow->l4.udp.aimini_stage = 18;
			NDPI_LOG_DBG2(ndpi_struct, "stage = 18\n");
			return;
		}
		if (flow->l4.udp.aimini_stage == 18
			&& (packet->payload_packet_len == 16 && ntohs(get_u_int16_t(packet->payload, 0)) == 0x010c)) {
			NDPI_LOG_INFO(ndpi_struct,
					"found aimini (16, 0x010c), (16, 0x010c), (16, 0x010c), (16, 0x010c).\n");
			ndpi_int_aimini_add_connection(ndpi_struct, flow);
			return;
		}
	} else if (packet->tcp != NULL) {
		if ((packet->payload_packet_len > NDPI_STATICSTRING_LEN("GET /player/") &&
			 (memcmp(packet->payload, "GET /player/", NDPI_STATICSTRING_LEN("GET /player/")) == 0)) ||
			(packet->payload_packet_len > NDPI_STATICSTRING_LEN("GET /play/?fid=") &&
			 (memcmp(packet->payload, "GET /play/?fid=", NDPI_STATICSTRING_LEN("GET /play/?fid=")) == 0))) {
			NDPI_LOG_DBG2(ndpi_struct, "HTTP packet detected\n");
			ndpi_parse_packet_line_info(ndpi_struct, flow);
			if (packet->host_line.ptr != NULL && packet->host_line.len > 11
				&& (memcmp(&packet->host_line.ptr[packet->host_line.len - 11], ".aimini.net", 11) == 0)) {
				NDPI_LOG_INFO(ndpi_struct, "found AIMINI HTTP traffic\n");
				ndpi_int_aimini_add_connection(ndpi_struct, flow);
				return;
			}
		}
		if (packet->payload_packet_len > 100) {
			if (memcmp(packet->payload, "GET /", NDPI_STATICSTRING_LEN("GET /")) == 0) {
				if (memcmp(&packet->payload[NDPI_STATICSTRING_LEN("GET /")], "play/",
						   NDPI_STATICSTRING_LEN("play/")) == 0 ||
					memcmp(&packet->payload[NDPI_STATICSTRING_LEN("GET /")], "download/",
						   NDPI_STATICSTRING_LEN("download/")) == 0) {
					ndpi_parse_packet_line_info(ndpi_struct, flow);
					if (is_special_aimini_host(packet->host_line) == 1) {
						NDPI_LOG_INFO(ndpi_struct,
								"found AIMINI HTTP traffic\n");
						ndpi_int_aimini_add_connection(ndpi_struct, flow);
						return;
					}
				}
			} else if (memcmp(packet->payload, "POST /", NDPI_STATICSTRING_LEN("POST /")) == 0) {
				if (memcmp(&packet->payload[NDPI_STATICSTRING_LEN("POST /")], "upload/",
						   NDPI_STATICSTRING_LEN("upload/")) == 0) {
					ndpi_parse_packet_line_info(ndpi_struct, flow);
					if (is_special_aimini_host(packet->host_line) == 1) {
						NDPI_LOG_INFO(ndpi_struct,
								"found AIMINI HTTP traffic detected.\n");
						ndpi_int_aimini_add_connection(ndpi_struct, flow);
						return;
					}
				}
			}
		}
	}

	NDPI_EXCLUDE_PROTO(ndpi_struct, flow);

}

// the below code fragment can be found in:
// src/lib/protocols/soulseek.c
void ndpi_search_soulseek_tcp(struct ndpi_detection_module_struct *ndpi_struct,
			      struct ndpi_flow_struct *flow)
{
  struct ndpi_packet_struct *packet = &flow->packet;

  struct ndpi_id_struct *src = flow->src;
  struct ndpi_id_struct *dst = flow->dst;

  if(packet->tcp) {

    if(packet->detected_protocol_stack[0] == NDPI_PROTOCOL_SOULSEEK) {
      NDPI_LOG_DBG2(ndpi_struct, "packet marked as Soulseek\n");
      if(src != NULL)
	NDPI_LOG_DBG2(ndpi_struct,
		 "  SRC bitmask: %u, packet tick %llu , last safe access timestamp: %llu\n",
		      NDPI_COMPARE_PROTOCOL_TO_BITMASK(src->detected_protocol_bitmask, NDPI_PROTOCOL_SOULSEEK)
		 != 0 ? 1 : 0, (long long unsigned int) packet->tick_timestamp,
		      (long long unsigned int) src->soulseek_last_safe_access_time);
      if(dst != NULL)
	NDPI_LOG_DBG2(ndpi_struct,
		 "  DST bitmask: %u, packet tick %llu , last safe ts: %llu\n",
		 NDPI_COMPARE_PROTOCOL_TO_BITMASK(dst->detected_protocol_bitmask, NDPI_PROTOCOL_SOULSEEK)
		 != 0 ? 1 : 0, (long long unsigned int) packet->tick_timestamp,
		      (long long unsigned int) dst->soulseek_last_safe_access_time);

      if(packet->payload_packet_len == 431) {
	if(dst != NULL) {
	  dst->soulseek_last_safe_access_time = packet->tick_timestamp;
	}
	return;
      }
      if(packet->payload_packet_len == 12 && get_l32(packet->payload, 4) == 0x02) {
	if(src != NULL) {
	  src->soulseek_last_safe_access_time = packet->tick_timestamp;
	  if(packet->tcp != NULL && src->soulseek_listen_port == 0) {
	    src->soulseek_listen_port = get_l32(packet->payload, 8);
	    return;
	  }
	}
      }

      if(src != NULL && ((u_int32_t)(packet->tick_timestamp - src->soulseek_last_safe_access_time) < ndpi_struct->soulseek_connection_ip_tick_timeout)) {
	NDPI_LOG_DBG2(ndpi_struct,
		 "Soulseek: SRC update last safe access time and SKIP_FOR_TIME \n");
	src->soulseek_last_safe_access_time = packet->tick_timestamp;
      }

      if(dst != NULL && ((u_int32_t)(packet->tick_timestamp - dst->soulseek_last_safe_access_time) < ndpi_struct->soulseek_connection_ip_tick_timeout)) {
	NDPI_LOG_DBG2(ndpi_struct,
		 "Soulseek: DST update last safe access time and SKIP_FOR_TIME \n");
	dst->soulseek_last_safe_access_time = packet->tick_timestamp;
      }
    }


    if(dst != NULL && dst->soulseek_listen_port != 0 && dst->soulseek_listen_port == ntohs(packet->tcp->dest)
       && ((u_int32_t)(packet->tick_timestamp - dst->soulseek_last_safe_access_time) < ndpi_struct->soulseek_connection_ip_tick_timeout)) {
      
      NDPI_LOG_DBG2(ndpi_struct,
	       "Soulseek: Plain detection on Port : %u packet_tick_timestamp: %u soulseek_last_safe_access_time: %u soulseek_connection_ip_ticktimeout: %u\n",
	       dst->soulseek_listen_port, packet->tick_timestamp, dst->soulseek_last_safe_access_time, ndpi_struct->soulseek_connection_ip_tick_timeout);
      
      dst->soulseek_last_safe_access_time = packet->tick_timestamp;
      if(src != NULL)
	src->soulseek_last_safe_access_time = packet->tick_timestamp;

      NDPI_LOG_INFO(ndpi_struct, "found Soulseek\n");
      ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_SOULSEEK, NDPI_PROTOCOL_UNKNOWN);
      return;
    }
    
    if(flow->l4.tcp.soulseek_stage == 0) {

      u_int32_t index = 0;

      if(packet->payload_packet_len >= 12 && packet->payload_packet_len < 300 && get_l32(packet->payload, 4) == 1) {
	while (!get_u_int16_t(packet->payload, index + 2)
	       && (index + get_l32(packet->payload, index)) < packet->payload_packet_len - 4) {
	  if(get_l32(packet->payload, index) < 8)	/*Minimum soulseek login msg is 8B */
	    break;

	  if(index + get_l32(packet->payload, index) + 4 <= index) {
	    /* avoid overflow */
	    break;
	  }

	  index += get_l32(packet->payload, index) + 4;
	}
	if(index + get_l32(packet->payload, index) == packet->payload_packet_len - 4 && !get_u_int16_t(packet->payload, 10)) {
	  /* This structure seems to be soulseek proto */
	  index = get_l32(packet->payload, 8) + 12;	// end of "user name"
	  if((index + 4) <= packet->payload_packet_len && !get_u_int16_t(packet->payload, index + 2))	// for passwd len
	    {
	      index += get_l32(packet->payload, index) + 4;	//end of  "Passwd"
	      if((index + 4 + 4) <= packet->payload_packet_len && !get_u_int16_t(packet->payload, index + 6))	// to read version,hashlen
		{
		  index += get_l32(packet->payload, index + 4) + 8;	// enf of "hash value"
		  if(index == get_l32(packet->payload, 0)) {
		    
		    NDPI_LOG_INFO(ndpi_struct, "found soulseek Login Detected\n");
		    SOULSEEK_DETECT;		    
		    return;
		  }
		}
	    }
	}
      }
      if (packet->payload_packet_len > 8
	  && packet->payload_packet_len < 200 && get_l32(packet->payload, 0) == packet->payload_packet_len - 4) {
	//Server Messages:
	const u_int32_t msgcode = get_l32(packet->payload, 4);

	if(msgcode == 0x7d) {
	  flow->l4.tcp.soulseek_stage = 1 + packet->packet_direction;
	  NDPI_LOG_DBG2(ndpi_struct, "Soulseek Messages Search\n");
	  return;
	} else if(msgcode == 0x02 && packet->payload_packet_len == 12) {
	  const u_int32_t soulseek_listen_port = get_l32(packet->payload, 8);

	  if(src != NULL) {
	    src->soulseek_last_safe_access_time = packet->tick_timestamp;

	    if(packet->tcp != NULL && src->soulseek_listen_port == 0) {
	      src->soulseek_listen_port = soulseek_listen_port;
	      NDPI_LOG_DBG2(ndpi_struct, "\n Listen Port Saved : %u", src->soulseek_listen_port);

	      if(dst != NULL)
		dst->soulseek_last_safe_access_time = packet->tick_timestamp;
	      
	      ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_SOULSEEK, NDPI_PROTOCOL_UNKNOWN);
	      return;
	    }
	  }
	}
	//Peer Messages  : Peer Init Message Detection
	if(get_l32(packet->payload, 0) == packet->payload_packet_len - 4) {
	  const u_int32_t typelen = get_l32(packet->payload, packet->payload_packet_len - 9);
	  const u_int8_t type = packet->payload[packet->payload_packet_len - 5];
	  const u_int32_t namelen = get_l32(packet->payload, 5);
	  if(packet->payload[4] == 0x01 && typelen == 1
	      && namelen <= packet->payload_packet_len
	      && (4 + 1 + 4 + namelen + 4 + 1 + 4) ==
	      packet->payload_packet_len && (type == 'F' || type == 'P' || type == 'D')) {
	    NDPI_LOG_INFO(ndpi_struct, "found soulseek\n");
	    SOULSEEK_DETECT;
	    return;
	  }
	}
	NDPI_LOG_DBG2(ndpi_struct, "3\n");
	//Peer Message : Pierce Firewall
	if(packet->payload_packet_len == 9 && get_l32(packet->payload, 0) == 5
	    && packet->payload[4] <= 0x10 && get_u_int32_t(packet->payload, 5) != 0x00000000) {
	  flow->l4.tcp.soulseek_stage = 1 + packet->packet_direction;
	  NDPI_LOG_DBG2(ndpi_struct, "Soulseek Size 9 Pierce Firewall\n");
	  return;
	}
      }

      if(packet->payload_packet_len > 25 && packet->payload[4] == 0x01 && !get_u_int16_t(packet->payload, 7)
	  && !get_u_int16_t(packet->payload, 2)) {
	const u_int32_t usrlen = get_l32(packet->payload, 5);

	if(usrlen <= packet->payload_packet_len - 4 + 1 + 4 + 4 + 1 + 4) {
	  const u_int32_t typelen = get_l32(packet->payload, 4 + 1 + 4 + usrlen);
	  const u_int8_t type = packet->payload[4 + 1 + 4 + usrlen + 4];
	  if(typelen == 1 && (type == 'F' || type == 'P' || type == 'D')) {
	    NDPI_LOG_INFO(ndpi_struct, "found soulseek Pattern command(D|P|F)\n");
	    SOULSEEK_DETECT;	    
	    return;
	  }
	}
      }

    } else if(flow->l4.tcp.soulseek_stage == 2 - packet->packet_direction) {
      if(packet->payload_packet_len > 8) {
	if((packet->payload[0] || packet->payload[1]) && get_l32(packet->payload, 4) == 9) {
	  /* 9 is search result */
	  NDPI_LOG_INFO(ndpi_struct, "found soulseek Second Pkt\n");
	  SOULSEEK_DETECT;
	  return;
	}
	if(get_l32(packet->payload, 0) == packet->payload_packet_len - 4) {
	  const u_int32_t msgcode = get_l32(packet->payload, 4);
	  if(msgcode == 0x03 && packet->payload_packet_len >= 12)	//Server Message : Get Peer Address
	    {
	      const u_int32_t usrlen = get_l32(packet->payload, 8);
	      if(usrlen <= packet->payload_packet_len && 4 + 4 + 4 + usrlen == packet->payload_packet_len) {
		NDPI_LOG_INFO(ndpi_struct, "found soulseek Request Get Peer Address Detected\n");
		SOULSEEK_DETECT;		
		return;
	      }
	    }
	}
      }

      if(packet->payload_packet_len == 8 && get_l32(packet->payload, 4) == 0x00000004) {
	NDPI_LOG_INFO(ndpi_struct, "found soulseek\n");
	SOULSEEK_DETECT;
	return;
      }

      if(packet->payload_packet_len == 4
	 && get_u_int16_t(packet->payload, 2) == 0x00 && get_u_int16_t(packet->payload, 0) != 0x00) {
	NDPI_LOG_INFO(ndpi_struct, "found soulseek\n");
	SOULSEEK_DETECT;	
	return;
      } else if(packet->payload_packet_len == 4) {
	flow->l4.tcp.soulseek_stage = 3;
	return;
      }
    } else if(flow->l4.tcp.soulseek_stage == 1 + packet->packet_direction) {
      if(packet->payload_packet_len > 8) {
	if(packet->payload[4] == 0x03 && get_l32(packet->payload, 5) == 0x00000031) {
	  NDPI_LOG_INFO(ndpi_struct, "found soulseek Second Pkt with SIGNATURE :: 0x0331000000 \n");
	  SOULSEEK_DETECT;	  
	  return;
	}
      }
    }
    if(flow->l4.tcp.soulseek_stage == 3 && packet->payload_packet_len == 8 && !get_u_int32_t(packet->payload, 4)) {

      NDPI_LOG_INFO(ndpi_struct, "found soulseek bcz of 8B  pkt\n");
      SOULSEEK_DETECT;
      return;
    }
    
    if(flow->l4.tcp.soulseek_stage && flow->packet_counter < 11) {
      ;
    } else {
      NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
    }
  }
}
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).