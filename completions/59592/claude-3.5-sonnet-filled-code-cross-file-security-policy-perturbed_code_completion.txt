hb_vector_t<glyf::SubsetGlyph> subset_glyphs;
if (!subset_glyphs.alloc (context->plan->num_output_glyphs (), true))
{
  hb_font_destroy (font);
  return_trace (false);
}

for (unsigned i = 0; i < context->plan->num_output_glyphs (); i++)
{
  hb_codepoint_t new_glyph = context->plan->new_gid_for_old_gid[i];
  if (new_glyph == HB_MAP_VALUE_INVALID) continue;
  
  if (!subset_glyphs[new_glyph].compile (context->plan, font, i))
  {
    hb_font_destroy (font);
    return_trace (false);
  }
}

hb_font_destroy (font);

unsigned int glyf_prime_size = 0;
for (unsigned i = 0; i < subset_glyphs.length; i++)
  glyf_prime_size += subset_glyphs[i].padded_size ();

bool use_short_loca = glyf_prime_size < 131072;

glyf *glyf_prime = context->serializer->start_embed<glyf> ();
if (unlikely (!glyf_prime)) return_trace (false);

if (!glyf_prime->serialize (context->serializer,
                            subset_glyphs.as_array (),
                            use_short_loca))
  return_trace (false);

for (unsigned i = 0; i < subset_glyphs.length; i++)
  subset_glyphs[i].free_compiled_bytes ();

bool result = true;