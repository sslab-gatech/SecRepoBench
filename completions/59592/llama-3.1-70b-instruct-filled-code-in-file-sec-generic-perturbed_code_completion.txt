hb_vector_t<glyf_impl::SubsetGlyph> glyphs;
if (unlikely (!_populate_subset_glyphs (context->plan, font, glyphs)))
  return_trace (false);

hb_vector_t<unsigned> padded_offsets;
if (unlikely (!padded_offsets.alloc (glyphs.length + 1, true)))
{
  _free_compiled_subset_glyphs (glyphs);
  return_trace (false);
}

unsigned short_loca = 0;
unsigned offset = 0;
for (unsigned i = 0; i < glyphs.length; i++)
{
  padded_offsets[i] = offset;
  offset += glyphs[i].get_padded_length ();
  if (unlikely (offset > 0xFFFF))
    short_loca = 0;
}
padded_offsets[glyphs.length] = offset;
short_loca = short_loca && offset <= 0xFFFF;

glyf new_glyf;
if (unlikely (!new_glyf.dataZ.alloc (offset, true)))
{
  _free_compiled_subset_glyphs (glyphs);
  return_trace (false);
}

bool result = new_glyf.serialize (context->serializer, glyphs.iter (), short_loca, context->plan);
_free_compiled_subset_glyphs (glyphs);
if (font)
  hb_font_destroy (font);
return_trace (result);