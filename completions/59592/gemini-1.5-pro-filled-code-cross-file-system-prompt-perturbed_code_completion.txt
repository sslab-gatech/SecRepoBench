bool result = false;
    hb_vector_t<SubSetGlyph> subset_glyphs;

    if (unlikely (!subset_glyphs.resize (context->plan->glyphs.length)))
      goto cleanup;

    if (unlikely (!compile_glyphs (context, font, subset_glyphs.arrayZ)))
      goto cleanup;

    if (font)
      hb_font_destroy (font);
    font = nullptr;

    unsigned max_glyph = context->plan->glyphs.max;
    unsigned num_glyphs = max_glyph + 1;

    bool short_loca = num_glyphs < (1u << 16);
    unsigned glyf_size = 0;
    unsigned loca_size = (short_loca ? 2 : 4) * num_glyphs;

    for (unsigned int i = 0; i < num_glyphs; i++)
    {
      subset_glyphs[i].padded_offset = glyf_size;
      glyf_size += subset_glyphs[i].size;
    }

    glyf_size = hb_pad4 (glyf_size);

    bool has_loca = _is_table_present (context->plan->source, HB_TAG ('l','o','c','a'));
    bool has_glyf = _is_table_present (context->plan->source, HB_TAG ('g','l','y','f'));

    if (unlikely (!has_loca || !has_glyf))
      goto cleanup;

    {
      bool create_new_table = true;
      glyf *glyf_prime = context->serializer->start_embed<glyf> (&create_new_table);

      if (unlikely (!glyf_prime))
        goto cleanup;

      if (unlikely (!glyf_prime->serialize (context->serializer,
					   *this,
					   subset_glyphs.arrayZ,
					   short_loca)))
      {
        DEBUG_MSG (SUBSET, nullptr, "Failed to serialize glyf table.");
	goto cleanup;
      }
      result = true;
    }


  cleanup:
    for (auto& glyph : subset_glyphs)
      glyph.free_compiled_bytes ();