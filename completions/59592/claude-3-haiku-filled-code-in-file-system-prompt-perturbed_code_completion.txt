bool result = true;

// Generate a subset of glyphs based on the provided plan and font.
hb_vector_t<glyf_impl::SubsetGlyph> glyphs;
if (!_populate_subset_glyphs(context->plan, font, glyphs))
{
  result = false;
  goto cleanup;
}

// Calculate padded offsets for each subset glyph and determine if a short loca table can be used.
bool use_short_loca = true;
unsigned int total_size = 0;
for (auto &g : glyphs)
{
  total_size += g.get_compiled_bytes().length;
  if (total_size > 0xFFFF)
  {
    use_short_loca = false;
    break;
  }
}

// Initialize a new glyf object for serialization.
glyf subset_glyf;

// Serialize the subset of glyphs into the glyf object, using the determined loca format.
if (!subset_glyf.serialize(context->serializer, glyphs.iter(), use_short_loca, context->plan))
{
  result = false;
  goto cleanup;
}

cleanup:
if (font)
  _free_compiled_subset_glyphs(glyphs);

return result;