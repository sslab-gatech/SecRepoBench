bool result = false;

{
  // Generate a subset of glyph IDs from the plan.
  hb_vector_t<unsigned> subset_glyph_ids;
  if (unlikely (!subset_glyph_ids.alloc (context->plan->glyphset.get_population (), true)))
  {
    DEBUG_MSG (SUBSET, nullptr, "Failed to allocate subset glyph ID array.");
    goto cleanup;
  }
  for (auto glyph_id : context->plan->glyphset)
    subset_glyph_ids.push (glyph_id);

  // Compile each glyph into a buffer for the subset.
  hb_vector_t<SubsetGlyph> compiled_glyphs;
  if (unlikely (!compiled_glyphs.alloc (subset_glyph_ids.length, true)))
  {
    DEBUG_MSG (SUBSET, nullptr, "Failed to allocate compiled glyph array.");
    goto cleanup;
  }
  for (unsigned i = 0; i < subset_glyph_ids.length; i++)
  {
    SubsetGlyph glyph;
    if (!glyph.compile (subset_glyph_ids[i], font))
    {
      DEBUG_MSG (SUBSET, nullptr, "Failed to compile subset glyph.");
      goto cleanup;
    }
    compiled_glyphs.push (glyph);
  }

  // Determine whether we can use a short loca table by calculating the total offsets.
  bool use_short_loca = true;
  unsigned offset_accum = 0;
  for (unsigned i = 0; i < compiled_glyphs.length; i++)
  {
    // Check if next glyph data would exceed short loca capacity (16-bit offsets).
    // Each offset is stored in units of 2 bytes when short loca is used.
    if (offset_accum + compiled_glyphs[i].get_length () > 0xFFFFu << 1)
    {
      use_short_loca = false;
      break;
    }
    offset_accum += compiled_glyphs[i].get_length ();
  }

  // Initialize a glyf object for serialization.
  glyf *glyf_obj = context->serializer->start_embed<glyf> ();
  if (unlikely (!glyf_obj))
  {
    DEBUG_MSG (SUBSET, nullptr, "Failed to start embedding glyf object.");
    goto cleanup;
  }

  // Serialize the compiled glyphs into the glyf object.
  if (!glyf_obj->serialize (compiled_glyphs, use_short_loca, context->serializer))
  {
    DEBUG_MSG (SUBSET, nullptr, "Failed to serialize glyf subset.");
    goto cleanup;
  }

  result = true;

cleanup:
  // Cleanup compiled glyph data.
  for (unsigned i = 0; i < compiled_glyphs.length; i++)
    compiled_glyphs[i].free_compiled_bytes ();

  if (font)
    hb_font_destroy (font);
}

return_trace (result);