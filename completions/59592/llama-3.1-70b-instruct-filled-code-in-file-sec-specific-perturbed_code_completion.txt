hb_vector_t<glyf_impl::SubsetGlyph> glyphs;
if (unlikely (!_populate_subset_glyphs (context->plan, font, glyphs)))
  return_trace (false);

hb_vector_t<unsigned> padded_offsets;
if (unlikely (!padded_offsets.alloc (glyphs.length + 1, true)))
{
  _free_compiled_subset_glyphs (glyphs);
  return_trace (false);
}

unsigned short_loca = 0;
unsigned offset = 0;
for (unsigned i = 0; i < glyphs.length; i++)
{
  padded_offsets[i] = offset;
  offset += glyphs[i].get_padded_length ();
  if (unlikely (offset > 0xFFFF))
    short_loca = 0;
}
padded_offsets[glyphs.length] = offset;
short_loca = short_loca && has_valid_glyf_format (context->plan->source);

glyf new_glyf;
if (unlikely (!new_glyf.dataZ.alloc (offset, true)))
{
  _free_compiled_subset_glyphs (glyphs);
  return_trace (false);
}

hb_serialize_context_t c (&new_glyf.dataZ, 0, new_glyf.dataZ.size);
if (unlikely (!serialize (&c, glyphs, short_loca, context->plan)))
{
  _free_compiled_subset_glyphs (glyphs);
  return_trace (false);
}

if (font)
  hb_font_destroy (font);

bool result = true;
if (unlikely (context->plan->flags & HB_SUBSET_FLAGS_RETAIN_GLYF))
{
  if (unlikely (!context->plan->source->table.glyf.set_blob (new_glyf.dataZ)))
  {
    result = false;
    goto done;
  }
}
else
{
  hb_blob_destroy (context->plan->source->table.glyf.get_blob ());
  if (unlikely (!context->plan->source->table.glyf.set_blob (new_glyf.dataZ)))
  {
    result = false;
    goto done;
  }
}

if (unlikely (!context->plan->source->table.loca.set_blob (hb_blob_create_sub_blob (new_glyf.dataZ, 0, padded_offsets[glyphs.length], short_loca? 2 : 4))))
{
  result = false;
  goto done;
}

done:
_free_compiled_subset_glyphs (glyphs);
return_trace (result);