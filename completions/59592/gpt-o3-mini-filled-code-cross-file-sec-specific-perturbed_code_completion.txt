bool result = false;

// Step 1: Compile the subset glyphs based on the plan (and font if needed)
SubsetGlyphList subset_glyphs;
if (!subset_glyphs.compile(context->plan, font)) {
    if (font)
        hb_font_destroy(font);
    return_trace(false);
}

// Step 2: Calculate padded offsets for each subset glyph and decide if the loca table should be short.
bool use_short_loca = subset_glyphs.calculate_offsets();

// Step 3: Initialize a new glyf object for serialization.
glyf new_glyf;
if (!new_glyf.init(subset_glyphs.size(), use_short_loca)) {
    subset_glyphs.free_compiled_bytes();
    if (font)
        hb_font_destroy(font);
    return_trace(false);
}

// Step 4: Serialize the subset glyphs into the glyf object.
if (!new_glyf.serialize(subset_glyphs)) {
    new_glyf.destroy();
    subset_glyphs.free_compiled_bytes();
    if (font)
        hb_font_destroy(font);
    return_trace(false);
}

// Step 5: Cleanup compiled subset glyph resources.
subset_glyphs.free_compiled_bytes();

// Step 6: If a font was created for instancing, destroy it.
if (font)
    hb_font_destroy(font);

// Step 7: Finalize the glyf object (e.g. write out offsets, fix up headers) and set the result.
result = new_glyf.finalize();