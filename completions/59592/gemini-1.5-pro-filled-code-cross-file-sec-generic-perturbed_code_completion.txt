bool result = true;
    hb_vector_t<hb_codepoint_t> subset_glyphs;
    if (unlikely (!subset_glyphs.alloc (context->plan->glyphs.length, true)))
    {
      if (font) hb_font_destroy (font);
      return_trace (false);
    }

    unsigned int num_glyphs;
    for (hb_codepoint_t gid : context->plan->glyphs)
      subset_glyphs.push (gid);

    if (font)
    {
      // Create a temporary face from the instanced font to extract glyph extents.
      hb_face_t *face = hb_font_get_face (font);
      hb_font_destroy (font);
      font = nullptr;

      for (unsigned i = 0; i < subset_glyphs.length; ++i)
      {
        hb_codepoint_t gid = subset_glyphs[i];
        hb_glyph_extents_t extents = {0, 0, 0, 0};
        if (hb_font_get_glyph_extents (context->plan->source, gid, &extents))
        {
          hb_glyph_extents_t normalized_extents = {0, 0, 0, 0};
          hb_font_get_glyph_extents (face, gid, &normalized_extents);
          if (normalized_extents.height)
            extents.height = normalized_extents.height;
          if (normalized_extents.width)
            extents.width = normalized_extents.width;
          hb_font_set_glyph_extents (context->plan->source, gid, &extents);
        }
      }
    }

    glyf_subsetter_t *glyf_subsetter = new glyf_subsetter_t (context, subset_glyphs);
    if (unlikely (!glyf_subsetter))
    {
      return_trace (false);
    }

    result = glyf_subsetter->serialize (context->serializer);

    delete glyf_subsetter;
    return_trace (result);