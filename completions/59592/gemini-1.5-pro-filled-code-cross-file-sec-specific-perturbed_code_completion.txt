bool result = false;
    auto subset_glyphs = _generate_subset_glyphs (context->plan, font);
    if (unlikely (subset_glyphs.failed ()))
      goto cleanup;

    if (font) {
      hb_font_destroy (font);
      font = nullptr;
    }

    unsigned glyf_count = subset_glyphs.length;
    unsigned *padded_offsets = (unsigned *) calloc (glyf_count + 1, sizeof (unsigned));
    if (unlikely (!padded_offsets))
      goto cleanup;

    bool short_loca = _calculate_padded_offsets (subset_glyphs, padded_offsets);

    hb_blob_t *glyf_blob = hb_blob_create (0);
    if (unlikely (!glyf_blob))
    {
      free (padded_offsets);
      goto cleanup;
    }

    hb_serialize_context_t serializer (glyf_blob);
    serializer.start_serialize<BigEndian> ();

    glyf_table_t::serialize_glyf (serializer,
				  context,
				  subset_glyphs,
				  padded_offsets,
				  short_loca);

    if (serializer.in_error ())
    {
      serializer.end_serialize ();
      hb_blob_destroy (glyf_blob);
      free (padded_offsets);
      goto cleanup;
    }

    serializer.end_serialize ();

    context->glyf_blob = glyf_blob;
    context->glyf_offset = 0;
    context->loca_is_short = short_loca;

    free (padded_offsets);
    result = true;

  cleanup:
    if (font)
      hb_font_destroy (font);

    if (!result)
       _destroy_subset_glyphs (subset_glyphs);