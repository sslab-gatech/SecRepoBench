bool result = true;
    auto compiled_glyphs = hb_malloc<SubsetGlyph> (context->plan->glyphs.length);
    if (unlikely (!compiled_glyphs)) return_trace (false);
    defer (hb_free (compiled_glyphs));

    unsigned int glyph_count = context->plan->glyphs.length;
    for (unsigned int i = 0; i < glyph_count; i++)
    {
      hb_codepoint_t glyph = context->plan->glyphs[i];
      compiled_glyphs[i].init (glyph);
    }

    if (font)
    {
      for (unsigned int i = 0; i < glyph_count; i++)
        compiled_glyphs[i].compile (*this, context, font);
      hb_font_destroy (font);
    }
    else
    {
      for (unsigned int i = 0; i < glyph_count; i++)
        compiled_glyphs[i].compile (*this, context);
    }


    /* Calculate padded offsets for each glyph. */
    unsigned int total_size = 0;
    for (unsigned int i = 0; i < glyph_count; i++)
    {
      compiled_glyphs[i].offset = total_size;
      total_size += compiled_glyphs[i].size;
    }

    bool short_loca = total_size < 65536 &&
                      !(context->plan->flags & HB_SUBSET_FLAGS_USE_LONG_LOCA);

    glyf_subsetter_t::glyf_t glyf_prime;
    if (unlikely (!glyf_prime.init ()))
    {
      result = false;
      goto end;
    }

    if (unlikely (!glyf_prime.serialize (context,
                                        *this,
                                        compiled_glyphs, glyph_count,
                                        short_loca)))
    {
      result = false;
    }

  end:
    for (unsigned int i = 0; i < glyph_count; i++)
      compiled_glyphs[i].free_compiled_bytes ();