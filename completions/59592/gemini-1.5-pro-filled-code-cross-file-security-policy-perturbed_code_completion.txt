bool result = true;
    auto compiled_glyphs = context->plan->compiled_glyphs ();
    unsigned num_glyphs = compiled_glyphs.length;

    if (context->plan->normalized_coords)
    {
      _apply_instance_variations (context->plan, font, compiled_glyphs);
      hb_font_destroy (font);
    }

    unsigned total_size = 0;
    unsigned max_offset = 0;
    for (hb_codepoint_t gid : compiled_glyphs)
    {
      auto& glyph = compiled_glyphs[gid];
      total_size = checked_add (total_size, glyph.size);
      max_offset = hb_max (max_offset, glyph.offset);
    }

    bool short_loca = (total_size + context->plan->glyf_offset <= 65535);
    if (!short_loca && context->plan->short_loca)
    {
      DEBUG_MSG (SUBSET, nullptr, "Disabling short loca.");
      context->plan->short_loca = false;
    }

    {
      glyf_subsetter_t::glyf_t glyf;

      if (unlikely (!glyf.init (context, total_size)))
      {
        DEBUG_MSG (SUBSET, context->plan, "Failed to allocate subset glyf table.");
        result = false;
        goto end;
      }

      for (hb_codepoint_t gid : compiled_glyphs)
      {
        auto& glyph = compiled_glyphs[gid];

        if (unlikely (!glyph.serialize (context, &glyf)))
        {
          DEBUG_MSG (SUBSET, context->plan, "Failed to serialize subset glyph %u.", gid);
          result = false;
          goto end;
        }
      }

      if (unlikely (!glyf.finalize ()))
      {
        DEBUG_MSG (SUBSET, context->plan, "Failed to finalize subset glyf table.");
        result = false;
      }

    end:
      glyf.fini ();
    }

    for (auto _ : compiled_glyphs)
      _.free_compiled_bytes ();

    if (!result)
      return_trace (false);

    _free_compiled_subset_glyphs (context->plan);