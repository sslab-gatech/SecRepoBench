bool
glyf::subset (hb_subset_context_t *context) const
{
  TRACE_SUBSET (this);

  if (!has_valid_glyf_format (context->plan->source)) {
    // glyf format is unknown don't attempt to subset it.
    DEBUG_MSG (SUBSET, nullptr,
               "unkown glyf format, dropping from subset.");
    return_trace (false);
  }

  hb_font_t *font = nullptr;
  if (context->plan->normalized_coords)
  {
    font = _create_font_for_instancing (context->plan);
    if (unlikely (!font))
      return_trace (false);
  }

  // Generate a subset of glyphs based on the provided plan and font.
  // Populate a list of subset glyphs, checking for failure in the process.
  // Destroy the font if it was created for instancing, after using it.
  // Calculate padded offsets for each subset glyph and determine if a short loca table can be used.
  // Initialize a new glyf object for serialization.
  // Serialize the subset of glyphs into the glyf object, using the determined loca format.
  // Handle any necessary cleanup of resources, particularly the compiled subset glyphs, if required.
  // Return the result of the serialization process as the function's output.
  hb_vector_t<glyf_impl::SubsetGlyph> glyphs;
  if (unlikely (! _populate_subset_glyphs (context->plan, font, glyphs)))
    return_trace (false);

  hb_blob_t *new_glyf_blob = hb_blob_create (HB_MEMORY_MODE_WRITE, HB_MEMORY_MODE_WRITE);
  if (unlikely (!new_glyf_blob))
    return_trace (false);

  hb_serialize_context_t *c = hb_serialize_context_create (new_glyf_blob);
  if (unlikely (!c))
  {
    hb_blob_destroy (new_glyf_blob);
    return_trace (false);
  }

  bool use_short_loca = glyphs[0].source_glyph.get_header ()->indexToLocFormat <= 1;
  bool result = serialize (c, glyphs.begin (), use_short_loca, context->plan);
  hb_serialize_context_destroy (c);
  hb_blob_destroy (new_glyf_blob);

  return result;
}