hb_vector_t<hb_glyph_info_t> subset_glyphs;
    if (unlikely (!subset_glyphs.alloc (context->plan->user_axes_location.get_population (), true)))
      return_trace (false);

    for (const auto &glyph : context->plan->glyphs)
    {
      if (!is_glyph_in_subset (glyph, context->plan))
        continue;

      hb_glyph_info_t glyph_info;
      glyph_info.codepoint = glyph.codepoint;
      glyph_info.index = glyph.index;

      subset_glyphs.push (glyph_info);
    }

    if (context->plan->normalized_coords)
    {
      // Calculate padded offsets and determine loca format
      // This is a placeholder for the actual logic to calculate offsets
      // and decide on the loca format based on the subset glyphs.
    }

    // Initialize a new glyf object for serialization
    glyf *new_glyf = new glyf();
    if (unlikely (!new_glyf->serialize (subset_glyphs, context->serializer)))
    {
      delete new_glyf;
      return_trace (false);
    }

    // Cleanup resources
    if (font)
      hb_font_destroy (font);

    // Return the result of the serialization process
    result = true; // or the appropriate result based on serialization