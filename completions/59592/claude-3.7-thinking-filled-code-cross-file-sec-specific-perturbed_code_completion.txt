hb_vector_t<glyf_impl::SubsetGlyph> subset_glyphs;
if (unlikely (!subset_glyphs.alloc (context->plan->num_output_glyphs (), true)))
{
  hb_font_destroy (font);
  return_trace (false);
}

for (unsigned i = 0; i < context->plan->num_output_glyphs (); i++)
{
  hb_codepoint_t new_glyph = i;
  hb_codepoint_t old_glyph = context->plan->old_gid_for_new_gid (new_glyph);

  subset_glyphs[i].old_glyph_index = old_glyph;
  subset_glyphs[i].new_glyph_index = new_glyph;
  if (unlikely (!_populate_subset_glyph (context->plan, font, &subset_glyphs[i])))
  {
    if (font) hb_font_destroy (font);
    subset_glyphs.fini ();
    return_trace (false);
  }
}

if (font) hb_font_destroy (font);

// Pad glyph offsets to 4 bytes for compatibility with OTS.
unsigned pad_to = 4;
unsigned subset_data_size = 0;
bool use_short_loca = true;
for (unsigned i = 0; i < subset_glyphs.length; i++)
{
  unsigned padded_size = _glyf_padding (subset_glyphs[i].length, pad_to);
  subset_data_size += padded_size;
  if (unlikely (subset_data_size > 0x1FFFFE))
    use_short_loca = false;
}

glyf *glyf_prime = context->serializer->start_embed<glyf> ();
if (unlikely (!glyf_prime)) {
  subset_glyphs.fini ();
  return_trace (false);
}

bool result = _serialize (context->serializer,
                          context->plan,
                          subset_glyphs.as_array (),
                          use_short_loca,
                          pad_to);

for (unsigned i = 0; i < subset_glyphs.length; i++)
  subset_glyphs[i].free_compiled_bytes ();

subset_glyphs.fini ();