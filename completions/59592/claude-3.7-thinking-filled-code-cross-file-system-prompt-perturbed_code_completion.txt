hb_vector_t<glyf_impl::SubsetGlyph> subset_glyphs;
if (unlikely (!subset_glyphs.alloc (context->plan->num_output_glyphs (), true)))
{
  hb_font_destroy (font);
  return_trace (false);
}

for (unsigned i = 0; i < context->plan->num_output_glyphs (); i++)
{
  hb_codepoint_t new_glyph = context->plan->new_gid_for_old_gid[i];
  if (new_glyph == HB_MAP_VALUE_INVALID) continue;

  subset_glyphs[new_glyph].old_glyph = i;
}

bool result = false;
if (font)
{
  result = _subset_glyphs (context, subset_glyphs, font);
  hb_font_destroy (font);
}
else
  result = _subset_glyphs (context, subset_glyphs);

if (unlikely (!result)) return_trace (false);

unsigned int glyf_prime_size;
unsigned int loca_prime_size;

unsigned int pad = 4;
if (context->plan->flags & HB_SUBSET_FLAGS_NO_HINTING)
  pad = 2;

bool use_short_loca = false;
if (_calculate_glyf_and_loca_prime_size (context->plan,
                                         subset_glyphs,
                                         &glyf_prime_size,
                                         &loca_prime_size,
                                         pad,
                                         &use_short_loca))
{
  glyf_impl::accelerator_t glyf;
  glyf.init (context->plan->source);

  glyf_impl::glyf_serialize_context_t glyf_ctx;
  glyf_impl::glyf_prime_t glyf_prime (use_short_loca);
  result = glyf_prime.serialize (&glyf_ctx,
                                 context->plan,
                                 subset_glyphs,
                                 glyf,
                                 context->plan->flags & HB_SUBSET_FLAGS_NO_HINTING);
  glyf.fini ();
}

for (unsigned i = 0; i < subset_glyphs.length; i++)
  subset_glyphs[i].free_compiled_bytes ();