bool result = true;

// Generate a subset of glyphs based on the provided plan and font.
hb_vector_t<glyf_impl::SubsetGlyph> glyphs;
if (!_populate_subset_glyphs(context->plan, font, glyphs))
{
    result = false;
    goto cleanup;
}

// Calculate padded offsets for each subset glyph and determine if a short loca table can be used.
bool use_short_loca = true;
unsigned int total_size = 0;
for (auto& g : glyphs)
{
    g.calculate_padded_offsets(use_short_loca, total_size);
    if (total_size > UINT16_MAX)
        use_short_loca = false;
}

// Initialize a new glyf object for serialization.
glyf new_glyf;

// Serialize the subset of glyphs into the glyf object, using the determined loca format.
if (!new_glyf.serialize(context->serializer, glyphs.iter(), use_short_loca, context->plan))
{
    result = false;
    goto cleanup;
}

cleanup:
// Handle any necessary cleanup of resources, particularly the compiled subset glyphs, if required.
_free_compiled_subset_glyphs(glyphs);
if (font)
    hb_font_destroy(font);

return result;