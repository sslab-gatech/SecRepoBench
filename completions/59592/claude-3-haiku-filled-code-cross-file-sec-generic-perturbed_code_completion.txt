// Generate a subset of glyphs based on the provided plan and font.
hb_set_t *glyphs_to_retain = hb_subset_plan_create_glyph_map (context->plan);
if (unlikely (!glyphs_to_retain))
  return_trace (false);

// Populate a list of subset glyphs, checking for failure in the process.
hb_vector_t<hb_subset_glyph_data_t> subset_glyphs;
if (unlikely (!subset_glyphs.alloc (glyphs_to_retain->get_population (), true)))
{
  hb_set_destroy (glyphs_to_retain);
  return_trace (false);
}

for (hb_codepoint_t gid : *glyphs_to_retain)
{
  hb_subset_glyph_data_t glyph_data;
  if (unlikely (!get_glyph_data (gid, &glyph_data, font)))
  {
    hb_set_destroy (glyphs_to_retain);
    subset_glyphs.fini ();
    return_trace (false);
  }
  subset_glyphs.push (glyph_data);
}
hb_set_destroy (glyphs_to_retain);

// Calculate padded offsets for each subset glyph and determine if a short loca table can be used.
bool use_short_loca = true;
hb_vector_t<hb_uint32_t> glyph_offsets;
if (unlikely (!calculate_glyph_offsets (subset_glyphs, &glyph_offsets, &use_short_loca)))
{
  subset_glyphs.fini_deep ();
  return_trace (false);
}

// Initialize a new glyf object for serialization.
glyf *glyf_prime = c->serializer->embed<glyf> ();
if (unlikely (!glyf_prime))
{
  subset_glyphs.fini_deep ();
  return_trace (false);
}

// Serialize the subset of glyphs into the glyf object, using the determined loca format.
if (unlikely (!glyf_prime->serialize (c->serializer, subset_glyphs, glyph_offsets, use_short_loca)))
{
  subset_glyphs.fini_deep ();
  return_trace (false);
}

// Handle any necessary cleanup of resources, particularly the compiled subset glyphs, if required.
subset_glyphs.fini_deep ();

// Destroy the font if it was created for instancing, after using it.
if (font)
  hb_font_destroy (font);

bool result = true;
return_trace (result);