bool subset_glyphs(hb_subset_context_t *context, hb_font_t *font, hb_set_t *glyphs_to_retain) {
    // Generate a subset of glyphs based on the provided plan and font
    hb_set_t *glyphs_to_drop = hb_set_create();
    if (!hb_subset_plan_populate_glyph_list(context->plan, glyphs_to_retain, glyphs_to_drop)) {
        hb_set_destroy(glyphs_to_drop);
        return false;
    }

    // Populate a list of subset glyphs, checking for failure in the process
    hb_codepoint_t glyph;
    hb_set_for_each(glyphs_to_retain, glyph, {
        if (!hb_subset_plan_add_table(context->plan, HB_OT_TAG_glyf, glyph)) {
            hb_set_destroy(glyphs_to_drop);
            return false;
        }
    });

    // Calculate padded offsets for each subset glyph and determine if a short loca table can be used
    bool use_short_loca = hb_subset_plan_calculate_glyph_offsets(context->plan);

    // Initialize a new glyf object for serialization
    hb_blob_t *glyf_blob = hb_subset_plan_create_glyf_blob(context->plan);
    if (!glyf_blob) {
        hb_set_destroy(glyphs_to_drop);
        return false;
    }

    // Serialize the subset of glyphs into the glyf object, using the determined loca format
    hb_blob_t *loca_blob = hb_subset_plan_create_loca_blob(context->plan, use_short_loca);
    if (!loca_blob) {
        hb_blob_destroy(glyf_blob);
        hb_set_destroy(glyphs_to_drop);
        return false;
    }

    // Handle any necessary cleanup of resources, particularly the compiled subset glyphs, if required
    hb_subset_plan_add_table(context->plan, HB_OT_TAG_glyf, glyf_blob);
    hb_subset_plan_add_table(context->plan, HB_OT_TAG_loca, loca_blob);
    hb_set_destroy(glyphs_to_drop);

    // Return the result of the serialization process as the function's output
    return true;
}