bool subset (hb_subset_context_t *context) const
  {
    TRACE_SUBSET (this);

    if (!has_valid_glyf_format (context->plan->source)) {
      // glyf format is unknown don't attempt to subset it.
      DEBUG_MSG (SUBSET, nullptr,
                 "unkown glyf format, dropping from subset.");
      return_trace (false);
    }

    hb_font_t *font = nullptr;
    if (context->plan->normalized_coords)
    {
      font = _create_font_for_instancing (context->plan);
      if (unlikely (!font))
	return_trace (false);
    }

    // Generate a subset of glyphs based on the provided plan and font.
    hb_set_t *glyphs = context->plan->glyphs;
    unsigned int num_glyphs = glyphs->get_population ();
    hb_vector_t<SubsetGlyph> subset_glyphs;
    if (unlikely (!subset_glyphs.alloc (num_glyphs, true)))
      return_trace (false);

    for (unsigned int i = 0; i < num_glyphs; i++) {
      hb_codepoint_t glyph_id = glyphs->get (i);
      SubsetGlyph *subset_glyph = new (subset_glyphs.push ()) SubsetGlyph (glyph_id);
      if (unlikely (!subset_glyph->init (context->plan->source, font)))
        return_trace (false);
    }

    // Populate a list of subset glyphs, checking for failure in the process.
    // Destroy the font if it was created for instancing, after using it.
    if (font) {
      hb_font_destroy (font);
      font = nullptr;
    }

    // Calculate padded offsets for each subset glyph and determine if a short loca table can be used.
    bool use_short_loca = true;
    for (unsigned int i = 0; i < num_glyphs; i++) {
      if (subset_glyphs[i].get_padded_size () > 0xFF) {
        use_short_loca = false;
        break;
      }
    }

    // Initialize a new glyf object for serialization.
    glyf *glyf_prime = context->serializer->start_embed<glyf> ();
    if (unlikely (!glyf_prime)) return_trace (false);

    // Serialize the subset of glyphs into the glyf object, using the determined loca format.
    if (!glyf_prime->serialize (context->serializer, subset_glyphs, use_short_loca))
      return_trace (false);

    // Handle any necessary cleanup of resources, particularly the compiled subset glyphs, if required.
    for (unsigned int i = 0; i < num_glyphs; i++)
      subset_glyphs[i].free_compiled_bytes ();

    // Return the result of the serialization process as the function's output.
    return_trace (true);
  }