// Generate a subset of glyphs based on the provided plan and font.
// Populate a list of subset glyphs, checking for failure in the process.
// Destroy the font if it was created for instancing, after using it.
// Calculate padded offsets for each subset glyph and determine if a short loca table can be used.
// Initialize a new glyf object for serialization.
// Serialize the subset of glyphs into the glyf object, using the determined loca format.
// Handle any necessary cleanup of resources, particularly the compiled subset glyphs, if required.
// Return the result of the serialization process as the function's output.
hb_glyf_t *glyf = hb_glyf_create ();
if (unlikely (!glyf)) return_trace (false);

hb_face_t *source = context->plan->source;
hb_tag_t loca_tag = HB_TAG ('l','o','c','a');
if (!_is_table_present (source, loca_tag))
{
  // If the loca table is not present, we can't use a short loca table.
  // In this case, we need to serialize the subset glyphs into the glyf object
  // using the default loca format.
  if (unlikely (!serialize_glyf (glyf, context->serializer)))
    return_trace (false);
}
else
{
  // If the locf table is present, we can use a short loca table.
  // In this case, we need to calculate the padded offsets for each subset glyph
  // and serialize the subset glyphs into the glyf object using the short loca format.
  if (unlikely (!serialize_short_loca_glyf (glyf, context->serializer)))
    return_trace (false);
}

// Clean up the compiled subset glyphs.
free_compiled_bytes ();

// Clean up the font if it was created for instancing.
if (font)
{
  hb_font_destroy (font);
  font = nullptr;
}

// Clean up the glyf object.
hb_glyf_destroy (glyf);
glyf = nullptr;

return true;