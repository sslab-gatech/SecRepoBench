// Generate a subset of glyphs based on the provided plan and font.
  bool result = _populate_subset_glyphs (plan, font, glyphs);

  // Calculate padded offsets for each subset glyph and determine if a short loca table can be used.
  bool use_short_loca = false;
  hb_vector_t<hb_uint32_t> loca_table;
  for (auto &g : glyphs)
  {
    hb_uint32_t start = g.dest_start.get_length ();
    hb_uint32_t end = g.dest_end.get_length ();
    loca_table.push (start);
    use_short_loca = use_short_loca || (end - start > 0xFFFF);
  }
  loca_table.push (glyphs.back().dest_end.get_length());

  // Initialize a new glyf object for serialization.
  glyf subset_glyf;

  // Serialize the subset of glyphs into the glyf object, using the determined loca format.
  if (use_short_loca)
  {
    hb_vector_t<hb_uint16_t> short_loca_table;
    for (auto &l : loca_table)
      short_loca_table.push (l);
    subset_glyf.serialize (c, short_loca_table.begin(), true, plan);
  }
  else
  {
    subset_glyf.serialize (c, loca_table.begin(), false, plan);
  }

  // Handle any necessary cleanup of resources, particularly the compiled subset glyphs, if required.
  if (!plan->pinned_at_default)
    _free_compiled_subset_glyphs (glyphs);

  // Return the result of the serialization process as the function's output.
  return result;