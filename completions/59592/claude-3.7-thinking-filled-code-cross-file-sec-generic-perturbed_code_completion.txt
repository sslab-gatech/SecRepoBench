hb_vector_t<glyf_impl::SubsetGlyph> subset_glyphs;
if (unlikely (!subset_glyphs.alloc (context->plan->num_output_glyphs (), true)))
{
  hb_font_destroy (font);
  return_trace (false);
}

for (unsigned i = 0; i < context->plan->num_output_glyphs (); i++)
{
  hb_codepoint_t new_glyph = context->plan->new_gid_for_old_gid[i];
  if (new_glyph == HB_MAP_VALUE_INVALID) continue;

  subset_glyphs[new_glyph].old_glyph = i;
}

bool result = false;
if (unlikely (!_populate_subset_glyphs (context->plan, font, subset_glyphs)))
{
  if (font) hb_font_destroy (font);
  return_trace (false);
}

if (font) hb_font_destroy (font);

unsigned int glyf_prime_size;
unsigned int loca_prime_size;
bool use_short_loca = false;
if (unlikely (!_calculate_glyf_and_loca_prime_size (context->plan,
                                                    subset_glyphs,
                                                    &glyf_prime_size,
                                                    &loca_prime_size,
                                                    &use_short_loca)))
  return_trace (false);

glyf_impl::accelerator_t glyf;
glyf.init (context->plan->source);
glyf_impl::glyf_serialize_context_t glyf_ctx;
if (unlikely (!glyf_ctx.start_serialize (context->serializer, glyf_prime_size)))
{
  glyf.fini ();
  return_trace (false);
}

result = _serialize_glyf_and_loca (context->plan,
                                   &glyf,
                                   &glyf_ctx,
                                   subset_glyphs,
                                   use_short_loca);

glyf_ctx.end_serialize ();
glyf.fini ();

for (unsigned i = 0; i < subset_glyphs.length; i++)
  subset_glyphs[i].free_compiled_bytes ();