hb_vector_t<const glyf::SubsetGlyph*> subset_glyphs;
    bool result = compile_subset (context->plan, font, subset_glyphs);

    if (font)
      hb_font_destroy (font);

    if (unlikely (!result))
      return_trace (false);

    /*
     * Now that we have the compiled glyphs, we can calculate the padded offsets
     * for each glyph.
     */
    size_t offset = 0;
    bool short_loca = true;
    for (unsigned int i = 0; i < subset_glyphs.length; ++i)
    {
      glyf::SubsetGlyph* glyph = const_cast<glyf::SubsetGlyph*>(subset_glyphs[i]);
      glyph->offset = offset;
      offset += glyph->padded_length;
      if (glyph->padded_length >= 0x20000)
        short_loca = false;
    }

    glyf new_glyf (context->serializer->get_face ());
    new_glyf.loca_format = short_loca ? 0 : 1;

    result = new_glyf.serialize (context->serializer, subset_glyphs);

    /* cleanup */
    for (unsigned int i = 0; i < subset_glyphs.length; ++i)
    {
      glyf::SubsetGlyph* glyph = const_cast<glyf::SubsetGlyph*>(subset_glyphs[i]);
      glyph->free_compiled_bytes ();
    }