bool
glyf::subset (hb_subset_context_t *context) const
{
  TRACE_SUBSET (this);

  if (!has_valid_glyf_format (context->plan->source)) {
    // glyf format is unknown don't attempt to subset it.
    DEBUG_MSG (SUBSET, nullptr,
               "unkown glyf format, dropping from subset.");
    return_trace (false);
  }

  hb_font_t *font = nullptr;
  if (context->plan->normalized_coords)
  {
    font = _create_font_for_instancing (context->plan);
    if (unlikely (!font))
      return_trace (false);
  }

  // Generate a subset of glyphs based on the provided plan and font.
  // Populate a list of subset glyphs, checking for failure in the process.
  // Destroy the font if it was created for instancing, after using it.
  // Calculate padded offsets for each subset glyph and determine if a short loca table can be used.
  // Initialize a new glyf object for serialization.
  // Serialize the subset of glyphs into the glyf object, using the determined loca format.
  // Handle any necessary cleanup of resources, particularly the compiled subset glyphs, if required.
  // Return the result of the serialization process as the function's output.
  hb_vector_t<glyf_impl::SubsetGlyph> glyphs;
  if (unlikely (! _populate_subset_glyphs (context->plan, font, glyphs)))
  {
    if (font)
      hb_font_destroy (font);
    return_trace (false);
  }

  if (font)
    hb_font_destroy (font);

  hb_blob_t *blob = hb_blob_create (glyphs.get_length () * sizeof (glyf_impl::SubsetGlyph), HB_MEMORY_MODE_READONLY);
  if (unlikely (!blob))
    return_trace (false);

  hb_bytes_t *data = hb_blob_get_data (blob, nullptr);
  if (unlikely (!data))
  {
    hb_blob_destroy (blob);
    return_trace (false);
  }

  glyf_impl::SubsetGlyph *p = (glyf_impl::SubsetGlyph *) data;
  for (unsigned i = 0; i < glyphs.get_length (); i++)
  {
    p[i].serialize (context->c, context->plan, glyphs.get_length ());
  }

  hb_blob_destroy (blob);
  return_trace (true);
}