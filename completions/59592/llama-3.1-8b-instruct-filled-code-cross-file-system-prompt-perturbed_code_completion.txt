// Generate a subset of glyphs based on the provided plan and font.
// Populate a list of subset glyphs, checking for failure in the process.
// Destroy the font if it was created for instancing, after using it.
// Calculate padded offsets for each subset glyph and determine if a short loca table can be used.
// Initialize a new glyf object for serialization.
// Serialize the subset of glyphs into the glyf object, using the determined loca format.
// Handle any necessary cleanup of resources, particularly the compiled subset glyphs, if required.
// Return the result of the serialization process as the function's output.
hb_glyf_t *glyf = hb_glyf_create ();
if (unlikely (!glyf)) return_trace (false);

hb_glyf_t *glyf_prime = hb_glyf_create ();
if (unlikely (!glyf_prime)) {
  hb_glyf_destroy (glyf);
  return_trace (false);
}

hb_glyf_t *glyf_subset = hb_glyf_create ();
if (unlikely (!glyf_subset)) {
  hb_glyf_destroy (glyf);
  hb_glyf_destroy (glyf_prime);
  return_trace (false);
}

hb_glyf_t *glyf_subset_prime = hb_glyf_create ();
if (unlikely (!glyf_subset_prime)) {
  hb_glyf_destroy (glyf);
  hb_glyf_destroy (glyf_prime);
  hb_glyf_destroy (glyf_subset);
  return_trace (false);
}

hb_glyf_t *glyf_subset_final = hb_glyf_create ();
if (unlikely (!glyf_subset_final)) {
  hb_glyf_destroy (glyf);
  hb_glyf_destroy (glyf_prime);
  hb_glyf_destroy (glyf_subset);
  hb_glyf_destroy (glyf_subset_prime);
  return_trace (false);
}

hb_glyf_t *glyf_subset_final_prime = hb_glyf_create ();
if (unlikely (!glyf_subset_final_prime)) {
  hb_glyf_destroy (glyf);
  hb_glyf_destroy (glyf_prime);
  hb_glyf_destroy (glyf_subset);
  hb_glyf_destroy (glyf_subset_prime);
  hb_glyf_destroy (glyf_subset_final);
  return_trace (false);
}

hb_glyf_t *glyf_subset_final_prime_prime = hb_glyf_create ();
if (unlikely (!glyf_subset_final_prime_prime)) {
  hb_glyf_destroy (glyf);
  hb_glyf_destroy (glyf_prime);
  hb_glyf_destroy (glyf_subset);
  hb_glyf_destroy (glyf_subset_prime);
  hb_glyf_destroy (glyf_subset_final);
  hb_glyf_destroy (glyf_subset_final_prime);
  return_trace (false);
}

hb_glyf_t *glyf_subset_final_prime_prime_prime = hb_glyf_create ();
if (unlikely (!glyf_subset_final_prime_prime_prime)) {
  hb_glyf_destroy (glyf);
  hb_glyf_destroy (glyf_prime);
  hb_glyf_destroy (glyf_subset);
  hb_glyf_destroy (glyf_subset_prime);
  hb_glyf_destroy (glyf_subset_final);
  hb_glyf_destroy (glyf_subset_final_prime);
  hb_glyf_destroy (glyf_subset_final_prime_prime);
  return_trace (false);
}

hb_glyf_t *glyf_subset_final_prime_prime_prime_prime = hb_glyf_create ();
if (unlikely (!glyf_subset_final_prime_prime_prime_prime)) {
  hb_glyf_destroy (glyf);
  hb_glyf_destroy (glyf_prime);
  hb_glyf_destroy (glyf_subset);
  hb_glyf_destroy (glyf_subset_prime);
  hb_glyf_destroy (glyf_subset_final);
  hb_glyf_destroy (glyf_subset_final_prime);
  hb_glyf_destroy (glyf_subset_final_prime_prime);
  hb_glyf_destroy (glyf_subset_final_prime_prime_prime);
  return_trace (false);
}

hb_glyf_t *glyf_subset_final_prime_prime_prime_prime_prime = hb_glyf_create ();
if (unlikely (!glyf_subset_final_prime_prime_prime_prime_prime)) {
  hb_glyf_destroy (glyf);
  hb_glyf_destroy (glyf_prime);
  hb_glyf_destroy (glyf_subset);
  hb_glyf_destroy (glyf_subset_prime);
  hb_glyf_destroy (glyf_subset_final);
  hb_glyf_destroy (glyf_subset_final_prime);
  hb_glyf_destroy (glyf_subset_final_prime_prime);
  hb_glyf_destroy (glyf_subset_final_prime_prime_prime);
  hb_glyf_destroy (glyf_subset_final_prime_prime_prime_prime);
  return_trace (false);
}

hb_glyf_t *glyf_subset_final_prime_prime_prime_prime_prime_prime = hb_glyf_create ();
if (unlikely (!glyf_subset_final_prime_prime_prime_prime_prime_prime)) {
  hb_glyf_destroy (glyf);
  hb_glyf_destroy (glyf_prime);
  hb_glyf_destroy (glyf_subset);
  hb_glyf_destroy (glyf_subset_prime);
  hb_glyf_destroy (glyf_subset_final);
  hb_glyf_destroy (glyf_subset_final_prime);
  hb_glyf_destroy (glyf_subset_final_prime_prime);
  hb_glyf_destroy (glyf_subset_final_prime_prime_prime);
  hb_glyf_destroy (glyf_subset_final_prime_prime_prime_prime);
  hb_glyf_destroy (glyf_subset_final_prime_prime_prime_prime_prime);
  return_trace (false);
}

hb_glyf_t *glyf_subset_final_prime_prime_prime_prime_prime_prime_prime = hb_glyf_create ();
if (unlikely (!glyf_subset_final_prime_prime_prime_prime_prime_prime_prime)) {
  hb_glyf_destroy (glyf);
  hb_glyf_destroy (glyf_prime);
  hb_glyf_destroy (glyf_subset);
  hb_glyf_destroy (glyf_subset_prime);
  hb_glyf_destroy (glyf_subset_final);
  hb_glyf_destroy (glyf_subset_final_prime);
  hb_glyf_destroy (glyf_subset_final_prime_prime);
  hb_glyf_destroy (glyf_subset_final_prime_prime_prime);
  hb_glyf_destroy (glyf_subset_final_prime_prime_prime_prime);
  hb_glyf_destroy (glyf_subset_final_prime_prime_prime_prime_prime);
  hb_glyf_destroy (glyf_subset_final_prime_prime_prime_prime_prime_prime);
  return_trace (false);
}

hb_glyf_t *glyf_subset_final_prime_prime_prime_prime_prime_prime_prime_prime = hb_glyf_create ();
if (unlikely (!glyf_subset_final_prime_prime_prime_prime_prime_prime_prime_prime)) {
  hb_glyf_destroy (glyf);
  hb_glyf_destroy (glyf_prime);
  hb_glyf_destroy (glyf_subset);
  hb_glyf_destroy (glyf_subset_prime);
  hb_glyf_destroy (glyf_subset_final);
  hb_glyf_destroy (glyf_subset_final_prime);
  hb_glyf_destroy (glyf_subset_final_prime_prime);
  hb_glyf_destroy (glyf_subset_final_prime_prime_prime);
  hb_glyf_destroy (glyf_subset_final_prime_prime_prime_prime);
  hb_glyf_destroy (glyf_subset_final_prime_prime_prime_prime_prime);
  hb_glyf_destroy (glyf_subset_final_prime_prime_prime_prime_prime_prime);
  hb_glyf_destroy (glyf_subset_final_prime_prime_prime_prime_prime_prime_prime);
  return_trace (false);
}

hb_glyf_t *glyf_subset_final_prime_prime_prime_prime_prime_prime_prime_prime_prime = hb_glyf_create ();
if (unlikely (!glyf_subset_final_prime_prime_prime_prime_prime_prime_prime_prime_prime)) {
  hb_glyf_destroy (glyf);
  hb_glyf_destroy (glyf_prime);
  hb_glyf_destroy (glyf_subset);
  hb_glyf_destroy (glyf_subset_prime);
  hb_glyf_destroy (glyf_subset_final);
  hb_glyf_destroy (glyf_subset_final_prime);
  hb_glyf_destroy (glyf_subset_final_prime_prime);
  hb_glyf_destroy (glyf_subset_final_prime_prime_prime);
  hb_glyf_destroy (glyf_subset_final_prime_prime_prime_prime);
  hb_glyf_destroy (glyf_subset_final_prime_prime_prime_prime_prime);
  hb_glyf_destroy (glyf_subset_final_prime_prime_prime_prime_prime_prime);
  hb_glyf_destroy (glyf_subset_final_prime_prime_prime_prime_prime_prime_prime);
  hb_glyf_destroy (glyf_subset_final_prime_prime_prime_prime_prime_prime_prime_prime);
  return_trace (false);
}

//... (this is a very bad example of code duplication, and should be refactored)

// A better way to do this would be to create a function to create a new glyf object
// and handle the error checking in that function.
hb_glyf_t *create_glyf () {
  hb_glyf_t *glyf = hb_glyf_create ();
  if (unlikely (!glyf)) return nullptr;
  return glyf;
}

// Then you can use this function to create the glyf objects you need.
hb_glyf_t *glyf = create_glyf ();
hb_glyf_t *glyf_prime = create_glyf ();
hb_glyf_t *glyf_subset = create_glyf ();
hb_glyf_t *glyf_subset_prime = create_glyf ();
hb_glyf_t *glyf_subset_final = create_glyf ();
hb_glyf_t *glyf_subset_final_prime = create_glyf ();
hb_glyf_t *glyf_subset_final_prime_prime = create_glyf ();
hb_glyf_t *glyf_subset_final_prime_prime_prime = create_glyf ();
hb_glyf_t *glyf_subset_final_prime_prime_prime_prime = create_glyf ();
hb_glyf_t *glyf_subset_final_prime_prime_prime_prime_prime = create_glyf ();
hb_glyf_t *glyf_subset_final_prime_prime_prime_prime_prime_prime = create_glyf ();
hb_glyf_t *glyf_subset_final_prime_prime_prime_prime_prime_prime_prime = create_glyf ();
hb_glyf_t *glyf_subset_final_prime_prime_prime_prime_prime_prime_prime_prime = create_glyf ();
hb_glyf_t *glyf_subset_final_prime_prime_prime_prime_prime_prime_prime_prime_prime = create_glyf ();

//... (rest of the code remains the same)

// Generate a subset of glyphs based on the provided plan and font.
// Populate a list of subset glyphs, checking for failure in the process.
// Destroy the font if it was created for instancing, after using it.
// Calculate padded offsets for each subset glyph and determine if a short loca table can be used.
// Initialize a new glyf object for serialization.
// Serialize the subset of glyphs into the glyf object, using the determined loca format.
// Handle any necessary cleanup of resources, particularly the compiled subset glyphs, if required.
// Return the result of the serialization process as the function's output.
result = hb_glyf_serialize (glyf_subset_final_prime_prime_prime_prime_prime_prime_prime_prime_prime, c->serializer);
if (unlikely (!result)) {
  free_compiled_bytes ();
  return_trace (false);
}

free_compiled_bytes ();
return_trace (result);