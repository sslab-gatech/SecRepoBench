hb_vector_t<glyf_impl::SubsetGlyph> subset_glyphs;
    if (!_populate_subset_glyphs(context->plan, font, subset_glyphs)) {
      if (font) hb_font_destroy(font);
      return_trace(false);
    }

    // Calculate padded offsets and determine if a short loca table can be used
    unsigned int offset = 0;
    bool use_short_loca = true;
    for (auto &subset_glyph : subset_glyphs) {
      subset_glyph.dest_start = offset;
      offset += subset_glyph.get_padded_length();
      if (offset >= 0x20000) use_short_loca = false;
    }

    // Initialize a new glyf object for serialization
    glyf new_glyf;
    if (!new_glyf.serialize(context->c, subset_glyphs, use_short_loca, context->plan)) {
      _free_compiled_subset_glyphs(subset_glyphs);
      if (font) hb_font_destroy(font);
      return_trace(false);
    }

    // Cleanup resources
    _free_compiled_subset_glyphs(subset_glyphs);
    if (font) hb_font_destroy(font);

    return_trace(true);