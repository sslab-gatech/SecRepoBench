bool result = false;

// Populate a list of glyphs to subset.
hb_vector_t<SubsetGlyph> subset_glyphs;
if (unlikely (!subset_glyphs.alloc (context->plan->num_output_glyphs ())))
{
  if (font) hb_font_destroy (font);
  return_trace (false);
}

if (unlikely (!build_subset_glyphs (context->plan, font, subset_glyphs)))
{
  if (font) hb_font_destroy (font);
  return_trace (false);
}

// Determine if the subset can use short loca.
bool can_use_short_loca = true;
for (auto &s_glyph : subset_glyphs)
{
  if (!s_glyph.fits_in_short_loca ())
  {
    can_use_short_loca = false;
    break;
  }
}

// Initialize a new glyf object for serialization.
glyf *glyf_prime = context->serializer->start_embed<glyf> ();
if (unlikely (!glyf_prime))
{
  if (font) hb_font_destroy (font);
  return_trace (false);
}

// Serialize the subset glyphs.
result = glyf_prime->serialize (context->serializer, subset_glyphs, can_use_short_loca);

// Free compiled glyph bytes and destroy the font if we created one.
for (auto &s_glyph : subset_glyphs)
  s_glyph.free_compiled_bytes ();

if (font)
  hb_font_destroy (font);

return_trace (result);