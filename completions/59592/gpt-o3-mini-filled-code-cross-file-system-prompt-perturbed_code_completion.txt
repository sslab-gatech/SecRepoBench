bool result = false;
{
  // Step 1: Compile the subset glyphs.
  hb_vector_t<SubsetGlyph> subset_glyphs;
  if (!subset_glyphs.alloc (context->plan->num_glyphs, false))
  {
    if (font)
      hb_font_destroy (font);
    return_trace (false);
  }
  for (unsigned int gid = 0; gid < context->plan->num_glyphs; gid++)
  {
    SubsetGlyph sg;
    if (!compile_subset_glyph (context->plan, font, gid, sg))
    {
      // Cleanup any already compiled glyphs.
      for (unsigned int i = 0; i < subset_glyphs.length; i++)
        subset_glyphs[i].free_compiled_bytes ();
      if (font)
        hb_font_destroy (font);
      return_trace (false);
    }
    subset_glyphs.push (sg);
  }

  // Step 2: Calculate padded offsets for each subset glyph and determine loca format.
  bool use_short_loca = determine_loca_format (subset_glyphs);

  // Step 3: Initialize a new glyf object for serialization.
  glyf new_glyf;
  if (!new_glyf.init (use_short_loca))
  {
    for (unsigned int i = 0; i < subset_glyphs.length; i++)
      subset_glyphs[i].free_compiled_bytes ();
    if (font)
      hb_font_destroy (font);
    return_trace (false);
  }

  // Step 4: Serialize the subset glyphs into the glyf object.
  result = new_glyf.serialize (context->serializer, subset_glyphs, use_short_loca);

  // Step 5: Clean up compiled glyph resources.
  for (unsigned int i = 0; i < subset_glyphs.length; i++)
    subset_glyphs[i].free_compiled_bytes ();

  // Destroy the instancing font if one was created.
  if (font)
    hb_font_destroy (font);
}