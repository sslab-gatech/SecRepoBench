bool result = true;
hb_vector_t<const hb_subset_glyphset_t*> subset_glyphs;
if (unlikely (!subset_glyphs.alloc (context->plan->glyphset.get_population (), true)))
  return_trace (false);

for (auto _ : context->plan->glyphset)
{
  hb_subset_glyphset_t *glyphset = &subset_glyphs[i++];
  glyphset->glyph = _;
  glyphset->index = hb_subset_plan_t::get_glyph_index (context->plan, _);
  if (unlikely (glyphset->index == HB_NOT_FOUND_GLYPH))
  {
    result = false;
    break;
  }
}

if (font)
  hb_font_destroy (font);

if (result)
{
  unsigned int max_offset = 0;
  for (auto _ : subset_glyphs)
  {
    max_offset = hb_max (max_offset, _->glyph->get_path ().get_points_size ());
  }

  bool use_short_loca = max_offset <= 0xFFFF;

  glyf glyf_prime;
  glyf_prime.loca_format = use_short_loca? 1 : 2;

  for (auto _ : subset_glyphs)
  {
    hb_blob_t *blob = _->glyph->serialize (context->serializer, glyf_prime.loca_format);
    if (unlikely (!blob))
    {
      result = false;
      break;
    }
    glyf_prime.add_glyph (blob, _->index);
  }

  if (result)
  {
    if (unlikely (!context->serializer->embed (glyf_prime)))
      result = false;
  }
}

for (auto _ : subset_glyphs)
  _->glyph->free_compiled_bytes ();

return result;