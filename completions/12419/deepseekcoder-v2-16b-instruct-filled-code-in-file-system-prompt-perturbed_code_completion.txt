reader ATTRIBUTE_UNUSED)
{
    xmlChar *resbuf;
    xmlBufferPtr buff, buff2;
    xmlDocPtr doc;

    if (xmlTextReaderExpand(reader) == NULL) {
        return NULL;
    }
    doc = reader->node->doc;
    buff = xmlBufferCreate();
    if (xmlNodeDump(buff, doc, reader->node, 0, 0) == -1) {
        xmlBufferFree(buff);
        return NULL;
    }
    buff2 = xmlBufferCreate();
    for (xmlNodePtr node = reader->node->children; node != NULL;
         node = node->next) {
        /* XXX: Why is the node copied? */
        if (xmlNodeDump(buff2, doc, node, 0, 0) == -1) {
            xmlBufferFree(buff);
            xmlBufferFree(buff2);
            return NULL;
        }
        xmlBufferCat(buff, buff2->content);
    }
    resbuf = buff->content;
    buff->content = NULL;

    xmlBufferFree(buff);
    xmlBufferFree(buff2);
    return resbuf;
}
#endif

/**
 * xmlTextReaderReadString:
 * @reader:  the xmlTextReaderPtr used
 *
 * Reads the contents of the current node and concatenates the text of all
 * child nodes.
 *
 * Returns a string containing the text content, or NULL if the current node
 *         is neither an element nor attribute, or has no child nodes. The
 *         string must be deallocated by the caller.
 */
xmlChar *
xmlTextReaderReadString(xmlTextReaderPtr reader) {
    xmlChar *resbuf;
    xmlBufferPtr buff;
    xmlNodePtr node;

    if (xmlTextReaderExpand(reader) == NULL) {
        return NULL;
    }
    buff = xmlBufferCreate();
    for (node = reader->node->children; node != NULL; node = node->next) {
        if ((node->type == XML_TEXT_NODE) || (node->type == XML_CDATA_SECTION_NODE)) {
            xmlBufferCat(buff, node->content);
        }
    }
    resbuf = buff->content;
    buff->content = NULL;

    xmlBufferFree(buff);
    return resbuf;
}

/**
 * xmlTextReaderGetAttribute:
 * @reader:  the xmlTextReaderPtr used
 * @name:  the name of the attribute
 *
 * Get the value of an attribute of the current node.
 *
 * Returns the attribute value or NULL if the attribute is not found.
 */
xmlChar *
xmlTextReaderGetAttribute(xmlTextReaderPtr reader, const xmlChar *name) {
    xmlAttrPtr attr;

    if ((reader == NULL) || (reader->node == NULL))
        return(NULL);
    if (reader->node->type != XML_ELEMENT_NODE)
        return(NULL);
    attr = xmlHasProp(reader->node, name);
    if (attr == NULL)
        return(NULL);
    return(xmlNodeGetContent(attr));
}

/**
 * xmlTextReaderGetAttributeNo:
 * @reader:  the xmlTextReaderPtr used
 * @name:  the name of the attribute
 * @value:  pointer to store the attribute value
 *
 * Get the value of an attribute of the current node.
 *
 * Returns 1 if the attribute is found, 0 otherwise.
 */
int
xmlTextReaderGetAttributeNo(xmlTextReaderPtr reader, const xmlChar *name, xmlChar **value) {
    xmlAttrPtr attr;

    if ((reader == NULL) || (reader->node == NULL))
        return(0);
    if (reader->node->type != XML_ELEMENT_NODE)
        return(0);
    attr = xmlHasProp(reader->node, name);
    if (attr == NULL)
        return(0);
    if (value != NULL)
        *value = xmlNodeGetContent(attr);
    return(1);
}

/**
 * xmlTextReaderGetAttributeNs:
 * @reader:  the xmlTextReaderPtr used
 * @localName:  the local name of the attribute
 * @namespaceURI:  the namespace URI of the attribute
 * @value:  pointer to store the attribute value
 *
 * Get the value of an attribute of the current node.
 *
 * Returns 1 if the attribute is found, 0 otherwise.
 */
int
xmlTextReaderGetAttributeNs(xmlTextReaderPtr reader,
                            const xmlChar *localName,
                            const xmlChar *namespaceURI,
                            xmlChar **value) {
    xmlAttrPtr attr;

    if ((reader == NULL) || (reader->node == NULL))
        return(0);
    if (reader->node->type != XML_ELEMENT_NODE)
        return(0);
    attr = xmlGetProp(reader->node, localName, namespaceURI);
    if (attr == NULL)
        return(0);
    if (value != NULL)
        *value = xmlNodeGetContent(attr);
    return(1);
}

/**
 * xmlTextReaderGetParserProp:
 * @reader:  the xmlTextReaderPtr used
 * @prop:  the property to get
 *
 * Get the value of a parser property.
 *
 * Returns the property value or NULL if the property is not found.
 */
xmlChar *
xmlTextReaderGetParserProp(xmlTextReaderPtr reader, int prop) {
    if (reader == NULL)
        return(NULL);
    switch (prop) {
    case XML_PARSER_DTDVALID:
        if (reader->validate & XML_TEXTREADER_VALIDATE_DTD)
            return(BAD_CAST "1");
        else
            return(BAD_CAST "0");
    case XML_PARSER_SCHEMAVALID:
#ifdef LIBXML_SCHEMAS_ENABLED
        if (reader->validate & XML_TEXTREADER_VALIDATE_RNG)
            return(BAD_CAST "1");
        else if (reader->validate & XML_TEXTREADER_VALIDATE_XSD)
            return(BAD_CAST "1");
        else
            return(BAD_CAST "0");
#else
        return(BAD_CAST "0");
#endif
    case XML_PARSER_VALIDATE:
        if (reader->validate != XML_TEXTREADER_NOT_VALIDATE)
            return(BAD_CAST "1");
        else
            return(BAD_CAST "0");
    case XML_PARSER_XINCLUDE:
#ifdef LIBXML_XINCLUDE_ENABLED
        if (reader->xinclude)
            return(BAD_CAST "1");
        else
            return(BAD_CAST "0");
#else
        return(BAD_CAST "0");
#endif
    case XML_PARSER_SUBST_ENTITIES:
        if (reader->ctxt->replaceEntities)
            return(BAD_CAST "1");
        else
            return(BAD_CAST "0");
    case XML_PARSER_HAS_ENC_DECL:
        if (reader->ctxt->hasExternalSubset)
            return(BAD_CAST "1");
        else
            return(BAD_CAST "0");
    case XML_PARSER_HAS_STANDALONE_DECL:
        if (reader->ctxt->standalone != XML_STANDALONE_NO)
            return(BAD_CAST "1");
        else
            return(BAD_CAST "0");
    case XML_PARSER_HAS_DOCTYPE:
        if (reader->ctxt->hasInternalSubset)
            return(BAD_CAST "1");
        else
            return(BAD_CAST "0");
    case XML_PARSER_IS_STANDALONE:
        if (reader->ctxt->standalone != XML_STANDALONE_NO)
            return(BAD_CAST "1");
        else
            return(BAD_CAST "0");
    case XML_PARSER_LOADED_PERCENT:
        if (reader->ctxt->instate == XML_PARSER_EOF)
            return(BAD_CAST "100");
        else
            return(BAD_CAST "0");
    case XML_PARSER_ENTITY_PARSING:
        if (reader->ctxt->options & XML_PARSE_NOENT)
            return(BAD_CAST "0");
        else
            return(BAD_CAST "1");
    case XML_PARSER_DTDLOAD:
        if (reader->ctxt->loadsubset)
            return(BAD_CAST "1");
        else
            return(BAD_CAST "0");
    case XML_PARSER_SCHEMA:
#ifdef LIBXML_SCHEMAS_ENABLED
        if (reader->ctxt->valid)
            return(BAD_CAST "1");
        else
            return(BAD_CAST "0");
#else
        return(BAD_CAST "0");
#endif
    case XML_PARSER_NAMESPACE:
        if (reader->ctxt->nsNr > 0)
            return(BAD_CAST "1");
        else
            return(BAD_CAST "0");
    case XML_PARSER_VALID:
        if (reader->ctxt->valid)
            return(BAD_CAST "1");
        else
            return(BAD_CAST "0");
    case XML_PARSER_NO_NETWORK_BYTE_ORDER_WARNING:
        if (reader->ctxt->options & XML_PARSE_NOBLANKS)
            return(BAD_CAST "1");
        else
            return(BAD_CAST "0");
    case XML_PARSER_NO_XINCLUDE:
#ifdef LIBXML_XINCLUDE_ENABLED
        if (reader->ctxt->options & XML_PARSE_NOXINCNODE)
            return(BAD_CAST "1");
        else
            return(BAD_CAST "0");
#else
        return(BAD_CAST "0");
#endif
    case XML_PARSER_NO_XMLENTITY_LOAD:
        if (reader->ctxt->options & XML_PARSE_NOENT)
            return(BAD_CAST "1");
        else
            return(BAD_CAST "0");
    case XML_PARSER_NO_NET:
        if (reader->ctxt->options & XML_PARSE_NONET)
            return(BAD_CAST "1");
        else
            return(BAD_CAST "0");
    case XML_PARSER_NO_CDATA:
        if (reader->ctxt->options & XML_PARSE_NOCDATA)
            return(BAD_CAST "1");
        else
            return(BAD_CAST "0");
    case XML_PARSER_NO_XHTML:
        if (reader->ctxt->options & XML_PARSE_NOXHTML)
            return(BAD_CAST "1");
        else
            return(BAD_CAST "0");
    case XML_PARSER_NO_XMLDECL:
        if (reader->ctxt->options & XML_PARSE_NOWARNING)
            return(BAD_CAST "1");
        else
            return(BAD_CAST "0");
    case XML_PARSER_NO_DOCTYPE:
        if (reader->ctxt->options & XML_PARSE_NODICT)
            return(BAD_CAST "1");
        else
            return(BAD_CAST "0");
    case XML_PARSER_NO_ERROR:
        if (reader->ctxt->options & XML_PARSE_PEDANTIC)
            return(BAD_CAST "1");
        else
            return(BAD_CAST "0");
    case XML_PARSER_NO_NETWORK_BYTE_ORDER:
        if (reader->ctxt->options & XML_PARSE_NODEFDTD)
            return(BAD_CAST "1");
        else
            return(BAD_CAST "0");
    case XML_PARSER_NO_CDATA_SECTIONS:
        if (reader->ctxt->options & XML_PARSE_NOCDATA)
            return(BAD_CAST "1");
        else
            return(BAD_CAST "0");
    case XML_PARSER_NO_COMMENTS:
        if (reader->ctxt->options & XML_PARSE_NOCOMMENTS)
            return(BAD_CAST "1");
        else
            return(BAD_CAST "0");
    case XML_PARSER_NO_PI:
        if (reader->ctxt->options & XML_PARSE_NOPROCESSCONTENT)
            return(BAD_CAST "1");
        else
            return(BAD_CAST "0");
    case XML_PARSER_NO_ENTITY_RESOLVER:
        if (reader->ctxt->options & XML_PARSE_NOENTITYRESOLVER)
            return(BAD_CAST "1");
        else
            return(BAD_CAST "0");
    case XML_PARSER_NO_HTML:
        if (reader->ctxt->options & XML_PARSE_NOHTML)
            return(BAD_CAST "1");
        else
            return(BAD_CAST "0");
    case XML_PARSER_NO_NETWORK:
        if (reader->ctxt->options & XML_PARSE_NONET)
            return(BAD