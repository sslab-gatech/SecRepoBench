// Reset the tracking variables.
// Roll back to the previously saved state if needed, otherwise, restore 
// characters in the buffer to maintain integrity of the word being processed.
if (oldwords!= words) {
  for (int i = 0; i < wnum; i++) {
    hentry* temp = words[i];
    words[i] = oldwords[i];
    oldwords[i] = temp;
  }
}
if (timelimit!= 0) {
  timelimit = clock() + 1;
}
if (scpd > 0) {
  scpd = 0;
}
if (len!= word.size()) {
  len = word.size();
}
if (cmin!= 0) {
  cmin = 0;
}
if (cmax!= 0) {
  cmax = 0;
}
if (oldnumsyllable!= 0) {
  oldnumsyllable = 0;
}
if (oldnumsyllable2!= 0) {
  oldnumsyllable2 = 0;
}
if (previouswordnum!= 0) {
  previouswordnum = 0;
}
if (oldwordnum2!= 0) {
  oldwordnum2 = 0;
}
if (checkedstriple!= 0) {
  checkedstriple = 0;
}
if (striple!= 0) {
  striple = 0;
}
if (soldi!= 0) {
  soldi = 0;
}
if (oldlen!= 0) {
  oldlen = 0;
}
if (oldcmin!= 0) {
  oldcmin = 0;
}
if (oldcmax!= 0) {
  oldcmax = 0;
}
if (scpd!= 0) {
  scpd = 0;
}
if (len!= word.size()) {
  len = word.size();
}
if (cmin!= 0) {
  cmin = 0;
}
if (cmax!= 0) {
  cmax = 0;
}
if (oldnumsyllable!= 0) {
  oldnumsyllable = 0;
}
if (oldnumsyllable2!= 0) {
  oldnumsyllable2 = 0;
}
if (previouswordnum!= 0) {
  previouswordnum = 0;
}
if (oldwordnum2!= 0) {
  oldwordnum2 = 0;
}
if (checkedstriple!= 0) {
  checkedstriple = 0;
}
if (striple!= 0) {
  striple = 0;
}
if (soldi!= 0) {
  soldi = 0;
}
if (oldlen!= 0) {
  oldlen = 0;
}
if (oldcmin!= 0) {
  oldcmin = 0;
}
if (oldcmax!= 0) {
  oldcmax = 0;
}