ssize_t) lenfun;
        }
      }
    }
    dummy_exception = DestroyExceptionInfo (dummy_exception);
    return 0;
  }

  *v0 = colour.red   / QuantumRange;
  *v1 = colour.green / QuantumRange;
  *v2 = colour.blue  / QuantumRange;
  dummy_exception = DestroyExceptionInfo (dummy_exception);
  return (ssize_t) pfx->lenToken;
}

static MagickBooleanType GetConstant (FxInfo * pfx, fxFltType *val)
{
  ssize_t len;
  len = GetConstantColour (pfx, val, val+1, val+2);
  if (len < 0) return MagickFalse;
  if (len == 0) {
    len = GetToken (pfx);
    if (len == 0) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "Expected constant at", "'%s'",
        SetShortExp(pfx));
      return MagickFalse;
    }
    *val = strtold (pfx->token, (char **) NULL);
    pfx->pex += len;
    return MagickTrue;
  }
  pfx->pex += len;
  return MagickTrue;
}

static MagickBooleanType GetSymbol (FxInfo * pfx, fxFltType *val)
{
  int ndx;
  if (!TokenMaybeUserSymbol (pfx)) return MagickFalse;
  ndx = FindUserSymbol (pfx, pfx->token);
  if (ndx == NULL_ADDRESS) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "Unknown symbol", "'%s' at '%s'",
      pfx->token, SetShortExp(pfx));
    return MagickFalse;
  }
  *val = pfx->UserSymVals[ndx];
  pfx->pex += pfx->lenToken;
  return MagickTrue;
}

static MagickBooleanType GetFunction (FxInfo * pfx, FunctionE fe)
{
  int i;
  if (fe < FirstFunc) return MagickFalse;
  for (i = 0; i < MaxTokenLen; i++) {
    if (Functions[fe-FirstFunc].str[i] != pfx->token[i]) break;
  }
  if (i == MaxTokenLen || Functions[fe-FirstFunc].str[i] != pfx->token[i]) {
    return MagickFalse;
  }
  pfx->pex += pfx->lenToken;
  return MagickTrue;
}

static MagickBooleanType GetImgAttr (FxInfo * pfx, fxFltType *val)
{
  ImgAttrE ia;
  if (!TokenMaybeUserSymbol (pfx)) return MagickFalse;
  ia = GetImgAttrToken (pfx);
  if (ia == aNull) return MagickFalse;
  *val = (fxFltType) ia;
  return MagickTrue;
}

static MagickBooleanType GetSymbol (FxInfo * pfx, fxFltType *val)
{
  int ndx;
  if (!TokenMaybeUserSymbol (pfx)) return MagickFalse;
  ndx = FindUserSymbol (pfx, pfx->token);
  if (ndx == NULL_ADDRESS) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "Unknown symbol", "'%s' at '%s'",
      pfx->token, SetShortExp(pfx));
    return MagickFalse;
  }
  *val = pfx->UserSymVals[ndx];
  pfx->pex += pfx->lenToken;
  return MagickTrue;
}

static MagickBooleanType GetOperator (FxInfo * pfx, fxFltType *val)
{
  int i;
  for (i = 0; i <= rNull; i++) {
    if (LocaleCompare (Operators[i].str, pfx->token) == 0) {
      *val = (fxFltType) i;
      pfx->pex += pfx->lenToken;
      return MagickTrue;
    }
  }
  return MagickFalse;
}

static MagickBooleanType GetControl (FxInfo * pfx, fxFltType *val)
{
  int i;
  for (i = 0; i <= rNull; i++) {
    if (LocaleCompare (Controls[i].str, pfx->token) == 0) {
      *val = (fxFltType) i;
      pfx->pex += pfx->lenToken;
      return MagickTrue;
    }
  }
  return MagickFalse;
}

static MagickBooleanType GetElement (FxInfo * pfx, ElementT * pel)
{
  int i;
  for (i = 0; i < pfx->usedElements; i++) {
    if (LocaleCompare (pfx->Elements[i].str, pfx->token) == 0) {
      *pel = pfx->Elements[i];
      pfx->pex += pfx->lenToken;
      return MagickTrue;
    }
  }
  return MagickFalse;
}

static MagickBooleanType GetElementAddressing (FxInfo * pfx, ElementT * pel)
{
  int i;
  for (i = 0; i < pfx->usedElements; i++) {
    if (LocaleCompare (pfx->Elements[i].str, pfx->token) == 0) {
      *pel = pfx->Elements[i];
      pfx->pex += pfx->lenToken;
      return MagickTrue;
    }
  }
  return MagickFalse;
}

static MagickBooleanType GetChannel (FxInfo * pfx, PixelChannel * channel)
{
  int i;
  for (i = 0; i < MaxTokenLen; i++) {
    if (Channels[i].str[0] == '\0') break;
    if (LocaleCompare (Channels[i].str, pfx->token) == 0) {
      *channel = Channels[i].pixChan;
      pfx->pex += pfx->lenToken;
      return MagickTrue;
    }
  }
  return MagickFalse;
}

static MagickBooleanType GetChannelQualifier (FxInfo * pfx, ElementT * pel)
{
  PixelChannel channel;
  if (!GetChannel (pfx, &channel)) return MagickFalse;
  pel->ChannelQual = channel;
  return MagickTrue;
}

static MagickBooleanType GetImgAttrQualifier (FxInfo * pfx, ElementT * pel)
{
  ImgAttrE ia;
  if (!TokenMaybeUserSymbol (pfx)) return MagickFalse;
  ia = GetImgAttrToken (pfx);
  if (ia == aNull) return MagickFalse;
  pel->ImgAttrQual = ia;
  return MagickTrue;
}

static MagickBooleanType GetColourConstant (FxInfo * pfx, ElementT * pel)
{
  fxFltType v0, v1, v2;
  if (!GetConstantColour (pfx, &v0, &v1, &v2)) return MagickFalse;
  pel->val = v0;
  pel->val1 = v1;
  pel->val2 = v2;
  pel->type = etColourConstant;
  return MagickTrue;
}

static MagickBooleanType GetElement (FxInfo * pfx, ElementT * pel)
{
  int i;
  for (i = 0; i < pfx->usedElements; i++) {
    if (LocaleCompare (pfx->Elements[i].str, pfx->token) == 0) {
      *pel = pfx->Elements[i];
      pfx->pex += pfx->lenToken;
      return MagickTrue;
    }
  }
  return MagickFalse;
}

static MagickBooleanType GetElementAddressing (FxInfo * pfx, ElementT * pel)
{
  int i;
  for (i = 0; i < pfx->usedElements; i++) {
    if (LocaleCompare (pfx->Elements[i].str, pfx->token) == 0) {
      *pel = pfx->Elements[i];
      pfx->pex += pfx->lenToken;
      return MagickTrue;
    }
  }
  return MagickFalse;
}

static MagickBooleanType GetChannel (FxInfo * pfx, PixelChannel * channel)
{
  int i;
  for (i = 0; i < MaxTokenLen; i++) {
    if (Channels[i].str[0] == '\0') break;
    if (LocaleCompare (Channels[i].str, pfx->token) == 0) {
      *channel = Channels[i].pixChan;
      pfx->pex += pfx->lenToken;
      return MagickTrue;
    }
  }
  return MagickFalse;
}

static MagickBooleanType GetChannelQualifier (FxInfo * pfx, ElementT * pel)
{
  PixelChannel channel;
  if (!GetChannel (pfx, &channel)) return MagickFalse;
  pel->ChannelQual = channel;
  return MagickTrue;
}

static MagickBooleanType GetImgAttrQualifier (FxInfo * pfx, ElementT * pel)
{
  ImgAttrE ia;
  if (!TokenMaybeUserSymbol (pfx)) return MagickFalse;
  ia = GetImgAttrToken (pfx);
  if (ia == aNull) return MagickFalse;
  pel->ImgAttrQual = ia;
  return MagickTrue;
}

static MagickBooleanType GetColourConstant (FxInfo * pfx, ElementT * pel)
{
  fxFltType v0, v1, v2;
  if (!GetConstantColour (pfx, &v0, &v1, &v2)) return MagickFalse;
  pel->val = v0;
  pel->val1 = v1;
  pel->val2 = v2;
  pel->type = etColourConstant;
  return MagickTrue;
}

static MagickBooleanType GetElement (FxInfo * pfx, ElementT * pel)
{
  int i;
  for (i = 0; i < pfx->usedElements; i++) {
    if (LocaleCompare (pfx->Elements[i].str, pfx->token) == 0) {
      *pel = pfx->Elements[i];
      pfx->pex += pfx->lenToken;
      return MagickTrue;
    }
  }
  return MagickFalse;
}

static MagickBooleanType GetElementAddressing (FxInfo * pfx, ElementT * pel)
{
  int i;
  for (i = 0; i < pfx->usedElements; i++) {
    if (LocaleCompare (pfx->Elements[i].str, pfx->token) == 0) {
      *pel = pfx->Elements[i];
      pfx->pex += pfx->lenToken;
      return MagickTrue;
    }
  }
  return MagickFalse;
}

static MagickBooleanType GetChannel (FxInfo * pfx, PixelChannel * channel)
{
  int i;
  for (i = 0; i < MaxTokenLen; i++) {
    if (Channels[i].str[0] == '\0') break;
    if (LocaleCompare (Channels[i].str, pfx->token) == 0) {
      *channel = Channels[i].pixChan;
      pfx->pex += pfx->lenToken;
      return MagickTrue;
    }
  }
  return MagickFalse;
}

static MagickBooleanType GetChannelQualifier (FxInfo * pfx, ElementT * pel)
{
  PixelChannel channel;
  if (!GetChannel (pfx, &channel)) return MagickFalse;
  pel->ChannelQual = channel;
  return MagickTrue;
}

static MagickBooleanType GetImgAttrQualifier (FxInfo * pfx, ElementT * pel)
{
  ImgAttrE ia;
  if (!TokenMaybeUserSymbol (pfx)) return MagickFalse;
  ia = GetImgAttrToken (pfx);
  if (ia == aNull) return MagickFalse;
  pel->ImgAttrQual = ia;
  return MagickTrue;
}

static MagickBooleanType GetColourConstant (FxInfo * pfx, ElementT * pel)
{
  fxFltType v0, v1, v2;
  if (!GetConstantColour (pfx, &v0, &v1, &v2)) return