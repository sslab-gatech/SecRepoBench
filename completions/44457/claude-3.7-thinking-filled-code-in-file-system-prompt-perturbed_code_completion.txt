static MagickBooleanType inline ProcessTernaryOpr (FxInfo * fxinfo, TernaryT * ptern)
/* Ternary operator "... ? ... : ..."
   returns false iff we have exception
*/
{
  if (fxinfo->usedOprStack <= 0) return MagickTrue;
  
  OperatorE topOp = fxinfo->OperatorStack[fxinfo->usedOprStack-1];
  
  if (topOp == oQuery) {
    // Ensure there's no existing query or colon
    if (ptern->addrQuery != NULL_ADDRESS || ptern->addrColon != NULL_ADDRESS) {
      (void) ThrowMagickException (
        fxinfo->exception, GetMagickModule(), OptionError,
        "Nested ternary operator not supported", "'%s'",
        SetShortExp(fxinfo));
      return MagickFalse;
    }
    
    // Pop the operator stack
    fxinfo->usedOprStack--;
    
    // Add an addressing element for conditional execution
    if (!AddAddressingElement (fxinfo, rIfZeroGoto, NULL_ADDRESS)) return MagickFalse;
    
    // Set the query address to the current element index (the IfZeroGoto element)
    ptern->addrQuery = fxinfo->usedElements - 1;
  }
  else if (topOp == oColon) {
    // Ensure there's a preceding query and no existing colon
    if (ptern->addrQuery == NULL_ADDRESS || ptern->addrColon != NULL_ADDRESS) {
      (void) ThrowMagickException (
        fxinfo->exception, GetMagickModule(), OptionError,
        "':' without matching '?'", "'%s'",
        SetShortExp(fxinfo));
      return MagickFalse;
    }
    
    // Pop the operator stack
    fxinfo->usedOprStack--;
    
    // Mark the current element (last expression result) to push a result
    ElementT *pel = &fxinfo->Elements[fxinfo->usedElements-1];
    pel->DoPush = MagickTrue;
    
    // Add an addressing element for control flow
    if (!AddAddressingElement (fxinfo, rGoto, NULL_ADDRESS)) return MagickFalse;
    
    // Set the colon address to the current element index (the Goto element)
    ptern->addrColon = fxinfo->usedElements - 1;
  }
  
  return MagickTrue;
}