, &colour, dummy_exception) == MagickFalse) {
          dummy_exception = DestroyExceptionInfo (dummy_exception);
          (void) ThrowMagickException (
            pfx->exception, GetMagickModule(), OptionError,
            "constant color not recognized", "'%s' at '%s'",
            sFunc, SetShortExp(pfx));
          return -1;
        }
        pfx->pex = q + 1;
        *v0 = colour.red;
        *v1 = colour.green;
        *v2 = colour.blue;
        dummy_exception = DestroyExceptionInfo (dummy_exception);
        return ((ssize_t) lenfun);
      }
    }
  }
  dummy_exception = DestroyExceptionInfo (dummy_exception);
  return 0;
}

static MagickBooleanType GetConstant (FxInfo * pfx, fxFltType *val)
{
  ssize_t len;
  char * tailptr;
  char * text;

  len = GetConstantColour (pfx, val, val+1, val+2);
  if (len != 0) return (len > 0);

  text = pfx->token;
  *val = strtold (text, &tailptr);
  if (text == tailptr) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "constant not recognized", "'%s' at '%s'",
      text, SetShortExp(pfx));
    return MagickFalse;
  }
  pfx->pex += pfx->lenToken;
  return MagickTrue;
}

static MagickBooleanType GetSymbol (FxInfo * pfx, fxFltType *val)
{
  int ndx;
  if ((ndx = FindUserSymbol (pfx, pfx->token)) == NULL_ADDRESS) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "symbol not recognized", "'%s' at '%s'",
      pfx->token, SetShortExp(pfx));
    return MagickFalse;
  }
  *val = pfx->UserSymVals[ndx];
  pfx->pex += pfx->lenToken;
  return MagickTrue;
}

static MagickBooleanType GetFunction (FxInfo * pfx, FunctionE fe)
{
  int i;
  for (i=0; Functions[i].func != fNull; i++) {
    if (Functions[i].func == fe) {
      pfx->pex += strlen(Functions[i].str);
      return MagickTrue;
    }
  }
  (void) ThrowMagickException (
    pfx->exception, GetMagickModule(), OptionError,
    "function not recognized", "'%s' at '%s'",
    Functions[i-1].str, SetShortExp(pfx));
  return MagickFalse;
}

static MagickBooleanType GetImgAttr (FxInfo * pfx, fxFltType *val)
{
  ImgAttrE ia;
  if ((ia = GetImgAttrToken (pfx)) == aNull) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "image attribute not recognized", "'%s' at '%s'",
      pfx->token, SetShortExp(pfx));
    return MagickFalse;
  }
  *val = GetImageProperty (pfx->image, ImgAttrs[ia-FirstImgAttr].str);
  pfx->pex += pfx->lenToken;
  return MagickTrue;
}

static MagickBooleanType GetSymbolValue (FxInfo * pfx, fxFltType *val)
{
  int ndx;
  if ((ndx = FindUserSymbol (pfx, pfx->token)) == NULL_ADDRESS) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "symbol not recognized", "'%s' at '%s'",
      pfx->token, SetShortExp(pfx));
    return MagickFalse;
  }
  *val = pfx->UserSymVals[ndx];
  pfx->pex += pfx->lenToken;
  return MagickTrue;
}

static MagickBooleanType GetChannel (FxInfo * pfx, fxFltType *val)
{
  PixelChannel channel;
  channel = GetChannelQualifier (pfx, feNull);
  if (channel == NO_CHAN_QUAL) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "channel not recognized", "'%s' at '%s'",
      pfx->token, SetShortExp(pfx));
    return MagickFalse;
  }
  *val = GetPixelChannel (pfx->thisPixel, channel);
  pfx->pex += pfx->lenToken;
  return MagickTrue;
}

static MagickBooleanType GetChannelValue (FxInfo * pfx, fxFltType *val)
{
  PixelChannel channel;
  channel = GetChannelQualifier (pfx, feNull);
  if (channel == NO_CHAN_QUAL) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "channel not recognized", "'%s' at '%s'",
      pfx->token, SetShortExp(pfx));
    return MagickFalse;
  }
  *val = GetPixelChannel (pfx->thisPixel, channel);
  pfx->pex += pfx->lenToken;
  return MagickTrue;
}

static MagickBooleanType GetChannelValueWithIndex (FxInfo * pfx, fxFltType *val, int index)
{
  PixelChannel channel;
  channel = GetChannelQualifier (pfx, feNull);
  if (channel == NO_CHAN_QUAL) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "channel not recognized", "'%s' at '%s'",
      pfx->token, SetShortExp(pfx));
    return MagickFalse;
  }
  *val = GetPixelChannel (pfx->thisPixel, channel, index);
  pfx->pex += pfx->lenToken;
  return MagickTrue;
}

static MagickBooleanType GetChannelValueWithIndexAndChannel (FxInfo * pfx, fxFltType *val, int index, PixelChannel channel)
{
  *val = GetPixelChannel (pfx->thisPixel, channel, index);
  pfx->pex += pfx->lenToken;
  return MagickTrue;
}

static MagickBooleanType GetChannelValueWithIndexAndChannelAndDepth (FxInfo * pfx, fxFltType *val, int index, PixelChannel channel, size_t depth)
{
  *val = GetPixelChannel (pfx->thisPixel, channel, index, depth);
  pfx->pex += pfx->lenToken;
  return MagickTrue;
}

static MagickBooleanType GetChannelValueWithDepth (FxInfo * pfx, fxFltType *val, size_t depth)
{
  PixelChannel channel;
  channel = GetChannelQualifier (pfx, feNull);
  if (channel == NO_CHAN_QUAL) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "channel not recognized", "'%s' at '%s'",
      pfx->token, SetShortExp(pfx));
    return MagickFalse;
  }
  *val = GetPixelChannel (pfx->thisPixel, channel, depth);
  pfx->pex += pfx->lenToken;
  return MagickTrue;
}

static MagickBooleanType GetChannelValueWithChannel (FxInfo * pfx, fxFltType *val, PixelChannel channel)
{
  *val = GetPixelChannel (pfx->thisPixel, channel);
  pfx->pex += pfx->lenToken;
  return MagickTrue;
}

static MagickBooleanType GetChannelValueWithChannelAndDepth (FxInfo * pfx, fxFltType *val, PixelChannel channel, size_t depth)
{
  *val = GetPixelChannel (pfx->thisPixel, channel, depth);
  pfx->pex += pfx->lenToken;
  return MagickTrue;
}

static MagickBooleanType GetChannelValueWithDepthAndChannel (FxInfo * pfx, fxFltType *val, size_t depth, PixelChannel channel)
{
  *val = GetPixelChannel (pfx->thisPixel, channel, depth);
  pfx->pex += pfx->lenToken;
  return MagickTrue;
}

static MagickBooleanType GetChannelValueWithIndexAndDepth (FxInfo * pfx, fxFltType *val, int index, size_t depth)
{
  PixelChannel channel;
  channel = GetChannelQualifier (pfx, feNull);
  if (channel == NO_CHAN_QUAL) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "channel not recognized", "'%s' at '%s'",
      pfx->token, SetShortExp(pfx));
    return MagickFalse;
  }
  *val = GetPixelChannel (pfx->thisPixel, channel, index, depth);
  pfx->pex += pfx->lenToken;
  return MagickTrue;
}

static MagickBooleanType GetChannelValueWithIndexAndChannelAndDepthAndDepth (FxInfo * pfx, fxFltType *val, int index, PixelChannel channel, size_t depth, size_t depth2)
{
  *val = GetPixelChannel (pfx->thisPixel, channel, index, depth, depth2);
  pfx->pex += pfx->lenToken;
  return MagickTrue;
}

static MagickBooleanType GetChannelValueWithIndexAndChannelAndDepthAndDepthAndDepth (FxInfo * pfx, fxFltType *val, int index, PixelChannel channel, size_t depth, size_t depth2, size_t depth3)
{
  *val = GetPixelChannel (pfx->thisPixel, channel, index, depth, depth2, depth3);
  pfx->pex += pfx->lenToken;
  return MagickTrue;
}

static MagickBooleanType GetChannelValueWithIndexAndChannelAndDepthAndDepthAndDepthAndDepth (FxInfo * pfx, fxFltType *val, int index, PixelChannel channel, size_t depth, size_t depth2, size_t depth3, size_t depth4)
{
  *val = GetPixelChannel (pfx->thisPixel, channel, index, depth, depth2, depth3, depth4);
  pfx->pex += pfx->lenToken;
  return MagickTrue;
}

static MagickBooleanType GetChannelValueWithIndexAndChannelAndDepthAndDepthAndDepthAndDepthAndDepth (FxInfo * pfx, fxFltType *val, int index, PixelChannel channel, size_t depth, size_t depth2, size_t depth3, size_t depth4, size_t depth5)
{
  *val = GetPixelChannel (pfx->thisPixel, channel, index, depth, depth2, depth3, depth4, depth5);
  pfx->pex += pfx->lenToken;
  return MagickTrue;
}

static MagickBooleanType GetChannelValueWithIndexAndChannelAndDepthAndDepthAndDepthAndDepthAndDepthAndDepth (FxInfo * pfx, fxFltType *val, int index, PixelChannel channel, size_t depth, size_t depth2, size_t depth3, size_t depth4, size_t depth5, size_t depth6)
{
  *val = GetPixelChannel (pfx->thisPixel, channel, index, depth, depth2, depth3, depth4, depth5, depth6);
  pfx->pex += pfx->lenToken;
  return MagickTrue;
}

static MagickBooleanType GetChannelValueWithIndexAndChannelAndDepthAndDepthAndDepthAndDepthAndDepthAndDepthAndDepth (FxInfo * pfx, fxFltType *val, int index, PixelChannel channel, size_t depth, size_t depth2, size_t depth3, size_t depth4, size_t depth5, size_t depth6, size_t depth7)
{
  *val = GetPixelChannel (pfx->thisPixel, channel, index, depth, depth2, depth3, depth4, depth5, depth6, depth7);
  pfx->pex += pfx->lenToken;
  return MagickTrue;
}

static MagickBooleanType GetChannelValueWithIndexAndChannelAndDepthAndDepthAndDepthAndDepthAndDepthAndDepthAndDepthAndDepth (FxInfo * pfx, fxFltType *val, int index, PixelChannel channel, size_t depth, size_t depth2, size_t depth3