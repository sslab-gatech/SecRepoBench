// Assuming 'image' is the input image and 'mask' is the mask image
// with the same dimensions as 'image'

Image * FillMaskedRegion(Image * image, Image * mask, ExceptionInfo * exception) {
  CacheView
    *image_view,
    *mask_view;

  Quantum
    *magick_restrict p,
    *magick_restrict q;

  ssize_t
    y;

  if (image->columns != mask->columns || image->rows != mask->rows) {
    (void) ThrowMagickException(exception, GetMagickModule(), OptionError,
      "Image and mask must have the same dimensions", "(%dx%d) and (%dx%d)",
      image->columns, image->rows, mask->columns, mask->rows);
    return NULL;
  }

  image_view = AcquireVirtualCacheView(image, exception);
  mask_view = AcquireVirtualCacheView(mask, exception);

  if (image_view == NULL || mask_view == NULL) {
    (void) ThrowMagickException(exception, GetMagickModule(), ResourceLimitFatalError,
      "Unable to acquire cache views", "(%dx%d)", image->columns, image->rows);
    return NULL;
  }

  for (y = 0; y < image->rows; y++) {
    p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);
    q = GetCacheViewVirtualPixels(mask_view, 0, y, mask->columns, 1, exception);

    if (p == NULL || q == NULL) {
      (void) ThrowMagickException(exception, GetMagickModule(), ResourceLimitFatalError,
        "Unable to get cache pixels", "(%dx%d)", image->columns, image->rows);
      return NULL;
    }

    for (ssize_t x = 0; x < image->columns; x++) {
      if (q[x] == QuantumRange - 1) { // Mask pixel is black, fill with black
        SetPixel(image, x, y, GetPixelBlack(image));
      } else if (q[x] == QuantumRange) { // Mask pixel is white, copy image pixel
        SetPixel(image, x, y, GetPixel(image, x, y));
      }
    }
  }

  mask_view = DestroyCacheView(mask_view);
  image_view = DestroyCacheView(image_view);

  return image;
}