static MagickBooleanType inline ProcessTernaryOpr (FxInfo * fxinfo, TernaryT * ptern)
{
  // Check the top operator of the stack to determine if it is a ternary query ('?') or colon (':').
  // If the operator is a query ('?'):
  //   - Ensure there is no existing query or colon set in the ternary structure.
  //   - Pop the operator stack and set the query address to the current element index.
  //   - Add an addressing element for conditional execution based on the query result.
  // If the operator is a colon (':'):
  //   - Ensure there is a preceding query in the ternary structure and no existing colon set.
  //   - Pop the operator stack and set the colon address to the current element index.
  //   - Mark the current element to push a result and add an addressing element for control flow.
  // Handle exceptions appropriately by throwing an error if the ternary structure is inconsistent.
  // Return false only if an exception occurs during the processing of the ternary operator.
  if (fxinfo->usedOprStack < 1) {
    (void) ThrowMagickException (
      fxinfo->exception, GetMagickModule(), OptionError,
      "Ternary operator requires at least one operator on the stack", "");
    return MagickFalse;
  }

  OperatorE op = fxinfo->OperatorStack[fxinfo->usedOprStack-1];
  if (op == oQuery) {
    // Ensure there is no existing query or colon set in the ternary structure.
    if (ptern->addrQuery!= NULL_ADDRESS || ptern->addrColon!= NULL_ADDRESS) {
      (void) ThrowMagickException (
        fxinfo->exception, GetMagickModule(), OptionError,
        "Ternary operator already has a query or colon set", "");
      return MagickFalse;
    }
    // Pop the operator stack and set the query address to the current element index.
    pfx->usedOprStack--;
    ptern->addrQuery = fxinfo->usedElements-1;
    // Add an addressing element for conditional execution based on the query result.
    (void) AddAddressingElement (fxinfo, rCondExec, ptern->addrQuery);
  } else if (op == oColon) {
    // Ensure there is a preceding query in the ternary structure and no existing colon set.
    if (ptern->addrQuery == NULL_ADDRESS || ptern->addrColon!= NULL_ADDRESS) {
      (void) ThrowMagickException (
        fxinfo->exception, GetMagickModule(), OptionError,
        "Ternary operator requires a preceding query and no existing colon set", "");
      return MagickFalse;
    }
    // Pop the operator stack and set the colon address to the current element index.
    pfx->usedOprStack--;
    ptern->addrColon = fxinfo->usedElements-1;
    // Mark the current element to push a result and add an addressing element for control flow.
    fxinfo->Elements[fxinfo->usedElements-1].DoPush = MagickTrue;
    (void) AddAddressingElement (fxinfo, rPushResult, ptern->addrColon);
  } else {
    (void) ThrowMagickException (
      fxinfo->exception, GetMagickModule(), OptionError,
      "Invalid ternary operator", "");
    return MagickFalse;
  }

  return MagickTrue;
}