case 'S':
    case 's':
    {
      if (LocaleCompare(symbol,"saturation") == 0)
        {
          double
            hue,
            lightness,
            saturation;

          ConvertRGBToHSL(pixel.red,pixel.green,pixel.blue,&hue,&saturation,
            &lightness);
          return(saturation);
        }
      if (LocaleCompare(symbol,"scale") == 0)
        return((double) image->page.width);
      if (LocaleCompare(symbol,"sigma") == 0)
        return(FxChannelStatistics(fx_info,image,channel,symbol,exception));
      if (LocaleCompare(symbol,"s") == 0)
        return((double) y);
      break;
    }
    case 'T':
    case 't':
    {
      if (LocaleCompare(symbol,"time") == 0)
        return((double) GetMagickTime());
      break;
    }
    case 'U':
    case 'u':
    {
      if (LocaleCompare(symbol,"u") == 0)
        return((double) x);
      break;
    }
    case 'V':
    case 'v':
    {
      if (LocaleCompare(symbol,"v") == 0)
        return((double) y);
      break;
    }
    case 'X':
    case 'x':
    {
      if (LocaleCompare(symbol,"x") == 0)
        return((double) x);
      break;
    }
    case 'Y':
    case 'y':
    {
      if (LocaleCompare(symbol,"y") == 0)
        return((double) y);
      break;
    }
    case 'Z':
    case 'z':
    {
      if (LocaleCompare(symbol,"z") == 0)
        return((double) image->depth);
      break;
    }
    default:
      break;
  }
  value=GetValueFromSplayTree(fx_info->symbols,symbol);
  if (value != (const char *) NULL)
    return(QuantumScale*StringToDouble(value,(char **) NULL));
  (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
    "UndefinedSymbol","`%s'",symbol);
  return(0.0);
}

static double FxEvaluateSubexpression(FxInfo *fx_info,const PixelChannel channel,
  const ssize_t x,const ssize_t y,const char *expression,const size_t depth,
  double *alpha,ExceptionInfo *exception)
{
  char
    *p,
    *q,
    *subexpression;

  double
    beta,
    gamma,
    value;

  size_t
    level;

  p=expression;
  level=0;
  subexpression=AcquireString(expression);
  while ((*p != '\0') &&
         ((level != 1) || (strchr(")",(int) *p) == (char *) NULL)))
  {
    if (strchr("(",(int) *p) != (char *) NULL)
      level++;
    else
      if (strchr(")",(int) *p) != (char *) NULL)
        level--;
    p++;
  }
  if (*p == '\0')
    {
      subexpression=DestroyString(subexpression);
      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
        "UnbalancedParenthesis","`%s'",expression);
      return(0.0);
    }
  *p='\0';
  p++;
  value=FxEvaluateExpression(fx_info,channel,x,y,subexpression,depth,alpha,
    exception);
  if (IsFxFunction(expression,"abs",3) != MagickFalse)
    value=fabs(value);
  if (IsFxFunction(expression,"acos",4) != MagickFalse)
    value=acos(value);
  if (IsFxFunction(expression,"asin",4) != MagickFalse)
    value=asin(value);
  if (IsFxFunction(expression,"atan",4) != MagickFalse)
    value=atan(value);
  if (IsFxFunction(expression,"atan2",5) != MagickFalse)
    {
      beta=FxEvaluateExpression(fx_info,channel,x,y,p,depth,alpha,exception);
      value=atan2(value,beta);
    }
  if (IsFxFunction(expression,"ceil",4) != MagickFalse)
    value=ceil(value);
  if (IsFxFunction(expression,"cos",3) != MagickFalse)
    value=cos(value);
  if (IsFxFunction(expression,"cosh",4) != MagickFalse)
    value=cosh(value);
  if (IsFxFunction(expression,"exp",3) != MagickFalse)
    value=exp(value);
  if (IsFxFunction(expression,"floor",5) != MagickFalse)
    value=floor(value);
  if (IsFxFunction(expression,"log",3) != MagickFalse)
    value=log(value);
  if (IsFxFunction(expression,"log10",5) != MagickFalse)
    value=log10(value);
  if (IsFxFunction(expression,"pow",3) != MagickFalse)
    {
      beta=FxEvaluateExpression(fx_info,channel,x,y,p,depth,alpha,exception);
      value=pow(value,beta);
    }
  if (IsFxFunction(expression,"sin",3) != MagickFalse)
    value=sin(value);
  if (IsFxFunction(expression,"sinh",4) != MagickFalse)
    value=sinh(value);
  if (IsFxFunction(expression,"sqrt",4) != MagickFalse)
    value=sqrt(value);
  if (IsFxFunction(expression,"tan",3) != MagickFalse)
    value=tan(value);
  if (IsFxFunction(expression,"tanh",4) != MagickFalse)
    value=tanh(value);
  if (IsFxFunction(expression,"trunc",5) != MagickFalse)
    value=floor(value);
  if (IsFxFunction(expression,"round",5) != MagickFalse)
    value=floor(value+0.5);
  if (IsFxFunction(expression,"signum",6) != MagickFalse)
    value=(value < 0.0) ? -1.0 : (value > 0.0) ? 1.0 : 0.0;
  if (IsFxFunction(expression,"random",6) != MagickFalse)
    {
      beta=FxEvaluateExpression(fx_info,channel,x,y,p,depth,alpha,exception);
      value=Random(value,beta);
    }
  if (IsFxFunction(expression,"min",3) != MagickFalse)
    {
      beta=FxEvaluateExpression(fx_info,channel,x,y,p,depth,alpha,exception);
      value=Min(value,beta);
    }
  if (IsFxFunction(expression,"max",3) != MagickFalse)
    {
      beta=FxEvaluateExpression(fx_info,channel,x,y,p,depth,alpha,exception);
      value=Max(value,beta);
    }
  if (IsFxFunction(expression,"clamp",5) != MagickFalse)
    value=ClampToQuantum(value);
  if (IsFxFunction(expression,"modulate",7) != MagickFalse)
    {
      beta=FxEvaluateExpression(fx_info,channel,x,y,p,depth,alpha,exception);
      value=Modulate(value,beta);
    }
  if (IsFxFunction(expression,"noise",4) != MagickFalse)
    {
      beta=FxEvaluateExpression(fx_info,channel,x,y,p,depth,alpha,exception);
      value=GenerateDifferentialNoise(fx_info->random_info,value,
        (NoiseType) beta,0.0);
    }
  if (IsFxFunction(expression,"hue",4) != MagickFalse)
    {
      beta=FxEvaluateExpression(fx_info,channel,x,y,p,depth,alpha,exception);
      gamma=FxEvaluateExpression(fx_info,channel,x,y,expression+4,depth,alpha,
        exception);
      value=Hue(value,beta,gamma);
    }
  if (IsFxFunction(expression,"saturation",10) != MagickFalse)
    {
      beta=FxEvaluateExpression(fx_info,channel,x,y,p,depth,alpha,exception);
      gamma=FxEvaluateExpression(fx_info,channel,x,y,expression+10,depth,alpha,
        exception);
      value=Saturation(value,beta,gamma);
    }
  if (IsFxFunction(expression,"lightness",9) != MagickFalse)
    {
      beta=FxEvaluateExpression(fx_info,channel,x,y,p,depth,alpha,exception);
      gamma=FxEvaluateExpression(fx_info,channel,x,y,expression+9,depth,alpha,
        exception);
      value=Lightness(value,beta,gamma);
    }
  if (IsFxFunction(expression,"color",5) != MagickFalse)
    {
      beta=FxEvaluateExpression(fx_info,channel,x,y,p,depth,alpha,exception);
      gamma=FxEvaluateExpression(fx_info,channel,x,y,expression+5,depth,alpha,
        exception);
      value=Color(value,beta,gamma);
    }
  if (IsFxFunction(expression,"rgb",3) != MagickFalse)
    {
      beta=FxEvaluateExpression(fx_info,channel,x,y,p,depth,alpha,exception);
      gamma=FxEvaluateExpression(fx_info,channel,x,y,expression+3,depth,alpha,
        exception);
      value=RGB(value,beta,gamma);
    }
  if (IsFxFunction(expression,"cmyk",4) != MagickFalse)
    {
      beta=FxEvaluateExpression(fx_info,channel,x,y,p,depth,alpha,exception);
      gamma=FxEvaluateExpression(fx_info,channel,x,y,expression+4,depth,alpha,
        exception);
      value=CMYK(value,beta,gamma);
    }
  if (IsFxFunction(expression,"gray",4) != MagickFalse)
    {
      beta=FxEvaluateExpression(fx_info,channel,x,y,p,depth,alpha,exception);
      value=Gray(value,beta);
    }
  if (IsFxFunction(expression,"wave",4) != MagickFalse)
    {
      beta=FxEvaluateExpression(fx_info,channel,x,y,p,depth,alpha,exception);
      value=Wave(value,beta);
    }
  if (IsFxFunction(expression,"swirl",5) != MagickFalse)
    {
      beta=FxEvaluateExpression(fx_info,channel,x,y,p,depth,alpha,exception);
      value=Swirl(value,beta);
    }
  if (IsFxFunction(expression,"roll",4) != MagickFalse)
    {
      beta=FxEvaluateExpression(fx_info,channel,x,y,p,depth,alpha,exception);
      gamma=FxEvaluateExpression(fx_info,channel,x,y,expression+4,depth,alpha,
        exception);
      value=Roll(value,beta,gamma);
    }
  if (IsFxFunction(expression,"tile",4) != MagickFalse)
    {
      beta=FxEvaluateExpression(fx_info,channel,x,y,p,depth,alpha,exception);
      gamma=FxEvaluateExpression(fx_info,channel,x,y,expression+4,depth,alpha,
        exception);
      value=Tile(value,beta,gamma);
    }
  if (IsFxFunction(expression,"turbulence",10) != MagickFalse)
    {
      beta=FxEvaluateExpression(fx_info,channel,x,y,p,depth,alpha,exception);
      gamma=FxEvaluateExpression(fx_info,channel,x,y,expression+10,depth,alpha,
        exception);
      value=Turbulence(value,beta,gamma);
    }
  if (IsFxFunction(expression,"voronoi",7) != MagickFalse)
    {
      beta=FxEvaluateExpression(fx_info,channel,x,y,p,depth,alpha,exception);
      gamma=FxEvaluateExpression(fx_info,channel,x,y,expression+7,depth,alpha,