image->resolution.x);
      if (LocaleCompare(symbol,"resolution.y") == 0)
        return(image->resolution.y);
      if (LocaleCompare(symbol,"r") == 0)
        return(QuantumScale*pixel.red);
      break;
    }
    case 'S':
    case 's':
    {
      if (LocaleCompare(symbol,"saturation") == 0)
        {
          double
            hue,
            lightness,
            saturation;

          ConvertRGBToHSL(pixel.red,pixel.green,pixel.blue,&hue,&saturation,
            &lightness);
          return(saturation);
        }
      if (LocaleCompare(symbol,"size") == 0)
        return((double) GetBlobSize(image));
      if (LocaleCompare(symbol,"s") == 0)
        return(QuantumScale*pixel.blue);
      break;
    }
    case 'T':
    case 't':
    {
      if (LocaleCompare(symbol,"t") == 0)
        return((double) image->rows);
      if (LocaleCompare(symbol,"time") == 0)
        return((double) image->delay);
      break;
    }
    case 'U':
    case 'u':
    {
      if (LocaleCompare(symbol,"units") == 0)
        return((double) image->units);
      break;
    }
    case 'V':
    case 'v':
    {
      if (LocaleCompare(symbol,"v") == 0)
        return((double) y);
      break;
    }
    case 'W':
    case 'w':
    {
      if (LocaleCompare(symbol,"width") == 0)
        return((double) image->columns);
      break;
    }
    case 'X':
    case 'x':
    {
      if (LocaleCompare(symbol,"x") == 0)
        return((double) x);
      break;
    }
    case 'Y':
    case 'y':
    {
      if (LocaleCompare(symbol,"y") == 0)
        return((double) y);
      if (LocaleCompare(symbol,"ycbcr.y") == 0)
        {
          double
            ycbcr[3];

          ConvertRGBToYCbCr(pixel.red,pixel.green,pixel.blue,&ycbcr[0],
            &ycbcr[1],&ycbcr[2]);
          return(QuantumScale*ycbcr[0]);
        }
      break;
    }
    case 'Z':
    case 'z':
    {
      if (LocaleCompare(symbol,"z") == 0)
        return((double) image->depth);
      break;
    }
    default:
      break;
  }
  if (LocaleCompare(symbol,"depth") == 0)
    return((double) image->depth);
  if (LocaleCompare(symbol,"k") == 0)
    {
      if (image->colorspace != CMYKColorspace)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            "ColorSeparatedImageRequired","`%s'",image->filename);
          return(0.0);
        }
      return(QuantumScale*pixel.black);
    }
  if (LocaleCompare(symbol,"intensity") == 0)
    {
      Quantum
        quantum_pixel[MaxPixelChannels];

      SetPixelViaPixelInfo(image,&pixel,quantum_pixel);
      return(QuantumScale*GetPixelIntensity(image,quantum_pixel));
    }
  if (LocaleCompare(symbol,"luma") == 0)
    {
      double
        luma;

      luma=0.212656*pixel.red+0.715158*pixel.green+0.072186*pixel.blue;
      return(QuantumScale*luma);
    }
  if (LocaleCompare(symbol,"luminance") == 0)
    {
      double
        luminence;

      luminence=0.212656*pixel.red+0.715158*pixel.green+0.072186*pixel.blue;
      return(QuantumScale*luminence);
    }
  if (LocaleCompare(symbol,"max") == 0)
    {
      double
        maxima,
        minima;

      (void) GetImageRange(image,&minima,&maxima,exception);
      return(QuantumScale*maxima);
    }
  if (LocaleCompare(symbol,"mean") == 0)
    {
      double
        mean,
        standard_deviation;

      (void) GetImageMean(image,&mean,&standard_deviation,exception);
      return(QuantumScale*mean);
    }
  if (LocaleCompare(symbol,"min") == 0)
    {
      double
        maxima,
        minima;

      (void) GetImageRange(image,&minima,&maxima,exception);
      return(QuantumScale*minima);
    }
  if (LocaleCompare(symbol,"range") == 0)
    {
      double
        maxima,
        minima;

      (void) GetImageRange(image,&minima,&maxima,exception);
      return(QuantumScale*(maxima-minima));
    }
  if (LocaleCompare(symbol,"red") == 0)
    return(QuantumScale*pixel.red);
    if (LocaleCompare(symbol,"saturation") == 0)
    {
      double
        hue,
        lightness,
        saturation;

      ConvertRGBToHSL(pixel.red,pixel.green,pixel.blue,&hue,&saturation,
        &lightness);
      return(saturation);
    }
  if (LocaleCompare(symbol,"skewness") == 0)
    {
      double
        kurtosis,
        skewness;

      (void) GetImageKurtosis(image,&kurtosis,&skewness,exception);
      return(QuantumScale*skewness);
    }
  if (LocaleCompare(symbol,"standard_deviation") == 0)
    {
      double
        mean,
        standard_deviation;

      (void) GetImageMean(image,&mean,&standard_deviation,exception);
      return(QuantumScale*standard_deviation);
    }
  if (LocaleCompare(symbol,"ycbcr.y") == 0)
    {
      double
        ycbcr[3];

      ConvertRGBToYCbCr(pixel.red,pixel.green,pixel.blue,&ycbcr[0],
        &ycbcr[1],&ycbcr[2]);
      return(QuantumScale*ycbcr[0]);
    }
  if (LocaleCompare(symbol,"ycbcr.cb") == 0)
    {
      double
        ycbcr[3];

      ConvertRGBToYCbCr(pixel.red,pixel.green,pixel.blue,&ycbcr[0],
        &ycbcr[1],&ycbcr[2]);
      return(QuantumScale*ycbcr[1]);
    }
  if (LocaleCompare(symbol,"ycbcr.cr") == 0)
    {
      double
        ycbcr[3];

      ConvertRGBToYCbCr(pixel.red,pixel.green,pixel.blue,&ycbcr[0],
        &ycbcr[1],&ycbcr[2]);
      return(QuantumScale*ycbcr[2]);
    }
  if (LocaleCompare(symbol,"blue") == 0)
    return(QuantumScale*pixel.blue);
  if (LocaleCompare(symbol,"green") == 0)
    return(QuantumScale*pixel.green);
  if (LocaleCompare(symbol,"hue") == 0)
    {
      double
        hue,
        lightness,
        saturation;

      ConvertRGBToHSL(pixel.red,pixel.green,pixel.blue,&hue,&saturation,
        &lightness);
      return(hue);
    }
  if (LocaleCompare(symbol,"lightness") == 0)
    {
      double
        hue,
        lightness,
        saturation;

      ConvertRGBToHSL(pixel.red,pixel.green,pixel.blue,&hue,&saturation,
        &lightness);
      return(lightness);
    }
  if (LocaleCompare(symbol,"saturation") == 0)
    {
      double
        hue,
        lightness,
        saturation;

      ConvertRGBToHSL(pixel.red,pixel.green,pixel.blue,&hue,&saturation,
        &lightness);
      return(saturation);
    }
  if (LocaleCompare(symbol,"black") == 0)
    {
      if (image->colorspace != CMYKColorspace)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            "ColorSeparatedImageRequired","`%s'",image->filename);
          return(0.0);
        }
      return(QuantumScale*pixel.black);
    }
  if (LocaleCompare(symbol,"alpha") == 0)
    return((QuantumScale*pixel.alpha));
  if (LocaleCompare(symbol,"intensity") == 0)
    {
      Quantum
        quantum_pixel[MaxPixelChannels];

      SetPixelViaPixelInfo(image,&pixel,quantum_pixel);
      return(QuantumScale*GetPixelIntensity(image,quantum_pixel));
    }
  if (LocaleCompare(symbol,"luma") == 0)
    {
      double
        luma;

      luma=0.212656*pixel.red+0.715158*pixel.green+0.072186*pixel.blue;
      return(QuantumScale*luma);
    }
  if (LocaleCompare(symbol,"luminance") == 0)
    {
      double
        luminence;

      luminence=0.212656*pixel.red+0.715158*pixel.green+0.072186*pixel.blue;
      return(QuantumScale*luminence);
    }
  if (LocaleCompare(symbol,"max") == 0)
    {
      double
        maxima,
        minima;

      (void) GetImageRange(image,&minima,&maxima,exception);
      return(QuantumScale*maxima);
    }
  if (LocaleCompare(symbol,"mean") == 0)
    {
      double
        mean,
        standard_deviation;

      (void) GetImageMean(image,&mean,&standard_deviation,exception);
      return(QuantumScale*mean);
    }
  if (LocaleCompare(symbol,"min") == 0)
    {
      double
        maxima,
        minima;

      (void) GetImageRange(image,&minima,&maxima,exception);
      return(QuantumScale*minima);
    }
  if (LocaleCompare(symbol,"range") == 0)
    {
      double
        maxima,
        minima;

      (void) GetImageRange(image,&minima,&maxima,exception);
      return(QuantumScale*(maxima-minima));
    }
  if (LocaleCompare(symbol,"red") == 0)
    return(QuantumScale*pixel.red);
  if (LocaleCompare(symbol,"saturation") == 0)
    {
      double
        hue,
        lightness,
        saturation;

      ConvertRGBToHSL(pixel.red,pixel.green,pixel.blue,&hue,&saturation,
        &lightness);
      return(saturation);
    }
  if (LocaleCompare(symbol,"skewness") == 0)
    {
      double
        kurtosis,
        skewness;

      (void) GetImageKurtosis(image,&kurtosis,&skewness,exception);
      return(QuantumScale*skewness);
    }
  if (LocaleCompare(symbol,"standard_deviation") == 0)
    {
      double
        mean,
        standard_deviation;

      (void) GetImageMean(image,&mean,&standard_deviation,exception);
      return(QuantumScale*standard_deviation);
    }
  if (LocaleCompare(symbol,"ycbcr.y") == 0)
    {
      double
        ycbcr[3];

      ConvertRGBToYCbCr(pixel.red,pixel.green,pixel.blue,&ycbcr[0],
        &ycbcr[1],&ycbcr[2]);
      return(QuantumScale*ycbcr[0]);
    }
  if (LocaleCompare(symbol,"ycbcr.cb") == 0)
    {