if (ctx->bytes_in_header) {
	if (ctx->bytes_in_header + remain < 4) {
		memcpy(ctx->hdr_store + ctx->bytes_in_header, start, remain);
		ctx->bytes_in_header += remain;
		break;
	}
	memcpy(ctx->hdr_store + ctx->bytes_in_header, start, 4 - ctx->bytes_in_header);
	current = mpgviddmx_next_start_code(ctx->hdr_store, ctx->bytes_in_header + 4);
	if (current < 0) {
		//no start code found, dispatch the bytes as continuation of previous data
		dst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header + 4, &packet_data);
		if (!dst_pck) return GF_OUT_OF_MEM;

		if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
		memcpy(packet_data, ctx->hdr_store, ctx->bytes_in_header + 4);
		gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
		gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
		gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);

		if (byte_offset != GF_FILTER_NO_BO) {
			gf_filter_pck_set_byte_offset(dst_pck, byte_offset);
		}

		mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
		ctx->bytes_in_header = 0;
	} else {
		//start code found, adjust parsing state
		sc_type_forced = ctx->hdr_store[current + 1];
		hdr_offset = current + 2;
	}
}