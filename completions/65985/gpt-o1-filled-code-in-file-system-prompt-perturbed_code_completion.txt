if (ctx->bytes_in_header) {
	s32 sc_pos;
	u8 *temp_buf = gf_malloc(ctx->bytes_in_header + remain);
	memcpy(temp_buf, ctx->hdr_store, ctx->bytes_in_header);
	memcpy(temp_buf + ctx->bytes_in_header, start, remain);

	sc_pos = mpgviddmx_next_start_code(temp_buf, ctx->bytes_in_header + remain);
	if (sc_pos >= 0) {
		/* Found a start code in the combined buffer. */
		bytes_from_store = sc_pos;
		if ((u32)sc_pos < ctx->bytes_in_header) {
			/* The start code is entirely in stored data. */
			hdr_offset = 0;
		} else {
			/* The start code extends into the new data. */
			hdr_offset = sc_pos - ctx->bytes_in_header;
		}
	} else {
		/* No start code found, treat stored bytes as continuation of previous data. */
		dst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &packet_data);
		if (!dst_pck) {
			gf_free(temp_buf);
			return GF_OUT_OF_MEM;
		}
		if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
		memcpy(packet_data, ctx->hdr_store, ctx->bytes_in_header);
		gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
		gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
		gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);
		if (byte_offset != GF_FILTER_NO_BO) {
			gf_filter_pck_set_byte_offset(dst_pck, byte_offset);
		}
		mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
		ctx->bytes_in_header = 0;
	}
	gf_free(temp_buf);
	current = sc_pos;
}