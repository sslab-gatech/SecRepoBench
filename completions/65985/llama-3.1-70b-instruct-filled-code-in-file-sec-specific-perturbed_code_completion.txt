// Check if there are any bytes stored in the header buffer that need processing.
// If there are, attempt to find a start code within these bytes by appending new data.
// If a start code is found, determine its type and location.
// Adjust the parsing state accordingly, preparing to process the next video frame data.
// If no start code is found, treat the stored bytes as continuation of the previous data
// and dispatch them. Reset the header buffer after processing.
if (ctx->bytes_in_header) {
    u32 i;
    u32 bytes_from_store = ctx->bytes_in_header;
    u32 hdr_offset = 0;
    u8 *store = ctx->hdr_store;
    u8 *data = start;
    u32 size = remain;
    u32 total_size = bytes_from_store + size;
    u32 pos = 0;
    u32 v = 0xffffffff;
    Bool sc_type_forced = GF_FALSE;
    u8 forced_sc_type = 0;

    // Check if there are any bytes stored in the header buffer that need processing.
    // If there are, attempt to find a start code within these bytes by appending new data.
    for (i = 0; i < total_size; i++) {
        v = (v << 8) & 0xFFFFFF00;
        if (i < bytes_from_store) {
            v |= store[i];
        } else {
            v |= data[i - bytes_from_store];
        }
        pos++;
        if ((v & 0xFFFFFF00) == 0x00000100) {
            // A start code is found, determine its type and location.
            // Adjust the parsing state accordingly, preparing to process the next video frame data.
            sc_type_forced = GF_TRUE;
            forced_sc_type = (u8) ((v & 0xFF) >> 4);
            hdr_offset = pos - 4;
            break;
        }
    }

    if (!sc_type_forced) {
        // No start code is found, treat the stored bytes as continuation of the previous data
        // and dispatch them. Reset the header buffer after processing.
        dst_pck = gf_filter_pck_new_alloc(ctx->opid, bytes_from_store, &packet_data);
        if (!dst_pck) return GF_OUT_OF_MEM;

        if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
        gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
        gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);
        gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);

        if (byte_offset!= GF_FILTER_NO_BO) {
            gf_filter_pck_set_byte_offset(dst_pck, byte_offset);
        }

        memcpy(packet_data, ctx->hdr_store, bytes_from_store);
        mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
        ctx->bytes_in_header = 0;
    } else {
        // A start code is found, adjust the parsing state accordingly.
        // Prepare to process the next video frame data.
        ctx->bytes_in_header = 0;
        bytes_from_store = hdr_offset;
    }
}
//no startcode in store, look for startcode in packet
current = mpgviddmx_next_start_code(start, remain);