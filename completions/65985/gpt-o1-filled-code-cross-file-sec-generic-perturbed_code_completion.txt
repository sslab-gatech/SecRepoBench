/* first, check if we have any partial start code bytes stored */
	current = -1;
	if (ctx->bytes_in_header) {
		s32 needed = 4 - ctx->bytes_in_header;
		s32 to_copy = (needed > remain) ? remain : needed;

		/* ensure hdr_store has enough space for any new data */
		if (ctx->hdr_store_alloc < (ctx->bytes_in_header + to_copy)) {
			ctx->hdr_store_alloc = ctx->bytes_in_header + to_copy;
			ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char) * ctx->hdr_store_alloc);
			if (!ctx->hdr_store) {
				return GF_OUT_OF_MEM;
			}
		}

		/* copy enough bytes to complete a potential start code */
		memcpy(ctx->hdr_store + ctx->bytes_in_header, start, (size_t)to_copy);
		ctx->bytes_in_header += to_copy;
		start += to_copy;
		remain -= to_copy;

		/* if we have at least 4 bytes, attempt to find a start code */
		if (ctx->bytes_in_header >= 4) {
			s32 sc_offset = mpgviddmx_next_start_code((u8 *)ctx->hdr_store, ctx->bytes_in_header);
			if (sc_offset >= 0) {
				/* found a start code in hdr_store */
				current = sc_offset;
			} else {
				/* no start code - dispatch or discard hdr_store as continuation */
				if (!ctx->frame_started) {
					GF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, ("[MPGVid] no start code in hdr_store and no frame started, discarding data\n"));
				} else {
					u8 *packet_data;
					GF_FilterPacket *dst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &packet_data);
					if (!dst_pck) {
						return GF_OUT_OF_MEM;
					}
					if (ctx->src_pck) {
						gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
					}
					memcpy(packet_data, ctx->hdr_store, (size_t)ctx->bytes_in_header);
					gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
					gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
					gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);
					mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
				}
				ctx->bytes_in_header = 0;
			}
		}
	}