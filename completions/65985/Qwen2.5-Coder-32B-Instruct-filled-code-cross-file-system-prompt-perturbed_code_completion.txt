// Check if there are any bytes stored in the header buffer that need processing.
if (ctx->bytes_in_header) {
    // Attempt to find a start code within the stored bytes by appending new data.
    u32 total_bytes = ctx->bytes_in_header + remain;
    u8 *combined_data = (u8 *)gf_malloc(total_bytes);
    memcpy(combined_data, ctx->hdr_store, ctx->bytes_in_header);
    memcpy(combined_data + ctx->bytes_in_header, start, remain);

    current = mpgviddmx_next_start_code(combined_data, total_bytes);
    if (current >= 0) {
        // Start code found, determine its type and location.
        sc_type = combined_data[current + 3];
        hdr_offset = current + 4;
        if (current >= ctx->bytes_in_header) {
            // Start code starts in the new data, adjust pointers and counters.
            start += current - ctx->bytes_in_header + 4;
            remain -= current - ctx->bytes_in_header + 4;
        } else {
            // Start code starts in the stored bytes, adjust pointers and counters.
            bytes_from_store = current + 4;
            remain -= bytes_from_store - ctx->bytes_in_header;
            start += bytes_from_store - ctx->bytes_in_header;
        }
        ctx->bytes_in_header = 0;
    } else {
        // No start code found, treat the stored bytes as continuation of the previous data.
        if (total_bytes > sizeof(ctx->hdr_store)) {
            ctx->hdr_store = gf_realloc(ctx->hdr_store, total_bytes);
        }
        memcpy(ctx->hdr_store, combined_data, total_bytes);
        ctx->bytes_in_header = total_bytes;
        break;
    }
    gf_free(combined_data);
}