if (ctx->bytes_in_header) {
    // Append new data to existing header buffer
    u32 copy_size = (remain < 5 - ctx->bytes_in_header) ? remain : (5 - ctx->bytes_in_header);
    memcpy(ctx->hdr_store + ctx->bytes_in_header, start, copy_size);
    ctx->bytes_in_header += copy_size;

    // If we have enough bytes, check for start code
    if (ctx->bytes_in_header >= 5) {
        current = mpgviddmx_next_start_code(ctx->hdr_store, ctx->bytes_in_header);
        if (current >= 0) {
            // Start code found, prepare to process it
            start = ctx->hdr_store;
            remain = ctx->bytes_in_header;
            bytes_from_store = ctx->bytes_in_header;
            ctx->bytes_in_header = 0;
        } else {
            // No start code, dispatch stored bytes as continuation
            dst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header - 3, &packet_data);
            if (!dst_pck) return GF_OUT_OF_MEM;
            memcpy(packet_data, ctx->hdr_store, ctx->bytes_in_header - 3);
            gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
            mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
            
            // Keep last 3 bytes for next iteration
            memmove(ctx->hdr_store, ctx->hdr_store + ctx->bytes_in_header - 3, 3);
            ctx->bytes_in_header = 3;
        }
    } else {
        // Not enough bytes, wait for more data
        break;
    }
} else {
    //no startcode in store, look for startcode in packet
    current = mpgviddmx_next_start_code(start, remain);
}