if (ctx->bytes_in_header > 0) {
    // Append new data to the header buffer
    u32 total_bytes = ctx->bytes_in_header + remain;
    if (total_bytes < 4) {
        // Not enough data to form a start code, store and wait for more
        memcpy(ctx->hdr_store + ctx->bytes_in_header, start, remain);
        ctx->bytes_in_header = total_bytes;
        break;
    }

    // Check for a valid start code in the combined data
    memcpy(ctx->hdr_store + ctx->bytes_in_header, start, 4 - ctx->bytes_in_header);
    current = mpgviddmx_next_start_code(ctx->hdr_store, 4);
    if (current == -1) {
        // No valid start code, dispatch the stored bytes as continuation
        dst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &packet_data);
        if (!dst_pck) return GF_OUT_OF_MEM;

        if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
        memcpy(packet_data, ctx->hdr_store, ctx->bytes_in_header);
        gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
        gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
        gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);

        if (byte_offset != GF_FILTER_NO_BO) {
            gf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->bytes_in_header);
        }

        mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
        ctx->bytes_in_header = 0;
    } else {
        // Valid start code found, adjust parsing state
        sc_type = ctx->hdr_store[current + 3];
        sc_type_forced = GF_TRUE;
        forced_sc_type = sc_type;
        hdr_offset = current;
        bytes_from_store = 4 - current;
    }

    // Adjust start and remain to account for processed bytes
    start += (4 - ctx->bytes_in_header);
    remain -= (4 - ctx->bytes_in_header);
    ctx->bytes_in_header = 0;
}