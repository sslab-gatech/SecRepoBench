if (ctx->bytes_in_header) {
    u32 copy_size = (remain < 5 - ctx->bytes_in_header) ? remain : (5 - ctx->bytes_in_header);
    memcpy(ctx->hdr_store + ctx->bytes_in_header, start, copy_size);
    ctx->bytes_in_header += copy_size;
    
    if (ctx->bytes_in_header == 5) {
        current = mpgviddmx_next_start_code(ctx->hdr_store, 5);
        if (current >= 0) {
            sc_type = ctx->hdr_store[4];
            forced_sc_type = sc_type;
            sc_type_forced = GF_TRUE;
            hdr_offset = 5 - current;
            bytes_from_store = current;
        } else {
            // No start code found, dispatch stored bytes as continuation
            dst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header - 1, &packet_data);
            if (!dst_pck) return GF_OUT_OF_MEM;
            
            if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
            memcpy(packet_data, ctx->hdr_store, ctx->bytes_in_header - 1);
            gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
            gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
            gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);
            
            mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
            
            ctx->hdr_store[0] = ctx->hdr_store[ctx->bytes_in_header - 1];
            ctx->bytes_in_header = 1;
        }
    }
    
    if (ctx->bytes_in_header < 5) {
        start += copy_size;
        remain -= copy_size;
    }
}