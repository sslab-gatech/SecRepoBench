if (ctx->bytes_in_header) {
    // Copy enough bytes to check for start code
    u32 copy_size = (remain < 8-ctx->bytes_in_header) ? remain : (8-ctx->bytes_in_header);
    memcpy(ctx->hdr_store + ctx->bytes_in_header, start, copy_size);
    current = mpgviddmx_next_start_code(ctx->hdr_store, ctx->bytes_in_header + copy_size);
    
    // No start code found in header
    if (current < 0) {
        if (ctx->frame_started) {
            // Send stored bytes as continuation
            dst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &packet_data);
            if (!dst_pck) return GF_OUT_OF_MEM;
            
            if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
            memcpy(packet_data, ctx->hdr_store, ctx->bytes_in_header);
            gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
            gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
            gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);
            
            if (byte_offset != GF_FILTER_NO_BO) {
                gf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->bytes_in_header);
            }
            
            mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
        } else {
            GF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, ("[MPGVid] no start code in block and no frame started, discarding data\n"));
        }
        ctx->bytes_in_header = 0;
    } 
    // Start code within header
    else if (current < ctx->bytes_in_header) {
        // If we have data before the start code, send it
        if (current > 0 && ctx->frame_started) {
            dst_pck = gf_filter_pck_new_alloc(ctx->opid, current, &packet_data);
            if (!dst_pck) return GF_OUT_OF_MEM;
            
            if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
            memcpy(packet_data, ctx->hdr_store, current);
            gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
            gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
            gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);
            
            if (byte_offset != GF_FILTER_NO_BO) {
                gf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->bytes_in_header);
            }
            
            mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
        }
        
        // Setup for parsing the start code
        sc_type_forced = GF_TRUE;
        forced_sc_type = ctx->hdr_store[current+3];
        hdr_offset = current+4;
        bytes_from_store = ctx->bytes_in_header - current;
        current = 0;
    } 
    // Start code found but spans both header and packet
    else {
        // If we have data in header store, send it
        if (ctx->frame_started) {
            dst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &packet_data);
            if (!dst_pck) return GF_OUT_OF_MEM;
            
            if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
            memcpy(packet_data, ctx->hdr_store, ctx->bytes_in_header);
            gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
            gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
            gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);
            
            if (byte_offset != GF_FILTER_NO_BO) {
                gf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->bytes_in_header);
            }
            
            mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
        }
        
        // Adjust current to point in the new buffer
        current -= ctx->bytes_in_header;
        ctx->bytes_in_header = 0;
    }
}