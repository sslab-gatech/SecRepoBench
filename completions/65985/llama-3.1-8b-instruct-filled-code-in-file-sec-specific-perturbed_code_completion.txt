//no startcode in store, look for startcode in packet
if (current == -1) {
	//locate next start code
	current = mpgviddmx_next_start_code(start, remain);
	//no start code, dispatch the block
	if (current<0) {
		u8 b3, b2, b1;
		if (! ctx->frame_started) {
			GF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, ("[MPGVid] no start code in block and no frame started, discarding data\n" ));
			break;
		}
		size = remain;
		b3 = start[remain-3];
		b2 = start[remain-2];
		b1 = start[remain-1];
		//we may have a startcode at the end of the packet, store it and don't dispatch the last 3 bytes!
		if (!b1 ||!b2 ||!b3) {
			copy_last_bytes = GF_TRUE;
			gf_assert(size >= 3);
			size -= 3;
			ctx->bytes_in_header = 3;
		}

		dst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &packet_data);
		if (!dst_pck) return GF_OUT_OF_MEM;

		if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
		memcpy(packet_data, start, (size_t) size);
		gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
		gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
		gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);

		if (byte_offset!= GF_FILTER_NO_BO) {
			gf_filter_pck_set_byte_offset(dst_pck, byte_offset);
		}

		mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
		if (copy_last_bytes) {
			memcpy(ctx->hdr_store, start+remain-3, 3);
		}
		break;
	}
}