if (ctx->bytes_in_header) {
    u32 header_size = ctx->bytes_in_header;
    if (remain < 5 - header_size) {
        // Not enough bytes to complete the start code, store remaining bytes
        memcpy(ctx->hdr_store + ctx->bytes_in_header, start, remain);
        ctx->bytes_in_header += remain;
        break;
    } else {
        // Complete the start code and check its validity
        memcpy(ctx->hdr_store + ctx->bytes_in_header, start, 5 - ctx->bytes_in_header);
        u8 b1 = ctx->hdr_store[2];
        u8 b2 = ctx->hdr_store[3];
        u8 b3 = ctx->hdr_store[4];
        if (!(b1 == 0 && b2 == 0 && (b3 == 1 || b3 == 0))) {
            // Invalid start code, dispatch stored bytes as continuation of previous data
            dst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &packet_data);
            if (!dst_pck) return GF_OUT_OF_MEM;

            if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
            memcpy(packet_data, ctx->hdr_store, ctx->bytes_in_header);
            gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
            gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
            gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);

            if (byte_offset != GF_FILTER_NO_BO) {
                gf_filter_pck_set_byte_offset(dst_pck, byte_offset - pck_size);
            }

            mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
            ctx->bytes_in_header = 0;
        } else {
            current = 0;
            sc_type_forced = b3;
            sc_type_forced &= 0x7F;
            sc_type_forced |= 0x80;
            hdr_offset = 5 - ctx->bytes_in_header;
            ctx->bytes_in_header = 0;
        }
        start += 5 - ctx->bytes_in_header;
        remain -= 5 - ctx->bytes_in_header;
    }
} else {
    u8 b1 = start[2];
    u8 b2 = start[3];
    u8 b3 = start[4];
    if (b1 == 0 && b2 == 0 && (b3 == 1 || b3 == 0)) {
        current = 0;
        sc_type_forced = b3;
        sc_type_forced &= 0x7F;
        sc_type_forced |= 0x80;
        sc_type_forced = GF_TRUE;
        hdr_offset = 0;
    } else {
        // No valid start code found, continue searching in the packet
        current = mpgviddmx_next_start_code(start, remain);
        if (current < 0) {
            // No start code found, store last few bytes for next packet
            if (!ctx->frame_started) {
                GF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, ("[MPGVid] no start code in block and no frame started, discarding data\n"));
                break;
            }
            size = remain;
            b1 = start[remain - 3];
            b2 = start[remain - 2];
            b3 = start[remain - 1];
            if (!b1 || !b2 || !b3) {
                copy_last_bytes = GF_TRUE;
                gf_assert(size >= 3);
                size -= 3;
                ctx->bytes_in_header = 3;
            }
            dst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32)size, &packet_data);
            if (!dst_pck) return GF_OUT_OF_MEM;

            if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
            memcpy(packet_data, start, (size_t)size);
            gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
            gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
            gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);

            if (byte_offset != GF_FILTER_NO_BO) {
                gf_filter_pck_set_byte_offset(dst_pck, byte_offset);
            }

            mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
            if (copy_last_bytes) {
                memcpy(ctx->hdr_store, start + remain - 3, 3);
            }
            break;
        }
    }
}