if (ctx->bytes_in_header) {
    u32 nb_copy = (remain < (4-ctx->bytes_in_header)) ? remain : (4-ctx->bytes_in_header);
    memcpy(ctx->hdr_store + ctx->bytes_in_header, start, nb_copy);
    
    // Check if we have a valid start code in the stored buffer
    if ((ctx->bytes_in_header + nb_copy >= 4) && 
        (ctx->hdr_store[0]==0) && (ctx->hdr_store[1]==0) && (ctx->hdr_store[2]==1)) {
        // We have a start code
        forced_sc_type = ctx->hdr_store[3];
        sc_type_forced = GF_TRUE;
        current = 0;
        bytes_from_store = ctx->bytes_in_header;
        hdr_offset = nb_copy;
    } else {
        // No start code found, dispatch bytes as continuation if we're in a frame
        if (ctx->frame_started) {
            dst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &packet_data);
            if (!dst_pck) return GF_OUT_OF_MEM;

            if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
            memcpy(packet_data, ctx->hdr_store, ctx->bytes_in_header);
            gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
            gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
            gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);

            if (byte_offset != GF_FILTER_NO_BO) {
                gf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->bytes_in_header);
            }

            mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
        }
        
        // Skip the bytes we just processed
        start += nb_copy;
        remain -= nb_copy;
    }
    
    // If we didn't get enough bytes to complete a potential start code, wait for more data
    if (!sc_type_forced && (ctx->bytes_in_header + nb_copy < 4) && (nb_copy == remain)) {
        ctx->bytes_in_header += nb_copy;
        return GF_OK;
    }
    
    // Reset bytes_in_header as we've processed or dispatched them
    ctx->bytes_in_header = 0;
}