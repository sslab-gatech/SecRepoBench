if (ctx->bytes_in_header) {
			current = mpgviddmx_next_start_code(ctx->hdr_store, ctx->bytes_in_header + remain);
			if (current>=0) {
				bytes_from_store = (u32) current;
				hdr_offset = ctx->bytes_in_header;
				//we have a start code in the store, adjust the start code type
				gf_bs_reassign_buffer(ctx->bs, ctx->hdr_store, bytes_from_store);
				gf_bs_read_int(ctx->bs, 24);
				forced_sc_type = gf_bs_read_int(ctx->bs, 8);
				sc_type_forced = GF_TRUE;
				//adjust remain
				remain -= (s32) bytes_from_store;
				start += bytes_from_store;
			} else {
				//no start code in store, dispatch the bytes
				dst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &packet_data);
				if (!dst_pck) return GF_OUT_OF_MEM;

				if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
				memcpy(packet_data, ctx->hdr_store, ctx->bytes_in_header);
				gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
				gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
				gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);

				if (byte_offset != GF_FILTER_NO_BO) {
					gf_filter_pck_set_byte_offset(dst_pck, byte_offset);
				}

				mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
				ctx->bytes_in_header = 0;
			}
		}