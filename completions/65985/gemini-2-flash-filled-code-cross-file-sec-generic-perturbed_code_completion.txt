if (ctx->bytes_in_header) {
			current = mpgviddmx_next_start_code(ctx->hdr_store, ctx->bytes_in_header);
			if (current>=0) {
				//start code found, copy remaining bytes from packet to header store
				if (ctx->bytes_in_header + current < pck_size) {
					u32 remaining_bytes = pck_size - current;
					if (ctx->hdr_store_alloc < ctx->bytes_in_header + remaining_bytes) {
						ctx->hdr_store_alloc = ctx->bytes_in_header + remaining_bytes;
						ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
					}
					memcpy(ctx->hdr_store + ctx->bytes_in_header, data + current, remaining_bytes);
					start = data = ctx->hdr_store;
					remain = pck_size = ctx->bytes_in_header + remaining_bytes;
					bytes_from_store = ctx->bytes_in_header;
					ctx->bytes_in_header = 0;
					hdr_offset = current;
				} else {
					//start code found, but not enough bytes in packet to complete it
					memcpy(ctx->hdr_store + ctx->bytes_in_header, data + current, pck_size - current);
					ctx->bytes_in_header += pck_size - current;
					break;
				}
			} else {
				//no start code found, dispatch the bytes in the header store
				dst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &packet_data);
				if (!dst_pck) return GF_OUT_OF_MEM;

				if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
				memcpy(packet_data, ctx->hdr_store, ctx->bytes_in_header);
				gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
				gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
				gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);

				if (byte_offset != GF_FILTER_NO_BO) {
					gf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->bytes_in_header);
				}

				mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
				ctx->bytes_in_header = 0;
				break;
			}
		}