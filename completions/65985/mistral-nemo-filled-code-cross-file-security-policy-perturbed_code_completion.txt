// Check if there are any bytes stored in the header buffer that need processing.
	// If there are, attempt to find a start code within these bytes by appending new data.
	// If a start code is found, determine its type and location.
	// Adjust the parsing state accordingly, preparing to process the next video frame data.
	// If no start code is found, treat the stored bytes as continuation of the previous data
	// and dispatch them. Reset the header buffer after processing.
	// <MASK>
	if (ctx->hdr_store_size) {
		u32 new_size = ctx->hdr_store_size + pck_size;
		if (new_size > ctx->hdr_store_alloc) {
			ctx->hdr_store_alloc = new_size;
			ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
		}
		memmove(ctx->hdr_store + ctx->hdr_store_size, data, pck_size);
		ctx->hdr_store_size = new_size;

		// Attempt to find a start code within the stored bytes.
		u32 start_code_pos = mpgviddmx_find_start_code(ctx->hdr_store, ctx->hdr_store_size);
		if (start_code_pos != GF_BS_NOT_FOUND) {
			// A start code was found. Determine its type and location.
			u8 sc_type = ctx->hdr_store[start_code_pos + 4];
			u32 obj_size = mpgviddmx_get_object_size(ctx->hdr_store, ctx->hdr_store_size, start_code_pos);
			if (obj_size != GF_BS_NOT_FOUND) {
				// The start code and its corresponding object size have been determined.
				// Adjust the parsing state accordingly.
				vosh_end = start_code_pos + obj_size;
				mpgviddmx_check_pid(filter, ctx, vosh_end, ctx->hdr_store + start_code_pos);
				skip_pck = GF_TRUE;
				start += obj_size;
				remain -= obj_size;
			}
		} else {
			// No start code was found. Treat the stored bytes as continuation of the previous data.
			dst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->hdr_store_size, &packet_data);
			if (!dst_pck) return GF_OUT_OF_MEM;

			if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
			memcpy(packet_data, ctx->hdr_store, ctx->hdr_store_size);
			gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
			gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
			gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);

			if (byte_offset != GF_FILTER_NO_BO) {
				gf_filter_pck_set_byte_offset(dst_pck, byte_offset);
			}

			mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
			ctx->hdr_store_size = 0;
		}
	}