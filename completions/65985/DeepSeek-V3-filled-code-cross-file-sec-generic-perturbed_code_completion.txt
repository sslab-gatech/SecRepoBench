if (ctx->bytes_in_header) {
    // Check if we have enough bytes to form a start code (4 bytes)
    if (ctx->bytes_in_header + remain >= 4) {
        u8 *tmp = ctx->hdr_store;
        u32 total = ctx->bytes_in_header + remain;
        u32 i;
        
        // Look for start code in combined buffer
        for (i=0; i<total-3; i++) {
            if (!tmp[i] && !tmp[i+1] && (tmp[i+2]==1)) {
                // Found start code
                current = i;
                sc_type = tmp[i+3];
                sc_type_forced = GF_TRUE;
                forced_sc_type = sc_type;
                hdr_offset = i;
                
                // If start code is in header store, bytes_from_store is the offset
                if (i < ctx->bytes_in_header) {
                    bytes_from_store = ctx->bytes_in_header - i;
                }
                break;
            }
        }
        
        // If no start code found, dispatch the stored bytes as continuation data
        if (current == -1) {
            dst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &packet_data);
            if (!dst_pck) return GF_OUT_OF_MEM;
            
            if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
            memcpy(packet_data, ctx->hdr_store, ctx->bytes_in_header);
            gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
            gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
            gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);
            
            if (byte_offset != GF_FILTER_NO_BO) {
                gf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->bytes_in_header);
            }
            
            mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
            ctx->bytes_in_header = 0;
        }
    } else {
        // Not enough bytes yet, store what we have
        memcpy(ctx->hdr_store + ctx->bytes_in_header, start, remain);
        ctx->bytes_in_header += remain;
        break;
    }
}