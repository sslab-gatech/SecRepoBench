if (ctx->bytes_in_header) {
    // Attempt to find a start code by appending new data to stored bytes
    u32 check_size = ctx->bytes_in_header + (remain < 4 ? remain : 4);
    u8 *check_buf = alloca(check_size);
    memcpy(check_buf, ctx->hdr_store, ctx->bytes_in_header);
    memcpy(check_buf + ctx->bytes_in_header, start, check_size - ctx->bytes_in_header);
    
    current = mpgviddmx_next_start_code(check_buf, check_size);
    
    if (current >= 0) {
        // Start code found, determine its type and location
        sc_type = check_buf[current + 3];
        forced_sc_type = sc_type;
        sc_type_forced = GF_TRUE;
        hdr_offset = (current + 4) - ctx->bytes_in_header;
        
        if (hdr_offset > 0) {
            // Dispatch bytes before the start code
            dst_pck = gf_filter_pck_new_alloc(ctx->opid, hdr_offset, &packet_data);
            if (!dst_pck) return GF_OUT_OF_MEM;
            
            if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
            memcpy(packet_data, ctx->hdr_store, hdr_offset);
            gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
            gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
            gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);
            
            if (byte_offset != GF_FILTER_NO_BO) {
                gf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->bytes_in_header);
            }
            
            mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
        }
        
        bytes_from_store = ctx->bytes_in_header - hdr_offset;
        ctx->bytes_in_header = 0;
    } else {
        // No start code found, treat stored bytes as continuation
        dst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &packet_data);
        if (!dst_pck) return GF_OUT_OF_MEM;
        
        if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
        memcpy(packet_data, ctx->hdr_store, ctx->bytes_in_header);
        gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
        gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
        gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);
        
        if (byte_offset != GF_FILTER_NO_BO) {
            gf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->bytes_in_header);
        }
        
        mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
        ctx->bytes_in_header = 0;
    }
}