if (ctx->hdr_store_size) {
    s32 current = mpgviddmx_next_start_code(ctx->hdr_store, ctx->hdr_store_size);
    if (current >= 0) {
        if (current > 0) {
            dst_pck = gf_filter_pck_new_alloc(ctx->opid, current, &packet_data);
            if (!dst_pck) return GF_OUT_OF_MEM;
            memcpy(packet_data, ctx->hdr_store, current);
            if (byte_offset != GF_FILTER_NO_BO)
                gf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->hdr_store_size + current);
            mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
        }
        forced_sc_type = ctx->hdr_store[current + 3];
        sc_type_forced = GF_TRUE;
        hdr_offset = current + 4;
        bytes_from_store = current + 4;
        ctx->hdr_store_size -= (current + 4);
        if (ctx->hdr_store_size > 0)
            memmove(ctx->hdr_store, ctx->hdr_store + current + 4, ctx->hdr_store_size);
    } else {
        u32 partial = 0;
        if (ctx->hdr_store_size >= 2 && ctx->hdr_store[ctx->hdr_store_size - 2] == 0 && ctx->hdr_store[ctx->hdr_store_size - 1] == 0) {
            if (remain >= 1 && start[0] == 0x01)
                partial = 2;
        } else if (ctx->hdr_store_size >= 1 && ctx->hdr_store[ctx->hdr_store_size - 1] == 0) {
            if (remain >= 2 && start[0] == 0x00 && start[1] == 0x01)
                partial = 1;
        }
        if (partial > 0) {
            u32 bytes_to_dispatch = ctx->hdr_store_size - partial;
            if (bytes_to_dispatch > 0) {
                dst_pck = gf_filter_pck_new_alloc(ctx->opid, bytes_to_dispatch, &packet_data);
                if (!dst_pck) return GF_OUT_OF_MEM;
                memcpy(packet_data, ctx->hdr_store, bytes_to_dispatch);
                if (byte_offset != GF_FILTER_NO_BO)
                    gf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->hdr_store_size + bytes_to_dispatch);
                mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
            }
            forced_sc_type = start[partial];
            sc_type_forced = GF_TRUE;
            start += partial + 1;
            remain -= partial + 1;
            hdr_offset = partial + 1;
            bytes_from_store = ctx->hdr_store_size - partial;
            ctx->hdr_store_size = 0;
        } else {
            dst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->hdr_store_size, &packet_data);
            if (!dst_pck) return GF_OUT_OF_MEM;
            memcpy(packet_data, ctx->hdr_store, ctx->hdr_store_size);
            if (byte_offset != GF_FILTER_NO_BO)
                gf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->hdr_store_size);
            mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
            ctx->hdr_store_size = 0;
        }
    }
}