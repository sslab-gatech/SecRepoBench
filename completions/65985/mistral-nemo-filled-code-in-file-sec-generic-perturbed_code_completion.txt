// Check if there are any bytes stored in the header buffer that need processing.
// If there are, attempt to find a start code within these bytes by appending new data.
// If a start code is found, determine its type and location.
// Adjust the parsing state accordingly, preparing to process the next video frame data.
// If no start code is found, treat the stored bytes as continuation of the previous data
// and dispatch them. Reset the header buffer after processing.
if (ctx->hdr_store_size) {
    u32 new_size = pck_size + ctx->hdr_store_size;
    u8 *new_data = gf_realloc(ctx->hdr_store, new_size);
    memcpy(new_data + ctx->hdr_store_size, data, pck_size);
    gf_free(ctx->hdr_store);
    ctx->hdr_store = new_data;
    ctx->hdr_store_size = new_size;
    ctx->bytes_in_header = 0;
    start = ctx->hdr_store;
    remain = ctx->hdr_store_size;
    current = mpgviddmx_next_start_code(start, remain);
    if (current >= 0) {
        // Found start code in stored data, adjust parsing state
        gf_bs_reassign_buffer(ctx->bs, start, remain);
        sc_type = gf_bs_read_int(ctx->bs, 8);
        // Continue parsing as if the start code was found in the new data packet
    } else {
        // No start code found in stored data, treat stored data as continuation of previous data
        dst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->hdr_store_size, &packet_data);
        if (!dst_pck) return GF_OUT_OF_MEM;
        memcpy(packet_data, ctx->hdr_store, ctx->hdr_store_size);
        gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
        gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
        gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);
        if (byte_offset != GF_FILTER_NO_BO) {
            gf_filter_pck_set_byte_offset(dst_pck, byte_offset);
        }
        mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
        ctx->hdr_store_size = 0;
    }
}