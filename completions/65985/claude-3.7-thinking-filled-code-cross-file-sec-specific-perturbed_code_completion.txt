if (ctx->bytes_in_header) {
    // We have potential bytes of a start code in the store, check if we have a complete start code
    if (ctx->bytes_in_header + remain >= 4) {
        // We have enough bytes to check for a start code
        // Copy some bytes from the current packet to the header store
        u32 nb_to_copy = 4 - ctx->bytes_in_header;
        
        // Make sure we have enough space in the header buffer
        if (ctx->bytes_in_header + nb_to_copy > ctx->hdr_store_alloc) {
            ctx->hdr_store_alloc = ctx->bytes_in_header + nb_to_copy;
            ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char) * ctx->hdr_store_alloc);
            if (!ctx->hdr_store) {
                GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, ("[MPGVid] Failed to allocate memory for header buffer\n"));
                return GF_OUT_OF_MEM;
            }
        }
        
        memcpy(ctx->hdr_store + ctx->bytes_in_header, start, nb_to_copy);
        
        // Check if we have a complete start code now
        current = mpgviddmx_next_start_code(ctx->hdr_store, ctx->bytes_in_header + nb_to_copy);
        
        if (current >= 0) {
            // We found a start code, set up parsing state
            forced_sc_type = ctx->hdr_store[current+3];
            sc_type_forced = GF_TRUE;
            hdr_offset = current + 4;
            bytes_from_store = ctx->bytes_in_header;
            
            // Adjust start and remain to skip the bytes we just processed
            start += nb_to_copy;
            remain -= nb_to_copy;
        } else {
            // No start code found, dispatch the stored bytes as continuation of previous data
            if (ctx->frame_started) {
                dst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &packet_data);
                if (!dst_pck) return GF_OUT_OF_MEM;
                
                if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
                memcpy(packet_data, ctx->hdr_store, ctx->bytes_in_header);
                gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
                gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
                gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);
                
                if (byte_offset != GF_FILTER_NO_BO) {
                    gf_filter_pck_set_byte_offset(dst_pck, byte_offset);
                }
                
                mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
            } else {
                GF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, ("[MPGVid] no start code in block and no frame started, discarding data\n"));
            }
            
            ctx->bytes_in_header = 0;
        }
    } else {
        // Not enough bytes to check for a start code, wait for more data
        if (ctx->hdr_store_alloc < ctx->bytes_in_header + remain) {
            ctx->hdr_store_alloc = ctx->bytes_in_header + remain;
            ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char) * ctx->hdr_store_alloc);
            if (!ctx->hdr_store) {
                GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, ("[MPGVid] Failed to allocate memory for header buffer\n"));
                return GF_OUT_OF_MEM;
            }
        }
        
        memcpy(ctx->hdr_store + ctx->bytes_in_header, start, remain);
        ctx->bytes_in_header += remain;
        remain = 0;
    }
}