if (ctx->bytes_in_header > 0) {
    u8 tmp[4];
    u32 tmp_size = ctx->bytes_in_header + GF_MIN(4 - ctx->bytes_in_header, remain);
    memcpy(tmp, ctx->hdr_store, ctx->bytes_in_header);
    if (tmp_size > ctx->bytes_in_header)
        memcpy(tmp + ctx->bytes_in_header, start, tmp_size - ctx->bytes_in_header);
    current = mpgviddmx_next_start_code(tmp, tmp_size);
    if (current >= 0) {
        if (current < ctx->bytes_in_header) {
            hdr_offset = current + 4;
            if (hdr_offset > ctx->bytes_in_header) {
                u32 shift = hdr_offset - ctx->bytes_in_header;
                memmove(ctx->hdr_store, ctx->hdr_store + current, ctx->bytes_in_header - current);
                memcpy(ctx->hdr_store + (ctx->bytes_in_header - current), start, shift);
                ctx->bytes_in_header += shift;
                start += shift;
                remain -= shift;
                current = 0;
                hdr_offset = ctx->bytes_in_header;
            } else {
                forced_sc_type = tmp[current + 3];
                sc_type_forced = GF_TRUE;
                bytes_from_store = ctx->bytes_in_header;
                start -= (ctx->bytes_in_header - current);
                remain += (ctx->bytes_in_header - current);
                ctx->bytes_in_header = 0;
            }
        } else {
            hdr_offset = current - ctx->bytes_in_header;
            forced_sc_type = start[hdr_offset + 3];
            sc_type_forced = GF_TRUE;
            bytes_from_store = ctx->bytes_in_header + hdr_offset;
            start += hdr_offset;
            remain -= hdr_offset;
            ctx->bytes_in_header = 0;
        }
        if (bytes_from_store > 0) {
            dst_pck = gf_filter_pck_new_alloc(ctx->opid, bytes_from_store, &packet_data);
            if (!dst_pck) return GF_OUT_OF_MEM;
            if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
            memcpy(packet_data, ctx->hdr_store, bytes_from_store);
            gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
            gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
            gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);
            if (byte_offset != GF_FILTER_NO_BO)
                gf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);
            mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
        }
    } else {
        dst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &packet_data);
        if (!dst_pck) return GF_OUT_OF_MEM;
        if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
        memcpy(packet_data, ctx->hdr_store, ctx->bytes_in_header);
        gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
        gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
        gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);
        if (byte_offset != GF_FILTER_NO_BO)
            gf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->bytes_in_header);
        mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
        ctx->bytes_in_header = 0;
    }
}