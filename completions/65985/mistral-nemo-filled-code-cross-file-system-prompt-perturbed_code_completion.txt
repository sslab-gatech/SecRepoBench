// Check if there are any bytes stored in the header buffer that need processing.
	// If there are, attempt to find a start code within these bytes by appending new data.
	// If a start code is found, determine its type and location.
	// Adjust the parsing state accordingly, preparing to process the next video frame data.
	// If no start code is found, treat the stored bytes as continuation of the previous data
	// and dispatch them. Reset the header buffer after processing.
	// <MASK>
	if (ctx->hdr_store_size) {
		u32 new_size = ctx->hdr_store_size + pck_size;
		if (ctx->hdr_store_alloc < new_size) {
			ctx->hdr_store_alloc = new_size;
			ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
		}
		memcpy(ctx->hdr_store + ctx->hdr_store_size, data, sizeof(char)*pck_size);
		if (byte_offset != GF_FILTER_NO_BO) {
			if (byte_offset >= ctx->hdr_store_size)
				byte_offset -= ctx->hdr_store_size;
			else
				byte_offset = GF_FILTER_NO_BO;
		}
		ctx->hdr_store_size = new_size;
		start = data = ctx->hdr_store;
		remain = pck_size = ctx->hdr_store_size;
	}

	// Check if there are any bytes stored in the header buffer that need processing.
	// If there are, attempt to find a start code within these bytes by appending new data.
	// If a start code is found, determine its type and location.
	// Adjust the parsing state accordingly, preparing to process the next video frame data.
	// If no start code is found, treat the stored bytes as continuation of the previous data
	// and dispatch them. Reset the header buffer after processing.
	// <MASK>
	if (ctx->hdr_store_size) {
		u32 new_size = ctx->hdr_store_size + pck_size;
		if (ctx->hdr_store_alloc < new_size) {
			ctx->hdr_store_alloc = new_size;
			ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
		}
		memcpy(ctx->hdr_store + ctx->hdr_store_size, data, sizeof(char)*pck_size);
		if (byte_offset != GF_FILTER_NO_BO) {
			if (byte_offset >= ctx->hdr_store_size)
				byte_offset -= ctx->hdr_store_size;
			else
				byte_offset = GF_FILTER_NO_BO;
		}
		ctx->hdr_store_size = new_size;
		start = data = ctx->hdr_store;
		remain = pck_size = ctx->hdr_store_size;
	}