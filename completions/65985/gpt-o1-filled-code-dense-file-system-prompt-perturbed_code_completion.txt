if (ctx->hdr_store_size && (ctx->bytes_in_header > 0)) {
	s32 tmp_sc = mpgviddmx_next_start_code((u8*)ctx->hdr_store, ctx->bytes_in_header);
	if (tmp_sc >= 0) {
		/* Found a start code in the stored bytes, so just reuse it */
		current = tmp_sc;
		ctx->bytes_in_header = 0;
	} else {
		/* No start code in stored data alone, see if appending some of the new packet helps */
		u32 needed = 4 > ctx->bytes_in_header ? (4 - ctx->bytes_in_header) : 0;
		if (needed && remain) {
			if ((s32)needed > remain) needed = remain;
			memcpy(ctx->hdr_store + ctx->bytes_in_header, start, needed);
			ctx->bytes_in_header += needed;
			start += needed;
			remain -= needed;
		}
		tmp_sc = mpgviddmx_next_start_code((u8*)ctx->hdr_store, ctx->bytes_in_header);
		if (tmp_sc < 0) {
			/* Still no start code, dispatch the stored data as continuation of the frame */
			dst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &packet_data);
			if (!dst_pck) return GF_OUT_OF_MEM;

			if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
			memcpy(packet_data, ctx->hdr_store, ctx->bytes_in_header);
			gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
			gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
			gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);

			if (byte_offset != GF_FILTER_NO_BO) {
				gf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->bytes_in_header);
			}
			mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);

			/* Reset the stored-header state and fall back to normal start code detection */
			ctx->bytes_in_header = 0;
			current = -1;
		} else {
			/* Found a start code in the combined data (stored + new) */
			current = tmp_sc;
			ctx->bytes_in_header = 0;
		}
	}
} else {
	current = -1;
}