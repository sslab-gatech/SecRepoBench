// Check if there are any bytes stored in the header buffer that need processing.
// If there are, attempt to find a start code within these bytes by appending new data.
// If a start code is found, determine its type and location.
// Adjust the parsing state accordingly, preparing to process the next video frame data.
// If no start code is found, treat the stored bytes as continuation of the previous data
// and dispatch them. Reset the header buffer after processing.
current = -1;
if (ctx->bytes_in_header) {
    u32 bytes_to_append = 5 - ctx->bytes_in_header;
    if (bytes_to_append > remain) bytes_to_append = (u32) remain;
    memcpy(ctx->hdr_store + ctx->bytes_in_header, start, bytes_to_append);
    remain -= bytes_to_append;
    start += bytes_to_append;
    ctx->bytes_in_header += bytes_to_append;
    // Check if we have enough bytes to find a start code.
    if (ctx->bytes_in_header >= 4) {
        current = mpgviddmx_next_start_code(ctx->hdr_store, ctx->bytes_in_header);
        if (current >= 0) {
            bytes_from_store = (u32) current;
            hdr_offset = 0;
        }
    }
}