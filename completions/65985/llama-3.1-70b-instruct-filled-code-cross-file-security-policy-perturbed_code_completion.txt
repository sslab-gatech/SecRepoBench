// Check if there are any bytes stored in the header buffer that need processing.
// If there are, attempt to find a start code within these bytes by appending new data.
// If a start code is found, determine its type and location.
// Adjust the parsing state accordingly, preparing to process the next video frame data.
// If no start code is found, treat the stored bytes as continuation of the previous data
// and dispatch them. Reset the header buffer after processing.
if (ctx->bytes_in_header) {
    u32 bytes_to_copy = (u32) (remain < ctx->bytes_in_header? remain : ctx->bytes_in_header);
    memmove(ctx->hdr_store + ctx->bytes_in_header, start, bytes_to_copy);
    ctx->bytes_in_header += bytes_to_copy;
    start += bytes_to_copy;
    remain -= bytes_to_copy;
    current = mpgviddmx_next_start_code(ctx->hdr_store, ctx->bytes_in_header);
    if (current >= 0) {
        sc_type_forced = GF_TRUE;
        forced_sc_type = ctx->hdr_store[current + 1];
        bytes_from_store = current + 2;
        hdr_offset = 2;
        ctx->bytes_in_header = 0;
    } else {
        //no start code, dispatch the block
        u8 b3, b2, b1;
        if (!ctx->frame_started) {
            GF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, ("[MPGVid] no start code in block and no frame started, discarding data\n"));
            ctx->bytes_in_header = 0;
            continue;
        }
        size = ctx->bytes_in_header;
        b3 = ctx->hdr_store[ctx->bytes_in_header - 3];
        b2 = ctx->hdr_store[ctx->bytes_in_header - 2];
        b1 = ctx->hdr_store[ctx->bytes_in_header - 1];
        //we may have a startcode at the end of the packet, store it and don't dispatch the last 3 bytes!
        if (!b1 ||!b2 ||!b3) {
            copy_last_bytes = GF_TRUE;
            gf_assert(size >= 3);
            size -= 3;
            ctx->bytes_in_header = 3;
        }

        dst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &packet_data);
        if (!dst_pck) return GF_OUT_OF_MEM;

        if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
        memcpy(packet_data, ctx->hdr_store, (size_t) size);
        gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
        gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
        gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);

        if (byte_offset!= GF_FILTER_NO_BO) {
            gf_filter_pck_set_byte_offset(dst_pck, byte_offset);
        }

        mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
        if (copy_last_bytes) {
            memcpy(ctx->hdr_store, ctx->hdr_store + ctx->bytes_in_header - 3, 3);
        }
        ctx->bytes_in_header = 0;
    }
}