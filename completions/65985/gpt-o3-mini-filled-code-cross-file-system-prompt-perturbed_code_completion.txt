if (ctx->bytes_in_header > 0) {
    /* Try to complete a potential partial start code stored in hdr_store.
       A valid start code begins with 0x00 0x00 0x01, so if we have less than
       3 bytes stored, attempt to copy enough bytes from the current packet to complete it.
    */
    u32 need = 3 - ctx->bytes_in_header;
    if ((u32)remain < need) {
        memcpy(ctx->hdr_store + ctx->bytes_in_header, start, remain);
        ctx->bytes_in_header += remain;
        remain = 0;
        break;
    }
    memcpy(ctx->hdr_store + ctx->bytes_in_header, start, need);
    ctx->bytes_in_header += need;
    start += need;
    remain -= need;
    /* Check if the completed hdr_store now contains a valid start code prefix */
    if (ctx->bytes_in_header == 3 && ctx->hdr_store[0]==0 && ctx->hdr_store[1]==0 && ctx->hdr_store[2]==1) {
        /* Valid start code found in the stored header.
           Reset the bytes_in_header so that further parsing can proceed normally.
        */
        ctx->bytes_in_header = 0;
    } else {
        /* No valid start code: dispatch the stored bytes as continuation data.
           This treats the previously stored bytes as part of the current frame.
        */
        dst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &packet_data);
        if (!dst_pck)
            return GF_OUT_OF_MEM;
        if (ctx->src_pck)
            gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
        memcpy(packet_data, ctx->hdr_store, ctx->bytes_in_header);
        gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
        gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
        gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);
        if (byte_offset != GF_FILTER_NO_BO)
            gf_filter_pck_set_byte_offset(dst_pck, byte_offset);
        mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
        /* Reset header buffer state */
        ctx->bytes_in_header = 0;
    }
}