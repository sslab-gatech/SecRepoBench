if (ctx->bytes_in_header) {
    // Check if we have enough bytes to form a start code (4 bytes)
    if (ctx->bytes_in_header + remain >= 4) {
        u8 *tmp = ctx->hdr_store;
        u32 total = ctx->bytes_in_header + remain;
        u32 i;
        
        // Look for start code in combined buffer
        for (i=0; i<total-3; i++) {
            if (!tmp[i] && !tmp[i+1] && (tmp[i+2]==1)) {
                // Found start code
                current = i;
                sc_type = tmp[i+3];
                sc_type_forced = GF_TRUE;
                forced_sc_type = sc_type;
                hdr_offset = i;
                break;
            }
        }
        
        if (current >= 0) {
            // Found start code, dispatch any data before it
            if (current > 0) {
                dst_pck = gf_filter_pck_new_alloc(ctx->opid, current, &packet_data);
                if (!dst_pck) return GF_OUT_OF_MEM;
                
                if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
                memcpy(packet_data, tmp, current);
                gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
                gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
                gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);
                mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
            }
            
            // Update remaining data
            bytes_from_store = ctx->bytes_in_header - current;
            if (bytes_from_store > 0) {
                memmove(ctx->hdr_store, tmp + current, bytes_from_store);
            }
            ctx->bytes_in_header = bytes_from_store;
        } else {
            // No start code found, dispatch all stored data
            dst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &packet_data);
            if (!dst_pck) return GF_OUT_OF_MEM;
            
            if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
            memcpy(packet_data, tmp, ctx->bytes_in_header);
            gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
            gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
            gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);
            mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
            
            ctx->bytes_in_header = 0;
        }
    } else {
        // Not enough bytes yet, just store them
        memcpy(ctx->hdr_store + ctx->bytes_in_header, start, remain);
        ctx->bytes_in_header += remain;
        remain = 0;
    }
}