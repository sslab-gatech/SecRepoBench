static MagickBooleanType DrawImage(Image *image, const DrawInfo *draw_info,
  ExceptionInfo *exception)
{
  // ... (other code)

  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent, GetMagickModule(), "%s", image->filename);

  assert(draw_info != (const DrawInfo *) NULL);
  assert(draw_info->signature == MagickCoreSignature);

  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent, GetMagickModule(), "...", image->filename);

  if ((draw_info->primitive == (char *) NULL) ||
      (*draw_info->primitive == '\0'))
    return(MagickFalse);

  if (image->debug != MagickFalse)
    (void) LogMagickEvent(DrawEvent, GetMagickModule(), "begin draw-image");

  primitive=(char *) NULL;
  if (*draw_info->primitive != '@')
    primitive=AcquireString(draw_info->primitive);
  else
    if (*(draw_info->primitive+1) != '-')
      primitive=FileToString(draw_info->primitive+1,~0UL,exception);
  if (primitive == (char *) NULL)
    return(MagickFalse);

  primitive_extent=(double) strlen(primitive);
  (void) SetImageArtifact(image,"MVG",primitive);
  n=0;
  // Initialize the number of stops to zero and set the stops pointer to NULL.
  // Allocate memory for graphic context, which is an array of DrawInfo pointers.
  // If memory allocation fails for the graphic context, release resources and throw a memory allocation exception.
  // Set the initial number of points for primitives and allocate memory for primitive information storage.
  // <MASK>
  if (primitive_info == (PrimitiveInfo *) NULL)
    {
      primitive=DestroyString(primitive);
      for ( ; n >= 0; n--)
        graphic_context[n]=DestroyDrawInfo(graphic_context[n]);
      graphic_context=(DrawInfo **) RelinquishMagickMemory(graphic_context);
      ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
        image->filename);
    }
  graphic_context[n]=CloneDrawInfo((ImageInfo *) NULL,draw_info);
  graphic_context[n]->viewbox=image->page;
  if ((image->page.width == 0) || (image->page.height == 0))
    {
      graphic_context[n]->viewbox.width=image->columns;
      graphic_context[n]->viewbox.height=image->rows;
    }
  token=AcquireString(primitive);
  extent=strlen(token)+MagickPathExtent;
  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)
    return(MagickFalse);
  defsDepth=0;
  status=MagickTrue;
  for (q=primitive; *q != '\0'; )
  {
    // ... (other code)

    if (LocaleCompare(keyword,"pop") == 0)
      {
        GetNextToken(q,(const char **) NULL,extent,token);
        if (LocaleCompare(token,"clip-path") == 0)
          {
            (void) WriteBlobString(image,"</clipPath>\n");
            break;
          }
        if (LocaleCompare(token,"defs") == 0)
          {
            defsDepth--;
            graphic_context[n]->render=defsDepth > 0 ? MagickFalse : MagickTrue;
            (void) WriteBlobString(image,"</defs>\n");
            break;
          }
        if (LocaleCompare(token,"gradient") == 0)
          {
            (void) FormatLocaleString(message,MagickPathExtent,
              "</%sGradient>\n",type);
            (void) WriteBlobString(image,message);
            break;
          }
        if (LocaleCompare(token,"graphic-context") == 0)
          {
            n--;
            if (n < 0)
              ThrowWriterException(DrawError,"UnbalancedGraphicContextPushPop");
            (void) WriteBlobString(image,"</g>\n");
            break;
          }
        if (LocaleCompare(token,"pattern") == 0)
          {
            (void) WriteBlobString(image,"</pattern>\n");
            break;
          }
        status=MagickFalse;
        break;
      }

    // ... (other code)

    if (primitive_info == (PrimitiveInfo *) NULL)
      break;

    primitive_info[i].primitive=primitive_type;
    primitive_info[i].coordinates=0;
    primitive_info[i].method=FloodfillMethod;
    i++;
    if (i < (ssize_t) number_points)
      continue;
    number_points+=6*BezierQuantum+360;
    primitive_info=(PrimitiveInfo *) ResizeQuantumMemory(primitive_info,
      number_points,sizeof(*primitive_info));
    if ((primitive_info == (PrimitiveInfo *) NULL) ||
        (number_points != (MagickSizeType) ((size_t) number_points)))
      {
        (void) ThrowMagickException(exception,GetMagickModule(),
          ResourceLimitError,"MemoryAllocationFailed","`%s'",image->filename);
        break;
      }
  }

  // ... (other code)

  if (primitive_info == (PrimitiveInfo *) NULL)
    break;

  primitive_info[i].primitive=UndefinedPrimitive;
  if (status == 0)
    break;

  // ... (other code)

  if (primitive_info->text != (char *) NULL)
    primitive_info->text=(char *) RelinquishMagickMemory(primitive_info->text);

  // ... (other code)

  return(status != 0 ? MagickTrue : MagickFalse);
}