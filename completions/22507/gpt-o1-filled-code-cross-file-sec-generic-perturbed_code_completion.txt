{
  mrb_value val = GETARG();
  mrb_float fval;
  char fbuf[32];
  size_t need;
  int n;

  fval = mrb_to_flo(mrb, val);

  fmt_setup(fbuf, sizeof(fbuf), *p, flags, width, prec);
  need = 0;
  if (*p != 'e' && *p != 'E') {
    int i;
    (void)frexp(fval, &i);
    if (i > 0) {
      need = BIT_DIGITS(i);
    }
  }
  if (need > MRB_INT_MAX - ((flags & FPREC) ? prec : 6)) {
  too_big_width:
    mrb_raise(mrb, E_ARGUMENT_ERROR,
      (width > prec ? "width too big" : "prec too big"));
  }
  need += (flags & FPREC) ? prec : 6;
  if ((flags & FWIDTH) && need < (size_t)width) {
    need = (size_t)width;
  }
  if (need > MRB_INT_MAX - 20) {
    goto too_big_width;
  }
  need += 20;

  CHECK(need);
  n = mrb_float_to_cstr(mrb, &buf[blen], need, fbuf, fval);
  if (n < 0 || n >= (int)need) {
    mrb_raise(mrb, E_RUNTIME_ERROR, "formatting error");
  }
  blen += n;
}
break;