mrb_value val = GETARG();
mrb_float fval = mrb_to_flo(mrb, val);
char fbuf[64];
mrb_int need;

if (isnan(fval) || isinf(fval)) {
  /* Handle sign */
  if (signbit(fval)) {
    PUSH("-", 1);
  }
  else if (flags & FPLUS) {
    PUSH("+", 1);
  }
  else if (flags & FSPACE) {
    PUSH(" ", 1);
  }

  /* Handle special cases: NaN or Infinity */
  if (isnan(fval)) {
    PUSH("NaN", 3);
  }
  else {
    PUSH("Inf", 3);
  }
}
else {
  /* Build format string */
  fmt_setup(fbuf, sizeof(fbuf), *p, flags,
            (flags & FWIDTH) ? width : 0,
            (flags & FPREC)  ? prec  : -1);

  need = 0;
  /* For non-exponential formats, estimate digits needed */
  if (*p != 'e' && *p != 'E') {
    int i;
    frexp(fval, &i);
    if (i > 0) {
      need = BIT_DIGITS(i);
    }
  }

  /* Check bounds for width/precision */
  if (need > MRB_INT_MAX - ((flags & FPREC) ? prec : 6)) {
  too_big_width:
    mrb_raise(mrb, E_ARGUMENT_ERROR,
      (width > prec) ? "width too big" : "prec too big");
  }
  need += (flags & FPREC) ? prec : 6;
  if ((flags & FWIDTH) && need < width) {
    need = width;
  }
  if (need > MRB_INT_MAX - 20) {
    goto too_big_width;
  }
  need += 20;

  CHECK(need);
  /* Convert float to string with the requested format */
  n = mrb_float_to_cstr(mrb, &buf[blen], need, fbuf, fval);
  if (n < 0 || n >= need) {
    mrb_raise(mrb, E_RUNTIME_ERROR, "formatting error");
  }
  blen += n;
}