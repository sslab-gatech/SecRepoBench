double fval = mrb_float(val);
        char fbuf[32];
        int need = 0;

        if (isnan(fval)) {
          const char *nan_str = "NaN";
          need = strlen(nan_str);
          if (flags & FPLUS) {
            need++; // for the '+' sign
          } else if (flags & FSPACE) {
            need++; // for the space
          }
          CHECK(need);
          if (flags & FPLUS) {
            buf[blen++] = '+';
          } else if (flags & FSPACE) {
            buf[blen++] = ' ';
          }
          memcpy(&buf[blen], nan_str, strlen(nan_str));
          blen += strlen(nan_str);
        } else if (isinf(fval)) {
          const char *inf_str = (fval > 0) ? "Inf" : "-Inf";
          need = strlen(inf_str);
          if (flags & FPLUS) {
            need++; // for the '+' sign
          } else if (flags & FSPACE) {
            need++; // for the space
          }
          CHECK(need);
          if (flags & FPLUS) {
            buf[blen++] = '+';
          } else if (flags & FSPACE) {
            buf[blen++] = ' ';
          }
          memcpy(&buf[blen], inf_str, strlen(inf_str));
          blen += strlen(inf_str);
        } else {
          // Normal floating point formatting
          fmt_setup(fbuf, sizeof(fbuf), *p, flags, width, prec);
          need = 0;
          if (*p != 'e' && *p != 'E') {
            int i;
            frexp(fval, &i);
            if (i > 0)
              need = BIT_DIGITS(i);
          }
          if (need > MRB_INT_MAX - ((flags&FPREC) ? prec : 6)) {
            goto too_big_width;
          }
          need += (flags&FPREC) ? prec : 6;
          if ((flags&FWIDTH) && need < width)
            need = width;
          if (need > MRB_INT_MAX - 20) {
            goto too_big_width;
          }
          need += 20;

          CHECK(need);
          n = mrb_float_to_cstr(mrb, &buf[blen], need, fbuf, fval);
          if (n < 0 || n >= need) {
            mrb_raise(mrb, E_RUNTIME_ERROR, "formatting error");
          }
          blen += n;
        }