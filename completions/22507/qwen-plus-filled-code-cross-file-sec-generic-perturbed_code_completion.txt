mrb_value val = GETARG();
if (!mrb_float_p(val)) {
  mrb_raise(mrb, E_ARGUMENT_ERROR, "expected a float value");
}
double fval = mrb_float(val);

// Handle NaN and Infinity
if (isnan(fval)) {
  const char *nan_str = "NaN";
  if (flags & FPLUS) {
    PUSH("+", 1);
  } else if (flags & FSPACE) {
    PUSH(" ", 1);
  }
  PUSH(nan_str, strlen(nan_str));
  if ((flags & FMINUS) == 0 && width > 0) {
    FILL(' ', width - strlen(nan_str));
  }
  break;
}

if (isinf(fval)) {
  const char *inf_str = (fval > 0) ? "Inf" : "-Inf";
  int inf_len = strlen(inf_str);
  if (fval > 0 && flags & FPLUS) {
    PUSH("+", 1);
    inf_len++;
  } else if (fval > 0 && flags & FSPACE) {
    PUSH(" ", 1);
    inf_len++;
  }
  PUSH(inf_str, inf_len);
  if ((flags & FMINUS) == 0 && width > 0) {
    FILL(' ', width - inf_len);
  }
  break;
}

// Calculate the number of characters needed for representation
int need = prec + 6; // Assuming default precision of 6 for floating-point numbers
if ((flags & FWIDTH) && need < width) {
  need = width;
}
if (need > MRB_INT_MAX - 20) {
  mrb_raise(mrb, E_ARGUMENT_ERROR, "width too big");
}
need += 20;

// Prepare formatting string
char fbuf[64];
fmt_setup(fbuf, sizeof(fbuf), *p, flags, width, prec);

// Perform actual formatting
CHECK(need);
n = snprintf(&buf[blen], need, fbuf, mrb_float(val));
if (n < 0 || n >= need) {
  mrb_raise(mrb, E_RUNTIME_ERROR, "formatting error");
}
blen += n;