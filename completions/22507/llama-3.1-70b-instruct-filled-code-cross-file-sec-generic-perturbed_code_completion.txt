// Check if the next argument is finite. If the value is NaN (Not a Number) or
// Infinity, prepare to format it as "NaN" or "Inf" respectively, 
// including potential sign handling ('+' or'' for positive numbers if specified).
// Calculate the number of characters needed for representation. 
// Handle padding and alignment (left or right) based on flags before storing the result
// in the buffer.
mrb_value val = GETARG();
mrb_float fval = mrb_float(val);
if (mrb_isinf(fval)) {
  char *s = mrb_isposinf(fval)? "Inf" : "-Inf";
  int len = strlen(s);
  if (flags & FPLUS) {
    char c = '+';
    PUSH(&c, 1);
    width--;
  }
  else if (flags & FSPACE) {
    char c ='';
    PUSH(&c, 1);
    width--;
  }
  if (!(flags & FMINUS) && width > 0) {
    FILL(' ', width);
    width = 0;
  }
  PUSH(s, len);
}
else if (mrb_isnan(fval)) {
  char *s = "NaN";
  int len = strlen(s);
  if (flags & FPLUS) {
    char c = '+';
    PUSH(&c, 1);
    width--;
  }
  else if (flags & FSPACE) {
    char c ='';
    PUSH(&c, 1);
    width--;
  }
  if (!(flags & FMINUS) && width > 0) {
    FILL(' ', width);
    width = 0;
  }
  PUSH(s, len);
}
else {
  // Calculate the number of characters needed for representation. 
  // Handle padding and alignment (left or right) based on flags before storing the result
  // in the buffer.
  fmt_setup(fbuf, sizeof(fbuf), *p, flags, width, prec);
  need = 0;
  if (*p!= 'e' && *p!= 'E') {
    int i;
    frexp(fval, &i);
    if (i > 0)
      need = BIT_DIGITS(i);
  }
  if (need > MRB_INT_MAX - ((flags&FPREC)? prec : 6)) {
  too_big_width:
    mrb_raise(mrb, E_ARGUMENT_ERROR,
              (width > prec? "width too big" : "prec too big"));
  }
  need += (flags&FPREC)? prec : 6;
  if ((flags&FWIDTH) && need < width)
    need = width;
  if (need > MRB_INT_MAX - 20) {
    goto too_big_width;
  }
  need += 20;

  CHECK(need);
  n = mrb_float_to_cstr(mrb, &buf[blen], need, fbuf, fval);
  if (n < 0 || n >= need) {
    mrb_raise(mrb, E_RUNTIME_ERROR, "formatting error");
  }
  blen += n;
}