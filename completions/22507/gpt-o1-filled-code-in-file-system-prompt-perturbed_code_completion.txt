{
  mrb_value val = GETARG();
  mrb_float fval;
  char fbuf[64];
  int n, need;

  /* Convert argument to float */
  val = mrb_to_flo(mrb, val);
  fval = mrb_float(val);

  /* Prepare a format string */
  fmt_setup(fbuf, sizeof(fbuf), *p, flags, width, prec);

  need = 0;
  /* Estimate required buffer size for non-exponential formats */
  if (*p != 'e' && *p != 'E') {
    int i;
    (void)frexp(fval, &i);
    if (i > 0) {
      need = BIT_DIGITS(i);
    }
  }
  /* Check for width/precision overflow */
  if (need > MRB_INT_MAX - ((flags & FPREC) ? prec : 6)) {
too_big_width:
    mrb_raise(mrb, E_ARGUMENT_ERROR, (width > prec) ? "width too big" : "prec too big");
  }
  need += (flags & FPREC) ? prec : 6;
  if ((flags & FWIDTH) && need < width) need = width;
  if (need > MRB_INT_MAX - 20) goto too_big_width;
  need += 20;

  CHECK(need);
  /* Format float into buffer */
  n = mrb_float_to_cstr(mrb, &buf[blen], need, fbuf, fval);
  if (n < 0 || n >= need) {
    mrb_raise(mrb, E_RUNTIME_ERROR, "formatting error");
  }
  blen += n;
}
break;