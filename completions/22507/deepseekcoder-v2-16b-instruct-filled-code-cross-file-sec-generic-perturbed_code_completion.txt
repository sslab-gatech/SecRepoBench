case 'f':
      case 'g':
      case 'G':
      case 'e':
      case 'E':
      case 'a':
      case 'A': {
        mrb_value val = GETARG();
        int need = 0;
        double fval = 0.0;
        char fbuf[128];

        switch (mrb_type(val)) {
          case MRB_TT_FLOAT:
            fval = mrb_float(val);
            break;
          default:
            val = mrb_Float(mrb, val);
            fval = mrb_float(val);
            break;
        }

        fmt_setup(fbuf, sizeof(fbuf), *p, flags, width, prec);

        if (*p != 'e' && *p != 'E') {
          int i;
          frexp(fval, &i);
          if (i > 0)
            need = BIT_DIGITS(i);
        }

        if (need > MRB_INT_MAX - ((flags&FPREC) ? prec : 6)) {
          goto too_big_width;
        }

        need += (flags&FPREC) ? prec : 6;

        if ((flags&FWIDTH) && need < width) {
          need = width;
        }

        if (need > MRB_INT_MAX - 20) {
          goto too_big_width;
        }

        need += 20;

        CHECK(need);
        int n = mrb_float_to_cstr(mrb, &buf[blen], need, fbuf, fval);
        if (n < 0 || n >= need) {
          mrb_raise(mrb, E_RUNTIME_ERROR, "formatting error");
        }
        blen += n;
      }
      break;