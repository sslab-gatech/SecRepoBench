// <MASK>
        // Check if the next argument is finite. If the value is NaN (Not a Number) or
        // Infinity, prepare to format it as "NaN" or "Inf" respectively, 
        // including potential sign handling ('+' or ' ' for positive numbers if specified).
        // Calculate the number of characters needed for representation. 
        // Handle padding and alignment (left or right) based on flags before storing the result
        // in the buffer.
        mrb_value num_value = GETARG();
        if (mrb_float_p(num_value)) {
            double fval = mrb_float(num_value);
            if (isnan(fval)) {
                if (flags & FPLUS) *buf++ = '+';
                else if (flags & FSPACE) *buf++ = ' ';
                strcpy(buf, "NaN");
                buf += 3;
            } else if (isinf(fval)) {
                if (fval > 0) {
                    if (flags & FPLUS) *buf++ = '+';
                    else if (flags & FSPACE) *buf++ = ' ';
                }
                strcpy(buf, "Inf");
                buf += 3;
            } else {
                fmt_setup(fbuf, sizeof(fbuf), *p, flags, width, prec);
                need = 0;
                if (*p != 'e' && *p != 'E') {
                    int i;
                    frexp(fval, &i);
                    if (i > 0)
                        need = BIT_DIGITS(i);
                }
                if (need > MRB_INT_MAX - ((flags&FPREC) ? prec : 6)) {
                    goto too_big_width;
                }
                need += (flags&FPREC) ? prec : 6;
                if ((flags&FWIDTH) && need < width)
                    need = width;
                if (need > MRB_INT_MAX - 20) {
                    goto too_big_width;
                }
                need += 20;

                CHECK(need);
                n = mrb_float_to_cstr(mrb, &buf[blen], need, fbuf, fval);
                if (n < 0 || n >= need) {
                    mrb_raise(mrb, E_RUNTIME_ERROR, "formatting error");
                }
                blen += n;
            }
        } else {
            mrb_raisef(mrb, E_ARGUMENT_ERROR, "expected a number, got %S", num_value);
        }