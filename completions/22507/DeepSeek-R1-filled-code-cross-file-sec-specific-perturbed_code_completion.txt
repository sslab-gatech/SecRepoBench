mrb_value val = GETARG();
        mrb_float fval = mrb_as_float(mrb, val);
        const char *s;
        mrb_int slen;

        if (!isfinite(fval)) {
            if (isnan(fval)) {
                s = "NaN";
            }
            else {
                if (fval < 0) {
                    s = "-Inf";
                }
                else {
                    if (flags & FPLUS) {
                        s = "+Inf";
                    }
                    else if (flags & FSPACE) {
                        s = " Inf";
                    }
                    else {
                        s = "Inf";
                    }
                }
            }

            slen = (mrb_int)strlen(s);
            if (width > slen) {
                mrb_int pad = width - slen;
                if (!(flags & FMINUS)) {
                    FILL(' ', pad);
                }
                PUSH(s, slen);
                if (flags & FMINUS) {
                    FILL(' ', pad);
                }
            }
            else {
                PUSH(s, slen);
            }
            break;
        }

        fmt_setup(fbuf, sizeof(fbuf), *p, flags, width, prec);
        mrb_int need = 0;
        if (*p != 'e' && *p != 'E') {
            int i;
            frexp(fval, &i);
            if (i > 0)
                need = BIT_DIGITS(i);
        }
        if (need > MRB_INT_MAX - ((flags&FPREC) ? prec : 6)) {
        too_big_width:
            mrb_raise(mrb, E_ARGUMENT_ERROR,
                      (width > prec ? "width too big" : "prec too big"));
        }
        need += (flags&FPREC) ? prec : 6;
        if ((flags&FWIDTH) && need < width)
            need = width;
        if (need > MRB_INT_MAX - 20) {
            goto too_big_width;
        }
        need += 20;

        CHECK(need);
        int n = mrb_float_to_cstr(mrb, &buf[blen], need, fbuf, fval);
        if (n < 0 || n >= need) {
            mrb_raise(mrb, E_RUNTIME_ERROR, "formatting error");
        }
        blen += n;