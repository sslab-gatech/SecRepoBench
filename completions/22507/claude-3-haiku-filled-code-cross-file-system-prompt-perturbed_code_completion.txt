// <MASK>
mrb_value val = GETARG();
if (mrb_float_p(val)) {
  double fval = mrb_float(val);
  if (isfinite(fval)) {
    char fbuf[64];
    int need;
    int n;

    fmt_setup(fbuf, sizeof(fbuf), *p, flags, width, prec);
    need = 0;
    if (*p != 'e' && *p != 'E') {
      int i;
      frexp(fval, &i);
      if (i > 0)
        need = BIT_DIGITS(i);
    }
    if (need > MRB_INT_MAX - ((flags&FPREC) ? prec : 6)) {
    too_big_width:
      mrb_raise(mrb, E_ARGUMENT_ERROR,
                (width > prec ? "width too big" : "prec too big"));
    }
    need += (flags&FPREC) ? prec : 6;
    if ((flags&FWIDTH) && need < width)
      need = width;
    if (need > MRB_INT_MAX - 20) {
      goto too_big_width;
    }
    need += 20;

    CHECK(need);
    n = mrb_float_to_cstr(mrb, &buf[blen], need, fbuf, fval);
    if (n < 0 || n >= need) {
      mrb_raise(mrb, E_RUNTIME_ERROR, "formatting error");
    }
    blen += n;
  } else if (isnan(fval)) {
    const char *nan = "NaN";
    int len = 3;
    if (flags & FPLUS) {
      PUSH("+", 1);
      width--;
    } else if (flags & FSPACE) {
      PUSH(" ", 1);
      width--;
    }
    if (flags & FWIDTH && width > len) {
      if (flags & FMINUS) {
        PUSH(nan, len);
        FILL(' ', width - len);
      } else {
        FILL(' ', width - len);
        PUSH(nan, len);
      }
    } else {
      PUSH(nan, len);
    }
  } else { // Infinity
    const char *inf = "Inf";
    int len = 3;
    if (flags & FPLUS) {
      PUSH("+", 1);
      width--;
    } else if (flags & FSPACE) {
      PUSH(" ", 1);
      width--;
    } else if (fval < 0) {
      PUSH("-", 1);
      width--;
    }
    if (flags & FWIDTH && width > len) {
      if (flags & FMINUS) {
        PUSH(inf, len);
        FILL(' ', width - len);
      } else {
        FILL(' ', width - len);
        PUSH(inf, len);
      }
    } else {
      PUSH(inf, len);
    }
  }
} else {
  mrb_raise(mrb, E_ARGUMENT_ERROR, "not a float");
}