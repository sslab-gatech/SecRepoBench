// Check if the next argument is finite. If the value is NaN (Not a Number) or
// Infinity, prepare to format it as "NaN" or "Inf" respectively, 
// including potential sign handling ('+' or'' for positive numbers if specified).
// Calculate the number of characters needed for representation. 
// Handle padding and alignment (left or right) based on flags before storing the result
// in the buffer.
mrb_value val = GETARG();
mrb_float fval = mrb_float(val);
char *s;
int sign = 1;
int len;

if (isinf(fval)) {
  s = "Inf";
  len = 3;
}
else if (isnan(fval)) {
  s = "NaN";
  len = 3;
}
else {
  if (fval < 0) {
    sign = -1;
    fval = -fval;
  }
  if (flags & FPLUS) {
    len = 1;
  }
  else if (flags & FSPACE) {
    len = 1;
  }
  else {
    len = 0;
  }
  len += strlen("123.456789"); // max length of float representation
}

if (sign < 0) {
  len++;
}

if ((flags & (FZERO|FMINUS|FPREC)) == FZERO) {
  prec = width;
  width = 0;
}
else {
  if (prec < len) {
    prec = len;
  }
  width -= prec;
}

if (!(flags&FMINUS) && width > 0) {
  FILL(' ', width);
  width = 0;
}

if (sign < 0) {
  PUSH("-", 1);
}
else if (flags & FPLUS) {
  PUSH("+", 1);
}
else if (flags & FSPACE) {
  PUSH(" ", 1);
}

if (isinf(fval) || isnan(fval)) {
  PUSH(s, len);
}
else {
  fmt_setup(fbuf, sizeof(fbuf), *p, flags, width, prec);
  need = 0;
  if (*p!= 'e' && *p!= 'E') {
    int i;
    frexp(fval, &i);
    if (i > 0)
      need = BIT_DIGITS(i);
  }
  if (need > MRB_INT_MAX - ((flags&FPREC)? prec : 6)) {
  too_big_width:
    mrb_raise(mrb, E_ARGUMENT_ERROR,
              (width > prec? "width too big" : "prec too big"));
  }
  need += (flags&FPREC)? prec : 6;
  if ((flags&FWIDTH) && need < width)
    need = width;
  if (need > MRB_INT_MAX - 20) {
    goto too_big_width;
  }
  need += 20;

  CHECK(need);
  n = mrb_float_to_cstr(mrb, &buf[blen], need, fbuf, fval);
  if (n < 0 || n >= need) {
    mrb_raise(mrb, E_RUNTIME_ERROR, "formatting error");
  }
  blen += n;
}

if (width > 0) {
  FILL(' ', width);
}