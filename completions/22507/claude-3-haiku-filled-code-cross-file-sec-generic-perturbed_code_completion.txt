// <MASK>
mrb_value val = GETARG();
if (isfinite(mrb_float(val))) {
    double fval = mrb_float(val);
    char fbuf[32];
    int need;

    fmt_setup(fbuf, sizeof(fbuf), *p, flags, width, prec);
    need = 0;
    if (*p != 'e' && *p != 'E') {
        int i;
        frexp(fval, &i);
        if (i > 0)
            need = BIT_DIGITS(i);
    }
    if (need > MRB_INT_MAX - ((flags&FPREC) ? prec : 6)) {
        goto too_big_width;
    }
    need += (flags&FPREC) ? prec : 6;
    if ((flags&FWIDTH) && need < width)
        need = width;
    if (need > MRB_INT_MAX - 20) {
        goto too_big_width;
    }
    need += 20;

    CHECK(need);
    n = mrb_float_to_cstr(mrb, &buf[blen], need, fbuf, fval);
    if (n < 0 || n >= need) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "formatting error");
    }
    blen += n;
}
else {
    const char *sign = "";
    const char *value = "NaN";
    int len;

    if (isnan(mrb_float(val))) {
        value = "NaN";
    }
    else {
        value = "Inf";
        if (signbit(mrb_float(val)) == 0 && (flags & FPLUS)) {
            sign = "+";
            width--;
        }
        else if (flags & FSPACE) {
            sign = " ";
            width--;
        }
    }

    len = strlen(sign) + strlen(value);
    if ((flags & FWIDTH) && len < width) {
        if (flags & FMINUS) {
            PUSH(sign, strlen(sign));
            PUSH(value, strlen(value));
            FILL(' ', width - len);
        }
        else {
            FILL(' ', width - len);
            PUSH(sign, strlen(sign));
            PUSH(value, strlen(value));
        }
    }
    else {
        PUSH(sign, strlen(sign));
        PUSH(value, strlen(value));
    }
}