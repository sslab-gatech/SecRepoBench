// <MASK>
mrb_value val = GETARG();
double fval;
char fbuf[32];
int need;

if (mrb_float_p(val)) {
  fval = mrb_float(val);
}
else {
  fval = (double)mrb_as_float(mrb, val);
}

if (isinf(fval)) {
  need = 3 + ((flags & FPLUS) ? 1 : ((flags & FSPACE) ? 1 : 0));
  CHECK(need);
  if (signbit(fval)) {
    buf[blen++] = '-';
  }
  else if (flags & FPLUS) {
    buf[blen++] = '+';
  }
  else if (flags & FSPACE) {
    buf[blen++] = ' ';
  }
  strcpy(&buf[blen], "Inf");
  blen += 3;
}
else if (isnan(fval)) {
  need = 3;
  CHECK(need);
  strcpy(&buf[blen], "NaN");
  blen += 3;
}
else {
  fmt_setup(fbuf, sizeof(fbuf), *p, flags, width, prec);
  need = 0;
  if (*p != 'e' && *p != 'E') {
    int i;
    frexp(fval, &i);
    if (i > 0)
      need = BIT_DIGITS(i);
  }
  if (need > MRB_INT_MAX - ((flags&FPREC) ? prec : 6)) {
  too_big_width:
    mrb_raise(mrb, E_ARGUMENT_ERROR,
              (width > prec ? "width too big" : "prec too big"));
  }
  need += (flags&FPREC) ? prec : 6;
  if ((flags&FWIDTH) && need < width)
    need = width;
  if (need > MRB_INT_MAX - 20) {
    goto too_big_width;
  }
  need += 20;

  CHECK(need);
  n = mrb_float_to_cstr(mrb, &buf[blen], need, fbuf, fval);
  if (n < 0 || n >= need) {
    mrb_raise(mrb, E_RUNTIME_ERROR, "formatting error");
  }
  blen += n;
}