mrb_value val = GETARG();
double fval;
char fbuf[128];
int need;

if (mrb_float_p(val)) {
  fval = mrb_float(val);
}
else if (mrb_fixnum_p(val)) {
  fval = (double)mrb_fixnum(val);
}
else {
  mrb_raise(mrb, E_ARGUMENT_ERROR, "invalid argument for float formatting");
}

// Handle special cases: NaN and Infinity
if (!isfinite(fval)) {
  if (isnan(fval)) {
    const char *nan_str = "NaN";
    int nan_len = strlen(nan_str);

    if (flags & FPLUS) {
      PUSH("+", 1);
      width--;
    }
    else if (flags & FSPACE) {
      PUSH(" ", 1);
      width--;
    }

    if ((flags & FMINUS) == 0 && width > 0) {
      FILL(' ', width - nan_len);
    }

    PUSH(nan_str, nan_len);

    if (flags & FMINUS && width > 0) {
      FILL(' ', width - nan_len);
    }

    continue;
  }
  else { // Infinity
    const char *inf_str = "Inf";
    int inf_len = strlen(inf_str);

    if (fval < 0) {
      PUSH("-", 1);
      width--;
    }
    else if (flags & FPLUS) {
      PUSH("+", 1);
      width--;
    }
    else if (flags & FSPACE) {
      PUSH(" ", 1);
      width--;
    }

    if ((flags & FMINUS) == 0 && width > 0) {
      FILL(' ', width - inf_len);
    }

    PUSH(inf_str, inf_len);

    if (flags & FMINUS && width > 0) {
      FILL(' ', width - inf_len);
    }

    continue;
  }
}

fmt_setup(fbuf, sizeof(fbuf), *p, flags, width, prec);
need = snprintf(NULL, 0, fbuf, fval); // Calculate the number of characters needed

if (need > MRB_INT_MAX || need < 0) {
  mrb_raise(mrb, E_ARGUMENT_ERROR, "result too large or invalid format");
}

if ((flags & FWIDTH) && need < width) {
  need = width;
}

CHECK(need + 1); // Ensure buffer size is sufficient including null terminator
snprintf(&buf[blen], need + 1, fbuf, fval);
blen += need;