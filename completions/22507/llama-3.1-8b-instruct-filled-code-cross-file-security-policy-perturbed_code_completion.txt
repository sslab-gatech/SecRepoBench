#ifndef MRB_WITHOUT_FLOAT
      case 'f':
      case 'g':
      case 'G':
      case 'e':
      case 'E':
      case 'a':
      case 'A': {
        // Check if the next argument is finite. If the value is NaN (Not a Number) or
        // Infinity, prepare to format it as "NaN" or "Inf" respectively, 
        // including potential sign handling ('+' or'' for positive numbers if specified).
        // Calculate the number of characters needed for representation. 
        // Handle padding and alignment (left or right) based on flags before storing the result
        // in the buffer.
        mrb_float fval = mrb_float_value(mrb, GETARG());
        mrb_int i;
        double d;

        if (mrb_float_is_nan(fval)) {
          fmt_setup(buf, sizeof(fbuf), *p, flags, width, prec);
          need = 3;
          if (flags & FWIDTH) {
            if (need < width) need = width;
          }
          if (need > MRB_INT_MAX - 20) {
            goto too_big_width;
          }
          need += 20;
          CHECK(need);
          n = mrb_snprintf(&buf[blen], need - blen, "NaN");
          if (n < 0 || n >= need - blen) {
            mrb_raise(mrb, E_RUNTIME_ERROR, "formatting error");
          }
          blen += n;
        }
        else if (mrb_float_is_infinite(fval)) {
          fmt_setup(buf, sizeof(fbuf), *p, flags, width, prec);
          need = 4;
          if (flags & FWIDTH) {
            if (need < width) need = width;
          }
          if (need > MRB_INT_MAX - 20) {
            goto too_big_width;
          }
          need += 20;
          CHECK(need);
          n = mrb_snprintf(&buf[blen], need - blen, "Inf");
          if (n < 0 || n >= need - blen) {
            mrb_raise(mrb, E_RUNTIME_ERROR, "formatting error");
          }
          blen += n;
        }
        else {
          frexp(fval, &i);
          if (i > 0)
            need = BIT_DIGITS(i);
          if (need > MRB_INT_MAX - ((flags&FPREC)? prec : 6)) {
          too_big_width:
            mrb_raise(mrb, E_ARGUMENT_ERROR,
                      (width > prec? "width too big" : "prec too big"));
          }
          need += (flags&FPREC)? prec : 6;
          if ((flags&FWIDTH) && need < width)
            need = width;
          if (need > MRB_INT_MAX - 20) {
            goto too_big_width;
          }
          need += 20;

          CHECK(need);
          d = fval;
          if (flags & FPREC) {
            d = fval;
            if (prec == 0) {
              d = round(d);
            }
            else {
              d = round(d * pow(10.0, prec));
            }
          }
          n = mrb_float_to_cstr(mrb, &buf[blen], need, fbuf, d);
          if (n < 0 || n >= need) {
            mrb_raise(mrb, E_RUNTIME_ERROR, "formatting error");
          }
          blen += n;
        }
      }
      break;
#endif