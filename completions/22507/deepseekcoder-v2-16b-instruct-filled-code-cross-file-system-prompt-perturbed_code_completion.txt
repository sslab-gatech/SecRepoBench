case 'f':
      case 'g':
      case 'G':
      case 'e':
      case 'E':
      case 'a':
      case 'A': {
        mrb_value val = GETARG();
        const char *fmt_str = NULL;
        int fmt_len = 0;
        int need = 0;
        double fval = 0.0;
        char fbuf[64];

        switch (mrb_type(val)) {
          case MRB_TT_FLOAT:
            fval = mrb_float(val);
            break;
          default:
            val = mrb_convert_to_float(mrb, val);
            fval = mrb_float(val);
            break;
        }

        switch (*p) {
          case 'f':
            fmt_str = "%.f";
            break;
          case 'g':
            fmt_str = "%g";
            break;
          case 'G':
            fmt_str = "%.G";
            break;
          case 'e':
            fmt_str = "%.e";
            break;
          case 'E':
            fmt_str = "%.E";
            break;
          case 'a':
            fmt_str = "%.a";
            break;
          case 'A':
            fmt_str = "%.A";
            break;
          default:
            break;
        }

        if (fmt_str) {
          fmt_len = strlen(fmt_str);
          need = fmt_len + (flags & (FPREC | FWIDTH) ? 1 : 0);
          if (flags & FPREC) {
            need += 1; // for the precision specifier
          }
          if (flags & FWIDTH) {
            need += 1; // for the width specifier
          }
          if (need > MRB_INT_MAX - 20) {
            goto too_big_width;
          }
          need += 20;

          CHECK(need);
          n = snprintf(&buf[blen], need, fmt_str, fval);
          if (n < 0 || n >= need) {
            mrb_raise(mrb, E_RUNTIME_ERROR, "formatting error");
          }
          blen += n;
        }
      }
      break;