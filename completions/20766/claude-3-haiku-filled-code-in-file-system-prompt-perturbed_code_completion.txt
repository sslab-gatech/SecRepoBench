if(proto == IPPROTO_UDP) {
    // Parse the UDP header from the packet using the current IP offset.
    struct ndpi_udphdr *udph = (struct ndpi_udphdr *)&packet[ip_offset];
    u_int16_t sport = ntohs(udph->source), dport = ntohs(udph->dest);

    // Check for GTP-U protocol by comparing ports
    if((sport == GTP_U_V1_PORT || dport == GTP_U_V1_PORT) && (header->caplen >= ip_offset + sizeof(struct ndpi_udphdr) + sizeof(struct ndpi_gtp_hdr))) {
        struct ndpi_gtp_hdr *gtp = (struct ndpi_gtp_hdr *)&packet[ip_offset + sizeof(struct ndpi_udphdr)];
        if(gtp->version == 1 && (gtp->message_type == 0xFF || gtp->message_type == 0x00)) {
            ip_offset += sizeof(struct ndpi_udphdr) + sizeof(struct ndpi_gtp_hdr);
            tunnel_type = ndpi_gtp_tunnel;
        }
    }
    // Check for TZSP protocol using ports
    else if((sport == TZSP_PORT || dport == TZSP_PORT) && (header->caplen >= ip_offset + sizeof(struct ndpi_udphdr) + 4)) {
        u_int8_t *tzsp = &packet[ip_offset + sizeof(struct ndpi_udphdr)];
        if(tzsp[0] == 0x01 && tzsp[3] == 0x00) { // TZSP version 1, packet encapsulation
            u_int16_t encap_proto = (tzsp[4] << 8) + tzsp[5];
            ip_offset = eth_offset = 0;
            datalink_type = encap_proto;
            goto datalink_check;
        }
    }
    // Check for CAPWAP protocol using source port
    else if(sport == NDPI_CAPWAP_DATA_PORT && (header->caplen >= ip_offset + sizeof(struct ndpi_udphdr) + 1)) {
        u_int8_t *capwap = &packet[ip_offset + sizeof(struct ndpi_udphdr)];
        if((capwap[0] & 0x0F) == 0x00) { // CAPWAP header
            ip_offset += sizeof(struct ndpi_udphdr) + ((capwap[1] & 0x0F) * 4); // CAPWAP header length
            tunnel_type = ndpi_capwap_tunnel;
        }
    }
}