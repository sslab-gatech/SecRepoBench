struct ndpi_udphdr *udp = (struct ndpi_udphdr *)&packet[ip_offset + ip_len];
u_int16_t sport = ntohs(udp->source), dport = ntohs(udp->dest);

if((sport == GTP_U_V1_PORT) || (dport == GTP_U_V1_PORT)) {
  u_int8_t *gtp_packet = (u_int8_t *)&packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr)];
  u_int8_t gtp_version = (gtp_packet[0] >> 5) & 0x07;
  u_int8_t gtp_message_type = gtp_packet[1];

  if((gtp_version == 1) && (gtp_message_type == 0xFF)) {
    ip_offset += ip_len + sizeof(struct ndpi_udphdr) + 8;
    tunnel_type = ndpi_gtp_tunnel;
  }
} else if((sport == TZSP_PORT) || (dport == TZSP_PORT)) {
  u_int8_t *tzsp = (u_int8_t *)&packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr)];
  u_int8_t version = tzsp[0];
  u_int8_t type = tzsp[1];

  if((version == 1) && (type == 0)) {
    u_int8_t *end = &packet[header->caplen];
    u_int8_t *tag = &tzsp[4];

    while(tag < end) {
      if(*tag == 1) {
        tag += 2;
        break;
      } else
        tag += tag[1] + 2;
    }

    if(tag < end) {
      ip_offset = (u_int16_t)(tag - packet);
      tunnel_type = ndpi_tzsp_tunnel;
    }
  }
} else if(sport == CAPWAP_DATA_PORT) {
  u_int8_t *capwap = (u_int8_t *)&packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr)];
  u_int8_t capwap_type = (capwap[0] >> 4) & 0x0F;

  if(capwap_type == 0) {
    u_int16_t capwap_header_len = (capwap[1] & 0xF8) >> 3;
    ip_offset += ip_len + sizeof(struct ndpi_udphdr) + capwap_header_len;
    tunnel_type = ndpi_capwap_tunnel;
  }
}