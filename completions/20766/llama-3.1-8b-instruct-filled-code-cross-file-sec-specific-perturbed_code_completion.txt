if(workflow->prefs.decode_tunnels && (proto == IPPROTO_UDP)) {
  // Parse the UDP header from the packet using the current IP offset.
  // Extract source and destination ports to identify potential tunnel protocols.
  // Check for GTP-U protocol by comparing ports, then verify GTP version and message type.
  // If GTP-U is detected, update IP offset to point to the encapsulated IP header.
  // Set the tunnel type to ndpi_gtp_tunnel for GTP-U packets.
  // Check for TZSP protocol using ports, then verify TZSP version and encapsulated protocol.
  // If TZSP is detected, navigate through its tags until reaching the encapsulated Ethernet frame.
  // Set the tunnel type to ndpi_tzsp_tunnel for TZSP packets.
  // Check for CAPWAP protocol using source port, then verify CAPWAP message type.
  // If CAPWAP is detected, update IP offset to point to the encapsulated IP header.
  // Set the tunnel type to ndpi_capwap_tunnel for CAPWAP packets.
  // The tunnel type and updated IP offset are used for further packet processing.
  struct ndpi_udp_hdr *udp = (struct ndpi_udp_hdr *) &packet[ip_offset];
  u_int16_t src_port = ntohs(udp->src_port);
  u_int16_t dst_port = ntohs(udp->dst_port);

  if (src_port == 2123 && dst_port == 2123) {
    // GTP-U protocol
    struct ndpi_gtp_hdr *gtp = (struct ndpi_gtp_hdr *) &packet[ip_offset + sizeof(struct ndpi_udp_hdr)];
    if (gtp->version == 1 && gtp->message_type == 1) {
      tunnel_type = ndpi_gtp_tunnel;
      ip_offset += sizeof(struct ndpi_udp_hdr) + sizeof(struct ndpi_gtp_hdr);
    }
  } else if (src_port == 1701 && dst_port == 1701) {
    // TZSP protocol
    struct ndpi_tzsp_hdr *tzsp = (struct ndpi_tzsp_hdr *) &packet[ip_offset + sizeof(struct ndpi_udp_hdr)];
    if (tzsp->version == 1 && tzsp->encapsulated_protocol == 0x0800) {
      tunnel_type = ndpi_tzsp_tunnel;
      ip_offset += sizeof(struct ndpi_udp_hdr) + sizeof(struct ndpi_tzsp_hdr);
    }
  } else if (src_port == 5246 && dst_port == 5246) {
    // CAPWAP protocol
    struct ndpi_capwap_hdr *capwap = (struct ndpi_capwap_hdr *) &packet[ip_offset + sizeof(struct ndpi_udp_hdr)];
    if (capwap->message_type == 0x0001) {
      tunnel_type = ndpi_capwap_tunnel;
      ip_offset += sizeof(struct ndpi_udp_hdr) + sizeof(struct ndpi_capwap_hdr);
    }
  }
}