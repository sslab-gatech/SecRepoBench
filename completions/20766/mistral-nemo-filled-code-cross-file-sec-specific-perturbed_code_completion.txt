if(workflow->prefs.decode_tunnels && (proto == IPPROTO_UDP)) {
    struct ndpi_udphdr *udph = (struct ndpi_udphdr *)&packet[ip_offset + ip_len];
    u_int16_t src_port = ntohs(udph->uh_sport);
    u_int16_t dst_port = ntohs(udph->uh_dport);

    if((src_port == GTPU_SRC_PORT && dst_port == GTPU_DST_PORT) ||
       (src_port == GTPU_DST_PORT && dst_port == GTPU_SRC_PORT)) {
      tunnel_type = ndpi_gtp_tunnel;
      ip_offset += sizeof(struct ndpi_udphdr);
    } else if((src_port == TZSP_SRC_PORT && dst_port == TZSP_DST_PORT) ||
              (src_port == TZSP_DST_PORT && dst_port == TZSP_SRC_PORT)) {
      tunnel_type = ndpi_tzsp_tunnel;
      ip_offset += sizeof(struct ndpi_udphdr);
      // Navigate through TZSP tags until reaching the encapsulated Ethernet frame.
    } else if(src_port == CAPWAP_SRC_PORT) {
      tunnel_type = ndpi_capwap_tunnel;
      ip_offset += sizeof(struct ndpi_udphdr);
    } else {
      tunnel_type = ndpi_no_tunnel;
    }
  }

  /* process the packet */
  return(packet_processing(workflow, time, vlan_id, tunnel_type, iph, iph6,
                           ip_offset, header->caplen - ip_offset,
                           header->caplen, header, packet, header->ts));