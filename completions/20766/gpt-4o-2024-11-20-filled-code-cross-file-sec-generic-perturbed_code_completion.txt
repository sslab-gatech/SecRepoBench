struct ndpi_udphdr *udph = NULL;
    struct ndpi_gtphdr *gtph = NULL;
    struct ndpi_tcphdr *tcph = NULL;

    u_int16_t sport = 0, dport = 0;
    u_int16_t gtp_message_type = 0;
    u_int8_t *payload = NULL;
    u_int16_t payload_len = 0;

    /* Check for UDP-based tunnels */
    if(proto == IPPROTO_UDP) {
      udph = (struct ndpi_udphdr *) &packet[ip_offset + ip_len];
      sport = ntohs(udph->source);
      dport = ntohs(udph->dest);

      /* Check for GTP-U (GPRS Tunneling Protocol User Plane) */
      if((dport == 2152) || (sport == 2152)) { /* GTP-U port */
        gtph = (struct ndpi_gtphdr *) &packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr)];
        gtp_message_type = gtph->message_type;

        if((gtph->version == 1) && (gtp_message_type == 255)) { /* GTP-U message type */
          ip_offset += ip_len + sizeof(struct ndpi_udphdr) + sizeof(struct ndpi_gtphdr);
          tunnel_type = ndpi_gtp_tunnel;
        }
      }

      /* Check for TZSP (TaZmen Sniffer Protocol) */
      if((dport == 37008) || (sport == 37008)) { /* TZSP port */
        u_int8_t *tzsp_header = (u_int8_t *) &packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr)];
        if(tzsp_header[0] == 1) { /* TZSP version */
          u_int8_t encapsulated_protocol = tzsp_header[1];
          if(encapsulated_protocol == 1) { /* Ethernet encapsulation */
            u_int16_t tzsp_offset = ip_len + sizeof(struct ndpi_udphdr) + 2;
            while(tzsp_header[tzsp_offset] != 1) { /* Skip TZSP tags */
              tzsp_offset += tzsp_header[tzsp_offset + 1] + 2;
            }
            ip_offset += tzsp_offset + 1; /* Point to encapsulated Ethernet frame */
            tunnel_type = ndpi_tzsp_tunnel;
          }
        }
      }

      /* Check for CAPWAP (Control and Provisioning of Wireless Access Points) */
      if((dport == 5246) || (sport == 5246)) { /* CAPWAP control port */
        u_int8_t *capwap_header = (u_int8_t *) &packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr)];
        if((capwap_header[0] & 0xF0) == 0x00) { /* CAPWAP version */
          if(capwap_header[0] & 0x04) { /* Check for payload presence */
            ip_offset += ip_len + sizeof(struct ndpi_udphdr) + 8; /* Point to encapsulated IP header */
            tunnel_type = ndpi_capwap_tunnel;
          }
        }
      }
    }