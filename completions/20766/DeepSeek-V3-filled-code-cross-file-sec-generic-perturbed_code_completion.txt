struct ndpi_udphdr *udp = (struct ndpi_udphdr *)&packet[ip_offset + ip_len];
    u_int16_t sport = ntohs(udp->source), dport = ntohs(udp->dest);

    if((sport == GTP_U_V1_PORT) || (dport == GTP_U_V1_PORT)) {
      struct ndpi_gtpv1_header *gtp = (struct ndpi_gtpv1_header *)&packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr)];
      if((gtp->flags & 0xE0) == 0x20) { /* GTPv1-U */
        ip_offset += ip_len + sizeof(struct ndpi_udphdr) + sizeof(struct ndpi_gtpv1_header);
        tunnel_type = ndpi_gtp_tunnel;
      }
    } else if((sport == TZSP_PORT) || (dport == TZSP_PORT)) {
      struct ndpi_tzsp_header *tzsp = (struct ndpi_tzsp_header *)&packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr)];
      if(tzsp->version == 1) {
        u_int8_t *tzsp_payload = (u_int8_t *)tzsp + sizeof(struct ndpi_tzsp_header);
        while(*tzsp_payload != 0) { /* Skip tags */
          tzsp_payload += 2 + tzsp_payload[1];
        }
        ip_offset = (tzsp_payload + 1) - packet;
        tunnel_type = ndpi_tzsp_tunnel;
      }
    } else if(sport == CAPWAP_DATA_PORT) {
      struct ndpi_capwap_header *capwap = (struct ndpi_capwap_header *)&packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr)];
      if((capwap->type & 0x7) == 0) { /* Data packet */
        ip_offset += ip_len + sizeof(struct ndpi_udphdr) + sizeof(struct ndpi_capwap_header);
        tunnel_type = ndpi_capwap_tunnel;
      }
    }