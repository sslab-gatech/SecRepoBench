if(workflow->prefs.decode_tunnels && (proto == IPPROTO_UDP)) {
    u_int16_t sport = ntohs(iph->sport), dport = ntohs(iph->dport);

    if((sport == GTPv1_U_PORT || sport == GTPv0_U_PORT) && (dport == GTPv1_U_PORT || dport == GTPv0_U_PORT)) {
      u_int8_t gtpu_version = (packet[ip_offset] >> 5) & 0x07;
      u_int8_t gtpu_message_type = packet[ip_offset + 1];

      if((gtpu_version == 1 && gtpu_message_type == GTPv1_USER_DATA_PACKET) ||
         (gtpu_version == 0 && gtpu_message_type == GTPv0_T_PDU)) {
        ip_offset += 8; /* GTPv1/GTPv0 header len */
        iph = (struct ndpi_iphdr *) &packet[ip_offset];
        tunnel_type = ndpi_gtp_tunnel;
      }
    } else if((sport == TZSP_PORT || dport == TZSP_PORT) && (packet[ip_offset] == TZSP_VERSION)) {
      u_int16_t len = ntohs(*((u_int16_t*)&packet[ip_offset+2]));
      u_int8_t tag = packet[ip_offset+4];

      while(tag != TZSP_TAG_END && ((ip_offset + 5 + len) < header->caplen)) {
        switch(tag) {
        case TZSP_TAG_VLAN:
          vlan_id = ntohs(*((u_int16_t*)&packet[ip_offset+5]));
          break;
        case TZSP_TAG_DIRECTION:
          *src_to_dst_direction = packet[ip_offset+5];
          break;
        case TZSP_TAG_ENCAPSULATED:
          ip_offset += 5 + len;
          iph = (struct ndpi_iphdr *) &packet[ip_offset];
          tunnel_type = ndpi_tzsp_tunnel;
          break;
        }

        tag = packet[ip_offset+5+len];
        len = ntohs(*((u_int16_t*)&packet[ip_offset+6+len]));
      }
    } else if(sport == CAPWAP_DATA_PORT || dport == CAPWAP_DATA_PORT) {
      u_int8_t msg_type = packet[ip_offset+1];

      if(msg_type == CAPWAP_PREAMBLE) {
        u_int16_t msg_len = ntohs(*((u_int16_t*)&packet[ip_offset+2]));

        if((ip_offset + msg_len) <= header->caplen) {
          ip_offset += msg_len;
          iph = (struct ndpi_iphdr *) &packet[ip_offset];
          tunnel_type = ndpi_capwap_tunnel;
        }
      }
    }
  }