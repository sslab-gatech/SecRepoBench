struct ndpi_udphdr *udph = NULL;
    u_int16_t sport = 0, dport = 0;

    udph = (struct ndpi_udphdr *) &packet[ip_offset + ip_len];
    sport = ntohs(udph->source), dport = ntohs(udph->dest);

    if(sport == GTP_U_PORT || dport == GTP_U_PORT) {
      // Check for GTP packets
      u_int8_t message_type = packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr) + 1];
      u_int8_t gtp_version = packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr)] & 0xF0;

      if(gtp_version == 1 && message_type == GTP_G_PDU) {
	ip_offset += ip_len + 8; // jump UDP + GTP-U header
	tunnel_type = ndpi_gtp_tunnel;
	goto iph_check;
      }
    } else if (sport == TZSP_PORT || dport == TZSP_PORT) {
      // Check for TZSP packets
      u_int8_t tzsp_version = packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr)];
      u_int8_t tzsp_encap_proto = packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr) + 1];

      if (tzsp_version == 1 && tzsp_encap_proto == TZSP_ENCAP_ETH) {
	u_int16_t tzsp_offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr) + 2;
	u_int16_t tzsp_tag_len;

	while (tzsp_offset < header->caplen) {
	  tzsp_tag_len = ntohs(*(u_int16_t*)(packet + tzsp_offset));
	  tzsp_offset += 2 + tzsp_tag_len;
	  if (tzsp_offset + sizeof(struct ndpi_ethhdr) <= header->caplen) {
	    ip_offset = tzsp_offset;
	    tunnel_type = ndpi_tzsp_tunnel;
	    datalink_type = DLT_EN10MB;
	    goto datalink_check;
	  }
	}
      }
    } else if (sport == CAPWAP_CONTROL_PORT) {
      // Check for CAPWAP packets
      u_int8_t capwap_message_type = packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr) + 1];

      if (capwap_message_type == CAPWAP_DATA_MESSAGE) {
	ip_offset += ip_len + 8; // jump UDP + CAPWAP header
	tunnel_type = ndpi_capwap_tunnel;
	goto iph_check;
      }
    }