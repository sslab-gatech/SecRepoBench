// <MASK>
if(proto == IPPROTO_UDP) {
  struct ndpi_udphdr *udp = (struct ndpi_udphdr *)&packet[ip_offset];
  u_int16_t sport = ntohs(udp->source), dport = ntohs(udp->dest);

  // Check for GTP-U protocol
  if((sport == 2152 || dport == 2152) && (header->caplen >= ip_offset + sizeof(struct ndpi_udphdr) + 8)) {
    u_int8_t gtpu_version = (packet[ip_offset + sizeof(struct ndpi_udphdr)] >> 5) & 0x07;
    u_int8_t gtpu_message_type = packet[ip_offset + sizeof(struct ndpi_udphdr) + 1];

    if(gtpu_version == 1 && (gtpu_message_type == 0xFF || gtpu_message_type == 0x01)) {
      ip_offset += sizeof(struct ndpi_udphdr) + 8;
      tunnel_type = ndpi_gtp_tunnel;
    }
  }
  // Check for TZSP protocol
  else if((sport == 37008 || dport == 37008) && (header->caplen >= ip_offset + sizeof(struct ndpi_udphdr) + 4)) {
    u_int8_t tzsp_version = packet[ip_offset + sizeof(struct ndpi_udphdr)];
    u_int8_t tzsp_type = packet[ip_offset + sizeof(struct ndpi_udphdr) + 1];

    if(tzsp_version == 1 && tzsp_type == 0x01) {
      u_int16_t tzsp_length = ntohs(*(u_int16_t *)&packet[ip_offset + sizeof(struct ndpi_udphdr) + 2]);
      u_int16_t encapsulated_proto = 0;
      u_int16_t tag_type, tag_length;
      u_int16_t offset = sizeof(struct ndpi_udphdr) + 4;

      while(offset < tzsp_length && offset < header->caplen - ip_offset) {
        tag_type = packet[ip_offset + offset++];
        tag_length = packet[ip_offset + offset++];

        if(tag_type == 0x01) { // TZSP tag: Encapsulated Protocol
          encapsulated_proto = (packet[ip_offset + offset] << 8) | packet[ip_offset + offset + 1];
          break;
        }

        offset += tag_length;
      }

      if(encapsulated_proto == ETH_P_IP || encapsulated_proto == ETH_P_IPV6) {
        ip_offset += offset;
        tunnel_type = ndpi_tzsp_tunnel;
      }
    }
  }
  // Check for CAPWAP protocol
  else if(sport == 5247) {
    u_int8_t capwap_type = packet[ip_offset + sizeof(struct ndpi_udphdr)];

    if(capwap_type == 0x21 || capwap_type == 0x11) {
      ip_offset += sizeof(struct ndpi_udphdr) + 1;
      tunnel_type = ndpi_capwap_tunnel;
    }
  }
}