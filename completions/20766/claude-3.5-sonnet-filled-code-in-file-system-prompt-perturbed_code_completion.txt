struct ndpi_udphdr *udp = (struct ndpi_udphdr *)&packet[ip_offset + ip_len];
u_int16_t sport = ntohs(udp->source), dport = ntohs(udp->dest);

if((sport == GTP_U_V1_PORT) || (dport == GTP_U_V1_PORT)) {
  u_int8_t *gtp_packet = (u_int8_t *)&packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr)];
  u_int8_t gtp_version = (gtp_packet[0] & 0xE0) >> 5;
  u_int8_t gtp_msg_type = gtp_packet[1];

  if((gtp_version == 1) && (gtp_msg_type == 0xFF)) {
    ip_offset += ip_len + sizeof(struct ndpi_udphdr) + 8; /* GTP-U header size */
    tunnel_type = ndpi_gtp_tunnel;
  }
} else if(dport == TZSP_PORT) {
  u_int8_t *tzsp = (u_int8_t *)&packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr)];
  u_int8_t version = tzsp[0];
  u_int8_t type = tzsp[1];

  if((version == 1) && (type == 0)) {
    u_int8_t *end = &packet[header->caplen];
    u_int8_t *tag = &tzsp[4];

    while(tag < end) {
      if(tag[0] == 0) {
        tag = &tag[1];
        break;
      } else if(tag[0] == 1) {
        tag = &tag[5];
      } else {
        tag = &tag[2];
      }
    }

    if(tag < end) {
      ip_offset = (u_int16_t)(tag - packet);
      tunnel_type = ndpi_tzsp_tunnel;
    }
  }
} else if(sport == CAPWAP_DATA_PORT) {
  u_int8_t *capwap = (u_int8_t *)&packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr)];
  u_int8_t capwap_type = (capwap[0] & 0xF0) >> 4;

  if(capwap_type == 0) { /* CAPWAP Data Packet */
    u_int16_t capwap_header_len = (capwap[1] & 0xF8) >> 1;
    ip_offset += ip_len + sizeof(struct ndpi_udphdr) + capwap_header_len;
    tunnel_type = ndpi_capwap_tunnel;
  }
}