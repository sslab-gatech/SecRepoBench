struct ndpi_udphdr *udp = (struct ndpi_udphdr *)&packet[ip_offset + ip_len];
    u_int16_t sport = ntohs(udp->source), dport = ntohs(udp->dest);

    if((sport == GTP_U_V1_PORT) || (dport == GTP_U_V1_PORT)) {
      struct ndpi_gtpv1_header *gtp = (struct ndpi_gtpv1_header *)&packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr)];
      
      if((gtp->flags & 0xE0) == 0x30) { /* GTPv1-U */
        ip_offset += ip_len + sizeof(struct ndpi_udphdr) + sizeof(struct ndpi_gtpv1_header);
        tunnel_type = ndpi_gtp_tunnel;
        proto = gtp->proto;
        goto iph_check;
      }
    } else if((sport == TZSP_PORT) || (dport == TZSP_PORT)) {
      struct ndpi_tzsp_header *tzsp = (struct ndpi_tzsp_header *)&packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr)];
      
      if(tzsp->version == 1) {
        u_int8_t *tzsp_payload = (u_int8_t *)tzsp + sizeof(struct ndpi_tzsp_header);
        u_int16_t tzsp_len = sizeof(struct ndpi_tzsp_header);
        
        /* Skip TZSP tags */
        while(*tzsp_payload != 0) { /* 0 = end of tags */
          tzsp_len += 2 + tzsp_payload[1];
          tzsp_payload += 2 + tzsp_payload[1];
        }
        tzsp_len++; /* Skip end-of-tags marker */
        
        ip_offset += ip_len + sizeof(struct ndpi_udphdr) + tzsp_len;
        tunnel_type = ndpi_tzsp_tunnel;
        datalink_type = DLT_EN10MB;
        eth_offset = 0;
        goto datalink_check;
      }
    } else if(sport == CAPWAP_DATA_PORT) {
      struct ndpi_capwap_header *capwap = (struct ndpi_capwap_header *)&packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr)];
      
      if((capwap->type & 0xF8) == 0x00) { /* CAPWAP Data */
        ip_offset += ip_len + sizeof(struct ndpi_udphdr) + sizeof(struct ndpi_capwap_header);
        tunnel_type = ndpi_capwap_tunnel;
        goto iph_check;
      }
    }