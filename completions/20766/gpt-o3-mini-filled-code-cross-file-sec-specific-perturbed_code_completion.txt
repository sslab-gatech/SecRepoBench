if (header->caplen < ip_offset + sizeof(struct ndpi_udphdr))
  goto skip_tunnel;

{
  const struct ndpi_udphdr *udph = (const struct ndpi_udphdr *)(packet + ip_offset);
  uint16_t src_port = ntohs(udph->source);
  uint16_t dst_port = ntohs(udph->dest);
  size_t udp_header_len = sizeof(struct ndpi_udphdr);

  /* Check for GTP-U tunnel (typically port 2152) */
  if (src_port == 2152 || dst_port == 2152) {
    if (header->caplen >= ip_offset + udp_header_len + 8) {
      uint8_t gtp_flags = packet[ip_offset + udp_header_len];
      uint8_t gtp_msg_type = packet[ip_offset + udp_header_len + 1];
      if (((gtp_flags >> 5) == 1) && (gtp_msg_type == 255)) {
        tunnel_type = ndpi_gtp_tunnel;
        ip_offset += udp_header_len + 8;
        goto tunnel_handled;
      }
    }
  }

  /* Check for TZSP tunnel (typically port 37008) */
  if (src_port == 37008 || dst_port == 37008) {
    if (header->caplen >= ip_offset + udp_header_len + 2) {
      size_t tzsp_off = ip_offset + udp_header_len;
      uint8_t tzsp_version = packet[tzsp_off];
      if (tzsp_version == 1) { /* expected TZSP version */
        tzsp_off += 2; /* skip version and type */
        while (tzsp_off < header->caplen) {
          uint8_t tag_type = packet[tzsp_off++];
          if (tag_type == 1) { /* End tag */
            break;
          }
          if (tzsp_off >= header->caplen)
            break;
          uint8_t tag_len = packet[tzsp_off++];
          if (tzsp_off + tag_len > header->caplen)
            break;
          tzsp_off += tag_len;
        }
        if (tzsp_off <= header->caplen) {
          tunnel_type = ndpi_tzsp_tunnel;
          ip_offset = tzsp_off;
          goto tunnel_handled;
        }
      }
    }
  }

  /* Check for CAPWAP tunnel (typically source port 5246) */
  if (src_port == 5246) {
    if (header->caplen >= ip_offset + udp_header_len + 4) {
      /* Optionally, further verification of the CAPWAP header can be done here */
      tunnel_type = ndpi_capwap_tunnel;
      ip_offset += udp_header_len + 4;
      goto tunnel_handled;
    }
  }

  /* If no known tunnel protocol is detected, advance past UDP header */
  ip_offset += udp_header_len;
}

tunnel_handled:
  /* continue processing tunneled/UDP packet */
skip_tunnel: