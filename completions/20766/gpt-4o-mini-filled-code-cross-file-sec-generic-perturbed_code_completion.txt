struct ndpi_udphdr *udph = NULL;
    struct ndpi_tcphdr *tcph = NULL;
    u_int16_t sport = 0, dport = 0;
    u_int8_t *payload = NULL;
    u_int16_t payload_len = 0;
    u_int8_t src_to_dst_direction = 0;

    // Check for GTP-U protocol (UDP port 2152)
    if (proto == IPPROTO_UDP) {
        udph = (struct ndpi_udphdr *) &packet[ip_offset];
        sport = ntohs(udph->source);
        dport = ntohs(udph->dest);

        if (sport == 2152 || dport == 2152) {
            // GTP-U detected
            ip_offset += sizeof(struct ndpi_udphdr);
            tunnel_type = ndpi_gtp_tunnel;
            // Update IP header offset for encapsulated packet
            iph = (struct ndpi_iphdr *) &packet[ip_offset];
        }
    }

    // Check for TZSP protocol (UDP port 37008)
    if (proto == IPPROTO_UDP && (sport == 37008 || dport == 37008)) {
        // TZSP detected
        ip_offset += sizeof(struct ndpi_udphdr);
        tunnel_type = ndpi_tzsp_tunnel;
        // Update IP header offset for encapsulated packet
        iph = (struct ndpi_iphdr *) &packet[ip_offset];
    }

    // Check for CAPWAP protocol (UDP port 5246)
    if (proto == IPPROTO_UDP && (sport == 5246 || dport == 5246)) {
        // CAPWAP detected
        ip_offset += sizeof(struct ndpi_udphdr);
        tunnel_type = ndpi_capwap_tunnel;
        // Update IP header offset for encapsulated packet
        iph = (struct ndpi_iphdr *) &packet[ip_offset];
    }