{
  struct ndpi_udphdr *udph;
  /* Ensure there's enough space for the UDP header */
  if(header->caplen - ip_offset < sizeof(struct ndpi_udphdr))
    break; /* Not enough data to read UDP header */

  udph = (struct ndpi_udphdr *)&packet[ip_offset];
  uint16_t sport = ntohs(udph->source);
  uint16_t dport = ntohs(udph->dest);

  /* Check for GTP-U on port 2152 */
  if(sport == 2152 || dport == 2152) {
    /* GTP-U header is at least 8 bytes */
    if((header->caplen - ip_offset) >= (sizeof(struct ndpi_udphdr) + 8)) {
      uint8_t gtp_flags = packet[ip_offset + sizeof(struct ndpi_udphdr)];
      uint8_t gtp_msg_type = packet[ip_offset + sizeof(struct ndpi_udphdr) + 1];
      /* Check version = 1 (bits 5..7) and message type = 0xFF for T-PDU */
      if(((gtp_flags >> 5) & 0x07) == 1 && gtp_msg_type == 0xFF) {
        ip_offset += sizeof(struct ndpi_udphdr) + 8; 
        if(ip_offset < header->caplen) {
          tunnel_type = ndpi_gtp_tunnel;
        }
      }
    }
  }
  /* Check for CAPWAP on port 5247 */
  else if(sport == 5247 || dport == 5247) {
    /* Minimal CAPWAP header is 8 bytes */
    if((header->caplen - ip_offset) >= (sizeof(struct ndpi_udphdr) + 8)) {
      uint8_t capwap_flags = packet[ip_offset + sizeof(struct ndpi_udphdr)];
      uint8_t capwap_msg_type = packet[ip_offset + sizeof(struct ndpi_udphdr) + 1];
      /* Check if it's likely a CAPWAP data packet (flags & 0x03 == 1, msg_type == 0) */
      if(((capwap_flags & 0x03) == 0x01) && (capwap_msg_type == 0)) {
        ip_offset += sizeof(struct ndpi_udphdr) + 8;
        if(ip_offset < header->caplen) {
          tunnel_type = ndpi_capwap_tunnel;
        }
      }
    }
  }
  /* Check for TZSP on port 37008 */
  else if(sport == 37008 || dport == 37008) {
    /* Minimal TZSP header is 4 bytes */
    if((header->caplen - ip_offset) >= (sizeof(struct ndpi_udphdr) + 4)) {
      uint8_t tzsp_version = packet[ip_offset + sizeof(struct ndpi_udphdr)];
      uint8_t tzsp_type = packet[ip_offset + sizeof(struct ndpi_udphdr) + 1];
      /* TZSP version 1 and type 0 indicate an Ethernet frame */
      if((tzsp_version == 1) && (tzsp_type == 0)) {
        ip_offset += sizeof(struct ndpi_udphdr) + 4;
        if(ip_offset < header->caplen) {
          tunnel_type = ndpi_tzsp_tunnel;
        }
      }
    }
  }
}