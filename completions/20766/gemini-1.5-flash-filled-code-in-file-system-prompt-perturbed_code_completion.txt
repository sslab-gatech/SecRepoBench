if(ntohs(iph->dport) == GTP_U_V1_PORT) {
      u_int8_t gtp_version;
      u_int8_t gtp_msg_type;

      if(payload_len >= 4) {
	gtp_version = (payload[0] >> 4) & 0xF;
	gtp_msg_type = payload[1] & 0x7F;

	if(gtp_version == 1 && gtp_msg_type != 0x03) {
	  ip_offset += sizeof(struct ndpi_udphdr) + 8;
	  tunnel_type = ndpi_gtp_tunnel;
	}
      }
    } else if(ntohs(iph->sport) == TZSP_PORT || ntohs(iph->dport) == TZSP_PORT) {
      u_int8_t tzsp_version;
      u_int8_t tzsp_proto;

      if(payload_len >= 2) {
	tzsp_version = payload[0] & 0xF;
	tzsp_proto = payload[1] & 0xF;

	if(tzsp_version == 1) {
	  u_int16_t tzsp_len = ntohs(*(u_int16_t*)&payload[2]);
	  ip_offset += sizeof(struct ndpi_udphdr) + tzsp_len;
	  tunnel_type = ndpi_tzsp_tunnel;
	}
      }
    } else if(ntohs(iph->sport) == NDPI_CAPWAP_DATA_PORT) {
      u_int16_t capwap_msg_type;

      if(payload_len >= 2) {
	capwap_msg_type = ntohs(*(u_int16_t*)&payload[0]);

	if(capwap_msg_type != 0x0000) {
	  ip_offset += sizeof(struct ndpi_udphdr) + 4;
	  tunnel_type = ndpi_capwap_tunnel;
	}
      }
    }