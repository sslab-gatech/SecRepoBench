u_int16_t udp_offset = ip_offset + ip_len;
    if (udp_offset + sizeof(struct ndpi_udphdr) > header->caplen) return ndpiprotocol;
    struct ndpi_udphdr *udp = (struct ndpi_udphdr *)&packet[udp_offset];
    u_int16_t sport = ntohs(udp->source), dport = ntohs(udp->dest);

    /* Check GTP-U */
    if(dport == 2152) {
        if(udp_offset + sizeof(*udp) + 8 <= header->caplen) {
            u_int8_t *gtp = (u_int8_t*)(udp + 1);
            u_int8_t version = (gtp[0] >> 5) & 0x07;
            u_int8_t msg_type = gtp[1];
            if(version == 1 && msg_type == 0xFF) { /* GTPv1, G-PDU */
                ip_offset = udp_offset + sizeof(*udp) + 8;
                tunnel_type = ndpi_gtp_tunnel;
            }
        }
    }
    /* Check TZSP */
    else if((sport == 6188 || sport == 6189 || dport == 6188 || dport == 6189) &&
            (udp_offset + sizeof(*udp) + 2 <= header->caplen)) {
        u_int8_t *tzsp = (u_int8_t*)(udp + 1);
        u_int8_t version = tzsp[0], encap_type = tzsp[1];
        if(version == 1 && encap_type == 0) { /* Ethernet encapsulation */
            u_int8_t *ptr = tzsp + 2;
            while(ptr + 2 <= &packet[header->caplen]) {
                u_int8_t tag_type = *ptr++;
                if(tag_type == 0) break;
                u_int8_t tag_len = *ptr++;
                ptr += tag_len;
                if(ptr > &packet[header->caplen]) break;
            }
            eth_offset = udp_offset + sizeof(*udp) + (ptr - tzsp);
            datalink_type = DLT_EN10MB;
            goto datalink_check;
        }
        tunnel_type = ndpi_tzsp_tunnel;
    }
    /* Check CAPWAP */
    else if((sport == 5246 || sport == 5247) &&
            (udp_offset + sizeof(*udp) + 8 <= header->caplen)) {
        u_int8_t *capwap = (u_int8_t*)(udp + 1);
        u_int8_t msg_type = capwap[0] & 0x7F;
        if(msg_type == 0) { /* Data message */
            ip_offset = udp_offset + sizeof(*udp) + 8;
            tunnel_type = ndpi_capwap_tunnel;
        }
    }