struct ndpi_udphdr *udph = NULL;
    u_int16_t sport = 0, dport = 0;

    udph = (struct ndpi_udphdr *) &packet[ip_offset + ip_len];
    sport = ntohs(udph->source), dport = ntohs(udph->dest);

    if (sport == GTP_U_PORT || dport == GTP_U_PORT) {
      // Check for GTP-U protocol
      u_int8_t message_type = packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr)];

      if ((message_type == GTP_G_PDU || message_type == GTP_T_PDU) && packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr)+1] == 1) {
          ip_offset += ip_len + 8;
          tunnel_type = ndpi_gtp_tunnel;
          goto iph_check;
      }
    } else if(sport == TZSP_PORT || dport == TZSP_PORT) {
      // Check for TZSP protocol
      u_int8_t tzsp_version = packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr)];
      u_int8_t tzsp_encap_proto = packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr) + 1];

      if(tzsp_version == 1 && tzsp_encap_proto == 0) {
        u_int16_t tzsp_offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr) + 4;
        u_int16_t tzsp_tag_len = 0;

        while(tzsp_offset + 2 < header->caplen) {
          tzsp_tag_len = ntohs(*((u_int16_t*)(packet + tzsp_offset)));
          if(tzsp_tag_len == 0)
            break;

          tzsp_offset += tzsp_tag_len + 2;
        }

        if(tzsp_offset + sizeof(struct ndpi_ethhdr) <= header->caplen) {
          ip_offset = tzsp_offset;
          tunnel_type = ndpi_tzsp_tunnel;
          datalink_type = DLT_EN10MB;
          goto datalink_check;
        }
      }
    } else if (dport == CAPWAP_CONTROL_PORT) {
      // Check for CAPWAP protocol
      u_int8_t capwap_message_type = packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr) + 4];
      if (capwap_message_type == CAPWAP_DATA_MESSAGE) {
        ip_offset += ip_len + 8 + 8; // Skip UDP, CAPWAP header, and WTP radio MAC
        tunnel_type = ndpi_capwap_tunnel;
        goto iph_check;
      }
    }