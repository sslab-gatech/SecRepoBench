// Parse the UDP header from the packet using the current IP offset.
struct ndpi_udphdr *udph = (struct ndpi_udphdr *)&packet[ip_offset];

// Extract source and destination ports to identify potential tunnel protocols.
u_int16_t src_port = ntohs(udph->source);
u_int16_t dst_port = ntohs(udph->dest);

// Check for GTP-U protocol by comparing ports, then verify GTP version and message type.
if (src_port == 2152 || dst_port == 2152) {
  // GTP-U header is 8 bytes long, so we need to check if the packet is long enough.
  if (header->caplen < ip_offset + sizeof(struct ndpi_udphdr) + 8) {
    return ndpiprotocol; // Too short for GTP-U header
  }

  // Parse the GTP-U header.
  struct ndpi_gtpu_header *gtpu = (struct ndpi_gtpu_header *)&packet[ip_offset + sizeof(struct ndpi_udphdr)];

  // Verify GTP version and message type.
  if (gtpu->version == 1 && (gtpu->msg_type == 0xff || gtpu->msg_type == 0xfe)) {
    // Update IP offset to point to the encapsulated IP header.
    ip_offset += sizeof(struct ndpi_udphdr) + 8;

    // Set the tunnel type to ndpi_gtp_tunnel for GTP-U packets.
    tunnel_type = ndpi_gtp_tunnel;
  }
}

// Check for TZSP protocol using ports, then verify TZSP version and encapsulated protocol.
if (src_port == 3873 || dst_port == 3873) {
  // TZSP header is 4 bytes long, so we need to check if the packet is long enough.
  if (header->caplen < ip_offset + sizeof(struct ndpi_udphdr) + 4) {
    return ndpiprotocol; // Too short for TZSP header
  }

  // Parse the TZSP header.
  struct ndpi_tzsp_header *tzsp = (struct ndpi_tzsp_header *)&packet[ip_offset + sizeof(struct ndpi_udphdr)];

  // Verify TZSP version and encapsulated protocol.
  if (tzsp->version == 1 && tzsp->encapsulated_protocol == 0x0800) {
    // Navigate through TZSP tags until reaching the encapsulated Ethernet frame.
    u_int16_t tzsp_offset = ip_offset + sizeof(struct ndpi_udphdr) + 4;
    while (tzsp_offset < header->caplen) {
      struct ndpi_tzsp_tag *tag = (struct ndpi_tzsp_tag *)&packet[tzsp_offset];

      // Check if the tag is a payload tag.
      if (tag->tag_type == 0x01) {
        // Update IP offset to point to the encapsulated Ethernet frame.
        ip_offset = tzsp_offset + 4;

        // Set the tunnel type to ndpi_tzsp_tunnel for TZSP packets.
        tunnel_type = ndpi_tzsp_tunnel;

        break;
      }

      // Move to the next tag.
      tzsp_offset += 4 + ntohs(tag->tag_length);
    }
  }
}

// Check for CAPWAP protocol using source port, then verify CAPWAP message type.
if (src_port == 5246) {
  // CAPWAP header is 4 bytes long, so we need to check if the packet is long enough.
  if (header->caplen < ip_offset + sizeof(struct ndpi_udphdr) + 4) {
    return ndpiprotocol; // Too short for CAPWAP header
  }

  // Parse the CAPWAP header.
  struct ndpi_capwap_header *capwap = (struct ndpi_capwap_header *)&packet[ip_offset + sizeof(struct ndpi_udphdr)];

  // Verify CAPWAP message type.
  if (capwap->msg_type == 0x03) {
    // Update IP offset to point to the encapsulated IP header.
    ip_offset += sizeof(struct ndpi_udphdr) + 4;

    // Set the tunnel type to ndpi_capwap_tunnel for CAPWAP packets.
    tunnel_type = ndpi_capwap_tunnel;
  }
}