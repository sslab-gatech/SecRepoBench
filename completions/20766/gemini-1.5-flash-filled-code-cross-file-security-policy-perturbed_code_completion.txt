const struct ndpi_udphdr *udp = (struct ndpi_udphdr *) &packet[ip_offset + (iph ? ((u_int16_t)iph->ihl * 4) : ip_len)];
    u_int16_t src_port = ntohs(udp->source);
    u_int16_t dst_port = ntohs(udp->dest);
    int udp_len = ntohs(udp->len);

    if (header->caplen < ip_offset + ip_len + sizeof(struct ndpi_udphdr))
      return ndpiprotocol;

    if (src_port == GTPU_PORT || dst_port == GTPU_PORT) {
      // Check GTP-U
      if (check_gtp(packet + ip_offset + ip_len + sizeof(struct ndpi_udphdr), udp_len - sizeof(struct ndpi_udphdr), &ip_offset)) {
        tunnel_type = ndpi_gtp_tunnel;
      }
    } else if (src_port == TZSP_PORT || dst_port == TZSP_PORT) {
      // Check TZSP
      if (check_tzsp(packet + ip_offset + ip_len + sizeof(struct ndpi_udphdr), udp_len - sizeof(struct ndpi_udphdr), &ip_offset)) {
        tunnel_type = ndpi_tzsp_tunnel;
      }
    } else if (src_port == CAPWAP_PORT) {
      // Check CAPWAP
      if (check_capwap(packet + ip_offset + ip_len + sizeof(struct ndpi_udphdr), udp_len - sizeof(struct ndpi_udphdr), &ip_offset)) {
        tunnel_type = ndpi_capwap_tunnel;
      }
    }