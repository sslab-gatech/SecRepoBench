struct ndpi_udphdr *udph = (struct ndpi_udphdr *)&packet[ip_offset + ip_len];
    u_int16_t sport = ntohs(udph->source);
    u_int16_t dport = ntohs(udph->dest);

    // Check for GTP-U (port 2152)
    if ((sport == 2152 || dport == 2152) && 
        (header->caplen >= ip_offset + ip_len + sizeof(struct ndpi_udphdr) + 4)) {
      // Verify GTP version and message type
      u_int8_t *gtp_header = (u_int8_t *)&packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr)];
      if ((gtp_header[0] & 0x0f) >= 1 && (gtp_header[1] & 0x3f) == 0) {
        tunnel_type = ndpi_gtp_tunnel;
        ip_offset += ip_len + sizeof(struct ndpi_udphdr) + 4;  // Skip UDP + GTP header
      }
    }

    // Check for TZSP (port 9999)
    else if (sport == 9999 && 
             (header->caplen >= ip_offset + ip_len + sizeof(struct ndpi_udphdr) + 4)) {
      // Verify TZSP version and tags
      u_int8_t *tzsp_header = (u_int8_t *)&packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr)];
      if (tzsp_header[0] == 0x01 && tzsp_header[1] == 0x00) {
        tunnel_type = ndpi_tzsp_tunnel;
        // Skip UDP + TZSP header and navigate through tags
        ip_offset += ip_len + sizeof(struct ndpi_udphdr) + 4;
        // Continue until encapsulated Ethernet frame is found
        while (ip_offset < header->caplen && packet[ip_offset] != 0xAA) {
          ip_offset++;
        }
      }
    }

    // Check for CAPWAP (port 5246)
    else if (sport == 5246 && 
             (header->caplen >= ip_offset + ip_len + sizeof(struct ndpi_udphdr) + 4)) {
      // Verify CAPWAP message type
      u_int8_t *capwap_header = (u_int8_t *)&packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr)];
      if (capwap_header[0] == 0x01 && (capwap_header[1] & 0x0f) == 0x01) {
        tunnel_type = ndpi_capwap_tunnel;
        ip_offset += ip_len + sizeof(struct ndpi_udphdr) + 4;  // Skip UDP + CAPWAP header
      }
    }