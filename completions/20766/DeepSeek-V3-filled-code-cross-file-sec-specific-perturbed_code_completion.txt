struct ndpi_udphdr *udp = (struct ndpi_udphdr *)&packet[ip_offset + ip_len];
    u_int16_t sport = ntohs(udp->source), dport = ntohs(udp->dest);
    u_int16_t payload_len = ntohs(udp->len) - sizeof(struct ndpi_udphdr);
    u_int8_t *payload = (u_int8_t *)udp + sizeof(struct ndpi_udphdr);

    /* Check for GTP-U */
    if(dport == GTP_U_V1_PORT) {
      if(payload_len >= sizeof(struct ndpi_gtpv1_header)) {
        struct ndpi_gtpv1_header *gtp = (struct ndpi_gtpv1_header *)payload;
        if((gtp->flags & 0xE0) == 0x30 && gtp->type == GTP_V1_G_PDU) {
          ip_offset += ip_len + sizeof(struct ndpi_udphdr) + sizeof(struct ndpi_gtpv1_header);
          tunnel_type = ndpi_gtp_tunnel;
        }
      }
    }
    /* Check for TZSP */
    else if(sport == TZSP_PORT || dport == TZSP_PORT) {
      if(payload_len >= 2 && payload[0] == 0x01 && payload[1] == 0x00) {
        u_int16_t offset = 2;
        while(offset + 1 < payload_len) {
          u_int8_t tag_type = payload[offset];
          u_int8_t tag_len = payload[offset+1];
          offset += 2 + tag_len;
          if(tag_type == 0x0) { /* Encapsulated ethernet frame */
            ip_offset += ip_len + sizeof(struct ndpi_udphdr) + offset;
            tunnel_type = ndpi_tzsp_tunnel;
            break;
          }
        }
      }
    }
    /* Check for CAPWAP */
    else if(sport == CAPWAP_CONTROL_PORT) {
      if(payload_len >= sizeof(struct ndpi_capwap_header)) {
        struct ndpi_capwap_header *capwap = (struct ndpi_capwap_header *)payload;
        if(ntohs(capwap->type) == CAPWAP_DATA_TYPE) {
          ip_offset += ip_len + sizeof(struct ndpi_udphdr) + sizeof(struct ndpi_capwap_header);
          tunnel_type = ndpi_capwap_tunnel;
        }
      }
    }