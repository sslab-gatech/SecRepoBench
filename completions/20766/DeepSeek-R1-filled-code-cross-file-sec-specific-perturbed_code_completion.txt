struct ndpi_udphdr *udp = (struct ndpi_udphdr*)&packet[ip_offset + ip_len];
    u_int16_t sport = ntohs(udp->source), dport = ntohs(udp->dest);

    if(header->caplen >= ip_offset + ip_len + sizeof(struct ndpi_udphdr)) {
        /* Check for GTP-U */
        if(dport == 2152 && header->caplen >= ip_offset + ip_len + sizeof(struct ndpi_udphdr) + 8) {
            u_int8_t *gtp = (u_int8_t*)(udp + 1);
            if((gtp[0] >> 5) == 1 && gtp[1] == 0xFF) { /* GTPv1-U, T-PDU */
                tunnel_type = ndpi_gtp_tunnel;
                ip_offset += ip_len + sizeof(struct ndpi_udphdr) + 8;
            }
        }
        /* Check for TZSP */
        else if((sport == 6188 || dport == 6188 || sport == 6189 || dport == 6189) &&
                header->caplen >= ip_offset + ip_len + sizeof(struct ndpi_udphdr) + 4) {
            u_int8_t *tzsp = (u_int8_t*)(udp + 1);
            if(tzsp[0] == 1 && ntohs(*(u_int16_t*)&tzsp[2]) == 0x0001) { /* Version 1, Ethernet */
                u_int8_t *ptr = tzsp + 4;
                while(ptr + 2 <= packet + header->caplen) {
                    u_int8_t tag_type = ptr[0];
                    u_int8_t tag_len = ptr[1];
                    ptr += 2 + tag_len;
                    if(ptr > packet + header->caplen) break;
                }
                if(ptr <= packet + header->caplen) {
                    tunnel_type = ndpi_tzsp_tunnel;
                    ip_offset = ptr - packet;
                }
            }
        }
        /* Check for CAPWAP */
        else if((sport == 5246 || sport == 5247) &&
                header->caplen >= ip_offset + ip_len + sizeof(struct ndpi_udphdr) + 8) {
            u_int8_t *capwap = (u_int8_t*)(udp + 1);
            if(capwap[0] == 0xAA && capwap[1] == 0xAA && capwap[2] == 0xBB && capwap[3] == 0xBB &&
               ntohl(*(u_int32_t*)&capwap[4]) == 0x00000000) { /* Data message */
                tunnel_type = ndpi_capwap_tunnel;
                ip_offset += ip_len + sizeof(struct ndpi_udphdr) + 8;
            }
        }
    }