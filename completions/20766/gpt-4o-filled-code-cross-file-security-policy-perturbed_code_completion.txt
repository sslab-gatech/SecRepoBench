struct ndpi_udphdr *udph = (struct ndpi_udphdr *)&packet[ip_offset];
    u_int16_t sport = ntohs(udph->source), dport = ntohs(udph->dest);

    if(header->caplen < ip_offset + sizeof(struct ndpi_udphdr))
      return(ndpiprotocol); /* Too short for UDP header */

    if((sport == 2152) || (dport == 2152)) { /* GTP-U */
      u_int8_t flags = packet[ip_offset + sizeof(struct ndpi_udphdr)];
      u_int8_t message_type = packet[ip_offset + sizeof(struct ndpi_udphdr) + 1];

      if((flags >> 5) == 1 && message_type == 0xFF) { /* GTPv1 and T-PDU */
        ip_offset += sizeof(struct ndpi_udphdr) + 8;
        tunnel_type = ndpi_gtp_tunnel;
      }
    } else if((sport == 3703) || (dport == 3703)) { /* TZSP */
      u_int8_t version = packet[ip_offset + sizeof(struct ndpi_udphdr)];
      u_int8_t type = packet[ip_offset + sizeof(struct ndpi_udphdr) + 1];

      if(version == 1 && type == 0) { /* Ethernet */
        ip_offset += sizeof(struct ndpi_udphdr) + 2;
        while(packet[ip_offset] != 1) { /* End tag */
          ip_offset += packet[ip_offset + 1] + 2;
        }
        ip_offset += 2; /* Skip end tag */
        tunnel_type = ndpi_tzsp_tunnel;
      }
    } else if(sport == 5246) { /* CAPWAP */
      u_int8_t flags = packet[ip_offset + sizeof(struct ndpi_udphdr)];
      u_int8_t message_type = packet[ip_offset + sizeof(struct ndpi_udphdr) + 1];

      if((flags & 0xF) == 0 && message_type == 0) { /* Data packet */
        ip_offset += sizeof(struct ndpi_udphdr) + 8;
        tunnel_type = ndpi_capwap_tunnel;
      }
    }