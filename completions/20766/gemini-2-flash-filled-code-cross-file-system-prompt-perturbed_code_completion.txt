struct ndpi_udphdr *udph = (struct ndpi_udphdr *) &packet[ip_offset + ip_len];
    u_int16_t sport = ntohs(udph->source), dport = ntohs(udph->dest);

    if(sport == 2152 && dport == 2152) {
      /* Check for GTP-U */
      u_int8_t gtp_version = packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr)];
      u_int8_t gtp_message_type = packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr) + 1];

      if((gtp_version >> 5) == 1 && gtp_message_type == 0xFF) {
        /* GTP-U detected */
        tunnel_type = ndpi_gtp_tunnel;
        ip_offset += ip_len + sizeof(struct ndpi_udphdr) + 8; /* GTP-U header size */
      }
    } else if(sport == 37008 && dport == 37008) {
      /* Check for TZSP */
      u_int8_t tzsp_version = packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr)];
      u_int8_t tzsp_encapsulated_protocol = packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr) + 1];

      if(tzsp_version == 1) {
        /* TZSP detected */
        u_int16_t tzsp_header_len = 4;
        while (1) {
          u_int16_t tag_type = ntohs(*((u_int16_t*)&packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr) + tzsp_header_len]));
          u_int16_t tag_length = ntohs(*((u_int16_t*)&packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr) + tzsp_header_len + 2]));

          if (tag_type == 0) break; /* End of tags */

          tzsp_header_len += (tag_length + 4);
          if(tzsp_header_len > 100)
            break;
        }
        ip_offset += ip_len + sizeof(struct ndpi_udphdr) + tzsp_header_len;
        tunnel_type = ndpi_tzsp_tunnel;
        datalink_type = DLT_EN10MB;
        goto datalink_check;
      }
    } else if(sport == 5246) {
      /* Check for CAPWAP */
      u_int8_t capwap_message_type = packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr)];

      if(capwap_message_type == 0x01) {
        /* CAPWAP detected */
        tunnel_type = ndpi_capwap_tunnel;
        ip_offset += ip_len + sizeof(struct ndpi_udphdr) + 8; /* CAPWAP header size */
      }
    }