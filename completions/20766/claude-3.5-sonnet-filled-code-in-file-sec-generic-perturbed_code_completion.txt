struct ndpi_udphdr *udp = (struct ndpi_udphdr *)&packet[ip_offset + ip_len];
u_int16_t sport = ntohs(udp->source), dport = ntohs(udp->dest);

if((sport == GTP_U_V1_PORT) || (dport == GTP_U_V1_PORT)) {
  u_int8_t *gtp_packet = (u_int8_t *)&packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr)];
  u_int8_t gtp_version = (gtp_packet[0] & 0xE0) >> 5;
  u_int8_t gtp_msg_type = gtp_packet[1];

  if((gtp_version == 1) && (gtp_msg_type == 0xFF)) {
    ip_offset += ip_len + sizeof(struct ndpi_udphdr) + 8; /* GTP-U header size */
    tunnel_type = ndpi_gtp_tunnel;
  }
} else if((sport == TZSP_PORT) || (dport == TZSP_PORT)) {
  u_int8_t *tzsp = (u_int8_t *)&packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr)];

  if((tzsp[0] == 1) && (tzsp[1] == 0)) { /* TZSP v1, TYPE_RECEIVED_TAG_LIST */
    u_int8_t *end_ptr = (u_int8_t *)&packet[header->caplen - 1];
    u_int8_t *tag_ptr = &tzsp[4];

    while(tag_ptr < end_ptr) {
      if(*tag_ptr == 0) {
        tag_ptr = &tag_ptr[1]; /* Skip padding */
        continue;
      } else if(*tag_ptr == 1) {
        /* End of tag list */
        ip_offset = (tag_ptr - packet) + 1; /* Point to the encapsulated Ethernet frame */
        tunnel_type = ndpi_tzsp_tunnel;
        break;
      }
      tag_ptr = &tag_ptr[tag_ptr[1] + 2];
    }
  }
} else if(sport == NDPI_CAPWAP_DATA_PORT) {
  u_int8_t *capwap = (u_int8_t *)&packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr)];
  u_int8_t capwap_type = (capwap[0] & 0xF0) >> 4;

  if(capwap_type == 0) { /* CAPWAP Data Packet */
    ip_offset += ip_len + sizeof(struct ndpi_udphdr) + 8; /* CAPWAP header size */
    tunnel_type = ndpi_capwap_tunnel;
  }
}