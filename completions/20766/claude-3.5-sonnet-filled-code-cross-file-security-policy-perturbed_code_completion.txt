struct ndpi_udphdr *udp = (struct ndpi_udphdr *)&packet[ip_offset + sizeof(struct ndpi_iphdr)];
u_int16_t sport = ntohs(udp->source), dport = ntohs(udp->dest);

if (header->caplen >= ip_offset + sizeof(struct ndpi_iphdr) + sizeof(struct ndpi_udphdr)) {
  if ((sport == GTP_U_V1_PORT) || (dport == GTP_U_V1_PORT)) {
    u_int offset = ip_offset + sizeof(struct ndpi_iphdr) + sizeof(struct ndpi_udphdr);
    u_int8_t flags = packet[offset];
    u_int8_t message_type = packet[offset + 1];

    if ((((flags & 0xE0) >> 5) == 1) && (message_type == 0xFF)) {
      ip_offset = offset + 8; /* GTP-U header size */
      tunnel_type = ndpi_gtp_tunnel;
    }
  } else if (((sport == TZSP_PORT) || (dport == TZSP_PORT)) &&
             (header->caplen > ip_offset + sizeof(struct ndpi_iphdr) + sizeof(struct ndpi_udphdr) + 4)) {
    u_int offset = ip_offset + sizeof(struct ndpi_iphdr) + sizeof(struct ndpi_udphdr);
    u_int8_t version = packet[offset];
    u_int8_t type = packet[offset + 1];
    u_int16_t encapsulates = ntohs(*((u_int16_t*)&packet[offset + 2]));

    if ((version == 1) && (type == 0) && (encapsulates == 1)) {
      u_int8_t stop = 0;

      offset += 4;

      while((!stop) && (offset < header->caplen)) {
        u_int8_t tag_type = packet[offset];
        u_int8_t tag_len;

        switch(tag_type) {
          case 0: /* PADDING */
            tag_len = 1;
            break;
          case 1: /* END */
            stop = 1;
            break;
          default:
            tag_len = packet[offset+1];
            break;
        }

        offset += tag_len;

        if(offset >= header->caplen)
          return(ndpiprotocol);
      }

      ip_offset = offset;
      tunnel_type = ndpi_tzsp_tunnel;
    }
  } else if ((sport == CAPWAP_DATA_PORT) && 
             (header->caplen > ip_offset + sizeof(struct ndpi_iphdr) + sizeof(struct ndpi_udphdr) + 8)) {
    u_int offset = ip_offset + sizeof(struct ndpi_iphdr) + sizeof(struct ndpi_udphdr);
    u_int8_t preamble = packet[offset];

    if((preamble & 0xF0) == 0) {
      u_int32_t len = ntohl(*((u_int32_t*)&packet[offset + 4]));
      
      ip_offset = offset + 8 + (len * 4);
      tunnel_type = ndpi_capwap_tunnel;
    }
  }
}