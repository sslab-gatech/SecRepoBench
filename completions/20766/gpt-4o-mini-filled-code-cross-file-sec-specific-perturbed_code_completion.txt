// Check for GTP-U protocol
    uint16_t src_port = ntohs(((struct ndpi_udphdr *)(packet + ip_offset))->source);
    uint16_t dst_port = ntohs(((struct ndpi_udphdr *)(packet + ip_offset))->dest);
    
    if ((src_port == 2123 || dst_port == 2123) && (header->caplen >= ip_offset + sizeof(struct ndpi_udphdr))) {
        // Verify GTP version and message type
        uint8_t *gtp_header = packet + ip_offset + sizeof(struct ndpi_udphdr);
        if (gtp_header[0] & 0xC0 == 0x20) { // Check GTP version
            tunnel_type = ndpi_gtp_tunnel;
            ip_offset += sizeof(struct ndpi_udphdr) + 8; // Move past UDP and GTP headers
        }
    }

    // Check for TZSP protocol
    if ((src_port == 37008 || dst_port == 37008) && (header->caplen >= ip_offset + sizeof(struct ndpi_tzsp_header))) {
        // Verify TZSP version and encapsulated protocol
        struct ndpi_tzsp_header *tzsp_header = (struct ndpi_tzsp_header *)(packet + ip_offset);
        if (tzsp_header->version == 1) {
            tunnel_type = ndpi_tzsp_tunnel;
            ip_offset += sizeof(struct ndpi_tzsp_header); // Move past TZSP header
        }
    }

    // Check for CAPWAP protocol
    if ((src_port == 5246 || dst_port == 5246) && (header->caplen >= ip_offset + sizeof(struct ndpi_capwap_header))) {
        struct ndpi_capwap_header *capwap_header = (struct ndpi_capwap_header *)(packet + ip_offset);
        if (capwap_header->version == 1) {
            tunnel_type = ndpi_capwap_tunnel;
            ip_offset += sizeof(struct ndpi_capwap_header); // Move past CAPWAP header
        }
    }