{
  #define GTPU_PORT 2152
  #define TZSP_PORT 37008
  #define CAPWAP_PORT_CONTROL 5246
  #define CAPWAP_PORT_DATA 5247

  /* Parse UDP header */
  u_int16_t udp_offset = ip_offset + ip_len;
  if(header->caplen < udp_offset + sizeof(struct ndpi_udphdr))
    return(ndpiprotocol); /* Too short for UDP header */

  struct ndpi_udphdr *udph = (struct ndpi_udphdr *)&packet[udp_offset];
  u_int16_t sport = ntohs(udph->source);
  u_int16_t dport = ntohs(udph->dest);

  /* GTP-U detection */
  if(sport == GTPU_PORT || dport == GTPU_PORT) {
    if(header->caplen >= (udp_offset + sizeof(struct ndpi_udphdr) + 8)) {
      const u_int8_t *gtp = &packet[udp_offset + sizeof(struct ndpi_udphdr)];
      u_int8_t flags = gtp[0], msg_type = gtp[1];
      /* Check GTP version == 1 and G-PDU message type (0xFF) */
      if(((flags & 0xe0) >> 5) == 1 && (msg_type == 0xff)) {
        tunnel_type = ndpi_gtp_tunnel;
        ip_offset = udp_offset + sizeof(struct ndpi_udphdr) + 8;
        goto iph_check;
      }
    }
  }

  /* TZSP detection */
  if(dport == TZSP_PORT) {
    /* Check minimum TZSP header */
    if(header->caplen >= (udp_offset + sizeof(struct ndpi_udphdr) + 4)) {
      const u_int8_t *tzsp = &packet[udp_offset + sizeof(struct ndpi_udphdr)];
      /* TZSP version (1) and type (0 => received Ethernet) */
      if(tzsp[0] == 1 && tzsp[1] == 0) {
        u_int16_t tzsp_offset = 2;
        /* Skip TZSP tags */
        while(header->caplen >= (udp_offset + sizeof(struct ndpi_udphdr) + tzsp_offset + 2)) {
          u_int8_t tag_type = tzsp[tzsp_offset];
          u_int8_t tag_len = tzsp[tzsp_offset + 1];
          tzsp_offset += 2;
          if(tag_type == 1 /* end tag */) break;
          tzsp_offset += tag_len;
        }
        /* Encapsulated Ethernet frame */
        tunnel_type = ndpi_tzsp_tunnel;
        ip_offset = udp_offset + sizeof(struct ndpi_udphdr) + tzsp_offset;
        datalink_type = DLT_EN10MB;
        eth_offset = ip_offset;
        goto datalink_check;
      }
    }
  }

  /* CAPWAP detection */
  if(sport == CAPWAP_PORT_CONTROL || sport == CAPWAP_PORT_DATA ||
     dport == CAPWAP_PORT_CONTROL || dport == CAPWAP_PORT_DATA) {
    if(header->caplen >= (udp_offset + sizeof(struct ndpi_udphdr) + 8)) {
      const u_int8_t *capwap = &packet[udp_offset + sizeof(struct ndpi_udphdr)];
      /* Basic check for CAPWAP version 0 and data/control bits */
      if(((capwap[0] & 0xf0) == 0) && (capwap[1] & 0x01)) {
        tunnel_type = ndpi_capwap_tunnel;
        ip_offset = udp_offset + sizeof(struct ndpi_udphdr) + 8;
        goto iph_check;
      }
    }
  }
}