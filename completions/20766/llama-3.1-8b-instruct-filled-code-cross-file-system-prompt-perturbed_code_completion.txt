if(workflow->prefs.decode_tunnels && (proto == IPPROTO_UDP)) {
  // Parse the UDP header from the packet using the current IP offset.
  // Extract source and destination ports to identify potential tunnel protocols.
  // Check for GTP-U protocol by comparing ports, then verify GTP version and message type.
  // If GTP-U is detected, update IP offset to point to the encapsulated IP header.
  // Set the tunnel type to ndpi_gtp_tunnel for GTP-U packets.
  // Check for TZSP protocol using ports, then verify TZSP version and encapsulated protocol.
  // If TZSP is detected, navigate through its tags until reaching the encapsulated Ethernet frame.
  // Set the tunnel type to ndpi_tzsp_tunnel for TZSP packets.
  // Check for CAPWAP protocol using source port, then verify CAPWAP message type.
  // If CAPWAP is detected, update IP offset to point to the encapsulated IP header.
  // Set the tunnel type to ndpi_capwap_tunnel for CAPWAP packets.
  // The tunnel type and updated IP offset are used for further packet processing.
  if(is_ndpi_proto(&workflow->stats.protocol_counter, IPPROTO_GTP)) {
    // GTP-U protocol detected
    struct ndpi_gtp_header *gtp = (struct ndpi_gtp_header *) &packet[ip_offset];
    if(ntohs(gtp->version) == 1 && ntohs(gtp->message_type) == 1) {
      // GTP-U version 1, message type 1 (request)
      tunnel_type = ndpi_gtp_tunnel;
      ip_offset += sizeof(struct ndpi_gtp_header);
    }
  } else if(is_ndpi_proto(&workflow->stats.protocol_counter, IPPROTO_TZSP)) {
    // TZSP protocol detected
    struct ndpi_tzsp_header *tzsp = (struct ndpi_tzsp_header *) &packet[ip_offset];
    if(ntohs(tzsp->version) == 1 && ntohs(tzsp->encapsulated_protocol) == ETH_P_IP) {
      // TZSP version 1, encapsulated protocol is IPv4
      tunnel_type = ndpi_tzsp_tunnel;
      ip_offset += sizeof(struct ndpi_tzsp_header);
    }
  } else if(is_ndpi_proto(&workflow->stats.protocol_counter, IPPROTO_CAPWAP)) {
    // CAPWAP protocol detected
    struct ndpi_capwap_header *capwap = (struct ndpi_capwap_header *) &packet[ip_offset];
    if(ntohs(capwap->message_type) == 1) {
      // CAPWAP message type 1 (request)
      tunnel_type = ndpi_capwap_tunnel;
      ip_offset += sizeof(struct ndpi_capwap_header);
    }
  }
}