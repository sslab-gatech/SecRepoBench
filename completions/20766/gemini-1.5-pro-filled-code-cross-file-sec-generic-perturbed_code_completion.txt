struct ndpi_udphdr *udph = NULL;
    u_int16_t sport = 0, dport = 0;

    udph = (struct ndpi_udphdr *) &packet[ip_offset + ip_len];
    sport = ntohs(udph->source), dport = ntohs(udph->dest);

    if (sport == GTP_U_PORT || dport == GTP_U_PORT) {
      // Check for GTP-U protocol
      u_int8_t message_type = packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr)];

      if ((message_type == GTP_G_PDU || message_type == GTP_T_PDU) && packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr)+1] == 1) {
          ip_offset += ip_len + 8;
          tunnel_type = ndpi_gtp_tunnel;
          goto iph_check;
      }
    } else if(sport == TZSP_PORT || dport == TZSP_PORT) {
      // Check for TZSP protocol
      u_int8_t tzsp_version = packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr)];
      u_int8_t tzsp_encap_proto = packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr) + 1];

      if(tzsp_version == 1 && tzsp_encap_proto == 0) {
        u_int16_t tzsp_offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr) + 2;
        u_int16_t tzsp_tag_len;

        while(tzsp_offset + 4 < header->caplen) {
          tzsp_tag_len = ntohs(*(u_int16_t*)&packet[tzsp_offset + 2]);

          if(tzsp_tag_len == 0)
            break;

          if(*(u_int16_t*)&packet[tzsp_offset] == 0) {
            // Ethernet frame found
            eth_offset = tzsp_offset + 4;
            tunnel_type = ndpi_tzsp_tunnel;
            datalink_type = DLT_EN10MB;
            goto datalink_check;
          }

          tzsp_offset += 4 + tzsp_tag_len;
        }
      }
    } else if (sport == CAPWAP_CONTROL_PORT) {
      // Check for CAPWAP protocol
      u_int8_t capwap_message_type = packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr) + 1];
      if (capwap_message_type == CAPWAP_DATA_MESSAGE) {
        ip_offset += ip_len + 8;
        tunnel_type = ndpi_capwap_tunnel;
        goto iph_check;
      }
    }