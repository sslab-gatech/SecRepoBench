struct ndpi_udphdr *udph = (struct ndpi_udphdr *)&packet[ip_offset];
    u_int16_t sport = ntohs(udph->source), dport = ntohs(udph->dest);

    if((sport == 2152) || (dport == 2152)) { // GTP-U
      if(header->caplen >= ip_offset + 8) {
        u_int8_t flags = packet[ip_offset + 8];
        if((flags >> 5) == 1) { // GTP version 1
          ip_offset += 12; // Skip GTP header
          tunnel_type = ndpi_gtp_tunnel;
        }
      }
    } else if((sport == 3703) || (dport == 3703)) { // TZSP
      if(header->caplen >= ip_offset + 8) {
        u_int8_t version = packet[ip_offset + 8];
        if(version == 1) { // TZSP version 1
          ip_offset += 8; // Skip TZSP header
          while(packet[ip_offset] != 1 && ip_offset < header->caplen) { // End tag
            ip_offset += packet[ip_offset + 1] + 2; // Skip tag
          }
          ip_offset += 2; // Skip end tag
          tunnel_type = ndpi_tzsp_tunnel;
        }
      }
    } else if(sport == 5246) { // CAPWAP
      if(header->caplen >= ip_offset + 8) {
        u_int8_t flags = packet[ip_offset + 8];
        if((flags & 0xF0) == 0x00) { // CAPWAP control message
          ip_offset += 8; // Skip CAPWAP header
          tunnel_type = ndpi_capwap_tunnel;
        }
      }
    }