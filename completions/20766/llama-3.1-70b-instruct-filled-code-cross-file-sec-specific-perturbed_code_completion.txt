// Parse the UDP header from the packet using the current IP offset.
struct ndpi_udphdr *udph = (struct ndpi_udphdr *)&packet[ip_offset];

// Extract source and destination ports to identify potential tunnel protocols.
u_int16_t src_port = ntohs(udph->source);
u_int16_t dst_port = ntohs(udph->dest);

// Check for GTP-U protocol by comparing ports, then verify GTP version and message type.
if (src_port == 2152 || dst_port == 2152) {
  // GTP-U header is 8 bytes long, followed by a 1-byte message type and a 1-byte length.
  if (header->caplen >= ip_offset + sizeof(struct ndpi_udphdr) + 10) {
    u_int8_t *gtpu_header = (u_int8_t *)&packet[ip_offset + sizeof(struct ndpi_udphdr)];
    if (gtpu_header[0] == 0xFF && gtpu_header[1] == 0x01) { // GTP version 1
      tunnel_type = ndpi_gtp_tunnel;
      ip_offset += sizeof(struct ndpi_udphdr) + 10;
    }
  }
}

// Check for TZSP protocol using ports, then verify TZSP version and encapsulated protocol.
if (src_port == 37008 || dst_port == 37008) {
  // TZSP header is 4 bytes long, followed by a 1-byte version and a 1-byte encapsulated protocol.
  if (header->caplen >= ip_offset + sizeof(struct ndpi_udphdr) + 6) {
    u_int8_t *tzsp_header = (u_int8_t *)&packet[ip_offset + sizeof(struct ndpi_udphdr)];
    if (tzsp_header[0] == 0x01 && tzsp_header[1] == 0x00) { // TZSP version 1
      tunnel_type = ndpi_tzsp_tunnel;
      ip_offset += sizeof(struct ndpi_udphdr) + 6;
      // Navigate through TZSP tags until reaching the encapsulated Ethernet frame.
      while (header->caplen >= ip_offset + 2) {
        u_int16_t tag_len = ntohs(*(u_int16_t *)&packet[ip_offset]);
        ip_offset += 2 + tag_len;
      }
    }
  }
}

// Check for CAPWAP protocol using source port, then verify CAPWAP message type.
if (src_port == 5246) {
  // CAPWAP header is 4 bytes long, followed by a 1-byte message type and a 1-byte flags.
  if (header->caplen >= ip_offset + sizeof(struct ndpi_udphdr) + 6) {
    u_int8_t *capwap_header = (u_int8_t *)&packet[ip_offset + sizeof(struct ndpi_udphdr)];
    if (capwap_header[0] == 0x01 && capwap_header[1] == 0x00) { // CAPWAP message type 1
      tunnel_type = ndpi_capwap_tunnel;
      ip_offset += sizeof(struct ndpi_udphdr) + 6;
    }
  }
}