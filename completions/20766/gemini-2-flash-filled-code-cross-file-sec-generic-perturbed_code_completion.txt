struct ndpi_udphdr *udph = (struct ndpi_udphdr *) &packet[ip_offset + ip_len];
    u_int16_t sport = ntohs(udph->source), dport = ntohs(udph->dest);

    if(dport == 2152 && header->caplen >= ip_offset + ip_len + 8) {
      /* GTP-U */
      u_int8_t gtp_version = packet[ip_offset + ip_len + 0] >> 5;
      u_int8_t gtp_message_type = packet[ip_offset + ip_len + 1];

      if(gtp_version == 1 && gtp_message_type == 0xFF) {
        tunnel_type = ndpi_gtp_tunnel;
        ip_offset += ip_len + 8; /* Skip UDP and GTP headers */
      }
    } else if((sport == 37008 || dport == 37008) && header->caplen >= ip_offset + ip_len + 4) {
      /* TZSP */
      u_int8_t tzsp_version = packet[ip_offset + ip_len + 0];
      u_int8_t tzsp_encapsulated_protocol = packet[ip_offset + ip_len + 1];

      if(tzsp_version == 1 && tzsp_encapsulated_protocol == 0) {
        /* TZSP Ethernet Frame */
        u_int16_t tzsp_length = (packet[ip_offset + ip_len + 2] << 8) | packet[ip_offset + ip_len + 3];
        u_int16_t tag_type, tag_length, offset = ip_offset + ip_len + 4;

        tunnel_type = ndpi_tzsp_tunnel;

        while (offset < ip_offset + ip_len + tzsp_length) {
          if (offset + 4 > header->caplen) break;
          tag_type = (packet[offset] << 8) | packet[offset + 1];
          tag_length = (packet[offset + 2] << 8) | packet[offset + 3];

          if (tag_type == 0) {
            offset += 4;
          } else {
            offset += 4 + tag_length;
          }

          if (tag_type == 1) {
            ip_offset = offset;
            break;
          }
        }
      }
    } else if(sport == 5246 && header->caplen >= ip_offset + ip_len + 4) {
      /* CAPWAP */
      u_int8_t capwap_header_type = packet[ip_offset + ip_len + 0] >> 7;

      if(capwap_header_type == 0) {
        tunnel_type = ndpi_capwap_tunnel;
        ip_offset += ip_len + 8; /* Skip UDP and CAPWAP headers */
      }
    }