if (header->caplen < ip_offset + sizeof(struct ndpi_udphdr))
      return(ndpiprotocol); /* Too short for UDP header */

    struct ndpi_udphdr *udph = (struct ndpi_udphdr *)&packet[ip_offset];
    u_int16_t src_port = ntohs(udph->source);
    u_int16_t dst_port = ntohs(udph->dest);

    // Check for GTP-U protocol
    if ((src_port == 2123 || dst_port == 2123) || (src_port == 2152 || dst_port == 2152)) {
      // Verify GTP version and message type
      if (header->caplen >= ip_offset + sizeof(struct ndpi_udphdr) + 1) {
        u_int8_t gtp_version = (packet[ip_offset + sizeof(struct ndpi_udphdr)] & 0xE0) >> 5;
        if (gtp_version == 1) {
          // Update IP offset to point to the encapsulated IP header
          ip_offset += sizeof(struct ndpi_udphdr) + 1; // Skip GTP header
          tunnel_type = ndpi_gtp_tunnel;
        }
      }
    }

    // Check for TZSP protocol
    if ((src_port == 37008 || dst_port == 37008)) {
      // Verify TZSP version and encapsulated protocol
      if (header->caplen >= ip_offset + 4) {
        u_int8_t tzsp_version = packet[ip_offset + 3];
        if (tzsp_version == 1) {
          // Navigate through TZSP tags to reach encapsulated Ethernet frame
          ip_offset += 4; // Skip TZSP header
          tunnel_type = ndpi_tzsp_tunnel;
        }
      }
    }

    // Check for CAPWAP protocol
    if ((src_port == 5246 || dst_port == 5246) || (src_port == 5247 || dst_port == 5247)) {
      // Verify CAPWAP message type
      if (header->caplen >= ip_offset + sizeof(struct ndpi_udphdr) + 4) {
        // Update IP offset to point to the encapsulated IP header
        ip_offset += sizeof(struct ndpi_udphdr) + 4; // Skip CAPWAP header
        tunnel_type = ndpi_capwap_tunnel;
      }
    }