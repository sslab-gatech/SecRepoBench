struct ndpi_tcphdr *tcph = NULL;
    struct ndpi_udphdr *udph = NULL;
    u_int16_t sport = 0, dport = 0;
    u_int8_t udp_payload[header->caplen - ip_offset];
    size_t udp_payload_len = sizeof(udp_payload);

    if (header->caplen < ip_offset + sizeof(struct ndpi_udphdr))
      return(ndpiprotocol);

    udph = (struct ndpi_udphdr *)&packet[ip_offset];

    sport = ntohs(udph->source);
    dport = ntohs(udph->dest);

    if (sport == GTPU_PORT || dport == GTPU_PORT) {
      /* GTP-U protocol check */
      if (header->caplen >= ip_offset + sizeof(struct ndpi_udphdr) + 1) {
        u_int8_t gtp_version = packet[ip_offset + sizeof(struct ndpi_udphdr)];
        if ((gtp_version & 0xE0) >> 5 == 1) { // GTP version 1
          if (packet[ip_offset + sizeof(struct ndpi_udphdr) + 1] == 0x01) { // GTP Echo Request
            ip_offset += sizeof(struct ndpi_udphdr) + 8; // Skip UDP header and GTP header
            tunnel_type = ndpi_gtp_tunnel;
          }
        }
      }
    } else if (sport == TZSP_PORT || dport == TZSP_PORT) {
      /* TZSP protocol check */
      if (header->caplen >= ip_offset + sizeof(struct ndpi_udphdr) + 4) {
        u_int32_t tzsp_id = ntohl(*((u_int32_t *)&packet[ip_offset + sizeof(struct ndpi_udphdr)]));
        if (tzsp_id == TZSP_ID) {
          u_int8_t *tag = &packet[ip_offset + sizeof(struct ndpi_udphdr) + 4];
          while (ip_offset + tag - &packet[0] < header->caplen && *tag != 0x00) {
            if (*tag == 0x02 && tag[1] >= 2) { // Encapsulated Ethernet frame
              ip_offset += sizeof(struct ndpi_udphdr) + 4 + tag[1]; // Skip UDP header, TZSP ID, and tags
              tunnel_type = ndpi_tzsp_tunnel;
              break;
            }
            tag += 2 + tag[1];
          }
        }
      }
    } else if (sport == CAPWAP_PORT || dport == CAPWAP_PORT) {
      /* CAPWAP protocol check */
      if (header->caplen >= ip_offset + sizeof(struct ndpi_udphdr) + 4) {
        u_int32_t capwap_message_type = ntohl(*((u_int32_t *)&packet[ip_offset + sizeof(struct ndpi_udphdr)]));
        if (capwap_message_type == CAPWAP_DATA_MESSAGE) {
          ip_offset += sizeof(struct ndpi_udphdr) + 8; // Skip UDP header and CAPWAP header
          tunnel_type = ndpi_capwap_tunnel;
        }
      }
    }

    if (tunnel_type != ndpi_no_tunnel) {
      if (header->caplen > ip_offset + udp_payload_len) {
        udp_payload_len = header->caplen - ip_offset;
      }
      memcpy(udp_payload, &packet[ip_offset], udp_payload_len);
      ip_offset += udp_payload_len;
    }