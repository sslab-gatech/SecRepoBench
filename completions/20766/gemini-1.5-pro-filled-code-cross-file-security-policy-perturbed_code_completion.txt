struct ndpi_udphdr *udph = NULL;
    u_int16_t sport = 0, dport = 0;

    if (header->caplen >= ip_offset + sizeof(struct ndpi_udphdr)) {
      udph = (struct ndpi_udphdr *) &packet[ip_offset];
      sport = ntohs(udph->source), dport = ntohs(udph->dest);

      if(workflow->prefs.tunnel_classification_enabled == 1) {
          if(sport == GTP_U_PORT || dport == GTP_U_PORT) {
              // Check for GTP packets
              u_int8_t message_type = 0;
              u_int8_t gtp_version = 0;
              if (header->caplen >= ip_offset + sizeof(struct ndpi_gtp_hdr)) {
                  struct ndpi_gtp_hdr *gtph = (struct ndpi_gtp_hdr *) &packet[ip_offset];
                  message_type = gtph->message_type;
                  gtp_version = gtph->version;
              }
              if (gtp_version == 1 && message_type == GTP_G_PDU) {
                  ip_offset += sizeof(struct ndpi_gtp_hdr);
                  tunnel_type = ndpi_gtp_tunnel;
                  goto iph_check;
              }
          } else if (sport == TZSP_PORT || dport == TZSP_PORT) {
              if (header->caplen >= ip_offset + sizeof(struct ndpi_tzsp_hdr)) {
                  struct ndpi_tzsp_hdr *tzsp = (struct ndpi_tzsp_hdr *) &packet[ip_offset];
                  if (tzsp->version == 0) {
                      u_int16_t tzsp_len = ntohs(tzsp->len);
                      if (header->caplen >= ip_offset + tzsp_len) {
                          ip_offset += tzsp_len;
                          tunnel_type = ndpi_tzsp_tunnel;
                          datalink_type = DLT_EN10MB;
                          eth_offset = ip_offset;
                          goto datalink_check;
                      }
                  }
              }
          } else if (sport == CAPWAP_CONTROL_PORT) {
              if (header->caplen >= ip_offset + sizeof(struct ndpi_capwap_hdr)) {
                  struct ndpi_capwap_hdr *capwap = (struct ndpi_capwap_hdr *) &packet[ip_offset];
                  if ((capwap->version == 1 || capwap->version == 2) &&
                      capwap->message_type == CAPWAP_DATA) {
                      ip_offset += sizeof(struct ndpi_capwap_hdr);
                      tunnel_type = ndpi_capwap_tunnel;
                      goto iph_check;
                  }
              }
          }
      }
    }