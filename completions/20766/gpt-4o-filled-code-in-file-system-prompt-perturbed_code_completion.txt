struct ndpi_udphdr *udph = (struct ndpi_udphdr *)&packet[ip_offset];
    u_int16_t sport = ntohs(udph->source), dport = ntohs(udph->dest);

    if((sport == GTP_U_V1_PORT) || (dport == GTP_U_V1_PORT)) {
      struct ndpi_gtpv1_hdr *gtp = (struct ndpi_gtpv1_hdr *)&packet[ip_offset+sizeof(struct ndpi_udphdr)];

      if(gtp->v_pt_rsv_flags == 0x30) {
        ip_offset += sizeof(struct ndpi_udphdr) + 8;
        tunnel_type = ndpi_gtp_tunnel;
        goto iph_check;
      }
    } else if((sport == TZSP_PORT) || (dport == TZSP_PORT)) {
      struct ndpi_tzsp_header *tzsp = (struct ndpi_tzsp_header *)&packet[ip_offset+sizeof(struct ndpi_udphdr)];

      if(tzsp->version == 1 && tzsp->type == 0) {
        u_int8_t *tag = (u_int8_t *)&packet[ip_offset+sizeof(struct ndpi_udphdr)+sizeof(struct ndpi_tzsp_header)];

        while(*tag != 1) {
          tag += tag[1] + 2;
        }

        ip_offset = (tag - packet) + 2;
        tunnel_type = ndpi_tzsp_tunnel;
        goto datalink_check;
      }
    } else if(sport == NDPI_CAPWAP_DATA_PORT) {
      struct ndpi_capwap_hdr *capwap = (struct ndpi_capwap_hdr *)&packet[ip_offset+sizeof(struct ndpi_udphdr)];

      if(capwap->version == 0 && capwap->type == 0) {
        ip_offset += sizeof(struct ndpi_udphdr) + sizeof(struct ndpi_capwap_hdr);
        tunnel_type = ndpi_capwap_tunnel;
        goto iph_check;
      }
    }