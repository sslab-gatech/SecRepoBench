struct ndpi_udphdr *udp = (struct ndpi_udphdr *)&packet[ip_offset];
    u_int16_t sport = ntohs(udp->source), dport = ntohs(udp->dest);

    if((sport == GTP_U_V1_PORT) || (dport == GTP_U_V1_PORT)) {
      if((header->caplen - ip_offset) < 8)
        return(ndpiprotocol);

      if((packet[ip_offset+8] >> 4) == 1 /* GTP v1 */
         && packet[ip_offset+1] == 0xFF /* G-PDU */) {
        ip_offset += 8 + ((packet[ip_offset] & 0x07) ? 4 : 0);
        tunnel_type = ndpi_gtp_tunnel;
      }
    } else if((sport == TZSP_PORT) || (dport == TZSP_PORT)) {
      if((header->caplen - ip_offset) < 2)
        return(ndpiprotocol);

      if(packet[ip_offset] == 1 /* Version */
         && packet[ip_offset+1] == 0 /* Ethernet */) {
        ip_offset += 2;

        while(packet[ip_offset] != 1 /* End */) {
          if(packet[ip_offset] == 0) /* Padding */
            ip_offset++;
          else
            ip_offset += packet[ip_offset+1] + 2;
        }

        ip_offset++;
        tunnel_type = ndpi_tzsp_tunnel;
      }
    } else if(sport == NDPI_CAPWAP_DATA_PORT) {
      if((header->caplen - ip_offset) < 8)
        return(ndpiprotocol);

      if((packet[ip_offset] & 0xF0) == 0x00 /* CAPWAP */) {
        ip_offset += 8;
        tunnel_type = ndpi_capwap_tunnel;
      }
    }