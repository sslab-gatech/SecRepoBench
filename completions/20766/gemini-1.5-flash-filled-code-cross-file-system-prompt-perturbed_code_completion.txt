struct ndpi_udphdr *udp_header = (struct ndpi_udphdr *) &packet[ip_offset];
    u_int16_t source_port = ntohs(udp_header->source);
    u_int16_t dest_port = ntohs(udp_header->dest);

    if (source_port == GTPU_PORT || dest_port == GTPU_PORT) {
      // Check GTP-U
      if (is_gtpu(packet + ip_offset + sizeof(struct ndpi_udphdr), header->caplen - ip_offset - sizeof(struct ndpi_udphdr))) {
        ip_offset += sizeof(struct ndpi_udphdr) + 8;
        tunnel_type = ndpi_gtp_tunnel;
      }
    } else if (source_port == TZSP_PORT || dest_port == TZSP_PORT) {
      // Check TZSP
      if (is_tzsp(packet + ip_offset + sizeof(struct ndpi_udphdr), header->caplen - ip_offset - sizeof(struct ndpi_udphdr))) {
        ip_offset = tzsp_get_ip_offset(packet + ip_offset + sizeof(struct ndpi_udphdr), header->caplen - ip_offset - sizeof(struct ndpi_udphdr));
        tunnel_type = ndpi_tzsp_tunnel;
      }
    } else if (source_port == CAPWAP_PORT) {
      // Check CAPWAP
      if (is_capwap(packet + ip_offset + sizeof(struct ndpi_udphdr), header->caplen - ip_offset - sizeof(struct ndpi_udphdr))) {
        ip_offset += sizeof(struct ndpi_udphdr) + 4;
        tunnel_type = ndpi_capwap_tunnel;
      }
    }