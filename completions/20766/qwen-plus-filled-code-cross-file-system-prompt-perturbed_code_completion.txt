if (iph != NULL) { // IPv4 case
  struct ndpi_udphdr *udph = (struct ndpi_udphdr *) ((u_int8_t *) iph + (((iph->ihl) * 4)));
  u_int16_t sport = ntohs(udph->source);
  u_int16_t dport = ntohs(udph->dest);

  if ((sport == GTP_U_PORT || dport == GTP_U_PORT)) {
    u_int8_t *gtp_header = (u_int8_t *) udph + sizeof(struct ndpi_udphdr);
    if ((*gtp_header & 0x1F) == 0x10 && (*(gtp_header + 1) & 0x3) == 0x0) {
      ip_offset += sizeof(struct ndpi_udphdr) + 8; // Skip UDP header and GTP-U header
      tunnel_type = ndpi_gtp_tunnel;
    }
  } else if ((sport == TZSP_PORT || dport == TZSP_PORT)) {
    u_int8_t *tzsp_header = (u_int8_t *) udph + sizeof(struct ndpi_udphdr);
    if (*tzsp_header == TZSP_VERSION) {
      // Navigate through TZSP tags until reaching the encapsulated Ethernet frame
      u_int8_t *current = tzsp_header + 1;
      while ((current - (u_int8_t *) packet) < header->caplen) {
        u_int8_t tag_id = *current++;
        u_int16_t tag_length = (*current++ << 8) | *current++;
        if (tag_id == TZSP_TAG_ETHERNET2) {
          eth_offset = current - packet;
          break;
        }
        current += tag_length;
      }
      tunnel_type = ndpi_tzsp_tunnel;
    }
  } else if (sport == CAPWAP_PORT) {
    u_int8_t *capwap_header = (u_int8_t *) udph + sizeof(struct ndpi_udphdr);
    if (((*capwap_header >> 4) & 0xF) == CAPWAP_VERSION) {
      u_int8_t message_type = *(capwap_header + 1);
      if (message_type == CAPWAP_DATA_MESSAGE) {
        ip_offset += sizeof(struct ndpi_udphdr) + (*capwap_header & 0xF) * 4; // Skip UDP header and CAPWAP header
        tunnel_type = ndpi_capwap_tunnel;
      }
    }
  }
} else if (iph6 != NULL) { // IPv6 case
  struct ndpi_udphdr *udph = (struct ndpi_udphdr *) ((u_int8_t *) iph6 + ip_len);
  u_int16_t sport = ntohs(udph->source);
  u_int16_t dport = ntohs(udph->dest);

  if ((sport == GTP_U_PORT || dport == GTP_U_PORT)) {
    u_int8_t *gtp_header = (u_int8_t *) udph + sizeof(struct ndpi_udphdr);
    if ((*gtp_header & 0x1F) == 0x10 && (*(gtp_header + 1) & 0x3) == 0x0) {
      ip_offset += sizeof(struct ndpi_udphdr) + 8; // Skip UDP header and GTP-U header
      tunnel_type = ndpi_gtp_tunnel;
    }
  } else if ((sport == TZSP_PORT || dport == TZSP_PORT)) {
    u_int8_t *tzsp_header = (u_int8_t *) udph + sizeof(struct ndpi_udphdr);
    if (*tzsp_header == TZSP_VERSION) {
      // Navigate through TZSP tags until reaching the encapsulated Ethernet frame
      u_int8_t *current = tzsp_header + 1;
      while ((current - (u_int8_t *) packet) < header->caplen) {
        u_int8_t tag_id = *current++;
        u_int16_t tag_length = (*current++ << 8) | *current++;
        if (tag_id == TZSP_TAG_ETHERNET2) {
          eth_offset = current - packet;
          break;
        }
        current += tag_length;
      }
      tunnel_type = ndpi_tzsp_tunnel;
    }
  } else if (sport == CAPWAP_PORT) {
    u_int8_t *capwap_header = (u_int8_t *) udph + sizeof(struct ndpi_udphdr);
    if (((*capwap_header >> 4) & 0xF) == CAPWAP_VERSION) {
      u_int8_t message_type = *(capwap_header + 1);
      if (message_type == CAPWAP_DATA_MESSAGE) {
        ip_offset += sizeof(struct ndpi_udphdr) + (*capwap_header & 0xF) * 4; // Skip UDP header and CAPWAP header
        tunnel_type = ndpi_capwap_tunnel;
      }
    }
  }
}