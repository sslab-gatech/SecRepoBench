struct ndpi_udphdr *udp = (struct ndpi_udphdr *)&packet[ip_offset + sizeof(struct ndpi_iphdr)];
u_int16_t sport = ntohs(udp->source), dport = ntohs(udp->dest);

if(((sport == GTP_U_V1_PORT) || (dport == GTP_U_V1_PORT)) && (ip_offset + sizeof(struct ndpi_iphdr) + sizeof(struct ndpi_udphdr) + 8 < header->caplen)) {
  u_int8_t *gtp_packet = (u_int8_t *)&packet[ip_offset + sizeof(struct ndpi_iphdr) + sizeof(struct ndpi_udphdr)];
  u_int8_t gtp_version = (gtp_packet[0] & 0xE0) >> 5;
  u_int8_t gtp_type = gtp_packet[1];

  if((gtp_version == 1) && (gtp_type == 0xFF)) {
    ip_offset += sizeof(struct ndpi_iphdr) + sizeof(struct ndpi_udphdr) + 8;
    tunnel_type = ndpi_gtp_tunnel;
  }
} else if((sport == TZSP_PORT) || (dport == TZSP_PORT)) {
  u_int8_t *tzsp_packet = (u_int8_t *)&packet[ip_offset + sizeof(struct ndpi_iphdr) + sizeof(struct ndpi_udphdr)];
  u_int8_t version = tzsp_packet[0];
  u_int8_t type = tzsp_packet[1];

  if((version == 1) && (type == 0)) {
    u_int8_t *end = &packet[header->caplen];
    u_int8_t *tag = &tzsp_packet[4];

    while(tag < end) {
      if(*tag == 1) { /* TZSP_TAG_END */
        tag++;
        break;
      } else {
        tag += tag[1] + 2;
      }
    }
    if(tag < end) {
      ip_offset = (u_int16_t)(tag - packet);
      tunnel_type = ndpi_tzsp_tunnel;
    }
  }
} else if(sport == CAPWAP_DATA_PORT) {
  u_int8_t *capwap_packet = (u_int8_t *)&packet[ip_offset + sizeof(struct ndpi_iphdr) + sizeof(struct ndpi_udphdr)];
  u_int8_t capwap_type = (capwap_packet[0] & 0xF0) >> 4;

  if(capwap_type == 0) { /* CAPWAP_DATA_PACKET */
    u_int16_t capwap_header_len = (capwap_packet[1] & 0xF8) >> 3;
    ip_offset += sizeof(struct ndpi_iphdr) + sizeof(struct ndpi_udphdr) + capwap_header_len;
    tunnel_type = ndpi_capwap_tunnel;
  }
}