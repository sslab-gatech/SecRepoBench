struct ndpi_udphdr *udph_tunnel;

    udph_tunnel = (struct ndpi_udphdr*)(&packet[ip_offset] + ip_len);
    if(ntohs(udph_tunnel->dest) == GTP_U_V1_PORT) {
      // Check GTP version and message type
      u_int8_t message_type = *((u_int8_t*)(udph_tunnel) + sizeof(struct ndpi_udphdr) + 1);
      if(*((u_int8_t*)(udph_tunnel) + sizeof(struct ndpi_udphdr)) == 1 /* GTPv1 */
	 && (message_type == 2 /* T-PDU */ || message_type == 255 /* GTP' */)) {
	ip_offset += ip_len + sizeof(struct ndpi_udphdr) + 8; /* GTP-U header is 8 bytes */
	tunnel_type = ndpi_gtp_tunnel;
	workflow->stats.gtp_count++;
	goto iph_check;
      }
    } else if(ntohs(udph_tunnel->dest) == TZSP_PORT) {
      u_int8_t tzsp_version = *((u_int8_t*)(udph_tunnel) + sizeof(struct ndpi_udphdr));
      u_int8_t tzsp_encap_proto = *((u_int8_t*)(udph_tunnel) + sizeof(struct ndpi_udphdr) + 1);

      if(tzsp_version == 1 && tzsp_encap_proto == 0) {
	u_int16_t tzsp_type, tzsp_len;
	u_int16_t tzsp_offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr) + 2;

	do {
	  tzsp_type = ntohs(*((u_int16_t*)(&packet[tzsp_offset])));
	  tzsp_len  = ntohs(*((u_int16_t*)(&packet[tzsp_offset + 2])));

	  if(tzsp_type == 0 /* Ethernet */) {
	    datalink_type = DLT_EN10MB;
	    eth_offset = tzsp_offset + 4;
	    tunnel_type = ndpi_tzsp_tunnel;
	    workflow->stats.tzsp_count++;
	    goto datalink_check;
	  }

	  tzsp_offset += 4 + tzsp_len;
	} while(tzsp_offset < header->caplen);
      }
    } else if(ntohs(udph_tunnel->source) == NDPI_CAPWAP_DATA_PORT) {
      u_int8_t capwap_message_type = *((u_int8_t*)(udph_tunnel) + sizeof(struct ndpi_udphdr) + 4);

      if(capwap_message_type == 0 /* Data */) {
	ip_offset += ip_len + sizeof(struct ndpi_udphdr) + 8 /* CAPWAP header is 8 bytes */;
	tunnel_type = ndpi_capwap_tunnel;
	workflow->stats.capwap_count++;
	goto iph_check;
      }
    }