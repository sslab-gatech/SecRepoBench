struct ndpi_udphdr *udp = (struct ndpi_udphdr *)&packet[ip_offset];
u_int16_t sport = ntohs(udp->source), dport = ntohs(udp->dest);
u_int8_t *udp_payload = (u_int8_t*)&packet[ip_offset + sizeof(struct ndpi_udphdr)];
u_int16_t udp_payload_len = header->caplen - (ip_offset + sizeof(struct ndpi_udphdr));

// GTP-U detection (UDP port 2152)
if(((dport == 2152) || (sport == 2152)) && (udp_payload_len > 8)) {
  // First byte of GTP header contains version (bits 6-8) and message type (bits 0-5)
  u_int8_t gtp_version = (udp_payload[0] & 0xE0) >> 5;
  u_int8_t gtp_message_type = udp_payload[0] & 0x1F;
  
  // Check for GTP-U (version 1) and message type 255 (T-PDU)
  if((gtp_version == 1) && (gtp_message_type == 255)) {
    u_int8_t gtp_flags = udp_payload[1];
    u_int8_t has_extension = (gtp_flags & 0x04) >> 2;
    u_int8_t has_sequence = (gtp_flags & 0x02) >> 1;
    u_int8_t has_pdu_num = gtp_flags & 0x01;
    
    // Calculate GTP header length (8 bytes is the minimum)
    u_int16_t gtp_header_len = 8;
    
    // If we have extension, sequence, or N-PDU number, add 4 bytes
    if(has_extension || has_sequence || has_pdu_num)
      gtp_header_len += 4;
    
    // Skip extensions if present
    if(has_extension && (udp_payload_len > gtp_header_len)) {
      u_int8_t next_extension = udp_payload[gtp_header_len];
      
      while(next_extension != 0) {
        if(gtp_header_len + 1 >= udp_payload_len) break;
        gtp_header_len += ((udp_payload[gtp_header_len + 1] & 0x0F) * 4);
        if(gtp_header_len >= udp_payload_len) break;
        next_extension = udp_payload[gtp_header_len];
      }
    }
    
    // Update IP offset to the start of the encapsulated IP packet
    ip_offset += sizeof(struct ndpi_udphdr) + gtp_header_len;
    
    // Mark as GTP tunnel
    tunnel_type = ndpi_gtp_tunnel;
    
    // Recheck IP header
    if(header->caplen > ip_offset)
      goto iph_check;
  }
} 
// TZSP detection (UDP port 37008)
else if(((sport == 37008) || (dport == 37008)) && (udp_payload_len > 4)) {
  u_int8_t tzsp_version = udp_payload[0];
  u_int8_t tzsp_type = udp_payload[1];
  
  // Check for TZSP version 1 and type 0 (received from wired)
  if((tzsp_version == 1) && (tzsp_type == 0)) {
    u_int16_t offset = 4; // Initial TZSP header size
    
    // Iterate through TZSP tags until we hit a tag indicating end of tags
    while(offset < udp_payload_len) {
      if(udp_payload[offset] == 0) { // End of tags
        offset++; // Move past the end tag
        break;
      }
      
      if(udp_payload[offset] == 1) { // Padding, skip to the next tag
        offset++;
        continue;
      }
      
      if(offset + 2 > udp_payload_len) // Ensure we have room for the tag length
        break;
        
      u_int8_t tag_length = udp_payload[offset+1];
      
      if(offset + 2 + tag_length > udp_payload_len) // Ensure we have room for the tag data
        break;
        
      offset += 2 + tag_length; // Move to the next tag
    }
    
    // At this point, offset should point to the encapsulated Ethernet frame
    if(offset < udp_payload_len) {
      ip_offset += sizeof(struct ndpi_udphdr) + offset;
      tunnel_type = ndpi_tzsp_tunnel;
      
      // Reset datalink type to Ethernet as we're now parsing an Ethernet frame
      datalink_type = DLT_EN10MB;
      eth_offset = ip_offset;
      
      // Go back to datalink detection
      goto datalink_check;
    }
  }
}
// CAPWAP detection (UDP port 5246 or 5247)
else if(((sport == 5246) || (sport == 5247) || (dport == 5246) || (dport == 5247)) && (udp_payload_len > 8)) {
  // First byte: CAPWAP preamble
  // Second byte: bits 0-3 are the HLEN field (header length)
  u_int8_t preamble = udp_payload[0];
  u_int8_t capwap_hlen = udp_payload[1] & 0x0F;
  
  // Check if it's a CAPWAP data packet (CAPWAP preamble is typically 0)
  if(preamble == 0) {
    // HLEN field gives the header length in 4-byte words
    u_int16_t capwap_header_len = capwap_hlen * 4;
    
    if(capwap_header_len + sizeof(struct ndpi_udphdr) < header->caplen - ip_offset) {
      // Update IP offset to the start of the wireless frame
      ip_offset += sizeof(struct ndpi_udphdr) + capwap_header_len;
      
      // Mark as CAPWAP tunnel
      tunnel_type = ndpi_capwap_tunnel;
      
      // Recheck IP header
      goto iph_check;
    }
  }
}