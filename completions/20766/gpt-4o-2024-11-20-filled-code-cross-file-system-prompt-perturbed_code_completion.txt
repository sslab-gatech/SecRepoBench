struct ndpi_udphdr *udph = (struct ndpi_udphdr *)&packet[ip_offset];
    u_int16_t sport = ntohs(udph->source), dport = ntohs(udph->dest);

    if((sport == 2152) || (dport == 2152)) { // GTP-U
      struct ndpi_gtphdr *gtph = (struct ndpi_gtphdr *)&packet[ip_offset + sizeof(struct ndpi_udphdr)];

      if((header->caplen >= (ip_offset + sizeof(struct ndpi_udphdr) + sizeof(struct ndpi_gtphdr))) &&
         (NDPI_GTP_GET_VERSION(gtph) == 1) && (gtph->message_type == 255)) {
        ip_offset += sizeof(struct ndpi_udphdr) + sizeof(struct ndpi_gtphdr);
        tunnel_type = ndpi_gtp_tunnel;
      }
    } else if((sport == 37008) || (dport == 37008)) { // TZSP
      struct ndpi_tzsphdr *tzsph = (struct ndpi_tzsphdr *)&packet[ip_offset + sizeof(struct ndpi_udphdr)];

      if((header->caplen >= (ip_offset + sizeof(struct ndpi_udphdr) + sizeof(struct ndpi_tzsphdr))) &&
         (tzsph->version == 1) && (tzsph->type == 0)) {
        ip_offset += sizeof(struct ndpi_udphdr) + sizeof(struct ndpi_tzsphdr);

        while((ip_offset < header->caplen) && (packet[ip_offset] != 1)) {
          u_int8_t tag_len = packet[ip_offset + 1];
          ip_offset += 2 + tag_len;
        }

        if((ip_offset + 1) < header->caplen) {
          ip_offset += 2; // Skip encapsulated Ethernet frame tag
          tunnel_type = ndpi_tzsp_tunnel;
        }
      }
    } else if(sport == 5246) { // CAPWAP
      struct ndpi_capwaphdr *capwaph = (struct ndpi_capwaphdr *)&packet[ip_offset + sizeof(struct ndpi_udphdr)];

      if((header->caplen >= (ip_offset + sizeof(struct ndpi_udphdr) + sizeof(struct ndpi_capwaphdr))) &&
         (capwaph->type == 0)) {
        ip_offset += sizeof(struct ndpi_udphdr) + sizeof(struct ndpi_capwaphdr);
        tunnel_type = ndpi_capwap_tunnel;
      }
    }