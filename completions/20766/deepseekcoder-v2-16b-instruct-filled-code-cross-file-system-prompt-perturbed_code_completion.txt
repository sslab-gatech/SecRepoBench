if(workflow->prefs.decode_tunnels && (proto == IPPROTO_UDP)) {
    // Parse the UDP header from the packet using the current IP offset.
    // Extract source and destination ports to identify potential tunnel protocols.
    // Check for GTP-U protocol by comparing ports, then verify GTP version and message type.
    // If GTP-U is detected, update IP offset to point to the encapsulated IP header.
    // Set the tunnel type to ndpi_gtp_tunnel for GTP-U packets.
    // Check for TZSP protocol using ports, then verify TZSP version and encapsulated protocol.
    // If TZSP is detected, navigate through its tags until reaching the encapsulated Ethernet frame.
    // Set the tunnel type to ndpi_tzsp_tunnel for TZSP packets.
    // Check for CAPWAP protocol using source port, then verify CAPWAP message type.
    // If CAPWAP is detected, update IP offset to point to the encapsulated IP header.
    // Set the tunnel type to ndpi_capwap_tunnel for CAPWAP packets.
    // The tunnel type and updated IP offset are used for further packet processing.
    struct ndpi_udphdr *udp = (struct ndpi_udphdr *)&packet[ip_offset];
    *sport = ntohs(udp->source);
    *dport = ntohs(udp->dest);

    if (*sport == 2152 && *dport == 2152) { // GTP-U ports
      // Check GTP version and message type
      if (header->caplen >= ip_offset + sizeof(struct ndpi_udphdr) + 8) {
        u_int8_t *gtp_data = (u_int8_t *)&packet[ip_offset + sizeof(struct ndpi_udphdr)];
        u_int8_t version = (gtp_data[0] & 0xF0) >> 4;
        u_int8_t message_type = gtp_data[0] & 0x0F;
        if (version == 1 && (message_type == 1 || message_type == 2)) {
          ip_offset += sizeof(struct ndpi_udphdr) + 8;
          tunnel_type = ndpi_gtp_tunnel;
        }
      }
    } else if (*sport == 3948 && *dport == 3948) { // TZSP ports
      // Check TZSP version and encapsulated protocol
      if (header->caplen >= ip_offset + sizeof(struct ndpi_udphdr) + 4) {
        u_int8_t *tzsp_data = (u_int8_t *)&packet[ip_offset + sizeof(struct ndpi_udphdr)];
        u_int8_t version = tzsp_data[0];
        u_int8_t protocol = tzsp_data[1];
        if (version == 1 && protocol == 0x88) {
          // Navigate through TZSP tags
          u_int16_t tag_length;
          u_int8_t *tag = tzsp_data + 2;
          while (header->caplen >= ip_offset + sizeof(struct ndpi_udphdr) + tag[0]) {
            tag_length = tag[0];
            if (tag_length >= 2 && tag_length <= 255) {
              ip_offset += sizeof(struct ndpi_udphdr) + tag_length;
              tag = &packet[ip_offset];
            } else {
              break;
            }
          }
          tunnel_type = ndpi_tzsp_tunnel;
        }
      }
    } else if (*sport == 3386) { // CAPWAP source port
      // Check CAPWAP message type
      if (header->caplen >= ip_offset + sizeof(struct ndpi_udphdr) + 4) {
        u_int8_t *capwap_data = (u_int8_t *)&packet[ip_offset + sizeof(struct ndpi_udphdr)];
        u_int8_t message_type = capwap_data[0];
        if (message_type == 1 || message_type == 2) {
          ip_offset += sizeof(struct ndpi_udphdr) + 4;
          tunnel_type = ndpi_capwap_tunnel;
        }
      }
    }
  }