// Parse the UDP header from the packet using the current IP offset.
struct ndpi_udphdr *udph = (struct ndpi_udphdr *)&packet[ip_offset];

// Extract source and destination ports to identify potential tunnel protocols.
u_int16_t src_port = ntohs(udph->source);
u_int16_t dst_port = ntohs(udph->dest);

// Check for GTP-U protocol by comparing ports.
if (src_port == GTP_U_V1_PORT || dst_port == GTP_U_V1_PORT) {
  // Verify GTP version and message type.
  u_int8_t *gtpu_header = (u_int8_t *)&packet[ip_offset + sizeof(struct ndpi_udphdr)];
  if (gtpu_header[0] == 0xFF && gtpu_header[1] == 0x1) {
    // Update IP offset to point to the encapsulated IP header.
    ip_offset += sizeof(struct ndpi_udphdr) + 8;
    // Set the tunnel type to ndpi_gtp_tunnel for GTP-U packets.
    tunnel_type = ndpi_gtp_tunnel;
  }
}

// Check for TZSP protocol using ports.
if (src_port == TZSP_PORT || dst_port == TZSP_PORT) {
  // Verify TZSP version and encapsulated protocol.
  u_int8_t *tzsp_header = (u_int8_t *)&packet[ip_offset + sizeof(struct ndpi_udphdr)];
  if (tzsp_header[0] == 0x01 && tzsp_header[1] == 0x00) {
    // Navigate through its tags until reaching the encapsulated Ethernet frame.
    u_int16_t tzsp_offset = sizeof(struct ndpi_udphdr) + 4;
    while (tzsp_offset < header->caplen) {
      u_int8_t tzsp_tag = tzsp_header[tzsp_offset];
      u_int8_t tzsp_len = tzsp_header[tzsp_offset + 1];
      tzsp_offset += tzsp_len + 2;
      if (tzsp_tag == 0x03) {
        // Update IP offset to point to the encapsulated IP header.
        ip_offset = tzsp_offset;
        // Set the tunnel type to ndpi_tzsp_tunnel for TZSP packets.
        tunnel_type = ndpi_tzsp_tunnel;
        break;
      }
    }
  }
}

// Check for CAPWAP protocol using source port.
if (src_port == NDPI_CAPWAP_DATA_PORT) {
  // Verify CAPWAP message type.
  u_int8_t *capwap_header = (u_int8_t *)&packet[ip_offset + sizeof(struct ndpi_udphdr)];
  if (capwap_header[0] == 0x01) {
    // Update IP offset to point to the encapsulated IP header.
    ip_offset += sizeof(struct ndpi_udphdr) + 4;
    // Set the tunnel type to ndpi_capwap_tunnel for CAPWAP packets.
    tunnel_type = ndpi_capwap_tunnel;
  }
}