if(workflow->prefs.decode_tunnels && (proto == IPPROTO_UDP)) {
    // Parse the UDP header from the packet using the current IP offset.
    // Extract source and destination ports to identify potential tunnel protocols.
    // Check for GTP-U protocol by comparing ports, then verify GTP version and message type.
    // If GTP-U is detected, update IP offset to point to the encapsulated IP header.
    // Set the tunnel type to ndpi_gtp_tunnel for GTP-U packets.
    // Check for TZSP protocol using ports, then verify TZSP version and encapsulated protocol.
    // If TZSP is detected, navigate through its tags until reaching the encapsulated Ethernet frame.
    // Set the tunnel type to ndpi_tzsp_tunnel for TZSP packets.
    // Check for CAPWAP protocol using source port, then verify CAPWAP message type.
    // If CAPWAP is detected, update IP offset to point to the encapsulated IP header.
    // Set the tunnel type to ndpi_capwap_tunnel for CAPWAP packets.
    // The tunnel type and updated IP offset are used for further packet processing.

    struct ndpi_udphdr *udp = (struct ndpi_udphdr *)&packet[ip_offset];
    *sport = ntohs(udp->source);
    *dport = ntohs(udp->dest);

    if (*sport == 2152 && *dport == 2152) { // GTP-U ports
      // Check GTP version and message type
      if (header->caplen >= ip_offset + sizeof(struct ndpi_udphdr) + 8) {
        u_int8_t *gtp_data = (u_int8_t *)&packet[ip_offset + sizeof(struct ndpi_udphdr)];
        u_int8_t version = (gtp_data[0] & 0xF0) >> 4;
        u_int8_t message_type = gtp_data[0] & 0x0F;
        if (version == 1 && (message_type == 1 || message_type == 2)) {
          ip_offset += sizeof(struct ndpi_udphdr) + 8;
          tunnel_type = ndpi_gtp_tunnel;
        }
      }
    } else if (*sport == 3380 && *dport == 3380) { // TZSP ports
      // Verify TZSP version and encapsulated protocol
      if (header->caplen >= ip_offset + sizeof(struct ndpi_udphdr) + 4) {
        u_int8_t *tzsp_data = (u_int8_t *)&packet[ip_offset + sizeof(struct ndpi_udphdr)];
        u_int8_t version = tzsp_data[0];
        u_int8_t protocol = tzsp_data[1];
        if (version == 1 && protocol == 0x08) { // Ethernet encapsulation
          ip_offset += sizeof(struct ndpi_udphdr) + 4;
          tunnel_type = ndpi_tzsp_tunnel;
        }
      }
    } else if (*sport == 3380) { // CAPWAP source port
      // Verify CAPWAP message type
      if (header->caplen >= ip_offset + sizeof(struct ndpi_udphdr) + 4) {
        u_int8_t *capwap_data = (u_int8_t *)&packet[ip_offset + sizeof(struct ndpi_udphdr)];
        u_int8_t message_type = capwap_data[0];
        if (message_type == 1) { // Initial Message
          ip_offset += sizeof(struct ndpi_udphdr) + 4;
          tunnel_type = ndpi_capwap_tunnel;
        }
      }
    }
  }