{
  uint16_t s_port = ntohs(udph->source);
  uint16_t d_port = ntohs(udph->dest);

  /* GTP-U */
  if((s_port == GTP_U_V1_PORT) || (d_port == GTP_U_V1_PORT)) {
    /* Ensure there's enough space for GTP header */
    if(ip_offset + 8 <= header->caplen) {
      /* Check GTP v1: Top 3 bits = 1, PT bit = 1 => 0x30 mask */
      if((packet[ip_offset] & 0xF0) == 0x30) {
        uint16_t gtp_length = ((packet[ip_offset + 2] << 8) | packet[ip_offset + 3]);
        /* Skip base GTP-U header (8 bytes). If the extension headers are set, we are not skipping them here. */
        ip_offset += 8;
        /* GTP payload should be IP */
        if(ip_offset + gtp_length <= header->caplen) {
          tunnel_type = ndpi_gtp_tunnel;
          type = ETH_P_IP;
          goto iph_check;
        }
      }
    }
  }

  /* TZSP (TaZmen Sniffer Protocol) */
  if((s_port == TZSP_PORT) || (d_port == TZSP_PORT)) {
    /* Basic TZSP check: version = 1, type = 0 (received packet), then parse tags until we find real L2 data */
    if(ip_offset + 4 <= header->caplen) {
      if((packet[ip_offset] == 1) && (packet[ip_offset + 1] == 0)) {
        /* Skip TZSP header (4 bytes), then parse tags */
        ip_offset += 4;
        while(ip_offset + 2 <= header->caplen) {
          uint8_t tag_type = packet[ip_offset];
          uint8_t tag_len  = packet[ip_offset + 1];
          ip_offset += 2;
          if(tag_type == 1 /* end-of-tags */) {
            break;
          }
          ip_offset += tag_len;
          if(ip_offset >= header->caplen) {
            break;
          }
        }
        /* After tags, we expect an encapsulated Ethernet frame: reset type and proceed */
        if(ip_offset + sizeof(struct ndpi_ethhdr) <= header->caplen) {
          tunnel_type = ndpi_tzsp_tunnel;
          datalink_type = DLT_EN10MB; /* parse as Ethernet */
          eth_offset = ip_offset;
          ip_offset += sizeof(struct ndpi_ethhdr);
          /* re-check so we parse the new type properly */
          type = 0;
          goto datalink_check;
        }
      }
    }
  }

  /* CAPWAP data */
  if((s_port == NDPI_CAPWAP_DATA_PORT) || (d_port == NDPI_CAPWAP_DATA_PORT)) {
    /* Basic CAPWAP: check that we have at least the header fields for data packets */
    if(ip_offset + 8 <= header->caplen) {
      /* For simplified handling, skip the CAPWAP header. This is not a full parse. */
      ip_offset += 8;
      /* Assume inner payload is IP */
      if(ip_offset < header->caplen) {
        tunnel_type = ndpi_capwap_tunnel;
        type = ETH_P_IP;
        goto iph_check;
      }
    }
  }
}