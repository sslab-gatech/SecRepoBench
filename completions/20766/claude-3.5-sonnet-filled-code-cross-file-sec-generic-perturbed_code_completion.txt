struct ndpi_udphdr *udp = (struct ndpi_udphdr *)&packet[ip_offset + ip_len];
u_int16_t sport = ntohs(udp->source), dport = ntohs(udp->dest);

if(((sport == GTP_U_V1_PORT) || (dport == GTP_U_V1_PORT)) && (ip_offset + ip_len + sizeof(struct ndpi_udphdr) + 8 < header->caplen)) {
  u_int8_t *gtp_packet = (u_int8_t *)&packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr)];
  u_int8_t gtp_version = (gtp_packet[0] & 0xE0) >> 5;
  u_int8_t gtp_type = gtp_packet[1];

  if((gtp_version == 1) && (gtp_type == 0xFF)) {
    ip_offset += ip_len + sizeof(struct ndpi_udphdr) + 8; /* GTP-U header size */
    tunnel_type = ndpi_gtp_tunnel;
    goto iph_check;
  }
}

if(((sport == TZSP_PORT) || (dport == TZSP_PORT)) && (ip_offset + ip_len + sizeof(struct ndpi_udphdr) + 4 < header->caplen)) {
  u_int8_t *tzsp = (u_int8_t *)&packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr)];

  if((tzsp[0] == 1) && (tzsp[1] == 0)) { /* TZSP v1, type 0 */
    u_int8_t *end = (u_int8_t *)&packet[header->caplen];
    u_int8_t *next = tzsp + 4;
    while(next < end) {
      if(*next == 0) {
        next++;
        if(next == end) break;
        if(*next == 1) { /* Header follows */
          ip_offset = (next + 1) - packet;
          tunnel_type = ndpi_tzsp_tunnel;
          goto datalink_check;
        }
      }
      next++;
    }
  }
}

if((sport == CAPWAP_DATA_PORT) && (ip_offset + ip_len + sizeof(struct ndpi_udphdr) + 8 < header->caplen)) {
  u_int8_t *capwap = (u_int8_t *)&packet[ip_offset + ip_len + sizeof(struct ndpi_udphdr)];
  u_int8_t capwap_type = (capwap[1] & 0xF0) >> 4;

  if(capwap_type == 0) { /* CAPWAP Data Packet */
    ip_offset += ip_len + sizeof(struct ndpi_udphdr) + 8; /* CAPWAP header size */
    tunnel_type = ndpi_capwap_tunnel;
    goto iph_check;
  }
}