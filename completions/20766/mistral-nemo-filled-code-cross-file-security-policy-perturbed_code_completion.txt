if(workflow->prefs.decode_tunnels && (proto == IPPROTO_UDP)) {
    struct ndpi_udphdr *udph = (struct ndpi_udphdr *)&packet[ip_offset + ip_len];
    u_int16_t src_port = ntohs(udph->uh_sport);
    u_int16_t dst_port = ntohs(udph->uh_dport);

    if((src_port == GTPU_PORT && dst_port == GTPU_PORT) ||
       (src_port == TZSP_PORT && dst_port == TZSP_PORT) ||
       (src_port == CAPWAP_PORT && dst_port == CAPWAP_PORT)) {
      if(src_port == GTPU_PORT && dst_port == GTPU_PORT) {
        // Parse GTP-U header and check version and message type
        // If GTP-U, update ip_offset to point to the encapsulated IP header
        // Set tunnel_type to ndpi_gtp_tunnel
      } else if(src_port == TZSP_PORT && dst_port == TZSP_PORT) {
        // Parse TZSP header and navigate through tags to reach encapsulated Ethernet frame
        // Set tunnel_type to ndpi_tzsp_tunnel
      } else if(src_port == CAPWAP_PORT && dst_port == CAPWAP_PORT) {
        // Parse CAPWAP header and check message type
        // If CAPWAP, update ip_offset to point to the encapsulated IP header
        // Set tunnel_type to ndpi_capwap_tunnel
      }
    }
    tunnel_type = ndpi_no_tunnel;
  }

  /* process the packet */
  return(packet_processing(workflow, time, vlan_id, tunnel_type, iph, iph6,
                           ip_offset, header->caplen - ip_offset,
                           header->caplen, header, packet, header->ts));
}