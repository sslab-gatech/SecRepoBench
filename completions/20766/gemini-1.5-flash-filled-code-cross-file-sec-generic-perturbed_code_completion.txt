struct ndpi_udphdr *udp_header = (struct ndpi_udphdr *) &packet[ip_offset];
    u_int16_t source_port = ntohs(udp_header->source);
    u_int16_t dest_port = ntohs(udp_header->dest);

    if (source_port == GTPU_PORT || dest_port == GTPU_PORT) {
      // Check GTP-U protocol
      if (is_gtpu(packet + ip_offset + sizeof(struct ndpi_udphdr), header->caplen - ip_offset - sizeof(struct ndpi_udphdr))) {
        ip_offset += sizeof(struct ndpi_udphdr) + get_gtpu_header_len(packet + ip_offset + sizeof(struct ndpi_udphdr));
        tunnel_type = ndpi_gtp_tunnel;
      }
    } else if (source_port == TZSP_PORT || dest_port == TZSP_PORT) {
      // Check TZSP protocol
      if (is_tzsp(packet + ip_offset + sizeof(struct ndpi_udphdr), header->caplen - ip_offset - sizeof(struct ndpi_udphdr))) {
        ip_offset += sizeof(struct ndpi_udphdr) + get_tzsp_header_len(packet + ip_offset + sizeof(struct ndpi_udphdr));
        tunnel_type = ndpi_tzsp_tunnel;
      }
    } else if (source_port == CAPWAP_PORT) {
      // Check CAPWAP protocol
      if (is_capwap(packet + ip_offset + sizeof(struct ndpi_udphdr), header->caplen - ip_offset - sizeof(struct ndpi_udphdr))) {
        ip_offset += sizeof(struct ndpi_udphdr) + get_capwap_header_len(packet + ip_offset + sizeof(struct ndpi_udphdr));
        tunnel_type = ndpi_capwap_tunnel;
      }
    }