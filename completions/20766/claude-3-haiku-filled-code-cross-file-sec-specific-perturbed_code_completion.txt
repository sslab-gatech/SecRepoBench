// <MASK>
if(proto == IPPROTO_UDP) {
    struct ndpi_udphdr *udp = (struct ndpi_udphdr *)&packet[ip_offset];
    u_int16_t sport = ntohs(udp->source), dport = ntohs(udp->dest);

    // Check for GTP-U protocol
    if((sport == 2152 || dport == 2152) && (ntohs(udp->len) >= 8)) {
        u_int8_t gtp_version = (packet[ip_offset + 4] & 0xE0) >> 5;
        u_int8_t gtp_message_type = packet[ip_offset + 5];

        if(gtp_version == 1 && (gtp_message_type == 0xFF || (gtp_message_type >= 0x30 && gtp_message_type <= 0x4D))) {
            ip_offset += 8; // Skip the GTP-U header
            tunnel_type = ndpi_gtp_tunnel;
        }
    }
    // Check for TZSP protocol
    else if((sport == 37008 || dport == 37008) && (ntohs(udp->len) >= 4)) {
        u_int8_t tzsp_version = packet[ip_offset + 2];
        u_int8_t tzsp_type = packet[ip_offset + 3];

        if(tzsp_version == 1 && tzsp_type == 0x01) { // TZSP packet
            u_int16_t tag_type, tag_len;
            u_int16_t offset = 4;

            while(offset < ntohs(udp->len)) {
                tag_type = packet[ip_offset + offset];
                tag_len = packet[ip_offset + offset + 1];

                if(tag_type == 0x01) { // Encapsulated protocol
                    ip_offset = ip_offset + offset + 2;
                    tunnel_type = ndpi_tzsp_tunnel;
                    break;
                }

                offset += tag_len + 2;
            }
        }
    }
    // Check for CAPWAP protocol
    else if(sport == 5247) {
        u_int8_t capwap_type = packet[ip_offset + 4] & 0x3F;

        if(capwap_type == 0x00 || capwap_type == 0x10) { // CAPWAP data or keep-alive packets
            ip_offset += ((packet[ip_offset + 2] << 8) + packet[ip_offset + 3]); // Skip the CAPWAP header
            tunnel_type = ndpi_capwap_tunnel;
        }
    }
}