if(workflow->prefs.decode_tunnels && (proto == IPPROTO_UDP)) {
    struct ndpi_udphdr *udph = (struct ndpi_udphdr *)&packet[ip_offset + ip_len];
    u_int16_t src_port = ntohs(udph->uh_sport);
    u_int16_t dst_port = ntohs(udph->uh_dport);

    if((src_port == GTPU_PORT && dst_port == GTPU_PORT) ||
       (src_port == TZSP_PORT && dst_port == TZSP_PORT) ||
       (src_port == CAPWAP_PORT && dst_port == CAPWAP_PORT)) {
      u_int16_t tunnel_type = ndpi_no_tunnel;

      if(src_port == GTPU_PORT && dst_port == GTPU_PORT) {
        u_int8_t gtp_version = ((packet[ip_offset + ip_len + UDP_HDR_LEN] & 0xF0) >> 4);
        u_int8_t gtp_message_type = (packet[ip_offset + ip_len + UDP_HDR_LEN] & 0x0F);

        if(gtp_version == GTPVERSION && gtp_message_type == GTPU_MESSAGE_TYPE) {
          tunnel_type = ndpi_gtp_tunnel;
          ip_offset += ip_len + UDP_HDR_LEN + GTPU_HDR_LEN;
        }
      } else if(src_port == TZSP_PORT && dst_port == TZSP_PORT) {
        u_int8_t tzsp_version = packet[ip_offset + ip_len + UDP_HDR_LEN];
        u_int8_t encapsulated_protocol = packet[ip_offset + ip_len + UDP_HDR_LEN + 1];

        if(tzsp_version == TZSPVERSION) {
          u_int16_t tag_len = (packet[ip_offset + ip_len + UDP_HDR_LEN + 2] << 8) + packet[ip_offset + ip_len + UDP_HDR_LEN + 3];
          u_int16_t tag_offset = ip_len + UDP_HDR_LEN + TZSP_HDR_LEN;

          while(tag_len > 0) {
            u_int8_t tag_type = packet[ip_offset + tag_offset];
            u_int16_t tag_value_len = (packet[ip_offset + tag_offset + 1] << 8) + packet[ip_offset + tag_offset + 2];

            if(tag_type == TZSP_ETHERNET_TAG) {
              tunnel_type = ndpi_tzsp_tunnel;
              ip_offset += tag_offset + tag_value_len;
              break;
            }

            tag_len -= tag_value_len + 3;
            tag_offset += tag_value_len + 3;
          }
        }
      } else if(src_port == CAPWAP_PORT && dst_port == CAPWAP_PORT) {
        u_int8_t capwap_message_type = packet[ip_offset + ip_len + UDP_HDR_LEN];

        if(capwap_message_type == CAPWAP_MESSAGE_TYPE) {
          tunnel_type = ndpi_capwap_tunnel;
          ip_offset += ip_len + UDP_HDR_LEN + CAPWAP_HDR_LEN;
        }
      }

      if(tunnel_type != ndpi_no_tunnel) {
        workflow->stats.tunnel_count++;
        tunnel_type = tunnel_type;
      }
    }
  }