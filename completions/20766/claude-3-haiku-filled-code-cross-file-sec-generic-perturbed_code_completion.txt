// <MASK>
  u_int16_t sport, dport;
  struct ndpi_tcphdr *tcph = NULL;
  struct ndpi_udphdr *udph = NULL;
  struct ndpi_id_struct *src = NULL, *dst = NULL;
  u_int8_t proto = 0;
  u_int8_t *payload = NULL;
  u_int16_t payload_len = 0;
  u_int8_t src_to_dst_direction = 0;
  struct timeval when;
  when.tv_sec = header->ts.tv_sec;
  when.tv_usec = header->ts.tv_usec;

  struct ndpi_flow_info *flow = get_ndpi_flow_info6(workflow, vlan_id, tunnel_type,
                                                   (const struct ndpi_ipv6hdr *)iph6,
                                                   ip_offset, header->caplen - ip_offset,
                                                   &tcph, &udph, &sport, &dport,
                                                   &src, &dst, &proto, &payload,
                                                   &payload_len, &src_to_dst_direction,
                                                   when);

  if (flow != NULL) {
    if (proto == IPPROTO_UDP && sport == 2152 && dport == 2152) {
      // Detect GTP-U tunnel
      tunnel_type = ndpi_gtp_tunnel;
      ip_offset += 8; // Skip the UDP header
      iph6 = (const struct ndpi_ipv6hdr *)&packet[ip_offset];
    } else if (proto == IPPROTO_UDP && sport == 37008 && dport == 37008) {
      // Detect TZSP tunnel
      tunnel_type = ndpi_tzsp_tunnel;
      // Navigate through the TZSP tags to find the encapsulated Ethernet frame
      ip_offset = ndpi_tzsp_parse(workflow, &packet[ip_offset], header->caplen - ip_offset, &iph6);
    } else if (proto == IPPROTO_UDP && sport == 5247) {
      // Detect CAPWAP tunnel
      tunnel_type = ndpi_capwap_tunnel;
      ip_offset += 8; // Skip the UDP header
      iph6 = (const struct ndpi_ipv6hdr *)&packet[ip_offset];
    }
  }