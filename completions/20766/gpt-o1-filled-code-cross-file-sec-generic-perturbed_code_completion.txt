{
  /* Safely parse the UDP header */
  if ((header->caplen - ip_offset) < sizeof(struct ndpi_udphdr))
    return(ndpiprotocol); /* Not enough space for UDP header */

  struct ndpi_udphdr *udph = (struct ndpi_udphdr *)&packet[ip_offset];
  u_int16_t sport = ntohs(udph->source);
  u_int16_t dport = ntohs(udph->dest);
  u_int16_t udp_len = ntohs(udph->len);

  /* Verify that the entire UDP payload is present */
  if (udp_len < sizeof(struct ndpi_udphdr) || (header->caplen - ip_offset) < udp_len)
    return(ndpiprotocol);

  /* Advance past UDP header */
  ip_offset += sizeof(struct ndpi_udphdr);

  /* -------------------------
   * Check for GTP-U (port 2152)
   * ------------------------- */
  if (sport == 2152 || dport == 2152) {
    /* Minimal GTP-U header is 8 bytes */
    if ((header->caplen - ip_offset) >= 8) {
      const u_int8_t *gtp_data = &packet[ip_offset];
      u_int8_t gtp_flags = gtp_data[0];
      u_int8_t gtp_msg_type = gtp_data[1];

      /* Check if version bits indicate version 1 and message is T-PDU (0xFF) */
      if (((gtp_flags >> 5) & 0x07) == 1 && gtp_msg_type == 0xFF) {
        tunnel_type = ndpi_gtp_tunnel;
        ip_offset += 8; /* Skip GTP-U header */

        /* If next byte is present, check if it looks like IPv4 or IPv6 */
        if ((header->caplen - ip_offset) > 0) {
          u_int8_t ver = packet[ip_offset] >> 4;
          if (ver == 4) {
            proto = IPPROTO_IP;
          } else if (ver == 6) {
            proto = IPPROTO_IPV6;
          }
        }
      }
    }
  }
  /* -------------------------
   * Check for TZSP (commonly port 37008)
   * ------------------------- */
  else if (sport == 37008 || dport == 37008) {
    /* Minimal TZSP header is 4 bytes:
     *  byte 0: version
     *  byte 1: type
     *  bytes 2..3: Encapsulated protocol
     */
    if ((header->caplen - ip_offset) >= 4) {
      const u_int8_t *tzsp_data = &packet[ip_offset];
      u_int8_t tzsp_version = tzsp_data[0];
      u_int8_t tzsp_type = tzsp_data[1];

      /* version=1 and type=0 => Received encapsulated frame */
      if (tzsp_version == 1 && tzsp_type == 0) {
        /* Skip TZSP header */
        ip_offset += 4;

        /* Parse TZSP tags until we reach end-of-tags or run out of data */
        while ((header->caplen - ip_offset) >= 2) {
          u_int8_t tag_type = packet[ip_offset];
          u_int8_t tag_len  = packet[ip_offset + 1];
          ip_offset += 2;

          if (tag_type == 1 /* TAG_END */)
            break;

          if ((header->caplen - ip_offset) < tag_len)
            break; /* Malformed or truncated tags */

          ip_offset += tag_len;
        }

        /* Next data should be an Ethernet frame, switch datalink parser */
        datalink_type = DLT_EN10MB;
        eth_offset = ip_offset;
        goto datalink_check;
      }
    }
  }
  /* -------------------------
   * Check for CAPWAP (ports 5246 or 5247)
   * ------------------------- */
  else if ((sport == 5246 || dport == 5246) ||
           (sport == 5247 || dport == 5247)) {
    /* Minimal CAPWAP control header is 8 bytes */
    if ((header->caplen - ip_offset) >= 8) {
      tunnel_type = ndpi_capwap_tunnel;
      ip_offset += 8; /* Skip CAPWAP control header */

      /* Check if next byte suggests IPv4 or IPv6 */
      if ((header->caplen - ip_offset) > 0) {
        u_int8_t ver = packet[ip_offset] >> 4;
        if (ver == 4) {
          proto = IPPROTO_IP;
        } else if (ver == 6) {
          proto = IPPROTO_IPV6;
        }
      }
    }
  }
}