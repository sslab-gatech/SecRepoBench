if(workflow->prefs.decode_tunnels && (proto == IPPROTO_UDP)) {
    // Parse the UDP header from the packet using the current IP offset.
    struct ndpi_udphdr *udp = (struct ndpi_udphdr *)&packet[ip_offset];
    *sport = ntohs(udp->source);
    *dport = ntohs(udp->dest);

    // Check for GTP-U protocol by comparing ports
    if (*sport == 2152 || *dport == 2152) {
      workflow->stats.gtpu_count++;
      // Verify GTP version and message type
      u_int8_t gtpu_version = (*sport == 2152) ? (udp->dest >> 4) & 0xF : (udp->source >> 4) & 0xF;
      if (gtpu_version == 1) {
        u_int8_t message_type = (*sport == 2152) ? (udp->dest & 0xF) : (udp->source & 0xF);
        if (message_type == 0 || message_type == 1 || message_type == 2 || message_type == 3) {
          // Update IP offset to point to the encapsulated IP header
          ip_offset += sizeof(struct ndpi_udphdr);
          // Set the tunnel type to ndpi_gtp_tunnel for GTP-U packets
          tunnel_type = ndpi_gtp_tunnel;
        }
      }
    }

    // Check for TZSP protocol using ports
    if (*sport == 17000 || *dport == 17000) {
      workflow->stats.tzsp_count++;
      // Verify TZSP version and encapsulated protocol
      u_int8_t tzsp_version = (*sport == 17000) ? (udp->dest >> 4) & 0xF : (udp->source >> 4) & 0xF;
      if (tzsp_version == 1) {
        u_int8_t encapsulated_protocol = (*sport == 17000) ? (udp->dest & 0xF) : (udp->source & 0xF);
        // Navigate through its tags until reaching the encapsulated Ethernet frame
        // This is a simplified example, actual implementation may vary
        ip_offset += sizeof(struct ndpi_udphdr);
        // Set the tunnel type to ndpi_tzsp_tunnel for TZSP packets
        tunnel_type = ndpi_tzsp_tunnel;
      }
    }

    // Check for CAPWAP protocol using source port
    if (*sport == 36472) {
      workflow->stats.capwap_count++;
      // Verify CAPWAP message type
      u_int8_t capwap_message_type = (udp->dest & 0xFF);
      if (capwap_message_type == 1 || capwap_message_type == 2 || capwap_message_type == 3) {
        // Update IP offset to point to the encapsulated IP header
        ip_offset += sizeof(struct ndpi_udphdr);
        // Set the tunnel type to ndpi_capwap_tunnel for CAPWAP packets
        tunnel_type = ndpi_capwap_tunnel;
      }
    }

    // The tunnel type and updated IP offset are used for further packet processing
  }