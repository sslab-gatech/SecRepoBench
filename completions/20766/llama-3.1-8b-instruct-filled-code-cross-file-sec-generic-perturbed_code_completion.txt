if(workflow->prefs.decode_tunnels && (proto == IPPROTO_UDP)) {
  // Parse the UDP header from the packet using the current IP offset.
  // Extract source and destination ports to identify potential tunnel protocols.
  // Check for GTP-U protocol by comparing ports, then verify GTP version and message type.
  // If GTP-U is detected, update IP offset to point to the encapsulated IP header.
  // Set the tunnel type to ndpi_gtp_tunnel for GTP-U packets.
  // Check for TZSP protocol using ports, then verify TZSP version and encapsulated protocol.
  // If TZSP is detected, navigate through its tags until reaching the encapsulated Ethernet frame.
  // Set the tunnel type to ndpi_tzsp_tunnel for TZSP packets.
  // Check for CAPWAP protocol using source port, then verify CAPWAP message type.
  // If CAPWAP is detected, update IP offset to point to the encapsulated IP header.
  // Set the tunnel type to ndpi_capwap_tunnel for CAPWAP packets.
  // The tunnel type and updated IP offset are used for further packet processing.
  // Check for other tunnel protocols (e.g., L2TP, PPTP) using ports and message types.
  // If a tunnel protocol is detected, update the IP offset and set the tunnel type accordingly.
  // If no tunnel protocol is detected, set the tunnel type to ndpi_no_tunnel.
  // <MASK>

  // Check for GTP-U protocol
  if (ntohs(iph->saddr) == 2123 && ntohs(iph->daddr) == 2123) {
    // Check GTP version and message type
    if (iph->protocol == IPPROTO_UDP && ntohs(iph->protocol) == 2123) {
      // Update IP offset to point to the encapsulated IP header
      ip_offset += sizeof(struct ndpi_udp_header);
      // Set the tunnel type to ndpi_gtp_tunnel for GTP-U packets
      tunnel_type = ndpi_gtp_tunnel;
    }
  }

  // Check for TZSP protocol
  if (ntohs(iph->saddr) == 2123 && ntohs(iph->daddr) == 2123) {
    // Check TZSP version and encapsulated protocol
    if (iph->protocol == IPPROTO_UDP && ntohs(iph->protocol) == 2123) {
      // Navigate through TZSP tags until reaching the encapsulated Ethernet frame
      // Update IP offset to point to the encapsulated Ethernet frame
      ip_offset += sizeof(struct ndpi_tzsp_header);
      // Set the tunnel type to ndpi_tzsp_tunnel for TZSP packets
      tunnel_type = ndpi_tzsp_tunnel;
    }
  }

  // Check for CAPWAP protocol
  if (ntohs(iph->saddr) == 5246 && ntohs(iph->daddr) == 5246) {
    // Check CAPWAP message type
    if (iph->protocol == IPPROTO_UDP && ntohs(iph->protocol) == 5246) {
      // Update IP offset to point to the encapsulated IP header
      ip_offset += sizeof(struct ndpi_udp_header);
      // Set the tunnel type to ndpi_capwap_tunnel for CAPWAP packets
      tunnel_type = ndpi_capwap_tunnel;
    }
  }

  // Check for other tunnel protocols (e.g., L2TP, PPTP) using ports and message types
  // If a tunnel protocol is detected, update the IP offset and set the tunnel type accordingly
  // If no tunnel protocol is detected, set the tunnel type to ndpi_no_tunnel
  if (tunnel_type == ndpi_no_tunnel) {
    // Check for L2TP protocol
    if (ntohs(iph->saddr) == 1701 && ntohs(iph->daddr) == 1701) {
      // Set the tunnel type to ndpi_l2tp_tunnel for L2TP packets
      tunnel_type = ndpi_l2tp_tunnel;
    }
    // Check for PPTP protocol
    else if (ntohs(iph->saddr) == 1723 && ntohs(iph->daddr) == 1723) {
      // Set the tunnel type to ndpi_pptp_tunnel for PPTP packets
      tunnel_type = ndpi_pptp_tunnel;
    }
  }
}