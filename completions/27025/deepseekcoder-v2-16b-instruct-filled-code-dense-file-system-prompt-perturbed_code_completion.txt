// Assign the value from the configuration key-value pair to the appropriate field
        // in the entry structure based on the map type. Handle different data types
        // such as string, integer, double, size, time, boolean, and list. Convert the
        // string value to the required type using utility functions if necessary.
        // For boolean types, validate the value and handle errors by logging and
        // freeing resources. For list types, parse the string into a list, validate
        // the number of entries, and handle errors similarly. Ensure the entry is
        // added to the map's list of multiple values if the map allows multiple entries.
        if (m->type == FLB_CONFIG_MAP_STR) {
            m_str = (char **) (base + m->offset);
            *m_str = kv->val;
        }
        else if (m->type == FLB_CONFIG_MAP_INT) {
            m_i_num = (int *) (base + m->offset);
            *m_i_num = atoi(kv->val);
        }
        else if (m->type == FLB_CONFIG_MAP_DOUBLE) {
            m_d_num = (double *) (base + m->offset);
            *m_d_num = atof(kv->val);
        }
        else if (m->type == FLB_CONFIG_MAP_BOOL) {
            m_bool = (char *) (base + m->offset);
            ret = flb_utils_bool(kv->val);
            if (ret == -1) {
                flb_error("[config map] invalid value for boolean property '%s=%s'",
                          m->name, kv->val);
                return -1;
            }
            *m_bool = ret;
        }
        else if (m->type == FLB_CONFIG_MAP_SIZE) {
            m_s_num = (size_t *) (base + m->offset);
            *m_s_num = flb_utils_size_to_bytes(kv->val);
        }
        else if (m->type == FLB_CONFIG_MAP_TIME) {
            m_i_num = (int *) (base + m->offset);
            *m_i_num = flb_utils_time_to_seconds(kv->val);
        }
        else if (m->type >= FLB_CONFIG_MAP_CLIST ||
                 m->type <= FLB_CONFIG_MAP_SLIST_4) {
            list = parse_string_map_to_list(m, kv->val);
            if (!list) {
                flb_error("[config map] cannot parse list of values '%s'", kv->val);
                flb_free(entry);
                return -1;
            }

            if (m->value.val.list) {
                destroy_map_val(m->type, &m->value);
            }

            m->value.val.list = list;
            m_list = (struct mk_list **) (base + m->offset);
            *m_list = m->value.val.list;
        }