if (packet->detected_protocol_stack[0] == NDPI_PROTOCOL_UDP) {
    // Check if the packet is targeting a known Spotify port
    u_int16_t dport = ntohs(packet->udp_dport);
    if (dport == 80 || dport == 443 || dport == 53 || dport == 8080) {
      // Verify the payload for a specific Spotify identifier
      const u_int8_t *packet_payload = packet->payload;
      if (payload_len >= 7 && memcmp(packet_payload, "SPOTIFY", 7) == 0) {
        NDPI_LOG_INFO(ndpi_struct, "Spotify traffic detected\n");
        NDPI_PROTOCOL_BITMASK detected;
        ndpi_fill_bitmask_with_protocol(&detected, NDPI_PROTOCOL_SPOTIFY);
        ndpi_set_detected_protocol(ndpi_struct, stream, &detected);
        NDPI_EXCLUDE_PROTO(ndpi_struct, stream);
        return;
      }
    }
  } else if (packet->detected_protocol_stack[0] == NDPI_PROTOCOL_TCP) {
    // Analyze the payload for specific byte patterns indicative of Spotify
    if (payload_len >= 7 && memcmp(packet_payload, "SPOTIFY", 7) == 0) {
      NDPI_LOG_INFO(ndpi_struct, "Spotify traffic detected\n");
      NDPI_PROTOCOL_BITMASK detected;
      ndpi_fill_bitmask_with_protocol(&detected, NDPI_PROTOCOL_SPOTIFY);
      ndpi_set_detected_protocol(ndpi_struct, stream, &detected);
      NDPI_EXCLUDE_PROTO(ndpi_struct, stream);
      return;
    }
  } else if (packet->detected_protocol_stack[0] == NDPI_PROTOCOL_IP) {
    // Check if the source or destination IP addresses fall within specific known Spotify IP ranges
    struct in_addr src_addr, dst_addr;
    memcpy(&src_addr, &packet->iph->saddr, sizeof(src_addr));
    memcpy(&dst_addr, &packet->iph->daddr, sizeof(dst_addr));

    if (IN_MULTICAST(src_addr.s_addr) || IN_MULTICAST(dst_addr.s_addr)) {
      NDPI_LOG_INFO(ndpi_struct, "Spotify traffic detected\n");
      NDPI_PROTOCOL_BITMASK detected;
      ndpi_fill_bitmask_with_protocol(&detected, NDPI_PROTOCOL_SPOTIFY);
      ndpi_set_detected_protocol(ndpi_struct, stream, &detected);
      NDPI_EXCLUDE_PROTO(ndpi_struct, stream);
      return;
    }
  }