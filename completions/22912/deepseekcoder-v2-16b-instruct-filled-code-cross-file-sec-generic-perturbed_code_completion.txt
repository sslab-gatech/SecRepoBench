if (packet->detected_protocol_stack[0] == NDPI_PROTOCOL_UDP) {
    // Check if the packet is specifically targeting a known Spotify port
    u_int16_t src_port = ntohs(packet->src_port);
    u_int16_t dst_port = ntohs(packet->dst_port);
    if ((src_port == 8883 || dst_port == 8883) || (src_port == 4070 || dst_port == 4070)) {
      // Verify the payload for a specific Spotify identifier
      const u_int8_t *packet_payload = packet->payload;
      if (payload_len >= 4 && memcmp(packet_payload, "\x01\x00\x00\x00", 4) == 0) {
        NDPI_LOG_INFO(ndpi_struct, "Spotify traffic detected via UDP\n");
        NDPI_SET_PROTOCOL_BITMASK_AS_PROBABLE(stream->considered_protocol_bitmask, NDPI_PROTOCOL_SPOTIFY);
        NDPI_EXCLUDE_PROTO(ndpi_struct, stream);
        return;
      }
    }
  } else if (packet->detected_protocol_stack[0] == NDPI_PROTOCOL_TCP) {
    // Analyze the payload for specific byte patterns indicative of Spotify
    if (payload_len >= 4 && memcmp(packet->payload, "\x01\x00\x00\x00", 4) == 0) {
      NDPI_LOG_INFO(ndpi_struct, "Spotify traffic detected via TCP\n");
      NDPI_SET_PROTOCOL_BITMASK_AS_PROBABLE(stream->considered_protocol_bitmask, NDPI_PROTOCOL_SPOTIFY);
      NDPI_EXCLUDE_PROTO(ndpi_struct, stream);
      return;
    }
  } else if (packet->detected_protocol_stack[0] == NDPI_PROTOCOL_IP) {
    // Check if the source or destination IP addresses fall within specific known Spotify IP ranges
    struct in_addr src_ip = packet->src_ip;
    struct in_addr dst_ip = packet->dst_ip;
    if ((src_ip.s_addr & 0xFF000000) == 0x01000000 || (dst_ip.s_addr & 0xFF000000) == 0x01000000) {
      NDPI_LOG_INFO(ndpi_struct, "Spotify traffic detected via IP range\n");
      NDPI_SET_PROTOCOL_BITMASK_AS_PROBABLE(stream->considered_protocol_bitmask, NDPI_PROTOCOL_SPOTIFY);
      NDPI_EXCLUDE_PROTO(ndpi_struct, stream);
      return;
    }
  }