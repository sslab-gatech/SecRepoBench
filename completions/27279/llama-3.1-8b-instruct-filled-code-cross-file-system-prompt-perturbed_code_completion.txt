// Allocate memory for the response data buffer with a predefined maximum size.
// Check if a proxy is specified and parse its data, updating the client
// structure accordingly. Handle the case where proxy parsing fails.
if (proxy_address) {
    // Parse proxy data
    flb_sds_t proxy_host;
    flb_sds_t proxy_port;
    flb_sds_t proxy_username;
    flb_sds_t proxy_password;

    proxy_host = flb_parse_proxy(proxy_address);
    if (!proxy_host) {
        flb_errno();
        flb_http_client_destroy(c);
        return NULL;
    }

    proxy_port = flb_parse_proxy_port(proxy_address);
    if (!proxy_port) {
        flb_errno();
        flb_http_client_destroy(c);
        return NULL;
    }

    // Update client structure
    c->proxy.host = proxy_host;
    c->proxy.port = proxy_port;

    // Check if proxy requires authentication
    if (u_conn->u->flags & FLB_IO_TCP_PROXY_AUTH) {
        proxy_username = flb_parse_proxy_username(proxy_address);
        if (!proxy_username) {
            flb_errno();
            flb_http_client_destroy(c);
            return NULL;
        }

        proxy_password = flb_parse_proxy_password(proxy_address);
        if (!proxy_password) {
            flb_errno();
            flb_http_client_destroy(c);
            return NULL;
        }

        // Update client structure
        c->proxy.username = proxy_username;
        c->proxy.password = proxy_password;
    }
}
else if (method == FLB_HTTP_CONNECT) {
    // Update client structure
    c->proxy.host = host;
    c->proxy.port = port;
}

// Allocate memory for the response data buffer with a predefined maximum size.
c->resp.data = flb_calloc(1, c->resp.data_size_max);
if (!c->resp.data) {
    flb_errno();
    flb_http_client_destroy(c);
    return NULL;
}
c->resp.data_len  = 0;
c->resp.data_size = c->resp.data_size_max;
c->resp.data_size_max = c->resp.data_size_max;