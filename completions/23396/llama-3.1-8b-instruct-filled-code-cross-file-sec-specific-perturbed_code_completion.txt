// Check if a sequence of two consecutive CR+LF ("\r\n\r\n") is present in the payload
// after the current CR+LF position. If found, calculate the remaining payload length
// beyond the sequence. Limit this length to the size of the initial_binary_bytes
// buffer and copy the data into it. Update the length of the copied data in
// initial_binary_bytes_len.
u_int16_t remaining_len = 0;
u_int16_t remaining_len_limit = (u_int16_t) (packet->payload_packet_len - (a + 2));
u_int16_t i;
for (i = a + 2; i < packet->payload_packet_len && i < remaining_len_limit; i++) {
  if ((packet->payload[i] == 0x0d) && (packet->payload[i + 1] == 0x0a)) {
    remaining_len = i - (a + 2);
    break;
  }
}
if (remaining_len > 0) {
  packet->line[packet->parsed_lines].len = (u_int16_t) (remaining_len);
  packet->line[packet->parsed_lines].ptr = &packet->payload[a + 2];
}