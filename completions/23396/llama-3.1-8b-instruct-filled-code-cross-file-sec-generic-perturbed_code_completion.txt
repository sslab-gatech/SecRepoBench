// Check if a sequence of two consecutive CR+LF ("\r\n\r\n") is present in the payload
// after the current CR+LF position. If found, calculate the remaining payload length
// beyond the sequence. Limit this length to the size of the initial_binary_bytes
// buffer and copy the data into it. Update the length of the copied data in
// initial_binary_bytes_len.
u_int16_t remaining_len = 0;
u_int16_t crlf_pos = a + 1;
while (crlf_pos < packet->payload_packet_len && packet->payload[crlf_pos] == 0x0d && packet->payload[crlf_pos + 1] == 0x0a) {
  crlf_pos += 2;
}
if (crlf_pos < packet->payload_packet_len) {
  remaining_len = packet->payload_packet_len - crlf_pos;
  if (remaining_len > NDPI_MAX_INITIAL_BINARY_BYTES) {
    remaining_len = NDPI_MAX_INITIAL_BINARY_BYTES;
  }
  memcpy(&packet->initial_binary_bytes[0], &packet->payload[crlf_pos], remaining_len);
  packet->initial_binary_bytes_len = remaining_len;
}