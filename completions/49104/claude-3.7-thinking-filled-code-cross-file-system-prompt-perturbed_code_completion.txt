assert(exception != (ExceptionInfo *) NULL);
p=(const MagicInfo *) NULL;
/*
  Initialize magic list and cache if needed
*/
if (IsMagicCacheInstantiated() == MagickFalse)
  return((const MagicInfo *) NULL);
if (magic_list == (LinkedListInfo *) NULL)
  {
    if (magic_list_semaphore == (SemaphoreInfo *) NULL)
      ActivateSemaphoreInfo(&magic_list_semaphore);
    LockSemaphoreInfo(magic_list_semaphore);
    if (magic_list == (LinkedListInfo *) NULL)
      magic_list=NewLinkedList(0);
    UnlockSemaphoreInfo(magic_list_semaphore);
  }
/*
  Search the magic cache for matching magic
*/
if (magic != (const unsigned char *) NULL)
  {
    LockSemaphoreInfo(magic_cache_semaphore);
    ResetLinkedListIterator(magic_cache);
    p=(const MagicInfo *) GetNextValueInLinkedList(magic_cache);
    while (p != (const MagicInfo *) NULL)
    {
      if ((p->offset+p->length) <= size)
        {
          if ((p->length == 0) ||
              (memcmp(magic+p->offset,p->magic,p->length) == 0))
            break;
        }
      p=(const MagicInfo *) GetNextValueInLinkedList(magic_cache);
    }
    UnlockSemaphoreInfo(magic_cache_semaphore);
    if (p != (const MagicInfo *) NULL)
      return(p);
  }
/*
  Search the list of magic for a match
*/
LockSemaphoreInfo(magic_list_semaphore);
ResetLinkedListIterator(magic_list);
p=(const MagicInfo *) GetNextValueInLinkedList(magic_list);
while (p != (const MagicInfo *) NULL)
{
  if ((p->offset+p->length) <= size)
    {
      if ((p->length == 0) ||
          (memcmp(magic+p->offset,p->magic,p->length) == 0))
        break;
    }
  p=(const MagicInfo *) GetNextValueInLinkedList(magic_list);
}