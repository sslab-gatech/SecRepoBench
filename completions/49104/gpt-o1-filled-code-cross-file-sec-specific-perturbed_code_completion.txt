if (exception == (ExceptionInfo *) NULL)
  return((const MagicInfo *) NULL);

(void) IsMagicCacheInstantiated();
p=(const MagicInfo *) NULL;

/* Search the cache if magic is provided. */
if ((magic != (const unsigned char *) NULL) && (size > 0) &&
    (magic_cache != (LinkedListInfo *) NULL))
  {
    LockSemaphoreInfo(magic_cache_semaphore);
    ResetLinkedListIterator(magic_cache);
    for (const MagicInfo *cache_info=(const MagicInfo *) GetNextValueInLinkedList(magic_cache);
         cache_info != (const MagicInfo *) NULL;
         cache_info=(const MagicInfo *) GetNextValueInLinkedList(magic_cache))
      {
        /*
          Compare only up to cache_info->length to avoid any buffer
          overflow and ensure the provided data is long enough.
        */
        if ((cache_info->length <= size) &&
            (memcmp(magic, cache_info->magic, cache_info->length) == 0))
          {
            p=cache_info;
            break;
          }
      }
    UnlockSemaphoreInfo(magic_cache_semaphore);
  }

/* If not found in cache (or magic was null), search the main list. */
if (p == (const MagicInfo *) NULL)
  {
    LockSemaphoreInfo(magic_list_semaphore);
    ResetLinkedListIterator(magic_list);
    for (const MagicInfo *list_info=(const MagicInfo *) GetNextValueInLinkedList(magic_list);
         list_info != (const MagicInfo *) NULL;
         list_info=(const MagicInfo *) GetNextValueInLinkedList(magic_list))
      {
        if ((magic != (const unsigned char *) NULL) && (size > 0) &&
            (list_info->length <= size) &&
            (memcmp(magic, list_info->magic, list_info->length) == 0))
          {
            p=list_info;
            break;
          }
      }
  }