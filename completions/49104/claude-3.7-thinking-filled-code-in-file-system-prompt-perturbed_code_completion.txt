assert(exception != (ExceptionInfo *) NULL);
if (IsMagicListInstantiated(exception) == MagickFalse)
  return((const MagicInfo *) NULL);

p=(const MagicInfo *) NULL;  /* Initialize p to NULL */

if (magic != (const unsigned char *) NULL)
  {
    /* Check the cache first */
    if (IsMagicCacheInstantiated() != MagickFalse)
      {
        LockSemaphoreInfo(magic_cache_semaphore);
        ResetLinkedListIterator(magic_cache);
        p=(const MagicInfo *) GetNextValueInLinkedList(magic_cache);
        while (p != (const MagicInfo *) NULL)
          {
            if (MatchesMagic(magic,size,p) != MagickFalse)
              break;
            p=(const MagicInfo *) GetNextValueInLinkedList(magic_cache);
          }
        UnlockSemaphoreInfo(magic_cache_semaphore);
        if (p != (const MagicInfo *) NULL)
          return(p);
      }
    
    /* If not found in cache, check the main list */
    LockSemaphoreInfo(magic_list_semaphore);
    ResetLinkedListIterator(magic_list);
    p=(const MagicInfo *) GetNextValueInLinkedList(magic_list);
    while (p != (const MagicInfo *) NULL)
      {
        if (MatchesMagic(magic,size,p) != MagickFalse)
          break;
        p=(const MagicInfo *) GetNextValueInLinkedList(magic_list);
      }
  }
  else
    {
      /* If no magic provided, just return the first entry in the list */
      LockSemaphoreInfo(magic_list_semaphore);
      ResetLinkedListIterator(magic_list);
      p=(const MagicInfo *) GetNextValueInLinkedList(magic_list);
    }