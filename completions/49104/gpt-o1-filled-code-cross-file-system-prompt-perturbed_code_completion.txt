assert(exception != (ExceptionInfo *) NULL);
  (void) IsMagicCacheInstantiated();
  p=(const MagicInfo *) NULL;

  /*
    If 'magic' is non-null, attempt to locate an existing match in
    the cached magic entries.
  */
  if ((magic != (const unsigned char *) NULL) && (size != 0))
    {
      register const MagicInfo
        *q;

      LockSemaphoreInfo(magic_cache_semaphore);
      for (q=(const MagicInfo *) GetLinkedListHead(magic_cache);
           q != (const MagicInfo *) NULL;
           q=(const MagicInfo *) GetNextValueInLinkedList(magic_cache))
        {
          if ((q->extent <= size) &&
              (memcmp(magic,q->magic,q->extent) == 0))
            {
              p=q;
              break;
            }
        }
      UnlockSemaphoreInfo(magic_cache_semaphore);
    }

  /*
    If the cached search failed or 'magic' is null, search the main
    magic list for any matching entries.
  */
  if (p == (const MagicInfo *) NULL)
    {
      if (magic_list_semaphore == (SemaphoreInfo *) NULL)
        ActivateSemaphoreInfo(&magic_list_semaphore);
      LockSemaphoreInfo(magic_list_semaphore);
      if ((magic != (const unsigned char *) NULL) && (size != 0))
        {
          register const MagicInfo
            *q;

          for (q=(const MagicInfo *) GetLinkedListHead(magic_list);
               q != (const MagicInfo *) NULL;
               q=(const MagicInfo *) GetNextValueInLinkedList(magic_list))
            {
              if ((q->extent <= size) &&
                  (memcmp(magic,q->magic,q->extent) == 0))
                {
                  p=q;
                  break;
                }
            }
        }
    }