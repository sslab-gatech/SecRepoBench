p=(const MagicInfo *) NULL;
if (magic != (const unsigned char *) NULL)
  {
    LockSemaphoreInfo(magic_cache_semaphore);
    {
      size_t i;
      const size_t count=GetLinkedListLength(magic_cache);
      for (i=0; i < count; i++)
      {
        const MagicInfo *magic_info=(const MagicInfo *) GetLinkedListValue(magic_cache,i);
        if (magic_info != (const MagicInfo *) NULL)
          {
            /* Ensure we do not read past the provided magic buffer. */
            if (magic_info->length <= size)
              {
                if (memcmp(magic,magic_info->magic,magic_info->length) == 0)
                  {
                    p=magic_info;
                    break;
                  }
              }
          }
      }
    }
    UnlockSemaphoreInfo(magic_cache_semaphore);
  }
if (p == (const MagicInfo *) NULL)
  {
    LockSemaphoreInfo(magic_list_semaphore);
    {
      size_t i;
      const size_t count=GetLinkedListLength(magic_list);
      for (i=0; i < count; i++)
      {
        const MagicInfo *magic_info=(const MagicInfo *) GetLinkedListValue(magic_list,i);
        if (magic_info != (const MagicInfo *) NULL)
          {
            /* Prevent heap over-read by ensuring our input is large enough. */
            if (magic_info->length <= size)
              {
                if (memcmp(magic,magic_info->magic,magic_info->length) == 0)
                  {
                    p=magic_info;
                    break;
                  }
              }
          }
      }
    }
  }