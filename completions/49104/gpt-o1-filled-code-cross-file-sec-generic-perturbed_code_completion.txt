assert(exception != (ExceptionInfo *) NULL);
  p = (const MagicInfo *) NULL;

  /*
    If magic is not null, search the cached magic entries for a match.
  */
  if ((magic != (unsigned char *) NULL) &&
      (IsMagicCacheInstantiated() != MagickFalse))
    {
      const MagicInfo
        *cache_info;

      LockSemaphoreInfo(magic_cache_semaphore);
      for (cache_info = (const MagicInfo *) GetValueFromLinkedListHead(magic_cache);
           cache_info != (const MagicInfo *) NULL;
           cache_info = (const MagicInfo *) GetNextValueInLinkedList(magic_cache))
        {
          if ((cache_info->signature == MagickCoreSignature) &&
              (cache_info->extent <= size) &&
              (memcmp(magic, cache_info->magic, cache_info->extent) == 0))
            {
              p = cache_info;
              UnlockSemaphoreInfo(magic_cache_semaphore);
              return p;
            }
        }
      UnlockSemaphoreInfo(magic_cache_semaphore);
    }

  /*
    If no match in the cache or magic is null, proceed to the main magic list.
  */
  LockSemaphoreInfo(magic_list_semaphore);
  if (magic != (const unsigned char *) NULL)
    {
      const MagicInfo
        *list_info;

      for (list_info = (const MagicInfo *) GetValueFromLinkedListHead(magic_list);
           list_info != (const MagicInfo *) NULL;
           list_info = (const MagicInfo *) GetNextValueInLinkedList(magic_list))
        {
          if ((list_info->signature == MagickCoreSignature) &&
              (list_info->extent <= size) &&
              (memcmp(magic, list_info->magic, list_info->extent) == 0))
            {
              p = list_info;
              break;
            }
        }
    }