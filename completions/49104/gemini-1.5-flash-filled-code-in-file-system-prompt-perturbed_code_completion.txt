if (exception == (ExceptionInfo *) NULL)
    return((const MagicInfo *) NULL);
  if (IsMagicListInstantiated(exception) == MagickFalse)
    return((const MagicInfo *) NULL);
  if (magic == (const unsigned char *) NULL)
    {
      LockSemaphoreInfo(magic_list_semaphore);
      p=(const MagicInfo *) GetNextValueInLinkedList(magic_list);
      UnlockSemaphoreInfo(magic_list_semaphore);
      return(p);
    }
  if (IsMagicCacheInstantiated() == MagickFalse)
    {
      LockSemaphoreInfo(magic_list_semaphore);
      ResetLinkedListIterator(magic_list);
      for (p=(const MagicInfo *) GetNextValueInLinkedList(magic_list);
           p != (const MagicInfo *) NULL;
           p=(const MagicInfo *) GetNextValueInLinkedList(magic_list))
        if (MatchesMagic(magic,size,p) != MagickFalse)
          break;
      UnlockSemaphoreInfo(magic_list_semaphore);
      return(p);
    }
  LockSemaphoreInfo(magic_cache_semaphore);
  ResetLinkedListIterator(magic_cache);
  for (p=(const MagicInfo *) GetNextValueInLinkedList(magic_cache);
       p != (const MagicInfo *) NULL;
       p=(const MagicInfo *) GetNextValueInLinkedList(magic_cache))
    if (MatchesMagic(magic,size,p) != MagickFalse)
      break;
  if (p == (const MagicInfo *) NULL)
    {
      LockSemaphoreInfo(magic_list_semaphore);
      ResetLinkedListIterator(magic_list);
      for (p=(const MagicInfo *) GetNextValueInLinkedList(magic_list);
           p != (const MagicInfo *) NULL;
           p=(const MagicInfo *) GetNextValueInLinkedList(magic_list))
        if (MatchesMagic(magic,size,p) != MagickFalse)
          break;
      UnlockSemaphoreInfo(magic_list_semaphore);
    }