assert(exception != (ExceptionInfo *) NULL);

if (IsMagicListInstantiated(exception) == MagickFalse)
{
  p = (const MagicInfo *) NULL;
  /*
    Lock so the caller can safely unlock outside this block.
  */
  LockSemaphoreInfo(magic_list_semaphore);
  goto MagicInfoDone;
}

(void) IsMagicCacheInstantiated();
p = (const MagicInfo *) NULL;
/*
  Lock the magic list prior to searching.
*/
LockSemaphoreInfo(magic_list_semaphore);

/*
  Only attempt matching if we have a non-empty signature.
*/
if ((magic != (const unsigned char *) NULL) && (size != 0))
{
  /*
    First, search our cache for a match.
  */
  LockSemaphoreInfo(magic_cache_semaphore);
  ResetLinkedListIterator(magic_cache);
  {
    const MagicInfo *entry;
    while ((entry = (const MagicInfo *) GetNextValueInLinkedList(magic_cache)) != (const MagicInfo *) NULL)
    {
      if (MatchesMagic(magic, size, entry) != MagickFalse)
      {
        p = entry;
        break;
      }
    }
  }
  UnlockSemaphoreInfo(magic_cache_semaphore);

  /*
    If not found in cache, search the main magic list.
  */
  if (p == (const MagicInfo *) NULL)
  {
    ResetLinkedListIterator(magic_list);
    {
      const MagicInfo *entry;
      while ((entry = (const MagicInfo *) GetNextValueInLinkedList(magic_list)) != (const MagicInfo *) NULL)
      {
        if (MatchesMagic(magic, size, entry) != MagickFalse)
        {
          p = entry;
          break;
        }
      }
    }
  }
}

MagicInfoDone: