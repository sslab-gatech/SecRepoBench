{
  /* Safely compute the component sample index, taking downsampling into account. */
  const size_t offset = (size_t)
    (
      (y / jp2_image->comps[i].dy) *
      (jp2_image->comps[i].w / jp2_image->comps[i].dx) +
      (columnindex / jp2_image->comps[i].dx)
    );

  /* Ensure we do not read beyond the buffer. */
  if (offset < (size_t)jp2_image->comps[i].w * jp2_image->comps[i].h)
  {
    double sample_value = (double) jp2_image->comps[i].data[offset];

    /* Adjust for signed data, if necessary. */
    if (jp2_image->comps[i].sgnd != 0)
      sample_value += (1UL << (jp2_image->comps[i].prec - 1));

    /* Clamp sample_value within the valid range. */
    if (sample_value < 0.0)
      sample_value = 0.0;
    else if (sample_value > (double)((1UL << jp2_image->comps[i].prec) - 1))
      sample_value = (double)((1UL << jp2_image->comps[i].prec) - 1);

    /* Scale to Quantum range. */
    scale = (double) QuantumRange /
      (double) ((1UL << jp2_image->comps[i].prec) - 1);
    pixel = scale * sample_value;
  }
  else
    /* Fallback in case of unexpected index. */
    pixel = 0.0;
}