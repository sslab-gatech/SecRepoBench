/* Allocate memory for coefficients and points based on the number of coordinates and a quantum value.
   * Calculate the number of control points to be used for Bezier curve computation.
   * Check for memory allocation failure and handle errors if necessary.
   * Ensure that the primitive extent can accommodate the computed control points.
   */
  coefficients = (double *) AcquireQuantumMemory(number_coordinates, sizeof(double));
  if (coefficients == (double *) NULL)
  {
    (void) ThrowMagickException(bezierinfo->exception, GetMagickModule(),
      ResourceLimitError, "MemoryAllocationFailed", "`%s`", "");
    return (MagickFalse);
  }

  points = (PointInfo *) AcquireQuantumMemory(number_coordinates, sizeof(PointInfo));
  if (points == (PointInfo *) NULL)
  {
    (void) ThrowMagickException(bezierinfo->exception, GetMagickModule(),
      ResourceLimitError, "MemoryAllocationFailed", "`%s`", "");
    (void) RelinquishMagickMemory(coefficients);
    return (MagickFalse);
  }

  control_points = number_coordinates;

  /*
    Compute bezier points.
  */
  end = primitive_info[number_coordinates - 1].point;
  for (i = 0; i < (ssize_t) number_coordinates; i++)
    coefficients[i] = Permutate((ssize_t) number_coordinates - 1, i);
  weight = 0.0;
  for (i = 0; i < (ssize_t) control_points; i++)
  {
    p = primitive_info;
    point.x = 0.0;
    point.y = 0.0;
    alpha = pow((double) (1.0 - weight), (double) number_coordinates - 1.0);
    for (j = 0; j < (ssize_t) number_coordinates; j++)
    {
      point.x += alpha * coefficients[j] * p->point.x;
      point.y += alpha * coefficients[j] * p->point.y;
      alpha *= weight / (1.0 - weight);
      p++;
    }
    points[i] = point;
    weight += 1.0 / control_points;
  }

  /*
    Bezier curves are just short segmented polys.
  */
  p = primitive_info;
  for (i = 0; i < (ssize_t) control_points; i++)
  {
    if (TracePoint(p, points[i]) == MagickFalse)
    {
      points = (PointInfo *) RelinquishMagickMemory(points);
      coefficients = (double *) RelinquishMagickMemory(coefficients);
      return (MagickFalse);
    }
    p += p->coordinates;
  }
  if (TracePoint(p, end) == MagickFalse)
  {
    points = (PointInfo *) RelinquishMagickMemory(points);
    coefficients = (double *) RelinquishMagickMemory(coefficients);
    return (MagickFalse);
  }
  p += p->coordinates;
  primitive_info->coordinates = (size_t) (p - primitive_info);
  primitive_info->closed_subpath = MagickFalse;
  for (i = 0; i < (ssize_t) primitive_info->coordinates; i++)
  {
    p->primitive = primitive_info->primitive;
    p--;
  }
  points = (PointInfo *) RelinquishMagickMemory(points);
  coefficients = (double *) RelinquishMagickMemory(coefficients);
  return (MagickTrue);