// Allocate memory for coefficients and points based on the number of coordinates and a quantum value.
// Calculate the number of control points to be used for Bezier curve computation.
// Check for memory allocation failure and handle errors if necessary.
// Ensure that the primitive extent can accommodate the computed control points.
coefficients=(double *) AcquireMagickMemory((size_t) number_coordinates * sizeof(double));
if (coefficients == (double *) NULL)
  {
    (void) ThrowMagickException(bezierinfo->exception,GetMagickModule(),
      ResourceLimitError,"MemoryAllocationFailed","`%s'","");
    return(MagickFalse);
  }
points=(PointInfo *) AcquireMagickMemory((size_t) control_points * sizeof(PointInfo));
if (points == (PointInfo *) NULL)
  {
    (void) ThrowMagickException(bezierinfo->exception,GetMagickModule(),
      ResourceLimitError,"MemoryAllocationFailed","`%s'","");
    coefficients=(double *) RelinquishMagickMemory(coefficients);
    return(MagickFalse);
  }
control_points=0;
quantum=number_coordinates;
for (i=0; i < (ssize_t) number_coordinates; i++)
  {
    for (j=i+1; j < (ssize_t) number_coordinates; j++)
      {
        alpha=fabs(primitive_info[j].point.x-primitive_info[i].point.x);
        if (alpha > (double) SSIZE_MAX)
          {
            (void) ThrowMagickException(bezierinfo->exception,GetMagickModule(),
              ResourceLimitError,"MemoryAllocationFailed","`%s'","");
            coefficients=(double *) RelinquishMagickMemory(coefficients);
            points=(PointInfo *) RelinquishMagickMemory(points);
            return(MagickFalse);
          }
        if (alpha > (double) quantum)
          quantum=(size_t) alpha;
        alpha=fabs(primitive_info[j].point.y-primitive_info[i].point.y);
        if (alpha > (double) SSIZE_MAX)
          {
            (void) ThrowMagickException(bezierinfo->exception,GetMagickModule(),
              ResourceLimitError,"MemoryAllocationFailed","`%s'","");
            coefficients=(double *) RelinquishMagickMemory(coefficients);
            points=(PointInfo *) RelinquishMagickMemory(points);
            return(MagickFalse);
          }
        if (alpha > (double) quantum)
          quantum=(size_t) alpha;
      }
  }
if (CheckPrimitiveExtent(bezierinfo,PrimitiveExtentPad) == MagickFalse)
  {
    coefficients=(double *) RelinquishMagickMemory(coefficients);
    points=(PointInfo *) RelinquishMagickMemory(points);
    return(MagickFalse);
  }