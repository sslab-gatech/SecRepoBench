// Allocate memory for coefficients and points based on the number of coordinates and a quantum value.
  // Calculate the number of control points to be used for Bezier curve computation.
  // Check for memory allocation failure and handle errors if necessary.
  // Ensure that the primitive extent can accommodate the computed control points.
  coefficients = (double *) AcquireQuantumMemory(number_coordinates, sizeof(double));
  if (coefficients == NULL) {
    (void) ThrowMagickException(bezierinfo->exception, GetMagickModule(),
      ResourceLimitError, "MemoryAllocationFailed", "`%s`", "");
    return MagickFalse;
  }

  points = (PointInfo *) AcquireQuantumMemory(control_points, sizeof(PointInfo));
  if (points == NULL) {
    (void) ThrowMagickException(bezierinfo->exception, GetMagickModule(),
      ResourceLimitError, "MemoryAllocationFailed", "`%s`", "");
    RelinquishMagickMemory(coefficients);
    return MagickFalse;
  }

  // Compute bezier points.
  end = primitive_info[number_coordinates - 1].point;
  for (i = 0; i < (ssize_t) number_coordinates; i++)
    coefficients[i] = Permutate((ssize_t) number_coordinates - 1, i);
  weight = 0.0;
  for (i = 0; i < (ssize_t) control_points; i++) {
    p = primitive_info;
    point.x = 0.0;
    point.y = 0.0;
    alpha = pow((double) (1.0 - weight), (double) number_coordinates - 1.0);
    for (j = 0; j < (ssize_t) number_coordinates; j++) {
      point.x += alpha * coefficients[j] * p->point.x;
      point.y += alpha * coefficients[j] * p->point.y;
      alpha *= weight / (1.0 - weight);
      p++;
    }
    points[i] = point;
    weight += 1.0 / control_points;
  }

  // Bezier curves are just short segmented polys.
  p = primitive_info;
  for (i = 0; i < (ssize_t) control_points; i++) {
    if (TracePoint(p, points[i]) == MagickFalse) {
      RelinquishMagickMemory(points);
      RelinquishMagickMemory(coefficients);
      return MagickFalse;
    }
    p += p->coordinates;
  }
  if (TracePoint(p, end) == MagickFalse) {
    RelinquishMagickMemory(points);
    RelinquishMagickMemory(coefficients);
    return MagickFalse;
  }
  p += p->coordinates;
  primitive_info->coordinates = (size_t) (p - primitive_info);
  primitive_info->closed_subpath = MagickFalse;
  for (i = 0; i < (ssize_t) primitive_info->coordinates; i++) {
    p->primitive = primitive_info->primitive;
    p--;
  }
  RelinquishMagickMemory(points);
  RelinquishMagickMemory(coefficients);
  return MagickTrue;