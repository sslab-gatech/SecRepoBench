// <MASK>
if(is_utpv1_pkt(packet->payload, packet->payload_packet_len)) {
  const char *bt_proto = ndpi_strnstr((const char *)packet->payload, BITTORRENT_PROTO_STRING, packet->payload_packet_len);
  if(bt_proto != NULL && ((u_int8_t *)&bt_proto[27] - packet->payload + sizeof(flow->protos.bittorrent.hash)) < packet->payload_packet_len) {
    memcpy(flow->protos.bittorrent.hash, &bt_proto[27], sizeof(flow->protos.bittorrent.hash));
    flow->extra_packets_func = NULL; /* Nothing else to do */
    NDPI_LOG_INFO(detectionmodule, "found BT: uTP\n");
    ndpi_add_connection_as_bittorrent(detectionmodule, flow, -1, 0, NDPI_CONFIDENCE_DPI);
    return;
  }
}

/* Check for other BitTorrent patterns */
if(packet->payload_packet_len >= 8 && memcmp(packet->payload, "GET /get?", 9) == 0) {
  NDPI_LOG_INFO(detectionmodule, "found BT: plain\n");
  ndpi_add_connection_as_bittorrent(detectionmodule, flow, -1, 1, NDPI_CONFIDENCE_DPI);
  return;
}

if(packet->payload_packet_len >= 8 && memcmp(packet->payload, "GET /file", 8) == 0) {
  NDPI_LOG_INFO(detectionmodule, "found BT: plain\n");
  ndpi_add_connection_as_bittorrent(detectionmodule, flow, -1, 1, NDPI_CONFIDENCE_DPI);
  return;
}

if(packet->payload_packet_len >= 23 && memcmp(packet->payload, "GET /announce?info_hash=", 23) == 0) {
  NDPI_LOG_INFO(detectionmodule, "found BT: plain\n");
  ndpi_add_connection_as_bittorrent(detectionmodule, flow, -1, 1, NDPI_CONFIDENCE_DPI);
  return;
}

/* No BitTorrent pattern found, exclude the protocol */
ndpi_skip_bittorrent(detectionmodule, flow, packet);