// Iterate over directory entries in the buffer while there is data to process.
while (step) {
    // Iterate over directory entries in the buffer while there is data to process.
    for (p = b; p < b + step; p += reclen) {
        // Parse the directory entry and add it to the archive structure.
        file = parse_file_info(a, parent, p, reclen);
        if (file == NULL)
            return (ARCHIVE_FATAL);
        // Skip entries for '.' and '..' directories.
        if (strcmp(file->name.s, ".") == 0 || strcmp(file->name.s, "..") == 0) {
            continue;
        }
        // Manage multi-extent files by collecting their contents into a list.
        if (file->multi_extent) {
            struct content *con;

            con = (struct content *)calloc(1, sizeof(*con));
            if (con == NULL) {
                archive_set_error(&a->archive, ENOMEM,
                    "No memory for file extent");
                return (ARCHIVE_FATAL);
            }
            con->offset = file->offset;
            con->size = file->size;
            con->next = NULL;
            *file->contents.last = con;
            file->contents.last = &(con->next);
            file->offset = -1;
            file->size = 0;
            file->multi_extent = 0;
        }
        // Add the directory entry to the archive structure.
        if (add_entry(a, iso9660, file)!= ARCHIVE_OK)
            return (ARCHIVE_FATAL);
        reclen = (size_t)isodirrec[DR_length_offset];
    }
    // Consume the buffer.
    __archive_read_consume(a, step);
    iso9660->current_position += step;
}