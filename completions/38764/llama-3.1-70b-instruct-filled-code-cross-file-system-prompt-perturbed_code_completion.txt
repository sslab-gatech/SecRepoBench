p = b;
while (step) {
    struct file_info *file;
    int entry_size;

    if (step < 34) {
        archive_set_error(&archivereader->archive, ARCHIVE_ERRNO_MISC,
            "Directory entry too short");
        return (ARCHIVE_FATAL);
    }
    entry_size = (int)b[0];
    if (entry_size == 0) {
        /* Empty entry, skip it. */
        break;
    }
    if (entry_size > step) {
        archive_set_error(&archivereader->archive, ARCHIVE_ERRNO_MISC,
            "Directory entry extends past end of buffer");
        return (ARCHIVE_FATAL);
    }
    file = parse_entry(iso9660, p, entry_size);
    if (file == NULL) {
        /* Skip entries for '.' and '..' directories. */
        if (p[1] == 1 || p[1] == 2) {
            p += entry_size;
            step -= entry_size;
            continue;
        }
        return (ARCHIVE_FATAL);
    }
    if (file->mode & AE_IFMT) {
        if ((file->mode & AE_IFMT) == AE_IFDIR) {
            if (file->name.s[0] == 0) {
                /* Skip entries for '.' and '..' directories. */
                p += entry_size;
                step -= entry_size;
                continue;
            }
            if (file->name.s[0] == 1) {
                /* Skip entries for '.' and '..' directories. */
                p += entry_size;
                step -= entry_size;
                continue;
            }
        }
    }
    if (file->pz) {
        /* Manage multi-extent files by collecting their contents into a list. */
        if (multi == NULL) {
            multi = file;
        } else {
            struct file_info *last;

            last = multi;
            while (last->next!= NULL)
                last = last->next;
            last->next = file;
        }
    } else {
        if (multi!= NULL) {
            /* For each valid directory entry, add it to the archive structure. */
            add_file(iso9660, multi);
            multi = NULL;
        }
        /* For each valid directory entry, add it to the archive structure. */
        add_file(iso9660, file);
    }
    p += entry_size;
    step -= entry_size;
}