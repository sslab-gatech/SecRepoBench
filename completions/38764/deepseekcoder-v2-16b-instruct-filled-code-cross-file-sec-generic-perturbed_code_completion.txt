// Iterate over directory entries in the buffer while there is data to process.
// For each directory entry, parse its file information, and handle special cases:
// - Skip entries for '.' and '..' directories.
// - Manage multi-extent files by collecting their contents into a list.
// - For each valid directory entry, add it to the archive structure.
// - Handle memory allocation and error management for multi-extent file handling.

const unsigned char *entry_data = b;
size_t entry_data_size = step;
size_t processed_size = 0;

while (processed_size < entry_data_size) {
    struct file_info *new_file = NULL;
    size_t entry_size = *(size_t *)(entry_data + processed_size);
    processed_size += sizeof(size_t);

    if (entry_size == 0) {
        break;
    }

    new_file = (struct file_info *)malloc(entry_size);
    if (new_file == NULL) {
        archive_set_error(&archivereader->archive, ENOMEM, "No memory");
        return (ARCHIVE_FATAL);
    }

    memcpy(new_file, entry_data + processed_size, entry_size);
    processed_size += entry_size;

    if (new_file->mode & AE_IFDIR) {
        if (strcmp(new_file->name.s, ".") == 0 || strcmp(new_file->name.s, "..") == 0) {
            free(new_file);
            continue;
        }
    }

    // Add the new file to the archive structure
    // This part depends on how you manage file entries in your archive structure
    // For example:
    // archive_add_entry(archivereader, new_file);

    // Handle multi-extent files
    if (new_file->re) {
        // Collect contents into a list
        struct file_content *content = new_file->contents.first;
        while (content != NULL) {
            // Add content to the archive structure
            // This part depends on how you manage file contents in your archive structure
            // For example:
            // archive_add_content(archivereader, content);

            content = content->next;
        }
    }

    // Add the new file to the list of cached files
    cache_add_entry(iso9660, new_file);
}