p = b + (b - (unsigned char *)0) % iso9660->logical_block_size;
		while (p + 33 < b + skip_size) {
			size_t reclen;
			struct file_info *child;

			reclen = p[DR_length_offset];
			/* Skip entries for '.' and '..' directories. */
			if (reclen == 1 || reclen == 3) {
				p += reclen;
				continue;
			}
			child = parse_file_info(archivereader, parent, p, skip_size);
			if (child == NULL)
				return (ARCHIVE_FATAL);
			if (child->multi_extent) {
				struct content *con;

				/* Allocate memory for a new content entry. */
				con = (struct content *)malloc(sizeof(*con));
				if (con == NULL) {
					archive_set_error(&archivereader->archive, ENOMEM,
					    "No memory for multi-extent file content");
					return (ARCHIVE_FATAL);
				}
				con->offset = child->offset;
				con->size = child->size;
				con->next = NULL;
				/* Add the content entry to the list. */
				*child->contents.last = con;
				child->contents.last = &(con->next);
				/* Adjust the size of the current extent. */
				child->size = 0;
				/* Add the child to the archive structure. */
				add_entry(archivereader, iso9660, child);
			} else {
				/* Add the child to the archive structure. */
				add_entry(archivereader, iso9660, child);
			}
			p += reclen;
			step -= reclen;
		}
		skip_size -= (b + skip_size - p);
		b = p;