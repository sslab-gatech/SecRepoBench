p = b;
while (step > 0) {
    struct file_info *file;
    size_t entry_size;

    if (p + 1 >= b + step)
        break;
    entry_size = p[0];
    if (entry_size == 0) {
        /* Zero-length entry indicates end of directory. */
        step = 0;
        break;
    }
    if (entry_size < LOGICAL_BLOCK_SIZE && p + entry_size <= b + step) {
        file = parse_file_info(archivereader, iso9660, p, entry_size);
        if (file == NULL) {
            archive_set_error(&archivereader->archive, ARCHIVE_ERRNO_MISC,
                "Failed to parse file info");
            return (ARCHIVE_FATAL);
        }
        if (strcmp(file->name.s, ".") != 0 && strcmp(file->name.s, "..") != 0) {
            if (file->multi_extent) {
                if (multi == NULL) {
                    multi = file;
                } else {
                    multi->next = file;
                    multi = file;
                }
            } else {
                if (add_entry(archivereader, iso9660, parent, file) != ARCHIVE_OK) {
                    return (ARCHIVE_FATAL);
                }
            }
        } else {
            free_file(file);
        }
        p += entry_size;
        step -= entry_size;
    } else {
        p += LOGICAL_BLOCK_SIZE;
        step -= LOGICAL_BLOCK_SIZE;
    }
}

if (multi != NULL) {
    struct file_info *file, *next;

    file = multi;
    while (file != NULL) {
        next = file->next;
        if (add_entry(archivereader, iso9660, parent, file) != ARCHIVE_OK) {
            while (next != NULL) {
                file = next;
                next = file->next;
                free_file(file);
            }
            return (ARCHIVE_FATAL);
        }
        file = next;
    }
}