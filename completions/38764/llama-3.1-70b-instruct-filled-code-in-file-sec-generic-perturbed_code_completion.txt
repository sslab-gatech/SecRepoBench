// Iterate over directory entries in the buffer while there is data to process.
while (step) {
    // Iterate over directory entries in the buffer while there is data to process.
    for (p = b; p < b + step; p += reclen) {
        // Parse the current directory entry.
        file = parse_file_info(a, parent, p, reclen);
        if (file == NULL)
            return (ARCHIVE_FATAL);

        // Skip entries for '.' and '..' directories.
        if (strcmp(file->name.s, ".") == 0 || strcmp(file->name.s, "..") == 0) {
            continue;
        }

        // Manage multi-extent files by collecting their contents into a list.
        if (file->multi_extent) {
            struct content *con;

            con = (struct content *)calloc(1, sizeof(*con));
            if (con == NULL) {
                archive_set_error(&a->archive, ENOMEM, "No memory for file extent");
                return (ARCHIVE_FATAL);
            }
            con->offset = file->offset;
            con->size = file->size;
            con->next = NULL;
            if (file->contents.first == NULL) {
                file->contents.first = con;
                file->contents.last = &(file->contents.first);
            } else {
                *file->contents.last = con;
                file->contents.last = &(con->next);
            }
            file->offset = -1;
            file->size = 0;
        }

        // For each valid directory entry, add it to the archive structure.
        if (add_entry(a, iso9660, file)!= ARCHIVE_OK)
            return (ARCHIVE_FATAL);
    }

    // Handle memory allocation and error management for multi-extent file handling.
    if (file!= NULL) {
        free(file);
    }

    // Consume the buffer.
    __archive_read_consume(a, step);
    iso9660->current_position += step;
    step = 0;
}