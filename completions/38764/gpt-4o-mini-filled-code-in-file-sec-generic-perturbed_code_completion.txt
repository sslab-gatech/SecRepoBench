const unsigned char *entry_start = b;
		const unsigned char *entry_end = b + step;
		while (b < entry_end) {
			struct file_info *new_file;
			size_t entry_length = (size_t)(b[DR_length_offset]);
			if (entry_length < DR_name_offset + 1) {
				archive_set_error(&archivereader->archive, ARCHIVE_ERRNO_MISC,
				    "Invalid directory record length");
				return (ARCHIVE_FATAL);
			}
			if (b + entry_length > entry_end) {
				archive_set_error(&archivereader->archive, ARCHIVE_ERRNO_MISC,
				    "Directory record extends beyond buffer");
				return (ARCHIVE_FATAL);
			}
			new_file = parse_file_info(archivereader, parent, b, entry_length);
			if (new_file == NULL) {
				return (ARCHIVE_FATAL);
			}
			if (new_file->size == 0 && new_file->mode == (AE_IFDIR | 0700)) {
				// Skip empty directories
				free(new_file);
			} else {
				add_entry(archivereader, iso9660, new_file);
			}
			b += entry_length; // Move to the next directory entry
		}