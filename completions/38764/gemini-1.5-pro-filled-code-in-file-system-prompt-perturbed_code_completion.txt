for (p = b; p + 33 < b + step; p += dr_len) {
			struct file_info *file;
			const unsigned char *isodirrec = p;

			dr_len = isodirrec[DR_length_offset];
			/* If dr_len is zero, it's the end. */
			if (dr_len == 0) {
				step -= (p - b);
				break;
			}
			if (p + dr_len > b + step) {
				/* We don't have the full record. */
				step -= (p - b);
				break;
			}

			file = parse_file_info(archivereader, parent,
			    isodirrec, dr_len);
			if (file == NULL)
				return (ARCHIVE_FATAL);

			/* Special cases for '.' and '..' */
			if (archive_strlen(&file->name) == 1 &&
			    file->name.s[0] == '\0') {
				/* '.' entry points to itself. */
				free(file);
				continue;
			}
			if (archive_strlen(&file->name) == 1 &&
			    file->name.s[0] == '\001') {
				/* '..' entry points to parent. */
				free(file);
				continue;
			}

			if (file->multi_extent) {
				struct content *con;

				con = malloc(sizeof(struct content));
				if (con == NULL) {
					archive_set_error(
					    &archivereader->archive, ENOMEM,
					    "Can't allocate data");
					return (ARCHIVE_FATAL);
				}
				con->offset = file->offset;
				con->size = file->size;
				con->next = NULL;
				*file->contents.last = con;
				file->contents.last = &(con->next);
				if (multi == NULL)
					multi = file;
				free(file);
				continue;
			}
			if (multi != NULL) {
				struct content *con;

				con = malloc(sizeof(struct content));
				if (con == NULL) {
					archive_set_error(
					    &archivereader->archive, ENOMEM,
					    "Can't allocate data");
					return (ARCHIVE_FATAL);
				}
				con->offset = file->offset;
				con->size = file->size;
				con->next = NULL;
				*multi->contents.last = con;
				multi->contents.last = &(con->next);
				free(file);
				continue;
			}

			if (add_entry(archivereader, iso9660, file)
			    != ARCHIVE_OK)
				return (ARCHIVE_FATAL);
		}
		if (step > 0) {
			skip_size -= step;
			step = 0;
		}
		if (multi != NULL) {
			if (add_entry(archivereader, iso9660, multi)
			    != ARCHIVE_OK)
				return (ARCHIVE_FATAL);
			multi = NULL;
		}