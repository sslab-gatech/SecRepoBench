if (p[0] == 0) {
			p++;
			step--;
			continue;
		}
		len = p[0];
		if (len < 33 || len > step) {
			archive_set_error(&archivereader->archive,
			    ARCHIVE_ERRNO_MISC,
			    "Invalid directory entry length");
			return (ARCHIVE_FATAL);
		}

		if (p[32] == 1) {
			if (p[33] == 0 || p[33] == 1) {
				p += len;
				step -= len;
				continue;
			}
		}

		struct file_info *file = calloc(1, sizeof(struct file_info));
		if (file == NULL) {
			archive_set_error(&archivereader->archive, ENOMEM,
			    "No memory for file info");
			return (ARCHIVE_FATAL);
		}

		file->offset = archive_le32dec(p + 2);
		file->size = archive_le32dec(p + 10);
		file->flags = p[25];
		file->name_len = p[32];
		if (file->name_len > 0)
			memcpy(file->name, p + 33, file->name_len);

		if (multi != NULL) {
			if ((multi->flags & 0x80) == 0) {
				multi->contents.first = file;
				multi->contents.last = &file->next;
			} else {
				*multi->contents.last = file;
				multi->contents.last = &file->next;
			}
		} else {
			file->next = parent->sub_files;
			parent->sub_files = file;
		}

		if (file->flags & 0x80)
			multi = file;
		else
			multi = NULL;

		p += len;
		step -= len;