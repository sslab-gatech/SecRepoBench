struct directory_record *dirrec;
		struct file_info *file;
		int r;

		dirrec = (struct directory_record *)b;
		while (step > 0 && dirrec->length > 0) {
			if (step < ISO9660_DIR_RECORD_SIZE)
				break;
			if (dirrec->length < ISO9660_DIR_RECORD_SIZE)
				break;

			file = parse_file_info(a, iso9660, dirrec, parent);
			if (file == NULL)
				return (ARCHIVE_FATAL);

			/* Skip '.' and '..' entries. */
			if (file->name.s[0] == '\0' ||
			    (file->name.s[0] == '.' && file->name.s[1] == '\0') ||
			    (file->name.s[0] == '.' && file->name.s[1] == '.' && file->name.s[2] == '\0')) {
				free(file);
			} else if (file->multi_extent) {
				if (multi == NULL)
					multi = file;
				else {
					file->next = multi->next;
					multi->next = file;
				}
			} else {
				r = add_entry(iso9660, file);
				if (r != ARCHIVE_OK) {
					free(file);
					if (multi != NULL)
						release_files(multi);
					return (r);
				}
			}

			step -= dirrec->length;
			b += dirrec->length;
			dirrec = (struct directory_record *)b;
		}
		if (step > 0 && dirrec->length == 0) {
			/* We hit end-of-directory marker; consume it. */
			step -= ISO9660_DIR_RECORD_SIZE;
			b += ISO9660_DIR_RECORD_SIZE;
			dirrec = (struct directory_record *)b;
			/* If there's another record, loop to process it. */
			if (step > 0 && dirrec->length > 0)
				continue;
			/* Otherwise, we've hit the true end. */
			skip_size -= step;
			step = 0;
		}
		if (step > 0) {
			/* We should never encounter a record that
			 * extends past the end of the directory. */
			break;
		}