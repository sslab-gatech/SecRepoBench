while (step) {
	struct file_info *re, *d;
	struct file_info *file = NULL;
	int r;

	/* Iterate over directory entries in the buffer while there is data to process. */
	while ((re = re_get_entry(iso9660))!= NULL) {
		/* Skip entries for '.' and '..' directories. */
		if (re->name.s[0] == '.' && re->name.s[1] == '\0')
			continue;
		if (re->name.s[0] == '.' && re->name.s[1] == '.' &&
		    re->name.s[2] == '\0')
			continue;

		/* Parse the file information. */
		parse_rockridge_NM1(re, b, step);

		/* Handle special cases: */
		/* - Skip entries for '.' and '..' directories. */
		/* - Manage multi-extent files by collecting their contents into a list. */
		/* - For each valid directory entry, add it to the archive structure. */
		/* - Handle memory allocation and error management for multi-extent file handling. */
		if (re->mode & AE_IFDIR) {
			/* Read file entries in this dir. */
			r = read_children(archivereader, re);
			if (r!= ARCHIVE_OK)
				return (r);
		}

		/* Add the file to the archive structure. */
		archive_entry_set_mode(entry, re->mode);
		archive_entry_set_uid(entry, re->uid);
		archive_entry_set_gid(entry, re->gid);
		archive_entry_set_nlink(entry, re->nlinks);
		if (re->birthtime_is_set)
			archive_entry_set_birthtime(entry, re->birthtime, 0);
		else
			archive_entry_unset_birthtime(entry);
		archive_entry_set_mtime(entry, re->mtime, 0);
		archive_entry_set_ctime(entry, re->ctime, 0);
		archive_entry_set_atime(entry, re->atime, 0);
		archive_entry_set_rdev(entry, (dev_t)re->rdev);
		archive_entry_set_size(entry, re->size);

		/* If this is a Rockridge extension, handle it specially. */
		if (re->rr_moved) {
			/* Handle a special dir of Rockridge extensions, "rr_moved". */
			if (re->rr_moved_has_re_only)
				continue;
			/* Otherwise expose "rr_moved" entry. */
		} else if (re->re) {
			/* Do not expose this at this time because we have not gotten its full-path name yet. */
			re_add_entry(iso9660, re);
			continue;
		} else if (re->re_descendant) {
			/* If the top level "RE" entry of this entry is not exposed, we, accordingly, should not expose this entry at this time because we cannot make its proper full-path name. */
			if (rede_add_entry(re) == 0)
				continue;
			/* Otherwise we can expose this entry because it seems its top level "RE" has already been exposed. */
		}

		/* Add the file to the cache. */
		cache_add_entry(iso9660, re);

		/* Move to the next entry. */
		re = next_entry(iso9660);
	}

	/* If we've reached the end of the buffer, move to the next buffer. */
	if (step == 0) {
		__archive_read_consume(archivereader, skip_size);
		iso9660->current_position += step;
		step = (size_t)(((parent->size + iso9660->logical_block_size -1) /
		    iso9660->logical_block_size) * iso9660->logical_block_size);
		b = __archive_read_ahead(archivereader, step, NULL);
		if (b == NULL) {
			archive_set_error(&archivereader->archive, ARCHIVE_ERRNO_MISC,
			    "Failed to read full block when scanning "
			    "ISO9660 directory list");
			return (ARCHIVE_FATAL);
		}
		iso9660->current_position += step;
	}
}