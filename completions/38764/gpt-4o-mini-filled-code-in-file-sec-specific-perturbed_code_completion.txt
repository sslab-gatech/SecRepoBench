const unsigned char *entry_start = b;
		const unsigned char *entry_end = b + step;
		while (b < entry_end) {
			struct file_info *new_file;
			size_t entry_length = (size_t)b[DR_length_offset];

			// Ensure we do not read beyond the buffer
			if (entry_length > (size_t)(entry_end - b)) {
				archive_set_error(&archivereader->archive, ARCHIVE_ERRNO_MISC,
				    "Invalid directory entry length");
				return (ARCHIVE_FATAL);
			}

			// Parse the file information from the directory record
			new_file = parse_file_info(archivereader, parent, b, entry_length);
			if (new_file == NULL) {
				archive_set_error(&archivereader->archive, ARCHIVE_ERRNO_MISC,
				    "Failed to parse file info");
				return (ARCHIVE_FATAL);
			}

			// Add the new file to the heap
			if (add_entry(archivereader, iso9660, new_file) != ARCHIVE_OK) {
				archive_set_error(&archivereader->archive, ARCHIVE_ERRNO_MISC,
				    "Failed to add entry to heap");
				free(new_file);
				return (ARCHIVE_FATAL);
			}

			// Move to the next entry in the directory
			b += entry_length;
		}