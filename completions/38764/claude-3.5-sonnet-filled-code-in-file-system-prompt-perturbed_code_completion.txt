while (step) {
    p = b;
    while (p < b + step && p + DR_length_offset < b + step) {
        int dr_len = p[DR_length_offset];
        if (dr_len == 0)
            break;
        if (p + dr_len > b + step) {
            archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
                "Invalid directory record length");
            return (ARCHIVE_FATAL);
        }
        if (p[DR_name_len_offset] == 1 && p[DR_name_offset] == '\0')
            /* Skip the '.' entry. */
            p += dr_len;
        else if (p[DR_name_len_offset] == 1 && p[DR_name_offset] == '\001')
            /* Skip the '..' entry. */
            p += dr_len;
        else {
            file = parse_file_info(a, parent, p, dr_len);
            if (file == NULL)
                return (ARCHIVE_FATAL);
            if (file->multi_extent) {
                if (multi == NULL) {
                    multi = file;
                    multi->contents.first = multi->contents.last = NULL;
                } else {
                    struct content *con;
                    con = malloc(sizeof(*con));
                    if (con == NULL) {
                        archive_set_error(&a->archive, ENOMEM,
                            "No memory for multi extent");
                        return (ARCHIVE_FATAL);
                    }
                    con->offset = file->offset;
                    con->size = file->size;
                    con->next = NULL;
                    if (multi->contents.last == NULL)
                        multi->contents.first = multi->contents.last = con;
                    else {
                        multi->contents.last->next = con;
                        multi->contents.last = con;
                    }
                    multi->size += file->size;
                    free(file);
                }
            } else {
                if (multi != NULL) {
                    if (add_entry(a, iso9660, multi) != ARCHIVE_OK)
                        return (ARCHIVE_FATAL);
                    multi = NULL;
                }
                if (add_entry(a, iso9660, file) != ARCHIVE_OK)
                    return (ARCHIVE_FATAL);
            }
            p += dr_len;
        }
    }
    if (multi != NULL) {
        if (add_entry(a, iso9660, multi) != ARCHIVE_OK)
            return (ARCHIVE_FATAL);
        multi = NULL;
    }
    b += step;
    step = b + step > p ? b + step - p : 0;
    skip_size -= step;
}