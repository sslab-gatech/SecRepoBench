p = b;
while (step) {
	/* Parse directory entry. */
	if (*p == 0)
		break;
	if (step < ISO_DIRECTORY_RECORD_SIZE) {
		archive_set_error(&archivereader->archive,
		    ARCHIVE_ERRNO_MISC,
		    "Corrupted directory entry: %s",
		    parent->name.s);
		return (ARCHIVE_WARN);
	}
	struct file_info *child = create_file_info();
	parse_directory_record(child, p);

	/* Skip '.' and '..' entries. */
	if (strcmp(child->name.s, ".") == 0 || strcmp(child->name.s, "..") == 0) {
		free_file_info(child);
	} else if (child->multi_extent) {
		/* Handle multi-extent files by collecting their contents into a list. */
		if (!multi) {
			multi = child;
			multi->next = NULL;
		} else {
			struct file_info *temp = multi;
			while (temp->next) temp = temp->next;
			temp->next = child;
		}
	} else {
		/* Add valid directory entry to the archive structure. */
		if (add_to_archive(archivereader, child) != ARCHIVE_OK) {
			free_file_info(child);
			return (ARCHIVE_WARN);
		}
	}

	/* Move to the next entry. */
	size_t record_len = *(p + ISO_RECORD_LENGTH_OFFSET);
	p += record_len;
	step -= record_len;
}

/* Handle memory allocation and error management for multi-extent file handling. */
if (multi) {
	if (process_multi_extent_files(archivereader, multi) != ARCHIVE_OK) {
		free_multi_extent_list(multi);
		return (ARCHIVE_WARN);
	}
	free_multi_extent_list(multi);
}