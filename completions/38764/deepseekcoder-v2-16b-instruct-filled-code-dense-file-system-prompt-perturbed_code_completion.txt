while (step) {
		// Iterate over directory entries in the buffer while there is data to process.
		// For each directory entry, parse its file information, and handle special cases:
		// - Skip entries for '.' and '..' directories.
		// - Manage multi-extent files by collecting their contents into a list.
		// - For each valid directory entry, add it to the archive structure.
		// - Handle memory allocation and error management for multi-extent file handling.
		const unsigned char *entry_start = b;
		const unsigned char *entry_end = b + step;
		while (entry_start < entry_end) {
			// Parse the directory entry
			struct iso9660_dirent *dirent = parse_dirent(entry_start, entry_end);
			if (dirent == NULL) {
				archive_set_error(&archivereader->archive, ARCHIVE_ERRNO_MISC,
				    "Failed to parse directory entry");
				return (ARCHIVE_FATAL);
			}
			entry_start += dirent->size;

			// Skip entries for '.' and '..' directories
			if (strcmp(dirent->name, ".") == 0 || strcmp(dirent->name, "..") == 0) {
				continue;
			}

			// Handle multi-extent files
			if (dirent->is_multi_extent) {
				if (handle_multi_extent_file(archivereader, iso9660, parent, dirent) != ARCHIVE_OK) {
					return (ARCHIVE_FATAL);
				}
			} else {
				// For each valid directory entry, add it to the archive structure
				if (add_entry_to_archive(archivereader, iso9660, parent, dirent) != ARCHIVE_OK) {
					return (ARCHIVE_FATAL);
				}
			}
		}

		// Update the buffer and step size
		b = entry_start;
		step = (size_t)(((parent->size + iso9660->logical_block_size - 1) /
		    iso9660->logical_block_size) * iso9660->logical_block_size);
		if (b + step > entry_end) {
			step = entry_end - b;
		}
	}