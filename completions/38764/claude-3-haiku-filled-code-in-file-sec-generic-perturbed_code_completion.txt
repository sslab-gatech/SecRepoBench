while (step) {
    // Iterate over directory entries in the buffer while there is data to process.
    while (p + DR_name_offset < b + step) {
        size_t reclen = (size_t)p[DR_length_offset];
        // Skip entries for '.' and '..' directories.
        if (reclen > 0 && (p[DR_name_offset] == 0 || (p[DR_name_offset] == 1 && p[DR_name_offset + 1] == 0))) {
            p += reclen;
            continue;
        }
        // Parse the file information and handle special cases.
        struct file_info *file = parse_file_info(a, parent, p, reclen);
        if (file == NULL) {
            return (ARCHIVE_FATAL);
        }
        if (file->multi_extent) {
            // Manage multi-extent files by collecting their contents into a list.
            if (file->contents.first == NULL) {
                file->contents.last = &file->contents.first;
            } else {
                *file->contents.last = malloc(sizeof(struct content));
                if (*file->contents.last == NULL) {
                    archive_set_error(&a->archive, ENOMEM, "No memory");
                    return (ARCHIVE_FATAL);
                }
                (*file->contents.last)->offset = file->offset;
                (*file->contents.last)->size = file->size;
                (*file->contents.last)->next = NULL;
                file->contents.last = &(*file->contents.last)->next;
            }
        } else {
            // For each valid directory entry, add it to the archive structure.
            if (add_entry(a, iso9660, file) != ARCHIVE_OK) {
                return (ARCHIVE_FATAL);
            }
        }
        p += reclen;
    }
    skip_size = step;
    step -= p - b;
}