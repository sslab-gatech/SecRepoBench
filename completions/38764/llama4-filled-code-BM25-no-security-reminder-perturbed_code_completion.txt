p = b;
		while (step) {
			/* If we have reached the end of buffer, refill it. */
			if (skip_size == 0) {
				/* If we have processed all of the data, exit. */
				if (b == NULL)
					break;
				p = b;
				skip_size = step;
			}

			/* Get the length of the current directory entry. */
			if (skip_size < 1)
				break;
			int entry_length = *p++;
			skip_size -= 1;

			/* If the entry is unused or the length is invalid, skip it. */
			if (entry_length < 1 || entry_length > skip_size)
				continue;

			/* Parse the directory entry. */
			const unsigned char *entry = p;
			p += entry_length;
			skip_size -= entry_length;

			/* Skip entries for '.' and '..' directories. */
			if (entry[0] == 0x00 || entry[0] == 0x01)
				continue;

			/* Extract file information. */
			int64_t file_offset = archive_le32dec(entry + 2);
			uint32_t file_size = archive_le32dec(entry + 10);
			uint8_t file_flags = entry[1];
			uint8_t file_unit_size = entry[4];
			uint8_t file_gaps = entry[5];
			uint8_t file_version = entry[6];

			/* Check if the file is a directory. */
			if (file_flags & 0x02) {
				/* Add the directory to the archive structure. */
				struct file_info *file;
				file = new_file_info(iso9660, parent, file_offset, file_size, file_flags, file_unit_size, file_gaps, file_version);
				if (file == NULL) {
					archive_set_error(&archivereader->archive, ENOMEM, "No memory");
					return (ARCHIVE_FATAL);
				}
				add_child(multi, file);
			} else {
				/* Handle multi-extent files. */
				if (file_flags & 0x80) {
					/* Collect multi-extent file contents into a list. */
					struct file_info *file;
					file = new_file_info(iso9660, parent, file_offset, file_size, file_flags, file_unit_size, file_gaps, file_version);
					if (file == NULL) {
						archive_set_error(&archivereader->archive, ENOMEM, "No memory");
						return (ARCHIVE_FATAL);
					}
					add_multi_extent_file(multi, file);
				} else {
					/* Add the file to the archive structure. */
					struct file_info *file;
					file = new_file_info(iso9660, parent, file_offset, file_size, file_flags, file_unit_size, file_gaps, file_version);
					if (file == NULL) {
						archive_set_error(&archivereader->archive, ENOMEM, "No memory");
						return (ARCHIVE_FATAL);
					}
					add_child(multi, file);
				}
			}
		}