// Iterate over directory entries in the buffer while there is data to process.
// For each directory entry, parse its file information, and handle special cases:
// - Skip entries for '.' and '..' directories.
// - Manage multi-extent files by collecting their contents into a list.
// - For each valid directory entry, add it to the archive structure.
// - Handle memory allocation and error management for multi-extent file handling.
	while (step) {
		const unsigned char *entry_data = b;
		size_t entry_length = step;

		while (entry_length > 0) {
			size_t entry_consumed = 0;
			parse_rockridge_NM1(multi, entry_data, entry_length);

			if (multi && multi->name_continues) {
				entry_data += entry_consumed;
				entry_length -= entry_consumed;
				continue;
			}

			if (multi && (multi->name.length > 0)) {
				struct file_info *new_file = malloc(sizeof(struct file_info));
				if (!new_file) {
					archive_set_error(&archivereader->archive, ENOMEM, "No memory");
					return (ARCHIVE_FATAL);
				}
				*new_file = *multi;
				archive_strncpy(&new_file->name, multi->name.s, multi->name.length);
				cache_add_entry(iso9660, new_file);
				multi = NULL;
			}

			if (entry_data[0] == 2 || entry_data[0] == 4) {
				entry_data += 1;
				entry_length -= 1;
				continue;
			}

			if (entry_data[0] == 0 || entry_data[0] == 1) {
				size_t name_length = entry_length - 1;
				if (name_length > 0) {
					multi = malloc(sizeof(struct file_info));
					if (!multi) {
						archive_set_error(&archivereader->archive, ENOMEM, "No memory");
						return (ARCHIVE_FATAL);
					}
					multi->name_continues = (entry_data[0] == 1);
					archive_strncpy(&multi->name, (const char *)entry_data + 1, name_length);
					entry_data += 1;
					entry_length -= 1;
				}
			}

			entry_data += entry_consumed;
			entry_length -= entry_consumed;
		}

		b = __archive_read_ahead(archivereader, step, NULL);
		if (b == NULL) {
			archive_set_error(&archivereader->archive, ARCHIVE_ERRNO_MISC,
			    "Failed to read full block when scanning "
			    "ISO9660 directory list");
			return (ARCHIVE_FATAL);
		}
		iso9660->current_position += step;
	}

	__archive_read_consume(archivereader, skip_size);