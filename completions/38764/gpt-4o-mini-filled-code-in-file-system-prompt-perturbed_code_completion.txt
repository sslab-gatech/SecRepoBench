// Read the directory record length and check for valid entries.
		dr_len = (size_t)isodirrec[DR_length_offset];
		if (dr_len < DR_name_offset + 1) {
			archive_set_error(&archivereader->archive, ARCHIVE_ERRNO_MISC,
			    "Invalid directory record length");
			return (ARCHIVE_FATAL);
		}

		// Skip '.' and '..' entries.
		if (name_len == 1 && isodirrec[DR_name_offset] == 0) {
			// Skip current directory entry.
			p += dr_len;
			step -= dr_len;
			continue;
		} else if (name_len == 2 && isodirrec[DR_name_offset] == '.' &&
			isodirrec[DR_name_offset + 1] == 0) {
			// Skip parent directory entry.
			p += dr_len;
			step -= dr_len;
			continue;
		}

		// Parse the file information from the directory record.
		file = parse_file_info(archivereader, parent, isodirrec, dr_len);
		if (file == NULL) {
			archive_set_error(&archivereader->archive, ARCHIVE_ERRNO_MISC,
			    "Failed to parse file information");
			return (ARCHIVE_FATAL);
		}

		// Handle multi-extent files by adding their contents to the list.
		if (file->multi_extent) {
			struct content *con = malloc(sizeof(struct content));
			if (con == NULL) {
				archive_set_error(&archivereader->archive, ENOMEM,
				    "No memory for content structure");
				return (ARCHIVE_FATAL);
			}
			con->offset = file->offset;
			con->size = file->size;
			con->next = NULL;

			if (file->contents.first == NULL) {
				file->contents.first = con;
				file->contents.last = &con->next;
			} else {
				*(file->contents.last) = con;
				file->contents.last = &con->next;
			}
		}

		// Add the file to the heap for further processing.
		if (add_entry(archivereader, iso9660, file) != ARCHIVE_OK) {
			archive_set_error(&archivereader->archive, ARCHIVE_ERRNO_MISC,
			    "Failed to add entry to heap");
			return (ARCHIVE_FATAL);
		}

		// Move to the next directory record in the buffer.
		p += dr_len;
		step -= dr_len;