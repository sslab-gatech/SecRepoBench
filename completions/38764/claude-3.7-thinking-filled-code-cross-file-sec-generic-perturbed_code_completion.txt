p = b;
while (step > 0) {
    struct file_info *file;
    int dr_len;

    dr_len = *p;
    if (dr_len == 0) {
        /* Skip to the next sector */
        size_t skip = iso9660->logical_block_size - ((p - b) % iso9660->logical_block_size);
        if (skip > step) skip = step;
        p += skip;
        step -= skip;
        continue;
    }
    
    if (dr_len < 32) {
        /* Directory record must be at least 32 bytes long */
        archive_set_error(&archivereader->archive, ARCHIVE_ERRNO_MISC,
            "Invalid directory record length");
        return (ARCHIVE_FATAL);
    }
    
    if (dr_len > step) {
        /* Directory record extends beyond buffer */
        archive_set_error(&archivereader->archive, ARCHIVE_ERRNO_MISC,
            "Directory record exceeds block size");
        return (ARCHIVE_FATAL);
    }
    
    /* Skip "." and ".." entries */
    if (p[32] == 1 && (p[33] == 0 || p[33] == 1)) {
        p += dr_len;
        step -= dr_len;
        continue;
    }
    
    file = calloc(1, sizeof(*file));
    if (file == NULL) {
        archive_set_error(&archivereader->archive, ENOMEM,
            "No memory for file entry");
        return (ARCHIVE_FATAL);
    }
    
    /* Initialize file info */
    file->parent = parent;
    file->nlinks = 1;
    file->number = -1;
    file->ce_offset = 0;
    file->ce_size = 0;
    file->contents.first = NULL;
    file->contents.last = &(file->contents.first);
    archive_string_init(&file->name);
    archive_string_init(&file->symlink);
    
    /* Extract basic file information */
    file->offset = archive_le32dec(p + 2) * iso9660->logical_block_size;
    file->size = archive_le32dec(p + 10);
    
    /* Handle file name */
    {
        int name_len = p[32];
        if (name_len > 0) {
            archive_strncat(&file->name, (const char *)(p + 33), name_len);
        }
    }
    
    /* Set file mode based on flags */
    if ((p[25] & 0x02) != 0) { /* Directory flag */
        file->mode = AE_IFDIR | 0555;
        parent->subdirs++;
    } else {
        file->mode = AE_IFREG | 0444;
    }
    
    /* Handle multi-extent files */
    if (multi) {
        if (archive_strlen(&multi->name) == archive_strlen(&file->name) &&
            memcmp(multi->name.s, file->name.s, archive_strlen(&file->name)) == 0) {
            /* This is a continuation of the previous file */
            struct content_info *content = malloc(sizeof(*content));
            if (content == NULL) {
                archive_set_error(&archivereader->archive, ENOMEM,
                    "No memory for content");
                archive_string_free(&file->name);
                archive_string_free(&file->symlink);
                free(file);
                return (ARCHIVE_FATAL);
            }
            content->next = NULL;
            content->offset = file->offset;
            content->size = file->size;
            *(multi->contents.last) = content;
            multi->contents.last = &(content->next);
            multi->size += file->size;
            archive_string_free(&file->name);
            archive_string_free(&file->symlink);
            free(file);
        } else {
            /* This is a different file */
            iso9660->pending_files.files[iso9660->pending_files.used++] = multi;
            if (p[25] & 0x80) { /* Multi-extent flag */
                multi = file;
            } else {
                iso9660->pending_files.files[iso9660->pending_files.used++] = file;
                multi = NULL;
            }
        }
    } else {
        if (p[25] & 0x80) { /* Multi-extent flag */
            multi = file;
        } else {
            iso9660->pending_files.files[iso9660->pending_files.used++] = file;
        }
    }
    
    p += dr_len;
    step -= dr_len;
}

if (multi) {
    iso9660->pending_files.files[iso9660->pending_files.used++] = multi;
}