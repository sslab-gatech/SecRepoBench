for (;;) {
		struct file_info *file;
		const unsigned char *entry;
		int entry_length;

		entry = b + skip_size;
		entry_length = (int)step - skip_size;
		if (entry_length < 1)
			break;
		file = next_entry(iso9660);
		if (file == NULL)
			break;
		parse_iso9660_entry(file, entry, entry_length);
		if (file->name_continues) {
			skip_size += entry_length;
			continue;
		}
		if (file->name.s[0] == 0)
			continue;
		if (strcmp(file->name.s, ".") == 0 ||
		    strcmp(file->name.s, "..") == 0) {
			file->name_continues = 0;
			continue;
		}
		if ((file->mode & AE_IFMT) == AE_IFDIR) {
			if (read_children(a, file) != ARCHIVE_OK)
				return (ARCHIVE_FATAL);
			continue;
		}
		if (file->rr_moved) {
			if (iso9660->rr_moved == NULL) {
				iso9660->rr_moved = file;
				iso9660->rr_moved->rr_moved_has_re_only = 1;
			} else {
				iso9660->rr_moved->rr_moved_has_re_only = 0;
				iso9660->rr_moved = NULL;
			}
			continue;
		}
		if (file->re) {
			if (iso9660->re_files.first == NULL) {
				iso9660->re_files.first = file;
				iso9660->re_files.last = &(iso9660->re_files.first->next);
			} else {
				*iso9660->re_files.last = file;
				iso9660->re_files.last = &(file->next);
			}
			file->re = 0;
			continue;
		}
		if (file->re_descendant) {
			if (rede_add_entry(file) < 0)
				return (ARCHIVE_FATAL);
			continue;
		}
		if (file->number == -1) {
			file->next = NULL;
			*empty_files.last = file;
			empty_files.last = &(file->next);
			continue;
		}
		count++;
		cache_add_entry(iso9660, file);
	}
	if (count > 1) {
		for (file = iso9660->cache_files.first;
		    file != NULL; file = file->next)
			file->nlinks = count;
	}
	if (empty_files.first != NULL) {
		*iso9660->cache_files.last = empty_files.first;
		iso9660->cache_files.last = empty_files.last;
	}
	*pfile = cache_get_entry(iso9660);