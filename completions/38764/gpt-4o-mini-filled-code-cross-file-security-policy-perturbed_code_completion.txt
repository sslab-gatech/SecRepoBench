const unsigned char *entry_start = b;
		size_t entry_size = 0;
		struct file_info *file_info;

		while (entry_size < skip_size) {
			// Ensure we do not exceed the buffer boundaries
			if (entry_size + sizeof(struct file_info) > step) {
				archive_set_error(&archivereader->archive, ARCHIVE_ERRNO_MISC,
				    "Buffer overflow while reading directory entries");
				return (ARCHIVE_FATAL);
			}

			file_info = (struct file_info *)(entry_start + entry_size);
			if (file_info->mode == 0) {
				// Skip empty entries
				entry_size += sizeof(struct file_info);
				continue;
			}

			// Handle '.' and '..' entries
			if (file_info->name.s[0] == '.' && 
			    (file_info->name.s[1] == '\0' || 
			     (file_info->name.s[1] == '.' && file_info->name.s[2] == '\0'))) {
				entry_size += sizeof(struct file_info);
				continue;
			}

			// Process valid directory entry
			// Add file_info to the archive structure
			// (Assuming a function add_file_to_archive exists)
			if (add_file_to_archive(archivereader, file_info) != ARCHIVE_OK) {
				return (ARCHIVE_FATAL);
			}

			entry_size += sizeof(struct file_info);
		}