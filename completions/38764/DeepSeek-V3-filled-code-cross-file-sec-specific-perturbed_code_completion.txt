p = b;
while (step > 0) {
    size_t l;

    if (p[0] == 0) {
        /* Skip padding. */
        step--;
        p++;
        skip_size--;
        continue;
    }

    l = p[0];
    if (l > step) {
        archive_set_error(&archivereader->archive,
            ARCHIVE_ERRNO_MISC,
            "Invalid directory entry size");
        return (ARCHIVE_FATAL);
    }

    if (p[1] == 0 && multi != NULL) {
        /* End of multi-extent. */
        multi->contents.last->offset = parent->offset +
            (p - b);
        multi->contents.last->size = l;
        multi = NULL;
    } else if (p[1] != 0) {
        struct file_info *file;
        int r;

        file = parse_file_info(archivereader, parent, p, l);
        if (file == NULL)
            return (ARCHIVE_FATAL);

        if (file->multi_extent) {
            if (multi == NULL) {
                multi = file;
                file->contents.first = file->contents.last =
                    calloc(1, sizeof(*file->contents.first));
                if (file->contents.first == NULL) {
                    archive_set_error(&archivereader->archive,
                        ENOMEM, "No memory");
                    return (ARCHIVE_FATAL);
                }
                file->contents.first->offset = parent->offset +
                    (p - b);
            } else {
                struct content *con;

                con = calloc(1, sizeof(*con));
                if (con == NULL) {
                    archive_set_error(&archivereader->archive,
                        ENOMEM, "No memory");
                    return (ARCHIVE_FATAL);
                }
                con->offset = parent->offset + (p - b);
                multi->contents.last->next = con;
                multi->contents.last = con;
            }
        }

        r = add_entry(archivereader, iso9660, file);
        if (r != ARCHIVE_OK)
            return (r);
    }

    step -= l;
    p += l;
    skip_size -= l;
}