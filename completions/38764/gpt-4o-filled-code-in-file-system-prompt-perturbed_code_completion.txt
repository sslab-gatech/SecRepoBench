while (step) {
			if (step < 34 || step < isodirrec[DR_length_offset])
				break;
			if (isodirrec[DR_length_offset] == 0) {
				step = (step + iso9660->logical_block_size - 1) &
				    ~(iso9660->logical_block_size - 1);
				break;
			}
			file = parse_file_info(archivereader, parent, isodirrec, step);
			if (file == NULL)
				return (ARCHIVE_FATAL);
			if (file->name.s[0] == '\0' || file->name.s[0] == 0) {
				/* Skip '.' and '..' entries. */
				if (file->name.s[0] == '\0' ||
				    (file->name.s[0] == 0 && file->name.s[1] == 0)) {
					free(file);
					step -= isodirrec[DR_length_offset];
					isodirrec += isodirrec[DR_length_offset];
					continue;
				}
			}
			if (file->multi_extent) {
				if (multi == NULL) {
					multi = file;
					multi->contents.first = NULL;
					multi->contents.last = &multi->contents.first;
				} else {
					struct content *con;
					con = (struct content *)malloc(sizeof(*con));
					if (con == NULL) {
						archive_set_error(&archivereader->archive, ENOMEM,
						    "No memory for multi-extent file");
						free(file);
						return (ARCHIVE_FATAL);
					}
					con->offset = file->offset;
					con->size = file->size;
					con->next = NULL;
					*multi->contents.last = con;
					multi->contents.last = &con->next;
					free(file);
				}
			} else {
				if (multi != NULL) {
					struct content *con;
					con = (struct content *)malloc(sizeof(*con));
					if (con == NULL) {
						archive_set_error(&archivereader->archive, ENOMEM,
						    "No memory for multi-extent file");
						free(file);
						return (ARCHIVE_FATAL);
					}
					con->offset = file->offset;
					con->size = file->size;
					con->next = NULL;
					*multi->contents.last = con;
					multi->contents.last = &con->next;
					file = multi;
					multi = NULL;
				}
				if (add_entry(archivereader, iso9660, file) != ARCHIVE_OK)
					return (ARCHIVE_FATAL);
			}
			step -= isodirrec[DR_length_offset];
			isodirrec += isodirrec[DR_length_offset];
		}