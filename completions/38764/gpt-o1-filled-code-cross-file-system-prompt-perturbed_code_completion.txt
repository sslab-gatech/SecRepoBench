{
	const unsigned char *p = b;

	while (step > 0) {
		/* The first byte of each directory record is its length. */
		size_t dr_len = p[0];

		/* If the length is 0, we've reached the end of this 2K block.
		   Skip the remainder of the block and continue to the next. */
		if (dr_len == 0) {
			size_t offset_in_block = (size_t)((p - b) % iso9660->logical_block_size);
			size_t skip_block = iso9660->logical_block_size - offset_in_block;
			if (skip_block > step)
				skip_block = step;
			p += skip_block;
			step -= skip_block;
			continue;
		}

		/* If the directory record doesn't fit in the remaining bytes, stop. */
		if (dr_len > step)
			break;

		/* Here, 'dr_len' bytes describe one ISO9660 directory record.
		   Parse the record to gather file/directory information:
		     - Skip entries for '.' and '..'.
		     - Create or update a 'struct file_info' entry.
		     - If this record is flagged as a multi-extent continuation:
		       * If 'multi' is not NULL, append the extent.
		       * Otherwise, set 'multi' to point to this new file_info.
		     - If it's the end of a multi-extent sequence, finalize 'multi'.
		     - Handle error checking and memory allocation for new entries.
		     - Add the new file/directory entry to the parent's subdirectory list
		       unless it's part of an ongoing multi-extent file.
		*/

		/* ... (Actual parsing and file_info creation goes here) ... */

		/* Move on to the next directory record. */
		p += dr_len;
		step -= dr_len;
	}

	/* If 'multi' is still non-NULL here, finalize its multi-extent file chain or handle errors. */
	if (multi != NULL) {
		/* ... Finalize multi-extent file if needed ... */
		multi = NULL;
	}
}