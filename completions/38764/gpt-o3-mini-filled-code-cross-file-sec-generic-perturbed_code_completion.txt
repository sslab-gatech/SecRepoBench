{
	const unsigned char *entry = b;
	/* The first byte of the directory record indicates its length */
	unsigned char entry_len = entry[0];

	/* A length of zero indicates the remainder of the block is padding.
	 * Skip to the start of the next block. */
	if (entry_len == 0) {
		size_t pad = iso9660->logical_block_size - ((iso9660->current_position - skip_size) % iso9660->logical_block_size);
		if (pad > step)
			pad = step;
		b += pad;
		step -= pad;
		skip_size -= pad;
		continue;
	}
	/* Validate that the directory record does not exceed the buffer */
	if (entry_len > step) {
		archive_set_error(&archivereader->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    "Invalid directory record length");
		return (ARCHIVE_FATAL);
	}

	/* Parse the directory record.
	 * Assume parse_iso9660_dir_record() allocates and fills a new file_info structure,
	 * using the parent pointer for context. */
	struct file_info *fi = parse_iso9660_dir_record(b, entry_len, parent);
	if (fi == NULL) {
		archive_set_error(&archivereader->archive, ARCHIVE_ERRNO_MISC,
		    "Failed to parse directory record");
		return (ARCHIVE_FATAL);
	}

	/* Skip directory entries for "." and ".." */
	if ((fi->name.s[0] == '.' && (fi->name.s[1] == '\0')) ||
	    (fi->name.s[0] == '.' && fi->name.s[1] == '.' && fi->name.s[2] == '\0')) {
		/* Free the allocated file_info structure if not needed */
		free_file_info(fi);
	} else {
		/* Handle multi-extent files:
		 * If the file is marked as multi-extent, chain its parts together.
		 * Otherwise, add the single entry to the cache.
		 */
		if (fi->multi_extent) {
			if (multi == NULL) {
				multi = fi;
			} else {
				struct file_info *last = multi;
				while (last->next != NULL)
					last = last->next;
				last->next = fi;
			}
		} else {
			cache_add_entry(iso9660, fi);
		}
	}
	/* Advance to the next directory record. */
	b += entry_len;
	step -= entry_len;
	skip_size -= entry_len;
}