while (step) {
	b = __archive_read_ahead(archivereader, iso9660->logical_block_size, NULL);
	if (b == NULL) {
		archive_set_error(&archivereader->archive, ARCHIVE_ERRNO_MISC,
		    "Failed to read full block when scanning "
		    "ISO9660 directory list");
		return (ARCHIVE_FATAL);
	}
	p = b;
	step -= iso9660->logical_block_size;
	iso9660->current_position += iso9660->logical_block_size;

	while (p < b + iso9660->logical_block_size) {
		struct file_info *file;
		int len, name_len;

		file = calloc(1, sizeof(*file));
		if (file == NULL) {
			archive_set_error(&archivereader->archive, ENOMEM,
			    "Can't allocate file info");
			return (ARCHIVE_FATAL);
		}

		file->parent = parent;
		file->offset = iso9660->current_position;
		file->number = -1;

		/* Parse the directory entry. */
		len = parse_file_entry(iso9660, p, &file->mode, &file->uid,
		    &file->gid, &file->rdev, &file->size, &file->mtime,
		    &file->ctime, &file->atime, &file->birthtime,
		    &file->birthtime_is_set, &name_len);
		if (len < 0) {
			free(file);
			archive_set_error(&archivereader->archive,
			    ARCHIVE_ERRNO_FILE_FORMAT,
			    "Malformed ISO9660 directory entry");
			return (ARCHIVE_FATAL);
		}

		p += len;
		iso9660->current_position += len;
		skip_size -= len;

		/* Handle special cases for the directory entry. */
		if (name_len == 1 && p[-1] == 0) {
			/* Skip '.' directory. */
			free(file);
			continue;
		}
		if (name_len == 1 && p[-1] == 1) {
			/* Skip '..' directory. */
			free(file);
			continue;
		}

		/* Collect multi-extent files. */
		if (file->size == 0 && file->number != -1) {
			multi = calloc(1, sizeof(*multi));
			if (multi == NULL) {
				free(file);
				archive_set_error(&archivereader->archive, ENOMEM,
				    "Can't allocate file info");
				return (ARCHIVE_FATAL);
			}
			memcpy(multi, file, sizeof(*file));
			free(file);
			file = multi;
			if (file->contents.first == NULL)
				file->contents.first = file;
			else
				file->contents.last->next = file;
			file->contents.last = file;
		} else {
			/* Add the directory entry to the archive structure. */
			if (parent->subdirs >= 0)
				parent->subdirs++;
			if (pending_add_entry(iso9660, file) != ARCHIVE_OK) {
				free(file);
				return (ARCHIVE_FATAL);
			}
		}
	}
}