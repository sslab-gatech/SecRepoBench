size_t len;
		int rr_skip;

		p = b;
		if (step < 34)
			break;

		len = p[0];
		if (len == 0)
			break;

		if (len > step) {
			archive_set_error(&archivereader->archive,
			    ARCHIVE_ERRNO_FILE_FORMAT,
			    "Invalid directory entry length %d > %d",
			    (int)len, (int)step);
			return (ARCHIVE_FATAL);
		}

		/* primary record length */
		/* extended attribute record length */
		/* location of extent */
		/* data length */
		/* recording date */
		/* file flags */
		/* file unit size */
		/* interleave gap size */
		/* volume sequence number */
		/* length of file identifier */
		if (len < 34) {
			archive_set_error(&archivereader->archive,
			    ARCHIVE_ERRNO_FILE_FORMAT,
			    "Directory entry too short; corrupted ISO image?");
			return (ARCHIVE_FATAL);
		}
		/* file identifier */
		/* padding */

		/* Skip '.' and '..' entries */
		if (p[32] == 0 || p[32] == 1) {
			step -= len;
			b += len;
			continue;
		}

		struct file_info *file = file_info_from_dirent(archivereader,
		    iso9660, parent, p, len);
		if (file == NULL)
			return (ARCHIVE_FATAL);

		/* Check for multi-extent files. */
		if (file->number == 0) {
			if (multi == NULL) {
				multi = file;
			} else {
				if (add_content(multi, file) != ARCHIVE_OK) {
					release_file(file);
					release_file(multi);
					return (ARCHIVE_FATAL);
				}
				release_file(file);
			}
			step -= len;
			b += len;
			continue;
		} else {
			if (multi != NULL) {
				if (add_content(multi, file) != ARCHIVE_OK) {
					release_file(file);
					release_file(multi);
					return (ARCHIVE_FATAL);
				}
				file = multi;
				multi = NULL;
			}
		}

		/* Add the file to the archive structure. */
		cache_add_entry(iso9660, file);

		step -= len;
		b += len;