int len, reclen, err = ARCHIVE_OK;
		struct file_info *file, *filep;

		p = b;
		while (step > 0 && (reclen = *p) != 0) {
			if (step < ISO9660_DR_LEN) {
				err = ARCHIVE_EOF;
				break;
			}
			len = ISO9660_DR_LEN;
			if (reclen == 1) {
				if (step < ISO9660_DR_LEN_2) {
					err = ARCHIVE_EOF;
					break;
				}
				len = ISO9660_DR_LEN_2;
				reclen = p[1];
			}
			step -= reclen;
			p += reclen;

			file = parse_file_info(iso9660, parent, p - reclen, len);
			if (file == NULL) {
				err = ARCHIVE_FATAL;
				break;
			}

			/* Skip '.' and '..' entries. */
			if (file->name.s[0] == '\0' ||
			    (file->name.s[0] == '.' && file->name.s[1] == '\0') ||
			    (file->name.s[0] == '.' && file->name.s[1] == '.' && file->name.s[2] == '\0')) {
				release_file(iso9660, file);
				continue;
			}

			if (file->multi_extent) {
				if (multi == NULL)
					multi = file;
				else {
					filep = multi;
					while (filep->next_multi != NULL)
						filep = filep->next_multi;
					filep->next_multi = file;
				}
				continue;
			}

			if (multi != NULL) {
				filep = multi;
				while (filep->next_multi != NULL)
					filep = filep->next_multi;
				filep->next_multi = file;
				cache_add_entry(iso9660, multi);
				multi = NULL;
			} else
				cache_add_entry(iso9660, file);
		}
		if (err != ARCHIVE_OK)
			break;
		if (step > 0 && reclen == 0) {
			skip_size -= step;
			step = 0;
		}