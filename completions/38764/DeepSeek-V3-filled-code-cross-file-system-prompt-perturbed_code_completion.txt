p = b;
while (step > 0) {
    struct file_info *file;
    size_t length;

    if (p[0] == 0) {
        /* Skip padding. */
        step--;
        p++;
        skip_size--;
        continue;
    }

    length = p[0];
    if (length > step) {
        archive_set_error(&archivereader->archive,
            ARCHIVE_ERRNO_MISC,
            "Invalid directory entry length");
        return (ARCHIVE_FATAL);
    }

    file = parse_file_info(archivereader, parent, p, length);
    if (file == NULL)
        return (ARCHIVE_FATAL);

    if (file->name.s[0] != '\0' && file->name.s[0] != '.' &&
        (file->name.s[0] != '.' || file->name.s[1] != '.')) {
        if (file->multi_extent) {
            if (multi == NULL) {
                multi = file;
                file->contents.first = file;
                file->contents.last = &file->contents.first;
            } else {
                *multi->contents.last = file;
                multi->contents.last = &file->next;
                file->contents.first = multi;
                file->contents.last = multi->contents.last;
            }
        } else {
            if (multi != NULL) {
                *multi->contents.last = NULL;
                multi = NULL;
            }
            if (add_entry(archivereader, iso9660, file) != ARCHIVE_OK) {
                free(file);
                return (ARCHIVE_FATAL);
            }
        }
    } else {
        free(file);
    }

    step -= length;
    p += length;
    skip_size -= length;
}