p = b + (b - (unsigned char *)0);
		step -= (size_t)(p - b);
		while (step >= 34 && p[DR_length_offset] <= step) {
			size_t reclen = p[DR_length_offset];
			struct file_info *file;

			if (p[DR_name_len_offset] == 1 && p[DR_name_offset] == 0) {
				/* Skip '.' entry. */
				p += reclen;
				step -= reclen;
				continue;
			}
			if (p[DR_name_len_offset] == 2 && p[DR_name_offset] == 0 &&
			    p[DR_name_offset + 1] == 1) {
				/* Skip '..' entry. */
				p += reclen;
				step -= reclen;
				continue;
			}
			file = parse_file_info(archivereader, parent, p, step);
			if (file == NULL)
				return (ARCHIVE_FATAL);
			if (file->multi_extent) {
				struct content *con;

				con = (struct content *)calloc(1, sizeof(*con));
				if (con == NULL) {
					archive_set_error(&archivereader->archive, ENOMEM,
					    "No memory for multi-extent file entry");
					return (ARCHIVE_FATAL);
				}
				con->offset = file->offset;
				con->size = file->size;
				con->next = NULL;
				if (multi == NULL) {
					multi = file;
					multi->contents.first = con;
					multi->contents.last = &(con->next);
				} else {
					*multi->contents.last = con;
					multi->contents.last = &(con->next);
				}
				file->size = 0;
				file->offset = 0;
			} else
				add_entry(archivereader, iso9660, file);
			p += reclen;
			step -= reclen;
		}