while (step > 0) {
			if (step < 34) {
				// Remaining data is too small to be a valid directory record
				break;
			}

			// Parse the directory record
			p = b;
			size_t dr_length = p[DR_length_offset];
			if (dr_length < 34 || dr_length > step) {
				// Invalid directory record length
				break;
			}

			// Check for '.' and '..' entries and skip them
			if (p[DR_name_len_offset] == 1 && (p[DR_name_offset] == 0 || p[DR_name_offset] == 1)) {
				b += dr_length;
				step -= dr_length;
				continue;
			}

			// Parse the file information
			struct file_info *file = parse_file_info(archivereader, parent, p, dr_length);
			if (file == NULL) {
				// Failed to parse file information
				return ARCHIVE_FATAL;
			}

			// Handle multi-extent files
			if (file->multi_extent) {
				if (multi == NULL) {
					multi = file;
				} else {
					// Append to the multi-extent list
					struct content *con = (struct content *)malloc(sizeof(struct content));
					if (con == NULL) {
						archive_set_error(&archivereader->archive, ENOMEM, "No memory for multi-extent file");
						return ARCHIVE_FATAL;
					}
					con->offset = file->offset;
					con->size = file->size;
					con->next = NULL;
					*multi->contents.last = con;
					multi->contents.last = &con->next;
					free(file);
				}
			} else {
				// Add the file to the archive structure
				if (add_entry(archivereader, iso9660, file) != ARCHIVE_OK) {
					return ARCHIVE_FATAL;
				}
			}

			b += dr_length;
			step -= dr_length;
		}