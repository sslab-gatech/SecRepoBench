p = b;
while (p < b + parent->size && step > 0) {
    int r;
    struct file_info *child;
    
    if (*p == 0) {
        /* Skip a null entry. */
        p++;
        continue;
    }
    
    if (p + *p > b + parent->size) {
        /* Avoid overflow. */
        break;
    }
    
    /* Parse this entry. */
    child = parse_file_info(a, parent, p, (size_t)*p);
    if (child == NULL) {
        skip_size = (size_t)(p - b);
        return (ARCHIVE_FATAL);
    }
    
    /* Skip "." entry. */
    if (child->name.s != NULL && strcmp(child->name.s, ".") == 0) {
        p += *p;
        continue;
    }
    
    /* Skip ".." entry. */
    if (child->name.s != NULL && strcmp(child->name.s, "..") == 0) {
        p += *p;
        continue;
    }
    
    if (child->multi_extent && multi != NULL &&
        strcmp(child->name.s, multi->name.s) == 0) {
        struct content *content;
        
        /* This is a continuous data for the last file. */
        content = calloc(1, sizeof(*content));
        if (content == NULL) {
            archive_set_error(&a->archive, ENOMEM, "No memory");
            p += *p;
            skip_size = (size_t)(p - b);
            return (ARCHIVE_FATAL);
        }
        content->offset = (uint64_t)child->offset;
        content->size = (uint64_t)child->size;
        *multi->contents.last = content;
        multi->contents.last = &(content->next);
        p += *p;
        continue;
    }
    
    if (child->multi_extent) {
        struct content *content;
        
        /*
         * This is the first entry of a multi extent file.
         */
        content = calloc(1, sizeof(*content));
        if (content == NULL) {
            archive_set_error(&a->archive, ENOMEM, "No memory");
            p += *p;
            skip_size = (size_t)(p - b);
            return (ARCHIVE_FATAL);
        }
        content->offset = (uint64_t)child->offset;
        content->size = (uint64_t)child->size;
        child->contents.first = content;
        child->contents.last = &(content->next);
        
        /* Mark the file multi extent to collect other extents. */
        multi = child;
    }
    
    r = add_entry(a, iso9660, child);
    if (r != ARCHIVE_OK) {
        skip_size = (size_t)(p - b);
        return (r);
    }
    
    p += *p;
}