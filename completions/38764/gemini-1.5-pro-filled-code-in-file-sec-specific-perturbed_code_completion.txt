p = b + (step - parent->size);
		while(p + 34 <= b + step && p[DR_length_offset] != 0) {
			struct file_info *file;
			size_t reclen;

			reclen = (size_t)(b + step - p);
			file = parse_file_info(archivereader, parent, p, reclen);
			if (file == NULL)
				return (ARCHIVE_FATAL);

			/*
			 * Skip '.' and '..' entries.
			 */
			if (archive_strlen(&file->name) == 1 &&
			    file->name.s[0] == '.') {
				if (file->multi_extent) {
					archive_set_error(
					    &archivereader->archive,
					    ARCHIVE_ERRNO_FILE_FORMAT,
					    "Multi-extent '.' entry");
					return (ARCHIVE_FATAL);
				}
				free(file);
			} else if (archive_strlen(&file->name) == 2 &&
			    file->name.s[0] == '.' &&
			    file->name.s[1] == '.') {
				if (file->multi_extent) {
					archive_set_error(
					    &archivereader->archive,
					    ARCHIVE_ERRNO_FILE_FORMAT,
					    "Multi-extent '..' entry");
					return (ARCHIVE_FATAL);
				}
				free(file);
			} else if (file->multi_extent) {
				struct content *con;

				if (multi != NULL) {
					archive_set_error(
					    &archivereader->archive,
					    ARCHIVE_ERRNO_FILE_FORMAT,
					    "Multi-extent entry not last");
					return (ARCHIVE_FATAL);
				}

				multi = file;
				multi->contents.first = NULL;
				multi->contents.last = &multi->contents.first;
				con = malloc(sizeof(*con));
				if (con == NULL) {
					archive_set_error(
					    &archivereader->archive, ENOMEM,
					    "No memory");
					return (ARCHIVE_FATAL);
				}
				con->offset = file->offset;
				con->size = file->size;
				con->next = NULL;
				*multi->contents.last = con;
				multi->contents.last = &(con->next);
			} else if (multi != NULL) {
				struct content *con;

				con = malloc(sizeof(*con));
				if (con == NULL) {
					archive_set_error(
					    &archivereader->archive, ENOMEM,
					    "No memory");
					return (ARCHIVE_FATAL);
				}
				con->offset = file->offset;
				con->size = file->size;
				con->next = NULL;
				*multi->contents.last = con;
				multi->contents.last = &(con->next);
				/*
				 * Adjust the file size of multi extent entry.
				 */
				multi->size += file->size;
				free(file);
			} else {
				if (add_entry(archivereader, iso9660, file)
				    != ARCHIVE_OK)
					return (ARCHIVE_FATAL);
			}
			p += p[DR_length_offset];
		}
		if (multi != NULL) {
			if (add_entry(archivereader, iso9660, multi)
			    != ARCHIVE_OK)
				return (ARCHIVE_FATAL);
			multi = NULL;
		}
		step = (size_t)parent->size - (step - (b + step - p));
		b = p;
		skip_size = step;