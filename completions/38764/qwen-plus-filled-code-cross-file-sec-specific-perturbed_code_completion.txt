p = b;
while (step > 0) {
    size_t record_len;

    if (*p == 0) {
        /* End of directory entry */
        step -= 1;
        p += 1;
        continue;
    }

    /* Parse the directory record length */
    record_len = ((size_t)p[ISO_DIR_LEN_OFFSET]) + ISO_DIR_BASE_SIZE;

    if (record_len > step) {
        archive_set_error(&archivereader->archive, ARCHIVE_ERRNO_FILE_FORMAT,
            "Invalid directory entry size");
        return (ARCHIVE_FATAL);
    }

    /* Skip '.' and '..' directories */
    if (p[ISO_XA_RECORD_OFFSET] != 0x00 && 
        (p[ISO_NAMELEN_OFFSET] == 1 && 
         (p[ISO_NAME_OFFSET] == '.' || p[ISO_NAME_OFFSET] == '.'))
       ) {
        step -= record_len;
        p += record_len;
        continue;
    }

    /* Allocate memory for file_info structure */
    struct file_info *new_file;
    new_file = (struct file_info *)malloc(sizeof(struct file_info));
    if (new_file == NULL) {
        archive_set_error(&archivereader->archive, ENOMEM,
            "Failed to allocate memory for file info");
        return (ARCHIVE_FATAL);
    }
    memset(new_file, 0, sizeof(struct file_info));

    /* Parse file information */
    parse_file_info(new_file, p);

    /* Handle multi-extent files */
    if (multi && multi->extent == new_file->extent) {
        /* Add to multi-extent list */
        multi->next = new_file;
        multi = new_file;
    } else {
        /* Add as a regular file entry */
        cache_add_entry(iso9660, new_file);
    }

    step -= record_len;
    p += record_len;
}