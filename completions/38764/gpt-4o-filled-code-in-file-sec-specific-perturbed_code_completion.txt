while (step > 0) {
			if (step < 34) {
				archive_set_error(&archivereader->archive, ARCHIVE_ERRNO_MISC,
				    "Invalid length of directory record");
				return (ARCHIVE_FATAL);
			}
			p = b;
			if (*p == 0) {
				/* Found a null entry, which means end of this directory. */
				break;
			}
			if (multi != NULL) {
				/* Handle multi-extent files. */
				struct content *con = (struct content *)malloc(sizeof(*con));
				if (con == NULL) {
					archive_set_error(&archivereader->archive, ENOMEM,
					    "No memory for multi-extent file");
					return (ARCHIVE_FATAL);
				}
				con->offset = iso9660->logical_block_size * (uint64_t)archive_le32dec(p + DR_extent_offset);
				con->size = archive_le32dec(p + DR_size_offset);
				con->next = NULL;
				*multi->contents.last = con;
				multi->contents.last = &(con->next);
				multi = NULL;
			} else {
				/* Parse the file information. */
				struct file_info *file = parse_file_info(archivereader, parent, p, step);
				if (file == NULL)
					return (ARCHIVE_FATAL);

				/* Skip '.' and '..' entries. */
				if (file->name.length == 1 && file->name.s[0] == 0) {
					/* '.' entry */
					free(file);
				} else if (file->name.length == 1 && file->name.s[0] == 1) {
					/* '..' entry */
					free(file);
				} else {
					/* Add the file to the archive structure. */
					if (add_entry(archivereader, iso9660, file) != ARCHIVE_OK)
						return (ARCHIVE_FATAL);
					if (file->multi_extent)
						multi = file;
				}
			}
			step -= p[DR_length_offset];
			b += p[DR_length_offset];
		}