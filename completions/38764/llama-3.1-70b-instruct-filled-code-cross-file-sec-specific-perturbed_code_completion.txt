p = b;
while (step) {
    struct file_info *file;
    int entry_size;

    if (step < 34) {
        archive_set_error(&archivereader->archive, ARCHIVE_ERRNO_MISC,
            "Directory entry too short");
        return (ARCHIVE_FATAL);
    }

    entry_size = p[0];
    if (entry_size == 0) {
        /* Empty entry, skip it. */
        step -= 2;
        p += 2;
        continue;
    }

    if (entry_size + 2 > step) {
        archive_set_error(&archivereader->archive, ARCHIVE_ERRNO_MISC,
            "Directory entry extends past end of buffer");
        return (ARCHIVE_FATAL);
    }

    file = parse_entry(iso9660, p, entry_size);
    if (file == NULL) {
        /* Skip entries for '.' and '..' directories. */
        step -= entry_size + 2;
        p += entry_size + 2;
        continue;
    }

    if (file->mode & AE_IFMT) {
        if ((file->mode & AE_IFMT) == AE_IFDIR) {
            /* Manage multi-extent files by collecting their contents into a list. */
            if (file->number!= -1) {
                if (multi == NULL)
                    multi = file;
                else
                    multi->contents.next = file;
                multi = file;
            }
        } else {
            /* For each valid directory entry, add it to the archive structure. */
            if (file->number!= -1) {
                if (multi!= NULL) {
                    file->contents = multi->contents;
                    multi->contents.next = NULL;
                }
                cache_add_entry(iso9660, file);
            }
        }
    }

    step -= entry_size + 2;
    p += entry_size + 2;
}