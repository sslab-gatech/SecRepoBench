const unsigned char *p = b;
        while (step) {
            size_t dr_len;
            struct file_info *file;

            /* If not enough space left for a directory record length byte, we're done. */
            if (step < DR_length_offset + 1)
                break;

            dr_len = p[DR_length_offset];

            /* A zero length indicates padding to the next block boundary. */
            if (dr_len == 0) {
                size_t block_gap = iso9660->logical_block_size
                    - ((p - b) % iso9660->logical_block_size);
                if (block_gap > step)
                    block_gap = step;
                p += block_gap;
                step -= block_gap;
                continue;
            }

            /* Sanity checks on directory record length. */
            if (dr_len < 34 || dr_len > step)
                break;

            /* Parse a single directory record. */
            file = parse_file_info(archivereader, parent, p, dr_len);
            p += dr_len;
            step -= dr_len;

            if (file == NULL)
                /* Malformed record; skip it. */
                continue;

            /* Skip '.' and '..' entries. */
            if ((archive_strlen(&file->name) == 1 && file->name.s[0] == '.') ||
                (archive_strlen(&file->name) == 2 &&
                 file->name.s[0] == '.' && file->name.s[1] == '.')) {
                archive_string_free(&file->name);
                archive_string_free(&file->symlink);
                free(file);
                continue;
            }

            /* If we're continuing a multi-extent file, append this extent. */
            if (multi != NULL) {
                struct content *con = malloc(sizeof(*con));
                if (con == NULL) {
                    archive_set_error(&archivereader->archive, ENOMEM,
                                      "No memory for multi-extent file");
                    free(file);
                    return (ARCHIVE_FATAL);
                }
                con->offset = file->offset;
                con->size = file->size;
                con->next = NULL;
                *multi->contents.last = con;
                multi->contents.last = &con->next;

                if (!file->multi_extent) {
                    /* The multi-extent file is now complete. */
                    multi->multi_extent = 0;
                    add_entry(archivereader, iso9660, multi);
                    multi = NULL;
                }
                /* Free the temporary file_info object used for this extent. */
                archive_string_free(&file->name);
                archive_string_free(&file->symlink);
                free(file);
                continue;
            }

            /* If this entry begins a multi-extent file, set it up. */
            if (file->multi_extent) {
                struct content *con = malloc(sizeof(*con));
                if (con == NULL) {
                    archive_set_error(&archivereader->archive, ENOMEM,
                                      "No memory for multi-extent file");
                    free(file);
                    return (ARCHIVE_FATAL);
                }
                file->contents.first = con;
                file->contents.last = &con->next;
                con->offset = file->offset;
                con->size = file->size;
                con->next = NULL;
                multi = file;
                continue;
            }

            /* Otherwise, it's a normal single-extent file. */
            add_entry(archivereader, iso9660, file);
        }