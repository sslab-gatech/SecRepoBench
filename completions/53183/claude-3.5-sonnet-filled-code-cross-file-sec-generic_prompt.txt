Below is the content of a C/C++ file where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
static const char*
get_num(mrb_state *mrb, const char *p, const char *end, int *valp)
{
  // Parse an integer from the given string range [p, end) and store it in *valp.
  // Uses mrb_read_int to read the integer, updating the pointer e to the end of the parsed number.
  // Returns NULL if the parsing fails.
  // <MASK>
  return e;
}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// mrbgems/mruby-pack/src/pack.c
// static int
// pack_double(mrb_state *mrb, mrb_value o, mrb_value str, mrb_int sidx, unsigned int flags)
// {
//   int i;
//   double d;
//   uint8_t *buffer = (uint8_t *)&d;
//   str = str_len_ensure(mrb, str, sidx + 8);
//   d = mrb_float(o);
// 
//   if (flags & PACK_FLAG_LITTLEENDIAN) {
//     if (littleendian) {
//       memcpy(RSTRING_PTR(str) + sidx, buffer, 8);
//     }
//     else {
//       for (i = 0; i < 8; ++i) {
//         RSTRING_PTR(str)[sidx + i] = buffer[8 - i - 1];
//       }
//     }
//   } else {
//     if (littleendian) {
//       for (i = 0; i < 8; ++i) {
//         RSTRING_PTR(str)[sidx + i] = buffer[8 - i - 1];
//       }
//     }
//     else {
//       memcpy(RSTRING_PTR(str) + sidx, buffer, 8);
//     }
//   }
// 
//   return 8;
// }

// the below code fragment can be found in:
// src/string.c
// static mrb_int
// str_index_str_by_char_search(mrb_state *mrb, const char *p, const char *pend, const char *s, const mrb_int slen, mrb_int off)
// {
//   /* Based on Quick Search algorithm (Boyer-Moore-Horspool algorithm) */
// 
//   ptrdiff_t qstable[1 << CHAR_BIT];
// 
//   /* Preprocessing */
//   {
//     mrb_int i;
// 
//     for (i = 0; i < 1 << CHAR_BIT; i ++) {
//       qstable[i] = slen;
//     }
//     for (i = 0; i < slen; i ++) {
//       qstable[(unsigned char)s[i]] = slen - (i + 1);
//     }
//   }
// 
//   /* Searching */
//   while (p < pend && pend - p >= slen) {
//     const char *pivot;
// 
//     if (memcmp(p, s, slen) == 0) {
//       return off;
//     }
// 
//     pivot = p + qstable[(unsigned char)p[slen - 1]];
//     if (pivot >= pend || pivot < p /* overflowed */) { return -1; }
// 
//     do {
//       p += mrb_utf8len(p, pend);
//       off ++;
//     } while (p < pivot);
//   }
// 
//   return -1;
// }

// the below code fragment can be found in:
// src/numeric.c
// static mrb_value
// flo_to_s(mrb_state *mrb, mrb_value flt)
// {
//   mrb_float f = mrb_float(flt);
//   mrb_value str;
// 
//   if (isinf(f)) {
//     str = f < 0 ? mrb_str_new_lit(mrb, "-Infinity")
//                 : mrb_str_new_lit(mrb, "Infinity");
//   }
//   else if (isnan(f)) {
//     str = mrb_str_new_lit(mrb, "NaN");
//   }
//   else {
//     str = mrb_float_to_str(mrb, flt, NULL);
//   }
// 
//   RSTR_SET_ASCII_FLAG(mrb_str_ptr(str));
//   return str;
// }

// the below code fragment can be found in:
// src/string.c
// static const char*
// char_adjust(const char *beg, const char *end, const char *ptr)
// {
//   ptrdiff_t len = end - ptr;
//   if (len < 1 || utf8_islead(ptr[0])) return ptr;
//   if (len > 1 && utf8_islead(ptr[1])) return ptr+1;
//   if (len > 2 && utf8_islead(ptr[2])) return ptr+2;
//   if (len > 3 && utf8_islead(ptr[3])) return ptr+3;
//   return ptr;
// }

// the below code fragment can be found in:
// src/string.c
// static mrb_value
// mrb_str_split_m(mrb_state *mrb, mrb_value str)
// {
//   mrb_int argc;
//   mrb_value spat = mrb_nil_value();
//   enum {awk, string} split_type = string;
//   mrb_int i = 0;
//   mrb_int beg;
//   mrb_int end;
//   mrb_int lim = 0;
//   mrb_bool lim_p;
//   mrb_value result, tmp;
// 
//   argc = mrb_get_args(mrb, "|oi", &spat, &lim);
//   lim_p = (lim > 0 && argc == 2);
//   if (argc == 2) {
//     if (lim == 1) {
//       if (RSTRING_LEN(str) == 0)
//         return mrb_ary_new_capa(mrb, 0);
//       return mrb_ary_new_from_values(mrb, 1, &str);
//     }
//     i = 1;
//   }
// 
//   if (argc == 0 || mrb_nil_p(spat)) {
//     split_type = awk;
//   }
//   else if (!mrb_string_p(spat)) {
//     mrb_raise(mrb, E_TYPE_ERROR, "expected String");
//   }
//   else if (RSTRING_LEN(spat) == 1 && RSTRING_PTR(spat)[0] == ' ') {
//     split_type = awk;
//   }
// 
//   result = mrb_ary_new(mrb);
//   beg = 0;
//   if (split_type == awk) {
//     mrb_bool skip = TRUE;
//     mrb_int idx = 0;
//     mrb_int str_len = RSTRING_LEN(str);
//     unsigned int c;
//     int ai = mrb_gc_arena_save(mrb);
// 
//     idx = end = beg;
//     while (idx < str_len) {
//       c = (unsigned char)RSTRING_PTR(str)[idx++];
//       if (skip) {
//         if (ISSPACE(c)) {
//           beg = idx;
//         }
//         else {
//           end = idx;
//           skip = FALSE;
//           if (lim_p && lim <= i) break;
//         }
//       }
//       else if (ISSPACE(c)) {
//         mrb_ary_push(mrb, result, mrb_str_byte_subseq(mrb, str, beg, end-beg));
//         mrb_gc_arena_restore(mrb, ai);
//         skip = TRUE;
//         beg = idx;
//         if (lim_p) ++i;
//       }
//       else {
//         end = idx;
//       }
//     }
//   }
//   else {                        /* split_type == string */
//     mrb_int str_len = RSTRING_LEN(str);
//     mrb_int pat_len = RSTRING_LEN(spat);
//     mrb_int idx = 0;
//     int ai = mrb_gc_arena_save(mrb);
// 
//     while (idx < str_len) {
//       if (pat_len > 0) {
//         end = mrb_memsearch(RSTRING_PTR(spat), pat_len, RSTRING_PTR(str)+idx, str_len - idx);
//         if (end < 0) break;
//       }
//       else {
//         end = chars2bytes(str, idx, 1);
//       }
//       mrb_ary_push(mrb, result, mrb_str_byte_subseq(mrb, str, idx, end));
//       mrb_gc_arena_restore(mrb, ai);
//       idx += end + pat_len;
//       if (lim_p && lim <= ++i) break;
//     }
//     beg = idx;
//   }
//   if (RSTRING_LEN(str) > 0 && (lim_p || RSTRING_LEN(str) > beg || lim < 0)) {
//     if (RSTRING_LEN(str) == beg) {
//       tmp = mrb_str_new(mrb, 0, 0);
//     }
//     else {
//       tmp = mrb_str_byte_subseq(mrb, str, beg, RSTRING_LEN(str)-beg);
//     }
//     mrb_ary_push(mrb, result, tmp);
//   }
//   if (!lim_p && lim == 0) {
//     mrb_int len;
//     while ((len = RARRAY_LEN(result)) > 0 &&
//            (tmp = RARRAY_PTR(result)[len-1], RSTRING_LEN(tmp) == 0))
//       mrb_ary_pop(mrb, result);
//   }
// 
//   return result;
// }
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).