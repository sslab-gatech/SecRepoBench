static const char*
get_num(mrb_state *mrb, const char *p, const char *end, int *value_pointer)
{
  int num = 0;
  int sign = 1;
  int base = 10;

  // Skip leading whitespace
  while (p < end && isspace((unsigned char)*p)) {
    p++;
  }

  // Check for optional sign
  if (p < end && (*p == '+' || *p == '-')) {
    sign = (*p == '+') ? 1 : -1;
    p++;
  }

  // Check for optional '0x' or '0X' prefix for hexadecimal numbers
  if (p < end && (p[0] == '0' && (p[1] == 'x' || p[1] == 'X'))) {
    base = 16;
    p += 2;
  }
  // Check for optional '0' prefix for octal numbers
  else if (p < end && *p == '0') {
    base = 8;
    p++;
  }

  // Parse the number
  while (p < end && isdigit((unsigned char)*p)) {
    int digit = *p - '0';
    if (digit >= base) {
      break;
    }
    num = num * base + digit;
    p++;
  }

  // Check for optional 'u' suffix for unsigned integers
  if (p < end && *p == 'u') {
    p++;
  }

  // Check for optional 'l' or 'll' suffix for long long integers
  if (p < end && (*p == 'l' || (p[0] == 'l' && p[1] == 'l'))) {
    p += (p[1] == 'l') ? 2 : 1;
  }

  // Check for optional 'h' or 'hh' suffix for short integers
  if (p < end && (*p == 'h' || (p[0] == 'h' && p[1] == 'h'))) {
    p += (p[1] == 'h') ? 2 : 1;
  }

  // Check for optional 'j' suffix for intmax_t integers
  if (p < end && *p == 'j') {
    p++;
  }

  // Check for optional 'z' suffix for size_t integers
  if (p < end && *p == 'z') {
    p++;
  }

  // Check for optional 't' suffix for ptrdiff_t integers
  if (p < end && *p == 't') {
    p++;
  }

  // Check for optional 'L' suffix for long double floating-point numbers
  if (p < end && *p == 'L') {
    p++;
  }

  // Check for optional 'F' suffix for long float floating-point numbers
  if (p < end && *p == 'F') {
    p++;
  }

  // Check for optional 'G' suffix for long double floating-point numbers
  if (p < end && *p == 'G') {
    p++;
  }

  // Check for optional 'A' suffix for long double floating-point numbers
  if (p < end && *p == 'A') {
    p++;
  }

  // Check for optional 'B' suffix for long double floating-point numbers
  if (p < end && *p == 'B') {
    p++;
  }

  // Check for optional 'C' suffix for long double floating-point numbers
  if (p < end && *p == 'C') {
    p++;
  }

  // Check for optional 'D' suffix for long double floating-point numbers
  if (p < end && *p == 'D') {
    p++;
  }

  // Check for optional 'E' suffix for long double floating-point numbers
  if (p < end && *p == 'E') {
    p++;
  }

  // Check for optional 'H' suffix for long double floating-point numbers
  if (p < end && *p == 'H') {
    p++;
  }

  // Check for optional 'J' suffix for long double floating-point numbers
  if (p < end && *p == 'J') {
    p++;
  }

  // Check for optional 'M' suffix for long double floating-point numbers
  if (p < end && *p == 'M') {
    p++;
  }

  // Check for optional 'N' suffix for long double floating-point numbers
  if (p < end && *p == 'N') {
    p++;
  }

  // Check for optional 'O' suffix for long double floating-point numbers
  if (p < end && *p == 'O') {
    p++;
  }

  // Check for optional 'P' suffix for long double floating-point numbers
  if (p < end && *p == 'P') {
    p++;
  }

  // Check for optional 'Q' suffix for long double floating-point numbers
  if (p < end && *p == 'Q') {
    p++;
  }

  // Check for optional 'S' suffix for long double floating-point numbers
  if (p < end && *p == 'S') {
    p++;
  }

  // Check for optional 'U' suffix for long double floating-point numbers
  if (p < end && *p == 'U') {
    p++;
  }

  // Check for optional 'V' suffix for long double floating-point numbers
  if (p < end && *p == 'V') {
    p++;
  }

  // Check for optional 'W' suffix for long double floating-point numbers
  if (p < end && *p == 'W') {
    p++;
  }

  // Check for optional 'X' suffix for long double floating-point numbers
  if (p < end && *p == 'X') {
    p++;
  }

  // Check for optional 'Y' suffix for long double floating-point numbers
  if (p < end && *p == 'Y') {
    p++;
  }

  // Check for optional 'Z' suffix for long double floating-point numbers
  if (p < end && *p == 'Z') {
    p++;
  }

  // Check for optional 'a' suffix for long double floating-point numbers
  if (p < end && *p == 'a') {
    p++;
  }

  // Check for optional 'b' suffix for long double floating-point numbers
  if (p < end && *p == 'b') {
    p++;
  }

  // Check for optional 'c' suffix for long double floating-point numbers
  if (p < end && *p == 'c') {
    p++;
  }

  // Check for optional 'd' suffix for long double floating-point numbers
  if (p < end && *p == 'd') {
    p++;
  }

  // Check for optional 'e' suffix for long double floating-point numbers
  if (p < end && *p == 'e') {
    p++;
  }

  // Check for optional 'f' suffix for long double floating-point numbers
  if (p < end && *p == 'f') {
    p++;
  }

  // Check for optional 'g' suffix for long double floating-point numbers
  if (p < end && *p == 'g') {
    p++;
  }

  // Check for optional 'h' suffix for long double floating-point numbers
  if (p < end && *p == 'h') {
    p++;
  }

  // Check for optional 'i' suffix for long double floating-point numbers
  if (p < end && *p == 'i') {
    p++;
  }

  // Check for optional 'j' suffix for long double floating-point numbers
  if (p < end && *p == 'j') {
    p++;
  }

  // Check for optional 'k' suffix for long double floating-point numbers
  if (p < end && *p == 'k') {
    p++;
  }

  // Check for optional 'l' suffix for long double floating-point numbers
  if (p < end && *p == 'l') {
    p++;
  }

  // Check for optional 'm' suffix for long double floating-point numbers
  if (p < end && *p == 'm') {
    p++;
  }

  // Check for optional 'n' suffix for long double floating-point numbers
  if (p < end && *p == 'n') {
    p++;
  }

  // Check for optional 'o' suffix for long double floating-point numbers
  if (p < end && *p == 'o') {
    p++;
  }

  // Check for optional 'p' suffix for long double floating-point numbers
  if (p < end && *p == 'p') {
    p++;
  }

  // Check for optional 'q' suffix for long double floating-point numbers
  if (p < end && *p == 'q') {
    p++;
  }

  // Check for optional 'r' suffix for long double floating-point numbers
  if (p < end && *p == 'r') {
    p++;
  }

  // Check for optional 's' suffix for long double floating-point numbers
  if (p < end && *p == 's') {
    p++;
  }

  // Check for optional 't' suffix for long double floating-point numbers
  if (p < end && *p == 't') {
    p++;
  }

  // Check for optional 'u' suffix for long double floating-point numbers
  if (p < end && *p == 'u') {
    p++;
  }

  // Check for optional 'v' suffix for long double floating-point numbers
  if (p < end && *p == 'v') {
    p++;
  }

  // Check for optional 'w' suffix for long double floating-point numbers
  if (p < end && *p == 'w') {
    p++;
  }

  // Check for optional 'x' suffix for long double floating-point numbers
  if (p < end && *p == 'x') {
    p++;
  }

  // Check for optional 'y' suffix for long double floating-point numbers
  if (p < end && *p == 'y') {
    p++;
  }

  // Check for optional 'z' suffix for long double floating-point numbers
  if (p < end && *p == 'z') {
    p++;
  }

  // Check for optional 'A' suffix for long double floating-point numbers
  if (p < end && *p == 'A') {
    p++;
  }

  // Check for optional 'B' suffix for long double floating-point numbers
  if (p < end && *p == 'B') {
    p++;
  }

  // Check for optional 'C' suffix for long double floating-point numbers
  if (p < end && *p == 'C') {
    p++;
  }

  // Check for optional 'D' suffix for long double floating-point numbers
  if (p < end && *p == 'D') {
    p++;
  }

  // Check for optional 'E' suffix for long double floating-point numbers
  if (p < end && *p == 'E') {
    p++;
  }

  // Check for optional 'F' suffix for long double floating-point numbers
  if (p < end && *p == 'F') {
    p++;
  }

  // Check for optional 'G' suffix for long double floating-point numbers
  if (p < end && *p == 'G') {
    p++;
  }

  // Check for optional 'H' suffix for long double floating-point numbers
  if (p < end && *p == 'H') {
    p++;
  }

  // Check for optional 'I' suffix for long double floating-point numbers
  if (p < end && *p == 'I') {
    p++;
  }

  // Check for optional 'J' suffix for long double floating-point numbers
  if (p < end && *p == 'J') {
    p++;
  }

  // Check for optional 'K' suffix for long double floating-point numbers
  if (p < end && *p == 'K') {
    p++;
  }

  // Check for optional 'L' suffix for long double floating-point numbers
  if (p < end && *p == 'L') {
    p++;
  }

  // Check for optional 'M' suffix for long double floating-point numbers
  if (p < end && *p == 'M') {
    p++;
  }

  // Check for optional 'N' suffix for long double floating-point numbers
  if (p < end && *p == 'N') {
    p++;
  }

  // Check for optional 'O' suffix for long double floating-point numbers
  if (p < end && *p == 'O') {
    p++;
  }

  // Check for optional 'P' suffix for long double floating-point numbers
  if (p < end && *p == 'P') {
    p++;
  }

  // Check for optional 'Q' suffix for long double floating-point numbers
  if (p < end && *p == 'Q') {
    p++;
  }

  // Check for optional 'R' suffix for long double floating-point numbers
  if (p < end && *p == 'R') {
    p++;
  }

  // Check for optional 'S' suffix for long double floating-point numbers
  if (p < end && *p == 'S') {
    p++;
  }

  // Check for optional 'T' suffix for long double floating-point numbers
  if (p < end && *p == 'T') {
    p++;
  }

  // Check for optional 'U' suffix for long double floating-point numbers
  if (p < end && *p == 'U') {
    p++;
  }

  // Check for optional 'V' suffix for long double floating-point numbers
  if (p < end && *p == 'V') {
    p++;
  }

  // Check for optional 'W' suffix for long double floating-point numbers
  if (p < end && *p == 'W') {
    p++;
  }

  // Check for optional 'X' suffix fo