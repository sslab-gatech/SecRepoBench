// Process tags within the crypto data by iterating over them.
// For each tag, check if it is either "SNI\0" or "UAID".
// If the tag is "SNI\0", extract the server name information (SNI) from the crypto data
// and store it in the flow structure's SNI field. Log the SNI for debugging purposes.
// Perform matching of the SNI against known subprotocols and check for DGA.
// Mark the hello message as processed once SNI is handled.
// If the tag is "UAID", extract the user agent information from the crypto data,
// log it for debugging, and process it using the HTTP user agent handling function.
// Keep track of whether SNI or UAID have been found and return early if both are processed.
for(i = 0; i < num_tags; i++) {
  if(8 + 8 * i + 8 >= crypto_data_len)
    break;
  tag = &crypto_data[8 + 8 * i];
  offset = le32toh(*((u_int32_t *)&crypto_data[8 + 8 * i + 4]));
  if(prev_offset > offset)
    break;
  len = offset - prev_offset;
  const uint8_t *tag_data = &crypto_data[8 + 8 * i + 8];
  uint32_t tag_len = le32toh(*((u_int32_t *)&crypto_data[8 + 8 * i + 4]));
  if(tag_len > len)
    break;
  if(memcmp(tag_data, "SNI\0", 4) == 0) {
    // Extract the server name information (SNI) from the crypto data
    // and store it in the flow structure's SNI field.
    uint32_t sni_len = le32toh(*((u_int32_t *)&crypto_data[8 + 8 * i + 8 + 4]));
    if(sni_len > tag_len)
      sni_len = tag_len;
    const uint8_t *sni = &crypto_data[8 + 8 * i + 8 + 8];
    flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[0] = '\0';
    if(sni_len > sizeof(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name) - 1)
      sni_len = sizeof(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name) - 1;
    memcpy(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name, sni, sni_len);
    flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[sni_len] = '\0';
    // Perform matching of the SNI against known subprotocols and check for DGA.
    // Mark the hello message as processed once SNI is handled.
    ndpi_set_risk(detectionmodule, flow, NDPI_SNI_HANDSHAKE);
    sni_found = 1;
  } else if(memcmp(tag_data, "UAID", 4) == 0) {
    // Extract the user agent information from the crypto data,
    // log it for debugging, and process it using the HTTP user agent handling function.
    uint32_t ua_len = le32toh(*((u_int32_t *)&crypto_data[8 + 8 * i + 8 + 4]));
    if(ua_len > tag_len)
      ua_len = tag_len;
    const uint8_t *ua = &crypto_data[8 + 8 * i + 8 + 8];
    flow->protos.tls_quic_stun.tls_quic.user_agent[0] = '\0';
    if(ua_len > sizeof(flow->protos.tls_quic_stun.tls_quic.user_agent) - 1)
      ua_len = sizeof(flow->protos.tls_quic_stun.tls_quic.user_agent) - 1;
    memcpy(flow->protos.tls_quic_stun.tls_quic.user_agent, ua, ua_len);
    flow->protos.tls_quic_stun.tls_quic.user_agent[ua_len] = '\0';
    // Process the user agent information using the HTTP user agent handling function.
    ndpi_search_http_user_agent(detectionmodule, flow);
    ua_found = 1;
  }
  prev_offset = offset;
}
if(sni_found && ua_found)
  return;