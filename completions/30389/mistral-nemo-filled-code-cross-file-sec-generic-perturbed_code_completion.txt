for(i = 0; i < num_tags; i++) {
    if(8 + 8 * i + 8 >= crypto_data_len)
      break;
    tag = &crypto_data[8 + 8 * i];
    offset = le32toh(*((u_int32_t *)&crypto_data[8 + 8 * i + 4]));
    if(prev_offset > offset)
      break;
    len = offset - prev_offset;

    if(memcmp(tag, "SNI\0", 4) == 0) {
      sni_len = len - 4;
      if(sni_len > 0) {
        memcpy(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name, &crypto_data[prev_offset + 4], sni_len);
        flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[sni_len] = '\0';
        ndpi_set_risk(detectionmodule, flow, NDPI_TLS_SNI_FOUND);
        sni_found = 1;
        ret_match = ndpi_detection_process_tls_sni(detectionmodule, flow, flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);
        if(ret_match != NDPI_PROTOCOL_MATCH_UNKNOWN) {
          ndpi_set_protocol(detectionmodule, flow, ret_match);
        }
      }
    } else if(memcmp(tag, "UAID", 4) == 0) {
      ua_len = len - 4;
      if(ua_len > 0) {
        memcpy(flow->protos.tls_quic_stun.tls_quic.user_agent, &crypto_data[prev_offset + 4], ua_len);
        flow->protos.tls_quic_stun.tls_quic.user_agent[ua_len] = '\0';
        ndpi_set_risk(detectionmodule, flow, NDPI_TLS_UAID_FOUND);
        ua_found = 1;
        ndpi_detection_process_http_user_agent(detectionmodule, flow, flow->protos.tls_quic_stun.tls_quic.user_agent);
      }
    }

    prev_offset = offset;
  }
  if(sni_found && ua_found)
    return;