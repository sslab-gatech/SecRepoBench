if (len > crypto_data_len - tag_offset_start) {
        NDPI_LOG_ERR(detectionmodule, "Tag length exceeds available crypto data\n");
        return;
    }

    if (memcmp(tag, "SNI\0", 4) == 0) {
        sni_len = len - 4; // Exclude the null terminator
        if (sni_len > sizeof(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name) - 1) {
            NDPI_LOG_ERR(detectionmodule, "SNI length exceeds buffer size\n");
            return;
        }
        memcpy(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name, &crypto_data[tag_offset_start + prev_offset + 4], sni_len);
        flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[sni_len] = '\0'; // Null-terminate
        sni_found = 1;
        NDPI_LOG_DBG(detectionmodule, "SNI found: %s\n", flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);
    } else if (memcmp(tag, "UAID", 4) == 0) {
        // Handle UAID similarly, ensuring no overflow occurs
        // Assuming a similar structure exists for UAID
        // Example: memcpy(flow->protos.tls_quic_stun.tls_quic.user_agent_id, &crypto_data[tag_offset_start + prev_offset + 4], len - 4);
        ua_found = 1;
        NDPI_LOG_DBG(detectionmodule, "UAID found\n");
    }

    if (sni_found && ua_found) {
        return; // Both SNI and UAID processed, exit early
    }