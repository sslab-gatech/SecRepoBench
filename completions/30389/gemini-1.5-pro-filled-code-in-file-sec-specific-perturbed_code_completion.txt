if(tag_offset_start + len > crypto_data_len)
      break;
    if(len == 4 && memcmp(tag, "SNI\0", 4) == 0) {
      sni_len = le32toh(*((u_int32_t *)&crypto_data[tag_offset_start]));
      if(sni_len + tag_offset_start + 4 <= crypto_data_len) {
        NDPI_LOG_DBG(detectionmodule, "SNI: [%.*s]\n", sni_len, &crypto_data[tag_offset_start + 4]);
        // Allocate memory for SNI only if it's not already allocated or if the new SNI is longer.
        if (flow->protos.tls_quic_stun.tls_quic.client_requested_server_name == NULL ||
            sni_len > strlen(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name)) {
          ndpi_free(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);
          flow->protos.tls_quic_stun.tls_quic.client_requested_server_name = (char *)ndpi_malloc(sni_len + 1);
        }
        // Check if memory allocation was successful.
        if (flow->protos.tls_quic_stun.tls_quic.client_requested_server_name != NULL) {
          // Copy the SNI into the allocated buffer.
          memcpy(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name, &crypto_data[tag_offset_start + 4], sni_len);
          flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[sni_len] = '\0';
          ret_match = ndpi_match_protocol_from_sni(detectionmodule, flow);
          if (ret_match == NDPI_MATCH_PROTOCOL_DGA_DETECTED) {
            NDPI_LOG_DBG(detectionmodule, "DGA detected\n");
            ndpi_set_risk(detectionmodule, flow, NDPI_RISK_DGA);
          }
        }
      }
      sni_found = 1;
    } else if(len == 5 && memcmp(tag, "UAID", 4) == 0) {
      uint8_t ua_len = crypto_data[tag_offset_start];
      if(ua_len + tag_offset_start + 1 <= crypto_data_len) {
        NDPI_LOG_DBG(detectionmodule, "UA: [%.*s]\n", ua_len, &crypto_data[tag_offset_start + 1]);
        http_process_user_agent(detectionmodule, flow, &crypto_data[tag_offset_start + 1], ua_len);
      }
      ua_found = 1;
    }
    tag_offset_start += len;
    if(sni_found && ua_found)
      return;