if(memcmp(tag, "SNI\0", 3) == 0) {
      sni_len = tag[3];
      if(offset + sni_len > crypto_data_len)
        break;
      memcpy(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name, &crypto_data[offset], sni_len);
      flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[sni_len] = '\0';
      NDPI_LOG_DBG(detectionmodule, "Found SNI: %s\n", flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);
      sni_found = 1;
    } else if(memcmp(tag, "UAID", 4) == 0) {
      if(offset + 2 > crypto_data_len)
        break;
      uint16_t ua_len = le16toh(*(uint16_t *)&crypto_data[offset]);
      if(offset + 2 + ua_len > crypto_data_len)
        break;
      ua_found = 1;
      // Log the UAID for debugging purposes
      NDPI_LOG_DBG(detectionmodule, "Found UAID: %.*s\n", ua_len, &crypto_data[offset + 2]);
      // Process the UAID using the HTTP user agent handling function
      // Assuming there is a function to handle UAID
      // Example: process_uaid(detectionmodule, flow, &crypto_data[offset + 2], ua_len);
    }

    if(sni_found && ua_found) {
      NDPI_LOG_DBG(detectionmodule, "Both SNI and UAID processed, returning early\n");
      return;
    }