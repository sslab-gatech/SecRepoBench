if(memcmp(tag, "SNI\0", 4) == 0) {
      if(len > sizeof(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name) - 1)
        sni_len = sizeof(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name) - 1;
      else
        sni_len = len;
      memcpy(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,
             &crypto_data[tag_offset_start + prev_offset], sni_len);
      flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[sni_len] = '\0';
#ifdef QUIC_DEBUG
      NDPI_LOG_DBG(detectionmodule, "SNI: %s\n", flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);
#endif
      ret_match = ndpi_match_subprotocol(detectionmodule, flow,
                                           flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,
                                           sizeof(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name));

      if(ret_match == NDPI_PROTOCOL_MATCH_DGA) {
        ndpi_set_risk(detectionmodule, flow, NDPI_PROTOCOL_RISK_DGA);
      }

      flow->protos.tls_quic_stun.tls_quic.hello_processed = 1;
      sni_found = 1;
    } else if(memcmp(tag, "UAID", 4) == 0) {
#ifdef QUIC_DEBUG
      char *user_agent = ndpi_malloc(len + 1);
      if(user_agent != NULL) {
        memcpy(user_agent, &crypto_data[tag_offset_start + prev_offset], len);
        user_agent[len] = '\0';
        NDPI_LOG_DBG(detectionmodule, "UAID: %s\n", user_agent);
        ndpi_free(user_agent);
      }
#endif
      process_http_user_agent(detectionmodule, flow, &crypto_data[tag_offset_start + prev_offset], len);
      ua_found = 1;
    }
    if(sni_found && ua_found)
      return;