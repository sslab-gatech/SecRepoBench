// <MASK>
if(memcmp(tag, "SNI\0", 4) == 0) {
  offset = le32toh(*((u_int32_t *)&crypto_data[tag_offset_start + 8 * i + 4]));
  sni_len = offset - prev_offset;
  if(sni_len > 0) {
    memcpy(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,
           &crypto_data[prev_offset], MIN(sni_len, sizeof(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name) - 1));
    flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[MIN(sni_len, sizeof(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name) - 1)] = '\0';
    NDPI_LOG_DBG2(detectionmodule, "SNI: [%s]\n", flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);
    ret_match = ndpi_match_subprotocol(ndpi_struct, flow, NDPI_PROTOCOL_QUIC, flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);
    if(ret_match!= NDPI_NO_MATCH) {
      ndpi_int_change_protocol(ndpi_struct, flow, ret_match, NDPI_PROTOCOL_QUIC);
    }
    if(ndpi_check_dga(ndpi_struct, flow, NDPI_PROTOCOL_QUIC, flow->protos.tls_quic_stun.tls_quic.client_requested_server_name)) {
      ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_DGA);
    }
    sni_found = 1;
    flow->protos.tls_quic_stun.tls_quic.hello_processed = 1;
  }
} else if(memcmp(tag, "UAID", 4) == 0) {
  offset = le32toh(*((u_int32_t *)&crypto_data[tag_offset_start + 8 * i + 4]));
  sni_len = offset - prev_offset;
  if(sni_len > 0) {
    NDPI_LOG_DBG2(detectionmodule, "UAID: [%.*s]\n", sni_len, &crypto_data[prev_offset]);
    http_process_user_agent(ndpi_struct, flow, &crypto_data[prev_offset], sni_len);
    ua_found = 1;
  }
}
if(sni_found && ua_found) {
  return;
}
// </MASK>