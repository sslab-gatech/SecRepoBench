if (memcmp(tag, "SNI\0", 4) == 0) {
  sni_found = 1;
  
  if (tag_offset_start + prev_offset < crypto_data_len) {
    sni_len = len;
    
    // Ensure we don't read beyond crypto_data
    if (tag_offset_start + prev_offset + sni_len > crypto_data_len) {
      sni_len = crypto_data_len - (tag_offset_start + prev_offset);
    }
    
    // Ensure we don't overflow the destination buffer
    if (sni_len >= sizeof(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name)) {
      sni_len = sizeof(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name) - 1;
    }
    
    if (sni_len > 0) {
      memcpy(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,
             &crypto_data[tag_offset_start + prev_offset], sni_len);
      flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[sni_len] = '\0';
      
      NDPI_LOG_DBG2(detectionmodule, "SNI: %s\n", flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);
      
      // Check for subprotocols
      ndpi_match_host_subprotocol(detectionmodule, flow,
                                 flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,
                                 strlen(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name),
                                 &ret_match, NDPI_PROTOCOL_QUIC);
      
      // Check for DGA
      if (ndpi_check_dga_name(detectionmodule,
                             flow,
                             flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,
                             1, 0)) {
        NDPI_LOG_DBG(detectionmodule, "DGA detected for SNI: %s\n",
                    flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);
      }
      
      flow->protos.tls_quic_stun.tls_quic.hello_processed = 1;
    }
  } else {
    NDPI_LOG_DBG(detectionmodule, "Invalid SNI offset %u\n", tag_offset_start + prev_offset);
  }
} else if (memcmp(tag, "UAID", 4) == 0) {
  ua_found = 1;
  
  if (tag_offset_start + prev_offset < crypto_data_len) {
    uint32_t ua_len = len;
    
    // Ensure we don't read beyond crypto_data
    if (tag_offset_start + prev_offset + ua_len > crypto_data_len) {
      ua_len = crypto_data_len - (tag_offset_start + prev_offset);
    }
    
    if (ua_len > 0) {
      char ua[256];
      
      // Ensure we don't overflow the UA buffer
      if (ua_len >= sizeof(ua)) {
        ua_len = sizeof(ua) - 1;
      }
      
      memcpy(ua, &crypto_data[tag_offset_start + prev_offset], ua_len);
      ua[ua_len] = '\0';
      
      NDPI_LOG_DBG2(detectionmodule, "User-Agent: %s\n", ua);
      
      ndpi_match_ua_category(detectionmodule, flow, ua, ua_len);
    }
  } else {
    NDPI_LOG_DBG(detectionmodule, "Invalid UA offset %u\n", tag_offset_start + prev_offset);
  }
}

if (sni_found && ua_found) {
  // Both SNI and UA have been processed, we can stop
  return;
}