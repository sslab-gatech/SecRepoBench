/* Ensure offsets are within bounds */
    if((tag_offset_start + offset) <= crypto_data_len) {
      /* 'len' bytes of data for this tag are located from
       * crypto_data[tag_offset_start + prev_offset] to
       * crypto_data[tag_offset_start + offset - 1].
       */
      if(memcmp(tag, "SNI\0", 4) == 0 && !sni_found && len > 0) {
        /* Extract SNI */
        sni_len = (len < sizeof(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name) - 1)
                    ? len
                    : sizeof(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name) - 1;

        memcpy(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,
               &crypto_data[tag_offset_start + prev_offset],
               sni_len);
        flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[sni_len] = '\0';

#ifdef QUIC_DEBUG
        NDPI_LOG_DBG(detectionmodule, "[QUIC] SNI: %s\n",
                     flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);
#endif

        /* (Optional) Match SNI against known subprotocols and check for DGA here */
        /* ret_match = ndpi_match_subprotocol(detectionmodule, flow, ...);
           if(ret_match.detected) {
             ndpi_int_add_connection_to_protocol(...);
           } */

        sni_found = 1;
        /* Mark the hello message as processed if needed */
        /* flow->protos.tls_quic_stun.tls_quic.hello_processed = 1; */

        if(sni_found && ua_found)
          return;
      } else if(memcmp(tag, "UAID", 4) == 0 && !ua_found && len > 0) {
        /* Temporarily store user agent in a local buffer to process */
        char ua_buffer[256];
        uint32_t ua_len = (len < sizeof(ua_buffer) - 1) ? len : sizeof(ua_buffer) - 1;

        memcpy(ua_buffer, &crypto_data[tag_offset_start + prev_offset], ua_len);
        ua_buffer[ua_len] = '\0';

#ifdef QUIC_DEBUG
        NDPI_LOG_DBG(detectionmodule, "[QUIC] UAID: %s\n", ua_buffer);
#endif

        /* Process UA with HTTP user agent handling if relevant */
        /* ndpi_search_http_user_agent(detectionmodule, flow, ua_buffer, ua_len); */

        ua_found = 1;
        if(sni_found && ua_found)
          return;
      }
    }