if (memcmp(tag, "SNI\0", 4) == 0) {
        uint32_t sni_start = tag_offset_start + prev_offset;
        if (sni_start + len > crypto_data_len) break;
        size_t copy_len = ndpi_min(len, sizeof(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name) - 1);
        strncpy(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name, (const char*)&crypto_data[sni_start], copy_len);
        flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[copy_len] = '\0';
#ifdef QUIC_DEBUG
        NDPI_LOG_DBG(detectionmodule, "Found SNI: %s", flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);
#endif
        ndpi_match_host_subprotocol(detectionmodule, flow, flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,
                                    strlen(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name), &ret_match, 0);
        if(ndpi_check_dga_name(detectionmodule, flow, flow->protos.tls_quic_stun.tls_quic.client_requested_server_name))
            ndpi_set_risk(detectionmodule, flow, NDPI_DGA_DOMAIN);
        flow->protos.tls_quic_stun.tls_quic.hello_processed = 1;
        sni_found = 1;
    } else if (memcmp(tag, "UAID", 4) == 0) {
        uint32_t ua_start = tag_offset_start + prev_offset;
        if (ua_start + len > crypto_data_len) break;
        char ua[256];
        size_t copy_len = ndpi_min(len, sizeof(ua)-1);
        strncpy(ua, (const char*)&crypto_data[ua_start], copy_len);
        ua[copy_len] = '\0';
#ifdef QUIC_DEBUG
        NDPI_LOG_DBG(detectionmodule, "Found UA: %s", ua);
#endif
        ndpi_process_http_user_agent(detectionmodule, flow, ua, copy_len);
        ua_found = 1;
    }
    if(sni_found && ua_found)
        break;