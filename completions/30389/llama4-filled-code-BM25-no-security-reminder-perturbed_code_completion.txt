for(i = 0; i < num_tags; i++) {
    if(8 + 8 * i + 8 >= crypto_data_len)
      break;
    tag = &crypto_data[8 + 8 * i];
    offset = le32toh(*((u_int32_t *)&crypto_data[8 + 8 * i + 4]));
    if(prev_offset > offset)
      break;
    len = offset - prev_offset;
    if(memcmp(tag, "SNI\0", 4) == 0) {
      sni_len = len;
      if(sni_len > NDPI_MAX_SNI_LEN)
        sni_len = NDPI_MAX_SNI_LEN;
      memcpy(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name, tag + 4, sni_len);
      flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[sni_len] = '\0';
#ifdef QUIC_DEBUG
      NDPI_LOG_DBG(detectionmodule, "SNI: %s\n", flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);
#endif
      ndpi_match_subprotocols(detectionmodule, flow, NDPI_LOG_DBG);
      ndpi_check_dga(detectionmodule, flow);
      sni_found = 1;
      flow->flags |= NDPI_DETECTION_HELLO_MSG_PROCESS; /* Mark hello message as processed */
    } else if(memcmp(tag, "UAID", 4) == 0) {
      ua_found = 1;
#ifdef QUIC_DEBUG
      NDPI_LOG_DBG(detectionmodule, "UAID: %.*s\n", (int)len, tag + 4);
#endif
      ndpi_parse_http_user_agent(detectionmodule, flow, tag + 4, len);
    }
    if(sni_found && ua_found)
      break;

    prev_offset = offset;
}