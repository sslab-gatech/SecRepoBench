if(memcmp(tag, "SNI\0", 4) == 0) {
        sni_len = len - 4; // Length of SNI excluding the tag
        if (sni_len > sizeof(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name) - 1) {
            sni_len = sizeof(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name) - 1; // Prevent overflow
        }
        memcpy(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name, &tag[4], sni_len);
        flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[sni_len] = '\0'; // Null-terminate
        sni_found = 1;

#ifdef QUIC_DEBUG
        NDPI_LOG_DBG(detectionmodule, "SNI found: %s\n", flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);
#endif

        // Perform matching against known subprotocols and check for DGA
        // (Assuming a function `ndpi_match_sni` exists for this purpose)
        ret_match = ndpi_match_sni(detectionmodule, flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);
        if (ret_match == NDPI_PROTOCOL_MATCH) {
            ndpi_set_risk(detectionmodule, flow, NDPI_TLS_SNI_MATCH);
        }

    } else if(memcmp(tag, "UAID", 4) == 0) {
        // Extract UAID
        if (len > sizeof(flow->protos.tls_quic_stun.tls_quic.user_agent_id) - 1) {
            len = sizeof(flow->protos.tls_quic_stun.tls_quic.user_agent_id) - 1; // Prevent overflow
        }
        memcpy(flow->protos.tls_quic_stun.tls_quic.user_agent_id, &tag[4], len);
        flow->protos.tls_quic_stun.tls_quic.user_agent_id[len] = '\0'; // Null-terminate
        ua_found = 1;

#ifdef QUIC_DEBUG
        NDPI_LOG_DBG(detectionmodule, "UAID found: %s\n", flow->protos.tls_quic_stun.tls_quic.user_agent_id);
#endif

        // Process UAID (Assuming a function `ndpi_process_user_agent` exists for this purpose)
        ndpi_process_user_agent(detectionmodule, flow->protos.tls_quic_stun.tls_quic.user_agent_id);
    }

    // Return early if both SNI and UAID have been found
    if (sni_found && ua_found) {
        return;
    }