if(len > 0 && (tag_offset_start + prev_offset + len) <= crypto_data_len) {
      /* Pointer to the current tag's data */
      const uint8_t *data_ptr = &crypto_data[tag_offset_start + prev_offset];

      /* Check if the tag is "SNI\0" */
      if(memcmp(tag, "SNI\0", 4) == 0 && !sni_found) {
        sni_len = (len < sizeof(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name) - 1)
          ? len
          : (sizeof(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name) - 1);

        memcpy(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name, data_ptr, sni_len);
        flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[sni_len] = '\0';

#ifdef QUIC_DEBUG
        NDPI_LOG_DBG(detectionmodule, "CHLO: Found SNI: %s\n",
                     flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);
#endif
        /* Perform matching of the SNI against known subprotocols and check for DGA if needed */
        /* e.g., checkTLSSubprotocol(detectionmodule, flow); ndpi_int_check_dga(...); */

        flow->protos.tls_quic_stun.tls_quic.hello_processed = 1;
        sni_found = 1;
      }
      /* Check if the tag is "UAID" */
      else if(memcmp(tag, "UAID", 4) == 0 && !ua_found) {
        char ua_buf[256];
        uint32_t ua_len = (len < sizeof(ua_buf) - 1) ? len : (sizeof(ua_buf) - 1);

        memcpy(ua_buf, data_ptr, ua_len);
        ua_buf[ua_len] = '\0';

#ifdef QUIC_DEBUG
        NDPI_LOG_DBG(detectionmodule, "CHLO: Found UAID: %s\n", ua_buf);
#endif
        /* Process it using the HTTP user agent handling function, e.g.:
           ndpi_parse_user_agent(detectionmodule, flow, (const uint8_t *)ua_buf, ua_len, 0); */

        ua_found = 1;
      }

      /* Return early if we've processed both SNI and UAID */
      if(sni_found && ua_found)
        return;
    }