if(tag_offset_start + offset + len > crypto_data_len)
      break;

    if(len == 4 && memcmp(tag, "SNI\0", 4) == 0) {
      sni_len = le32toh(*((u_int32_t *)&crypto_data[tag_offset_start + offset]));
      if(sni_len + tag_offset_start + offset + 4 <= crypto_data_len) {
	if (sni_len > 0) {
          memcpy(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,
                 &crypto_data[tag_offset_start + offset + 4],
                 sni_len > MAX_SNI_LEN ? MAX_SNI_LEN : sni_len);
          flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[MAX_SNI_LEN] = 0;
	}

#ifdef QUIC_DEBUG
	NDPI_LOG_DBG(detectionmodule, "SNI: %s\n", flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);
#endif
	ret_match = ndpi_match_protocol_from_sni(detectionmodule, flow);
	if(ret_match != NDPI_PROTOCOL_MATCH_NO_MATCH) {
	  ndpi_protocol_level_t proto_level;
	  proto_level.protocol = ret_match;
	  proto_level.dga_probability = ndpi_check_dga(detectionmodule, flow);
	  ndpi_risk_t risk = NDPI_NO_RISK;
	  if(proto_level.dga_probability > 0) {
	    risk = NDPI_DGA_SUSPICIOUS;
	  }
	  ndpi_match_found(detectionmodule, flow, proto_level, risk);
	  flow->protos.tls_quic_stun.tls_quic.hello_message_processed = 1;
	}
	sni_found = 1;
	if(ua_found)
	  return;
      }
    } else if(len == 5 && memcmp(tag, "UAID", 4) == 0) {
      uint32_t ua_len = le32toh(*((u_int32_t *)&crypto_data[tag_offset_start + offset]));
      if(ua_len + tag_offset_start + offset + 4 <= crypto_data_len) {
#ifdef QUIC_DEBUG
	NDPI_LOG_DBG(detectionmodule, "UA: %s\n", &crypto_data[tag_offset_start + offset + 4]);
#endif
	ndpi_handle_http_user_agent(detectionmodule, flow, (const char *)&crypto_data[tag_offset_start + offset + 4], ua_len);
	ua_found = 1;
	if(sni_found)
	  return;
      }
    }