if(memcmp(tag, "SNI\0", 4) == 0) {
  if(prev_offset + 4 >= crypto_data_len)
    break;
  sni_len = le32toh(*((u_int32_t *)&crypto_data[prev_offset]));
  if(sni_len > crypto_data_len - prev_offset - 4 || sni_len > NDPI_MAX_SNI_LEN) {
    NDPI_LOG_ERR(detectionmodule, "Invalid SNI length\n");
    break;
  }
  memcpy(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,
         &crypto_data[prev_offset + 4], sni_len);
  flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[sni_len] = '\0';
  NDPI_LOG_DBG(detectionmodule, "SNI: %s\n",
               flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);
  ret_match = ndpi_protocol_bitmask_intersect(&detectionmodule->dga_bitmask,
                                              &flow->l7_proto_match_result);
  if(ret_match.match_found) {
    NDPI_LOG_DBG(detectionmodule, "DGA detected for domain %s\n",
                 flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);
    ndpi_set_risk(detectionmodule, flow, NDPI_DNS_DGA);
  }
  sni_found = 1;
} else if(memcmp(tag, "UAID", 4) == 0) {
  if(prev_offset + 4 >= crypto_data_len)
    break;
  len = le32toh(*((u_int32_t *)&crypto_data[prev_offset]));
  if(len > crypto_data_len - prev_offset - 4) {
    NDPI_LOG_ERR(detectionmodule, "Invalid UAID length\n");
    break;
  }
  char ua[len + 1];
  memcpy(ua, &crypto_data[prev_offset + 4], len);
  ua[len] = '\0';
  NDPI_LOG_DBG(detectionmodule, "UAID: %s\n", ua);
  process_http_user_agent(detectionmodule, flow, ua, len);
  ua_found = 1;
}

if(sni_found && ua_found)
  return;