for(i = 0; i < num_tags; i++) {
    if(8 + 8 * i + 8 >= crypto_data_len)
      break;
    tag = &crypto_data[8 + 8 * i];
    offset = le32toh(*((u_int32_t *)&crypto_data[8 + 8 * i + 4]));
    if(prev_offset > offset)
      break;
    len = offset - prev_offset;
    if(memcmp(tag, "SNI\0", 4) == 0) {
      sni_len = len - 4;
      if(sni_len > 0) {
        memcpy(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name, &tag[4], sni_len);
        flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[sni_len] = '\0';
        ndpi_set_risk(detectionmodule, flow, NDPI_TLS_QUIC_SNI_FOUND);
        ndpi_log_tls_quic_sni(detectionmodule, flow, flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);
        process_sni(ndpi_struct, flow, flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);
        sni_found = 1;
      }
    } else if(memcmp(tag, "UAID", 4) == 0) {
      ua_len = len - 4;
      if(ua_len > 0) {
        memcpy(flow->protos.tls_quic_stun.tls_quic.user_agent, &tag[4], ua_len);
        flow->protos.tls_quic_stun.tls_quic.user_agent[ua_len] = '\0';
        ndpi_log_tls_quic_uaid(detectionmodule, flow, flow->protos.tls_quic_stun.tls_quic.user_agent);
        process_uaid(ndpi_struct, flow, flow->protos.tls_quic_stun.tls_quic.user_agent);
        ua_found = 1;
      }
    }
    prev_offset = offset;
    if(sni_found && ua_found)
      break;
  }