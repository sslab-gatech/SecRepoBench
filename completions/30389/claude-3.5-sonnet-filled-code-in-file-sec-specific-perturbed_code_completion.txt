if (memcmp(tag, "SNI\0", 4) == 0) {
  sni_len = len < 256 ? len : 255;
  if (tag_offset_start + offset + sni_len > crypto_data_len)
    break;
  memcpy(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,
         &crypto_data[tag_offset_start + offset], sni_len);
  flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[sni_len] = '\0';
  NDPI_LOG_DBG(detectionmodule, "SNI: [%s]\n",
               flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);
  ndpi_match_host_subprotocol(detectionmodule, flow,
                              flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,
                              strlen(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name),
                              &ret_match, NDPI_PROTOCOL_QUIC);
  if (ndpi_is_valid_hostname(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,
                             sni_len) == 0) {
    ndpi_set_risk(detectionmodule, flow, NDPI_INVALID_CHARACTERS);
  }
  flow->protos.tls_quic_stun.tls_quic.hello_processed = 1;
  sni_found = 1;
} else if (memcmp(tag, "UAID", 4) == 0) {
  if (tag_offset_start + offset + len > crypto_data_len)
    break;
  NDPI_LOG_DBG(detectionmodule, "UA: [%.*s]\n", len, &crypto_data[tag_offset_start + offset]);
  http_process_user_agent(detectionmodule, flow, &crypto_data[tag_offset_start + offset], len);
  ua_found = 1;
}

if (sni_found && ua_found)
  break;