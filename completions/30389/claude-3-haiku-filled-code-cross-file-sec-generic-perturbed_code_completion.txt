// Process tags within the crypto data by iterating over them.
for(; offset < tag_offset_start; offset += len) {
  tag = &crypto_data[offset];
  len = strlen((const char *)tag) + 1;
  if(memcmp(tag, "SNI\0", 4) == 0) {
    sni_len = crypto_data_len - (offset + 4);
    if(sni_len > 0 && sni_len < sizeof(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name)) {
      memcpy(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,
             &crypto_data[offset + 4], sni_len);
      flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[sni_len] = '\0';
      NDPI_LOG_DBG(detectionmodule, "SNI: %s\n", flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);
      ndpi_match_host_subprotocol(detectionmodule, flow, flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,
                                  strlen(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name), &ret_match);
      ndpi_check_dga_name(detectionmodule, flow, flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);
      sni_found = 1;
    }
  } else if(memcmp(tag, "UAID", 4) == 0) {
    len = crypto_data_len - (offset + 4);
    if(len > 0 && len < sizeof(flow->http.user_agent)) {
      memcpy(flow->http.user_agent, &crypto_data[offset + 4], len);
      flow->http.user_agent[len] = '\0';
      NDPI_LOG_DBG(detectionmodule, "UAID: %s\n", flow->http.user_agent);
      ndpi_check_http_user_agent(detectionmodule, flow);
      ua_found = 1;
    }
  }
  if(sni_found && ua_found)
    return;
}