if(memcmp(tag, "SNI\0", 4) == 0) {
      if((offset + 2) > crypto_data_len) {
        NDPI_LOG_ERR(detectionmodule, "SNI length exceeds crypto data length");
        break;
      }
      sni_len = le16toh(*((u_int16_t *)&crypto_data[offset]));
      if((offset + 2 + sni_len) > crypto_data_len) {
        NDPI_LOG_ERR(detectionmodule, "SNI exceeds crypto data length");
        break;
      }
      if(sni_len >= sizeof(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name)) {
        NDPI_LOG_ERR(detectionmodule, "SNI length exceeds buffer size");
        break;
      }
      memcpy(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,
             &crypto_data[offset + 2], sni_len);
      flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[sni_len] = '\0';
#ifdef QUIC_DEBUG
      NDPI_LOG_DBG(detectionmodule, "SNI: %s\n", flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);
#endif
      ret_match = ndpi_match_subprotocol(detectionmodule, flow,
					 flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,
					 sni_len);
      if(ret_match == NDPI_PROTOCOL_MATCH_DGA) {
        ndpi_set_risk(detectionmodule, flow, NDPI_PROTOCOL_RISK_DGA);
      }
      flow->hello_processed = 1;
      sni_found = 1;
    } else if(memcmp(tag, "UAID", 4) == 0) {
      /* UAID */
      if((offset + len) > crypto_data_len) {
        NDPI_LOG_ERR(detectionmodule, "UAID exceeds crypto data length");
        break;
      }
#ifdef QUIC_DEBUG
      char *user_agent = ndpi_malloc(len + 1);
      if(user_agent != NULL) {
        memcpy(user_agent, &crypto_data[offset], len);
        user_agent[len] = '\0';
        NDPI_LOG_DBG(detectionmodule, "UAID: %s\n", user_agent);
        ndpi_free(user_agent);
      }
#endif
      process_http_user_agent(detectionmodule, flow, &crypto_data[offset], len);
      ua_found = 1;
    }
    if(sni_found && ua_found)
      return;