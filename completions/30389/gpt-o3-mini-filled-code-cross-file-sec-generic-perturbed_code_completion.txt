if (prev_offset + len > crypto_data_len) {
  NDPI_LOG_DBG(detectionmodule, "Invalid tag length: computed tag length extends beyond crypto_data_len");
  break;
}

if (memcmp(tag, "SNI\0", 4) == 0 && !sni_found) {
  /* Process SNI: extract the server name information from the crypto data */
  sni_len = len;
  /* Ensure we do not overflow the SNI buffer */
  if(sni_len >= sizeof(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name))
    sni_len = sizeof(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name) - 1;
  memcpy(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,
         &crypto_data[prev_offset],
         sni_len);
  flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[sni_len] = '\0';
  NDPI_LOG_DBG(detectionmodule, "Extracted SNI: %s",
               flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);

  /* TODO: perform matching against subprotocols and check for DGA if required */
  sni_found = 1;
} else if (memcmp(tag, "UAID", 4) == 0 && !ua_found) {
  /* Process UAID: extract the user agent information */
  if(len > 0) {
    /* Define a safe maximum length for user agent strings */
    #define NDPI_MAX_UA_LEN 256
    size_t ua_len = len;
    char ua_buffer[NDPI_MAX_UA_LEN];
    if(ua_len >= NDPI_MAX_UA_LEN)
      ua_len = NDPI_MAX_UA_LEN - 1;
    memcpy(ua_buffer, &crypto_data[prev_offset], ua_len);
    ua_buffer[ua_len] = '\0';
    NDPI_LOG_DBG(detectionmodule, "Extracted UAID: %s", ua_buffer);

    /* Process user agent using the HTTP user agent handling function */
    process_http_user_agent(detectionmodule, flow, ua_buffer, ua_len);
    ua_found = 1;
  }
}

if(sni_found && ua_found)
  break;