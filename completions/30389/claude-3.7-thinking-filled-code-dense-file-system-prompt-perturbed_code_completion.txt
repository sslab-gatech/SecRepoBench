if(memcmp(tag, "SNI\0", 4) == 0) {
  if(tag_offset_start + prev_offset + len <= crypto_data_len) {
    sni_len = len;
    if(sni_len > sizeof(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name) - 1)
      sni_len = sizeof(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name) - 1;
    memcpy(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,
           &crypto_data[tag_offset_start + prev_offset], sni_len);
    flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[sni_len] = '\0';
    
    NDPI_LOG_DBG(detectionmodule, "SNI: [%s]\n", flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);
    
    // Match against subprotocols
    ndpi_match_host_subprotocol(detectionmodule, flow,
                           flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,
                           strlen(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name),
                           &ret_match, NDPI_PROTOCOL_QUIC);
    
    // Check for DGA
    if(ndpi_check_dga_name(detectionmodule,
                         flow,
                         flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,
                         1)) {
      ndpi_set_risk(detectionmodule, flow, NDPI_SUSPICIOUS_DGA_DOMAIN);
    }
    
    flow->protos.tls_quic_stun.tls_quic.hello_processed = 1;
    sni_found = 1;
  }
} else if(memcmp(tag, "UAID", 4) == 0) {
  if(tag_offset_start + prev_offset + len <= crypto_data_len) {
    char ua[256];
    int ua_len = len;
    
    if(ua_len > sizeof(ua) - 1)
      ua_len = sizeof(ua) - 1;
    
    memcpy(ua, &crypto_data[tag_offset_start + prev_offset], ua_len);
    ua[ua_len] = '\0';
    
    NDPI_LOG_DBG(detectionmodule, "User-Agent: [%s]\n", ua);
    
    ndpi_http_process_user_agent(detectionmodule, flow, ua, ua_len);
    ua_found = 1;
  }
}

// Early return if both SNI and UAID are found
if(sni_found && ua_found)
  return;