if (tag[0] == 'S' && tag[1] == 'N' && tag[2] == 'I' && tag[3] == '\0') {
      sni_len = len;
      if (sni_len > crypto_data_len - offset) {
        NDPI_LOG_DBG(detectionmodule, "Invalid SNI length\n");
        break;
      }
      memcpy(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name, &crypto_data[offset], sni_len);
      flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[sni_len] = '\0';
      NDPI_LOG_DBG(detectionmodule, "Found SNI: %s\n", flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);
      ret_match = ndpi_match_server_name(detectionmodule, flow, flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);
      if (ret_match != NDPI_PROTOCOL_UNKNOWN) {
        flow->guessed_host_protocol_id = ret_match;
        sni_found = 1;
      }
      if (sni_found && ua_found) {
        NDPI_LOG_DBG(detectionmodule, "Both SNI and UAID processed, returning\n");
        return;
      }
    } else if (tag[0] == 'U' && tag[1] == 'A' && tag[2] == 'I' && tag[3] == 'D') {
      if (len > crypto_data_len - offset) {
        NDPI_LOG_DBG(detectionmodule, "Invalid UAID length\n");
        break;
      }
      ua_found = 1;
      // Process UAID tag
      // Assuming there's a function to handle UAID
      // Example: process_uaid(detectionmodule, flow, &crypto_data[offset], len);
      NDPI_LOG_DBG(detectionmodule, "Found UAID\n");
      if (sni_found && ua_found) {
        NDPI_LOG_DBG(detectionmodule, "Both SNI and UAID processed, returning\n");
        return;
      }
    }