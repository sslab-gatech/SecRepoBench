if(len + tag_offset_start > crypto_data_len)
      break;
    if(len == 4 && memcmp(tag, "SNI\0", 4) == 0) {
      sni_len = le32toh(*((u_int32_t *)&crypto_data[tag_offset_start]));
      if(sni_len + tag_offset_start + 4 <= crypto_data_len) {
        if (sni_len >= 256) {
          sni_len = 255;
        }
        memcpy(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,
               &crypto_data[tag_offset_start + 4], sni_len);
        flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[sni_len] = '\0';
#ifdef QUIC_DEBUG
        NDPI_LOG_DBG(detectionmodule, "SNI: %s\n", flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);
#endif
        ret_match = ndpi_match_protocol_from_subprotocols(detectionmodule,
                                                        flow,
                                                        flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);
        if(ret_match != NDPI_PROTOCOL_MATCH_NO_MATCH) {
          ndpi_protocol_level_t current_proto_level = flow->detected_protocol_stack[flow->detected_protocol_stack_depth];
          ndpi_protocol_t current_proto = current_proto_level.protocol;
          if(current_proto == NDPI_PROTOCOL_UNKNOWN || current_proto == NDPI_PROTOCOL_QUIC) {
            flow->detected_protocol_stack[flow->detected_protocol_stack_depth].protocol = ret_match;
          }
        }
        ndpi_check_for_dga(detectionmodule, flow, flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,
                           strlen((const char *)flow->protos.tls_quic_stun.tls_quic.client_requested_server_name));
        sni_found = 1;
        flow->protos.tls_quic_stun.tls_quic.hello_message_processed = 1;
        if(ua_found)
          return;
      }
    } else if(len == 5 && memcmp(tag, "UAID", 4) == 0) {
      uint32_t ua_len = le32toh(*((u_int32_t *)&crypto_data[tag_offset_start]));
      if(ua_len + tag_offset_start + 4 <= crypto_data_len) {
#ifdef QUIC_DEBUG
        NDPI_LOG_DBG(detectionmodule, "UA: %.*s\n", ua_len, (const char *)&crypto_data[tag_offset_start + 4]);
#endif
        ndpi_handle_http_user_agent(detectionmodule, flow, &crypto_data[tag_offset_start + 4], ua_len);
        ua_found = 1;
        if(sni_found)
          return;
      }
    }
    tag_offset_start += len + ((len % 4) ? (4 - (len % 4)) : 0);