{
    /* Ensure we don't read out-of-bounds data */
    if(tag_offset_start + prev_offset + len > crypto_data_len) {
#ifdef QUIC_DEBUG
      NDPI_LOG_DBG(detectionmodule, "Invalid offset/length encountered for tag iteration\n");
#endif
      break;
    }

    /* Check for SNI\0 tag */
    if(memcmp(tag, "SNI\0", 4) == 0 && len > 0 && sni_found == 0) {
      uint32_t cpy_len = len;
      if(cpy_len >= sizeof(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name))
        cpy_len = sizeof(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name) - 1;

      memcpy(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,
             &crypto_data[tag_offset_start + prev_offset], cpy_len);
      flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[cpy_len] = '\0';

      NDPI_LOG_DBG(detectionmodule, "QUIC: Found SNI: %s\n",
                   flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);

      /* TODO: Perform subprotocol matching using SNI and check for DGA here */
      sni_found = 1;

      /* Mark hello message as processed once SNI is handled */
      /* flow->protos.tls_quic_stun.tls_quic.chlo_processed = 1; */
    }
    /* Check for UAID tag */
    else if(memcmp(tag, "UAID", 4) == 0 && len > 0 && ua_found == 0) {
      char ua_buf[256];
      uint32_t cpy_len = len;
      if(cpy_len >= sizeof(ua_buf))
        cpy_len = sizeof(ua_buf) - 1;

      memcpy(ua_buf, &crypto_data[tag_offset_start + prev_offset], cpy_len);
      ua_buf[cpy_len] = '\0';

      NDPI_LOG_DBG(detectionmodule, "QUIC: Found UAID: %s\n", ua_buf);

      /* TODO: Process UA with HTTP user agent function here */
      ua_found = 1;
    }

    if(sni_found && ua_found) {
      return;
    }
}