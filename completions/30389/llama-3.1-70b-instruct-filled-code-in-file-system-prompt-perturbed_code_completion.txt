if(memcmp(tag, "SNI\0", 4) == 0) {
  offset = le32toh(*((u_int32_t *)&crypto_data[tag_offset_start + 8 * i]));
  len = offset - prev_offset;
  if(len > crypto_data_len) {
    NDPI_LOG_DBG(detectionmodule, "Invalid SNI length %d > %d\n", len, crypto_data_len);
    return;
  }
  sni_len = crypto_data[offset];
  if(sni_len + 1 > len) {
    NDPI_LOG_DBG(detectionmodule, "Invalid SNI length %d > %d\n", sni_len + 1, len);
    return;
  }
  memcpy(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,
	 &crypto_data[offset + 1], sni_len);
  flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[sni_len] = '\0';
  NDPI_LOG_DBG2(detectionmodule, "SNI: [%s]\n", flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);
  ret_match = ndpi_match_subprotocol(ndpi_struct, flow, NDPI_PROTOCOL_QUIC, NDPI_PROTOCOL_UNKNOWN);
  if(ret_match!= NDPI_MATCH_UNKNOWN) {
    ndpi_int_change_protocol(ndpi_struct, flow, ret_match, NDPI_PROTOCOL_QUIC);
  }
  if(ndpi_check_dga(ndpi_struct, flow, NDPI_PROTOCOL_QUIC, NDPI_PROTOCOL_UNKNOWN)) {
    ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_DGA);
  }
  flow->protos.tls_quic_stun.tls_quic.hello_processed = 1;
  sni_found = 1;
} else if(memcmp(tag, "UAID", 4) == 0) {
  offset = le32toh(*((u_int32_t *)&crypto_data[tag_offset_start + 8 * i]));
  len = offset - prev_offset;
  if(len > crypto_data_len) {
    NDPI_LOG_DBG(detectionmodule, "Invalid UAID length %d > %d\n", len, crypto_data_len);
    return;
  }
  NDPI_LOG_DBG2(detectionmodule, "UAID: [%.*s]\n", len, &crypto_data[offset]);
  http_process_user_agent(ndpi_struct, flow, &crypto_data[offset], len);
  ua_found = 1;
}
if(sni_found && ua_found)
  return;