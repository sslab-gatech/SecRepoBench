if(tag_offset_start + offset + len > crypto_data_len)
      break;

    if(len == 4 && memcmp(tag, "SNI\0", 4) == 0) {
      sni_len = le32toh(*((u_int32_t *)&crypto_data[tag_offset_start + offset]));
      if(sni_len + 4 + tag_offset_start + offset <= crypto_data_len) {
        if (sni_len >= MAX_SNI_LEN) {
          sni_len = MAX_SNI_LEN - 1;
        }
	memcpy(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,
	       &crypto_data[tag_offset_start + offset + 4], sni_len);
	flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[sni_len] = '\0';
#ifdef QUIC_DEBUG
	NDPI_LOG_DBG(detectionmodule, "SNI: %s\n", flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);
#endif
	ret_match = ndpi_match_protocol_from_sni(detectionmodule, flow);
        if (ret_match != NDPI_PROTOCOL_MATCH_NO_MATCH) {
          NDPI_BITMASK_SET_PROTOCOL(detectionmodule->flow_bitmask, flow->ndpi_flow_id, ret_match);
        }
	ndpi_check_dga(detectionmodule, flow, flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,
		       strlen(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name));
	sni_found = 1;
      }
    } else if(len == 5 && memcmp(tag, "UAID", 4) == 0) {
      uint32_t ua_len = le32toh(*((u_int32_t *)&crypto_data[tag_offset_start + offset]));
      if(ua_len + 4 + tag_offset_start + offset <= crypto_data_len) {
#ifdef QUIC_DEBUG
        NDPI_LOG_DBG(detectionmodule, "UA: %.*s\n", ua_len, (char *)&crypto_data[tag_offset_start + offset + 4]);
#endif
	ndpi_handle_http_ua(detectionmodule, flow, (const char *)&crypto_data[tag_offset_start + offset + 4], ua_len);
	ua_found = 1;
      }
    }
    if(sni_found && ua_found) {
      flow->protos.tls_quic_stun.tls_quic.hello_message_processed = 1;
      return;
    }