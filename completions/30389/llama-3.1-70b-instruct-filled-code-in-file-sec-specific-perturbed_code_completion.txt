// <MASK>
tag = &crypto_data[8 + 8 * i];
offset = le32toh(*((u_int32_t *)&crypto_data[8 + 8 * i + 4]));
if(prev_offset > offset)
  break;
len = offset - prev_offset;
if(memcmp(tag, "SNI\0", 4) == 0) {
  sni_len = len - 4;
  if(sni_len > 0) {
    memcpy(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name, &crypto_data[offset], MIN(sni_len, sizeof(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name) - 1));
    flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[MIN(sni_len, sizeof(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name) - 1)] = '\0';
    NDPI_LOG_DBG2(detectionmodule, "SNI: [%s]\n", flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);
    ret_match = ndpi_match_subprotocol(ndpi_struct, flow, NDPI_PROTOCOL_QUIC, flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);
    if(ret_match!= NDPI_NO_MATCH) {
      ndpi_int_change_protocol(ndpi_struct, flow, ret_match, NDPI_PROTOCOL_QUIC);
    }
    if(ndpi_check_dga(ndpi_struct, flow, NDPI_PROTOCOL_QUIC, flow->protos.tls_quic_stun.tls_quic.client_requested_server_name)) {
      ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_DGA);
    }
    sni_found = 1;
  }
} else if(memcmp(tag, "UAID", 4) == 0) {
  sni_len = len - 4;
  if(sni_len > 0) {
    NDPI_LOG_DBG2(detectionmodule, "UAID: [%.*s]\n", sni_len, &crypto_data[offset]);
    http_process_user_agent(ndpi_struct, flow, &crypto_data[offset], sni_len);
    ua_found = 1;
  }
}
prev_offset = offset;
if(sni_found && ua_found)
  break;
// </MASK>