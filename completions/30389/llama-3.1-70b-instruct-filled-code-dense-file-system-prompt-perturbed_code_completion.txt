if(memcmp(tag, "SNI\0", 4) == 0) {
  sni_len = len - 5;
  if(sni_len > 0) {
    memcpy(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,
           &crypto_data[prev_offset + 5], sni_len);
    flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[sni_len] = '\0';
    NDPI_LOG_DBG(detectionmodule, "SNI: [%s]\n",
                 flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);
    ret_match = ndpi_match_subprotocol(detectionmodule, flow,
                                       flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,
                                       NDPI_PROTOCOL_TLS_QUIC);
    if(ret_match!= NDPI_NO_MATCH) {
      ndpi_int_change_protocol(detectionmodule, flow, ret_match, NDPI_PROTOCOL_TLS_QUIC);
    }
    if(ndpi_check_dga(detectionmodule, flow,
                      flow->protos.tls_quic_stun.tls_quic.client_requested_server_name)) {
      ndpi_set_risk(detectionmodule, flow, NDPI_TLS_DGA);
    }
    sni_found = 1;
    flow->protos.tls_quic_stun.tls_quic.hello_processed = 1;
  }
} else if(memcmp(tag, "UAID", 4) == 0) {
  NDPI_LOG_DBG(detectionmodule, "UAID: [%.*s]\n", len, &crypto_data[prev_offset]);
  ndpi_parse_user_agent(detectionmodule, flow, &crypto_data[prev_offset], len);
  ua_found = 1;
}
if(sni_found && ua_found) {
  break;
}