if(len > crypto_data_len || tag_offset_start + len > crypto_data_len)
      break;
    if(memcmp(tag, "SNI\0", 4) == 0) {
      sni_len = le32toh(*((u_int32_t *)&crypto_data[tag_offset_start]));
      if(sni_len + tag_offset_start + 4 <= crypto_data_len) {
        NDPI_LOG_DBG(detectionmodule, "Found SNI [%.*s]\n", sni_len,
                     &crypto_data[tag_offset_start + 4]);
        if (sni_len < NDPI_MAX_SNI_LEN) {
          memcpy(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,
                 &crypto_data[tag_offset_start + 4], sni_len);
          flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[sni_len] = 0;
          ret_match = ndpi_match_protocol_from_sni(detectionmodule, flow,
                                                  flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);
          if (ret_match == NDPI_MATCH_PROTOCOL) {
            NDPI_LOG_DBG(detectionmodule, "SNI matched sub-protocol\n");
          } else if (ret_match == NDPI_MATCH_DGA) {
            NDPI_LOG_DBG(detectionmodule, "SNI matched DGA\n");
          }
        }
      }
      sni_found = 1;
    } else if(memcmp(tag, "UAID", 4) == 0) {
      len = le32toh(*((u_int32_t *)&crypto_data[tag_offset_start]));
      if(len + tag_offset_start + 4 <= crypto_data_len) {
        NDPI_LOG_DBG(detectionmodule, "Found UAID [%.*s]\n", len,
                     &crypto_data[tag_offset_start + 4]);
        http_process_user_agent(detectionmodule, flow,
                               &crypto_data[tag_offset_start + 4], len);
      }
      ua_found = 1;
    }
    tag_offset_start += len + 4; /* 4 is for the length field */
    if(sni_found && ua_found)
      return; /* No need to keep iterating */