for (++iterator; iterator; ++iterator)
{
    hb_codepoint_t gid = (*iterator).first;
    unsigned klass = (*iterator).second;

    if (gid == prev_gid + 1 && klass == prev_klass)
    {
        record->last = gid;
        prev_gid = gid;
    }
    else
    {
        num_ranges++;
        RangeRecord<Types> new_range;
        new_range.first = gid;
        new_range.last = gid;
        new_range.value = klass;
        auto *new_record = c->copy (new_range);
        if (unlikely (!new_record)) return_trace (false);
        record = new_record;
        prev_gid = gid;
        prev_klass = klass;
    }
}

rangeRecord.len = num_ranges;

if (rangeRecord.len > 1)
    hb_sort (rangeRecord.arrayZ, rangeRecord.len,
            sizeof (RangeRecord<Types>),
            [] (const void* a, const void* b) {
                const auto* ra = static_cast<const RangeRecord<Types>*>(a);
                const auto* rb = static_cast<const RangeRecord<Types>*>(b);
                return ra->first < rb->first ? -1 : ra->first > rb->first ? 1 : 0;
            });

return_trace (true);