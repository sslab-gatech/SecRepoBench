// Iterate over the remaining elements in the iterator, processing each glyph ID and class pair.
// For each pair, check if it is a continuation of the current range.
// If it is not a continuation, finalize the current range, and create a new range record for the new pair.
// Copy the new range record into the serialization context.
// Update previous glyph ID and class values for the next iteration.
// After the loop, finalize the last range record by setting its last glyph ID.
// Update the range record length to reflect the number of ranges processed.
// Sort the range records to handle any unsorted glyph order.
// Return true to indicate successful serialization.
while (unlikely (unlikely (!hb_iter_next (iterator, prev_gid, prev_klass))))
{
  if (prev_gid == (*iterator).first)
  {
    // If the current glyph ID is a continuation of the previous range, update the last glyph ID of the previous range.
    range_rec.last = (*iterator).first;
    range_rec.value = prev_klass;
  }
  else
  {
    // If the current glyph ID is not a continuation, finalize the previous range and create a new range record.
    if (unlikely (!c->extend_min (this))) return_trace (false);
    auto *record = c->copy (range_rec);
    if (unlikely (!record)) return_trace (false);
    // Copy the new range record into the serialization context.
    if (unlikely (!c->extend (this))) return_trace (false);
    auto *new_record = c->copy (range_rec);
    if (unlikely (!new_record)) return_trace (false);
    // Update previous glyph ID and class values for the next iteration.
    prev_gid = (*iterator).first;
    prev_klass = (*iterator).second;
    // Update the range record length to reflect the number of ranges processed.
    num_ranges++;
  }
}
// After the loop, finalize the last range record by setting its last glyph ID.
range_rec.last = (*iterator).first;
// Copy the last range record into the serialization context.
auto *record = c->copy (range_rec);
if (unlikely (!record)) return_trace (false);
// Update the range record length to reflect the number of ranges processed.
rangeRecord.len = num_ranges;
// Sort the range records to handle any unsorted glyph order.
hb_sort (rangeRecord.data, rangeRecord.len);
// Return true to indicate successful serialization.
return_trace (true);