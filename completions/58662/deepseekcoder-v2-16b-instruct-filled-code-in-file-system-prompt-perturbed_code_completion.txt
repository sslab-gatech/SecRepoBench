ClassDefFormat1_2;
  friend struct ClassDefFormat1_4;

  bool sanitize (hb_sanitize_context_t *c) const
  {
    TRACE_SANITIZE (this);
    return_trace (c->check_struct (this) &&
		  glyphs.sanitize (c, this) &&
		  classes.sanitize (c, this));
  }

  void collect_glyphs (hb_set_t *glyphs_to_retain /* OUT */) const
  {
    this->glyphs.add_glyphs (glyphs_to_retain);
  }

  bool subset (hb_subset_context_t *c,
	       hb_subset_layout_context_t *l,
	       const hb_set_t *glyph_set) const
  {
    TRACE_SUBSET (this);
    auto *out = c->serializer->start_embed (*this);
    if (unlikely (!out || !c->serializer->extend_min (out))) return_trace (false);

    out->glyphs.serialize (c->serializer, l, glyph_set, this->glyphs.iter ());

    hb_set_t klasses;
    hb_sorted_vector_t<hb_pair_t<hb_codepoint_t, hb_codepoint_t>> glyph_and_klass;
    hb_map_t klass_map;
    bool use_class_zero = false;

    for (const auto &_ : this->glyphs)
    {
      hb_codepoint_t glyph = _;
      hb_codepoint_t klass = this->classes.get (glyph, 0);
      if (klass == 0) use_class_zero = true;
      klasses.add (klass);
      glyph_and_klass.push (hb_pair (glyph, klass));
    }

    if (!ClassDef_remap_and_serialize (c->serializer, klasses, use_class_zero, glyph_and_klass, &klass_map))
      return_trace (false);

    if (klass_map.length)
      out->klass_map = c->serializer->embed (klass_map);

    return_trace (true);
  }

  protected:
  Array16Of<Types::GlyphID> glyphs;
  Array16Of<Types::ClassID> classes;
  public:
  DEFINE_SIZE_ARRAYS (2, glyphs, classes);
};

template <typename Types>
struct ClassDefFormat1_2
{
  friend struct ClassDefFormat1_3;
  friend struct ClassDefFormat1_4;

  bool sanitize (hb_sanitize_context_t *c) const
  {
    TRACE_SANITIZE (this);
    return_trace (c->check_struct (this) &&
		  glyphs.sanitize (c, this) &&
		  classes.sanitize (c, this));
  }

  void collect_glyphs (hb_set_t *glyphs_to_retain /* OUT */) const
  {
    this->glyphs.add_glyphs (glyphs_to_retain);
  }

  bool subset (hb_subset_context_t *c,
	       hb_subset_layout_context_t *l,
	       const hb_set_t *glyph_set) const
  {
    TRACE_SUBSET (this);
    auto *out = c->serializer->start_embed (*this);
    if (unlikely (!out || !c->serializer->extend_min (out))) return_trace (false);

    out->glyphs.serialize (c->serializer, l, glyph_set, this->glyphs.iter ());

    hb_set_t klasses;
    hb_sorted_vector_t<hb_pair_t<hb_codepoint_t, hb_codepoint_t>> glyph_and_klass;
    bool use_class_zero = false;

    for (const auto &_ : this->glyphs)
    {
      hb_codepoint_t glyph = _;
      hb_codepoint_t klass = this->classes.get (glyph, 0);
      if (klass == 0) use_class_zero = true;
      klasses.add (klass);
      glyph_and_klass.push (hb_pair (glyph, klass));
    }

    if (!ClassDef_remap_and_serialize (c->serializer, klasses, use_class_zero, glyph_and_klass))
      return_trace (false);

    return_trace (true);
  }

  protected:
  Array16Of<Types::GlyphID> glyphs;
  Array16Of<Types::ClassID> classes;
  public:
  DEFINE_SIZE_ARRAYS (2, glyphs, classes);
};

template <typename Types>
struct ClassDefFormat1_4
{
  friend struct ClassDefFormat1_3;
  friend struct ClassDefFormat1_2;

  bool sanitize (hb_sanitize_context_t *c) const
  {
    TRACE_SANITIZE (this);
    return_trace (c->check_struct (this) &&
		  glyphs.sanitize (c, this) &&
		  classes.sanitize (c, this));
  }

  void collect_glyphs (hb_set_t *glyphs_to_retain /* OUT */) const
  {
    this->glyphs.add_glyphs (glyphs_to_retain);
  }

  bool subset (hb_subset_context_t *c,
	       hb_subset_layout_context_t *l,
	       const hb_set_t *glyph_set) const
  {
    TRACE_SUBSET (this);
    auto *out = c->serializer->start_embed (*this);
    if (unlikely (!out || !c->serializer->extend_min (out))) return_trace (false);

    out->glyphs.serialize (c->serializer, l, glyph_set, this->glyphs.iter ());

    hb_set_t klasses;
    hb_sorted_vector_t<hb_pair_t<hb_codepoint_t, hb_codepoint_t>> glyph_and_klass;
    bool use_class_zero = false;

    for (const auto &_ : this->glyphs)
    {
      hb_codepoint_t glyph = _;
      hb_codepoint_t klass = this->classes.get (glyph, 0);
      if (klass == 0) use_class_zero = true;
      klasses.add (klass);
      glyph_and_klass.push (hb_pair (glyph, klass));
    }

    if (!ClassDef_remap_and_serialize (c->serializer, klasses, use_class_zero, glyph_and_klass))
      return_trace (false);

    return_trace (true);
  }

  protected:
  Array16Of<Types::GlyphID> glyphs;
  Array16Of<Types::ClassID> classes;
  public:
  DEFINE_SIZE_ARRAYS (2, glyphs, classes);
};

template <typename Types>
struct ClassDefFormat2
{
  bool sanitize (hb_sanitize_context_t *c) const
  {
    TRACE_SANITIZE (this);
    return_trace (c->check_struct (this) &&
		  glyphs.sanitize (c, this) &&
		  classes.sanitize (c, this));
  }

  void collect_glyphs (hb_set_t *glyphs_to_retain /* OUT */) const
  {
    this->glyphs.add_glyphs (glyphs_to_retain);
  }

  bool subset (hb_subset_context_t *c,
	       hb_subset_layout_context_t *l,
	       const hb_set_t *glyph_set) const
  {
    TRACE_SUBSET (this);
    auto *out = c->serializer->start_embed (*this);
    if (unlikely (!out || !c->serializer->extend_min (out))) return_trace (false);

    out->glyphs.serialize (c->serializer, l, glyph_set, this->glyphs.iter ());

    hb_set_t klasses;
    hb_sorted_vector_t<hb_pair_t<hb_codepoint_t, hb_codepoint_t>> glyph_and_klass;
    bool use_class_zero = false;

    for (const auto &_ : this->glyphs)
    {
      hb_codepoint_t glyph = _;
      hb_codepoint_t klass = this->classes.get (glyph, 0);
      if (klass == 0) use_class_zero = true;
      klasses.add (klass);
      glyph_and_klass.push (hb_pair (glyph, klass));
    }

    if (!ClassDef_remap_and_serialize (c->serializer, klasses, use_class_zero, glyph_and_klass))
      return_trace (false);

    return_trace (true);
  }

  protected:
  Array16Of<Types::GlyphID> glyphs;
  Array16Of<Types::ClassID> classes;
  public:
  DEFINE_SIZE_ARRAYS (2, glyphs, classes);
};

template <typename Types>
struct ClassDefFormat3
{
  bool sanitize (hb_sanitize_context_t *c) const
  {
    TRACE_SANITIZE (this);
    return_trace (c->check_struct (this) &&
		  glyphs.sanitize (c, this) &&
		  classes.sanitize (c, this));
  }

  void collect_glyphs (hb_set_t *glyphs_to_retain /* OUT */) const
  {
    this->glyphs.add_glyphs (glyphs_to_retain);
  }

  bool subset (hb_subset_context_t *c,
	       hb_subset_layout_context_t *l,
	       const hb_set_t *glyph_set) const
  {
    TRACE_SUBSET (this);
    auto *out = c->serializer->start_embed (*this);
    if (unlikely (!out || !c->serializer->extend_min (out))) return_trace (false);

    out->glyphs.serialize (c->serializer, l, glyph_set, this->glyphs.iter ());

    hb_set_t klasses;
    hb_sorted_vector_t<hb_pair_t<hb_codepoint_t, hb_codepoint_t>> glyph_and_klass;
    bool use_class_zero = false;

    for (const auto &_ : this->glyphs)
    {
      hb_codepoint_t glyph = _;
      hb_codepoint_t klass = this->classes.get (glyph, 0);
      if (klass == 0) use_class_zero = true;
      klasses.add (klass);
      glyph_and_klass.push (hb_pair (glyph, klass));
    }

    if (!ClassDef_remap_and_serialize (c->serializer, klasses, use_class_zero, glyph_and_klass))
      return_trace (false);

    return_trace (true);
  }

  protected:
  Array16Of<Types::GlyphID> glyphs;
  Array16Of<Types::ClassID> classes;
  public:
  DEFINE_SIZE_ARRAYS (2, glyphs, classes);
};

template <typename Types>
struct ClassDefFormat4
{
  bool sanitize (hb_sanitize_context_t *c) const
  {
    TRACE_SANITIZE (this);
    return_trace (c->check_struct (this) &&
		  glyphs.sanitize (c, this) &&
		  classes.sanitize (c, this));
  }

  void collect_glyphs (hb_set_t *glyphs_to_retain /* OUT */) const
  {
    this->glyphs.add_glyphs (glyphs_to_retain);
  }

  bool subset (hb_subset_context_t *c,
	       hb_subset_layout_context_t *l,
	       const hb_set_t *glyph_set) const
  {
    TRACE_SUBSET (this);
    auto *out = c->serializer->start_embed (*this);
    if (unlikely (!out || !c->serializer->extend_min (out))) return_trace (false);

    out->glyphs.serialize (c->serializer, l, glyph_set, this->glyphs.iter ());

    hb_set_t kl