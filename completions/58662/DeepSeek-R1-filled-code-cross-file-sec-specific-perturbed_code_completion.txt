for (; iterator; ++iterator)
    {
        hb_codepoint_t current_gid = (*iterator).first;
        unsigned current_klass = (*iterator).second;

        if (current_gid == prev_gid + 1 && current_klass == prev_klass)
        {
            record->last = current_gid;
            prev_gid = current_gid;
        }
        else
        {
            RangeRecord<Types> new_range;
            new_range.first = current_gid;
            new_range.last = current_gid;
            new_range.value = current_klass;

            record = c->copy(new_range);
            if (unlikely (!record)) return_trace (false);
            num_ranges++;
            prev_gid = current_gid;
            prev_klass = current_klass;
        }
    }

    this->rangeRecord.len = num_ranges;

    hb_qsort (this->rangeRecord.arrayZ, num_ranges, sizeof (RangeRecord<Types>),
              [](const void* a, const void* b) {
                  const auto* ra = (const RangeRecord<Types>*) a;
                  const auto* rb = (const RangeRecord<Types>*) b;
                  return ra->first.cmp (rb->first);
              });

    return_trace (true);