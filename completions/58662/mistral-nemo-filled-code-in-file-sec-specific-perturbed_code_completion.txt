/*
 * OpenType Layout Common Table Formats
 *
 */

/*
 * Script, ScriptList, LangSys, Feature, FeatureList, Lookup, LookupList
 */

struct IndexArray : Array16Of<Index>
{
  bool intersects (const hb_map_t *indexes) const
  { return hb_any (*this, indexes); }

  template <typename Iterator,
	    hb_requires (hb_is_iterator (Iterator))>
  void serialize (hb_serialize_context_t *c,
		  hb_subset_layout_context_t *l,
		  Iterator it)
  {
    if (!it) return;
    if (unlikely (!c->extend_min ((*this)))) return;

    for (const auto _ : it)
    {
      if (!l->visitLookupIndex()) break;

      Index i;
      i = _;
      c->copy (i);
      this->len++;
    }
  }

  unsigned int get_indexes (unsigned int start_offset,
			    unsigned int *feature_count /* IN/OUT */,
			    unsigned int *feature_indexes /* OUT */) const
  {
    if (feature_count)
    {
      + this->as_array ().sub_array (start_offset, feature_count)
      | hb_sink (hb_array (feature_indexes, *feature_count))
      ;
    }
    return this->len;
  }
  void add_indexes_to (hb_set_t *output /* OUT */) const
  { output->add_array (as_array ()); }
};