{
  // Gather all (glyph, class) pairs into a temporary vector.
  hb_vector_t<hb_pair_t<hb_codepoint_t, unsigned>> gathered_pairs;
  if (unlikely (!gathered_pairs.init ()))
    return_trace (false);

  // Push the first pair we already have.
  if (unlikely (!gathered_pairs.push (hb_pair_t<hb_codepoint_t, unsigned> (prev_gid, prev_klass))))
    return_trace (false);

  // Collect the rest from the iterator.
  for (++iterator; iterator; ++iterator)
  {
    hb_codepoint_t gid = (*iterator).first;
    unsigned klass = (*iterator).second;
    if (unlikely (!gathered_pairs.push (hb_pair_t<hb_codepoint_t, unsigned> (gid, klass))))
      return_trace (false);
  }

  // Sort the collected pairs by glyph ID.
  gathered_pairs.sort ([] (const auto &a, const auto &b) {
    return a.first < b.first;
  });

  // Build and copy the range records.
  num_ranges = 0;
  for (unsigned i = 0; i < gathered_pairs.length; i++)
  {
    if (i == 0)
    {
      // Initialize the first range record with the sorted pair.
      record->first = gathered_pairs[i].first;
      record->last = gathered_pairs[i].first;
      record->value = gathered_pairs[i].second;
      num_ranges = 1;
    }
    else if (gathered_pairs[i].first == record->last + 1 &&
	     gathered_pairs[i].second == record->value)
    {
      // Continue the current range.
      record->last = gathered_pairs[i].first;
    }
    else
    {
      // Finalize the current range and start a new one.
      RangeRecord<Types> new_range;
      new_range.first = gathered_pairs[i].first;
      new_range.last = gathered_pairs[i].first;
      new_range.value = gathered_pairs[i].second;

      record = c->copy (new_range);
      if (unlikely (!record))
	return_trace (false);

      num_ranges++;
    }
  }

  // Update range length and return.
  rangeRecord.len = num_ranges;
  return_trace (true);
}