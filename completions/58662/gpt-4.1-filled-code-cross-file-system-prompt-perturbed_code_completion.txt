for (++iterator; iterator; ++iterator)
    {
      hb_codepoint_t gid = (*iterator).first;
      unsigned klass = (*iterator).second;

      if (gid == prev_gid + 1 && klass == prev_klass)
      {
        // Continue the current range
        prev_gid = gid;
        continue;
      }

      // Finalize the current range
      record->last = prev_gid;

      // Start a new range
      range_rec.first = gid;
      range_rec.last = gid;
      range_rec.value = klass;
      record = c->copy (range_rec);
      if (unlikely (!record)) return_trace (false);

      prev_gid = gid;
      prev_klass = klass;
      num_ranges++;
    }

    // Finalize the last range
    record->last = prev_gid;

    rangeRecord.len = num_ranges;

    // Sort the range records by first glyph id, in case input was unsorted
    if (num_ranges > 1)
    {
      auto arr = reinterpret_cast<RangeRecord<Types>*>(rangeRecord.arrayZ);
      std::sort(arr, arr + num_ranges, [](const RangeRecord<Types>& a, const RangeRecord<Types>& b) {
        return a.first < b.first;
      });
    }

    return_trace (true);