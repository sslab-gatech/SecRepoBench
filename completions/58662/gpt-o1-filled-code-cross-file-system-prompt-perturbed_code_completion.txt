for (++iterator; iterator; ++iterator)
{
  hb_codepoint_t gid = (*iterator).first;
  unsigned int current_klass = (*iterator).second;

  if (gid == prev_gid + 1 && current_klass == prev_klass)
  {
    /* Extend the current range */
    record->last = gid;
  }
  else
  {
    /* Finalize the previous range */
    record->last = prev_gid;

    /* Start a new range */
    RangeRecord<Types> new_rec;
    new_rec.first = gid;
    new_rec.last = gid;
    new_rec.value = current_klass;

    auto *new_record = rangeRecord.serialize_append(c);
    if (unlikely(!new_record))
      return_trace(false);

    num_ranges++;
    *new_record = new_rec;
    record = new_record;
  }

  prev_gid = gid;
  prev_klass = current_klass;
}

/* Finalize the last range */
record->last = prev_gid;

/* Update the total number of ranges */
rangeRecord.len = num_ranges;

/* Sort the range records by glyph ID if needed:
   RangeRecord<Types> *arr = reinterpret_cast<RangeRecord<Types>*>(rangeRecord.arrayZ);
   std::sort(arr, arr + num_ranges, [](auto &a, auto &b) { return a.first < b.first; });
*/

classFormat = 2;
return_trace(true);