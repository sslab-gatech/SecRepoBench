for (++iterator; iterator; ++iterator)
{
  hb_codepoint_t cur_gid  = (*iterator).first;
  unsigned     cur_klass = (*iterator).second;

  // If the current glyph is consecutive and has the same class, extend the current range.
  if (cur_gid == prev_gid + 1 && cur_klass == prev_klass)
  {
    record->last = cur_gid;
  }
  else
  {
    // Finalize the current range and start a new one.
    num_ranges++;
    RangeRecord<Types> new_range;
    new_range.first = cur_gid;
    new_range.last  = cur_gid;
    new_range.value = cur_klass;

    record = c->copy(new_range);
    if (unlikely(!record))
      return_trace(false);
  }
  prev_gid   = cur_gid;
  prev_klass = cur_klass;
}

rangeRecord.len = num_ranges;

// Sort the serialized range records to ensure ascending order by starting glyph ID.
// Assumes rangeRecord.records is an array of RangeRecord<Types> with length rangeRecord.len.
std::sort(rangeRecord.records, rangeRecord.records + rangeRecord.len,
          [](const RangeRecord<Types> &a, const RangeRecord<Types> &b) {
            return a.first < b.first;
          });

return_trace(true);