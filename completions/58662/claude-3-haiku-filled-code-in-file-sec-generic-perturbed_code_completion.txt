bool serialize (hb_serialize_context_t *c,
                Iterator iterator)
{
  TRACE_SERIALIZE (this);
  if (unlikely (!c->extend_min (this))) return_trace (false);

  if (unlikely (!iterator))
  {
    classFormat = 2;
    rangeRecord.len = 0;
    return_trace (true);
  }

  unsigned num_ranges = 1;
  hb_codepoint_t prev_gid = (*iterator).first;
  unsigned prev_klass = (*iterator).second;

  RangeRecord<Types> range_rec;
  range_rec.first = prev_gid;
  range_rec.last = prev_gid;
  range_rec.value = prev_klass;

  auto *record = c->copy (range_rec);
  if (unlikely (!record)) return_trace (false);

  for (const auto gid_klass_pair : + iterator | hb_drop (1))
  {
    hb_codepoint_t cur_gid = gid_klass_pair.first;
    unsigned cur_klass = gid_klass_pair.second;

    if (cur_gid == prev_gid + 1 && cur_klass == prev_klass)
    {
      range_rec.last = cur_gid;
    }
    else
    {
      record->last = prev_gid;
      record = c->copy (range_rec);
      if (unlikely (!record)) return_trace (false);
      range_rec.first = cur_gid;
      range_rec.last = cur_gid;
      range_rec.value = cur_klass;
      num_ranges++;
    }

    prev_gid = cur_gid;
    prev_klass = cur_klass;
  }

  record->last = prev_gid;
  rangeRecord.len = num_ranges;

  hb_bubble_sort (rangeRecord.arrayZ, num_ranges,
                  [] (const RangeRecord<Types> &a, const RangeRecord<Types> &b)
                  { return a.first > b.first; });

  return_trace (true);
}