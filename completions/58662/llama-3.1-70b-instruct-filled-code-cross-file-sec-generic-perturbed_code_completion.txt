for (++iterator; iterator; ++iterator)
{
  hb_codepoint_t gid = (*iterator).first;
  unsigned klass = (*iterator).second;

  if (gid == prev_gid + 1 && klass == prev_klass)
  {
    range_rec.last = gid;
  }
  else
  {
    range_rec.last = prev_gid;
    record->last = prev_gid;

    range_rec.first = gid;
    range_rec.last = gid;
    range_rec.value = klass;

    record = c->copy (range_rec);
    if (unlikely (!record)) return_trace (false);

    num_ranges++;
  }

  prev_gid = gid;
  prev_klass = klass;
}

range_rec.last = prev_gid;
record->last = prev_gid;

rangeRecord.len = num_ranges;

// Sort the range records to handle any unsorted glyph order.
// This is a simplified example and actual implementation may vary.
hb_sorted_vector_t<RangeRecord<Types>> sorted_records;
for (unsigned i = 0; i < rangeRecord.len; i++)
{
  sorted_records.push (rangeRecord.arrayZ[i]);
}
sorted_records.sort ([](const RangeRecord<Types>& a, const RangeRecord<Types>& b) {
  return a.first < b.first;
});

// Update rangeRecord with sorted records.
for (unsigned i = 0; i < rangeRecord.len; i++)
{
  rangeRecord.arrayZ[i] = sorted_records[i];
}

return_trace (true);