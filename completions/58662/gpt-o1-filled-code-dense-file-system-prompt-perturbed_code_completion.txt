{
  // Gather all pairs from the iterator into a temporary vector.
  hb_vector_t<hb_pair_t<hb_codepoint_t, unsigned>> pairs;
  pairs.push((*iterator));
  for (++iterator; iterator; ++iterator)
    if (unlikely (!pairs.push((*iterator))))
      return_trace(false);

  // Sort the gathered pairs by glyph ID.
  std::sort(pairs.begin(), pairs.end(),
            [] (const hb_pair_t<hb_codepoint_t, unsigned> &a,
                const hb_pair_t<hb_codepoint_t, unsigned> &b)
            {
              return a.first < b.first;
            });

  // Initialize range tracking.
  hb_codepoint_t prev_gid = pairs[0].first;
  unsigned prev_klass = pairs[0].second;
  RangeRecord<Types> range_rec;
  range_rec.first = prev_gid;
  range_rec.last = prev_gid;
  range_rec.value = prev_klass;

  auto *record = c->copy(range_rec);
  if (unlikely (!record)) return_trace(false);

  // Process all subsequent pairs, merging consecutive glyphs of the same class.
  for (unsigned i = 1; i < pairs.length; i++)
  {
    hb_codepoint_t cur_gid = pairs[i].first;
    unsigned cur_klass = pairs[i].second;

    if (cur_gid == prev_gid + 1 && cur_klass == prev_klass)
      record->last = cur_gid; // Continue current range
    else
    {
      // Start a new range
      RangeRecord<Types> new_rec;
      new_rec.first = cur_gid;
      new_rec.last = cur_gid;
      new_rec.value = cur_klass;

      record = c->copy(new_rec);
      if (unlikely (!record)) return_trace(false);

      num_ranges++;
    }

    prev_gid = cur_gid;
    prev_klass = cur_klass;
  }

  // Update the range record count and return success.
  rangeRecord.len = num_ranges;
  return_trace(true);
}