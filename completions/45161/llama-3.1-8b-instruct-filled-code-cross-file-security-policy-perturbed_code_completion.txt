// <MASK>
if (!((yr_le64toh(tilde_header->Valid) >> bit_check) & 0x01))
  continue;

#define ROW_CHECK(name)                                                  \
  if (fits_in_pe(pe, row_offset, (matched_bits + 1) * sizeof(uint32_t))) \
    rows.name = *(row_offset + matched_bits);

#define ROW_CHECK_WITH_INDEX(name)    \
  ROW_CHECK(name);                    \
  if (yr_le32toh(rows.name) > 0xFFFF) \
    index_sizes.name = 4;

switch (bit_check)
{
case BIT_MODULE:
  ROW_CHECK(module);
  break;
case BIT_MODULEREF:
  ROW_CHECK_WITH_INDEX(moduleref);
  break;
case BIT_ASSEMBLYREF:
  ROW_CHECK_WITH_INDEX(assemblyref);
  break;
case BIT_ASSEMBLYREFPROCESSOR:
  ROW_CHECK_WITH_INDEX(assemblyrefprocessor);
  break;
case BIT_TYPEREF:
  ROW_CHECK(typeref);
  break;
case BIT_METHODDEF:
  ROW_CHECK_WITH_INDEX(methoddef);
  break;
case BIT_MEMBERREF:
  ROW_CHECK_WITH_INDEX(memberref);
  break;
case BIT_TYPEDEF:
  ROW_CHECK_WITH_INDEX(typedef_);
  break;
case BIT_TYPESPEC:
  ROW_CHECK(typespec);
  break;
case BIT_FIELD:
  ROW_CHECK_WITH_INDEX(field);
  break;
case BIT_PARAM:
  ROW_CHECK_WITH_INDEX(param);
  break;
case BIT_PROPERTY:
  ROW_CHECK_WITH_INDEX(property);
  break;
case BIT_INTERFACEIMPL:
  ROW_CHECK(interfaceimpl);
  break;
case BIT_EVENT:
  ROW_CHECK_WITH_INDEX(event);
  break;
case BIT_STANDALONESIG:
  ROW_CHECK(standalonesig);
  break;
case BIT_ASSEMBLY:
  ROW_CHECK(assembly);
  break;
case BIT_FILE:
  ROW_CHECK(file);
  break;
case BIT_EXPORTEDTYPE:
  ROW_CHECK(exportedtype);
  break;
case BIT_MANIFESTRESOURCE:
  ROW_CHECK(manifestresource);
  break;
case BIT_GENERICPARAM:
  ROW_CHECK_WITH_INDEX(genericparam);
  break;
case BIT_GENERICPARAMCONSTRAINT:
  ROW_CHECK(genericparamconstraint);
  break;
case BIT_METHODSPEC:
  ROW_CHECK(methodspec);
  break;
default:
  break;
}

matched_bits++;