if (result == op1) {
    // Extend the memory allocation of op1_string to accommodate the concatenated result.
    // Assign the extended string to result_str, which will hold the final concatenated string.
    // If op1_string is being used as the result, ensure it is not prematurely freed.
    // Handle the case where op1_string and op2_string are the same, preventing double release.
    // Update op2_string to point to the new extended string if necessary.
    size_t new_len = op1_len + op2_len;
    if (UNEXPECTED(new_len > ZSTR_MAX_LEN)) {
        zend_throw_error(NULL, "String size overflow");
        if (orig_op1 != result) {
            ZVAL_UNDEF(result);
        }
        return FAILURE;
    }
    result_str = zend_string_extend(op1_string, new_len, 0);
    memcpy(ZSTR_VAL(result_str) + op1_len, ZSTR_VAL(op2_string), op2_len);
    ZSTR_VAL(result_str)[new_len] = '\0';
    if (op1_string == op2_string) {
        op2_string = result_str;
    }
} else {
    // Handle the case where result is not the same as op1.
    result_str = zend_string_alloc(result_len, 0);
    memcpy(ZSTR_VAL(result_str), ZSTR_VAL(op1_string), op1_len);
    memcpy(ZSTR_VAL(result_str) + op1_len, ZSTR_VAL(op2_string), op2_len);
    ZSTR_VAL(result_str)[result_len] = '\0';
}