if (result == op1) {
    // Extend the memory allocation of op1_string to accommodate the concatenated result.
    // Assign the extended string to result_str, which will hold the final concatenated string.
    // If op1_string is being used as the result, ensure it is not prematurely freed.
    // Handle the case where op1_string and op2_string are the same, preventing double release.
    // Update op2_string to point to the new extended string if necessary.
    size_t new_len = op1_len + op2_len;
    if (new_len > ZSTR_MAX_LEN) {
        zend_throw_error(NULL, "String size overflow");
        if (shouldfreeopstring) zend_string_release(op1_string);
        if (free_op2_string) zend_string_release(op2_string);
        if (orig_op1!= result) {
            ZVAL_UNDEF(result);
        }
        return FAILURE;
    }
    zend_string *new_str = zend_string_extend(op1_string, new_len);
    if (new_str == NULL) {
        if (shouldfreeopstring) zend_string_release(op1_string);
        if (free_op2_string) zend_string_release(op2_string);
        if (orig_op1!= result) {
            ZVAL_UNDEF(result);
        }
        return FAILURE;
    }
    memcpy(ZSTR_VAL(new_str), ZSTR_VAL(op1_string), op1_len);
    memcpy(ZSTR_VAL(new_str) + op1_len, ZSTR_VAL(op2_string), op2_len);
    ZSTR_VAL(new_str)[new_len] = '\0';
    if (shouldfreeopstring) {
        zend_string_release(op1_string);
    }
    result_str = new_str;
} else {
    result_str = zend_string_alloc(result_len, 0);
    memcpy(ZSTR_VAL(result_str), ZSTR_VAL(op1_string), op1_len);
}