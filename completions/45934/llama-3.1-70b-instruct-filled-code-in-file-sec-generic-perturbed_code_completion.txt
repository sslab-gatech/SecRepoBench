image->delay);
            (void) WriteBlobString(image,buffer);
          }
        if (image->ticks_per_second!= 0)
          {
            (void) FormatLocaleString(buffer,MagickPathExtent,
              "ticks-per-second=%.20g\n",(double) image->ticks_per_second);
            (void) WriteBlobString(image,buffer);
          }
      }
    if (image->gamma!= 1.0)
      {
        (void) FormatLocaleString(buffer,MagickPathExtent,"gamma=%.20g\n",
          image->gamma);
        (void) WriteBlobString(image,buffer);
      }
    if (image->rendering_intent!= UndefinedIntent)
      {
        (void) FormatLocaleString(buffer,MagickPathExtent,
          "rendering-intent=%s\n",CommandOptionToMnemonic(MagickIntentOptions,
          image->rendering_intent));
        (void) WriteBlobString(image,buffer);
      }
    if (image->chromaticity.red_primary.x!= 0.0)
      {
        (void) FormatLocaleString(buffer,MagickPathExtent,
          "red-primary=%.20gx%.20g\n",image->chromaticity.red_primary.x,
          image->chromaticity.red_primary.y);
        (void) WriteBlobString(image,buffer);
      }
    if (image->chromaticity.green_primary.x!= 0.0)
      {
        (void) FormatLocaleString(buffer,MagickPathExtent,
          "green-primary=%.20gx%.20g\n",image->chromaticity.green_primary.x,
          image->chromaticity.green_primary.y);
        (void) WriteBlobString(image,buffer);
      }
    if (image->chromaticity.blue_primary.x!= 0.0)
      {
        (void) FormatLocaleString(buffer,MagickPathExtent,
          "blue-primary=%.20gx%.20g\n",image->chromaticity.blue_primary.x,
          image->chromaticity.blue_primary.y);
        (void) WriteBlobString(image,buffer);
      }
    if (image->chromaticity.white_point.x!= 0.0)
      {
        (void) FormatLocaleString(buffer,MagickPathExtent,
          "white-point=%.20gx%.20g\n",image->chromaticity.white_point.x,
          image->chromaticity.white_point.y);
        (void) WriteBlobString(image,buffer);
      }
    if (image->background_color.red!= 0.0)
      {
        (void) FormatLocaleString(buffer,MagickPathExtent,
          "background-color=%s\n",image->background_color);
        (void) WriteBlobString(image,buffer);
      }
    if (image->border_color.red!= 0.0)
      {
        (void) FormatLocaleString(buffer,MagickPathExtent,
          "border-color=%s\n",image->border_color);
        (void) WriteBlobString(image,buffer);
      }
    if (image->matte_color.red!= 0.0)
      {
        (void) FormatLocaleString(buffer,MagickPathExtent,
          "matte-color=%s\n",image->matte_color);
        (void) WriteBlobString(image,buffer);
      }
    if (image->dispose!= UndefinedDispose)
      {
        (void) FormatLocaleString(buffer,MagickPathExtent,
          "dispose=%s\n",CommandOptionToMnemonic(MagickDisposeOptions,
          image->dispose));
        (void) WriteBlobString(image,buffer);
      }
    if (image->gravity!= UndefinedGravity)
      {
        (void) FormatLocaleString(buffer,MagickPathExtent,
          "gravity=%s\n",CommandOptionToMnemonic(MagickGravityOptions,
          image->gravity));
        (void) WriteBlobString(image,buffer);
      }
    if (image->orientation!= UndefinedOrientation)
      {
        (void) FormatLocaleString(buffer,MagickPathExtent,
          "orientation=%s\n",CommandOptionToMnemonic(MagickOrientationOptions,
          image->orientation));
        (void) WriteBlobString(image,buffer);
      }
    if (image->quality!= 0)
      {
        (void) FormatLocaleString(buffer,MagickPathExtent,
          "quality=%.20g\n",(double) image->quality);
        (void) WriteBlobString(image,buffer);
      }
    if (image->montage!= (char *) NULL)
      {
        (void) FormatLocaleString(buffer,MagickPathExtent,
          "montage=%s\n",image->montage);
        (void) WriteBlobString(image,buffer);
      }
    for (property=image->properties; property!= (const char *) NULL;
      property=GetNextValueInLinkedList(image->properties,property))
      {
        value=GetMagickProperty(image,property);
        if (value == (const char *) NULL)
          continue;
        (void) FormatLocaleString(buffer,MagickPathExtent,"%s=%s\n",property,
          value);
        (void) WriteBlobString(image,buffer);
      }
    (void) WriteBlobString(image,":\n");
    if (image->storage_class == PseudoClass)
      {
        unsigned char
          *colormap;

        /*
          Write image colormap.
        */
        packet_size=(size_t) (3UL*image->depth/8UL);
        colormap=(unsigned char *) AcquireQuantumMemory(image->colors,
          packet_size*sizeof(*colormap));
        if (colormap == (unsigned char *) NULL)
          ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
        for (i=0; i < (ssize_t) image->colors; i++)
        {
          switch (image->depth)
          {
            case 8:
            {
              unsigned char
                char_pixel;

              char_pixel=(unsigned char) ScaleQuantumToChar(image->colormap[i].
                red);
              colormap=PopCharPixel(char_pixel,colormap);
              char_pixel=(unsigned char) ScaleQuantumToChar(image->colormap[i].
                green);
              colormap=PopCharPixel(char_pixel,colormap);
              char_pixel=(unsigned char) ScaleQuantumToChar(image->colormap[i].
                blue);
              colormap=PopCharPixel(char_pixel,colormap);
              break;
            }
            case 16:
            {
              unsigned short
                short_pixel;

              short_pixel=ScaleQuantumToShort(image->colormap[i].red);
              colormap=PopShortPixel(MSBEndian,short_pixel,colormap);
              short_pixel=ScaleQuantumToShort(image->colormap[i].green);
              colormap=PopShortPixel(MSBEndian,short_pixel,colormap);
              short_pixel=ScaleQuantumToShort(image->colormap[i].blue);
              colormap=PopShortPixel(MSBEndian,short_pixel,colormap);
              break;
            }
            case 32:
            default:
            {
              unsigned int
                long_pixel;

              long_pixel=ScaleQuantumToLong(image->colormap[i].red);
              colormap=PopLongPixel(MSBEndian,long_pixel,colormap);
              long_pixel=ScaleQuantumToLong(image->colormap[i].green);
              colormap=PopLongPixel(MSBEndian,long_pixel,colormap);
              long_pixel=ScaleQuantumToLong(image->colormap[i].blue);
              colormap=PopLongPixel(MSBEndian,long_pixel,colormap);
              break;
            }
          }
        }
        (void) WriteBlob(image,(size_t) (packet_size*image->colors),colormap);
        colormap=(unsigned char *) RelinquishMagickMemory(colormap);
      }
    pixels=(unsigned char *) GetQuantumPixels(quantum_info);
    quantum_type=RGBQuantum;
    if (image->alpha_trait!= UndefinedPixelTrait)
      quantum_type=RGBAQuantum;
    if (image->colorspace == CMYKColorspace)
      {
        quantum_type=CMYKQuantum;
        if (image->alpha_trait!= UndefinedPixelTrait)
          quantum_type=CMYKAQuantum;
      }
    if (IsGrayColorspace(image->colorspace)!= MagickFalse)
      {
        quantum_type=GrayQuantum;
        if (image->alpha_trait!= UndefinedPixelTrait)
          quantum_type=GrayAlphaQuantum;
      }
    if (image->storage_class == PseudoClass)
      {
        quantum_type=IndexQuantum;
        if (image->alpha_trait!= UndefinedPixelTrait)
          quantum_type=IndexAlphaQuantum;
      }
    status=MagickTrue;
    GetPixelInfo(image,&pixel);
    for (y=0; y < (ssize_t) image->rows; y++)
    {
      ssize_t
        x;

      Quantum
        *magick_restrict q;

      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
      if (q == (Quantum *) NULL)
        break;
      for (x=0; x < (ssize_t) image->columns; x++)
      {
        if (image->storage_class == PseudoClass)
          {
            pixel.index=GetPixelIndex(image,q);
            if (image->alpha_trait!= UndefinedPixelTrait)
              pixel.alpha=GetPixelAlpha(image,q);
          }
        else
          {
            pixel.red=GetPixelRed(image,q);
            pixel.green=GetPixelGreen(image,q);
            pixel.blue=GetPixelBlue(image,q);
            if (image->colorspace == CMYKColorspace)
              pixel.black=GetPixelBlack(image,q);
          }
        pixels=PopRunlengthPacket(image,pixels,length,&pixel);
        if (length == 0)
          {
            length=1;
            pixels=PopRunlengthPacket(image,pixels,length,&pixel);
          }
        length++;
        if (length > 127)
          {
            pixels=PopRunlengthPacket(image,pixels,length,&pixel);
            length=1;
          }
        q+=GetPixelChannels(image);
      }
      pixels=PopRunlengthPacket(image,pixels,length,&pixel);
      length=0;
      if (compression == RLECompression)
        {
          (void) WriteBlob(image,(size_t) (packet_size*image->columns+1),
            pixels);
          pixels=(unsigned char *) GetQuantumPixels(quantum_info);
          continue;
        }
      switch (compression)
      {
#if defined(MAGICKCORE_BZLIB_DELEGATE)
        case BZipCompression:
        {
          int
            code;

          bzip_info.bzalloc=AcquireBZIPMemory;
          bzip_info.bzfree=RelinquishBZIPMemory;
          bzip_info.opaque=(void *) image;
          code=BZ2_bzBuffToBuffCompress(compress_pixels,(unsigned int *)
            &length,pixels,packet_size*image->columns,9,BZ_DEFAULT,30);
          if (code!= BZ_OK)
            status=MagickFalse;
          (void) WriteBlobMSBLong(image,length);
          (void) WriteBlob(image,length,compress_pixels);
          break;
        }
#endif
#if defined(MAGICKCORE_LZMA_DELEGATE)
        case LZMACompression:
        {
          int
            code;

          allocator.alloc=AcquireLZMAMemory;
          allocator.free=RelinquishLZMAMemory;
          allocator.opaque=(void *) image;
          lzma_info=initialize_lzma;
          lzma_info.allocator=(&allocator);
          code=lzma_easy_encoder(&lzma_info,9,LZMA_CHECK_CRC32);
          if (code!= LZMA_OK)
            status=MagickFalse;
          lzma_info.next_in=pixels;
          lzma_info.avail_in=packet_size*image->columns;
          lzma_info.next_out=compress_pixels;
          lzma_info.avail_out=length;
          code=lzma_code(&lzma_info,LZMA_FINISH);
          if ((code!= LZMA_OK) && (code!= LZMA_STREAM_END))
            status=MagickFalse;
          (void) WriteBlobMSBLong(image,lzma_info.total_out);
          (void) WriteBlob(image,lzma_info.total_out,compress_pixels);
          lzma_end(&lzma_info);
          break;
        }
#endif
#if defined(MAGICKCORE_ZLIB_DELEGATE)
        case LZWCompression:
        case ZipCompression:
        {
          int
            code;

          zip_info.zalloc=AcquireZIPMemory;
          zip_info.zfree=RelinquishZIPMemory;
          zip_info.opaque=(voidpf) image;
          code=deflateInit(&zip_info,Z_DEFAULT_COMPRESSION);
          if (code!= Z_OK)
            status=MagickFalse;
          zip_info.next_in=pixels;
          zip_info.avail_in=(uInt) (packet_size*image->columns);
          zip_info.next_out=compress_pixels;
          zip_info.avail_out=(uInt) length;
          code=deflate(&zip_info,Z_FINISH);
          if ((code!= Z_OK) && (code!= Z_STREAM_END))
            status=MagickFalse;
          (void) WriteBlobMSBLong(image,zip_info.total_out);
          (void) WriteBlob(image,zip_info.total_out,compress_pixels);
          (void) deflateEnd(&zip_info);
          break;
        }
#endif
        default:
        {
          (void) WriteBlob(image,(size_t) (packet_size*image->columns),pixels);
          break;
        }
      }
      pixels=(unsigned char *) GetQuantumPixels(quantum_info);
    }
    quantum_info=DestroyQuantumInfo(quantum_info);
    compress_pixels=(unsigned char *) RelinquishMagickMemory(compress_pixels);
    if (status == MagickFalse)
      return(status);
    if (EOFBlob(image)!= MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,"UnexpectedEndOfFile",
          image->filename);
        break;
      }
    /*
      Proceed to next image.
    */
    if (image_info->number_scenes!= 0)
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    scene++;
    if (GetNextImageInList(image) == (Image *) NULL)
      break;
    image=SyncNextImageInList(image);
    status=SetImageProgress(image,SaveImagesTag,TellBlob(image),
      GetBlobSize(image));
    if (status == MagickFalse)
      break;
  } while (scene < imageListLength);
  (void) CloseBlob(image);
  return(status);
}
#endif