ormap=(unsigned char *) AcquireQuantumMemory(image->colors,
          colormap_size*sizeof(*colormap));
        if (colormap == (unsigned char *) NULL)
          ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
        for (i=0; i < (ssize_t) image->colors; i++)
        {
          colormap[i*3+0]=(unsigned char)
            ScaleQuantumToChar(image->colormap[i].red);
          colormap[i*3+1]=(unsigned char)
            ScaleQuantumToChar(image->colormap[i].green);
          colormap[i*3+2]=(unsigned char)
            ScaleQuantumToChar(image->colormap[i].blue);
        }
        (void) WriteBlob(image,image->colors*colormap_size,colormap);
        colormap=(unsigned char *) RelinquishMagickMemory(colormap);
      }
    else
      {
        /*
          Write image pixels.
        */
        pixels=(unsigned char *) GetQuantumPixels(quantum_info);
        switch (quantum_info->format)
        {
          case FloatingPointQuantumFormat:
          {
            double
              *p;

            for (y=0; y < (ssize_t) image->rows; y++)
            {
              q=pixels;
              for (i=0; i < (ssize_t) image->columns; i++)
              {
                p=PushDoublePixel(q);
                (void) WriteBlobMSBLong(image,(unsigned int)
                  ScaleQuantumToChar(image->colormap[*p].red));
                (void) WriteBlobMSBLong(image,(unsigned int)
                  ScaleQuantumToChar(image->colormap[*p].green));
                (void) WriteBlobMSBLong(image,(unsigned int)
                  ScaleQuantumToChar(image->colormap[*p].blue));
                if (image->colorspace == CMYKColorspace)
                  (void) WriteBlobMSBLong(image,(unsigned int)
                    ScaleQuantumToChar(image->colormap[*p].black));
                if (image->alpha_trait != UndefinedPixelTrait)
                  (void) WriteBlobMSBLong(image,(unsigned int)
                    ScaleQuantumToChar(image->colormap[*p].alpha));
                q+=GetPixelChannels(image);
              }
              pixels+=quantum_info->row_stride;
            }
            break;
          }
          case UndefinedQuantumFormat:
          case IntegerQuantumFormat:
          default:
          {
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              q=pixels;
              for (i=0; i < (ssize_t) image->columns; i++)
              {
                (void) WriteBlobMSBLong(image,(unsigned int)
                  ScaleQuantumToChar(image->colormap[*q].red));
                (void) WriteBlobMSBLong(image,(unsigned int)
                  ScaleQuantumToChar(image->colormap[*q].green));
                (void) WriteBlobMSBLong(image,(unsigned int)
                  ScaleQuantumToChar(image->colormap[*q].blue));
                if (image->colorspace == CMYKColorspace)
                  (void) WriteBlobMSBLong(image,(unsigned int)
                    ScaleQuantumToChar(image->colormap[*q].black));
                if (image->alpha_trait != UndefinedPixelTrait)
                  (void) WriteBlobMSBLong(image,(unsigned int)
                    ScaleQuantumToChar(image->colormap[*q].alpha));
                q+=GetPixelChannels(image);
              }
              pixels+=quantum_info->row_stride;
            }
            break;
          }
        }
      }
    if (compression != NoCompression)
      {
        size_t
          compress_length;

        switch (compression)
        {
#if defined(MAGICKCORE_BZLIB_DELEGATE)
          case BZipCompression:
          {
            bzip_info.bzalloc=AcquireBZIPMemory;
            bzip_info.bzfree=RelinquishBZIPMemory;
            bzip_info.opaque=(void *) image;
            bzip_info.next_in=(char *) pixels;
            bzip_info.avail_in=(unsigned int) (packet_size*image->columns*
              image->rows);
            bzip_info.next_out=(char *) compress_pixels;
            bzip_info.avail_out=(unsigned int) length;
            (void) BZ2_bzCompressInit(&bzip_info,(int) image_info->quality,
              0,0);
            do
            {
              int
                code;

              code=BZ2_bzCompress(&bzip_info,BZ_RUN);
              if ((code != BZ_RUN_OK) && (code != BZ_FLUSH_OK) &&
                  (code != BZ_FINISH_OK))
                ThrowWriterException(CoderError,"BZipCompressionFailed");
              compress_length=length-(size_t) bzip_info.avail_out;
              if (compress_length != 0)
                (void) WriteBlob(image,compress_length,compress_pixels);
              bzip_info.next_out=(char *) compress_pixels;
              bzip_info.avail_out=(unsigned int) length;
            } while (bzip_info.avail_in != 0);
            (void) BZ2_bzCompressEnd(&bzip_info);
            break;
          }
#endif
#if defined(MAGICKCORE_LZMA_DELEGATE)
          case LZMACompression:
          {
            lzma_info=initialize_lzma;
            lzma_info.allocator=&allocator;
            lzma_info.next_in=pixels;
            lzma_info.avail_in=(size_t) (packet_size*image->columns*
              image->rows);
            lzma_info.next_out=compress_pixels;
            lzma_info.avail_out=length;
            (void) lzma_code(&lzma_info,LZMA_RUN);
            compress_length=length-(size_t) lzma_info.avail_out;
            if (compress_length != 0)
              (void) WriteBlob(image,compress_length,compress_pixels);
            (void) lzma_code(&lzma_info,LZMA_FINISH);
            break;
          }
#endif
#if defined(MAGICKCORE_ZLIB_DELEGATE)
          case LZWCompression:
          case ZipCompression:
          {
            zip_info.zalloc=AcquireZIPMemory;
            zip_info.zfree=RelinquishZIPMemory;
            zip_info.opaque=(voidpf) image;
            zip_info.next_in=pixels;
            zip_info.avail_in=(uInt) (packet_size*image->columns*image->rows);
            zip_info.next_out=compress_pixels;
            zip_info.avail_out=length;
            (void) deflateInit(&zip_info,Z_DEFAULT_COMPRESSION);
            do
            {
              int
                code;

              code=deflate(&zip_info,Z_SYNC_FLUSH);
              if ((code != Z_OK) && (code != Z_STREAM_END))
                ThrowWriterException(CoderError,"ZipCompressionFailed");
              compress_length=length-(size_t) zip_info.avail_out;
              if (compress_length != 0)
                (void) WriteBlob(image,compress_length,compress_pixels);
              zip_info.next_out=compress_pixels;
              zip_info.avail_out=length;
            } while (zip_info.avail_in != 0);
            (void) deflateEnd(&zip_info);
            break;
          }
#endif
          default:
            break;
        }
      }
    if (image->scene != 0)
      {
        (void) WriteBlobString(image,"\f\n:\032");
        if (image->directory != (char *) NULL)
          (void) WriteBlob(image,strlen(image->directory),(unsigned char *)
            image->directory);
        (void) WriteBlobByte(image,'\0');
      }
    if (image->profiles != 0)
      {
        const char
          *name;

        const StringInfo
          *profile;

        /*
          Write image profile blob.
        */
        ResetImageProfileIterator(image);
        name=GetNextImageProfile(image);
        while (name != (const char *) NULL)
        {
          profile=GetImageProfile(image,name);
          (void) WriteBlobMSBLong(image,(unsigned int)
            GetStringInfoLength(profile));
          (void) WriteBlob(image,GetStringInfoLength(profile),
            GetStringInfoDatum(profile));
          name=GetNextImageProfile(image);
        }
      }
    if (image->montage != (char *) NULL)
      {
        (void) WriteBlobString(image,"\f\n:\032");
        if (image->directory != (char *) NULL)
          (void) WriteBlob(image,strlen(image->directory),(unsigned char *)
            image->directory);
        (void) WriteBlobByte(image,'\0');
      }
    if (image->profiles != 0)
      {
        const char
          *name;

        const StringInfo
          *profile;

        /*
          Write image profile names.
        */
        ResetImageProfileIterator(image);
        for (name=GetNextImageProfile(image); name != (const char *) NULL; )
        {
          profile=GetImageProfile(image,name);
          if (profile != (StringInfo *) NULL)
            {
              (void) FormatLocaleString(buffer,MagickPathExtent,"profile=%s\n",
                name);
              (void) WriteBlobString(image,buffer);
            }
          name=GetNextImageProfile(image);
        }
      }
    if (image->montage != (char *) NULL)
      {
        (void) WriteBlobString(image,"\f\n:\032");
        if (image->directory != (char *) NULL)
          (void) WriteBlob(image,strlen(image->directory),(unsigned char *)
            image->directory);
        (void) WriteBlobByte(image,'\0');
      }
    if (image->scene != 0)
      {
        (void) WriteBlobString(image,"\f\n:\032");
        if (image->directory != (char *) NULL)
          (void) WriteBlob(image,strlen(image->directory),(unsigned char *)
            image->directory);
        (void) WriteBlobByte(image,'\0');
      }
    if (image->profiles != 0)
      {
        const char
          *name;

        const StringInfo
          *profile;

        /*
          Write image profile blob.
        */
        ResetImageProfileIterator(image);
        name=GetNextImageProfile(image);
        while (name != (const char *) NULL)
        {
          profile=GetImageProfile(image,name);
          (void) WriteBlobMSBLong(image,(unsigned int)
            GetStringInfoLength(profile));
          (void) WriteBlob(image,GetStringInfoLength(profile),
            GetStringInfoDatum(profile));
          name=GetNextImageProfile(image);
        }
      }
    if (image->montage != (char *) NULL)
      {
        (void) WriteBlobString(image,"\f\n:\032");
        if (image->directory != (char *) NULL)
          (void) WriteBlob(image,strlen(image->directory),(unsigned char *)
            image->directory);
        (void) WriteBlobByte(image,'\0');
      }
    if (image->profiles != 0)
      {
        const char
          *name;

        const StringInfo
          *profile;

        /*
          Write image profile names.
        */
        ResetImageProfileIterator(image);
        for (name=GetNextImageProfile(image); name != (const char *) NULL; )
        {
          profile=GetImageProfile(image,name);
          if (profile != (StringInfo *) NULL)
            {
              (void) FormatLocaleString(buffer,MagickPathExtent,"profile=%s\n",
                name);
              (void) WriteBlobString(image,buffer);
            }
          name=GetNextImageProfile(image);
        }
      }
    if (image->montage != (char *) NULL)
      {
        (void) WriteBlobString(image,"\f\n:\