case 8:
            {
              unsigned char
                char_pixel;

              char_pixel=ScaleQuantumToChar((Quantum)
                image->colormap[i].red);
              q=PushCharPixel(q,&char_pixel);
              char_pixel=ScaleQuantumToChar((Quantum)
                image->colormap[i].green);
              q=PushCharPixel(q,&char_pixel);
              char_pixel=ScaleQuantumToChar((Quantum)
                image->colormap[i].blue);
              q=PushCharPixel(q,&char_pixel);
              break;
            }
          }
        }
        (void) WriteBlob(image,image->colors*colormap_size,colormap);
        colormap=(unsigned char *) RelinquishMagickMemory(colormap);
      }
    /*
      Write image pixels.
    */
    pixels=GetImagePixels(image,0,0,image->columns,image->rows,exception);
    if (pixels == (unsigned char *) NULL)
      ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
    length=0;
    for (y=0; y < (ssize_t) image->rows; y++)
    {
      if (status == MagickFalse)
        break;
      q=pixels;
      switch (compression)
      {
#if defined(MAGICKCORE_BZLIB_DELEGATE)
        case BZipCompression:
        {
          bzip_info.next_in=(char *) q;
          bzip_info.avail_in=(unsigned int) (packet_size*image->columns);
          do
          {
            int
              code;

            bzip_info.next_out=(char *) compress_pixels;
            bzip_info.avail_out=(unsigned int) (packet_size*image->columns);
            code=BZ2_bzCompress(&bzip_info,BZ_RUN);
            if ((code != BZ_OK) && (code != BZ_STREAM_END))
              {
                status=MagickFalse;
                break;
              }
            if (code == BZ_STREAM_END)
              break;
            count=WriteBlob(image,bzip_info.next_out-compress_pixels,
              compress_pixels);
            if (count != (ssize_t) (bzip_info.next_out-compress_pixels))
              {
                status=MagickFalse;
                break;
              }
          } while (bzip_info.avail_out == 0);
          length+=count;
          break;
        }
#endif
#if defined(MAGICKCORE_LZMA_DELEGATE)
        case LZMACompression:
        {
          lzma_info=initialize_lzma;
          lzma_info.allocator=&allocator;
          lzma_info.next_in=q;
          lzma_info.avail_in=(size_t) (packet_size*image->columns);
          do
          {
            int
              code;

            lzma_info.next_out=compress_pixels;
            lzma_info.avail_out=(size_t) (packet_size*image->columns);
            code=lzma_code(&lzma_info,LZMA_RUN);
            if ((code != LZMA_OK) && (code != LZMA_STREAM_END))
              {
                status=MagickFalse;
                break;
              }
            if (code == LZMA_STREAM_END)
              break;
            count=WriteBlob(image,lzma_info.next_out-compress_pixels,
              compress_pixels);
            if (count != (ssize_t) (lzma_info.next_out-compress_pixels))
              {
                status=MagickFalse;
                break;
              }
          } while (lzma_info.avail_out == 0);
          length+=count;
          break;
        }
#endif
#if defined(MAGICKCORE_ZLIB_DELEGATE)
        case LZWCompression:
        case ZipCompression:
        {
          zip_info.next_in=q;
          zip_info.avail_in=(uInt) (packet_size*image->columns);
          do
          {
            int
              code;

            zip_info.next_out=compress_pixels;
            zip_info.avail_out=(uInt) (packet_size*image->columns);
            code=deflate(&zip_info,Z_SYNC_FLUSH);
            if ((code != Z_OK) && (code != Z_STREAM_END))
              {
                status=MagickFalse;
                break;
              }
            if (code == Z_STREAM_END)
              break;
            count=WriteBlob(image,zip_info.next_out-compress_pixels,
              compress_pixels);
            if (count != (ssize_t) (zip_info.next_out-compress_pixels))
              {
                status=MagickFalse;
                break;
              }
          } while (zip_info.avail_out == 0);
          length+=count;
          break;
        }
#endif
        case RLECompression:
        {
          for (i=0; i < (ssize_t) (packet_size*image->columns); i++)
          {
            if (length == 0)
              {
                count=WriteBlob(image,packet_size,q);
                if (count != (ssize_t) packet_size)
                  {
                    status=MagickFalse;
                    break;
                  }
                PushRunlengthPacket(image,q,&length,&pixel,exception);
              }
            length--;
            q+=GetPixelChannels(image);
          }
          length=(size_t) i;
          break;
        }
        default:
        {
          const void
            *stream;

          stream=WriteBlobStream(image,packet_size*image->columns,q,&count);
          if (count != (ssize_t) (packet_size*image->columns))
            {
              status=MagickFalse;
              break;
            }
          length+=count;
          break;
        }
      }
      pixels+=image->columns*GetPixelChannels(image);
    }
    if (status == MagickFalse)
      break;
    status=SyncImagePixels(image,exception);
    if (status == MagickFalse)
      break;
    if (image->scene != 0)
      {
        if (scene == 0)
          (void) FormatLocaleString(buffer,MagickPathExtent,
            "iterations=%.20g  delay=%.20g  ticks-per-second=%.20g\n",
            (double) image->iterations,(double) image->delay,
            (double) image->ticks_per_second);
        else
          (void) FormatLocaleString(buffer,MagickPathExtent,
            "scene=%.20g  iterations=%.20g  delay=%.20g  ticks-per-second=%.20g\n",
            (double) image->scene,(double) image->iterations,(double)
            image->delay,(double) image->ticks_per_second);
        (void) WriteBlobString(image,buffer);
        scene++;
      }
    if (image->montage != (char *) NULL)
      {
        if (image->directory != (char *) NULL)
          (void) WriteBlob(image,strlen(image->directory),(unsigned char *)
            image->directory);
        (void) WriteBlobByte(image,'\0');
      }
    if (image->profiles != 0)
      {
        const char
          *name;

        const StringInfo
          *profile;

        ResetImageProfileIterator(image);
        name=GetNextImageProfile(image);
        while (name != (const char *) NULL)
        {
          profile=GetImageProfile(image,name);
          (void) WriteBlobMSBLong(image,(unsigned int)
            GetStringInfoLength(profile));
          (void) WriteBlob(image,GetStringInfoLength(profile),
            GetStringInfoDatum(profile));
          name=GetNextImageProfile(image);
        }
      }
    if (image->montage != (char *) NULL)
      {
        if (image->directory != (char *) NULL)
          (void) WriteBlob(image,strlen(image->directory),(unsigned char *)
            image->directory);
        (void) WriteBlobByte(image,'\0');
      }
    if (image->profiles != 0)
      {
        const char
          *name;

        const StringInfo
          *profile;

        ResetImageProfileIterator(image);
        name=GetNextImageProfile(image);
        while (name != (const char *) NULL)
        {
          profile=GetImageProfile(image,name);
          (void) WriteBlobMSBLong(image,(unsigned int)
            GetStringInfoLength(profile));
          (void) WriteBlob(image,GetStringInfoLength(profile),
            GetStringInfoDatum(profile));
          name=GetNextImageProfile(image);
        }
      }
    if (image->montage != (char *) NULL)
      {
        if (image->directory != (char *) NULL)
          (void) WriteBlob(image,strlen(image->directory),(unsigned char *)
            image->directory);
        (void) WriteBlobByte(image,'\0');
      }
    if (image->profiles != 0)
      {
        const char
          *name;

        const StringInfo
          *profile;

        ResetImageProfileIterator(image);
        name=GetNextImageProfile(image);
        while (name != (const char *) NULL)
        {
          profile=GetImageProfile(image,name);
          (void) WriteBlobMSBLong(image,(unsigned int)
            GetStringInfoLength(profile));
          (void) WriteBlob(image,GetStringInfoLength(profile),
            GetStringInfoDatum(profile));
          name=GetNextImageProfile(image);
        }
      }
    if (image->montage != (char *) NULL)
      {
        if (image->directory != (char *) NULL)
          (void) WriteBlob(image,strlen(image->directory),(unsigned char *)
            image->directory);
        (void) WriteBlobByte(image,'\0');
      }
    if (image->profiles != 0)
      {
        const char
          *name;

        const StringInfo
          *profile;

        ResetImageProfileIterator(image);
        name=GetNextImageProfile(image);
        while (name != (const char *) NULL)
        {
          profile=GetImageProfile(image,name);
          (void) WriteBlobMSBLong(image,(unsigned int)
            GetStringInfoLength(profile));
          (void) WriteBlob(image,GetStringInfoLength(profile),
            GetStringInfoDatum(profile));
          name=GetNextImageProfile(image);
        }
      }
    if (image->montage != (char *) NULL)
      {
        if (image->directory != (char *) NULL)
          (void) WriteBlob(image,strlen(image->directory),(unsigned char *)
            image->directory);
        (void) WriteBlobByte(image,'\0');
      }
    if (image->profiles != 0)
      {
        const char
          *name;

        const StringInfo
          *profile;

        ResetImageProfileIterator(image);
        name=GetNextImageProfile(image);
        while (name != (const char *) NULL)
        {
          profile=GetImageProfile(image,name);
          (void) WriteBlobMSBLong(image,(unsigned int)
            GetStringInfoLength(profile));
          (void) WriteBlob(image,GetStringInfoLength(profile),
            GetStringInfoDatum(profile));
          name=GetNextImageProfile(image);
        }
      }
    if (image->montage != (char *) NULL)
      {
        if (image->directory != (char *) NULL)
          (void) WriteBlob(image,strlen(image->directory),(unsigned char *)
            image->directory);
        (void) WriteBlobByte(image,'\0');
      }
    if (image->profiles != 0)
      {
        const char
          *name;

        const StringInfo
          *profile;

        ResetImageProfileIterator(image);
        name=GetNextImageProfile(image);
        while (name != (const char *) NULL)
        {
          profile=GetImageProfile(image,name);
          (void) WriteBlobMSBLong(image,(unsigned int)
            GetStringInfoLength(profile));
          (void) WriteBlob(image,GetStringInfoLength(profile),
            GetStringInfoDatum(profile));
          name=GetNextImageProfile(image);
        }
      }
    if (image->montage