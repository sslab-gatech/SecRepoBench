pixels=PushLongPixel(MSBEndian,pixels,&value);
          break;
        }
        case 16:
        {
          value=(unsigned short) (value << (image->depth-MAGICKCORE_QUANTUM_DEPTH));
          pixels=PushShortPixel(MSBEndian,pixels,&value);
          break;
        }
        case 8:
        {
          pixels=PushCharPixel(pixels,&value);
          break;
        }
      }
      length--;
      return(pixels);
    }
  value=(unsigned int) ClampToQuantum(pixel->red);
  switch (image->depth)
  {
    case 32:
    default:
    {
      pixels=PushLongPixel(MSBEndian,pixels,&value);
      break;
    }
    case 16:
    {
      value=(unsigned short) (value << (image->depth-MAGICKCORE_QUANTUM_DEPTH));
      pixels=PushShortPixel(MSBEndian,pixels,&value);
      break;
    }
    case 8:
    {
      pixels=PushCharPixel(pixels,&value);
      break;
    }
  }
  value=(unsigned int) ClampToQuantum(pixel->green);
  switch (image->depth)
  {
    case 32:
    default:
    {
      pixels=PushLongPixel(MSBEndian,pixels,&value);
      break;
    }
    case 16:
    {
      value=(unsigned short) (value << (image->depth-MAGICKCORE_QUANTUM_DEPTH));
      pixels=PushShortPixel(MSBEndian,pixels,&value);
      break;
    }
    case 8:
    {
      pixels=PushCharPixel(pixels,&value);
      break;
    }
  }
  value=(unsigned int) ClampToQuantum(pixel->blue);
  switch (image->depth)
  {
    case 32:
    default:
    {
      pixels=PushLongPixel(MSBEndian,pixels,&value);
      break;
    }
    case 16:
    {
      value=(unsigned short) (value << (image->depth-MAGICKCORE_QUANTUM_DEPTH));
      pixels=PushShortPixel(MSBEndian,pixels,&value);
      break;
    }
    case 8:
    {
      pixels=PushCharPixel(pixels,&value);
      break;
    }
  }
  if (image->colorspace == CMYKColorspace)
    {
      value=(unsigned int) ClampToQuantum(pixel->black);
      switch (image->depth)
      {
        case 32:
        default:
        {
          pixels=PushLongPixel(MSBEndian,pixels,&value);
          break;
        }
        case 16:
        {
          value=(unsigned short) (value << (image->depth-MAGICKCORE_QUANTUM_DEPTH));
          pixels=PushShortPixel(MSBEndian,pixels,&value);
          break;
        }
        case 8:
        {
          pixels=PushCharPixel(pixels,&value);
          break;
        }
      }
    }
  if (image->alpha_trait != UndefinedPixelTrait)
    {
      value=(unsigned int) ClampToQuantum(pixel->alpha);
      switch (image->depth)
      {
        case 32:
        default:
        {
          pixels=PushLongPixel(MSBEndian,pixels,&value);
          break;
        }
        case 16:
        {
          value=(unsigned short) (value << (image->depth-MAGICKCORE_QUANTUM_DEPTH));
          pixels=PushShortPixel(MSBEndian,pixels,&value);
          break;
        }
        case 8:
        {
          pixels=PushCharPixel(pixels,&value);
          break;
        }
      }
    }
  length--;
  return(pixels);
}

static MagickBooleanType WriteMIFFImage(const ImageInfo *image_info,
  Image *image,ExceptionInfo *exception)
{
#define BZipMaxExtent(x)  ((x)+((x)/100)+600)
#define LZMAMaxExtent(x)  ((x)+((x)/3)+128)
#define ZipMaxExtent(x)  ((x)+(((x)+7) >> 3)+(((x)+63) >> 6)+11)

#if defined(MAGICKCORE_BZLIB_DELEGATE)
  bz_stream
    bzip_info;
#endif

  char
    *options;

  double
    version;

  size_t
    compress_extent,
    extent,
    length,
    packet_size;

  ssize_t
    y;

#if defined(MAGICKCORE_LZMA_DELEGATE)
  lzma_stream
    lzma_info = LZMA_STREAM_INIT;

  lzma_allocator
    allocator;
#endif

  MagickBooleanType
    status;

  PixelInfo
    pixel;

  QuantumType
    quantum_type;

  unsigned char
    *compress_pixels,
    *pixels;

#if defined(MAGICKCORE_ZLIB_DELEGATE)
  z_stream
    zip_info;
#endif

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
  if (status == MagickFalse)
    return(status);
  /*
    Initialize image structure.
  */
  version=1.0;
  (void) version;
  options=AcquireString((char *) NULL);
  (void) strcpy(options,"id=ImageMagick");
  (void) WriteBlobString(image,options);
  (void) WriteBlobByte(image,(int) '\n');
  /*
    Write image header;  header terminates one character beyond a ':'.
  */
  (void) strcpy(options,"class=DirectClass");
  (void) WriteBlobString(image,options);
  (void) WriteBlobByte(image,(int) '\n');
  (void) strcpy(options,"depth=8");
  (void) WriteBlobString(image,options);
  (void) WriteBlobByte(image,(int) '\n');
  (void) strcpy(options,"colors=256");
  (void) WriteBlobString(image,options);
  (void) WriteBlobByte(image,(int) '\n');
  (void) strcpy(options,"colormap=gray");
  (void) WriteBlobString(image,options);
  (void) WriteBlobByte(image,(int) '\n');
  (void) strcpy(options,"alpha-trait=Undefined");
  (void) WriteBlobString(image,options);
  (void) WriteBlobByte(image,(int) '\n');
  (void) strcpy(options,"endian=LSBEndian");
  (void) WriteBlobString(image,options);
  (void) WriteBlobByte(image,(int) '\n');
  (void) strcpy(options,"matte=False");
  (void) WriteBlobString(image,options);
  (void) WriteBlobByte(image,(int) '\n');
  (void) strcpy(options,"compression=RLECompression");
  (void) WriteBlobString(image,options);
  (void) WriteBlobByte(image,(int) '\n');
  (void) strcpy(options,"resolution=1x1");
  (void) WriteBlobString(image,options);
  (void) WriteBlobByte(image,(int) '\n');
  (void) strcpy(options,"geometry=0x0+0+0");
  (void) WriteBlobString(image,options);
  (void) WriteBlobByte(image,(int) '\n');
  (void) strcpy(options,"ticks-per-second=100");
  (void) WriteBlobString(image,options);
  (void) WriteBlobByte(image,(int) '\n');
  (void) strcpy(options,"delay=0");
  (void) WriteBlobString(image,options);
  (void) WriteBlobByte(image,(int) '\n');
  (void) strcpy(options,"dispose=Undefined");
  (void) WriteBlobString(image,options);
  (void) WriteBlobByte(image,(int) '\n');
  (void) strcpy(options,"orientation=Undefined");
  (void) WriteBlobString(image,options);
  (void) WriteBlobByte(image,(int) '\n');
  (void) strcpy(options,"page=0x0+0+0");
  (void) WriteBlobString(image,options);
  (void) WriteBlobByte(image,(int) '\n');
  (void) strcpy(options,"type=TrueColor");
  (void) WriteBlobString(image,options);
  (void) WriteBlobByte(image,(int) '\n');
  (void) strcpy(options,"units=Undefined");
  (void) WriteBlobString(image,options);
  (void) WriteBlobByte(image,(int) '\n');
  (void) strcpy(options,"rendering-intent=Undefined");
  (void) WriteBlobString(image,options);
  (void) WriteBlobByte(image,(int) '\n');
  (void) strcpy(options,"gamma=0.0");
  (void) WriteBlobString(image,options);
  (void) WriteBlobByte(image,(int) '\n');
  (void) strcpy(options,"colorspace=sRGB");
  (void) WriteBlobString(image,options);
  (void) WriteBlobByte(image,(int) '\n');
  (void) strcpy(options,"chromaticity.red_primary.x=0.640000");
  (void) WriteBlobString(image,options);
  (void) WriteBlobByte(image,(int) '\n');
  (void) strcpy(options,"chromaticity.red_primary.y=0.330000");
  (void) WriteBlobString(image,options);
  (void) WriteBlobByte(image,(int) '\n');
  (void) strcpy(options,"chromaticity.green_primary.x=0.300000");
  (void) WriteBlobString(image,options);
  (void) WriteBlobByte(image,(int) '\n');
  (void) strcpy(options,"chromaticity.green_primary.y=0.600000");
  (void) WriteBlobString(image,options);
  (void) WriteBlobByte(image,(int) '\n');
  (void) strcpy(options,"chromaticity.blue_primary.x=0.150000");
  (void) WriteBlobString(image,options);
  (void) WriteBlobByte(image,(int) '\n');
  (void) strcpy(options,"chromaticity.blue_primary.y=0.060000");
  (void) WriteBlobString(image,options);
  (void) WriteBlobByte(image,(int) '\n');
  (void) strcpy(options,"chromaticity.white_point.x=0.312700");
  (void) WriteBlobString(image,options);
  (void) WriteBlobByte(image,(int) '\n');
  (void) strcpy(options,"chromaticity.white_point.y=0.329000");
  (void) WriteBlobString(image,options);
  (void) WriteBlobByte(image,(int) '\n');
  (void) strcpy(options,"quality=100");
  (void) WriteBlobString(image,options);
  (void) WriteBlobByte(image,(int) '\n');
  (void) strcpy(options,"comment=This is a comment");
  (void) WriteBlobString(image,options);
  (void) WriteBlobByte(image,(int) '\n');
  (void) strcpy(options,"profile=icc");
  (void) WriteBlobString(image,options);
  (void) WriteBlobByte(image,(int) '\n');
  (void) strcpy(options,"profile=iptc");
  (void