ClampToQuantum(pixel->green));
          pixels=PopLongPixel(MSBEndian,value,pixels);
          value=ScaleQuantumToLong(ClampToQuantum(pixel->blue));
          pixels=PopLongPixel(MSBEndian,value,pixels);
        }
      if (image->colorspace == CMYKColorspace)
        {
          value=ScaleQuantumToLong(ClampToQuantum(pixel->black));
          pixels=PopLongPixel(MSBEndian,value,pixels);
        }
      if (image->alpha_trait != UndefinedPixelTrait)
        {
          value=ScaleQuantumToLong(ClampToQuantum(pixel->alpha));
          pixels=PopLongPixel(MSBEndian,value,pixels);
        }
      break;
    }
    case 16:
    {
      unsigned short
        value;

      value=ScaleQuantumToShort(ClampToQuantum(pixel->red));
      pixels=PopShortPixel(MSBEndian,value,pixels);
      if (IsGrayColorspace(image->colorspace) == MagickFalse)
        {
          value=ScaleQuantumToShort(ClampToQuantum(pixel->green));
          pixels=PopShortPixel(MSBEndian,value,pixels);
          value=ScaleQuantumToShort(ClampToQuantum(pixel->blue));
          pixels=PopShortPixel(MSBEndian,value,pixels);
        }
      if (image->colorspace == CMYKColorspace)
        {
          value=ScaleQuantumToShort(ClampToQuantum(pixel->black));
          pixels=PopShortPixel(MSBEndian,value,pixels);
        }
      if (image->alpha_trait != UndefinedPixelTrait)
        {
          value=ScaleQuantumToShort(ClampToQuantum(pixel->alpha));
          pixels=PopShortPixel(MSBEndian,value,pixels);
        }
      break;
    }
    case 8:
    {
      unsigned char
        value;

      value=ScaleQuantumToChar(ClampToQuantum(pixel->red));
      pixels=PopCharPixel(value,pixels);
      if (IsGrayColorspace(image->colorspace) == MagickFalse)
        {
          value=ScaleQuantumToChar(ClampToQuantum(pixel->green));
          pixels=PopCharPixel(value,pixels);
          value=ScaleQuantumToChar(ClampToQuantum(pixel->blue));
          pixels=PopCharPixel(value,pixels);
        }
      if (image->colorspace == CMYKColorspace)
        {
          value=ScaleQuantumToChar(ClampToQuantum(pixel->black));
          pixels=PopCharPixel(value,pixels);
        }
      if (image->alpha_trait != UndefinedPixelTrait)
        {
          value=ScaleQuantumToChar(ClampToQuantum(pixel->alpha));
          pixels=PopCharPixel(value,pixels);
        }
      break;
    }
  }
  *pixels++=(unsigned char) length;
  return(pixels);
}

static MagickBooleanType WriteMIFFImage(const ImageInfo *image_info,
  Image *image,ExceptionInfo *exception)
{
#define BZipMaxExtent(x)  ((x)+((x)/100)+600)
#define LZMAMaxExtent(x)  ((x)+((x)/3)+128)
#define ZipMaxExtent(x)  ((x)+(((x)+7) >> 3)+(((x)+63) >> 6)+11)

#if defined(MAGICKCORE_BZLIB_DELEGATE)
  bz_stream
    bzip_info;
#endif

  char
    *options;

  double
    version;

  size_t
    compress_extent,
    extent,
    length,
    packet_size;

  ssize_t
    count;

  unsigned char
    *compress_pixels,
    *pixels;

#if defined(MAGICKCORE_ZLIB_DELEGATE)
  z_stream
    zip_info;
#endif

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",
      image_info->filename);
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
  if (OpenBlob(image_info,image,WriteBinaryBlobMode,exception) == MagickFalse)
    return(MagickFalse);
  /*
    Initialize image attributes.
  */
  version=0.0;
  (void) version;
  options=AcquireString((char *) NULL);
  (void) strcpy(options,"{");
  if (image->alpha_trait != UndefinedPixelTrait)
    (void) strcat(options,"alpha-trait=");
  if (image->colorspace == CMYKColorspace)
    (void) strcat(options,"colorspace=CMYK ");
  if (image->depth != 8)
    (void) strcat(options,"depth=");
  if (image->delay != 0)
    (void) strcat(options,"delay=");
  if (image->dispose != UndefinedDispose)
    (void) strcat(options,"dispose=");
  if (image->endian != UndefinedEndian)
    (void) strcat(options,"endian=");
  if (image->gamma != 0.0)
    (void) strcat(options,"gamma=");
  if (image->gravity != UndefinedGravity)
    (void) strcat(options,"gravity=");
  if (image->intensity != UndefinedIntensity)
    (void) strcat(options,"intensity=");
  if (image->matte_color.red != 0.0)
    (void) strcat(options,"mattecolor=");
  if (image->montage != (char *) NULL)
    (void) strcat(options,"montage=");
  if (image->orientation != UndefinedOrientation)
    (void) strcat(options,"orientation=");
  if (image->page.width != 0)
    (void) strcat(options,"page=");
  if (image->quality != 0)
    (void) strcat(options,"quality=");
  if (image->rendering_intent != UndefinedIntent)
    (void) strcat(options,"rendering-intent=");
  if (image->resolution.x != 0)
    (void) strcat(options,"resolution=");
  if (image->scene != 0)
    (void) strcat(options,"scene=");
  if (image->ticks_per_second != 0)
    (void) strcat(options,"ticks-per-second=");
  if (image->type != UndefinedImage)
    (void) strcat(options,"type=");
  if (image->units != UndefinedResolution)
    (void) strcat(options,"units=");
  if (image->version != 0.0)
    (void) strcat(options,"version=");
  if (image->white_point.x != 0.0)
    (void) strcat(options,"white-point=");
  (void) strcat(options,"}");
  /*
    Write image header;  header terminates one character beyond a ':'.
  */
  (void) WriteBlobString(image,"id=ImageMagick");
  (void) WriteBlobString(image,":");
  (void) WriteBlobString(image,options);
  options=DestroyString(options);
  /*
    Write image pixels.
  */
  pixels=GetImagePixels(image,0,0,image->columns,image->rows,exception);
  if (pixels == (unsigned char *) NULL)
    return(MagickFalse);
  if (image->storage_class == DirectClass)
    {
      size_t
        x;

      for (y=0; y < (ssize_t) image->rows; y++)
      {
        for (x=0; x < (ssize_t) image->columns; x++)
        {
          PixelInfo
            pixel;

          GetPixelInfo(image,&pixel);
          pixels=PopRunlengthPacket(image,pixels,&length,&pixel);
        }
        if (SyncImagePixels(image,exception) == MagickFalse)
          break;
      }
    }
  else
    {
      size_t
        x;

      for (y=0; y < (ssize_t) image->rows; y++)
      {
        for (x=0; x < (ssize_t) image->columns; x++)
        {
          PixelInfo
            pixel;

          GetPixelInfo(image,&pixel);
          pixels=PopRunlengthPacket(image,pixels,&length,&pixel);
        }
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
      }
    }
  if (pixels == (unsigned char *) NULL)
    return(MagickFalse);
  compress_pixels=(unsigned char *) NULL;
  switch (image->compression)
  {
#if defined(MAGICKCORE_BZLIB_DELEGATE)
    case BZipCompression:
    {
      int
        code;

      bzip_info.bzalloc=AcquireBZIPMemory;
      bzip_info.bzfree=RelinquishBZIPMemory;
      bzip_info.opaque=(void *) image;
      code=BZ2_bzCompressInit(&bzip_info,(int) image_info->quality,0,30);
      if (code != BZ_OK)
        ThrowMIFFException(ResourceLimitError,"MemoryAllocationFailed");
      bzip_info.next_out=(char *) compress_pixels;
      bzip_info.avail_out=(unsigned int) BZipMaxExtent(packet_size*
        image->columns);
      do
      {
        int
          code;

        if (bzip_info.avail_in == 0)
          {
            bzip_info.next_in=(char *) pixels;
            bzip_info.avail_in=(unsigned int) ReadBlob(image,packet_size*
              image->columns,pixels);
          }
        code=BZ2_bzCompress(&bzip_info,BZ_RUN);
        if ((code != BZ_OK) && (code != BZ_STREAM_END))
          ThrowMIFFException(ResourceLimitError,"MemoryAllocationFailed");
        if (code == BZ_STREAM_END)
          break;
      } while (bzip_info.avail_out != 0);
      code=BZ2_bzCompressEnd(&bzip_info);
      if (code != BZ_OK)
        ThrowMIFFException(ResourceLimitError,"MemoryAllocationFailed");
      break;
    }
#endif
#if defined(MAGICKCORE_LZMA_DELEGATE)
    case LZMACompression:
    {
      lzma_stream
        lzma_info = LZMA_STREAM_INIT;

      lzma_allocator
        allocator;

      int
        code;

      allocator.alloc=AcquireLZMAMemory;
      allocator.free=RelinquishLZMAMemory;
      allocator.opaque=(void *) image;
      lzma_info.allocator=&allocator;
      lzma_info.next_in=pixels;
      lzma_info.avail_in=(size_t) ReadBlob(image,packet_size*image->columns,
        pixels);
      code=lzma_code(&lzma_info,LZMA_RUN);
      if ((code != LZMA_OK) && (code != LZMA_STREAM_END))
        ThrowMIFFException(ResourceLimitError,"MemoryAllocationFailed");
      if (code == LZMA_STREAM_END)
        break;
      break;
    }
#endif
#if defined(MAGICKCORE_ZLIB_DELEGATE)
    case ZipCompression:
    {
      zip_info.zalloc=AcquireZIPMemory;
      zip_info.zfree=RelinquishZIPMemory;
      zip_info.opaque=(voidpf) image;
      zip_info.next_in=pixels;
      zip_info.avail_in=(uInt) ReadBlob(image,packet_size*image->columns,
        pixels);
      do
      {
        int
          code;

        zip_info.next_out=compress_pixels;
        zip_info.avail_out=(uInt) ZipMaxExtent(packet_size*image->columns);