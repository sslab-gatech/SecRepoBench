));
        bzip_info.bzalloc=AcquireBZIPMemory;
        bzip_info.bzfree=RelinquishBZIPMemory;
        bzip_info.opaque=(void *) image;
        code=BZ2_bzCompressInit(&bzip_info,(int) image_info->quality,
          MagickFalse,30);
        if (code != BZ_OK)
          status=MagickFalse;
        break;
      }
#endif
#if defined(MAGICKCORE_LZMA_DELEGATE)
      case LZMACompression:
      {
        int
          code;

        allocator.alloc=AcquireLZMAMemory;
        allocator.free=RelinquishLZMAMemory;
        allocator.opaque=(void *) image;
        lzma_info=initialize_lzma;
        lzma_info.allocator=(&allocator);
        code=lzma_auto_encoder(&lzma_info,(uint64_t) -1,LZMA_PRESET_DEFAULT);
        if (code != LZMA_OK)
          status=MagickFalse;
        break;
      }
#endif
#if defined(MAGICKCORE_ZLIB_DELEGATE)
      case ZipCompression:
      case LZWCompression:
      {
        int
          code;

        (void) memset(&zip_info,0,sizeof(zip_info));
        zip_info.zalloc=AcquireZIPMemory;
        zip_info.zfree=RelinquishZIPMemory;
        zip_info.opaque=(voidpf) image;
        code=deflateInit(&zip_info,Z_DEFAULT_COMPRESSION);
        if (code != Z_OK)
          status=MagickFalse;
        break;
      }
#endif
      case RLECompression:
        break;
      default:
        break;
    }
    pixels=GetImagePixels(image,0,0,image->columns,image->rows,exception);
    if (pixels == (unsigned char *) NULL)
      {
        status=MagickFalse;
        break;
      }
    for (y=0; y < (ssize_t) image->rows; y++)
    {
      if (status == MagickFalse)
        break;
      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
      if (q == (Quantum *) NULL)
        break;
      switch (compression)
      {
#if defined(MAGICKCORE_BZLIB_DELEGATE)
        case BZipCompression:
        {
          bzip_info.next_in=(char *) pixels;
          bzip_info.avail_in=(unsigned int) (packet_size*image->columns);
          do
          {
            int
              code;

            bzip_info.next_out=(char *) compress_pixels;
            bzip_info.avail_out=(unsigned int) (packet_size*image->columns);
            code=BZ2_bzCompress(&bzip_info,BZ_RUN);
            if ((code != BZ_RUN_OK) && (code != BZ_FLUSH_OK) &&
                (code != BZ_FINISH_OK))
              {
                status=MagickFalse;
                break;
              }
            if (code == BZ_STREAM_END)
              break;
            count=WriteBlob(image,packet_size*image->columns-
              bzip_info.avail_out,compress_pixels);
            if (count != (ssize_t) (packet_size*image->columns-
              bzip_info.avail_out))
              {
                status=MagickFalse;
                break;
              }
          } while (bzip_info.avail_in != 0);
          break;
        }
#endif
#if defined(MAGICKCORE_LZMA_DELEGATE)
        case LZMACompression:
        {
          lzma_info.next_in=pixels;
          lzma_info.avail_in=(size_t) (packet_size*image->columns);
          do
          {
            int
              code;

            lzma_info.next_out=compress_pixels;
            lzma_info.avail_out=(size_t) (packet_size*image->columns);
            code=lzma_code(&lzma_info,LZMA_RUN);
            if ((code != LZMA_OK) && (code != LZMA_STREAM_END))
              {
                status=MagickFalse;
                break;
              }
            if (code == LZMA_STREAM_END)
              break;
            count=WriteBlob(image,packet_size*image->columns-
              lzma_info.avail_out,compress_pixels);
            if (count != (ssize_t) (packet_size*image->columns-
              lzma_info.avail_out))
              {
                status=MagickFalse;
                break;
              }
          } while (lzma_info.avail_in != 0);
          break;
        }
#endif
#if defined(MAGICKCORE_ZLIB_DELEGATE)
        case ZipCompression:
        case LZWCompression:
        {
          zip_info.next_in=pixels;
          zip_info.avail_in=(uInt) (packet_size*image->columns);
          do
          {
            int
              code;

            zip_info.next_out=compress_pixels;
            zip_info.avail_out=(uInt) (packet_size*image->columns);
            code=deflate(&zip_info,Z_SYNC_FLUSH);
            if ((code != Z_OK) && (code != Z_STREAM_END))
              {
                status=MagickFalse;
                break;
              }
            if (code == Z_STREAM_END)
              break;
            count=WriteBlob(image,packet_size*image->columns-
              zip_info.avail_out,compress_pixels);
            if (count != (ssize_t) (packet_size*image->columns-
              zip_info.avail_out))
              {
                status=MagickFalse;
                break;
              }
          } while (zip_info.avail_in != 0);
          break;
        }
#endif
        case RLECompression:
        {
          for (i=0; i < (ssize_t) image->columns; i++)
          {
            if (image->storage_class == PseudoClass)
              {
                Quantum
                *magick_restrict p;

                p=q;
                SetPixelIndex(image,ClampToQuantum(pixel.index),p);
                q+=GetPixelChannels(image);
              }
            else
              {
                SetPixelRed(image,ClampToQuantum(pixel.red),q);
                SetPixelGreen(image,ClampToQuantum(pixel.green),q);
                SetPixelBlue(image,ClampToQuantum(pixel.blue),q);
                if (image->colorspace == CMYKColorspace)
                  SetPixelBlack(image,ClampToQuantum(pixel.black),q);
              }
            if (image->alpha_trait != UndefinedPixelTrait)
              SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);
            q+=GetPixelChannels(image);
          }
          break;
        }
        default:
        {
          const void
            *stream;

          stream=pixels;
          count=WriteBlob(image,packet_size*image->columns,stream);
          if (count != (ssize_t) (packet_size*image->columns))
            {
              status=MagickFalse;
              break;
            }
          break;
        }
      }
      if (SyncAuthenticPixels(image,exception) == MagickFalse)
        {
          status=MagickFalse;
          break;
        }
      pixels+=packet_size*image->columns;
    }
    switch (compression)
    {
#if defined(MAGICKCORE_BZLIB_DELEGATE)
      case BZipCompression:
      {
        int
          code;

        do
        {
          bzip_info.next_in=(char *) pixels;
          bzip_info.avail_in=(unsigned int) (packet_size*image->columns);
          code=BZ2_bzCompress(&bzip_info,BZ_FINISH);
          if ((code != BZ_RUN_OK) && (code != BZ_FLUSH_OK) &&
              (code != BZ_FINISH_OK))
            {
              status=MagickFalse;
              break;
            }
          count=WriteBlob(image,packet_size*image->columns-
            bzip_info.avail_out,compress_pixels);
          if (count != (ssize_t) (packet_size*image->columns-
            bzip_info.avail_out))
            {
              status=MagickFalse;
              break;
            }
        } while (bzip_info.avail_in != 0);
        code=BZ2_bzCompressEnd(&bzip_info);
        if (code != BZ_OK)
          status=MagickFalse;
        break;
      }
#endif
#if defined(MAGICKCORE_LZMA_DELEGATE)
      case LZMACompression:
      {
        int
          code;

        do
        {
          lzma_info.next_in=pixels;
          lzma_info.avail_in=(size_t) (packet_size*image->columns);
          code=lzma_code(&lzma_info,LZMA_RUN);
          if ((code != LZMA_OK) && (code != LZMA_STREAM_END))
            {
              status=MagickFalse;
              break;
            }
          count=WriteBlob(image,packet_size*image->columns-
            lzma_info.avail_out,compress_pixels);
          if (count != (ssize_t) (packet_size*image->columns-
            lzma_info.avail_out))
            {
              status=MagickFalse;
              break;
            }
        } while (lzma_info.avail_in != 0);
        code=lzma_code(&lzma_info,LZMA_FINISH);
        if ((code != LZMA_STREAM_END) && (code != LZMA_OK))
          status=MagickFalse;
        lzma_end(&lzma_info);
        break;
      }
#endif
#if defined(MAGICKCORE_ZLIB_DELEGATE)
      case ZipCompression:
      case LZWCompression:
      {
        int
          code;

        do
        {
          zip_info.next_in=pixels;
          zip_info.avail_in=(uInt) (packet_size*image->columns);
          code=deflate(&zip_info,Z_SYNC_FLUSH);
          if ((code != Z_OK) && (code != Z_STREAM_END))
            {
              status=MagickFalse;
              break;
            }
          count=WriteBlob(image,packet_size*image->columns-
            zip_info.avail_out,compress_pixels);
          if (count != (ssize_t) (packet_size*image->columns-
            zip_info.avail_out))
            {
              status=MagickFalse;
              break;
            }
        } while (zip_info.avail_in != 0);
        do
        {
          zip_info.next_in=pixels;
          zip_info.avail_in=(uInt) (packet_size*image->columns);
          code=deflate(&zip_info,Z_FINISH);
          if ((code != Z_OK) && (code != Z_STREAM_END))
            {
              status=MagickFalse;
              break;
            }
          count=WriteBlob(image,packet_size*image->columns-
            zip_info.avail_out,compress_pixels);
          if (count != (ssize_t) (packet_size*image->columns-
            zip_info.avail_out))
            {
              status=MagickFalse;
              break;
            }
        } while (zip_info.avail_in != 0);
        code=deflateEnd(&zip_info);
        if (code != Z_OK)
          status=MagickFalse;
        break;
      }
#endif
      case RLECompression:
        break;
      default:
        break;
    }
    pixels=GetImagePixels(image,0,0,image->columns,image->rows,exception);
    if (pixels == (unsigned char *) NULL)
      {
        status=MagickFalse;
        break;
      }
    quantum_type=GetQuantumImageType(image);
    for (y=0; y < (ssize