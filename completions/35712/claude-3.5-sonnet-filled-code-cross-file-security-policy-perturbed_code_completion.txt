CASE(OP_EXT1, Z) {
  FETCH_Z();
  switch (insn) {
    CASE(OP_ANDN, BB) {
      regs[a] = mrb_integer_value(mrb_integer(regs[a]) & ~mrb_integer(regs[a+1]));
      NEXT;
    }
    CASE(OP_ORN, BB) {
      regs[a] = mrb_integer_value(mrb_integer(regs[a]) | ~mrb_integer(regs[a+1]));
      NEXT;
    }
    CASE(OP_XNOR, BB) {
      regs[a] = mrb_integer_value(~(mrb_integer(regs[a]) ^ mrb_integer(regs[a+1])));
      NEXT;
    }
    default:
      mrb_raisef(mrb, E_RUNTIME_ERROR, "Unknown OP_EXT1 instruction: %S", mrb_fixnum_value(insn));
  }
  pc--;
  NEXT;
}

CASE(OP_EXT2, Z) {
  FETCH_Z();
  switch (insn) {
    CASE(OP_BYTE, BB) {
      regs[a] = mrb_fixnum_value(mrb_integer(regs[a]) & 0xFF);
      NEXT;
    }
    CASE(OP_WORD, BB) {
      regs[a] = mrb_fixnum_value(mrb_integer(regs[a]) & 0xFFFF);
      NEXT;
    }
    default:
      mrb_raisef(mrb, E_RUNTIME_ERROR, "Unknown OP_EXT2 instruction: %S", mrb_fixnum_value(insn));
  }
  pc--;
  NEXT;
}

CASE(OP_EXT3, Z) {
  FETCH_Z();
  switch (insn) {
    CASE(OP_LAMDA, BB) {
      struct RProc *p;
      const mrb_irep *nirep = irep->reps[b];
      
      p = mrb_closure_new(mrb, nirep);
      p->flags |= MRB_PROC_LAMBDA;
      regs[a] = mrb_obj_value(p);
      mrb_gc_arena_restore(mrb, ai);
      NEXT;
    }
    default:
      mrb_raisef(mrb, E_RUNTIME_ERROR, "Unknown OP_EXT3 instruction: %S", mrb_fixnum_value(insn));
  }
  pc--;
  NEXT;
}