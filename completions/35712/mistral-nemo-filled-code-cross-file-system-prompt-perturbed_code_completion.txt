case is necessary
    // to ensure that the program counter points to the next instruction after
    // the extended opcode.

    CASE(OP_EXT1, B) {
      uint8_t op = pc[1];
      pc -= 2;
      switch (op) {
        // Define cases for extended opcodes within OP_EXT1.
        // Each case should handle the corresponding operation and update
        // the program counter (pc) accordingly.
        default:
          // Handle unknown or unsupported extended opcode.
          // You can add error handling or logging here.
          break;
      }
      NEXT;
    }

    CASE(OP_EXT2, B) {
      uint8_t op = pc[1];
      pc -= 2;
      switch (op) {
        // Define cases for extended opcodes within OP_EXT2.
        // Each case should handle the corresponding operation and update
        // the program counter (pc) accordingly.
        default:
          // Handle unknown or unsupported extended opcode.
          // You can add error handling or logging here.
          break;
      }
      NEXT;
    }

    CASE(OP_EXT3, B) {
      uint8_t op = pc[1];
      pc -= 2;
      switch (op) {
        // Define cases for extended opcodes within OP_EXT3.
        // Each case should handle the corresponding operation and update
        // the program counter (pc) accordingly.
        default:
          // Handle unknown or unsupported extended opcode.
          // You can add error handling or logging here.
          break;
      }
      NEXT;
    }

    default:
      // Handle unknown or unsupported opcode.
      // You can add error handling or logging here.
      break;
  }
}

int main() {
  // Initialize the MRI interpreter and context.
  mrb_state *mrb = mrb_open();
  mrb_context *c = mrb->root_c;

  // Set up the initial call stack and environment.
  mrb->c->ci = mrb->c->cibase;
  mrb->c->ci->proc = NULL;
  mrb->c->ci->mid = 0;
  mrb->c->ci->argc = 0;
  mrb->c->ci->acc = CI_ACC_DIRECT;
  mrb->c->ci->u.target_class = NULL;

  // Execute the MRI bytecode interpreter loop.
  while (mrb->c->ci->proc) {
    mrb_vm_exec(mrb, mrb->c->ci->proc, mrb->c->ci->pc);
  }

  // Clean up and close the MRI interpreter.
  mrb_close(mrb);

  return 0;
}