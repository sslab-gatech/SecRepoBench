regs[a+2] = mrb_nil_value();
          argc = -1;
        }
        mrb_stack_extend(mrb, 3);
        ci->stack[0] = recv;
        ci->stack[1] = mrb_ary_new_from_values(mrb, argc, regs+a+1);
        ci->stack[2] = mrb_nil_value();
        ci->argc = -1;
        ci->mid = mid;
        ci->u.target_class = cls;
        goto L_RAISE;
      }
      if (MRB_METHOD_PROC_P(m)) {
        struct RProc *p = MRB_METHOD_PROC(m);
        mrb_int nregs = p->body.irep->nregs;

        if (nregs < argc + 2) {
          mrb_stack_extend(mrb, argc + 2);
        }
        else {
          mrb_stack_extend(mrb, nregs);
          stack_clear(ci->stack+argc+2, nregs-argc-2);
        }
        ci->argc = argc;
        ci->mid = mid;
        ci->u.target_class = cls;
        ci->stack[0] = recv;
        if (argc >= 0) {
          stack_copy(ci->stack+1, regs+a+1, argc);
        }
        ci->stack[argc+1] = blk;
        ci = cipush(mrb, argc+2, CI_ACC_SKIP, cls, p, mid, argc);
        if (MRB_METHOD_CFUNC_P(m)) {
          ci->acc = CI_ACC_DIRECT;
          regs[a] = MRB_METHOD_CFUNC(m)(mrb, recv);
          cipop(mrb);
        }
        else {
          regs[a] = mrb_run(mrb, p, recv);
        }
        NEXT;
      }
      else {
        ci->argc = argc;
        ci->mid = mid;
        ci->u.target_class = cls;
        ci = cipush(mrb, argc+2, CI_ACC_SKIP, cls, NULL, mid, argc);
        regs[a] = mrb_exec_irep(mrb, recv, MRB_METHOD_PROC(m));
        NEXT;
      }
    }

    CASE(OP_SENDB_SYM, BB) {
      c = CALL_MAXARGS;
      goto L_SEND_SYM;
    }

    CASE(OP_SEND_SYM, BB) {
      c = CALL_MAXARGS;
      goto L_SEND_SYM;
    }

    CASE(OP_SUPER, BBB) {
      mrb_value recv, args, blk;
      mrb_int argc;
      struct RClass *cls;
      mrb_method_t m;
      mrb_callinfo *ci = mrb->c->ci;

      recv = regs[a];
      args = regs[b];
      blk = regs[c];
      if (!mrb_nil_p(blk) && !mrb_proc_p(blk)) {
        blk = mrb_type_convert(mrb, blk, MRB_TT_PROC, MRB_SYM(to_proc));
        regs[c] = blk;
      }
      cls = mrb_class(mrb, recv);
      m = mrb_method_search_vm(mrb, &cls, syms[b]);
      if (MRB_METHOD_UNDEF_P(m)) {
        mrb_sym missing = MRB_SYM(method_missing);
        mrb_value args;

        if (mrb_func_basic_p(mrb, recv, missing, mrb_obj_missing)) {
        method_missing:
          args = get_send_args(mrb, argc, regs+a+1);
          mrb_method_missing(mrb, mid, recv, args);
        }
        if (mid != missing) {
          cls = mrb_class(mrb, recv);
        }
        m = mrb_method_search_vm(mrb, &cls, missing);
        if (MRB_METHOD_UNDEF_P(m)) goto method_missing; /* just in case */
        if (argc >= 0) {
          if (a+2 >= irep->nregs) {
            mrb_stack_extend(mrb, a+3);
          }
          regs[a+1] = mrb_ary_new_from_values(mrb, c, regs+a+1);
          regs[a+2] = mrb_nil_value();
          argc = -1;
        }
        mrb_stack_extend(mrb, 3);
        ci->stack[0] = recv;
        ci->stack[1] = mrb_ary_new_from_values(mrb, argc, regs+a+1);
        ci->stack[2] = mrb_nil_value();
        ci->argc = -1;
        ci->mid = mid;
        ci->u.target_class = cls;
        goto L_RAISE;
      }
      if (MRB_METHOD_PROC_P(m)) {
        struct RProc *p = MRB_METHOD_PROC(m);
        mrb_int nregs = p->body.irep->nregs;

        if (nregs < argc + 2) {
          mrb_stack_extend(mrb, argc + 2);
        }
        else {
          mrb_stack_extend(mrb, nregs);
          stack_clear(ci->stack+argc+2, nregs-argc-2);
        }
        ci->argc = argc;
        ci->mid = mid;
        ci->u.target_class = cls;
        ci->stack[0] = recv;
        if (argc >= 0) {
          stack_copy(ci->stack+1, regs+a+1, argc);
        }
        ci->stack[argc+1] = blk;
        ci = cipush(mrb, argc+2, CI_ACC_SKIP, cls, p, mid, argc);
        if (MRB_METHOD_CFUNC_P(m)) {
          ci->acc = CI_ACC_DIRECT;
          regs[a] = MRB_METHOD_CFUNC(m)(mrb, recv);
          cipop(mrb);
        }
        else {
          regs[a] = mrb_run(mrb, p, recv);
        }
        NEXT;
      }
      else {
        ci->argc = argc;
        ci->mid = mid;
        ci->u.target_class = cls;
        ci = cipush(mrb, argc+2, CI_ACC_SKIP, cls, NULL, mid, argc);
        regs[a] = mrb_exec_irep(mrb, recv, MRB_METHOD_PROC(m));
        NEXT;
      }
    }

    CASE(OP_SUPER_SYM, BB) {
      c = CALL_MAXARGS;
      goto L_SEND_SYM;
    }

    CASE(OP_SEND_SYM, BB) {
      c = CALL_MAXARGS;
      goto L_SEND_SYM;
    }

    CASE(OP_CALL, BBB) {
      mrb_value recv, args, blk;
      mrb_int argc;
      struct RClass *cls;
      mrb_method_t m;
      mrb_callinfo *ci = mrb->c->ci;

      recv = regs[a];
      args = regs[b];
      blk = regs[c];
      if (!mrb_nil_p(blk) && !mrb_proc_p(blk)) {
        blk = mrb_type_convert(mrb, blk, MRB_TT_PROC, MRB_SYM(to_proc));
        regs[c] = blk;
      }
      cls = mrb_class(mrb, recv);
      m = mrb_method_search_vm(mrb, &cls, syms[b]);
      if (MRB_METHOD_UNDEF_P(m)) {
        mrb_sym missing = MRB_SYM(method_missing);
        mrb_value args;

        if (mrb_func_basic_p(mrb, recv, missing, mrb_obj_missing)) {
        method_missing:
          args = get_send_args(mrb, argc, regs+a+1);
          mrb_method_missing(mrb, mid, recv, args);
        }
        if (mid != missing) {
          cls = mrb_class(mrb, recv);
        }
        m = mrb_method_search_vm(mrb, &cls, missing);
        if (MRB_METHOD_UNDEF_P(m)) goto method_missing; /* just in case */
        if (argc >= 0) {
          if (a+2 >= irep->nregs) {
            mrb_stack_extend(mrb, a+3);
          }
          regs[a+1] = mrb_ary_new_from_values(mrb, c, regs+a+1);
          regs[a+2] = mrb_nil_value();
          argc = -1;
        }
        mrb_stack_extend(mrb, 3);
        ci->stack[0] = recv;
        ci->stack[1] = mrb_ary_new_from_values(mrb, argc, regs+a+1);
        ci->stack[2] = mrb_nil_value();
        ci->argc = -1;
        ci->mid = mid;
        ci->u.target_class = cls;
        goto L_RAISE;
      }
      if (MRB_METHOD_PROC_P(m)) {
        struct RProc *p = MRB_METHOD_PROC(m);
        mrb_int nregs = p->body.irep->nregs;

        if (nregs < argc + 2) {
          mrb_stack_extend(mrb, argc + 2);
        }
        else {
          mrb_stack_extend(mrb, nregs);
          stack_clear(ci->stack+argc+2, nregs-argc-2);
        }
        ci->argc = argc;
        ci->mid = mid;
        ci->u.target_class = cls;
        ci->stack[0] = recv;
        if (argc >= 0) {
          stack_copy(ci->stack+1, regs+a+1, argc);
        }
        ci->stack[argc+1] = blk;
        ci = cipush(mrb, argc+2, CI_ACC_SKIP, cls, p, mid, argc);
        if (MRB_METHOD_CFUNC_P(m)) {
          ci->acc = CI_ACC_DIRECT;
          regs[a] = MRB_METHOD_CFUNC(m)(mrb, recv);
          cipop(mrb);
        }
        else {
          regs[a] = mrb_run(mrb, p, recv);
        }
        NEXT;
      }
      else {
        ci->argc = argc;
        ci->mid = mid;
        ci->u.target_class = cls;
        ci = cipush(mrb, argc+2, CI_ACC_SKIP, cls, NULL, mid, argc);
        regs[a] = mrb_exec_irep(mrb, recv, MRB_METHOD_PROC(m));
        NEXT;
      }
    }

    CASE(OP_CALL_KW, BBB) {
      mrb_value recv, args, blk;
      mrb_int argc;
      struct RClass *cls;
      mrb_method_t m;
      mrb_callinfo *ci = mrb->c->ci;

      recv = regs[a];
      args = regs[b];
      blk = regs[c];
      if (!mrb_nil_p(blk) && !mrb_proc_p(blk)) {
        blk = mrb_type_convert(mrb, blk, MRB_TT_PROC, MRB_SYM(to_proc));
        regs[c] = blk;
      }
      cls = mrb_class(mrb, recv);
      m = mrb_method_search_vm(mrb, &cls, syms[b]);
      if (MRB_METHOD_UNDEF_P(m)) {
        mrb_sym missing = MRB_SYM(