to dispatch
    // to the appropriate handler based on the instruction.
    CASE(OP_EXT1, B) {
      uint8_t inst = pool[a+1].u.i8;
      switch (inst) {
        // Handle each extended opcode instruction here.
        // For example:
        // case 0x01:
        //   // Handle OP_EXT1 instruction 0x01
        //   break;
        // case 0x02:
        //   // Handle OP_EXT1 instruction 0x02
        //   break;
        // ...
        default:
          // Handle unknown or unsupported extended opcode instruction.
          // For example, raise an error or take some other appropriate action.
          break;
      }
      NEXT;
    }
    CASE(OP_EXT2, B) {
      uint8_t inst = pool[a+1].u.i8;
      switch (inst) {
        // Handle each extended opcode instruction here.
        // For example:
        // case 0x01:
        //   // Handle OP_EXT2 instruction 0x01
        //   break;
        // case 0x02:
        //   // Handle OP_EXT2 instruction 0x02
        //   break;
        // ...
        default:
          // Handle unknown or unsupported extended opcode instruction.
          // For example, raise an error or take some other appropriate action.
          break;
      }
      NEXT;
    }
    CASE(OP_EXT3, B) {
      uint8_t inst = pool[a+1].u.i8;
      switch (inst) {
        // Handle each extended opcode instruction here.
        // For example:
        // case 0x01:
        //   // Handle OP_EXT3 instruction 0x01
        //   break;
        // case 0x02:
        //   // Handle OP_EXT3 instruction 0x02
        //   break;
        // ...
        default:
          // Handle unknown or unsupported extended opcode instruction.
          // For example, raise an error or take some other appropriate action.
          break;
      }
      NEXT;
    }

    default:
      mrb_assert(!"unknown opcode");
      NEXT;
  }
  mrb_gc_arena_restore(mrb, ai);
  mrb_gc_arena_shrink(mrb, ai);
  return regs[a];
}