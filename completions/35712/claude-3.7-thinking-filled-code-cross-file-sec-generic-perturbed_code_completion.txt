CASE(OP_EXT1, Z) {
  FETCH_Z();
  instruction = READ_B();
  switch (instruction) {
    CASE(OP_LAMBDA, BB)
    c = OP_L_LAMBDA | OP_L_CAPTURE;
    goto L_MAKE_LAMBDA;

    CASE(OP_BLOCK, BB) {
      c = OP_L_BLOCK | OP_L_CAPTURE;
      goto L_MAKE_LAMBDA;
    }

    CASE(OP_METHOD, BB) {
      c = OP_L_METHOD | OP_L_CAPTURE;
      goto L_MAKE_LAMBDA;
    }

    CASE(OP_SUPER, BB) {
      mrb_int argc = (b == CALL_MAXARGS) ? -1 : b;
      int bidx = (argc < 0) ? a+2 : a+b+1;
      mrb_method_t m;
      struct RClass *cls;
      mrb_callinfo *ci = mrb->c->ci;
      mrb_value recv, blk;
      const struct RProc *p = ci->proc;
      mrb_sym mid = ci->mid;
      struct RClass* target_class = MRB_PROC_TARGET_CLASS(p);

      if (MRB_PROC_ENV_P(p) && p->e.env->mid && p->e.env->mid != mid) { /* alias support */
        mid = p->e.env->mid;    /* restore old mid */
      }
      mrb_assert(bidx < irep->nregs);

      if (mid == 0 || !target_class) {
        mrb_value exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, "super called outside of method");
        mrb_exc_set(mrb, exc);
        goto L_RAISE;
      }
      if (target_class->flags & MRB_FL_CLASS_IS_PREPENDED) {
        target_class = mrb_vm_ci_target_class(ci);
      }
      else if (target_class->tt == MRB_TT_MODULE) {
        target_class = mrb_vm_ci_target_class(ci);
        if (target_class->tt != MRB_TT_ICLASS) {
          goto super_typeerror;
        }
      }
      recv = regs[0];
      if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {
        goto super_typeerror;
      }
      blk = regs[bidx];
      if (!mrb_nil_p(blk) && !mrb_proc_p(blk)) {
        blk = mrb_type_convert(mrb, blk, MRB_TT_PROC, MRB_SYM(to_proc));
        regs[bidx] = blk;
        ci = mrb->c->ci;
      }
      cls = target_class->super;
      m = mrb_method_search_vm(mrb, &cls, mid);
      if (MRB_METHOD_UNDEF_P(m)) {
        mrb_sym missing = MRB_SYM(method_missing);
        mrb_value args;

        if (mrb_func_basic_p(mrb, recv, missing, mrb_obj_missing)) {
          goto super_missing;
        }
        if (mid != missing) {
          cls = mrb_class(mrb, recv);
        }
        m = mrb_method_search_vm(mrb, &cls, missing);
        if (MRB_METHOD_UNDEF_P(m)) goto super_missing;
        if (argc >= 0) {
          if (a+2 >= irep->nregs) {
            mrb_stack_extend(mrb, a+3);
          }
          regs[a+1] = mrb_ary_new_from_values(mrb, b, regs+a+1);
          regs[a+2] = blk;
          argc = -1;
        }
        mrb_ary_unshift(mrb, regs[a+1], mrb_symbol_value(mid));
        mid = missing;
      }

      /* push callinfo */
      ci = cipush(mrb, a, 0, cls, NULL, mid, argc);

      /* prepare stack */
      mrb->c->ci->stack[0] = recv;

      if (MRB_METHOD_CFUNC_P(m)) {
        mrb_value v;

        if (MRB_METHOD_PROC_P(m)) {
          mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));
        }
        v = MRB_METHOD_CFUNC(m)(mrb, recv);
        mrb_gc_arena_restore(mrb, ai);
        if (mrb->exc) goto L_RAISE;
        ci = mrb->c->ci;
        mrb_assert(!mrb_break_p(v));
        if (!mrb_vm_ci_target_class(ci)) {
          if (ci->acc == CI_ACC_RESUMED) {
            mrb->jmp = prev_jmp;
            return v;
          }
          else {
            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));
            proc = ci[-1].proc;
            irep = proc->body.irep;
            pool = irep->pool;
            syms = irep->syms;
          }
        }
        mrb->c->ci->stack[0] = v;
        ci = cipop(mrb);
        pc = ci->pc;
        JUMP;
      }
      else {
        /* fill callinfo */
        ci->acc = a;

        /* setup environment for calling method */
        mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));
        irep = proc->body.irep;
        pool = irep->pool;
        syms = irep->syms;
        mrb_stack_extend(mrb, (argc < 0 && irep->nregs < 3) ? 3 : irep->nregs);
        pc = irep->iseq;
        JUMP;
      }
    }

    default:
      mrb_assert(!"unknown opcode in OP_EXT1");
  }
  pc--;
  NEXT;
}

CASE(OP_EXT2, Z) {
  FETCH_Z();
  instruction = READ_B();
  switch (instruction) {
    CASE(OP_LAMBDA, BB)
    c = OP_L_LAMBDA | OP_L_STRICT;
    goto L_MAKE_LAMBDA;

    CASE(OP_BLOCK, BB) {
      c = OP_L_BLOCK | OP_L_STRICT;
      goto L_MAKE_LAMBDA;
    }

    CASE(OP_METHOD, BB) {
      c = OP_L_METHOD | OP_L_STRICT;
      goto L_MAKE_LAMBDA;
    }

    default:
      mrb_assert(!"unknown opcode in OP_EXT2");
  }
  pc--;
  NEXT;
}

CASE(OP_EXT3, Z) {
  FETCH_Z();
  instruction = READ_B();
  switch (instruction) {
    CASE(OP_LAMBDA, BB)
    c = OP_L_LAMBDA | OP_L_CAPTURE | OP_L_STRICT;
    goto L_MAKE_LAMBDA;

    CASE(OP_BLOCK, BB) {
      c = OP_L_BLOCK | OP_L_CAPTURE | OP_L_STRICT;
      goto L_MAKE_LAMBDA;
    }

    CASE(OP_METHOD, BB) {
      c = OP_L_METHOD | OP_L_CAPTURE | OP_L_STRICT;
      goto L_MAKE_LAMBDA;
    }

    default:
      mrb_assert(!"unknown opcode in OP_EXT3");
  }
  pc--;
  NEXT;
}