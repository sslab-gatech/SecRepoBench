args = mrb_ary_new_from_values(mrb, argc, regs+a+1);
          mrb_ary_unshift(mrb, args, mrb_symbol_value(mid));
        }
        else {
          args = mrb_ary_subseq(mrb, regs[a+1], 1, RARRAY_LEN(regs[a+1]) - 1);
        }
        mrb_ary_unshift(mrb, args, mrb_symbol_value(mid));
        mrb_stack_extend(mrb, argc+2);
        regs[a+1] = args;
        argc = -1;
      }
      if (mrb->c->ci - mrb->c->cibase > MRB_FUNCALL_DEPTH_MAX) {
        mrb_exc_raise(mrb, mrb_obj_value(mrb->stack_err));
      }
      ci = cipush(mrb, argc+2, CI_ACC_SKIP, cls, NULL, mid, argc);
      if (argc < 0) {
        ci->argc = -1;
        argc = 1;
      }
      mrb_stack_extend(mrb, argc + 2);
      regs[a] = recv;
      regs[a+argc+1] = blk;
      if (MRB_METHOD_CFUNC_P(m)) {
        ci->acc = CI_ACC_DIRECT;
        regs[a+argc+2] = MRB_METHOD_CFUNC(m)(mrb, recv);
        cipop(mrb);
      }
      else {
        ci->acc = CI_ACC_SKIP;
        regs[a+argc+2] = mrb_run(mrb, MRB_METHOD_PROC(m), recv);
      }
      NEXT;
    }

    CASE(OP_SEND_KW, BB) {
      c = CALL_MAXARGS;
      goto L_SEND_KW;
    }
    CASE(OP_SEND_KWB, BB) {
      c = CALL_MAXARGS;
      goto L_SEND_KWB;
    }
    CASE(OP_SEND_KWV, BB) {
      c = CALL_MAXARGS;
      goto L_SEND_KWV;
    }
    CASE(OP_SEND_KWVB, BB) {
      c = CALL_MAXARGS;
      goto L_SEND_KWVB;
    }
    CASE(OP_SEND_KW, BBB)
    L_SEND_KW:
    {
      int bidx = (c == CALL_MAXARGS) ? a+2 : a+c+1;
      SET_NIL_VALUE(regs[bidx]);
      goto L_SEND_KWB;
    }
    L_SEND_KW_SYM:
    {
      int bidx = (c == CALL_MAXARGS) ? a+2 : a+c+1;
      SET_NIL_VALUE(regs[bidx]);
      goto L_SEND_KWB_SYM;
    }
    CASE(OP_SEND_KWB, BBB)
    L_SEND_KWB:
    mid = syms[b];
    L_SEND_KWB_SYM:
    {
      mrb_int argc = (c == CALL_MAXARGS) ? -1 : c;
      mrb_int bidx = (argc < 0) ? a+2 : a+c+1;
      mrb_method_t m;
      struct RClass *cls;
      mrb_callinfo *ci = mrb->c->ci;
      mrb_value recv, blk;

      mrb_assert(bidx < irep->nregs);

      recv = regs[a];
      blk = regs[bidx];
      if (!mrb_nil_p(blk) && !mrb_proc_p(blk)) {
        blk = mrb_type_convert(mrb, blk, MRB_TT_PROC, MRB_SYM(to_proc));
        /* The stack might have been reallocated during mrb_type_convert(),
           see #3622 */
        regs[bidx] = blk;
      }
      cls = mrb_class(mrb, recv);
      m = mrb_method_search_vm(mrb, &cls, mid);
      if (MRB_METHOD_UNDEF_P(m)) {
        mrb_sym missing = MRB_SYM(method_missing);
        mrb_value args;

        if (mrb_func_basic_p(mrb, recv, missing, mrb_obj_missing)) {
        method_missing:
          args = get_send_args(mrb, argc, regs+a+1);
          mrb_method_missing(mrb, mid, recv, args);
        }
        if (mid != missing) {
          cls = mrb_class(mrb, recv);
        }
        m = mrb_method_search_vm(mrb, &cls, missing);
        if (MRB_METHOD_UNDEF_P(m)) goto method_missing; /* just in case */
        if (argc >= 0) {
          args = mrb_ary_new_from_values(mrb, argc, regs+a+1);
          mrb_ary_unshift(mrb, args, mrb_symbol_value(mid));
        }
        else {
          args = mrb_ary_subseq(mrb, regs[a+1], 1, RARRAY_LEN(regs[a+1]) - 1);
        }
        mrb_ary_unshift(mrb, args, mrb_symbol_value(mid));
        mrb_stack_extend(mrb, argc+2);
        regs[a+1] = args;
        argc = -1;
      }
      if (mrb->c->ci - mrb->c->cibase > MRB_FUNCALL_DEPTH_MAX) {
        mrb_exc_raise(mrb, mrb_obj_value(mrb->stack_err));
      }
      ci = cipush(mrb, argc+2, CI_ACC_SKIP, cls, NULL, mid, argc);
      if (argc < 0) {
        ci->argc = -1;
        argc = 1;
      }
      mrb_stack_extend(mrb, argc + 2);
      regs[a] = recv;
      regs[a+argc+1] = blk;
      if (MRB_METHOD_CFUNC_P(m)) {
        ci->acc = CI_ACC_DIRECT;
        regs[a+argc+2] = MRB_METHOD_CFUNC(m)(mrb, recv);
        cipop(mrb);
      }
      else {
        ci->acc = CI_ACC_SKIP;
        regs[a+argc+2] = mrb_run(mrb, MRB_METHOD_PROC(m), recv);
      }
      NEXT;
    }

    CASE(OP_YIELD, B) {
      mrb_value blk = regs[a];
      mrb_value ret;

      if (mrb_nil_p(blk)) {
        localjump_error(mrb, LOCALJUMP_ERROR_YIELD);
      }
      if (!mrb_proc_p(blk)) {
        mrb_raise(mrb, E_TYPE_ERROR, "not a proc");
      }
      ret = mrb_yield_with_class(mrb, blk, 0, NULL, regs[0], MRB_PROC_TARGET_CLASS(blk));
      regs[a] = ret;
      NEXT;
    }

    CASE(OP_YIELDW, BB) {
      mrb_value blk = regs[a];
      mrb_value ret;
      mrb_int argc = b;

      if (mrb_nil_p(blk)) {
        localjump_error(mrb, LOCALJUMP_ERROR_YIELD);
      }
      if (!mrb_proc_p(blk)) {
        mrb_raise(mrb, E_TYPE_ERROR, "not a proc");
      }
      ret = mrb_yield_with_class(mrb, blk, argc, regs+a+1, regs[0], MRB_PROC_TARGET_CLASS(blk));
      regs[a] = ret;
      NEXT;
    }

    CASE(OP_RETURN, B) {
      mrb_value ret = regs[a];

      if (mrb->exc) {
        mrb_value exc = mrb_obj_value(mrb->exc);
        mrb->exc = NULL;
        regs[a] = exc;
      }
      if (mrb->c->ci->acc == CI_ACC_DIRECT) {
        mrb_value blk = regs[a+1];
        if (!mrb_nil_p(blk) && !mrb_proc_p(blk)) {
          blk = mrb_type_convert(mrb, blk, MRB_TT_PROC, MRB_SYM(to_proc));
          regs[a+1] = blk;
        }
        mrb_yield_with_class(mrb, blk, 1, &ret, regs[0], MRB_PROC_TARGET_CLASS(blk));
        cipop(mrb);
      }
      else {
        cipop(mrb);
      }
      mrb_gc_arena_restore(mrb, ai);
      return ret;
    }

    CASE(OP_BREAK, S) {
      uint32_t tag = (uint32_t)a;
      struct RBreak *brk;

      if (!check_target_class(mrb)) {
        goto L_RAISE;
      }
      brk = (struct RBreak*)mrb->exc;
      if (brk && brk->tt == MRB_TT_BREAK && brk->tag == tag) {
        mrb->exc = NULL;
        cipop(mrb);
        mrb_gc_arena_restore(mrb, ai);
        return mrb_nil_value();
      }
      if (mrb->exc) {
        mrb_value exc = mrb_obj_value(mrb->exc);
        mrb->exc = NULL;
        regs[a] = exc;
      }
      THROW_TAGGED_BREAK(mrb, tag, proc, regs[0]);
    L_CATCH_TAGGED_BREAK:
      mrb_gc_arena_restore(mrb, ai);
      return mrb_nil_value();
    }

    CASE(OP_RETRY, B) {
      if (!check_target_class(mrb)) {
        goto L_RAISE;
      }
      if (mrb->exc) {
        mrb_value exc = mrb_obj_value(mrb->exc);
        mrb->exc = NULL;
        regs[a] = exc;
      }
      THROW_TAGGED_BREAK(mrb, RBREAK_TAG_RETRY, proc, regs[0]);
    L_CATCH_TAGGED_RETRY:
      mrb_gc_arena_restore(mrb, ai);
      return mrb_nil_value();
    }

    CASE(OP_THROW, B) {
      mrb_value exc = regs[a];

      if (mrb->exc) {
        mrb_value exc2 = mrb_obj_value(mrb->exc);
        mrb->exc = NULL;
        regs[a] = exc2;
      }
      mrb->exc = exc;
      goto L_RAISE;
    }

    CASE(OP_THROWIF, B) {
      mrb_value exc = regs[a];

      if (mrb_test(exc)) {
        if (mrb->exc) {
          mrb_value exc2 = mrb_obj_value(mrb->exc);
          mrb->exc = NULL;
          regs[a] = exc2;
        }
        mrb->exc = exc;
        goto L_RAISE;
      }
      NEXT;
    }

    CASE(OP_RAISE, B) {
      mrb_value exc = regs[a];

      if (mrb->exc) {
        mrb_value exc2 = mrb_obj_value(mrb->exc);
        mrb->exc = NULL;
        regs[a] = exc2;
      }
      mrb->exc = exc;
    L_RAISE:
      mrb_gc_