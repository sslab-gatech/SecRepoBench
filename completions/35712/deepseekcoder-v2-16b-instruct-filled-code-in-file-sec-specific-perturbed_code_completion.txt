(mrb, argc + 2);
          }
          regs[a+1] = mrb_symbol_value(mid);
          regs[a+2] = args;
          argc = -1;
        }
        else {
          regs[a+1] = mrb_ary_new_from_values(mrb, argc, regs+a+1);
          mrb_ary_unshift(mrb, regs[a+1], mrb_symbol_value(mid));
          argc = 1;
        }
        mrb_stack_extend(mrb, argc + 2);
        regs[a+argc+1] = blk;
        ci->stack[0] = recv;
        ci->stack[1] = mrb_symbol_value(mid);
        ci->stack[2] = args;
        ci->stack[argc+2] = blk;
        ci->argc = argc;
        ci->acc = CI_ACC_SKIP;
        goto L_SEND_METHOD;
      }
      if (MRB_METHOD_PROC_P(m)) {
        struct RProc *p = MRB_METHOD_PROC(m);

        if (MRB_PROC_CFUNC_P(p)) {
          ci->acc = CI_ACC_DIRECT;
          regs[a] = MRB_METHOD_CFUNC(m)(mrb, recv);
          goto L_SEND_METHOD;
        }
        else {
          ci->acc = CI_ACC_SKIP;
          regs[a] = mrb_run(mrb, p, recv);
          goto L_SEND_METHOD;
        }
      }
      else {
        ci->acc = CI_ACC_SKIP;
        regs[a] = exec_irep(mrb, recv, p);
      }
    L_SEND_METHOD:
      NEXT;
    }

    CASE(OP_SENDB_SYM, BB) {
      mid = syms[b];
      goto L_SEND_SYM;
    }

    CASE(OP_CALL, BBB) {
      mrb_int argc = (c == CALL_MAXARGS) ? -1 : c;
      mrb_int bidx = (argc < 0) ? a+2 : a+c+1;
      mrb_method_t m;
      struct RClass *cls;
      mrb_callinfo *ci = mrb->c->ci;
      mrb_value recv, blk;

      mrb_assert(bidx < irep->nregs);

      recv = regs[a];
      blk = regs[bidx];
      if (!mrb_nil_p(blk) && !mrb_proc_p(blk)) {
        blk = mrb_type_convert(mrb, blk, MRB_TT_PROC, MRB_SYM(to_proc));
        /* The stack might have been reallocated during mrb_type_convert(),
           see #3622 */
        regs[bidx] = blk;
      }
      cls = mrb_class(mrb, recv);
      m = mrb_method_search_vm(mrb, &cls, mid);
      if (MRB_METHOD_UNDEF_P(m)) {
        mrb_sym missing = MRB_SYM(method_missing);
        mrb_value args;

        if (mrb_func_basic_p(mrb, recv, missing, mrb_obj_missing)) {
        method_missing:
          args = get_send_args(mrb, argc, regs+a+1);
          mrb_method_missing(mrb, mid, recv, args);
        }
        if (mid != missing) {
          cls = mrb_class(mrb, recv);
        }
        m = mrb_method_search_vm(mrb, &cls, missing);
        if (MRB_METHOD_UNDEF_P(m)) goto method_missing; /* just in case */
        if (argc >= 0) {
          if (a+2 >= irep->nregs) {
            mrb_stack_extend(mrb, argc + 2);
          }
          regs[a+1] = mrb_symbol_value(mid);
          regs[a+2] = args;
          argc = -1;
        }
        else {
          regs[a+1] = mrb_ary_new_from_values(mrb, argc, regs+a+1);
          mrb_ary_unshift(mrb, regs[a+1], mrb_symbol_value(mid));
          argc = 1;
        }
        mrb_stack_extend(mrb, argc + 2);
        regs[a+argc+1] = blk;
        ci->stack[0] = recv;
        ci->stack[1] = mrb_symbol_value(mid);
        ci->stack[2] = args;
        ci->stack[argc+2] = blk;
        ci->argc = argc;
        ci->acc = CI_ACC_SKIP;
        goto L_CALL_METHOD;
      }
      if (MRB_METHOD_PROC_P(m)) {
        struct RProc *p = MRB_METHOD_PROC(m);

        if (MRB_PROC_CFUNC_P(p)) {
          ci->acc = CI_ACC_DIRECT;
          regs[a] = MRB_METHOD_CFUNC(m)(mrb, recv);
          goto L_CALL_METHOD;
        }
        else {
          ci->acc = CI_ACC_SKIP;
          regs[a] = mrb_run(mrb, p, recv);
          goto L_CALL_METHOD;
        }
      }
      else {
        ci->acc = CI_ACC_SKIP;
        regs[a] = exec_irep(mrb, recv, p);
      }
    L_CALL_METHOD:
      NEXT;
    }

    CASE(OP_CALL_KW, BBB) {
      mrb_int argc = (c == CALL_MAXARGS) ? -1 : c;
      mrb_int bidx = (argc < 0) ? a+2 : a+c+1;
      mrb_method_t m;
      struct RClass *cls;
      mrb_callinfo *ci = mrb->c->ci;
      mrb_value recv, blk;

      mrb_assert(bidx < irep->nregs);

      recv = regs[a];
      blk = regs[bidx];
      if (!mrb_nil_p(blk) && !mrb_proc_p(blk)) {
        blk = mrb_type_convert(mrb, blk, MRB_TT_PROC, MRB_SYM(to_proc));
        /* The stack might have been reallocated during mrb_type_convert(),
           see #3622 */
        regs[bidx] = blk;
      }
      cls = mrb_class(mrb, recv);
      m = mrb_method_search_vm(mrb, &cls, mid);
      if (MRB_METHOD_UNDEF_P(m)) {
        mrb_sym missing = MRB_SYM(method_missing);
        mrb_value args;

        if (mrb_func_basic_p(mrb, recv, missing, mrb_obj_missing)) {
        method_missing:
          args = get_send_args(mrb, argc, regs+a+1);
          mrb_method_missing(mrb, mid, recv, args);
        }
        if (mid != missing) {
          cls = mrb_class(mrb, recv);
        }
        m = mrb_method_search_vm(mrb, &cls, missing);
        if (MRB_METHOD_UNDEF_P(m)) goto method_missing; /* just in case */
        if (argc >= 0) {
          if (a+2 >= irep->nregs) {
            mrb_stack_extend(mrb, argc + 2);
          }
          regs[a+1] = mrb_symbol_value(mid);
          regs[a+2] = args;
          argc = -1;
        }
        else {
          regs[a+1] = mrb_ary_new_from_values(mrb, argc, regs+a+1);
          mrb_ary_unshift(mrb, regs[a+1], mrb_symbol_value(mid));
          argc = 1;
        }
        mrb_stack_extend(mrb, argc + 2);
        regs[a+argc+1] = blk;
        ci->stack[0] = recv;
        ci->stack[1] = mrb_symbol_value(mid);
        ci->stack[2] = args;
        ci->stack[argc+2] = blk;
        ci->argc = argc;
        ci->acc = CI_ACC_SKIP;
        goto L_CALL_KW_METHOD;
      }
      if (MRB_METHOD_PROC_P(m)) {
        struct RProc *p = MRB_METHOD_PROC(m);

        if (MRB_PROC_CFUNC_P(p)) {
          ci->acc = CI_ACC_DIRECT;
          regs[a] = MRB_METHOD_CFUNC(m)(mrb, recv);
          goto L_CALL_KW_METHOD;
        }
        else {
          ci->acc = CI_ACC_SKIP;
          regs[a] = mrb_run(mrb, p, recv);
          goto L_CALL_KW_METHOD;
        }
      }
      else {
        ci->acc = CI_ACC_SKIP;
        regs[a] = exec_irep(mrb, recv, p);
      }
    L_CALL_KW_METHOD:
      NEXT;
    }

    CASE(OP_CALL_KW_SYM, BB) {
      mid = syms[b];
      goto L_SEND_SYM;
    }

    CASE(OP_CALL_ARG, BBB) {
      mrb_int argc = (c == CALL_MAXARGS) ? -1 : c;
      mrb_int bidx = (argc < 0) ? a+2 : a+c+1;
      mrb_method_t m;
      struct RClass *cls;
      mrb_callinfo *ci = mrb->c->ci;
      mrb_value recv, blk;

      mrb_assert(bidx < irep->nregs);

      recv = regs[a];
      blk = regs[bidx];
      if (!mrb_nil_p(blk) && !mrb_proc_p(blk)) {
        blk = mrb_type_convert(mrb, blk, MRB_TT_PROC, MRB_SYM(to_proc));
        /* The stack might have been reallocated during mrb_type_convert(),
           see #3622 */
        regs[bidx] = blk;
      }
      cls = mrb_class(mrb, recv);
      m = mrb_method_search_vm(mrb, &cls, mid);
      if (MRB_METHOD_UNDEF_P(m)) {
        mrb_sym missing = MRB_SYM(method_missing);
        mrb_value args;

        if (mrb_func_basic_p(mrb, recv, missing, mrb_obj_missing)) {
        method_missing:
          args = get_send_args(mrb, argc, regs+a+1);
          mrb_method_missing(mrb, mid, recv, args);
        }
        if (mid != missing) {
          cls = mrb_class(mrb, recv);
        }
        m = mrb_method_search_vm(mrb, &cls, missing);
        if (MRB_METHOD_UNDEF_P(m)) goto method_missing; /* just in case */
        if (argc >= 0) {
          if (a+2 >= irep->nregs) {
            mrb_stack_extend(mrb, argc + 2);
          }
          regs[a+1] = mrb_symbol_value(mid);
          regs[a+2] = args;
          argc = -1;
        }
        else {
          regs[a+1] = mrb_ary_new_from_values(mrb, argc, regs+a+1);
          mrb_ary_unshift(mrb, regs[a+1], mrb_symbol_value(mid));
          argc = 1;
        }
        mrb_stack_extend