CASE(OP_EXT1, B) {
  FETCH_B();
  switch (b) {
    CASE(OP_EXT1_0, Z) {
      /* do nothing */
      NEXT;
    }
    CASE(OP_EXT1_1, BB) {
      regs[a] = regs[b];
      NEXT;
    }
    CASE(OP_EXT1_2, BB) {
      switch (pool[b].tt) {   /* number */
      case IREP_TT_INT32:
        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i32);
        break;
      case IREP_TT_INT64:
#if defined(MRB_INT64)
        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);
        break;
#else
#if defined(MRB_64BIT)
        if (INT32_MIN <= pool[b].u.i64 && pool[b].u.i64 <= INT32_MAX) {
          regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);
          break;
        }
#endif
        goto L_INT_OVERFLOW;
#endif
      case IREP_TT_BIGINT:
        goto L_INT_OVERFLOW;
#ifndef MRB_NO_FLOAT
      case IREP_TT_FLOAT:
        regs[a] = mrb_float_value(mrb, pool[b].u.f);
        break;
#endif
      default:
        /* should not happen (tt:string) */
        regs[a] = mrb_nil_value();
        break;
      }
      NEXT;
    }
    CASE(OP_EXT1_3, BB) {
      SET_FIXNUM_VALUE(regs[a], b);
      NEXT;
    }
    CASE(OP_EXT1_4, BB) {
      SET_FIXNUM_VALUE(regs[a], -b);
      NEXT;
    }
    CASE(OP_EXT1_5, B) {
      SET_FIXNUM_VALUE(regs[a], (mrb_int)instruction - (mrb_int)OP_EXT1_0);
      NEXT;
    }
    CASE(OP_EXT1_6, BS) {
      SET_FIXNUM_VALUE(regs[a], (mrb_int)(int16_t)b);
      NEXT;
    }
    CASE(OP_EXT1_7, BSS) {
      SET_INT_VALUE(mrb, regs[a], (int32_t)(((uint32_t)b<<16)+c));
      NEXT;
    }
    CASE(OP_EXT1_8, BB) {
      SET_SYM_VALUE(regs[a], syms[b]);
      NEXT;
    }
    CASE(OP_EXT1_9, B) {
      SET_NIL_VALUE(regs[a]);
      NEXT;
    }
    CASE(OP_EXT1_10, B) {
      regs[a] = regs[0];
      NEXT;
    }
    CASE(OP_EXT1_11, B) {
      SET_TRUE_VALUE(regs[a]);
      NEXT;
    }
    CASE(OP_EXT1_12, B) {
      SET_FALSE_VALUE(regs[a]);
      NEXT;
    }
    CASE(OP_EXT1_13, BB) {
      mrb_value val = mrb_gv_get(mrb, syms[b]);
      regs[a] = val;
      NEXT;
    }
    CASE(OP_EXT1_14, BB) {
      mrb_gv_set(mrb, syms[b], regs[a]);
      NEXT;
    }
    CASE(OP_EXT1_15, BB) {
      mrb_value val = mrb_vm_special_get(mrb, syms[b]);
      regs[a] = val;
      NEXT;
    }
    CASE(OP_EXT1_16, BB) {
      mrb_vm_special_set(mrb, syms[b], regs[a]);
      NEXT;
    }
    CASE(OP_EXT1_17, BB) {
      regs[a] = mrb_iv_get(mrb, regs[0], syms[b]);
      NEXT;
    }
    CASE(OP_EXT1_18, BB) {
      mrb_iv_set(mrb, regs[0], syms[b], regs[a]);
      NEXT;
    }
    CASE(OP_EXT1_19, BB) {
      mrb_value val;
      val = mrb_vm_cv_get(mrb, syms[b]);
      regs[a] = val;
      NEXT;
    }
    CASE(OP_EXT1_20, BB) {
      mrb_vm_cv_set(mrb, syms[b], regs[a]);
      NEXT;
    }
    CASE(OP_EXT1_21, BB) {
      mrb_value val;
      mrb_sym sym = syms[b];

      val = mrb_vm_const_get(mrb, sym);
      regs[a] = val;
      NEXT;
    }
    CASE(OP_EXT1_22, BB) {
      mrb_vm_const_set(mrb, syms[b], regs[a]);
      NEXT;
    }
    CASE(OP_EXT1_23, BB) {
      mrb_value val;

      val = mrb_const_get(mrb, regs[a], syms[b]);
      regs[a] = val;
      NEXT;
    }
    CASE(OP_EXT1_24, BB) {
      mrb_const_set(mrb, regs[a+1], syms[b], regs[a]);
      NEXT;
    }
    CASE(OP_EXT1_25, BBB) {
      mrb_value *regs_a = regs + a;
      struct REnv *e = uvenv(mrb, c);

      if (e && b < MRB_ENV_LEN(e)) {
        *regs_a = e->stack[b];
      }
      else {
        *regs_a = mrb_nil_value();
      }
      NEXT;
    }
    CASE(OP_EXT1_26, BBB) {
      struct REnv *e = uvenv(mrb, c);

      if (e) {
        mrb_value *regs_a = regs + a;

        if (b < MRB_ENV_LEN(e)) {
          e->stack[b] = *regs_a;
          mrb_write_barrier(mrb, (struct RBasic*)e);
        }
      }
      NEXT;
    }
    CASE(OP_EXT1_27, S) {
      pc += (int16_t)a;
      JUMP;
    }
    CASE(OP_EXT1_28, BS) {
      if (mrb_test(regs[a])) {
        pc += (int16_t)b;
        JUMP;
      }
      NEXT;
    }
    CASE(OP_EXT1_29, BS) {
      if (!mrb_test(regs[a])) {
        pc += (int16_t)b;
        JUMP;
      }
      NEXT;
    }
    CASE(OP_EXT1_30, BS) {
      if (mrb_nil_p(regs[a])) {
        pc += (int16_t)b;
        JUMP;
      }
      NEXT;
    }
    CASE(OP_EXT1_31, B) {
      c = OP_R_NORMAL;
      goto L_RETURN;
    }
    default:
      mrb_assert(!"unknown extended opcode");
  }
  pc--;
  NEXT;
}

CASE(OP_EXT2, B) {
  FETCH_B();
  switch (b) {
    CASE(OP_EXT2_0, Z) {
      /* do nothing */
      NEXT;
    }
    CASE(OP_EXT2_1, BB) {
      regs[a] = regs[b];
      NEXT;
    }
    CASE(OP_EXT2_2, BB) {
      switch (pool[b].tt) {   /* number */
      case IREP_TT_INT32:
        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i32);
        break;
      case IREP_TT_INT64:
#if defined(MRB_INT64)
        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);
        break;
#else
#if defined(MRB_64BIT)
        if (INT32_MIN <= pool[b].u.i64 && pool[b].u.i64 <= INT32_MAX) {
          regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);
          break;
        }
#endif
        goto L_INT_OVERFLOW;
#endif
      case IREP_TT_BIGINT:
        goto L_INT_OVERFLOW;
#ifndef MRB_NO_FLOAT
      case IREP_TT_FLOAT:
        regs[a] = mrb_float_value(mrb, pool[b].u.f);
        break;
#endif
      default:
        /* should not happen (tt:string) */
        regs[a] = mrb_nil_value();
        break;
      }
      NEXT;
    }
    CASE(OP_EXT2_3, BB) {
      SET_FIXNUM_VALUE(regs[a], b);
      NEXT;
    }
    CASE(OP_EXT2_4, BB) {
      SET_FIXNUM_VALUE(regs[a], -b);
      NEXT;
    }
    CASE(OP_EXT2_5, B) {
      SET_FIXNUM_VALUE(regs[a], (mrb_int)instruction - (mrb_int)OP_EXT2_0);
      NEXT;
    }
    CASE(OP_EXT2_6, BS) {
      SET_FIXNUM_VALUE(regs[a], (mrb_int)(int16_t)b);
      NEXT;
    }
    CASE(OP_EXT2_7, BSS) {
      SET_INT_VALUE(mrb, regs[a], (int32_t)(((uint32_t)b<<16)+c));
      NEXT;
    }
    CASE(OP_EXT2_8, BB) {
      SET_SYM_VALUE(regs[a], syms[b]);
      NEXT;
    }
    CASE(OP_EXT2_9, B) {
      SET_NIL_VALUE(regs[a]);
      NEXT;
    }
    CASE(OP_EXT2_10, B) {
      regs[a] = regs[0];
      NEXT;
    }
    CASE(OP_EXT2_11, B) {
      SET_TRUE_VALUE(regs[a]);
      NEXT;
    }
    CASE(OP_EXT2_12, B) {
      SET_FALSE_VALUE(regs[a]);
      NEXT;
    }
    CASE(OP_EXT2_13, BB) {
      mrb_value val = mrb_gv_get(mrb, syms[b]);
      regs[a] = val;
      NEXT;
    }
    CASE(OP_EXT2_14, BB) {
      mrb_gv_set(mrb, syms[b], regs[a]);
      NEXT;
    }
    CASE(OP_EXT2_15, BB) {
      mrb_value val = mrb_vm_special_get(mrb, syms[b]);
      regs[a] = val;
      NEXT;
    }
    CASE(OP_EXT2_16, BB) {
      mrb_vm_special_set(mrb, syms[b], regs[a]);
      NEXT;
    }
    CASE(OP_EXT2_17, BB) {
      regs[a] = mrb_iv_get(mrb, regs[0], syms[b]);
      NEXT;
    }
    CASE(OP_EXT2_18, BB) {
      mrb_iv_set(mrb, regs[0], syms[b], regs[a]);
      NEXT;
    }
    CASE(OP_EXT2_19, BB) {
      mrb_value val;
      val = mrb_vm_cv_get(mrb, syms[b]);
      regs[a] = val;
      NEXT;
    }
    CASE(OP_EXT2_20, BB) {
      mrb_vm_cv_set(mrb, syms[b], regs[a]);
      NEXT;
    }
    CASE(OP_EXT2_21, BB) {
      mrb_value val;
      mrb_sym sym = syms[b];

      val = mrb_vm_const_get(mrb, sym);
      regs[a] = val;
      NEXT;
    }
    CASE(OP_EXT2_22, BB) {
      mrb_vm_const_set(mrb, syms[b], regs[a]);
      NEXT;
    }
    CASE(OP_EXT2_23, BB) {
      mrb_value val;

      val = mrb_const_get(mrb, regs[a], syms[b]);
      regs[a] = val;
      NEXT;
    }
    CASE(OP_EXT2_24, BB) {
      mrb_const_set(mrb, regs[a+1], syms[b], regs[a]);
      NEXT;
    }
    CASE(OP_EXT2_25, BBB) {
      mrb_value *regs_a = regs + a;
      struct REnv *e = uvenv(mrb, c);

      if (e && b < MRB_ENV_LEN(e)) {
        *regs_a = e->stack[b];
      }
      else {
        *regs_a = mrb_nil_value();
      }
      NEXT;
    }
    CASE(OP_EXT2_26, BBB) {
      struct REnv *e = uvenv(mrb, c);

      if (e) {
        mrb_value *regs_a = regs + a;

        if (b < MRB_ENV_LEN(e)) {
          e->stack[b] = *regs_a;
          mrb_write_barrier(mrb, (struct RBasic*)e);
        }
      }
      NEXT;
    }
    CASE(OP_EXT2_27, S) {
      pc += (int16_t)a;
      JUMP;
    }
    CASE(OP_EXT2_28, BS) {
      if (mrb_test(regs[a])) {
        pc += (int16_t)b;
        JUMP;
      }
      NEXT;
    }
    CASE(OP_EXT2_29, BS) {
      if (!mrb_test(regs[a])) {
        pc += (int16_t)b;
        JUMP;
      }
      NEXT;
    }
    CASE(OP_EXT2_30, BS) {
      if (mrb_nil_p(regs[a])) {
        pc += (int16_t)b;
        JUMP;
      }
      NEXT;
    }
    CASE(OP_EXT2_31, B) {
      c = OP_R_NORMAL;
      goto L_RETURN;
    }
    default:
      mrb_assert(!"unknown extended opcode");
  }
  pc--;
  NEXT;
}

CASE(OP_EXT3, B) {
  FETCH_B();
  switch (b) {
    CASE(OP_EXT3_0, Z) {
      /* do nothing */
      NEXT;
    }
    CASE(OP_EXT3_1, BB) {
      regs[a] = regs[b];
      NEXT;
    }
    CASE(OP_EXT3_2, BB) {
      switch (pool[b].tt) {   /* number */
      case IREP_TT_INT32:
        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i32);
        break;
      case IREP_TT_INT64:
#if defined(MRB_INT64)
        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);
        break;
#else
#if defined(MRB_64BIT)
        if (INT32_MIN <= pool[b].u.i64 && pool[b].u.i64 <= INT32_MAX) {
          regs[a]