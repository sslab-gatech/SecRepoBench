(mrb_hash_p(kdict)) {
        mrb_hash_set(mrb, kdict, k, regs[a]);
      }
      else {
        mrb_value exc = mrb_exc_new_lit(mrb, E_ARGUMENT_ERROR, "no keyword arguments");
        mrb_exc_set(mrb, exc);
        goto L_RAISE;
      }
      NEXT;
    }

    CASE(OP_KDICT, BB) {
      mrb_value kdict = regs[mrb->c->ci->argc];

      if (mrb_hash_p(kdict)) {
        mrb_hash_dup_check(mrb, kdict);
      }
      else {
        mrb_value exc = mrb_exc_new_lit(mrb, E_ARGUMENT_ERROR, "no keyword arguments");
        mrb_exc_set(mrb, exc);
        goto L_RAISE;
      }
      NEXT;
    }

    CASE(OP_RETURN, B) {
      mrb_value v = regs[a];
      mrb_callinfo *ci = mrb->c->ci;
      mrb_value *regs_a = regs + a;
      struct RProc *p = ci->proc;
      struct REnv *e = mrb_vm_ci_env(ci);

      if (ci->acc == CI_ACC_RESUMED) {
        mrb->jmp = prev_jmp;
        return v;
      }
      if (ci->acc == CI_ACC_DIRECT) {
        mrb->c->ci->stack[0] = v;
        ci = cipop(mrb);
        pc = ci->pc;
        JUMP;
      }
      if (ci->acc == CI_ACC_SKIP) {
        if (MRB_PROC_CFUNC_P(p)) {
          mrb->c->ci->stack[0] = v;
          ci = cipop(mrb);
          pc = ci->pc;
          JUMP;
        }
        else {
          mrb_value ret;
          if (MRB_PROC_ENV_P(p)) {
            ret = mrb_top_run(mrb, p, v, 1);
          }
          else {
            ret = mrb_run(mrb, p, v);
          }
          if (mrb->exc && mrb->jmp) {
            mrb_exc_raise(mrb, mrb_obj_value(mrb->exc));
          }
          return ret;
        }
      }
      if (MRB_PROC_ENV_P(p)) {
        if (MRB_ENV_LEN(e) > 0) {
          *regs_a = e->stack[0];
        }
        else {
          *regs_a = mrb_nil_value();
        }
      }
      else {
        *regs_a = v;
      }
      if (MRB_PROC_ENV_P(p)) {
        mrb_env_unshare(mrb, e);
      }
      mrb->c->ci->stack[0] = *regs_a;
      ci = cipop(mrb);
      pc = ci->pc;
      JUMP;
    }

    CASE(OP_RETURN_BLK, B) {
      mrb_value v = regs[a];
      mrb_callinfo *ci = mrb->c->ci;
      struct RProc *p = ci->proc;
      struct REnv *e = mrb_vm_ci_env(ci);

      if (MRB_PROC_ENV_P(p)) {
        if (MRB_ENV_LEN(e) > 0) {
          regs[a] = e->stack[0];
        }
        else {
          regs[a] = mrb_nil_value();
        }
      }
      else {
        regs[a] = v;
      }
      if (MRB_PROC_ENV_P(p)) {
        mrb_env_unshare(mrb, e);
      }
      mrb->c->ci->stack[0] = regs[a];
      ci = cipop(mrb);
      pc = ci->pc;
      JUMP;
    }

    CASE(OP_RETURN_SPLAT, B) {
      mrb_value v = regs[a];
      mrb_callinfo *ci = mrb->c->ci;
      struct RProc *p = ci->proc;
      struct REnv *e = mrb_vm_ci_env(ci);

      if (MRB_PROC_ENV_P(p)) {
        if (MRB_ENV_LEN(e) > 0) {
          regs[a] = e->stack[0];
        }
        else {
          regs[a] = mrb_nil_value();
        }
      }
      else {
        regs[a] = v;
      }
      if (MRB_PROC_ENV_P(p)) {
        mrb_env_unshare(mrb, e);
      }
      mrb->c->ci->stack[0] = regs[a];
      ci = cipop(mrb);
      pc = ci->pc;
      JUMP;
    }

    CASE(OP_TAILCALL, B) {
      mrb_value v = regs[a];
      mrb_callinfo *ci = mrb->c->ci;
      struct RProc *p = ci->proc;
      struct REnv *e = mrb_vm_ci_env(ci);

      if (MRB_PROC_ENV_P(p)) {
        if (MRB_ENV_LEN(e) > 0) {
          regs[a] = e->stack[0];
        }
        else {
          regs[a] = mrb_nil_value();
        }
      }
      else {
        regs[a] = v;
      }
      if (MRB_PROC_ENV_P(p)) {
        mrb_env_unshare(mrb, e);
      }
      mrb->c->ci->stack[0] = regs[a];
      ci = cipop(mrb);
      pc = ci->pc;
      JUMP;
    }

    CASE(OP_BLKPUSH, BB) {
      mrb_value blk = regs[a];
      mrb_value *regs_a = regs + a;
      struct RProc *p;
      struct REnv *e;

      if (mrb_nil_p(blk)) {
        *regs_a = mrb_nil_value();
      }
      else {
        p = mrb_proc_ptr(blk);
        e = MRB_PROC_ENV(p);
        if (MRB_ENV_ONSTACK_P(e)) {
          *regs_a = e->stack[0];
        }
        else {
          *regs_a = mrb_nil_value();
        }
      }
      NEXT;
    }

    CASE(OP_BLKPUSH_SPLAT, BB) {
      mrb_value blk = regs[a];
      mrb_value *regs_a = regs + a;
      struct RProc *p;
      struct REnv *e;

      if (mrb_nil_p(blk)) {
        *regs_a = mrb_nil_value();
      }
      else {
        p = mrb_proc_ptr(blk);
        e = MRB_PROC_ENV(p);
        if (MRB_ENV_ONSTACK_P(e)) {
          *regs_a = e->stack[0];
        }
        else {
          *regs_a = mrb_nil_value();
        }
      }
      NEXT;
    }

    CASE(OP_BLKFILL, BB) {
      mrb_value blk = regs[a];
      mrb_value *regs_a = regs + a;
      struct RProc *p;
      struct REnv *e;

      if (mrb_nil_p(blk)) {
        *regs_a = mrb_nil_value();
      }
      else {
        p = mrb_proc_ptr(blk);
        e = MRB_PROC_ENV(p);
        if (MRB_ENV_ONSTACK_P(e)) {
          *regs_a = e->stack[0];
        }
        else {
          *regs_a = mrb_nil_value();
        }
      }
      NEXT;
    }

    CASE(OP_BLKFILL_SPLAT, BB) {
      mrb_value blk = regs[a];
      mrb_value *regs_a = regs + a;
      struct RProc *p;
      struct REnv *e;

      if (mrb_nil_p(blk)) {
        *regs_a = mrb_nil_value();
      }
      else {
        p = mrb_proc_ptr(blk);
        e = MRB_PROC_ENV(p);
        if (MRB_ENV_ONSTACK_P(e)) {
          *regs_a = e->stack[0];
        }
        else {
          *regs_a = mrb_nil_value();
        }
      }
      NEXT;
    }

    CASE(OP_YIELD, BB) {
      mrb_value v = regs[a];
      mrb_value *regs_a = regs + a;
      mrb_value *regs_b = regs + b;
      struct RProc *p;
      struct REnv *e;

      if (mrb_nil_p(v)) {
        *regs_a = mrb_nil_value();
      }
      else {
        p = mrb_proc_ptr(v);
        e = MRB_PROC_ENV(p);
        if (MRB_ENV_ONSTACK_P(e)) {
          *regs_a = e->stack[0];
        }
        else {
          *regs_a = mrb_nil_value();
        }
      }
      if (mrb_nil_p(*regs_b)) {
        *regs_b = mrb_nil_value();
      }
      else {
        p = mrb_proc_ptr(*regs_b);
        e = MRB_PROC_ENV(p);
        if (MRB_ENV_ONSTACK_P(e)) {
          *regs_b = e->stack[0];
        }
        else {
          *regs_b = mrb_nil_value();
        }
      }
      NEXT;
    }

    CASE(OP_YIELD_SPLAT, BB) {
      mrb_value v = regs[a];
      mrb_value *regs_a = regs + a;
      mrb_value *regs_b = regs + b;
      struct RProc *p;
      struct REnv *e;

      if (mrb_nil_p(v)) {
        *regs_a = mrb_nil_value();
      }
      else {
        p = mrb_proc_ptr(v);
        e = MRB_PROC_ENV(p);
        if (MRB_ENV_ONSTACK_P(e)) {
          *regs_a = e->stack[0];
        }
        else {
          *regs_a = mrb_nil_value();
        }
      }
      if (mrb_nil_p(*regs_b)) {
        *regs_b = mrb_nil_value();
      }
      else {
        p = mrb_proc_ptr(*regs_b);
        e = MRB_PROC_ENV(p);
        if (MRB_ENV_ONSTACK_P(e)) {
          *regs_b = e->stack[0];
        }
        else {
          *regs_b = mrb_nil_value();
        }
      }
      NEXT;
    }

    CASE(OP_YIELD_PUSH, BB) {
      mrb_value v = regs[a];
      mrb_value *regs_a = regs + a;
      mrb_value *regs_b = regs + b;
      struct RProc *p;
      struct REnv *e;

      if (mrb_nil_p(v)) {
        *regs_a = mrb_nil_value();
      }
      else {
        p = mrb_proc_ptr(v);
        e = MRB_PROC_ENV(p);
        if (MRB_ENV_ONSTACK_P(e)) {
          *regs_a = e->stack[0];
        }
        else {
          *regs_a = mrb_nil_value();
        }
      }
      if (mrb_nil_p(*regs_b)) {
        *regs_b = mrb_nil_value();
      }
      else {
        p = mrb_proc_ptr(*regs_b);
        e = MRB_PROC_ENV(p);
        if (MRB_ENV_ONSTACK_P(e)) {
          *regs_b = e->stack[0];
        }
        else {
          *regs_b = mrb_nil_value();
        }
      }
      NEXT;
    }

    CASE(OP_YIELD_PUSH_SPLAT, BB) {
      mrb_value v = regs[a];
      mrb_value *regs_a = regs + a;
      mrb_value *regs_b = regs + b;
      struct RProc *p;
      struct REnv *e;

      if (mrb_nil_p(v)) {
        *regs_a = mrb_nil_value();
      }
      else {
        p = mrb_proc_ptr(v);
        e = MRB_PROC_ENV(p);
        if (MRB_ENV_ONSTACK_P(e)) {
          *regs_a = e->stack[0];
        }
        else {
          *regs_a = mrb_nil_value();
        }
      }
      if (mrb_nil_p(*regs_b)) {
        *regs_b = mrb_nil_value();
      }
      else {
        p = mrb_proc_ptr(*regs_b);
        e = MRB_PROC_ENV(p);
        if (MRB_ENV_ONSTACK_P(e)) {
          *regs_b = e->stack[0];
        }
        else {
          *regs_b = mrb_nil_value();
        }
      }
      NEXT;
    }

    CASE(OP_YIELD_POP, BB) {
      mrb_value v = regs[a];
      mrb_value *regs_a = regs + a;
      mrb_value *regs_b = regs + b;
      struct RProc *p;
      struct REnv *e;

      if (mrb_nil_p(v)) {
        *regs_a = mrb_nil_value();
      }
      else {
        p = mrb_proc_ptr(v);
        e = MRB_PROC_ENV(p);
        if (MRB_ENV_ONSTACK_P(e)) {
          *regs_a = e->stack[0];
        }
        else {
          *regs_a = mrb_nil_value();
        }
      }
      if (mrb_nil_p(*regs_b)) {
        *regs_b = mrb_nil_value();
      }
      else {
        p = mrb_proc_ptr(*regs_b);
        e = MRB_PROC_ENV(p);
        if (MRB_ENV_ONSTACK_P(e)) {
          *regs_b = e->stack[0];
        }
        else {
          *regs_b = mrb_nil_value();
        }
      }
      NEXT;
    }

    CASE(OP_YIELD_POP_SPLAT, BB) {
      mrb_value v = regs[a];
      mrb_value *regs_a = regs + a;
      mrb_value *regs_b = regs + b;
      struct RProc *p;
      struct REnv *e;

      if (mrb_nil_p(v)) {
        *regs_a = mrb_nil_value();
      }
      else {
        p = mrb_proc_ptr(v);
        e = MRB_PROC_ENV(p);
        if (MRB_ENV_ONSTACK_P(e)) {
          *regs_a = e->stack[0];
        }
        else {
          *regs_a = mrb_nil_value();
        }
      }
      if (mrb_nil_p(*regs_b)) {
        *regs_b = mrb_nil_value();
      }
      else {
        p = mrb_proc_ptr(*regs_b);
        e = MRB_PROC_ENV(p);
        if (MRB_ENV_ONSTACK_P(e)) {
          *regs_b = e->stack[0];
        }
        else {
          *regs_b = mrb_nil_value();
        }
      }
      NEXT;
    }

    CASE(OP_STOP, Z) {
      mrb_value v = regs[0];
      mrb_callinfo *ci = mrb->c->ci;
      struct RProc *p = ci->proc;
      struct R