regs[a+1], mrb_symbol_value(mid));
        mrb_stack_extend(mrb, a+3);
        regs[a] = recv;
        regs[a+1] = args;
        regs[a+2] = blk;
        ci->stack[0] = recv;
        ci->stack[1] = args;
        ci->stack[2] = blk;
        ci->argc = -1;
        goto L_SEND_SYM;
      }
      if (mrb_cfunc_p(m)) {
        if (MRB_METHOD_PROC_P(m)) {
          mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));
        }
        ci->argc = argc;
        ci->mid = mid;
        ci->u.target_class = cls;
        ci->stack[0] = recv;
        if (argc >= 0) {
          stack_copy(ci->stack+1, regs+a+1, argc);
        }
        ci->stack[argc+1] = blk;
        if (MRB_METHOD_CFUNC_P(m)) {
          ci->acc = CI_ACC_DIRECT;
          regs[a] = MRB_METHOD_CFUNC(m)(mrb, recv);
          cipop(mrb);
        }
        else {
          ci->acc = CI_ACC_SKIP;
          regs[a] = mrb_run(mrb, MRB_METHOD_PROC(m), recv);
        }
        NEXT;
      }
      else {
        mrb_value *argv = regs+a+1;
        mrb_value args;
        int ai = mrb_gc_arena_save(mrb);

        if (argc >= 0) {
          args = mrb_ary_new_from_values(mrb, argc, argv);
        }
        else {
          args = regs[a+1];
        }
        if (mrb_nil_p(blk) || mrb_proc_p(blk)) {
          regs[a] = mrb_funcall_with_block(mrb, recv, mid, argc, argv, blk);
        }
        else {
          regs[a] = mrb_funcall_with_block(mrb, recv, mid, argc, argv, blk);
        }
        mrb_gc_arena_restore(mrb, ai);
        NEXT;
      }
    }
    L_SEND_SYM:
    {
      mrb_int argc = (c == CALL_MAXARGS) ? -1 : c;
      mrb_int bidx = (argc < 0) ? a+2 : a+c+1;
      mrb_method_t m;
      struct RClass *cls;
      mrb_callinfo *ci = mrb->c->ci;
      mrb_value recv, blk;

      mrb_assert(bidx < irep->nregs);

      recv = regs[a];
      blk = regs[bidx];
      if (!mrb_nil_p(blk) && !mrb_proc_p(blk)) {
        blk = mrb_type_convert(mrb, blk, MRB_TT_PROC, MRB_SYM(to_proc));
        /* The stack might have been reallocated during mrb_type_convert(),
           see #3622 */
        regs[bidx] = blk;
      }
      cls = mrb_class(mrb, recv);
      m = mrb_method_search_vm(mrb, &cls, mid);
      if (MRB_METHOD_UNDEF_P(m)) {
        mrb_sym missing = MRB_SYM(method_missing);
        mrb_value args;

        if (mrb_func_basic_p(mrb, recv, missing, mrb_obj_missing)) {
        method_missing:
          args = get_send_args(mrb, argc, regs+a+1);
          mrb_method_missing(mrb, mid, recv, args);
        }
        if (mid != missing) {
          cls = mrb_class(mrb, recv);
        }
        m = mrb_method_search_vm(mrb, &cls, missing);
        if (MRB_METHOD_UNDEF_P(m)) goto method_missing; /* just in case */
        if (argc >= 0) {
          if (a+2 >= irep->nregs) {
            mrb_stack_extend(mrb, a+3);
          }
          regs[a+1] = mrb_ary_new_from_values(mrb, c, regs+a+1);
          regs[a+2] = mrb_nil_value();
          argc = -1;
        }
        mrb_ary_unshift(mrb, regs[a+1], mrb_symbol_value(mid));
        mrb_stack_extend(mrb, a+3);
        regs[a] = recv;
        regs[a+1] = args;
        regs[a+2] = blk;
        ci->stack[0] = recv;
        ci->stack[1] = args;
        ci->stack[2] = blk;
        ci->argc = -1;
        goto L_SEND_SYM_END;
      }
      if (mrb_cfunc_p(m)) {
        if (MRB_METHOD_PROC_P(m)) {
          mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));
        }
        ci->argc = argc;
        ci->mid = mid;
        ci->u.target_class = cls;
        ci->stack[0] = recv;
        if (argc >= 0) {
          stack_copy(ci->stack+1, regs+a+1, argc);
        }
        ci->stack[argc+1] = blk;
        if (MRB_METHOD_CFUNC_P(m)) {
          ci->acc = CI_ACC_DIRECT;
          regs[a] = MRB_METHOD_CFUNC(m)(mrb, recv);
          cipop(mrb);
        }
        else {
          ci->acc = CI_ACC_SKIP;
          regs[a] = mrb_run(mrb, MRB_METHOD_PROC(m), recv);
        }
        NEXT;
      }
      else {
        mrb_value *argv = regs+a+1;
        mrb_value args;
        int ai = mrb_gc_arena_save(mrb);

        if (argc >= 0) {
          args = mrb_ary_new_from_values(mrb, argc, argv);
        }
        else {
          args = regs[a+1];
        }
        if (mrb_nil_p(blk) || mrb_proc_p(blk)) {
          regs[a] = mrb_funcall_with_block(mrb, recv, mid, argc, argv, blk);
        }
        else {
          regs[a] = mrb_funcall_with_block(mrb, recv, mid, argc, argv, blk);
        }
        mrb_gc_arena_restore(mrb, ai);
        NEXT;
      }
    }
    L_SEND_SYM_END:
    {
      NEXT;
    }

    CASE(OP_SUPER, BBB) {
      mrb_value recv, *argv, blk;
      mrb_int argc;
      struct RClass *cls;
      mrb_method_t m;
      mrb_callinfo *ci = mrb->c->ci;

      recv = regs[a];
      argc = (int16_t)b;
      argv = regs + a + 2;
      blk = regs[a + argc + 2];
      cls = mrb_class(mrb, recv);
      m = mrb_method_search_vm(mrb, &cls, syms[c]);
      if (MRB_METHOD_UNDEF_P(m)) {
        mrb_sym missing = MRB_SYM(method_missing);
        mrb_value args;

        if (mrb_func_basic_p(mrb, recv, missing, mrb_obj_missing)) {
        method_missing:
          args = mrb_ary_new_from_values(mrb, argc, argv);
          mrb_method_missing(mrb, syms[c], recv, args);
        }
        if (syms[c] != missing) {
          cls = mrb_class(mrb, recv);
        }
        m = mrb_method_search_vm(mrb, &cls, missing);
        if (MRB_METHOD_UNDEF_P(m)) goto method_missing; /* just in case */
        if (argc >= 0) {
          if (a+3 >= irep->nregs) {
            mrb_stack_extend(mrb, a+4);
          }
          regs[a+2] = mrb_ary_new_from_values(mrb, argc, argv);
          regs[a+3] = blk;
          argc = -1;
        }
        mrb_ary_unshift(mrb, regs[a+2], mrb_symbol_value(syms[c]));
        mrb_stack_extend(mrb, a+4);
        regs[a] = recv;
        regs[a+1] = regs[a+2];
        regs[a+2] = blk;
        ci->stack[0] = recv;
        ci->stack[1] = regs[a+2];
        ci->stack[2] = blk;
        ci->argc = -1;
        goto L_SUPER_SYM;
      }
      if (mrb_cfunc_p(m)) {
        if (MRB_METHOD_PROC_P(m)) {
          mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));
        }
        ci->argc = argc;
        ci->mid = syms[c];
        ci->u.target_class = cls;
        ci->stack[0] = recv;
        if (argc >= 0) {
          stack_copy(ci->stack+1, argv, argc);
        }
        ci->stack[argc+1] = blk;
        if (MRB_METHOD_CFUNC_P(m)) {
          ci->acc = CI_ACC_DIRECT;
          regs[a] = MRB_METHOD_CFUNC(m)(mrb, recv);
          cipop(mrb);
        }
        else {
          ci->acc = CI_ACC_SKIP;
          regs[a] = mrb_run(mrb, MRB_METHOD_PROC(m), recv);
        }
        NEXT;
      }
      else {
        mrb_value *argv = regs+a+2;
        mrb_value args;
        int ai = mrb_gc_arena_save(mrb);

        if (argc >= 0) {
          args = mrb_ary_new_from_values(mrb, argc, argv);
        }
        else {
          args = regs[a+2];
        }
        if (mrb_nil_p(blk) || mrb_proc_p(blk)) {
          regs[a] = mrb_funcall_with_block(mrb, recv, syms[c], argc, argv, blk);
        }
        else {
          regs[a] = mrb_funcall_with_block(mrb, recv, syms[c], argc, argv, blk);
        }
        mrb_gc_arena_restore(mrb, ai);
        NEXT;
      }
    }
    L_SUPER_SYM:
    {
      NEXT;
    }

    CASE(OP_SUPERCLASS, B) {
      struct RClass *cls = mrb_class_ptr(regs[a]);

      regs[a] = mrb_obj_value(cls->super);
      NEXT;
    }

    CASE(OP_CLASSOF, B) {
      regs[a] = mrb_obj_value(mrb_class_ptr(regs[a])->tt);
      NEXT;
    }

    CASE(OP_INSTANCEOF, BB) {
      regs[a] = mrb_bool_value(mrb_obj_is_instance_of(mrb, regs[a], mrb_class_ptr(regs