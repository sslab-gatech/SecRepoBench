regs[a+2] = mrb_nil_value();
          argc = -1;
        }
        else {
          regs[a+1] = mrb_ary_subseq(mrb, regs[a+1], 0, RARRAY_LEN(regs[a+1])-1);
        }
        args = regs[a+1];
        mrb_ary_unshift(mrb, args, mrb_symbol_value(mid));
        mrb_stack_extend(mrb, 3);
        regs[a+1] = args;
        regs[a+2] = blk;
        ci->stack[0] = recv;
        ci->stack[1] = args;
        ci->stack[2] = blk;
        ci->argc = -1;
        argc = 1;
      }
      if (mrb->c->ci - mrb->c->cibase > MRB_FUNCALL_DEPTH_MAX) {
        mrb_exc_raise(mrb, mrb_obj_value(mrb->stack_err));
      }
      ci = cipush(mrb, argc+2, CI_ACC_SKIP, cls, NULL, mid, argc);
      if (argc < 0) {
        ci->argc = -1;
        argc = 1;
      }
      mrb_stack_extend(mrb, argc + 2);
      regs[a] = recv;
      regs[a+1] = args;
      regs[a+argc+1] = blk;
      ci->stack[0] = recv;
      ci->stack[1] = args;
      ci->stack[argc+1] = blk;
      if (MRB_METHOD_CFUNC_P(m)) {
        ci->acc = CI_ACC_DIRECT;
        regs[a+argc+1] = MRB_METHOD_CFUNC(m)(mrb, recv);
        cipop(mrb);
      }
      else {
        ci->acc = CI_ACC_SKIP;
        regs[a+argc+1] = mrb_run(mrb, MRB_METHOD_PROC(m), recv);
      }
      NEXT;
    }

    CASE(OP_SENDB_SYM, BB)
    L_SENDB_SYM:
    {
      mid = syms[b];
      mrb_int argc = (c == CALL_MAXARGS) ? -1 : c;
      mrb_int bidx = (argc < 0) ? a+2 : a+c+1;
      mrb_method_t m;
      struct RClass *cls;
      mrb_callinfo *ci = mrb->c->ci;
      mrb_value recv, blk;

      mrb_assert(bidx < irep->nregs);

      recv = regs[a];
      blk = regs[bidx];
      if (!mrb_nil_p(blk) && !mrb_proc_p(blk)) {
        blk = mrb_type_convert(mrb, blk, MRB_TT_PROC, MRB_SYM(to_proc));
        /* The stack might have been reallocated during mrb_type_convert(),
           see #3622 */
        regs[bidx] = blk;
      }
      cls = mrb_class(mrb, recv);
      m = mrb_method_search_vm(mrb, &cls, mid);
      if (MRB_METHOD_UNDEF_P(m)) {
        mrb_sym missing = MRB_SYM(method_missing);
        mrb_value args;

        if (mrb_func_basic_p(mrb, recv, missing, mrb_obj_missing)) {
        method_missing:
          args = get_send_args(mrb, argc, regs+a+1);
          mrb_method_missing(mrb, mid, recv, args);
        }
        if (mid != missing) {
          cls = mrb_class(mrb, recv);
        }
        m = mrb_method_search_vm(mrb, &cls, missing);
        if (MRB_METHOD_UNDEF_P(m)) goto method_missing; /* just in case */
        if (argc >= 0) {
          if (a+2 >= irep->nregs) {
            mrb_stack_extend(mrb, a+3);
          }
          regs[a+1] = mrb_ary_new_from_values(mrb, c, regs+a+1);
          regs[a+2] = mrb_nil_value();
          argc = -1;
        }
        else {
          regs[a+1] = mrb_ary_subseq(mrb, regs[a+1], 0, RARRAY_LEN(regs[a+1])-1);
        }
        args = regs[a+1];
        mrb_ary_unshift(mrb, args, mrb_symbol_value(mid));
        mrb_stack_extend(mrb, 3);
        regs[a+1] = args;
        regs[a+2] = blk;
        ci->stack[0] = recv;
        ci->stack[1] = args;
        ci->stack[2] = blk;
        ci->argc = -1;
        argc = 1;
      }
      if (mrb->c->ci - mrb->c->cibase > MRB_FUNCALL_DEPTH_MAX) {
        mrb_exc_raise(mrb, mrb_obj_value(mrb->stack_err));
      }
      ci = cipush(mrb, argc+2, CI_ACC_SKIP, cls, NULL, mid, argc);
      if (argc < 0) {
        ci->argc = -1;
        argc = 1;
      }
      mrb_stack_extend(mrb, argc + 2);
      regs[a] = recv;
      regs[a+1] = args;
      regs[a+argc+1] = blk;
      ci->stack[0] = recv;
      ci->stack[1] = args;
      ci->stack[argc+1] = blk;
      if (MRB_METHOD_CFUNC_P(m)) {
        ci->acc = CI_ACC_DIRECT;
        regs[a+argc+1] = MRB_METHOD_CFUNC(m)(mrb, recv);
        cipop(mrb);
      }
      else {
        ci->acc = CI_ACC_SKIP;
        regs[a+argc+1] = mrb_run(mrb, MRB_METHOD_PROC(m), recv);
      }
      NEXT;
    }

    CASE(OP_SEND_SYM, B) {
      mid = syms[a];
      goto L_SEND_SYM;
    }

    CASE(OP_SEND_NIL, B) {
      mid = 0;
      goto L_SEND_NIL;
    }

    CASE(OP_SEND_SELF, B) {
      mid = 0;
      goto L_SEND_SELF;
    }

    CASE(OP_SEND_TRUE, B) {
      mid = 0;
      goto L_SEND_TRUE;
    }

    CASE(OP_SEND_FALSE, B) {
      mid = 0;
      goto L_SEND_FALSE;
    }

    CASE(OP_SEND_FIXNUM, B) {
      mid = 0;
      goto L_SEND_FIXNUM;
    }

    CASE(OP_SEND_FLOAT, B) {
      mid = 0;
      goto L_SEND_FLOAT;
    }

    CASE(OP_SEND_STR, B) {
      mid = 0;
      goto L_SEND_STR;
    }

    CASE(OP_SEND_SYM, B) {
      mid = 0;
      goto L_SEND_SYM;
    }

    CASE(OP_SEND_ARRAY, B) {
      mid = 0;
      goto L_SEND_ARRAY;
    }

    CASE(OP_SEND_HASH, B) {
      mid = 0;
      goto L_SEND_HASH;
    }

    CASE(OP_SEND_RANGE, B) {
      mid = 0;
      goto L_SEND_RANGE;
    }

    CASE(OP_SEND_PROC, B) {
      mid = 0;
      goto L_SEND_PROC;
    }

    CASE(OP_SEND_CLASS, B) {
      mid = 0;
      goto L_SEND_CLASS;
    }

    CASE(OP_SEND_MODULE, B) {
      mid = 0;
      goto L_SEND_MODULE;
    }

    CASE(OP_SEND_OBJECT, B) {
      mid = 0;
      goto L_SEND_OBJECT;
    }

    CASE(OP_SEND_UNDEF, B) {
      mid = 0;
      goto L_SEND_UNDEF;
    }

    CASE(OP_SEND_TRUE, B) {
      mid = 0;
      goto L_SEND_TRUE;
    }

    CASE(OP_SEND_FALSE, B) {
      mid = 0;
      goto L_SEND_FALSE;
    }

    CASE(OP_SEND_NIL, B) {
      mid = 0;
      goto L_SEND_NIL;
    }

    CASE(OP_SEND_SELF, B) {
      mid = 0;
      goto L_SEND_SELF;
    }

    CASE(OP_SEND_FIXNUM, B) {
      mid = 0;
      goto L_SEND_FIXNUM;
    }

    CASE(OP_SEND_FLOAT, B) {
      mid = 0;
      goto L_SEND_FLOAT;
    }

    CASE(OP_SEND_STR, B) {
      mid = 0;
      goto L_SEND_STR;
    }

    CASE(OP_SEND_SYM, B) {
      mid = 0;
      goto L_SEND_SYM;
    }

    CASE(OP_SEND_ARRAY, B) {
      mid = 0;
      goto L_SEND_ARRAY;
    }

    CASE(OP_SEND_HASH, B) {
      mid = 0;
      goto L_SEND_HASH;
    }

    CASE(OP_SEND_RANGE, B) {
      mid = 0;
      goto L_SEND_RANGE;
    }

    CASE(OP_SEND_PROC, B) {
      mid = 0;
      goto L_SEND_PROC;
    }

    CASE(OP_SEND_CLASS, B) {
      mid = 0;
      goto L_SEND_CLASS;
    }

    CASE(OP_SEND_MODULE, B) {
      mid = 0;
      goto L_SEND_MODULE;
    }

    CASE(OP_SEND_OBJECT, B) {
      mid = 0;
      goto L_SEND_OBJECT;
    }

    CASE(OP_SEND_UNDEF, B) {
      mid = 0;
      goto L_SEND_UNDEF;
    }

    CASE(OP_SEND_SUPER, BBB) {
      mrb_value recv, args, blk;
      mrb_method_t m;
      struct RClass *cls;
      mrb_callinfo *ci = mrb->c->ci;

      recv = regs[a];
      cls = mrb_class(mrb, recv);
      m = mrb_method_search_vm(mrb, &cls, syms[b]);
      if (MRB_METHOD_UNDEF_P(m)) {
        mrb_sym missing = MRB_SYM(method_missing);
        mrb_value args;

        if (mrb_func_basic_p(mrb, recv, missing, mrb_obj_missing)) {
        method_missing:
          args = get_send_args(mrb, argc, regs+a+1);
          mrb_method_missing(mrb, syms[b], recv, args);
        }
        if (syms[b] != missing) {
          cls = mrb_class(mrb, recv);
        }
        m = mrb_method_search_vm(mrb, &cls, missing);
        if (MRB_METHOD_UNDEF_P(m)) goto method_missing; /* just in case */
        if (argc >= 0) {
          if (a+2 >= irep