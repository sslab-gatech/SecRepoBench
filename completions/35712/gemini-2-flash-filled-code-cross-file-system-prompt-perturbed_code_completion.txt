CASE(OP_EXT1, Z) {
      instruction = *++pc;
      switch (instruction) {
        CASE(OP_EXT1_GETIV, BB) {
          regs[a] = mrb_iv_get(mrb, regs[0], syms[b]);
          break;
        }
        CASE(OP_EXT1_SETIV, BB) {
          mrb_iv_set(mrb, regs[0], syms[b], regs[a]);
          break;
        }
        CASE(OP_EXT1_GETMCNST, BB) {
          mrb_value val;

          val = mrb_const_get(mrb, regs[a], syms[b]);
          regs[a] = val;
          break;
        }
        CASE(OP_EXT1_SETMCNST, BB) {
          mrb_const_set(mrb, regs[a+1], syms[b], regs[a]);
          break;
        }
        CASE(OP_EXT1_CHECK_METHOD, BB) {
          struct RClass *cls = mrb_class(mrb, regs[a]);
          mrb_method_t m = mrb_method_search_vm(mrb, &cls, syms[b]);
          regs[a] = mrb_bool_value(!MRB_METHOD_UNDEF_P(m));
          break;
        }
        default:
#ifndef MRB_NO_STDIO
          fprintf(stderr, "Unimplemented extended opcode: %d\n", instruction);
#endif
          abort();
      }
      pc--;
      NEXT;
    }

    CASE(OP_EXT2, Z) {
      instruction = *++pc;
      switch (instruction) {
        CASE(OP_EXT2_MMETHOD, BB) {
          struct RClass *target = mrb_class_ptr(regs[a]);
          struct RProc *p = mrb_proc_ptr(regs[a+1]);
          mrb_method_t m;
          mrb_sym mid = syms[b];

          MRB_METHOD_FROM_PROC(m, p);
          mrb_define_method_raw(mrb, target, mid, m);
          mrb_method_added(mrb, target, mid);
          mrb_gc_arena_restore(mrb, ai);
          break;
        }
        default:
#ifndef MRB_NO_STDIO
          fprintf(stderr, "Unimplemented extended opcode: %d\n", instruction);
#endif
          abort();
      }
      pc--;
      NEXT;
    }

    CASE(OP_EXT3, Z) {
      instruction = *++pc;
      switch (instruction) {
        default:
#ifndef MRB_NO_STDIO
          fprintf(stderr, "Unimplemented extended opcode: %d\n", instruction);
#endif
          abort();
      }
      pc--;
      NEXT;
    }