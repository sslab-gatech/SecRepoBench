CASE(OP_EXT1, Z) {
  uint8_t ext_opcode;
  FETCH_B(ext_opcode);
  pc--;
  switch (ext_opcode) {
    case 0x00: // OP_EXT1_SEND
      {
        FETCH_BB(b, c);
        mid = syms[b];
        c = 1;
        goto L_SEND_SYM;
      }
    case 0x01: // OP_EXT1_SENDB
      {
        FETCH_BB(b, c);
        mid = syms[b];
        goto L_SENDB_SYM;
      }
    case 0x02: // OP_EXT1_ENTER
      {
        FETCH_W(a);
        CASE(OP_ENTER, W) {
          mrb_int m1 = MRB_ASPEC_REQ(a);
          mrb_int o  = MRB_ASPEC_OPT(a);
          mrb_int r  = MRB_ASPEC_REST(a);
          mrb_int m2 = MRB_ASPEC_POST(a);
          mrb_int kd = (MRB_ASPEC_KEY(a) > 0 || MRB_ASPEC_KDICT(a))? 1 : 0;
          /* unused
          int b  = MRB_ASPEC_BLOCK(a);
          */
          mrb_int argc = mrb->c->ci->argc;
          mrb_value *argv = regs+1;
          mrb_value * const argv0 = argv;
          mrb_int const len = m1 + o + r + m2;
          mrb_int const blk_pos = len + kd + 1;
          mrb_value *blk = &argv[argc < 0 ? 1 : argc];
          mrb_value kdict = mrb_nil_value();
          mrb_int kargs = kd;

          /* arguments is passed with Array */
          if (argc < 0) {
            struct RArray *ary = mrb_ary_ptr(regs[1]);
            argv = ARY_PTR(ary);
            argc = (int)ARY_LEN(ary);
            mrb_gc_protect(mrb, regs[1]);
          }

          /* strict argument check */
          if (mrb->c->ci->proc && MRB_PROC_STRICT_P(mrb->c->ci->proc)) {
            if (argc < m1 + m2 || (r == 0 && argc > len + kd)) {
              argnum_error(mrb, m1+m2);
              goto L_RAISE;
            }
          }
          /* extract first argument array to arguments */
          else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
            mrb_gc_protect(mrb, argv[0]);
            argc = (int)RARRAY_LEN(argv[0]);
            argv = RARRAY_PTR(argv[0]);
          }

          if (kd) {
            /* check last arguments is hash if method takes keyword arguments */
            if (argc == m1+m2) {
              kdict = mrb_hash_new(mrb);
              kargs = 0;
            }
            else {
              if (argv && argc > 0 && mrb_hash_p(argv[argc-1])) {
                kdict = argv[argc-1];
                mrb_hash_check_kdict(mrb, kdict);
              }
              else if (r || argc <= m1+m2+o
                       || !(mrb->c->ci->proc && MRB_PROC_STRICT_P(mrb->c->ci->proc))) {
                kdict = mrb_hash_new(mrb);
                kargs = 0;
              }
              else {
                argnum_error(mrb, m1+m2);
                goto L_RAISE;
              }
              if (MRB_ASPEC_KEY(a) > 0) {
                kdict = mrb_hash_dup(mrb, kdict);
              }
            }
          }

          /* no rest arguments */
          if (argc-kargs < len) {
            mrb_int mlen = m2;
            if (argc < m1+m2) {
              mlen = m1 < argc ? argc - m1 : 0;
            }
            regs[blk_pos] = *blk; /* move block */
            if (kd) regs[len + 1] = kdict;

            /* copy mandatory and optional arguments */
            if (argv0 != argv && argv) {
              value_move(&regs[1], argv, argc-mlen); /* m1 + o */
            }
            if (argc < m1) {
              stack_clear(&regs[argc+1], m1-argc);
            }
            /* copy post mandatory arguments */
            if (mlen) {
              value_move(&regs[len-m2+1], &argv[argc-mlen], mlen);
            }
            if (mlen < m2) {
              stack_clear(&regs[len-m2+mlen+1], m2-mlen);
            }
            /* initialize rest arguments with empty Array */
            if (r) {
              regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
            }
            /* skip initializer of passed arguments */
            if (o > 0 && argc-kargs > m1+m2)
              pc += (argc - kargs - m1 - m2)*3;
          }
          else {
            mrb_int rnum = 0;
            if (argv0 != argv) {
              regs[blk_pos] = *blk; /* move block */
              if (kd) regs[len + 1] = kdict;
              value_move(&regs[1], argv, m1+o);
            }
            if (r) {
              mrb_value ary;

              rnum = argc-m1-o-m2-kargs;
              ary = mrb_ary_new_from_values(mrb, rnum, argv+m1+o);
              regs[m1+o+1] = ary;
            }
            if (m2) {
              if (argc-m2 > m1) {
                value_move(&regs[m1+o+r+1], &argv[m1+o+rnum], m2);
              }
            }
            if (argv0 == argv) {
              regs[blk_pos] = *blk; /* move block */
              if (kd) regs[len + 1] = kdict;
            }
            pc += o*3;
          }

          /* format arguments for generated code */
          mrb->c->ci->argc = (int16_t)(len + kd);

          /* clear local (but non-argument) variables */
          if (irep->nlocals-blk_pos-1 > 0) {
            stack_clear(&regs[blk_pos+1], irep->nlocals-blk_pos-1);
          }
          JUMP;
        }
      }
    case 0x03: // OP_EXT1_KARG
      {
        FETCH_BB(b, c);
        CASE(OP_KARG, BB) {
          mrb_value k = mrb_symbol_value(syms[b]);
          mrb_value kdict = regs[mrb->c->ci->argc];

          if (!mrb_hash_p(kdict) || !mrb_hash_key_p(mrb, kdict, k)) {
            mrb_value str = mrb_format(mrb, "missing keyword: %v", k);
            mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));
            goto L_RAISE;
          }
          regs[a] = mrb_hash_get(mrb, kdict, k);
          mrb_hash_delete_key(mrb, kdict, k);
          NEXT;
        }
      }
    case 0x04: // OP_EXT1_KEY_P
      {
        FETCH_BB(b, c);
        CASE(OP_KEY_P, BB) {
          mrb_value k = mrb_symbol_value(syms[b]);
          mrb_value kdict = regs[mrb->c->ci->argc];
          mrb_bool key_p = FALSE;

          if (mrb_hash_p(kdict)) {
            key_p = mrb_hash_key_p(mrb, kdict, k);
          }
          regs[a] = mrb_bool_value(key_p);
          NEXT;
        }
      }
    case 0x05: // OP_EXT1_KEYEND
      {
        CASE(OP_KEYEND, Z) {
          mrb_value kdict = regs[mrb->c->ci->argc];

          if (mrb_hash_p(kdict) && !mrb_hash_empty_p(mrb, kdict)) {
            mrb_value keys = mrb_hash_keys(mrb, kdict);
            mrb_value key1 = RARRAY_PTR(keys)[0];
            mrb_value str = mrb_format(mrb, "unknown keyword: %v", key1);
            mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));
            goto L_RAISE;
          }
          NEXT;
        }
      }
    default:
      mrb_raise(mrb, E_ARGUMENT_ERROR, "unknown extended opcode");
  }
  pc++;
  JUMP;
}

CASE(OP_EXT2, Z) {
  uint8_t ext_opcode;
  FETCH_B(ext_opcode);
  pc--;
  switch (ext_opcode) {
    case 0x00: // OP_EXT2_SEND
      {
        FETCH_BBB(b, c, a);
        mid = syms[b];
        goto L_SEND;
      }
    case 0x01: // OP_EXT2_SENDB
      {
        FETCH_BBB(b, c, a);
        mid = syms[b];
        goto L_SENDB;
      }
    case 0x02: // OP_EXT2_CALL
      {
        CASE(OP_CALL, Z) {
          mrb_callinfo *ci;
          mrb_value recv = mrb->c->ci->stack[0];
          struct RProc *m = mrb_proc_ptr(recv);

          /* replace callinfo */
          ci = mrb->c->ci;
          ci->u.target_class = MRB_PROC_TARGET_CLASS(m);
          mrb_vm_ci_proc_set(ci, m);
          if (MRB_PROC_ENV_P(m)) {
            ci->mid = MRB_PROC_ENV(m)->mid;
          }

          /* prepare stack */
          if (MRB_PROC_CFUNC_P(m)) {
            recv = MRB_PROC_CFUNC(m)(mrb, recv);
            mrb_gc_arena_restore(mrb, ai);
            mrb_gc_arena_shrink(mrb, ai);
            if (mrb->exc) goto L_RAISE;
            /* pop stackpos */
            ci = cipop(mrb);
            pc = ci->pc;
            regs[ci[1].acc] = recv;
            irep = mrb->c->ci->proc->body.irep;
            pool = irep->pool;
            syms = irep->syms;
            JUMP;
          }
          else {
            /* setup environment for calling method *