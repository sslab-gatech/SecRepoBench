CASE(OP_EXT1, Z) {
      uint8_t insn = READ_B();
      switch (insn) {
        CASE(OP_EXT1_LAMBDA, BB) {
          c = OP_L_LAMBDA | OP_L_CAPTURE;
          goto L_MAKE_LAMBDA;
        }
        CASE(OP_EXT1_BLOCK, BB) {
          c = OP_L_BLOCK | OP_L_CAPTURE;
          goto L_MAKE_LAMBDA;
        }
        CASE(OP_EXT1_METHOD, BB) {
          c = OP_L_METHOD | OP_L_CAPTURE;
          goto L_MAKE_LAMBDA;
        }
        default:
          mrb_assert(!"unknown OP_EXT1");
      }
      pc--;
      NEXT;
    }

    CASE(OP_EXT2, Z) {
      uint8_t insn = READ_B();
      switch (insn) {
        CASE(OP_EXT2_LAMBDA, BB) {
          c = OP_L_LAMBDA | OP_L_CAPTURE | OP_L_STRICT;
          goto L_MAKE_LAMBDA;
        }
        default:
          mrb_assert(!"unknown OP_EXT2");
      }
      pc--;
      NEXT;
    }

    CASE(OP_EXT3, Z) {
      uint8_t insn = READ_B();
      switch (insn) {
        CASE(OP_EXT3_RESCUE, BB) {
          mrb_value exc = regs[a];
          if (!mrb_obj_is_kind_of(mrb, exc, mrb->eException_class)) {
            exc = mrb_obj_value(mrb_class_get(mrb, "RuntimeError"));
          }
          regs[b] = exc;
          NEXT;
        }
        CASE(OP_EXT3_ENSURE, BB) {
          mrb_callinfo *ci = mrb->c->ci;
          struct RProc *p;
          const mrb_irep *nirep = irep->reps[b];

          p = mrb_closure_new(mrb, nirep);
          p->flags |= MRB_PROC_SCOPE;
          ci->proc = p;
          ci->nregs = irep->nregs;
          ci->target_class = MRB_PROC_TARGET_CLASS(p);
          JUMP;
        }
        default:
          mrb_assert(!"unknown OP_EXT3");
      }
      pc--;
      NEXT;
    }