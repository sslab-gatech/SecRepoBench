(syms[b]);
      mrb_value v = regs[a];
      mrb_hash_set(mrb, regs[0], k, v);
      NEXT;
    }

    CASE(OP_RETURN, B) {
      mrb_value v = regs[a];
      if (mrb->c->ci->acc >= 0) {
        regs[mrb->c->ci->acc] = v;
      }
      else {
        mrb->c->ci->stack[0] = v;
      }
      cipop(mrb);
      pc = mrb->c->ci->pc;
      JUMP;
    }

    CASE(OP_RETFALSE, B) {
      mrb_value v = regs[a];
      if (mrb_test(v)) {
        NEXT;
      }
      else {
        regs[mrb->c->ci->acc] = v;
        cipop(mrb);
        pc = mrb->c->ci->pc;
        JUMP;
      }
    }

    CASE(OP_RETVOID, B) {
      mrb_value v = regs[a];
      if (mrb_test(v)) {
        NEXT;
      }
      else {
        regs[mrb->c->ci->acc] = v;
        cipop(mrb);
        pc = mrb->c->ci->pc;
        JUMP;
      }
    }

    CASE(OP_RETNIL, B) {
      mrb_value v = regs[a];
      if (mrb_test(v)) {
        NEXT;
      }
      else {
        regs[mrb->c->ci->acc] = v;
        cipop(mrb);
        pc = mrb->c->ci->pc;
        JUMP;
      }
    }

    CASE(OP_RETURN_S, B) {
      mrb_value v = regs[a];
      if (mrb->c->ci->acc >= 0) {
        regs[mrb->c->ci->acc] = v;
      }
      else {
        mrb->c->ci->stack[0] = v;
      }
      cipop(mrb);
      pc = mrb->c->ci->pc;
      JUMP;
    }

    CASE(OP_RETURN_B, B) {
      mrb_value v = regs[a];
      if (mrb->c->ci->acc >= 0) {
        regs[mrb->c->ci->acc] = v;
      }
      else {
        mrb->c->ci->stack[0] = v;
      }
      cipop(mrb);
      pc = mrb->c->ci->pc;
      JUMP;
    }

    CASE(OP_RETURN_UW, B) {
      mrb_value v = regs[a];
      if (mrb->c->ci->acc >= 0) {
        regs[mrb->c->ci->acc] = v;
      }
      else {
        mrb->c->ci->stack[0] = v;
      }
      cipop(mrb);
      pc = mrb->c->ci->pc;
      JUMP;
    }

    CASE(OP_RETURN_NORMAL, B) {
      mrb_value v = regs[a];
      if (mrb->c->ci->acc >= 0) {
        regs[mrb->c->ci->acc] = v;
      }
      else {
        mrb->c->ci->stack[0] = v;
      }
      cipop(mrb);
      pc = mrb->c->ci->pc;
      JUMP;
    }

    CASE(OP_RETURN_BLOCK, B) {
      mrb_value v = regs[a];
      if (mrb->c->ci->acc >= 0) {
        regs[mrb->c->ci->acc] = v;
      }
      else {
        mrb->c->ci->stack[0] = v;
      }
      cipop(mrb);
      pc = mrb->c->ci->pc;
      JUMP;
    }

    CASE(OP_RETURNjmp, B) {
      mrb_value v = regs[a];
      if (mrb->c->ci->acc >= 0) {
        regs[mrb->c->ci->acc] = v;
      }
      else {
        mrb->c->ci->stack[0] = v;
      }
      cipop(mrb);
      pc = mrb->c->ci->pc;
      JUMP;
    }

    CASE(OP_RETURNjmpS, B) {
      mrb_value v = regs[a];
      if (mrb->c->ci->acc >= 0) {
        regs[mrb->c->ci->acc] = v;
      }
      else {
        mrb->c->ci->stack[0] = v;
      }
      cipop(mrb);
      pc = mrb->c->ci->pc;
      JUMP;
    }

    CASE(OP_RETURNjmpB, B) {
      mrb_value v = regs[a];
      if (mrb->c->ci->acc >= 0) {
        regs[mrb->c->ci->acc] = v;
      }
      else {
        mrb->c->ci->stack[0] = v;
      }
      cipop(mrb);
      pc = mrb->c->ci->pc;
      JUMP;
    }

    CASE(OP_RETURNjmpUW, B) {
      mrb_value v = regs[a];
      if (mrb->c->ci->acc >= 0) {
        regs[mrb->c->ci->acc] = v;
      }
      else {
        mrb->c->ci->stack[0] = v;
      }
      cipop(mrb);
      pc = mrb->c->ci->pc;
      JUMP;
    }

    CASE(OP_RETURNjmp_NORMAL, B) {
      mrb_value v = regs[a];
      if (mrb->c->ci->acc >= 0) {
        regs[mrb->c->ci->acc] = v;
      }
      else {
        mrb->c->ci->stack[0] = v;
      }
      cipop(mrb);
      pc = mrb->c->ci->pc;
      JUMP;
    }

    CASE(OP_RETURNjmp_BLOCK, B) {
      mrb_value v = regs[a];
      if (mrb->c->ci->acc >= 0) {
        regs[mrb->c->ci->acc] = v;
      }
      else {
        mrb->c->ci->stack[0] = v;
      }
      cipop(mrb);
      pc = mrb->c->ci->pc;
      JUMP;
    }

    CASE(OP_RETURNjmpUW_S, B) {
      mrb_value v = regs[a];
      if (mrb->c->ci->acc >= 0) {
        regs[mrb->c->ci->acc] = v;
      }
      else {
        mrb->c->ci->stack[0] = v;
      }
      cipop(mrb);
      pc = mrb->c->ci->pc;
      JUMP;
    }

    CASE(OP_RETURNjmpUW_B, B) {
      mrb_value v = regs[a];
      if (mrb->c->ci->acc >= 0) {
        regs[mrb->c->ci->acc] = v;
      }
      else {
        mrb->c->ci->stack[0] = v;
      }
      cipop(mrb);
      pc = mrb->c->ci->pc;
      JUMP;
    }

    CASE(OP_RETURNjmpUW_NORMAL, B) {
      mrb_value v = regs[a];
      if (mrb->c->ci->acc >= 0) {
        regs[mrb->c->ci->acc] = v;
      }
      else {
        mrb->c->ci->stack[0] = v;
      }
      cipop(mrb);
      pc = mrb->c->ci->pc;
      JUMP;
    }

    CASE(OP_RETURNjmpUW_BLOCK, B) {
      mrb_value v = regs[a];
      if (mrb->c->ci->acc >= 0) {
        regs[mrb->c->ci->acc] = v;
      }
      else {
        mrb->c->ci->stack[0] = v;
      }
      cipop(mrb);
      pc = mrb->c->ci->pc;
      JUMP;
    }

    CASE(OP_RETURNjmpUW_S_BLOCK, B) {
      mrb_value v = regs[a];
      if (mrb->c->ci->acc >= 0) {
        regs[mrb->c->ci->acc] = v;
      }
      else {
        mrb->c->ci->stack[0] = v;
      }
      cipop(mrb);
      pc = mrb->c->ci->pc;
      JUMP;
    }

    CASE(OP_RETURNjmpUW_B_BLOCK, B) {
      mrb_value v = regs[a];
      if (mrb->c->ci->acc >= 0) {
        regs[mrb->c->ci->acc] = v;
      }
      else {
        mrb->c->ci->stack[0] = v;
      }
      cipop(mrb);
      pc = mrb->c->ci->pc;
      JUMP;
    }

    CASE(OP_RETURNjmpUW_NORMAL_BLOCK, B) {
      mrb_value v = regs[a];
      if (mrb->c->ci->acc >= 0) {
        regs[mrb->c->ci->acc] = v;
      }
      else {
        mrb->c->ci->stack[0] = v;
      }
      cipop(mrb);
      pc = mrb->c->ci->pc;
      JUMP;
    }

    CASE(OP_RETURNjmpUW_BLOCK_BLOCK, B) {
      mrb_value v = regs[a];
      if (mrb->c->ci->acc >= 0) {
        regs[mrb->c->ci->acc] = v;
      }
      else {
        mrb->c->ci->stack[0] = v;
      }
      cipop(mrb);
      pc = mrb->c->ci->pc;
      JUMP;
    }

    CASE(OP_RETURNjmpUW_S_NORMAL_BLOCK, B) {
      mrb_value v = regs[a];
      if (mrb->c->ci->acc >= 0) {
        regs[mrb->c->ci->acc] = v;
      }
      else {
        mrb->c->ci->stack[0] = v;
      }
      cipop(mrb);
      pc = mrb->c->ci->pc;
      JUMP;
    }

    CASE(OP_RETURNjmpUW_B_NORMAL_BLOCK, B) {
      mrb_value v = regs[a];
      if (mrb->c->ci->acc >= 0) {
        regs[mrb->c->ci->acc] = v;
      }
      else {
        mrb->c->ci->stack[0] = v;
      }
      cipop(mrb);
      pc = mrb->c->ci->pc;
      JUMP;
    }

    CASE(OP_RETURNjmpUW_NORMAL_NORMAL_BLOCK, B) {
      mrb_value v = regs[a];
      if (mrb->c->ci->acc >= 0) {
        regs[mrb->c->ci->acc] = v;
      }
      else {
        mrb->c->ci->stack[0] = v;
      }
      cipop(mrb);
      pc = mrb->c->ci->pc;
      JUMP;
    }

    CASE(OP_RETURNjmpUW_BLOCK_NORMAL_BLOCK, B) {
      mrb_value v = regs[a];
      if (mrb->c->ci->acc >= 0) {
        regs[mrb->c->ci->acc] = v;
      }
      else {
        mrb->c->ci->stack[0] = v;
      }
      cipop(mrb);
      pc = mrb->c->ci->pc;
      JUMP;
    }

    CASE(OP_RETURNjmpUW_S_BLOCK_BLOCK, B) {
      mrb_value v = regs[a];
      if (mrb->c->ci->acc >= 0) {
        regs[mrb->c->ci->acc] = v;
      }
      else {
        mrb->c->ci->stack[0] = v;
      }
      cipop(mrb);
      pc = mrb->c->ci->pc;
      JUMP;
    }

    CASE(OP_RETURNjmpUW_B_BLOCK_BLOCK, B) {
      mrb_value v = regs[a];
      if (mrb->c->ci->acc >= 0) {
        regs[mrb->c->ci->acc] = v;
      }
      else {
        mrb->c->ci->stack[0] = v;
      }
      cipop(mrb);
      pc = mrb->c->ci->pc;
      JUMP;
    }

    CASE(OP_RETURNjmpUW_NORMAL_BLOCK_BLOCK, B) {
      mrb_value v = regs[a];
      if (mrb->c->ci->acc >= 0) {
        regs[mrb->c->ci->acc] = v;
      }
      else {
        mrb->c->ci->stack[0] = v;
      }
      cipop(mrb);
      pc = mrb->c->ci->pc;
      JUMP;
    }

    CASE(OP_RETURNjmpUW_BLOCK_BLOCK_BLOCK, B) {
      mrb_value v = regs[a];
      if (mrb->c->ci->acc >= 0) {
        regs[mrb->c->ci->acc] = v;
      }
      else {
        mrb->c->ci->stack[0] = v;
      }
      cipop(mrb);
      pc = mrb->c->ci->pc;
      JUMP;
    }

    CASE(OP_RETURNjmpUW_S_NORMAL_BLOCK_BLOCK, B) {
      mrb_value v = regs[a];
      if (mrb->c->ci->acc >= 0) {
        regs[mrb->c->ci->acc] = v;
      }
      else {
        mrb->c->ci->stack[0] = v;
      }
      cipop(mrb);
      pc = mrb->c->ci->pc;
      JUMP;
    }

    CASE(OP_RETURNjmpUW_B_NORMAL_BLOCK_BLOCK, B) {
      mrb_value v = regs[a];
      if (mrb->c->ci->acc >= 0) {
        regs[mrb->c->ci->acc] = v;
      }
      else {
        mrb->c->ci->stack[0] = v;
      }
      cipop(mrb);
      pc = mrb->c->ci->pc;
      JUMP;
    }

    CASE(OP