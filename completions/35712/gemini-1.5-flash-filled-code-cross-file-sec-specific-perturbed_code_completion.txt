CASE(OP_EXT1, X) {
      instruction = pc[1];
      pc++;
      switch (instruction) {
        CASE(OP_EXT1_CALL, BBB) {
          c = CALL_MAXARGS;
          goto L_SEND;
        }
        CASE(OP_EXT1_SENDV, BB) {
          c = CALL_MAXARGS;
          goto L_SEND;
        }
        CASE(OP_EXT1_SENDVB, BB) {
          c = CALL_MAXARGS;
          goto L_SENDB;
        }
        CASE(OP_EXT1_SEND, BBB) {
          goto L_SEND;
        }
        CASE(OP_EXT1_SENDB, BBB) {
          goto L_SENDB;
        }
        CASE(OP_EXT1_BLOCK, BB) {
          c = OP_L_BLOCK;
          goto L_MAKE_LAMBDA;
        }
        CASE(OP_EXT1_METHOD, BB) {
          c = OP_L_METHOD;
          goto L_MAKE_LAMBDA;
        }
        CASE(OP_EXT1_LAMBDA, BB) {
          c = OP_L_LAMBDA;
          goto L_MAKE_LAMBDA;
        }
        CASE(OP_EXT1_CAPTURE, BB) {
          c = OP_L_CAPTURE;
          goto L_MAKE_LAMBDA;
        }
        CASE(OP_EXT1_STRCAT, B) {
          mrb_str_concat(mrb, regs[a], regs[a+1]);
          NEXT;
        }
        CASE(OP_EXT1_HASHADD, BB) {
          mrb_value hash;
          int i;
          int lim = a+b*2+1;

          hash = mrb_ensure_hash_type(mrb, regs[a]);
          for (i=a+1; i<lim; i+=2) {
            mrb_hash_set(mrb, hash, regs[i], regs[i+1]);
          }
          mrb_gc_arena_restore(mrb, ai);
          NEXT;
        }
        CASE(OP_EXT1_HASHCAT, B) {
          mrb_value hash = mrb_ensure_hash_type(mrb, regs[a]);

          mrb_hash_merge(mrb, hash, regs[a+1]);
          mrb_gc_arena_restore(mrb, ai);
          NEXT;
        }
        CASE(OP_EXT1_ARYCAT, B) {
          mrb_value splat = mrb_ary_splat(mrb, regs[a+1]);
          if (mrb_nil_p(regs[a])) {
            regs[a] = splat;
          }
          else {
            mrb_ary_concat(mrb, regs[a], splat);
          }
          mrb_gc_arena_restore(mrb, ai);
          NEXT;
        }
        CASE(OP_EXT1_ARYPUSH, B) {
          mrb_ary_push(mrb, regs[a], regs[a+1]);
          NEXT;
        }
        CASE(OP_EXT1_ARYDUP, B) {
          mrb_value ary = regs[a];
          if (mrb_array_p(ary)) {
            ary = mrb_ary_new_from_values(mrb, RARRAY_LEN(ary), RARRAY_PTR(ary));
          }
          else {
            ary = mrb_ary_new_from_values(mrb, 1, &ary);
          }
          regs[a] = ary;
          NEXT;
        }
        default:
          goto L_UNIMPLEMENTED_OPCODE;
      }
      pc--;
      JUMP;
    }
    CASE(OP_EXT2, X) {
      instruction = pc[1];
      pc++;
      switch (instruction) {
        CASE(OP_EXT2_GETUPVAR, BBB) {
          mrb_value *regs_a = regs + a;
          struct REnv *e = uvenv(mrb, c);

          if (e && b < MRB_ENV_LEN(e)) {
            *regs_a = e->stack[b];
          }
          else {
            *regs_a = mrb_nil_value();
          }
          NEXT;
        }
        CASE(OP_EXT2_SETUPVAR, BBB) {
          struct REnv *e = uvenv(mrb, c);

          if (e) {
            mrb_value *regs_a = regs + a;

            if (b < MRB_ENV_LEN(e)) {
              e->stack[b] = *regs_a;
              mrb_write_barrier(mrb, (struct RBasic*)e);
            }
          }
          NEXT;
        }
        default:
          goto L_UNIMPLEMENTED_OPCODE;
      }
      pc--;
      JUMP;
    }
    CASE(OP_EXT3, X) {
      instruction = pc[1];
      pc++;
      switch (instruction) {
        CASE(OP_EXT3_AREF, BBB) {
          mrb_value v = regs[b];

          if (!mrb_array_p(v)) {
            if (c == 0) {
              regs[a] = v;
            }
            else {
              SET_NIL_VALUE(regs[a]);
            }
          }
          else {
            v = mrb_ary_ref(mrb, v, c);
            regs[a] = v;
          }
          NEXT;
        }
        CASE(OP_EXT3_ASET, BBB) {
          mrb_ary_set(mrb, regs[b], c, regs[a]);
          NEXT;
        }
        CASE(OP_EXT3_APOST, BBB) {
          mrb_value v = regs[a];
          int pre  = b;
          int post = c;
          struct RArray *ary;
          int len, idx;

          if (!mrb_array_p(v)) {
            v = mrb_ary_new_from_values(mrb, 1, &regs[a]);
          }
          ary = mrb_ary_ptr(v);
          len = (int)ARY_LEN(ary);
          if (len > pre + post) {
            v = mrb_ary_new_from_values(mrb, len - pre - post, ARY_PTR(ary)+pre);
            regs[a++] = v;
            while (post--) {
              regs[a++] = ARY_PTR(ary)[len-post-1];
            }
          }
          else {
            v = mrb_ary_new_capa(mrb, 0);
            regs[a++] = v;
            for (idx=0; idx+pre<len; idx++) {
              regs[a+idx] = ARY_PTR(ary)[pre+idx];
            }
            while (idx < post) {
              SET_NIL_VALUE(regs[a+idx]);
              idx++;
            }
          }
          mrb_gc_arena_restore(mrb, ai);
          NEXT;
        }
        default:
          goto L_UNIMPLEMENTED_OPCODE;
      }
      pc--;
      JUMP;
    }
  L_UNIMPLEMENTED_OPCODE:
    {
      mrb_value exc = mrb_exc_new_lit(mrb, E_NOTIMP_ERROR, "unimplemented opcode");
      mrb_exc_set(mrb, exc);
    }
    goto L_RAISE;