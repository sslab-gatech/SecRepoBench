CASE(OP_EXT1, X) {
      instruction = pc[1];
      pc++;
      switch (instruction) {
      case OP_EXT1_CALL0:
        a = 0;
        c = 0;
        goto L_OP_CALL;
      case OP_EXT1_CALL1:
        a = 1;
        c = 1;
        goto L_OP_CALL;
      case OP_EXT1_CALL2:
        a = 2;
        c = 2;
        goto L_OP_CALL;
      case OP_EXT1_CALL3:
        a = 3;
        c = 3;
        goto L_OP_CALL;
      case OP_EXT1_CALL4:
        a = 4;
        c = 4;
        goto L_OP_CALL;
      case OP_EXT1_CALLN:
        FETCH_BB();
        c = b;
        goto L_OP_CALL;
      case OP_EXT1_BLOCK_PASS:
        FETCH_B();
        regs[a] = regs[a+1];
        NEXT;
      case OP_EXT1_BLOCK_COPY:
        FETCH_BB();
        regs[a] = regs[b];
        NEXT;
      case OP_EXT1_LAMBDA_PASS:
        FETCH_B();
        regs[a] = regs[a+1];
        NEXT;
      case OP_EXT1_LAMBDA_COPY:
        FETCH_BB();
        regs[a] = regs[b];
        NEXT;
      case OP_EXT1_SENDV_BLK:
        FETCH_BB();
        c = CALL_MAXARGS;
        goto L_SEND;
      case OP_EXT1_SENDVB_BLK:
        FETCH_BB();
        c = CALL_MAXARGS;
        goto L_SENDB;
      case OP_EXT1_SEND_BLK:
        FETCH_BBB();
        goto L_SEND;
      case OP_EXT1_SENDB_BLK:
        FETCH_BBB();
        goto L_SENDB;
      case OP_EXT1_GETUPVAR_BLK:
        FETCH_BBB();
        goto L_GETUPVAR;
      case OP_EXT1_SETUPVAR_BLK:
        FETCH_BBB();
        goto L_SETUPVAR;
      case OP_EXT1_GETUPVAR:
        FETCH_BBB();
      L_GETUPVAR:
        {
          mrb_value *regs_a = regs + a;
          struct REnv *e = uvenv(mrb, c);

          if (e && b < MRB_ENV_LEN(e)) {
            *regs_a = e->stack[b];
          }
          else {
            *regs_a = mrb_nil_value();
          }
        }
        NEXT;
      case OP_EXT1_SETUPVAR:
        FETCH_BBB();
      L_SETUPVAR:
        {
          struct REnv *e = uvenv(mrb, c);

          if (e) {
            mrb_value *regs_a = regs + a;

            if (b < MRB_ENV_LEN(e)) {
              e->stack[b] = *regs_a;
              mrb_write_barrier(mrb, (struct RBasic*)e);
            }
          }
        }
        NEXT;
      default:
        goto L_UNSUPPORTED_EXT;
      }
      JUMP;
    }
    CASE(OP_EXT2, X) {
      instruction = pc[1];
      pc++;
      switch (instruction) {
      case OP_EXT2_GETCONST:
        FETCH_BB();
        goto L_GETCONST;
      case OP_EXT2_SETCONST:
        FETCH_BB();
        goto L_SETCONST;
      case OP_EXT2_GETMCNST:
        FETCH_BB();
        goto L_GETMCNST;
      case OP_EXT2_SETMCNST:
        FETCH_BB();
        goto L_SETMCNST;
      default:
        goto L_UNSUPPORTED_EXT;
      }
      JUMP;
    }
    CASE(OP_EXT3, X) {
      instruction = pc[1];
      pc++;
      switch (instruction) {
      case OP_EXT3_EVAL:
        FETCH_B();
        regs[a] = eval_under(mrb, regs[a], regs[a+1], mrb->object_class);
        mrb_gc_arena_restore(mrb, ai);
        NEXT;
      default:
        goto L_UNSUPPORTED_EXT;
      }
      JUMP;
    }
  L_UNSUPPORTED_EXT:
    {
      mrb_value exc = mrb_exc_new_lit(mrb, E_NOTIMP_ERROR, "unsupported extended opcode");
      mrb_exc_set(mrb, exc);
    }
    goto L_RAISE;