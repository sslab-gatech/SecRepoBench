CASE(OP_EXT1, X) {
      instruction = BYTECODE_DECODER(*pc++);
      switch (instruction) {
      CASE(OP_EXT1_GETUPVAR, BBB) {
        mrb_value *regs_a = regs + a;
        struct REnv *e = uvenv(mrb, c);

        if (e && b < MRB_ENV_LEN(e)) {
          *regs_a = e->stack[b];
        }
        else {
          *regs_a = mrb_nil_value();
        }
        NEXT;
      }
      CASE(OP_EXT1_SETUPVAR, BBB) {
        struct REnv *e = uvenv(mrb, c);

        if (e) {
          mrb_value *regs_a = regs + a;

          if (b < MRB_ENV_LEN(e)) {
            e->stack[b] = *regs_a;
            mrb_write_barrier(mrb, (struct RBasic*)e);
          }
        }
        NEXT;
      }
      default:
        mrb_assert(!"unknown ext1 opcode");
        break;
      }
      pc--;
      JUMP;
    }
    CASE(OP_EXT2, X) {
      instruction = BYTECODE_DECODER(*pc++);
      switch (instruction) {
      CASE(OP_EXT2_GETCONST, BB) {
        mrb_value val;
        mrb_sym sym = syms[b];

        val = mrb_vm_const_get(mrb, sym);
        regs[a] = val;
        NEXT;
      }
      CASE(OP_EXT2_SETCONST, BB) {
        mrb_vm_const_set(mrb, syms[b], regs[a]);
        NEXT;
      }
      default:
        mrb_assert(!"unknown ext2 opcode");
        break;
      }
      pc--;
      JUMP;
    }
    CASE(OP_EXT3, X) {
      instruction = BYTECODE_DECODER(*pc++);
      switch (instruction) {
      CASE(OP_EXT3_GETMCNST, BB) {
        mrb_value val;

        val = mrb_const_get(mrb, regs[a], syms[b]);
        regs[a] = val;
        NEXT;
      }
      CASE(OP_EXT3_SETMCNST, BB) {
        mrb_const_set(mrb, regs[a+1], syms[b], regs[a]);
        NEXT;
      }
      default:
        mrb_assert(!"unknown ext3 opcode");
        break;
      }
      pc--;
      JUMP;
    }