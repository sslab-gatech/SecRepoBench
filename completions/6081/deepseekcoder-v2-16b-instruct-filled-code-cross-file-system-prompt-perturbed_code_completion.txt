// <MASK>
  // Parse through the XML string to identify and process different components of a DOCTYPE declaration.
  // When encountering an ENTITY declaration, parse and store the entity definitions in the appropriate data structure.
  // Handle both parameter and general entities, updating predefined entities as needed.
  // Validate entity definitions and handle any errors or circular declarations appropriately.
  // For ATTLIST declarations, parse and store default attributes, managing memory for new attribute tags as necessary.
  // Ensure that malformed or incomplete declarations are handled by throwing appropriate exceptions.
  // Process comments and processing instructions by identifying their boundaries and calling appropriate processing functions.
  // Continue parsing until the end of the DOCTYPE declaration or the input string is reached.
  for (c = xml; c < xml + length && *c != '\0'; c++) {
    if (*c == '<') {
      if (strncmp(c, "<!ENTITY", 8) == 0) {
        // Parse ENTITY declaration
        c += 8;
        while (*c == ' ') c++;
        n = c;
        while (*c != ' ' && *c != '>' && *c != '\0') c++;
        if (*c == '>') *c = '\0';
        else *c = '\0';
        v = c + 1;
        while (*v == ' ') v++;
        if (predefined_entitites != (char **) NULL) {
          for (i = 0; predefined_entitites[i] != (char *) NULL; i++) {
            if (strcmp(predefined_entitites[i], n) == 0) {
              // Handle circular declaration
              ThrowFatalException(SyntaxError,"CircularEntityReference");
            }
          }
          index = GetFirstQuark(n);
          if (index == (ssize_t) -1) {
            index = AddToStringKey(root->entities, n);
          }
          predefined_entitites[i] = AcquireString(n);
          predefined_entitites[i + 1] = AcquireString(v);
          predefined_entitites = (char **) ResizeMagickMemory(predefined_entitites, (i + 2) * sizeof(char *), (i + 3) * sizeof(char *));
          if (predefined_entitites == (char **) NULL) {
            ThrowFatalException(ResourceLimitError, "MemoryAllocationFailed");
          }
        }
        c = n - 1;
      } else if (strncmp(c, "<!ATTLIST", 9) == 0) {
        // Parse ATTLIST declaration
        c += 9;
        while (*c == ' ') c++;
        n = c;
        while (*c != ' ' && *c != '>' && *c != '\0') c++;
        if (*c == '>') *c = '\0';
        else *c = '\0';
        v = c + 1;
        while (*v == ' ') v++;
        // Handle ATTLIST declaration
      } else if (strncmp(c, "<!DOCTYPE", 9) == 0) {
        // Handle DOCTYPE declaration
        c += 9;
        while (*c == ' ') c++;
        n = c;
        while (*c != ' ' && *c != '>' && *c != '\0') c++;
        if (*c == '>') *c = '\0';
        else *c = '\0';
        v = c + 1;
        while (*v == ' ') v++;
        // Handle DOCTYPE declaration
      } else if (strncmp(c, "<!ELEMENT", 9) == 0) {
        // Parse ELEMENT declaration
        c += 9;
        while (*c == ' ') c++;
        n = c;
        while (*c != ' ' && *c != '>' && *c != '\0') c++;
        if (*c == '>') *c = '\0';
        else *c = '\0';
        v = c + 1;
        while (*v == ' ') v++;
        // Handle ELEMENT declaration
      } else if (strncmp(c, "<!PI", 4) == 0) {
        // Parse processing instruction
        c += 4;
        while (*c == ' ') c++;
        n = c;
        while (*c != ' ' && *c != '>' && *c != '\0') c++;
        if (*c == '>') *c = '\0';
        else *c = '\0';
        v = c + 1;
        while (*v == ' ') v++;
        // Handle processing instruction
      } else if (strncmp(c, "<!--", 4) == 0) {
        // Parse comment
        c += 4;
        while (*c != '\0' && strncmp(c, "-->", 3) != 0) c++;
        if (*c == '\0') {
          ThrowFatalException(SyntaxError, "MalformedComment");
        }
        c += 3;
        // Handle comment
      }
    }
  }
  // </MASK>