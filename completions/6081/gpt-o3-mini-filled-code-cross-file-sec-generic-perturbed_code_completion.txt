{
  c = xml;
  while (*c != '\0')
  {
    /* Skip any leading whitespace */
    while (isspace((unsigned char)*c))
      c++;
    if (*c == '\0')
      break;
    /* Handle comments: <!-- comment --> */
    if (strncmp(c, "<!--", 4) == 0)
    {
      char *end_comment = strstr(c, "-->");
      if (end_comment == (char *) NULL)
      {
        ThrowFatalException(OptionError, "IncompleteComment");
        return MagickFalse;
      }
      /* Advance pointer beyond the comment */
      c = end_comment + 3;
      continue;
    }
    /* Handle ENTITY declarations: <!ENTITY ...> */
    else if (strncmp(c, "<!ENTITY", 8) == 0)
    {
      c += 8;
      /* Skip whitespace */
      while (isspace((unsigned char)*c))
        c++;
      /* Determine if this is a parameter entity */
      MagickBooleanType is_parameter = MagickFalse;
      if (*c == '%')
      {
        is_parameter = MagickTrue;
        c++;  /* skip '%' */
        while (isspace((unsigned char)*c))
          c++;
      }
      /* Extract the entity name into a fixed buffer */
      {
        char entityName[256];
        size_t name_len = 0;
        while (*c != '\0' && !isspace((unsigned char)*c) &&
               *c != '>' && name_len < (sizeof(entityName) - 1))
        {
          entityName[name_len++] = *c;
          c++;
        }
        entityName[name_len] = '\0';
        /* Skip whitespace before the entity value */
        while (isspace((unsigned char)*c))
          c++;
        /* The entity value must be quoted */
        if (*c != '\"' && *c != '\'')
        {
          ThrowFatalException(OptionError, "MissingQuoteForEntityValue");
          return MagickFalse;
        }
        char quote = *c;
        c++;  /* skip opening quote */
        char entityValue[1024];
        size_t value_len = 0;
        while (*c != '\0' && *c != quote && value_len < (sizeof(entityValue) - 1))
        {
          entityValue[value_len++] = *c;
          c++;
        }
        entityValue[value_len] = '\0';
        if (*c != quote)
        {
          ThrowFatalException(OptionError, "UnterminatedEntityValue");
          return MagickFalse;
        }
        c++;  /* skip closing quote */
        /* Skip until the end of the declaration '>' */
        while (*c != '\0' && *c != '>')
          c++;
        if (*c == '>')
          c++;
        /* Add the parsed entity to the XML tree (both parameter and general entities). 
           Assume AddEntityToXMLTree is a helper that safely updates root->entities. */
        (void) AddEntityToXMLTree(root, entityName, entityValue, is_parameter);
      }
      continue;
    }
    /* Handle ATTLIST declarations: <!ATTLIST ...> */
    else if (strncmp(c, "<!ATTLIST", 9) == 0)
    {
      c += 9;
      /* Skip to the end of the ATTLIST declaration */
      while (*c != '\0' && *c != '>')
        c++;
      if (*c == '>')
        c++;
      continue;
    }
    /* For any other declaration or unknown content, skip until end of declaration */
    else
    {
      while (*c != '\0' && *c != '>')
        c++;
      if (*c == '>')
        c++;
      continue;
    }
  }
  xml = c;
}