xml=GetXMLNextTag(xml);
    if (xml == (char *) NULL)
      break;
    if (LocaleNCompare(xml,"<!DOCTYPE",9) == 0)
      {
        (void) ParseDoctype(root,xml,exception);
        break;
      }
    if (LocaleNCompare(xml,"<!ENTITY",8) == 0)
      {
        char
          *entity;

        /*
          Parse an ENTITY.
        */
        c=xml+8;
        while (isspace((int) ((unsigned char) *c)) != 0)
          c++;
        t=c;
        while (isalnum((int) ((unsigned char) *c)) != 0)
          c++;
        if (*c == '\0')
          {
            xml=DestroyString(xml);
            break;
          }
        if (*c != '%')
          {
            entity=AcquireString(t);
            entity[c-t]='\0';
            while (isspace((int) ((unsigned char) *c)) != 0)
              c++;
            if (*c == '\0')
              {
                xml=DestroyString(xml);
                entity=DestroyString(entity);
                break;
              }
            q=*c++;
            while (isspace((int) ((unsigned char) *c)) != 0)
              c++;
            if (*c == '\0')
              {
                xml=DestroyString(xml);
                entity=DestroyString(entity);
                break;
              }
            t=c;
            v=t;
            for ( ; *c != '\0'; c++)
            {
              if (*c == q)
                break;
              if (*c == '&')
                {
                  *c='\0';
                  v=ParseEntities(v,predefined_entitites,'>');
                  (void) ConcatenateString(&entity,v);
                  v=c+1;
                  continue;
                }
            }
            *c='\0';
            (void) ConcatenateString(&entity,v);
            index=GetPredefinedEntity(entity);
            if (index < 0)
              (void) AddEntityToXMLTree(root,t,entity);
            entity=DestroyString(entity);
          }
        else
          {
            /*
              Predefined entities.
            */
            c++;
            while (isspace((int) ((unsigned char) *c)) != 0)
              c++;
            if (*c == '\0')
              {
                xml=DestroyString(xml);
                break;
              }
            t=c;
            while (isalnum((int) ((unsigned char) *c)) != 0)
              c++;
            if (*c == '\0')
              {
                xml=DestroyString(xml);
                break;
              }
            entity=AcquireString(t);
            entity[c-t]='\0';
            while (isspace((int) ((unsigned char) *c)) != 0)
              c++;
            if (*c == '\0')
              {
                xml=DestroyString(xml);
                entity=DestroyString(entity);
                break;
              }
            q=*c++;
            while (isspace((int) ((unsigned char) *c)) != 0)
              c++;
            if (*c == '\0')
              {
                xml=DestroyString(xml);
                entity=DestroyString(entity);
                break;
              }
            t=c;
            for ( ; *c != '\0'; c++)
              if (*c == q)
                break;
            *c='\0';
            index=GetPredefinedEntity(entity);
            if (index < 0)
              {
                if (n == (char *) NULL)
                  n=ConstantString(t);
                else
                  {
                    entities=predefined_entitites;
                    predefined_entitites=(char **) AcquireMagickMemory((size_t)
                      (i+2)*sizeof(*predefined_entitites));
                    if (predefined_entitites == (char **) NULL)
                      ThrowFatalException(ResourceLimitError,
                        "MemoryAllocationFailed");
                    for (i=0; entities[i] != (char *) NULL; i++)
                      predefined_entitites[i]=entities[i];
                    predefined_entitites[i]=ConstantString(t);
                    predefined_entitites[i+1]=(char *) NULL;
                    entities=(char **) RelinquishMagickMemory(entities);
                  }
              }
            entity=DestroyString(entity);
          }
        continue;
      }
    if (LocaleNCompare(xml,"<!--",4) == 0)
      {
        /*
          Parse a comment.
        */
        c=xml+4;
        t=c;
        while ((*c != '-') || (*(c+1) != '-') || (*(c+2) != '>'))
        {
          if (*c == '\0')
            {
              xml=DestroyString(xml);
              break;
            }
          c++;
        }
        if (*c == '\0')
          break;
        *c='\0';
        (void) ParseComment(root,t);
        xml=c+3;
        continue;
      }
    if (LocaleNCompare(xml,"<?",2) == 0)
      {
        /*
          Parse a processing instruction.
        */
        c=xml+2;
        t=c;
        while (*c != '?')
        {
          if (*c == '\0')
            {
              xml=DestroyString(xml);
              break;
            }
          c++;
        }
        if (*c == '\0')
          break;
        *c='\0';
        (void) ParseProcessingInstructions(root,t);
        xml=c+1;
        while ((*xml != '\0') && (*xml != '>'))
          xml++;
        if (*xml == '\0')
          {
            xml=DestroyString(xml);
            break;
          }
        xml++;
        continue;
      }
    if (LocaleNCompare(xml,"<!ATTLIST",9) == 0)
      {
        /*
          Parse default attributes.
        */
        c=xml+9;
        while (isspace((int) ((unsigned char) *c)) != 0)
          c++;
        t=c;
        while (isalnum((int) ((unsigned char) *c)) != 0)
          c++;
        if (*c == '\0')
          {
            xml=DestroyString(xml);
            break;
          }
        if (*c != '>')
          (void) ParseAttributes(root,c+1,exception);
        else
          (void) ParseAttributes(root,c+1,exception);
        break;
      }
    if (*xml == '<')
      {
        /*
          Parse an open tag.
        */
        xml++;
        c=xml;
        while (isalnum((int) ((unsigned char) *c)) != 0)
          c++;
        if (*c == '\0')
          {
            xml=DestroyString(xml);
            break;
          }
        if (*c != '>')
          (void) ParseOpenTag(root,xml,ParseAttributes(root,c,exception));
        else
          (void) ParseOpenTag(root,xml,NULL);
        xml=c+(*c != '>' ? 0 : 1);
        continue;
      }
    if (LocaleNCompare(xml,"</",2) == 0)
      {
        /*
          Parse a close tag.
        */
        xml+=2;
        c=xml;
        while (isalnum((int) ((unsigned char) *c)) != 0)
          c++;
        *c='\0';
        root->node=PruneTagFromXMLTree(root->node);
        xml=c+1;
        continue;
      }
    /*
      Parse character content.
    */
    c=xml;
    while (*c != '<')
    {
      if (*c == '\0')
        {
          xml=DestroyString(xml);
          break;
        }
      c++;
    }
    if (*c == '\0')
      break;
    ParseCharacterContent(root,xml,(size_t) (c-xml),'>');
    xml=c;