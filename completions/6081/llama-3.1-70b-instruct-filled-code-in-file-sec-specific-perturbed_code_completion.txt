// Parse through the XML string to identify and process different components of a DOCTYPE declaration.
// When encountering an ENTITY declaration, parse and store the entity definitions in the appropriate data structure.
// Handle both parameter and general entities, updating predefined entities as needed.
// Validate entity definitions and handle any errors or circular declarations appropriately.
// For ATTLIST declarations, parse and store default attributes, managing memory for new attribute tags as necessary.
// Ensure that malformed or incomplete declarations are handled by throwing appropriate exceptions.
// Process comments and processing instructions by identifying their boundaries and calling appropriate processing functions.
// Continue parsing until the end of the DOCTYPE declaration or the input string is reached.

// Parse ENTITY declaration
if (strncmp(xml,"ENTITY",6) == 0)
{
  char
    *entity,
    *name,
    *value;

  ssize_t
    j;

  xml+=6;
  xml+=strspn(xml,XMLWhitespace);
  if (*xml!= '%')
    {
      // General entity
      name=xml;
      xml+=strcspn(xml,XMLWhitespace "'>");
      *xml++='\0';
      xml+=strspn(xml,XMLWhitespace);
      if (*xml == '"')
        {
          xml++;
          value=xml;
          xml=strchr(xml,'"');
          if (xml == (char *) NULL)
            {
              (void) ThrowMagickException(exception,GetMagickModule(),
                OptionWarning,"ParseError","missing \"");
              predefined_entitites=(char **) RelinquishMagickMemory(
                predefined_entitites);
              return(MagickFalse);
            }
          *xml++='\0';
        }
      else
        if (*xml == '\'')
          {
            xml++;
            value=xml;
            xml=strchr(xml,'\'');
            if (xml == (char *) NULL)
              {
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,"ParseError","missing '");
                predefined_entitites=(char **) RelinquishMagickMemory(
                  predefined_entitites);
                return(MagickFalse);
              }
            *xml++='\0';
          }
        else
          {
            (void) ThrowMagickException(exception,GetMagickModule(),
              OptionWarning,"ParseError","missing'or \"");
            predefined_entitites=(char **) RelinquishMagickMemory(
              predefined_entitites);
            return(MagickFalse);
          }
      if (strlen(name) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),
            OptionWarning,"ParseError","missing entity name");
          predefined_entitites=(char **) RelinquishMagickMemory(
            predefined_entitites);
          return(MagickFalse);
        }
      if (strlen(value) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),
            OptionWarning,"ParseError","missing entity value");
          predefined_entitites=(char **) RelinquishMagickMemory(
            predefined_entitites);
          return(MagickFalse);
        }
      j=0;
      while ((predefined_entitites[j]!= (char *) NULL) &&
             (strcmp(predefined_entitites[j],name)!= 0))
        j+=2;
      if (predefined_entitites[j]!= (char *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),
            OptionWarning,"ParseError","entity '%s' redefined",name);
          predefined_entitites=(char **) RelinquishMagickMemory(
            predefined_entitites);
          return(MagickFalse);
        }
      predefined_entitites=(char **) ResizeQuantumMemory(predefined_entitites,
        (size_t) (j+4),sizeof(*predefined_entitites));
      if (predefined_entitites == (char **) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),
            ResourceLimitError,"MemoryAllocationFailed","`%s'","");
          return(MagickFalse);
        }
      predefined_entitites[j+2]=(char *) NULL;
      predefined_entitites[j+1]=(char *) NULL;
      predefined_entitites[j]=ConstantString(name);
      predefined_entitites[j+1]=ConstantString(value);
    }
  else
    {
      // Parameter entity
      xml++;
      name=xml;
      xml+=strcspn(xml,XMLWhitespace "'>");
      *xml++='\0';
      xml+=strspn(xml,XMLWhitespace);
      if (*xml == '"')
        {
          xml++;
          value=xml;
          xml=strchr(xml,'"');
          if (xml == (char *) NULL)
            {
              (void) ThrowMagickException(exception,GetMagickModule(),
                OptionWarning,"ParseError","missing \"");
              predefined_entitites=(char **) RelinquishMagickMemory(
                predefined_entitites);
              return(MagickFalse);
            }
          *xml++='\0';
        }
      else
        if (*xml == '\'')
          {
            xml++;
            value=xml;
            xml=strchr(xml,'\'');
            if (xml == (char *) NULL)
              {
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,"ParseError","missing '");
                predefined_entitites=(char **) RelinquishMagickMemory(
                  predefined_entitites);
                return(MagickFalse);
              }
            *xml++='\0';
          }
        else
          {
            (void) ThrowMagickException(exception,GetMagickModule(),
              OptionWarning,"ParseError","missing'or \"");
            predefined_entitites=(char **) RelinquishMagickMemory(
              predefined_entitites);
            return(MagickFalse);
          }
      if (strlen(name) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),
            OptionWarning,"ParseError","missing entity name");
          predefined_entitites=(char **) RelinquishMagickMemory(
            predefined_entitites);
          return(MagickFalse);
        }
      if (strlen(value) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),
            OptionWarning,"ParseError","missing entity value");
          predefined_entitites=(char **) RelinquishMagickMemory(
            predefined_entitites);
          return(MagickFalse);
        }
      j=0;
      while ((predefined_entitites[j]!= (char *) NULL) &&
             (strcmp(predefined_entitites[j],name)!= 0))
        j+=2;
      if (predefined_entitites[j]!= (char *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),
            OptionWarning,"ParseError","entity '%s' redefined",name);
          predefined_entitites=(char **) RelinquishMagickMemory(
            predefined_entitites);
          return(MagickFalse);
        }
      predefined_entitites=(char **) ResizeQuantumMemory(predefined_entitites,
        (size_t) (j+4),sizeof(*predefined_entitites));
      if (predefined_entitites == (char **) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),
            ResourceLimitError,"MemoryAllocationFailed","`%s'","");
          return(MagickFalse);
        }
      predefined_entitites[j+2]=(char *) NULL;
      predefined_entitites[j+1]=(char *) NULL;
      predefined_entitites[j]=ConstantString(name);
      predefined_entitites[j+1]=ConstantString(value);
    }
}

// Parse ATTLIST declaration
else if (strncmp(xml,"ATTLIST",7) == 0)
{
  char
    *attribute,
    *default_value,
    *element,
    *name,
    *type;

  ssize_t
    j;

  xml+=7;
  xml+=strspn(xml,XMLWhitespace);
  element=xml;
  xml+=strcspn(xml,XMLWhitespace);
  *xml++='\0';
  xml+=strspn(xml,XMLWhitespace);
  if (root->attributes[0] == (char **) NULL)
    {
      root->attributes=(char ***) AcquireCriticalMemory(sizeof(
        *root->attributes));
      *root->attributes=(char **) NULL;
    }
  j=0;
  while ((root->attributes[j]!= (char **) NULL) &&
         (strcmp(root->attributes[j][0],element)!= 0))
    j++;
  if (root->attributes[j] == (char **) NULL)
    {
      root->attributes=(char ***) ResizeQuantumMemory(root->attributes,
        (size_t) (j+2),sizeof(*root->attributes));
      if (root->attributes == (char ***) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),
            ResourceLimitError,"MemoryAllocationFailed","`%s'","");
          predefined_entitites=(char **) RelinquishMagickMemory(
            predefined_entitites);
          return(MagickFalse);
        }
      root->attributes[j]=(char **) AcquireQuantumMemory(4,sizeof(
        **root->attributes));
      if (root->attributes[j] == (char **) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),
            ResourceLimitError,"MemoryAllocationFailed","`%s'","");
          predefined_entitites=(char **) RelinquishMagickMemory(
            predefined_entitites);
          return(MagickFalse);
        }
      root->attributes[j+1]=(char **) NULL;
      root->attributes[j][0]=ConstantString(element);
      root->attributes[j][1]=(char *) root->attributes[j+1];
      root->attributes[j][2]=ConstantString("");
    }
  for ( ; ; xml++)
  {
    while ((*xml!= '\0') && (*xml!= '#') && (*xml!= '%') &&
           (*xml!= '(') && (*xml!= ')') && (*xml!= ',') &&
           (*xml!= '-') && (*xml!= '.') && (*xml!= '/') &&
           (*xml!= ':') && (*xml!= ';') && (*xml!= '=') &&
           (*xml!= '?') && (*xml!= '[') && (*xml!= ']') &&
           (*xml!= '_') && (isalnum((int) ((unsigned char) *xml)) == 0))
      xml++;
    if (*xml == '\0')
      break;
    attribute=xml;
    xml+=strcspn(xml,XMLWhitespace "'>");
    *xml++='\0';
    xml+=strspn(xml,XMLWhitespace);
    if (*xml == '#')
      {
        // Attribute type
        xml++;
        type=xml;
        xml+=strcspn(xml,XMLWhitespace "'>");
        *xml++='\0';
        xml+=strspn(xml,XMLWhitespace);
      }
    else
      {
        // Attribute name
        name=xml;
        xml+=strcspn(xml,XMLWhitespace "'>");
        *xml++='\0';
        xml+=strspn(xml,XMLWhitespace);
        if (*xml == 'C' || *xml == 'c')
          {
            // CDATA
            xml++;
            type="CDATA";
          }
        else
          if (*xml == 'E' || *xml == 'e')
            {
              // ENTITY
              xml++;
              type="ENTITY";
            }
          else
            if (*xml == 'E' || *xml == 'e')
              {
                // ENTITIES
                xml++;
                type="ENTITIES";
              }
            else
              if (*xml == 'I' || *xml == 'i')
                {
                  // ID
                  xml++;
                  type="ID";
                }
              else
                if (*xml == 'I' || *xml == 'i')
                  {
                    // IDREF
                    xml++;
                    type="IDREF";
                  }
                else
                  if (*xml == 'I' || *xml == 'i')
                    {
                      // IDREFS
                      xml++;
                      type="IDREFS";
                    }
                  else
                    if (*xml == 'N' || *xml == 'n')
                      {
                        // NMTOKEN
                        xml++;
                        type="NMTOKEN";
                      }
                    else
                      if (*xml == 'N' || *xml == 'n')
                        {
                          // NMTOKENS
                          xml++;
                          type="NMTOKENS";
                        }
                      else
                        if (*xml == 'N' || *xml == 'n')
                          {
                            // NOTATION
                            xml++;
                            type="NOTATION";
                          }
                        else
                          {
                            (void) ThrowMagickException(exception,
                              GetMagickModule(),OptionWarning,"ParseError",
                              "unknown attribute type '%s'",xml);
                            predefined_entitites=(char **) RelinquishMagickMemory(
                              predefined_entitites);
                            return(MagickFalse);
                          }
      }
    xml+=strspn(xml,XMLWhitespace);
    if (*xml == '#')
      {
        // Default value
        xml++;
        default_value=xml;
        xml+=strcspn(xml,XMLWhitespace "'>");
        *xml++='\0';
        xml+=strspn(xml,XMLWhitespace);
      }
    else
      default_value=(char *) NULL;
    j=1;
    while ((root->attributes[j]!= (char **) NULL) &&
           (strcmp(root->attributes[j][0],attribute)!= 0))
      j+=3;
    if (root->attributes[j] == (char **) NULL)
      {
        root->attributes[j]=(char **) AcquireQuantumMemory(4,sizeof(
          **root->attributes));
        if (root->attributes[j] == (char **) NULL)
          {
            (void) ThrowMagickException(exception,GetMagickModule(),
              ResourceLimitError,"MemoryAllocationFailed","`%s'","");
            predefined_entitites=(char **) RelinquishMagickMemory(
              predefined_entitites);
            return(MagickFalse);
          }
        root->attributes[j+1]=(char *) NULL;
        root->attributes[j][0]=ConstantString(attribute);
        root->attributes[j][1]=ConstantString(type);
        root->attributes[j][2]=ConstantString(default_value);
      }
    else
      {
        if (root->attributes[j][1]!=