// Parse through the XML string to identify and process different components of a DOCTYPE declaration.
// When encountering an ENTITY declaration, parse and store the entity definitions in the appropriate data structure.
// Handle both parameter and general entities, updating predefined entities as needed.
// Validate entity definitions and handle any errors or circular declarations appropriately.
// For ATTLIST declarations, parse and store default attributes, managing memory for new attribute tags as necessary.
// Ensure that malformed or incomplete declarations are handled by throwing appropriate exceptions.
// Process comments and processing instructions by identifying their boundaries and calling appropriate processing functions.
// Continue parsing until the end of the DOCTYPE declaration or the input string is reached.

// Parse ENTITY declaration
if (strncmp(xml,"ENTITY",6) == 0)
{
  char
    *entity,
    *name,
    *value;

  ssize_t
    j;

  p+=6;
  p+=strspn(p,XMLWhitespace);
  if (*p == '%')
    {
      // Parameter entity
      p++;
      p+=strspn(p,XMLWhitespace);
      name=p;
      p+=strcspn(p,XMLWhitespace ">");
      *p='\0';
      p+=strspn(p,XMLWhitespace);
      if (*p!= '"')
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","missing \"");
          continue;
        }
      p++;
      value=p;
      p+=strcspn(p,"\"");
      *p='\0';
      p++;
      if (root->entities[0] == (char *) NULL)
        {
          root->entities=(char **) AcquireMagickMemory(3*sizeof(*root->entities));
          if (root->entities == (char **) NULL)
            ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
          root->entities[2]=(char *) NULL;
        }
      else
        {
          j=0;
          while (root->entities[j]!= (char *) NULL)
            j+=2;
          root->entities=(char **) ResizeQuantumMemory(root->entities,
            (size_t) (j+3),sizeof(*root->entities));
          if (root->entities == (char **) NULL)
            ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
          root->entities[j+2]=(char *) NULL;
        }
      root->entities[j]=ConstantString(name);
      root->entities[j+1]=ConstantString(value);
      if (ValidateEntities(name,value,0,root->entities) == MagickFalse)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","circular entity reference");
          continue;
        }
    }
  else
    {
      // General entity
      name=p;
      p+=strcspn(p,XMLWhitespace ">");
      *p='\0';
      p+=strspn(p,XMLWhitespace);
      if (*p!= '"')
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","missing \"");
          continue;
        }
      p++;
      value=p;
      p+=strcspn(p,"\"");
      *p='\0';
      p++;
      if (root->entities[0] == (char *) NULL)
        {
          root->entities=(char **) AcquireMagickMemory(3*sizeof(*root->entities));
          if (root->entities == (char **) NULL)
            ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
          root->entities[2]=(char *) NULL;
        }
      else
        {
          j=0;
          while (root->entities[j]!= (char *) NULL)
            j+=2;
          root->entities=(char **) ResizeQuantumMemory(root->entities,
            (size_t) (j+3),sizeof(*root->entities));
          if (root->entities == (char **) NULL)
            ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
          root->entities[j+2]=(char *) NULL;
        }
      root->entities[j]=ConstantString(name);
      root->entities[j+1]=ConstantString(value);
      if (ValidateEntities(name,value,0,root->entities) == MagickFalse)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","circular entity reference");
          continue;
        }
    }
}

// Parse ATTLIST declaration
else if (strncmp(xml,"ATTLIST",7) == 0)
{
  char
    *attribute,
    *default_value,
    *element,
    *type;

  ssize_t
    j;

  p+=7;
  p+=strspn(p,XMLWhitespace);
  element=p;
  p+=strcspn(p,XMLWhitespace ">");
  *p='\0';
  p+=strspn(p,XMLWhitespace);
  if (root->attributes[0] == (char **) NULL)
    {
      root->attributes=(char ***) AcquireMagickMemory(2*sizeof(*root->attributes));
      if (root->attributes == (char ***) NULL)
        ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
      root->attributes[1]=(char **) NULL;
    }
  else
    {
      j=0;
      while (root->attributes[j]!= (char **) NULL)
        j++;
      root->attributes=(char ***) ResizeQuantumMemory(root->attributes,
        (size_t) (j+2),sizeof(*root->attributes));
      if (root->attributes == (char ***) NULL)
        ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
      root->attributes[j+1]=(char **) NULL;
    }
  root->attributes[j]=(char **) AcquireMagickMemory(4*sizeof(**root->attributes));
  if (root->attributes[j] == (char **) NULL)
    ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
  root->attributes[j][0]=ConstantString(element);
  root->attributes[j][1]=(char *) NULL;
  root->attributes[j][2]=(char *) NULL;
  root->attributes[j][3]=(char *) NULL;
  p+=strspn(p,XMLWhitespace);
  attribute=p;
  p+=strcspn(p,XMLWhitespace ">");
  *p='\0';
  p+=strspn(p,XMLWhitespace);
  type=p;
  p+=strcspn(p,XMLWhitespace ">");
  *p='\0';
  p+=strspn(p,XMLWhitespace);
  if (*p == '#')
    {
      p++;
      if (strncmp(p,"REQUIRED",8) == 0)
        default_value=(char *) NULL;
      else if (strncmp(p,"IMPLIED",7) == 0)
        default_value=(char *) NULL;
      else if (strncmp(p,"FIXED",5) == 0)
        {
          p+=5;
          p+=strspn(p,XMLWhitespace "\"'");
          if (*p!= '"' && *p!= '\'')
            {
              (void) ThrowMagickException(exception,GetMagickModule(),
                OptionWarning,"ParseError","missing \"");
              continue;
            }
          default_value=p+1;
          p+=strcspn(p+1,"\"'");
          *p='\0';
        }
      else
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","unexpected #");
          continue;
        }
    }
  else
    {
      if (*p!= '"')
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","missing \"");
          continue;
        }
      p++;
      default_value=p;
      p+=strcspn(p,"\"");
      *p='\0';
    }
  root->attributes[j][1]=ConstantString(attribute);
  root->attributes[j][2]=ConstantString(type);
  root->attributes[j][3]=ConstantString(default_value);
}

// Parse comment
else if (strncmp(xml,"<!--",4) == 0)
{
  p=strstr(p+4,"--");
  if (p == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        "ParseError","unclosed <!--");
      continue;
    }
  p+=2;
}

// Parse processing instruction
else if (*p == '?')
{
  p=strstr(p+1,"?>");
  if (p == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        "ParseError","unclosed <?");
      continue;
    }
  ParseProcessingInstructions(root,xml+1,(size_t) (p-xml-2));
  p+=2;
}

// Parse end of DOCTYPE declaration
else if (*p == ']')
{
  p++;
  if (*p!= '>')
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        "ParseError","missing >");
      continue;
    }
  p++;
  break;
}