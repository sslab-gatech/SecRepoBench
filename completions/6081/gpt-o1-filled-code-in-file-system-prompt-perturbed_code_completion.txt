/*
      Skip leading whitespace.
    */
    while (isspace((int) (unsigned char) *xml) != 0)
      xml++;
    if (*xml == '\0')
      break;

    /*
      Check for comment: <!-- ... -->
    */
    if (strncmp(xml,"--",2) == 0)
    {
      c=strstr(xml+2,"--");
      if (c == (char *) NULL)
        break;
      c+=2;
      if (*c == '>')
        c++;
      xml=c;
      continue;
    }

    /*
      Check for ENTITY declaration: <!ENTITY ...
    */
    if (strncasecmp(xml,"ENTITY",6) == 0)
    {
      MagickBooleanType
        parameter = MagickFalse;

      xml+=6;
      while (isspace((int) (unsigned char) *xml) != 0)
        xml++;
      /*
        Check for parameter entity: <!ENTITY % name ...
      */
      if (*xml == '%')
      {
        parameter=MagickTrue;
        xml++;
        while (isspace((int) (unsigned char) *xml) != 0)
          xml++;
      }
      /*
        Parse entity name.
      */
      t=xml;
      while ((*xml != '\0') && !isspace((int) (unsigned char) *xml) &&
             (*xml != '\"') && (*xml != '\'') && (*xml != '>'))
        xml++;
      if (*xml == '\0')
        break;
      *xml++='\0';
      while (isspace((int) (unsigned char) *xml) != 0)
        xml++;
      /*
        Parse quoted value.
      */
      q=(*xml);
      if ((q != '\"') && (q != '\''))
        break;
      xml++;
      v=xml;
      c=strchr(xml,q);
      if (c == (char *) NULL)
        break;
      *c='\0';
      xml=c+1;

      /*
        Store entity in root->entities.
      */
      if ((t[0] != '\0') && (v[0] != '\0'))
      {
        i=0;
        entities=root->entities;
        while (entities[i] != (char *) NULL)
          i+=2;
        entities=(char **) ResizeQuantumMemory(entities,(size_t) (i+4),
          sizeof(*entities));
        if (entities == (char **) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),
            ResourceLimitError,"MemoryAllocationFailed","`%s'","");
          break;
        }
        entities[i]=ConstantString(t);
        entities[i+1]=ConstantString(v);
        entities[i+2]=(char *) NULL;
        entities[i+3]=(char *) NULL;
        root->entities=entities;
        /*
          Validate for circular references.
        */
        if (ValidateEntities(t,v,0,root->entities) == MagickFalse)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),
            OptionWarning,"ParseError","circular entity declaration `%s'",t);
          break;
        }
      }
      /*
        Skip to next '>'.
      */
      c=strchr(xml,'>');
      if (c == (char *) NULL)
        break;
      xml=c+1;
      continue;
    }

    /*
      Check for ATTLIST declaration: <!ATTLIST ...
      (Here, we only skip over it; a full parser would store default attributes.)
    */
    if (strncasecmp(xml,"ATTLIST",7) == 0)
    {
      xml+=7;
      while ((*xml != '\0') && (*xml != '>'))
        xml++;
      if (*xml == '>')
        xml++;
      continue;
    }

    /*
      Check for NOTATION or other constructs; skip their content up to '>'.
    */
    if (strncasecmp(xml,"NOTATION",8) == 0)
    {
      xml+=8;
      while ((*xml != '\0') && (*xml != '>'))
        xml++;
      if (*xml == '>')
        xml++;
      continue;
    }

    /*
      Otherwise, skip until next '>' if present.
    */
    c=strchr(xml,'>');
    if (c == (char *) NULL)
      break;
    xml=c+1;