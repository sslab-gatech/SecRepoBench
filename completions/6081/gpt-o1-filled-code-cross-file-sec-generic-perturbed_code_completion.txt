c=xml;
    while (*c != '\0')
    {
      /* Skip leading whitespace */
      while (isspace((unsigned char)*c))
        c++;

      /* If we've reached the end or encountered the closing bracket, stop */
      if (*c == '\0' || *c == '>')
      {
        if (*c == '>')
          c++;
        break;
      }

      /* Look for a comment: <!-- ... --> */
      if ((strncmp(c,"<!--",4) == 0))
      {
        char *comment_end=strstr(c+4,"-->");
        if (comment_end == (char *) NULL)
        {
          /* Malformed or incomplete comment, stop parsing. */
          break;
        }
        /* Advance the pointer past the comment block */
        c = comment_end+3;
        continue;
      }

      /* Look for an ENTITY declaration: <!ENTITY or <!ENTITY % ...> */
      if (strncasecmp(c,"<!ENTITY",8) == 0)
      {
        char
          entity_name[256],
          entity_value[1024];

        MagickBooleanType
          is_parameter_entity=MagickFalse;

        ssize_t
          offset=8,
          name_length=0,
          value_length=0;

        /* Advance past "<!ENTITY" */
        c += offset;

        /* Skip any spaces */
        while (isspace((unsigned char)*c))
          c++;

        /* Check if it's a parameter entity (<!ENTITY % ...) */
        if (*c == '%')
        {
          is_parameter_entity=MagickTrue;
          c++;
          while (isspace((unsigned char)*c))
            c++;
        }

        /* Parse the entity name */
        while ((*c != '\0') && !isspace((unsigned char)*c) &&
               (*c != '"') && (*c != '\'') && (*c != '>') &&
               (name_length < (ssize_t) (sizeof(entity_name)-1)))
        {
          entity_name[name_length++]=*c++;
        }
        entity_name[name_length]='\0';

        /* Skip whitespaces until we find the quote that starts the value */
        while (isspace((unsigned char)*c))
          c++;
        if ((*c != '"') && (*c != '\''))
        {
          /* Malformed entity declaration, stop parsing. */
          break;
        }

        /* Determine which quote char is used */
        q = *c;
        c++;

        /* Parse the entity value until the matching quote */
        while ((*c != '\0') && (*c != q) &&
               (value_length < (ssize_t) (sizeof(entity_value)-1)))
        {
          entity_value[value_length++]=*c++;
        }
        entity_value[value_length]='\0';

        /* If we didn't find the closing quote, malformed declaration */
        if (*c != q)
          break;
        c++;

        /* Skip until the end of the entity declaration (looking for '>') */
        while ((*c != '\0') && (*c != '>'))
          c++;
        if (*c == '>')
          c++;

        /*
          At this point, entity_name holds the parsed name and
          entity_value the parsed value. Store them as needed:
          - For parameter entities or general entities, we can store them
            in root->entities or update predefined_entitites, checking
            for duplicates or other constraints.
          - Validate or handle circular references as needed.
        */

        /* Example: append to root->entities if appropriate */
        {
          ssize_t idx=0;
          while (root->entities[idx] != (char *) NULL)
            idx++;
          {
            char **new_entities=(char **) ResizeQuantumMemory(root->entities,
              (size_t) idx+3,sizeof(*new_entities));
            if (new_entities == (char **) NULL)
              break;
            root->entities=new_entities;
            /* Store the new entity in a "name=value" form or other scheme */
            {
              size_t combined_len=strlen(entity_name)+strlen(entity_value)+2;
              char *combined=(char *) AcquireQuantumMemory(combined_len,
                sizeof(*combined));
              if (combined == (char *) NULL)
                break;
              (void) FormatLocaleString(combined,combined_len,"%s=%s",
                entity_name,entity_value);
              root->entities[idx]=combined;
              root->entities[idx+1]=(char *) NULL;
            }
          }
        }
        continue;
      }

      /* Look for an ATTLIST declaration: <!ATTLIST ...> */
      if (strncasecmp(c,"<!ATTLIST",9) == 0)
      {
        /* Advance past "<!ATTLIST" */
        c += 9;
        /* Skip spaces and parse ATTLIST content as needed */
        while (isspace((unsigned char)*c))
          c++;

        /*
          Parse the element name, then attribute definitions, including
          default values or #IMPLIED, etc. Allocate new attribute storage
          for the associated element if required.
        */

        /* For now, simply skip until next '>' */
        while ((*c != '\0') && (*c != '>'))
          c++;
        if (*c == '>')
          c++;
        continue;
      }

      /*
        If none of the recognized declarations match, move forward:
        Could be another markup declaration or unrecognized text in the
        DOCTYPE. This simplistic approach just skips until the next '<'.
      */
      {
        char *next_decl=strchr(c,'<');
        if (next_decl == (char *) NULL)
          break;
        c=next_decl;
      }
    }
    xml=c;