for (c=xml; *c != '\0'; c++)
  {
    if (*c == '<')
    {
      if (strncmp(c,"<!DOCTYPE",8) == 0)
      {
        // Process DOCTYPE declaration
        c += 8;
        ParseOpenTag(root,"DOCTYPE",(char **) NULL);
        while (*c != '\0' && *c != '>')
        {
          if (*c == '[')
          {
            // Process internal subset
            c++;
            ParseInternalSubset(root,c,&length,exception);
            c++;
          }
          else if (*c == '(')
          {
            // Process parameter entity reference
            c++;
            ParseParameterEntityReference(root,c,&length,exception);
            c++;
          }
          else if (*c == '[')
          {
            // Process conditional section
            c++;
            ParseConditionalSection(root,c,&length,exception);
            c++;
          }
          else if (*c == '>')
          {
            // End of DOCTYPE declaration
            break;
          }
          else
          {
            // Invalid character in DOCTYPE declaration
            ThrowXMLTreeException(ParseError,"InvalidCharacterInDoctypeDeclaration",
              xml,exception);
          }
        }
        if (*c == '>')
          c++;
        PruneTagFromXMLTree(root->node);
      }
      else if (strncmp(c,"<![CDATA[",8) == 0)
      {
        // Process CDATA section
        c += 8;
        ParseCDATASection(root,c,&length,exception);
        c += strlen(c) - 1; // Skip ']]>'
      }
      else if (strncmp(c,"<!--",4) == 0)
      {
        // Process comment
        c += 4;
        ParseComment(root,c,&length,exception);
        c += strlen(c) - 2; // Skip '-->'
      }
      else if (strncmp(c,"<?",2) == 0)
      {
        // Process processing instruction
        c += 2;
        ParseProcessingInstruction(root,c,&length,exception);
        c += strlen(c) - 2; // Skip '?>'
      }
      else
      {
        // Process element
        ParseOpenTag(root,c,&attributes);
        while (*c != '\0' && *c != '>')
        {
          if (*c == '/')
          {
            // Self-closing tag
            c++;
            ParseCloseTag(root,c,&length,exception);
            break;
          }
          else if (*c == '>')
          {
            // End of element
            c++;
            break;
          }
          else if (*c == ' ')
          {
            // Process attribute
            c++;
            ParseAttribute(root,c,&length,exception,&attributes);
          }
          else
          {
            // Invalid character in element
            ThrowXMLTreeException(ParseError,"InvalidCharacterInElement",
              xml,exception);
          }
        }
        if (*c == '>')
          c++;
        ParseCloseTag(root,c,&length,exception);
      }
    }
  }