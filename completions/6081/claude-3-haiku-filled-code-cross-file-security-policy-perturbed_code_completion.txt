// <MASK>
while (xml != (char *) NULL)
{
  // Check if the current character is the start of a DOCTYPE declaration
  if (strncmp(xml, "<!DOCTYPE", 9) == 0)
  {
    // Parse the DOCTYPE declaration
    c = xml + 9;
    while (*c != '>')
    {
      // Check for ENTITY declarations
      if (strncmp(c, "<!ENTITY", 8) == 0)
      {
        // Parse the ENTITY declaration and store the entity definition
        c += 8;
        while (isspace(*c))
          c++;
        if (*c == '%')
        {
          // Parameter entity
          c++;
          while (isspace(*c))
            c++;
          n = c;
          while (*c != ';' && *c != '>')
            c++;
          if (*c == ';')
          {
            *c = '\0';
            entities = (char **)AcquireMagickMemory(sizeof(char *) * (size_t)(index + 2));
            if (entities == (char **)NULL)
              ThrowFatalException(ResourceLimitError, "MemoryAllocationFailed");
            if (index > 0)
              (void)CopyMagickMemory(entities, predefined_entitites, sizeof(char *) * (size_t)index);
            entities[index++] = ConstantString(n);
            entities[index] = (char *)NULL;
            predefined_entitites = (char **)RelinquishMagickMemory(predefined_entitites);
            predefined_entitites = entities;
          }
        }
        else
        {
          // General entity
          n = c;
          while (*c != ';' && *c != '>')
            c++;
          if (*c == ';')
          {
            *c = '\0';
            entities = (char **)AcquireMagickMemory(sizeof(char *) * (size_t)(index + 2));
            if (entities == (char **)NULL)
              ThrowFatalException(ResourceLimitError, "MemoryAllocationFailed");
            if (index > 0)
              (void)CopyMagickMemory(entities, predefined_entitites, sizeof(char *) * (size_t)index);
            entities[index++] = ConstantString(n);
            entities[index] = (char *)NULL;
            predefined_entitites = (char **)RelinquishMagickMemory(predefined_entitites);
            predefined_entitites = entities;
          }
        }
      }
      // Check for ATTLIST declarations
      else if (strncmp(c, "<!ATTLIST", 8) == 0)
      {
        // Parse the ATTLIST declaration and store the default attributes
        c += 8;
        while (isspace(*c))
          c++;
        n = c;
        while (*c != '>' && !isspace(*c))
          c++;
        q = *c;
        *c = '\0';
        ParseOpenTag(root, n, sentinel);
        *c = q;
      }
      // Handle comments and processing instructions
      else if (strncmp(c, "<!--", 4) == 0)
      {
        // Parse the comment and call the appropriate processing function
        c += 4;
        t = c;
        while (strncmp(c, "-->", 3) != 0 && *c != '\0')
          c++;
        if (*c != '\0')
        {
          *c = '\0';
          c += 3;
          ProcessComment(root, t);
        }
        else
          break;
      }
      else if (strncmp(c, "<?", 2) == 0)
      {
        // Parse the processing instruction and call the appropriate processing function
        c += 2;
        t = c;
        while (strncmp(c, "?>", 2) != 0 && *c != '\0')
          c++;
        if (*c != '\0')
        {
          *c = '\0';
          c += 2;
          ProcessProcessingInstruction(root, t);
        }
        else
          break;
      }
      else
      {
        // Encountered an unexpected token, throw an exception
        ThrowException(exception, CorruptImageError, "UnexpectedElement", xml);
        break;
      }
      while (isspace(*c))
        c++;
    }
    if (*c == '>')
      c++;
    xml = c;
  }
  else
  {
    // Encountered an unexpected token, throw an exception
    ThrowException(exception, CorruptImageError, "UnexpectedElement", xml);
    break;
  }
}
// </MASK>