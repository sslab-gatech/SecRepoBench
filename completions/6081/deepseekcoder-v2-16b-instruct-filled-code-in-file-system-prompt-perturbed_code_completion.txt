+3]=(char *) NULL;
              else
                {
                  *p++='\0';
                  p+=strspn(p,XMLWhitespace);
                  if ((*p == '\'') || (*p == '"'))
                    {
                      q=*p++;
                      attributes[l+3]=p;
                      p+=strcspn(p,q);
                      *p++=q;
                    }
                  else
                    {
                      attributes[l+3]=p;
                      p+=strcspn(p,XMLWhitespace);
                    }
                }
            }
            if ((*p == '/') && (*(p+1) == '>'))
              {
                /*
                  Empty element.
                */
                ParseCharacterContent(root,tag,l,0);
                p+=2;
              }
            else
              {
                /*
                  Start element.
                */
                ParseOpenTag(root,tag,attributes);
                p+=strspn(p,XMLWhitespace);
                if ((*p == '>') && (isspace((int) ((unsigned char) *(p+1)) == 0)))
                  {
                    ParseCharacterContent(root,p+1,strlen(p+1),' ');
                    p+=strlen(p+1)+1;
                  }
              }
            if (IsSkipTag(tag) == MagickTrue)
              ignore_depth++;
            else
              ignore_depth=0;
          }
        else
          {
            p+=strspn(p,XMLWhitespace);
            if ((*p == '>') && (isspace((int) ((unsigned char) *(p+1)) == 0)))
              {
                ParseCharacterContent(root,p+1,strlen(p+1),' ');
                p+=strlen(p+1)+1;
              }
            if (ignore_depth > 0)
              ignore_depth--;
          }
      }
    else
      if ((*p == '<') && (*(p+1) == '?'))
        {
          /*
            Processing instructions.
          */
          p+=2;
          p+=strspn(p,XMLWhitespace);
          ParseProcessingInstructions(root,p,strlen(p));
          p+=strlen(p);
        }
      else
        if ((*p == '<') && (*(p+1) == '!'))
          {
            /*
              Doctype.
            */
            p+=2;
            p+=strspn(p,XMLWhitespace);
            if (strncmp(p,"DOCTYPE",7) == 0)
              {
                p+=7;
                p+=strspn(p,XMLWhitespace);
                if ((*p == '[') && (strncmp(p,"[",1) == 0))
                  {
                    p+=1;
                    p+=strspn(p,XMLWhitespace);
                    if (strncmp(p,"SYSTEM",6) == 0)
                      {
                        p+=6;
                        p+=strspn(p,XMLWhitespace);
                        if ((*p == '\'') || (*p == '"'))
                          {
                            q=*p++;
                            p+=strcspn(p,q);
                            *p++=q;
                          }
                        else
                          {
                            p+=strcspn(p,XMLWhitespace);
                          }
                      }
                    else
                      if (strncmp(p,"PUBLIC",6) == 0)
                        {
                          p+=6;
                          p+=strspn(p,XMLWhitespace);
                          if ((*p == '\'') || (*p == '"'))
                            {
                              q=*p++;
                              p+=strcspn(p,q);
                              *p++=q;
                            }
                          else
                            {
                              p+=strcspn(p,XMLWhitespace);
                            }
                        }
                    if ((*p == '>') && (isspace((int) ((unsigned char) *(p+1)) == 0)))
                      {
                        ParseCharacterContent(root,p+1,strlen(p+1),' ');
                        p+=strlen(p+1)+1;
                      }
                    ParseInternalDoctype(root,p,strlen(p),exception);
                  }
                else
                  {
                    ParseCharacterContent(root,p,strlen(p),' ');
                    p+=strlen(p);
                  }
              }
            else
              {
                ParseCharacterContent(root,p,strlen(p),' ');
                p+=strlen(p);
              }
          }
        else
          if ((*p == '<') && (*(p+1) == '/'))
            {
              /*
                Close tag.
              */
              p+=2;
              p+=strspn(p,XMLWhitespace);
              tag=p;
              p+=strcspn(p,XMLWhitespace ">");
              *p++='\0';
              p+=strspn(p,XMLWhitespace);
              if ((*p == '>') && (isspace((int) ((unsigned char) *(p+1)) == 0)))
                {
                  ParseCharacterContent(root,p+1,strlen(p+1),' ');
                  p+=strlen(p+1)+1;
                }
              if (IsSkipTag(tag) == MagickTrue)
                ignore_depth++;
              else
                ignore_depth=0;
              if (root->node != (XMLTreeInfo *) NULL)
                {
                  if (strcmp(root->node->tag,tag) == 0)
                    {
                      if (ParseCloseTag(root,tag,exception) == &root->root)
                        break;
                    }
                  else
                    {
                      if (ignore_depth == 0)
                        {
                          (void) ThrowMagickException(exception,
                            GetMagickModule(),OptionWarning,"ParseError",
                            "unexpected closing tag </%s>",tag);
                        }
                    }
                }
            }
          else
            {
              /*
                Character content.
              */
              ParseCharacterContent(root,p,strlen(p),'*');
              p+=strlen(p);
            }
    if (*p == '\0')
      break;
  }
  utf8=DestroyString(utf8);
  if (root->node == (XMLTreeInfo *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        "ParseError","root tag missing");
      return((XMLTreeInfo *) NULL);
    }
  return(&root->root);
}

static XMLTreeInfo *NewXMLTreeTag(const char *tag)
{
  XMLTreeInfo
    *xml_info;

  xml_info=(XMLTreeInfo *) AcquireMagickMemory(sizeof(*xml_info));
  if (xml_info == (XMLTreeInfo *) NULL)
    return((XMLTreeInfo *) NULL);
  (void) ResetMagickMemory(xml_info,0,sizeof(*xml_info));
  xml_info->tag=ConstantString(tag);
  xml_info->attributes=sentinel;
  xml_info->content=ConstantString("");
  xml_info->debug=IsEventLogging();
  xml_info->signature=MagickCoreSignature;
  return(xml_info);
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   P r i n t X M L T r e e                                                   %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  PrintXMLTree() prints the XML tree to the specified file stream.
%
%  The format of the PrintXMLTree method is:
%
%      void PrintXMLTree(FILE *file,XMLTreeInfo *xml_info)
%
%  A description of each parameter follows:
%
%    o file: the file stream.
%
%    o xml_info: the xml info.
%
*/
MagickExport void PrintXMLTree(FILE *file,XMLTreeInfo *xml_info)
{
  if (xml_info == (XMLTreeInfo *) NULL)
    return;
  (void) fprintf(file,"<%s",xml_info->tag);
  if (xml_info->attributes != sentinel)
    {
      for (register ssize_t i=0; xml_info->attributes[i] != (char *) NULL; i+=2)
        (void) fprintf(file," %s=\"%s\"",xml_info->attributes[i],
          xml_info->attributes[i+1]);
    }
  if ((xml_info->child == (XMLTreeInfo *) NULL) &&
      (xml_info->content == (char *) NULL) &&
      (xml_info->sibling == (XMLTreeInfo *) NULL))
    (void) fprintf(file,">\n");
  else
    {
      (void) fprintf(file,">\n");
      if (xml_info->content != (char *) NULL)
        (void) fprintf(file,"%s\n",xml_info->content);
      if (xml_info->child != (XMLTreeInfo *) NULL)
        PrintXMLTree(file,xml_info->child);
      if (xml_info->sibling != (XMLTreeInfo *) NULL)
        PrintXMLTree(file,xml_info->sibling);
      (void) fprintf(file,"</%s>\n",xml_info->tag);
    }
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   R e m o v e X M L T r e e T a g                                         %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  RemoveXMLTreeTag() removes a tag from the XML tree.
%
%  The format of the RemoveXMLTreeTag method is:
%
%      XMLTreeInfo *RemoveXMLTreeTag(XMLTreeInfo *xml_info,const char *tag)
%
%  A description of each parameter follows:
%
%    o xml_info: the xml info.
%
%    o tag: the tag.
%
*/
MagickExport XMLTreeInfo *RemoveXMLTreeTag(XMLTreeInfo *xml_info,const char *tag)
{
  XMLTreeInfo
    *child,
    *node,
    *previous;

  assert(xml_info != (XMLTreeInfo *) NULL);
  assert((xml_info->signature == MagickCoreSignature) ||
         (((XMLTreeRoot *) xml_info)->signature == MagickCoreSignature));
  if (xml_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),"...");
  if (xml_info->child != (XMLTreeInfo *) NULL)
    {
      child=xml_info->child;
      while ((child != (XMLTreeInfo *) NULL) && (strcmp(child->tag,tag) != 0))
        child=child->sibling;
      if (child != (XMLTreeInfo *) NULL)
        {
          if (child->parent != xml_info)
            return(xml_info);
          if (child->child != (XMLTreeInfo *) NULL)
            child->child=RemoveXMLTreeTag(child->child,tag);
          if (child->ordered != (XMLTreeInfo *) NULL)
            child->ordered=RemoveXMLTreeTag(child->ordered,tag);
          if (child->sibling != (XMLTreeInfo *) NULL)
            child->sibling=RemoveXMLTreeTag(child->sibling,tag);
          if (child->next != (XMLTreeInfo *) NULL)
            child->next=RemoveXMLTreeTag(child->next,tag);
          node=child->sibling;
          previous=child->parent;
          if (previous != (XMLTreeInfo *) NULL)
            {
              if (previous->child == child)
                previous->child=node;
              else
                {
                  while ((previous->sibling != child) && (previous != (XMLTreeInfo *) NULL))
                    previous=previous->sibling;
                  if (previous != (XMLTreeInfo *) NULL)
                    previous->sibling=node;
                }
            }
          child=(XMLTreeInfo *) RelinquishMagickMemory(child);
          return(xml_info);
        }
    }
  return(xml_info);
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   S e t X M L T r e e A t t r i b u t e                                     %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  SetXMLTreeAttribute() sets the value of the attribute tag with the
%  specified tag.
%
%  The format of the SetXMLTreeAttribute method is:
%
%      MagickBooleanType SetXMLTreeAttribute(XMLTreeInfo *xml_info,
%        const char *tag,const char *value)