static MagickBooleanType ParseInternalDoctype(XMLTreeRoot *root,char *xml,
  size_t length,ExceptionInfo *exception)
{
  char
    *c,
    **entities,
    *n,
    **predefined_entitites,
    q,
    *t,
    *v;

  register ssize_t
    i;

  ssize_t
    index;

  n=(char *) NULL;
  predefined_entitites=(char **) AcquireMagickMemory(sizeof(sentinel));
  if (predefined_entitites == (char **) NULL)
    ThrowFatalException(ResourceLimitError,"MemoryAllocationFailed");
  (void) CopyMagickMemory(predefined_entitites,sentinel,sizeof(sentinel));
  for (xml[length]='\0'; xml!= (char *) NULL; )
  {
    // Parse through the XML string to identify and process different components of a DOCTYPE declaration.
    // When encountering an ENTITY declaration, parse and store the entity definitions in the appropriate data structure.
    // Handle both parameter and general entities, updating predefined entities as needed.
    // Validate entity definitions and handle any errors or circular declarations appropriately.
    // For ATTLIST declarations, parse and store default attributes, managing memory for new attribute tags as necessary.
    // Ensure that malformed or incomplete declarations are handled by throwing appropriate exceptions.
    // Process comments and processing instructions by identifying their boundaries and calling appropriate processing functions.
    // Continue parsing until the end of the DOCTYPE declaration or the input string is reached.
    // <MASK>
    // Parse ENTITY declarations
    if (strncmp(xml,"<!ENTITY",9) == 0)
    {
      // Extract entity name and value
      xml+=9;
      t=strchr(xml,'>');
      if (t == (char *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","unclosed ENTITY declaration");
          return(MagickFalse);
        }
      *t='\0';
      t=strchr(xml,' ');
      if (t == (char *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","missing entity name");
          return(MagickFalse);
        }
      v=strchr(t,' ');
      if (v == (char *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","missing entity value");
          return(MagickFalse);
        }
      *v='\0';
      t++;
      // Check for parameter entity
      if (strncmp(t,"%",1) == 0)
        {
          // Parse parameter entity
          n=ParseEntities(t+1,predefined_entitites,'%');
          if (n == (char *) NULL)
            {
              (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
                "ParseError","invalid parameter entity");
              return(MagickFalse);
            }
          // Add entity to list
          i=0;
          while ((predefined_entitites[i]!= (char *) NULL) &&
                 (strncmp(predefined_entitites[i],v,strlen(v))!= 0))
            i+=2;
          if (predefined_entitites[i]!= (char *) NULL)
            {
              (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
                "ParseError","circular entity reference");
              return(MagickFalse);
            }
          predefined_entitites[i+1]=n;
        }
      else
        {
          // Parse general entity
          n=ParseEntities(v,predefined_entitites,'&');
          if (n == (char *) NULL)
            {
              (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
                "ParseError","invalid general entity");
              return(MagickFalse);
            }
          // Add entity to list
          i=0;
          while ((predefined_entitites[i]!= (char *) NULL) &&
                 (strncmp(predefined_entitites[i],v,strlen(v))!= 0))
            i+=2;
          if (predefined_entitites[i]!= (char *) NULL)
            {
              (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
                "ParseError","circular entity reference");
              return(MagickFalse);
            }
          predefined_entitites[i+1]=n;
        }
    }
    // Parse ATTLIST declarations
    else if (strncmp(xml,"<!ATTLIST",9) == 0)
    {
      // Extract element name and attribute list
      xml+=9;
      t=strchr(xml,'>');
      if (t == (char *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","unclosed ATTLIST declaration");
          return(MagickFalse);
        }
      *t='\0';
      t=strchr(xml,' ');
      if (t == (char *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","missing element name");
          return(MagickFalse);
        }
      v=strchr(t,' ');
      if (v == (char *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","missing attribute list");
          return(MagickFalse);
        }
      *v='\0';
      t++;
      // Parse attribute list
      while (t!= (char *) NULL)
      {
        // Extract attribute name and value
        v=strchr(t,' ');
        if (v == (char *) NULL)
          {
            (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
              "ParseError","missing attribute name");
            return(MagickFalse);
          }
        *v='\0';
        v++;
        // Check for default value
        if (strncmp(v,"#",1) == 0)
          {
            // Parse default value
            v+=2;
            n=ParseEntities(v,predefined_entitites,'&');
            if (n == (char *) NULL)
              {
                (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
                  "ParseError","invalid default value");
                return(MagickFalse);
              }
            // Add attribute to list
            i=0;
            while ((root->attributes[i]!= (char **) NULL) &&
                   (strcmp(root->attributes[i][0],t)!= 0))
              i++;
            if (root->attributes[i] == (char **) NULL)
              {
                root->attributes=(char ***) AcquireCriticalMemory(sizeof(
                  *root->attributes));
                *root->attributes=(char **) NULL;
              }
            root->attributes[i]=(char **) AcquireQuantumMemory(4,
              sizeof(**root->attributes));
            if (root->attributes[i] == (char **) NULL)
              ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
            root->attributes[i][0]=ConstantString(t);
            root->attributes[i][1]=(char *) NULL;
            root->attributes[i][2]=ConstantString("");
            root->attributes[i][3]=(char *) NULL;
            root->attributes[i+1]=(char **) NULL;
            root->attributes[i+2]=(char **) NULL;
            root->attributes[i+3]=(char **) NULL;
            root->attributes[i][1]=n;
          }
        else
          {
            // Parse attribute value
            n=ParseEntities(v,predefined_entitites,'&');
            if (n == (char *) NULL)
              {
                (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
                  "ParseError","invalid attribute value");
                return(MagickFalse);
              }
            // Add attribute to list
            i=0;
            while ((root->attributes[i]!= (char **) NULL) &&
                   (strcmp(root->attributes[i][0],t)!= 0))
              i++;
            if (root->attributes[i] == (char **) NULL)
              {
                root->attributes=(char ***) AcquireCriticalMemory(sizeof(
                  *root->attributes));
                *root->attributes=(char **) NULL;
              }
            root->attributes[i]=(char **) AcquireQuantumMemory(4,
              sizeof(**root->attributes));
            if (root->attributes[i] == (char **) NULL)
              ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
            root->attributes[i][0]=ConstantString(t);
            root->attributes[i][1]=(char *) NULL;
            root->attributes[i][2]=ConstantString("");
            root->attributes[i][3]=(char *) NULL;
            root->attributes[i+1]=(char **) NULL;
            root->attributes[i+2]=(char **) NULL;
            root->attributes[i+3]=(char **) NULL;
            root->attributes[i][1]=n;
          }
        // Skip to next attribute
        t=strchr(v,' ');
        if (t == (char *) NULL)
          break;
        *t='\0';
        t++;
      }
    }
    // Parse comments
    else if (strncmp(xml,"<!--",4) == 0)
    {
      // Extract comment text
      xml+=4;
      t=strchr(xml,'--');
      if (t == (char *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","unclosed comment");
          return(MagickFalse);
        }
      *t='\0';
      t++;
      // Skip to next comment
      xml=strchr(xml,'>');
      if (xml == (char *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","unclosed comment");
          return(MagickFalse);
        }
      xml++;
    }
    // Parse processing instructions
    else if (strncmp(xml,"<?",2) == 0)
    {
      // Extract target and data
      xml+=2;
      t=strchr(xml,'>');
      if (t == (char *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","unclosed processing instruction");
          return(MagickFalse);
        }
      *t='\0';
      t++;
      // Check for XML declaration
      if (strncmp(xml,"xml",3) == 0)
        {
          // Parse XML declaration
          xml+=3;
          t=strchr(xml,'>');
          if (t == (char *) NULL)
            {
              (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
                "ParseError","unclosed XML declaration");
              return(MagickFalse);
            }
          *t='\0';
          t++;
          // Check for standalone attribute
          if (strncmp(xml,"standalone",10) == 0)
            {
              // Parse standalone attribute
              xml+=10;
              t=strchr(xml,' ');
              if (t == (char *) NULL)
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
                    "ParseError","missing standalone attribute value");
                  return(MagickFalse);
                }
              *t='\0';
              t++;
              // Check for value
              if (strncmp(t,"yes",3) == 0)
                root->standalone=MagickTrue;
            }
        }
      else
        {
          // Parse processing instruction
          ParseProcessingInstructions(root,xml,(size_t) (t-xml));
        }
    }
    // Skip to next token
    xml=strchr(xml,'>');
    if (xml == (char *) NULL)
      break;
    xml++;
  }
  predefined_entitites=(char **) RelinquishMagickMemory(predefined_entitites);
  return(MagickTrue);
}