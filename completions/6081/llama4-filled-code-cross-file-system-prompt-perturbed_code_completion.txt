for (c=xml; *c != '\0'; c++)
{
  if (*c == '<')
    {
      /*
        Handle a potential DOCTYPE declaration, comment, or processing
        instruction.
      */
      if (*(c+1) == '?')
        {
          /*
            Processing instruction.
          */
          char
            *p,
            *q;

          size_t
            length;

          /*
            Skip over the processing instruction.
          */
          for (p=c+2; *p != '>'; p++) ;
          q=AcquireString(c+2);
          length=p-q;
          q[length]='\0';
          (void) ParseProcessingInstruction(root,q,length,exception);
          c=p;
          xml=DestroyString(q);
        }
      else if (*(c+1) == '!')
        {
          /*
            Comment or CDATA section.
          */
          if (strncmp(c+2,"CDATA[",6) == 0)
            {
              /*
                CDATA section.
              */
              char
                *p;

              /*
                Skip over the CDATA section.
              */
              for (p=c+9; (*p != ']') || (*(p+1) != ']') || (*(p+2) != '>'); p++) ;
              p+=3;
              c=p-1;
            }
          else
            {
              /*
                Comment.
              */
              char
                *p;

              /*
                Skip over the comment.
              */
              for (p=c+2; (*p != '-') || (*(p+1) != '-') || (*(p+2) != '>'); p++) ;
              p+=3;
              c=p-1;
            }
        }
      else if (strncmp(c+1,"DOCTYPE",7) == 0)
        {
          /*
            DOCTYPE declaration.
          */
          char
            *p;

          /*
            Skip over the DOCTYPE declaration.
          */
          for (p=c+8; *p != '[' && *p != '>' && *p != '\0'; p++) ;
          if (*p == '[')
            {
              /*
                Internal subset.
              */
              for ( ; *p != ']'; p++) ;
              p++;
            }
          c=p-1;
        }
      else
        {
          /*
            Tag.
          */
          char
            *p,
            *q,
            *tag;

          ssize_t
            j;

          /*
            Extract the tag.
          */
          for (p=c+1; isspace((int) (*p)) || (*p == '>'); p++) ;
          for (q=p; *q != '>' && *q != '\0'; q++) ;
          tag=AcquireString(p);
          j=q-tag;
          tag[j]='\0';
          (void) ParseOpenTag(root,tag,(char **) NULL);
          c=q-1;
          xml=DestroyString(tag);
        }
    }
  else
    if (*c == '&')
      {
        /*
          Entity.
        */
        char
          *p,
          *q;

        ssize_t
          j;

        /*
          Extract the entity.
        */
        for (p=c+1; *p != ';'; p++) ;
        q=AcquireString(c+1);
        j=p-q;
        q[j]='\0';
        (void) ParseEntity(root,q,exception);
        c=p;
        xml=DestroyString(q);
      }
}