// Parse through the XML string to identify and process different components of a DOCTYPE declaration.
// When encountering an ENTITY declaration, parse and store the entity definitions in the appropriate data structure.
// Handle both parameter and general entities, updating predefined entities as needed.
// Validate entity definitions and handle any errors or circular declarations appropriately.
// For ATTLIST declarations, parse and store default attributes, managing memory for new attribute tags as necessary.
// Ensure that malformed or incomplete declarations are handled by throwing appropriate exceptions.
// Process comments and processing instructions by identifying their boundaries and calling appropriate processing functions.
// Continue parsing until the end of the DOCTYPE declaration or the input string is reached.

// Parse ENTITY declaration
if (strncmp(xml,"ENTITY",6) == 0)
{
  char
    *entity,
    *name,
    *value;

  ssize_t
    j;

  xml+=6;
  xml+=strspn(xml,XMLWhitespace);
  if (*xml == '%')
    {
      // Parameter entity
      xml++;
      xml+=strspn(xml,XMLWhitespace);
      name=xml;
      xml+=strcspn(xml,XMLWhitespace ">");
      *xml++='\0';
      xml+=strspn(xml,XMLWhitespace);
      if (*xml == '"')
        {
          xml++;
          value=xml;
          xml+=strcspn(xml,'"');
          *xml++='\0';
        }
      else
        if (*xml == '\'')
          {
            xml++;
            value=xml;
            xml+=strcspn(xml,'\'');
            *xml++='\0';
          }
        else
          {
            (void) ThrowMagickException(exception,GetMagickModule(),
              OptionWarning,"ParseError","missing entity value");
            continue;
          }
      if (root->entities[0] == (char *) NULL)
        {
          root->entities=(char **) AcquireMagickMemory(sizeof(sentinel));
          if (root->entities == (char **) NULL)
            ThrowFatalException(ResourceLimitError,"MemoryAllocationFailed");
          (void) CopyMagickMemory(root->entities,sentinel,sizeof(sentinel));
        }
      j=0;
      while ((root->entities[j]!= (char *) NULL) &&
             (strcmp(root->entities[j],name)!= 0))
        j+=2;
      if (root->entities[j] == (char *) NULL)
        {
          root->entities=(char **) ResizeQuantumMemory(root->entities,
            (size_t) (j+4),sizeof(*root->entities));
          if (root->entities == (char **) NULL)
            ThrowFatalException(ResourceLimitError,"MemoryAllocationFailed");
          root->entities[j]=ConstantString(name);
          root->entities[j+1]=ConstantString(value);
          root->entities[j+2]=(char *) NULL;
        }
      else
        {
          root->entities[j+1]=ConstantString(value);
          if (ValidateEntities(name,value,0,root->entities) == MagickFalse)
            {
              (void) ThrowMagickException(exception,GetMagickModule(),
                OptionWarning,"ParseError","circular entity reference");
              continue;
            }
        }
    }
  else
    {
      // General entity
      xml+=strspn(xml,XMLWhitespace);
      name=xml;
      xml+=strcspn(xml,XMLWhitespace ">");
      *xml++='\0';
      xml+=strspn(xml,XMLWhitespace);
      if (*xml == '"')
        {
          xml++;
          value=xml;
          xml+=strcspn(xml,'"');
          *xml++='\0';
        }
      else
        if (*xml == '\'')
          {
            xml++;
            value=xml;
            xml+=strcspn(xml,'\'');
            *xml++='\0';
          }
        else
          {
            (void) ThrowMagickException(exception,GetMagickModule(),
              OptionWarning,"ParseError","missing entity value");
            continue;
          }
      if (root->entities[0] == (char *) NULL)
        {
          root->entities=(char **) AcquireMagickMemory(sizeof(sentinel));
          if (root->entities == (char **) NULL)
            ThrowFatalException(ResourceLimitError,"MemoryAllocationFailed");
          (void) CopyMagickMemory(root->entities,sentinel,sizeof(sentinel));
        }
      j=0;
      while ((root->entities[j]!= (char *) NULL) &&
             (strcmp(root->entities[j],name)!= 0))
        j+=2;
      if (root->entities[j] == (char *) NULL)
        {
          root->entities=(char **) ResizeQuantumMemory(root->entities,
            (size_t) (j+4),sizeof(*root->entities));
          if (root->entities == (char **) NULL)
            ThrowFatalException(ResourceLimitError,"MemoryAllocationFailed");
          root->entities[j]=ConstantString(name);
          root->entities[j+1]=ConstantString(value);
          root->entities[j+2]=(char *) NULL;
        }
      else
        {
          root->entities[j+1]=ConstantString(value);
          if (ValidateEntities(name,value,0,root->entities) == MagickFalse)
            {
              (void) ThrowMagickException(exception,GetMagickModule(),
                OptionWarning,"ParseError","circular entity reference");
              continue;
            }
        }
    }
}

// Parse ATTLIST declaration
if (strncmp(xml,"ATTLIST",7) == 0)
{
  char
    *attribute,
    *default_value,
    *element,
    *name,
    *type;

  ssize_t
    j;

  xml+=7;
  xml+=strspn(xml,XMLWhitespace);
  element=xml;
  xml+=strcspn(xml,XMLWhitespace);
  *xml++='\0';
  xml+=strspn(xml,XMLWhitespace);
  for ( ; ; )
  {
    name=xml;
    xml+=strcspn(xml,XMLWhitespace);
    *xml++='\0';
    xml+=strspn(xml,XMLWhitespace);
    type=xml;
    xml+=strcspn(xml,XMLWhitespace);
    *xml++='\0';
    xml+=strspn(xml,XMLWhitespace);
    if (*xml == '#')
      {
        xml++;
        if (strncmp(xml,"REQUIRED",8) == 0)
          default_value=(char *) NULL;
        else
          if (strncmp(xml,"IMPLIED",7) == 0)
            default_value=(char *) NULL;
          else
            if (strncmp(xml,"FIXED",5) == 0)
              {
                xml+=5;
                xml+=strspn(xml,XMLWhitespace);
                if (*xml == '"')
                  {
                    xml++;
                    default_value=xml;
                    xml+=strcspn(xml,'"');
                    *xml++='\0';
                  }
                else
                  if (*xml == '\'')
                    {
                      xml++;
                      default_value=xml;
                      xml+=strcspn(xml,'\'');
                      *xml++='\0';
                    }
                  else
                    {
                      (void) ThrowMagickException(exception,GetMagickModule(),
                        OptionWarning,"ParseError","missing default value");
                      continue;
                    }
              }
            else
              {
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,"ParseError","unknown default value");
                continue;
              }
      }
    else
      if (*xml == '"')
        {
          xml++;
          default_value=xml;
          xml+=strcspn(xml,'"');
          *xml++='\0';
        }
      else
        if (*xml == '\'')
          {
            xml++;
            default_value=xml;
            xml+=strcspn(xml,'\'');
            *xml++='\0';
          }
        else
          {
            (void) ThrowMagickException(exception,GetMagickModule(),
              OptionWarning,"ParseError","missing default value");
            continue;
          }
    if (root->attributes[0] == (char **) NULL)
      {
        root->attributes=(char ***) AcquireCriticalMemory(sizeof(
          *root->attributes));
        *root->attributes=(char **) NULL;
      }
    j=0;
    while ((root->attributes[j]!= (char **) NULL) &&
           (strcmp(root->attributes[j][0],element)!= 0))
      j++;
    if (root->attributes[j] == (char **) NULL)
      {
        root->attributes=(char ***) ResizeQuantumMemory(root->attributes,
          (size_t) (j+2),sizeof(*root->attributes));
        if (root->attributes == (char ***) NULL)
          ThrowFatalException(ResourceLimitError,"MemoryAllocationFailed");
        root->attributes[j]=(char **) AcquireQuantumMemory(4,
          sizeof(**root->attributes));
        if (root->attributes[j] == (char **) NULL)
          ThrowFatalException(ResourceLimitError,"MemoryAllocationFailed");
        root->attributes[j+1]=(char **) NULL;
        root->attributes[j][0]=ConstantString(element);
        root->attributes[j][1]=(char *)
          root->attributes[j+1];
        root->attributes[j][2]=ConstantString("");
      }
    attribute=root->attributes[j];
    if (attribute[0]!= (char *) NULL)
      attribute[0]=DestroyString(attribute[0]);
    attribute[0]=ConstantString(name);
    if (attribute[1]!= (char *) NULL)
      attribute[1]=DestroyString(attribute[1]);
    attribute[1]=ConstantString(type);
    if (attribute[2]!= (char *) NULL)
      attribute[2]=DestroyString(attribute[2]);
    attribute[2]=ConstantString(default_value);
    if (*xml!= '>')
      {
        (void) ThrowMagickException(exception,GetMagickModule(),
          OptionWarning,"ParseError","missing >");
        continue;
      }
    xml++;
    xml+=strspn(xml,XMLWhitespace);
    if (*xml == '\0')
      break;
  }
}

// Parse comments
if (strncmp(xml,"<!--",4) == 0)
{
  xml+=4;
  xml=strstr(xml,"-->");
  if (xml == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        "ParseError","unclosed <!--");
      continue;
    }
  xml+=2;
}

// Parse processing instructions
if (*xml == '?')
{
  char
    *target;

  target=xml+1;
  xml+=strcspn(xml+1,XMLWhitespace);
  if (*xml!= '\0')
    {
      *xml='\0';
      xml+=strspn(xml+1,XMLWhitespace);
    }
  if (strcmp(target,"xml") == 0)
    {
      xml=strstr(xml,"standalone");
      if ((xml!= (char *) NULL) &&
          (strncmp(xml+strspn(xml+10,XMLWhitespace "='\"")+10,"yes",3) == 0))
        root->standalone=MagickTrue;
      continue;
    }
  if (root->processing_instructions[0] == (char **) NULL)
    {
      root->processing_instructions=(char ***) AcquireCriticalMemory(sizeof(
        *root->processing_instructions));
      *root->processing_instructions=(char **) NULL;
    }
  j=0;
  while ((root->processing_instructions[j]!= (char **) NULL) &&
         (strcmp(target,root->processing_instructions[j][0])!= 0))
    j++;
  if (root->processing_instructions[j] == (char **) NULL)
    {
      root->processing_instructions=(char ***) ResizeQuantumMemory(
        root->processing_instructions,(size_t) (j+2),
        sizeof(*root->processing_instructions));
      if (root->processing_instructions == (char ***) NULL)
        ThrowFatalException(ResourceLimitError,"MemoryAllocationFailed");
      root->processing_instructions[j]=(char **) AcquireQuantumMemory(3,
        sizeof(**root->processing_instructions));
      if (root->processing_instructions[j] == (char **) NULL)
        ThrowFatalException(ResourceLimitError,"MemoryAllocationFailed");
      root->processing_instructions[j+1]=(char **) NULL;
      root->processing_instructions[j][0]=ConstantString(target);
      root->processing_instructions[j][1]=(char *)
        root->processing_instructions[j+1];
      root->processing_instructions[j][2]=ConstantString("");
    }
  j=1;
  while (root->processing_instructions[j][j]!= (char *) NULL)
    j++;
  root->processing_instructions[j]=(char **) ResizeQuantumMemory(
    root->processing_instructions[j],(size_t) (j+3),
    sizeof(**root->processing_instructions));
  if (root->processing_instructions[j] == (char **) NULL)
    ThrowFatalException(ResourceLimitError,"MemoryAllocationFailed");
  root->processing_instructions[j][j+2]=(char *) ResizeQuantumMemory(
    root->processing_instructions[j][j+1],(size_t) (j+1),
    sizeof(***root->processing_instructions));
  if (root->processing_instructions[j][j+2] == (char *) NULL)
    ThrowFatalException(ResourceLimitError,"MemoryAllocationFailed");
  (void) CopyMagickString(root->processing_instructions[j][j+2]+j-1,
    root->root.tag!= (char *) NULL? ">" : "<",2);
  root->processing_instructions[j][j]=ConstantString(xml);
  root->processing_instructions[j][j+1]=(char *) NULL;
}