static MagickBooleanType ParseInternalDoctype(XMLTreeRoot *root,char *xml,
  size_t length,ExceptionInfo *exception)
{
  char
    *c,
    **entities,
    *n,
    **predefined_entitites,
    q,
    *t,
    *v;

  register ssize_t
    i;

  ssize_t
    index;

  n=(char *) NULL;
  predefined_entitites=(char **) AcquireMagickMemory(sizeof(sentinel));
  if (predefined_entitites == (char **) NULL)
    ThrowFatalException(ResourceLimitError,"MemoryAllocationFailed");
  (void) CopyMagickMemory(predefined_entitites,sentinel,sizeof(sentinel));
  for (xml[length]='\0'; xml!= (char *) NULL; )
  {
    // Parse through the XML string to identify and process different components of a DOCTYPE declaration.
    // When encountering an ENTITY declaration, parse and store the entity definitions in the appropriate data structure.
    // Handle both parameter and general entities, updating predefined entities as needed.
    // Validate entity definitions and handle any errors or circular declarations appropriately.
    // For ATTLIST declarations, parse and store default attributes, managing memory for new attribute tags as necessary.
    // Ensure that malformed or incomplete declarations are handled by throwing appropriate exceptions.
    // Process comments and processing instructions by identifying their boundaries and calling appropriate processing functions.
    // Continue parsing until the end of the DOCTYPE declaration or the input string is reached.
    // <MASK>
    // Parse ENTITY declarations
    if (strncmp(xml,"<!ENTITY",9) == 0)
    {
      // Extract entity name and value
      xml+=9;
      t=strchr(xml,'>');
      if (t == (char *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","unclosed ENTITY declaration");
          return(MagickFalse);
        }
      *t='\0';
      t=strchr(xml,' ');
      if (t == (char *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","missing entity name");
          return(MagickFalse);
        }
      v=strchr(t,' ');
      if (v == (char *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","missing entity value");
          return(MagickFalse);
        }
      *v='\0';
      t=strchr(t,' ');
      if (t == (char *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","missing entity value");
          return(MagickFalse);
        }
      *t='\0';
      // Check for circular entity references
      if (ValidateEntities(xml,xml+strlen(xml),0,predefined_entitites) == MagickFalse)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","circular entity reference");
          return(MagickFalse);
        }
      // Add entity to predefined entities
      n=(char *) AcquireMagickMemory(strlen(xml)+strlen(v)+2);
      if (n == (char *) NULL)
        ThrowFatalException(ResourceLimitError,"MemoryAllocationFailed");
      (void) CopyMagickMemory(n,xml,strlen(xml));
      n[strlen(xml)]=' ';
      (void) CopyMagickMemory(n+strlen(xml)+1,v,strlen(v));
      n[strlen(xml)+strlen(v)+1]='\0';
      predefined_entitites=(char **) ResizeQuantumMemory(predefined_entitites,
        (size_t) (strlen(predefined_entitites)+2),sizeof(*predefined_entitites));
      if (predefined_entitites == (char **) NULL)
        ThrowFatalException(ResourceLimitError,"MemoryAllocationFailed");
      predefined_entitites[strlen(predefined_entitites)]=n;
      predefined_entitites[strlen(predefined_entitites)+1]=(char *) NULL;
    }
    // Parse ATTLIST declarations
    else if (strncmp(xml,"<!ATTLIST",9) == 0)
    {
      // Extract element name and attribute declarations
      xml+=9;
      t=strchr(xml,'>');
      if (t == (char *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","unclosed ATTLIST declaration");
          return(MagickFalse);
        }
      *t='\0';
      t=strchr(xml,' ');
      if (t == (char *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","missing element name");
          return(MagickFalse);
        }
      v=strchr(t,' ');
      if (v == (char *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","missing attribute declaration");
          return(MagickFalse);
        }
      *v='\0';
      t=strchr(v,' ');
      if (t == (char *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","missing attribute declaration");
          return(MagickFalse);
        }
      *t='\0';
      // Parse attribute declaration
      i=0;
      while ((xml[i]!= '\0') && (xml[i]!=''))
        i++;
      if (xml[i] == '\0')
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","missing attribute name");
          return(MagickFalse);
        }
      xml[i]='\0';
      t=strchr(xml,' ');
      if (t == (char *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","missing attribute name");
          return(MagickFalse);
        }
      *t='\0';
      v=strchr(t,' ');
      if (v == (char *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","missing attribute value");
          return(MagickFalse);
        }
      *v='\0';
      t=strchr(v,' ');
      if (t == (char *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","missing attribute value");
          return(MagickFalse);
        }
      *t='\0';
      // Check for circular entity references
      if (ValidateEntities(xml,xml+strlen(xml),0,predefined_entitites) == MagickFalse)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","circular entity reference");
          return(MagickFalse);
        }
      // Add attribute to predefined entities
      n=(char *) AcquireMagickMemory(strlen(xml)+strlen(v)+2);
      if (n == (char *) NULL)
        ThrowFatalException(ResourceLimitError,"MemoryAllocationFailed");
      (void) CopyMagickMemory(n,xml,strlen(xml));
      n[strlen(xml)]=' ';
      (void) CopyMagickMemory(n+strlen(xml)+1,v,strlen(v));
      n[strlen(xml)+strlen(v)+1]='\0';
      predefined_entitites=(char **) ResizeQuantumMemory(predefined_entitites,
        (size_t) (strlen(predefined_entitites)+2),sizeof(*predefined_entitites));
      if (predefined_entitites == (char **) NULL)
        ThrowFatalException(ResourceLimitError,"MemoryAllocationFailed");
      predefined_entitites[strlen(predefined_entitites)]=n;
      predefined_entitites[strlen(predefined_entitites)+1]=(char *) NULL;
    }
    // Parse comment declarations
    else if (strncmp(xml,"<!--",4) == 0)
    {
      // Extract comment text
      xml+=4;
      t=strchr(xml,'--');
      if (t == (char *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","unclosed comment declaration");
          return(MagickFalse);
        }
      *t='\0';
      t=strchr(t,'>');
      if (t == (char *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","unclosed comment declaration");
          return(MagickFalse);
        }
      *t='\0';
      // Add comment to predefined entities
      n=(char *) AcquireMagickMemory(strlen(xml)+1);
      if (n == (char *) NULL)
        ThrowFatalException(ResourceLimitError,"MemoryAllocationFailed");
      (void) CopyMagickMemory(n,xml,strlen(xml));
      n[strlen(xml)]='\0';
      predefined_entitites=(char **) ResizeQuantumMemory(predefined_entitites,
        (size_t) (strlen(predefined_entitites)+2),sizeof(*predefined_entitites));
      if (predefined_entitites == (char **) NULL)
        ThrowFatalException(ResourceLimitError,"MemoryAllocationFailed");
      predefined_entitites[strlen(predefined_entitites)]=n;
      predefined_entitites[strlen(predefined_entitites)+1]=(char *) NULL;
    }
    // Parse processing instructions
    else if (strncmp(xml,"<?",2) == 0)
    {
      // Extract processing instruction target and data
      xml+=2;
      t=strchr(xml,'>');
      if (t == (char *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","unclosed processing instruction");
          return(MagickFalse);
        }
      *t='\0';
      t=strchr(t,' ');
      if (t == (char *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","missing processing instruction target");
          return(MagickFalse);
        }
      v=strchr(t,' ');
      if (v == (char *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","missing processing instruction target");
          return(MagickFalse);
        }
      *v='\0';
      t=strchr(v,' ');
      if (t == (char *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","missing processing instruction data");
          return(MagickFalse);
        }
      *t='\0';
      // Add processing instruction to predefined entities
      n=(char *) AcquireMagickMemory(strlen(xml)+strlen(v)+2);
      if (n == (char *) NULL)
        ThrowFatalException(ResourceLimitError,"MemoryAllocationFailed");
      (void) CopyMagickMemory(n,xml,strlen(xml));
      n[strlen(xml)]=' ';
      (void) CopyMagickMemory(n+strlen(xml)+1,v,strlen(v));
      n[strlen(xml)+strlen(v)+1]='\0';
      predefined_entitites=(char **) ResizeQuantumMemory(predefined_entitites,
        (size_t) (strlen(predefined_entitites)+2),sizeof(*predefined_entitites));
      if (predefined_entitites == (char **) NULL)
        ThrowFatalException(ResourceLimitError,"MemoryAllocationFailed");
      predefined_entitites[strlen(predefined_entitites)]=n;
      predefined_entitites[strlen(predefined_entitites)+1]=(char *) NULL;
    }
    // Parse DTD declarations
    else if (strncmp(xml,"<!DOCTYPE",9) == 0)
    {
      // Extract DTD name and public ID
      xml+=9;
      t=strchr(xml,'>');
      if (t == (char *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","unclosed DTD declaration");
          return(MagickFalse);
        }
      *t='\0';
      t=strchr(t,' ');
      if (t == (char *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","missing DTD name");
          return(MagickFalse);
        }
      v=strchr(t,' ');
      if (v == (char *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","missing DTD name");
          return(MagickFalse);
        }
      *v='\0';
      t=strchr(v,' ');
      if (t == (char *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
            "ParseError","missing public ID");
          return(MagickFalse);
        }
      *t='\0';
      // Add DTD to predefined entities
      n=(char *) AcquireMagickMemory(strlen(xml)+strlen(v)+2);
      if (n == (char *) NULL)
        ThrowFatalException(ResourceLimitError,"MemoryAllocationFailed");
      (void) CopyMagickMemory(n,xml,strlen(xml));
      n[strlen(xml)]=' ';
      (void) CopyMagickMemory(n+strlen(xml)+1,v,strlen(v));
      n[strlen(xml)+strlen(v)+1]='\0';
      predefined_entitites=(char **) ResizeQuantumMemory(predefined_entitites,
        (size_t) (strlen(predefined_entitites)+2),sizeof(*predefined_entitites));
      if (predefined_entitites == (char **) NULL)
        ThrowFatalException(ResourceLimitError,"MemoryAllocationFailed");
      predefined_entitites[strlen(predefined_entitites)]=n;
      predefined_entitites[strlen(predefined_entitites)+1]=(char *) NULL;
    }
    // Parse other declarations
    else
    {
      // Add declaration to predefined entities
      n=(char *) AcquireMagickMemory(strlen(xml)+1);
      if (n == (char *) NULL)
        ThrowFatalException(ResourceLimitError,"MemoryAllocationFailed");
      (void) CopyMagickMemory(n,xml,strlen(xml));
      n[strlen(xml)]='\0';
      predefined_entitites=(char **) ResizeQuantumMemory(predefined_en