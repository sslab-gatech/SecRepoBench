// Initialize variables required for processing certificate elements.
int i, num_found = 0;
char buffer[256], rdnSeqBuf[256];
int rdn_len = 0;

// Check after handshake protocol header (5 bytes) and message header (4 bytes)
for(i = p_offset; i < certificate_len - 2; i++) {
  // Process certificate elements here
}

// Populate the subject and issuer DN fields
if(rdn_len && (flow->protos.tls_quic.subjectDN == NULL)) {
  flow->protos.tls_quic.subjectDN = ndpi_strdup(rdnSeqBuf);

  if(flow->detected_protocol_stack[1] == NDPI_PROTOCOL_UNKNOWN) {
    // No idea what is happening behind the scenes: let's check the certificate
    u_int32_t val;
    int rc = ndpi_match_string_value(detectionmodulestruct->tls_cert_subject_automa.ac_automa,
                                     rdnSeqBuf, strlen(rdnSeqBuf), &val);

    if(rc == 0) {
      // Match found
      u_int16_t proto_id = (u_int16_t)val;
      ndpi_protocol ret = { __get_master(detectionmodulestruct, flow), proto_id, NDPI_PROTOCOL_UNKNOWN /* unused */, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NULL};

      ndpi_set_detected_protocol(detectionmodulestruct, flow, proto_id, __get_master(detectionmodulestruct, flow), NDPI_CONFIDENCE_DPI);
      flow->category = ndpi_get_proto_category(detectionmodulestruct, ret);
      ndpi_check_subprotocol_risk(detectionmodulestruct, flow, proto_id);
      ndpi_unset_risk(detectionmodulestruct, flow, NDPI_NUMERIC_IP_HOST);

      if(detectionmodulestruct->tls_cert_cache) {
        u_int32_t key = make_tls_cert_key(packet, 0 /* from the server */);

        ndpi_lru_add_to_cache(detectionmodulestruct->tls_cert_cache, key, proto_id, ndpi_get_current_time(flow));
      }
    }
  }
}