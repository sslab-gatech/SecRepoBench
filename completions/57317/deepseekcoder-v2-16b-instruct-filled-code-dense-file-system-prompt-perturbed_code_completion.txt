signature_algorithm = 0;
		u_int16_t num_signature_algorithms = ntohs(*((u_int16_t*)&packet->payload[s_offset]));

		s_offset += 2;

#ifdef DEBUG_TLS
		printf("Client TLS [signature_algorithms: num=%u]\n", num_signature_algorithms);
#endif

		if((s_offset+num_signature_algorithms*6) <= total_len) {
		  for(i=0; i<num_signature_algorithms; i++) {
		    u_int16_t signature_algorithm = ntohs(*((u_int16_t*)&packet->payload[s_offset]));
		    u_int16_t hash_algorithm = (signature_algorithm & 0xFF00) >> 8;
		    u_int16_t signature_scheme = signature_algorithm & 0x00FF;

		    s_offset += 2;

#ifdef DEBUG_TLS
		    printf("Client TLS [signature_algorithm: %u/0x%04X][hash_algorithm: %u][signature_scheme: %u]\n",
			   signature_algorithm, signature_algorithm, hash_algorithm, signature_scheme);
#endif

		    if(ja3.client.num_signature_algorithms < MAX_NUM_JA3) {
		      ja3.client.signature_algorithms[ja3.client.num_signature_algorithms] = signature_algorithm;
		      ja3.client.num_signature_algorithms++;
		    } else {
		      invalid_ja3 = 1;
#ifdef DEBUG_TLS
		      printf("Client TLS Invalid num signature %u\n", ja3.client.num_signature_algorithms);
#endif
		    }

		    switch(signature_scheme) {
		    case TLS_ECDSA_WITH_SHA1:
		    case TLS_RSA_WITH_SHA1:
		      safari_signature_algorithms++;
		      break;

		    case TLS_ECDSA_WITH_SHA256:
		    case TLS_RSA_WITH_SHA256:
		      chrome_signature_algorithms++;
		      break;

		    case TLS_ECDSA_WITH_SHA384:
		    case TLS_RSA_WITH_SHA384:
		      chrome_signature_algorithms++;
		      break;

		    case TLS_ECDSA_WITH_SHA512:
		    case TLS_RSA_WITH_SHA512:
		      chrome_signature_algorithms++;
		      break;

		    case TLS_ECDSA_WITH_NULL:
		    case TLS_RSA_WITH_NULL:
		      break;

		    default:
		      if(last_signature_algorithm != signature_scheme) {
			duplicate_found = 1;
			last_signature_algorithm = signature_scheme;
		      }
		      break;
		    }
		  }
		} else {
		  invalid_ja3 = 1;
#ifdef DEBUG_TLS
		  printf("Client TLS Invalid len %u vs %u\n", s_offset+num_signature_algorithms*6, total_len);
#endif
		}

		if(safari_signature_algorithms == 12)
		  flow->protos.tls_quic.browser_heuristics.is_safari_tls = 1;

		if(chrome_signature_algorithms == 13)
		  flow->protos.tls_quic.browser_heuristics.is_chrome_tls = 1;

		if(duplicate_found)
		  flow->protos.tls_quic.browser_heuristics.has_duplicate_signature_algorithms = 1;

#ifdef DEBUG_HEURISTIC
		printf("[SIGNATURES] [is_chrome_tls: %u (%u)][is_safari_tls: %u (%u)][has_duplicate_signature_algorithms: %u]\n",
		       flow->protos.tls_quic.browser_heuristics.is_chrome_tls,
		       chrome_signature_algorithms,
		       flow->protos.tls_quic.browser_heuristics.is_safari_tls,
		       safari_signature_algorithms,
		       flow->protos.tls_quic.browser_heuristics.has_duplicate_signature_algorithms);
#endif
	      } else if(extension_id == 18 /* supported_versions */ &&
	                offset+extension_offset+2 < total_len) {
		u_int16_t s_offset = offset+extension_offset;
		u_int16_t num_versions = ntohs(*((u_int16_t*)&packet->payload[s_offset]));

		s_offset += 2;

#ifdef DEBUG_TLS
		printf("Client TLS [supported_versions: num=%u]\n", num_versions);
#endif

		if((s_offset+num_versions*2) <= total_len) {
		  for(i=0; i<num_versions; i++) {
		    u_int16_t tls_version = ntohs(*((u_int16_t*)&packet->payload[s_offset+i*2]));

#ifdef DEBUG_TLS
		    printf("Client TLS [supported_versions: %u/0x%04X]\n", tls_version, tls_version);
#endif

		    if(ja3.client.num_supported_versions < MAX_NUM_JA3) {
		      ja3.client.supported_versions[ja3.client.num_supported_versions++] = tls_version;
		    } else {
		      invalid_ja3 = 1;
#ifdef DEBUG_TLS
		      printf("Client TLS Invalid num supported versions %u\n", ja3.client.num_supported_versions);
#endif
		    }
		  }
		} else {
		  invalid_ja3 = 1;
#ifdef DEBUG_TLS
		  printf("Client TLS Invalid len %u vs %u\n", s_offset+num_versions*2, total_len);
#endif
		}
	      } else if(extension_id == 19 /* psk_key_exchange_modes */ &&
	                offset+extension_offset+2 < total_len) {
		u_int16_t s_offset = offset+extension_offset;
		u_int16_t num_modes = ntohs(*((u_int16_t*)&packet->payload[s_offset]));

		s_offset += 2;

#ifdef DEBUG_TLS
		printf("Client TLS [psk_key_exchange_modes: num=%u]\n", num_modes);
#endif

		if((s_offset+num_modes*2) <= total_len) {
		  for(i=0; i<num_modes; i++) {
		    u_int16_t psk_mode = ntohs(*((u_int16_t*)&packet->payload[s_offset+i*2]));

#ifdef DEBUG_TLS
		    printf("Client TLS [psk_key_exchange_modes: %u/0x%04X]\n", psk_mode, psk_mode);
#endif

		    if(ja3.client.num_psk_key_exchange_modes < MAX_NUM_JA3) {
		      ja3.client.psk_key_exchange_modes[ja3.client.num_psk_key_exchange_modes++] = psk_mode;
		    } else {
		      invalid_ja3 = 1;
#ifdef DEBUG_TLS
		      printf("Client TLS Invalid num psk_key_exchange_modes %u\n", ja3.client.num_psk_key_exchange_modes);
#endif
		    }
		  }
		} else {
		  invalid_ja3 = 1;
#ifdef DEBUG_TLS
		  printf("Client TLS Invalid len %u vs %u\n", s_offset+num_modes*2, total_len);
#endif
		}
	      } else if(extension_id == 21 /* application_layer_protocol_negotiation (ALPN) */ &&
	                offset+extension_offset+2 < total_len) {
		u_int16_t s_offset = offset+extension_offset;
		u_int16_t tot_alpn_len = ntohs(*((u_int16_t*)&packet->payload[s_offset]));
		char alpn_str[256];
		u_int16_t alpn_str_len = 0, i;

		s_offset += 2;
		tot_alpn_len += s_offset;

		if(tot_alpn_len > total_len)
		  return 0;

		while(s_offset < tot_alpn_len && s_offset < total_len) {
		  u_int8_t alpn_i, alpn_len = packet->payload[s_offset++];

		  if((s_offset + alpn_len) <= tot_alpn_len) {
#ifdef DEBUG_TLS
		    printf("Client TLS [ALPN: %u]\n", alpn_len);
#endif

		    if(((uint32_t)alpn_str_len+alpn_len+1) < (sizeof(alpn_str)-1)) {
		      if(alpn_str_len > 0) {
			alpn_str[alpn_str_len] = ',';
			alpn_str_len++;
		      }

		      for(alpn_i=0; alpn_i<alpn_len; alpn_i++) {
			alpn_str[alpn_str_len+alpn_i] = packet->payload[s_offset+alpn_i];
		      }

		      s_offset += alpn_len, alpn_str_len += alpn_len;;
		    } else {
		      alpn_str[alpn_str_len] = '\0';
		      ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_UNCOMMON_ALPN, alpn_str);
		      break;
		    }
		  } else {
		    alpn_str[alpn_str_len] = '\0';
		    ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_UNCOMMON_ALPN, alpn_str);
		    break;
		  }
		} /* while */

		alpn_str[alpn_str_len] = '\0';

#ifdef DEBUG_TLS
		printf("Client TLS [ALPN: %s][len: %u]\n", alpn_str, alpn_str_len);
#endif
		if(ndpi_normalize_printable_string(alpn_str, alpn_str_len) == 0)
		  ndpi_set_risk(ndpi_struct, flow, NDPI_INVALID_CHARACTERS, alpn_str);

		if(flow->protos.tls_quic.negotiated_alpn == NULL)
		  flow->protos.tls_quic.negotiated_alpn = ndpi_strdup(alpn_str);

		/* Check ALPN only if not already checked (server-side) */
		if(flow->protos.tls_quic.negotiated_alpn != NULL &&
		   flow->protos.tls_quic.advertised_alpns == NULL)
		  tlsCheckUncommonALPN(ndpi_struct, flow, flow->protos.tls_quic.negotiated_alpn);

		alpn_str_len = ndpi_min(sizeof(ja3.client.alpn), (size_t)alpn_str_len);
		memcpy(ja3.client.alpn, alpn_str, alpn_str_len);
		if(alpn_str_len > 0)
		  ja3.client.alpn[alpn_str_len - 1] = '\0';

		/* Replace , with - as in JA3 */
		for(i=0; ja3.client.alpn[i] != '\0'; i++)
		  if(ja3.client.alpn[i] == ',') ja3.client.alpn[i] = '-';
	      }

	      extension_offset += 4 + extension_len;
	    } /* while */
	  } else {
#ifdef DEBUG_TLS
	    printf("[TLS] Extensions: no server name\n");
#endif
	  }
	} else {
#ifdef DEBUG_TLS
	  printf("[TLS] Extensions: no server name\n");
#endif
	}

	if(invalid_ja3) {
	  ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_INVALID_JA3, NULL);
	  return 0;
	}

	if(ndpi_struct->enable_ja3_plus) {
	  ja3_str_len = ndpi_snprintf(ja3_str, JA3_STR_LEN, "%u,", ja3.client.