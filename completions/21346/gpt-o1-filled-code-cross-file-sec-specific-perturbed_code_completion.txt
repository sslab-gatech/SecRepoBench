{
  /* Parse the DCC command (SEND, CHAT, chat, sslchat, TSEND). */
  char cmd[16];
  int cmd_start = j, cmd_end, cmd_len, space_count = 0;
  u_int16_t new_port = 0;
  int has_command = 0;
  struct ndpi_id_struct *id_struct = (src_id != NULL) ? src_id : dst;
  const int max_irc_ports = 16;  /* Typically NDPI_MAX_IRC_PORTS or similar. */

  /* Safely parse next token (the command) after "DCC ". */
  while (cmd_start < packet->line[i].len &&
         (packet->line[i].ptr[cmd_start] == ' ' || packet->line[i].ptr[cmd_start] == '\t'))
    cmd_start++;
  cmd_end = cmd_start;
  while (cmd_end < packet->line[i].len &&
         packet->line[i].ptr[cmd_end] != ' ' && packet->line[i].ptr[cmd_end] != '\t')
    cmd_end++;

  cmd_len = cmd_end - cmd_start;
  if (cmd_len > 0 && cmd_len < (int)sizeof(cmd)) {
    memcpy(cmd, &packet->line[i].ptr[cmd_start], cmd_len);
    cmd[cmd_len] = '\0';
    if (!strcmp(cmd, "SEND") || !strcmp(cmd, "CHAT") || !strcmp(cmd, "chat") ||
        !strcmp(cmd, "sslchat") || !strcmp(cmd, "TSEND")) {
      has_command = 1;
    }
  }
  if(!has_command) {
    /* Not a recognized DCC command, stop parsing this line. */
    continue;
  }

  /* Skip until we find the third space after "DCC <command>". */
  space_count = 0;
  j = cmd_end; /* continue from end of command */
  while (j < packet->line[i].len && space_count < 3) {
    if (packet->line[i].ptr[j] == ' ')
      space_count++;
    j++;
  }
  /* Now j points just past the third space, parse the port. */
  if (j >= packet->line[i].len)
    continue;  /* Not enough data left for port. */

  /* Read the port token safely. */
  {
    int port_start = j, port_end;
    while (port_start < packet->line[i].len &&
           (packet->line[i].ptr[port_start] == ' ' || packet->line[i].ptr[port_start] == '\t'))
      port_start++;
    port_end = port_start;
    while (port_end < packet->line[i].len &&
           packet->line[i].ptr[port_end] != ' ' && packet->line[i].ptr[port_end] != '\t')
      port_end++;

    if (port_end > port_start && (port_end - port_start) < 6) {
      char port_buf[6];
      memcpy(port_buf, &packet->line[i].ptr[port_start], port_end - port_start);
      port_buf[port_end - port_start] = '\0';
      new_port = (u_int16_t)atoi(port_buf);
    }
  }

  if(new_port > 0 && id_struct != NULL) {
    /* Store the new port in src or dst, avoiding duplicates. */
    u_int16_t *port_array = id_struct->irc_port;
    u_int16_t *port_count = &id_struct->irc_number_of_port;
    u_int32_t *time_array = id_struct->last_time_port_used;

    int found_duplicate = 0;
    for(int p = 0; p < *port_count; p++) {
      if(port_array[p] == new_port) {
        found_duplicate = 1;
        time_array[p] = packet->tick_timestamp;
        break;
      }
    }
    if(!found_duplicate) {
      /* If there's room, add it. Otherwise replace the least recently used. */
      if(*port_count < max_irc_ports) {
        port_array[*port_count] = new_port;
        time_array[*port_count] = packet->tick_timestamp;
        (*port_count)++;
      } else {
        /* Replace LRU entry if not a duplicate. */
        int lru_index = 0;
        for(int p = 1; p < max_irc_ports; p++) {
          if(time_array[p] < time_array[lru_index])
            lru_index = p;
        }
        port_array[lru_index] = new_port;
        time_array[lru_index] = packet->tick_timestamp;
      }
    }
  }
}