{
  int space_count = 0;
  int k = j; // start scanning after "DCC " command
  // Look for the third space to locate the port field
  while (k < packet->line[i].len && space_count < 3) {
    if (packet->line[i].ptr[k] == ' ')
      space_count++;
    k++;
  }
  if (space_count < 3)
    break; // Not enough fields detected

  // Skip any extra spaces to get to the port number
  while (k < packet->line[i].len && packet->line[i].ptr[k] == ' ')
    k++;

  // Parse the port number (assuming digits only)
  int port_num = 0;
  while (k < packet->line[i].len && isdigit((unsigned char)packet->line[i].ptr[k])) {
    port_num = port_num * 10 + (packet->line[i].ptr[k] - '0');
    k++;
  }
  if (port_num <= 0 || port_num > 65535)
    break; // Invalid port number

  u_int16_t dcc_port = (u_int16_t)port_num;

  // Attempt to add the parsed port to the source or destination IRC port list
  if (src_id != NULL) {
    int found = 0;
    for (counter = 0; counter < src_id->irc_number_of_port; counter++) {
      if (src_id->irc_port[counter] == dcc_port) {
        found = 1;
        src_id->last_time_port_used[counter] = packet->tick_timestamp;
        break;
      }
    }
    if (!found) {
      if (src_id->irc_number_of_port < NDPI_MAX_IRC_PORTS) {
        src_id->irc_port[src_id->irc_number_of_port] = dcc_port;
        src_id->last_time_port_used[src_id->irc_number_of_port] = packet->tick_timestamp;
        src_id->irc_number_of_port++;
      } else {
        int min_index = 0;
        u_int16_t min_time = src_id->last_time_port_used[0];
        for (counter = 1; counter < NDPI_MAX_IRC_PORTS; counter++) {
          if (src_id->last_time_port_used[counter] < min_time) {
            min_index = counter;
            min_time = src_id->last_time_port_used[counter];
          }
        }
        src_id->irc_port[min_index] = dcc_port;
        src_id->last_time_port_used[min_index] = packet->tick_timestamp;
      }
    }
    NDPI_LOG_INFO(ndpi_struct, "found DCC: added port %d to src", dcc_port);
    ndpi_int_irc_add_connection(ndpi_struct, flow);
  } else if (dst != NULL) {
    int found = 0;
    for (counter = 0; counter < dst->irc_number_of_port; counter++) {
      if (dst->irc_port[counter] == dcc_port) {
        found = 1;
        dst->last_time_port_used[counter] = packet->tick_timestamp;
        break;
      }
    }
    if (!found) {
      if (dst->irc_number_of_port < NDPI_MAX_IRC_PORTS) {
        dst->irc_port[dst->irc_number_of_port] = dcc_port;
        dst->last_time_port_used[dst->irc_number_of_port] = packet->tick_timestamp;
        dst->irc_number_of_port++;
      } else {
        int min_index = 0;
        u_int16_t min_time = dst->last_time_port_used[0];
        for (counter = 1; counter < NDPI_MAX_IRC_PORTS; counter++) {
          if (dst->last_time_port_used[counter] < min_time) {
            min_index = counter;
            min_time = dst->last_time_port_used[counter];
          }
        }
        dst->irc_port[min_index] = dcc_port;
        dst->last_time_port_used[min_index] = packet->tick_timestamp;
      }
    }
    NDPI_LOG_INFO(ndpi_struct, "found DCC: added port %d to dst", dcc_port);
    ndpi_int_irc_add_connection(ndpi_struct, flow);
  }
}