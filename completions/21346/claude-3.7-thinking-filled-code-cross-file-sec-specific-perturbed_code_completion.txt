if (memcmp(&packet->line[i].ptr[j], "SEND ", 5) == 0
    || memcmp(&packet->line[i].ptr[j], "CHAT ", 5) == 0
    || memcmp(&packet->line[i].ptr[j], "chat ", 5) == 0
    || memcmp(&packet->line[i].ptr[j], "sslchat ", 8) == 0
    || memcmp(&packet->line[i].ptr[j], "TSEND ", 6) == 0) {
  NDPI_LOG_DBG2(ndpi_struct, "found DCC CHAT, SEND, TSEND.");
  
  // Skip to the first space
  while (j < packet->line[i].len && packet->line[i].ptr[j] != ' ') {
    j++;
  }
  
  if (j < packet->line[i].len) {
    j++; // Skip the space
    
    // Skip to the second space (after filename)
    while (j < packet->line[i].len && packet->line[i].ptr[j] != ' ') {
      j++;
    }
    
    if (j < packet->line[i].len) {
      j++; // Skip the space
      
      // Skip to the third space (after ip address)
      while (j < packet->line[i].len && packet->line[i].ptr[j] != ' ') {
        j++;
      }
      
      if (j < packet->line[i].len) {
        j++; // Skip the space
        
        // Now we're at the port number
        u_int16_t port = 0;
        
        // Read port number
        while (j < packet->line[i].len && packet->line[i].ptr[j] >= '0' && 
               packet->line[i].ptr[j] <= '9') {
          u_int16_t new_port = port * 10 + (packet->line[i].ptr[j] - '0');
          // Check for overflow
          if (new_port < port) {
            break; // Overflow occurred
          }
          port = new_port;
          j++;
        }
        
        if (port > 0) {
          NDPI_LOG_DBG2(ndpi_struct, 
                         "found DCC port %u.", port);
          
          if (src_id != NULL) {
            // Check if port is already in the list
            u_int8_t found = 0;
            u_int16_t index_to_replace = 0;
            u_int32_t oldest_timestamp = 0xffffffff;
            
            for (less = 0; less < src_id->irc_number_of_port; less++) {
              if (src_id->irc_port[less] == port) {
                src_id->last_time_port_used[less] = packet->tick_timestamp;
                found = 1;
                break;
              }
              
              if (src_id->last_time_port_used[less] < oldest_timestamp) {
                oldest_timestamp = src_id->last_time_port_used[less];
                index_to_replace = less;
              }
            }
            
            if (found == 0) {
              if (src_id->irc_number_of_port < NDPI_IRC_MAX_PORTS) {
                src_id->irc_port[src_id->irc_number_of_port] = port;
                src_id->last_time_port_used[src_id->irc_number_of_port] = packet->tick_timestamp;
                src_id->irc_number_of_port++;
              } else if (src_id->irc_number_of_port > 0) {
                // Replace oldest
                src_id->irc_port[index_to_replace] = port;
                src_id->last_time_port_used[index_to_replace] = packet->tick_timestamp;
              }
            }
            
            src_id->irc_ts = packet->tick_timestamp;
          }
          
          if (dst != NULL) {
            // Check if port is already in the list
            u_int8_t found = 0;
            u_int16_t index_to_replace = 0;
            u_int32_t oldest_timestamp = 0xffffffff;
            
            for (less = 0; less < dst->irc_number_of_port; less++) {
              if (dst->irc_port[less] == port) {
                dst->last_time_port_used[less] = packet->tick_timestamp;
                found = 1;
                break;
              }
              
              if (dst->last_time_port_used[less] < oldest_timestamp) {
                oldest_timestamp = dst->last_time_port_used[less];
                index_to_replace = less;
              }
            }
            
            if (found == 0) {
              if (dst->irc_number_of_port < NDPI_IRC_MAX_PORTS) {
                dst->irc_port[dst->irc_number_of_port] = port;
                dst->last_time_port_used[dst->irc_number_of_port] = packet->tick_timestamp;
                dst->irc_number_of_port++;
              } else if (dst->irc_number_of_port > 0) {
                // Replace oldest
                dst->irc_port[index_to_replace] = port;
                dst->last_time_port_used[index_to_replace] = packet->tick_timestamp;
              }
            }
            
            dst->irc_ts = packet->tick_timestamp;
          }
        }
      }
    }
  }
}