// Extract and parse IRC commands from packet lines.
  // Check if the command is one of SEND, CHAT, chat, sslchat, or TSEND.
  // If a command is detected, advance the index to process further.
  // Iterate through the characters in the line to identify spaces and the port number.
  // After the third space, attempt to read the port number from the line.
  // If a valid port is found and the source or destination structure is not NULL, store the port.
  // If the IRC port array is not full, add the new port unless it's a duplicate.
  // If the array is full, replace the least recently used port with the new one if not a duplicate.
  // Update the timestamp of the last IRC activity for source or destination.

  if (packet->payload[packet->payload_packet_len - 2] != 0x0d
      && packet->payload[packet->payload_packet_len - 1] == 0x0a) {
    ndpi_parse_packet_line_info_any(ndpi_struct, flow);
  } else if (packet->payload[packet->payload_packet_len - 2] == 0x0d) {
    ndpi_parse_packet_line_info(ndpi_struct, flow);
  } else {
    return;
  }

  for (i = 0; i < packet->parsed_lines; i++) {
    if (packet->line[i].len > 6 && memcmp(packet->line[i].ptr, "NOTICE ", 7) == 0) {
      NDPI_LOG_DBG2(ndpi_struct, "NOTICE");
      for (j = 7; j < packet->line[i].len - 8; j++) {
        if (packet->line[i].ptr[j] == ':') {
          if (memcmp(&packet->line[i].ptr[j + 1], "DCC SEND ", 9) == 0
              || memcmp(&packet->line[i].ptr[j + 1], "DCC CHAT ", 9) == 0) {
            NDPI_LOG_INFO(ndpi_struct,
                          "found NOTICE and DCC CHAT or DCC SEND.");
          }
        }
      }
    }
    if (packet->payload_packet_len > 0 && packet->payload[0] == 0x3a /* 0x3a = ':' */ ) {
      NDPI_LOG_DBG2(ndpi_struct, "3a");
      for (j = 1; j < packet->line[i].len - 9; j++) {
        if (packet->line[i].ptr[j] == ' ') {
          j++;
          if (packet->line[i].ptr[j] == 'P') {
            NDPI_LOG_DBG2(ndpi_struct, "P");
            j++;
            if (memcmp(&packet->line[i].ptr[j], "RIVMSG ", 7) == 0)
              NDPI_LOG_DBG2(ndpi_struct, "RIVMSG");
            h = j + 7;
            goto read_privmsg;
          }
        }
      }
    }
    if (packet->line[i].len > 7 && (memcmp(packet->line[i].ptr, "PRIVMSG ", 8) == 0)) {
      NDPI_LOG_DBG2(ndpi_struct, "PRIVMSG	");
      h = 7;
    read_privmsg:
      for (j = h; j < packet->line[i].len - 9; j++) {
        if (packet->line[i].ptr[j] == ':') {
          if (memcmp(&packet->line[i].ptr[j + 1], "xdcc ", 5) == 0) {
            NDPI_LOG_DBG2(ndpi_struct, "xdcc should match.");
          }
          j += 2;
          if (memcmp(&packet->line[i].ptr[j], "DCC ", 4) == 0) {
            j += 4;
            NDPI_LOG_DBG2(ndpi_struct, "found DCC.");
            // Extract and parse IRC commands from packet lines.
            // Check if the command is one of SEND, CHAT, chat, sslchat, or TSEND.
            // If a command is detected, advance the index to process further.
            // Iterate through the characters in the line to identify spaces and the port number.
            // After the third space, attempt to read the port number from the line.
            // If a valid port is found and the source or destination structure is not NULL, store the port.
            // If the IRC port array is not full, add the new port unless it's a duplicate.
            // If the array is full, replace the least recently used port with the new one if not a duplicate.
            // Update the timestamp of the last IRC activity for source or destination.

            // Extract the port number
            u_int16_t port = 0;
            while (j < packet->line[i].len && !isspace(packet->line[i].ptr[j])) {
              port = port * 10 + (packet->line[i].ptr[j] - '0');
              j++;
            }

            if (port > 0 && (src_id != NULL || dst != NULL)) {
              if (dst != NULL) {
                for (counter = 0; counter < dst->irc_number_of_port; counter++) {
                  if (dst->irc_port[counter] == port) {
                    dst->last_time_port_used[counter] = packet->tick_timestamp;
                    NDPI_LOG_INFO(ndpi_struct, "found IRC: dest port matched with the DCC port");
                    ndpi_int_irc_add_connection(ndpi_struct, flow);
                    return;
                  }
                }
                if (dst->irc_number_of_port < MAX_IRC_PORTS) {
                  dst->irc_port[dst->irc_number_of_port++] = port;
                  dst->last_time_port_used[dst->irc_number_of_port - 1] = packet->tick_timestamp;
                } else {
                  // Replace the least recently used port
                  u_int16_t least_recently_used_index = 0;
                  u_int32_t least_recently_used_time = UINT32_MAX;
                  for (counter = 0; counter < MAX_IRC_PORTS; counter++) {
                    if (dst->last_time_port_used[counter] < least_recently_used_time) {
                      least_recently_used_time = dst->last_time_port_used[counter];
                      least_recently_used_index = counter;
                    }
                  }
                  if (dst->irc_port[least_recently_used_index] != port) {
                    dst->irc_port[least_recently_used_index] = port;
                    dst->last_time_port_used[least_recently_used_index] = packet->tick_timestamp;
                  }
                }
              }
              if (src_id != NULL) {
                for (counter = 0; counter < src_id->irc_number_of_port; counter++) {
                  if (src_id->irc_port[counter] == port) {
                    src_id->last_time_port_used[counter] = packet->tick_timestamp;
                    NDPI_LOG_INFO(ndpi_struct, "found  IRC: Source port matched with the DCC port");
                    ndpi_int_irc_add_connection(ndpi_struct, flow);
                    return;
                  }
                }
                if (src_id->irc_number_of_port < MAX_IRC_PORTS) {
                  src_id->irc_port[src_id->irc_number_of_port++] = port;
                  src_id->last_time_port_used[src_id->irc_number_of_port - 1] = packet->tick_timestamp;
                } else {
                  // Replace the least recently used port
                  u_int16_t least_recently_used_index = 0;
                  u_int32_t least_recently_used_time = UINT32_MAX;
                  for (counter = 0; counter < MAX_IRC_PORTS; counter++) {
                    if (src_id->last_time_port_used[counter] < least_recently_used_time) {
                      least_recently_used_time = src_id->last_time_port_used[counter];
                      least_recently_used_index = counter;
                    }
                  }
                  if (src_id->irc_port[least_recently_used_index] != port) {
                    src_id->irc_port[least_recently_used_index] = port;
                    src_id->last_time_port_used[least_recently_used_index] = packet->tick_timestamp;
                  }
                }
              }
            }
          }
        }
      }
    }
  }