u_int16_t port_number = 0;
	      u_int8_t found_port = 0;

	      // Extract the port number from the DCC command
	      for (j = 0; j < 5; j++) {
	        if (packet->line[i].ptr[j] >= '0' && packet->line[i].ptr[j] <= '9') {
	          port_number = port_number * 10 + (packet->line[i].ptr[j] - '0');
	        } else if (packet->line[i].ptr[j] == ' ') {
	          break;
	        }
	      }

	      // Check if the port number is valid
	      if (port_number > 0 && port_number <= 65535) {
	        // Check if the source or destination structure is not NULL
	        if (src_id != NULL) {
	          // Check for duplicate port
	          for (k = 0; k < src_id->irc_number_of_port; k++) {
	            if (src_id->irc_port[k] == port_number) {
	              found_port = 1;
	              break;
	            }
	          }
	          // If not a duplicate, add the port
	          if (!found_port && src_id->irc_number_of_port < MAX_IRC_PORTS) {
	            src_id->irc_port[src_id->irc_number_of_port++] = port_number;
	            src_id->last_time_port_used[src_id->irc_number_of_port - 1] = packet->tick_timestamp;
	          }
	        }
	        if (dst != NULL) {
	          // Check for duplicate port
	          found_port = 0;
	          for (k = 0; k < dst->irc_number_of_port; k++) {
	            if (dst->irc_port[k] == port_number) {
	              found_port = 1;
	              break;
	            }
	          }
	          // If not a duplicate, add the port
	          if (!found_port && dst->irc_number_of_port < MAX_IRC_PORTS) {
	            dst->irc_port[dst->irc_number_of_port++] = port_number;
	            dst->last_time_port_used[dst->irc_number_of_port - 1] = packet->tick_timestamp;
	          }
	        }
	      }