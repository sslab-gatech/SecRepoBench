if (packet->payload[packet->payload_packet_len - 2] != 0x0d
    && packet->payload[packet->payload_packet_len - 1] == 0x0a) {
  NDPI_LOG_DBG2(ndpi_struct, "ndpi_parse_packet_line_info_any(ndpi_struct, flow);");
  ndpi_parse_packet_line_info_any(ndpi_struct, flow);
} else if (packet->payload[packet->payload_packet_len - 2] == 0x0d) {
  ndpi_parse_packet_line_info(ndpi_struct, flow);
} else {
  return;
}
for (i = 0; i < packet->parsed_lines; i++) {
  if (packet->line[i].len > 6 && memcmp(packet->line[i].ptr, "NOTICE ", 7) == 0) {
    NDPI_LOG_DBG2(ndpi_struct, "NOTICE");
    for (j = 7; j < packet->line[i].len - 8; j++) {
      if (packet->line[i].ptr[j] == ':') {
	if (memcmp(&packet->line[i].ptr[j + 1], "DCC SEND ", 9) == 0
	    || memcmp(&packet->line[i].ptr[j + 1], "DCC CHAT ", 9) == 0) {
	  NDPI_LOG_INFO(ndpi_struct,
		       "found NOTICE and DCC CHAT or DCC SEND.");
	}
      }
    }
  }
  if (packet->payload_packet_len > 0 && packet->payload[0] == 0x3a /* 0x3a = ':' */ ) {
    NDPI_LOG_DBG2(ndpi_struct, "3a");
    for (j = 1; j < packet->line[i].len - 9; j++) {
      if (packet->line[i].ptr[j] == ' ') {
	j++;
	if (packet->line[i].ptr[j] == 'P') {
	  NDPI_LOG_DBG2(ndpi_struct, "P");
	  j++;
	  if (memcmp(&packet->line[i].ptr[j], "RIVMSG ", 7) == 0)
	    NDPI_LOG_DBG2(ndpi_struct, "RIVMSG");
	  h = j + 7;
	  goto read_privmsg;
	}
      }
    }
  }
  if (packet->line[i].len > 7 && (memcmp(packet->line[i].ptr, "PRIVMSG ", 8) == 0)) {
    NDPI_LOG_DBG2(ndpi_struct, "PRIVMSG	");
    h = 7;
  read_privmsg:
    for (j = h; j < packet->line[i].len - 9; j++) {
      if (packet->line[i].ptr[j] == ':') {
	if (memcmp(&packet->line[i].ptr[j + 1], "xdcc ", 5) == 0) {
	  NDPI_LOG_DBG2(ndpi_struct, "xdcc should match.");
	}
	j += 2;
	if (memcmp(&packet->line[i].ptr[j], "DCC ", 4) == 0) {
	  j += 4;
	  NDPI_LOG_DBG2(ndpi_struct, "found DCC.");
	  // Extract and parse IRC commands from packet lines.
	  // Check if the command is one of SEND, CHAT, chat, sslchat, or TSEND.
	  // If a command is detected, advance the index to process further.
	  // Iterate through the characters in the line to identify spaces and the port number.
	  // After the third space, attempt to read the port number from the line.
	  // If a valid port is found and the source or destination structure is not NULL, store the port.
	  // If the IRC port array is not full, add the new port unless it's a duplicate.
	  // If the array is full, replace the least recently used port with the new one if not a duplicate.
	  // Update the timestamp of the last IRC activity for source or destination.
	  // <MASK>
	}
      }
    }

  }
}