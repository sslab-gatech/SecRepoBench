if (memcmp(&packet->line[i].ptr[j], "DCC ", 4) == 0) {
  j += 4;
  NDPI_LOG_DBG2(ndpi_struct, "found DCC.");
  // Extract and parse IRC commands from packet lines.
  // Check if the command is one of SEND, CHAT, chat, sslchat, or TSEND.
  // If a command is detected, advance the index to process further.
  // Iterate through the characters in the line to identify spaces and the port number.
  // After the third space, attempt to read the port number from the line.
  // If a valid port is found and the source or destination structure is not NULL, store the port.
  // If the IRC port array is not full, add the new port unless it's a duplicate.
  // If the array is full, replace the least recently used port with the new one if not a duplicate.
  // Update the timestamp of the last IRC activity for source or destination.
  for (k = j + 1; k < packet->line[i].len; k++) {
    if (packet->line[i].ptr[k] =='') {
      if (k - j == 3) {
        // Extract the port number from the line.
        u_int16_t port = 0;
        for (h = k + 1; h < packet->line[i].len; h++) {
          if (packet->line[i].ptr[h] =='') {
            break;
          }
          port = (port << 4) | (packet->line[i].ptr[h] - '0');
        }
        // Check if the port is valid.
        if (port > 0 && port < 65536) {
          // Check if the source or destination structure is not NULL.
          if (src_id!= NULL) {
            // Check if the port is not a duplicate.
            if (!ndpi_is_duplicate(src_id, port)) {
              // Add the new port to the IRC port array.
              if (src_id->irc_number_of_port < NDPI_IRC_MAXPORT) {
                src_id->irc_port[src_id->irc_number_of_port] = port;
                src_id->irc_number_of_port++;
              } else {
                // Replace the least recently used port with the new one.
                less = 0;
                NDPI_IRC_FIND_LESS(src_id->last_time_port_used, less);
                src_id->irc_port[less] = port;
                src_id->last_time_port_used[less] = packet->tick_timestamp;
              }
              // Update the timestamp of the last IRC activity for source.
              src_id->irc_ts = packet->tick_timestamp;
            }
          } else if (dst!= NULL) {
            // Check if the port is not a duplicate.
            if (!ndpi_is_duplicate(dst, port)) {
              // Add the new port to the IRC port array.
              if (dst->irc_number_of_port < NDPI_IRC_MAXPORT) {
                dst->irc_port[dst->irc_number_of_port] = port;
                dst->irc_number_of_port++;
              } else {
                // Replace the least recently used port with the new one.
                less = 0;
                NDPI_IRC_FIND_LESS(dst->last_time_port_used, less);
                dst->irc_port[less] = port;
                dst->last_time_port_used[less] = packet->tick_timestamp;
              }
              // Update the timestamp of the last IRC activity for destination.
              dst->irc_ts = packet->tick_timestamp;
            }
          }
        }
      }
    }
  }
}