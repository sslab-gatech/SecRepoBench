// <MASK>
      // Extract and parse IRC commands from packet lines.
      // Check if the command is one of SEND, CHAT, chat, sslchat, or TSEND.
      // If a command is detected, advance the index to process further.
      // Iterate through the characters in the line to identify spaces and the port number.
      // After the third space, attempt to read the port number from the line.
      // If a valid port is found and the source or destination structure is not NULL, store the port.
      // If the IRC port array is not full, add the new port unless it's a duplicate.
      // If the array is full, replace the least recently used port with the new one if not a duplicate.
      // Update the timestamp of the last IRC activity for source or destination.
      if (memcmp(&packet->line[i].ptr[j], "SEND ", 5) == 0 ||
          memcmp(&packet->line[i].ptr[j], "CHAT ", 5) == 0 ||
          memcmp(&packet->line[i].ptr[j], "chat ", 5) == 0 ||
          memcmp(&packet->line[i].ptr[j], "sslchat ", 8) == 0 ||
          memcmp(&packet->line[i].ptr[j], "TSEND ", 6) == 0) {
        j += 5;
        if (memcmp(&packet->line[i].ptr[j], "SEND ", 5) == 0) {
          j += 5;
        } else if (memcmp(&packet->line[i].ptr[j], "CHAT ", 5) == 0) {
          j += 5;
        } else if (memcmp(&packet->line[i].ptr[j], "chat ", 5) == 0) {
          j += 5;
        } else if (memcmp(&packet->line[i].ptr[j], "sslchat ", 8) == 0) {
          j += 8;
        } else if (memcmp(&packet->line[i].ptr[j], "TSEND ", 6) == 0) {
          j += 6;
        }
        
        int spaces = 0;
        for (; j < packet->line[i].len; j++) {
          if (packet->line[i].ptr[j] == ' ') {
            spaces++;
            if (spaces == 3) {
              j++;
              port = atoi(&packet->line[i].ptr[j]);
              if (src_id != NULL && port != 0) {
                if (src_id->irc_number_of_port < NDPI_PROTOCOL_IRC_MAXPORT) {
                  if (!ndpi_is_duplicate(src_id, port)) {
                    src_id->irc_port[src_id->irc_number_of_port] = port;
                    src_id->last_time_port_used[src_id->irc_number_of_port] = packet->tick_timestamp;
                    src_id->irc_number_of_port++;
                  }
                } else {
                  NDPI_IRC_FIND_LESS(src_id->last_time_port_used, less);
                  if (!ndpi_is_duplicate(src_id, port)) {
                    src_id->irc_port[less] = port;
                    src_id->last_time_port_used[less] = packet->tick_timestamp;
                  }
                }
                src_id->irc_ts = packet->tick_timestamp;
              } else if (dst != NULL && port != 0) {
                if (dst->irc_number_of_port < NDPI_PROTOCOL_IRC_MAXPORT) {
                  if (!ndpi_is_duplicate(dst, port)) {
                    dst->irc_port[dst->irc_number_of_port] = port;
                    dst->last_time_port_used[dst->irc_number_of_port] = packet->tick_timestamp;
                    dst->irc_number_of_port++;
                  }
                } else {
                  NDPI_IRC_FIND_LESS(dst->last_time_port_used, less);
                  if (!ndpi_is_duplicate(dst, port)) {
                    dst->irc_port[less] = port;
                    dst->last_time_port_used[less] = packet->tick_timestamp;
                  }
                }
                dst->irc_ts = packet->tick_timestamp;
              }
              break;
            }
          }
        }
      }