if (memcmp(&packet->line[i].ptr[j + 1], "DCC SEND ", 9) == 0
    || memcmp(&packet->line[i].ptr[j + 1], "DCC CHAT ", 9) == 0
    || memcmp(&packet->line[i].ptr[j + 1], "sslchat", 7) == 0
    || memcmp(&packet->line[i].ptr[j + 1], "TSEND", 5) == 0) {
  NDPI_LOG_INFO(ndpi_struct, "found DCC SEND, DCC CHAT, sslchat, or TSEND.");
  // Extract and parse IRC commands from packet lines.
  // Check if the command is one of SEND, CHAT, chat, sslchat, or TSEND.
  // If a command is detected, advance the index to process further.
  // Iterate through the characters in the line to identify spaces and the port number.
  // After the third space, attempt to read the port number from the line.
  // If a valid port is found and the source or destination structure is not NULL, store the port.
  // If the IRC port array is not full, add the new port unless it's a duplicate.
  // If the array is full, replace the least recently used port with the new one if not a duplicate.
  // Update the timestamp of the last IRC activity for source or destination.
  // <MASK>
  if (packet->line[i].ptr[j + 1][0] == 'D' && packet->line[i].ptr[j + 1][1] == 'C' && packet->line[i].ptr[j + 1][2] == 'C') {
    if (packet->line[i].ptr[j + 1][3] =='' && packet->line[i].ptr[j + 1][4] == 'S' && packet->line[i].ptr[j + 1][5] == 'E' && packet->line[i].ptr[j + 1][6] == 'N') {
      // DCC SEND
      if (packet->line[i].ptr[j + 1][7] =='' && packet->line[i].ptr[j + 1][8] =='' && packet->line[i].ptr[j + 1][9] =='') {
        // Extract the port number
        for (k = 10; k < packet->line[i].len - 1; k++) {
          if (packet->line[i].ptr[k] =='') {
            break;
          }
        }
        if (k < packet->line[i].len - 1) {
          port = get_u_int16_t(packet->line[i].ptr + k + 1, packet->line[i].len - k - 1);
          if (port > 0 && port < 65536) {
            if (src_id!= NULL) {
              src_id->irc_port[src_id->irc_number_of_port] = port;
              src_id->irc_number_of_port++;
              src_id->last_time_port_used[src_id->irc_number_of_port - 1] = packet->tick_timestamp;
            } else if (dst!= NULL) {
              dst->irc_port[dst->irc_number_of_port] = port;
              dst->irc_number_of_port++;
              dst->last_time_port_used[dst->irc_number_of_port - 1] = packet->tick_timestamp;
            }
          }
        }
      }
    } else if (packet->line[i].ptr[j + 1][3] =='' && packet->line[i].ptr[j + 1][4] == 'C' && packet->line[i].ptr[j + 1][5] == 'H' && packet->line[i].ptr[j + 1][6] == 'A' && packet->line[i].ptr[j + 1][7] == 'T') {
      // DCC CHAT
      if (packet->line[i].ptr[j + 1][8] =='' && packet->line[i].ptr[j + 1][9] =='') {
        // Extract the port number
        for (k = 10; k < packet->line[i].len - 1; k++) {
          if (packet->line[i].ptr[k] =='') {
            break;
          }
        }
        if (k < packet->line[i].len - 1) {
          port = get_u_int16_t(packet->line[i].ptr + k + 1, packet->line[i].len - k - 1);
          if (port > 0 && port < 65536) {
            if (src_id!= NULL) {
              src_id->irc_port[src_id->irc_number_of_port] = port;
              src_id->irc_number_of_port++;
              src_id->last_time_port_used[src_id->irc_number_of_port - 1] = packet->tick_timestamp;
            } else if (dst!= NULL) {
              dst->irc_port[dst->irc_number_of_port] = port;
              dst->irc_number_of_port++;
              dst->last_time_port_used[dst->irc_number_of_port - 1] = packet->tick_timestamp;
            }
          }
        }
      }
    } else if (packet->line[i].ptr[j + 1][3] =='' && packet->line[i].ptr[j + 1][4] =='s' && packet->line[i].ptr[j + 1][5] =='s' && packet->line[i].ptr[j + 1][6] == 'l' && packet->line[i].ptr[j + 1][7] == 'c' && packet->line[i].ptr[j + 1][8] == 'h' && packet->line[i].ptr[j + 1][9] == 'a' && packet->line[i].ptr[j + 1][10] == 't') {
      // sslchat
      if (packet->line[i].ptr[j + 1][11] =='') {
        // Extract the port number
        for (k = 12; k < packet->line[i].len - 1; k++) {
          if (packet->line[i].ptr[k] =='') {
            break;
          }
        }
        if (k < packet->line[i].len - 1) {
          port = get_u_int16_t(packet->line[i].ptr + k + 1, packet->line[i].len - k - 1);
          if (port > 0 && port < 65536) {
            if (src_id!= NULL) {
              src_id->irc_port[src_id->irc_number_of_port] = port;
              src_id->irc_number_of_port++;
              src_id->last_time_port_used[src_id->irc_number_of_port - 1] = packet->tick_timestamp;
            } else if (dst!= NULL) {
              dst->irc_port[dst->irc_number_of_port] = port;
              dst->irc_number_of_port++;
              dst->last_time_port_used[dst->irc_number_of_port - 1] = packet->tick_timestamp;
            }
          }
        }
      }
    } else if (packet->line[i].ptr[j + 1][3] =='' && packet->line[i].ptr[j + 1][4] == 'T' && packet->line[i].ptr[j + 1][5] == 'S' && packet->line[i].ptr[j + 1][6] == 'E' && packet->line[i].ptr[j + 1][7] == 'N' && packet->line[i].ptr[j + 1][8] == 'D') {
      // TSEND
      if (packet->line[i].ptr[j + 1][9] =='') {
        // Extract the port number
        for (k = 10; k < packet->line[i].len - 1; k++) {
          if (packet->line[i].ptr[k] =='') {
            break;
          }
        }
        if (k < packet->line[i].len - 1) {
          port = get_u_int16_t(packet->line[i].ptr + k + 1, packet->line[i].len - k - 1);
          if (port > 0 && port < 65536) {
            if (src_id!= NULL) {
              src_id->irc_port[src_id->irc_number_of_port] = port;
              src_id->irc_number_of_port++;
              src_id->last_time_port_used[src_id->irc_number_of_port - 1] = packet->tick_timestamp;
            } else if (dst!= NULL) {
              dst->irc_port[dst->irc_number_of_port] = port;
              dst->irc_number_of_port++;
              dst->last_time_port_used[dst->irc_number_of_port - 1] = packet->tick_timestamp;
            }
          }
        }
      }
    }
  }
}