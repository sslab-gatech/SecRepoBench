if (memcmp(&packet->line[i].ptr[j], "SEND ", 5) == 0 ||
    memcmp(&packet->line[i].ptr[j], "CHAT ", 5) == 0 ||
    memcmp(&packet->line[i].ptr[j], "chat ", 5) == 0 ||
    memcmp(&packet->line[i].ptr[j], "sslchat ", 8) == 0 ||
    memcmp(&packet->line[i].ptr[j], "TSEND ", 6) == 0) {
  
  NDPI_LOG_DBG2(ndpi_struct, "found DCC CHAT, SEND, TSEND.");
  
  space = 0;
  for (j++; j < packet->line[i].len - 1; j++) {
    if (packet->line[i].ptr[j] == ' ') {
      space++;
      if (space == 3) {
        j++;
        
        port = 0;
        for (; j < packet->line[i].len - 1; j++) {
          if (packet->line[i].ptr[j] >= '0' && packet->line[i].ptr[j] <= '9') {
            port = port * 10 + (packet->line[i].ptr[j] - '0');
          } else {
            break;
          }
        }
        
        NDPI_LOG_DBG2(ndpi_struct, "found port=%u", port);
        
        if (port != 0) {
          if (src_id != NULL) {
            if (packet->tcp->source == port) {
              NDPI_LOG_DBG2(ndpi_struct, "source port matched.");
              if (src_id->irc_number_of_port < NDPI_MAX_IRC_PORTS) {
                for (k = 0; k < src_id->irc_number_of_port; k++) {
                  if (src_id->irc_port[k] == port) {
                    src_id->last_time_port_used[k] = packet->tick_timestamp;
                    break;
                  }
                }
                
                if (k == src_id->irc_number_of_port) {
                  src_id->irc_port[src_id->irc_number_of_port] = port;
                  src_id->last_time_port_used[src_id->irc_number_of_port] = packet->tick_timestamp;
                  src_id->irc_number_of_port++;
                }
              } else {
                less = 0;
                for (k = 0; k < NDPI_MAX_IRC_PORTS; k++) {
                  if (src_id->last_time_port_used[k] < src_id->last_time_port_used[less]) {
                    less = k;
                  }
                }
                
                for (k = 0; k < NDPI_MAX_IRC_PORTS; k++) {
                  if (src_id->irc_port[k] == port) {
                    src_id->last_time_port_used[k] = packet->tick_timestamp;
                    break;
                  }
                }
                
                if (k == NDPI_MAX_IRC_PORTS) {
                  src_id->irc_port[less] = port;
                  src_id->last_time_port_used[less] = packet->tick_timestamp;
                }
              }
            }
            
            src_id->irc_ts = packet->tick_timestamp;
          }
          
          if (dst != NULL) {
            if (packet->tcp->dest == port) {
              NDPI_LOG_DBG2(ndpi_struct, "destination port matched.");
              if (dst->irc_number_of_port < NDPI_MAX_IRC_PORTS) {
                for (k = 0; k < dst->irc_number_of_port; k++) {
                  if (dst->irc_port[k] == port) {
                    dst->last_time_port_used[k] = packet->tick_timestamp;
                    break;
                  }
                }
                
                if (k == dst->irc_number_of_port) {
                  dst->irc_port[dst->irc_number_of_port] = port;
                  dst->last_time_port_used[dst->irc_number_of_port] = packet->tick_timestamp;
                  dst->irc_number_of_port++;
                }
              } else {
                less = 0;
                for (k = 0; k < NDPI_MAX_IRC_PORTS; k++) {
                  if (dst->last_time_port_used[k] < dst->last_time_port_used[less]) {
                    less = k;
                  }
                }
                
                for (k = 0; k < NDPI_MAX_IRC_PORTS; k++) {
                  if (dst->irc_port[k] == port) {
                    dst->last_time_port_used[k] = packet->tick_timestamp;
                    break;
                  }
                }
                
                if (k == NDPI_MAX_IRC_PORTS) {
                  dst->irc_port[less] = port;
                  dst->last_time_port_used[less] = packet->tick_timestamp;
                }
              }
            }
            
            dst->irc_ts = packet->tick_timestamp;
          }
        }
        break;
      }
    }
  }
}