// Extract and parse IRC commands from packet lines.
// Check if the command is one of SEND, CHAT, chat, sslchat, or TSEND.
if(memcmp(&packet->line[i].ptr[j], "SEND ", 5) == 0 ||
   memcmp(&packet->line[i].ptr[j], "CHAT ", 5) == 0 ||
   memcmp(&packet->line[i].ptr[j], "chat ", 5) == 0 ||
   memcmp(&packet->line[i].ptr[j], "sslchat ", 8) == 0 ||
   memcmp(&packet->line[i].ptr[j], "TSEND ", 6) == 0) {
  
  // Advance j based on which command was detected
  if(memcmp(&packet->line[i].ptr[j], "SEND ", 5) == 0 ||
     memcmp(&packet->line[i].ptr[j], "CHAT ", 5) == 0 ||
     memcmp(&packet->line[i].ptr[j], "chat ", 5) == 0) {
    j += 5;
  } else if(memcmp(&packet->line[i].ptr[j], "sslchat ", 8) == 0) {
    j += 8;
  } else if(memcmp(&packet->line[i].ptr[j], "TSEND ", 6) == 0) {
    j += 6;
  }
  
  // Iterate through characters to identify spaces and the port number
  for(k = j; k < packet->line[i].len - 1; k++) {
    if(packet->line[i].ptr[k] == ' ') {
      if(space == 2) {
        // After the third space, attempt to read the port number
        space = 3;
        k++;
        
        // Try to read the port number
        port = 0;
        while(k < packet->line[i].len - 1 && packet->line[i].ptr[k] >= '0' && packet->line[i].ptr[k] <= '9') {
          port = port * 10 + (packet->line[i].ptr[k] - '0');
          k++;
        }
        
        NDPI_LOG_DBG2(ndpi_struct, "port = %u\n", port);
        
        if(port != 0) {
          // If a valid port is found and source is not NULL, store the port
          if(src_id != NULL) {
            less = 0;
            
            // If the IRC port array is not full, add the new port unless it's a duplicate
            if(src_id->irc_number_of_port < NDPI_MAX_IRC_CHANNELS) {
              for(h = 0; h < src_id->irc_number_of_port; h++) {
                if(src_id->irc_port[h] == port) {
                  // Already have this port, just update timestamp
                  src_id->last_time_port_used[h] = packet->tick_timestamp;
                  less = 1;
                  break;
                }
              }
              
              if(less == 0) {
                // Not a duplicate, add it to the array
                src_id->irc_port[src_id->irc_number_of_port] = port;
                src_id->last_time_port_used[src_id->irc_number_of_port] = packet->tick_timestamp;
                src_id->irc_number_of_port++;
              }
            } else {
              // Array is full, replace the least recently used port if not a duplicate
              for(h = 0; h < NDPI_MAX_IRC_CHANNELS; h++) {
                if(src_id->irc_port[h] == port) {
                  src_id->last_time_port_used[h] = packet->tick_timestamp;
                  less = 1;
                  break;
                }
              }
              
              if(less == 0) {
                // Not already there, find the oldest port to replace
                u_int32_t min_time = src_id->last_time_port_used[0];
                int min_idx = 0;
                
                for(h = 1; h < NDPI_MAX_IRC_CHANNELS; h++) {
                  if(src_id->last_time_port_used[h] < min_time) {
                    min_time = src_id->last_time_port_used[h];
                    min_idx = h;
                  }
                }
                
                // Replace the oldest port
                src_id->irc_port[min_idx] = port;
                src_id->last_time_port_used[min_idx] = packet->tick_timestamp;
              }
            }
            
            // Update the timestamp of last IRC activity for source
            src_id->irc_ts = packet->tick_timestamp;
          }
          
          // Same logic for destination
          if(dst != NULL) {
            less = 0;
            
            if(dst->irc_number_of_port < NDPI_MAX_IRC_CHANNELS) {
              for(h = 0; h < dst->irc_number_of_port; h++) {
                if(dst->irc_port[h] == port) {
                  dst->last_time_port_used[h] = packet->tick_timestamp;
                  less = 1;
                  break;
                }
              }
              
              if(less == 0) {
                dst->irc_port[dst->irc_number_of_port] = port;
                dst->last_time_port_used[dst->irc_number_of_port] = packet->tick_timestamp;
                dst->irc_number_of_port++;
              }
            } else {
              for(h = 0; h < NDPI_MAX_IRC_CHANNELS; h++) {
                if(dst->irc_port[h] == port) {
                  dst->last_time_port_used[h] = packet->tick_timestamp;
                  less = 1;
                  break;
                }
              }
              
              if(less == 0) {
                u_int32_t min_time = dst->last_time_port_used[0];
                int min_idx = 0;
                
                for(h = 1; h < NDPI_MAX_IRC_CHANNELS; h++) {
                  if(dst->last_time_port_used[h] < min_time) {
                    min_time = dst->last_time_port_used[h];
                    min_idx = h;
                  }
                }
                
                dst->irc_port[min_idx] = port;
                dst->last_time_port_used[min_idx] = packet->tick_timestamp;
              }
            }
            
            dst->irc_ts = packet->tick_timestamp;
          }
        }
        break;
      } else {
        space++;
      }
    }
  }
}