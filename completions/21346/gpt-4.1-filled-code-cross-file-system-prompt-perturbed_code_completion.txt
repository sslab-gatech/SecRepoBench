// Check for DCC command types
	      if ((memcmp(&packet->line[i].ptr[j], "SEND ", 5) == 0) ||
		  (memcmp(&packet->line[i].ptr[j], "CHAT ", 5) == 0) ||
		  (memcmp(&packet->line[i].ptr[j], "chat ", 5) == 0) ||
		  (memcmp(&packet->line[i].ptr[j], "sslchat ", 8) == 0) ||
		  (memcmp(&packet->line[i].ptr[j], "TSEND ", 6) == 0)) {
		// Advance j to after the command
		if (memcmp(&packet->line[i].ptr[j], "SEND ", 5) == 0) j += 5;
		else if (memcmp(&packet->line[i].ptr[j], "CHAT ", 5) == 0) j += 5;
		else if (memcmp(&packet->line[i].ptr[j], "chat ", 5) == 0) j += 5;
		else if (memcmp(&packet->line[i].ptr[j], "sslchat ", 8) == 0) j += 8;
		else if (memcmp(&packet->line[i].ptr[j], "TSEND ", 6) == 0) j += 6;
		// Now, skip to the port number (after 3 spaces)
		int space_count = 0;
		u_int16_t port_candidate = 0;
		u_int16_t port_found = 0;
		u_int16_t l = j;
		while (l < packet->line[i].len) {
		  if (packet->line[i].ptr[l] == ' ') {
		    space_count++;
		    if (space_count == 3) {
		      // Try to read the port number
		      l++;
		      // Read up to 6 digits
		      char portbuf[7] = {0};
		      u_int16_t m = 0;
		      while (l < packet->line[i].len && m < 6 && packet->line[i].ptr[l] >= '0' && packet->line[i].ptr[l] <= '9') {
			portbuf[m++] = packet->line[i].ptr[l++];
		      }
		      port_candidate = (u_int16_t)atoi(portbuf);
		      if (port_candidate > 0 && port_candidate < 65536) {
			port_found = port_candidate;
		      }
		      break;
		    }
		  }
		  l++;
		}
		if (port_found && (src_id != NULL || dst != NULL)) {
		  struct ndpi_id_struct *id = src_id ? src_id : dst;
		  u_int16_t *irc_ports = id->irc_port;
		  u_int16_t *last_time = id->last_time_port_used;
		  u_int16_t *num_ports = &id->irc_number_of_port;
		  int found = 0;
		  for (k = 0; k < *num_ports; k++) {
		    if (irc_ports[k] == port_found) {
		      found = 1;
		      last_time[k] = packet->tick_timestamp;
		      break;
		    }
		  }
		  if (!found) {
		    if (*num_ports < NDPI_MAX_IRC_PORTS) {
		      irc_ports[*num_ports] = port_found;
		      last_time[*num_ports] = packet->tick_timestamp;
		      (*num_ports)++;
		    } else {
		      // Replace the least recently used port
		      u_int16_t min_idx = 0;
		      for (k = 1; k < NDPI_MAX_IRC_PORTS; k++) {
			if (last_time[k] < last_time[min_idx])
			  min_idx = k;
		      }
		      irc_ports[min_idx] = port_found;
		      last_time[min_idx] = packet->tick_timestamp;
		    }
		  }
		  id->irc_ts = packet->tick_timestamp;
		}
	      }