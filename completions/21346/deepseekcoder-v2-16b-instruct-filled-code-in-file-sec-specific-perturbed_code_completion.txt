if (packet->payload_packet_len > 0 && packet->payload[0] == 0x3a /* 0x3a = ':' */ ) {
    NDPI_LOG_DBG2(ndpi_struct, "3a");
    for (j = 1; j < packet->line[i].len - 9; j++) {
      if (packet->line[i].ptr[j] == ' ') {
        j++;
        if (packet->line[i].ptr[j] == 'P') {
          NDPI_LOG_DBG2(ndpi_struct, "P");
          j++;
          if (memcmp(&packet->line[i].ptr[j], "RIVMSG ", 7) == 0)
            NDPI_LOG_DBG2(ndpi_struct, "RIVMSG");
          h = j + 7;
          goto read_privmsg;
        }
      }
    }
  }
  if (packet->line[i].len > 7 && (memcmp(packet->line[i].ptr, "PRIVMSG ", 8) == 0)) {
    NDPI_LOG_DBG2(ndpi_struct, "PRIVMSG	");
    h = 7;
  read_privmsg:
    for (j = h; j < packet->line[i].len - 9; j++) {
      if (packet->line[i].ptr[j] == ':') {
        if (memcmp(&packet->line[i].ptr[j + 1], "xdcc ", 5) == 0) {
          NDPI_LOG_DBG2(ndpi_struct, "xdcc should match.");
        }
        j += 2;
        if (memcmp(&packet->line[i].ptr[j], "DCC ", 4) == 0) {
          j += 4;
          NDPI_LOG_DBG2(ndpi_struct, "found DCC.");
          // Extract and parse IRC commands from packet lines.
          // Check if the command is one of SEND, CHAT, chat, sslchat, or TSEND.
          // If a command is detected, advance the index to process further.
          // Iterate through the characters in the line to identify spaces and the port number.
          // After the third space, attempt to read the port number from the line.
          // If a valid port is found and the source or destination structure is not NULL, store the port.
          // If the IRC port array is not full, add the new port unless it's a duplicate.
          // If the array is full, replace the least recently used port with the new one if not a duplicate.
          // Update the timestamp of the last IRC activity for source or destination.
          u_int16_t port = 0;
          u_int8_t space_count = 0;
          for (; j < packet->line[i].len; j++) {
            if (packet->line[i].ptr[j] == ' ') {
              space_count++;
              if (space_count == 3) break;
            }
            port = (port * 10) + (packet->line[i].ptr[j] - '0');
          }
          if (space_count == 3 && src_id != NULL && dst != NULL) {
            if (!ndpi_is_duplicate(src_id, port) && src_id->irc_number_of_port < NDPI_PROTOCOL_IRC_MAXPORT) {
              src_id->irc_port[src_id->irc_number_of_port++] = port;
            }
            if (!ndpi_is_duplicate(dst, port) && dst->irc_number_of_port < NDPI_PROTOCOL_IRC_MAXPORT) {
              dst->irc_port[dst->irc_number_of_port++] = port;
            }
          }
        }
      }
    }
  }