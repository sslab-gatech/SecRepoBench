if (memcmp(&packet->line[i].ptr[j], "SEND ", 5) == 0
    || memcmp(&packet->line[i].ptr[j], "CHAT ", 5) == 0
    || memcmp(&packet->line[i].ptr[j], "chat ", 5) == 0
    || memcmp(&packet->line[i].ptr[j], "sslchat ", 8) == 0
    || memcmp(&packet->line[i].ptr[j], "TSEND ", 6) == 0) {
  j += ((packet->line[i].ptr[j] == 'T') ? 6 : ((packet->line[i].ptr[j] == 's' && packet->line[i].ptr[j+7] == 'c') ? 8 : 5));
  space = 0;
  
  for (k = j; k < packet->line[i].len - 10; k++) {
    if (packet->line[i].ptr[k] == ' ') {
      space++;
      if (space == 3) {
        port = ntohs(get_u_int16_t(&packet->line[i].ptr[k + 1], 2));
        break;
      }
    }
  }

  if (port != 0) {
    if (src_id != NULL) {
      if (src_id->irc_number_of_port < NDPI_MAX_PORTS_PER_HOST) {
        int duplicate = 0;
        for (h = 0; h < src_id->irc_number_of_port; h++) {
          if (src_id->irc_port[h] == port) {
            duplicate = 1;
            break;
          }
        }
        if (!duplicate) {
          src_id->irc_port[src_id->irc_number_of_port++] = port;
          src_id->last_time_port_used[src_id->irc_number_of_port - 1] = packet->tick_timestamp;
        }
      } else {
        // Replace the least recently used port if not a duplicate.
        u_int32_t oldest = packet->tick_timestamp;
        u_int16_t replace_idx = 0;

        for (h = 0; h < NDPI_MAX_PORTS_PER_HOST; h++) {
          if (src_id->last_time_port_used[h] < oldest) {
            oldest = src_id->last_time_port_used[h];
            replace_idx = h;
          }
        }

        src_id->irc_port[replace_idx] = port;
        src_id->last_time_port_used[replace_idx] = packet->tick_timestamp;
      }
    }

    if (dst != NULL) {
      if (dst->irc_number_of_port < NDPI_MAX_PORTS_PER_HOST) {
        int duplicate = 0;
        for (h = 0; h < dst->irc_number_of_port; h++) {
          if (dst->irc_port[h] == port) {
            duplicate = 1;
            break;
          }
        }
        if (!duplicate) {
          dst->irc_port[dst->irc_number_of_port++] = port;
          dst->last_time_port_used[dst->irc_number_of_port - 1] = packet->tick_timestamp;
        }
      } else {
        // Replace the least recently used port if not a duplicate.
        u_int32_t oldest = packet->tick_timestamp;
        u_int16_t replace_idx = 0;

        for (h = 0; h < NDPI_MAX_PORTS_PER_HOST; h++) {
          if (dst->last_time_port_used[h] < oldest) {
            oldest = dst->last_time_port_used[h];
            replace_idx = h;
          }
        }

        dst->irc_port[replace_idx] = port;
        dst->last_time_port_used[replace_idx] = packet->tick_timestamp;
      }
    }
  }

  if (src_id != NULL) {
    src_id->irc_ts = packet->tick_timestamp;
  }

  if (dst != NULL) {
    dst->irc_ts = packet->tick_timestamp;
  }
}