if (j + 4 < packet->line[i].len && memcmp(&packet->line[i].ptr[j], "SEND", 4) == 0) {
		// Handle DCC SEND command
		// Extract port number if available
		if (j + 6 < packet->line[i].len) {
		  u_int16_t port_number = (packet->line[i].ptr[j + 5] - '0') * 1000 + 
					  (packet->line[i].ptr[j + 6] - '0') * 100 + 
					  (packet->line[i].ptr[j + 7] - '0') * 10 + 
					  (packet->line[i].ptr[j + 8] - '0');
		  // Store the port number in the appropriate structure
		  if (src_id != NULL && src_id->irc_number_of_port < MAX_IRC_PORTS) {
		    src_id->irc_port[src_id->irc_number_of_port++] = port_number;
		    src_id->last_time_port_used[src_id->irc_number_of_port - 1] = packet->tick_timestamp;
		  } else if (dst != NULL && dst->irc_number_of_port < MAX_IRC_PORTS) {
		    dst->irc_port[dst->irc_number_of_port++] = port_number;
		    dst->last_time_port_used[dst->irc_number_of_port - 1] = packet->tick_timestamp;
		  }
		}
	      }
	      if (j + 4 < packet->line[i].len && memcmp(&packet->line[i].ptr[j], "CHAT", 4) == 0) {
		// Handle DCC CHAT command
		// Similar port extraction logic as above
		if (j + 6 < packet->line[i].len) {
		  u_int16_t port_number = (packet->line[i].ptr[j + 5] - '0') * 1000 + 
					  (packet->line[i].ptr[j + 6] - '0') * 100 + 
					  (packet->line[i].ptr[j + 7] - '0') * 10 + 
					  (packet->line[i].ptr[j + 8] - '0');
		  // Store the port number in the appropriate structure
		  if (src_id != NULL && src_id->irc_number_of_port < MAX_IRC_PORTS) {
		    src_id->irc_port[src_id->irc_number_of_port++] = port_number;
		    src_id->last_time_port_used[src_id->irc_number_of_port - 1] = packet->tick_timestamp;
		  } else if (dst != NULL && dst->irc_number_of_port < MAX_IRC_PORTS) {
		    dst->irc_port[dst->irc_number_of_port++] = port_number;
		    dst->last_time_port_used[dst->irc_number_of_port - 1] = packet->tick_timestamp;
		  }
		}
	      }