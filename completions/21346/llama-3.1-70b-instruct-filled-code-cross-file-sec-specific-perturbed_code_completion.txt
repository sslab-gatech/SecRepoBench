// Extract and parse IRC commands from packet lines.
// Check if the command is one of SEND, CHAT, chat, sslchat, or TSEND.
// If a command is detected, advance the index to process further.
// Iterate through the characters in the line to identify spaces and the port number.
// After the third space, attempt to read the port number from the line.
// If a valid port is found and the source or destination structure is not NULL, store the port.
// If the IRC port array is not full, add the new port unless it's a duplicate.
// If the array is full, replace the least recently used port with the new one if not a duplicate.
// Update the timestamp of the last IRC activity for source or destination.
for (j += 5; j < packet->line[i].len; j++) {
  if (packet->line[i].ptr[j] =='') {
    space++;
    if (space == 3) {
      k = j + 1;
      while (k < packet->line[i].len && packet->line[i].ptr[k]!='') {
	k++;
      }
      port = (u_int16_t)atoi((char *)&packet->line[i].ptr[j + 1]);
      if (port > 0 && port < 65536) {
	if (dst!= NULL) {
	  less = 0;
	  for (counter = 0; counter < dst->irc_number_of_port; counter++) {
	    if (dst->irc_port[counter] == port) {
	      less = 1;
	      break;
	    }
	  }
	  if (less == 0) {
	    if (dst->irc_number_of_port < MAX_IRC_PORT) {
	      dst->irc_port[dst->irc_number_of_port] = port;
	      dst->last_time_port_used[dst->irc_number_of_port] = packet->tick_timestamp;
	      dst->irc_number_of_port++;
	    } else {
	      less = 0;
	      for (counter = 0; counter < dst->irc_number_of_port; counter++) {
		if (dst->last_time_port_used[counter] < dst->last_time_port_used[less]) {
		  less = counter;
		}
	      }
	      if (dst->irc_port[less]!= port) {
		dst->irc_port[less] = port;
		dst->last_time_port_used[less] = packet->tick_timestamp;
	      }
	    }
	  }
	}
	if (src_id!= NULL) {
	  less = 0;
	  for (counter = 0; counter < src_id->irc_number_of_port; counter++) {
	    if (src_id->irc_port[counter] == port) {
	      less = 1;
	      break;
	    }
	  }
	  if (less == 0) {
	    if (src_id->irc_number_of_port < MAX_IRC_PORT) {
	      src_id->irc_port[src_id->irc_number_of_port] = port;
	      src_id->last_time_port_used[src_id->irc_number_of_port] = packet->tick_timestamp;
	      src_id->irc_number_of_port++;
	    } else {
	      less = 0;
	      for (counter = 0; counter < src_id->irc_number_of_port; counter++) {
		if (src_id->last_time_port_used[counter] < src_id->last_time_port_used[less]) {
		  less = counter;
		}
	      }
	      if (src_id->irc_port[less]!= port) {
		src_id->irc_port[less] = port;
		src_id->last_time_port_used[less] = packet->tick_timestamp;
	      }
	    }
	  }
	}
      }
    }
  }
}