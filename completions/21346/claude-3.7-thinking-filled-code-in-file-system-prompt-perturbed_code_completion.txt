if (memcmp(&packet->line[i].ptr[j], "SEND ", 5) == 0 ||
    memcmp(&packet->line[i].ptr[j], "CHAT ", 5) == 0 ||
    memcmp(&packet->line[i].ptr[j], "chat ", 5) == 0 ||
    memcmp(&packet->line[i].ptr[j], "sslchat ", 8) == 0 ||
    memcmp(&packet->line[i].ptr[j], "TSEND ", 6) == 0) {
  NDPI_LOG_DBG2(ndpi_struct, "found CHAT, SEND, chat, sslchat, or TSEND.");
  
  // Advance j to the command we found
  if (memcmp(&packet->line[i].ptr[j], "SEND ", 5) == 0)
    j += 5;
  else if (memcmp(&packet->line[i].ptr[j], "CHAT ", 5) == 0)
    j += 5;
  else if (memcmp(&packet->line[i].ptr[j], "chat ", 5) == 0)
    j += 5;
  else if (memcmp(&packet->line[i].ptr[j], "sslchat ", 8) == 0)
    j += 8;
  else if (memcmp(&packet->line[i].ptr[j], "TSEND ", 6) == 0)
    j += 6;
  
  // Find the third space which should precede the port number
  space = 0;
  for (; j < packet->line[i].len; j++) {
    if (packet->line[i].ptr[j] == ' ') {
      space++;
      if (space == 3) {
        j++; // Move past the space
        
        // Try to read the port number
        if (j + 1 < packet->line[i].len) {
          port = 0;
          for (; j < packet->line[i].len && packet->line[i].ptr[j] >= '0' && 
               packet->line[i].ptr[j] <= '9'; j++) {
            port = port * 10 + (packet->line[i].ptr[j] - '0');
          }
          
          // If we got a valid port and have a source or destination structure, store it
          if (port > 0) {
            if (src_id != NULL) {
              if (src_id->irc_number_of_port < NDPI_PROTOCOL_IRC_MAXPORT) {
                // Check if the port is already known
                if (!ndpi_is_duplicate(src_id, port)) {
                  src_id->irc_port[src_id->irc_number_of_port] = port;
                  src_id->irc_ts = packet->tick_timestamp;
                  src_id->last_time_port_used[src_id->irc_number_of_port] = packet->tick_timestamp;
                  src_id->irc_number_of_port++;
                  NDPI_LOG_DBG2(ndpi_struct, "added port to src");
                }
              } else {
                // If the array is full, replace the oldest port
                NDPI_IRC_FIND_LESS(src_id->last_time_port_used, less);
                if (!ndpi_is_duplicate(src_id, port)) {
                  src_id->irc_port[less] = port;
                  src_id->irc_ts = packet->tick_timestamp;
                  src_id->last_time_port_used[less] = packet->tick_timestamp;
                  NDPI_LOG_DBG2(ndpi_struct, "replaced port in src");
                }
              }
              src_id->irc_ts = packet->tick_timestamp;
            }
            
            if (dst != NULL) {
              if (dst->irc_number_of_port < NDPI_PROTOCOL_IRC_MAXPORT) {
                if (!ndpi_is_duplicate(dst, port)) {
                  dst->irc_port[dst->irc_number_of_port] = port;
                  dst->irc_ts = packet->tick_timestamp;
                  dst->last_time_port_used[dst->irc_number_of_port] = packet->tick_timestamp;
                  dst->irc_number_of_port++;
                  NDPI_LOG_DBG2(ndpi_struct, "added port to dst");
                }
              } else {
                NDPI_IRC_FIND_LESS(dst->last_time_port_used, less);
                if (!ndpi_is_duplicate(dst, port)) {
                  dst->irc_port[less] = port;
                  dst->irc_ts = packet->tick_timestamp;
                  dst->last_time_port_used[less] = packet->tick_timestamp;
                  NDPI_LOG_DBG2(ndpi_struct, "replaced port in dst");
                }
              }
              dst->irc_ts = packet->tick_timestamp;
            }
          }
        }
        break; // We've processed the port, no need to continue the loop
      }
    }
  }
}