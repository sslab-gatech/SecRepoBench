// Extract the port number from the PRIVMSG line
	      int space_count = 0;
	      u_int16_t extracted_port = 0;
	      for (k = j; k < packet->line[i].len; k++) {
	        if (packet->line[i].ptr[k] == ' ') {
	          space_count++;
	          if (space_count == 3) {
	            // Attempt to read the port number
	            extracted_port = (u_int16_t)atoi(&packet->line[i].ptr[k + 1]);
	            break;
	          }
	        }
	      }

	      if (extracted_port > 0) {
	        struct ndpi_id_struct *target_id = (src_id != NULL) ? src_id : dst;
	        if (target_id != NULL) {
	          // Check if the port is already in the list
	          int port_exists = 0;
	          for (counter = 0; counter < target_id->irc_number_of_port; counter++) {
	            if (target_id->irc_port[counter] == extracted_port) {
	              port_exists = 1;
	              target_id->last_time_port_used[counter] = packet->tick_timestamp;
	              break;
	            }
	          }

	          if (!port_exists) {
	            if (target_id->irc_number_of_port < MAX_IRC_PORTS) {
	              // Add the new port
	              target_id->irc_port[target_id->irc_number_of_port] = extracted_port;
	              target_id->last_time_port_used[target_id->irc_number_of_port] = packet->tick_timestamp;
	              target_id->irc_number_of_port++;
	            } else {
	              // Replace the least recently used port
	              u_int16_t oldest_index = 0;
	              for (counter = 1; counter < MAX_IRC_PORTS; counter++) {
	                if (target_id->last_time_port_used[counter] < target_id->last_time_port_used[oldest_index]) {
	                  oldest_index = counter;
	                }
	              }
	              target_id->irc_port[oldest_index] = extracted_port;
	              target_id->last_time_port_used[oldest_index] = packet->tick_timestamp;
	            }
	          }
	        }
	      }