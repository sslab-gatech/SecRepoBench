{
  /* Parse various DCC subcommands (SEND, CHAT, sslchat, TSEND, etc.) and extract the port number. */
  static const char *dcc_cmds[] = { "DCC SEND ", "DCC CHAT ", "DCC TSEND ", "DCC chat ", "DCC sslchat " };
  #define NDPI_NUM_DCC_CMDS (sizeof(dcc_cmds)/sizeof(dcc_cmds[0]))

  for (k = 0; k < NDPI_NUM_DCC_CMDS; k++) {
    u_int16_t cmd_len = (u_int16_t)strlen(dcc_cmds[k]);
    if((packet->line[i].len > (j+1+cmd_len)) &&
       (memcmp(&packet->line[i].ptr[j+1], dcc_cmds[k], cmd_len) == 0)) {

      NDPI_LOG_INFO(ndpi_struct, "found DCC subcommand: %.*s",
                    cmd_len-1, &packet->line[i].ptr[j+1+4]); /* e.g. "SEND", "CHAT", etc. */

      /* Move pointer after "DCC SEND " or "DCC CHAT ", etc. to parse the subsequent tokens. */
      /* The format is typically: DCC SEND <filename> <ip> <port> <size> */
      {
        u_int16_t dcc_port = 0;
        char *dcc_ptr = (char *)&packet->line[i].ptr[j+1+cmd_len];
        char *dcc_end = (char *)&packet->line[i].ptr[packet->line[i].len];
        char *endptr;
        int spaces_found = 0;

        /* Skip at least two fields (filename/ip) to reach the port. */
        while(dcc_ptr < dcc_end && spaces_found < 2) {
          if(*dcc_ptr == ' ') spaces_found++;
          dcc_ptr++;
        }

        /* Convert the next token to integer (port). */
        dcc_port = (u_int16_t)strtoul(dcc_ptr, &endptr, 10);
        if(dcc_port) {
          NDPI_LOG_DBG2(ndpi_struct, "DCC port candidate: %u\n", dcc_port);

          /* Helper macro to store the given port in the provided id_struct. */
          #define NDPI_IRC_STORE_PORT(id_struct) do {                                   \
            if((id_struct) != NULL) {                                                  \
              u_int16_t idx, replace_idx = 0;                                          \
              /* Check if we already have this port stored. */                         \
              for(idx = 0; idx < (id_struct)->irc_number_of_port; idx++) {             \
                if((id_struct)->irc_port[idx] == dcc_port) {                           \
                  (id_struct)->last_time_port_used[idx] = packet->tick_timestamp;      \
                  goto port_stored;                                                    \
                }                                                                      \
              }                                                                        \
              /* If not found, add or replace. */                                      \
              if((id_struct)->irc_number_of_port < NDPI_MAX_PORTS) {                   \
                (id_struct)->irc_port[(id_struct)->irc_number_of_port] = dcc_port;     \
                (id_struct)->last_time_port_used[(id_struct)->irc_number_of_port] =    \
                  packet->tick_timestamp;                                              \
                (id_struct)->irc_number_of_port++;                                     \
              } else {                                                                 \
                /* Replace the least recently used port. */                            \
                u_int32_t oldest = (id_struct)->last_time_port_used[0];                \
                for(idx = 1; idx < NDPI_MAX_PORTS; idx++) {                            \
                  if((id_struct)->last_time_port_used[idx] < oldest) {                 \
                    oldest = (id_struct)->last_time_port_used[idx];                    \
                    replace_idx = idx;                                                 \
                  }                                                                    \
                }                                                                      \
                (id_struct)->irc_port[replace_idx] = dcc_port;                         \
                (id_struct)->last_time_port_used[replace_idx] = packet->tick_timestamp;\
              }                                                                        \
            }                                                                          \
            port_stored: ;                                                            \
          } while(0)

          /* Now store the parsed port in the source/dest IRC port lists. */
          NDPI_IRC_STORE_PORT(src_id);
          NDPI_IRC_STORE_PORT(dst);

          #undef NDPI_IRC_STORE_PORT
        }
      }
      /* We can break after handling the first recognized DCC command. */
      break;
    }
  }
}