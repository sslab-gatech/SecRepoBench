// Extract and parse IRC commands from packet lines.
// Check if the command is one of SEND, CHAT, chat, sslchat, or TSEND.
// If a command is detected, advance the index to process further.
// Iterate through the characters in the line to identify spaces and the port number.
// After the third space, attempt to read the port number from the line.
// If a valid port is found and the source or destination structure is not NULL, store the port.
// If the IRC port array is not full, add the new port unless it's a duplicate.
// If the array is full, replace the least recently used port with the new one if not a duplicate.
// Update the timestamp of the last IRC activity for source or destination.
for (k = j; k < packet->line[i].len; k++) {
  if (packet->line[i].ptr[k] == ' ') {
    space++;
    if (space == 3) {
      port = atoi(&packet->line[i].ptr[k + 1]);
      if (port > 0 && port < 65536) {
        if (src_id != NULL) {
          for (h = 0; h < src_id->irc_number_of_port; h++) {
            if (src_id->irc_port[h] == port) {
              src_id->last_time_port_used[h] = packet->tick_timestamp;
              break;
            }
          }
          if (h == src_id->irc_number_of_port && src_id->irc_number_of_port < NDPI_MAX_IRC_PORTS) {
            src_id->irc_port[src_id->irc_number_of_port] = port;
            src_id->last_time_port_used[src_id->irc_number_of_port] = packet->tick_timestamp;
            src_id->irc_number_of_port++;
          } else if (h == src_id->irc_number_of_port) {
            int least_recent_idx = 0;
            u_int32_t least_recent_time = src_id->last_time_port_used[0];
            for (h = 1; h < src_id->irc_number_of_port; h++) {
              if (src_id->last_time_port_used[h] < least_recent_time) {
                least_recent_idx = h;
                least_recent_time = src_id->last_time_port_used[h];
              }
            }
            src_id->irc_port[least_recent_idx] = port;
            src_id->last_time_port_used[least_recent_idx] = packet->tick_timestamp;
          }
        }
        if (dst != NULL) {
          for (h = 0; h < dst->irc_number_of_port; h++) {
            if (dst->irc_port[h] == port) {
              dst->last_time_port_used[h] = packet->tick_timestamp;
              break;
            }
          }
          if (h == dst->irc_number_of_port && dst->irc_number_of_port < NDPI_MAX_IRC_PORTS) {
            dst->irc_port[dst->irc_number_of_port] = port;
            dst->last_time_port_used[dst->irc_number_of_port] = packet->tick_timestamp;
            dst->irc_number_of_port++;
          } else if (h == dst->irc_number_of_port) {
            int least_recent_idx = 0;
            u_int32_t least_recent_time = dst->last_time_port_used[0];
            for (h = 1; h < dst->irc_number_of_port; h++) {
              if (dst->last_time_port_used[h] < least_recent_time) {
                least_recent_idx = h;
                least_recent_time = dst->last_time_port_used[h];
              }
            }
            dst->irc_port[least_recent_idx] = port;
            dst->last_time_port_used[least_recent_idx] = packet->tick_timestamp;
          }
        }
        break;
      }
    }
  }
}