// Extract and parse IRC commands from packet lines.
// Check if the command is one of SEND, CHAT, chat, sslchat, or TSEND.
// If a command is detected, advance the index to process further.
// Iterate through the characters in the line to identify spaces and the port number.
// After the third space, attempt to read the port number from the line.
// If a valid port is found and the source or destination structure is not NULL, store the port.
// If the IRC port array is not full, add the new port unless it's a duplicate.
// If the array is full, replace the least recently used port with the new one if not a duplicate.
// Update the timestamp of the last IRC activity for source or destination.

if (packet->payload_packet_len > 0 && packet->payload[0] == 'D') {
  u_int16_t port = 0;
  u_int16_t space_count = 0;
  u_int16_t i = 0;

  for (i = 0; i < packet->payload_packet_len; i++) {
    if (packet->payload[i] == ' ') {
      space_count++;
      if (space_count == 3) {
        break;
      }
    }
  }

  if (i < packet->payload_packet_len - 1) {
    u_int16_t port_start = i + 1;
    u_int16_t port_len = 0;

    while (port_start + port_len < packet->payload_packet_len && packet->payload[port_start + port_len] >= '0' && packet->payload[port_start + port_len] <= '9') {
      port_len++;
    }

    if (port_len > 0) {
      port = (u_int16_t)atoi(&packet->payload[port_start]);

      if (src_id != NULL && dst != NULL) {
        if (src_id->irc_port_count < NDPI_MAX_IRC_PORTS) {
          for (u_int16_t j = 0; j < src_id->irc_port_count; j++) {
            if (src_id->irc_port[j] == port) {
              goto update_timestamp;
            }
          }
          src_id->irc_port[src_id->irc_port_count++] = port;
          src_id->last_time_port_used[src_id->irc_port_count - 1] = packet->tick_timestamp;
        } else {
          for (u_int16_t j = 0; j < src_id->irc_port_count; j++) {
            if (src_id->irc_port[j] == port) {
              goto update_timestamp;
            }
          }
          src_id->irc_port[0] = port;
          src_id->last_time_port_used[0] = packet->tick_timestamp;
        }
      }

      if (dst != NULL) {
        if (dst->irc_port_count < NDPI_MAX_IRC_PORTS) {
          for (u_int16_t j = 0; j < dst->irc_port_count; j++) {
            if (dst->irc_port[j] == port) {
              goto update_timestamp;
            }
          }
          dst->irc_port[dst->irc_port_count++] = port;
          dst->last_time_port_used[dst->irc_port_count - 1] = packet->tick_timestamp;
        } else {
          for (u_int16_t j = 0; j < dst->irc_port_count; j++) {
            if (dst->irc_port[j] == port) {
              goto update_timestamp;
            }
          }
          dst->irc_port[0] = port;
          dst->last_time_port_used[0] = packet->tick_timestamp;
        }
      }
    }
  }
}

update_timestamp:
if (src_id != NULL) {
  src_id->irc_ts = packet->tick_timestamp;
}
if (dst != NULL) {
  dst->irc_ts = packet->tick_timestamp;
}