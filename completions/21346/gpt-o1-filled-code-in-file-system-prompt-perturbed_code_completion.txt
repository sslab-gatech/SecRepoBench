/* Skip command word, e.g., "SEND", "CHAT", etc. (the first word following "DCC ") */
while(j < packet->line[i].len && packet->line[i].ptr[j] != ' ') {
  j++;
}
if(j < packet->line[i].len) j++;

/* Skip second token, e.g., filename or "chat". */
space = 0;
while(j < packet->line[i].len && space < 1) {
  if(packet->line[i].ptr[j] == ' ') space++;
  j++;
}
if(j >= packet->line[i].len) return;

/*
 * Now the next token is the host or IP, so skip it,
 * looking for one more space.
 */
space = 0;
while(j < packet->line[i].len && space < 1) {
  if(packet->line[i].ptr[j] == ' ') space++;
  j++;
}
if(j >= packet->line[i].len) return;

/* The next token should be the port. Parse it. */
{
  char port_str[6];
  k = 0;
  memset(port_str, 0, sizeof(port_str));
  while(j < packet->line[i].len && k < (sizeof(port_str) - 1) &&
        isdigit((unsigned char)packet->line[i].ptr[j])) {
    port_str[k++] = packet->line[i].ptr[j++];
  }
  port_str[k] = '\0';
  port = (u_int16_t)atoi(port_str);
}

/* If we successfully got a port, store it in src_id or dst if available. */
if(port > 0) {
  NDPI_LOG_DBG2(ndpi_struct, "DCC found port %u", port);
  if(src_id != NULL) {
    if(src_id->irc_number_of_port < NDPI_PROTOCOL_IRC_MAXPORT) {
      if(!ndpi_is_duplicate(src_id, port)) {
        src_id->irc_port[src_id->irc_number_of_port] = port;
        src_id->last_time_port_used[src_id->irc_number_of_port] = packet->tick_timestamp;
        src_id->irc_number_of_port++;
      }
    } else {
      NDPI_IRC_FIND_LESS(src_id->last_time_port_used, less);
      if(!ndpi_is_duplicate(src_id, port)) {
        src_id->irc_port[less] = port;
        src_id->last_time_port_used[less] = packet->tick_timestamp;
      }
    }
    src_id->irc_ts = packet->tick_timestamp;
  }

  if(dst != NULL) {
    if(dst->irc_number_of_port < NDPI_PROTOCOL_IRC_MAXPORT) {
      if(!ndpi_is_duplicate(dst, port)) {
        dst->irc_port[dst->irc_number_of_port] = port;
        dst->last_time_port_used[dst->irc_number_of_port] = packet->tick_timestamp;
        dst->irc_number_of_port++;
      }
    } else {
      NDPI_IRC_FIND_LESS(dst->last_time_port_used, less);
      if(!ndpi_is_duplicate(dst, port)) {
        dst->irc_port[less] = port;
        dst->last_time_port_used[less] = packet->tick_timestamp;
      }
    }
    dst->irc_ts = packet->tick_timestamp;
  }
}