// Extract and parse IRC commands from packet lines.
// Check if the command is one of SEND, CHAT, chat, sslchat, or TSEND.
// If a command is detected, advance the index to process further.
// Iterate through the characters in the line to identify spaces and the port number.
// After the third space, attempt to read the port number from the line.
// If a valid port is found and the source or destination structure is not NULL, store the port.
// If the IRC port array is not full, add the new port unless it's a duplicate.
// If the array is full, replace the least recently used port with the new one if not a duplicate.
// Update the timestamp of the last IRC activity for source or destination.
for (j = h; j < packet->line[i].len - 9; j++) {
  if (packet->line[i].ptr[j] == ':') {
    if (memcmp(&packet->line[i].ptr[j + 1], "SEND ", 5) == 0 ||
        memcmp(&packet->line[i].ptr[j + 1], "CHAT ", 5) == 0 ||
        memcmp(&packet->line[i].ptr[j + 1], "chat ", 5) == 0 ||
        memcmp(&packet->line[i].ptr[j + 1], "sslchat ", 8) == 0 ||
        memcmp(&packet->line[i].ptr[j + 1], "TSEND ", 6) == 0) {
      j += 6;
      int spaces = 0;
      int port = 0;
      for (; j < packet->line[i].len - 9; j++) {
        if (packet->line[i].ptr[j] == ' ') {
          spaces++;
          if (spaces == 3) {
            int k = j + 1;
            while (k < packet->line[i].len - 9 && packet->line[i].ptr[k] >= '0' && packet->line[i].ptr[k] <= '9') {
              port = port * 10 + (packet->line[i].ptr[k] - '0');
              k++;
            }
            if (port > 0 && port < 65536) {
              if (src_id != NULL) {
                int found = 0;
                for (int l = 0; l < src_id->irc_number_of_port; l++) {
                  if (src_id->irc_port[l] == port) {
                    found = 1;
                    break;
                  }
                }
                if (!found) {
                  if (src_id->irc_number_of_port < NDPI_MAX_IRC_PORTS) {
                    src_id->irc_port[src_id->irc_number_of_port++] = port;
                  } else {
                    int least_recent = 0;
                    for (int l = 1; l < src_id->irc_number_of_port; l++) {
                      if (src_id->last_time_port_used[l] < src_id->last_time_port_used[least_recent]) {
                        least_recent = l;
                      }
                    }
                    src_id->irc_port[least_recent] = port;
                    src_id->last_time_port_used[least_recent] = packet->tick_timestamp;
                  }
                }
                src_id->last_time_port_used[src_id->irc_number_of_port - 1] = packet->tick_timestamp;
              }
              if (dst != NULL) {
                int found = 0;
                for (int l = 0; l < dst->irc_number_of_port; l++) {
                  if (dst->irc_port[l] == port) {
                    found = 1;
                    break;
                  }
                }
                if (!found) {
                  if (dst->irc_number_of_port < NDPI_MAX_IRC_PORTS) {
                    dst->irc_port[dst->irc_number_of_port++] = port;
                  } else {
                    int least_recent = 0;
                    for (int l = 1; l < dst->irc_number_of_port; l++) {
                      if (dst->last_time_port_used[l] < dst->last_time_port_used[least_recent]) {
                        least_recent = l;
                      }
                    }
                    dst->irc_port[least_recent] = port;
                    dst->last_time_port_used[least_recent] = packet->tick_timestamp;
                  }
                }
                dst->last_time_port_used[dst->irc_number_of_port - 1] = packet->tick_timestamp;
              }
            }
            break;
          }
        }
      }
    }
  }
}