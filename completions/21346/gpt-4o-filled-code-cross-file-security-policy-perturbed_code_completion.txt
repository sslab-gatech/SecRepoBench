// Extract and parse IRC commands from packet lines.
// Check if the command is one of SEND, CHAT, chat, sslchat, or TSEND.
// If a command is detected, advance the index to process further.
// Iterate through the characters in the line to identify spaces and the port number.
// After the third space, attempt to read the port number from the line.
// If a valid port is found and the source or destination structure is not NULL, store the port.
// If the IRC port array is not full, add the new port unless it's a duplicate.
// If the array is full, replace the least recently used port with the new one if not a duplicate.
// Update the timestamp of the last IRC activity for source or destination.
if (memcmp(&packet->line[i].ptr[j], "SEND ", 5) == 0
    || memcmp(&packet->line[i].ptr[j], "CHAT ", 5) == 0
    || memcmp(&packet->line[i].ptr[j], "chat ", 5) == 0
    || (j+7 < packet->line[i].len && memcmp(&packet->line[i].ptr[j], "sslchat ", 8) == 0)
    || memcmp(&packet->line[i].ptr[j], "TSEND ", 6) == 0) {
  j += 5;
  if (packet->line[i].ptr[j-1] == 't') j++; // for "sslchat"
  space = 0;
  while (j < packet->line[i].len) {
    if (packet->line[i].ptr[j] == ' ') {
      space++;
      if (space == 3) {
        j++;
        port = 0;
        while (j < packet->line[i].len && packet->line[i].ptr[j] >= '0' && packet->line[i].ptr[j] <= '9') {
          port = (port * 10) + (packet->line[i].ptr[j] - '0');
          j++;
        }
        if (port != 0) {
          if (src_id != NULL) {
            for (k = 0; k < src_id->irc_number_of_port; k++) {
              if (src_id->irc_port[k] == port) break;
            }
            if (k == src_id->irc_number_of_port) {
              if (src_id->irc_number_of_port < MAX_IRC_PORTS) {
                src_id->irc_port[src_id->irc_number_of_port++] = port;
              } else {
                src_id->irc_port[0] = port;
              }
            }
            src_id->last_time_port_used[k] = packet->tick_timestamp;
          }
          if (dst != NULL) {
            for (k = 0; k < dst->irc_number_of_port; k++) {
              if (dst->irc_port[k] == port) break;
            }
            if (k == dst->irc_number_of_port) {
              if (dst->irc_number_of_port < MAX_IRC_PORTS) {
                dst->irc_port[dst->irc_number_of_port++] = port;
              } else {
                dst->irc_port[0] = port;
              }
            }
            dst->last_time_port_used[k] = packet->tick_timestamp;
          }
        }
        break;
      }
    }
    j++;
  }
}