ret = xmlMallocAtomic (ret_len + 1);
if (ret == NULL) {
    xsltTransformError(tctxt, NULL, tctxt->inst,
        "exsltCryptoRc4DecryptFunction: Failed to allocate decrypted string\n");
    tctxt->state = XSLT_STATE_STOPPED;
    xmlXPathReturnEmptyString (parsercontext);
    goto done;
}
// Decrypt the binary data using the RC4 algorithm with the provided padded key.
// Allocate memory for the decrypted result and handle errors if allocation fails.
// Perform the decryption and null-terminate the resulting string.
// Validate the decrypted result if necessary, handling any errors appropriately.
// Return the decrypted string to the caller.
// Ensure all allocated resources are freed before exiting the function.
ret = exsltCryptoRc4Decrypt (padkey, key_len, bin, bin_len, ret, ret_len + 1);
if (ret == NULL) {
    xsltTransformError(tctxt, NULL, tctxt->inst,
        "exsltCryptoRc4DecryptFunction: Failed to decrypt binary data\n");
    tctxt->state = XSLT_STATE_STOPPED;
    xmlXPathReturnEmptyString (parsercontext);
    goto done;
}

// Validate the decrypted result if necessary, handling any errors appropriately.
if (xmlUTF8Validate (ret, ret_len)!= 0) {
    xsltTransformError(tctxt, NULL, tctxt->inst,
        "exsltCryptoRc4DecryptFunction: Decrypted string is not valid UTF-8\n");
    tctxt->state = XSLT_STATE_STOPPED;
    xmlXPathReturnEmptyString (parsercontext);
    goto done;
}

// Return the decrypted string to the caller.
xmlXPathReturnString (parsercontext, ret);

done:
if (str!= NULL)
    xmlFree (str);
if (padkey!= NULL)
    xmlFree (padkey);
if (bin!= NULL)
    xmlFree (bin);
if (ret!= NULL)
    xmlFree (ret);