// Decrypt the binary data using the RC4 algorithm with the provided padded key.
// Allocate memory for the decrypted result and handle errors if allocation fails.
// Perform the decryption and null-terminate the resulting string.
// Validate the decrypted result if necessary, handling any errors appropriately.
// Return the decrypted string to the caller.
// Ensure all allocated resources are freed before exiting the function.

if (ret_len > 0) {
    ret = xmlMallocAtomic(ret_len + 1);
    if (ret == NULL) {
        xsltTransformError(tctxt, NULL, tctxt->inst,
            "exsltCryptoRc4DecryptFunction: Failed to allocate decrypted string\n");
        tctxt->state = XSLT_STATE_STOPPED;
        xmlXPathReturnEmptyString(parsercontext);
        goto done;
    }
    memset(ret, 0, ret_len + 1);

    if (exsltCryptoRc4Decrypt(bin, bin_len, padkey, key_len, ret, &ret_len) != 0) {
        xsltTransformError(tctxt, NULL, tctxt->inst,
            "exsltCryptoRc4DecryptFunction: RC4 decryption failed\n");
        tctxt->state = XSLT_STATE_STOPPED;
        xmlXPathReturnEmptyString(parsercontext);
        goto done;
    }

    // Validate the decrypted result
    if (!xmlCheckUTF8(ret)) {
        xsltTransformError(tctxt, NULL, tctxt->inst,
            "exsltCryptoRc4DecryptFunction: Decrypted result is not valid UTF-8\n");
        tctxt->state = XSLT_STATE_STOPPED;
        xmlXPathReturnEmptyString(parsercontext);
        goto done;
    }

    xmlXPathReturnString(parsercontext, ret);
}
else {
    xmlXPathReturnEmptyString(parsercontext);
}

done:
if (str != NULL)
    xmlFree(str);
if (padkey != NULL)
    xmlFree(padkey);
if (bin != NULL)
    xmlFree(bin);