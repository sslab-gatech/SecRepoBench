// Decrypt the binary data using the RC4 algorithm with the provided padded key.
    // Allocate memory for the decrypted result and handle errors if allocation fails.
    // Perform the decryption and null-terminate the resulting string.
    // Validate the decrypted result if necessary, handling any errors appropriately.
    // Return the decrypted string to the caller.
    // Ensure all allocated resources are freed before exiting the function.
    unsigned char *decrypted_data = (unsigned char *)xmlMallocAtomic(ret_len + 1);
    if (decrypted_data == NULL) {
        xsltTransformError(tctxt, NULL, tctxt->inst,
            "exsltCryptoRc4EncryptFunction: Failed to allocate decrypted_data\n");
        tctxt->state = XSLT_STATE_STOPPED;
        xmlXPathReturnEmptyString(parsercontext);
        goto done;
    }

    // Perform the RC4 decryption
    RC4(&padkey, (unsigned char *)bin, (unsigned char *)decrypted_data, bin_len);

    // Null-terminate the resulting string
    decrypted_data[ret_len] = '\0';

    // Validate the decrypted result as UTF-8
    if (!xmlValidateUTF8((const xmlChar *)decrypted_data, ret_len)) {
        xsltTransformError(tctxt, NULL, tctxt->inst,
            "exsltCryptoRc4EncryptFunction: Decrypted data is not valid UTF-8\n");
        tctxt->state = XSLT_STATE_STOPPED;
        xmlXPathReturnEmptyString(parsercontext);
        xmlFree(decrypted_data);
        goto done;
    }

    // Return the decrypted string to the caller
    xmlXPathReturnString(parsercontext, (xmlChar *)decrypted_data);

done:
    if (str != NULL)
        xmlFree(str);
    if (padkey != NULL)
        xmlFree(padkey);
    if (bin != NULL)
        xmlFree(bin);
    if (decrypted_data != NULL)
        xmlFree(decrypted_data);
}