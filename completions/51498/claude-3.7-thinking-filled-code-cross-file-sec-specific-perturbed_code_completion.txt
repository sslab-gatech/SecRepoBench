if (!checkcpdtable.empty() && scpd < checkcpdtable.size()) {
  int p1_len = checkcpdtable[scpd].pattern1_len;
  int p2_len = checkcpdtable[scpd].pattern2_len;
  
  if (p1_len <= i && p2_len <= (st.size() - i)) {
    // Check if both parts of the pattern match
    const char* part1 = st.c_str() + (i - p1_len);
    const char* part2 = st.c_str() + i;
    
    if (isRevSubset(checkcpdtable[scpd].pattern1, part1 + p1_len - 1, p1_len) &&
        (strncmp(checkcpdtable[scpd].pattern2, part2, p2_len) == 0)) {
      
      // Save original values for possible restoration
      soldi = i;
      oldlen = len;
      oldcmin = cmin;
      oldcmax = cmax;
      
      // Replace the matched parts with the replacement pattern
      std::string new_st;
      if (i - p1_len > 0) {
        new_st.append(st, 0, i - p1_len);
      }
      new_st.append(checkcpdtable[scpd].replacement);
      if (i + p2_len < st.size()) {
        new_st.append(st, i + p2_len, st.size() - (i + p2_len));
      }
      
      // Update the string and related parameters
      st = new_st;
      len = st.size();
      i = i - p1_len + checkcpdtable[scpd].replacement.size();
      
      // Recalculate character min and max values
      setcminmax(&cmin, &cmax, st.c_str(), len);
      
      continue;
    }
  }
}