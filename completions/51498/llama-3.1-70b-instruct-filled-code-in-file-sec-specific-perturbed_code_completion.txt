// Check if there is an active compound pattern processing.
// Find a matching pattern in the compound pattern table.
// If a match is found, replace parts of the string'st' with new patterns
// as specified in the compound pattern table.
// Update the indices and length parameters to reflect the changes made
// to the string'st'.
// Adjust character minimum and maximum values for further processing.
// <MASK>
if (simplifiedcpd && scpd < checkcpdtable.size()) {
  size_t len;
  if (isSubset(checkcpdtable[scpd].pattern.c_str(), st.c_str() + i) &&
      (!r1 ||!checkcpdtable[scpd].cond ||
       (r1->astr && TESTAFF(r1->astr, checkcpdtable[scpd].cond, r1->alen))) &&
      (!r2 ||!checkcpdtable[scpd].cond2 ||
       (r2->astr && TESTAFF(r2->astr, checkcpdtable[scpd].cond2, r2->alen)))) {
    if (checkcpdtable[scpd].pattern3.empty()) {
      // zero length pattern => only TESTAFF
      // zero pattern (0/flag) => unmodified stem (zero affixes allowed)
      if (checkcpdtable[scpd].pattern.empty() ||
          ((checkcpdtable[scpd].pattern[0] == '0' && r1->blen <= i &&
            strncmp(st.c_str() + i - r1->blen, r1->word, r1->blen) == 0) ||
           (checkcpdtable[scpd].pattern[0]!= '0' &&
            ((len = checkcpdtable[scpd].pattern.size())!= 0) && len <= i &&
            strncmp(st.c_str() + i - len, checkcpdtable[scpd].pattern.c_str(), len) == 0)))) {
        // replace parts of the string'st' with new patterns
        std::string newst = st.substr(0, i);
        newst.append(checkcpdtable[scpd].pattern3);
        newst.append(st.c_str() + i);
        st = newst;
        // update the indices and length parameters
        i = 0;
        len = st.size();
        setcminmax(&cmin, &cmax, st.c_str(), len);
        // adjust character minimum and maximum values for further processing
        soldi = i;
        oldlen = len;
        oldcmin = cmin;
        oldcmax = cmax;
      }
    }
  }
}