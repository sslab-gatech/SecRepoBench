// Check if there is an active compound pattern processing.
// Find a matching pattern in the compound pattern table.
// If a match is found, replace parts of the string'st' with new patterns
// as specified in the compound pattern table.
// Update the indices and length parameters to reflect the changes made
// to the string'st'.
// Adjust character minimum and maximum values for further processing.
// <MASK>
if (simplifiedcpd && scpd < checkcpdtable.size()) {
  size_t len;
  if (isSubset(checkcpdtable[scpd].pattern.c_str(), st.c_str() + i) &&
      (!r1 ||!checkcpdtable[scpd].cond ||
       (r1->astr && TESTAFF(r1->astr, checkcpdtable[scpd].cond, r1->alen))) &&
      (!r2 ||!checkcpdtable[scpd].cond2 ||
       (r2->astr && TESTAFF(r2->astr, checkcpdtable[scpd].cond2, r2->alen))) &&
      // zero length pattern => only TESTAFF
      // zero pattern (0/flag) => unmodified stem (zero affixes allowed)
      (checkcpdtable[scpd].pattern.empty() ||
       ((checkcpdtable[scpd].pattern[0] == '0' && r1->blen <= i &&
         strncmp(st.c_str() + i - r1->blen, r1->word, r1->blen) == 0) ||
        (checkcpdtable[scpd].pattern[0]!= '0' &&
         ((len = checkcpdtable[scpd].pattern.size())!= 0) && len <= i &&
         strncmp(st.c_str() + i - len, checkcpdtable[scpd].pattern.c_str(), len) == 0)))) {
    std::string candidate(st);
    candidate.replace(i, checkcpdtable[scpd].pattern.size(),
                      checkcpdtable[scpd].pattern3);
    soldi = i;
    oldlen = len;
    oldcmin = cmin;
    oldcmax = cmax;
    setcminmax(&cmin, &cmax, candidate.c_str(), candidate.size());
    st.assign(candidate);
    i = cmin;
  }
}