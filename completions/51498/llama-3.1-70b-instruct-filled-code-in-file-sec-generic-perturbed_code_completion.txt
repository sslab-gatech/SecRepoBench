// Check if there is an active compound pattern processing.
// Find a matching pattern in the compound pattern table.
// If a match is found, replace parts of the string'st' with new patterns
// as specified in the compound pattern table.
// Update the indices and length parameters to reflect the changes made
// to the string'st'.
// Adjust character minimum and maximum values for further processing.
// <MASK>
if (simplifiedcpd && scpd < checkcpdtable.size()) {
  size_t len;
  if (isSubset(checkcpdtable[scpd].pattern.c_str(), st.c_str() + i) &&
      (!r1 ||!checkcpdtable[scpd].cond ||
       (r1->astr && TESTAFF(r1->astr, checkcpdtable[scpd].cond, r1->alen))) &&
      (!r2 ||!checkcpdtable[scpd].cond2 ||
       (r2->astr && TESTAFF(r2->astr, checkcpdtable[scpd].cond2, r2->alen)))) {
    if (checkcpdtable[scpd].pattern3.empty()) {
      // zero length pattern => only TESTAFF
      // zero pattern (0/flag) => unmodified stem (zero affixes allowed)
      if (checkcpdtable[scpd].pattern.empty() ||
          ((checkcpdtable[scpd].pattern[0] == '0' && r1->blen <= i &&
            strncmp(st.c_str() + i - r1->blen, r1->word, r1->blen) == 0) ||
           (checkcpdtable[scpd].pattern[0]!= '0' &&
            ((len = checkcpdtable[scpd].pattern.size())!= 0) && len <= i &&
            strncmp(st.c_str() + i - len, checkcpdtable[scpd].pattern.c_str(), len) == 0)))) {
        scpd++;
        if (utf8) {
          int i2 = i;
          for (; (st[i2] & 0xc0) == 0x80; i2++)
            ;
          i = i2;
        }
        continue;
      } else {
        // replace parts of the string'st' with new patterns
        std::string candidate(st);
        candidate.replace(i, checkcpdtable[scpd].pattern.size(),
                          checkcpdtable[scpd].pattern3);
        st.assign(candidate);
        // update the indices and length parameters
        if (utf8) {
          int i2 = i;
          for (; (st[i2] & 0xc0) == 0x80; i2++)
            ;
          i = i2;
        }
        len = st.size();
        setcminmax(&cmin, &cmax, st.c_str(), len);
        // adjust character minimum and maximum values for further processing
        if (i < cmin)
          i = cmin;
        if (i >= cmax)
          break;
        scpd++;
        soldi = i;
        oldlen = len;
        oldcmin = cmin;
        oldcmax = cmax;
      }
    }
  }
}