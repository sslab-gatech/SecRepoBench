timelimit = clock() + 1;
  }

  if (cpdwordmax != -1 && wordnum >= cpdwordmax)
    return NULL;

  if (cpdmaxsyllable != 0 && numsyllable > cpdmaxsyllable)
    return NULL;

  if (cpdmin != -1 && len < cpdmin)
    return NULL;

  if (cpdmaxsyllable != 0 && numsyllable > cpdmaxsyllable)
    return NULL;

  if (maxwordnum != -1 && wnum > maxwordnum)
    return NULL;

  if (wordnum == 0) {
    // set the time limit
    timelimit = clock() + 1;
  }

  if (timelimit && clock() > timelimit) {
    return NULL;
  }

  // check for double words in compounds
  if (checkcompounddup && wordnum > 0) {
    for (int i = 0; i < wordnum; i++) {
      if (words[i]->alen == len &&
          strncmp(words[i]->word, compound_word.c_str(), len) == 0) {
        return NULL;
      }
    }
  }

  // check for triple letters in compounds
  if (checkcompoundtriple && wordnum > 0) {
    for (int i = 0; i < wordnum; i++) {
      if (words[i]->alen > 1) {
        for (int j = 0; j < words[i]->alen - 1; j++) {
          if (words[i]->word[j] == words[i]->word[j + 1]) {
            striple++;
          }
        }
      }
    }
    if (striple > 0) {
      if (checkedstriple == 0) {
        checkedstriple = 1;
        if (checkcompoundtriple)
          return NULL;
      }
    }
  }

  // check for REP substitutions in compounds
  if (checkcompoundrep && wordnum > 0) {
    if (cpdrep_check(compound_word.c_str(), len))
      return NULL;
  }

  // check for word with numbers in compounds
  if (checknum && wordnum > 0) {
    for (int i = 0; i < wordnum; i++) {
      if (words[i]->alen > 0) {
        for (int j = 0; j < words[i]->alen; j++) {
          if (isdigit(words[i]->word[j])) {
            return NULL;
          }
        }
      }
    }
  }

  // check for upper and lower case combinations at word bounds
  if (checkcompoundcase && wordnum > 0) {
    for (int i = 0; i < wordnum; i++) {
      if (words[i]->alen > 0) {
        for (int j = 0; j < words[i]->alen; j++) {
          if (isupper(words[i]->word[j]) && islower(words[i]->word[j + 1])) {
            return NULL;
          }
        }
      }
    }
  }

  // check for forbidden word in compounds
  if (forbiddenword && wordnum > 0) {
    for (int i = 0; i < wordnum; i++) {
      if (words[i]->alen == len &&
          strncmp(words[i]->word, compound_word.c_str(), len) == 0) {
        return NULL;
      }
    }
  }

  // check for word pairs in compounds
  if (checkcompounddup && wordnum > 0) {
    if (cpdwordpair_check(compound_word.c_str(), len))
      return NULL;
  }

  // check for patterns at word bounds
  if (checkcompoundpat_check(compound_word.c_str(), len, words, wordnum))
    return NULL;

  // check for syllable count
  if (cpdsyllablenum.size() > 0 && wordnum > 0) {
    oldnumsyllable = numsyllable;
    oldwordnum = wordnum;
    oldcmin = cmin;
    oldcmax = cmax;
    oldlen = len;
    setcminmax(&cmin, &cmax, compound_word.c_str(), len);
    if (cmin > oldcmin || cmax < oldcmax) {
      if (cpdsyllablenum.find(compound_word.substr(cmin, cmax - cmin)) ==
          std::string::npos) {
        return NULL;
      }
    }
  }

  // check for compound patterns
  if (defcpd_check(&words, wordnum, NULL, NULL, 0))
    return NULL;

  // check for compound patterns with affix
  if (defcpd_check(&words, wordnum, NULL, NULL, 1))
    return NULL;

  // check for compound patterns with affix and affixed
  if (defcpd_check(&words, wordnum, NULL, NULL, 2))
    return NULL;

  // check for compound patterns with affix and affixed and all
  if (defcpd_check(&words, wordnum, NULL, NULL, 3))
    return NULL;

  // check for compound patterns with affix and affixed and all
  // and check for forbidden word in compounds
  if (forbiddenword && wordnum > 0) {
    for (int i = 0; i < wordnum; i++) {
      if (words[i]->alen == len &&
          strncmp(words[i]->word, compound_word.c_str(), len) == 0) {
        return NULL;
      }
    }
  }

  // check for compound patterns with affix and affixed and all
  // and check for word pairs in compounds
  if (checkcompounddup && wordnum > 0) {
    if (cpdwordpair_check(compound_word.c_str(), len))
      return NULL;
  }

  // check for compound patterns with affix and affixed and all
  // and check for REP substitutions in compounds
  if (checkcompoundrep && wordnum > 0) {
    if (cpdrep_check(compound_word.c_str(), len))
      return NULL;
  }

  // check for compound patterns with affix and affixed and all
  // and check for word with numbers in compounds
  if (checknum && wordnum > 0) {
    for (int i = 0; i < wordnum; i++) {
      if (words[i]->alen > 0) {
        for (int j = 0; j < words[i]->alen; j++) {
          if (isdigit(words[i]->word[j])) {
            return NULL;
          }
        }
      }
    }
  }

  // check for compound patterns with affix and affixed and all
  // and check for upper and lower case combinations at word bounds
  if (checkcompoundcase && wordnum > 0) {
    for (int i = 0; i < wordnum; i++) {
      if (words[i]->alen > 0) {
        for (int j = 0; j < words[i]->alen; j++) {
          if (isupper(words[i]->word[j]) && islower(words[i]->word[j + 1])) {
            return NULL;
          }
        }
      }
    }
  }

  // check for compound patterns with affix and affixed and all
  // and check for forbidden word in compounds
  if (forbiddenword && wordnum > 0) {
    for (int i = 0; i < wordnum; i++) {
      if (words[i]->alen == len &&
          strncmp(words[i]->word, compound_word.c_str(), len) == 0) {
        return NULL;
      }
    }
  }

  // check for compound patterns with affix and affixed and all
  // and check for word pairs in compounds
  if (checkcompounddup && wordnum > 0) {
    if (cpdwordpair_check(compound_word.c_str(), len))
      return NULL;
  }

  // check for compound patterns with affix and affixed and all
  // and check for REP substitutions in compounds
  if (checkcompoundrep && wordnum > 0) {
    if (cpdrep_check(compound_word.c_str(), len))
      return NULL;
  }

  // check for compound patterns with affix and affixed and all
  // and check for word with numbers in compounds
  if (checknum && wordnum > 0) {
    for (int i = 0; i < wordnum; i++) {
      if (words[i]->alen > 0) {
        for (int j = 0; j < words[i]->alen; j++) {
          if (isdigit(words[i]->word[j])) {
            return NULL;
          }
        }
      }
    }
  }

  // check for compound patterns with affix and affixed and all
  // and check for upper and lower case combinations at word bounds
  if (checkcompoundcase && wordnum > 0) {
    for (int i = 0; i < wordnum; i++) {
      if (words[i]->alen > 0) {
        for (int j = 0; j < words[i]->alen; j++) {
          if (isupper(words[i]->word[j]) && islower(words[i]->word[j + 1])) {
            return NULL;
          }
        }
      }
    }
  }

  // check for compound patterns with affix and affixed and all
  // and check for forbidden word in compounds
  if (forbiddenword && wordnum > 0) {
    for (int i = 0; i < wordnum; i++) {
      if (words[i]->alen == len &&
          strncmp(words[i]->word, compound_word.c_str(), len) == 0) {
        return NULL;
      }
    }
  }

  // check for compound patterns with affix and affixed and all
  // and check for word pairs in compounds
  if (checkcompounddup && wordnum > 0) {
    if (cpdwordpair_check(compound_word.c_str(), len))
      return NULL;
  }

  // check for compound patterns with affix and affixed and all
  // and check for REP substitutions in compounds
  if (checkcompoundrep && wordnum > 0) {
    if (cpdrep_check(compound_word.c_str(), len))
      return NULL;
  }

  // check for compound patterns with affix and affixed and all
  // and check for word with numbers in compounds
  if (checknum && wordnum > 0) {
    for (int i = 0; i < wordnum; i++) {
      if (words[i]->alen > 0) {
        for (int j = 0; j < words[i]->alen; j++) {
          if (isdigit(words[i]->word[j])) {
            return NULL;
          }
        }
      }
    }
  }

  // check for compound patterns with affix and affixed and all
  // and check for upper and lower case combinations at word bounds
  if (checkcompoundcase && wordnum > 0) {
    for (int i = 0; i < wordnum; i++) {
      if (words[i]->alen > 0) {
        for (int j = 0; j < words[i]->alen; j++) {
          if (isupper(words[i]->word[j]) && islower(words[i]->word[j + 1])) {
            return NULL;
          }
        }
      }
    }
  }

  // check for compound patterns with affix and affixed and all
  // and check for forbidden word in compounds
  if (forbiddenword && wordnum > 0) {
    for (int i = 0; i < wordnum; i++) {
      if (words[i]->alen == len &&
          strncmp(words[i]->word, compound_word.c_str(), len) == 0) {
        return NULL;
      }
    }
  }

  // check for compound patterns with affix and affixed and all
  // and check for word pairs in compounds
  if (checkcompounddup && wordnum > 0) {
    if (cpdwordpair_check(compound_word.c_