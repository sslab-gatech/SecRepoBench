if (!checkcpdtable.empty() && scpd < checkcpdtable.size()) {
  const compoundpattern& cpdpat = checkcpdtable[scpd];

  // Get pattern lengths
  int patlen = cpdpat.pattern.size();
  int patlen2 = cpdpat.pattern2.size();

  // Check if patterns can fit in the string at the current position
  if (i >= patlen && (i + patlen2) <= len) {
    // Save original positions and values if not already saved
    if (soldi == 0) {
      soldi = i;
      oldlen = len;
      oldcmin = cmin;
      oldcmax = cmax;
    }

    // Check if pattern matches at current position
    if (st.compare(i - patlen, patlen, cpdpat.pattern) == 0 &&
        st.compare(i, patlen2, cpdpat.pattern2) == 0) {

      // Replace matched patterns with replacements
      st.replace(i - patlen, patlen, cpdpat.replacement);
      st.replace(i - patlen + cpdpat.replacement.size(), patlen2, cpdpat.replacement2);

      // Update position and length
      i = i - patlen + cpdpat.replacement.size();
      len = st.size();

      // Recalculate character min and max
      setcminmax(&cmin, &cmax, st.c_str(), len);

      // Skip to next iteration
      continue;
    }
  }
}