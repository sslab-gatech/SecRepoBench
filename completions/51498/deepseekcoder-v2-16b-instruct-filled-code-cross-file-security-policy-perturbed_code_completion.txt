// Check if there is an active compound pattern processing.
// Find a matching pattern in the compound pattern table.
// If a match is found, replace parts of the string 'st' with new patterns
// as specified in the compound pattern table.
// Update the indices and length parameters to reflect the changes made
// to the string 'st'.
// Adjust character minimum and maximum values for further processing.

ch = st[i];
st[i] = '\0';

sfx = NULL;
pfx = NULL;

// FIRST WORD

affixed = 1;
rv = lookup(st.c_str(), i);  // perhaps without prefix

// forbid dictionary stems with COMPOUNDFORBIDFLAG in
// compound words, overriding the effect of COMPOUNDPERMITFLAG
if ((rv) && compoundforbidflag &&
        TESTAFF(rv->astr, compoundforbidflag, rv->alen) && !hu_mov_rule)
    continue;

// search homonym with compound flag
while ((rv) && !hu_mov_rule &&
       ((needaffix && TESTAFF(rv->astr, needaffix, rv->alen)) ||
        !((compoundflag && !words && !onlycpdrule &&
           TESTAFF(rv->astr, compoundflag, rv->alen)) ||
          (compoundbegin && !wordnum && !onlycpdrule &&
           TESTAFF(rv->astr, compoundbegin, rv->alen)) ||
          (compoundmiddle && wordnum && !words && !onlycpdrule &&
           TESTAFF(rv->astr, compoundmiddle, rv->alen)) ||
          (!defcpdtable.empty() && onlycpdrule &&
           ((!words && !wordnum &&
             defcpd_check(&words, wnum, rv, rwords, 0)) ||
            (words &&
             defcpd_check(&words, wnum, rv, rwords, 0))))) ||
        (scpd != 0 && checkcpdtable[scpd - 1].cond != FLAG_NULL &&
         !TESTAFF(rv->astr, checkcpdtable[scpd - 1].cond, rv->alen)))) {
  rv = rv->next_homonym;
}

if (rv)
  affixed = 0;

if (!rv) {
  if (onlycpdrule)
    break;
  if (compoundflag &&
      !(rv = prefix_check(st, 0, i,
                          hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN,
                          compoundflag))) {
    if (((rv = suffix_check(
              st, 0, i, 0, NULL, FLAG_NULL, compoundflag,
              hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN)) ||
         (compoundmoresuffixes &&
          (rv = suffix_check_twosfx(st, 0, i, 0, NULL, compoundflag)))) &&
        !hu_mov_rule && sfx->getCont() &&
        ((compoundforbidflag &&
          TESTAFF(sfx->getCont(), compoundforbidflag,
                  sfx->getContLen())) ||
         (compoundend &&
          TESTAFF(sfx->getCont(), compoundend, sfx->getContLen())))) {
      rv = NULL;
    }
  }

  if (rv ||
      (((wordnum == 0) && compoundbegin &&
        ((rv = suffix_check(
              st, 0, i, 0, NULL, FLAG_NULL, compoundbegin,
              hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN)) ||
         (compoundmoresuffixes &&
          (rv = suffix_check_twosfx(
               st, 0, i, 0, NULL,
               compoundbegin))) ||  // twofold suffixes + compound
         (rv = prefix_check(st, 0, i,
                            hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN,
                            compoundbegin)))) ||
       ((wordnum > 0) && compoundmiddle &&
        ((rv = suffix_check(
              st, 0, i, 0, NULL, FLAG_NULL, compoundmiddle,
              hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN)) ||
         (compoundmoresuffixes &&
          (rv = suffix_check_twosfx(
               st, 0, i, 0, NULL,
               compoundmiddle))) ||  // twofold suffixes + compound
         (rv = prefix_check(st, 0, i,
                            hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN,
                            compoundmiddle))))))
    checked_prefix = 1;
  // else check forbiddenwords and needaffix
} else if (rv->astr && (TESTAFF(rv->astr, forbiddenword, rv->alen) ||
                        TESTAFF(rv->astr, needaffix, rv->alen) ||
                        TESTAFF(rv->astr, ONLYUPCASEFLAG, rv->alen) ||
                        (is_sug && nosuggest &&
                         TESTAFF(rv->astr, nosuggest, rv->alen)))) {
  st[i] = ch;
  // continue;
  break;
}

// check non_compound flag in suffix and prefix
if ((rv) && !hu_mov_rule &&
    ((pfx && pfx->getCont() &&
      TESTAFF(pfx->getCont(), compoundforbidflag, pfx->getContLen())) ||
     (sfx && sfx->getCont() &&
      TESTAFF(sfx->getCont(), compoundforbidflag,
              sfx->getContLen())))) {
  rv = NULL;
}

// check compoundend flag in suffix and prefix
if ((rv) && !checked_prefix && compoundend && !hu_mov_rule &&
    ((pfx && pfx->getCont() &&
      TESTAFF(pfx->getCont(), compoundend, pfx->getContLen())) ||
     (sfx && sfx->getCont() &&
      TESTAFF(sfx->getCont(), compoundend, sfx->getContLen())))) {
  rv = NULL;
}

// check compoundmiddle flag in suffix and prefix
if ((rv) && !checked_prefix && (wordnum == 0) && compoundmiddle &&
    !hu_mov_rule &&
    ((pfx && pfx->getCont() &&
      TESTAFF(pfx->getCont(), compoundmiddle, pfx->getContLen())) ||
     (sfx && sfx->getCont() &&
      TESTAFF(sfx->getCont(), compoundmiddle, sfx->getContLen())))) {
  rv = NULL;
}

// check forbiddenwords
if ((rv) && (rv->astr) &&
    (TESTAFF(rv->astr, forbiddenword, rv->alen) ||
     TESTAFF(rv->astr, ONLYUPCASEFLAG, rv->alen) ||
     (is_sug && nosuggest && TESTAFF(rv->astr, nosuggest, rv->alen)))) {
  return NULL;
}

// increment word number, if the second root has a compoundroot flag
if ((rv) && compoundroot &&
    (TESTAFF(rv->astr, compoundroot, rv->alen))) {
  wordnum++;
}

// first word is acceptable in compound words?
if (((rv) &&
     (checked_prefix || (words && words[wnum]) ||
      (compoundflag && TESTAFF(rv->astr, compoundflag, rv->alen)) ||
      ((oldwordnum == 0) && compoundbegin &&
       TESTAFF(rv->astr, compoundbegin, rv->alen)) ||
      ((oldwordnum > 0) && compoundmiddle &&
       TESTAFF(rv->astr, compoundmiddle, rv->alen))

      // LANG_hu section: spec. Hungarian rule
      || ((langnum == LANG_hu) && hu_mov_rule &&
          (TESTAFF(
               rv->astr, 'F',
               rv->alen) ||  // XXX hardwired Hungarian dictionary codes
           TESTAFF(rv->astr, 'G', rv->alen) ||
           TESTAFF(rv->astr, 'H', rv->alen)))
      // END of LANG_hu section
      ) &&
     (
         // test CHECKCOMPOUNDPATTERN conditions
         scpd == 0 || checkcpdtable[scpd - 1].cond == FLAG_NULL ||
         TESTAFF(rv->astr, checkcpdtable[scpd - 1].cond, rv->alen)) &&
     !((checkcompoundtriple && scpd == 0 &&
        !words &&  // test triple letters
        (compound_word[i - 1] == compound_word[i]) &&
        (((i > 1) && (compound_word[i - 1] == compound_word[i - 2])) ||
         ((compound_word[i - 1] == compound_word[i + 1]))  // may be word[i+1] == '\0'
         )) ||
       (checkcompoundcase && scpd == 0 && !words &&
        cpdcase_check(compound_word.c_str(), i))))
    // LANG_hu section: spec. Hungarian rule
    || ((!rv) && (langnum == LANG_hu) && hu_mov_rule &&
        (rv = affix_check(st, 0, i)) &&
        (sfx && sfx->getCont() &&
         (  // XXX hardwired Hungarian dic. codes
             TESTAFF(sfx->getCont(), (unsigned short)'x',
                     sfx->getContLen()) ||
             TESTAFF(
                 sfx->getCont(), (unsigned short)'%',
                 sfx->getContLen()))))) {  // first word is ok condition

  // LANG_hu section: spec. Hungarian rule
  if (langnum == LANG_hu) {
    // calculate syllable number of the word
    numsyllable += get_syllable(st.substr(0, i));
    // + 1 word, if syllable number of the prefix > 1 (hungarian
    // convention)
    if (pfx && (get_syllable(pfx->getKey()) > 1))
      wordnum++;
  }
  // END of LANG_hu section

  // NEXT WORD(S)
  rv_first = rv;
  st[i] = ch;

  do {  // striple loop

    // check simplifiedtriple
    if (simplifiedtriple) {
      if (striple) {
        checkedstriple = 1;
        i--;  // check "fahrt" instead of "ahrt" in "Schiffahrt"
      } else if (i > 2 && compound_word[i - 1] == compound_word[i - 2])
        striple = 1;
    }

    rv = lookup(st.c_str() + i, st.size() - i);  // perhaps without prefix

    // search homonym with compound flag
    while ((rv) &&
           ((needaffix && TESTAFF(rv->astr, needaffix, rv->alen)) ||
            !((compoundflag && !words &&
               TESTAFF(rv->astr, compoundflag, rv->alen)) ||
              (compoundend && !words &&
               TESTAFF(rv->astr, compoundend, rv->alen)) ||
              (!defcpdtable.empty() && words &&
               defcpd_check(&words, wnum + 1, rv, NULL, 1))) ||
            (scpd != 0 && checkcpdtable[scpd - 1].cond2 != FLAG_NULL &&
             !TESTAFF(rv->astr, checkcpdtable[scpd - 1].cond2,
                      rv->alen)))) {
      rv = rv->next_homonym;
    }

    // check FORCEUCASE
    if (rv && forceucase &&
        (TESTAFF(rv->astr, forceucase, rv->alen)) &&
        !(info && *info & SPELL_ORIGCAP))
      rv = NULL;

    if (rv && words && words[wnum + 1])
      return rv_first;

    oldnumsyllable2 = numsyllable;
    oldwordnum2 = wordnum;

    // LANG_hu section: spec. Hungarian rule, XXX hardwired dictionary
    // code
    if ((rv) && (langnum == LANG_hu) &&
        (TESTAFF(rv->astr, 'I', rv->alen)) &&
        !(TESTAFF(rv->astr, 'J', rv->alen))) {
      numsyllable--;
    }
    // END of LANG_hu section

    // increment word number, if the second root has a compoundroot flag
    if ((rv) && (compoundroot) &&
        (TESTAFF(rv->astr, compoundroot, r