->astr || dp->alen == 0) && (aff == NULL || al == 0)) {
      if (dp->var & H_OPT) {
        if (dp->var & H_OPT_ALIASM) {
          if (desc && desc->size() > 0) {
            store_pointer(hp->word + hp->blen + 1, get_aliasm(atoi(desc->c_str())));
          }
        } else {
          if (desc && desc->size() > 0) {
            strcpy(hp->word + hp->blen + 1, desc->c_str());
          }
        }
      }
      if (dp->var & H_OPT_INITCAP) {
        hp->var |= H_OPT_INITCAP;
      }
      if (dp->var & H_OPT_PHON) {
        hp->var |= H_OPT_PHON;
      }
      if (dp->var & H_OPT_ALIASM) {
        hp->var |= H_OPT_ALIASM;
      }
      hp->next = dp->next;
      dp->next = hp;
      delete desc_copy;
      delete word_copy;
      return 0;
    }
    dp = dp->next;
  }

  if ((!dp->astr || dp->alen == 0) && (aff == NULL || al == 0)) {
    if (dp->var & H_OPT) {
      if (dp->var & H_OPT_ALIASM) {
        if (desc && desc->size() > 0) {
          store_pointer(hp->word + hp->blen + 1, get_aliasm(atoi(desc->c_str())));
        }
      } else {
        if (desc && desc->size() > 0) {
          strcpy(hp->word + hp->blen + 1, desc->c_str());
        }
      }
    }
    if (dp->var & H_OPT_INITCAP) {
      hp->var |= H_OPT_INITCAP;
    }
    if (dp->var & H_OPT_PHON) {
      hp->var |= H_OPT_PHON;
    }
    if (dp->var & H_OPT_ALIASM) {
      hp->var |= H_OPT_ALIASM;
    }
    dp->next = hp;
    delete desc_copy;
    delete word_copy;
    return 0;
  }

  if (dp->blen == hp->blen && dp->clen == hp->clen) {
    if (dp->astr && hp->astr) {
      if (dp->alen == hp->alen) {
        if (memcmp(dp->astr, hp->astr, dp->alen) == 0) {
          if (dp->var & H_OPT) {
            if (dp->var & H_OPT_ALIASM) {
              if (desc && desc->size() > 0) {
                store_pointer(hp->word + hp->blen + 1, get_aliasm(atoi(desc->c_str())));
              }
            } else {
              if (desc && desc->size() > 0) {
                strcpy(hp->word + hp->blen + 1, desc->c_str());
              }
            }
          }
          if (dp->var & H_OPT_INITCAP) {
            hp->var |= H_OPT_INITCAP;
          }
          if (dp->var & H_OPT_PHON) {
            hp->var |= H_OPT_PHON;
          }
          if (dp->var & H_OPT_ALIASM) {
            hp->var |= H_OPT_ALIASM;
          }
          free_flag(hp->astr, hp->alen);
          free(hp);
          delete desc_copy;
          delete word_copy;
          return 0;
        }
      }
    }
  }

  if (dp->astr && hp->astr) {
    if (dp->alen == hp->alen) {
      if (memcmp(dp->astr, hp->astr, dp->alen) == 0) {
        if (dp->var & H_OPT) {
          if (dp->var & H_OPT_ALIASM) {
            if (desc && desc->size() > 0) {
              store_pointer(hp->word + hp->blen + 1, get_aliasm(atoi(desc->c_str())));
            }
          } else {
            if (desc && desc->size() > 0) {
              strcpy(hp->word + hp->blen + 1, desc->c_str());
            }
          }
        }
        if (dp->var & H_OPT_INITCAP) {
          hp->var |= H_OPT_INITCAP;
        }
        if (dp->var & H_OPT_PHON) {
          hp->var |= H_OPT_PHON;
        }
        if (dp->var & H_OPT_ALIASM) {
          hp->var |= H_OPT_ALIASM;
        }
        free_flag(hp->astr, hp->alen);
        free(hp);
        delete desc_copy;
        delete word_copy;
        return 0;
      }
    }
  }

  if (dp->astr &&!hp->astr) {
    if (dp->var & H_OPT) {
      if (dp->var & H_OPT_ALIASM) {
        if (desc && desc->size() > 0) {
          store_pointer(hp->word + hp->blen + 1, get_aliasm(atoi(desc->c_str())));
        }
      } else {
        if (desc && desc->size() > 0) {
          strcpy(hp->word + hp->blen + 1, desc->c_str());
        }
      }
    }
    if (dp->var & H_OPT_INITCAP) {
      hp->var |= H_OPT_INITCAP;
    }
    if (dp->var & H_OPT_PHON) {
      hp->var |= H_OPT_PHON;
    }
    if (dp->var & H_OPT_ALIASM) {
      hp->var |= H_OPT_ALIASM;
    }
    free_flag(hp->astr, hp->alen);
    free(hp);
    delete desc_copy;
    delete word_copy;
    return 0;
  }

  if (!dp->astr && hp->astr) {
    if (dp->var & H_OPT) {
      if (dp->var & H_OPT_ALIASM) {
        if (desc && desc->size() > 0) {
          store_pointer(hp->word + hp->blen + 1, get_aliasm(atoi(desc->c_str())));
        }
      } else {
        if (desc && desc->size() > 0) {
          strcpy(hp->word + hp->blen + 1, desc->c_str());
        }
      }
    }
    if (dp->var & H_OPT_INITCAP) {
      hp->var |= H_OPT_INITCAP;
    }
    if (dp->var & H_OPT_PHON) {
      hp->var |= H_OPT_PHON;
    }
    if (dp->var & H_OPT_ALIASM) {
      hp->var |= H_OPT_ALIASM;
    }
    free_flag(hp->astr, hp->alen);
    free(hp);
    delete desc_copy;
    delete word_copy;
    return 0;
  }

  if (dp->var & H_OPT) {
    if (dp->var & H_OPT_ALIASM) {
      if (desc && desc->size() > 0) {
        store_pointer(hp->word + hp->blen + 1, get_aliasm(atoi(desc->c_str())));
      }
    } else {
      if (desc && desc->size() > 0) {
        strcpy(hp->word + hp->blen + 1, desc->c_str());
      }
    }
  }
  if (dp->var & H_OPT_INITCAP) {
    hp->var |= H_OPT_INITCAP;
  }
  if (dp->var & H_OPT_PHON) {
    hp->var |= H_OPT_PHON;
  }
  if (dp->var & H_OPT_ALIASM) {
    hp->var |= H_OPT_ALIASM;
  }
  free_flag(hp->astr, hp->alen);
  free(hp);
  delete desc_copy;
  delete word_copy;
  return 0;
}

// the below code fragment can be found in:
// src/hunspell/affixmgr.cxx
struct hentry* AffixMgr::prefix_check(const std::string& word,
                                      int start,
                                      int len,
                                      char in_compound,
                                      const FLAG needflag,
                                      PfxEntry* ppfx) {
  struct hentry* rv = NULL;
  PfxEntry* ep = ppfx;

  // first handle the special case of 0 length prefixes
  PfxEntry* pe = pStart[0];

  while (pe) {
    if (!needflag || pe->getCont()) {
      // prefixes are not allowed in end of compounds
      if (((in_compound!= IN_CPD_END) ||  // &&!needflag
           // except when signed with compoundpermitflag flag
           (pe->getCont() && compoundpermitflag &&
            TESTAFF(pe->getCont(), compoundpermitflag, pe->getContLen()))) &&
          (!circumfix ||
           // no circumfix flag in prefix and suffix
           ((!ep ||!(ep->getCont()) ||
            !TESTAFF(ep->getCont(), circumfix, ep->getContLen())) &&
            (!pe->getCont() ||
            !(TESTAFF(pe->getCont(), circumfix, pe->getContLen())))) ||
           // circumfix flag in prefix AND suffix
           ((ep && (ep->getCont()) &&
             TESTAFF(ep->getCont(), circumfix, ep->getContLen())) &&
            (pe->getCont() &&
             (TESTAFF(pe->getCont(), circumfix, pe->getContLen()))))) &&
          // fogemorpheme
          (in_compound ||
          !((pe->getCont() && (TESTAFF(pe->getCont(), onlyincompound,
                                        pe->getContLen()))))) &&
          // needaffix on prefix or first suffix
          (needflag ||
          !(pe->getCont() &&
             TESTAFF(pe->getCont(), needaffix, pe->getContLen())) ||
           (ep &&
           !((ep->getCont()) &&
              TESTAFF(ep->getCont(), needaffix, ep->getContLen()))))) {
        rv = pe->checkword(word, start, len, 0, ep, needflag, 0, in_compound);
        if (rv) {
          pfx = pe;  // BUG: pfx not stateless
          return rv;
        }
      }
    }
    pe = pe->getNext();
  }

  // now handle the general case
  if (len == 0)
    return NULL;  // FULLSTRIP
  unsigned char sp = word[start];
  PfxEntry* pptr = pStart[sp];

  while (pptr) {
    if (isSubset(pptr->getKey(), word.c_str() + start, len)) {
      // prefixes are not allowed in end of compounds
      if (((in_compound!= IN_CPD_END) ||  // &&!needflag
           // except when signed with compoundpermitflag flag
           (pptr->getCont() && compoundpermitflag &&
            TESTAFF(pptr->getCont(), compoundpermitflag,
                    pptr->getContLen()))) &&
          (!circumfix ||
           // no circumfix flag in prefix and suffix
           ((!ep ||!(ep->getCont()) ||
            !TESTAFF(ep->getCont(), circumfix, ep->getContLen())) &&
            (!pptr->getCont() ||
            !(TESTAFF(pptr->getCont(), circumfix, pptr->getContLen())))) ||
           // circumfix flag in prefix AND suffix
           ((ep && (ep->getCont()) &&
             TESTAFF(ep->getCont(), circumfix, ep->getContLen())) &&
            (pptr->getCont() &&
             (TESTAFF(pptr->getCont(), circumfix, pptr->getContLen()))))) &&
          // fogemorpheme
          (in_compound ||
          !((pptr->getCont() && (TESTAFF(pptr->getCont(), onlyincompound,
                                          pptr->getContLen()))))) &&
          // needaffix on prefix or first suffix
          (needflag ||
          !(pptr->getCont() &&
             TESTAFF(pptr->getCont(), needaffix, pptr->getContLen())) ||
           (ep &&
           !((ep->getCont()) &&
              TESTAFF(ep->getCont(), needaffix, ep->getContLen()))))) {
        rv = pptr->checkword(word, start, len, 0, ep, needflag, 0, in_compound);
        if (rv) {
          pfx = pptr;  // BUG: pfx not stateless
          return rv;
        }
      }
      pptr = pptr->getNextEQ();
    } else {
      pptr = pptr->getNextNE();
    }
  }

  return NULL;
}

// the below code fragment can be found in:
// src/hunspell/affixmgr.cxx
std::string AffixMgr::prefix_check_morph(const std::string& word,
                                         int start,
                                         int len,
                                         char in_compound,
                                         const FLAG needflag,
                                         PfxEntry* ppfx) {
  std::string result;

  struct hentry* rv = NULL;

  PfxEntry* ep = ppfx;

  // first handle the special case of 0 length prefixes
  PfxEntry* pe = pStart[0];
  while (pe) {
    if (!needflag || pe->getCont()) {
      // prefixes are not allowed in end of compounds
      if (((in_compound!= IN_CPD_END) ||  // &&!needflag
           // except when signed with compoundpermitflag flag
           (pe->getCont() && compoundpermitflag &&
            TESTAFF(pe->getCont(), compoundpermitflag, pe->getContLen()))) &&
          (!circumfix ||
           // no circumfix flag in prefix and suffix
           ((!ep ||!(ep->getCont()) ||
            !TESTAFF(ep->getCont(), circumfix, ep->getContLen())) &&
            (!pe->getCont() ||
            !(TESTAFF(pe->getCont(), circumfix, pe->getContLen())))) ||
           // circumfix flag in prefix AND suffix