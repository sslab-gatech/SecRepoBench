if (!defcpdtable.empty()) {
    // Check if the current substring matches any compound pattern.
    for (size_t j = 0; j < defcpdtable.size(); ++j) {
        const CompoundPattern& cp = defcpdtable[j];
        if (cp.minlen <= len && cp.maxlen >= len &&
            strncmp(compound_word.c_str() + i, cp.pattern, cp.len) == 0) {
            // Adjust indices and length parameters based on matched pattern.
            oldlen = len;
            soldi = i;
            len -= cp.len;
            i += static_cast<int>(cp.len);
            cmin = i + cp.pos1;
            cmax = std::min(static_cast<int>(oldlen), cmin + cp.num1);

            // Update words array with new patterns if necessary.
            if (words && !cp.words.empty()) {
                for (size_t k = 0; k < cp.words.size(); ++k) {
                    words[k] = lookup(cp.words[k].c_str(), cp.words[k].size());
                }
            }

            // Adjust character minimum and maximum values for further processing.
            setcminmax(&cmin, &cmax, compound_word.c_str() + i, len);
            scpd = j + 1; // Set scpd to indicate a match was found.
            break;
        }
    }
}