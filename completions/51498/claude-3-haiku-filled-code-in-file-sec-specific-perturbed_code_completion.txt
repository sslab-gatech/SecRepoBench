// <MASK>
if (!checkcpdtable.empty()) {
    int cpdpat_len = checkcpdtable[scpd - 1].pattern.size();
    int cpdpat2_len = checkcpdtable[scpd - 1].pattern2.size();
    int cpdpat3_len = checkcpdtable[scpd - 1].pattern3.size();

    // Check if the current word matches the compound pattern
    if ((cpdpat_len == 0 || isSubset(checkcpdtable[scpd - 1].pattern.c_str(), word.c_str() + i)) &&
        (cpdpat2_len == 0 || isSubset(checkcpdtable[scpd - 1].pattern2.c_str(), word.c_str() + i)) &&
        (cpdpat3_len == 0 || word.find(checkcpdtable[scpd - 1].pattern3) != std::string::npos)) {
        // Update the indices and length parameters based on the matched pattern
        if (cpdpat3_len > 0) {
            size_t pos = word.find(checkcpdtable[scpd - 1].pattern3);
            i += pos + cpdpat3_len;
            len = word.size() - i;
            soldi = i;
            oldlen = len;
            oldcmin = cmin;
            oldcmax = cmax;
        } else if (cpdpat2_len > 0) {
            i += cpdpat2_len;
            len = word.size() - i;
            soldi = i;
            oldlen = len;
            oldcmin = cmin;
            oldcmax = cmax;
        } else {
            i += cpdpat_len;
            len = word.size() - i;
            soldi = i;
            oldlen = len;
            oldcmin = cmin;
            oldcmax = cmax;
        }

        // Update the character minimum and maximum values for further processing
        setcminmax(&cmin, &cmax, word.c_str(), len);

        // Recursively check the remaining part of the word
        if (timelimit != 0 && (clock() > timelimit + TIMELIMIT)) {
            timelimit = 0;
        }
        if (timelimit == 0)
            return NULL;

        if (wordnum + 2 < maxwordnum) {
            rv = compound_check(word, wordnum + 1, numsyllable, maxwordnum, wnum + 1, words, rwords, hu_mov_rule, is_sug, info);
            if (rv)
                return rv;
        }
    }
}