// <MASK>
if (!checkcpdtable.empty()) {
    int cpdpat_len = checkcpdtable[scpd - 1].pattern.size();
    int cpdpat2_len = checkcpdtable[scpd - 1].pattern2.size();
    int cpdpat3_len = checkcpdtable[scpd - 1].pattern3.size();

    // Check if the current word matches the compound pattern
    if (cpdpat_len > 0 && strncmp(word.c_str() + i, checkcpdtable[scpd - 1].pattern.c_str(), cpdpat_len) == 0) {
        // Update the indices and length parameters
        i += cpdpat_len;
        len -= cpdpat_len;
        cmin += cpdpat_len;
        cmax -= cpdpat_len;
    } else if (cpdpat2_len > 0 && strncmp(word.c_str() + i, checkcpdtable[scpd - 1].pattern2.c_str(), cpdpat2_len) == 0) {
        i += cpdpat2_len;
        len -= cpdpat2_len;
        cmin += cpdpat2_len;
        cmax -= cpdpat2_len;
    } else if (cpdpat3_len > 0 && strncmp(word.c_str() + i, checkcpdtable[scpd - 1].pattern3.c_str(), cpdpat3_len) == 0) {
        i += cpdpat3_len;
        len -= cpdpat3_len;
        cmin += cpdpat3_len;
        cmax -= cpdpat3_len;
    } else {
        // The current word does not match the compound pattern, move to the next iteration
        scpd++;
        continue;
    }

    // Check if the current word matches the compound pattern condition
    if (checkcpdtable[scpd - 1].cond != FLAG_NULL && !TESTAFF(rv->astr, checkcpdtable[scpd - 1].cond, rv->alen)) {
        scpd++;
        continue;
    }

    // Check if the next word matches the compound pattern condition
    if (checkcpdtable[scpd - 1].cond2 != FLAG_NULL && words && !TESTAFF(words[wnum + 1]->astr, checkcpdtable[scpd - 1].cond2, words[wnum + 1]->alen)) {
        scpd++;
        continue;
    }

    // Update the state variables
    soldi = i;
    oldlen = len;
    oldcmin = cmin;
    oldcmax = cmax;
}