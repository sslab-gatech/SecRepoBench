// Interpret the NetBIOS name from the packet payload and store it in the flow's host server name.
  // Determine the offset to start interpreting the name based on the payload's content.
  // Update the detected protocol for the flow based on the sub-protocol value.
  u_int8_t *payload = packet->payload;
  u_int8_t *name_start = NULL;
  u_int16_t payload_len = packet->payload_packet_len;

  // Check for NetBIOS name query request
  if (h.flags == 0 &&
      h.questions == 1 &&
      h.answer_rrs == 0 &&
      h.authority_rrs == 0 && h.additional_rrs == 0) {
    // Look for the name in the payload
    for (u_int16_t i = 0; i < payload_len; i++) {
      if (payload[i] == 0x00) {
        name_start = &payload[i + 1];
        break;
      }
    }
  }

  // Check for NetBIOS name query response
  if (h.flags == 0x8400 &&
      h.questions == 1 &&
      h.answer_rrs == 0 &&
      h.authority_rrs == 0 && h.additional_rrs == 1) {
    // Look for the name in the payload
    for (u_int16_t i = 0; i < payload_len; i++) {
      if (payload[i] == 0x00) {
        name_start = &payload[i + 1];
        break;
      }
    }
  }

  // If a name is found, interpret it
  if (name_start != NULL) {
    char name_buffer[256];
    int name_length = ndpi_netbios_name_interpret(name_start, payload_len - (name_start - payload), name_buffer, sizeof(name_buffer));
    if (name_length > 0) {
      ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_NETBIOS);
      flow->host_server_name = strndup(name_buffer, name_length);
    }
  }