const u_int8_t *ptr = flow->packet.payload;
  u_int16_t name_offset = 0;

  if (sub_protocol == NDPI_NETBIOS_SUBPROTOCOL_NAME_QUERY_REQUEST ||
      sub_protocol == NDPI_NETBIOS_SUBPROTOCOL_NAME_QUERY_RESPONSE) {
    if (flow->packet.payload_packet_len > 17 && ptr[16] != 0x20) {
      name_offset = 17; // Adjust offset for name resolution responses.
    } else if (flow->packet.payload_packet_len > 1 && ptr[0] != 0x20) {
      name_offset = 1;  // Adjust offset for name registration requests.
    }
  }

  if (name_offset > 0 && flow->packet.payload_packet_len > name_offset + 32) {
    // Ensure we don't read beyond the payload boundary.

    memcpy(flow->host_server_name, &ptr[name_offset], 32);
    flow->host_server_name[32] = '\0'; // Null-terminate the string.
  }

  switch (sub_protocol) {
  case NDPI_NETBIOS_SUBPROTOCOL_NAME_QUERY_REQUEST:
    ndpi_int_change_packet_protocol(detectionmodulestruct, flow, NDPI_PROTOCOL_NETBIOS, NDPI_NETBIOS_SUBPROTOCOL_NAME_QUERY_REQUEST);
    break;
  case NDPI_NETBIOS_SUBPROTOCOL_NAME_QUERY_RESPONSE:
    ndpi_int_change_packet_protocol(detectionmodulestruct, flow, NDPI_PROTOCOL_NETBIOS, NDPI_NETBIOS_SUBPROTOCOL_NAME_QUERY_RESPONSE);
    break;
  case NDPI_NETBIOS_SUBPROTOCOL_NAME_REGISTRATION_REQUEST:
    ndpi_int_change_packet_protocol(detectionmodulestruct, flow, NDPI_PROTOCOL_NETBIOS, NDPI_NETBIOS_SUBPROTOCOL_NAME_REGISTRATION_REQUEST);
    break;
  default:
    ndpi_int_change_packet_protocol(detectionmodulestruct, flow, NDPI_PROTOCOL_NETBIOS, NDPI_NETBIOS_SUBPROTOCOL_UNKNOWN);
    break;
  }