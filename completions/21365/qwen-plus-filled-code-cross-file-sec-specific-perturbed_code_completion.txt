u_int8_t *netbios_name = NULL;
u_int16_t name_length = 0;

// Determine the offset to start interpreting the NetBIOS name based on payload content
if(flow->packet.payload_packet_len > sizeof(struct ndpi_transport_layer_credentials)) {
  struct ndpi_transport_layer_credentials *credentials = (struct ndpi_transport_layer_credentials *)flow->packet.payload;
  
  if(credentials->username_len > 0 && credentials->username_len <= NBNS_NAME_MAX_LENGTH) {
    name_length = credentials->username_len;
    netbios_name = (u_int8_t*)&credentials->username;
    
    // Validate that the name_length does not exceed allocated space
    if(name_length > flow->packet.payload_packet_len - offsetof(struct ndpi_transport_layer_credentials, username)) {
      NDPI_LOG_ERROR(detectionmodulestruct, "Invalid NetBIOS name length. Possible overflow detected.\n");
      return;
    }
    
    // Store the NetBIOS name in the flow's host server name
    if(flow->host_server_name == NULL) {
      flow->host_server_name = malloc(name_length + 1);
      
      if(flow->host_server_name != NULL) {
        memcpy(flow->host_server_name, netbios_name, name_length);
        flow->host_server_name[name_length] = '\0';
      } else {
        NDPI_LOG_ERROR(detectionmodulestruct, "Failed to allocate memory for host_server_name.\n");
        return;
      }
    }
  }
}

// Update the detected protocol for the flow based on the sub-protocol value
ndpi_int_change_packet_protocol(detectionmodulestruct, flow, NDPI_PROTOCOL_NETBIOS, sub_protocol);