// Interpret the NetBIOS name from the packet payload and store it in the flow's host server name.
  // Determine the offset to start interpreting the name based on the payload's content.
  // Update the detected protocol for the flow based on the sub-protocol value.
  u_int8_t *payload = packet->payload;
  u_int8_t *name_start = NULL;
  u_int16_t payload_len = packet->payload_packet_len;

  // Check for NetBIOS name query request
  if (packet->payload[0] == 0x81 && packet->payload[1] == 0x00 && payload_len >= 12) {
    name_start = &payload[12];
  } else if (packet->payload[0] == 0x83 && packet->payload[1] == 0x00 && payload_len >= 12) {
    name_start = &payload[12];
  } else if (packet->payload[0] == 0x84 && packet->payload[1] == 0x00 && payload_len >= 12) {
    name_start = &payload[12];
  } else if (packet->payload[0] == 0x85 && packet->payload[1] == 0x00 && payload_len >= 12) {
    name_start = &payload[12];
  } else if (packet->payload[0] == 0x86 && packet->payload[1] == 0x00 && payload_len >= 12) {
    name_start = &payload[12];
  } else if (packet->payload[0] == 0x87 && packet->payload[1] == 0x00 && payload_len >= 12) {
    name_start = &payload[12];
  } else if (packet->payload[0] == 0x88 && packet->payload[1] == 0x00 && payload_len >= 12) {
    name_start = &payload[12];
  }

  if (name_start != NULL) {
    u_int8_t name_length = name_start[0];
    if (name_length + 1 < payload_len && name_start[name_length + 1] == 0) {
      char name[256];
      int name_len = ndpi_netbios_name_interpret(name_start, name_length, name, sizeof(name));
      if (name_len > 0) {
        ndpi_set_detected_protocol(flow, NDPI_PROTOCOL_NETBIOS, NDPI_PROTOCOL_UNKNOWN);
        flow->host_server_name = strdup(name);
      }
    }
  }