{
    struct ndpi_packet_struct *packet = &flow->packet;
    /* Ensure there is enough payload to contain a NetBIOS name.
       Here we expect at least 33 bytes: one possible extra byte indicating the encoding,
       followed by the actual encoded name (up to 32 bytes). */
    if(packet->payload_packet_len < 33)
        return;

    /* Determine the starting offset for the NetBIOS name.
       It is common for a NetBIOS packet to include an extra initial byte (e.g. 0x20)
       that indicates the encoding â€“ if present, skip it. */
    u_int16_t name_offset = 0;
    if(packet->payload[0] == 0x20 && packet->payload_packet_len >= 33)
        name_offset = 1;

    /* Calculate the number of bytes available for the name. */
    size_t available_len = packet->payload_packet_len - name_offset;

    /* 
     * Copy the NetBIOS name into the flow's host_server_name field.
     * We assume that flow->host_server_name is a fixed-size array.
     * Copy at most (buffer_size - 1) bytes to leave room for the terminating null.
     */
    size_t buf_size = sizeof(flow->host_server_name);
    size_t copy_len = available_len < (buf_size - 1) ? available_len : (buf_size - 1);
    memcpy(flow->host_server_name, &packet->payload[name_offset], copy_len);
    flow->host_server_name[copy_len] = '\0';

    /* Update the protocol detection by marking the primary protocol as NDPI_PROTOCOL_NETBIOS
       and the secondary protocol with the provided sub_protocol value. */
    ndpi_int_change_packet_protocol(detectionmodulestruct, flow, NDPI_PROTOCOL_NETBIOS, sub_protocol);
}