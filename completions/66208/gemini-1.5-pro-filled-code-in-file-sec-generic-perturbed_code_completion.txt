if (m == 0) return 0;

  /* Initialize the bitmask and prefilter table */
  bitint mask = 0;
  bitint table[256];
  for (long i = 0; i < 256; ++i) {
    table[i] = ~0;
  }
  for (long i = 0; i < m; ++i) {
    mask |= (bitint)1 << (xs[i] & (sizeof(bitint) * CHAR_BIT - 1));
    table[xs[i]] ^= (bitint)1 << (i & (sizeof(bitint) * CHAR_BIT - 1));
  }

  bitint r = ~0;
  const unsigned char *ys_end = ys + lengthy;
#if ALIGNED_WORD_ACCESS
  /* Adjust the alignment of `ys` */
  long align = (sizeof(bitint) - 1) & (long)ys;
  for (; align > 0 && ys < ys_end; --align, ++ys) {
    r = (r << 1) | table[*ys];
    if (!(r & MASK4)) return (long)(ys - align - xs + 1);
  }
#endif
  /* Perform the search using bit manipulation */
  for (; ys + m <= ys_end; ys += sizeof(bitint)) {
    for (long i = 0; i < sizeof(bitint); ++i) {
      r = (r << 1) | table[*ys];
      if (!(r & MASK4)) return (long)(ys - xs + 1);
      ++ys;
    }
    ys -= sizeof(bitint);
    if (!((mask & *(bitint*)ys) == mask)) continue;
    if (memcmp(xs, ys, m) == 0) return (long)(ys - xs);
  }
  /* Handle the remaining bytes */
  for (; ys < ys_end; ++ys) {
    r = (r << 1) | table[*ys];
    if (!(r & MASK4)) return (long)(ys - xs + 1);
  }