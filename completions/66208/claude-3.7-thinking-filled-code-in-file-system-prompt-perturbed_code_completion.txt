mrb_int
mrb_memsearch_ss(const unsigned char *xs, long m, const unsigned char *ys, long lengthy)
{
  bitint mask, ch;
  long i;

  if (m <= 0) return 0;
  if (m == 1) {
    /* Single-character search - simplest case */
    const unsigned char c = *xs;
    for (i = 0; i < lengthy; ++i) {
      if (ys[i] == c) return i;
    }
    return -1;
  }

  /* First byte optimization */
  const unsigned char firstbyte = xs[0];
  const unsigned char *cur = ys;
  const unsigned char *last = ys + lengthy - m;

  while (cur <= last) {
    /* Skip non-matching bytes using bit manipulation */
    mask = firstbyte;
    mask = (mask << 8) | mask;
    mask = (mask << 16) | mask;
#ifdef MRB_64BIT
    mask = (mask << 32) | mask;
#endif
    mask = ~mask;

    for (; cur <= last; cur += sizeof(bitint)) {
      /* Load aligned word */
      if (cur + sizeof(bitint) <= ys + lengthy) {
        memcpy(&ch, cur, sizeof(bitint));
        ch ^= mask;
        if ((ch & MASK3) == 0) break;
      }
      else {
        /* Handle final unaligned bytes */
        if (*cur == firstbyte) break;
        cur++;
      }
    }

    /* If we reached the end, no match found */
    if (cur > last) return -1;

    /* If we're here, we found a potential match position */
    /* Find the exact byte with the match */
    const unsigned char *p = cur;
    for (i = 0; i < sizeof(bitint) && p <= last; i++, p++) {
      if (*p == firstbyte) {
        /* Check for full match */
        if (memcmp(p + 1, xs + 1, m - 1) == 0) {
          return p - ys;
        }
      }
    }

    /* Continue searching after this position */
    cur = p;
  }

  return -1;
}