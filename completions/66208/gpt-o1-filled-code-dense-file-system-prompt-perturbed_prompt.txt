Below is the content of a C/C++ function where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
static inline mrb_int
mrb_memsearch_ss(const unsigned char *xs, long m, const unsigned char *ys, long lengthy)
{
#ifdef MRB_64BIT
#define bitint uint64_t
#define MASK1 0x0101010101010101ull
#define MASK2 0x7f7f7f7f7f7f7f7full
#define MASK3 0x8080808080808080ull
#else
#define bitint uint32_t
#define MASK1 0x01010101ul
#define MASK2 0x7f7f7f7ful
#define MASK3 0x80808080ul
#endif
#if defined(MRB_ENDIAN_BIG)
#ifdef MRB_64BIT
#define MASK4 0x8000000000000000ull
#else
#define MASK4 0x80000000ul
#endif
#else
#define MASK4 0x80
#endif

// This function performs a substring search using a bit manipulation technique.
// It returns the byte index of the first occurrence of `xs` in `ys`.
// <MASK>

  return -1;
}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/string.c
static mrb_int
mrb_memsearch(const char *x0, mrb_int m, const char *y0, mrb_int n)
{
  const unsigned char *x = (const unsigned char*)x0, *y = (const unsigned char*)y0;

  if (m > n) return -1;
  else if (m == n) {
    return memcmp(x0, y0, m) == 0 ? 0 : -1;
  }
  else if (m < 1) {
    return 0;
  }
  else if (m == 1) {
    const unsigned char *p = (const unsigned char*)memchr(y, *x, n);

    if (p) return (mrb_int)(p - y);
    return -1;
  }
  return mrb_memsearch_ss((const unsigned char*)x0, m, (const unsigned char*)y0, n);
}

// the below code fragment can be found in:
// mrbgems/mruby-compiler/core/y.tab.c
static inline mrb_sym
intern_gen(parser_state *p, const char *s, size_t len)
{
  return mrb_intern(p->mrb, s, len);
}

// the below code fragment can be found in:
// mrbgems/mruby-bigint/core/bigint.c
mrb_int
mrb_bint_cmp(mrb_state *mrb, mrb_value x, mrb_value y)
{
#ifndef MRB_NO_FLOAT
  if (mrb_float_p(y)) {
    mrb_float v1 = mrb_bint_as_float(mrb, x);
    mrb_float v2 = mrb_float(y);
    if (v1 == v2) return 0;
    if (v1 > v2)  return 1;
    return -1;
  }
#endif
  struct RBigint *b = RBIGINT(x);
  if (!mrb_bigint_p(y)) {
    if (!mrb_integer_p(y)) return -2; /* type mismatch */

    mrb_int i1, i2 = mrb_integer(y);
    if (mpz_get_int(&b->mp, &i1)) {
      if (i1 == i2) return 0;
      if (i1 > i2) return 1;
      return -1;
    }
    if (b->mp.sn > 0) return 1;
    return -1;
  }
  struct RBigint *b2 = RBIGINT(y);
  return mpz_cmp(mrb, &b->mp, &b2->mp);
}

// the below code fragment can be found in:
// src/numeric.c
static mrb_value
int_xor(mrb_state *mrb, mrb_value x)
{
  mrb_value y = mrb_get_arg1(mrb);

#ifdef MRB_USE_BIGINT
  if (mrb_bigint_p(x)) {
    return mrb_bint_xor(mrb, x, y);
  }
  if (mrb_bigint_p(y)) {
    return mrb_bint_xor(mrb, mrb_as_bint(mrb, x), y);
  }
#endif
  bit_op(x, y, or, ^);
}

// the below code fragment can be found in:
// src/numeric.c
static mrb_value
int_or(mrb_state *mrb, mrb_value x)
{
  mrb_value y = mrb_get_arg1(mrb);

#ifdef MRB_USE_BIGINT
  if (mrb_bigint_p(x)) {
    return mrb_bint_or(mrb, x, y);
  }
  if (mrb_bigint_p(y)) {
    return mrb_bint_or(mrb, mrb_as_bint(mrb, x), y);
  }
#endif
  bit_op(x, y, or, |);
}
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).