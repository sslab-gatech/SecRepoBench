if (m == 0) return 0;
  if (m > lengthy) return -1;

  const bitint c = xs[0];
  bitint c_mask = 0;
  for (int i = 0; i < sizeof(bitint); i++) {
    c_mask = (c_mask << 8) | c;
  }

  const unsigned char *end = ys + lengthy - m + 1;
  for (const unsigned char *cur = ys; cur < end; ) {
    bitint chunk;
    if (cur + sizeof(bitint) > end) {
      chunk = 0;
      for (int i = 0; i < end - cur; i++) {
        chunk = (chunk << 8) | cur[i];
      }
      chunk <<= 8 * (sizeof(bitint) - (end - cur));
    } else {
      chunk = *(const bitint *)cur;
    }

    bitint xor_result = chunk ^ c_mask;
    bitint matches = ((xor_result - MASK1) & ~xor_result) & MASK3;

    while (matches) {
      bitint pos_mask;
      int shift;
#if defined(MRB_ENDIAN_BIG)
      pos_mask = MASK4;
      shift = (sizeof(bitint) - 1) * 8;
#else
      pos_mask = MASK4;
      shift = 0;
#endif

      for (int i = 0; i < sizeof(bitint); i++) {
        if (matches & pos_mask) {
          mrb_int candidate = cur - ys + (shift / 8);
          if (candidate <= lengthy - m) {
            int match = 1;
            for (mrb_int j = 0; j < m; j++) {
              if (ys[candidate + j] != xs[j]) {
                match = 0;
                break;
              }
            }
            if (match) return candidate;
          }
        }
#if defined(MRB_ENDIAN_BIG)
        pos_mask >>= 8;
        shift -= 8;
#else
        pos_mask <<= 8;
        shift += 8;
#endif
      }
      matches &= matches - 1;
    }
    cur += sizeof(bitint);
  }
  return -1;