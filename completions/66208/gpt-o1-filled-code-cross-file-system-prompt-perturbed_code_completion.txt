if (m <= 0) {
    /* Empty needle or invalid length */
    return -1;
  }
  if (m > lengthy) {
    /* Needle is longer than haystack */
    return -1;
  }

  /* Precompute a bitint value filled with the first byte of xs */
  bitint first_byte_fill = (unsigned char)xs[0];
#if defined(MRB_ENDIAN_BIG)
  /* For big endian, shift right by 8 each time and add the first byte at the top */
  for (int i = 1; i < (int)sizeof(bitint); i++) {
    first_byte_fill >>= 8;
    first_byte_fill |= ((bitint)(xs[0]) << ((sizeof(bitint) - 1) * 8));
  }
#else
  /* For little endian, shift left by 8 each time and add the first byte at the bottom */
  for (int i = 1; i < (int)sizeof(bitint); i++) {
    first_byte_fill <<= 8;
    first_byte_fill |= (bitint)(xs[0]);
  }
#endif

  /* Search for the first occurrence of xs in ys using bit manipulation */
  for (long i = 0; i <= lengthy - m; i += (long)sizeof(bitint)) {
    /* Read a chunk of haystack as a bitint */
    bitint block = *((const bitint*)(ys + i));

    /* XOR with the repeated first byte to find potential matches */
    block ^= first_byte_fill;

    /* Use the known trick (x - MASK1) & ~x & MASK2/MASK3 to detect zero bytes */
    bitint match_mask = (block - MASK1) & ~block & MASK2;

    /* Check each possible matched byte inside this chunk */
    while (match_mask != 0) {
#if defined(MRB_64BIT)
      /* Find offset of the least significant set bit, in multiples of 8 for bytes */
      unsigned long offset = __builtin_ctzll(match_mask) >> 3;
#else
      unsigned long offset = __builtin_ctz(match_mask) >> 3;
#endif
      if (offset + i + m <= (unsigned long)lengthy) {
        /* Verify if we have a full match of xs at this position */
        if (memcmp(xs, ys + i + offset, m) == 0) {
          return i + offset;
        }
      }
      /* Clear the least significant set bit and continue */
      match_mask &= (match_mask - 1);
    }
  }