*     "hello".capitalize   #=> "Hello"
 *     "HELLO".capitalize   #=> "Hello"
 *     "123ABC".capitalize  #=> "123abc"
 */
static mrb_value
mrb_str_capitalize(mrb_state *mrb, mrb_value str)
{
  struct RString *s = mrb_str_ptr(str);
  struct RString *dup = str_new(mrb, 0, 0);

  if (RSTR_LEN(s) == 0) return mrb_obj_value(dup);
  if (ISLOWER(s->as.heap.ptr[0])) {
    dup = str_init_normal(mrb, dup, s->as.heap.ptr, 1);
  }
  else {
    dup = str_init_normal(mrb, dup, s->as.heap.ptr, 1);
    mrb_str_modify_keep_ascii(mrb, dup);
  }
  char *p = RSTR_PTR(dup) + 1;
  char *pend = RSTR_PTR(dup) + RSTR_LEN(dup);
  while (p < pend) {
    if (ISUPPER(*p)) {
      *p = TOLOWER(*p);
    }
    p++;
  }
  return mrb_obj_value(dup);
}

/* 15.2.10.5.9  */
/*
 *  call-seq:
 *     str.casecmp(other_str)   => -1, 0, 1
 *
 *  Case-insensitive comparison of <i>str</i> with <i>other_str</i>.
 *
 *  If <i>str</i> <code><=></code> <i>other_str</i> is less than 0, returns -1.
 *  If <i>str</i> <code><=></code> <i>other_str</i> is greater than 0, returns 1.
 *  If they are equal, returns 0.
 *
 *     "abcdef".casecmp("abcde")     #=> 1
 *     "aBcDeF".casecmp("abcdef")    #=> 0
 *     "abcdef".casecmp("abcdefg")   #=> -1
 *     "abcdef".casecmp("ABCDEF")    #=> 0
 */
static mrb_value
mrb_str_casecmp(mrb_state *mrb, mrb_value str1)
{
  mrb_value str2 = mrb_get_arg1(mrb);
  int result;

  if (!mrb_string_p(str2)) {
    return mrb_nil_value();
  }
  else {
    result = strncasecmp(RSTRING_PTR(str1), RSTRING_PTR(str2), RSTRING_LEN(str1));
    if (result < 0) return mrb_int_value(mrb, -1);
    if (result > 0) return mrb_int_value(mrb, 1);
    return mrb_int_value(mrb, 0);
  }
}

/* 15.2.10.5.10 */
/*
 *  call-seq:
 *     str.center(integer, padstr)   => new_str
 *
 *  If <i>integer</i> is greater than the length of <i>str</i>, returns a new
 *  <code>String</code>, padding with <i>padstr</i> to the width <i>integer</i>.
 *  Padding is done using the <i>padstr</i> string or with whitespace
 *  when <i>padstr</i> is not supplied.
 *
 *     "hello".center(4)         #=> "hello"
 *     "hello".center(20)        #=> "       hello        "
 *     "hello".center(20, "=")   #=> "=========hello========"
 */
static mrb_value
mrb_str_center(mrb_state *mrb, mrb_value str, mrb_int width, mrb_value padstr)
{
  struct RString *s = mrb_str_ptr(str);
  struct RString *dup;
  mrb_int len = RSTR_LEN(s);
  mrb_int padlen = 0;
  const char *pad = NULL;

  if (mrb_nil_p(padstr)) {
    padstr = mrb_str_new_lit(mrb, " ");
  }
  else {
    mrb_ensure_string_type(mrb, padstr);
  }
  padlen = RSTR_LEN(padstr);
  pad = RSTRING_PTR(padstr);

  if (width <= len) {
    dup = str_new(mrb, 0, len);
    memcpy(RSTR_PTR(dup), RSTR_PTR(s), len);
  }
  else {
    dup = str_new(mrb, 0, width);
    mrb_str_modify(mrb, dup);
    mrb_int pad_len = (width - len) / 2;
    mrb_int pad_len_mod = (width - len) % 2;
    if (pad_len > 0) {
      memcpy(RSTR_PTR(dup), pad, pad_len * sizeof(char));
    }
    memcpy(RSTR_PTR(dup) + pad_len, RSTR_PTR(s), len);
    if (pad_len_mod > 0) {
      memcpy(RSTR_PTR(dup) + pad_len + len, pad, pad_len_mod * sizeof(char));
    }
  }
  RSTR_SET_LEN(dup, width);
  RSTR_PTR(dup)[width] = '\0';
  return mrb_obj_value(dup);
}

/* 15.2.10.5.11 */
/*
 *  call-seq:
 *     str.chomp([separator])   => new_str
 *
 *  Returns a new <code>String</code> with the given record separator removed
 *  from the end of <i>str</i> (if present). If <i>separator</i> is
 *  <code>nil</code>, it will remove all trailing newlines from the string.
 *
 *     "hello".chomp            #=> "hello"
 *     "hello\n".chomp          #=> "hello"
 *     "hello\r\n".chomp        #=> "hello"
 *     "hello\n\r".chomp        #=> "hello\n"
 *     "hello\r".chomp          #=> "hello"
 *     "hello \n there".chomp   #=> "hello \n there"
 *     "hello".chomp("llo")     #=> "he"
 */
static mrb_value
mrb_str_chomp(mrb_state *mrb, mrb_value str, mrb_value sep)
{
  struct RString *s = mrb_str_ptr(str);
  const char *sepstr = NULL;
  mrb_int seplen = 0;
  char *p, *pend;

  if (!mrb_nil_p(sep)) {
    mrb_ensure_string_type(mrb, sep);
    sepstr = RSTRING_PTR(sep);
    seplen = RSTRING_LEN(sep);
  }

  p = RSTR_PTR(s) + RSTR_LEN(s) - 1;
  pend = RSTR_PTR(s);

  if (seplen == 0) {
    while (p >= pend && (*p == '\n' || *p == '\r')) {
      p--;
    }
  }
  else {
    p = RSTR_PTR(s) + RSTR_LEN(s) - seplen;
    if (strncmp(p, sepstr, seplen) == 0) {
      p += seplen;
    }
  }

  struct RString *dup = str_new(mrb, 0, (mrb_int)(p - RSTR_PTR(s)));
  memcpy(RSTR_PTR(dup), RSTR_PTR(s), p - RSTR_PTR(s));
  RSTR_SET_LEN(dup, p - RSTR_PTR(s));
  RSTR_PTR(dup)[RSTR_LEN(dup)] = '\0';

  return mrb_obj_value(dup);
}

/* 15.2.10.5.12 */
/*
 *  call-seq:
 *     str.chomp!(separator=$/)   => str or nil
 *
 *  Modifies <i>str</i> in place as described for <code>String#chomp</code>,
 *  returning <i>str</i>, or <code>nil</code> if no modifications were made.
 */
static mrb_value
mrb_str_chomp_bang(mrb_state *mrb, mrb_value str, mrb_value sep)
{
  struct RString *s = mrb_str_ptr(str);
  const char *sepstr = NULL;
  mrb_int seplen = 0;
  char *p, *pend;

  if (!mrb_nil_p(sep)) {
    mrb_ensure_string_type(mrb, sep);
    sepstr = RSTRING_PTR(sep);
    seplen = RSTRING_LEN(sep);
  }

  p = RSTR_PTR(s) + RSTR_LEN(s) - 1;
  pend = RSTR_PTR(s);

  if (seplen == 0) {
    while (p >= pend && (*p == '\n' || *p == '\r')) {
      p--;
    }
  }
  else {
    p = RSTR_PTR(s) + RSTR_LEN(s) - seplen;
    if (strncmp(p, sepstr, seplen) == 0) {
      p += seplen;
    }
  }

  if (p == RSTR_PTR(s)) {
    return mrb_nil_value();
  }

  mrb_str_modify(mrb, s);
  RSTR_SET_LEN(s, p - RSTR_PTR(s));
  RSTR_PTR(s)[RSTR_LEN(s)] = '\0';

  return str;
}

/* 15.2.10.5.13 */
/*
 *  call-seq:
 *     str.chop   => new_str
 *
 *  Returns a new <code>String</code> with the last character removed.  If the
 *  string ends with <code>\r\n</code>, both characters are removed. Applying
 *  <code>chop</code> to an empty string returns an empty string.
 *
 *     "string\r\n".chop       #=> "string"
 *     "string\n\r".chop       #=> "string\n"
 *     "string\n".chop         #=> "string"
 *     "string".chop           #=> "strin"
 *     "x".chop                #=> ""
 *     "".chop                 #=> ""
 */
static mrb_value
mrb_str_chop(mrb_state *mrb, mrb_value str)
{
  struct RString *s = mrb_str_ptr(str);
  mrb_int len = RSTR_LEN(s);
  struct RString *dup;

  if (len == 0) {
    dup = str_new(mrb, 0, 0);
  }
  else {
    dup = str_new(mrb, 0, len - 1);
    memcpy(RSTR_PTR(dup), RSTR_PTR(s), len - 1);
    RSTR_PTR(dup)[len - 1] = '\0';
    if (len > 1 && RSTR_PTR(s)[len - 1] == '\n' && RSTR_PTR(s)[len - 2] == '\r') {
      RSTR_SET_LEN(dup, len - 2);
    }
  }
  return mrb_obj_value(dup);
}

/* 15.2.10.5.14 */
/*
 *  call-seq:
 *     str.chop!   => str or nil
 *
 *  Removes the last character of <i>str</i>.  If the string ends with <code>\r\n</code>,
 *  both characters are removed.  If the string is empty, the original string is
 *  returned.  If the string