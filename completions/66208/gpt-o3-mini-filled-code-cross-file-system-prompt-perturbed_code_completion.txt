if (m == 0) return 0;
if (lengthy < m) return -1;

/* For multi-byte patterns, fall back to a simple byte‐by‐byte search */
if (m != 1) {
  for (long i = 0; i <= lengthy - m; i++) {
    if (ys[i] == xs[0] && memcmp(ys + i, xs, m) == 0)
      return i;
  }
  return -1;
}

/* When m == 1, use a bit-manipulation based search for the target byte */
unsigned char c = xs[0];
const unsigned char *p = ys;
long n = lengthy;

/* Process initial bytes until p is aligned to a word boundary */
while (n > 0 && ((uintptr_t)p & (sizeof(bitint) - 1))) {
  if (*p == c)
    return p - ys;
  p++;
  n--;
}

/* Process aligned words */
if (n >= (long)sizeof(bitint)) {
  bitint k = c * MASK1;  /* Replicate the target byte in every byte of k */
  while (n >= (long)sizeof(bitint)) {
    bitint w = *(const bitint *)p;
    bitint tmp = w ^ k;
    /* The following expression detects if any byte in w equals c */
    if (((tmp - MASK1) & ~tmp & MASK3) != 0) {
      for (int i = 0; i < (int)sizeof(bitint); i++) {
        if (p[i] == c)
          return (p - ys) + i;
      }
    }
    p += sizeof(bitint);
    n -= sizeof(bitint);
  }
}

/* Process any remaining bytes */
while (n--) {
  if (*p == c)
    return p - ys;
  p++;
}