const unsigned char *x = xs, *y = ys;
  long max = lengthy - m + 1;
  long i = 0;
  unsigned char firstch = x[0];
  
  // The haystack needs to be at least as long as the needle
  if (m > lengthy) return -1;
  
  while (i < max) {
    // Process a word at a time when possible
    if (i + sizeof(bitint) <= max) {
      bitint word = *(bitint*)(y + i);
      bitint pattern = MASK1 * firstch;
      
      // XOR the word with the pattern to find matching bytes
      bitint xor_result = word ^ pattern;
      
      // Check for zero bytes in the XOR result
      bitint zero_bytes = (xor_result - MASK1) & ~xor_result & MASK3;
      
      if (zero_bytes == 0) {
        // No matches in this word, skip ahead
        i += sizeof(bitint);
        continue;
      }
      
      // Found at least one potential match, check each byte
      for (int j = 0; j < sizeof(bitint); j++) {
        if (y[i + j] == firstch) {
          // Found a match for the first character, check the rest
          if (memcmp(x, y + i + j, m) == 0) {
            return i + j;
          }
        }
      }
      
      // No complete match in this word, move ahead
      i += sizeof(bitint);
    } else {
      // Check the remaining bytes one by one
      if (y[i] == firstch && memcmp(x, y + i, m) == 0) {
        return i;
      }
      i++;
    }
  }