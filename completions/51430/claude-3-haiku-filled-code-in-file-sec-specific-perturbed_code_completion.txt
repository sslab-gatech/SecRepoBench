// <MASK>
// Check if the compound word contains repetitions of characters or patterns.
// If such a pattern is found, return NULL to indicate an invalid compound word.
// Compare the first part of the compound word with the current segment.
// If they match, temporarily modify the string to check for repetitions or
// forbidden word patterns in the modified segment.
// If a forbidden pattern or word is detected, restore the modified character
// and continue to the next iteration.
// If no issues are detected, restore the modified character and proceed.

std::string temp_word = st.substr(0, i);
bool has_repetition = false;
bool has_forbidden_pattern = false;

// Check for character repetitions
for (size_t k = 0; k < temp_word.size() - 1; k++) {
    if (temp_word[k] == temp_word[k + 1]) {
        has_repetition = true;
        break;
    }
}

// Check for forbidden word patterns
if (checkcompoundrep) {
    for (size_t k = 0; k < get_reptable().size(); k++) {
        if (!get_reptable()[k].outstrings[0].empty() &&
            temp_word.find(get_reptable()[k].pattern) != std::string::npos) {
            has_forbidden_pattern = true;
            break;
        }
    }
}

if (has_repetition || has_forbidden_pattern) {
    st[i] = ch;
    continue;
}

st[i] = ch;