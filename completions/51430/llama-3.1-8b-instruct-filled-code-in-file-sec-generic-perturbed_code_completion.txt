// Check if the compound word contains repetitions of characters or patterns.
// If such a pattern is found, return NULL to indicate an invalid compound word.
// Compare the first part of the compound word with the current segment.
// If they match, temporarily modify the string to check for repetitions or
// forbidden word patterns in the modified segment.
// If a forbidden pattern or word is detected, restore the modified character
// and continue to the next iteration.
// If no issues are detected, restore the modified character and proceed.
if (checkcompoundrep || forbiddenword) {
  // Check for repetitions of characters or patterns in the compound word.
  // If a repetition is found, return NULL to indicate an invalid compound word.
  for (size_t i = 0; i < compound_word.size(); ++i) {
    // Check for repetitions of characters.
    for (size_t j = i + 1; j < compound_word.size(); ++j) {
      if (compound_word[i] == compound_word[j]) {
        // If a repetition is found, return NULL to indicate an invalid compound word.
        return NULL;
      }
    }

    // Check for forbidden word patterns in the modified segment.
    std::string modified_segment = compound_word.substr(0, i + 1);
    for (size_t k = 0; k < checkcpdtable.size(); ++k) {
      size_t len;
      if (isSubset(checkcpdtable[k].pattern2.c_str(), compound_word.c_str() + i) &&
          (!r1 ||!checkcpdtable[k].cond ||
           (r1->astr && TESTAFF(r1->astr, checkcpdtable[k].cond, r1->alen))) &&
          (!r2 ||!checkcpdtable[k].cond2 ||
           (r2->astr && TESTAFF(r2->astr, checkcpdtable[k].cond2, r2->alen))) &&
          // zero length pattern => only TESTAFF
          // zero pattern (0/flag) => unmodified stem (zero affixes allowed)
          (checkcpdtable[k].pattern.empty() ||
           ((checkcpdtable[k].pattern[0] == '0' && r1->blen <= i &&
             strncmp(compound_word.c_str() + i - r1->blen, r1->word, r1->blen) == 0) ||
            (checkcpdtable[k].pattern[0]!= '0' &&
             ((len = checkcpdtable[k].pattern.size())!= 0) && len <= i &&
             strncmp(compound_word.c_str() + i - len, checkcpdtable[k].pattern.c_str(), len) == 0)))) {
        // If a forbidden pattern is found, return NULL to indicate an invalid compound word.
        return NULL;
      }
    }

    // Check for forbidden words in the modified segment.
    if (forbiddenword && (TESTAFF(modified_segment.c_str(), forbiddenword, modified_segment.size()))) {
      // If a forbidden word is found, return NULL to indicate an invalid compound word.
      return NULL;
    }
  }
}