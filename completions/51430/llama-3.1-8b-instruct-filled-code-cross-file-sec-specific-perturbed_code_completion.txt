// Check if the compound word contains repetitions of characters or patterns.
// If such a pattern is found, return NULL to indicate an invalid compound word.
// Compare the first part of the compound word with the current segment.
// If they match, temporarily modify the string to check for repetitions or
// forbidden word patterns in the modified segment.
// If a forbidden pattern or word is detected, restore the modified character
// and continue to the next iteration.
// If no issues are detected, restore the modified character and proceed.
if (checkcompoundrep || forbiddenword) {
  // Check for repetitions of characters
  for (int i = 0; i < len; i++) {
    for (int j = i + 1; j < len; j++) {
      if (compound_word[i] == compound_word[j]) {
        // Temporarily modify the string to check for forbidden word patterns
        std::string temp = compound_word;
        temp[i] = '\0';
        if (check_forbidden(temp)) {
          // Restore the modified character and continue to the next iteration
          compound_word[i] = compound_word[j];
          continue;
        }
        // If no issues are detected, restore the modified character and proceed
        compound_word[i] = compound_word[j];
        break;
      }
    }
  }

  // Check for forbidden word patterns
  for (int i = 0; i < len; i++) {
    for (int j = i + 1; j < len; j++) {
      std::string temp = compound_word;
      temp[i] = '\0';
      temp[j] = '\0';
      if (check_forbidden(temp)) {
        // Restore the modified character and continue to the next iteration
        compound_word[i] = compound_word[j];
        continue;
      }
    }
  }

  // If any issues are detected, return NULL to indicate an invalid compound word
  if (check_forbidden(compound_word)) {
    return NULL;
  }
}