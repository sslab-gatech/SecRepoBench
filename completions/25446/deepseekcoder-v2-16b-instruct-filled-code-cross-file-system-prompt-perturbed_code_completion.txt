// Calculate the offset for the Kerberos realm data within the flow packet payload.
// Determine if the cname string represents a hostname or a username by
// checking if it ends with a '$'. If it does, strip the '$' and store it
// as a hostname. Otherwise, store it as a username in the flow structure.
// Increment the realm offset by scanning through the flow packet payload until
// a specific ASN.1 identifier is found or a maximum number of iterations is reached.

u_int16_t realm_offset = koffsetp + 1 + pad_len;
u_int16_t num_cname = 0;

while(++num_cname <= 2) {
  if(cname_len > sizeof(cname_str)-1)
    cname_len = sizeof(cname_str)-1;

  strncpy(cname_str, (char*)&flow_packet->payload[name_offset+1], cname_len);
  cname_str[cname_len] = '\0';
  for(i=0; i<cname_len; i++) cname_str[i] = tolower(cname_str[i]);

  if(((strcmp(cname_str, "host") == 0) || (strcmp(cname_str, "ldap") == 0)) && (flow_packet->payload[name_offset+1+cname_len] == 0x1b)) {
    name_offset += cname_len + 2;
    cname_len = flow_packet->payload[name_offset];
  } else
    break;
}

if(num_cname == 2) {
  realm_offset++;
  if(realm_offset  < flow_packet->payload_packet_len) {
    realm_len = flow_packet->payload[realm_offset];

    if((realm_offset+realm_len) < flow_packet->payload_packet_len) {
      char realm_str[48];

      if(realm_len > sizeof(realm_str)-1)
        realm_len = sizeof(realm_str)-1;

      realm_offset += 1;

      strncpy(realm_str, (char*)&flow_packet->payload[realm_offset], realm_len);
      realm_str[realm_len] = '\0';
      for(i=0; i<realm_len; i++) realm_str[i] = tolower(realm_str[i]);

      snprintf(flow->protos.kerberos.domain, sizeof(flow->protos.kerberos.domain), "%s", realm_str);
    }
  }
}