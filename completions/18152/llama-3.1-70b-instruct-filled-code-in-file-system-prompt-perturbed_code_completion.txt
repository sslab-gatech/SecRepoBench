// Set the insert size from the input data.
// Calculate the new length for data allocation, considering extra nulls.
// Check for overflow and consistency errors in data lengths.
// Allocate or reallocate memory for the BAM data buffer to accommodate the new data size.
// Read the query name part of the BAM record into the buffer.
// Pad the query name with extra nulls if necessary.
new_m_data = c->l_qname + c->l_extranul + c->l_qseq + (c->l_qseq + 1) / 2 + c->n_cigar * 4 + 32;
if (new_m_data < c->l_qname + c->l_extranul) {
    errno = ENOMEM; // Not strictly true but we can't store the size
    return -4;
}
if ((bam_get_mempolicy(b) & BAM_USER_OWNS_DATA) == 0) {
    new_data = realloc(b->data, new_m_data);
} else {
    if ((new_data = malloc(new_m_data))!= NULL) {
        if (b->l_data > 0)
            memcpy(new_data, b->data,
                   b->l_data < b->m_data? b->l_data : b->m_data);
        bam_set_mempolicy(b, bam_get_mempolicy(b) & (~BAM_USER_OWNS_DATA));
    }
}
if (!new_data) return -4;
b->data = new_data;
b->m_data = new_m_data;
b->l_data = 0;

// Read the query name part of the BAM record into the buffer.
if (b->l_data < c->l_qname ||
    bgzf_read(filepointer, b->data + b->l_data, c->l_qname)!= c->l_qname)
    return -4;
b->l_data += c->l_qname;

// Pad the query name with extra nulls if necessary.
if (c->l_extranul > 0) {
    if (b->l_data + c->l_extranul > b->m_data) {
        if (realloc_bam_data(b, b->l_data + c->l_extranul) < 0) return -4;
    }
    memset(b->data + b->l_data, 0, c->l_extranul);
    b->l_data += c->l_extranul;
}