// Calculate the new length for data allocation, considering extra nulls.
    new_l_data = c->l_qname + c->n_cigar * 4 + (c->l_qseq + 1) / 2 + c->l_qseq + c->l_extranul;

    // Check for overflow and consistency errors in data lengths.
    if (new_l_data < c->l_qname || new_l_data < c->n_cigar * 4 || new_l_data < c->l_qseq ||
        new_l_data < b->l_data || new_l_data > INT32_MAX) {
        return -4; // Overflow or invalid data length
    }

    // Allocate or reallocate memory for the BAM data buffer to accommodate the new data size.
    if (b->m_data < new_l_data) {
        uint8_t *new_data = realloc(b->data, new_l_data);
        if (!new_data) {
            return -4; // Memory allocation failure
        }
        b->data = new_data;
        b->m_data = new_l_data;
    }
    b->l_data = new_l_data;

    // Read the query name part of the BAM record into the buffer.
    if (bgzf_read(filepointer, b->data, c->l_qname) != c->l_qname) {
        return -4; // Failed to read query name
    }

    // Pad the query name with extra nulls if necessary.
    for (i = 0; i < c->l_extranul; ++i) {
        b->data[c->l_qname + i] = 0;
    }