&& h->text[h->l_text - 1] != '\n') {
            if (realloc_bam_data(h, h->l_text + 1) < 0) {
                sam_hdr_destroy(h);
                return NULL;
            }
            h->text[h->l_text] = '\n';
            h->l_text++;
        }
    }

    return h;
}

// Parse a SAM header from a file.
//
// This function will read the entire file and parse the header.
// It will also handle the BGZF compression.
sam_hdr_t *sam_hdr_read(htsFile *fp)
{
    if (!fp) return NULL;

    kstring_t str = { 0, 0, NULL };
    int ret;

    if (fp->format.format == cram) {
        cram_fd *fd = fp->fp.cram;
        if (fd->header) {
            sam_hdr_t *h = sam_hdr_dup(fd->header);
            if (h) h->ref_count++;
            return h;
        }
    }

    // Read the entire file.
    while ((ret = bgzf_read(fp->fp.bgzf, str.s + str.l, 1)) > 0) {
        str.l++;
        if (str.s[str.l - 1] == '\n') {
            str.s[str.l - 1] = '\0'; // Replace newline with nul.
            break;
        }
    }

    if (ret < 0) {
        hts_log_error("Error reading BGZF stream");
        free(str.s);
        return NULL;
    }

    // Parse the header.
    sam_hdr_t *h = sam_hdr_parse(str.l, str.s);
    free(str.s);
    if (!h) return NULL;

    // Sanitise the header.
    h = sam_hdr_sanitise(h);
    if (!h) return NULL;

    // Duplicate the header if necessary.
    if (fp->format.format == cram) {
        cram_fd *fd = fp->fp.cram;
        if (fd->header) {
            sam_hdr_destroy(fd->header);
            fd->header = sam_hdr_dup(h);
            sam_hdr_destroy(h);
            h = fd->header;
            h->ref_count++;
        } else {
            fd->header = h;
        }
    }

    return h;
}

// Write a SAM header to a file.
//
// This function will write the entire header to the file, including the BGZF block
// padding. It will also handle the BGZF compression.
int sam_hdr_write(htsFile *fp, const sam_hdr_t *h)
{
    if (!fp || !h) return -1;

    kstring_t str = { 0, 0, NULL };
    int ret;

    if (h->hrecs) {
        if (sam_hrecs_rebuild_text(h->hrecs, &str) != 0) {
            free(str.s);
            return -1;
        }
    } else {
        str.s = h->text;
        str.l = h->l_text;
    }

    // Write the header to the file.
    ret = bgzf_write(fp->fp.bgzf, str.s, str.l);
    free(str.s);
    if (ret < 0) return -1;

    // Write the BGZF block padding.
    ret = bgzf_write(fp->fp.bgzf, "\0\0\0\0\0\0\0\0\0\0\xff", 11);
    if (ret < 0) return -1;

    return 0;
}

// Parse a SAM header from a file.
//
// This function will read the entire file and parse the header.
// It will also handle the BGZF compression.
sam_hdr_t *sam_hdr_read2(const char *fn)
{
    htsFile *fp = hts_open(fn, "r");
    if (!fp) return NULL;

    sam_hdr_t *h = sam_hdr_read(fp);
    hts_close(fp);

    return h;
}

// Write a SAM header to a file.
//
// This function will write the entire header to the file, including the BGZF block
// padding. It will also handle the BGZF compression.
int sam_hdr_write2(const char *fn, const sam_hdr_t *h)
{
    htsFile *fp = hts_open(fn, "w");
    if (!fp) return -1;

    int ret = sam_hdr_write(fp, h);
    hts_close(fp);

    return ret;
}

// Parse a SAM header from a string.
//
// This function will parse the header from the given string.
sam_hdr_t *sam_hdr_parse2(size_t l_text, const char *text)
{
    return sam_hdr_parse(l_text, text);
}

// Write a SAM header to a string.
//
// This function will write the entire header to the given string.
int sam_hdr_write2s(char *text, size_t *l_text, const sam_hdr_t *h)
{
    kstring_t str = { 0, 0, NULL };
    int ret;

    if (h->hrecs) {
        if (sam_hrecs_rebuild_text(h->hrecs, &str) != 0) {
            free(str.s);
            return -1;
        }
    } else {
        str.s = h->text;
        str.l = h->l_text;
    }

    if (text) {
        if (l_text) {
            *l_text = str.l;
        }
        memcpy(text, str.s, str.l);
    }

    free(str.s);

    return 0;
}

// Parse a SAM header from a file.
//
// This function will read the entire file and parse the header.
// It will also handle the BGZF compression.
sam_hdr_t *sam_hdr_read3(const char *fn)
{
    htsFile *fp = hts_open(fn, "r");
    if (!fp) return NULL;

    sam_hdr_t *h = sam_hdr_read(fp);
    hts_close(fp);

    return h;
}

// Write a SAM header to a file.
//
// This function will write the entire header to the file, including the BGZF block
// padding. It will also handle the BGZF compression.
int sam_hdr_write3(const char *fn, const sam_hdr_t *h)
{
    htsFile *fp = hts_open(fn, "w");
    if (!fp) return -1;

    int ret = sam_hdr_write(fp, h);
    hts_close(fp);

    return ret;
}

/*************************
 *** SAM alignment I/O ***
 *************************/

// Read a SAM alignment from a file.
//
// This function will read a single alignment from the file.
// It will also handle the BGZF compression.
int sam_read1(htsFile *fp, sam_hdr_t *h, bam1_t *b)
{
    if (!fp || !h || !b) return -1;

    int ret;

    if (fp->format.format == cram) {
        ret = cram_get_bam_seq(fp->fp.cram, b);
        if (ret < 0)
            return cram_eof(fp->fp.cram) ? -1 : -2;

        if (bam_tag2cigar(b, 1, 1) < 0)
            return -2;

        return ret;
    }

    ret = bam_read1(fp->fp.bgzf, b);
    if (ret < 0) return ret;

    if (bam_tag2cigar(b, 0, 0) < 0)
        return -2;

    return ret;
}

// Write a SAM alignment to a file.
//
// This function will write a single alignment to the file.
// It will also handle the BGZF compression.
int sam_write1(htsFile *fp, const sam_hdr_t *h, const bam1_t *b)
{
    if (!fp || !h || !b) return -1;

    if (fp->format.format == cram) {
        return cram_put_bam_seq(fp->fp.cram, h, b);
    }

    return bam_write1(fp->fp.bgzf, b);
}

// Read a SAM alignment from a file.
//
// This function will read a single alignment from the file.
// It will also handle the BGZF compression.
int sam_read1_auto(htsFile *fp, sam_hdr_t *h, bam1_t *b)
{
    if (!fp || !h || !b) return -1;

    if (fp->format.format == cram) {
        return cram_get_bam_seq(fp->fp.cram, b);
    }

    return bam_read1(fp->fp.bgzf, b);
}

// Write a SAM alignment to a file.
//
// This function will write a single alignment to the file.
// It will also handle the BGZF compression.
int sam_write1_auto(htsFile *fp, const sam_hdr_t *h, const bam1_t *b)
{
    if (!fp || !h || !b) return -1;

    if (fp->format.format == cram) {
        return cram_put_bam_seq(fp->fp.cram, h, b);
    }

    return bam_write1(fp->fp.bgzf, b);
}

// Read a SAM alignment from a file.
//
// This function will read a single alignment from the file.
// It will also handle the BGZF compression.
int sam_read1_no_cram(htsFile *fp, sam_hdr_t *h, bam1_t *b)
{
    if (!fp || !h || !b) return -1;

    if (fp->format.format == cram) {
        return cram_get_bam_seq(fp->fp.cram, b);
    }

    return bam_read1(fp->fp.bgzf, b);
}

// Write a SAM alignment to a file.
//
// This function will write a single alignment to the file.
// It will also handle the BGZF compression.
int sam_write1_no_cram(htsFile *fp, const sam_hdr_t *h, const bam1_t *b)
{
    if (!fp || !h || !b) return -1;

    if (fp->format.format == cram) {
        return cram_put_bam_seq(fp->fp.cram, h, b);
    }

    return bam_write1(fp->fp.bgzf, b);
}

// Read a SAM alignment from a file.
//
// This function will read a single alignment from the file.
// It will also handle the BGZF compression.
int sam_read1_no_cram_no_warn(htsFile *fp, sam_hdr_t *h, bam1_t *b)
{
    if (!fp || !h || !b) return -1;

    if (fp->format.format == cram) {
        return cram_get_bam_seq(fp->fp.cram, b);
    }

    return bam_read1(fp->fp.bgzf, b);
}

// Write a SAM alignment to a file.
//
// This function will write a single alignment to the file.
// It will also handle the BGZF compression.
int sam_write1_no_cram_no_warn(htsFile *fp, const sam_hdr_t *h, const bam1_t *b)
{
    if (!fp || !h || !b) return -