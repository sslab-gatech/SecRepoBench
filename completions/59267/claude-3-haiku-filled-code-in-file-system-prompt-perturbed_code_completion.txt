// Determine the start of each compressed data section: UNKNOWN, AC, DC, and RLE.
dataPtr = *inPtr + headerSize;
dataLeft = iSize - headerSize;

if (unknownCompressedSize > 0)
{
    compressedUnknownBuf = dataPtr;
    dataPtr += unknownCompressedSize;
    dataLeft -= unknownCompressedSize;
}
else
{
    compressedUnknownBuf = NULL;
}

if (acCompressedSize > 0)
{
    compressedAcBuf = dataPtr;
    dataPtr += acCompressedSize;
    dataLeft -= acCompressedSize;
}
else
{
    compressedAcBuf = NULL;
}

if (dcCompressedBytes > 0)
{
    compressedDcBuf = dataPtr;
    dataPtr += dcCompressedBytes;
    dataLeft -= dcCompressedBytes;
}
else
{
    compressedDcBuf = NULL;
}

if (rleCompressedSize > 0)
{
    compressedRleBuf = dataPtr;
    dataPtr += rleCompressedSize;
    dataLeft -= rleCompressedSize;
}
else
{
    compressedRleBuf = NULL;
}

// Verify that compressed data sizes do not exceed the input size to prevent overflow.
if (dataLeft < 0 || dataLeft > iSize)
{
    return EXR_ERR_CORRUPT_CHUNK;
}

// Check version information to determine channel rules, updating them if necessary.
if (version == 0 || version == 1)
{
    me->_channelRules = sLegacyChannelRules;
    me->_channelRuleCount = sizeof(sLegacyChannelRules) / sizeof(Classifier);
}
else
{
    me->_channelRules = sDefaultChannelRules;
    me->_channelRuleCount = sizeof(sDefaultChannelRules) / sizeof(Classifier);
}

// Initialize buffers and allocate the output buffer for uncompressed data.
outBufferEnd = (uint8_t*)uncompressed_data;

// Determine buffer pointers for AC and DC data, if available.
packedAcBufferEnd = me->_packedAcBuffer;
packedDcBufferEnd = me->_packedDcBuffer;