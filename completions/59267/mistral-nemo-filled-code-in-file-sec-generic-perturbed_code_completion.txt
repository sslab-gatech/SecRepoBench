// <MASK>
if (unknownCompressedSize > 0)
{
    size_t outSize;

    rv = exr_compress_buffer (
        me->_encode->context,
        9, // TODO: use default??? the old call to zlib had 9 hardcoded
        me->_planarUncBuffer[UNKNOWN],
        unknownUncompressedSize,
        outPtr,
        exr_compress_max_buffer_size (unknownUncompressedSize),
        &outSize);
    if (rv != EXR_ERR_SUCCESS) return rv;

    outPtr += outSize;
    *unknownCompressedSize = outSize;
    nWritten += outSize;
}

if (acCompressedSize > 0)
{
    switch (acCompression)
    {
        case STATIC_HUFFMAN:
            rv = internal_huf_compress (
                acCompressedSize,
                outPtr,
                outBufferSize - (uintptr_t) outPtr,
                (const uint16_t*) me->_packedAcBuffer,
                totalAcUncompressedCount,
                me->_encode->scratch_buffer_1,
                me->_encode->scratch_alloc_size_1);
            if (rv != EXR_ERR_SUCCESS)
            {
                if (rv == EXR_ERR_ARGUMENT_OUT_OF_RANGE)
                {
                    memcpy (
                        me->_encode->compressed_buffer,
                        me->_encode->packed_buffer,
                        me->_encode->packed_alloc_size);
                    me->_encode->compressed_bytes =
                        me->_encode->packed_alloc_size;
                    return EXR_ERR_SUCCESS;
                }
                return rv;
            }
            break;

        case DEFLATE: {
            size_t destLen;

            rv = exr_compress_buffer (
                me->_encode->context,
                9, // TODO: use default??? the old call to zlib had 9 hardcoded
                me->_packedAcBuffer,
                totalAcUncompressedCount * sizeof (uint16_t),
                outPtr,
                exr_compress_max_buffer_size (totalAcUncompressedCount * sizeof (uint16_t)),
                &destLen);
            if (rv != EXR_ERR_SUCCESS) return rv;

            *acCompressedSize = destLen;
            break;
        }

        default: return EXR_ERR_INVALID_ARGUMENT; break;
    }

    outPtr += *acCompressedSize;
    nWritten += *acCompressedSize;
}

if (dcCompressedBytes > 0)
{
    size_t compBytes;
    size_t uncompBytes = totalDcUncompressedCount * sizeof (uint16_t);
    if (uncompBytes > me->_packedDcBufferSize)
    {
        return EXR_ERR_CORRUPT_CHUNK;
    }

    rv = internal_decode_alloc_buffer (
        me->_encode,
        EXR_TRANSCODE_BUFFER_SCRATCH1,
        &(me->_encode->scratch_buffer_1),
        &(me->_encode->scratch_alloc_size_1),
        uncompBytes);

    if (rv != EXR_ERR_SUCCESS) return rv;

    rv = exr_compress_buffer (
        me->_encode->context,
        me->_zipLevel,
        me->_encode->scratch_buffer_1,
        uncompBytes,
        outPtr,
        exr_compress_max_buffer_size (uncompBytes),
        &compBytes);

    if (rv != EXR_ERR_SUCCESS || (uncompBytes != compBytes))
    {
        return EXR_ERR_CORRUPT_CHUNK;
    }

    *dcCompressedSize = compBytes;
    outPtr += compBytes;
    nWritten += compBytes;
}
else
{
    // if the compressed size is 0, then the uncompressed size must also be zero
    if (totalDcUncompressedCount != 0) { return EXR_ERR_CORRUPT_CHUNK; }
}

if (rleRawSize > 0)
{
    size_t compBytes;
    *rleUncompressedSize = internal_rle_compress (
        me->_rleBuffer,
        me->_rleBufferSize,
        me->_planarUncBuffer[RLE],
        *rleRawSize);

    rv = exr_compress_buffer (
        me->_encode->context,
        9, // TODO: use default??? the old call to zlib had 9 hardcoded
        me->_rleBuffer,
        *rleUncompressedSize,
        outPtr,
        exr_compress_max_buffer_size (*rleUncompressedSize),
        &compBytes);

    if (rv != EXR_ERR_SUCCESS) return rv;

    *rleCompressedSize = compBytes;
    outPtr += compBytes;
    nWritten += compBytes;
}