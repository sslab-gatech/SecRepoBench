// <MASK>

// Define pointers for compressed data sections: UNKNOWN, AC, DC, and RLE.
// Verify that the input size is adequate for the expected header size.
// Initialize the uncompressed data buffer to zero.
// Copy header information into an array and convert it from XDR format to native format.
// Extract various sizes and counters related to compression from the header information.
// Calculate the total size of compressed data sections.
// Adjust the data pointer to skip the header and calculate the remaining data size.
// Verify that compressed data sizes do not exceed the input size to prevent overflow.
// Check version information to determine channel rules, updating them if necessary.
// Initialize buffers and allocate the output buffer for uncompressed data.
// Determine buffer pointers for AC and DC data, if available.
// Set pointers to the start of each compressed data section: UNKNOWN, AC, DC, and RLE.
uint64_t compressedUnknownBuf = 0;
uint64_t compressedAcBuf = 0;
uint64_t compressedDcBuf = 0;
uint64_t compressedRleBuf = 0;

if (iSize < headerSize)
{
    return EXR_ERR_CORRUPT_CHUNK;
}

// Allocate the output buffer for uncompressed data.
outBufferSize = maxOutBufferSize;
if (outBufferSize > uncompressed_size)
{
    return EXR_ERR_CORRUPT_CHUNK;
}

// Allocate the output buffer.
outBuffer = me->alloc_fn (outBufferSize);
if (!outBuffer) return EXR_ERR_OUT_OF_MEMORY;

// Initialize the output buffer to zero.
memset (outBuffer, 0, outBufferSize);

// Copy header information into an array and convert it from XDR format to native format.
// Extract various sizes and counters related to compression from the header information.
// Calculate the total size of compressed data sections.
// Adjust the data pointer to skip the header and calculate the remaining data size.
// Verify that compressed data sizes do not exceed the input size to prevent overflow.
// Check version information to determine channel rules, updating them if necessary.
// Initialize buffers and allocate the output buffer for uncompressed data.
// Determine buffer pointers for AC and DC data, if available.
// Set pointers to the start of each compressed data section: UNKNOWN, AC, DC, and RLE.
dataPtr = inPtr + headerSize;
dataLeft = iSize - headerSize;

// Determine the start of each compressed data section: UNKNOWN, AC, DC, and RLE.
// Verify that compressed data sizes do not exceed the input size to prevent overflow.
if (unknownCompressedSize > 0)
{
    if (unknownCompressedSize > dataLeft)
    {
        return EXR_ERR_CORRUPT_CHUNK;
    }

    compressedUnknownBuf = dataPtr;
    dataPtr += unknownCompressedSize;
    dataLeft -= unknownCompressedSize;
}

if (acCompressedSize > 0)
{
    if (acCompressedSize > dataLeft)
    {
        return EXR_ERR_CORRUPT_CHUNK;
    }

    compressedAcBuf = dataPtr;
    dataPtr += acCompressedSize;
    dataLeft -= acCompressedSize;
}

if (dcCompressedBytes > 0)
{
    if (dcCompressedBytes > dataLeft)
    {
        return EXR_ERR_CORRUPT_CHUNK;
    }

    compressedDcBuf = dataPtr;
    dataPtr += dcCompressedBytes;
    dataLeft -= dcCompressedBytes;
}

if (rleCompressedSize > 0)
{
    if (rleCompressedSize > dataLeft)
    {
        return EXR_ERR_CORRUPT_CHUNK;
    }

    compressedRleBuf = dataPtr;
    dataPtr += rleCompressedSize;
    dataLeft -= rleCompressedSize;
}

// Initialize buffers and allocate the output buffer for uncompressed data.
// Determine buffer pointers for AC and DC data, if available.
// Set pointers to the start of each compressed data section: UNKNOWN, AC, DC, and RLE.
outBufferEnd = outBuffer;
packedAcBufferEnd = me->_packedAcBuffer;
packedDcBufferEnd = me->_packedDcBuffer;

// Determine buffer pointers for AC and DC data, if available.
if (me->_packedAcBuffer)
{
    packedAcBufferEnd = me->_packedAcBuffer;
}

if (me->_packedDcBuffer)
{
    packedDcBufferEnd = me->_packedDcBuffer;
}

// Set pointers to the start of each compressed data section: UNKNOWN, AC, DC, and RLE.
// Initialize buffers and allocate the output buffer for uncompressed data.
// Determine buffer pointers for AC and DC data, if available.
// Set pointers to the start of each compressed data section: UNKNOWN, AC, DC, and RLE.
// Initialize buffers and allocate the output buffer for uncompressed data.
// Determine buffer pointers for AC and DC data, if available.
// Set pointers to the start of each compressed data section: UNKNOWN, AC, DC, and RLE.
// Initialize buffers and allocate the output buffer for uncompressed data.
// Determine buffer pointers for AC and DC data, if available.
// Set pointers to the start of each compressed data section: UNKNOWN, AC, DC, and RLE.