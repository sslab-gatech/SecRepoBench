// Define pointers for compressed data sections: UNKNOWN, AC, DC, and RLE.
const uint8_t* compressedUnknownBuf = inPtr + headerSize;
const uint8_t* compressedAcBuf = inPtr + headerSize;
const uint8_t* compressedDcBuf = inPtr + headerSize;
const uint8_t* compressedRleBuf = inPtr + headerSize;

// Verify that the input size is adequate for the expected header size.
if (iSize < headerSize) {
    return EXR_ERR_BAD_CHUNK_LEADER;
}

// Initialize the uncompressed data buffer to zero.
memset(uncompressed_data, 0, uncompressed_size);

// Copy header information into an array and convert it from XDR format to native format.
// Extract various sizes and counters related to compression from the header information.
// Calculate the total size of compressed data sections.
// Adjust the data pointer to skip the header and calculate the remaining data size.
// Verify that compressed data sizes do not exceed the input size to prevent overflow.
// Check version information to determine channel rules, updating them if necessary.
// Initialize buffers and allocate the output buffer for uncompressed data.
// Determine buffer pointers for AC and DC data, if available.
// Set pointers to the start of each compressed data section: UNKNOWN, AC, DC, and RLE.

// Initialize version, counters, and other variables from the header.
memcpy(&version, inPtr, sizeof(version));
memcpy(counters, inPtr + sizeof(version), NUM_SIZES_SINGLE * sizeof(uint64_t));

// Calculate the total size of compressed data sections.
uint64_t totalCompressedSize = 0;
for (int i = 0; i < NUM_SIZES_SINGLE; ++i) {
    totalCompressedSize += counters[i];
}

// Adjust the data pointer to skip the header and calculate the remaining data size.
const uint8_t* dataPtr = inPtr + headerSize;
uint64_t dataLeft = iSize - headerSize;

// Verify that compressed data sizes do not exceed the input size to prevent overflow.
if (totalCompressedSize > dataLeft) {
    return EXR_ERR_BAD_CHUNK_LEADER;
}

// Check version information to determine channel rules, updating them if necessary.
if (version > 2) {
    return EXR_ERR_BAD_CHUNK_LEADER;
}

// Initialize buffers and allocate the output buffer for uncompressed data.
uint8_t* outBuffer = (uint8_t*)uncompressed_data;
size_t outBufferSize = uncompressed_size;

// Determine buffer pointers for AC and DC data, if available.
uint8_t* packedAcBuffer = me->_packedAcBuffer;
uint8_t* packedDcBuffer = me->_packedDcBuffer;
size_t packedAcBufferSize = me->_packedAcBufferSize;
size_t packedDcBufferSize = me->_packedDcBufferSize;

// Set pointers to the start of each compressed data section: UNKNOWN, AC, DC, and RLE.
const uint8_t* compressedUnknownBuf = inPtr + headerSize;
const uint8_t* compressedAcBuf = inPtr + headerSize;
const uint8_t* compressedDcBuf = inPtr + headerSize;
const uint8_t* compressedRleBuf = inPtr + headerSize;