// <MASK>
//
// Uncompress the AC data into _packedAcBuffer
//
if (acCompressedSize > 0)
{
    if (!me->_packedAcBuffer ||
        totalAcUncompressedCount * sizeof (uint16_t) >
            me->_packedAcBufferSize)
    {
        return EXR_ERR_CORRUPT_CHUNK;
    }

    //
    // Don't trust the user to get it right, look in the file.
    //

    switch (acCompression)
    {
        case STATIC_HUFFMAN:
            rv = internal_huf_decompress (
                me->_decode,
                compressedAcBuf,
                acCompressedSize,
                (uint16_t*) me->_packedAcBuffer,
                totalAcUncompressedCount,
                me->_decode->scratch_buffer_1,
                me->_decode->scratch_alloc_size_1);
            if (rv != EXR_ERR_SUCCESS) { return rv; }
            break;

        case DEFLATE: {
            size_t destLen;

            rv = exr_uncompress_buffer (
                me->_decode->context,
                compressedAcBuf,
                acCompressedSize,
                me->_packedAcBuffer,
                totalAcUncompressedCount * sizeof (uint16_t),
                &destLen);
            if (rv != EXR_ERR_SUCCESS) return rv;

            if (totalAcUncompressedCount * sizeof (uint16_t) != destLen)
            {
                return EXR_ERR_CORRUPT_CHUNK;
            }
        }
        break;

        default: return EXR_ERR_CORRUPT_CHUNK; break;
    }
}