// <MASK>

//
// Determine buffer pointers for AC and DC data, if available.
//

if (acCompressedSize > 0)
{
    packedAcBufferEnd = me->_packedAcBuffer;
    packedDcBufferEnd = me->_packedDcBuffer;
}

if (dcCompressedBytes > 0)
{
    packedDcBufferEnd = me->_packedDcBuffer;
}

//
// Set pointers to the start of each compressed data section: UNKNOWN, AC, DC, and RLE.
//

compressedUnknownBuf = inPtr + headerSize;
compressedAcBuf     = compressedUnknownBuf + unknownCompressedSize;
compressedDcBuf     = compressedAcBuf + acCompressedSize;
compressedRleBuf    = compressedDcBuf + dcCompressedBytes;

dataPtr = inPtr + headerSize;
dataLeft = iSize - headerSize;

//
// Verify that compressed data sizes do not exceed the input size to prevent overflow.
//

if (unknownCompressedSize > dataLeft ||
    acCompressedSize > dataLeft ||
    dcCompressedBytes > dataLeft ||
    rleCompressedSize > dataLeft)
{
    return EXR_ERR_CORRUPT_CHUNK;
}

//
// Check version information to determine channel rules, updating them if necessary.
//

if (version > 2) { return EXR_ERR_BAD_CHUNK_LEADER; }

rv = DwaCompressor_setupChannelData (me);

//
// Initialize buffers and allocate the output buffer for uncompressed data.
//

outBufferSize = 0;
rv = DwaCompressor_initializeBuffers (me, &outBufferSize);
if (rv!= EXR_ERR_SUCCESS) return rv;

outBuffer = me->alloc_fn (outBufferSize);
if (!outBuffer) return EXR_ERR_OUT_OF_MEMORY;
memset (outBuffer, 0, outBufferSize);

//
// Determine buffer pointers for AC and DC data, if available.
//

if (acCompressedSize > 0)
{
    packedAcBufferEnd = me->_packedAcBuffer;
    packedDcBufferEnd = me->_packedDcBuffer;
}

if (dcCompressedBytes > 0)
{
    packedDcBufferEnd = me->_packedDcBuffer;
}

//
// Set pointers to the start of each compressed data section: UNKNOWN, AC, DC, and RLE.
//

compressedUnknownBuf = inPtr + headerSize;
compressedAcBuf     = compressedUnknownBuf + unknownCompressedSize;
compressedDcBuf     = compressedAcBuf + acCompressedSize;
compressedRleBuf    = compressedDcBuf + dcCompressedBytes;

dataPtr = inPtr + headerSize;
dataLeft = iSize - headerSize;

//
// Verify that compressed data sizes do not exceed the input size to prevent overflow.
//

if (unknownCompressedSize > dataLeft ||
    acCompressedSize > dataLeft ||
    dcCompressedBytes > dataLeft ||
    rleCompressedSize > dataLeft)
{
    return EXR_ERR_CORRUPT_CHUNK;
}

//
// Check version information to determine channel rules, updating them if necessary.
//

if (version > 2) { return EXR_ERR_BAD_CHUNK_LEADER; }

rv = DwaCompressor_setupChannelData (me);

//
// Initialize buffers and allocate the output buffer for uncompressed data.
//

outBufferSize = 0;
rv = DwaCompressor_initializeBuffers (me, &outBufferSize);
if (rv!= EXR_ERR_SUCCESS) return rv;

outBuffer = me->alloc_fn (outBufferSize);
if (!outBuffer) return EXR_ERR_OUT_OF_MEMORY;
memset (outBuffer, 0, outBufferSize);

//
// Copy header information into an array and convert it from XDR format to native format.
//

header = (uint64_t*) outBuffer;
memcpy (header, inPtr, headerSize);

//
// Extract various sizes and counters related to compression from the header information.
//

unknownUncompressedSize = header[0];
unknownCompressedSize   = header[1];
acCompressedSize       = header[2];
dcCompressedBytes      = header[3];
rleCompressedSize      = header[4];
rleUncompressedSize    = header[5];
totalAcUncompressedCount = header[6];
totalDcUncompressedCount = header[7];
acCompression          = header[8];

//
// Calculate the total size of compressed data sections.
//

compressedSize = unknownCompressedSize + acCompressedSize + dcCompressedBytes + rleCompressedSize;

//
// Adjust the data pointer to skip the header and calculate the remaining data size.
//

dataPtr = inPtr + headerSize;
dataLeft = iSize - headerSize;

//
// Verify that compressed data sizes do not exceed the input size to prevent overflow.
//

if (unknownCompressedSize > dataLeft ||
    acCompressedSize > dataLeft ||
    dcCompressedBytes > dataLeft ||
    rleCompressedSize > dataLeft)
{
    return EXR_ERR_CORRUPT_CHUNK;
}

//
// Check version information to determine channel rules, updating them if necessary.
//

if (version > 2) { return EXR_ERR_BAD_CHUNK_LEADER; }

rv = DwaCompressor_setupChannelData (me);

//
// Initialize buffers and allocate the output buffer for uncompressed data.
//

outBufferSize = 0;
rv = DwaCompressor_initializeBuffers (me, &outBufferSize);
if (rv!= EXR_ERR_SUCCESS) return rv;

outBuffer = me->alloc_fn (outBufferSize);
if (!outBuffer) return EXR_ERR_OUT_OF_MEMORY;
memset (outBuffer, 0, outBufferSize);

//
// Copy header information into an array and convert it from XDR format to native format.
//

header = (uint64_t*) outBuffer;
memcpy (header, inPtr, headerSize);

//
// Extract various sizes and counters related to compression from the header information.
//

unknownUncompressedSize = header[0];
unknownCompressedSize   = header[1];
acCompressedSize       = header[2];
dcCompressedBytes      = header[3];
rleCompressedSize      = header[4];
rleUncompressedSize    = header[5];
totalAcUncompressedCount = header[6];
totalDcUncompressedCount = header[7];
acCompression          = header[8];

//
// Calculate the total size of compressed data sections.
//

compressedSize = unknownCompressedSize + acCompressedSize + dcCompressedBytes + rleCompressedSize;

//
// Adjust the data pointer to skip the header and calculate the remaining data size.
//

dataPtr = inPtr + headerSize;
dataLeft = iSize - headerSize;

//
// Verify that compressed data sizes do not exceed the input size to prevent overflow.
//

if (unknownCompressedSize > dataLeft ||
    acCompressedSize > dataLeft ||
    dcCompressedBytes > dataLeft ||
    rleCompressedSize > dataLeft)
{
    return EXR_ERR_CORRUPT_CHUNK;
}

//
// Check version information to determine channel rules, updating them if necessary.
//

if (version > 2) { return EXR_ERR_BAD_CHUNK_LEADER; }

rv = DwaCompressor_setupChannelData (me);

//
// Initialize buffers and allocate the output buffer for uncompressed data.
//

outBufferSize = 0;
rv = DwaCompressor_initializeBuffers (me, &outBufferSize);
if (rv!= EXR_ERR_SUCCESS) return rv;

outBuffer = me->alloc_fn (outBufferSize);
if (!outBuffer) return EXR_ERR_OUT_OF_MEMORY;
memset (outBuffer, 0, outBufferSize);

//
// Copy header information into an array and convert it from XDR format to native format.
//

header = (uint64_t*) outBuffer;
memcpy (header, inPtr, headerSize);

//
// Extract various sizes and counters related to compression from the header information.
//

unknownUncompressedSize = header[0];
unknownCompressedSize   = header[1];
acCompressedSize       = header[2];
dcCompressedBytes      = header[3];
rleCompressedSize      = header[4];
rleUncompressedSize    = header[5];
totalAcUncompressedCount = header[6];
totalDcUncompressedCount = header[7];
acCompression          = header[8];

//
// Calculate the total size of compressed data sections.
//

compressedSize = unknownCompressedSize + acCompressedSize + dcCompressedBytes + rleCompressedSize;

//
// Adjust the data pointer to skip the header and calculate the remaining data size.
//

dataPtr = inPtr + headerSize;
dataLeft = iSize - headerSize;

//
// Verify that compressed data sizes do not exceed the input size to prevent overflow.
//

if (unknownCompressedSize > dataLeft ||
    acCompressedSize > dataLeft ||
    dcCompressedBytes > dataLeft ||
    rleCompressedSize > dataLeft)
{
    return EXR_ERR_CORRUPT_CHUNK;
}

//
// Check version information to determine channel rules, updating them if necessary.
//

if (version > 2) { return EXR_ERR_BAD_CHUNK_LEADER; }

rv = DwaCompressor_setupChannelData (me);

//
// Initialize buffers and allocate the output buffer for uncompressed data.
//

outBufferSize = 0;
rv = DwaCompressor_initializeBuffers (me, &outBufferSize);
if (rv!= EXR_ERR_SUCCESS) return rv;

outBuffer = me->alloc_fn (outBufferSize);
if (!outBuffer) return EXR_ERR_OUT_OF_MEMORY;
memset (outBuffer, 0, outBufferSize);

//
// Copy header information into an array and convert it from XDR format to native format.
//

header = (uint64_t*) outBuffer;
memcpy (header, inPtr, headerSize);

//
// Extract various sizes and counters related to compression from the header information.
//

unknownUncompressedSize = header[0];
unknownCompressedSize   = header[1];
acCompressedSize       = header[2];
dcCompressedBytes      = header[3];
rleCompressedSize      = header[4];
rleUncompressedSize    = header[5];
totalAcUncompressedCount = header[6];
totalDcUncompressedCount = header[7];
acCompression          = header[8];

//
// Calculate the total size of compressed data sections.
//

compressedSize = unknownCompressedSize + acCompressedSize + dcCompressedBytes + rleCompressedSize;

//
// Adjust the data pointer to skip the header and calculate the remaining data size.
//

dataPtr = inPtr + headerSize;
dataLeft = iSize - headerSize;

//
// Verify that compressed data sizes do not exceed the input size to prevent overflow.
//

if (unknownCompressedSize > dataLeft ||
    acCompressedSize > dataLeft ||
    dcCompressedBytes > dataLeft ||
    rleCompressedSize > dataLeft)
{
    return EXR_ERR_CORRUPT_CHUNK;
}

//
// Check version information to determine channel rules, updating them if necessary.
//

if (version > 2) { return EXR_ERR_BAD_CHUNK_LEADER; }

rv = DwaCompressor_setupChannelData (me);

//
// Initialize buffers and allocate the output buffer for uncompressed data.
//

outBufferSize = 0;
rv = DwaCompressor_initializeBuffers (me, &outBufferSize);
if (rv!= EXR_ERR_SUCCESS) return rv;

outBuffer = me->alloc_fn (outBufferSize);
if (!outBuffer) return EXR_ERR_OUT_OF_MEMORY;
memset (outBuffer, 0, outBufferSize);

//
// Copy header information into an array and convert it from XDR format to native format.
//

header = (uint64_t*) outBuffer;
memcpy (header, inPtr, headerSize);

//
// Extract various sizes and counters related to compression from the header information.
//

unknownUncompressedSize = header[0];
unknownCompressedSize   = header[1];
acCompressedSize       = header[2];
dcCompressedBytes      = header[3];
rleCompressedSize      = header[4];
rleUncompressedSize    = header[5];
totalAcUncompressedCount = header[6];
totalDcUncompressedCount = header[7];
acCompression          = header[8];

//
// Calculate the total size of compressed data sections.
//

compressedSize = unknownCompressedSize + acCompressedSize + dcCompressedBytes + rleCompressedSize;

//
// Adjust the data pointer to skip the header and calculate the remaining data size.
//

dataPtr = inPtr + headerSize;
dataLeft = iSize - headerSize;

//
// Verify that compressed data sizes do not exceed the input size to prevent overflow.
//

if (unknownCompressedSize > dataLeft ||
    acCompressedSize > dataLeft ||
    dcCompressedBytes > dataLeft ||
    rleCompressedSize > dataLeft)
{
    return EXR_ERR_CORRUPT_CHUNK;
}

//
// Check version information to determine channel rules, updating them if necessary.
//

if (version > 2) { return EXR_ERR_BAD_CHUNK_LEADER; }

rv = DwaCompressor_setupChannelData (me);

//
// Initialize buffers and allocate the output buffer for uncompressed data.
//

outBufferSize = 0;
rv = DwaCompressor_initializeBuffers (me, &outBufferSize);
if (rv!= EXR_ERR_SUCCESS) return rv;

outBuffer = me->alloc_fn (outBufferSize);
if (!outBuffer) return EXR_ERR_OUT_OF_MEMORY;
memset (outBuffer, 0, outBufferSize);

//
// Copy header information into an array and convert it from XDR format to native format.
//

header = (uint64_t*) outBuffer;
memcpy (header, inPtr, headerSize);

//
// Extract various sizes and counters related to compression from the header information.
//

unknownUncompressedSize = header[0];
unknownCompressedSize   = header[1];
acCompressedSize       = header[2];
dcCompressedBytes      = header[3];
rleCompressedSize      = header[4];
rleUncompressedSize    = header[5];
totalAcUncompressedCount = header[6];
totalDcUncompressedCount = header[7];
acCompression          = header[8];

//
// Calculate the total size of compressed data sections.
//

compressedSize = unknownCompressedSize + acCompressedSize + dcCompressedBytes + rleCompressedSize;

//
// Adjust the data pointer to skip the header and calculate the remaining data size.
//

dataPtr = inPtr + headerSize;
dataLeft = iSize - headerSize;

//
// Verify that compressed data sizes do not exceed the input size to prevent overflow.
//

if (unknownCompressedSize > dataLeft ||
    acCompressedSiz