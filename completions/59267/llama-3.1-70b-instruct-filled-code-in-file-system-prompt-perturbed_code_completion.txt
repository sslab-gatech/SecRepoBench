// Define pointers for compressed data sections: UNKNOWN, AC, DC, and RLE.
const uint8_t* compressedUnknownBuf = dataPtr + *unknownCompressedSize;
const uint8_t* compressedAcBuf =
    compressedUnknownBuf + *unknownCompressedSize;
const uint8_t* compressedDcBuf =
    compressedAcBuf + *acCompressedSize;
const uint8_t* compressedRleBuf =
    compressedDcBuf + *dcCompressedBytes;

// Verify that the input size is adequate for the expected header size.
if (iSize < headerSize) return EXR_ERR_CORRUPT_CHUNK;

// Initialize the uncompressed data buffer to zero.
memset(uncompressed_data, 0, uncompressed_size);

// Copy header information into an array and convert it from XDR format to native format.
memcpy(counters, inPtr, headerSize);
priv_to_native64(counters, NUM_SIZES_SINGLE);

// Extract various sizes and counters related to compression from the header information.
version                 = counters[VERSION];
unknownUncompressedSize = counters[UNKNOWN_UNCOMPRESSED_SIZE];
unknownCompressedSize   = counters[UNKNOWN_COMPRESSED_SIZE];
acCompressedSize        = counters[AC_COMPRESSED_SIZE];
dcCompressedBytes       = counters[DC_COMPRESSED_SIZE];
rleCompressedSize       = counters[RLE_COMPRESSED_SIZE];
rleUncompressedSize     = counters[RLE_UNCOMPRESSED_SIZE];
rleRawSize              = counters[RLE_RAW_SIZE];

totalAcUncompressedCount = counters[AC_UNCOMPRESSED_COUNT];
totalDcUncompressedCount = counters[DC_UNCOMPRESSED_COUNT];

acCompression = counters[AC_COMPRESSION];

// Calculate the total size of compressed data sections.
uint64_t totalCompressedSize =
    unknownCompressedSize + acCompressedSize + dcCompressedBytes + rleCompressedSize;

// Adjust the data pointer to skip the header and calculate the remaining data size.
dataPtr += headerSize;
dataLeft = iSize - headerSize;

// Verify that compressed data sizes do not exceed the input size to prevent overflow.
if (totalCompressedSize > dataLeft) return EXR_ERR_CORRUPT_CHUNK;

// Check version information to determine channel rules, updating them if necessary.
if (version < 2)
{
    me->_channelRules = sLegacyChannelRules;
    me->_channelRuleCount =
        sizeof(sLegacyChannelRules) / sizeof(Classifier);
}
else
{
    me->_channelRules = sDefaultChannelRules;
    me->_channelRuleCount =
        sizeof(sDefaultChannelRules) / sizeof(Classifier);
}

// Initialize buffers and allocate the output buffer for uncompressed data.
uint8_t* outBufferEnd = (uint8_t*)uncompressed_data;

// Determine buffer pointers for AC and DC data, if available.
uint8_t* packedAcBufferEnd = NULL;
uint8_t* packedDcBufferEnd = NULL;

if (me->_packedAcBuffer) packedAcBufferEnd = me->_packedAcBuffer;
if (me->_packedDcBuffer) packedDcBufferEnd = me->_packedDcBuffer;

// Set pointers to the start of each compressed data section: UNKNOWN, AC, DC, and RLE.