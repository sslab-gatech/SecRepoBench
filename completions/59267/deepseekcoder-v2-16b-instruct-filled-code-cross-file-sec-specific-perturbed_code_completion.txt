// Define pointers for compressed data sections: UNKNOWN, AC, DC, and RLE.
    const uint8_t* compressedUnknownBuf = inPtr + headerSize;
    const uint8_t* compressedAcBuf = inPtr + headerSize;
    const uint8_t* compressedDcBuf = inPtr + headerSize;
    const uint8_t* compressedRleBuf = inPtr + headerSize;

    // Initialize the uncompressed data buffer to zero.
    memset(uncompressed_data, 0, uncompressed_size);

    // Copy header information into an array and convert it from XDR format to native format.
    // Extract various sizes and counters related to compression from the header information.
    // Calculate the total size of compressed data sections.
    // Adjust the data pointer to skip the header and calculate the remaining data size.
    // Verify that compressed data sizes do not exceed the input size to prevent overflow.
    // Check version information to determine channel rules, updating them if necessary.
    // Initialize buffers and allocate the output buffer for uncompressed data.
    // Determine buffer pointers for AC and DC data, if available.
    // Set pointers to the start of each compressed data section: UNKNOWN, AC, DC, and RLE.
    // Initialize buffers and allocate the output buffer for uncompressed data.
    uint8_t* outBuffer = (uint8_t*)uncompressed_data;
    size_t outBufferSize = uncompressed_size;

    // Initialize buffers and allocate the output buffer for uncompressed data.
    uint8_t* acBuffer = NULL;
    uint8_t* dcBuffer = NULL;
    size_t acBufferSize = 0;
    size_t dcBufferSize = 0;

    // Set pointers to the start of each compressed data section: UNKNOWN, AC, DC, and RLE.
    const uint8_t* unknownDataPtr = inPtr + headerSize;
    const uint8_t* acDataPtr = inPtr + headerSize;
    const uint8_t* dcDataPtr = inPtr + headerSize;
    const uint8_t* rleDataPtr = inPtr + headerSize;

    // Calculate the total size of compressed data sections.
    uint64_t totalCompressedSize = 0;

    // Adjust the data pointer to skip the header and calculate the remaining data size.
    uint64_t remainingDataSize = iSize - headerSize;

    // Verify that compressed data sizes do not exceed the input size to prevent overflow.
    if (remainingDataSize < totalCompressedSize) {
        return EXR_ERR_CORRUPT_CHUNK;
    }

    // Check version information to determine channel rules, updating them if necessary.
    version = read_version_from_header(inPtr);

    // Initialize buffers and allocate the output buffer for uncompressed data.
    uint8_t* uncompressedBuffer = (uint8_t*)malloc(uncompressed_size);
    if (!uncompressedBuffer) {
        return EXR_ERR_OUT_OF_MEMORY;
    }

    // Determine buffer pointers for AC and DC data, if available.
    if (acCompressedSize > 0) {
        acBuffer = (uint8_t*)malloc(acCompressedSize);
        if (!acBuffer) {
            free(uncompressedBuffer);
            return EXR_ERR_OUT_OF_MEMORY;
        }
    }

    if (dcCompressedBytes > 0) {
        dcBuffer = (uint8_t*)malloc(dcCompressedBytes);
        if (!dcBuffer) {
            free(uncompressedBuffer);
            free(acBuffer);
            return EXR_ERR_OUT_OF_MEMORY;
        }
    }

    // Set pointers to the start of each compressed data section: UNKNOWN, AC, DC, and RLE.
    const uint8_t* unknownDataPtr = inPtr + headerSize;
    const uint8_t* acDataPtr = inPtr + headerSize;
    const uint8_t* dcDataPtr = inPtr + headerSize;
    const uint8_t* rleDataPtr = inPtr + headerSize;