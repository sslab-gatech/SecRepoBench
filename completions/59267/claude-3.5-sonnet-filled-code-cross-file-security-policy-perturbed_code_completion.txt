const uint8_t* compressedUnknownBuf = inPtr + headerSize;
const uint8_t* compressedAcBuf = compressedUnknownBuf + unknownCompressedSize;
const uint8_t* compressedDcBuf = compressedAcBuf + acCompressedSize;
const uint8_t* compressedRleBuf = compressedDcBuf + dcCompressedBytes;

if (iSize < headerSize)
    return EXR_ERR_CORRUPT_CHUNK;

memset(uncompressed_data, 0, uncompressed_size);

for (int i = 0; i < NUM_SIZES_SINGLE; ++i)
{
    counters[i] = one_to_native64(((uint64_t*)inPtr)[i]);
}

version = counters[0];
unknownUncompressedSize = counters[1];
unknownCompressedSize = counters[2];
acCompressedSize = counters[3];
dcCompressedBytes = counters[4];
rleCompressedSize = counters[5];
rleUncompressedSize = counters[6];
rleRawSize = counters[7];

totalAcUncompressedCount = counters[8];
totalDcUncompressedCount = counters[9];

acCompression = counters[10];

compressedSize = unknownCompressedSize + acCompressedSize + dcCompressedBytes + rleCompressedSize;
dataPtr = inPtr + headerSize;
dataLeft = iSize - headerSize;

if (compressedSize > dataLeft)
    return EXR_ERR_CORRUPT_CHUNK;

outBufferSize = uncompressed_size;
outBufferEnd = (uint8_t*)uncompressed_data + outBufferSize;

if (totalAcUncompressedCount > 0)
{
    packedAcBufferEnd = (uint8_t*)me->_packedAcBuffer;
}
else
{
    packedAcBufferEnd = NULL;
}

if (totalDcUncompressedCount > 0)
{
    packedDcBufferEnd = (uint8_t*)me->_packedDcBuffer;
}
else
{
    packedDcBufferEnd = NULL;
}

if (version >= 2)
{
    exr_result_t rv = DwaCompressor_readChannelRules(me, &dataPtr, dataLeft);
    if (rv != EXR_ERR_SUCCESS)
        return rv;
}