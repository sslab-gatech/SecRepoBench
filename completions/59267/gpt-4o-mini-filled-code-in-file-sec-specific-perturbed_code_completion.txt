// Verify that the input size is adequate for the expected header size.
    if (iSize < headerSize) {
        return EXR_ERR_CORRUPT_CHUNK;
    }

    // Initialize the uncompressed data buffer to zero.
    memset(uncompressed_data, 0, uncompressed_size);

    // Copy header information into an array and convert it from XDR format to native format.
    memcpy(counters, inPtr, headerSize);
    priv_from_native64(counters, NUM_SIZES_SINGLE);

    // Extract various sizes and counters related to compression from the header information.
    version = counters[VERSION];
    unknownUncompressedSize = counters[UNKNOWN_UNCOMPRESSED_SIZE];
    unknownCompressedSize = counters[UNKNOWN_COMPRESSED_SIZE];
    acCompressedSize = counters[AC_COMPRESSED_SIZE];
    dcCompressedBytes = counters[DC_COMPRESSED_SIZE];
    rleCompressedSize = counters[RLE_COMPRESSED_SIZE];
    rleUncompressedSize = counters[RLE_UNCOMPRESSED_SIZE];
    rleRawSize = counters[RLE_RAW_SIZE];

    // Calculate the total size of compressed data sections.
    totalAcUncompressedCount = counters[AC_UNCOMPRESSED_COUNT];
    totalDcUncompressedCount = counters[DC_UNCOMPRESSED_COUNT];
    acCompression = counters[AC_COMPRESSION];

    // Adjust the data pointer to skip the header and calculate the remaining data size.
    dataPtr = inPtr + headerSize;
    dataLeft = iSize - headerSize;

    // Verify that compressed data sizes do not exceed the input size to prevent overflow.
    if (unknownCompressedSize > dataLeft || 
        acCompressedSize > dataLeft || 
        dcCompressedBytes > dataLeft || 
        rleCompressedSize > dataLeft) {
        return EXR_ERR_CORRUPT_CHUNK;
    }

    // Check version information to determine channel rules, updating them if necessary.
    if (version > 2) { 
        return EXR_ERR_BAD_CHUNK_LEADER; 
    }

    rv = DwaCompressor_setupChannelData(me);