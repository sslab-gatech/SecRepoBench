//
// Uncompress the UNKNOWN data into _planarUncBuffer[UNKNOWN]
//

if (unknownCompressedSize > 0)
{
    if (unknownUncompressedSize > me->_planarUncBufferSize[UNKNOWN])
    {
        return EXR_ERR_CORRUPT_CHUNK;
    }

    if (EXR_ERR_SUCCESS!= exr_uncompress_buffer (
                               me->_decode->context,
                               compressedUnknownBuf,
                               unknownCompressedSize,
                               me->_planarUncBuffer[UNKNOWN],
                               unknownUncompressedSize,
                               NULL))
    {
        return EXR_ERR_CORRUPT_CHUNK;
    }
}

//
// Uncompress the AC data into _packedAcBuffer
//

if (acCompressedSize > 0)
{
    if (!me->_packedAcBuffer ||
        totalAcUncompressedCount * sizeof (uint16_t) >
            me->_packedAcBufferSize)
    {
        return EXR_ERR_CORRUPT_CHUNK;
    }

    //
    // Don't trust the user to get it right, look in the file.
    //

    switch (acCompression)
    {
        case STATIC_HUFFMAN:
            rv = internal_huf_decompress (
                me->_decode,
                compressedAcBuf,
                acCompressedSize,
                (uint16_t*) me->_packedAcBuffer,
                totalAcUncompressedCount,
                me->_decode->scratch_buffer_1,
                me->_decode->scratch_alloc_size_1);
            if (rv!= EXR_ERR_SUCCESS) { return rv; }
            break;

        case DEFLATE: {
            size_t destLen;

            rv = exr_uncompress_buffer (
                me->_decode->context,
                compressedAcBuf,
                acCompressedSize,
                me->_packedAcBuffer,
                totalAcUncompressedCount * sizeof (uint16_t),
                &destLen);
            if (rv!= EXR_ERR_SUCCESS) return rv;

            if (totalAcUncompressedCount * sizeof (uint16_t)!= destLen)
            {
                return EXR_ERR_CORRUPT_CHUNK;
            }
        }
        break;

        default: return EXR_ERR_CORRUPT_CHUNK; break;
    }
}

//
// Uncompress the DC data into _packedDcBuffer
//

if (dcCompressedBytes > 0)
{
    size_t destLen;
    size_t uncompBytes = totalDcUncompressedCount * sizeof (uint16_t);
    if (uncompBytes > me->_packedDcBufferSize)
    {
        return EXR_ERR_CORRUPT_CHUNK;
    }

    rv = internal_decode_alloc_buffer (
        me->_decode,
        EXR_TRANSCODE_BUFFER_SCRATCH1,
        &(me->_decode->scratch_buffer_1),
        &(me->_decode->scratch_alloc_size_1),
        uncompBytes);

    if (rv!= EXR_ERR_SUCCESS) return rv;

    rv = exr_uncompress_buffer (
        me->_decode->context,
        compressedDcBuf,
        dcCompressedBytes,
        me->_decode->scratch_buffer_1,
        uncompBytes,
        &destLen);
    if (rv!= EXR_ERR_SUCCESS || (uncompBytes!= destLen))
    {
        return EXR_ERR_CORRUPT_CHUNK;
    }

    internal_zip_reconstruct_bytes (
        me->_packedDcBuffer, me->_decode->scratch_buffer_1, uncompBytes);
}
else
{
    // if the compressed size is 0, then the uncompressed size must also be zero
    if (totalDcUncompressedCount!= 0) { return EXR_ERR_CORRUPT_CHUNK; }
}

//
// Uncompress the RLE data into _rleBuffer, then unRLE the results
// into _planarUncBuffer[RLE]
//

if (rleRawSize > 0)
{
    size_t dstLen;

    if (rleUncompressedSize > me->_rleBufferSize ||
        rleRawSize > me->_planarUncBufferSize[RLE])
    {
        return EXR_ERR_CORRUPT_CHUNK;
    }

    if (EXR_ERR_SUCCESS!= exr_uncompress_buffer (
                               me->_decode->context,
                               compressedRleBuf,
                               rleCompressedSize,
                               me->_rleBuffer,
                               rleUncompressedSize,
                               &dstLen))
    {
        return EXR_ERR_CORRUPT_CHUNK;
    }

    if (dstLen!= rleUncompressedSize) { return EXR_ERR_CORRUPT_CHUNK; }

    if (internal_rle_decompress (
            me->_planarUncBuffer[RLE],
            rleRawSize,
            (const uint8_t*) me->_rleBuffer,
            rleUncompressedSize)!= rleRawSize)
    {
        return EXR_ERR_CORRUPT_CHUNK;
    }
}