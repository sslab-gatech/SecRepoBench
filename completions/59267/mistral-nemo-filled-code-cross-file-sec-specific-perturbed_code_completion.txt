// <MASK>
if (version > 2) { return EXR_ERR_BAD_CHUNK_LEADER; }

rv = DwaCompressor_setupChannelData(me);

// Initialize pointers for compressed data sections: UNKNOWN, AC, DC, and RLE.
compressedUnknownBuf = compressedAcBuf = compressedDcBuf = compressedRleBuf = NULL;
unknownCompressedSize = acCompressedSize = dcCompressedBytes = rleCompressedSize = 0;
unknownUncompressedSize = totalAcUncompressedCount = totalDcUncompressedCount = rleUncompressedSize = rleRawSize = 0;
packedAcBufferEnd = me->_packedAcBuffer;
packedDcBufferEnd = me->_packedDcBuffer;

// Verify that the input size is adequate for the expected header size.
if (iSize < headerSize) { return EXR_ERR_OUT_OF_MEMORY; }

// Initialize the uncompressed data buffer to zero.
memset(uncompressed_data, 0, uncompressed_size);

// Copy header information into an array and convert it from XDR format to native format.
if (EXR_ERR_SUCCESS != exr_xdr_to_native(
    me->_decode->context,
    inPtr,
    headerSize,
    counters,
    sizeof(counters),
    NULL))
{
    return EXR_ERR_CORRUPT_CHUNK;
}

// Extract various sizes and counters related to compression from the header information.
version = counters[0];
unknownUncompressedSize = counters[1];
unknownCompressedSize = counters[2];
acCompressedSize = counters[3];
dcCompressedBytes = counters[4];
rleCompressedSize = counters[5];
rleUncompressedSize = counters[6];
rleRawSize = counters[7];
totalAcUncompressedCount = counters[8];
totalDcUncompressedCount = counters[9];

// Calculate the total size of compressed data sections.
compressedSize = unknownCompressedSize + acCompressedSize + dcCompressedBytes + rleCompressedSize;

// Adjust the data pointer to skip the header and calculate the remaining data size.
dataPtr = inPtr + headerSize;
dataLeft = iSize - headerSize;

// Verify that compressed data sizes do not exceed the input size to prevent overflow.
if (unknownCompressedSize > dataLeft || acCompressedSize > dataLeft || dcCompressedBytes > dataLeft || rleCompressedSize > dataLeft)
{
    return EXR_ERR_CORRUPT_CHUNK;
}

// Check version information to determine channel rules, updating them if necessary.
if (version == 1)
{
    // Update channel rules for version 1
}
else if (version == 2)
{
    // Update channel rules for version 2
}

// Initialize buffers and allocate the output buffer for uncompressed data.
outBufferSize = uncompressed_size;
outBufferEnd = (uint8_t*)uncompressed_data + outBufferSize;

// Determine buffer pointers for AC and DC data, if available.
if (acCompressedSize > 0)
{
    packedAcBufferEnd = me->_packedAcBuffer;
}
if (dcCompressedBytes > 0)
{
    packedDcBufferEnd = me->_packedDcBuffer;
}

// Set pointers to the start of each compressed data section: UNKNOWN, AC, DC, and RLE.
compressedUnknownBuf = dataPtr;
compressedAcBuf = compressedUnknownBuf + unknownCompressedSize;
compressedDcBuf = compressedAcBuf + acCompressedSize;
compressedRleBuf = compressedDcBuf + dcCompressedBytes;

// </MASK>