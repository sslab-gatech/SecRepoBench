// Define pointers for compressed data sections: UNKNOWN, AC, DC, and RLE.
const uint8_t* compressedUnknownBuf = inPtr + headerSize;
const uint8_t* compressedAcBuf      = compressedUnknownBuf + unknownCompressedSize;
const uint8_t* compressedDcBuf      = compressedAcBuf + acCompressedSize;
const uint8_t* compressedRleBuf     = compressedDcBuf + dcCompressedBytes;

// Verify that the input size is adequate for the expected header size.
if (iSize < headerSize) { return EXR_ERR_CORRUPT_CHUNK; }

// Initialize the uncompressed data buffer to zero.
memset(uncompressed_data, 0, uncompressed_size);

// Copy header information into an array and convert it from XDR format to native format.
dataPtr = inPtr;
for (int i = 0; i < NUM_SIZES_SINGLE; ++i)
{
    if (dataLeft < sizeof(uint64_t)) { return EXR_ERR_CORRUPT_CHUNK; }
    counters[i] = one_from_native64(*reinterpret_cast<const uint64_t*>(dataPtr));
    dataPtr += sizeof(uint64_t);
    dataLeft -= sizeof(uint64_t);
}

// Extract various sizes and counters related to compression from the header information.
version                = counters[0];
unknownUncompressedSize = counters[1];
unknownCompressedSize   = counters[2];
acCompressedSize        = counters[3];
dcCompressedBytes       = counters[4];
rleCompressedSize       = counters[5];
rleUncompressedSize     = counters[6];
rleRawSize              = counters[7];
totalAcUncompressedCount = counters[8];
totalDcUncompressedCount = counters[9];
acCompression           = counters[10];

// Calculate the total size of compressed data sections.
compressedSize = unknownCompressedSize + acCompressedSize + dcCompressedBytes +
                 rleCompressedSize;

// Adjust the data pointer to skip the header and calculate the remaining data size.
dataPtr = inPtr + headerSize;
dataLeft = iSize - headerSize;

// Verify that compressed data sizes do not exceed the input size to prevent overflow.
if (dataLeft < compressedSize) { return EXR_ERR_CORRUPT_CHUNK; }

// Check version information to determine channel rules, updating them if necessary.
if (version == 2)
{
    exr_result_t rv = DwaCompressor_writeRelevantChannelRules(me, &dataPtr, dataLeft, &compressedSize);
    if (rv != EXR_ERR_SUCCESS) { return rv; }
    dataLeft -= compressedSize;
}

// Initialize buffers and allocate the output buffer for uncompressed data.
outBufferSize = uncompressed_size;
outBufferEnd = reinterpret_cast<uint8_t*>(uncompressed_data);
packedAcBufferEnd = reinterpret_cast<uint8_t*>(me->_packedAcBuffer);
packedDcBufferEnd = reinterpret_cast<uint8_t*>(me->_packedDcBuffer);

// Determine buffer pointers for AC and DC data, if available.
if (acCompressedSize > 0 && me->_packedAcBuffer)
{
    packedAcBufferEnd = reinterpret_cast<uint8_t*>(me->_packedAcBuffer);
}
if (dcCompressedBytes > 0 && me->_packedDcBuffer)
{
    packedDcBufferEnd = reinterpret_cast<uint8_t*>(me->_packedDcBuffer);
}

// Set pointers to the start of each compressed data section: UNKNOWN, AC, DC, and RLE.
compressedUnknownBuf = dataPtr;
compressedAcBuf = compressedUnknownBuf + unknownCompressedSize;
compressedDcBuf = compressedAcBuf + acCompressedSize;
compressedRleBuf = compressedDcBuf + dcCompressedBytes;