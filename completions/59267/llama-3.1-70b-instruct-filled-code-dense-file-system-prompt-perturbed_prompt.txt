Below is the content of a C/C++ function where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
exr_result_t
DwaCompressor_uncompress (
    DwaCompressor* me,
    const uint8_t* inPtr,
    uint64_t       iSize,
    void*          uncompressed_data,
    uint64_t       uncompressed_size)
{
    uint64_t     headerSize = NUM_SIZES_SINGLE * sizeof (uint64_t);
    exr_result_t rv         = EXR_ERR_SUCCESS;
    uint64_t     counters[NUM_SIZES_SINGLE];
    uint64_t     version;
    uint64_t     unknownUncompressedSize;
    uint64_t     unknownCompressedSize;
    uint64_t     acCompressedSize;
    uint64_t     dcCompressedBytes;
    uint64_t     rleCompressedSize;
    uint64_t     rleUncompressedSize;
    uint64_t     rleRawSize;

    uint64_t totalAcUncompressedCount;
    uint64_t totalDcUncompressedCount;

    uint64_t acCompression;

    size_t         outBufferSize;
    uint64_t       compressedSize;
    const uint8_t* dataPtr;
    uint64_t       dataLeft;
    uint8_t*       outBufferEnd;
    uint8_t*       packedAcBufferEnd;
    uint8_t*       packedDcBufferEnd;
    // Define pointers for compressed data sections: UNKNOWN, AC, DC, and RLE.
    // Verify that the input size is adequate for the expected header size.
    // Initialize the uncompressed data buffer to zero.
    // Copy header information into an array and convert it from XDR format to native format.
    // Extract various sizes and counters related to compression from the header information.
    // Calculate the total size of compressed data sections.
    // Adjust the data pointer to skip the header and calculate the remaining data size.
    // Verify that compressed data sizes do not exceed the input size to prevent overflow.
    // Check version information to determine channel rules, updating them if necessary.
    // Initialize buffers and allocate the output buffer for uncompressed data.
    // Determine buffer pointers for AC and DC data, if available.
    // Set pointers to the start of each compressed data section: UNKNOWN, AC, DC, and RLE.
    // <MASK>

    //
    // Sanity check that the version is something we expect. Right now,
    // we can decode version 0, 1, and 2. v1 adds 'end of block' symbols
    // to the AC RLE. v2 adds channel classification rules at the
    // start of the data block.
    //

    if (version > 2) { return EXR_ERR_BAD_CHUNK_LEADER; }

    rv = DwaCompressor_setupChannelData (me);

    //
    // Uncompress the UNKNOWN data into _planarUncBuffer[UNKNOWN]
    //

    if (unknownCompressedSize > 0)
    {
        if (unknownUncompressedSize > me->_planarUncBufferSize[UNKNOWN])
        {
            return EXR_ERR_CORRUPT_CHUNK;
        }

        if (EXR_ERR_SUCCESS != exr_uncompress_buffer (
                                   me->_decode->context,
                                   compressedUnknownBuf,
                                   unknownCompressedSize,
                                   me->_planarUncBuffer[UNKNOWN],
                                   unknownUncompressedSize,
                                   NULL))
        {
            return EXR_ERR_CORRUPT_CHUNK;
        }
    }

    //
    // Uncompress the AC data into _packedAcBuffer
    //

    if (acCompressedSize > 0)
    {
        if (!me->_packedAcBuffer ||
            totalAcUncompressedCount * sizeof (uint16_t) >
                me->_packedAcBufferSize)
        {
            return EXR_ERR_CORRUPT_CHUNK;
        }

        //
        // Don't trust the user to get it right, look in the file.
        //

        switch (acCompression)
        {
            case STATIC_HUFFMAN:
                rv = internal_huf_decompress (
                    me->_decode,
                    compressedAcBuf,
                    acCompressedSize,
                    (uint16_t*) me->_packedAcBuffer,
                    totalAcUncompressedCount,
                    me->_decode->scratch_buffer_1,
                    me->_decode->scratch_alloc_size_1);
                if (rv != EXR_ERR_SUCCESS) { return rv; }
                break;

            case DEFLATE: {
                size_t destLen;

                rv = exr_uncompress_buffer (
                    me->_decode->context,
                    compressedAcBuf,
                    acCompressedSize,
                    me->_packedAcBuffer,
                    totalAcUncompressedCount * sizeof (uint16_t),
                    &destLen);
                if (rv != EXR_ERR_SUCCESS) return rv;

                if (totalAcUncompressedCount * sizeof (uint16_t) != destLen)
                {
                    return EXR_ERR_CORRUPT_CHUNK;
                }
            }
            break;

            default: return EXR_ERR_CORRUPT_CHUNK; break;
        }
    }

    //
    // Uncompress the DC data into _packedDcBuffer
    //

    if (dcCompressedBytes > 0)
    {
        size_t destLen;
        size_t uncompBytes = totalDcUncompressedCount * sizeof (uint16_t);
        if (uncompBytes > me->_packedDcBufferSize)
        {
            return EXR_ERR_CORRUPT_CHUNK;
        }

        rv = internal_decode_alloc_buffer (
            me->_decode,
            EXR_TRANSCODE_BUFFER_SCRATCH1,
            &(me->_decode->scratch_buffer_1),
            &(me->_decode->scratch_alloc_size_1),
            uncompBytes);

        if (rv != EXR_ERR_SUCCESS) return rv;

        rv = exr_uncompress_buffer (
            me->_decode->context,
            compressedDcBuf,
            dcCompressedBytes,
            me->_decode->scratch_buffer_1,
            uncompBytes,
            &destLen);
        if (rv != EXR_ERR_SUCCESS || (uncompBytes != destLen))
        {
            return EXR_ERR_CORRUPT_CHUNK;
        }

        internal_zip_reconstruct_bytes (
            me->_packedDcBuffer, me->_decode->scratch_buffer_1, uncompBytes);
    }
    else
    {
        // if the compressed size is 0, then the uncompressed size must also be zero
        if (totalDcUncompressedCount != 0) { return EXR_ERR_CORRUPT_CHUNK; }
    }

    //
    // Uncompress the RLE data into _rleBuffer, then unRLE the results
    // into _planarUncBuffer[RLE]
    //

    if (rleRawSize > 0)
    {
        size_t dstLen;

        if (rleUncompressedSize > me->_rleBufferSize ||
            rleRawSize > me->_planarUncBufferSize[RLE])
        {
            return EXR_ERR_CORRUPT_CHUNK;
        }

        if (EXR_ERR_SUCCESS != exr_uncompress_buffer (
                                   me->_decode->context,
                                   compressedRleBuf,
                                   rleCompressedSize,
                                   me->_rleBuffer,
                                   rleUncompressedSize,
                                   &dstLen))
        {
            return EXR_ERR_CORRUPT_CHUNK;
        }

        if (dstLen != rleUncompressedSize) { return EXR_ERR_CORRUPT_CHUNK; }

        if (internal_rle_decompress (
                me->_planarUncBuffer[RLE],
                rleRawSize,
                (const uint8_t*) me->_rleBuffer,
                rleUncompressedSize) != rleRawSize)
        {
            return EXR_ERR_CORRUPT_CHUNK;
        }
    }

    //
    // Determine the start of each row in the output buffer
    //
    for (int c = 0; c < me->_numChannels; ++c)
    {
        me->_channelData[c].processed = 0;
    }

    for (int y = me->_min[1]; y <= me->_max[1]; ++y)
    {
        for (int c = 0; c < me->_numChannels; ++c)
        {
            ChannelData*               cd   = &(me->_channelData[c]);
            exr_coding_channel_info_t* chan = cd->chan;

            if ((y % chan->y_samples) != 0) continue;

            rv = DctCoderChannelData_push_row (
                me->alloc_fn, me->free_fn, &(cd->_dctData), outBufferEnd);
            if (rv != EXR_ERR_SUCCESS) return rv;

            outBufferEnd += chan->width * chan->bytes_per_element;
        }
    }

    //
    // Setup to decode each block of 3 channels that need to
    // be handled together
    //

    for (int csc = 0; csc < me->_numCscChannelSets; ++csc)
    {
        LossyDctDecoder decoder;
        CscChannelSet*  cset = &(me->_cscChannelSets[csc]);

        int rChan = cset->idx[0];
        int gChan = cset->idx[1];
        int bChan = cset->idx[2];

        if (me->_channelData[rChan].compression != LOSSY_DCT ||
            me->_channelData[gChan].compression != LOSSY_DCT ||
            me->_channelData[bChan].compression != LOSSY_DCT)
        {
            return EXR_ERR_CORRUPT_CHUNK;
        }

        rv = LossyDctDecoderCsc_construct (
            &decoder,
            &(me->_channelData[rChan]._dctData),
            &(me->_channelData[gChan]._dctData),
            &(me->_channelData[bChan]._dctData),
            packedAcBufferEnd,
            packedAcBufferEnd + totalAcUncompressedCount * sizeof (uint16_t),
            packedDcBufferEnd,
            dwaCompressorToLinear,
            me->_channelData[rChan].chan->width,
            me->_channelData[rChan].chan->height);

        if (rv == EXR_ERR_SUCCESS)
            rv = LossyDctDecoder_execute (me->alloc_fn, me->free_fn, &decoder);

        packedAcBufferEnd += decoder._packedAcCount * sizeof (uint16_t);

        packedDcBufferEnd += decoder._packedDcCount * sizeof (uint16_t);

        me->_channelData[rChan].processed = 1;
        me->_channelData[gChan].processed = 1;
        me->_channelData[bChan].processed = 1;

        if (rv != EXR_ERR_SUCCESS) { return rv; }
    }

    //
    // Setup to handle the remaining channels by themselves
    //

    for (int c = 0; c < me->_numChannels; ++c)
    {
        ChannelData*               cd        = &(me->_channelData[c]);
        exr_coding_channel_info_t* chan      = cd->chan;
        DctCoderChannelData*       dcddata   = &(cd->_dctData);
        int                        pixelSize = chan->bytes_per_element;

        if (cd->processed) continue;

        switch (cd->compression)
        {
            case LOSSY_DCT:

                //
                // Setup a single-channel lossy DCT decoder pointing
                // at the output buffer
                //

                {
                    const uint16_t* linearLut = NULL;
                    LossyDctDecoder decoder;

                    if (!chan->p_linear) linearLut = dwaCompressorToLinear;

                    rv = LossyDctDecoder_construct (
                        &decoder,
                        dcddata,
                        packedAcBufferEnd,
                        packedAcBufferEnd +
                            totalAcUncompressedCount * sizeof (uint16_t),
                        packedDcBufferEnd,
                        linearLut,
                        chan->width,
                        chan->height);

                    if (rv == EXR_ERR_SUCCESS)
                        rv = LossyDctDecoder_execute (
                            me->alloc_fn, me->free_fn, &decoder);

                    packedAcBufferEnd +=
                        (size_t) decoder._packedAcCount * sizeof (uint16_t);

                    packedDcBufferEnd +=
                        (size_t) decoder._packedDcCount * sizeof (uint16_t);

                    if (rv != EXR_ERR_SUCCESS) { return rv; }
                }

                break;

            case RLE:

                //
                // For the RLE case, the data has been un-RLE'd into
                // planarUncRleEnd[], but is still split out by bytes.
                // We need to rearrange the bytes back into the correct
                // order in the output buffer;
                //

                {
                    int row = 0;

                    for (int y = me->_min[1]; y <= me->_max[1]; ++y)
                    {
                        uint8_t* dst;
                        if ((y % chan->y_samples) != 0) continue;

                        dst = dcddata->_rows[row];

                        if (pixelSize == 2)
                        {
                            interleaveByte2 (
                                dst,
                                cd->planarUncRleEnd[0],
                                cd->planarUncRleEnd[1],
                                chan->width);

                            cd->planarUncRleEnd[0] += chan->width;
                            cd->planarUncRleEnd[1] += chan->width;
                        }
                        else
                        {
                            for (int x = 0; x < chan->width; ++x)
                            {
                                for (int byte = 0; byte < pixelSize; ++byte)
                                {
                                    *dst++ = *cd->planarUncRleEnd[byte]++;
                                }
                            }
                        }

                        row++;
                    }
                }

                break;

            case UNKNOWN:

                //
                // In the UNKNOWN case, data is already in planarUncBufferEnd
                // and just needs to copied over to the output buffer
                //

                {
                    int    row = 0;
                    size_t dstScanlineSize =
                        (size_t) chan->width * (size_t) pixelSize;

                    for (int y = me->_min[1]; y <= me->_max[1]; ++y)
                    {
                        if ((y % chan->y_samples) != 0) continue;

                        //
                        // sanity check for buffer data lying within range
                        //
                        if ((cd->planarUncBufferEnd +
                             (size_t) (dstScanlineSize)) >
                            (me->_planarUncBuffer[UNKNOWN] +
                             me->_planarUncBufferSize[UNKNOWN]))
                        {
                            return EXR_ERR_CORRUPT_CHUNK;
                        }

                        memcpy (
                            dcddata->_rows[row],
                            cd->planarUncBufferEnd,
                            dstScanlineSize);

                        cd->planarUncBufferEnd += dstScanlineSize;
                        row++;
                    }
                }

                break;

            case NUM_COMPRESSOR_SCHEMES:
            default: return EXR_ERR_CORRUPT_CHUNK; break;
        }

        cd->processed = 1;
    }

    return rv;
}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/lib/OpenEXRCore/internal_dwa_compressor.h
exr_result_t
DwaCompressor_compress (DwaCompressor* me)
{
    exr_result_t rv;
    uint8_t*     outPtr;
    uint64_t*    sizes;
    size_t       outBufferSize = 0;
    uint64_t     dataBytes, nWritten = 0;
    uint64_t     nAvail;
    uint64_t     fileVersion = 2;
    uint64_t*    version;
    uint64_t*    unknownUncompressedSize;
    uint64_t*    unknownCompressedSize;
    uint64_t*    acCompressedSize;
    uint64_t*    dcCompressedSize;
    uint64_t*    rleCompressedSize;
    uint64_t*    rleUncompressedSize;
    uint64_t*    rleRawSize;

    uint64_t* totalAcUncompressedCount;
    uint64_t* totalDcUncompressedCount;

    uint64_t* acCompression;
    uint8_t*  packedAcEnd;
    uint8_t*  packedDcEnd;
    uint8_t*  outDataPtr;
    uint8_t*  inDataPtr;

    // Starting with 2, we write the channel
    // classification rules into the file
    if (fileVersion < 2)
    {
        me->_channelRules = sLegacyChannelRules;
        me->_channelRuleCount =
            sizeof (sLegacyChannelRules) / sizeof (Classifier);
    }
    else
    {
        me->_channelRules = sDefaultChannelRules;
        me->_channelRuleCount =
            sizeof (sDefaultChannelRules) / sizeof (Classifier);
    }

    rv = DwaCompressor_initializeBuffers (me, &outBufferSize);

    nAvail = me->_encode->compressed_alloc_size;
    if (nAvail < (NUM_SIZES_SINGLE * sizeof (uint64_t)))
        return EXR_ERR_OUT_OF_MEMORY;

    rv = internal_encode_alloc_buffer (
        me->_encode,
        EXR_TRANSCODE_BUFFER_SCRATCH1,
        &(me->_encode->compressed_buffer),
        &(me->_encode->compressed_alloc_size),
        outBufferSize);
    if (rv != EXR_ERR_SUCCESS) return rv;

    nAvail = outBufferSize;
    sizes  = (uint64_t*) me->_encode->compressed_buffer;

    //
    // Zero all the numbers in the chunk header
    //
    //    memset (sizes, 0, NUM_SIZES_SINGLE * sizeof (uint64_t));
    memset (sizes, 0, me->_encode->compressed_alloc_size);

#define OBIDX(x) (uint64_t*) (sizes + x)

    version                 = OBIDX (VERSION);
    unknownUncompressedSize = OBIDX (UNKNOWN_UNCOMPRESSED_SIZE);
    unknownCompressedSize   = OBIDX (UNKNOWN_COMPRESSED_SIZE);
    acCompressedSize        = OBIDX (AC_COMPRESSED_SIZE);
    dcCompressedSize        = OBIDX (DC_COMPRESSED_SIZE);
    rleCompressedSize       = OBIDX (RLE_COMPRESSED_SIZE);
    rleUncompressedSize     = OBIDX (RLE_UNCOMPRESSED_SIZE);
    rleRawSize              = OBIDX (RLE_RAW_SIZE);

    totalAcUncompressedCount = OBIDX (AC_UNCOMPRESSED_COUNT);
    totalDcUncompressedCount = OBIDX (DC_UNCOMPRESSED_COUNT);

    acCompression = OBIDX (AC_COMPRESSION);
    packedAcEnd   = NULL;
    packedDcEnd   = NULL;

    // Now write in the channel rules...
    outPtr = (uint8_t*) (sizes + NUM_SIZES_SINGLE);
    if (rv == EXR_ERR_SUCCESS && fileVersion >= 2)
    {
        rv = DwaCompressor_writeRelevantChannelRules (
            me, &outPtr, nAvail, &nWritten);
    }

    // post add this so we have a 0 value for the relevant channel
    // rules to fill up
    nWritten += NUM_SIZES_SINGLE * sizeof (uint64_t);

    if (rv != EXR_ERR_SUCCESS || nWritten >= me->_encode->compressed_alloc_size)
        return EXR_ERR_OUT_OF_MEMORY;

    outDataPtr = outPtr;

    //
    // We might not be dealing with any color data, in which
    // case the AC buffer size will be 0, and dereferencing
    // a vector will not be a good thing to do.
    //

    if (me->_packedAcBuffer) packedAcEnd = me->_packedAcBuffer;
    if (me->_packedDcBuffer) packedDcEnd = me->_packedDcBuffer;

    //
    // Setup the AC compression strategy and the version in the data block,
    // then write the relevant channel classification rules if needed
    //
    *version       = fileVersion;
    *acCompression = me->_acCompression;

    rv = DwaCompressor_setupChannelData (me);
    if (rv != EXR_ERR_SUCCESS) return rv;

    //
    // Determine the start of each row in the input buffer
    // Channels are interleaved by scanline
    //
    for (int c = 0; c < me->_numChannels; ++c)
    {
        me->_channelData[c].processed = 0;
    }

    inDataPtr = me->_encode->packed_buffer;

    for (int y = me->_min[1]; y <= me->_max[1]; ++y)
    {
        for (int c = 0; c < me->_numChannels; ++c)
        {
            ChannelData*               cd   = &(me->_channelData[c]);
            exr_coding_channel_info_t* chan = cd->chan;

            if ((y % chan->y_samples) != 0) continue;

            rv = DctCoderChannelData_push_row (
                me->alloc_fn, me->free_fn, &(cd->_dctData), inDataPtr);
            if (rv != EXR_ERR_SUCCESS) return rv;

            inDataPtr += chan->width * chan->bytes_per_element;
        }
    }

    //
    // Make a pass over all our CSC sets and try to encode them first
    //

    for (int csc = 0; csc < me->_numCscChannelSets; ++csc)
    {
        LossyDctEncoder enc;
        CscChannelSet*  cset = &(me->_cscChannelSets[csc]);

        rv = LossyDctEncoderCsc_construct (
            &enc,
            me->_dwaCompressionLevel / 100000.f,
            &(me->_channelData[cset->idx[0]]._dctData),
            &(me->_channelData[cset->idx[1]]._dctData),
            &(me->_channelData[cset->idx[2]]._dctData),
            packedAcEnd,
            packedDcEnd,
            dwaCompressorToNonlinear,
            me->_channelData[cset->idx[0]].chan->width,
            me->_channelData[cset->idx[0]].chan->height);

        if (rv == EXR_ERR_SUCCESS)
            rv = LossyDctEncoder_execute (me->alloc_fn, me->free_fn, &enc);

        *totalAcUncompressedCount = *totalAcUncompressedCount + enc._numAcComp;
        *totalDcUncompressedCount = *totalDcUncompressedCount + enc._numDcComp;

        packedAcEnd += enc._numAcComp * sizeof (uint16_t);
        packedDcEnd += enc._numDcComp * sizeof (uint16_t);

        me->_channelData[cset->idx[0]].processed = 1;
        me->_channelData[cset->idx[1]].processed = 1;
        me->_channelData[cset->idx[2]].processed = 1;

        if (rv != EXR_ERR_SUCCESS) return rv;
    }

    for (int chan = 0; chan < me->_numChannels; ++chan)
    {
        ChannelData*               cd    = &(me->_channelData[chan]);
        exr_coding_channel_info_t* pchan = cd->chan;

        if (cd->processed) continue;

        switch (cd->compression)
        {
            case LOSSY_DCT:
                //
                // For LOSSY_DCT, treat this just like the CSC'd case,
                // but only operate on one channel
                //
                {
                    LossyDctEncoder       enc;
                    const unsigned short* nonlinearLut = NULL;

                    if (!pchan->p_linear)
                        nonlinearLut = dwaCompressorToNonlinear;

                    rv = LossyDctEncoder_construct (
                        &enc,
                        me->_dwaCompressionLevel / 100000.f,
                        &(cd->_dctData),
                        packedAcEnd,
                        packedDcEnd,
                        nonlinearLut,
                        pchan->width,
                        pchan->height);

                    if (rv == EXR_ERR_SUCCESS)
                        rv = LossyDctEncoder_execute (
                            me->alloc_fn, me->free_fn, &enc);

                    *totalAcUncompressedCount =
                        *totalAcUncompressedCount + enc._numAcComp;
                    *totalDcUncompressedCount =
                        *totalDcUncompressedCount + enc._numDcComp;

                    packedAcEnd += enc._numAcComp * sizeof (uint16_t);
                    packedDcEnd += enc._numDcComp * sizeof (uint16_t);

                    if (rv != EXR_ERR_SUCCESS) return rv;
                }
                break;

            case RLE: {
                //
                // For RLE, bash the bytes up so that the first bytes of each
                // pixel are contiguous, as are the second bytes, and so on.
                //
                DctCoderChannelData* dcd = &(cd->_dctData);
                for (size_t y = 0; y < dcd->_size; ++y)
                {
                    const uint8_t* row = dcd->_rows[y];

                    for (int x = 0; x < pchan->width; ++x)
                    {
                        for (int byte = 0; byte < pchan->bytes_per_element;
                             ++byte)
                        {
                            *cd->planarUncRleEnd[byte]++ = *row++;
                        }
                    }

                    *rleRawSize += (uint64_t) pchan->width *
                                   (uint64_t) pchan->bytes_per_element;
                }

                break;
            }

            case UNKNOWN:

                //
                // Otherwise, just copy data over verbatim
                //

                {
                    size_t scanlineSize = (size_t) pchan->width *
                                          (size_t) pchan->bytes_per_element;
                    DctCoderChannelData* dcd = &(cd->_dctData);
                    for (size_t y = 0; y < dcd->_size; ++y)
                    {
                        memcpy (
                            cd->planarUncBufferEnd,
                            dcd->_rows[y],
                            scanlineSize);

                        cd->planarUncBufferEnd += scanlineSize;
                    }

                    *unknownUncompressedSize += cd->planarUncSize;
                }

                break;

            case NUM_COMPRESSOR_SCHEMES:
            default: return EXR_ERR_INVALID_ARGUMENT;
        }

        cd->processed = DWA_CLASSIFIER_TRUE;
    }

    //
    // Pack the Unknown data into the output buffer first. Instead of
    // just copying it uncompressed, try zlib compression at least.
    //

    if (*unknownUncompressedSize > 0)
    {
        size_t outSize;

        rv = exr_compress_buffer (
            me->_encode->context,
            9, // TODO: use default??? the old call to zlib had 9 hardcoded
            me->_planarUncBuffer[UNKNOWN],
            *unknownUncompressedSize,
            outDataPtr,
            exr_compress_max_buffer_size (*unknownUncompressedSize),
            &outSize);
        if (rv != EXR_ERR_SUCCESS) return rv;

        outDataPtr += outSize;
        *unknownCompressedSize = outSize;
        nWritten += outSize;
    }

    //
    // Now, pack all the Lossy DCT coefficients into our output
    // buffer, with Huffman encoding.
    //
    // Also, record the compressed size and the number of
    // uncompressed componentns we have.
    //

    if (*totalAcUncompressedCount > 0)
    {
        switch (me->_acCompression)
        {
            case STATIC_HUFFMAN: {
                size_t outDataSize =
                    outBufferSize -
                    (size_t) ((uintptr_t) outDataPtr - (uintptr_t) sizes);

                rv = internal_huf_compress (
                    acCompressedSize,
                    outDataPtr,
                    outDataSize,
                    (const uint16_t*) me->_packedAcBuffer,
                    *totalAcUncompressedCount,
                    me->_encode->scratch_buffer_1,
                    me->_encode->scratch_alloc_size_1);
                if (rv != EXR_ERR_SUCCESS)
                {
                    if (rv == EXR_ERR_ARGUMENT_OUT_OF_RANGE)
                    {
                        memcpy (
                            me->_encode->compressed_buffer,
                            me->_encode->packed_buffer,
                            me->_encode->packed_alloc_size);
                        me->_encode->compressed_bytes =
                            me->_encode->packed_alloc_size;
                        return EXR_ERR_SUCCESS;
                    }
                    return rv;
                }
                break;
            }

            case DEFLATE: {
                size_t sourceLen =
                    *totalAcUncompressedCount * sizeof (uint16_t);
                size_t destLen;

                rv = exr_compress_buffer (
                    me->_encode->context,
                    9, // TODO: use default??? the old call to zlib had 9 hardcoded
                    me->_packedAcBuffer,
                    sourceLen,
                    outDataPtr,
                    exr_compress_max_buffer_size (sourceLen),
                    &destLen);
                if (rv != EXR_ERR_SUCCESS) return rv;

                *acCompressedSize = destLen;
                break;
            }

            default:
                return EXR_ERR_INVALID_ARGUMENT;
                //assert (false);
        }

        outDataPtr += *acCompressedSize;
        nWritten += *acCompressedSize;
    }

    //
    // Handle the DC components separately
    //

    if (*totalDcUncompressedCount > 0)
    {
        size_t compBytes;
        size_t uncompBytes = *totalDcUncompressedCount * sizeof (uint16_t);

        rv = internal_encode_alloc_buffer (
            me->_encode,
            EXR_TRANSCODE_BUFFER_SCRATCH1,
            &(me->_encode->scratch_buffer_1),
            &(me->_encode->scratch_alloc_size_1),
            uncompBytes);

        if (rv != EXR_ERR_SUCCESS) return rv;

        internal_zip_deconstruct_bytes (
            me->_encode->scratch_buffer_1, me->_packedDcBuffer, uncompBytes);

        rv = exr_compress_buffer (
            me->_encode->context,
            me->_zipLevel,
            me->_encode->scratch_buffer_1,
            uncompBytes,
            outDataPtr,
            exr_compress_max_buffer_size (uncompBytes),
            &compBytes);

        if (rv != EXR_ERR_SUCCESS) return rv;

        *dcCompressedSize = compBytes;
        outDataPtr += compBytes;
        nWritten += compBytes;
    }

    //
    // If we have RLE data, first RLE encode it and set the uncompressed
    // size. Then, deflate the results and set the compressed size.
    //

    if (*rleRawSize > 0)
    {
        size_t compBytes;
        *rleUncompressedSize = internal_rle_compress (
            me->_rleBuffer,
            me->_rleBufferSize,
            me->_planarUncBuffer[RLE],
            *rleRawSize);

        rv = exr_compress_buffer (
            me->_encode->context,
            9, // TODO: use default??? the old call to zlib had 9 hardcoded
            me->_rleBuffer,
            *rleUncompressedSize,
            outDataPtr,
            exr_compress_max_buffer_size (*rleUncompressedSize),
            &compBytes);

        if (rv != EXR_ERR_SUCCESS) return rv;

        *rleCompressedSize = compBytes;
        outDataPtr += compBytes;
        nWritten += compBytes;
    }

    //
    // Flip the counters to XDR format
    //
    priv_from_native64 (sizes, NUM_SIZES_SINGLE);

    dataBytes =
        (uintptr_t) outDataPtr - (uintptr_t) me->_encode->compressed_buffer;
    if (nWritten != dataBytes) { return EXR_ERR_CORRUPT_CHUNK; }

    if (nWritten >= me->_encode->packed_bytes)
    {
        memcpy (
            me->_encode->compressed_buffer,
            me->_encode->packed_buffer,
            me->_encode->packed_bytes);
        me->_encode->compressed_bytes = me->_encode->packed_bytes;
    }
    else { me->_encode->compressed_bytes = nWritten; }
    return rv;
}

// the below code fragment can be found in:
// src/lib/OpenEXR/ImfDwaCompressor.cpp
int
DwaCompressor::uncompress (
    const char*            inPtr,
    int                    inSize,
    IMATH_NAMESPACE::Box2i range,
    const char*&           outPtr)
{
    int minX = range.min.x;
    int maxX = std::min (range.max.x, _max[0]);
    int minY = range.min.y;
    int maxY = std::min (range.max.y, _max[1]);

    uint64_t iSize      = static_cast<uint64_t> (inSize);
    uint64_t headerSize = NUM_SIZES_SINGLE * sizeof (uint64_t);
    if (iSize < headerSize)
    {
        throw IEX_NAMESPACE::InputExc ("Error uncompressing DWA data"
                                       "(truncated header).");
    }

    //
    // Flip the counters from XDR to NATIVE
    //

    std::array<uint64_t, NUM_SIZES_SINGLE> counterBuf;
    memcpy (counterBuf.data (), inPtr, counterBuf.size() * sizeof (uint64_t));
    for (int i = 0; i < NUM_SIZES_SINGLE; ++i)
    {
        uint64_t*   dst = counterBuf.data() + i;
        const char* src = (char*) (counterBuf.data() + i);

        Xdr::read<CharPtrIO> (src, *dst);
    }

    //
    // Unwind all the counter info
    //

    const uint64_t* inPtr64 = counterBuf.data();

    uint64_t version                 = *(inPtr64 + VERSION);
    uint64_t unknownUncompressedSize = *(inPtr64 + UNKNOWN_UNCOMPRESSED_SIZE);
    uint64_t unknownCompressedSize   = *(inPtr64 + UNKNOWN_COMPRESSED_SIZE);
    uint64_t acCompressedSize        = *(inPtr64 + AC_COMPRESSED_SIZE);
    uint64_t dcCompressedSize        = *(inPtr64 + DC_COMPRESSED_SIZE);
    uint64_t rleCompressedSize       = *(inPtr64 + RLE_COMPRESSED_SIZE);
    uint64_t rleUncompressedSize     = *(inPtr64 + RLE_UNCOMPRESSED_SIZE);
    uint64_t rleRawSize              = *(inPtr64 + RLE_RAW_SIZE);

    uint64_t totalAcUncompressedCount = *(inPtr64 + AC_UNCOMPRESSED_COUNT);
    uint64_t totalDcUncompressedCount = *(inPtr64 + DC_UNCOMPRESSED_COUNT);

    uint64_t acCompression = *(inPtr64 + AC_COMPRESSION);

    uint64_t compressedSize = unknownCompressedSize + acCompressedSize +
                              dcCompressedSize + rleCompressedSize;

    const char* dataPtr = inPtr + NUM_SIZES_SINGLE * sizeof (uint64_t);

    /* Both the sum and individual sizes are checked in case of overflow. */
    if (iSize < (headerSize + compressedSize) ||
        iSize < unknownCompressedSize || iSize < acCompressedSize ||
        iSize < dcCompressedSize || iSize < rleCompressedSize)
    {
        throw IEX_NAMESPACE::InputExc ("Error uncompressing DWA data"
                                       "(truncated file).");
    }

    if ((int64_t) unknownUncompressedSize < 0 ||
        (int64_t) unknownCompressedSize < 0 || (int64_t) acCompressedSize < 0 ||
        (int64_t) dcCompressedSize < 0 || (int64_t) rleCompressedSize < 0 ||
        (int64_t) rleUncompressedSize < 0 || (int64_t) rleRawSize < 0 ||
        (int64_t) totalAcUncompressedCount < 0 ||
        (int64_t) totalDcUncompressedCount < 0)
    {
        throw IEX_NAMESPACE::InputExc ("Error uncompressing DWA data"
                                       " (corrupt header).");
    }

    if (version < 2)
        initializeLegacyChannelRules ();
    else
    {
        unsigned short ruleSize = 0;
        Xdr::read<CharPtrIO> (dataPtr, ruleSize);

        if (ruleSize < Xdr::size<unsigned short> ())
            throw IEX_NAMESPACE::InputExc ("Error uncompressing DWA data"
                                           " (corrupt header file).");

        headerSize += ruleSize;
        if (iSize < headerSize + compressedSize)
            throw IEX_NAMESPACE::InputExc ("Error uncompressing DWA data"
                                           " (truncated file).");

        _channelRules.clear ();
        ruleSize -= Xdr::size<unsigned short> ();
        while (ruleSize > 0)
        {
            Classifier rule (dataPtr, ruleSize);

            _channelRules.push_back (rule);
            ruleSize -= rule.size ();
        }
    }

    size_t outBufferSize = 0;
    initializeBuffers (outBufferSize);

    //
    // Allocate _outBuffer, if we haven't done so already
    //

    if (static_cast<size_t> (_maxScanLineSize * numScanLines ()) >
        _outBufferSize)
    {
        _outBufferSize =
            static_cast<size_t> (_maxScanLineSize * numScanLines ());
        if (_outBuffer != 0) delete[] _outBuffer;
        _outBuffer = new char[_maxScanLineSize * numScanLines ()];
    }

    char* outBufferEnd = _outBuffer;

    //
    // Find the start of the RLE packed AC components and
    // the DC components for each channel. This will be handy
    // if you want to decode the channels in parallel later on.
    //

    char* packedAcBufferEnd = 0;

    if (_packedAcBuffer) packedAcBufferEnd = _packedAcBuffer;

    char* packedDcBufferEnd = 0;

    if (_packedDcBuffer) packedDcBufferEnd = _packedDcBuffer;

    //
    // UNKNOWN data is packed first, followed by the
    // Huffman-compressed AC, then the DC values,
    // and then the zlib compressed RLE data.
    //

    const char* compressedUnknownBuf = dataPtr;

    const char* compressedAcBuf =
        compressedUnknownBuf + static_cast<ptrdiff_t> (unknownCompressedSize);
    const char* compressedDcBuf =
        compressedAcBuf + static_cast<ptrdiff_t> (acCompressedSize);
    const char* compressedRleBuf =
        compressedDcBuf + static_cast<ptrdiff_t> (dcCompressedSize);

    //
    // Sanity check that the version is something we expect. Right now,
    // we can decode version 0, 1, and 2. v1 adds 'end of block' symbols
    // to the AC RLE. v2 adds channel classification rules at the
    // start of the data block.
    //

    if (version > 2)
        throw IEX_NAMESPACE::InputExc (
            "Invalid version of compressed data block");

    setupChannelData (minX, minY, maxX, maxY);

    //
    // Uncompress the UNKNOWN data into _planarUncBuffer[UNKNOWN]
    //

    if (unknownCompressedSize > 0)
    {
        if (unknownUncompressedSize > _planarUncBufferSize[UNKNOWN])
        {
            throw IEX_NAMESPACE::InputExc ("Error uncompressing DWA data"
                                           "(corrupt header).");
        }

        if (EXR_ERR_SUCCESS != exr_uncompress_buffer (
                nullptr,
                compressedUnknownBuf,
                unknownCompressedSize,
                _planarUncBuffer[UNKNOWN],
                unknownUncompressedSize,
                nullptr))
        {
            throw IEX_NAMESPACE::BaseExc ("Error uncompressing UNKNOWN data.");
        }
    }

    //
    // Uncompress the AC data into _packedAcBuffer
    //

    if (acCompressedSize > 0)
    {
        if (!_packedAcBuffer ||
            totalAcUncompressedCount * sizeof (unsigned short) >
                _packedAcBufferSize)
        {
            throw IEX_NAMESPACE::InputExc ("Error uncompressing DWA data"
                                           "(corrupt header).");
        }

        //
        // Don't trust the user to get it right, look in the file.
        //

        switch (acCompression)
        {
            case STATIC_HUFFMAN:

                hufUncompress (
                    compressedAcBuf,
                    (int) acCompressedSize,
                    (unsigned short*) _packedAcBuffer,
                    (int) totalAcUncompressedCount);

                break;

            case DEFLATE: {
                size_t destLen;

                if (EXR_ERR_SUCCESS != exr_uncompress_buffer (
                        nullptr,
                        compressedAcBuf,
                        acCompressedSize,
                        _packedAcBuffer,
                        totalAcUncompressedCount * sizeof (unsigned short),
                        &destLen))
                {
                    throw IEX_NAMESPACE::InputExc (
                        "Data decompression (zlib) failed.");
                }

                if (totalAcUncompressedCount * sizeof (unsigned short) !=
                    destLen)
                {
                    throw IEX_NAMESPACE::InputExc ("AC data corrupt.");
                }
            }
            break;

            default:

                throw IEX_NAMESPACE::NoImplExc ("Unknown AC Compression");
                break;
        }
    }

    //
    // Uncompress the DC data into _packedDcBuffer
    //

    if (dcCompressedSize > 0)
    {
        if (totalDcUncompressedCount * sizeof (unsigned short) >
            _packedDcBufferSize)
        {
            throw IEX_NAMESPACE::InputExc ("Error uncompressing DWA data"
                                           "(corrupt header).");
        }

        if (static_cast<uint64_t> (_zip->uncompress (
                compressedDcBuf, (int) dcCompressedSize, _packedDcBuffer)) !=
            totalDcUncompressedCount * sizeof (unsigned short))
        {
            throw IEX_NAMESPACE::BaseExc ("DC data corrupt.");
        }
    }
    else
    {
        // if the compressed size is 0, then the uncompressed size must also be zero
        if (totalDcUncompressedCount != 0)
        {
            throw IEX_NAMESPACE::BaseExc ("DC data corrupt.");
        }
    }

    //
    // Uncompress the RLE data into _rleBuffer, then unRLE the results
    // into _planarUncBuffer[RLE]
    //

    if (rleRawSize > 0)
    {
        if (rleUncompressedSize > _rleBufferSize ||
            rleRawSize > _planarUncBufferSize[RLE])
        {
            throw IEX_NAMESPACE::InputExc ("Error uncompressing DWA data"
                                           "(corrupt header).");
        }

        size_t dstLen;

        if (EXR_ERR_SUCCESS != exr_uncompress_buffer (
                nullptr,
                compressedRleBuf,
                rleCompressedSize,
                _rleBuffer,
                rleUncompressedSize,
                &dstLen))
        {
            throw IEX_NAMESPACE::BaseExc ("Error uncompressing RLE data.");
        }

        if (dstLen != rleUncompressedSize)
            throw IEX_NAMESPACE::BaseExc ("RLE data corrupted");

        if (static_cast<uint64_t> (rleUncompress (
                (int) rleUncompressedSize,
                (int) rleRawSize,
                (signed char*) _rleBuffer,
                _planarUncBuffer[RLE])) != rleRawSize)
        {
            throw IEX_NAMESPACE::BaseExc ("RLE data corrupted");
        }
    }

    //
    // Determine the start of each row in the output buffer
    //

    std::vector<bool>               decodedChannels (_channelData.size ());
    std::vector<std::vector<char*>> rowPtrs (_channelData.size ());

    for (unsigned int chan = 0; chan < _channelData.size (); ++chan)
        decodedChannels[chan] = false;

    outBufferEnd = _outBuffer;

    for (int y = minY; y <= maxY; ++y)
    {
        for (unsigned int chan = 0; chan < _channelData.size (); ++chan)
        {
            ChannelData* cd = &_channelData[chan];

            if (IMATH_NAMESPACE::modp (y, cd->ySampling) != 0) continue;

            rowPtrs[chan].push_back (outBufferEnd);
            outBufferEnd +=
                cd->width * OPENEXR_IMF_NAMESPACE::pixelTypeSize (cd->type);
        }
    }

    //
    // Setup to decode each block of 3 channels that need to
    // be handled together
    //

    for (unsigned int csc = 0; csc < _cscSets.size (); ++csc)
    {
        int rChan = _cscSets[csc].idx[0];
        int gChan = _cscSets[csc].idx[1];
        int bChan = _cscSets[csc].idx[2];

        if (_channelData[rChan].compression != LOSSY_DCT ||
            _channelData[gChan].compression != LOSSY_DCT ||
            _channelData[bChan].compression != LOSSY_DCT)
        {
            throw IEX_NAMESPACE::BaseExc ("Bad DWA compression type detected");
        }

        LossyDctDecoderCsc decoder (
            rowPtrs[rChan],
            rowPtrs[gChan],
            rowPtrs[bChan],
            packedAcBufferEnd,
            packedAcBufferEnd +
                totalAcUncompressedCount * sizeof (unsigned short),
            packedDcBufferEnd,
            dwaCompressorToLinear,
            _channelData[rChan].width,
            _channelData[rChan].height,
            _channelData[rChan].type,
            _channelData[gChan].type,
            _channelData[bChan].type);

        decoder.execute ();

        packedAcBufferEnd +=
            decoder.numAcValuesEncoded () * sizeof (unsigned short);

        packedDcBufferEnd +=
            decoder.numDcValuesEncoded () * sizeof (unsigned short);

        decodedChannels[rChan] = true;
        decodedChannels[gChan] = true;
        decodedChannels[bChan] = true;
    }

    //
    // Setup to handle the remaining channels by themselves
    //

    for (unsigned int chan = 0; chan < _channelData.size (); ++chan)
    {
        if (decodedChannels[chan]) continue;

        ChannelData* cd = &_channelData[chan];
        int pixelSize   = OPENEXR_IMF_NAMESPACE::pixelTypeSize (cd->type);

        switch (cd->compression)
        {
            case LOSSY_DCT:

                //
                // Setup a single-channel lossy DCT decoder pointing
                // at the output buffer
                //

                {
                    const unsigned short* linearLut = 0;

                    if (!cd->pLinear) linearLut = dwaCompressorToLinear;

                    LossyDctDecoder decoder (
                        rowPtrs[chan],
                        packedAcBufferEnd,
                        packedAcBufferEnd +
                            totalAcUncompressedCount * sizeof (unsigned short),
                        packedDcBufferEnd,
                        linearLut,
                        cd->width,
                        cd->height,
                        cd->type);

                    decoder.execute ();

                    packedAcBufferEnd +=
                        decoder.numAcValuesEncoded () * sizeof (unsigned short);

                    packedDcBufferEnd +=
                        decoder.numDcValuesEncoded () * sizeof (unsigned short);
                }

                break;

            case RLE:

                //
                // For the RLE case, the data has been un-RLE'd into
                // planarUncRleEnd[], but is still split out by bytes.
                // We need to rearrange the bytes back into the correct
                // order in the output buffer;
                //

                {
                    int row = 0;

                    for (int y = minY; y <= maxY; ++y)
                    {
                        if (IMATH_NAMESPACE::modp (y, cd->ySampling) != 0)
                            continue;

                        char* dst = rowPtrs[chan][row];

                        if (pixelSize == 2)
                        {
                            interleaveByte2 (
                                dst,
                                cd->planarUncRleEnd[0],
                                cd->planarUncRleEnd[1],
                                cd->width);

                            cd->planarUncRleEnd[0] += cd->width;
                            cd->planarUncRleEnd[1] += cd->width;
                        }
                        else
                        {
                            for (int x = 0; x < cd->width; ++x)
                            {
                                for (int byte = 0; byte < pixelSize; ++byte)
                                {
                                    *dst++ = *cd->planarUncRleEnd[byte]++;
                                }
                            }
                        }

                        row++;
                    }
                }

                break;

            case UNKNOWN:

                //
                // In the UNKNOWN case, data is already in planarUncBufferEnd
                // and just needs to copied over to the output buffer
                //

                {
                    int row = 0;
                    int dstScanlineSize =
                        cd->width *
                        OPENEXR_IMF_NAMESPACE::pixelTypeSize (cd->type);

                    for (int y = minY; y <= maxY; ++y)
                    {
                        if (IMATH_NAMESPACE::modp (y, cd->ySampling) != 0)
                            continue;

                        //
                        // sanity check for buffer data lying within range
                        //
                        if ((cd->planarUncBufferEnd +
                             static_cast<size_t> (dstScanlineSize)) >
                            (_planarUncBuffer[UNKNOWN] +
                             _planarUncBufferSize[UNKNOWN]))
                        {
                            throw IEX_NAMESPACE::InputExc ("DWA data corrupt");
                        }

                        memcpy (
                            rowPtrs[chan][row],
                            cd->planarUncBufferEnd,
                            dstScanlineSize);

                        cd->planarUncBufferEnd += dstScanlineSize;
                        row++;
                    }
                }

                break;

            default:

                throw IEX_NAMESPACE::NoImplExc (
                    "Unhandled compression scheme case");
                break;
        }

        decodedChannels[chan] = true;
    }

    //
    // Return a ptr to _outBuffer
    //

    outPtr = _outBuffer;
    return (int) (outBufferEnd - _outBuffer);
}

// the below code fragment can be found in:
// src/lib/OpenEXRCore/internal_dwa_compressor.h
exr_result_t
DwaCompressor_initializeBuffers (DwaCompressor* me, size_t* bufferSize)
{
    exr_result_t rv = EXR_ERR_SUCCESS;

    //
    // _outBuffer needs to be big enough to hold all our
    // compressed data - which could vary depending on what sort
    // of channels we have.
    //

    uint64_t maxOutBufferSize  = 0;
    uint64_t numLossyDctChans  = 0;
    uint64_t unknownBufferSize = 0;
    uint64_t rleBufferSize     = 0;

    uint64_t maxLossyDctAcSize =
        (uint64_t) (ceilf ((float) me->_numScanLines / 8.0f)) *
        (uint64_t) (ceilf ((float) (me->_max[0] - me->_min[0] + 1) / 8.0f)) *
        63 * sizeof (uint16_t);

    uint64_t maxLossyDctDcSize =
        (uint64_t) (ceilf ((float) me->_numScanLines / 8.0f)) *
        (uint64_t) (ceilf ((float) (me->_max[0] - me->_min[0] + 1) / 8.0f)) *
        sizeof (uint16_t);

    uint64_t pixelCount = (uint64_t) (me->_numScanLines) *
                          (uint64_t) (me->_max[0] - me->_min[0] + 1);

    uint64_t planarUncBufferSize[NUM_COMPRESSOR_SCHEMES];

    for (int i = 0; i < NUM_COMPRESSOR_SCHEMES; ++i)
        planarUncBufferSize[i] = 0;

    for (size_t i = 0; i < me->_channelRuleCount; ++i)
    {
        maxOutBufferSize += Classifier_size (&(me->_channelRules[i]));
    }

    rv = DwaCompressor_classifyChannels (me);
    if (rv != EXR_ERR_SUCCESS) return rv;

    for (int c = 0; c < me->_numChannels; ++c)
    {
        const exr_coding_channel_info_t* curc = me->_channelData[c].chan;
        switch (me->_channelData[c].compression)
        {
            case LOSSY_DCT:

                //
                // This is the size of the number of packed
                // components, plus the requirements for
                // maximum Huffman encoding size (for STATIC_HUFFMAN)
                // or for zlib compression (for DEFLATE)
                //

                maxOutBufferSize += std_max (
                    2lu * maxLossyDctAcSize + 65536lu,
                    exr_compress_max_buffer_size (maxLossyDctAcSize));
                numLossyDctChans++;
                break;

            case RLE:
                //
                // RLE, if gone horribly wrong, could double the size
                // of the source data.
                //
                rleBufferSize +=
                    2 * pixelCount * (uint64_t) curc->bytes_per_element;

                planarUncBufferSize[RLE] +=
                    2 * pixelCount * (uint64_t) curc->bytes_per_element;
                break;

            case UNKNOWN:
                unknownBufferSize +=
                    pixelCount * (uint64_t) curc->bytes_per_element;
                planarUncBufferSize[UNKNOWN] +=
                    pixelCount * (uint64_t) curc->bytes_per_element;
                break;

            case NUM_COMPRESSOR_SCHEMES:
            default: return EXR_ERR_INVALID_ARGUMENT;
        }
    }

    //
    // Also, since the results of the RLE are packed into
    // the output buffer, we need the extra room there. But
    // we're going to zlib compress() the data we pack,
    // which could take slightly more space
    //

    maxOutBufferSize += exr_compress_max_buffer_size (rleBufferSize);

    //
    // And the same goes for the UNKNOWN data
    //

    maxOutBufferSize += exr_compress_max_buffer_size (unknownBufferSize);

    //
    // Reserve space big enough to hold the DC data
    // and include its compressed results in the size requirements
    // for our output buffer
    //

    maxOutBufferSize +=
        exr_compress_max_buffer_size (maxLossyDctDcSize * numLossyDctChans);

    //
    // We also need to reserve space at the head of the buffer to
    // write out the size of our various packed and compressed data.
    //

    maxOutBufferSize += NUM_SIZES_SINGLE * sizeof (uint64_t);

    //
    // Later, we're going to hijack outBuffer for the result of
    // both encoding and decoding. So it needs to be big enough
    // to hold either a buffers' worth of uncompressed or
    // compressed data
    //
    // For encoding, we'll need _outBuffer to hold maxOutBufferSize bytes,
    // but for decoding, we only need it to be maxScanLineSize*numScanLines.
    // Cache the max size for now, and alloc the buffer when we either
    // encode or decode.
    //

    *bufferSize = maxOutBufferSize;

    //
    // _packedAcBuffer holds the quantized DCT coefficients prior
    // to Huffman encoding
    //

    if (maxLossyDctAcSize * numLossyDctChans > me->_packedAcBufferSize)
    {
        me->_packedAcBufferSize = maxLossyDctAcSize * numLossyDctChans;
        if (me->_packedAcBuffer != NULL) me->free_fn (me->_packedAcBuffer);
        me->_packedAcBuffer = me->alloc_fn (me->_packedAcBufferSize);
        if (!me->_packedAcBuffer) return EXR_ERR_OUT_OF_MEMORY;
        memset (me->_packedAcBuffer, 0, me->_packedAcBufferSize);
    }

    //
    // _packedDcBuffer holds one quantized DCT coef per 8x8 block
    //

    if (maxLossyDctDcSize * numLossyDctChans > me->_packedDcBufferSize)
    {
        me->_packedDcBufferSize = maxLossyDctDcSize * numLossyDctChans;
        if (me->_packedDcBuffer != NULL) me->free_fn (me->_packedDcBuffer);
        me->_packedDcBuffer = me->alloc_fn (me->_packedDcBufferSize);
        if (!me->_packedDcBuffer) return EXR_ERR_OUT_OF_MEMORY;
        memset (me->_packedDcBuffer, 0, me->_packedDcBufferSize);
    }

    if (rleBufferSize > me->_rleBufferSize)
    {
        me->_rleBufferSize = rleBufferSize;
        if (me->_rleBuffer != 0) me->free_fn (me->_rleBuffer);
        me->_rleBuffer = me->alloc_fn (rleBufferSize);
        if (!me->_rleBuffer) return EXR_ERR_OUT_OF_MEMORY;
        memset (me->_rleBuffer, 0, rleBufferSize);
    }

    //
    // The planar uncompressed buffer will hold float data for LOSSY_DCT
    // compressed values, and whatever the native type is for other
    // channels. We're going to use this to hold data in a planar
    // format, as opposed to the native interleaved format we take
    // into compress() and give back from uncompress().
    //
    // This also makes it easier to compress the UNKNOWN and RLE data
    // all in one swoop (for each compression scheme).
    //

    //
    // UNKNOWN data is going to be zlib compressed, which needs
    // a little extra headroom
    //

    if (planarUncBufferSize[UNKNOWN] > 0)
    {
        planarUncBufferSize[UNKNOWN] =
            exr_compress_max_buffer_size (planarUncBufferSize[UNKNOWN]);
    }

    for (int i = 0; i < NUM_COMPRESSOR_SCHEMES; ++i)
    {
        if (planarUncBufferSize[i] > me->_planarUncBufferSize[i])
        {
            me->_planarUncBufferSize[i] = planarUncBufferSize[i];
            if (me->_planarUncBuffer[i] != NULL)
                me->free_fn (me->_planarUncBuffer[i]);

            if (planarUncBufferSize[i] > SIZE_MAX)
            {
                return EXR_ERR_OUT_OF_MEMORY;
            }

            me->_planarUncBuffer[i] = me->alloc_fn (planarUncBufferSize[i]);
            if (!me->_planarUncBuffer[i]) return EXR_ERR_OUT_OF_MEMORY;
        }
    }

    return rv;
}

// the below code fragment can be found in:
// src/lib/OpenEXR/ImfDwaCompressor.cpp
int
DwaCompressor::compress (
    const char*            inPtr,
    int                    inSize,
    IMATH_NAMESPACE::Box2i range,
    const char*&           outPtr)
{
    const char* inDataPtr   = inPtr;
    char*       packedAcEnd = 0;
    char*       packedDcEnd = 0;
    int         fileVersion = 2; // Starting with 2, we write the channel
                                 // classification rules into the file

    if (fileVersion < 2)
        initializeLegacyChannelRules ();
    else
        initializeDefaultChannelRules ();

    size_t outBufferSize = 0;
    initializeBuffers (outBufferSize);

    unsigned short          channelRuleSize = 0;
    std::vector<Classifier> channelRules;
    if (fileVersion >= 2)
    {
        relevantChannelRules (channelRules);

        channelRuleSize = Xdr::size<unsigned short> ();
        for (size_t i = 0; i < channelRules.size (); ++i)
            channelRuleSize += channelRules[i].size ();
    }

    //
    // Remember to allocate _outBuffer, if we haven't done so already.
    //

    outBufferSize += channelRuleSize;
    if (outBufferSize > _outBufferSize)
    {
        _outBufferSize = outBufferSize;
        if (_outBuffer != 0) delete[] _outBuffer;
        _outBuffer = new char[outBufferSize];
    }

    char* outDataPtr =
        &_outBuffer[NUM_SIZES_SINGLE * sizeof (uint64_t) + channelRuleSize];

    //
    // We might not be dealing with any color data, in which
    // case the AC buffer size will be 0, and dereferencing
    // a vector will not be a good thing to do.
    //

    if (_packedAcBuffer) packedAcEnd = _packedAcBuffer;

    if (_packedDcBuffer) packedDcEnd = _packedDcBuffer;

#define OBIDX(x) (uint64_t*) &_outBuffer[x * sizeof (uint64_t)]

    uint64_t* version                 = OBIDX (VERSION);
    uint64_t* unknownUncompressedSize = OBIDX (UNKNOWN_UNCOMPRESSED_SIZE);
    uint64_t* unknownCompressedSize   = OBIDX (UNKNOWN_COMPRESSED_SIZE);
    uint64_t* acCompressedSize        = OBIDX (AC_COMPRESSED_SIZE);
    uint64_t* dcCompressedSize        = OBIDX (DC_COMPRESSED_SIZE);
    uint64_t* rleCompressedSize       = OBIDX (RLE_COMPRESSED_SIZE);
    uint64_t* rleUncompressedSize     = OBIDX (RLE_UNCOMPRESSED_SIZE);
    uint64_t* rleRawSize              = OBIDX (RLE_RAW_SIZE);

    uint64_t* totalAcUncompressedCount = OBIDX (AC_UNCOMPRESSED_COUNT);
    uint64_t* totalDcUncompressedCount = OBIDX (DC_UNCOMPRESSED_COUNT);

    uint64_t* acCompression = OBIDX (AC_COMPRESSION);

    int minX = range.min.x;
    int maxX = std::min (range.max.x, _max[0]);
    int minY = range.min.y;
    int maxY = std::min (range.max.y, _max[1]);

    //
    // Zero all the numbers in the chunk header
    //

    memset (_outBuffer, 0, NUM_SIZES_SINGLE * sizeof (uint64_t));

    //
    // Setup the AC compression strategy and the version in the data block,
    // then write the relevant channel classification rules if needed
    //
    *version       = fileVersion;
    *acCompression = _acCompression;

    setupChannelData (minX, minY, maxX, maxY);

    if (fileVersion >= 2)
    {
        char* writePtr = &_outBuffer[NUM_SIZES_SINGLE * sizeof (uint64_t)];
        Xdr::write<CharPtrIO> (writePtr, channelRuleSize);

        for (size_t i = 0; i < channelRules.size (); ++i)
            channelRules[i].write (writePtr);
    }

    //
    // Determine the start of each row in the input buffer
    // Channels are interleaved by scanline
    //

    std::vector<bool> encodedChannels (_channelData.size ());
    std::vector<std::vector<const char*>> rowPtrs (_channelData.size ());

    for (unsigned int chan = 0; chan < _channelData.size (); ++chan)
        encodedChannels[chan] = false;

    inDataPtr = inPtr;

    for (int y = minY; y <= maxY; ++y)
    {
        for (unsigned int chan = 0; chan < _channelData.size (); ++chan)
        {

            ChannelData* cd = &_channelData[chan];

            if (IMATH_NAMESPACE::modp (y, cd->ySampling) != 0) continue;

            rowPtrs[chan].push_back (inDataPtr);
            inDataPtr +=
                cd->width * OPENEXR_IMF_NAMESPACE::pixelTypeSize (cd->type);
        }
    }

    inDataPtr = inPtr;

    //
    // Make a pass over all our CSC sets and try to encode them first
    //

    for (unsigned int csc = 0; csc < _cscSets.size (); ++csc)
    {

        LossyDctEncoderCsc encoder (
            _dwaCompressionLevel / 100000.f,
            rowPtrs[_cscSets[csc].idx[0]],
            rowPtrs[_cscSets[csc].idx[1]],
            rowPtrs[_cscSets[csc].idx[2]],
            packedAcEnd,
            packedDcEnd,
            dwaCompressorToNonlinear,
            _channelData[_cscSets[csc].idx[0]].width,
            _channelData[_cscSets[csc].idx[0]].height,
            _channelData[_cscSets[csc].idx[0]].type,
            _channelData[_cscSets[csc].idx[1]].type,
            _channelData[_cscSets[csc].idx[2]].type);

        encoder.execute ();

        *totalAcUncompressedCount += encoder.numAcValuesEncoded ();
        *totalDcUncompressedCount += encoder.numDcValuesEncoded ();

        packedAcEnd += encoder.numAcValuesEncoded () * sizeof (unsigned short);
        packedDcEnd += encoder.numDcValuesEncoded () * sizeof (unsigned short);

        encodedChannels[_cscSets[csc].idx[0]] = true;
        encodedChannels[_cscSets[csc].idx[1]] = true;
        encodedChannels[_cscSets[csc].idx[2]] = true;
    }

    for (unsigned int chan = 0; chan < _channelData.size (); ++chan)
    {
        ChannelData* cd = &_channelData[chan];

        if (encodedChannels[chan]) continue;

        switch (cd->compression)
        {
            case LOSSY_DCT:

                //
                // For LOSSY_DCT, treat this just like the CSC'd case,
                // but only operate on one channel
                //

                {
                    const unsigned short* nonlinearLut = 0;

                    if (!cd->pLinear) nonlinearLut = dwaCompressorToNonlinear;

                    LossyDctEncoder encoder (
                        _dwaCompressionLevel / 100000.f,
                        rowPtrs[chan],
                        packedAcEnd,
                        packedDcEnd,
                        nonlinearLut,
                        cd->width,
                        cd->height,
                        cd->type);

                    encoder.execute ();

                    *totalAcUncompressedCount += encoder.numAcValuesEncoded ();
                    *totalDcUncompressedCount += encoder.numDcValuesEncoded ();

                    packedAcEnd +=
                        encoder.numAcValuesEncoded () * sizeof (unsigned short);

                    packedDcEnd +=
                        encoder.numDcValuesEncoded () * sizeof (unsigned short);
                }

                break;

            case RLE:

                //
                // For RLE, bash the bytes up so that the first bytes of each
                // pixel are contiguous, as are the second bytes, and so on.
                //

                for (unsigned int y = 0; y < rowPtrs[chan].size (); ++y)
                {
                    const char* row = rowPtrs[chan][y];

                    for (int x = 0; x < cd->width; ++x)
                    {
                        for (int byte = 0;
                             byte <
                             OPENEXR_IMF_NAMESPACE::pixelTypeSize (cd->type);
                             ++byte)
                        {

                            *cd->planarUncRleEnd[byte]++ = *row++;
                        }
                    }

                    *rleRawSize +=
                        cd->width *
                        OPENEXR_IMF_NAMESPACE::pixelTypeSize (cd->type);
                }

                break;

            case UNKNOWN:

                //
                // Otherwise, just copy data over verbatim
                //

                {
                    int scanlineSize =
                        cd->width *
                        OPENEXR_IMF_NAMESPACE::pixelTypeSize (cd->type);

                    for (unsigned int y = 0; y < rowPtrs[chan].size (); ++y)
                    {
                        memcpy (
                            cd->planarUncBufferEnd,
                            rowPtrs[chan][y],
                            scanlineSize);

                        cd->planarUncBufferEnd += scanlineSize;
                    }

                    *unknownUncompressedSize += cd->planarUncSize;
                }

                break;

            default: assert (false);
        }

        encodedChannels[chan] = true;
    }

    //
    // Pack the Unknown data into the output buffer first. Instead of
    // just copying it uncompressed, try zlib compression at least.
    //

    if (*unknownUncompressedSize > 0)
    {
        size_t outSize;
        if (EXR_ERR_SUCCESS != exr_compress_buffer(
                nullptr,
                9, // TODO: use default??? the old call to zlib had 9 hardcoded
                _planarUncBuffer[UNKNOWN],
                *unknownUncompressedSize,
                outDataPtr,
                exr_compress_max_buffer_size (*unknownUncompressedSize),
                &outSize))
        {
            throw IEX_NAMESPACE::BaseExc ("Data compression (zlib) failed.");
        }

        outDataPtr += outSize;
        *unknownCompressedSize = outSize;
    }

    //
    // Now, pack all the Lossy DCT coefficients into our output
    // buffer, with Huffman encoding.
    //
    // Also, record the compressed size and the number of
    // uncompressed componentns we have.
    //

    if (*totalAcUncompressedCount > 0)
    {
        switch (_acCompression)
        {
            case STATIC_HUFFMAN:

                *acCompressedSize = (int) hufCompress (
                    (unsigned short*) _packedAcBuffer,
                    (int) *totalAcUncompressedCount,
                    outDataPtr);
                break;

            case DEFLATE:

            {
                size_t sourceLen = *totalAcUncompressedCount * sizeof (unsigned short);
                size_t destLen;
                if (EXR_ERR_SUCCESS != exr_compress_buffer(
                        nullptr,
                        9, // TODO: use default??? the old call to zlib had 9 hardcoded
                        _packedAcBuffer,
                        sourceLen,
                        outDataPtr,
                        exr_compress_max_buffer_size (sourceLen),
                        &destLen))
                {
                    throw IEX_NAMESPACE::InputExc (
                        "Data compression (zlib) failed.");
                }

                *acCompressedSize = destLen;
            }

            break;

            default: assert (false);
        }

        outDataPtr += *acCompressedSize;
    }

    //
    // Handle the DC components separately
    //

    if (*totalDcUncompressedCount > 0)
    {
        *dcCompressedSize = _zip->compress (
            _packedDcBuffer,
            (int) (*totalDcUncompressedCount) * sizeof (unsigned short),
            outDataPtr);

        outDataPtr += *dcCompressedSize;
    }

    //
    // If we have RLE data, first RLE encode it and set the uncompressed
    // size. Then, deflate the results and set the compressed size.
    //

    if (*rleRawSize > 0)
    {
        *rleUncompressedSize = rleCompress (
            (int) (*rleRawSize),
            _planarUncBuffer[RLE],
            (signed char*) _rleBuffer);

        size_t dstLen;
        if (EXR_ERR_SUCCESS != exr_compress_buffer(
                nullptr,
                9, // TODO: use default??? the old call to zlib had 9 hardcoded
                _rleBuffer,
                *rleUncompressedSize,
                outDataPtr,
                exr_compress_max_buffer_size (*rleUncompressedSize),
                &dstLen))
        {
            throw IEX_NAMESPACE::BaseExc ("Error compressing RLE'd data.");
        }

        *rleCompressedSize = dstLen;
        outDataPtr += *rleCompressedSize;
    }

    //
    // Flip the counters to XDR format
    //

    for (int i = 0; i < NUM_SIZES_SINGLE; ++i)
    {
        uint64_t src = *(((uint64_t*) _outBuffer) + i);
        char*    dst = (char*) (((uint64_t*) _outBuffer) + i);

        Xdr::write<CharPtrIO> (dst, src);
    }

    //
    // We're done - compute the number of bytes we packed
    //

    outPtr = _outBuffer;

    return static_cast<int> (outDataPtr - _outBuffer);
}

// the below code fragment can be found in:
// src/lib/OpenEXR/ImfDwaCompressor.cpp
void
DwaCompressor::initializeBuffers (size_t& outBufferSize)
{
    classifyChannels (_channels, _channelData, _cscSets);

    //
    // _outBuffer needs to be big enough to hold all our
    // compressed data - which could vary depending on what sort
    // of channels we have.
    //

    uint64_t maxOutBufferSize  = 0;
    uint64_t numLossyDctChans  = 0;
    uint64_t unknownBufferSize = 0;
    uint64_t rleBufferSize     = 0;

    uint64_t maxLossyDctAcSize =
        static_cast<uint64_t> (ceil ((float) numScanLines () / 8.0f)) *
        static_cast<uint64_t> (ceil ((float) (_max[0] - _min[0] + 1) / 8.0f)) *
        63 * sizeof (unsigned short);

    uint64_t maxLossyDctDcSize =
        static_cast<uint64_t> (ceil ((float) numScanLines () / 8.0f)) *
        static_cast<uint64_t> (ceil ((float) (_max[0] - _min[0] + 1) / 8.0f)) *
        sizeof (unsigned short);

    uint64_t pixelCount = static_cast<uint64_t> (numScanLines ()) *
                          static_cast<uint64_t> (_max[0] - _min[0] + 1);

    for (unsigned int chan = 0; chan < _channelData.size (); ++chan)
    {
        switch (_channelData[chan].compression)
        {
            case LOSSY_DCT:

                //
                // This is the size of the number of packed
                // components, plus the requirements for
                // maximum Huffman encoding size (for STATIC_HUFFMAN)
                // or for zlib compression (for DEFLATE)
                //

                maxOutBufferSize += std::max (
                    2lu * maxLossyDctAcSize + 65536lu,
                    static_cast<uint64_t> (exr_compress_max_buffer_size (maxLossyDctAcSize)));
                numLossyDctChans++;
                break;

            case RLE: {
                //
                // RLE, if gone horribly wrong, could double the size
                // of the source data.
                //

                uint64_t rleAmount = 2 * pixelCount *
                                     OPENEXR_IMF_NAMESPACE::pixelTypeSize (
                                         _channelData[chan].type);

                rleBufferSize += rleAmount;
            }
            break;

            case UNKNOWN:

                unknownBufferSize +=
                    pixelCount * OPENEXR_IMF_NAMESPACE::pixelTypeSize (
                                     _channelData[chan].type);
                break;

            default:

                throw IEX_NAMESPACE::NoImplExc (
                    "Unhandled compression scheme case");
                break;
        }
    }

    //
    // Also, since the results of the RLE are packed into
    // the output buffer, we need the extra room there. But
    // we're going to zlib compress() the data we pack,
    // which could take slightly more space
    //

    maxOutBufferSize += static_cast<uint64_t> (exr_compress_max_buffer_size (rleBufferSize));

    //
    // And the same goes for the UNKNOWN data
    //

    maxOutBufferSize +=
        static_cast<uint64_t> (exr_compress_max_buffer_size (unknownBufferSize));

    //
    // Allocate a zip/deflate compressor big enough to hold the DC data
    // and include its compressed results in the size requirements
    // for our output buffer
    //

    if (_zip == 0)
        _zip = new Zip (maxLossyDctDcSize * numLossyDctChans, _zipLevel);
    else if (
        _zip->maxRawSize () <
        static_cast<size_t> (maxLossyDctDcSize * numLossyDctChans))
    {
        delete _zip;
        _zip = new Zip (maxLossyDctDcSize * numLossyDctChans, _zipLevel);
    }

    maxOutBufferSize += _zip->maxCompressedSize ();

    //
    // We also need to reserve space at the head of the buffer to
    // write out the size of our various packed and compressed data.
    //

    maxOutBufferSize += NUM_SIZES_SINGLE * sizeof (uint64_t);

    //
    // Later, we're going to hijack outBuffer for the result of
    // both encoding and decoding. So it needs to be big enough
    // to hold either a buffers' worth of uncompressed or
    // compressed data
    //
    // For encoding, we'll need _outBuffer to hold maxOutBufferSize bytes,
    // but for decoding, we only need it to be maxScanLineSize*numScanLines.
    // Cache the max size for now, and alloc the buffer when we either
    // encode or decode.
    //

    outBufferSize = maxOutBufferSize;

    //
    // _packedAcBuffer holds the quantized DCT coefficients prior
    // to Huffman encoding
    //

    if (maxLossyDctAcSize * numLossyDctChans > _packedAcBufferSize)
    {
        _packedAcBufferSize = maxLossyDctAcSize * numLossyDctChans;
        if (_packedAcBuffer != 0) delete[] _packedAcBuffer;
        _packedAcBuffer = new char[_packedAcBufferSize];
    }

    //
    // _packedDcBuffer holds one quantized DCT coef per 8x8 block
    //

    if (maxLossyDctDcSize * numLossyDctChans > _packedDcBufferSize)
    {
        _packedDcBufferSize = maxLossyDctDcSize * numLossyDctChans;
        if (_packedDcBuffer != 0) delete[] _packedDcBuffer;
        _packedDcBuffer = new char[_packedDcBufferSize];
    }

    if (rleBufferSize > _rleBufferSize)
    {
        _rleBufferSize = rleBufferSize;
        if (_rleBuffer != 0) delete[] _rleBuffer;
        _rleBuffer = new char[rleBufferSize];
    }

    //
    // The planar uncompressed buffer will hold float data for LOSSY_DCT
    // compressed values, and whatever the native type is for other
    // channels. We're going to use this to hold data in a planar
    // format, as opposed to the native interleaved format we take
    // into compress() and give back from uncompress().
    //
    // This also makes it easier to compress the UNKNOWN and RLE data
    // all in one swoop (for each compression scheme).
    //

    uint64_t planarUncBufferSize[NUM_COMPRESSOR_SCHEMES];
    for (int i = 0; i < NUM_COMPRESSOR_SCHEMES; ++i)
        planarUncBufferSize[i] = 0;

    for (unsigned int chan = 0; chan < _channelData.size (); ++chan)
    {
        switch (_channelData[chan].compression)
        {
            case LOSSY_DCT: break;

            case RLE:
                planarUncBufferSize[RLE] +=
                    pixelCount * OPENEXR_IMF_NAMESPACE::pixelTypeSize (
                                     _channelData[chan].type);
                break;

            case UNKNOWN:
                planarUncBufferSize[UNKNOWN] +=
                    pixelCount * OPENEXR_IMF_NAMESPACE::pixelTypeSize (
                                     _channelData[chan].type);
                break;

            default:
                throw IEX_NAMESPACE::NoImplExc (
                    "Unhandled compression scheme case");
                break;
        }
    }

    //
    // UNKNOWN data is going to be zlib compressed, which needs
    // a little extra headroom
    //

    if (planarUncBufferSize[UNKNOWN] > 0)
    {
        planarUncBufferSize[UNKNOWN] = static_cast<uint64_t> (
            exr_compress_max_buffer_size (planarUncBufferSize[UNKNOWN]));
    }

    for (int i = 0; i < NUM_COMPRESSOR_SCHEMES; ++i)
    {
        if (planarUncBufferSize[i] > _planarUncBufferSize[i])
        {
            _planarUncBufferSize[i] = planarUncBufferSize[i];
            if (_planarUncBuffer[i] != 0) delete[] _planarUncBuffer[i];

            if (planarUncBufferSize[i] > std::numeric_limits<size_t>::max ())
            {
                throw IEX_NAMESPACE::ArgExc ("DWA buffers too large");
            }

            _planarUncBuffer[i] = new char[planarUncBufferSize[i]];
        }
    }
}
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).