/* Check and update channel rules based on the version. */
    if (version < 2)
    {
        /* Versions 0 and 1 use the legacy classification rules. */
        me->_channelRules = sLegacyChannelRules;
        me->_channelRuleCount =
            (sizeof (sLegacyChannelRules) / sizeof (Classifier));
    }
    else
    {
        /* Version 2 introduces the default classification rules
           plus a block of channel rule data to skip. */
        me->_channelRules = sDefaultChannelRules;
        me->_channelRuleCount =
            (sizeof (sDefaultChannelRules) / sizeof (Classifier));

        /* Read and skip the channel-rules block size. */
        if (dataLeft < 2) { return EXR_ERR_CORRUPT_CHUNK; }
        uint16_t ruleSize = (uint16_t)((dataPtr[0] << 8) | dataPtr[1]);
        dataPtr += 2;
        dataLeft -= 2;

        if (ruleSize < 2) { return EXR_ERR_CORRUPT_CHUNK; }
        ruleSize -= 2;
        if (ruleSize > dataLeft) { return EXR_ERR_CORRUPT_CHUNK; }

        /* Skip the channel-rules block. */
        dataPtr += ruleSize;
        dataLeft -= ruleSize;
    }

    /* Initialize buffers and prepare for decompression. */
    rv = DwaCompressor_initializeBuffers (me, &outBufferSize);
    if (rv != EXR_ERR_SUCCESS) { return rv; }

    /* Adjust pointers for the various compressed data sections. */
    compressedSize = unknownCompressedSize + acCompressedSize +
                     dcCompressedBytes + rleCompressedSize;
    dataPtr += headerSize;
    dataLeft = iSize - headerSize;

    compressedUnknownBuf = dataPtr;
    compressedAcBuf      = compressedUnknownBuf + unknownCompressedSize;
    compressedDcBuf      = compressedAcBuf + acCompressedSize;
    compressedRleBuf     = compressedDcBuf + dcCompressedBytes;