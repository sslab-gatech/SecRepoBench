// Verify input size is at least large enough for the header
    if (iSize < headerSize) { return EXR_ERR_CORRUPT_CHUNK; }

    // Copy header data, then convert from XDR/Big-Endian to native
    memcpy (counters, inPtr, headerSize);
    for (int i = 0; i < NUM_SIZES_SINGLE; ++i)
        counters[i] = one_from_native64 (counters[i]);

    // Extract fields from the header counters
    version                 = counters[0];
    unknownUncompressedSize = counters[1];
    unknownCompressedSize   = counters[2];
    acCompressedSize        = counters[3];
    dcCompressedBytes       = counters[4];
    rleCompressedSize       = counters[5];
    rleUncompressedSize     = counters[6];
    rleRawSize              = counters[7];
    totalAcUncompressedCount= counters[8];
    totalDcUncompressedCount= counters[9];
    acCompression           = counters[10];

    // Calculate total compressed data size and verify
    compressedSize = unknownCompressedSize + acCompressedSize +
                     dcCompressedBytes + rleCompressedSize;
    if (compressedSize > (iSize - headerSize)) { return EXR_ERR_CORRUPT_CHUNK; }

    // Adjust pointers past the header
    dataPtr  = inPtr + headerSize;
    dataLeft = iSize - headerSize;

    // Assign pointers for the compressed data sections
    const uint8_t* compressedUnknownBuf = dataPtr;
    dataPtr += unknownCompressedSize;

    const uint8_t* compressedAcBuf = dataPtr;
    dataPtr += acCompressedSize;

    const uint8_t* compressedDcBuf = dataPtr;
    dataPtr += dcCompressedBytes;

    const uint8_t* compressedRleBuf = dataPtr;
    dataPtr += rleCompressedSize;

    // Initialize output pointers
    outBufferEnd      = (uint8_t*) uncompressed_data;
    packedAcBufferEnd = me->_packedAcBuffer;
    packedDcBufferEnd = me->_packedDcBuffer;