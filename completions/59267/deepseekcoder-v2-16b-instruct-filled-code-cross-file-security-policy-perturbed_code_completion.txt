// Define pointers for compressed data sections: UNKNOWN, AC, DC, and RLE.
    const uint8_t* compressedUnknownBuf = inPtr + headerSize;
    const uint8_t* compressedAcBuf = compressedUnknownBuf + unknownCompressedSize;
    const uint8_t* compressedDcBuf = compressedAcBuf + acCompressedSize;
    const uint8_t* compressedRleBuf = compressedDcBuf + dcCompressedBytes;

    // Verify that the input size is adequate for the expected header size.
    if (iSize < headerSize) {
        return EXR_ERR_CORRUPT_CHUNK;
    }

    // Initialize the uncompressed data buffer to zero.
    memset(uncompressed_data, 0, uncompressed_size);

    // Copy header information into an array and convert it from XDR format to native format.
    uint64_t* header = (uint64_t*)counters;
    memcpy(header, inPtr, headerSize);
    for (uint64_t i = 0; i < NUM_SIZES_SINGLE; ++i) {
        counters[i] = ntohll(header[i]);
    }

    // Extract various sizes and counters related to compression from the header information.
    version = counters[0];
    unknownUncompressedSize = counters[1];
    unknownCompressedSize = counters[2];
    acCompressedSize = counters[3];
    dcCompressedBytes = counters[4];
    rleCompressedSize = counters[5];
    rleUncompressedSize = counters[6];
    rleRawSize = counters[7];
    totalAcUncompressedCount = counters[8];
    totalDcUncompressedCount = counters[9];
    acCompression = counters[10];

    // Calculate the total size of compressed data sections.
    uint64_t totalCompressedSize = unknownCompressedSize + acCompressedSize + dcCompressedBytes + rleCompressedSize;

    // Adjust the data pointer to skip the header and calculate the remaining data size.
    dataPtr = inPtr + headerSize;
    dataLeft = iSize - headerSize;

    // Verify that compressed data sizes do not exceed the input size to prevent overflow.
    if (totalCompressedSize > dataLeft) {
        return EXR_ERR_CORRUPT_CHUNK;
    }

    // Check version information to determine channel rules, updating them if necessary.
    if (version > 2) {
        return EXR_ERR_BAD_CHUNK_LEADER;
    }

    // Initialize buffers and allocate the output buffer for uncompressed data.
    outBufferSize = uncompressed_size;
    uint8_t* outBuffer = (uint8_t*)uncompressed_data;
    uint8_t* packedAcBufferEnd = me->_packedAcBuffer + totalAcUncompressedCount * sizeof(uint16_t);
    uint8_t* packedDcBufferEnd = me->_packedDcBuffer + totalDcUncompressedCount * sizeof(uint16_t);

    // Determine buffer pointers for AC and DC data, if available.
    // Set pointers to the start of each compressed data section: UNKNOWN, AC, DC, and RLE.
    // <MASK>