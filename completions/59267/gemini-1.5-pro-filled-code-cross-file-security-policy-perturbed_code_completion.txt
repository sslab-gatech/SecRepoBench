if (iSize < headerSize) return EXR_ERR_CORRUPT_CHUNK;

    memset (uncompressed_data, 0, uncompressed_size);

    //
    // Copy header information into an array and convert from XDR
    //

    memcpy (counters, inPtr, headerSize);
    for (int i = 0; i < NUM_SIZES_SINGLE; ++i)
        counters[i] = one_from_native64 (counters[i]);

    version               = counters[VERSION];
    unknownUncompressedSize = counters[UNKNOWN_UNCOMPRESSED_SIZE];
    unknownCompressedSize   = counters[UNKNOWN_COMPRESSED_SIZE];
    acCompressedSize        = counters[AC_COMPRESSED_BYTES];
    dcCompressedBytes       = counters[DC_COMPRESSED_BYTES];
    rleCompressedSize       = counters[RLE_COMPRESSED_BYTES];
    rleUncompressedSize     = counters[RLE_UNCOMPRESSED_BYTES];
    rleRawSize             = counters[RLE_UNCOMPRESSED_RAW_SIZE];
    totalAcUncompressedCount = counters[TOTAL_AC_UNCOMPRESSED_COUNT];
    totalDcUncompressedCount = counters[TOTAL_DC_UNCOMPRESSED_COUNT];
    acCompression           = counters[AC_COMPRESSION];

    compressedSize =
        unknownCompressedSize + acCompressedSize + dcCompressedBytes +
        rleCompressedSize;

    dataPtr  = inPtr + headerSize;
    dataLeft = iSize - headerSize;

    if (dataLeft < compressedSize) { return EXR_ERR_CORRUPT_CHUNK; }

    // Check version information to determine channel rules
    if (version >= 2)
    {
        uint64_t nWritten = 0;
        uint16_t ruleSize = one_from_native16 (*((uint16_t*) dataPtr));

        if (dataLeft < ruleSize) return EXR_ERR_CORRUPT_CHUNK;

        rv = DwaCompressor_readChannelRules (
            me, &dataPtr, dataLeft, &nWritten, ruleSize);

        if (rv != EXR_ERR_SUCCESS) return rv;

        dataLeft -= nWritten;
    }

    outBufferSize = uncompressed_size;
    outBufferEnd = (uint8_t*) uncompressed_data + outBufferSize;

    // Determine buffer pointers for AC and DC data, if available
    packedAcBufferEnd = me->_packedAcBuffer;
    packedDcBufferEnd = me->_packedDcBuffer;

    const uint8_t* compressedUnknownBuf = dataPtr;
    dataPtr += unknownCompressedSize;

    const uint8_t* compressedAcBuf = dataPtr;
    dataPtr += acCompressedSize;

    const uint8_t* compressedDcBuf = dataPtr;
    dataPtr += dcCompressedBytes;

    const uint8_t* compressedRleBuf = dataPtr;
    dataPtr += rleCompressedSize;

    if (dataPtr > inPtr + iSize)
    {
        return EXR_ERR_CORRUPT_CHUNK;
    }