// Define pointers for compressed data sections: UNKNOWN, AC, DC, and RLE.
const uint8_t* compressedUnknownBuf;
const uint8_t* compressedAcBuf;
const uint8_t* compressedDcBuf;
const uint8_t* compressedRleBuf;

// Verify that the input size is adequate for the expected header size.
if (iSize < headerSize)
{
    return EXR_ERR_CORRUPT_CHUNK;
}

// Initialize the uncompressed data buffer to zero.
if (uncompressed_data && uncompressed_size > 0)
    memset(uncompressed_data, 0, uncompressed_size);

// Copy header information into an array and convert it from XDR format to native format.
memcpy(counters, inPtr, headerSize);

for (int i = 0; i < NUM_SIZES_SINGLE; ++i)
{
    counters[i] = one_to_native64(counters[i]);
}

// Extract various sizes and counters related to compression from the header information.
version                 = counters[0];
unknownUncompressedSize = counters[1];
unknownCompressedSize   = counters[2];
acCompressedSize        = counters[3];
dcCompressedBytes       = counters[4];
rleCompressedSize       = counters[5];
rleUncompressedSize     = counters[6];
rleRawSize              = counters[7];

acCompression          = counters[8];
totalAcUncompressedCount = counters[9];
totalDcUncompressedCount = counters[10];

// Calculate the total size of compressed data sections.
compressedSize = unknownCompressedSize + acCompressedSize + 
                 dcCompressedBytes + rleCompressedSize;

// Adjust the data pointer to skip the header and calculate the remaining data size.
dataPtr = inPtr + headerSize;
dataLeft = iSize - headerSize;

// Verify that compressed data sizes do not exceed the input size to prevent overflow.
if (compressedSize > dataLeft) 
{
    return EXR_ERR_CORRUPT_CHUNK;
}

// Check version information to determine channel rules, updating them if necessary.
if (version == 2)
{
    uint16_t ruleSize;
    
    if (dataLeft < sizeof(uint16_t))
    {
        return EXR_ERR_CORRUPT_CHUNK;
    }
    
    ruleSize = one_to_native16(*((const uint16_t *)dataPtr));
    
    // Make sure the rule size is reasonable and doesn't exceed the data we have left
    if (ruleSize < 2 || ruleSize > dataLeft)
    {
        return EXR_ERR_CORRUPT_CHUNK;
    }
    
    // Skip past the rule data
    dataPtr += ruleSize;
    dataLeft -= ruleSize;
    
    // Re-verify compressed size after skipping rules
    if (compressedSize > dataLeft)
    {
        return EXR_ERR_CORRUPT_CHUNK;
    }
}

// Initialize buffers for uncompressed data.
outBufferSize = uncompressed_size;
outBufferEnd = (uint8_t*)uncompressed_data;

// Set pointers to the start of each compressed data section: UNKNOWN, AC, DC, and RLE.
compressedUnknownBuf = dataPtr;
compressedAcBuf = compressedUnknownBuf + unknownCompressedSize;
compressedDcBuf = compressedAcBuf + acCompressedSize;
compressedRleBuf = compressedDcBuf + dcCompressedBytes;

// Determine buffer pointers for AC and DC data, if available.
packedAcBufferEnd = me->_packedAcBuffer;
packedDcBufferEnd = me->_packedDcBuffer;