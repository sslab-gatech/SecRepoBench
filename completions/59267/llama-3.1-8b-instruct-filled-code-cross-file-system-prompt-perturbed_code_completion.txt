// <MASK>

//
// Verify that the input size is adequate for the expected header size.
//

if (iSize < headerSize)
{
    return EXR_ERR_BAD_CHUNK_LEADER;
}

//
// Initialize the uncompressed data buffer to zero.
//

memset (uncompressed_data, 0, uncompressed_size);

//
// Copy header information into an array and convert it from XDR format to native format.
//

uint64_t* header = (uint64_t*) inPtr;
for (int i = 0; i < NUM_SIZES_SINGLE; ++i)
{
    me->_header[i] = one_from_native64 (header[i]);
}

//
// Extract various sizes and counters related to compression from the header information.
//

version = me->_header[VERSION];
unknownCompressedSize = me->_header[UNKNOWN_COMPRESSED_SIZE];
acCompressedSize = me->_header[AC_COMPRESSED_SIZE];
dcCompressedBytes = me->_header[DC_COMPRESSED_BYTES];
rleCompressedSize = me->_header[RLE_COMPRESSED_SIZE];
rleUncompressedSize = me->_header[RLE_UNCOMPRESSED_SIZE];
rleRawSize = me->_header[RLE_RAW_SIZE];

totalAcUncompressedCount = me->_header[TOTAL_AC_UNCOMPRESSED_COUNT];
totalDcUncompressedCount = me->_header[TOTAL_DC_UNCOMPRESSED_COUNT];

acCompression = me->_header[AC_COMPRESSION];

//
// Calculate the total size of compressed data sections.
//

compressedSize = unknownCompressedSize + acCompressedSize + dcCompressedBytes + rleCompressedSize;

//
// Adjust the data pointer to skip the header and calculate the remaining data size.
//

dataPtr = (const uint8_t*) inPtr + headerSize;
dataLeft = iSize - headerSize;

//
// Verify that compressed data sizes do not exceed the input size to prevent overflow.
//

if (compressedSize > dataLeft)
{
    return EXR_ERR_BAD_CHUNK_LEADER;
}

//
// Check version information to determine channel rules, updating them if necessary.
//

if (version > 2) { return EXR_ERR_BAD_CHUNK_LEADER; }

rv = DwaCompressor_setupChannelData (me);

//
// Initialize buffers and allocate the output buffer for uncompressed data.
//

outBufferSize = 0;
rv = DwaCompressor_initializeBuffers (me, &outBufferSize);
if (rv!= EXR_ERR_SUCCESS) return rv;

outBufferEnd = (uint8_t*) uncompressed_data;
packedAcBufferEnd = me->_packedAcBuffer;
packedDcBufferEnd = me->_packedDcBuffer;

//
// Determine buffer pointers for AC and DC data, if available.
//

if (acCompressedSize > 0)
{
    compressedAcBuf = dataPtr;
    dataPtr += acCompressedSize;
    dataLeft -= acCompressedSize;
}

if (dcCompressedBytes > 0)
{
    compressedDcBuf = dataPtr;
    dataPtr += dcCompressedBytes;
    dataLeft -= dcCompressedBytes;
}

if (rleCompressedSize > 0)
{
    compressedRleBuf = dataPtr;
    dataPtr += rleCompressedSize;
    dataLeft -= rleCompressedSize;
}

//
// Set pointers to the start of each compressed data section: UNKNOWN, AC, DC, and RLE.
//

if (unknownCompressedSize > 0)
{
    compressedUnknownBuf = dataPtr;
    dataPtr += unknownCompressedSize;
    dataLeft -= unknownCompressedSize;
}