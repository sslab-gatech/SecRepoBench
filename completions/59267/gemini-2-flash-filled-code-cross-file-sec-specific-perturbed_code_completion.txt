exr_decode_xdr_long (inPtr, &counters[0], NUM_SIZES_SINGLE);

    version               = counters[0];
    unknownUncompressedSize = counters[1];
    unknownCompressedSize   = counters[2];
    acCompressedSize      = counters[3];
    dcCompressedBytes     = counters[4];
    rleCompressedSize     = counters[5];
    rleUncompressedSize   = counters[6];
    rleRawSize            = counters[7];
    acCompression         = counters[8];

    totalAcUncompressedCount = counters[9];
    totalDcUncompressedCount = counters[10];

    compressedSize = unknownCompressedSize + acCompressedSize +
                     dcCompressedBytes + rleCompressedSize;

    dataPtr  = inPtr + headerSize;
    dataLeft = iSize - headerSize;

    if (unknownCompressedSize > dataLeft || acCompressedSize > dataLeft ||
        dcCompressedBytes > dataLeft || rleCompressedSize > dataLeft ||
        compressedSize > dataLeft)
    {
        return EXR_ERR_CORRUPT_CHUNK;
    }

    if (version > 0 && me->_channelRuleCount == 0)
    {
        me->_channelRules  = sDefaultChannelRules;
        me->_channelRuleCount =
            sizeof (sDefaultChannelRules) / sizeof (exr_attribute_desc_t);
    }

    outBufferSize = (size_t) me->_maxScanLineSize * (size_t) me->_numScanLines;

    if (outBufferSize > uncompressed_size)
    {
        return EXR_ERR_INVALID_ARGUMENT;
    }

    memset (uncompressed_data, 0, outBufferSize);

    outBufferEnd    = (uint8_t*) uncompressed_data;
    packedAcBufferEnd = (uint8_t*) me->_packedAcBuffer;
    packedDcBufferEnd = (uint8_t*) me->_packedDcBuffer;

    const uint8_t* compressedUnknownBuf = dataPtr;
    const uint8_t* compressedAcBuf      = compressedUnknownBuf + unknownCompressedSize;
    const uint8_t* compressedDcBuf      = compressedAcBuf + acCompressedSize;
    const uint8_t* compressedRleBuf = compressedDcBuf + dcCompressedBytes;