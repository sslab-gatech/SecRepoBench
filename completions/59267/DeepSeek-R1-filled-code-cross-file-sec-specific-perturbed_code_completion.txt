if (iSize < headerSize)
        return EXR_ERR_CORRUPT_CHUNK;

    memset(uncompressed_data, 0, uncompressed_size);

    memcpy(counters, inPtr, headerSize);
    for (int i = 0; i < NUM_SIZES_SINGLE; ++i)
        counters[i] = one_to_native64(counters[i]);

    version = counters[0];
    unknownUncompressedSize = counters[1];
    unknownCompressedSize = counters[2];
    acCompressedSize = counters[3];
    dcCompressedBytes = counters[4];
    rleCompressedSize = counters[5];
    rleUncompressedSize = counters[6];
    rleRawSize = counters[7];
    totalAcUncompressedCount = counters[8];
    totalDcUncompressedCount = counters[9];
    acCompression = counters[10];

    dataPtr = inPtr + headerSize;
    dataLeft = iSize - headerSize;

    if (version >= 2)
    {
        if (dataLeft < sizeof(uint16_t))
            return EXR_ERR_CORRUPT_CHUNK;
        uint16_t ruleSize = one_from_native16(*(const uint16_t*)dataPtr);
        dataPtr += sizeof(uint16_t);
        dataLeft -= sizeof(uint16_t);
        if (dataLeft < ruleSize)
            return EXR_ERR_CORRUPT_CHUNK;
        dataPtr += ruleSize;
        dataLeft -= ruleSize;
    }

    uint64_t compressedTotal = unknownCompressedSize + acCompressedSize + dcCompressedBytes + rleCompressedSize;
    if (compressedTotal > dataLeft)
        return EXR_ERR_CORRUPT_CHUNK;

    const uint8_t* compressedUnknownBuf = dataPtr;
    const uint8_t* compressedAcBuf = compressedUnknownBuf + unknownCompressedSize;
    const uint8_t* compressedDcBuf = compressedAcBuf + acCompressedSize;
    const uint8_t* compressedRleBuf = compressedDcBuf + dcCompressedBytes;

    if (compressedAcBuf < compressedUnknownBuf ||
        compressedDcBuf < compressedAcBuf ||
        compressedRleBuf < compressedDcBuf ||
        (compressedRleBuf + rleCompressedSize) > (dataPtr + dataLeft))
    {
        return EXR_ERR_CORRUPT_CHUNK;
    }

    outBufferEnd = (uint8_t*)uncompressed_data;
    packedAcBufferEnd = me->_packedAcBuffer;
    packedDcBufferEnd = me->_packedDcBuffer;