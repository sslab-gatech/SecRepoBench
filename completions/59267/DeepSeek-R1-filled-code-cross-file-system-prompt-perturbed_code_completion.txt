if (iSize < headerSize) return EXR_ERR_CORRUPT_CHUNK;

memset(uncompressed_data, 0, uncompressed_size);

memcpy(counters, inPtr, headerSize);
for (int i = 0; i < NUM_SIZES_SINGLE; ++i)
    counters[i] = one_to_native64(counters[i]);

version = counters[0];
unknownUncompressedSize = counters[1];
unknownCompressedSize = counters[2];
acCompressedSize = counters[3];
dcCompressedBytes = counters[4];
rleCompressedSize = counters[5];
rleUncompressedSize = counters[6];
rleRawSize = counters[7];
totalAcUncompressedCount = counters[8];
totalDcUncompressedCount = counters[9];
acCompression = counters[10];

dataPtr = inPtr + headerSize;
dataLeft = iSize - headerSize;

if (version >= 2)
{
    if (dataLeft < sizeof(uint16_t))
        return EXR_ERR_CORRUPT_CHUNK;
    uint16_t ruleSize = one_to_native16(*(const uint16_t*)dataPtr);
    dataPtr += sizeof(uint16_t);
    dataLeft -= sizeof(uint16_t);
    if (dataLeft < ruleSize)
        return EXR_ERR_CORRUPT_CHUNK;
    exr_result_t rv = DwaCompressor_readChannelRules(me, dataPtr, ruleSize);
    if (rv != EXR_ERR_SUCCESS)
        return rv;
    dataPtr += ruleSize;
    dataLeft -= ruleSize;
}

compressedSize = unknownCompressedSize + acCompressedSize + dcCompressedBytes + rleCompressedSize;
if (dataLeft < compressedSize)
    return EXR_ERR_CORRUPT_CHUNK;

const uint8_t* compressedUnknownBuf = dataPtr;
dataPtr += unknownCompressedSize;
const uint8_t* compressedAcBuf = dataPtr;
dataPtr += acCompressedSize;
const uint8_t* compressedDcBuf = dataPtr;
dataPtr += dcCompressedBytes;
const uint8_t* compressedRleBuf = dataPtr;
dataPtr += rleCompressedSize;

outBufferEnd = (uint8_t*)uncompressed_data;
packedAcBufferEnd = me->_packedAcBuffer;
packedDcBufferEnd = me->_packedDcBuffer;