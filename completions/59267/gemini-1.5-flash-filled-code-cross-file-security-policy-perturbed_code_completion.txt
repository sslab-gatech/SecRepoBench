compressedUnknownBuf = inPtr + headerSize;
    compressedAcBuf     = compressedUnknownBuf + unknownCompressedSize;
    compressedDcBuf     = compressedAcBuf + acCompressedSize;
    compressedRleBuf    = compressedDcBuf + dcCompressedBytes;

    //
    // Check that the compressed data sizes do not exceed the input buffer size.
    //

    if (unknownCompressedSize > iSize - headerSize ||
        acCompressedSize > iSize - headerSize - unknownCompressedSize ||
        dcCompressedBytes >
            iSize - headerSize - unknownCompressedSize - acCompressedSize ||
        rleCompressedSize >
            iSize - headerSize - unknownCompressedSize - acCompressedSize -
                dcCompressedBytes)
    {
        return EXR_ERR_CORRUPT_CHUNK;
    }

    version = one_from_native64 (counters[VERSION]);

    outBufferSize = (size_t) (me->_max[0] - me->_min[0] + 1) *
                    (size_t) (me->_max[1] - me->_min[1] + 1) *
                    (size_t) me->_numChannels * (size_t) sizeof (float);

    me->_outBuffer = (uint8_t*) me->alloc_fn (outBufferSize);
    if (!me->_outBuffer) return EXR_ERR_OUT_OF_MEMORY;

    outBufferEnd = me->_outBuffer;

    packedAcBufferEnd = me->_packedAcBuffer;
    packedDcBufferEnd = me->_packedDcBuffer;

    dataPtr  = inPtr + headerSize;
    dataLeft = iSize - headerSize;