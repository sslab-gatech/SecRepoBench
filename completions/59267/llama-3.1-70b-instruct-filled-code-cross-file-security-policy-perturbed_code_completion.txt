// Define pointers for compressed data sections: UNKNOWN, AC, DC, and RLE.
const uint8_t* compressedUnknownBuf = inPtr + headerSize;
const uint8_t* compressedAcBuf =
    compressedUnknownBuf + unknownCompressedSize;
const uint8_t* compressedDcBuf =
    compressedAcBuf + acCompressedSize;
const uint8_t* compressedRleBuf =
    compressedDcBuf + dcCompressedBytes;

// Verify that the input size is adequate for the expected header size.
if (iSize < headerSize) { return EXR_ERR_BAD_CHUNK_LEADER; }

// Initialize the uncompressed data buffer to zero.
memset(uncompressed_data, 0, uncompressed_size);

// Copy header information into an array and convert it from XDR format to native format.
memcpy(counters, inPtr, headerSize);
for (int i = 0; i < NUM_SIZES_SINGLE; ++i)
{
    counters[i] = xdr_to_native64(counters[i]);
}

// Extract various sizes and counters related to compression from the header information.
unknownUncompressedSize = counters[0];
unknownCompressedSize = counters[1];
acCompressedSize = counters[2];
dcCompressedBytes = counters[3];
rleCompressedSize = counters[4];
rleUncompressedSize = counters[5];
rleRawSize = counters[6];

totalAcUncompressedCount = counters[7];
totalDcUncompressedCount = counters[8];

acCompression = counters[9];

// Calculate the total size of compressed data sections.
compressedSize = unknownCompressedSize + acCompressedSize +
                 dcCompressedBytes + rleCompressedSize;

// Adjust the data pointer to skip the header and calculate the remaining data size.
dataPtr = inPtr + headerSize;
dataLeft = iSize - headerSize;

// Verify that compressed data sizes do not exceed the input size to prevent overflow.
if (compressedSize > dataLeft) { return EXR_ERR_BAD_CHUNK_LEADER; }

// Check version information to determine channel rules, updating them if necessary.
version = counters[10];

// Initialize buffers and allocate the output buffer for uncompressed data.
outBufferSize = uncompressed_size;
outBufferEnd = (uint8_t*) uncompressed_data;

// Determine buffer pointers for AC and DC data, if available.
packedAcBufferEnd = (uint8_t*) me->_packedAcBuffer;
packedDcBufferEnd = (uint8_t*) me->_packedDcBuffer;

// Set pointers to the start of each compressed data section: UNKNOWN, AC, DC, and RLE.
// Ensure that each pointer remains within the valid range of the input buffer.
if (compressedUnknownBuf < inPtr || compressedUnknownBuf >= inPtr + iSize)
{
    return EXR_ERR_BAD_CHUNK_LEADER;
}
if (compressedAcBuf < inPtr || compressedAcBuf >= inPtr + iSize)
{
    return EXR_ERR_BAD_CHUNK_LEADER;
}
if (compressedDcBuf < inPtr || compressedDcBuf >= inPtr + iSize)
{
    return EXR_ERR_BAD_CHUNK_LEADER;
}
if (compressedRleBuf < inPtr || compressedRleBuf >= inPtr + iSize)
{
    return EXR_ERR_BAD_CHUNK_LEADER;
}