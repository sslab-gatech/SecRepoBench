const uint8_t* compressedUnknownBuf;
const uint8_t* compressedAcBuf;
const uint8_t* compressedDcBuf;
const uint8_t* compressedRleBuf;

// Verify that the input size is adequate for the expected header size
if (iSize < headerSize) return EXR_ERR_CORRUPT_CHUNK;

// Initialize the uncompressed data buffer to zero
memset(uncompressed_data, 0, uncompressed_size);

// Copy header information into an array and convert it from XDR format to native format
memcpy(counters, inPtr, headerSize);
priv_to_native64(counters, NUM_SIZES_SINGLE);

// Extract various sizes and counters related to compression from the header information
version = counters[VERSION];
unknownUncompressedSize = counters[UNKNOWN_UNCOMPRESSED_SIZE];
unknownCompressedSize = counters[UNKNOWN_COMPRESSED_SIZE];
acCompressedSize = counters[AC_COMPRESSED_SIZE];
dcCompressedBytes = counters[DC_COMPRESSED_SIZE];
rleCompressedSize = counters[RLE_COMPRESSED_SIZE];
rleUncompressedSize = counters[RLE_UNCOMPRESSED_SIZE];
rleRawSize = counters[RLE_RAW_SIZE];
totalAcUncompressedCount = counters[AC_UNCOMPRESSED_COUNT];
totalDcUncompressedCount = counters[DC_UNCOMPRESSED_COUNT];
acCompression = counters[AC_COMPRESSION];

// Calculate the total size of compressed data sections
compressedSize = unknownCompressedSize + acCompressedSize + 
                 dcCompressedBytes + rleCompressedSize;

// Adjust the data pointer to skip the header and calculate the remaining data size
dataPtr = inPtr + headerSize;
dataLeft = iSize - headerSize;

// Verify that compressed data sizes do not exceed the input size to prevent overflow
if (dataLeft < compressedSize ||
    unknownCompressedSize > dataLeft ||
    acCompressedSize > dataLeft ||
    dcCompressedBytes > dataLeft ||
    rleCompressedSize > dataLeft)
{
    return EXR_ERR_CORRUPT_CHUNK;
}

// Check for negative values or other corruption
if ((int64_t)unknownUncompressedSize < 0 ||
    (int64_t)unknownCompressedSize < 0 ||
    (int64_t)acCompressedSize < 0 ||
    (int64_t)dcCompressedBytes < 0 ||
    (int64_t)rleCompressedSize < 0 ||
    (int64_t)rleUncompressedSize < 0 ||
    (int64_t)rleRawSize < 0 ||
    (int64_t)totalAcUncompressedCount < 0 ||
    (int64_t)totalDcUncompressedCount < 0)
{
    return EXR_ERR_CORRUPT_CHUNK;
}

// Initialize buffers and allocate the output buffer for uncompressed data
outBufferSize = uncompressed_size;
rv = DwaCompressor_initializeBuffers(me, &outBufferSize);
if (rv != EXR_ERR_SUCCESS) return rv;

// Determine buffer pointers for AC and DC data, if available
outBufferEnd = (uint8_t*)uncompressed_data;
packedAcBufferEnd = NULL;
packedDcBufferEnd = NULL;
if (me->_packedAcBuffer) packedAcBufferEnd = me->_packedAcBuffer;
if (me->_packedDcBuffer) packedDcBufferEnd = me->_packedDcBuffer;

// Set pointers to the start of each compressed data section: UNKNOWN, AC, DC, and RLE
compressedUnknownBuf = dataPtr;
compressedAcBuf = compressedUnknownBuf + unknownCompressedSize;
compressedDcBuf = compressedAcBuf + acCompressedSize;
compressedRleBuf = compressedDcBuf + dcCompressedBytes;