// <MASK>
// Define pointers for compressed data sections: UNKNOWN, AC, DC, and RLE.
const uint8_t* compressedUnknownBuf = inPtr + headerSize;
const uint8_t* compressedAcBuf = compressedUnknownBuf + unknownCompressedSize;
const uint8_t* compressedDcBuf = compressedAcBuf + acCompressedSize;
const uint8_t* compressedRleBuf = compressedDcBuf + dcCompressedBytes;

// Verify that the input size is adequate for the expected header size.
if (iSize < headerSize) {
    return EXR_ERR_CORRUPT_CHUNK;
}

// Initialize the uncompressed data buffer to zero.
memset(uncompressed_data, 0, uncompressed_size);

// Copy header information into an array and convert it from XDR format to native format.
for (int i = 0; i < NUM_SIZES_SINGLE; i++) {
    counters[i] = one_from_native64(*(uint64_t*)(inPtr + i * sizeof(uint64_t)));
}

// Extract various sizes and counters related to compression from the header information.
version = counters[0];
unknownUncompressedSize = counters[1];
unknownCompressedSize = counters[2];
acCompressedSize = counters[3];
dcCompressedBytes = counters[4];
rleCompressedSize = counters[5];
rleUncompressedSize = counters[6];
rleRawSize = counters[7];

totalAcUncompressedCount = counters[8];
totalDcUncompressedCount = counters[9];

acCompression = counters[10];

// Calculate the total size of compressed data sections.
compressedSize = headerSize + unknownCompressedSize + acCompressedSize + dcCompressedBytes + rleCompressedSize;

// Adjust the data pointer to skip the header and calculate the remaining data size.
dataPtr = inPtr + headerSize;
dataLeft = iSize - headerSize;

// Verify that compressed data sizes do not exceed the input size to prevent overflow.
if (compressedSize > iSize) {
    return EXR_ERR_CORRUPT_CHUNK;
}

// Check version information to determine channel rules, updating them if necessary.
if (version == 2) {
    rv = DwaCompressor_writeRelevantChannelRules(me, &dataPtr, dataLeft, &headerSize);
    if (rv != EXR_ERR_SUCCESS) {
        return rv;
    }
    dataLeft -= headerSize;
}

// Initialize buffers and allocate the output buffer for uncompressed data.
outBufferSize = uncompressed_size;
outBufferEnd = (uint8_t*)uncompressed_data;
packedAcBufferEnd = (uint8_t*)me->_packedAcBuffer;
packedDcBufferEnd = (uint8_t*)me->_packedDcBuffer;