// Check the type of the first primitive in the input. If the primitive type
// is not suitable for conversion, return a null pointer.
// Count the number of primitives in the input array that are not undefined,
// and use this count to allocate memory for the path information array.
// Return null if memory allocation fails.
// Initialize variables that will be used for tracking points and coordinates.
if (primitive_info == NULL || primitive_info[0].primitive == UndefinedPrimitive) {
  return NULL;
}

size_t primitive_count = 0;
for (ssize_t i = 0; primitive_info[i].primitive != UndefinedPrimitive; i++) {
  if (primitive_info[i].primitive != UndefinedPrimitive) {
    primitive_count++;
  }
}

PathInfo *path_info = (PathInfo *) AcquireQuantumMemory(primitive_count + 1, sizeof(PathInfo));
if (path_info == NULL) {
  return NULL;
}

ssize_t coordinates = 0;
PointInfo start_point, q;
ssize_t start = 0;
ssize_t n = 0;

for (ssize_t i = 0; primitive_info[i].primitive != UndefinedPrimitive; i++) {
  PathInfoCode code = LineToCode;
  if (coordinates <= 0) {
    coordinates = (ssize_t) primitive_info[i].coordinates;
    start_point = primitive_info[i].point;
    start = n;
    code = MoveToCode;
  }
  coordinates--;
  if ((code == MoveToCode) || (fabs(q.x - primitive_info[i].point.x) >= DrawEpsilon) ||
      (fabs(q.y - primitive_info[i].point.y) >= DrawEpsilon)) {
    path_info[n].code = code;
    path_info[n].point = primitive_info[i].point;
    q = primitive_info[i].point;
    n++;
  }
  if (coordinates > 0) {
    continue;
  }
  if ((fabs(start_point.x - primitive_info[i].point.x) < DrawEpsilon) &&
      (fabs(start_point.y - primitive_info[i].point.y) < DrawEpsilon)) {
    continue;
  }
  path_info[start].code = OpenCode;
  path_info[n].code = GhostlineCode;
  path_info[n].point = primitive_info[i].point;
  n++;
  path_info[n].code = LineToCode;
  path_info[n].point = start_point;
  n++;
}
path_info[n].code = EndCode;
path_info[n].point.x = 0.0;
path_info[n].point.y = 0.0;

if (IsEventLogging() != MagickFalse) {
  LogPathInfo(path_info);
}
return path_info;