// <MASK>
  // Check the type of the first primitive in the input. If the primitive type
  // is not suitable for conversion, return a null pointer.
  // Count the number of primitives in the input array that are not undefined,
  // and use this count to allocate memory for the path information array.
  // Return null if memory allocation fails.
  // Initialize variables that will be used for tracking points and coordinates.
  ssize_t path_count = 0;
  for (i=0; primitive_info[i].primitive!= UndefinedPrimitive; i++)
  {
    path_count++;
  }
  if (path_count == 0)
  {
    return NULL;
  }
  path_info = (PathInfo *) AcquireMagickMemory(sizeof(PathInfo) * path_count);
  if (path_info == (PathInfo *) NULL)
  {
    return NULL;
  }
  memset(path_info, 0, sizeof(PathInfo) * path_count);
  for (i=0; i < path_count; i++)
  {
    path_info[i].code = UndefinedCode;
    path_info[i].point.x = 0.0;
    path_info[i].point.y = 0.0;
  }
  coordinates = 0;
  start = 0;
  code = UndefinedCode;
  for (i=0; primitive_info[i].primitive!= UndefinedPrimitive; i++)
  {
    if (coordinates <= 0)
    {
      coordinates = (ssize_t) primitive_info[i].coordinates;
      start_point = primitive_info[i].point;
      start = i;
      code = MoveToCode;
    }
    coordinates--;
    if ((code == MoveToCode) || (fabs(q.x-primitive_info[i].point.x) >= DrawEpsilon) ||
        (fabs(q.y-primitive_info[i].point.y) >= DrawEpsilon))
    {
      path_info[n].code = code;
      path_info[n].point = primitive_info[i].point;
      q = primitive_info[i].point;
      n++;
    }
    if (coordinates > 0)
    {
      continue;
    }
    if ((fabs(start_point.x-primitive_info[i].point.x) < DrawEpsilon) &&
        (fabs(start_point.y-primitive_info[i].point.y) < DrawEpsilon))
    {
      continue;
    }
    path_info[start].code = OpenCode;
    path_info[n].code = GhostlineCode;
    path_info[n].point = primitive_info[i].point;
    n++;
    path_info[n].code = LineToCode;
    path_info[n].point = start_point;
    n++;
  }
  path_info[n].code = EndCode;
  path_info[n].point.x = 0.0;
  path_info[n].point.y = 0.0;
  if (IsEventLogging()!= MagickFalse)
  {
    LogPathInfo(path_info);
  }
  return(path_info);