// <MASK>
for (i=0; primitive_info[i].primitive != UndefinedPrimitive; i++) ;
number_vertices=(size_t) i;
dash_polygon=(PrimitiveInfo *) AcquireQuantumMemory((size_t)
  (2UL*number_vertices+32UL),sizeof(*dash_polygon));
if (dash_polygon == (PrimitiveInfo *) NULL)
  return(MagickFalse);
clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
clone_info->miterlimit=0;
dash_polygon[0]=primitive_info[0];
scale=ExpandAffine(&draw_info->affine);
length=scale*(draw_info->dash_pattern[0]-0.5);
offset=fabs(draw_info->dash_offset) >= DrawEpsilon ?
  scale*draw_info->dash_offset : 0.0;
j=1;
for (n=0; offset > 0.0; j=0)
{
  if (draw_info->dash_pattern[n] <= 0.0)
    break;
  length=scale*(draw_info->dash_pattern[n]+(n == 0 ? -0.5 : 0.5));
  if (offset > length)
    {
      offset-=length;
      n++;
      length=scale*(draw_info->dash_pattern[n]+0.5);
      continue;
    }
  if (offset < length)
    {
      length-=offset;
      offset=0.0;
      break;
    }
  offset=0.0;
  n++;
}