// <MASK>
  // Check the type of the first primitive in the input. If the primitive type
  // is not suitable for conversion, return a null pointer.
  // Count the number of primitives in the input array that are not undefined,
  // and use this count to allocate memory for the path information array.
  // Return null if memory allocation fails.
  // Initialize variables that will be used for tracking points and coordinates.
  n = 0;
  for (i=0; primitive_info[i].primitive!= UndefinedPrimitive; i++)
  {
    if (primitive_info[i].primitive == LinePrimitive)
    {
      code=LineToCode;
      if (coordinates <= 0)
      {
        coordinates=(ssize_t) primitive_info[i].coordinates;
        start_point=primitive_info[i].point;
        start=n;
        code=MoveToCode;
      }
      coordinates--;
      /*
        Eliminate duplicate points.
      */
      if ((code == MoveToCode) || (fabs(q.x-primitive_info[i].point.x) >= DrawEpsilon) ||
          (fabs(q.y-primitive_info[i].point.y) >= DrawEpsilon))
      {
        path_info[n].code=code;
        path_info[n].point=primitive_info[i].point;
        q=primitive_info[i].point;
        n++;
      }
      if (coordinates > 0)
        continue;
      if ((fabs(start_point.x-primitive_info[i].point.x) < DrawEpsilon) &&
          (fabs(start_point.y-primitive_info[i].point.y) < DrawEpsilon))
        continue;
      /*
        Mark the p point as open if it does not match the q.
      */
      path_info[start].code=OpenCode;
      path_info[n].code=GhostlineCode;
      path_info[n].point=primitive_info[i].point;
      n++;
      path_info[n].code=LineToCode;
      path_info[n].point=start_point;
      n++;
    }
    else if (primitive_info[i].primitive == EllipsePrimitive)
    {
      ssize_t num_coordinates = GetEllipseCoordinates(start_point, primitive_info[i].point, primitive_info[i].degrees);
      for (ssize_t j = 0; j < num_coordinates; j++)
      {
        path_info[n].code = LineToCode;
        path_info[n].point = primitive_info[i].point;
        n++;
        primitive_info[i].point.x += primitive_info[i].degrees.x;
        primitive_info[i].point.y += primitive_info[i].degrees.y;
      }
    }
    else if (primitive_info[i].primitive == PolygonPrimitive)
    {
      code = LineToCode;
      if (coordinates <= 0)
      {
        coordinates = (ssize_t) primitive_info[i].coordinates;
        start_point = primitive_info[i].point;
        start = n;
        code = MoveToCode;
      }
      coordinates--;
      /*
        Eliminate duplicate points.
      */
      if ((code == MoveToCode) || (fabs(q.x-primitive_info[i].point.x) >= DrawEpsilon) ||
          (fabs(q.y-primitive_info[i].point.y) >= DrawEpsilon))
      {
        path_info[n].code = code;
        path_info[n].point = primitive_info[i].point;
        q = primitive_info[i].point;
        n++;
      }
      if (coordinates > 0)
        continue;
      if ((fabs(start_point.x-primitive_info[i].point.x) < DrawEpsilon) &&
          (fabs(start_point.y-primitive_info[i].point.y) < DrawEpsilon))
        continue;
      /*
        Mark the p point as open if it does not match the q.
      */
      path_info[start].code = OpenCode;
      path_info[n].code = GhostlineCode;
      path_info[n].point = primitive_info[i].point;
      n++;
      path_info[n].code = LineToCode;
      path_info[n].point = start_point;
      n++;
    }
  }
  path_info[n].code = EndCode;
  path_info[n].point.x = 0.0;
  path_info[n].point.y = 0.0;
  if (IsEventLogging()!= MagickFalse)
    LogPathInfo(path_info);
  return(path_info);