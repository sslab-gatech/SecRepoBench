for (i=0; primitive_info[i].primitive != UndefinedPrimitive; i++)
{
  n++;
}
path_info = (PathInfo *) AcquireQuantumMemory(n+1UL, sizeof(*path_info));
if (path_info == (PathInfo *) NULL)
  return((PathInfo *) NULL);
(void) memset(path_info,0,(n+1UL)*sizeof(*path_info));
n=0;
for (i=0; primitive_info[i].primitive != UndefinedPrimitive; i++)
{
  code=LineToCode;
  if (coordinates <= 0)
    {
      coordinates=(ssize_t) primitive_info[i].coordinates;
      start_point=primitive_info[i].point;
      start=n;
      code=MoveToCode;
    }
  coordinates--;
  /*
    Eliminate duplicate points.
  */
  if ((code == MoveToCode) || (fabs(q.x-primitive_info[i].point.x) >= DrawEpsilon) ||
      (fabs(q.y-primitive_info[i].point.y) >= DrawEpsilon))
    {
      path_info[n].code=code;
      path_info[n].point=primitive_info[i].point;
      q=primitive_info[i].point;
      n++;
    }
  if (coordinates > 0)
    continue;
  if ((fabs(start_point.x-primitive_info[i].point.x) < DrawEpsilon) &&
      (fabs(start_point.y-primitive_info[i].point.y) < DrawEpsilon))
    continue;
  /*
    Mark the p point as open if it does not match the q.
  */
  path_info[start].code=OpenCode;
  path_info[n].code=GhostlineCode;
  path_info[n].point=primitive_info[i].point;
  n++;
  path_info[n].code=LineToCode;
  path_info[n].point=start_point;
  n++;
}
path_info[n].code=EndCode;
path_info[n].point.x=0.0;
path_info[n].point.y=0.0;