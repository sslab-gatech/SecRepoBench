if (primitive_info[0].primitive != PathPrimitive)
    return((PathInfo *) NULL);
  for (i=0; primitive_info[i].primitive != UndefinedPrimitive; i++)
    ;
  path_info=(PathInfo *) AcquireQuantumMemory((size_t) (2UL*i+1UL),
    sizeof(*path_info));
  if (path_info == (PathInfo *) NULL)
    return((PathInfo *) NULL);
  (void) memset(path_info,0,(size_t) (2UL*i+1UL)*sizeof(*path_info));
  coordinates=0;
  start=0;
  for (n=0; n < i; n++)
  {
    code=LineToCode;
    if (coordinates <= 0)
      {
        coordinates=(ssize_t) primitive_info[n].coordinates;
        start_point=primitive_info[n].point;
        start=n;
        code=MoveToCode;
      }
    coordinates--;
    /*
      Eliminate duplicate points.
    */
    if ((code == MoveToCode) || (fabs(q.x-primitive_info[n].point.x) >= DrawEpsilon) ||
        (fabs(q.y-primitive_info[n].point.y) >= DrawEpsilon))
      {
        path_info[n].code=code;
        path_info[n].point=primitive_info[n].point;
        q=primitive_info[n].point;
      }
    if (coordinates > 0)
      continue;
    if ((fabs(start_point.x-primitive_info[n].point.x) < DrawEpsilon) &&
        (fabs(start_point.y-primitive_info[n].point.y) < DrawEpsilon))
      continue;
    /*
      Mark the p point as open if it does not match the q.
    */
    path_info[start].code=OpenCode;
    path_info[n].code=GhostlineCode;
    path_info[n].point=primitive_info[n].point;
    n++;
    path_info[n].code=LineToCode;
    path_info[n].point=start_point;
  }
  path_info[n].code=EndCode;
  path_info[n].point.x=0.0;
  path_info[n].point.y=0.0;
  if (IsEventLogging() != MagickFalse)
    LogPathInfo(path_info);
  return(path_info);