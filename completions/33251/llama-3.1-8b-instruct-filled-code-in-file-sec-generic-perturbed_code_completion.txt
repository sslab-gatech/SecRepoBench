// Populate the metalayer string
int8_t nslen = *idxp & (uint8_t)0x1F;
idxp += 1;
header_pos += nslen;
if (header_len < header_pos) {
  return BLOSC2_ERROR_READ_BUFFER;
}
char* ns = malloc((size_t)nslen + 1);
memcpy(ns, idxp, nslen);
ns[nslen] = '\0';
idxp += nslen;
current_metalayer->name = ns;

// Populate the serialized value for this metalayer
// Get the offset
header_pos += 1;
if (header_len < header_pos) {
  return BLOSC2_ERROR_READ_BUFFER;
}
if ((*idxp & 0xffu)!= 0xd2u) {   // sanity check
  return BLOSC2_ERROR_DATA;
}
idxp += 1;
int32_t offset;
header_pos += sizeof(offset);
if (header_len < header_pos) {
  return BLOSC2_ERROR_READ_BUFFER;
}
from_big(&offset, idxp, sizeof(offset));
idxp += 4;
if (offset < 0 || offset >= header_len) {
  // Offset is less than zero or exceeds header length
  return BLOSC2_ERROR_DATA;
}
// Go to offset and see if we have the correct marker
uint8_t* content_marker = header + offset;
// Retrieve the length of the serialized content that follows the marker.
// Store the length in the metalayer structure.
// Use the obtained length to correctly position within the header and extract the content.
// Assign the extracted content to the metalayer's content field.
// <MASK>
int32_t content_len;
from_big(&content_len, content_marker + 1, sizeof(content_len));
if (content_len < 0) {
  return BLOSC2_ERROR_DATA;
}
current_metalayer->content_len = content_len;
// Finally, read the content
if (header_len < offset + 1 + 4 + content_len) {
  return BLOSC2_ERROR_READ_BUFFER;
}
char* content = malloc((size_t)content_len);
memcpy(content, content_marker + 1 + 4, (size_t)content_len);
current_metalayer->content = (uint8_t*)content;