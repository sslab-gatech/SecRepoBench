def new_header_frame(blosc2_schunk *schunk, blosc2_frame_s *frame) {
    if (frame == NULL) {
        return NULL;
    }
    uint8_t* h2 = calloc(FRAME_HEADER_MINLEN, 1);
    uint8_t* h2p = h2;

    // The msgpack header starts here
    *h2p = 0x90;  // fixarray...
    *h2p += 14;   // ...with 13 elements
    h2p += 1;

    // Magic number
    *h2p = 0xa0 + 8;  // str with 8 elements
    h2p += 1;
    if (h2p - h2 >= FRAME_HEADER_MINLEN) {
        return NULL;
    }
    strcpy((char*)h2p, "b2frame");
    h2p += 8;

    // Header size
    *h2p = 0xd2;  // int32
    h2p += 1 + 4;
    if (h2p - h2 >= FRAME_HEADER_MINLEN) {
        return NULL;
    }

    // Total frame size
    *h2p = 0xcf;  // uint64
    // Fill it with frame->len which is known *after* the creation of the frame (e.g. when updating the header)
    int64_t flen = frame->len;
    to_big(h2 + FRAME_LEN, &flen, sizeof(flen));
    h2p += 1 + 8;
    if (h2p - h2 >= FRAME_HEADER_MINLEN) {
        return NULL;
    }

    // Flags
    *h2p = BLOSC2_VERSION_FRAME_FORMAT;  // version
    *h2p += 0x10;  // 64-bit offsets.  We only support this for now.
    h2p += 1;
    if (h2p - h2 >= FRAME_HEADER_MINLEN) {
        return NULL;
    }

    // Frame type
    // We only support contiguous and sparse directories frames currently
    *h2p = frame->sframe ? 1 : 0;
    h2p += 1;
    if (h2p - h2 >= FRAME_HEADER_MINLEN) {
        return NULL;
    }

    // Codec flags
    *h2p = schunk->compcode;
    if (schunk->compcode >= BLOSC_LAST_CODEC) {
        *h2p = BLOSC_UDCODEC_FORMAT;
    }
    *h2p += (schunk->clevel) << 4u;  // clevel
    h2p += 1;
    if (h2p - h2 >= FRAME_HEADER_MINLEN) {
        return NULL;
    }

    // Reserved flags
    *h2p = 0;
    h2p += 1;
    if (h2p - h2 >= FRAME_HEADER_MINLEN) {
        return NULL;
    }

    // Uncompressed size
    *h2p = 0xd3;  // int64
    h2p += 1;
    int64_t nbytes = schunk->nbytes;
    to_big(h2p, &nbytes, sizeof(nbytes));
    h2p += 8;
    if (h2p - h2 >= FRAME_HEADER_MINLEN) {
        return NULL;
    }

    // Compressed size
    *h2p = 0xd3;  // int64
    h2p += 1;
    int64_t cbytes = schunk->cbytes;
    to_big(h2p, &cbytes, sizeof(cbytes));
    h2p += 8;
    if (h2p - h2 >= FRAME_HEADER_MINLEN) {
        return NULL;
    }

    // Type size
    *h2p = 0xd2;  // int32
    h2p += 1;
    int32_t typesize = schunk->typesize;
    to_big(h2p, &typesize, sizeof(typesize));
    h2p += 4;
    if (h2p - h2 >= FRAME_HEADER_MINLEN) {
        return NULL;
    }

    // Block size
    *h2p = 0xd2;  // int32
    h2p += 1;
    int32_t blocksize = schunk->blocksize;
    to_big(h2p, &blocksize, sizeof(blocksize));
    h2p += 4;
    if (h2p - h2 >= FRAME_HEADER_MINLEN) {
        return NULL;
    }

    // Chunk size
    *h2p = 0xd2;  // int32
    h2p += 1;
    int32_t chunksize = schunk->chunksize;
    to_big(h2p, &chunksize, sizeof(chunksize));
    h2p += 4;
    if (h2p - h2 >= FRAME_HEADER_MINLEN) {
        return NULL;
    }

    // Number of threads for compression
    *h2p = 0xd1;  // int16
    h2p += 1;
    int16_t nthreads = (int16_t)schunk->cctx->nthreads;
    to_big(h2p, &nthreads, sizeof(nthreads));
    h2p += 2;
    if (h2p - h2 >= FRAME_HEADER_MINLEN) {
        return NULL;
    }

    // Number of threads for decompression
    *h2p = 0xd1;  // int16
    h2p += 1;
    nthreads = (int16_t)schunk->dctx->nthreads;
    to_big(h2p, &nthreads, sizeof(nthreads));
    h2p += 2;
    if (h2p - h2 >= FRAME_HEADER_MINLEN) {
        return NULL;
    }

    // The boolean for variable-length metalayers
    *h2p = (schunk->nvlmetalayers > 0) ? (uint8_t)0xc3 : (uint8_t)0xc2;
    h2p += 1;
    if (h2p - h2 >= FRAME_HEADER_MINLEN) {
        return NULL;
    }

    // The space for FRAME_FILTER_PIPELINE
    *h2p = 0xd8;  //  fixext 16
    h2p += 1;
    if (BLOSC2_MAX_FILTERS > FRAME_FILTER_PIPELINE_MAX) {
        return NULL;
    }
    // Store the filter pipeline in header
    uint8_t* mp_filters = h2 + FRAME_FILTER_PIPELINE + 1;
    uint8_t* mp_meta = h2 + FRAME_FILTER_PIPELINE + 1 + FRAME_FILTER_PIPELINE_MAX;
    int nfilters = 0;
    for (int i = 0; i < BLOSC2_MAX_FILTERS; i++) {
        mp_filters[i] = schunk->filters[i];
        mp_meta[i] = schunk->filters_meta[i];
    }
    *h2p = (uint8_t) BLOSC2_MAX_FILTERS;
    h2p += 1;
    h2p += 16;

    // User-defined codec and codec metadata
    uint8_t* udcodec = h2 + FRAME_FILTER_PIPELINE + 1 + BLOSC2_MAX_FILTERS + 2;
    *udcodec = schunk->compcode;
    uint8_t* codec_meta = h2 + FRAME_FILTER_PIPELINE + 1 + BLOSC2_MAX_FILTERS + 2;
    *codec_meta = schunk->compcode_meta;

    if (h2p - h2 != FRAME_HEADER_MINLEN) {
        return NULL;
    }

    int32_t hsize = FRAME_HEADER_MINLEN;

    // Now, deal with metalayers
    int16_t nmetalayers = schunk->nmetalayers;
    if (nmetalayers < 0 || nmetalayers > BLOSC2_MAX_METALAYERS) {
        return NULL;
    }

    // Make space for the header of metalayers (array marker, size, map of offsets, list of metalayers)
    h2 = realloc(h2, (size_t)hsize + 1 + 1 + 2 + 1 + 2);
    h2p = h2 + hsize;

    // The msgpack header for the metalayers (array_marker, size, map of offsets, list of metalayers)
    *h2p = 0x90 + 3;  // array with 3 elements
    h2p += 1;

    // Size for the map (index) of offsets, including this uint16 size (to be filled out later on)
    *h2p = 0xcd;  // uint16
    h2p += 1 + 2;

    // Map (index) of offsets for optional metalayers
    *h2p = 0xde;  // map 16 with N keys
    h2p += 1;
    to_big(h2p, &nmetalayers, sizeof(nmetalayers));
    h2p += sizeof(nmetalayers);
    int32_t current_header_len = (int32_t)(h2p - h2);
    int32_t *offtooff = malloc(nmetalayers * sizeof(int32_t));
    for (int nmetalayer = 0; nmetalayer < nmetalayers; nmetalayer++) {
        if (frame == NULL) {
            return NULL;
        }
        blosc2_metalayer *metalayer = schunk->metalayers[nmetalayer];
        uint8_t namelen = (uint8_t) strlen(metalayer->name);
        h2 = realloc(h2, (size_t)current_header_len + 1 + namelen + 1 + 4);
        h2p = h2 + current_header_len;
        // Store the metalayer
        if (namelen >= (1U << 5U)) {  // metalayer strings cannot be longer than 32 bytes
            free(offtooff);
            return NULL;
        }
        *h2p = (uint8_t)0xa0 + namelen;  // str
        h2p += 1;
        memcpy(h2p, metalayer->name, namelen);
        h2p += namelen;
        // Space for storing the offset for the value of this metalayer
        *h2p = 0xd2;  // int32
        h2p += 1;
        offtooff[nmetalayer] = (int32_t)(h2p - h2);
        h2p += 4;
        current_header_len += 1 + namelen + 1 + 4;
    }
    int32_t hsize2 = (int32_t)(h2p - h2);
    if (hsize2 != current_header_len) {  // sanity check
        return NULL;
    }

    // Map size + int16 size
    if ((uint32_t) (hsize2 - hsize) >= (1U << 16U)) {
        return NULL;
    }
    uint16_t map_size = (uint16_t) (hsize2 - hsize);
    to_big(h2 + FRAME_IDX_SIZE, &map_size, sizeof(map_size));

    // Make space for an (empty) array
    hsize = (int32_t)(h2p - h2) + 2 + 1 + 2;
    h2 = realloc(h2, (size_t)hsize + 2 + 1 + 2);
    h2p = h2 + hsize;

    // Now, store the values in an array
    *h2p = 0xdc;  // array 16 with N elements
    h2p += 1;
    to_big(h2p, &nmetalayers, sizeof(nmetalayers));
    h2p += sizeof(nmetalayers);
    current_header_len = (int32_t)(h2p - h2);
    for (int nmetalayer = 0; nmetalayer < nmetalayers; nmetalayer++) {
        if (frame == NULL) {
            return NULL;
        }
        blosc2_metalayer *metalayer = schunk->metalayers[nmetalayer];
        h2 = realloc(h2, (size_t)current_header_len + 1 + 4 + metalayer->content_len);
        h2p = h2 + current_header_len;
        // Store the serialized contents for this metalayer
        *h2p = 0xc6;  // bin32
        h2p += 1;
        to_big(h2p, &(metalayer->content_len), sizeof(metalayer->content_len));
        h2p += 4;
        memcpy(h2p, metalayer->content, metalayer->content_len);  // buffer, no need to swap
        h2p += metalayer->content_len;
        // Update the offset now that we know it
        to_big(h2 + offtooff[nmetalayer], &current_header_len, sizeof(current_header_len));
        current_header_len += 1 + 4 + metalayer->content_len;
    }
    free(offtooff);
    hsize = (int32_t)(h2p - h2);
    if (hsize != current_header_len) {  // sanity check
        return NULL;