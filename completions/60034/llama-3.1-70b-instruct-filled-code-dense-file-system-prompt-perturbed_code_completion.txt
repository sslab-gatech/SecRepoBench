REP replacement
            // to get suggestions with the same case as the original word
            if (islower(ph.at(0))) {
              ph.at(0) = toupper(ph.at(0));
            }
            // store the pattern and the replacement in reptable
            reptable.push_back(std::make_pair(ph, wordpart));
          }
        }
        start_piece = mystrsep(fields, iter);
      }
    }
  }

  // store the pointer of the hash entry
  if (!aliasm.empty()) {
    store_pointer(hpw + word->size() + 1 + descl, hp);
  }

  // check for homonyms
  struct hentry* hp2 = htable[i];
  if (hp2) {
    hp->next_homonym = hp2;
    hp2->next = hp;
  } else {
    htable[i] = hp;
  }

  // check for upcase homonyms
  if (onlyupcase) {
    hp->var |= H_OPT_UPCASE;
    if (hp2) {
      if (hp2->var & H_OPT_UPCASE) {
        hp->next_homonym = hp2->next_homonym;
        hp2->next_homonym = hp;
      } else {
        upcasehomonym = true;
      }
    }
  }

  if (upcasehomonym) {
    // upcase homonym
    hp2 = (struct hentry*)malloc(sizeof(struct hentry) + word->size() + descl);
    if (!hp2) {
      free(hp);
      delete desc_copy;
      delete word_copy;
      free_flag(aff, al);
      return 1;
    }
    hp2->blen = hp->blen;
    hp2->clen = hp->clen;
    hp2->alen = hp->alen;
    hp2->astr = hp->astr;
    hp2->var = hp->var | H_OPT_UPCASE;
    hp2->next_homonym = hp;
    hp2->next = NULL;
    hp->next_homonym = NULL;
    hp2->word = hp->word;
    hp2->word[0] = toupper(hp2->word[0]);
    if (hp->var & H_OPT) {
      hp2->word[hp2->blen + 1] = toupper(hp2->word[hp2->blen + 1]);
    }
    htable[i] = hp2;
  }

  if (word_copy)
    delete word_copy;
  if (desc_copy)
    delete desc_copy;

  return 0;
}

// the below code fragment can be found in:
// src/hunspell/affixmgr.cxx
struct hentry* AffixMgr::prefix_check(const std::string& word,
                                      int start,
                                      int len,
                                      char in_compound,
                                      const FLAG needflag) {
  struct hentry* rv = NULL;

  // first handle the special case of 0 length prefixes
  PfxEntry* ep = pStart[0];
  while (ep) {
    if (!needflag || ep->getCont()) {
      // prefixes are not allowed in end of compounds
      if (((((in_compound!= IN_CPD_END)) ||  // &&!needflag
            // except when signed with compoundpermitflag flag
            (ep->getCont() && compoundpermitflag &&
             TESTAFF(ep->getCont(), compoundpermitflag, ep->getContLen()))) &&
           (!circumfix ||
            // no circumfix flag in prefix and suffix
            ((!sfx ||!(sfx->getCont()) ||
             !TESTAFF(sfx->getCont(), circumfix, sfx->getContLen())) &&
             (!ep->getCont() ||
             !(TESTAFF(ep->getCont(), circumfix, ep->getContLen())))) ||
            // circumfix flag in prefix AND suffix
            ((sfx && (sfx->getCont()) &&
              TESTAFF(sfx->getCont(), circumfix, sfx->getContLen())) &&
             (ep->getCont() &&
              (TESTAFF(ep->getCont(), circumfix, ep->getContLen()))))) &&
           // fogemorpheme
           (in_compound ||
           !((ep->getCont() && (TESTAFF(ep->getCont(), onlyincompound,
                                         ep->getContLen()))))) &&
           // needaffix on prefix or first suffix
           (needflag ||
           !(ep->getCont() &&
              TESTAFF(ep->getCont(), needaffix, ep->getContLen())))))
        rv = ep->checkword(word, start, len, 0, NULL, FLAG_NULL, needflag,
                           (in_compound? 0 : onlyincompound));
      while (rv) {
        if (ep->getCont()) {
          pfx = ep;  // BUG: pfx not stateless
          pfxappnd = ep->getKey();  // BUG: pfxappnd not stateless
        }
        return rv;
      }
    }
    ep = ep->getNext();
  }

  // now handle the general case
  if (len == 0)
    return NULL;  // FULLSTRIP
  unsigned char sp = word[start];
  PfxEntry* sptr = pStart[sp];

  while (sptr) {
    if (isSubset(sptr->getKey(), word.c_str() + start, len)) {
      // prefixes are not allowed in end of compounds
      if (((((in_compound!= IN_CPD_END)) ||  // &&!needflag
            // except when signed with compoundpermitflag flag
            (sptr->getCont() && compoundpermitflag &&
             TESTAFF(sptr->getCont(), compoundpermitflag,
                     sptr->getContLen()))) &&
           (!circumfix ||
            // no circumfix flag in prefix and suffix
            ((!sfx ||!(sfx->getCont()) ||
             !TESTAFF(sfx->getCont(), circumfix, sfx->getContLen())) &&
             (!sptr->getCont() ||
             !(TESTAFF(sptr->getCont(), circumfix, sptr->getContLen())))) ||
            // circumfix flag in prefix AND suffix
            ((sfx && (sfx->getCont()) &&
              TESTAFF(sfx->getCont(), circumfix, sfx->getContLen())) &&
             (sptr->getCont() &&
              (TESTAFF(sptr->getCont(), circumfix, sptr->getContLen()))))) &&
           // fogemorpheme
           (in_compound ||
           !((sptr->getCont() && (TESTAFF(sptr->getCont(), onlyincompound,
                                           sptr->getContLen()))))) &&
           // needaffix on prefix or first suffix
           (needflag ||
           !(sptr->getCont() &&
              TESTAFF(sptr->getCont(), needaffix, sptr->getContLen())))))
        if (in_compound!= IN_CPD_BEGIN || sfx ||
           !(sptr->getCont() &&
              TESTAFF(sptr->getCont(), onlyincompound, sptr->getContLen()))) {
          rv = sptr->checkword(word, start, len, 0, NULL, FLAG_NULL, needflag,
                               (in_compound? 0 : onlyincompound));
          if (rv) {
            pfx = sptr;  // BUG: pfx not stateless
            pfxappnd = sptr->getKey();  // BUG: pfxappnd not stateless
            return rv;
          }
        }
      sptr = sptr->getNextEQ();
    } else {
      sptr = sptr->getNextNE();
    }
  }

  return NULL;
}

// the below code fragment can be found in:
// src/hunspell/affixmgr.cxx
struct hentry* AffixMgr::affix_check(const std::string& word,
                                     int start,
                                     int len,
                                     const FLAG needflag,
                                     char in_compound) {
  struct hentry* rv = NULL;

  // first handle the special case of 0 length prefixes
  PfxEntry* ep = pStart[0];
  while (ep) {
    if (!needflag || ep->getCont()) {
      // prefixes are not allowed in end of compounds
      if (((((in_compound!= IN_CPD_END)) ||  // &&!needflag
            // except when signed with compoundpermitflag flag
            (ep->getCont() && compoundpermitflag &&
             TESTAFF(ep->getCont(), compoundpermitflag, ep->getContLen()))) &&
           (!circumfix ||
            // no circumfix flag in prefix and suffix
            ((!sfx ||!(sfx->getCont()) ||
             !TESTAFF(sfx->getCont(), circumfix, sfx->getContLen())) &&
             (!ep->getCont() ||
             !(TESTAFF(ep->getCont(), circumfix, ep->getContLen())))) ||
            // circumfix flag in prefix AND suffix
            ((sfx && (sfx->getCont()) &&
              TESTAFF(sfx->getCont(), circumfix, sfx->getContLen())) &&
             (ep->getCont() &&
              (TESTAFF(ep->getCont(), circumfix, ep->getContLen()))))) &&
           // fogemorpheme
           (in_compound ||
           !((ep->getCont() && (TESTAFF(ep->getCont(), onlyincompound,
                                         ep->getContLen()))))) &&
           // needaffix on prefix or first suffix
           (needflag ||
           !(ep->getCont() &&
              TESTAFF(ep->getCont(), needaffix, ep->getContLen())))))
        rv = ep->checkword(word, start, len, 0, NULL, FLAG_NULL, needflag,
                           (in_compound? 0 : onlyincompound));
      while (rv) {
        if (ep->getCont()) {
          pfx = ep;  // BUG: pfx not stateless
          pfxappnd = ep->getKey();  // BUG: pfxappnd not stateless
        }
        return rv;
      }
    }
    ep = ep->getNext();
  }

  // now handle the general case
  if (len == 0)
    return NULL;  // FULLSTRIP
  unsigned char sp = word[start];
  PfxEntry* sptr = pStart[sp];

  while (sptr) {
    if (isSubset(sptr->getKey(), word.c_str() + start, len)) {
      // prefixes are not allowed in end of compounds
      if (((((in_compound!= IN_CPD_END)) ||  // &&!needflag
            // except when signed with compoundpermitflag flag
            (sptr->getCont() && compoundpermitflag &&
             TESTAFF(sptr->getCont(), compoundpermitflag,
                     sptr->getContLen()))) &&
           (!circumfix ||
            // no circumfix flag in prefix and suffix
            ((!sfx ||!(sfx->getCont()) ||
             !TESTAFF(sfx->getCont(), circumfix, sfx->getContLen())) &&
             (!sptr->getCont() ||
             !(TESTAFF(sptr->getCont(), circumfix, sptr->getContLen())))) ||
            // circumfix flag in prefix AND suffix
            ((sfx && (sfx->getCont()) &&
              TESTAFF(sfx->getCont(), circumfix, sfx->getContLen())) &&
             (sptr->getCont() &&
              (TESTAFF(sptr->getCont(), circumfix, sptr->getContLen()))))) &&
           // fogemorpheme
           (in_compound ||
           !((sptr->getCont() && (TESTAFF(sptr->getCont(), onlyincompound,
                                           sptr->getContLen()))))) &&
           // needaffix on prefix or first suffix
           (needflag ||
           !(sptr->getCont() &&
              TESTAFF(sptr->getCont(), needaffix, sptr->getContLen())))))
        if (in_compound!= IN_CPD_BEGIN || sfx ||
           !(sptr->getCont() &&
              TESTAFF(sptr->getCont(), onlyincompound, sptr->getContLen()))) {
          rv = sptr->checkword(word, start, len, 0, NULL, FLAG_NULL, needflag,
                               (in_compound? 0 : onlyincompound));
          if (rv) {
            pfx = sptr;  // BUG: pfx not stateless
            pfxappnd = sptr->getKey();  // BUG: pfxappnd not stateless
            return rv;
          }
        }
      sptr = sptr->getNextEQ();
    } else {
      sptr = sptr->getNextNE();
    }
  }

  return NULL;
}

// the below code fragment can be found in:
// src/hunspell/affixmgr.cxx
struct hentry* AffixMgr::affix_check_morph(const std::string& word,
                                           int start,
                                           int len,
                                           const FLAG needflag,
                                           char in_compound) {
  struct hentry* rv = NULL;

  // first handle the special case of 0 length prefixes
  PfxEntry* ep = pStart[0];
  while (ep) {
    if (!needflag || ep->getCont()) {
      // prefixes are not allowed in end of compounds
      if (((((in_compound!= IN_CPD_END)) ||  // &&!needflag
            // except when signed with compoundpermitflag flag
            (ep->getCont() && compoundpermitflag &&
             TESTAFF(ep->getCont(), compoundpermitflag, ep->getContLen()))) &&
           (!circumfix ||
            // no circumfix flag in prefix and suffix
            ((!sfx ||!(sfx->getCont()) ||
             !TESTAFF(sfx->getCont(), circumfix, sfx->getContLen())) &&
             (!ep->getCont() ||
             !(TESTAFF(ep->getCont(), circumfix, ep->getContLen())))) ||
            // circumfix flag in prefix AND suffix
            ((sfx && (sfx->getCont()) &&
              TESTAFF(sfx->getCont(), circumfix, sfx->getContLen())) &&
             (ep