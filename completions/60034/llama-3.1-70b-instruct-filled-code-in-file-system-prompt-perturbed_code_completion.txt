// Check if the current dictionary entry is forbidden in compound words
// by checking for `COMPOUNDFORBIDFLAG`. If it is forbidden and not allowed
// by the Hungarian movement rule (`hu_mov_rule`), handle the case by either
// breaking out of a potential infinite loop or continuing the search for
// valid dictionary entries based on specific conditions such as simplified
// compound processing (`simplifiedcpd`).
// Adjust compound word boundaries if necessary.
//
// Iterate through homonyms of the current entry to find one with the
// required compound conditions. This includes conditions based on compound
// flags such as `compoundflag`, `compoundbegin`, `compoundmiddle`, and
// checks against specific compound pattern conditions (`checkcpdtable`).
// The process ensures that only valid compound components are accepted
// and it skips over invalid ones by moving to the next homonym.
// <MASK>
if ((rv) && compoundforbidflag &&
    TESTAFF(rv->astr, compoundforbidflag, rv->alen) &&!hu_mov_rule)
  continue;

// search homonym with compound flag
while ((rv) &&!hu_mov_rule &&
       ((needaffix && TESTAFF(rv->astr, needaffix, rv->alen)) ||
       !((compoundflag &&!words &&!onlycpdrule &&
           TESTAFF(rv->astr, compoundflag, rv->alen)) ||
          (compoundbegin &&!wordnum &&!onlycpdrule &&
           TESTAFF(rv->astr, compoundbegin, rv->alen)) ||
          (compoundmiddle && wordnum &&!words &&!onlycpdrule &&
           TESTAFF(rv->astr, compoundmiddle, rv->alen)) ||
          (!defcpdtable.empty() && onlycpdrule &&
           ((!words &&!wordnum &&
             defcpd_check(&words, wnum, rv, rwords, 0)) ||
            (words &&
             defcpd_check(&words, wnum, rv, rwords, 0))))))) {
  rv = rv->next_homonym;
}