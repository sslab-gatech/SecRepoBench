if (entry_result) {
  // Check if the current dictionary entry is forbidden in compound words
  // by checking for `COMPOUNDFORBIDFLAG`. If it is forbidden and not allowed
  // by the Hungarian movement rule (`hu_mov_rule`), handle the case by either
  // breaking out of a potential infinite loop or continuing the search for
  // valid dictionary entries based on specific conditions such as simplified
  // compound processing (`simplifiedcpd`).
  // Adjust compound word boundaries if necessary.

  // Iterate through homonyms of the current entry to find one with the
  // required compound conditions. This includes conditions based on compound
  // flags such as `compoundflag`, `compoundbegin`, `compoundmiddle`, and
  // checks against specific compound pattern conditions (`checkcpdtable`).
  // The process ensures that only valid compound components are accepted
  // and it skips over invalid ones by moving to the next homonym.
  // <MASK>

  if (entry_result->astr && TESTAFF(entry_result->astr, compoundforbidflag, entry_result->alen) &&
      (!hu_mov_rule || TESTAFF(entry_result->astr, hu_mov_rule, entry_result->alen))) {
    if (simplifiedcpd && scpd <= checkcpdtable.size() && checkcpdtable[scpd - 1].cond == FLAG_NULL) {
      // Continue searching for valid compound entries based on simplified compound processing conditions
      scpd++;
      continue;
    } else {
      // Break out of the loop if the current entry is forbidden in compound words and not allowed by the Hungarian movement rule
      break;
    }
  }

  // Check compound flags and conditions for the current entry
  if ((compoundflag && TESTAFF(entry_result->astr, compoundflag, entry_result->alen)) ||
      (compoundbegin && TESTAFF(entry_result->astr, compoundbegin, entry_result->alen)) ||
      (compoundmiddle && TESTAFF(entry_result->astr, compoundmiddle, entry_result->alen)) ||
      (langnum == LANG_hu && hu_mov_rule &&
       (TESTAFF(entry_result->astr, 'F', entry_result->alen) || TESTAFF(entry_result->astr, 'G', entry_result->alen) || TESTAFF(entry_result->astr, 'H', entry_result->alen)))) {
    // The current entry is acceptable as a compound word component
  } else {
    // The current entry is not acceptable as a compound word component, move to the next homonym
    entry_result = entry_result->next_homonym;
    continue;
  }
}