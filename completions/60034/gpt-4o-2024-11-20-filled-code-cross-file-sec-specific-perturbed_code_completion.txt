// Check if the current dictionary entry is forbidden in compound words
if (entry_result && entry_result->astr &&
    TESTAFF(entry_result->astr, compoundforbidflag, entry_result->alen)) {
  if (!hu_mov_rule) {
    // If Hungarian movement rule is not allowed, break or continue
    st[i] = ch;
    break;
  } else {
    // Adjust compound word boundaries for Hungarian movement rule
    st[i] = ch;
    continue;
  }
}

// Iterate through homonyms to find valid compound conditions
while (entry_result) {
  if ((compoundflag && TESTAFF(entry_result->astr, compoundflag, entry_result->alen)) ||
      (compoundbegin && TESTAFF(entry_result->astr, compoundbegin, entry_result->alen)) ||
      (compoundmiddle && TESTAFF(entry_result->astr, compoundmiddle, entry_result->alen)) ||
      (checkcpdtable.size() > 0 && scpd > 0 &&
       TESTAFF(entry_result->astr, checkcpdtable[scpd - 1].cond, entry_result->alen))) {
    // Valid compound component found
    break;
  }
  // Move to the next homonym
  entry_result = entry_result->next_homonym;
}

// If no valid entry is found, reset and continue
if (!entry_result) {
  st[i] = ch;
  continue;
}