if (entry_result) {
  // Check if the current dictionary entry is forbidden in compound words
  // by checking for `COMPOUNDFORBIDFLAG`. If it is forbidden and not allowed
  // by the Hungarian movement rule (`hu_mov_rule`), handle the case by either
  // breaking out of a potential infinite loop or continuing the search for
  // valid dictionary entries based on specific conditions such as simplified
  // compound processing (`simplifiedcpd`).
  // Adjust compound word boundaries if necessary.
  //
  // Iterate through homonyms of the current entry to find one with the
  // required compound conditions. This includes conditions based on compound
  // flags such as `compoundflag`, `compoundbegin`, `compoundmiddle`, and
  // checks against specific compound pattern conditions (`checkcpdtable`).
  // The process ensures that only valid compound components are accepted
  // and it skips over invalid ones by moving to the next homonym.
  // <MASK>

  if (entry_result->astr && TESTAFF(entry_result->astr, compoundforbidflag, entry_result->alen) &&
      (!hu_mov_rule || TESTAFF(entry_result->astr, hu_mov_rule, entry_result->alen))) {
    if (simplifiedcpd && scpd <= checkcpdtable.size() && checkcpdtable[scpd - 1].cond == FLAG_NULL) {
      // Continue the search for valid compound entries based on simplified compound processing conditions
      scpd++;
      continue;
    } else {
      // Break out of the loop if the current entry is forbidden in compound words and not allowed by the Hungarian movement rule
      break;
    }
  }

  // Check if the current entry is a valid compound component based on compound flags and compound pattern conditions
  if ((compoundflag && TESTAFF(entry_result->astr, compoundflag, entry_result->alen)) ||
      (compoundbegin && TESTAFF(entry_result->astr, compoundbegin, entry_result->alen)) ||
      (compoundmiddle && TESTAFF(entry_result->astr, compoundmiddle, entry_result->alen)) ||
      (checkcpdtable.empty() || scpd != 0 || cpdpat_check(word, i, rv_first, entry_result, 0))) {
    // The current entry is a valid compound component, so continue with the next word
    continue;
  }

  // If the current entry is not a valid compound component, skip to the next homonym
  entry_result = entry_result->next_homonym;
}