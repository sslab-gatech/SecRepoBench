// Check if the current dictionary entry is forbidden in compound words
// by checking for `COMPOUNDFORBIDFLAG`. If it is forbidden and not allowed
// by the Hungarian movement rule (`hu_mov_rule`), handle the case by either
// breaking out of a potential infinite loop or continuing the search for
// valid dictionary entries based on specific conditions such as simplified
// compound processing (`simplifiedcpd`).
// Adjust compound word boundaries if necessary.
//
// Iterate through homonyms of the current entry to find one with the
// required compound conditions. This includes conditions based on compound
// flags such as `compoundflag`, `compoundbegin`, `compoundmiddle`, and
// checks against specific compound pattern conditions (`checkcpdtable`).
// The process ensures that only valid compound components are accepted
// and it skips over invalid ones by moving to the next homonym.
if (entry_result) {
  if (TESTAFF(entry_result->astr, COMPOUNDFORBIDFLAG, entry_result->alen) &&
     !(hu_mov_rule && TESTAFF(entry_result->astr, hu_mov_rule, entry_result->alen))) {
    entry_result = NULL;
  } else {
    // check compound flag in suffix and prefix
    if ((entry_result) &&!hu_mov_rule &&
        ((pfx && pfx->getCont() &&
          TESTAFF(pfx->getCont(), compoundforbidflag, pfx->getContLen())) ||
         (sfx && sfx->getCont() &&
          TESTAFF(sfx->getCont(), compoundforbidflag,
                  sfx->getContLen())))) {
      entry_result = NULL;
    }

    // check compoundend flag in suffix and prefix
    if ((entry_result) &&!checked_prefix && compoundend &&!hu_mov_rule &&
        ((pfx && pfx->getCont() &&
          TESTAFF(pfx->getCont(), compoundend, pfx->getContLen())) ||
         (sfx && sfx->getCont() &&
          TESTAFF(sfx->getCont(), compoundend, sfx->getContLen())))) {
      entry_result = NULL;
    }

    // check compoundmiddle flag in suffix and prefix
    if ((entry_result) &&!checked_prefix && (wordnum == 0) && compoundmiddle &&
       !hu_mov_rule &&
        ((pfx && pfx->getCont() &&
          TESTAFF(pfx->getCont(), compoundmiddle, pfx->getContLen())) ||
         (sfx && sfx->getCont() &&
          TESTAFF(sfx->getCont(), compoundmiddle, sfx->getContLen())))) {
      entry_result = NULL;
    }

    // check forbiddenwords
    if ((entry_result) && (entry_result->astr) &&
        (TESTAFF(entry_result->astr, forbiddenword, entry_result->alen) ||
         TESTAFF(entry_result->astr, ONLYUPCASEFLAG, entry_result->alen) ||
         (is_sug && nosuggest &&
          TESTAFF(entry_result->astr, nosuggest, entry_result->alen)))) {
      return NULL;
    }

    // check non_compound flag in suffix and prefix
    if ((entry_result) &&!hu_mov_rule &&
        ((pfx && pfx->getCont() &&
          TESTAFF(pfx->getCont(), compoundforbidflag, pfx->getContLen())) ||
         (sfx && sfx->getCont() &&
          TESTAFF(sfx->getCont(), compoundforbidflag,
                  sfx->getContLen())))) {
      entry_result = NULL;
    }

    // check FORCEUCASE
    if (entry_result && forceucase &&
        (TESTAFF(entry_result->astr, forceucase, entry_result->alen)) &&
       !(info && *info & SPELL_ORIGCAP))
      entry_result = NULL;

    // check forbiddenwords
    if ((entry_result) && (entry_result->astr) &&
        (TESTAFF(entry_result->astr, forbiddenword, entry_result->alen) ||
         TESTAFF(entry_result->astr, ONLYUPCASEFLAG, entry_result->alen) ||
         (is_sug && nosuggest &&
          TESTAFF(entry_result->astr, nosuggest, entry_result->alen))))
      return NULL;
  }
}