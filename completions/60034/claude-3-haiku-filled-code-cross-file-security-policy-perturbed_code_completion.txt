// MASK
// Check if the current dictionary entry is forbidden in compound words
// by checking for `COMPOUNDFORBIDFLAG`. If it is forbidden and not allowed
// by the Hungarian movement rule (`hu_mov_rule`), handle the case by either
// breaking out of a potential infinite loop or continuing the search for
// valid dictionary entries based on specific conditions such as simplified
// compound processing (`simplifiedcpd`).
// Adjust compound word boundaries if necessary.
//
// Iterate through homonyms of the current entry to find one with the
// required compound conditions. This includes conditions based on compound
// flags such as `compoundflag`, `compoundbegin`, `compoundmiddle`, and
// checks against specific compound pattern conditions (`checkcpdtable`).
// The process ensures that only valid compound components are accepted
// and it skips over invalid ones by moving to the next homonym.
if (entry_result && entry_result->astr && (TESTAFF(entry_result->astr, compoundforbidflag, entry_result->alen))) {
    if (hu_mov_rule) {
        // Allow the entry if the Hungarian movement rule is in effect
        // (i.e., the entry has the 'F', 'G', or 'H' flag)
        if (!(TESTAFF(entry_result->astr, 'F', entry_result->alen) ||
              TESTAFF(entry_result->astr, 'G', entry_result->alen) ||
              TESTAFF(entry_result->astr, 'H', entry_result->alen))) {
            entry_result = NULL;
            break;
        }
    } else {
        // The entry is forbidden and the Hungarian movement rule is not in effect
        if (simplifiedcpd) {
            // In simplified compound processing mode, continue the search for valid entries
            continue;
        } else {
            // Otherwise, break out of the loop
            break;
        }
    }
}

// Iterate through homonyms to find one with the required compound conditions
while (entry_result) {
    // Check compound flags (compoundflag, compoundbegin, compoundmiddle)
    if ((compoundflag && TESTAFF(entry_result->astr, compoundflag, entry_result->alen)) ||
        ((oldwordnum == 0) && compoundbegin && TESTAFF(entry_result->astr, compoundbegin, entry_result->alen)) ||
        ((oldwordnum > 0) && compoundmiddle && TESTAFF(entry_result->astr, compoundmiddle, entry_result->alen))) {
        // Check CHECKCOMPOUNDPATTERN conditions
        if (scpd == 0 || checkcpdtable[scpd - 1].cond == FLAG_NULL ||
            TESTAFF(entry_result->astr, checkcpdtable[scpd - 1].cond, entry_result->alen)) {
            break;
        }
    }
    entry_result = entry_result->next_homonym;
}