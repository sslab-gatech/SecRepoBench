if (entry_result)
  affixed = 0;

if (!entry_result) {
  if (onlycpdrule)
    break;
  if (compoundflag &&
      !(entry_result = prefix_check(st, 0, i,
                              hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN,
                              compoundflag))) {
    if (((entry_result = suffix_check(
              st, 0, i, 0, NULL, FLAG_NULL, compoundflag,
              hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN)) ||
         (compoundmoresuffixes &&
          (entry_result = suffix_check_twosfx(st, 0, i, 0, NULL, compoundflag)))) &&
        !hu_mov_rule && sfx->getCont() &&
        ((compoundforbidflag &&
          TESTAFF(sfx->getCont(), compoundforbidflag,
                  sfx->getContLen())) ||
         (compoundend &&
          TESTAFF(sfx->getCont(), compoundend, sfx->getContLen())))) {
      entry_result = NULL;
    }
  }

  if (entry_result ||
      (((wordnum == 0) && compoundbegin &&
        ((entry_result = suffix_check(
              st, 0, i, 0, NULL, FLAG_NULL, compoundbegin,
              hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN)) ||
         (compoundmoresuffixes &&
          (entry_result = suffix_check_twosfx(
               st, 0, i, 0, NULL,
               compoundbegin))) ||  // twofold suffixes + compound
         (entry_result = prefix_check(st, 0, i,
                              hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN,
                              compoundbegin)))) ||
       ((wordnum > 0) && compoundmiddle &&
        ((entry_result = suffix_check(
              st, 0, i, 0, NULL, FLAG_NULL, compoundmiddle,
              hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN)) ||
         (compoundmoresuffixes &&
          (entry_result = suffix_check_twosfx(
               st, 0, i, 0, NULL,
               compoundmiddle))) ||  // twofold suffixes + compound
         (entry_result = prefix_check(st, 0, i,
                              hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN,
                              compoundmiddle))))))
    checked_prefix = 1;
  // else check forbiddenwords and needaffix
} else if (entry_result->astr && (TESTAFF(entry_result->astr, forbiddenword, entry_result->alen) ||
                         TESTAFF(entry_result->astr, needaffix, entry_result->alen) ||
                         TESTAFF(entry_result->astr, ONLYUPCASEFLAG, entry_result->alen) ||
                         (is_sug && nosuggest &&
                          TESTAFF(entry_result->astr, nosuggest, entry_result->alen)))) {
  st[i] = ch;
  // continue;
  break;
}

// check non_compound flag in suffix and prefix
if ((entry_result) && !hu_mov_rule &&
    ((pfx && pfx->getCont() &&
      TESTAFF(pfx->getCont(), compoundforbidflag, pfx->getContLen())) ||
     (sfx && sfx->getCont() &&
      TESTAFF(sfx->getCont(), compoundforbidflag,
              sfx->getContLen())))) {
  entry_result = NULL;
}

// check compoundend flag in suffix and prefix
if ((entry_result) && !checked_prefix && compoundend && !hu_mov_rule &&
    ((pfx && pfx->getCont() &&
      TESTAFF(pfx->getCont(), compoundend, pfx->getContLen())) ||
     (sfx && sfx->getCont() &&
      TESTAFF(sfx->getCont(), compoundend, sfx->getContLen())))) {
  entry_result = NULL;
}

// check compoundmiddle flag in suffix and prefix
if ((entry_result) && !checked_prefix && (wordnum == 0) && compoundmiddle &&
    !hu_mov_rule &&
    ((pfx && pfx->getCont() &&
      TESTAFF(pfx->getCont(), compoundmiddle, pfx->getContLen())) ||
     (sfx && sfx->getCont() &&
      TESTAFF(sfx->getCont(), compoundmiddle, sfx->getContLen())))) {
  entry_result = NULL;
}

// check forbiddenwords
if ((entry_result) && (entry_result->astr) &&
    (TESTAFF(entry_result->astr, forbiddenword, entry_result->alen) ||
     TESTAFF(entry_result->astr, ONLYUPCASEFLAG, entry_result->alen) ||
     (is_sug && nosuggest && TESTAFF(entry_result->astr, nosuggest, entry_result->alen)))) {
  return NULL;
}

// increment word number, if the second root has a compoundroot flag
if ((entry_result) && compoundroot &&
    (TESTAFF(entry_result->astr, compoundroot, entry_result->alen))) {
  wordnum++;
}

// first word is acceptable in compound words?
if (((entry_result) &&
     (checked_prefix || (words && words[wnum]) ||
      (compoundflag && TESTAFF(entry_result->astr, compoundflag, entry_result->alen)) ||
      ((oldwordnum == 0) && compoundbegin &&
       TESTAFF(entry_result->astr, compoundbegin, entry_result->alen)) ||
      ((oldwordnum > 0) && compoundmiddle &&
       TESTAFF(entry_result->astr, compoundmiddle, entry_result->alen))

      // LANG_hu section: spec. Hungarian rule
      || ((langnum == LANG_hu) && hu_mov_rule &&
          (TESTAFF(
               entry_result->astr, 'F',
               entry_result->alen) ||  // XXX hardwired Hungarian dictionary codes
           TESTAFF(entry_result->astr, 'G', entry_result->alen) ||
           TESTAFF(entry_result->astr, 'H', entry_result->alen)))
      // END of LANG_hu section
      ) &&
     (
         // test CHECKCOMPOUNDPATTERN conditions
         scpd == 0 || checkcpdtable[scpd - 1].cond == FLAG_NULL ||
         TESTAFF(entry_result->astr, checkcpdtable[scpd - 1].cond, entry_result->alen)) &&
     !((checkcompoundtriple && scpd == 0 &&
        !words && i < word.size() && // test triple letters
        (word[i - 1] == word[i]) &&
        (((i > 1) && (word[i - 1] == word[i - 2])) ||
         ((word[i - 1] == word[i + 1]))  // may be word[i+1] == '\0'
         )) ||
       (checkcompoundcase && scpd == 0 && !words && i < word.size() &&
        cpdcase_check(word, i))))
    // LANG_hu section: spec. Hungarian rule
    || ((!entry_result) && (langnum == LANG_hu) && hu_mov_rule &&
        (entry_result = affix_check(st, 0, i)) &&
        (sfx && sfx->getCont() &&
         (  // XXX hardwired Hungarian dic. codes
             TESTAFF(sfx->getCont(), (unsigned short)'x',
                     sfx->getContLen()) ||
             TESTAFF(
                 sfx->getCont(), (unsigned short)'%',
                 sfx->getContLen()))))) {  // first word is ok condition

  // LANG_hu section: spec. Hungarian rule
  if (langnum == LANG_hu) {
    // calculate syllable number of the word
    numsyllable += get_syllable(st.substr(0, i));
    // + 1 word, if syllable number of the prefix > 1 (hungarian
    // convention)
    if (pfx && (get_syllable(pfx->getKey()) > 1))
      wordnum++;
  }
  // END of LANG_hu section

  // NEXT WORD(S)
  rv_first = entry_result;
  st[i] = ch;

  do {  // striple loop

    // check simplifiedtriple
    if (simplifiedtriple) {
      if (striple) {
        checkedstriple = 1;
        i--;  // check "fahrt" instead of "ahrt" in "Schiffahrt"
      } else if (i > 2 && i <= word.size() && word[i - 1] == word[i - 2])
        striple = 1;
    }

    entry_result = lookup(st.c_str() + i, st.size() - i);  // perhaps without prefix

    // search homonym with compound flag
    while ((entry_result) &&
           ((needaffix && TESTAFF(entry_result->astr, needaffix, entry_result->alen)) ||
            !((compoundflag && !words &&
               TESTAFF(entry_result->astr, compoundflag, entry_result->alen)) ||
              (compoundend && !words &&
               TESTAFF(entry_result->astr, compoundend, entry_result->alen)) ||
              (!defcpdtable.empty() && words &&
               defcpd_check(&words, wnum + 1, entry_result, NULL, 1))) ||
            (scpd != 0 && checkcpdtable[scpd - 1].cond2 != FLAG_NULL &&
             !TESTAFF(entry_result->astr, checkcpdtable[scpd - 1].cond2,
                      entry_result->alen)))) {
      entry_result = entry_result->next_homonym;
    }

    // check FORCEUCASE
    if (entry_result && forceucase &&
        (TESTAFF(entry_result->astr, forceucase, entry_result->alen)) &&
        !(info && *info & SPELL_ORIGCAP))
      entry_result = NULL;

    if (entry_result && words && words[wnum + 1])
      return rv_first;

    oldnumsyllable2 = numsyllable;
    oldwordnum2 = wordnum;

    // LANG_hu section: spec. Hungarian rule, XXX hardwired dictionary
    // code
    if ((entry_result) && (langnum == LANG_hu) &&
        (TESTAFF(entry_result->astr, 'I', entry_result->alen)) &&
        !(TESTAFF(entry_result->astr, 'J', entry_result->alen))) {
      numsyllable--;
    }
    // END of LANG_hu section

    // increment word number, if the second root has a compoundroot flag
    if ((entry_result) && (compoundroot) &&
        (TESTAFF(entry_result->astr, compoundroot, entry_result->alen))) {
      wordnum++;
    }

    // check forbiddenwords
    if ((entry_result) && (entry_result->astr) &&
        (TESTAFF(entry_result->astr, forbiddenword, entry_result->alen) ||
         TESTAFF(entry_result->astr, ONLYUPCASEFLAG, entry_result->alen) ||
         (is_sug && nosuggest &&
          TESTAFF(entry_result->astr, nosuggest, entry_result->alen))))
      return NULL;

    // second word is acceptable, as a root?
    // hungarian conventions: compounding is acceptable,
    // when compound forms consist of 2 words, or if more,
    // then the syllable number of root words must be 6, or lesser.

    if ((entry_result) &&
        ((compoundflag && TESTAFF(entry_result->astr, compoundflag, entry_result->alen)) ||
         (compoundend && TESTAFF(entry_result->astr, compoundend, entry_result->alen))) &&
        (((cpdwordmax == -1) || (wordnum + 1 < cpdwordmax)) ||
         ((cpdmaxsyllable != 0) &&
          (numsyllable + get_syllable(std::string(HENTRY_WORD(entry_result), entry_result->blen)) <=
           cpdmaxsyllable))) &&
        (
            // test CHECKCOMPOUNDPATTERN
            checkcpdtable.empty() || scpd !=