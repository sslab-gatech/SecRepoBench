// Check if the current dictionary entry is forbidden in compound words
        // by checking for `COMPOUNDFORBIDFLAG`. If it is forbidden and not allowed
        // by the Hungarian movement rule (`hu_mov_rule`), handle the case by either
        // breaking out of a potential infinite loop or continuing the search for
        // valid dictionary entries based on specific conditions such as simplified
        // compound processing (`simplifiedcpd`).
        // Adjust compound word boundaries if necessary.
        //
        // Iterate through homonyms of the current entry to find one with the
        // required compound conditions. This includes conditions based on compound
        // flags such as `compoundflag`, `compoundbegin`, `compoundmiddle`, and
        // checks against specific compound pattern conditions (`checkcpdtable`).
        // The process ensures that only valid compound components are accepted
        // and it skips over invalid ones by moving to the next homonym.

        while (entry_result && entry_result->astr &&
               (TESTAFF(entry_result->astr, compoundforbidflag, entry_result->alen) ||
                (hu_mov_rule && TESTAFF(entry_result->astr, compoundend, entry_result->alen)))) {
          entry_result = entry_result->next_homonym;
        }

        if (!entry_result) {
          if (onlycpdrule)
            break;
          if (compoundflag &&
              !(entry_result = prefix_check(st, 0, i,
                                  hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN,
                                  compoundflag))) {
            if (((entry_result = suffix_check(
                      st, 0, i, 0, NULL, FLAG_NULL, compoundflag,
                      hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN)) ||
                 (compoundmoresuffixes &&
                  (entry_result = suffix_check_twosfx(st, 0, i, 0, NULL, compoundflag)))) &&
                !hu_mov_rule && sfx->getCont() &&
                ((compoundforbidflag &&
                  TESTAFF(sfx->getCont(), compoundforbidflag,
                          sfx->getContLen())) ||
                 (compoundend &&
                  TESTAFF(sfx->getCont(), compoundend, sfx->getContLen())))) {
              entry_result = NULL;
            }
          }

          if (entry_result ||
              (((wordnum == 0) && compoundbegin &&
                ((entry_result = suffix_check(
                      st, 0, i, 0, NULL, FLAG_NULL, compoundbegin,
                      hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN)) ||
                 (compoundmoresuffixes &&
                  (entry_result = suffix_check_twosfx(
                       st, 0, i, 0, NULL,
                       compoundbegin))) ||  // twofold suffixes + compound
                 (entry_result = prefix_check(st, 0, i,
                                    hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN,
                                    compoundbegin)))) ||
               ((wordnum > 0) && compoundmiddle &&
                ((entry_result = suffix_check(
                      st, 0, i, 0, NULL, FLAG_NULL, compoundmiddle,
                      hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN)) ||
                 (compoundmoresuffixes &&
                  (entry_result = suffix_check_twosfx(
                       st, 0, i, 0, NULL,
                       compoundmiddle))) ||  // twofold suffixes + compound
                 (entry_result = prefix_check(st, 0, i,
                                    hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN,
                                    compoundmiddle))))))
            checked_prefix = 1;
          // else check forbiddenwords and needaffix
        } else if (entry_result->astr && (TESTAFF(entry_result->astr, forbiddenword, entry_result->alen) ||
                                TESTAFF(entry_result->astr, needaffix, entry_result->alen) ||
                                TESTAFF(entry_result->astr, ONLYUPCASEFLAG, entry_result->alen) ||
                                (is_sug && nosuggest &&
                                 TESTAFF(entry_result->astr, nosuggest, entry_result->alen)))) {
          st[i] = ch;
          // continue;
          break;
        }