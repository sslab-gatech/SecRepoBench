// check forbiddenwords
if ((entry_result) && (entry_result->astr) &&
    (TESTAFF(entry_result->astr, forbiddenword, entry_result->alen) ||
     TESTAFF(entry_result->astr, ONLYUPCASEFLAG, entry_result->alen) ||
     (is_sug && nosuggest &&
      TESTAFF(entry_result->astr, nosuggest, entry_result->alen)))) {
  st[i] = ch;
  continue;
}

// check non_compound flag in suffix and prefix
if ((entry_result) &&!hu_mov_rule &&
    ((pfx && pfx->getCont() &&
      TESTAFF(pfx->getCont(), compoundforbidflag, pfx->getContLen())) ||
     (sfx && sfx->getCont() &&
      TESTAFF(sfx->getCont(), compoundforbidflag,
              sfx->getContLen())))) {
  continue;
}

// check compoundend flag in suffix and prefix
if ((entry_result) &&!checked_prefix && compoundend &&!hu_mov_rule &&
    ((pfx && pfx->getCont() &&
      TESTAFF(pfx->getCont(), compoundend, pfx->getContLen())) ||
     (sfx && sfx->getCont() &&
      TESTAFF(sfx->getCont(), compoundend, sfx->getContLen())))) {
  continue;
}

// check compoundmiddle flag in suffix and prefix
if ((entry_result) &&!checked_prefix && (wordnum == 0) && compoundmiddle &&
   !hu_mov_rule &&
    ((pfx && pfx->getCont() &&
      TESTAFF(pfx->getCont(), compoundmiddle, pfx->getContLen())) ||
     (sfx && sfx->getCont() &&
      TESTAFF(sfx->getCont(), compoundmiddle, sfx->getContLen())))) {
  rv = NULL;
}

// check forbiddenwords
if ((entry_result) && (entry_result->astr) &&
    (TESTAFF(entry_result->astr, forbiddenword, entry_result->alen) ||
     TESTAFF(entry_result->astr, ONLYUPCASEFLAG, entry_result->alen) ||
     (is_sug && nosuggest &&
      TESTAFF(entry_result->astr, nosuggest, entry_result->alen))))
  continue;

// increment word number, if the second root has a compoundroot flag
if ((entry_result) && (compoundroot) &&
    (TESTAFF(entry_result->astr, compoundroot, entry_result->alen))) {
  wordnum++;
}

// first word is acceptable in compound words?
if (((entry_result) &&
     (checked_prefix || (words && words[wnum]) ||
      (compoundflag && TESTAFF(entry_result->astr, compoundflag, entry_result->alen)) ||
      ((oldwordnum == 0) && compoundbegin &&
       TESTAFF(entry_result->astr, compoundbegin, entry_result->alen)) ||
      ((oldwordnum > 0) && compoundmiddle &&
       TESTAFF(entry_result->astr, compoundmiddle, entry_result->alen))
     // LANG_hu section: spec. Hungarian rule
     || ((langnum == LANG_hu) &&  // hu_mov_rule
         hu_mov_rule && (TESTAFF(rv->astr, 'F', rv->alen) ||
                         TESTAFF(rv->astr, 'G', rv->alen) ||
                         TESTAFF(rv->astr, 'H', rv->alen)))
     // END of LANG_hu section
     ) &&
     (
         // test CHECKCOMPOUNDPATTERN
        !checkcpdtable.empty() &&!words &&
         cpdpat_check(word, i, rv, entry_result, affixed)) ||
     (checkcompoundtriple &&!words &&  // test triple letters
      (word[i - 1] == word[i]) &&
      (((i > 1) && (word[i - 1] == word[i - 2])) ||
       ((word[i - 1] == word[i + 1]))  // may be word[i+1] == '\0'
       )) ||
     (
         // test CHECKCOMPOUNDPATTERN conditions
         scpd == 0 || checkcpdtable[scpd - 1].cond2 == FLAG_NULL ||
         TESTAFF(entry_result->astr, checkcpdtable[scpd - 1].cond2,
                 entry_result->alen))) {
  // LANG_hu section: spec. Hungarian rule
  if (langnum == LANG_hu) {
    // calculate syllable number of the word
    numsyllable += get_syllable(st.substr(0, i));

    // + 1 word, if syllable number of the prefix > 1 (hungarian
    // convention)
    if (pfx && (get_syllable(pfx->getKey()) > 1))
      wordnum++;
  }
  // END of LANG_hu section

  // NEXT WORD(S)
  rv_first = entry_result;
  st[i] = ch;

  do {  // striple loop

    // check simplifiedtriple
    if (simplifiedtriple) {
      if (striple) {
        checkedstriple = 1;
        i--;  // check "fahrt" instead of "ahrt" in "Schiffahrt"
      } else if (i > 2 && i <= word.size() && word[i - 1] == word[i - 2])
        striple = 1;
    }

    entry_result = lookup(word.c_str() + i, word.size() - i);  // perhaps without prefix

    // search homonym with compound flag
    while ((entry_result) &&
           ((needaffix && TESTAFF(entry_result->astr, needaffix, entry_result->alen)) ||
           !((compoundflag &&!words &&
               TESTAFF(entry_result->astr, compoundflag, entry_result->alen)) ||
              (compoundend &&!words &&
               TESTAFF(entry_result->astr, compoundend, entry_result->alen)) ||
              (!defcpdtable.empty() && words &&
               defcpd_check(&words, wnum + 1, entry_result, NULL, 1)))))) {
      entry_result = entry_result->next_homonym;
    }

    // check FORCEUCASE
    if (entry_result && forceucase &&
        (TESTAFF(entry_result->astr, forceucase, entry_result->alen)) &&
       !(info && *info & SPELL_ORIGCAP))
      entry_result = NULL;

    if (entry_result && words && words[wnum + 1])
      return rv_first;

    oldnumsyllable2 = numsyllable;
    oldwordnum2 = wordnum;

    // LANG_hu section: spec. Hungarian rule
    if ((entry_result) && (langnum == LANG_hu) &&
        (TESTAFF(entry_result->astr, 'I', entry_result->alen)) &&
       !(TESTAFF(entry_result->astr, 'J', entry_result->alen))) {
      numsyllable--;
    }
    // END of LANG_hu section

    // increment word number, if the second root has a compoundroot flag
    if ((entry_result) && (compoundroot) &&
        (TESTAFF(entry_result->astr, compoundroot, entry_result->alen))) {
      wordnum++;
    }

    // check forbiddenwords
    if ((entry_result) && (entry_result->astr) &&
        (TESTAFF(entry_result->astr, forbiddenword, entry_result->alen) ||
         TESTAFF(entry_result->astr, ONLYUPCASEFLAG, entry_result->alen) ||
         (is_sug && nosuggest &&
          TESTAFF(entry_result->astr, nosuggest, entry_result->alen))))
      return NULL;

    // second word is acceptable, as a root?
    // hungarian conventions: compounding is acceptable,
    // when compound forms consist of 2 words, or if more,
    // then the syllable number of root words must be 6, or lesser.

    if ((entry_result) &&
        ((compoundflag && TESTAFF(entry_result->astr, compoundflag, entry_result->alen)) ||
         (compoundend && TESTAFF(entry_result->astr, compoundend, entry_result->alen))) &&
        (((cpdwordmax == -1) || (wordnum + 1 < cpdwordmax)) ||
         ((cpdmaxsyllable!= 0) &&
          (numsyllable + get_syllable(std::string(HENTRY_WORD(entry_result), entry_result->blen)) <=
           cpdmaxsyllable))) &&
        ((!checkcompounddup || (entry_result!= rv_first)))) {
      // bad compound word
      result.append(presult);
      result.push_back(MSEP_FLD);
      result.append(MORPH_PART);
      result.append(word, i, word.size());

      if (HENTRY_DATA(entry_result)) {
        if (complexprefixes)
          result.append(HENTRY_DATA2(entry_result));
        if (!HENTRY_FIND(entry_result, MORPH_STEM)) {
          result.push_back(MSEP_FLD);
          result.append(MORPH_STEM);
          result.append(HENTRY_WORD(entry_result));
        }
        // store the pointer of the hash entry
        if (!complexprefixes) {
          result.push_back(MSEP_FLD);
          result.append(HENTRY_DATA2(entry_result));
        }
      }
      result.push_back(MSEP_REC);
      ok = 1;
    }

    numsyllable = oldnumsyllable2;
    wordnum = oldwordnum2;

    // perhaps second word has prefix or/and suffix
    sfx = NULL;
    sfxflag = FLAG_NULL;

    if (compoundflag &&!onlycpdrule)
      rv = affix_check(word, i, word.size() - i, compoundflag);
    else
      rv = NULL;

    if (!rv && compoundend &&!onlycpdrule) {
      sfx = NULL;
      pfx = NULL;
      rv = affix_check(word, i, word.size() - i, compoundend);
    }

    if (!rv &&!defcpdtable.empty() && words) {
      rv = affix_check(word, i, word.size() - i, 0, IN_CPD_END);
      if (rv && words && defcpd_check(&words, wnum + 1, rv, NULL, 1)) {
        std::string m;
        if (compoundflag)
          m = affix_check_morph(word, i, word.size() - i, compoundflag);
        if (m.empty() && compoundend) {
          m = affix_check_morph(word, i, word.size() - i, compoundend);
        }
        result.append(presult);
        if (!m.empty()) {
          result.push_back(MSEP_FLD);
          result.append(MORPH_PART);
          result.append(word, i, word.size());
          line_uniq_app(m, MSEP_REC);
          result.append(m);
        }
        result.push_back(MSEP_REC);
        ok = 1;
      }
    }

    // check non_compound flag in suffix and prefix
    if ((entry_result) &&
        ((pfx && pfx->getCont() &&
          TESTAFF(pfx->getCont(), compoundforbidflag, pfx->getContLen())) ||
         (sfx && sfx->getCont() &&
          TESTAFF(sfx->getCont(), compoundforbidflag,
                  sfx->getContLen())))) {
      entry_result = NULL;
    }

    // check forbiddenwords
    if ((entry_result) && (entry_result->astr) &&
        (TESTAFF(entry_result->astr, forbiddenword, entry_result->alen) ||
         TESTAFF(entry_result->astr, ONLYUPCASEFLAG, entry_result->alen)) &&
        (!TESTAFF(entry_result->astr, needaffix, entry_result->alen))) {
      st[i] = ch;
      continue;
    }

    if (langnum == LANG_hu) {
      // calculate syllable number of the word
      numsyllable += get_syllable(word.c_str() + i);

      // - affix syllable num.
      // XXX only second suffix (inflections, not derivations)
      if (sfxappnd) {
        std::string tmp(sfxappnd);
        reverseword(tmp);
        numsyllable -= short(get_syllable(tmp) + sfxextra);
      } else {
        numsyllable -= short(sfxextra);
      }

      // + 1 word, if syllable number of the prefix > 1 (hungarian
      // convention)
      if (pfx && (get_syllable(pfx->getKey()) > 1))
        wordnum++;

      // increment syllable num, if last word has a SYLLABLENUM flag
      // and the suffix is beginning `s`

      if (!cpdsyllablenum.empty()) {
        switch (sfxflag) {
          case 'c': {
            numsyllable += 2;
            break;
          }
          case 'J': {
            numsyllable += 1;
            break;
          }
          case 'I': {
            if (entry_result && TESTAFF(entry_result->astr, 'J', entry_result->alen))
              numsyllable += 1;
            break;
          }
        }
      }
    }

    // increment word number, if the second word has a compoundroot flag
    if ((entry_result) && (compoundroot) &&
        (TESTAFF(entry_result->astr, compoundroot, entry_result->alen))) {
      wordnum++;
    }
    // second word is acceptable, as a word with prefix or/and suffix?
    // hungarian conventions: compounding is acceptable,
    // when compound forms consist 2 word, otherwise
    // the syllable number of root words is 6, or lesser.
    if ((entry_result) &&
        (((cpdwordmax == -1) || (wordnum + 1 < cpdwordmax)) ||
         ((cpdmaxsyllable!= 0) && (numsyllable <= cpdmaxsyllable))) &&
        ((!checkcompounddup || (entry_result!= rv_first)))) {
      std::string m;
      if (compoundflag)
        m = affix_check_morph(word, i, word.size() - i, compoundflag);
      if (m.empty() && compoundend) {
        m = affix_check_morph(word, i, word.size() - i, compoundend);
      }
      result.append(presult);
      if (!m.empty()) {