{
  auto write_offset = [c, offsetSize](unsigned int value) -> bool {
    switch (offsetSize)
    {
      case 1:
        c->write_value((uint8_t)value);
        break;
      case 2:
        c->write_value((uint16_t)value);
        break;
      case 3:
      {
        uint8_t bytes[3] = { (uint8_t)(value >> 16), (uint8_t)(value >> 8), (uint8_t)value };
        c->write_bytes(bytes, 3);
        break;
      }
      case 4:
        c->write_value((uint32_t)value);
        break;
      default:
        return false;
    }
    return true;
  };

  unsigned int current_offset = 1; // The first offset is always 1.
  if (unlikely(!write_offset(current_offset)))
    return_trace(false);

  // Iterate over all font dictionaries; for each that is remapped,
  // compute its serialized size and update the offsets accordingly.
  for (unsigned int i = 0; i < fontDicts.length; i++)
  {
    if (fdmap.includes(i))
    {
      unsigned int dictSize = FontDict::calculate_serialized_size(fontDicts[i], opszr, privateInfos[fdmap[i]]);
      current_offset += dictSize;
      if (unlikely(!write_offset(current_offset)))
        return_trace(false);
    }
  }
}