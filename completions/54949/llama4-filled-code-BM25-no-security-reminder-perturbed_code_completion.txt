else if (ctx.pos < ctx.end && *ctx.pos == '=') 
    // Attempt to parse the data as a dictionary of 'strings'.
    // If parsing fails, free the allocated plist and set an error code.
    // If parsing succeeds, assign the newly created dictionary to the plist.
    {
        plist_t dict = plist_new_dict();
        ctx.pos++;
        parse_skip_ws(&ctx);
        if (*ctx.pos != '{') {
            err = PLIST_ERR_PARSE;
            plist_free(dict);
        } else {
            ctx.pos++;
            while (ctx.pos < ctx.end && *ctx.pos != '}') {
                plist_t key = NULL;
                plist_t value = NULL;
                err = node_from_openstep(&ctx, &key);
                if (err != 0 || !key || key->data_type != PLIST_STRING) {
                    plist_free(key);
                    plist_free(dict);
                    break;
                }
                parse_skip_ws(&ctx);
                if (*ctx.pos != '=') {
                    err = PLIST_ERR_PARSE;
                    plist_free(key);
                    plist_free(dict);
                    break;
                }
                ctx.pos++;
                parse_skip_ws(&ctx);
                err = node_from_openstep(&ctx, &value);
                if (err != 0 || !value) {
                    plist_free(key);
                    plist_free(value);
                    plist_free(dict);
                    break;
                }
                plist_dict_set_item(dict, key->data.strval, value);
                plist_free(key);
                parse_skip_ws(&ctx);
                if (*ctx.pos == ',') {
                    ctx.pos++;
                    parse_skip_ws(&ctx);
                }
            }
            if (err == 0 && *ctx.pos == '}') {
                ctx.pos++;
                *plist = dict;
            } else {
                plist_free(dict);
            }
        }
    }