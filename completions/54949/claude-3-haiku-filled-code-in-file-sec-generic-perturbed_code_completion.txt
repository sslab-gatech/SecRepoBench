// Attempt to parse the data as a dictionary of 'strings'.
// If parsing fails, free the allocated plist and set an error code.
// If parsing succeeds, assign the newly created dictionary to the plist.
{
    plist_t dict = plist_new_dict();
    parse_ctx ctx = { plistopenstep, plistopenstep, plistopenstep + length, 0 };
    parse_skip_ws(&ctx);
    while (ctx.pos < ctx.end && *ctx.pos != '}') {
        plist_t key = NULL;
        ctx.err = node_from_openstep(&ctx, &key);
        if (ctx.err != 0 || !PLIST_IS_STRING(key)) {
            plist_free(dict);
            return PLIST_ERR_PARSE;
        }
        parse_skip_ws(&ctx);
        if (*ctx.pos != '=') {
            plist_free(key);
            plist_free(dict);
            return PLIST_ERR_PARSE;
        }
        ctx.pos++;
        plist_t val = NULL;
        ctx.err = node_from_openstep(&ctx, &val);
        if (ctx.err != 0 || !val) {
            plist_free(key);
            plist_free(dict);
            return PLIST_ERR_PARSE;
        }
        plist_dict_set_item(dict, plist_get_string_ptr(key, NULL), val);
        plist_free(key);
        parse_skip_ws(&ctx);
        if (*ctx.pos != ';') {
            plist_free(dict);
            return PLIST_ERR_PARSE;
        }
        ctx.pos++;
    }
    *plist = dict;
    return PLIST_ERR_SUCCESS;
}