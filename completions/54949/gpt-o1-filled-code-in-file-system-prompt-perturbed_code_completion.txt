{
    /* We'll attempt to parse everything following the '=' as a "flat" dictionary of string keys and values. */
    plist_t dict = plist_new_dict();

    /* The current *plist is presumably our first "key" (already parsed), which must be a string. */
    if (!*plist || !PLIST_IS_STRING(*plist))
    {
        PLIST_OSTEP_ERR("Left-hand side of '=' is not a valid string key at offset %ld\n", ctx.pos - ctx.start);
        plist_free(dict);
        plist_free(*plist);
        *plist = NULL;
        ctx.err++;
        return PLIST_ERR_PARSE;
    }

    /* Store that key, then parse the value immediately following '='. */
    char *first_key = plist_get_string_ptr(*plist, NULL);
    plist_free(*plist);
    *plist = NULL;

    /* Skip '=' */
    ctx.pos++;
    parse_skip_ws(&ctx);

    /* Parse the value node. */
    plist_t first_val = NULL;
    ctx.err = node_from_openstep(&ctx, &first_val);
    if (ctx.err || !first_val)
    {
        PLIST_OSTEP_ERR("Could not parse dictionary value at offset %ld\n", ctx.pos - ctx.start);
        plist_free(dict);
        return PLIST_ERR_PARSE;
    }

    parse_skip_ws(&ctx);
    if (ctx.pos >= ctx.end || *ctx.pos != ';')
    {
        PLIST_OSTEP_ERR("Missing terminating ';' for dictionary item at offset %ld\n", ctx.pos - ctx.start);
        plist_free(first_val);
        plist_free(dict);
        ctx.err++;
        return PLIST_ERR_PARSE;
    }
    ctx.pos++;
    parse_skip_ws(&ctx);

    /* Add the first key-value pair. */
    plist_dict_set_item(dict, first_key, first_val);

    /* Now parse subsequent "key = value;" pairs until we can no longer do so. */
    while (ctx.pos < ctx.end && !ctx.err)
    {
        parse_skip_ws(&ctx);
        /* If the next character doesn't look like a string (quoted or unquoted), break out. */
        if (*ctx.pos != '"' && *ctx.pos != '\'' && !allowed_unquoted_chars[(unsigned char)*ctx.pos])
            break;

        /* Parse the next key (which must be a string). */
        plist_t k = NULL;
        ctx.err = node_from_openstep(&ctx, &k);
        if (ctx.err || !k || !PLIST_IS_STRING(k))
        {
            PLIST_OSTEP_ERR("Invalid dictionary key at offset %ld\n", ctx.pos - ctx.start);
            plist_free(k);
            break;
        }

        parse_skip_ws(&ctx);
        if (ctx.pos >= ctx.end || *ctx.pos != '=')
        {
            PLIST_OSTEP_ERR("Missing '=' while parsing dictionary item at offset %ld\n", ctx.pos - ctx.start);
            plist_free(k);
            ctx.err++;
            break;
        }

        ctx.pos++;
        parse_skip_ws(&ctx);

        /* Parse the value. */
        plist_t v = NULL;
        ctx.err = node_from_openstep(&ctx, &v);
        if (ctx.err || !v)
        {
            PLIST_OSTEP_ERR("Could not parse dictionary value at offset %ld\n", ctx.pos - ctx.start);
            plist_free(k);
            break;
        }

        parse_skip_ws(&ctx);
        if (ctx.pos >= ctx.end || *ctx.pos != ';')
        {
            PLIST_OSTEP_ERR("Missing terminating ';' for dictionary item at offset %ld\n", ctx.pos - ctx.start);
            plist_free(k);
            plist_free(v);
            ctx.err++;
            break;
        }

        ctx.pos++;
        parse_skip_ws(&ctx);

        /* Add the key-value pair to our dictionary. */
        plist_dict_set_item(dict, plist_get_string_ptr(k, NULL), v);
        plist_free(k);
    }

    /* If we encountered an error, free everything and return. */
    if (ctx.err)
    {
        plist_free(dict);
        return PLIST_ERR_PARSE;
    }

    /* Success: assign the newly created dictionary to *plist. */
    *plist = dict;
}