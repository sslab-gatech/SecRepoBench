Below is the content of a C/C++ function where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
PLIST_API int plist_from_openstep(const char *plistopenstep, uint32_t length, plist_t * plist)
{
    if (!plist) {
        return PLIST_ERR_INVALID_ARG;
    }
    *plist = NULL;
    if (!plistopenstep || (length == 0)) {
        return PLIST_ERR_INVALID_ARG;
    }

    struct _parse_ctx ctx = { plistopenstep, plistopenstep, plistopenstep + length, 0 };

    int err = node_from_openstep(&ctx, plist);
    if (err == 0) {
        if (!*plist) {
            /* whitespace only file is considered an empty dictionary */
            *plist = plist_new_dict();
        } else if (ctx.pos < ctx.end && *ctx.pos == '=') 
        // Attempt to parse the data as a dictionary of 'strings'.
        // If parsing fails, free the allocated plist and set an error code.
        // If parsing succeeds, assign the newly created dictionary to the plist.
        // <MASK>
    }

    return err;
}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/oplist.c
PLIST_API int plist_to_openstep(plist_t plist, char **openstep, uint32_t* length, int prettify)
{
    uint64_t size = 0;
    int res;

    if (!plist || !openstep || !length) {
        return PLIST_ERR_INVALID_ARG;
    }

    res = node_estimate_size(plist, &size, 0, prettify);
    if (res < 0) {
        return res;
    }

    strbuf_t *outbuf = str_buf_new(size);
    if (!outbuf) {
        PLIST_OSTEP_WRITE_ERR("Could not allocate output buffer");
        return PLIST_ERR_NO_MEM;
    }

    res = node_to_openstep(plist, &outbuf, 0, prettify);
    if (res < 0) {
        str_buf_free(outbuf);
        *openstep = NULL;
        *length = 0;
        return res;
    }
    if (prettify) {
        str_buf_append(outbuf, "\n", 1);
    }

    str_buf_append(outbuf, "\0", 1);

    *openstep = outbuf->data;
    *length = outbuf->len - 1;

    outbuf->data = NULL;
    str_buf_free(outbuf);

    return PLIST_ERR_SUCCESS;
}

// the below code fragment can be found in:
// src/plist.c
PLIST_API plist_err_t plist_from_memory(const char *plist_data, uint32_t length, plist_t * plist)
{
    int res = -1;
    if (!plist) {
        return PLIST_ERR_INVALID_ARG;
    }
    *plist = NULL;
    if (!plist_data || length == 0) {
        return PLIST_ERR_INVALID_ARG;
    }
    if (plist_is_binary(plist_data, length)) {
        res = plist_from_bin(plist_data, length, plist);
    } else {
        uint32_t pos = 0;
        int is_json = 0;
        int is_xml = 0;
        /* skip whitespace */
        SKIP_WS(plist_data, pos, length);
        if (plist_data[pos] == '<' && (length-pos > 3) && !isxdigit(plist_data[pos+1]) && !isxdigit(plist_data[pos+2]) && !isxdigit(plist_data[pos+3])) {
            is_xml = 1;
        } else if (plist_data[pos] == '[') {
            /* only valid for json */
            is_json = 1;
        } else if (plist_data[pos] == '(') {
            /* only valid for openstep */
        } else if (plist_data[pos] == '{') {
            /* this could be json or openstep */
            pos++;
            SKIP_WS(plist_data, pos, length);
            if (plist_data[pos] == '"') {
                /* still could be both */
                pos++;
                do {
                    FIND_NEXT(plist_data, pos, length, '"');
                    if (plist_data[pos-1] != '\\') {
                        break;
                    }
                    pos++;
                } while (pos < length);
                if (plist_data[pos] == '"') {
                    pos++;
                    SKIP_WS(plist_data, pos, length);
                    if (plist_data[pos] == ':') {
                        /* this is definitely json */
                        is_json = 1;
                    }
                }
            }
        }
        if (is_xml) {
            res = plist_from_xml(plist_data, length, plist);
        } else if (is_json) {
            res = plist_from_json(plist_data, length, plist);
        } else {
            res = plist_from_openstep(plist_data, length, plist);
        }
    }
    return res;
}

// the below code fragment can be found in:
// src/oplist.c
static int node_from_openstep(parse_ctx ctx, plist_t *plist)
{
    plist_t subnode = NULL;
    const char *p = NULL;
    while (ctx->pos < ctx->end && !ctx->err) {
        parse_skip_ws(ctx);
        if (ctx->pos >= ctx->end) {
            break;
        }
        plist_data_t data = plist_new_plist_data();
        if (*ctx->pos == '{') {
            data->type = PLIST_DICT;
            subnode = plist_new_node(data);
            ctx->pos++;
            parse_dict_data(ctx, subnode);
            if (ctx->err) {
                goto err_out;
            }
            if (*ctx->pos != '}') {
                PLIST_OSTEP_ERR("Missing terminating '}' at offset %ld\n", ctx->pos - ctx->start);
                ctx->err++;
                goto err_out;
            }
            ctx->pos++;
            *plist = subnode;
            parse_skip_ws(ctx);
            break;
        } else if (*ctx->pos == '(') {
            data->type = PLIST_ARRAY;
            subnode = plist_new_node(data);
            ctx->pos++;
            plist_t tmp = NULL;
            while (ctx->pos < ctx->end && !ctx->err) {
                parse_skip_ws(ctx);
                if (*ctx->pos == ')') {
                    break;
                }
                ctx->err = node_from_openstep(ctx, &tmp);
                if (ctx->err != 0) {
                    break;
                }
                if (!tmp) {
                    ctx->err++;
                    break;
                }
                plist_array_append_item(subnode, tmp);
                tmp = NULL;
                parse_skip_ws(ctx);
                if (*ctx->pos != ',') {
                    break;
                }
                ctx->pos++;
            }
            if (ctx->err) {
                goto err_out;
            }
            if (*ctx->pos != ')') {
                PLIST_OSTEP_ERR("Missing terminating ')' at offset %ld\n", ctx->pos - ctx->start);
                ctx->err++;
                goto err_out;
            }
            ctx->pos++;
            *plist = subnode;
            parse_skip_ws(ctx);
            break;
        } else if (*ctx->pos == '<') {
            data->type = PLIST_DATA;
            ctx->pos++;
            bytearray_t *bytes = byte_array_new(256);
            while (ctx->pos < ctx->end && !ctx->err) {
                parse_skip_ws(ctx);
                if (*ctx->pos == '>') {
                    break;
                }
                if (!isxdigit(*ctx->pos)) {
                    PLIST_OSTEP_ERR("Invalid byte group in data at offset %ld\n", ctx->pos - ctx->start);
                    ctx->err++;
                    break;
                }
                uint8_t b = HEX_DIGIT(*ctx->pos);
                ctx->pos++;
                if (ctx->pos >= ctx->end) {
                    PLIST_OSTEP_ERR("Unexpected end of data at offset %ld\n", ctx->pos - ctx->start);
                    ctx->err++;
                    break;
                }
                if (!isxdigit(*ctx->pos)) {
                    PLIST_OSTEP_ERR("Invalid byte group in data at offset %ld\n", ctx->pos - ctx->start);
                    ctx->err++;
                    break;
                }
                b = (b << 4) + HEX_DIGIT(*ctx->pos);
                byte_array_append(bytes, &b, 1);
                ctx->pos++;
            }
            if (ctx->err) {
                byte_array_free(bytes);
                plist_free_data(data);
                goto err_out;
            }
            if (*ctx->pos != '>') {
                byte_array_free(bytes);
                plist_free_data(data);
                PLIST_OSTEP_ERR("Missing terminating '>' at offset %ld\n", ctx->pos - ctx->start);
                ctx->err++;
                goto err_out;
            }
            ctx->pos++;
            data->buff = bytes->data;
            data->length = bytes->len;
            bytes->data = NULL;
            byte_array_free(bytes);
            *plist = plist_new_node(data);
            parse_skip_ws(ctx);
            break;
        } else if (*ctx->pos == '"' || *ctx->pos == '\'') {
            char c = *ctx->pos;
            ctx->pos++;
            p = ctx->pos;
            int num_escapes = 0;
            while (ctx->pos < ctx->end) {
                if (*ctx->pos == '\\') {
                    num_escapes++;
                }
                if ((*ctx->pos == c) && (*(ctx->pos-1) != '\\')) {
                    break;
                }
                ctx->pos++;
            }
            if (*ctx->pos != c) {
                plist_free_data(data);
                PLIST_OSTEP_ERR("Missing closing quote (%c) at offset %ld\n", c, ctx->pos - ctx->start);
                ctx->err++;
                goto err_out;
            }
            size_t slen = ctx->pos - p;
            ctx->pos++; // skip the closing quote
            char* strbuf = malloc(slen+1);
            if (num_escapes > 0) {
                size_t i = 0;
                size_t o = 0;
                while (i < slen) {
                    if (p[i] == '\\') {
                        /* handle escape sequence */
                        i++;
                        switch (p[i]) {
                            case '0':
                            case '1':
                            case '2':
                            case '3':
                            case '4':
                            case '5':
                            case '6':
                            case '7': {
                                // max 3 digits octal
                                unsigned char chr = 0;
                                int maxd = 3;
                                while ((i < slen) && (p[i] >= '0' && p[i] <= '7') && --maxd) {
                                    chr = (chr << 3) + p[i] - '0';
                                    i++;
                                }
                                strbuf[o++] = (char)chr;
                            }   break;
                            case 'U': {
                                i++;
                                // max 4 digits hex
                                uint16_t wchr = 0;
                                int maxd = 4;
                                while ((i < slen) && isxdigit(p[i]) && maxd--) {
                                    wchr = (wchr << 4) + ((p[i] <= '9') ? (p[i] - '0') : ((p[i] <= 'F') ? (p[i] - 'A' + 10) : (p[i] - 'a' + 10)));
                                    i++;
                                }
                                if (wchr >= 0x800) {
                                    strbuf[o++] = (char)(0xE0 + ((wchr >> 12) & 0xF));
                                    strbuf[o++] = (char)(0x80 + ((wchr >> 6) & 0x3F));
                                    strbuf[o++] = (char)(0x80 + (wchr & 0x3F));
                                } else if (wchr >= 0x80) {
                                    strbuf[o++] = (char)(0xC0 + ((wchr >> 6) & 0x1F));
                                    strbuf[o++] = (char)(0x80 + (wchr & 0x3F));
                                } else {
                                    strbuf[o++] = (char)(wchr & 0x7F);
                                }
                            }   break;
                            case 'a': strbuf[o++] = '\a'; i++; break;
                            case 'b': strbuf[o++] = '\b'; i++; break;
                            case 'f': strbuf[o++] = '\f'; i++; break;
                            case 'n': strbuf[o++] = '\n'; i++; break;
                            case 'r': strbuf[o++] = '\r'; i++; break;
                            case 't': strbuf[o++] = '\t'; i++; break;
                            case 'v': strbuf[o++] = '\v'; i++; break;
                            case '"': strbuf[o++] = '"';  i++; break;
                            case '\'': strbuf[o++] = '\''; i++; break;
                            default:
                                break;
                        }
                    } else {
                        strbuf[o++] = p[i++];
                    }
                }
                strbuf[o] = '\0';
                slen = o;
            } else {
                strncpy(strbuf, p, slen);
                strbuf[slen] = '\0';
            }
            data->type = PLIST_STRING;
            data->strval = strbuf;
            data->length = slen;
            *plist = plist_new_node(data);
            parse_skip_ws(ctx);
            break;
        } else {
            // unquoted string
            size_t slen = 0;
            parse_skip_ws(ctx);
            p = ctx->pos;
            while (ctx->pos < ctx->end) {
                if (!allowed_unquoted_chars[(uint8_t)*ctx->pos]) {
                    break;
                }
                ctx->pos++;
            }
            slen = ctx->pos-p;
            if (slen > 0) {
                data->type = PLIST_STRING;
                data->strval = strndup(p, slen);
                data->length = slen;
                *plist = plist_new_node(data);
                parse_skip_ws(ctx);
                break;
            } else {
                plist_free_data(data);
                PLIST_OSTEP_ERR("Unexpected character when parsing unquoted string at offset %ld\n", ctx->pos - ctx->start);
                ctx->err++;
                break;
            }
        }
        ctx->pos++;
    }

err_out:
    if (ctx->err) {
        plist_free(subnode);
        plist_free(*plist);
        *plist = NULL;
        return PLIST_ERR_PARSE;
    }
    return PLIST_ERR_SUCCESS;
}

// the below code fragment can be found in:
// src/xplist.c
PLIST_API plist_err_t plist_from_xml(const char *plist_xml, uint32_t length, plist_t * plist)
{
    if (!plist) {
        return PLIST_ERR_INVALID_ARG;
    }
    *plist = NULL;
    if (!plist_xml || (length == 0)) {
        return PLIST_ERR_INVALID_ARG;
    }

    struct _parse_ctx ctx = { plist_xml, plist_xml + length, 0 };

    return node_from_xml(&ctx, plist);
}

// the below code fragment can be found in:
// src/jplist.c
PLIST_API int plist_from_json(const char *json, uint32_t length, plist_t * plist)
{
    if (!plist) {
        return PLIST_ERR_INVALID_ARG;
    }
    *plist = NULL;
    if (!json || (length == 0)) {
        return PLIST_ERR_INVALID_ARG;
    }

    jsmn_parser parser;
    jsmn_init(&parser);
    int maxtoks = 256;
    int curtoks = 0;
    int r = 0;
    jsmntok_t *tokens = NULL;

    do {
        jsmntok_t* newtokens = realloc(tokens, sizeof(jsmntok_t)*maxtoks);
        if (!newtokens) {
            PLIST_JSON_ERR("%s: Out of memory\n", __func__);
            return PLIST_ERR_NO_MEM;
        }
        memset((unsigned char*)newtokens + sizeof(jsmntok_t)*curtoks, '\0', sizeof(jsmntok_t)*(maxtoks-curtoks));
        tokens = newtokens;
        curtoks = maxtoks;

        r = jsmn_parse(&parser, json, length, tokens, maxtoks);
        if (r == JSMN_ERROR_NOMEM) {
            maxtoks+=16;
            continue;
        }
    } while (r == JSMN_ERROR_NOMEM);

    switch(r) {
        case JSMN_ERROR_NOMEM:
            PLIST_JSON_ERR("%s: Out of memory...\n", __func__);
            free(tokens);
            return PLIST_ERR_NO_MEM;
        case JSMN_ERROR_INVAL:
            PLIST_JSON_ERR("%s: Invalid character inside JSON string\n", __func__);
            free(tokens);
            return PLIST_ERR_PARSE;
        case JSMN_ERROR_PART:
            PLIST_JSON_ERR("%s: Incomplete JSON, more bytes expected\n", __func__);
            free(tokens);
            return PLIST_ERR_PARSE;
        default:
            break;
    }

    int startindex = 0;
    jsmntok_info_t ti = { tokens, parser.toknext };
    switch (tokens[startindex].type) {
        case JSMN_PRIMITIVE:
            *plist = parse_primitive(json, &ti, &startindex);
            break;
        case JSMN_STRING:
            *plist = parse_string(json, &ti, &startindex);
            break;
        case JSMN_ARRAY:
            *plist = parse_array(json, &ti, &startindex);
            break;
        case JSMN_OBJECT:
            *plist = parse_object(json, &ti, &startindex);
            break;
        default:
            break;
    }
    free(tokens);
    return PLIST_ERR_SUCCESS;
}
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).