if (ctx->pos < ctx->end && *ctx->pos == '=') {
    plist_t dict = plist_new_dict();
    plist_t key = NULL;
    plist_t value = NULL;
    while (ctx->pos < ctx->end && !ctx->err) {
        parse_skip_ws(ctx);
        if (*ctx->pos == '"' || *ctx->pos == '\'') {
            char c = *ctx->pos;
            ctx->pos++;
            p = ctx->pos;
            int num_escapes = 0;
            while (ctx->pos < ctx->end) {
                if (*ctx->pos == '\\') {
                    num_escapes++;
                }
                if ((*ctx->pos == c) && (*(ctx->pos-1) != '\\')) {
                    break;
                }
                ctx->pos++;
            }
            if (*ctx->pos != c) {
                PLIST_OSTEP_ERR("Missing closing quote (%c) at offset %ld\n", c, ctx->pos - ctx->start);
                ctx->err++;
                goto err_out;
            }
            size_t slen = ctx->pos - p;
            ctx->pos++; // skip the closing quote
            char* strbuf = malloc(slen+1);
            if (num_escapes > 0) {
                // ... (same as the existing code for handling escaped strings)
            } else {
                // ... (same as the existing code for handling unescaped strings)
            }
            key = plist_new_string(strbuf, slen);
            parse_skip_ws(ctx);
            if (*ctx->pos != '=') {
                PLIST_OSTEP_ERR("Missing '=' at offset %ld\n", ctx->pos - ctx->start);
                ctx->err++;
                goto err_out;
            }
            ctx->pos++;
            parse_skip_ws(ctx);
            if (*ctx->pos == '{') {
                ctx->pos++;
                parse_dict_data(ctx, &value);
                if (ctx->err) {
                    goto err_out;
                }
                if (*ctx->pos != '}') {
                    PLIST_OSTEP_ERR("Missing terminating '}' at offset %ld\n", ctx->pos - ctx->start);
                    ctx->err++;
                    goto err_out;
                }
                ctx->pos++;
            } else if (*ctx->pos == '(') {
                ctx->pos++;
                plist_t tmp = NULL;
                while (ctx->pos < ctx->end && !ctx->err) {
                    parse_skip_ws(ctx);
                    if (*ctx->pos == ')') {
                        break;
                    }
                    ctx->err = node_from_openstep(ctx, &tmp);
                    if (ctx->err != 0) {
                        break;
                    }
                    if (!tmp) {
                        ctx->err++;
                        break;
                    }
                    if (value == NULL) {
                        value = plist_new_array();
                    }
                    plist_array_append_item(value, tmp);
                    tmp = NULL;
                    parse_skip_ws(ctx);
                    if (*ctx->pos != ',') {
                        break;
                    }
                    ctx->pos++;
                }
                if (ctx->err) {
                    goto err_out;
                }
                if (*ctx->pos != ')') {
                    PLIST_OSTEP_ERR("Missing terminating ')' at offset %ld\n", ctx->pos - ctx->start);
                    ctx->err++;
                    goto err_out;
                }
                ctx->pos++;
            } else {
                // ... (same as the existing code for parsing other data types)
            }
            plist_dict_set_item(dict, key, value);
            parse_skip_ws(ctx);
            if (*ctx->pos != ',') {
                break;
            }
            ctx->pos++;
        } else {
            PLIST_OSTEP_ERR("Invalid key at offset %ld\n", ctx->pos - ctx->start);
            ctx->err++;
            goto err_out;
        }
    }
    if (ctx->err) {
        goto err_out;
    }
    *plist = dict;
}

err_out:
if (ctx->err) {
    plist_free(dict);
    *plist = NULL;
}
return ctx->err;