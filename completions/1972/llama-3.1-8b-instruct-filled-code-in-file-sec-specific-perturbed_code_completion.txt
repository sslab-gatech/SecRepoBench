static void
xmlSnprintfElementContent(char *buf, int capacity, xmlElementContentPtr content, int englob) {
    int len;

    if (content == NULL) return;
    len = strlen(buf);
    if (capacity - len < 50) {
	if ((capacity - len > 4) && (buf[len - 1]!= '.'))
	    strcat(buf, "...");
	return;
    }
    if (englob) strcat(buf, "(");
    // Append the content representation to the buffer based on the type of XML element content.
    // Handle different content types: PCDATA, ELEMENT, SEQ (sequence), and OR (choice).
    // For PCDATA, append the literal "#PCDATA" to the buffer.
    // For ELEMENT, append the element name, optionally prefixed with its namespace prefix.
    // For SEQ, process both sub-elements in sequence, appending them with a comma delimiter.
    // For OR, process both sub-elements as alternatives, appending them with a pipe delimiter.
    // Recursively call the function for nested content elements, determining whether to enclose them in parentheses.
    // Ensure the buffer has enough space to append content or indicate truncation with "...".
    switch (content->type) {
        case XML_ELEMENT_CONTENT_PCDATA:
	    strcat(buf, "#PCDATA");
	    break;
	case XML_ELEMENT_CONTENT_ELEMENT: {
	    xmlChar fn[50];
	    xmlChar *fullname;

	    fullname = xmlBuildQName(content->name, content->prefix, fn, 50);
	    if (fullname == NULL) {
	        xmlVErrMemory(NULL, "Building content model");
		return;
	    }

	    if (englob)
	        strcat(buf, "(");
	    if (content->prefix!= NULL) {
		strcat(buf, (char *) content->prefix);
		strcat(buf, ":");
	    }
	    strcat(buf, (char *) fullname);
	    if (englob)
	        strcat(buf, ")");
	    break;
	}
	case XML_ELEMENT_CONTENT_SEQ: {
	    if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||
	        (content->c1->type == XML_ELEMENT_CONTENT_SEQ))
		xmlSnprintfElementContent(buf, capacity, content->c1, 1);
	    else
		xmlSnprintfElementContent(buf, capacity, content->c1, 0);
            strcat(buf, ", ");
	    if ((content->c2->type == XML_ELEMENT_CONTENT_OR) ||
	        ((content->c2->type == XML_ELEMENT_CONTENT_SEQ) &&
		 (content->c2->ocur!= XML_ELEMENT_CONTENT_ONCE)))
		xmlSnprintfElementContent(buf, capacity, content->c2, 1);
	    else
		xmlSnprintfElementContent(buf, capacity, content->c2, 0);
	    break;
	}
	case XML_ELEMENT_CONTENT_OR: {
	    if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||
	        (content->c1->type == XML_ELEMENT_CONTENT_SEQ))
		xmlSnprintfElementContent(buf, capacity, content->c1, 1);
	    else
		xmlSnprintfElementContent(buf, capacity, content->c1, 0);
            strcat(buf, " | ");
	    if ((content->c2->type == XML_ELEMENT_CONTENT_SEQ) ||
	        ((content->c2->type == XML_ELEMENT_CONTENT_OR) &&
		 (content->c2->ocur!= XML_ELEMENT_CONTENT_ONCE)))
		xmlSnprintfElementContent(buf, capacity, content->c2, 1);
	    else
		xmlSnprintfElementContent(buf, capacity, content->c2, 0);
	    break;
	}
	default:
	    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
		    "Internal: ELEMENT content corrupted invalid type\n",
		    NULL);
    }
    if (englob)
        strcat(buf, ")");
    switch (content->ocur) {
        case XML_ELEMENT_CONTENT_ONCE:
	    break;
        case XML_ELEMENT_CONTENT_OPT:
	    strcat(buf, "?");
	    break;
        case XML_ELEMENT_CONTENT_MULT:
	    strcat(buf, "*");
	    break;
        case XML_ELEMENT_CONTENT_PLUS:
	    strcat(buf, "+");
	    break;
    }
}