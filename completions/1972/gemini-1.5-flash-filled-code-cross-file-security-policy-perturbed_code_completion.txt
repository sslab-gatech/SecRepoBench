switch (content->type) {
    case XML_ELEMENT_CONTENT_PCDATA:
	len = strlen(buf);
	if (capacity - len < 10) {
	    if ((capacity - len > 4) && (buf[len - 1] != '.'))
		strcat(buf, " ...");
	    return;
	}
	strcat(buf, "#PCDATA");
	break;
    case XML_ELEMENT_CONTENT_ELEMENT:
	{
	    int prefixLen = 0;
	    const xmlChar *prefix = content->element.prefix;
	    if (prefix != NULL) {
		prefixLen = strlen((const char *)prefix);
		len = strlen(buf);
		if (capacity - len < prefixLen + strlen((const char *)content->element.name) + 2) {
		    if ((capacity - len > 4) && (buf[len - 1] != '.'))
			strcat(buf, " ...");
		    return;
		}
		strcat(buf, (const char *)prefix);
		strcat(buf, ":");
	    }
	    len = strlen(buf);
	    if (capacity - len < strlen((const char *)content->element.name)) {
		if ((capacity - len > 4) && (buf[len - 1] != '.'))
		    strcat(buf, " ...");
		return;
	    }
	    strcat(buf, (const char *)content->element.name);
	}
	break;
    case XML_ELEMENT_CONTENT_SEQ:
	xmlSnprintfElementContent(buf, capacity, content->sequence.first, 0);
	len = strlen(buf);
	if (capacity - len < 2) {
	    if ((capacity - len > 4) && (buf[len - 1] != '.'))
		strcat(buf, " ...");
	    return;
	}
	strcat(buf, ",");
	xmlSnprintfElementContent(buf, capacity, content->sequence.second, 0);
	break;
    case XML_ELEMENT_CONTENT_OR:
	xmlSnprintfElementContent(buf, capacity, content->choice.first, 0);
	len = strlen(buf);
	if (capacity - len < 2) {
	    if ((capacity - len > 4) && (buf[len - 1] != '.'))
		strcat(buf, " ...");
	    return;
	}
	strcat(buf, "|");
	xmlSnprintfElementContent(buf, capacity, content->choice.second, 0);
	break;
    }