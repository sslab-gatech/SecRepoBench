switch (content->type) {
        case XML_ELEMENT_CONTENT_PCDATA:
            /* Handle PCDATA */
            if (capacity - strlen(buf) < 8) {
                /* Not enough space to append "#PCDATA" safely */
                if ((capacity - strlen(buf) > 4) && (buf[strlen(buf) - 1] != '.'))
                    strcat(buf, " ...");
                return;
            }
            strcat(buf, "#PCDATA");
            break;

        case XML_ELEMENT_CONTENT_ELEMENT:
            /* Handle element name, optionally with its prefix */
            if (content->prefix != NULL) {
                if (capacity - strlen(buf) < (xmlStrlen(content->prefix) + xmlStrlen(content->name) + 10)) {
                    if ((capacity - strlen(buf) > 4) && (buf[strlen(buf) - 1] != '.'))
                        strcat(buf, " ...");
                    return;
                }
                strcat(buf, (const char *) content->prefix);
                strcat(buf, ":");
            } else {
                if (capacity - strlen(buf) < (xmlStrlen(content->name) + 10)) {
                    if ((capacity - strlen(buf) > 4) && (buf[strlen(buf) - 1] != '.'))
                        strcat(buf, " ...");
                    return;
                }
            }
            strcat(buf, (const char *) content->name);
            break;

        case XML_ELEMENT_CONTENT_SEQ:
            /* Handle sequence: content->c1 followed by ", " then content->c2 */
            if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||
                ((content->c1->type == XML_ELEMENT_CONTENT_SEQ) &&
                 (content->c1->ocur != XML_ELEMENT_CONTENT_ONCE))) {
                xmlSnprintfElementContent(buf, capacity, content->c1, 1);
            } else {
                xmlSnprintfElementContent(buf, capacity, content->c1, 0);
            }
            if (capacity - strlen(buf) < 4) {
                if ((capacity - strlen(buf) > 4) && (buf[strlen(buf) - 1] != '.'))
                    strcat(buf, " ...");
                return;
            }
            strcat(buf, " , ");
            if ((content->c2->type == XML_ELEMENT_CONTENT_OR) ||
                ((content->c2->type == XML_ELEMENT_CONTENT_SEQ) &&
                 (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE))) {
                xmlSnprintfElementContent(buf, capacity, content->c2, 1);
            } else {
                xmlSnprintfElementContent(buf, capacity, content->c2, 0);
            }
            break;

        case XML_ELEMENT_CONTENT_OR:
            /* Handle choice: content->c1 followed by " | " then content->c2 */
            if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||
                ((content->c1->type == XML_ELEMENT_CONTENT_SEQ) &&
                 (content->c1->ocur != XML_ELEMENT_CONTENT_ONCE))) {
                xmlSnprintfElementContent(buf, capacity, content->c1, 1);
            } else {
                xmlSnprintfElementContent(buf, capacity, content->c1, 0);
            }
            if (capacity - strlen(buf) < 4) {
                if ((capacity - strlen(buf) > 4) && (buf[strlen(buf) - 1] != '.'))
                    strcat(buf, " ...");
                return;
            }
            strcat(buf, " | ");
            if ((content->c2->type == XML_ELEMENT_CONTENT_SEQ) ||
                ((content->c2->type == XML_ELEMENT_CONTENT_OR) &&
                 (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE))) {
                xmlSnprintfElementContent(buf, capacity, content->c2, 1);
            } else {
                xmlSnprintfElementContent(buf, capacity, content->c2, 0);
            }
            break;

        default:
            /* Should not happen in normal operation */
            if (capacity - strlen(buf) > 4 && buf[strlen(buf) - 1] != '.')
                strcat(buf, " ...");
            break;
    }