xmlBufferWriteChar(buf, " ");
	xmlDumpEnumeration(buf, cur->next);
    }
}

/**
 * xmlDumpEnumerationList:
 * @buf:  the XML buffer output
 * @list:  An enumeration list
 *
 * This will dump the content of the enumeration list
 */
static void
xmlDumpEnumerationList(xmlBufferPtr buf, xmlEnumerationPtr list) {
    if ((buf == NULL) || (list == NULL))
        return;

    xmlBufferWriteChar(buf, "(");
    xmlDumpEnumeration(buf, list);
    xmlBufferWriteChar(buf, " ");
}

/**
 * xmlDumpEnumerationDecl:
 * @buf:  the XML buffer output
 * @enum:  An enumeration
 *
 * This will dump the content of the enumeration declaration as an XML
 * DTD definition
 */
void
xmlDumpEnumerationDecl(xmlBufferPtr buf, xmlEnumerationPtr enum_) {
    if ((buf == NULL) || (enum_ == NULL))
        return;

    xmlBufferWriteChar(buf, "<!ATTLIST ");
    xmlBufferWriteCHAR(buf, enum_->elemName);
    xmlBufferWriteChar(buf, " %s (", enum_->name);
    xmlDumpEnumerationList(buf, enum_->list);
    xmlBufferWriteChar(buf, ")*>\n");
}

/**
 * xmlDumpEnumerationTable:
 * @buf:  the XML buffer output
 * @table:  An enumeration table
 *
 * This will dump the content of the enumeration table as an XML
 * DTD definition
 */
void
xmlDumpEnumerationTable(xmlBufferPtr buf, xmlEnumerationTablePtr table) {
    if ((buf == NULL) || (table == NULL))
        return;

    xmlHashScan(table, (xmlHashScanner) xmlDumpEnumerationDecl, buf);
}
#endif /* LIBXML_OUTPUT_ENABLED */

/**
 * xmlAddEnumeration:
 * @table:  the enumeration table
 * @name:  the enumeration name
 * @list:  the enumeration list
 * @elemName:  the element name
 *
 * Add an enumeration to the enumeration table.
 *
 * Returns 1 if successful or 0 in case of error.
 */
int
xmlAddEnumeration(xmlEnumerationTablePtr table,
                  const xmlChar *name, xmlEnumerationPtr list,
                  const xmlChar *elemName) {
    xmlEnumerationPtr cur;

    if (table == NULL) return(0);
    if (name == NULL) return(0);

    cur = xmlCreateEnumeration(name);
    if (cur == NULL) return(0);

    cur->list = xmlCopyEnumeration(list);
    cur->elemName = xmlStrdup(elemName);

    if (xmlHashAddEntry(table, cur->name, cur) == -1) {
	xmlFreeEnumeration(cur);
	return(0);
    }
    return(1);
}

/**
 * xmlFreeEnumerationTable:
 * @table:  the enumeration table
 *
 * Deallocate the memory used by an enumeration hash table.
 */
void
xmlFreeEnumerationTable(xmlEnumerationTablePtr table) {
    xmlHashFree(table, (xmlHashDeallocator) xmlFreeEnumeration);
}

#ifdef LIBXML_TREE_ENABLED
/**
 * xmlCopyEnumerationTable:
 * @table:  the enumeration table
 *
 * Build a copy of an enumeration table.
 *
 * Returns the new xmlEnumerationTablePtr or NULL in case of error.
 */
xmlEnumerationTablePtr
xmlCopyEnumerationTable(xmlEnumerationTablePtr table) {
    return((xmlEnumerationTablePtr) xmlHashCopy(table,
		                             (xmlHashCopier) xmlCopyEnumeration));
}
#endif /* LIBXML_TREE_ENABLED */

#ifdef LIBXML_VALID_ENABLED
/**
 * xmlValidateElementDecl:
 * @ctxt:  the validation context
 * @elem:  the element declaration
 * @node:  the node to validate
 *
 * Validate an element declaration against the content model
 *
 * Returns 1 if successful or 0 in case of error.
 */
int
xmlValidateElementDecl(xmlValidCtxtPtr ctxt,
                       xmlElementPtr elem, xmlNodePtr node) {
    xmlElementContentPtr content;
    xmlValidStatePtr state;
    int ret = 0;

    if ((ctxt == NULL) || (elem == NULL) || (node == NULL))
        return(0);

    if (elem->etype != XML_ELEMENT_TYPE_ELEMENT)
        return(1);

    if (elem->contModel == NULL) {
        xmlValidBuildContentModel(ctxt, elem);
        if (elem->contModel == NULL) {
            xmlErrValidNode(ctxt, node, XML_ERR_INTERNAL_ERROR,
                            "Failed to build content model for %s\n",
                            elem->name, NULL, NULL);
            return(0);
        }
    }

    if (ctxt->vstateNr == 0) {
        state = (xmlValidStatePtr) xmlMalloc(sizeof(xmlValidState));
        if (state == NULL) {
            xmlVErrMemory(ctxt, "malloc failed");
            return(0);
        }
        state->elemDecl = elem;
        state->node = node;
        state->exec = xmlRegNewExecCtxt(elem->contModel, NULL, NULL);
        ctxt->vstateTab[ctxt->vstateNr++] = *state;
        ctxt->vstate = &ctxt->vstateTab[ctxt->vstateNr - 1];
        xmlFree(state);
    } else {
        state = ctxt->vstate;
    }

    content = elem->content;
    while (content != NULL) {
        switch (content->type) {
            case XML_ELEMENT_CONTENT_PCDATA:
                ret = xmlValidateElementPCDATAModel(ctxt, state, content, node);
                break;
            case XML_ELEMENT_CONTENT_ELEMENT:
                ret = xmlValidateElementElementModel(ctxt, state, content, node);
                break;
            case XML_ELEMENT_CONTENT_SEQ:
                ret = xmlValidateElementSeqModel(ctxt, state, content, node);
                break;
            case XML_ELEMENT_CONTENT_OR:
                ret = xmlValidateElementOrModel(ctxt, state, content, node);
                break;
            default:
                xmlErrValidNode(ctxt, node, XML_ERR_INTERNAL_ERROR,
                                "ContentModel broken for element %s\n",
                                elem->name, NULL, NULL);
                return(0);
        }
        if (ret == 0) {
            xmlErrValidNode(ctxt, node, XML_ERR_CONTENT_NOT_ALLOWED,
                            "Element %s: content model not matched\n",
                            elem->name, NULL, NULL);
            return(0);
        }
        content = content->c2;
    }

    if (ctxt->vstateNr > 0) {
        ctxt->vstateNr--;
        if (ctxt->vstateNr > 0)
            ctxt->vstate = &ctxt->vstateTab[ctxt->vstateNr - 1];
        else
            ctxt->vstate = NULL;
    }

    return(1);
}

/**
 * xmlValidateElementPCDATAModel:
 * @ctxt:  the validation context
 * @state:  the current validation state
 * @content:  the content model
 * @node:  the node to validate
 *
 * Validate an element against a PCDATA content model
 *
 * Returns 1 if successful or 0 in case of error.
 */
static int
xmlValidateElementPCDATAModel(xmlValidCtxtPtr ctxt,
                              xmlValidStatePtr state,
                              xmlElementContentPtr content,
                              xmlNodePtr node) {
    if (node == NULL) {
        xmlErrValidNode(ctxt, state->node, XML_ERR_INTERNAL_ERROR,
                        "Found NULL node in content model of %s\n",
                        state->elemDecl->name, NULL, NULL);
        return(0);
    }
    if (node->type != XML_TEXT_NODE) {
        xmlErrValidNode(ctxt, state->node, XML_ERR_CONTENT_NOT_ALLOWED,
                        "Element %s: content model not matched\n",
                        state->elemDecl->name, NULL, NULL);
        return(0);
    }
    return(1);
}

/**
 * xmlValidateElementElementModel:
 * @ctxt:  the validation context
 * @state:  the current validation state
 * @content:  the content model
 * @node:  the node to validate
 *
 * Validate an element against an element content model
 *
 * Returns 1 if successful or 0 in case of error.
 */
static int
xmlValidateElementElementModel(xmlValidCtxtPtr ctxt,
                               xmlValidStatePtr state,
                               xmlElementContentPtr content,
                               xmlNodePtr node) {
    xmlNodePtr cur;
    int ret = 0;

    if (node == NULL) {
        xmlErrValidNode(ctxt, state->node, XML_ERR_INTERNAL_ERROR,
                        "Found NULL node in content model of %s\n",
                        state->elemDecl->name, NULL, NULL);
        return(0);
    }
    if (node->type != XML_ELEMENT_NODE) {
        xmlErrValidNode(ctxt, state->node, XML_ERR_CONTENT_NOT_ALLOWED,
                        "Element %s: content model not matched\n",
                        state->elemDecl->name, NULL, NULL);
        return(0);
    }
    for (cur = node->children; cur != NULL; cur = cur->next) {
        if (cur->type == XML_TEXT_NODE) continue;
        if (cur->type == XML_ENTITY_REF_NODE) continue;
        if (cur->type == XML_CDATA_SECTION_NODE) continue;
        if (cur->type == XML_COMMENT_NODE) continue;
        if (cur->type == XML_PI_NODE) continue;
        if (cur->type == XML_ATTRIBUTE_NODE) continue;
        if (cur->type == XML_DTD_NODE) continue;
        if (cur->type == XML_ELEMENT_DECL) continue;
        if (cur->type == XML_ATTRIBUTE_DECL) continue;
        if (cur->type == XML_ENTITY_DECL) continue;
        if (cur->type == XML_NAMESPACE_DECL) continue;
        if (cur->type == XML_XINCLUDE_START) continue;
        if (cur->type == XML_XINCLUDE_END) continue;
        if (cur->type == XML_ELEMENT_NODE) {
            if (xmlValidateElementDecl(ctxt, (xmlElementPtr) cur, cur))
                ret = 1;
            else
                ret = 0;
        } else {
            xmlErrValidNode(ctxt, state->node, XML_ERR_CONTENT_NOT_ALLOWED,
                            "Element %s: content model not matched\n",
                            state->elemDecl->name, NULL, NULL);
            return(0);
        }
    }
    return(ret);
}

/**
 * xmlValidateElementSeqModel:
 * @ctxt:  the validation context
 * @state:  the current validation state
 * @content:  the content model
 * @node:  the node to validate
 *
 * Validate an element against a sequence content model
 *
 * Returns 1 if successful or 0 in case of error.
 */
static int
xmlValidateElementSeqModel(xmlValidCtxtPtr ctxt,
                           xmlValidStatePtr state,
                           xmlElementContentPtr content,
                           xmlNodePtr node) {
    xmlNodePtr cur;
    int ret = 1;

    if (node == NULL) {
        xmlErrValidNode(ctxt, state->node, XML_ERR_INTERNAL_ERROR,
                        "Found NULL node in content model of %s\n",
                        state->elemDecl->name, NULL, NULL);
        return(0);
    }
    if (content->ocur != XML_ELEMENT_CONTENT_ONCE) {
        xmlErrValidNode(ctxt, state->node, XML_ERR_INTERNAL_ERROR,
                        "Found multiple occurrence in content model of %s\n",
                        state->elemDecl->name, NULL, NULL);
        return(0);
    }
    for (cur = node->children; cur != NULL; cur = cur->next) {
        if (cur->type == XML_TEXT_NODE) continue;
        if (cur->type == XML_ENTITY_REF_NODE) continue;
        if (cur->type == XML_CDATA_SECTION_NODE) continue;
        if (cur->type == XML_COMMENT_NODE) continue;
        if (cur->type == XML_PI_NODE) continue;
        if (cur->type == XML_ATTRIBUTE_NODE) continue;
        if (cur->type == XML_DTD_NODE) continue;
        if (cur->type == XML_ELEMENT_DECL) continue;
        if (cur->type == XML_ATTRIBUTE_DECL) continue;
        if