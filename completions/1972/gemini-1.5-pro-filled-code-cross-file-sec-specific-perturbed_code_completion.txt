switch (content->type) {
    case XML_ELEMENT_CONTENT_PCDATA:
        if (len + 8 > capacity) {
            if ((capacity - len > 4) && (buf[len - 1] != '.'))
                strcat(buf, " ...");
            return;
        }
        strcat(buf, "#PCDATA");
        break;
    case XML_ELEMENT_CONTENT_ELEMENT:
        if (content->name != NULL) {
            int qnameLen;
            const xmlChar *name;
            char *qname;

            name = content->name;
            qname = xmlBuildQName(name, content->prefix, NULL, 0);
            if (qname == NULL) {
                qname = (char *) name;
            }
            qnameLen = strlen(qname);
            if (len + qnameLen + 1 > capacity) {
                if ((capacity - len > 4) && (buf[len - 1] != '.'))
                    strcat(buf, " ...");
                if (qname != (char *)name)
                    xmlFree(qname);
                return;
            }
            strcat(buf, qname);
            if (qname != (char *)name)
                xmlFree(qname);
        }
        break;
    case XML_ELEMENT_CONTENT_SEQ:
        xmlSnprintfElementContent(buf, capacity, content->c1, 1);
        if (len + 3 > capacity) {
            if ((capacity - len > 4) && (buf[len - 1] != '.'))
                strcat(buf, " ...");
            return;
        }
        strcat(buf, ", ");
        xmlSnprintfElementContent(buf, capacity, content->c2, 1);
        break;
    case XML_ELEMENT_CONTENT_OR:
        xmlSnprintfElementContent(buf, capacity, content->c1, 1);
        if (len + 3 > capacity) {
            if ((capacity - len > 4) && (buf[len - 1] != '.'))
                strcat(buf, " ...");
            return;
        }
        strcat(buf, " | ");
        xmlSnprintfElementContent(buf, capacity, content->c2, 1);
        break;
    }