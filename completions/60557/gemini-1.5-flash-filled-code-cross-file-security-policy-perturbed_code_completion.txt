{
	  size_t filename_size = filename_len + 1; // +1 for null terminator

	  if (filename_size > 0) { // Check for potential buffer overflow
	    char *filename = (char *)malloc(filename_size);

	    if (filename != NULL) {
	      strncpy(filename, &http_packet_struct->content_disposition_line.ptr[attachment_len + 1], filename_len -1);
	      filename[filename_len -1] = '\0'; // Ensure null termination

	      if (filename_len > 0) {
		for (i = 0; binary_file_ext[i] != NULL; i++) {
		  if (strncasecmp(filename, binary_file_ext[i], filename_len) == 0) {
		    char str[64];

		    snprintf(str, sizeof(str), "Found file extn %s", binary_file_ext[i]);
		    flow->guessed_category = flow->category = NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT;
		    ndpi_set_binary_application_transfer(ndpi_struct, flow, str);
		    NDPI_LOG_INFO(ndpi_struct, "found executable HTTP transfer");
		    break;
		  }
		}
	      }
	      free(filename);
	    }
	  }
	}