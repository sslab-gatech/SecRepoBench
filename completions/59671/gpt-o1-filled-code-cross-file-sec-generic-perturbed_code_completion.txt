case MV_TYPE_FIELD: {
        if (s->picture_structure == PICT_FRAME) {
            for (int i = 0; i < 2; i++) {
                int fs = s->field_select[dir][i];
                mpeg_motion_lowres(s,
                                   dest_y, dest_cb, dest_cr,
                                   1, fs, fs,
                                   ref_picture, pix_op,
                                   s->mv[dir][i][0], s->mv[dir][i][1],
                                   2 * block_s, macroblocky);
            }
        } else {
            mpeg_motion_lowres(s,
                               dest_y, dest_cb, dest_cr,
                               0, 0, 0,
                               ref_picture, pix_op,
                               s->mv[dir][0][0], s->mv[dir][0][1],
                               2 * block_s, macroblocky);
        }
        break;
    }
    case MV_TYPE_16X8: {
        mpeg_motion_lowres(s,
                           dest_y, dest_cb, dest_cr,
                           0, 0, 0,
                           ref_picture, pix_op,
                           s->mv[dir][0][0], s->mv[dir][0][1],
                           block_s, macroblocky);

        mpeg_motion_lowres(s,
                           dest_y + block_s * s->linesize,
                           dest_cb + (block_s >> s->chroma_y_shift) * s->uvlinesize,
                           dest_cr + (block_s >> s->chroma_y_shift) * s->uvlinesize,
                           0, 0, 0,
                           ref_picture, pix_op,
                           s->mv[dir][1][0], s->mv[dir][1][1],
                           block_s, macroblocky + (block_s >> s->chroma_y_shift));
        break;
    }
    case MV_TYPE_DMV: {
        /* Perform dual-prime motion compensation by combining two predictions.
           First prediction: */
        mpeg_motion_lowres(s,
                           dest_y, dest_cb, dest_cr,
                           s->picture_structure == PICT_FRAME,
                           s->dmv_field_select[dir][0],
                           s->dmv_field_select[dir][0],
                           ref_picture, pix_op,
                           s->dmv[dir][0][0], s->dmv[dir][0][1],
                           2 * block_s, macroblocky);

        /* Second prediction: use a temporary buffer, then average the results.
           For brevity, the temporary allocation and averaging step are shown
           conceptually here. */
        if (s->picture_structure == PICT_FRAME) {
            uint8_t *temp_y  = s->sc.edge_emu_buffer;
            uint8_t *temp_cb = temp_y + 16 * s->linesize; // Simplified offset
            uint8_t *temp_cr = temp_cb + 8  * s->uvlinesize; // Simplified offset

            mpeg_motion_lowres(s,
                               temp_y, temp_cb, temp_cr,
                               1, s->dmv_field_select[dir][1],
                               s->dmv_field_select[dir][1],
                               ref_picture, pix_op,
                               s->dmv[dir][1][0], s->dmv[dir][1][1],
                               2 * block_s, macroblocky);

            /* Average the two predictions (luma):
               s->vdsp.avg_pixels_tab[0](dest_y, temp_y, s->linesize, 2 * block_s);
               Repeat similarly for chroma. */
        }
        break;
    }