case MV_TYPE_FIELD:
    for (int i = 0; i < 2; i++) {
        mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,
                           1, i, s->field_select[dir][i],
                           ref_picture, pix_op,
                           s->mv[dir][i][0], s->mv[dir][i][1],
                           block_s, macroblocky);
        dest_y  += s->linesize * block_s;
        dest_cb += s->uvlinesize * (block_s >> s->chroma_y_shift);
        dest_cr += s->uvlinesize * (block_s >> s->chroma_y_shift);
    }
    break;
case MV_TYPE_16X8:
    for (int i = 0; i < 2; i++) {
        mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,
                           0, 0, 0,
                           ref_picture, pix_op,
                           s->mv[dir][i][0], s->mv[dir][i][1],
                           block_s, macroblocky * 2 + i);
        dest_y  += s->linesize * block_s;
        dest_cb += s->uvlinesize * (block_s >> s->chroma_y_shift);
        dest_cr += s->uvlinesize * (block_s >> s->chroma_y_shift);
    }
    break;
case MV_TYPE_DMV:
    for (int i = 0; i < 2; i++) {
        int field_select = s->field_select[dir][i];
        int mv_x = s->mv[dir][i][0];
        int mv_y = s->mv[dir][i][1];
        int pred_field = i;
        int pred_dir = dir;
        // For DMV, the prediction is averaged with the opposite field
        mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,
                           1, pred_field, field_select,
                           ref_picture, pix_op,
                           mv_x, mv_y,
                           block_s, macroblocky);
        dest_y  += s->linesize * block_s;
        dest_cb += s->uvlinesize * (block_s >> s->chroma_y_shift);
        dest_cr += s->uvlinesize * (block_s >> s->chroma_y_shift);
    }
    break;