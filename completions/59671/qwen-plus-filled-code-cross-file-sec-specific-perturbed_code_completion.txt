case MV_TYPE_FIELD:
    for (int i = 0; i < 2; i++) {
        mpeg_motion_lowres(s, dest_y + ((i & 1) * block_s),
                           dest_cb, dest_cr,
                           1, i, s->field_select[dir][i],
                           ref_picture, pix_op,
                           s->mv[dir][i][0], s->mv[dir][i][1],
                           block_s, macroblocky);
    }
    break;
case MV_TYPE_16X8:
    for (int i = 0; i < 2; i++) {
        mpeg_motion_lowres(s, dest_y + (i * block_s * s->linesize),
                           dest_cb, dest_cr,
                           0, 0, 0,
                           ref_picture, pix_op,
                           s->mv[dir][i][0], s->mv[dir][i][1],
                           block_s, macroblocky + (i >> 1));
    }
    break;
case MV_TYPE_DMV:
    for (int i = 0; i < 4; i++) {
        hpel_motion_lowres(s, dest_y + ((i & 1) + (i >> 1) *
                               s->linesize) * block_s,
                               ref_picture[0], 0, 0,
                               (2 * mb_x + (i & 1)) * block_s,
                               (2 * macroblocky + (i >> 1)) * block_s,
                               s->width, s->height, s->linesize,
                               s->h_edge_pos >> lowres, s->v_edge_pos >> lowres,
                               block_s, block_s, pix_op,
                               s->mv[dir][i][0], s->mv[dir][i][1]);
    }
    if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {
        int mx = 0, my = 0;
        for (int i = 0; i < 4; i++) {
            mx += s->mv[dir][i][0];
            my += s->mv[dir][i][1];
        }
        chroma_4mv_motion_lowres(s, dest_cb, dest_cr, ref_picture,
                                 pix_op, mx, my);
    }
    // Adjust prediction by averaging with the opposite field
    for (int i = 0; i < 4; i++) {
        int opposite_field_idx = (dir == 0) ? 1 : 0;
        uint8_t *opposite_ref_picture = ref_picture[opposite_field_idx];
        hpel_motion_lowres(s, dest_y + ((i & 1) + (i >> 1) *
                               s->linesize) * block_s,
                               opposite_ref_picture, 0, 0,
                               (2 * mb_x + (i & 1)) * block_s,
                               (2 * macroblocky + (i >> 1)) * block_s,
                               s->width, s->height, s->linesize,
                               s->h_edge_pos >> lowres, s->v_edge_pos >> lowres,
                               block_s, block_s, pix_op,
                               s->mv[opposite_field_idx][i][0], s->mv[opposite_field_idx][i][1]);
        // Average the results
        s->vdsp.avg_pixels_tab[lowres-1](dest_y + ((i & 1) + (i >> 1) * s->linesize) * block_s,
                                         dest_y + ((i & 1) + (i >> 1) * s->linesize) * block_s,
                                         s->linesize, block_s, block_s);
    }
    break;