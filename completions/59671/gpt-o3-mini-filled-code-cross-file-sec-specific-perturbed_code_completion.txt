case MV_TYPE_FIELD:
{
    /* Field motion compensation: treat as a full macroblock with field-based motion.
       Here we assume top field processing (field_based = 1, bottom_field = 0, field_select = 0). */
    mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,
                       1, 0, 0,
                       ref_picture, pix_op,
                       s->mv[dir][0][0], s->mv[dir][0][1],
                       2 * block_s, macroblocky);
}
break;
case MV_TYPE_16X8:
{
    /* 16x8 motion compensation: process the top and bottom halves separately. */
    /* Top 16x8 block */
    mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,
                       0, 0, 0,
                       ref_picture, pix_op,
                       s->mv[dir][0][0], s->mv[dir][0][1],
                       block_s, macroblocky);
    /* Bottom 16x8 block: move down by block_s lines */
    mpeg_motion_lowres(s, dest_y + block_s * s->linesize, dest_cb, dest_cr,
                       0, 0, 0,
                       ref_picture, pix_op,
                       s->mv[dir][1][0], s->mv[dir][1][1],
                       block_s, macroblocky);
}
break;
case MV_TYPE_DMV:
{
    /* Dual-prime motion compensation: perform two predictions and average them.
       The macroblock luma size is 2*block_s by 2*block_s. */
    const int mb_size = 2 * block_s;
    uint8_t tmp_buf1[256];
    uint8_t tmp_buf2[256];
    /* First prediction using the first motion vector */
    mpeg_motion_lowres(s, tmp_buf1, dest_cb, dest_cr,
                       0, 0, 0,
                       ref_picture, pix_op,
                       s->mv[dir][0][0], s->mv[dir][0][1],
                       2 * block_s, macroblocky);
    /* Second prediction using the second motion vector */
    mpeg_motion_lowres(s, tmp_buf2, dest_cb, dest_cr,
                       0, 0, 0,
                       ref_picture, pix_op,
                       s->mv[dir][1][0], s->mv[dir][1][1],
                       2 * block_s, macroblocky);
    /* Average the two predictions into dest_y */
    for (int y = 0; y < mb_size; y++) {
        for (int x = 0; x < mb_size; x++) {
            int idx = x + y * mb_size;
            dest_y[x + y * s->linesize] = (tmp_buf1[idx] + tmp_buf2[idx] + 1) >> 1;
        }
    }
}
break;