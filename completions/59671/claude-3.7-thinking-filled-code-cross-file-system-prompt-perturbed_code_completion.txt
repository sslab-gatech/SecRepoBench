case MV_TYPE_FIELD:
    if (s->picture_structure == PICT_FRAME) {
        // Frame pictures with field MVs - process each field separately
        for (int i = 0; i < 2; i++) {
            mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,
                              1, i, s->field_select[dir][i],
                              ref_picture, pix_op,
                              s->mv[dir][i][0], s->mv[dir][i][1],
                              2 * block_s, macroblocky);
        }
    } else {
        // Field pictures - just use the appropriate field
        mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,
                          0, 0, s->field_select[dir][0],
                          ref_picture, pix_op,
                          s->mv[dir][0][0], s->mv[dir][0][1],
                          2 * block_s, macroblocky);
    }
    break;
case MV_TYPE_16X8:
    // Process top and bottom halves separately
    for (int i = 0; i < 2; i++) {
        mpeg_motion_lowres(s, dest_y + i * block_s * s->linesize,
                          dest_cb + i * (block_s >> 1) * s->uvlinesize,
                          dest_cr + i * (block_s >> 1) * s->uvlinesize,
                          0, 0, s->field_select[dir][i],
                          ref_picture, pix_op,
                          s->mv[dir][i][0], s->mv[dir][i][1],
                          block_s, macroblocky + i);
    }
    break;
case MV_TYPE_DMV:
    if (s->picture_structure == PICT_FRAME) {
        // Frame pictures with DMV - process each field
        for (int i = 0; i < 2; i++) {
            mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,
                              1, i, 0,
                              ref_picture, pix_op,
                              s->mv[dir][i][0], s->mv[dir][i][1],
                              2 * block_s, macroblocky);
        }
    } else {
        // Field pictures with DMV - first normal field prediction
        mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,
                          0, 0, 0,
                          ref_picture, pix_op,
                          s->mv[dir][0][0], s->mv[dir][0][1],
                          2 * block_s, macroblocky);
                          
        // Then average with the opposite field
        if (dir == 0) {
            mpeg_motion_lowres(s, s->sc.edge_emu_buffer, NULL, NULL,
                              0, 0, 1,
                              ref_picture, pix_op,
                              s->mv[dir][1][0], s->mv[dir][1][1],
                              2 * block_s, macroblocky);
                              
            // Average the luma values
            for (int i = 0; i < 2 * block_s; i++) {
                for (int j = 0; j < 2 * block_s; j++) {
                    dest_y[j + i*s->linesize] = 
                        (dest_y[j + i*s->linesize] + s->sc.edge_emu_buffer[j + i*s->linesize] + 1) >> 1;
                }
            }
        }
    }
    break;