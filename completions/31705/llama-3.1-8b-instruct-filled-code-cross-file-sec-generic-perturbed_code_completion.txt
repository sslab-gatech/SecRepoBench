// <MASK>
if (frame->cframe!= NULL) {
  uint8_t* framep = frame->cframe;
  /* Make space for the new chunk and copy it */
  frame->cframe = framep = realloc(framep, (size_t)new_frame_len);
  if (framep == NULL) {
    BLOSC_TRACE_ERROR("Cannot realloc space for the frame.");
    return BLOSC2_ERROR_MEMORY_ALLOC;
  }
  /* Copy the chunk */
  memcpy(framep + header_len + cbytes, *chunk, (size_t)lazy_chunk_bytes);
  /* Copy the offsets */
  memcpy(framep + header_len + new_cbytes, off_chunk, (size_t)new_off_cbytes);
} else {
  size_t wbytes;
  if (frame->sframe) {
    // Update the offsets chunk in the chunks frame
    fp = sframe_open_index(frame->urlpath, "rb+");
    fseek(fp, header_len + 0, SEEK_SET);
  } else {
    // Regular frame
    fp = fopen(frame->urlpath, "rb+");
    fseek(fp, header_len + cbytes, SEEK_SET);
    wbytes = fwrite(*chunk, 1, (size_t)lazy_chunk_bytes, fp);  // the new chunk
    if (wbytes!= (size_t)lazy_chunk_bytes) {
      BLOSC_TRACE_ERROR("Cannot write the full chunk to frame.");
      fclose(fp);
      return BLOSC2_ERROR_FILE_WRITE;
    }
  }
  wbytes = fwrite(off_chunk, 1, (size_t)new_off_cbytes, fp);  // the new offsets
  fclose(fp);
  if (wbytes!= (size_t)new_off_cbytes) {
    BLOSC_TRACE_ERROR("Cannot write the offsets to frame.");
    return BLOSC2_ERROR_FILE_WRITE;
  }
  // Invalidate the cache for chunk offsets
  if (frame->coffsets!= NULL) {
    free(frame->coffsets);
    frame->coffsets = NULL;
  }
}
free(chunk);  // chunk has always to be a copy when reaching here...
free(off_chunk);

frame->len = new_frame_len;
rc = frame_update_header(frame, schunk, false);
if (rc < 0) {
  return rc;
}

rc = frame_update_trailer(frame, schunk);
if (rc < 0) {
  return rc;
}

return lazy_chunk_bytes;