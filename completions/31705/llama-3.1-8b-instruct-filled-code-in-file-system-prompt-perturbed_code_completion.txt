// <MASK>
if (frame->sframe) {
  // The chunk is not stored in the frame
  new_frame_len = header_len + 0 + new_off_cbytes + frame->trailer_len;
}
else {
  new_frame_len = header_len + new_cbytes + new_off_cbytes + frame->trailer_len;
}

FILE* fp = NULL;
if (frame->cframe!= NULL) {
  uint8_t* framep = frame->cframe;
  /* Make space for the new chunk and copy it */
  frame->cframe = framep = realloc(framep, (size_t)new_frame_len);
  if (framep == NULL) {
    BLOSC_TRACE_ERROR("Cannot realloc space for the frame.");
    return NULL;
  }
  /* Copy the chunk */
  memcpy(framep + header_len + cbytes, chunk, (size_t)chunk_cbytes);
  /* Copy the offsets */
  memcpy(framep + header_len + new_cbytes, off_chunk, (size_t)new_off_cbytes);
}
else {
  size_t wbytes;
  if (frame->sframe) {
    if (chunk_cbytes!= 0) {
      if (sframe_create_chunk(frame, chunk, nchunk, chunk_cbytes) == NULL) {
        BLOSC_TRACE_ERROR("Cannot write the full chunk.");
        return NULL;
      }
    }
    // Update the offsets chunk in the chunks frame
    fp = sframe_open_index(frame->urlpath, "rb+");
    fseek(fp, header_len + 0, SEEK_SET);
  }
  else {
    // Regular frame
    fp = fopen(frame->urlpath, "rb+");
    fseek(fp, header_len + cbytes, SEEK_SET);
    wbytes = fwrite(chunk, 1, (size_t)chunk_cbytes, fp);  // the new chunk
    if (wbytes!= (size_t)chunk_cbytes) {
      BLOSC_TRACE_ERROR("Cannot write the full chunk to frame.");
      fclose(fp);
      return NULL;
    }
  }
  wbytes = fwrite(off_chunk, 1, (size_t)new_off_cbytes, fp);  // the new offsets
  fclose(fp);
  if (wbytes!= (size_t)new_off_cbytes) {
    BLOSC_TRACE_ERROR("Cannot write the offsets to frame.");
    return NULL;
  }
  // Invalidate the cache for chunk offsets
  if (frame->coffsets!= NULL) {
    free(frame->coffsets);
    frame->coffsets = NULL;
  }
}
free(chunk);  // chunk has always to be a copy when reaching here...
free(off_chunk);

frame->len = new_frame_len;
rc = frame_update_header(frame, schunk, false);
if (rc < 0) {
  return NULL;
}

rc = frame_update_trailer(frame, schunk);
if (rc < 0) {
  return NULL;
}

return frame;