// Allocate space for the lazy chunk
size_t trailer_len = sizeof(int32_t) + sizeof(int64_t) + nblocks * sizeof(int32_t);
size_t trailer_offset = BLOSC_EXTENDED_HEADER_LENGTH + nblocks * sizeof(int32_t);
lazy_chunk_bytes = trailer_offset + trailer_len;
*chunk = malloc(lazy_chunk_bytes);
*needs_free = true;

// Read just the full header and bstarts section too (lazy partial length)
if (frame->sframe) {
  fseek(fp, 0, SEEK_SET);
}
else {
  fseek(fp, header_len + offset, SEEK_SET);
}

rbytes = fread(*chunk, 1, trailer_offset, fp);
if (rbytes != trailer_offset) {
  BLOSC_TRACE_ERROR("Cannot read the (lazy) chunk out of the frame.");
  rc = BLOSC2_ERROR_FILE_READ;
  goto end;
}

// Mark chunk as lazy
uint8_t* blosc2_flags = *chunk + BLOSC2_CHUNK_BLOSC2_FLAGS;
*blosc2_flags |= 0x08U;

// Add the trailer (currently, nchunk + offset + block_csizes)
if (frame->sframe) {
  *(int32_t*)(*chunk + trailer_offset) = offset;
  *(int64_t*)(*chunk + trailer_offset + sizeof(int32_t)) = offset;
}
else {
  *(int32_t*)(*chunk + trailer_offset) = nchunk;
  *(int64_t*)(*chunk + trailer_offset + sizeof(int32_t)) = header_len + offset;
}

int32_t* block_csizes = malloc(nblocks * sizeof(int32_t));

int memcpyed = *(*chunk + BLOSC2_CHUNK_FLAGS) & (uint8_t)BLOSC_MEMCPYED;
if (memcpyed) {
  // When memcpyed the blocksizes are trivial to compute
  for (int i = 0; i < (int)nblocks; i++) {
    block_csizes[i] = (int)chunk_blocksize;
  }
}
else {
  // In regular, compressed chunks, we need to sort the bstarts (they can be out
  // of order because of multi-threading), and get a reverse index too.
  memcpy(block_csizes, *chunk + BLOSC_EXTENDED_HEADER_LENGTH, nblocks * sizeof(int32_t));
  // Helper structure to keep track of original indexes
  struct csize_idx *csize_idx = malloc(nblocks * sizeof(struct csize_idx));
  for (int n = 0; n < (int)nblocks; n++) {
    csize_idx[n].val = block_csizes[n];
    csize_idx[n].idx = n;
  }
  qsort(csize_idx, nblocks, sizeof(struct csize_idx), &sort_offset);
  // Compute the actual csizes
  int idx;
  for (int n = 0; n < (int)nblocks - 1; n++) {
    idx = csize_idx[n].idx;
    block_csizes[idx] = csize_idx[n + 1].val - csize_idx[n].val;
  }
  idx = csize_idx[nblocks - 1].idx;
  block_csizes[idx] = (int)chunk_cbytes - csize_idx[nblocks - 1].val;
  free(csize_idx);
}
// Copy the csizes at the end of the trailer
void *trailer_csizes = *chunk + lazy_chunk_bytes - nblocks * sizeof(int32_t);
memcpy(trailer_csizes, block_csizes, nblocks * sizeof(int32_t));
free(block_csizes);