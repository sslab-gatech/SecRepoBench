case DLT_PPP_SERIAL:
  if (header->caplen < eth_offset + 4)
    return (nproto); // Too short for PPP serial header

  if (packet[eth_offset + 2] == 0x00 && packet[eth_offset + 3] == 0x21) {
    // IPv4
    ethertype = ETH_P_IP;
    ip_offset = eth_offset + 4;
  } else if (packet[eth_offset + 2] == 0x00 && packet[eth_offset + 3] == 0x57) {
    // IPv6
    ethertype = ETH_P_IPV6;
    ip_offset = eth_offset + 4;
  } else {
    return (nproto); // Unsupported protocol
  }
  break;

case DLT_C_HDLC:
  if (header->caplen < eth_offset + 4)
    return (nproto); // Too short for Cisco HDLC header

  chdlc = (struct ndpi_chdlc *) &packet[eth_offset];
  ip_offset = eth_offset + 4;

  if (ntohs(chdlc->proto_code) == 0x0800)
    ethertype = ETH_P_IP;
  else if (ntohs(chdlc->proto_code) == 0x86DD)
    ethertype = ETH_P_IPV6;
  else
    return (nproto); // Unsupported protocol
  break;