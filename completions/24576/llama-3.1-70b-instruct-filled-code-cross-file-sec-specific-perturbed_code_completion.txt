case DLT_C_HDLC:
  chdlc = (struct ndpi_chdlc *) &packet[eth_offset];
  if(chdlc->address == 0 && chdlc->control == 0x0F) {
    ip_offset = 4 + eth_offset;
    ethertype = ETH_P_IP;
  } else {
    ip_offset = 4 + eth_offset;
    ethertype = ETH_P_IPV6;
  }
  break;

case DLT_PPP_SERIAL:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_PPP_ETHER:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IPV6;
  break;

case DLT_FRELAY:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_RAW:
  ip_offset = eth_offset = 0;
  break;

case DLT_LOOP:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_NULL:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IPV6;
  break;

case DLT_PPP:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_C_HDLC:
  chdlc = (struct ndpi_chdlc *) &packet[eth_offset];
  if(chdlc->address == 0 && chdlc->control == 0x0F) {
    ip_offset = 4 + eth_offset;
    ethertype = ETH_P_IP;
  } else {
    ip_offset = 4 + eth_offset;
    ethertype = ETH_P_IPV6;
  }
  break;

case DLT_IEEE802:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_ARCNET:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_SLIP:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_PPP_HDLC:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_ATM_RFC1483:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_RAW:
  ip_offset = eth_offset = 0;
  break;

case DLT_SLIP_BSDOS:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_PPP_BSDOS:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_ATM_CLIP:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_REDBACK_SMARTBRIDGE:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_PPP_PPPD:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_C_HDLC:
  chdlc = (struct ndpi_chdlc *) &packet[eth_offset];
  if(chdlc->address == 0 && chdlc->control == 0x0F) {
    ip_offset = 4 + eth_offset;
    ethertype = ETH_P_IP;
  } else {
    ip_offset = 4 + eth_offset;
    ethertype = ETH_P_IPV6;
  }
  break;

case DLT_IEEE802_11_RADIO:
  radiotap = (struct ndpi_radiotap_header *) &packet[eth_offset];
  radio_len = radiotap->len;

  /* Check Bad FCS presence */
  if((radiotap->flags & BAD_FCS) == BAD_FCS) {
    workflow->stats.total_discarded_bytes +=  header->len;
    return(nproto);
  }

  if(header->caplen < (eth_offset + radio_len + sizeof(struct ndpi_wifi_header)))
    return(nproto);

  /* Calculate 802.11 header length (variable) */
  wifi = (struct ndpi_wifi_header*)( packet + eth_offset + radio_len);
  fc = wifi->fc;

  /* check wifi data presence */
  if(FCF_TYPE(fc) == WIFI_DATA) {
    if((FCF_TO_DS(fc) && FCF_FROM_DS(fc) == 0x0) ||
       (FCF_TO_DS(fc) == 0x0 && FCF_FROM_DS(fc)))
      wifi_len = 26; /* + 4 byte fcs */
  } else   /* no data frames */
    break;

  /* Check ether_type from LLC */
  if(header->caplen < (eth_offset + wifi_len + radio_len + sizeof(struct ndpi_llc_header_snap)))
    return(nproto);
  llc = (struct ndpi_llc_header_snap*)(packet + eth_offset + wifi_len + radio_len);
  if(llc->dsap == SNAP)
    ethertype = ntohs(llc->snap.proto_ID);

  /* Set IP header offset */
  ip_offset = wifi_len + radio_len + sizeof(struct ndpi_llc_header_snap) + eth_offset;
  break;

case DLT_PRISM_HEADER:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_AIRONET_HEADER:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_HHDLC:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_IP_OVER_FC:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_SUNATM:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_IEEE802_11_RADIO_AVS:
  radiotap = (struct ndpi_radiotap_header *) &packet[eth_offset];
  radio_len = radiotap->len;

  /* Check Bad FCS presence */
  if((radiotap->flags & BAD_FCS) == BAD_FCS) {
    workflow->stats.total_discarded_bytes +=  header->len;
    return(nproto);
  }

  if(header->caplen < (eth_offset + radio_len + sizeof(struct ndpi_wifi_header)))
    return(nproto);

  /* Calculate 802.11 header length (variable) */
  wifi = (struct ndpi_wifi_header*)( packet + eth_offset + radio_len);
  fc = wifi->fc;

  /* check wifi data presence */
  if(FCF_TYPE(fc) == WIFI_DATA) {
    if((FCF_TO_DS(fc) && FCF_FROM_DS(fc) == 0x0) ||
       (FCF_TO_DS(fc) == 0x0 && FCF_FROM_DS(fc)))
      wifi_len = 26; /* + 4 byte fcs */
  } else   /* no data frames */
    break;

  /* Check ether_type from LLC */
  if(header->caplen < (eth_offset + wifi_len + radio_len + sizeof(struct ndpi_llc_header_snap)))
    return(nproto);
  llc = (struct ndpi_llc_header_snap*)(packet + eth_offset + wifi_len + radio_len);
  if(llc->dsap == SNAP)
    ethertype = ntohs(llc->snap.proto_ID);

  /* Set IP header offset */
  ip_offset = wifi_len + radio_len + sizeof(struct ndpi_llc_header_snap) + eth_offset;
  break;

case DLT_BACNET_MS_TP:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_PPP_PPPD_WITH_DIRECTION:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_C_HDLC_WITH_DIR:
  chdlc = (struct ndpi_chdlc *) &packet[eth_offset];
  if(chdlc->address == 0 && chdlc->control == 0x0F) {
    ip_offset = 4 + eth_offset;
    ethertype = ETH_P_IP;
  } else {
    ip_offset = 4 + eth_offset;
    ethertype = ETH_P_IPV6;
  }
  break;

case DLT_FRELAY_WITH_DIR:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_IPNET:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_CAN20B:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_CANFD:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_IEEE802_15_4_NONASK_PHY:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_IEEE802_15_4:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_SITA:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_ERF:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_PPP_WITH_DIR:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_C_HDLC_WITH_DIR_AND_ADDR:
  chdlc = (struct ndpi_chdlc *) &packet[eth_offset];
  if(chdlc->address == 0 && chdlc->control == 0x0F) {
    ip_offset = 4 + eth_offset;
    ethertype = ETH_P_IP;
  } else {
    ip_offset = 4 + eth_offset;
    ethertype = ETH_P_IPV6;
  }
  break;

case DLT_C_HDLC_WITH_DIR_AND_ADDR_WITH_OUI:
  chdlc = (struct ndpi_chdlc *) &packet[eth_offset];
  if(chdlc->address == 0 && chdlc->control == 0x0F) {
    ip_offset = 4 + eth_offset;
    ethertype = ETH_P_IP;
  } else {
    ip_offset = 4 + eth_offset;
    ethertype = ETH_P_IPV6;
  }
  break;

case DLT_MPLS:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_PRISM:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_HSR:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_ETHERCAT:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_SCTP:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_K12:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_RFC_1483:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_USBPCAP:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_USB_LINUX:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_BLUETOOTH_HCI_H4:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_BLUETOOTH_HCI_H4_WITH_PHDR:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_AX25_KISS:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_PPI:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_PPP_WITH_DIR_AND_ADDR:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_C_HDLC_WITH_DIR_AND_ADDR_WITH_OUI_AND_CRC:
  chdlc = (struct ndpi_chdlc *) &packet[eth_offset];
  if(chdlc->address == 0 && chdlc->control == 0x0F) {
    ip_offset = 4 + eth_offset;
    ethertype = ETH_P_IP;
  } else {
    ip_offset = 4 + eth_offset;
    ethertype = ETH_P_IPV6;
  }
  break;

case DLT_IPMB:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_FLEXRAY:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_MOST:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_LIN:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_X2E_SENSOR_TRIGGER:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_X2E_SENSOR_TRIGGER_WITH_DATA:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_TIE1:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_FIBRE_CHANNEL_FC2:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_FIBRE_CHANNEL_FC2_WITH_FRAME_DELIMS:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_IPNET:
  ip_offset = 4