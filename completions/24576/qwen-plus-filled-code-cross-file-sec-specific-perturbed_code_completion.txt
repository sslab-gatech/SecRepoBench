case DLT_C_HDLC:
    chdlc = (struct ndpi_chdlc *) &packet[eth_offset];
    if(ntohs(chdlc->protocol) == PPP_IP) {
      ethertype = ETH_P_IP;
      ip_offset = eth_offset + sizeof(struct ndpi_chdlc);
    } else if(ntohs(chdlc->protocol) == PPP_IPV6) {
      ethertype = ETH_P_IPV6;
      ip_offset = eth_offset + sizeof(struct ndpi_chdlc);
    } else {
      return(nproto); // Unsupported protocol
    }
    break;

  case DLT_PPP_SERIAL:
    if(header->caplen < eth_offset + 2)
      return(nproto); // Too short for PPP header

    u_int16_t ppp_protocol = ntohs(*((u_int16_t*)&packet[eth_offset]));
    if(ppp_protocol == PPP_IP) {
      ethertype = ETH_P_IP;
      ip_offset = eth_offset + 2;
    } else if(ppp_protocol == PPP_IPV6) {
      ethertype = ETH_P_IPV6;
      ip_offset = eth_offset + 2;
    } else {
      return(nproto); // Unsupported protocol
    }
    break;