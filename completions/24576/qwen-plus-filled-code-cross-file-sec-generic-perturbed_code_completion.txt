case DLT_C_HDLC: 
    chdlc = (struct ndpi_chdlc *)&packet[eth_offset];
    if(header->caplen < eth_offset + sizeof(struct ndpi_chdlc))
      return(nproto); /* Too short for Cisco HDLC header */

    /* Extract protocol field from Cisco HDLC header */
    ethertype = ntohs(chdlc->protocol);

    /* Set IP header offset based on the presence of additional headers */
    ip_offset = sizeof(struct ndpi_chdlc) + eth_offset;
    break;

  case DLT_PPP_SERIAL:
    if(header->caplen < eth_offset + 2)
      return(nproto); /* Too short for PPP header */

    /* Determine ether type from PPP protocol field */
    if(ntohs(*((u_int16_t*)&packet[eth_offset])) == PPP_IP)
      ethertype = ETH_P_IP;
    else if(ntohs(*((u_int16_t*)&packet[eth_offset])) == PPP_IPV6)
      ethertype = ETH_P_IPV6;
    else
      return(nproto); /* Unsupported PPP protocol */

    /* Set IP header offset after PPP header */
    ip_offset = eth_offset + 2;
    break;