case DLT_C_HDLC: /* Cisco HDLC */
    chdlc = (struct ndpi_chdlc *) &packet[eth_offset];
    check = ntohs(chdlc->protocol);

    if(check == ETH_P_IP) {
      ethertype = ETH_P_IP;
      ip_offset = sizeof(struct ndpi_chdlc) + eth_offset;
    } else if(check == ETH_P_IPV6) {
      ethertype = ETH_P_IPV6;
      ip_offset = sizeof(struct ndpi_chdlc) + eth_offset;
    } else {
      goto v4_warning; /* Unsupported protocol */
    }
    break;

  case DLT_PPP: /* Point-to-Point Protocol */
    if(header->caplen < eth_offset + 4)
      return(nproto); /* Too short for PPP header */

    check = (packet[eth_offset + 2] << 8) | packet[eth_offset + 3];

    if(check == ETH_P_IP) {
      ethertype = ETH_P_IP;
      ip_offset = 4 + eth_offset;
    } else if(check == ETH_P_IPV6) {
      ethertype = ETH_P_IPV6;
      ip_offset = 4 + eth_offset;
    } else {
      goto v4_warning; /* Unsupported protocol */
    }
    break;

  case DLT_PPP_SERIAL: /* PPP over serial */
    check = ntohs(*((u_int16_t*)&packet[eth_offset]));

    if(check == ETH_P_IP) {
      ethertype = ETH_P_IP;
      ip_offset = 2 + eth_offset;
    } else if(check == ETH_P_IPV6) {
      ethertype = ETH_P_IPV6;
      ip_offset = 2 + eth_offset;
    } else {
      goto v4_warning; /* Unsupported protocol */
    }
    break;