case DLT_C_HDLC:
  chdlc = (struct ndpi_chdlc *) &packet[eth_offset];
  if(chdlc->address == 0 && chdlc->control == 0x0F) {
    ip_offset = 4 + eth_offset;
    ethertype = ETH_P_IP;
  } else {
    ip_offset = 4 + eth_offset;
    ethertype = ETH_P_IPV6;
  }
  break;

case DLT_PPP_SERIAL:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_PPP_ETHER:
  ip_offset = 4 + eth_offset;
  ethertype = ETH_P_IPV6;
  break;

case DLT_FDDI:
  ip_offset = 13 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_ATM_RFC1483:
  ip_offset = 8 + eth_offset;
  ethertype = ETH_P_IP;
  break;

case DLT_RAW:
  ip_offset = eth_offset = 0;
  break;

case DLT_IEEE802_11_RADIO_AVS:
  radiotap = (struct ndpi_radiotap_header *) &packet[eth_offset];
  radio_len = radiotap->len;

  /* Check Bad FCS presence */
  if((radiotap->flags & BAD_FCS) == BAD_FCS) {
    workflow->stats.total_discarded_bytes +=  header->len;
    return(nproto);
  }

  if(header->caplen < (eth_offset + radio_len + sizeof(struct ndpi_wifi_header)))
    return(nproto);

  /* Calculate 802.11 header length (variable) */
  wifi = (struct ndpi_wifi_header*)( packet + eth_offset + radio_len);
  fc = wifi->fc;

  /* check wifi data presence */
  if(FCF_TYPE(fc) == WIFI_DATA) {
    if((FCF_TO_DS(fc) && FCF_FROM_DS(fc) == 0x0) ||
       (FCF_TO_DS(fc) == 0x0 && FCF_FROM_DS(fc)))
      wifi_len = 26; /* + 4 byte fcs */
  } else   /* no data frames */
    break;

  /* Check ether_type from LLC */
  if(header->caplen < (eth_offset + wifi_len + radio_len + sizeof(struct ndpi_llc_header_snap)))
    return(nproto);
  llc = (struct ndpi_llc_header_snap*)(packet + eth_offset + wifi_len + radio_len);
  if(llc->dsap == SNAP)
    ethertype = ntohs(llc->snap.proto_ID);

  /* Set IP header offset */
  ip_offset = wifi_len + radio_len + sizeof(struct ndpi_llc_header_snap) + eth_offset;
  break;