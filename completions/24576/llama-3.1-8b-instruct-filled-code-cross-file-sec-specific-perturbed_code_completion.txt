case DLT_EN10MB:
    ethernet = (struct ndpi_ethhdr *) &packet[eth_offset];
    ip_offset = sizeof(struct ndpi_ethhdr) + eth_offset;
    check = ntohs(ethernet->h_proto);

    if(check <= 1500)
      pyld_eth_len = check;
    else if(check >= 1536)
      ethertype = check;

    if(pyld_eth_len!= 0) {
      llc = (struct ndpi_llc_header_snap *)(&packet[ip_offset]);
      /* check for LLC layer with SNAP extension */
      if(llc->dsap == SNAP || llc->ssap == SNAP) {
	ethertype = llc->snap.proto_ID;
	ip_offset += + 8;
      }
      /* No SNAP extension - Spanning Tree pkt must be discarted */
      else if(llc->dsap == BSTP || llc->ssap == BSTP) {
	goto v4_warning;
      }
    }

    // Handle packet processing for different Cisco PPP encapsulations
    // Determine the type of datalink layer for the packet and set the IP header offset and ether type.
    // Specifically, process serial and HDLC encapsulations by extracting protocol information.
    // Update the ether type and ip_offset variables based on the encapsulation method.
    if(check == 0x0021) { // PPP in HDLC-like framing
      chdlc = (struct ndpi_chdlc *)(&packet[ip_offset]);
      ip_offset += 4; // HDLC header length
      if(ntohs(chdlc->chdlc) == 0x0305) { // PPPoE
        workflow->stats.pppoe_count++;
        ethertype = ETH_P_IP;
        ip_offset += 8;
      } else if(ntohs(chdlc->chdlc) == 0x0800) { // IPv4
        ethertype = ETH_P_IP;
      } else if(ntohs(chdlc->chdlc) == 0x86DD) { // IPv6
        ethertype = ETH_P_IPV6;
      }
    } else if(check == 0x0023) { // PPP in HDLC-like framing with Cisco PPPoE
      chdlc = (struct ndpi_chdlc *)(&packet[ip_offset]);
      ip_offset += 4; // HDLC header length
      if(ntohs(chdlc->chdlc) == 0x0305) { // PPPoE
        workflow->stats.pppoe_count++;
        ethertype = ETH_P_IP;
        ip_offset += 8;
      } else if(ntohs(chdlc->chdlc) == 0x0800) { // IPv4
        ethertype = ETH_P_IP;
      } else if(ntohs(chdlc->chdlc) == 0x86DD) { // IPv6
        ethertype = ETH_P_IPV6;
      }
    }
    break;