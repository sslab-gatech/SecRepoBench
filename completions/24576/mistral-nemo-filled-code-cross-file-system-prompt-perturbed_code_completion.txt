case DLT_CISCO_HDLC:
    chdlc = (struct ndpi_chdlc *)&packet[eth_offset];
    ethertype = ntohs(chdlc->protocol);
    ip_offset = sizeof(struct ndpi_chdlc) + eth_offset;

    /* Check for Cisco HDLC encapsulation */
    if(ethertype == ETH_P_IP) {
      /* Check for Cisco HDLC with IP encapsulation */
      if(header->caplen < ip_offset + sizeof(struct ndpi_iphdr))
        return(nproto); /* Too short for IP header*/

      iph = (struct ndpi_iphdr *)&packet[ip_offset];
      if(iph->version == IPVERSION) {
        ip_len = ((u_int16_t)iph->ihl * 4);
        iph6 = NULL;
      } else if(iph->version == 6) {
        if(header->caplen < ip_offset + sizeof(struct ndpi_ipv6hdr))
          return(nproto); /* Too short for IPv6 header*/
        iph6 = (struct ndpi_ipv6hdr *)&packet[ip_offset];
        ip_len = ntohs(iph6->ip6_hdr.ip6_un1_plen);
      } else {
        goto v4_warning;
      }
    } else if(ethertype == ETH_P_IPV6) {
      /* Check for Cisco HDLC with IPv6 encapsulation */
      if(header->caplen < ip_offset + sizeof(struct ndpi_ipv6hdr))
        return(nproto); /* Too short for IPv6 header*/
      iph6 = (struct ndpi_ipv6hdr *)&packet[ip_offset];
      ip_len = ntohs(iph6->ip6_hdr.ip6_un1_plen);
      iph = NULL;
    } else {
      /* Unknown Cisco HDLC encapsulation */
      return(nproto);
    }
    break;