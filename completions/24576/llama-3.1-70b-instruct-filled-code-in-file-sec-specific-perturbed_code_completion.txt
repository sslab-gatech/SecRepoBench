case DLT_C_HDLC:
  chdlc = (struct ndpi_chdlc *) &packet[eth_offset];
  if(chdlc->address == 0x0F) {
    ip_offset = sizeof(struct ndpi_chdlc) + eth_offset;
    if(header->caplen < ip_offset + sizeof(struct ndpi_iphdr))
      return(nproto); /* Too short for next IP header*/
    iph = (struct ndpi_iphdr *) &packet[ip_offset];
    if(iph->version == IPVERSION) {
      ip_len = ((u_int16_t)iph->ihl * 4);
      iph6 = NULL;
    } else if(iph->version == 6) {
      iph6 = (struct ndpi_ipv6hdr *)&packet[ip_offset];
      iph = NULL;
    } else {
      static u_int8_t ipv4_warning_used = 0;

      if(ipv4_warning_used == 0) {
        if(!workflow->prefs.quiet_mode)
          LOG(NDPI_LOG_DEBUG,
               "\n\nWARNING: only IPv4/IPv6 packets are supported in this demo (nDPI supports both IPv4 and IPv6), all other packets will be discarded\n\n");
        ipv4_warning_used = 1;
      }
      workflow->stats.total_discarded_bytes +=  header->len;
      return(nproto);
    }
  } else {
    workflow->stats.total_discarded_bytes +=  header->len;
    return(nproto);
  }
  break;