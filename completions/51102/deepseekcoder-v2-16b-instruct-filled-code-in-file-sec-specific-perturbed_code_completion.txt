(n == _lcs)) * 1000 +
          // weight ngram score
          ngram_score +
          // weight 2-gram score
          re * fact;

      if (gscore[i] > thresh) {
        if (is_swap) {
          std::swap(guess[i], guess[is_swap]);
          std::swap(guessorig[i], guessorig[is_swap]);
          std::swap(gscore[i], gscore[is_swap]);
        }
        is_swap = i;
      }
    }
  }

  // now we have the best suggestions in guess[0]..guess[is_swap]
  // add them to the suggestion list
  for (int i = 0; i <= is_swap; i++) {
    if (gscore[i] > thresh) {
      testsug(wlst, std::string(guessorig[i]), 0, NULL, NULL);
    }
    delete[] guess[i];
  }
  if (ph) {
    for (int i = 0; i < MAX_ROOTS; i++) {
      if (rootsphon[i]) {
        testsug(wlst, std::string(rootsphon[i]), 0, NULL, NULL);
      }
    }
  }
}

// reverse the word for complex prefix handling
void SuggestMgr::reverseword(std::string& word) {
  std::reverse(word.begin(), word.end());
}

// reverse the word for complex prefix handling
void SuggestMgr::reverseword_utf(std::string& word) {
  std::vector<w_char> w_word;
  u8_u16(w_word, word.c_str());
  std::reverse(w_word.begin(), w_word.end());
  u16_u8(word, w_word);
}

// convert UTF-8 string to UTF-16
int SuggestMgr::u8_u16(std::vector<w_char>& u16, const char* u8) {
  u16.clear();
  if (!u8)
    return -1;
  int i = 0;
  while (u8[i] != '\0') {
    if ((u8[i] & 0x80) == 0) {
      u16.push_back({u8[i], 0});
    } else if ((u8[i] & 0xE0) == 0xC0) {
      if (u8[i + 1] == '\0' || (u8[i + 1] & 0xC0) != 0x80)
        return -1;
      u16.push_back({((u8[i] & 0x1F) << 6) | (u8[i + 1] & 0x3F), (u8[i] & 0x10) >> 4});
      i++;
    } else if ((u8[i] & 0xF0) == 0xE0) {
      if (u8[i + 1] == '\0' || (u8[i + 1] & 0xC0) != 0x80 || u8[i + 2] == '\0' || (u8[i + 2] & 0xC0) != 0x80)
        return -1;
      u16.push_back({((u8[i] & 0x0F) << 12) | ((u8[i + 1] & 0x3F) << 6) | (u8[i + 2] & 0x3F),
                     ((u8[i] & 0x1C) >> 2) | ((u8[i + 1] & 0x30) >> 4)});
      i += 2;
    } else if ((u8[i] & 0xF8) == 0xF0) {
      if (u8[i + 1] == '\0' || (u8[i + 1] & 0xC0) != 0x80 || u8[i + 2] == '\0' || (u8[i + 2] & 0xC0) != 0x80 || u8[i + 3] == '\0' || (u8[i + 3] & 0xC0) != 0x80)
        return -1;
      u16.push_back({((u8[i] & 0x07) << 18) | ((u8[i + 1] & 0x3F) << 12) | ((u8[i + 2] & 0x3F) << 6) | (u8[i + 3] & 0x3F),
                     ((u8[i] & 0x0F) << 12) | ((u8[i + 1] & 0x30) << 2) | ((u8[i + 2] & 0x3C) >> 4)});
      i += 3;
    } else {
      return -1;
    }
    i++;
  }
  return u16.size();
}

// convert UTF-16 string to UTF-8
void SuggestMgr::u16_u8(std::string& u8, const std::vector<w_char>& u16) {
  u8.clear();
  for (size_t i = 0; i < u16.size(); i++) {
    if (u16[i].h == 0) {
      u8.push_back(u16[i].l);
    } else if (u16[i].h == 1) {
      u8.push_back((u16[i].l >> 6) | 0xC0);
      u8.push_back((u16[i].l & 0x3F) | 0x80);
    } else if (u16[i].h == 2) {
      u8.push_back((u16[i].l >> 12) | 0xE0);
      u8.push_back(((u16[i].l >> 6) & 0x3F) | 0x80);
      u8.push_back((u16[i].l & 0x3F) | 0x80);
    } else if (u16[i].h == 3) {
      u8.push_back((u16[i].l >> 18) | 0xF0);
      u8.push_back(((u16[i].l >> 12) & 0x3F) | 0x80);
      u8.push_back(((u16[i].l >> 6) & 0x3F) | 0x80);
      u8.push_back((u16[i].l & 0x3F) | 0x80);
    }
  }
}

// convert UTF-8 string to UTF-16
int SuggestMgr::u8_u16(std::vector<w_char>& u16, const char* u8) {
  u16.clear();
  if (!u8)
    return -1;
  int i = 0;
  while (u8[i] != '\0') {
    if ((u8[i] & 0x80) == 0) {
      u16.push_back({u8[i], 0});
    } else if ((u8[i] & 0xE0) == 0xC0) {
      if (u8[i + 1] == '\0' || (u8[i + 1] & 0xC0) != 0x80)
        return -1;
      u16.push_back({((u8[i] & 0x1F) << 6) | (u8[i + 1] & 0x3F), (u8[i] & 0x10) >> 4});
      i++;
    } else if ((u8[i] & 0xF0) == 0xE0) {
      if (u8[i + 1] == '\0' || (u8[i + 1] & 0xC0) != 0x80 || u8[i + 2] == '\0' || (u8[i + 2] & 0xC0) != 0x80)
        return -1;
      u16.push_back({((u8[i] & 0x0F) << 12) | ((u8[i + 1] & 0x3F) << 6) | (u8[i + 2] & 0x3F),
                     ((u8[i] & 0x1C) >> 2) | ((u8[i + 1] & 0x30) >> 4)});
      i += 2;
    } else if ((u8[i] & 0xF8) == 0xF0) {
      if (u8[i + 1] == '\0' || (u8[i + 1] & 0xC0) != 0x80 || u8[i + 2] == '\0' || (u8[i + 2] & 0xC0) != 0x80 || u8[i + 3] == '\0' || (u8[i + 3] & 0xC0) != 0x80)
        return -1;
      u16.push_back({((u8[i] & 0x07) << 18) | ((u8[i + 1] & 0x3F) << 12) | ((u8[i + 2] & 0x3F) << 6) | (u8[i + 3] & 0x3F),
                     ((u8[i] & 0x0F) << 12) | ((u8[i + 1] & 0x30) << 2) | ((u8[i + 2] & 0x3C) >> 4)});
      i += 3;
    } else {
      return -1;
    }
    i++;
  }
  return u16.size();
}

// convert UTF-16 string to UTF-8
void SuggestMgr::u16_u8(std::string& u8, const std::vector<w_char>& u16) {
  u8.clear();
  for (size_t i = 0; i < u16.size(); i++) {
    if (u16[i].h == 0) {
      u8.push_back(u16[i].l);
    } else if (u16[i].h == 1) {
      u8.push_back((u16[i].l >> 6) | 0xC0);
      u8.push_back((u16[i].l & 0x3F) | 0x80);
    } else if (u16[i].h == 2) {
      u8.push_back((u16[i].l >> 12) | 0xE0);
      u8.push_back(((u16[i].l >> 6) & 0x3F) | 0x80);
      u8.push_back((u16[i].l & 0x3F) | 0x80);
    } else if (u16[i].h == 3) {
      u8.push_back((u16[i].l >> 18) | 0xF0);
      u8.push_back(((u16[i].l >> 12) & 0x3F) | 0x80);
      u8.push_back(((u16[i].l >> 6) & 0x3F) | 0x80);
      u8.push_back((u16[i].l & 0x3F) | 0x80);
    }
  }
}

// convert UTF-8 string to UTF-16
int SuggestMgr::u8_u16(std::vector<w_char>& u16, const char* u8) {
  u16.clear();
  if (!u8)
    return -1;
  int i = 0;
  while (u8[i] != '\0') {
    if ((u8[i] & 0x80) == 0) {
      u16.push_back({u8[