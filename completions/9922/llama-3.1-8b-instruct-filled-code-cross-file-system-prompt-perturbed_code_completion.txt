case '\\':
	// Handle escape sequences inside a JSON string. Advance the pointer `uc` for
	// valid escape sequences: `\\`, `\"`, `\/`, `\b`, `\f`, `\n`, `\r`, `\t`, and
	// `\u` followed by 4 hexadecimal digits. If an invalid escape sequence or 
	// unexpected end of data is encountered, exit the parsing loop.
	if (*uc == '\\') {
		*ucp = uc + 1;
		return 1;
	} else if (*uc == '"') {
		*ucp = uc + 1;
		return 1;
	} else if (*uc == '/') {
		*ucp = uc + 1;
		return 1;
	} else if (*uc == 'b') {
		*ucp = uc + 2;
		return 1;
	} else if (*uc == 'f') {
		*ucp = uc + 2;
		return 1;
	} else if (*uc == 'n') {
		*ucp = uc + 2;
		return 1;
	} else if (*uc == 'r') {
		*ucp = uc + 2;
		return 1;
	} else if (*uc == 't') {
		*ucp = uc + 2;
		return 1;
	} else if (*uc == 'u') {
		// Check if there are enough characters left to parse a 4-digit hex number
		if (uc + 5 > endptr) {
			DPRINTF("Bad escape sequence: unexpected end of data", uc, *ucp);
			*ucp = uc;
			return 0;
		}
		// Parse the 4-digit hex number
		int val = 0;
		for (int i = 0; i < 4; i++) {
			if (!json_isxdigit(*++uc)) {
				DPRINTF("Bad escape sequence: invalid hex digit", uc, *ucp);
				*ucp = uc;
				return 0;
			}
			val = (val << 4) | json_xdigit(*uc);
		}
		// Replace the escape sequence with the corresponding Unicode character
		*ucp = uc + 6;
		return 1;
	} else {
		DPRINTF("Bad escape sequence: invalid escape character", uc, *ucp);
		*ucp = uc;
		return 0;
	}