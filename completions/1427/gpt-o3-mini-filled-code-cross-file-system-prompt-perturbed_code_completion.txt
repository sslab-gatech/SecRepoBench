{
    int row_bytes = ((aligned_width * c->bpp + 7) >> 3);
    if (c->video_size < row_bytes * h) {
        av_log(avctx, AV_LOG_ERROR, "Video data too small: need %d bytes, got %d bytes\n", row_bytes * h, c->video_size);
        return AVERROR_INVALIDDATA;
    }
    if (!compressiontype) {
        if (c->palette_size && c->bpp <= 8) {
            avctx->pix_fmt = AV_PIX_FMT_PAL8;
        } else if (c->bpp == 24 && c->format == CHUNKY && c->palette_size == 0) {
            avctx->pix_fmt = AV_PIX_FMT_RGB24;
        } else {
            avpriv_request_sample(avctx,
                                  "Unencoded video with bpp %d, palette size %d and format 0x%x",
                                  c->bpp, c->palette_size, c->format);
            return AVERROR_PATCHWELCOME;
        }
    } else {
        if ((c->bpp == 6 || c->bpp == 8) && c->palette_size) {
            avctx->pix_fmt = AV_PIX_FMT_BGR24;
        } else {
            avpriv_request_sample(avctx,
                                  "Encoded video with unsupported bpp %d and palette size %d",
                                  c->bpp, c->palette_size);
            return AVERROR_PATCHWELCOME;
        }
    }
}