// Check if the video size is sufficient based on the aligned width, height, and bpp.
    {
        int needed_size;
        if (c->format == CHUNKY) {
            // For chunky format, assume bpp is the number of bits per pixel;
            // if bpp == 24, then it's 3 bytes per pixel.
            needed_size = avctx->width * avctx->height * ((c->bpp + 7) >> 3);
        } else {
            // For BIT_PLANAR or BIT_LINE, count bits per line (aligned_width * bpp) and convert to bytes.
            int needed_bits = avctx->height * (aligned_width * c->bpp);
            needed_size = (needed_bits + 7) >> 3;
        }
        if (c->video_size < needed_size)
            return AVERROR_INVALIDDATA;
    }

    // Determine the appropriate pixel format for the AVCodecContext.
    {
        // 1) If the video is encoded (compressiontype != 0) with bpp == 6 or 8 and palette size matches, choose BGR24.
        // 2) If the video is unencoded, has a palette, and uses <= 8 bpp, choose PAL8.
        // 3) If the video is unencoded, has 24 bpp, is in CHUNKY format, and has no palette, choose RGB24.
        // Otherwise, request a sample and return a patch-welcome error.
        if (compressiontype && (c->bpp == 6 || c->bpp == 8) &&
            c->palette_size == ((c->bpp == 6) ? 32 : 128)) {
            avctx->pix_fmt = AV_PIX_FMT_BGR24;
        } else if (!compressiontype && c->palette_size && c->bpp <= 8) {
            avctx->pix_fmt = AV_PIX_FMT_PAL8;
        } else if (!compressiontype && c->bpp == 24 && c->format == CHUNKY && !c->palette_size) {
            avctx->pix_fmt = AV_PIX_FMT_RGB24;
        } else {
            avpriv_request_sample(avctx, "Unknown pixel format "
                                        "bpp=%d, format=0x%x, palette_size=%d, compressiontype=%d",
                                        c->bpp, c->format, c->palette_size, compressiontype);
            return AVERROR_PATCHWELCOME;
        }
    }