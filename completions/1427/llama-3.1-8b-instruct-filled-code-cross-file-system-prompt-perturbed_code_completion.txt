if (compressiontype) {
    av_fast_padded_malloc(&c->new_video, &c->new_video_size,
                          h * w + AV_INPUT_BUFFER_PADDING_SIZE);
    if (!c->new_video)
        return AVERROR(ENOMEM);
    if (c->bpp == 8)
        cdxl_decode_ham8(c, p);
    else
        cdxl_decode_ham6(c, p);
} else if (avctx->pix_fmt == AV_PIX_FMT_PAL8) {
    cdxl_decode_rgb(c, p);
} else {
    cdxl_decode_raw(c, p);
}
// Determine the appropriate pixel format for the AVCodecContext based on
// encoding, palette size, bits per pixel, and video format. If the video is
// unencoded, has a palette, and uses <= 8 bpp, set the pixel format to PAL8.
// If the video is encoded with bpp of 6 or 8 and the palette size matches,
// set the pixel format to BGR24. If the video is unencoded, uses 24 bpp, is
// in CHUNKY format, and has no palette, set the pixel format to RGB24.
// If the format is unsupported, request a sample and return a patch-welcome
// error to indicate the need for further support.
if (compressiontype) {
    if (c->palette_size == c->bpp && c->bpp == 8)
        avctx->pix_fmt = AV_PIX_FMT_BGR24;
} else if (c->palette_size == 0 && c->bpp == 24 && c->format == CHUNKY)
    avctx->pix_fmt = AV_PIX_FMT_RGB24;
else if (c->palette_size > 0 && c->bpp <= 8)
    avctx->pix_fmt = AV_PIX_FMT_PAL8;
else
    avpriv_request_sample(avctx, "Unsupported pixel format 0x%0x", c->format);