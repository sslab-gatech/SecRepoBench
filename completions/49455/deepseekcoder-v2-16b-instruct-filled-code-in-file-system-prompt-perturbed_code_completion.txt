cmsFloat32Number x[3], y[3], x1[3];
    cmsFloat32Number Jacobian[3][3];
    cmsFloat32Number Delta[3];
    cmsFloat32Number Tolerance = 0.001f;
    cmsFloat32Number MaxDelta = 0.01f;
    cmsFloat32Number DeltaSum = 0;
    cmsFloat32Number DeltaMax = 0;
    cmsFloat32Number DeltaMin = 1.0f;
    cmsFloat32Number DeltaStep = 0.01f;
    cmsFloat32Number DeltaStepMax = 0.1f;
    cmsFloat32Number DeltaStepMin = 0.001f;
    int Iterations = 0;
    int InversionIterations = 0;
    cmsFloat32Number InverseJacobian[3][3];

    // Start from hint
    memmove(x, Hint, 3 * sizeof(cmsFloat32Number));

    // Evaluate the LUT at x
    lut ->EvalFloatFn(x, y, lut);

    // Evaluate the Jacobian at x
    for (i=0; i < 3; i++) {
        Delta[i] = DeltaStep;
        x1[i] = x[i] + Delta[i];
        lut ->EvalFloatFn(x1, y + 3, lut);
        Jacobian[i][0] = (y[0] - y[3]) / Delta[i];
        Jacobian[i][1] = (y[1] - y[4]) / Delta[i];
        Jacobian[i][2] = (y[2] - y[5]) / Delta[i];
        x1[i] = x[i] - Delta[i];
        lut ->EvalFloatFn(x1, y + 3, lut);
        Jacobian[i][3] = (y[3] - y[0]) / Delta[i];
        Jacobian[i][4] = (y[4] - y[1]) / Delta[i];
        Jacobian[i][5] = (y[5] - y[2]) / Delta[i];
    }

    // Invert the Jacobian
    if (!cmsComputeInverse(Jacobian, InverseJacobian, &InversionIterations))
        return FALSE;

    // Newton's method
    while (EuclideanDistance(Target, y, 3) > Tolerance && Iterations < 100) {

        // Evaluate the LUT at x
        lut ->EvalFloatFn(x, y, lut);

        // Compute the new guess
        for (i=0; i < 3; i++) {
            x1[i] = x[i];
            for (j=0; j < 3; j++) {
                x1[i] -= InverseJacobian[i][j] * (y[j] - Target[j]);
            }
        }

        // Update the guess
        for (i=0; i < 3; i++) {
            Delta[i] = x1[i] - x[i];
            if (Delta[i] > MaxDelta) Delta[i] = MaxDelta;
            if (Delta[i] < -MaxDelta) Delta[i] = -MaxDelta;
            x[i] = x1[i];
        }

        // Adjust the step size
        DeltaSum += fabs(Delta[0]) + fabs(Delta[1]) + fabs(Delta[2]);
        DeltaMax = fmaxf(fmaxf(fabs(Delta[0]), fabs(Delta[1])), fabs(Delta[2]));
        DeltaMin = fminf(fminf(fabs(Delta[0]), fabs(Delta[1])), fabs(Delta[2]));

        if (DeltaSum > 1.0f) {
            if (DeltaStep > DeltaStepMin) DeltaStep /= 2.0f;
        } else {
            if (DeltaStep < DeltaStepMax) DeltaStep *= 2.0f;
        }

        // Increment the delta
        for (i=0; i < 3; i++) {
            if (DeltaMax > 0.01f)
                IncDelta(&Delta[i]);
            else
                Delta[i] = 0.0f;
        }

        Iterations++;
    }

    // Return the result
    memmove(Result, x, 3 * sizeof(cmsFloat32Number));
    return TRUE;
}


// This function is used to create a pipeline from a sequence of stages.
cmsPipeline* CMSEXPORT cmsPipelineFromStages(cmsContext ContextID, cmsStage* FirstStage)
{
    cmsPipeline* NewLUT;
    cmsStage* mpe;

    if (FirstStage == NULL) return NULL;

    NewLUT = cmsPipelineAlloc(ContextID, FirstStage->InputChannels, FirstStage->OutputChannels);
    if (NewLUT == NULL) return NULL;

    for (mpe = FirstStage; mpe != NULL; mpe = mpe->Next) {
        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, cmsStageDup(mpe))) {
            cmsPipelineFree(NewLUT);
            return NULL;
        }
    }

    if (!BlessLUT(NewLUT)) {
        cmsPipelineFree(NewLUT);
        return NULL;
    }

    return NewLUT;
}


// This function is used to create a pipeline from a sequence of stages.
cmsPipeline* CMSEXPORT cmsPipelineFromArray(cmsContext ContextID, cmsStage** Stages, cmsUInt32Number n)
{
    cmsPipeline* NewLUT;
    cmsUInt32Number i;

    if (Stages == NULL || n == 0) return NULL;

    NewLUT = cmsPipelineAlloc(ContextID, Stages[0]->InputChannels, Stages[n-1]->OutputChannels);
    if (NewLUT == NULL) return NULL;

    for (i = 0; i < n; i++) {
        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, Stages[i])) {
            cmsPipelineFree(NewLUT);
            return NULL;
        }
    }

    if (!BlessLUT(NewLUT)) {
        cmsPipelineFree(NewLUT);
        return NULL;
    }

    return NewLUT;
}


// This function is used to create a pipeline from a sequence of stages.
cmsPipeline* CMSEXPORT cmsPipelineFromArrayOfElemType(cmsContext ContextID, cmsStageSignature FirstType, ...)
{
    cmsStageSignature Type;
    cmsStage* mpe;
    cmsStage** Stages;
    cmsUInt32Number n = 0;
    va_list args;

    if (FirstType == cmsSigUnknownType) return NULL;

    // Count the number of elements
    va_start(args, FirstType);
    for (Type = va_arg(args, cmsStageSignature);
         Type != cmsSigUnknownType;
         Type = va_arg(args, cmsStageSignature)) {
        n++;
    }
    va_end(args);

    // Allocate the array
    Stages = (cmsStage**) _cmsMalloc(ContextID, n * sizeof(cmsStage*));
    if (Stages == NULL) return NULL;

    // Fill the array
    va_start(args, FirstType);
    for (n = 0; n < n; n++) {
        Type = va_arg(args, cmsStageSignature);
        mpe = _cmsStageAllocPlaceholder(ContextID, Type, 0, 0, NULL, NULL, NULL, NULL);
        if (mpe == NULL) {
            cmsPipelineFree(cmsPipelineFromArray(ContextID, Stages, n));
            va_end(args);
            return NULL;
        }
        Stages[n] = mpe;
    }
    va_end(args);

    // Create the pipeline
    return cmsPipelineFromArray(ContextID, Stages, n);
}


// This function is used to create a pipeline from a sequence of stages.
cmsPipeline* CMSEXPORT cmsPipelineFromStagesArray(cmsContext ContextID, cmsStage** Stages, cmsUInt32Number n)
{
    cmsPipeline* NewLUT;
    cmsUInt32Number i;

    if (Stages == NULL || n == 0) return NULL;

    NewLUT = cmsPipelineAlloc(ContextID, Stages[0]->InputChannels, Stages[n-1]->OutputChannels);
    if (NewLUT == NULL) return NULL;

    for (i = 0; i < n; i++) {
        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, Stages[i])) {
            cmsPipelineFree(NewLUT);
            return NULL;
        }
    }

    if (!BlessLUT(NewLUT)) {
        cmsPipelineFree(NewLUT);
        return NULL;
    }

    return NewLUT;
}


// This function is used to create a pipeline from a sequence of stages.
cmsPipeline* CMSEXPORT cmsPipelineFromStagesArrayOfElemType(cmsContext ContextID, cmsStageSignature FirstType, ...)
{
    cmsStageSignature Type;
    cmsStage* mpe;
    cmsStage** Stages;
    cmsUInt32Number n = 0;
    va_list args;

    if (FirstType == cmsSigUnknownType) return NULL;

    // Count the number of elements
    va_start(args, FirstType);
    for (Type = va_arg(args, cmsStageSignature);
         Type != cmsSigUnknownType;
         Type = va_arg(args, cmsStageSignature)) {
        n++;
    }
    va_end(args);

    // Allocate the array
    Stages = (cmsStage**) _cmsMalloc(ContextID, n * sizeof(cmsStage*));
    if (Stages == NULL) return NULL;

    // Fill the array
    va_start(args, FirstType);
    for (n = 0; n < n; n++) {
        Type = va_arg(args, cmsStageSignature);
        mpe = _cmsStageAllocPlaceholder(ContextID, Type, 0, 0, NULL, NULL, NULL, NULL);
        if (mpe == NULL) {
            cmsPipelineFree(cmsPipelineFromStagesArray(ContextID, Stages, n));
            va_end(args);
            return NULL;
        }
        Stages[n] = mpe;
    }
    va_end(args);

    // Create the pipeline
    return cmsPipelineFromStagesArray(ContextID, Stages, n);
}


// This function is used to create a pipeline from a sequence of stages.
cmsPipeline* CMSEXPORT cmsPipelineFromStagesArrayOfElemTypeAndData(cmsContext ContextID, cmsStageSignature FirstType, ...)
{
    cmsStageSignature Type;
    cmsStage* mpe;
    cmsStage** Stages;
    cmsUInt32Number n = 0;
    va_list args;

    if (FirstType == cmsSigUnknownType) return NULL;

    // Count the number of elements
    va_start(args, FirstType);
    for (Type = va_arg(args, cmsStageSignature);
         Type != cmsSigUnknownType;
         Type = va_arg(args, cmsStageSignature)) {
        n++;
    }
    va_end(args);

    // Allocate the array
    Stages = (cmsStage**) _cmsMalloc(ContextID, n * sizeof(cmsStage*));
    if (Stages == NULL) return NULL;

    // Fill the array
    va_start(args, FirstType);
    for (n = 0; n < n; n++) {
        Type = va_arg(args, cmsStageSignature);
        mpe = _cmsStageAllocPlaceholder(ContextID, Type, 0, 0, NULL, NULL, NULL, NULL);
        if (mpe == NULL) {
            cmsPipelineFree(cmsPipelineFromStagesArrayOfElemTypeAndData(ContextID, Stages, n));
            va_end(args);
            return NULL;
        }
        Stages[n] = mpe;
    }
    va_end(args);

    // Create the pipeline
    return cmsPipelineFromStagesArrayOfElemTypeAndData(ContextID, Stages, n);
}


// This function