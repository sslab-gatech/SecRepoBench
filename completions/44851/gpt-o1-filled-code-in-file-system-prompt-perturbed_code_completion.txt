for (j=0; j < (ssize_t) polygon_info->number_edges; j++, p++)
{
  if ((double) ycoordinate <= (p->bounds.y1-mid-0.5))
    break;
  if ((double) ycoordinate > (p->bounds.y2+mid+0.5))
    {
      p--;
      (void) DestroyEdge(polygon_info,j--);
      continue;
    }
  if (((double) x <= (p->bounds.x1-mid-0.5)) ||
      ((double) x > (p->bounds.x2+mid+0.5)))
    continue;
  i=(ssize_t) MagickMax((double) p->highwater,1.0);
  for ( ; i < (ssize_t) p->number_points; i++)
  {
    if ((double) ycoordinate <= (p->points[i-1].y-mid-0.5))
      break;
    if ((double) ycoordinate > (p->points[i].y+mid+0.5))
      continue;
    {
      double
        intercept;

      intercept=(p->points[i-1].x-p->points[i].x)*(ycoordinate-
        p->points[i].y)/(p->points[i-1].y-p->points[i].y)+p->points[i].x;
      if (intercept < (double) x)
        winding_number+=(p->direction > 0) ? 1 : -1;
    }
  }
}