if (fill == MagickFalse)
  return(0.0);
if (subpath_alpha >= 1.0)
  return(1.0);
/*
  Determine winding number.
*/
winding_number=0;
p=polygon_info->edges;
for (j=0; j < (ssize_t) polygon_info->number_edges; j++, p++)
{
  // Iterate through the edges of the polygon to determine their relation
  // to the given point.
  // Update the winding number based on the position of the point relative
  // to the polygon edges. Use the direction of the edge to adjust the
  // winding number.
  if (p->direction!= 0)
    {
      if ((double) ycoordinate > p->points[0].y)
        continue;
      if ((double) ycoordinate < p->points[p->number_points-1].y)
        continue;
      if ((double) x < p->points[0].x)
        {
          if (p->ghostline == MagickFalse)
            winding_number++;
          continue;
        }
      if ((double) x >= p->points[p->number_points-1].x)
        {
          if (p->ghostline == MagickFalse)
            winding_number--;
          continue;
        }
      for (i=1; i < (ssize_t) p->number_points; i++)
      {
        if ((double) ycoordinate < p->points[i-1].y)
          continue;
        if ((double) ycoordinate >= p->points[i].y)
          continue;
        if ((double) x < p->points[i-1].x)
          continue;
        if ((double) x >= p->points[i].x)
          continue;
        if ((p->points[i].x-p->points[i-1].x)*(ycoordinate-p->points[i-1].y) <
            (p->points[i].y-p->points[i-1].y)*(x-p->points[i-1].x))
          {
            if (p->ghostline == MagickFalse)
              winding_number++;
            break;
          }
        else
          {
            if (p->ghostline == MagickFalse)
              winding_number--;
            break;
          }
      }
    }
  else
    {
      if ((double) ycoordinate < p->points[0].y)
        continue;
      if ((double) ycoordinate > p->points[p->number_points-1].y)
        continue;
      if ((double) x < p->points[0].x)
        {
          if (p->ghostline == MagickFalse)
            winding_number--;
          continue;
        }
      if ((double) x >= p->points[p->number_points-1].x)
        {
          if (p->ghostline == MagickFalse)
            winding_number++;
          continue;
        }
      for (i=1; i < (ssize_t) p->number_points; i++)
      {
        if ((double) ycoordinate > p->points[i-1].y)
          continue;
        if ((double) ycoordinate <= p->points[i].y)
          continue;
        if ((double) x < p->points[i-1].x)
          continue;
        if ((double) x >= p->points[i].x)
          continue;
        if ((p->points[i].x-p->points[i-1].x)*(ycoordinate-p->points[i-1].y) <
            (p->points[i].y-p->points[i-1].y)*(x-p->points[i-1].x))
          {
            if (p->ghostline == MagickFalse)
              winding_number--;
            break;
          }
        else
          {
            if (p->ghostline == MagickFalse)
              winding_number++;
            break;
          }
      }
    }
}
if (fill_rule!= NonZeroRule)
{
  if ((MagickAbsoluteValue(winding_number) & 0x01)!= 0)
    return(1.0);
}
else
  if (MagickAbsoluteValue(winding_number)!= 0)
    return(1.0);
return(subpath_alpha);