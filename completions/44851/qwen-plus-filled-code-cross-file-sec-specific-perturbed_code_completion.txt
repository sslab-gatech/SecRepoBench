q=p->points;
for (i=0; i < (ssize_t) p->number_points-1; i++)
{
  if ((q[i].y > ycoordinate) != (q[i+1].y > ycoordinate))
  {
    if (x < (double) (q[i].x + (ycoordinate - q[i].y) * 
      (q[i+1].x - q[i].x) / (q[i+1].y - q[i].y)))
      winding_number += (q[i].y > q[i+1].y) ? -1 : 1;
  }
}