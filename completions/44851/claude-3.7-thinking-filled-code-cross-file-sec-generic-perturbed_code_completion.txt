for (i=0; i < (ssize_t) p->number_points; i++)
{
  size_t j = (i+1) % p->number_points;  /* Next point (wrap around for last edge) */
  
  if (p->points[i].y < (double) ycoordinate && p->points[j].y >= (double) ycoordinate)
  {
    /* Up crossing */
    double intersectX = p->points[i].x + ((double) ycoordinate - p->points[i].y) *
                      (p->points[j].x - p->points[i].x) / 
                      (p->points[j].y - p->points[i].y);
    if (intersectX > (double) x)
      winding_number++;
  }
  else if (p->points[i].y >= (double) ycoordinate && p->points[j].y < (double) ycoordinate)
  {
    /* Down crossing */
    double intersectX = p->points[i].x + ((double) ycoordinate - p->points[i].y) *
                      (p->points[j].x - p->points[i].x) / 
                      (p->points[j].y - p->points[i].y);
    if (intersectX > (double) x)
      winding_number--;
  }
}