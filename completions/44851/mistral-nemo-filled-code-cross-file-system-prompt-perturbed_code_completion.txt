for (i=0; i < (ssize_t) polygon_info->number_edges; i++, p++)
{
  if ((double) ycoordinate <= (p->bounds.y1-mid-0.5))
    break;
  if ((double) ycoordinate > (p->bounds.y2+mid+0.5))
    {
      p--;
      (void) DestroyEdge(polygon_info,i--);
      continue;
    }
  if (((double) x <= (p->bounds.x1-mid-0.5)) ||
      ((double) x > (p->bounds.x2+mid+0.5)))
    continue;
  i=(ssize_t) MagickMax((double) p->highwater,1.0);
  for ( ; i < (ssize_t) p->number_points; i++)
  {
    if ((double) ycoordinate <= (p->points[i-1].y-mid-0.5))
      break;
    if ((double) ycoordinate > (p->points[i].y+mid+0.5))
      continue;
    if (p->scanline != (double) ycoordinate)
      {
        p->scanline=(double) ycoordinate;
        p->highwater=(size_t) i;
      }
    // Compute distance between a point and an edge.
    // Update winding number based on the position of the point relative
    // to the polygon edges. Use the direction of the edge to adjust
    // the winding number.
    // <MASK>
  }
}