for (i = 0; i < (ssize_t)p->number_points; i++) {
    if (((p->points[i].y <= (double)ycoordinate) &&
         (p->points[i + 1].y > (double)ycoordinate)) ||
        ((p->points[i].y > (double)ycoordinate) &&
         (p->points[i + 1].y <= (double)ycoordinate))) {
      double cross_product = (p->points[i + 1].x - p->points[i].x) *
                             ((double)ycoordinate - p->points[i].y) /
                             (p->points[i + 1].y - p->points[i].y) +
                             p->points[i].x;
      if (cross_product < (double)x)
        winding_number += p->direction;
    }
  }