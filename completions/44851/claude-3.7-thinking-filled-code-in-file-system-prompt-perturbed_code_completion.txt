for (j=0; j < (ssize_t) polygon_info->number_edges; j++, p++)
    {
      // If we've already processed this edge for the current scanline
      if (p->scanline == (double) ycoordinate)
        {
          if (p->direction != 0)
            {
              if ((p->highwater < p->number_points) &&
                  (p->points[p->highwater].x > (double) x))
                winding_number+=p->direction;
            }
          continue;
        }
      // Skip if the y-coordinate is not within the bounds of the edge
      if (!((p->bounds.y1 <= (double) ycoordinate) &&
            (p->bounds.y2 > (double) ycoordinate)))
        continue;
      // Handle edges going from top to bottom
      if (p->points[0].y > p->points[p->number_points-1].y)
        {
          if ((p->points[p->number_points-1].y <= (double) ycoordinate) &&
              (p->points[0].y > (double) ycoordinate))
            {
              i=p->highwater;
              while (i < (ssize_t) p->number_points)
              {
                if (p->points[i].y <= (double) ycoordinate)
                  break;
                i++;
              }
              if (i < (ssize_t) p->number_points)
                {
                  i--;
                  if ((p->points[i].x > (double) x) ||
                      ((p->points[i+1].x > (double) x) &&
                       ((p->points[i].x+(p->points[i+1].x-p->points[i].x)*
                         ((double) ycoordinate-p->points[i].y)/
                         (p->points[i+1].y-p->points[i].y)) >= (double) x)))
                    winding_number+=p->direction;
                }
            }
        }
      // Handle edges going from bottom to top
      else
        if ((p->points[0].y <= (double) ycoordinate) &&
            (p->points[p->number_points-1].y > (double) ycoordinate))
          {
            i=p->highwater;
            while (i < (ssize_t) p->number_points)
            {
              if (p->points[i].y > (double) ycoordinate)
                break;
              i++;
            }
            if (i < (ssize_t) p->number_points)
              {
                i--;
                if ((p->points[i].x > (double) x) ||
                    ((p->points[i+1].x > (double) x) &&
                     ((p->points[i].x+(p->points[i+1].x-p->points[i].x)*
                       ((double) ycoordinate-p->points[i].y)/
                       (p->points[i+1].y-p->points[i].y)) >= (double) x)))
                  winding_number+=p->direction;
              }
          }
    }