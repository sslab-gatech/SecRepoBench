if (p->highwater >= p->number_points)
  continue;
if ((p->bounds.y1 > ycoordinate) || (p->bounds.y2 <= ycoordinate))
  continue;
i=(ssize_t) MagickMax((double) p->highwater,1.0);
for ( ; i < (ssize_t) p->number_points; i++)
{
  if (((p->points[i-1].y <= ycoordinate) && (p->points[i].y > ycoordinate)) ||
      ((p->points[i-1].y > ycoordinate) && (p->points[i].y <= ycoordinate)))
  {
    /* Calculate x-coordinate of intersection */
    double dy = p->points[i].y - p->points[i-1].y;
    /* Avoid division by zero */
    if (fabs(dy) > MagickEpsilon)
    {
      double dx = p->points[i].x - p->points[i-1].x;
      double intersect_x = p->points[i-1].x + (ycoordinate - p->points[i-1].y) * dx / dy;
      
      if (x < intersect_x)
      {
        /* Update winding number based on crossing direction */
        if (p->points[i-1].y <= ycoordinate)
          winding_number++;
        else
          winding_number--;
      }
    }
  }
}