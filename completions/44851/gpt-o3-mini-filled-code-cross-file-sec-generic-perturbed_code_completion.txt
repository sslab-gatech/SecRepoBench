{
  ssize_t k;
  for (k = 1; k < (ssize_t) p->number_points; k++)
  {
    double y_start = p->points[k-1].y;
    double y_end = p->points[k].y;
    if (fabs(y_end - y_start) < MagickEpsilon)
      continue;
    if (((y_start <= (double) ycoordinate) && (y_end > (double) ycoordinate)) ||
        ((y_start > (double) ycoordinate) && (y_end <= (double) ycoordinate)))
    {
      double x_intersect = p->points[k-1].x +
        (((double) ycoordinate - y_start) * (p->points[k].x - p->points[k-1].x)) /
        (y_end - y_start);
      if ((double)x < x_intersect)
        winding_number += (y_end > y_start) ? 1 : -1;
    }
  }
}