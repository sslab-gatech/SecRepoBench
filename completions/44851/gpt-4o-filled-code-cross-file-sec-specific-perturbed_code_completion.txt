if ((p->direction == 0) || (p->ghostline != MagickFalse))
      continue;
    q=p->points;
    for (i=0; i < (ssize_t) p->number_points; i++)
    {
      if (((q->y <= (double) ycoordinate) &&
           ((q+1)->y > (double) ycoordinate)) ||
          (((q+1)->y <= (double) ycoordinate) &&
           (q->y > (double) ycoordinate)))
        {
          double intercept;

          intercept=q->x+((ycoordinate-q->y)*(q+1)->x-q->x)/
            ((q+1)->y-q->y);
          if (intercept < (double) x)
            winding_number+=p->direction;
        }
      q++;
    }