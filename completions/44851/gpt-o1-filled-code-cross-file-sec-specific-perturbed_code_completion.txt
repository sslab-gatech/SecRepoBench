{
  /*
    Here we apply the typical winding rule approach for each contiguous pair of
    points in the edge.  We check if the horizontal ray at ycoordinate intersects
    the edge segment.  If so, and the intersection is to the right of x, we update
    the winding number based on whether the segment goes upward or downward.
  */
  ssize_t k;
  for (k = 0; k < (ssize_t) p->number_points - 1; k++)
  {
    double y1 = p->points[k].y;
    double y2 = p->points[k+1].y;

    /*
      Determine if the horizontal line at ycoordinate crosses this edge segment
      strictly within its vertical bounds.
    */
    if (((y1 <= (double) ycoordinate) && (y2 > (double) ycoordinate)) ||
        ((y1 > (double) ycoordinate) && (y2 <= (double) ycoordinate)))
    {
      /*
        Compute the intersection of the line y = ycoordinate with this line
        segment.  If dy is sufficiently small, skip it to avoid numeric issues.
      */
      double dy = y2 - y1;
      if (fabs(dy) < MagickEpsilon)
        continue;

      double t = ((double) ycoordinate - y1) / dy;
      double x1 = p->points[k].x;
      double x2 = p->points[k+1].x;
      double x_intersect = x1 + t * (x2 - x1);

      /*
        If the intersection is to the right of x, adjust the winding number.
      */
      if (x_intersect >= (double) x)
      {
        if (y2 > y1)
          winding_number++;
        else
          winding_number--;
      }
    }
  }
}