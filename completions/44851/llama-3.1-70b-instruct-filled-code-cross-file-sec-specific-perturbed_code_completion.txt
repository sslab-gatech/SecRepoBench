for (j=0; j < (ssize_t) polygon_info->number_edges; j++, p++)
{
  if ((double) ycoordinate < (p->bounds.y1-mid-0.5))
    continue;
  if ((double) ycoordinate >= (p->bounds.y2+mid+0.5))
    break;
  if (((double) x <= (p->bounds.x1-mid-0.5)) ||
      ((double) x > (p->bounds.x2+mid+0.5)))
    continue;
  i=(ssize_t) MagickMax((double) p->highwater,1.0);
  for ( ; i < (ssize_t) p->number_points; i++)
  {
    if ((double) ycoordinate < (p->points[i-1].y-mid-0.5))
      break;
    if ((double) ycoordinate >= (p->points[i].y+mid+0.5))
      continue;
    if (p->scanline!= (double) ycoordinate)
      {
        p->scanline=(double) ycoordinate;
        p->highwater=(size_t) i;
      }
    q=p->points+i-1;
    delta.x=(q+1)->x-q->x;
    delta.y=(q+1)->y-q->y;
    beta=delta.x*(x-q->x)+delta.y*(ycoordinate-q->y);
    if (beta <= 0.0)
      {
        delta.x=(double) x-q->x;
        delta.y=(double) ycoordinate-q->y;
        distance=delta.x*delta.x+delta.y*delta.y;
      }
    else
      {
        alpha=delta.x*delta.x+delta.y*delta.y;
        if (beta >= alpha)
          {
            delta.x=(double) x-(q+1)->x;
            delta.y=(double) ycoordinate-(q+1)->y;
            distance=delta.x*delta.x+delta.y*delta.y;
          }
        else
          {
            alpha=PerceptibleReciprocal(alpha);
            beta=delta.x*(ycoordinate-q->y)-delta.y*(x-q->x);
            distance=alpha*beta*beta;
          }
      }
    if (distance <= 0.0)
      {
        if (p->direction == LeftDirection)
          winding_number++;
        else
          winding_number--;
        break;
      }
    if (distance > 1.0)
      continue;
    if (fabs(beta) < MagickEpsilon)
      {
        beta=1.0;
        if (fabs(distance-1.0) >= MagickEpsilon)
          beta=sqrt(distance);
      }
    alpha=beta-1.0;
    if (p->direction == LeftDirection)
      winding_number+=alpha;
    else
      winding_number-=alpha;
  }
}