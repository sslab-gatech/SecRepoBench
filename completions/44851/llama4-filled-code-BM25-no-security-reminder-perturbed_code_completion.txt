for (j=0; j < (ssize_t) polygon_info->number_edges; j++, p++)
{
  if ((double) ycoordinate > (p->bounds.y2+mid+0.5))
    {
      (void) DestroyEdge(polygon_info,j--);
      continue;
    }
  if (((double) x < (p->bounds.x1-mid-0.5)) ||
      ((double) x > (p->bounds.x2+mid+0.5)))
    continue;
  if (p->scanline != (double) ycoordinate)
    {
      p->scanline=(double) ycoordinate;
      p->highwater=(size_t) i;
    }
  q=p->points+i-1;
  delta.x=(q+1)->x-q->x;
  delta.y=(q+1)->y-q->y;
  beta=delta.x*(x-q->x)+delta.y*(ycoordinate-q->y);
  if (beta < 0.0)
    {
      delta.x=(double) x-q->x;
      delta.y=(double) ycoordinate-q->y;
      distance=delta.x*delta.x+delta.y*delta.y;
      if (distance < 0.0)
        winding_number--;
    }
  else
    if (beta > delta.x*delta.x+delta.y*delta.y)
      {
        delta.x=(double) x-(q+1)->x;
        delta.y=(double) ycoordinate-(q+1)->y;
        distance=delta.x*delta.x+delta.y*delta.y;
        if (distance < 0.0)
          winding_number++;
      }
    else
      {
        alpha=PerceptibleReciprocal(delta.x*delta.x+delta.y*delta.y);
        beta=delta.x*(ycoordinate-q->y)-delta.y*(x-q->x);
        distance=alpha*beta*beta;
        if (distance < 0.0)
          winding_number+= (beta < 0.0) ? -1 : 1;
      }
}