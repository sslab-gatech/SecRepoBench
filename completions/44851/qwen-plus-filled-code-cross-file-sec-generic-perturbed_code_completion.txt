for (i = 0; i < (ssize_t) p->number_points - 1; i++)
{
  if ((p->points[i].y > ycoordinate) != (p->points[i + 1].y > ycoordinate))
  {
    if (x < (p->points[i].x + ((double)(ycoordinate - p->points[i].y) / 
      (p->points[i + 1].y - p->points[i].y)) * 
      (p->points[i + 1].x - p->points[i].x)))
    {
      winding_number += (p->points[i].y > p->points[i + 1].y) ? -1 : 1;
    }
  }
}