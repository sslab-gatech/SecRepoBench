if (p->ghostline != MagickFalse)
  continue;
if ((double) ycoordinate >= p->bounds.y1 && (double) ycoordinate < p->bounds.y2)
{
  for (i=1; i < (ssize_t) p->number_points; i++)
  {
    double y1 = p->points[i-1].y;
    double y2 = p->points[i].y;
    if (((y1 <= (double) ycoordinate) && (y2 > (double) ycoordinate)) ||
        ((y1 > (double) ycoordinate) && (y2 <= (double) ycoordinate)))
    {
      double x1 = p->points[i-1].x;
      double x2 = p->points[i].x;
      double intersect = x1 + ((double) ycoordinate - y1)*(x2 - x1)/(y2 - y1);
      if ((double) x <= intersect)
        {
          if (y2 > y1)
            winding_number++;
          else
            winding_number--;
        }
    }
  }
}