for (i = 0; i < (ssize_t) p->number_points; i++)
{
  if ((double) ycoordinate <= (p->points[i-1].y-mid-0.5))
    break;
  if ((double) ycoordinate > (p->points[i].y+mid+0.5))
    continue;
  if (p->points[i-1].y == p->points[i].y)
    continue;
  if ((p->points[i-1].x > x) && (p->points[i].x > x))
    winding_number++;
  else if ((p->points[i-1].x < x) && (p->points[i].x < x))
    winding_number--;
  else
  {
    double slope = (p->points[i].x - p->points[i-1].x) / 
                   (p->points[i].y - p->points[i-1].y);
    double x_intercept = p->points[i-1].x + 
                         (ycoordinate - p->points[i-1].y) * slope;
    if (fabs(x_intercept - x) < MagickEpsilon)
      return(1.0);
    if (x_intercept <= x)
      winding_number += (p->points[i].y > p->points[i-1].y) ? 1 : -1;
  }
}