static MagickBooleanType TraceStrokePolygon(const Image *image,
  const DrawInfo *draw_info,const PrimitiveInfo *primitive_info)
{
  //... (rest of the code remains the same)

  // Define a macro to ensure sufficient memory is allocated for path arrays.
  // Check if adding a specified padding to the current index would exceed the maximum allocated strokes.
  // If so, increase the size of the allocated memory for path arrays or release memory and handle allocation failure.
  // The macro is used throughout the function to dynamically adjust memory for path_p and path_q,
  // ensuring they can accommodate additional points as the function processes each line segment.
  #define CheckPathExtent(stroke_limit) \
  { \
    size_t \
      new_limit; \
    \
    if ((stroke_limit+MaxStrokePad) > (size_t) SSIZE_MAX) \
      { \
        (void) ThrowMagickException(draw_info->exception,GetMagickModule(), \
          ResourceLimitError,"MemoryAllocationFailed","`%s'",""); \
        return((PrimitiveInfo *) NULL); \
      } \
    new_limit=(size_t) (stroke_limit+MaxStrokePad); \
    if (new_limit < (size_t) (stroke_limit+1)) \
      { \
        (void) ThrowMagickException(draw_info->exception,GetMagickModule(), \
          ResourceLimitError,"MemoryAllocationFailed","`%s'",""); \
        return((PrimitiveInfo *) NULL); \
      } \
    if (path_p!= (PointInfo *) NULL) \
      path_p=(PointInfo *) ResizeQuantumMemory(path_p,new_limit,sizeof(*path_p)); \
    if (path_q!= (PointInfo *) NULL) \
      path_q=(PointInfo *) ResizeQuantumMemory(path_q,new_limit,sizeof(*path_q)); \
    if ((path_p == (PointInfo *) NULL) || (path_q == (PointInfo *) NULL)) \
      { \
        (void) ThrowMagickException(draw_info->exception,GetMagickModule(), \
          ResourceLimitError,"MemoryAllocationFailed","`%s'",""); \
        return((PrimitiveInfo *) NULL); \
      } \
  }

  //... (rest of the code remains the same)
}