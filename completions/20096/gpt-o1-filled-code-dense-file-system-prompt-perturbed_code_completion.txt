#define CheckPathExtent(extra) \
{ \
  /* Ensure we have enough space in both path_p and path_q for p + extra or q + extra */ \
  size_t needed = (size_t)(((p) > (q) ? (p) : (q)) + (extra)); \
  if (needed >= stroke_limit) \
    { \
      /* Increase the stroke_limit to accommodate new points, including some padding */ \
      size_t new_limit = needed + MaxStrokePad; \
      PointInfo *new_path_p = (PointInfo *) ResizeQuantumMemory(path_p, new_limit, sizeof(*path_p)); \
      if (new_path_p == (PointInfo *) NULL) \
        { \
          /* Release all resources if allocation fails */ \
          path_p = (PointInfo *) RelinquishMagickMemory(path_p); \
          path_q = (PointInfo *) RelinquishMagickMemory(path_q); \
          polygon_primitive = (PrimitiveInfo *) RelinquishMagickMemory(polygon_primitive); \
          return((PrimitiveInfo *) NULL); \
        } \
      path_p = new_path_p; \
      PointInfo *new_path_q = (PointInfo *) ResizeQuantumMemory(path_q, new_limit, sizeof(*path_q)); \
      if (new_path_q == (PointInfo *) NULL) \
        { \
          /* Release all resources if allocation fails */ \
          path_p = (PointInfo *) RelinquishMagickMemory(path_p); \
          path_q = (PointInfo *) RelinquishMagickMemory(path_q); \
          polygon_primitive = (PrimitiveInfo *) RelinquishMagickMemory(polygon_primitive); \
          return((PrimitiveInfo *) NULL); \
        } \
      path_q = new_path_q; \
      stroke_limit = new_limit; \
    } \
}