for (unsigned int i = 0; i < effectiveaxiscount; i++)
    {
      coords[i] = map->map (coords[i]);
      map = &StructAfter<SegmentMaps> (*map);
    }

#ifndef HB_NO_VARIATIONS2
    if (version.major < 2)
      return;

    const auto &v2 = * (const avarV2Tail *) map;

    unsigned int axis_count = axisCount;
    float *coords_out = (float *) hb_calloc (axis_count, sizeof (float));
    if (unlikely (!coords_out))
      return;

    const VariationStore &var_store = *v2.varStore;
    hb_array_t<const HBUINT8> data = var_store.get_data ();
    const hb_array_t<const ItemVariationData> deltas = ItemVariationData::get_array (data);

    const DeltaSetIndexMap &idx_map = *v2.varIdxMap;
    unsigned int count = idx_map.get_count ();
    for (unsigned int i = 0; i < count; i++)
    {
      const DeltaSetIndexMap::Record &record = idx_map.get_record (i);
      unsigned int outer_index = record.get_outer_index ();
      if (unlikely (outer_index >= coords_length))
        continue;

      int peak = coords[outer_index];
      const ItemVariationData *delta = deltas.sub_array (record.get_inner_index (), record.get_count ());

      for (unsigned int j = 0; j < record.get_count (); j++)
      {
        unsigned int inner_index = delta->get_inner_index ();
        if (unlikely (inner_index >= axis_count))
          goto next_delta;

        float scalar = delta->get_scalar ();
        int v = roundf (scalar * peak);

        coords_out[inner_index] += v;

      next_delta:
        delta++;
      }
    }

    for (unsigned int i = 0; i < axis_count; i++)
    {
      coords[i] += roundf (coords_out[i]);
      coords[i] = hb_clamp (coords[i], -16384, 16384);
    }

    hb_free (coords_out);
#endif