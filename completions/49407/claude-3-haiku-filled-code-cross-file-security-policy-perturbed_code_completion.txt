// Iterate through the coordinates up to the smaller of coords_length and axisCount.
// For each coordinate, apply a mapping transformation using the current SegmentMaps
// object and then advance to the next SegmentMaps object.
for (unsigned int i = 0; i < effectiveaxiscount; i++)
{
  coords[i] = map->map (coords[i]);
  map = &StructAfter<SegmentMaps> (*map);
}

// If the version is 2 or higher, further process the coordinates using variation data.
if (version >= 2)
{
  // Allocate an output vector for the transformed coordinates.
  int* output_coords = (int*) calloc(effectiveaxiscount, sizeof(int));

  // For each coordinate, apply an additional transformation involving a variation index map and a variation
  // store to compute a delta value. Adjust each coordinate by the rounded delta, clamp the result to a
  // specified range, and store it in the output vector.
  for (unsigned int i = 0; i < effectiveaxiscount; i++)
  {
    int delta = variationStore->get_delta(variationIndexMap, i, coords[i]);
    output_coords[i] = hb_clamp(coords[i] + hb_round(delta), variationStore->get_axis_min(i), variationStore->get_axis_max(i));
  }

  // After processing, deallocate the variation store cache and update the original
  // coordinates array with the transformed values from the output vector.
  variationStore->clear_cache();
  memcpy(coords, output_coords, effectiveaxiscount * sizeof(int));
  free(output_coords);
}