void map_coords (int *coords, unsigned int coords_length) const
  {
    unsigned int effectiveaxiscount = hb_min (coords_length, axisCount);

    const SegmentMaps *map = &firstAxisSegmentMaps;
    unsigned int *output = (unsigned int *) malloc (coords_length * sizeof (unsigned int));
    unsigned int variationStoreSize = 0;
    unsigned int *variationStore = NULL;

    for (unsigned int i = 0; i < effectiveaxiscount; i++)
      {
        // Apply a mapping transformation using the current SegmentMaps object
        coords[i] = map->transform (coords[i]);

        // Advance to the next SegmentMaps object
        map = map->next;

        // If the version is 2 or higher, further process the coordinates using variation data
        if (version >= 2)
          {
            // Allocate an output vector for the transformed coordinates
            variationStoreSize = map->getVariationStoreSize ();
            variationStore = (unsigned int *) malloc (variationStoreSize * sizeof (unsigned int));
            map->getVariationStore (variationStore);

            for (unsigned int j = 0; j < coords_length; j++)
              {
                // Apply an additional transformation involving a variation index map and a variation store to compute a delta value
                unsigned int delta = map->getDelta (coords[j], variationStore);

                // Adjust each coordinate by the rounded delta, clamp the result to a specified range, and store it in the output vector
                output[j] = clamp (coords[j] + delta, minRange, maxRange);
              }

            // Deallocate the variation store cache
            free (variationStore);

            // Update the original coordinates array with the transformed values from the output vector
            for (unsigned int j = 0; j < coords_length; j++)
              {
                coords[j] = output[j];
              }
          }
      }

    // Deallocate the output vector
    free (output);
  }