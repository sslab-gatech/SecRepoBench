void map_coords (int *coords, unsigned int coords_length) const
  {
    unsigned int effectiveaxiscount = hb_min (coords_length, axisCount);

    const SegmentMaps *map = &firstAxisSegmentMaps;
    // Iterate through the coordinates up to the smaller of coords_length and axisCount.
    // For each coordinate, apply a mapping transformation using the current SegmentMaps
    // object and then advance to the next SegmentMaps object.
    // 
    // If the version is 2 or higher, further process the coordinates using variation data.
    // Allocate an output vector for the transformed coordinates. For each coordinate,
    // apply an additional transformation involving a variation index map and a variation
    // store to compute a delta value. Adjust each coordinate by the rounded delta,
    // clamp the result to a specified range, and store it in the output vector.
    // 
    // After processing, deallocate the variation store cache and update the original
    // coordinates array with the transformed values from the output vector.
    std::vector<int> transformed_coords(coords_length);
    for (unsigned int i = 0; i < effectiveaxiscount; i++) {
      map->apply_mapping(coords[i], &transformed_coords[i]);
      map++;
    }
    if (version >= 2) {
      VariationStoreCache variation_store_cache;
      for (unsigned int i = 0; i < effectiveaxiscount; i++) {
        VariationIndexMap variation_index_map;
        int delta = variation_store_cache.get_delta(transformed_coords[i]);
        transformed_coords[i] += delta;
        transformed_coords[i] = std::max(min_value, std::min(max_value, transformed_coords[i]));
      }
      variation_store_cache.deallocate();
      std::copy(transformed_coords.begin(), transformed_coords.end(), coords);
    }
  }