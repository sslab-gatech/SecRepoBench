// <MASK>
if (version >= 2)
{
  // Allocate an output vector for the transformed coordinates.
  int *output_coords = (int *) hb_calloc (coords_length, sizeof (int));
  if (unlikely (!output_coords))
    return;

  // For each coordinate, apply an additional transformation involving a variation index map and a variation store to compute a delta value.
  // Adjust each coordinate by the rounded delta, clamp the result to a specified range, and store it in the output vector.
  const VariationIndexMap *variation_index_map = &firstAxisVariationIndexMap;
  const VariationStore *variation_store = &firstAxisVariationStore;
  for (unsigned int i = 0; i < coords_length; i++)
  {
    int delta = variation_index_map->get_delta (coords[i]);
    int transformed_coord = variation_store->get_transformed_coord (coords[i], delta);
    output_coords[i] = hb_clamp (transformed_coord, coords[i] - 10, coords[i] + 10);
  }

  // Deallocate the variation store cache.
  hb_free (variation_store);

  // Update the original coordinates array with the transformed values from the output vector.
  for (unsigned int i = 0; i < coords_length; i++)
    coords[i] = output_coords[i];

  // Deallocate the output vector.
  hb_free (output_coords);
}