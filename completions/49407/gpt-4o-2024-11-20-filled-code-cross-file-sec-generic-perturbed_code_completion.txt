// Allocate an output vector for transformed coordinates
    int *transformed_coords = coords_length ? (int *) hb_calloc(coords_length, sizeof(int)) : nullptr;
    if (unlikely(coords_length && !transformed_coords))
      return;

    // Process each coordinate
    for (unsigned int i = 0; i < effectiveaxiscount; i++)
    {
      // Apply the mapping transformation
      coords[i] = map->map(coords[i]);
      map = &StructAfter<SegmentMaps>(*map);
    }

    // If version is 2 or higher, apply variation data processing
    if (version >= 2)
    {
      VariationStoreCache cache;
      if (cache.init(variationStore))
      {
        for (unsigned int i = 0; i < effectiveaxiscount; i++)
        {
          int delta = cache.get_delta(variationIndexMap.get_variation_index(i), coords, effectiveaxiscount);
          transformed_coords[i] = hb_clamp<int>(coords[i] + hb_round<int>(delta), -0x4000, 0x3FFF);
        }
      }
      cache.fini();
    }
    else
    {
      // If no variation data, simply copy the mapped coordinates
      for (unsigned int i = 0; i < effectiveaxiscount; i++)
        transformed_coords[i] = coords[i];
    }

    // Update the original coordinates with the transformed values
    for (unsigned int i = 0; i < effectiveaxiscount; i++)
      coords[i] = transformed_coords[i];

    // Free the allocated memory for transformed coordinates
    hb_free(transformed_coords);