// Allocate an output vector for the transformed coordinates.
    std::vector<int> transformed_coords(coords_length);

    // Iterate through the coordinates up to the smaller of coords_length and axisCount.
    for (unsigned int i = 0; i < effectiveaxiscount; i++) {
        // Apply a mapping transformation using the current SegmentMaps object.
        coords[i] = map->map(coords[i]);

        // If the version is 2 or higher, further process the coordinates using variation data.
        if (version >= 2) {
            // Apply an additional transformation involving a variation index map and a variation store to compute a delta value.
            int delta = variationIndexMap[i].computeDelta(variationStore[i], coords[i]);

            // Adjust each coordinate by the rounded delta, clamp the result to a specified range, and store it in the output vector.
            transformed_coords[i] = hb_clamp(coords[i] + delta, minRange, maxRange);
        } else {
            // If version is less than 2, just use the mapped coordinate.
            transformed_coords[i] = coords[i];
        }

        // Advance to the next SegmentMaps object.
        map = &StructAfter<SegmentMaps> (*map);
    }

    // After processing, deallocate the variation store cache and update the original coordinates array with the transformed values from the output vector.
    // Assuming variationStore and variationIndexMap are deallocated elsewhere in the code.
    std::memcpy(coords, transformed_coords.data(), coords_length * sizeof(int));