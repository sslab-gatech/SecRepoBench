// Iterate through the coordinates up to the smaller of coords_length and axisCount.
// For each coordinate, apply a mapping transformation using the current SegmentMaps
// object and then advance to the next SegmentMaps object.
for (unsigned int i = 0; i < effectiveaxiscount; i++)
{
  coords[i] = map->map (coords[i]);
  map = &StructAfter<SegmentMaps> (*map);
}

// If the version is 2 or higher, further process the coordinates using variation data.
if (version >= 2)
{
  // Allocate an output vector for the transformed coordinates.
  int* output_coords = new int[effectiveaxiscount];

  // For each coordinate, apply an additional transformation involving a variation index map and a variation
  // store to compute a delta value. Adjust each coordinate by the rounded delta, clamp the result to a
  // specified range, and store it in the output vector.
  for (unsigned int i = 0; i < effectiveaxiscount; i++)
  {
    int delta = variation_store.get_delta (variation_index_map, i, coords[i]);
    output_coords[i] = hb_clamp (coords[i] + hb_round (delta), min_value, max_value);
  }

  // After processing, deallocate the variation store cache and update the original
  // coordinates array with the transformed values from the output vector.
  variation_store.clear_cache();
  memcpy (coords, output_coords, effectiveaxiscount * sizeof(int));
  delete[] output_coords;
}