// Iterate through the coordinates up to the smaller of coords_length and axisCount.
// For each coordinate, apply a mapping transformation using the current SegmentMaps
// object and then advance to the next SegmentMaps object.
for (unsigned int i = 0; i < effectiveaxiscount; i++)
{
  coords[i] = map->map (coords[i]);
  map = &StructAfter<SegmentMaps> (*map);
}

#ifndef HB_NO_VARIATIONS2
if (version.major >= 2)
{
  // Allocate an output vector for the transformed coordinates.
  int *output_coords = (int *) calloc (coords_length, sizeof (int));

  // For each coordinate, apply an additional transformation involving a variation
  // index map and a variation store to compute a delta value. Adjust each
  // coordinate by the rounded delta, clamp the result to a specified range, and
  // store it in the output vector.
  const avarV2Tail &v2 = * (const avarV2Tail *) map;
  v2.varIdxMap.apply_deltas (coords, coords_length, v2.varStore, output_coords);

  // Deallocate the variation store cache and update the original coordinates
  // array with the transformed values from the output vector.
  v2.varStore.clear_cache ();
  memcpy (coords, output_coords, coords_length * sizeof (int));
  free (output_coords);
}
#endif