{
  // First, apply the segment map transformations.
  for (unsigned int i = 0; i < effectiveaxiscount; i++)
  {
    coords[i] = map->map(coords[i]);
    map = &StructAfter<SegmentMaps>(*map);
  }

#ifndef HB_NO_VARIATIONS2
  // If avar table version is 2 or higher, apply the variation data.
  if (version.major >= 2)
  {
    // The next structure after the last SegmentMaps is the avarV2Tail.
    const auto &v2 = *reinterpret_cast<const avarV2Tail *>(map);

    // Allocate a temporary buffer to hold the transformed coordinates.
    hb_auto_array_t<int> transformed;
    if (unlikely (!transformed.alloc(effectiveaxiscount)))
      return;

    // Copy the segment-mapped coords into the temporary buffer.
    for (unsigned int i = 0; i < effectiveaxiscount; i++)
      transformed[i] = coords[i];

    // Prepare to compute variation deltas.
    VariationStoreCache cache;
    cache.init(&v2.varStore);

    // For each axis, compute a delta using varIdxMap & varStore, then adjust.
    for (unsigned int i = 0; i < effectiveaxiscount; i++)
    {
      // Get delta set index for this axis (format details omitted).
      uint32_t delta_set_idx = v2.varIdxMap.get_delta_set_index(i);
      if (delta_set_idx == DeltaSetIndexMap::INVALID_DELTA_SET_INDEX)
        continue;

      // Retrieve and round the delta, then clamp to an F2DOT14-safe range.
      float delta = cache.evaluate(&v2.varStore, delta_set_idx);
      int adjusted = (int)floor(delta + 0.5f);
      adjusted = hb_clamp(adjusted + transformed[i], -16384, 16384);
      transformed[i] = adjusted;
    }

    cache.fini();

    // Copy the results back into the original coords array.
    for (unsigned int i = 0; i < effectiveaxiscount; i++)
      coords[i] = transformed[i];
  }
#endif
}