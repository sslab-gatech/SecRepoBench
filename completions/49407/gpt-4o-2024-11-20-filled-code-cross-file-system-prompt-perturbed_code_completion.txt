// Allocate an output vector for the transformed coordinates
    int *transformed_coords = (int *) hb_calloc(effectiveaxiscount, sizeof(int));
    if (unlikely(!transformed_coords))
      return;

    // Apply the mapping transformation for each coordinate
    for (unsigned int i = 0; i < effectiveaxiscount; i++)
    {
      transformed_coords[i] = map->map(coords[i]);
      map = &StructAfter<SegmentMaps>(*map);
    }

    // If version is 2 or higher, process using variation data
    if (version >= 2)
    {
      VariationStoreCache cache;
      if (unlikely(!cache.init(variationStore)))
      {
        hb_free(transformed_coords);
        return;
      }

      for (unsigned int i = 0; i < effectiveaxiscount; i++)
      {
        int delta = cache.get_delta(variationIndexMap.get_mapping(i), coords, effectiveaxiscount);
        transformed_coords[i] = hb_clamp<int>(transformed_coords[i] + hb_round<int>(delta), -0x8000, 0x7FFF);
      }

      cache.fini();
    }

    // Update the original coordinates array with the transformed values
    memcpy(coords, transformed_coords, effectiveaxiscount * sizeof(int));

    // Deallocate the output vector
    hb_free(transformed_coords);