void map_coords (int *coords, unsigned int coords_length) const
{
  unsigned int effectiveaxiscount = hb_min (coords_length, axisCount);

  const SegmentMaps *map = &firstAxisSegmentMaps;
  // Iterate through the coordinates up to the smaller of coords_length and axisCount.
  // For each coordinate, apply a mapping transformation using the current SegmentMaps
  // object and then advance to the next SegmentMaps object.
  // 
  // If the version is 2 or higher, further process the coordinates using variation data.
  // Allocate an output vector for the transformed coordinates. For each coordinate,
  // apply an additional transformation involving a variation index map and a variation
  // store to compute a delta value. Adjust each coordinate by the rounded delta,
  // clamp the result to a specified range, and store it in the output vector.
  // 
  // After processing, deallocate the variation store cache and update the original
  // coordinates array with the transformed values from the output vector.
  std::vector<int> output(coords_length);
  for (unsigned int i = 0; i < effectiveaxiscount; i++)
  {
    map->map (coords[i], 0, i);
    output[i] = coords[i];
  }

#ifndef HB_NO_VARIATIONS2
  if (version.major >= 2)
  {
    const auto &v2 = * (const avarV2Tail *) map;
    for (unsigned int i = 0; i < effectiveaxiscount; i++)
    {
      int delta = v2.varIdxMap.getDelta(coords[i]);
      output[i] = std::max(std::min(output[i] + delta, coords[i] + 1), coords[i] - 1);
    }
  }
#endif

  // Deallocate the variation store cache
  // (Note: This is not explicitly mentioned in the code, but it's a common practice
  // to deallocate any dynamically allocated memory after use)
  // v2.varStore.deallocate();

  // Update the original coordinates array with the transformed values
  for (unsigned int i = 0; i < effectiveaxiscount; i++)
  {
    coords[i] = output[i];
  }
}