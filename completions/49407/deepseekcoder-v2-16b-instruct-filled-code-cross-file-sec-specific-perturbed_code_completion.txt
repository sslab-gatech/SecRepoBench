// Allocate an output vector for the transformed coordinates.
    std::vector<int> transformed_coords(coords_length);

    // Process the coordinates using the current SegmentMaps object.
    for (unsigned int i = 0; i < effectiveaxiscount; i++) {
        transformed_coords[i] = map->map(coords[i]);
        map = &StructAfter<SegmentMaps> (*map);
    }

    // If the version is 2 or higher, further process the coordinates using variation data.
    if (version >= 2) {
        // Allocate a variation index map and a variation store.
        std::vector<int> variation_index_map(effectiveaxiscount);
        std::vector<float> variation_store(effectiveaxiscount);

        // Compute the delta values for each coordinate.
        for (unsigned int i = 0; i < effectiveaxiscount; i++) {
            variation_index_map[i] = compute_variation_index(coords[i]);
            variation_store[i] = compute_variation_value(coords[i]);
        }

        // Adjust each coordinate by the rounded delta, clamp the result to a specified range, and store it in the output vector.
        for (unsigned int i = 0; i < effectiveaxiscount; i++) {
            float delta = variation_store[i] - variation_index_map[i];
            int rounded_delta = static_cast<int>(std::round(delta));
            int clamped_value = std::clamp(transformed_coords[i] + rounded_delta, min_range, max_range);
            transformed_coords[i] = clamped_value;
        }
    }

    // Deallocate the variation store cache.
    // (Assuming there's a deallocation function for the variation store cache)
    deallocate_variation_store_cache();

    // Update the original coordinates array with the transformed values from the output vector.
    for (unsigned int i = 0; i < effectiveaxiscount; i++) {
        coords[i] = transformed_coords[i];
    }