// Allocate an output vector for the transformed coordinates.
    std::vector<int> transformed_coords(coords_length);

    // Process each coordinate
    for (unsigned int i = 0; i < effectiveaxiscount; ++i) {
        // Apply the mapping transformation using the current SegmentMaps object
        transformed_coords[i] = map->transform(coords[i]);
        // Advance to the next SegmentMaps object
        map = map->next();
    }

    // If the version is 2 or higher, further process the coordinates using variation data
    if (version >= 2) {
        // Allocate a variation index map and a variation store
        std::vector<int> variation_index_map(coords_length);
        std::vector<int> variation_store(coords_length);

        // Compute a delta value for each coordinate
        for (unsigned int i = 0; i < effectiveaxiscount; ++i) {
            int delta = variation_index_map[i] * variation_store[i];
            // Adjust each coordinate by the rounded delta, clamp the result to a specified range, and store it in the output vector
            int rounded_delta = static_cast<int>(std::round(delta));
            int clamped_value = std::clamp(transformed_coords[i] + rounded_delta, min_value, max_value);
            transformed_coords[i] = clamped_value;
        }
    }

    // Deallocate the variation store cache
    // Assuming variation_store_cache is a class member that manages the cache
    variation_store_cache.clear();

    // Update the original coordinates array with the transformed values from the output vector
    for (unsigned int i = 0; i < effectiveaxiscount; ++i) {
        coords[i] = transformed_coords[i];
    }