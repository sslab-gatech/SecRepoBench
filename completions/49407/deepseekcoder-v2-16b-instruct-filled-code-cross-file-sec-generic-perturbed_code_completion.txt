// Allocate an output vector for the transformed coordinates.
    std::vector<int> transformed_coords(coords_length);

    // For each coordinate, apply the mapping transformation using the current SegmentMaps object.
    const SegmentMaps *map = &firstAxisSegmentMaps;
    for (unsigned int i = 0; i < effectiveaxiscount; i++) {
        transformed_coords[i] = map->map(coords[i]);
        map = &StructAfter<SegmentMaps> (*map);
    }

    // If the version is 2 or higher, further process the coordinates using variation data.
    if (version >= 2) {
        // Allocate a variation index map and a variation store.
        std::vector<int> variation_index_map(effectiveaxiscount);
        std::vector<float> variation_store(effectiveaxiscount);

        // Compute the delta values for each coordinate using the variation store.
        for (unsigned int i = 0; i < effectiveaxiscount; i++) {
            variation_index_map[i] = get_variation_index(i);
            variation_store[i] = get_variation_store(i);
        }

        // Adjust each coordinate by the rounded delta, clamp the result to a specified range, and store it in the output vector.
        for (unsigned int i = 0; i < effectiveaxiscount; i++) {
            float delta = variation_index_map[i] * variation_store[i];
            int rounded_delta = static_cast<int>(std::round(delta));
            int clamped_value = std::clamp(transformed_coords[i] + rounded_delta, min_range, max_range);
            transformed_coords[i] = clamped_value;
        }
    }

    // Deallocate the variation store cache.
    // (Assuming there's a method to deallocate the cache, which is not shown in the provided code fragments.)

    // Update the original coordinates array with the transformed values from the output vector.
    for (unsigned int i = 0; i < effectiveaxiscount; i++) {
        coords[i] = transformed_coords[i];
    }