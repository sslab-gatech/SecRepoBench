// Allocate an output vector for the transformed coordinates.
    int *output_coords = (int *)hb_calloc(coords_length, sizeof(int));
    if (!output_coords) {
      hb_free(copy);
      hb_free(unmapped);
      hb_free(design_coords);
      return;
    }

    // For each coordinate, apply an additional transformation involving a variation index map and a variation store to compute a delta value.
    for (unsigned int i = 0; i < effectiveaxiscount; i++) {
      float delta = 0.0f;
      if (version >= 2) {
        // Get the variation index map and variation store
        const VariationIndexMap *variation_index_map = get_variation_index_map();
        const VariationStore *variation_store = get_variation_store();

        // Compute the delta value
        delta = variation_index_map->compute_delta(coords[i], variation_store);
      }

      // Adjust each coordinate by the rounded delta, clamp the result to a specified range, and store it in the output vector.
      output_coords[i] = hb_clamp(roundf(delta) + coords[i], min_value, max_value);
    }

    // After processing, deallocate the variation store cache and update the original coordinates array with the transformed values from the output vector.
    memcpy(coords, output_coords, coords_length * sizeof(int));
    hb_free(output_coords);