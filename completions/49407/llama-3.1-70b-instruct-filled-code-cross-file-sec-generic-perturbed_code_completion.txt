// Allocate an output vector for the transformed coordinates.
int *output_coords = (int *) hb_calloc (coords_length, sizeof (int));
if (unlikely (!output_coords))
  return;

// Iterate through the coordinates up to the smaller of coords_length and axisCount.
for (unsigned int i = 0; i < effectiveaxiscount; i++)
{
  // Apply a mapping transformation using the current SegmentMaps object.
  int mapped_coord = map->unmap (coords[i]);
  map = &StructAfter<SegmentMaps> (*map);

  // If the version is 2 or higher, further process the coordinates using variation data.
  if (version >= 2)
  {
    // Apply an additional transformation involving a variation index map and a variation store to compute a delta value.
    int delta = variation_store->get_delta (mapped_coord, variation_index_map);
    // Adjust each coordinate by the rounded delta.
    int adjusted_coord = mapped_coord + (int) round (delta);
    // Clamp the result to a specified range.
    adjusted_coord = hb_clamp (adjusted_coord, min_coord, max_coord);
    // Store it in the output vector.
    output_coords[i] = adjusted_coord;
  }
  else
  {
    // Store the mapped coordinate in the output vector if version is less than 2.
    output_coords[i] = mapped_coord;
  }
}

// Update the original coordinates array with the transformed values from the output vector.
memcpy (coords, output_coords, coords_length * sizeof (int));

// Deallocate the output vector.
hb_free (output_coords);