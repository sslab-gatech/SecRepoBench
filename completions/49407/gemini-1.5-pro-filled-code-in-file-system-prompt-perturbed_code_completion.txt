for (unsigned int i = 0; i < effectiveaxiscount; i++)
    {
      coords[i] = map->map (coords[i]);
      map = &StructAfter<SegmentMaps> (*map);
    }

#ifndef HB_NO_VARIATIONS2
    if (version.major < 2)
      return;

    const auto &v2 = * (const avarV2Tail *) map;

    unsigned int count = hb_min (coords_length, v2.varIdxMap->getMapCount ());
    if (!count) return;

    float *output = (float *) hb_calloc (count, sizeof (float));
    if (unlikely (!output)) return;

    const VariationStore &var_store = *v2.varStore;
    for (unsigned int i = 0; i < count; i++)
    {
      hb_variation_axis_info_t info;
      if (v2.varIdxMap->getAxisInfo (i, &info))
      {
	float delta = var_store.get_delta (info, coords);
	output[i] = coords[i] + roundf (delta);
	output[i] = hb_clamp (output[i], -16384.f, 16384.f);
      } else {
	output[i] = coords[i];
      }
    }

    hb_free (var_store.cache);
    var_store.cache = nullptr;

    for (unsigned int i = 0; i < count; i++)
    {
      coords[i] = output[i];
    }

    hb_free (output);
#endif