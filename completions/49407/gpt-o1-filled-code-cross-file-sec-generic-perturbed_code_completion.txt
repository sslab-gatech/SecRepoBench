unsigned int count = hb_min(coords_length, axisCount);
const SegmentMaps *map = &firstAxisSegmentMaps;

// First pass: apply the segment mappings
for (unsigned int i = 0; i < count; i++)
{
  coords[i] = map->map(coords[i]);
  map = &StructAfter<SegmentMaps>(*map);
}

// If version 2 or higher, apply variation data
if (version >= 2)
{
  // Allocate temporary storage for transformed coordinates
  int *temp_coords = (int *) hb_calloc(count, sizeof(int));
  if (!temp_coords)
    return; // Allocation failed, just return

  // Initialize variation store cache (assumes variationStore is valid)
  VariationStoreCache var_store_cache;
  if (!variationStore->init_cache(&var_store_cache))
  {
    hb_free(temp_coords);
    return; // Cache initialization failed
  }

  // Compute variation deltas and clamp
  for (unsigned int i = 0; i < count; i++)
  {
    // variationIndexMap[i] should hold the variation index for axis i
    float delta = variationStore->get_delta(variationIndexMap[i], &var_store_cache);

    // Round and clamp
    long adjusted = coords[i] + lroundf(delta);
    if (adjusted < -32768) adjusted = -32768;
    if (adjusted >  32767) adjusted =  32767;

    temp_coords[i] = (int)adjusted;
  }

  // Clean up variation store cache
  variationStore->fini_cache(&var_store_cache);

  // Copy transformed results back into coords
  memcpy(coords, temp_coords, count * sizeof(int));
  hb_free(temp_coords);
}