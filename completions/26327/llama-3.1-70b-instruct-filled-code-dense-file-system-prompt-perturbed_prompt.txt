Below is the content of a C/C++ function where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
int flb_parser_time_lookup(const char *time_str, size_t tsize,
                           time_t now,
                           struct flb_parser *timeparser,
                           struct tm *tm, double *ns)
{
    int ret;
    time_t time_now;
    char *p = NULL;
    char *fmt;
    int time_len = tsize;
    const char *time_ptr = time_str;
    char tmp[64];
    struct tm tmy;

    *ns = 0;

    if (tsize > sizeof(tmp) - 1) {
        flb_error("[parser] time string length is too long");
        return -1;
    }

    /*
     * Some records coming from old Syslog messages do not contain the
     * year, so it's required to ingest this information in the value
     * to be parsed.
     */
    // Check if the time string does not include the year.
    // If the year is missing, use the current date to fill in the missing year.
    // Create a temporary buffer to hold the modified time string with the year.
    // Concatenate the current year to the beginning of the time string.
    // Use `gmtime_r` to get the current date and fill the missing month and day.
    // Parse the modified time string with the year using `flb_strptime` and store results in `tm`.
    // If the time string includes the year, copy it to a temporary buffer ensuring it is null-terminated.
    // Parse the time string using `flb_strptime` with the expected format and store results in `tm`.
    // <MASK>

    if (p == NULL) {
        flb_error("[parser] cannot parse '%.*s'", tsize, time_str);
        return -1;
    }

    if (timeparser->time_frac_secs) {
        ret = parse_subseconds(p, time_len - (p - time_ptr), ns);
        if (ret < 0) {
            flb_error("[parser] cannot parse %L for '%.*s'", tsize, time_str);
            return -1;
        }
        p += ret;

        /* Parse the remaining part after %L */
        p = flb_strptime(p, timeparser->time_frac_secs, tm);
        if (p == NULL) {
            flb_error("[parser] cannot parse '%.*s' after %L", tsize, time_str);
            return -1;
        }
    }

#ifdef FLB_HAVE_GMTOFF
    if (timeparser->time_with_tz == FLB_FALSE) {
        tm->tm_gmtoff = timeparser->time_offset;
    }
#endif

    return 0;
}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/flb_parser_ltsv.c
static int ltsv_parser(struct flb_parser *parser,
                       const char *in_buf, size_t in_size,
                       msgpack_packer *tmp_pck,
                       char *time_key, size_t time_key_len,
                       time_t *time_lookup, double *tmfrac,
                       size_t *map_size)
{
    int ret;
    struct tm tm = {0};
    const unsigned char *label = NULL;
    size_t label_len = 0;
    const unsigned char *field = NULL;
    size_t field_len = 0;
    const unsigned char *c = (const unsigned char *)in_buf;
    const unsigned char *end = c + in_size;
    int last_byte;
    int do_pack = FLB_TRUE;

    /* if map_size is 0 only count the number of k:v */
    if (*map_size == 0) {
        do_pack = FLB_FALSE;
    }

    while (c < end) {
        label = c;
        while ((c < end) && ltvs_label[*c]) {
            c++;
        }
        label_len = c - label;
        if (c == end) {
            break;
        }

        if (*c != ':') {
            break;
        }
        c++;

        field = c;
        if (c != end) {
            while ((c < end) && ltvs_field[*c]) {
                c++;
            }
        }
        field_len = c - field;

        if (label_len > 0) {
            int time_found = FLB_FALSE;

            if (parser->time_fmt && label_len == time_key_len &&
                field_len > 0 &&
                !strncmp((const char *)label, time_key, label_len)) {
                if (do_pack) {
                    ret = flb_parser_time_lookup((const char *) field, field_len,
                                                  0, parser, &tm, tmfrac);
                    if (ret == -1) {
                       flb_error("[parser:%s] Invalid time format %s",
                                 parser->name, parser->time_fmt_full);
                       return -1;
                    }
                    *time_lookup = flb_parser_tm2time(&tm);
                }
                time_found = FLB_TRUE;
            }

            if (time_found == FLB_FALSE || parser->time_keep == FLB_TRUE) {
                if (do_pack) {
                    if (parser->types_len != 0) {
                        flb_parser_typecast((const char*) label, label_len,
                                            (const char*) field, field_len,
                                            tmp_pck,
                                            parser->types,
                                            parser->types_len);
                    }
                    else {
                        msgpack_pack_str(tmp_pck, label_len);
                        msgpack_pack_str_body(tmp_pck, (const char *)label, label_len);
                        msgpack_pack_str(tmp_pck, field_len);
                        msgpack_pack_str_body(tmp_pck, (const char *)field, field_len);
                    }
                }
                else {
                    (*map_size)++;
                }
            }
        }

        if (c == end) {
            break;
        }
        if (*c == '\t') {
            c++;
        }
        if (c == end) {
            break;
        }

        if (*c == '\r') {
            c++;
            if (c == end) {
                break;
            }
            if (*c == '\n') {
                c++;
            }
            break;
        }
        if (*c == '\n') {
            c++;
            break;
        }
    }
    last_byte = (const char *)c - in_buf;

    return last_byte;
}

// the below code fragment can be found in:
// include/fluent-bit/flb_parser.h
static inline time_t flb_parser_tm2time(const struct tm *src)
{
    struct tm tmp;
    time_t res;

    tmp = *src;
#ifdef FLB_HAVE_GMTOFF
    res = timegm(&tmp) - src->tm_gmtoff;
#else
    res = timegm(&tmp);
#endif
    return res;
}

// the below code fragment can be found in:
// src/flb_parser_logfmt.c
static int logfmt_parser(struct flb_parser *parser,
                         const char *in_buf, size_t in_size,
                         msgpack_packer *tmp_pck,
                         char *time_key, size_t time_key_len,
                         time_t *time_lookup, double *tmfrac,
                         size_t *map_size)
{
    int ret;
    struct tm tm = {0};
    const unsigned char *key = NULL;
    size_t key_len = 0;
    const unsigned char *value = NULL;
    size_t value_len = 0;
    const unsigned char *c = (const unsigned char *)in_buf;
    const unsigned char *end = c + in_size;
    int last_byte;
    int do_pack = FLB_TRUE;
    int value_str = FLB_FALSE;
    int value_escape = FLB_FALSE;

    /* if map_size is 0 only count the number of k:v */
    if (*map_size == 0) {
        do_pack = FLB_FALSE;
    }

    while (c < end) {
        /* garbage */
        while ((c < end) && !ident_byte[*c]) {
            c++;
        }
        if (c == end) {
            break;
        }
        /* key */
        key = c;
        while ((c < end) && ident_byte[*c]) {
            c++;
        }
        if (c == end) {
            break;
        }

        key_len = c - key;
        /* value */
        value_len = 0;
        value_str = FLB_FALSE;
        value_escape =  FLB_FALSE;

        if (*c == '=') {
            c++;
            if (c < end) {
                if (*c == '"') {
                    c++;
                    value = c;
                    value_str = FLB_TRUE;
                    while (c < end) {
                        if (*c != '\\' && *c!= '"') {
                            c++;
                        }
                        else if (*c == '\\') {
                            value_escape =  FLB_TRUE;
                            c++;
                            if (c == end) {
                                break;
                            }
                            c++;
                        }
                        else {
                            break;
                        }
                    }
                    value_len = c - value;
                    if (c < end && *c == '\"') {
                        c++;
                    }
                }
                else {
                   value = c;
                   while ((c < end) && ident_byte[*c]) {
                      c++;
                   }
                   value_len = c - value;
                }
            }
        }

        if (key_len > 0) {
            int time_found = FLB_FALSE;

            if (parser->time_fmt && key_len == time_key_len &&
                value_len > 0 &&
                !strncmp((const char *)key, time_key, key_len)) {
                if (do_pack) {
                    ret = flb_parser_time_lookup((const char *) value, value_len,
                                                  0, parser, &tm, tmfrac);
                    if (ret == -1) {
                        flb_error("[parser:%s] Invalid time format %s",
                                  parser->name, parser->time_fmt_full);
                        return -1;
                    }
                    *time_lookup = flb_parser_tm2time(&tm);
                }
                time_found = FLB_TRUE;
            }

            if (time_found == FLB_FALSE || parser->time_keep == FLB_TRUE) {
                if (do_pack) {
                    if (parser->types_len != 0) {
                        flb_parser_typecast((const char*) key, key_len,
                                            (const char*) value, value_len,
                                            tmp_pck,
                                            parser->types,
                                            parser->types_len);
                    }
                    else {
                        msgpack_pack_str(tmp_pck, key_len);
                        msgpack_pack_str_body(tmp_pck, (const char *)key, key_len);
                        if (value_len == 0) {
                            if (value_str == FLB_TRUE) {
                                msgpack_pack_str(tmp_pck, 0);
                            }
                            else {
                                msgpack_pack_nil(tmp_pck);
                            }
                        }
                        else {
                            if (value_escape == FLB_TRUE) {
                                int out_len;
                                char *out_str;

                                out_str = flb_malloc(value_len + 1);
                                if (out_str == NULL) {
                                    flb_errno();
                                    return -1;
                                }
                                out_str[0] = 0;
                                flb_unescape_string_utf8((const char *)value,
                                                          value_len,
                                                          out_str);
                                out_len = strlen(out_str);

                                msgpack_pack_str(tmp_pck, out_len);
                                msgpack_pack_str_body(tmp_pck,
                                                      out_str,
                                                      out_len);

                                flb_free(out_str);
                            }
                            else {
                                msgpack_pack_str(tmp_pck, value_len);
                                msgpack_pack_str_body(tmp_pck,
                                                      (const char *)value,
                                                      value_len);
                            }
                        }
                    }
                }
                else {
                    (*map_size)++;
                }
            }
        }

        if (c == end) {
            break;
        }

        if (*c == '\r') {
            c++;
            if (c == end) {
                break;
            }
            if (*c == '\n') {
                c++;
            }
            break;
        }
        if (*c == '\n') {
            c++;
            break;
        }
    }
    last_byte = (const char *)c - in_buf;

    return last_byte;
}

// the below code fragment can be found in:
// src/flb_parser_ltsv.c
int flb_parser_ltsv_do(struct flb_parser *parser,
                       const char *in_buf, size_t in_size,
                       void **out_buf, size_t *out_size,
                       struct flb_time *out_time)
{
    int ret;
    time_t time_lookup;
    double tmfrac = 0;
    struct flb_time *t;
    msgpack_sbuffer tmp_sbuf;
    msgpack_packer tmp_pck;
    char *dec_out_buf;
    size_t dec_out_size;
    size_t map_size;
    char *time_key;
    size_t time_key_len;
    int last_byte;

    if (parser->time_key) {
        time_key = parser->time_key;
    }
    else {
        time_key = "time";
    }
    time_key_len = strlen(time_key);
    time_lookup = 0;

    /* count the number of key value pairs */
    map_size = 0;
    ltsv_parser(parser, in_buf, in_size, NULL,
                time_key, time_key_len,
                &time_lookup, &tmfrac, &map_size);
    if (map_size == 0) {
        return -1;
    }

    /* Prepare new outgoing buffer */
    msgpack_sbuffer_init(&tmp_sbuf);
    msgpack_packer_init(&tmp_pck, &tmp_sbuf, msgpack_sbuffer_write);
    msgpack_pack_map(&tmp_pck, map_size);

    last_byte = ltsv_parser(parser, in_buf, in_size, &tmp_pck,
                            time_key, time_key_len,
                            &time_lookup, &tmfrac, &map_size);
    if (last_byte < 0) {
        msgpack_sbuffer_destroy(&tmp_sbuf);
        return last_byte;
    }

    /* Export results */
    *out_buf = tmp_sbuf.data;
    *out_size = tmp_sbuf.size;

    t = out_time;
    t->tm.tv_sec  = time_lookup;
    t->tm.tv_nsec = (tmfrac * 1000000000);

    /* Check if some decoder was specified */
    if (parser->decoders) {
        ret = flb_parser_decoder_do(parser->decoders,
                                    tmp_sbuf.data, tmp_sbuf.size,
                                    &dec_out_buf, &dec_out_size);
        if (ret == 0) {
            *out_buf = dec_out_buf;
            *out_size = dec_out_size;
            msgpack_sbuffer_destroy(&tmp_sbuf);
        }
    }

    return last_byte;
}

// the below code fragment can be found in:
// src/flb_parser.c
int flb_parser_tzone_offset(const char *str, int len, int *tmdiff)
{
    int neg;
    long hour;
    long min;
    const char *end;
    const char *p = str;

    /* Check timezones */
    if (*p == 'Z') {
        /* This is UTC, no changes required */
        *tmdiff = 0;
        return 0;
    }

    /* Unexpected timezone string */
    if (*p != '+' && *p != '-') {
        *tmdiff = 0;
        return -1;
    }

    /* Negative value ? */
    neg = (*p++ == '-');

    /* Locate end */
    end = str + len;

    /* Gather hours and minutes */
    hour = ((p[0] - '0') * 10) + (p[1] - '0');
    if (end - p == 5 && p[2] == ':') {
        min = ((p[3] - '0') * 10) + (p[4] - '0');
    }
    else {
        min = ((p[2] - '0') * 10) + (p[3] - '0');
    }

    if (hour < 0 || hour > 59 || min < 0 || min > 59) {
        return -1;
    }

    *tmdiff = ((hour * 3600) + (min * 60));
    if (neg) {
        *tmdiff = -*tmdiff;
    }

    return 0;
}
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).