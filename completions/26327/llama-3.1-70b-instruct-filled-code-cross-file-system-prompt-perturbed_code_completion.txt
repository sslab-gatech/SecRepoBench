// Check if the time string does not include the year.
if (timeparser->time_fmt_year) {
    fmt = timeparser->time_fmt_year;
}
else {
    fmt = "%Y";
}

// If the year is missing, use the current date to fill in the missing year.
if (timeparser->time_with_tz == FLB_TRUE) {
    time_now = time(NULL);
    gmtime_r(&time_now, &tmy);
    snprintf(tmp, sizeof(tmp), "%04d%s", tmy.tm_year + 1900, time_str);
    time_ptr = tmp;
    time_len = strlen(time_ptr);
}
else {
    time_ptr = time_str;
}

// Create a temporary buffer to hold the modified time string with the year.
if (time_len > sizeof(tmp) - 1) {
    flb_error("[parser] time string length is too long");
    return -1;
}

// Concatenate the current year to the beginning of the time string.
if (timeparser->time_with_tz == FLB_TRUE) {
    memcpy(tmp, time_ptr, time_len);
    time_ptr = tmp;
}

// Use `gmtime_r` to get the current date and fill the missing month and day.
if (timeparser->time_with_tz == FLB_TRUE) {
    time_now = time(NULL);
    gmtime_r(&time_now, &tmy);
    tmy.tm_isdst = 0;
}

// Parse the modified time string with the year using `flb_strptime` and store results in `tm`.
p = flb_strptime(time_ptr, timeparser->time_fmt_full, tm);
if (p == NULL) {
    // If the time string includes the year, copy it to a temporary buffer ensuring it is null-terminated.
    if (tsize > sizeof(tmp) - 1) {
        flb_error("[parser] time string length is too long");
        return -1;
    }
    memcpy(tmp, time_str, tsize);
    tmp[tsize] = '\0';
    time_ptr = tmp;

    // Parse the time string using `flb_strptime` with the expected format and store results in `tm`.
    p = flb_strptime(time_ptr, timeparser->time_fmt, tm);
}