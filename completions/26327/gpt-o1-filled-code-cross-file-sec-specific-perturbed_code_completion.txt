/* Determine if the input string likely has a four-digit year */
    {
        int has_year = FLB_FALSE;
        int i;

        for (i = 0; i <= (int)tsize - 4; i++) {
            if (isdigit((unsigned char)time_str[i]) &&
                isdigit((unsigned char)time_str[i+1]) &&
                isdigit((unsigned char)time_str[i+2]) &&
                isdigit((unsigned char)time_str[i+3])) {
                has_year = FLB_TRUE;
                break;
            }
        }

        /* If year is missing, prepend current year; otherwise, just copy the string */
        if (has_year == FLB_FALSE && timeparser->time_fmt_year) {
            time_t current_time = (now == 0) ? time(NULL) : now;
            gmtime_r(&current_time, &tmy);

            /* Check available space for " <year> " + time_str + null terminator */
            if (tsize + 6 > sizeof(tmp)) {
                flb_error("[parser] not enough buffer to prepend year");
                return -1;
            }

            snprintf(tmp, sizeof(tmp),
                     "%04d %.*s",
                     tmy.tm_year + 1900,
                     (int) tsize, time_str);

            p = flb_strptime(tmp, timeparser->time_fmt_year, tm);
            if (p == NULL) {
                flb_error("[parser] cannot parse '%s' with year format", tmp);
                return -1;
            }
        }
        else {
            memcpy(tmp, time_str, tsize);
            tmp[tsize] = '\0';
            p = flb_strptime(tmp, timeparser->time_fmt, tm);
            if (p == NULL) {
                flb_error("[parser] cannot parse '%s' with base format", tmp);
                return -1;
            }
        }
    }