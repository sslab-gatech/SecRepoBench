// <MASK>
    if (tsize > sizeof(tmp) - 1) {
        flb_error("[parser] time string length is too long");
        return -1;
    }

    if (time_str[0] == '\0') {
        flb_error("[parser] time string is empty");
        return -1;
    }

    if (timeparser->time_fmt_year) {
        // Concatenate the current year to the beginning of the time string.
        char tmp_year[5];
        strftime(tmp_year, sizeof(tmp_year), "%Y", &tmy);
        char *p = flb_strlcat(tmp_year, time_str, sizeof(tmp));
        if (p == NULL) {
            flb_error("[parser] cannot concatenate time string");
            return -1;
        }
        time_str = tmp_year;
        tsize = strlen(time_str);
    }

    // Use `gmtime_r` to get the current date and fill the missing month and day.
    if (time_str[4] == '\0') {
        strftime(time_str + 4, tsize - 4, "%m %d", &tmy);
    }

    // Parse the modified time string with the year using `flb_strptime` and store results in `tm`.
    p = flb_strptime(time_str, timeparser->time_fmt_year, tm);
    if (p == NULL) {
        flb_error("[parser] cannot parse time string '%.*s'", tsize, time_str);
        return -1;
    }

    // If the time string includes the year, copy it to a temporary buffer ensuring it is null-terminated.
    if (timeparser->time_fmt_year) {
        char tmp[64];
        flb_strlcpy(tmp, time_str, sizeof(tmp));
        tmp[tsize] = '\0';
        time_str = tmp;
    }

    // Parse the time string using `flb_strptime` with the expected format and store results in `tm`.
    p = flb_strptime(time_str, timeparser->time_fmt, tm);
    if (p == NULL) {
        flb_error("[parser] cannot parse time string '%.*s'", tsize, time_str);
        return -1;
    }

    // <MASK>