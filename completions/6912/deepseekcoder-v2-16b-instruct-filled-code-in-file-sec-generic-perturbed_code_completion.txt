// <MASK>
static void TraceArcPath(PrimitiveInfo *primitive_info,const PointInfo start,
  const PointInfo end,const PointInfo arc,const double angle,
  const MagickBooleanType large_arc,const MagickBooleanType sweep)
{
  double
    alpha,
    beta,
    delta,
    factor,
    gamma,
    theta;

  PointInfo
    center,
    points[3],
    radii;

  register double
    cosine,
    sine;

  register PrimitiveInfo
    *p;

  register ssize_t
    i;

  size_t
    arc_segments;

  /*
    Ellipses are just short segmented polys.
  */
  if ((fabs(stop.x) < DrawEpsilon) && (fabs(stop.y) < DrawEpsilon))
    {
      TracePoint(primitive_info,end);
      return;
    }
  delta=2.0/MagickMax(stop.x,stop.y);
  step=MagickPI/8.0;
  if ((delta >= 0.0) && (delta < (MagickPI/8.0)))
    step=MagickPI/(4*(MagickPI/delta/2+0.5));
  if (step < 0.0000001)
    step=0.0000001;
  theta.x=DegreesToRadians(angle);
  y=360.0;
  while (y < angle)
    y+=360.0;
  theta.y=DegreesToRadians(y);
  for (p=primitive_info; theta.x < theta.y; theta.x+=step)
  {
    point.x=cos(fmod(theta.x,DegreesToRadians(360.0)))*stop.x+start.x;
    point.y=sin(fmod(theta.x,DegreesToRadians(360.0)))*stop.y+start.y;
    TracePoint(p,point);
    p+=p->coordinates;
  }
  point.x=cos(fmod(theta.y,DegreesToRadians(360.0)))*stop.x+start.x;
  point.y=sin(fmod(theta.y,DegreesToRadians(360.0)))*stop.y+start.y;
  TracePoint(p,point);
  p+=p->coordinates;
  primitive_info->coordinates=(size_t) (p-primitive_info);
  for (i=0; i < (ssize_t) primitive_info->coordinates; i++)
  {
    p->primitive=primitive_info->primitive;
    p--;
  }
}