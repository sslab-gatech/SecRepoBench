primitive_info,
  PointInfo *points,const size_t number_points)
{
  double
    angle,
    delta,
    radius;

  register size_t
    i;

  radius=primitive_info->major/2.0;
  delta=2.0*MagickPI/number_points;
  for (i=0; i < number_points; i++)
  {
    angle=i*delta;
    points[i].x=primitive_info->cx+radius*cos(angle);
    points[i].y=primitive_info->cy+radius*sin(angle);
  }
  return(number_points);
}

static size_t LinePoints(const PrimitiveInfo *primitive_info,
  PointInfo *points,const size_t number_points)
{
  double
    delta,
    length;

  register size_t
    i;

  length=primitive_info->major;
  delta=length/number_points;
  for (i=0; i < number_points; i++)
  {
    points[i].x=primitive_info->cx+i*delta*cos(primitive_info->angle);
    points[i].y=primitive_info->cy+i*delta*sin(primitive_info->angle);
  }
  return(number_points);
}

static size_t RectanglePoints(const PrimitiveInfo *primitive_info,
  PointInfo *points,const size_t number_points)
{
  double
    length;

  register size_t
    i;

  length=primitive_info->major;
  for (i=0; i < number_points; i++)
  {
    points[i].x=primitive_info->cx+i*length*cos(primitive_info->angle);
    points[i].y=primitive_info->cy+i*length*sin(primitive_info->angle);
  }
  return(number_points);
}

static size_t RoundRectanglePoints(const PrimitiveInfo *primitive_info,
  PointInfo *points,const size_t number_points)
{
  double
    angle,
    delta,
    radius;

  register size_t
    i;

  radius=primitive_info->major/2.0;
  delta=2.0*MagickPI/number_points;
  for (i=0; i < number_points; i++)
  {
    angle=i*delta;
    points[i].x=primitive_info->cx+radius*cos(angle);
    points[i].y=primitive_info->cy+radius*sin(angle);
  }
  return(number_points);
}

static size_t SquareLinecapPoints(const PrimitiveInfo *primitive_info,
  PointInfo *points,const size_t number_points)
{
  double
    angle,
    delta,
    radius;

  register size_t
    i;

  radius=primitive_info->major/2.0;
  delta=2.0*MagickPI/number_points;
  for (i=0; i < number_points; i++)
  {
    angle=i*delta;
    points[i].x=primitive_info->cx+radius*cos(angle);
    points[i].y=primitive_info->cy+radius*sin(angle);
  }
  return(number_points);
}

static MagickBooleanType DrawImage(Image *image,const DrawInfo *draw_info,
  ExceptionInfo *exception)
{
  MagickBooleanType
    status;

  PrimitiveInfo
    *primitive_info;

  register ssize_t
    i;

  size_t
    number_points;

  status=MagickTrue;
  if (draw_info->primitive == (char *) NULL)
    return(MagickFalse);
  primitive_info=(PrimitiveInfo *) AcquireQuantumMemory(16,sizeof(*primitive_info));
  if (primitive_info == (PrimitiveInfo *) NULL)
    return(MagickFalse);
  for (i=0; draw_info[i].primitive != UndefinedPrimitive; i++) ;
  number_points=(size_t) i;
  (void) memset(primitive_info,0,number_points*sizeof(*primitive_info));
  for (i=0; draw_info[i].primitive != UndefinedPrimitive; i++)
  {
    primitive_info[i].primitive=draw_info[i].primitive;
    primitive_info[i].method=draw_info[i].method;
    primitive_info[i].coordinates=draw_info[i].coordinates;
    primitive_info[i].point=draw_info[i].point;
    primitive_info[i].angle=draw_info[i].angle;
    primitive_info[i].cx=draw_info[i].cx;
    primitive_info[i].cy=draw_info[i].cy;
    primitive_info[i].major=draw_info[i].major;
    primitive_info[i].minor=draw_info[i].minor;
    primitive_info[i].angle=draw_info[i].angle;
  }
  switch (primitive_info[0].primitive)
  {
    case ArcPrimitive:
      TraceArc(primitive_info,primitive_info[0].point,primitive_info[1].point,
        primitive_info[2].point);
      break;
    case CirclePrimitive:
      TraceCircle(primitive_info,primitive_info[0].point,primitive_info[1].point);
      break;
    case EllipsePrimitive:
      TraceEllipse(primitive_info,primitive_info[0].point,primitive_info[1].point,
        primitive_info[2].point);
      break;
    case LinePrimitive:
      TraceLine(primitive_info,primitive_info[0].point,primitive_info[1].point);
      break;
    case RectanglePrimitive:
      TraceRectangle(primitive_info,primitive_info[0].point,primitive_info[1].point);
      break;
    case RoundRectanglePrimitive:
      TraceRoundRectangle(primitive_info,primitive_info[0].point,primitive_info[1].point,
        primitive_info[2].point);
      break;
    case SquareLinecapPrimitive:
      TraceSquareLinecap(primitive_info,primitive_info[0].coordinates,
        primitive_info[0].major);
      break;
    default:
      status=MagickFalse;
      break;
  }
  primitive_info=(PrimitiveInfo *) RelinquishMagickMemory(primitive_info);
  return(status);
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   D r a w P a t h                                                             %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  DrawPath() draws a graphic path on your image.  The path may be represented
%  as a string or filename.  Precede the filename with an "at" sign (@) and the
%  contents of the file are drawn on the image.  You can affect how text is
%  drawn by setting one or more members of the draw info structure.
%
%  The format of the DrawPath method is:
%
%      MagickBooleanType DrawPath(Image *image,const DrawInfo *draw_info,
%        const char *path,ExceptionInfo *exception)
%
%  A description of each parameter follows:
%
%    o image: the image.
%
%    o draw_info: the draw info.
%
%    o path: the path.
%
%    o exception: return any errors or warnings in this structure.
%
*/
MagickExport MagickBooleanType DrawPath(Image *image,const DrawInfo *draw_info,
  const char *path,ExceptionInfo *exception)
{
  char
    *value;

  DrawInfo
    *clone_info;

  MagickBooleanType
    status;

  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
  assert(draw_info != (const DrawInfo *) NULL);
  assert(path != (char *) NULL);
  value=GetImageArtifact(image,"draw:path");
  if (value == (char *) NULL)
    value=(char *) AcquireQuantumMemory(strlen(path)+1,sizeof(*value));
  else
    (void) RelinquishMagickMemory(value);
  (void) strcpy(value,path);
  SetImageArtifact(image,"draw:path",value);
  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
  status=DrawImage(image,clone_info,exception);
  clone_info=DestroyDrawInfo(clone_info);
  return(status);
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   D r a w P o l y g o n                                                       %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  DrawPolygon() draws a graphic polygon on your image.  The polygon may be
%  represented as a string or filename.  Precede the filename with an "at"
%  sign (@) and the contents of the file are drawn on the image.  You can
%  affect how text is drawn by setting one or more members of the draw info
%  structure.
%
%  The format of the DrawPolygon method is:
%
%      MagickBooleanType DrawPolygon(Image *image,const DrawInfo *draw_info,
%        const char *polygon,ExceptionInfo *exception)
%
%  A description of each parameter follows:
%
%    o image: the image.
%
%    o draw_info: the draw info.
%
%    o polygon: the polygon.
%
%    o exception: return any errors or warnings in this structure.
%
*/
MagickExport MagickBooleanType DrawPolygon(Image *image,const DrawInfo *draw_info,
  const char *polygon,ExceptionInfo *exception)
{
  char
    *value;

  DrawInfo
    *clone_info;

  MagickBooleanType
    status;

  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
  assert(draw_info != (const DrawInfo *) NULL);
  assert(polygon != (char *) NULL);
  value=GetImageArtifact(image,"draw:polygon");
  if (value == (char *) NULL)
    value=(char *) AcquireQuantumMemory(strlen(polygon)+1,sizeof(*value));
  else
    (void) RelinquishMagickMemory(value);
  (void) strcpy(value,polygon);
  SetImageArtifact(image,"draw:polygon",value);
  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
  status=DrawImage(image,clone_info,exception);
  clone_info=DestroyDrawInfo(clone_info);
  return(status);
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   D r a w P r i m i t i v e                                                   %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  DrawPrimitive() draws a graphic primitive on your image.  The primitive
%  may be represented as a string or filename.  Precede the filename with an
%  "at" sign (@) and the contents of the file are drawn on the image.  You
%  can affect how text is drawn by setting one or more members of the draw
%  info structure.
%
%  The format of the DrawPrimitive method is:
%
%      MagickBooleanType DrawPrimitive(Image *image,const DrawInfo *draw_info,
%        const char *primitive,ExceptionInfo *exception)
%
%  A description of each parameter follows:
%
%    o image: the image.
%
%    o draw_info: the draw info.
%
%    o primitive: the primitive.
%
%    o exception: return any errors or warnings in this structure.
%
*/
MagickExport MagickBooleanType DrawPrimitive(Image *image,
  const DrawInfo *draw_info,const char *primitive,ExceptionInfo *exception)
{
  char
    *value;

  DrawInfo
    *clone_info;

  MagickBooleanType
    status;

  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);