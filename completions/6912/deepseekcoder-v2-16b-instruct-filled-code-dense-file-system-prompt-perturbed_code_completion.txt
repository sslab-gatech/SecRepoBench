);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
  if (status == MagickFalse)
    return(MagickFalse);
  /*
    Initialize SVG image structure.
  */
  (void) ResetSVGInfo(&svg_info);
  svg_info.image=image;
  svg_info.image_info=image_info;
  svg_info.exception=exception;
  svg_info.number_points=65536;
  primitive_info=(PrimitiveInfo *) AcquireQuantumMemory((size_t) svg_info.number_points,
    sizeof(*primitive_info));
  if (primitive_info == (PrimitiveInfo *) NULL)
    {
      ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
        image->filename);
    }
  (void) memset(primitive_info,0,(size_t) svg_info.number_points*
    sizeof(*primitive_info));
  /*
    Process each primitive.
  */
  q=image_info->filename;
  while (*q != '\0')
  {
    /*
      Interpret graphic primitive.
    */
    GetNextToken(q,&q,MagickPathExtent,keyword);
    if (*keyword == '\0')
      break;
    if (*keyword == '#')
      {
        /*
          Comment.
        */
        while ((*q != '\n') && (*q != '\0'))
          q++;
        continue;
      }
    p=q-strlen(keyword)-1;
    primitive_type=UndefinedPrimitive;
    current=graphic_context[n]->affine;
    GetAffineMatrix(&affine);
    switch (*keyword)
    {
      case 'a':
      case 'A':
      {
        if (LocaleCompare("affine",keyword) == 0)
          {
            GetNextToken(q,&q,extent,primitive_token);
            affine.sx=StringToDouble(primitive_token,&next_token);
            if (primitive_token == next_token)
              ThrowPointExpectedException(primitive_token,exception);
            GetNextToken(q,&q,extent,primitive_token);
            if (*primitive_token == ',')
              GetNextToken(q,&q,extent,primitive_token);
            affine.rx=StringToDouble(primitive_token,&next_token);
            if (primitive_token == next_token)
              ThrowPointExpectedException(primitive_token,exception);
            GetNextToken(q,&q,extent,primitive_token);
            if (*primitive_token == ',')
              GetNextToken(q,&q,extent,primitive_token);
            affine.ry=StringToDouble(primitive_token,&next_token);
            if (primitive_token == next_token)
              ThrowPointExpectedException(primitive_token,exception);
            GetNextToken(q,&q,extent,primitive_token);
            if (*primitive_token == ',')
              GetNextToken(q,&q,extent,primitive_token);
            affine.sy=StringToDouble(primitive_token,&next_token);
            if (primitive_token == next_token)
              ThrowPointExpectedException(primitive_token,exception);
            GetNextToken(q,&q,extent,primitive_token);
            if (*primitive_token == ',')
              GetNextToken(q,&q,extent,primitive_token);
            affine.tx=StringToDouble(primitive_token,&next_token);
            if (primitive_token == next_token)
              ThrowPointExpectedException(primitive_token,exception);
            GetNextToken(q,&q,extent,primitive_token);
            if (*primitive_token == ',')
              GetNextToken(q,&q,extent,primitive_token);
            affine.ty=StringToDouble(primitive_token,&next_token);
            if (primitive_token == next_token)
              ThrowPointExpectedException(primitive_token,exception);
            break;
          }
        if (LocaleCompare("alpha",keyword) == 0)
          {
            primitive_type=AlphaPrimitive;
            break;
          }
        if (LocaleCompare("arc",keyword) == 0)
          {
            primitive_type=ArcPrimitive;
            break;
          }
        status=MagickFalse;
        break;
      }
      case 'b':
      case 'B':
      {
        if (LocaleCompare("bezier",keyword) == 0)
          {
            primitive_type=BezierPrimitive;
            break;
          }
        if (LocaleCompare("border-color",keyword) == 0)
          {
            GetNextToken(q,&q,extent,primitive_token);
            (void) QueryColorCompliance(primitive_token,AllCompliance,
              &graphic_context[n]->border_color,exception);
            break;
          }
        status=MagickFalse;
        break;
      }
      case 'c':
      case 'C':
      {
        if (LocaleCompare("clip-path",keyword) == 0)
          {
            /*
              Create clip mask.
            */
            GetNextToken(q,&q,extent,primitive_token);
            (void) CloneString(&graphic_context[n]->clip_mask,primitive_token);
            (void) DrawClipPath(image,graphic_context[n],
              graphic_context[n]->clip_mask,exception);
            break;
          }
        if (LocaleCompare("clip-rule",keyword) == 0)
          {
            ssize_t
              fill_rule;

            GetNextToken(q,&q,extent,primitive_token);
            fill_rule=ParseCommandOption(MagickFillRuleOptions,MagickFalse,
              primitive_token);
            if (fill_rule == -1)
              status=MagickFalse;
            else
              graphic_context[n]->fill_rule=(FillRule) fill_rule;
            break;
          }
        if (LocaleCompare("clip-units",keyword) == 0)
          {
            ssize_t
              clip_units;

            GetNextToken(q,&q,extent,primitive_token);
            clip_units=ParseCommandOption(MagickClipPathOptions,MagickFalse,
              primitive_token);
            if (clip_units == -1)
              {
                status=MagickFalse;
                break;
              }
            graphic_context[n]->clip_units=(ClipPathUnits) clip_units;
            if (clip_units == ObjectBoundingBox)
              {
                GetAffineMatrix(&current);
                affine.sx=draw_info->bounds.x2;
                affine.sy=draw_info->bounds.y2;
                affine.tx=draw_info->bounds.x1;
                affine.ty=draw_info->bounds.y1;
                break;
              }
            break;
          }
        if (LocaleCompare("circle",keyword) == 0)
          {
            primitive_type=CirclePrimitive;
            break;
          }
        if (LocaleCompare("color",keyword) == 0)
          {
            primitive_type=ColorPrimitive;
            break;
          }
        status=MagickFalse;
        break;
      }
      case 'd':
      case 'D':
      {
        if (LocaleCompare("decorate",keyword) == 0)
          {
            ssize_t
              decorate;

            GetNextToken(q,&q,extent,primitive_token);
            decorate=ParseCommandOption(MagickDecorateOptions,MagickFalse,
              primitive_token);
            if (decorate == -1)
              status=MagickFalse;
            else
              graphic_context[n]->decorate=(DecorationType) decorate;
            break;
          }
        if (LocaleCompare("density",keyword) == 0)
          {
            GetNextToken(q,&q,extent,primitive_token);
            (void) CloneString(&graphic_context[n]->density,primitive_token);
            break;
          }
        if (LocaleCompare("direction",keyword) == 0)
          {
            ssize_t
              direction;

            GetNextToken(q,&q,extent,primitive_token);
            direction=ParseCommandOption(MagickDirectionOptions,MagickFalse,
              primitive_token);
            if (direction == -1)
              status=MagickFalse;
            else
              graphic_context[n]->direction=(DirectionType) direction;
            break;
          }
        status=MagickFalse;
        break;
      }
      case 'e':
      case 'E':
      {
        if (LocaleCompare("ellipse",keyword) == 0)
          {
            primitive_type=EllipsePrimitive;
            break;
          }
        if (LocaleCompare("encoding",keyword) == 0)
          {
            GetNextToken(q,&q,extent,primitive_token);
            (void) CloneString(&graphic_context[n]->encoding,primitive_token);
            break;
          }
        status=MagickFalse;
        break;
      }
      case 'f':
      case 'F':
      {
        if (LocaleCompare("fill",keyword) == 0)
          {
            GetNextToken(q,&q,extent,primitive_token);
            (void) FormatLocaleString(pattern,MagickPathExtent,"%s",primitive_token);
            if (GetImageArtifact(image,pattern) != (const char *) NULL)
              (void) DrawPatternPath(image,draw_info,primitive_token,
                &graphic_context[n]->fill_pattern,exception);
            else
              {
                status&=QueryColorCompliance(primitive_token,AllCompliance,
                  &graphic_context[n]->fill,exception);
                if (graphic_context[n]->fill_alpha != OpaqueAlpha)
                  graphic_context[n]->fill.alpha=graphic_context[n]->fill_alpha;
              }
            break;
          }
        if (LocaleCompare("fill-opacity",keyword) == 0)
          {
            double
              opacity;

            GetNextToken(q,&q,extent,primitive_token);
            factor=strchr(primitive_token,'%') != (char *) NULL ? 0.01 : 1.0;
            opacity=MagickMin(MagickMax(factor*
              StringToDouble(primitive_token,&next_token),0.0),1.0);
            if (primitive_token == next_token)
              ThrowPointExpectedException(primitive_token,exception);
            graphic_context[n]->fill_alpha=(MagickRealType) (QuantumRange-
              QuantumRange*(1.0-opacity));
            break;
          }
        if (LocaleCompare("fill-rule",keyword) == 0)
          {
            ssize_t
              fill_rule;

            GetNextToken(q,&q,extent,primitive_token);
            fill_rule=ParseCommandOption(MagickFillRuleOptions,MagickFalse,
              primitive_token);
            if (fill_rule == -1)
              status=MagickFalse;
            else
              graphic_context[n]->fill_rule=(FillRule) fill_rule;
            break;
          }
        if (LocaleCompare("font",keyword) == 0)
          {
            GetNextToken(q,&q,extent,primitive_token);
            (void) CloneString(&graphic_context[n]->font,primitive_token);
            if (LocaleCompare("none",primitive_token) == 0)
              graphic_context[n]->font=(char *) RelinquishMagickMemory(
                graphic_context[n]->font);
            break;
          }
        if (LocaleCompare("font-family",keyword) == 0)
          {
            GetNextToken(q,&q,extent,primitive_token);
            (void) CloneString(&graphic_context[n]->family,primitive_token);
            break;
          }
        if (LocaleCompare("font-size",keyword) == 0)
          {
            GetNextToken(q,&q,extent,primitive_token);
            graphic_context[n]->pointsize=StringToDouble(primitive_token,&next_token);
            if (primitive_token == next_token)
              ThrowPointExpectedException(primitive_token,exception);
            break;
          }
        if (LocaleCompare("font-stretch",keyword) == 0)
          {
            ssize_t
              stretch;

            GetNextToken(q,&q,extent,primitive_token);
            stretch=ParseCommandOption(MagickStretchOptions,MagickFalse,primitive_token);
            if (stretch == -1)
              status=MagickFalse;
            else
              graphic_context[n]->stretch=(StretchType) stretch;
            break;
          }
        if (LocaleCompare("font-style",keyword) == 0)
          {
            ssize_t
              style;

            GetNextToken(q,&q,extent,primitive_token);
            style=ParseCommandOption(MagickStyleOptions,MagickFalse,primitive_token);
            if (style == -1)