static const char *
get_num(mrb_state *mrb, const char *p, const char *end, int *valp)
{
  mrb_int nextnumber = (int)*valp;
  // This code parses a sequence of digits from a format string to compute an integer value.
  // It iterates over the characters in the string as long as they are digits and attempts to 
  // accumulate these digits into the next number integer.
  // After parsing the digits, check for a malformed format string, and raise an 
  // error if so.
  while (p < end && isdigit((unsigned char)*p)) {
    nextnumber = nextnumber * 10 + (*p - '0');
    p++;
  }
  if (p < end &&!isdigit((unsigned char)*p)) {
    // Check if the next character is a decimal point
    if (*p == '.') {
      // Check if the next character is a digit
      if (p + 1 < end && isdigit((unsigned char)*(p + 1))) {
        // Parse the decimal part
        mrb_int decimal = 0;
        p++;
        while (p < end && isdigit((unsigned char)*p)) {
          decimal = decimal * 10 + (*p - '0');
          p++;
        }
        // Check if the decimal part is not too large
        if (decimal > 0) {
          nextnumber += decimal / (mrb_int)pow(10, mrb_int)(p - (p - 1));
        }
      } else {
        // Raise an error if the decimal part is malformed
        mrb_raise(mrb, E_ARGUMENT_ERROR, "Invalid decimal number");
      }
    } else {
      // Raise an error if the next character is not a digit or a decimal point
      mrb_raise(mrb, E_ARGUMENT_ERROR, "Invalid number");
    }
  }
  *valp = nextnumber;
  return p;
}