// Check if the codec ID is AV_CODEC_ID_HYMT and validate the buffer size
// and specific conditions at the end of the packet data. Determine
// the number of slices, slice height, and offset for slice information.
// If any of these are invalid, return an error. 
// If the codec ID does not match, default to a single slice covering the full height.
// <MASK>
if (avctx->codec_id == AV_CODEC_ID_HYMT) {
    if (buf_size < (width * height + 7)/8)
        return AVERROR_INVALIDDATA;

    if (buf_size < 8)
        return AVERROR_INVALIDDATA;

    if (buf_size > INT_MAX - 8)
        return AVERROR_INVALIDDATA;

    if (buf[buf_size - 8]!= 0x00)
        return AVERROR_INVALIDDATA;

    if (buf[buf_size - 7]!= 0x00)
        return AVERROR_INVALIDDATA;

    if (buf[buf_size - 6]!= 0x00)
        return AVERROR_INVALIDDATA;

    if (buf[buf_size - 5]!= 0x00)
        return AVERROR_INVALIDDATA;

    if (buf[buf_size - 4]!= 0x00)
        return AVERROR_INVALIDDATA;

    if (buf[buf_size - 3]!= 0x00)
        return AVERROR_INVALIDDATA;

    if (buf[buf_size - 2]!= 0x00)
        return AVERROR_INVALIDDATA;

    if (buf[buf_size - 1]!= 0x00)
        return AVERROR_INVALIDDATA;

    slices_info_offset = buf_size - 8;
    nb_slices = (buf[slices_info_offset] & 0xFF);
    if (nb_slices == 0)
        return AVERROR_INVALIDDATA;

    if (nb_slices > 1) {
        if (buf_size < (nb_slices + 1) * 8)
            return AVERROR_INVALIDDATA;

        slice_height = (buf[slices_info_offset + 1] & 0xFF) << 8;
        slice_height |= (buf[slices_info_offset + 2] & 0xFF);
        if (slice_height == 0)
            return AVERROR_INVALIDDATA;
    } else {
        slice_height = height;
    }
} else {
    nb_slices = 1;
    slice_height = height;
}