if (avctx->codec_id == AV_CODEC_ID_HYMT) {
    /* The last 8 bytes are used to store nb_slices and slice_height:
       [ nb_slices (4 bytes, little-endian) | slice_height (4 bytes, little-endian) ]
       Then nb_slices*8 bytes before that store offset/size pairs for each slice. */
    if (buf_size < 8) {
        return AVERROR_INVALIDDATA;
    }
    nb_slices    = AV_RL32(packet->data + buf_size - 8);
    slice_height = AV_RL32(packet->data + buf_size - 4);

    /* Validate the slices count and slice height */
    if (nb_slices < 1 || slice_height < 1 ||
        nb_slices > INT_MAX / 8 ||
        (uint64_t)nb_slices * 8 > buf_size - 8 ||
        slice_height * nb_slices != height) {
        return AVERROR_INVALIDDATA;
    }

    slices_info_offset = buf_size - 8 - nb_slices * 8;
    if (slices_info_offset > (unsigned)buf_size) {
        return AVERROR_INVALIDDATA;
    }
} else {
    /* For non-HYMT, just decode the entire frame as a single slice. */
    nb_slices          = 1;
    slice_height       = height;
    slices_info_offset = 0;
}