// Iterate through the initial set of glyph IDs to retain, and for each glyph ID,
// add it and its component glyphs to the complete set of glyph IDs to retain.
while (initial_gids_to_retain->next (&gid))
{
  if (!glyf.get_glyph_data (gid, nullptr))
    continue;

  full_glyphs_to_retain->add (gid);

  hb_blob_t *glyph_blob = glyf.get_glyph_blob (gid);
  OT::glyf::GlyphHeader *glyph_header = (OT::glyf::GlyphHeader *) hb_blob_get_data (glyph_blob, nullptr);
  if (glyph_header->flags & OT::glyf::GlyphHeader::FLAG_COMPOSITE)
  {
    OT::glyf::CompositeGlyphHeader *composite = (OT::glyf::CompositeGlyphHeader *) glyph_header;
    do
    {
      full_glyphs_to_retain->add (composite->component_glyph);
      composite = composite->get_next();
    } while (composite);
  }
  hb_blob_destroy (glyph_blob);
}
hb_set_destroy (initial_gids_to_retain);

// Allocate memory for the vector to store the glyph IDs and populate it with all the
// glyph IDs that need to be retained.
glyphs->resize (full_glyphs_to_retain->get_population ());
unsigned int i = 0;
gid = HB_SET_VALUE_INVALID;
while (full_glyphs_to_retain->next (&gid))
  (*glyphs)[i++] = gid;

// Finalize and clean up any resources associated with the glyph and cmap accelerators.
cmap.fini ();
glyf.fini ();

// Return the complete set of glyph IDs to retain.
return full_glyphs_to_retain;