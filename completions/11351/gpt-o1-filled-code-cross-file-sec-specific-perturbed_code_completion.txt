{
  // Use a queue to ensure we add all composite components transitively.
  hb_vector_t<hb_codepoint_t> queue;

  // Initialize the queue with all glyph IDs from the initial set.
  gid = HB_SET_VALUE_INVALID;
  while (initial_gids_to_retain->next(&gid))
  {
    if (!full_glyphs_to_retain->has(gid))
    {
      full_glyphs_to_retain->add(gid);
      queue.push(gid);
    }
  }

  // Recursively add component glyphs for each composite glyph.
  while (!queue.empty())
  {
    hb_codepoint_t current_gid = queue.pop();

    // Skip invalid indices to avoid reading past the buffer boundary.
    if (current_gid >= glyf.num_glyphs)
      continue;

    // Read the glyph data and collect its components.
    const OT::glyf::GlyphData* g = glyf.get_glyph_data(current_gid);
    if (!g) continue;

    if (g->is_composite())
    {
      unsigned int component_count = g->get_component_count();
      for (unsigned int i = 0; i < component_count; i++)
      {
        hb_codepoint_t comp_gid = g->get_component_glyph(i);
        if (!full_glyphs_to_retain->has(comp_gid))
        {
          full_glyphs_to_retain->add(comp_gid);
          queue.push(comp_gid);
        }
      }
    }
  }

  // Free the initial set now that we've collected all required glyphs.
  hb_set_destroy(initial_gids_to_retain);

  // Populate the 'glyphs' vector with all retained glyph IDs.
  gid = HB_SET_VALUE_INVALID;
  while (full_glyphs_to_retain->next(&gid))
  {
    glyphs->push(gid);
  }

  // Finalize accelerators and return.
  glyf.fini();
  cmap.fini();
  return full_glyphs_to_retain;
}