{
  hb_vector_t<hb_codepoint_t> worklist;
  hb_vector_init(&worklist);

  hb_codepoint_t val = HB_SET_VALUE_INVALID;
  /* Seed worklist and full_glyphs_to_retain from initial_gids_to_retain */
  while (initial_gids_to_retain->next(&val))
  {
    full_glyphs_to_retain->add(val);
    hb_vector_push(&worklist, val);
  }

  /* Iteratively process each glyph in the worklist to add composite components */
  while (worklist.len > 0)
  {
    /* Pop the last element from the worklist */
    hb_codepoint_t current = worklist.data[worklist.len - 1];
    worklist.len--;

    hb_vector_t<hb_codepoint_t> components;
    hb_vector_init(&components);
    if (glyf.get_components(current, &components))
    {
      for (unsigned int i = 0; i < components.len; i++)
      {
        hb_codepoint_t comp = components.data[i];
        if (!full_glyphs_to_retain->has(comp))
        {
          full_glyphs_to_retain->add(comp);
          hb_vector_push(&worklist, comp);
        }
      }
    }
    hb_vector_destroy(&components);
  }
  hb_vector_destroy(&worklist);

  /* Populate the output glyphs vector with glyph IDs from the complete set */
  val = HB_SET_VALUE_INVALID;
  while (full_glyphs_to_retain->next(&val))
    glyphs->add(val);

  hb_set_destroy(initial_gids_to_retain);

  return full_glyphs_to_retain;
}