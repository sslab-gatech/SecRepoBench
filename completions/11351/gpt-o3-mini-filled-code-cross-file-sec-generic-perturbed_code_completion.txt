/* Add all initial glyph IDs into the complete set and into a processing queue. */
  hb_vector_t<hb_codepoint_t> queue;
  hb_vector_init(&queue);
  hb_codepoint_t gid = HB_SET_VALUE_INVALID;
  /* Reset the iterator for initial_gids_to_retain */
  while (initial_gids_to_retain->next (&gid))
  {
    full_glyphs_to_retain->add (gid);
    hb_vector_push (&queue, gid);
  }

  /* Iteratively add composite components for each glyph */
  while (queue.len > 0)
  {
    /* Pop a glyph ID from the queue. */
    hb_codepoint_t current_gid = queue.data[queue.len - 1];
    queue.len--;

    /* Initialize a temporary vector to hold component glyph IDs.
       Assumes glyf.get_components returns true and populates the vector if the glyph is composite.
       If the glyph is simple, get_components returns false. */
    hb_vector_t<hb_codepoint_t> components;
    hb_vector_init (&components);
    if (glyf.get_components (current_gid, &components))
    {
      for (unsigned int i = 0; i < components.len; i++)
      {
        hb_codepoint_t comp_gid = components.data[i];
        if (!full_glyphs_to_retain->has (comp_gid))
        {
          full_glyphs_to_retain->add (comp_gid);
          hb_vector_push (&queue, comp_gid);
        }
      }
    }
    hb_vector_destroy (&components);
  }
  hb_vector_destroy (&queue);

  /* Clean up the initial set as it is no longer needed */
  hb_set_destroy (initial_gids_to_retain);

  /* Populate the glyph vector with the complete set of glyph IDs. */
  gid = HB_SET_VALUE_INVALID;
  while (full_glyphs_to_retain->next (&gid))
    hb_vector_push (glyphs, gid);

  /* Finalize the accelerators. */
  glyf.done (face);
  cmap.done (face);

  return full_glyphs_to_retain;