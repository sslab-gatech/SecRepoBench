{
  /* Create a worklist vector and initialize it with all glyph IDs from the initial set. */
  hb_vector_t<hb_codepoint_t> worklist;
  worklist.len = 0;
  {
    hb_codepoint_t tmp_gid = HB_SET_VALUE_INVALID;
    while (hb_set_next(initial_gids_to_retain, &tmp_gid))
      hb_vector_push(worklist, tmp_gid);
  }

  /* Copy the initial glyphs into the full set (if not already there) */
  {
    hb_codepoint_t tmp_gid = HB_SET_VALUE_INVALID;
    while (hb_set_next(initial_gids_to_retain, &tmp_gid))
      hb_set_add (full_glyphs_to_retain, tmp_gid);
  }

  /* Process the worklist: for each glyph, if it is composite, add its component glyphs. */
  while (worklist.len > 0)
  {
    /* Pop a glyph from the worklist */
    hb_codepoint_t gid = worklist.array[--worklist.len];

    /* Check if this glyph has composites.  The accelerator is expected to provide
       an is_composite() method and a get_components() method that fills a vector with
       component glyph IDs. */
    if (glyf.is_composite(gid))
    {
      hb_vector_t<hb_codepoint_t> components;
      components.len = 0;
      glyf.get_components(gid, &components);
      for (unsigned int i = 0; i < components.len; i++)
      {
        hb_codepoint_t comp = components.array[i];
        if (!hb_set_has(full_glyphs_to_retain, comp))
        {
          hb_set_add(full_glyphs_to_retain, comp);
          hb_vector_push(worklist, comp);
        }
      }
    }
  }

  /* Free the memory allocated for the initial set of glyph IDs */
  hb_set_destroy(initial_gids_to_retain);

  /* Populate the output glyph vector with the complete set of glyph IDs. */
  {
    hb_codepoint_t tmp_gid = HB_SET_VALUE_INVALID;
    while (hb_set_next(full_glyphs_to_retain, &tmp_gid))
      hb_vector_push(*glyphs, tmp_gid);
  }

  /* Finalize the accelerators (if needed) */
  cmap.fini();
  glyf.fini();

  return full_glyphs_to_retain;
}