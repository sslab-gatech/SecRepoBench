TLVRecordType getNextTLVRecord(TLVRecordType& record, const uint8_t* tlvBufferPtr, size_t tlvDataLen) const
{
    TLVRecordType resRec(NULL); // for NRVO optimization

    // Check if the input record is null; if so, return an uninitialized result record.
    if (record.isNull())
        return resRec;

    // Calculate the next TLV record by advancing the current record's base pointer by its total size.
    size_t nextRecordOffset = (size_t)record.getRecordBasePtr() + record.getTotalSize();

    // Check if the calculated record is within the bounds of the TLV memory range.
    if (nextRecordOffset > tlvBufferPtr + tlvDataLen)
        return resRec;

    // Calculate the size of the next TLV record.
    size_t nextRecordSize = 0;
    if (nextRecordOffset + sizeof(uint32_t) <= tlvBufferPtr + tlvDataLen)
        nextRecordSize = sizeof(uint32_t); // Assume the next record has a type field.
    else if (nextRecordOffset + sizeof(uint32_t) + sizeof(uint16_t) <= tlvBufferPtr + tlvDataLen)
        nextRecordSize = sizeof(uint32_t) + sizeof(uint16_t); // Assume the next record has a type and length field.
    else if (nextRecordOffset + sizeof(uint32_t) + sizeof(uint16_t) + sizeof(uint32_t) <= tlvBufferPtr + tlvDataLen)
        nextRecordSize = sizeof(uint32_t) + sizeof(uint16_t) + sizeof(uint32_t); // Assume the next record has a type, length, and value field.
    else
        return resRec; // The next record is out of bounds.

    // Create a new TLVRecord instance for the next record.
    resRec.assign((uint8_t*)tlvBufferPtr + nextRecordOffset);
    resRec.m_Data->recordLen = nextRecordSize - sizeof(uint32_t); // Set the length field of the next record.

    return resRec;
}