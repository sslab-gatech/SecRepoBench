// <MASK>
if (*p!= ';') {
    goto outexcept;
}
++p;

/* members */
if (*p!='m' || *++p!= ':') {
    goto outexcept;
}
++p;

pmembers = var_tmp_var(&var_hash);
if (!php_var_unserialize(pmembers, &p, s + buf_len, &var_hash) || Z_TYPE_P(pmembers)!= IS_ARRAY) {
    goto outexcept;
}

/* copy members */
object_properties_load(&intern->std, Z_ARRVAL_P(pmembers));

/* iterate through the serialized elements */
while (*p == ';') {
    ++p;
    if (*p == '\0') {
        break;
    }

    /* unserialize the count of elements in the buffer */
    if (*p!= 'c' || *++p!= ':') {
        goto outexcept;
    }
    ++p;

    count = var_tmp_var(&var_hash);
    if (!php_var_unserialize(count, &p, s + buf_len, &var_hash) || Z_TYPE_P(count)!= IS_LONG) {
        goto outexcept;
    }

    /* unserialize the element */
    if (*p!= ';') {
        goto outexcept;
    }
    ++p;

    elem = var_tmp_var(&var_hash);
    if (!php_var_unserialize(elem, &p, s + buf_len, &var_hash) || Z_TYPE_P(elem)!= IS_OBJECT) {
        goto outexcept;
    }

    /* validate the unserialized data */
    if (!spl_object_storage_validate(elem)) {
        goto outexcept;
    }

    /* attach the unserialized element to the internal storage structure */
    spl_object_storage_attach(intern, elem);

    /* manage references and memory for the unserialized entries */
    Z_TRY_ADDREF(elem);
}

/* validate the unserialized data, ensuring it is an object, and retrieve or create a storage element */
if (!spl_object_storage_validate(intern)) {
    goto outexcept;
}

/* done reading $serialized */
PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
return;

outexcept:
PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0, "Error at offset %zd of %zd bytes", ((char*)p - serialized_data_buffer), buf_len);
RETURN_THROWS();