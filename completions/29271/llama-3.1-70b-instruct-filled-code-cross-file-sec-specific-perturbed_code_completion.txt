/* storage */
if (*p!='a' && *p!='O' && *p!='C' && *p!='r') {
	goto outexcept;
}

zval *storage = var_tmp_var(&var_hash);
if (!php_var_unserialize(storage, &p, s + buf_len, &var_hash)
		|| (Z_TYPE_P(storage)!= IS_ARRAY && Z_TYPE_P(storage)!= IS_OBJECT)) {
	goto outexcept;
}

if (Z_TYPE_P(storage) == IS_ARRAY) {
	zend_hash_clean(&intern->storage);
	ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(storage), elem) {
		if (Z_TYPE_P(elem)!= IS_ARRAY || zend_hash_num_elements(Z_ARRVAL_P(elem))!= 2) {
			zend_hash_clean(&intern->storage);
			goto outexcept;
		}
		zval *obj = NULL;
		zval *inf = NULL;
		ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(elem), entry) {
			if (Z_TYPE_P(entry) == IS_OBJECT) {
				obj = entry;
			} else {
				inf = entry;
			}
		} ZEND_HASH_FOREACH_END();
		if (!obj ||!inf) {
			zend_hash_clean(&intern->storage);
			goto outexcept;
		}
		spl_SplObjectStorageElement *data;
		zend_hash_find(&intern->storage, Z_OBJ_P(obj), (void **)&data);
		if (data) {
			zval_ptr_dtor(&data->inf);
		} else {
			data = emalloc(sizeof(spl_SplObjectStorageElement));
			data->obj = obj;
			zend_hash_add(&intern->storage, Z_OBJ_P(obj), data, sizeof(spl_SplObjectStorageElement), NULL);
		}
		Z_TRY_ADDREF(inf);
		ZVAL_COPY_VALUE(&data->inf, inf);
	} ZEND_HASH_FOREACH_END();
	zval_ptr_dtor(storage);
} else {
	zend_hash_clean(&intern->storage);
	spl_SplObjectStorageElement *data = emalloc(sizeof(spl_SplObjectStorageElement));
	data->obj = storage;
	zend_hash_add(&intern->storage, Z_OBJ_P(storage), data, sizeof(spl_SplObjectStorageElement), NULL);
}

if (*p!= ';') {
	goto outexcept;
}
++p;