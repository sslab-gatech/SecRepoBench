if (TIFFWritePixels(tiff,&tiff_info,y,2,image) == -1)
                break;
            }
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,SaveImageTag,300,400);
                if (status == MagickFalse)
                  break;
              }
            if (image->alpha_trait!= UndefinedPixelTrait)
              for (y=0; y < (ssize_t) image->rows; y++)
              {
                register const Quantum
                  *magick_restrict p;

                p=GetVirtualPixels(image,0,y,image->columns,1,exception);
                if (p == (const Quantum *) NULL)
                  break;
                length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,
                  AlphaQuantum,pixels,exception);
                if (TIFFWritePixels(tiff,&tiff_info,y,3,image) == -1)
                  break;
              }
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,SaveImageTag,400,400);
                if (status == MagickFalse)
                  break;
              }
            break;
          }
        }
        break;
      }
      case PHOTOMETRIC_MINISBLACK:
      case PHOTOMETRIC_MINISWHITE:
      {
        quantum_type=IndexQuantum;
        if (image->alpha_trait!= UndefinedPixelTrait)
          {
            if (image->storage_class!= PseudoClass)
              {
                quantum_type=samples_per_pixel == 1? AlphaQuantum :
                  GrayAlphaQuantum;
              }
            else
              {
                quantum_type=IndexAlphaQuantum;
              }
          }
        else
          if (image->storage_class!= PseudoClass)
            {
              quantum_type=GrayQuantum;
            }
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          register const Quantum
            *magick_restrict p;

          p=GetVirtualPixels(image,0,y,image->columns,1,exception);
          if (p == (const Quantum *) NULL)
            break;
          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,
            quantum_type,pixels,exception);
          (void) length;
          if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case PHOTOMETRIC_PALETTE:
      {
        quantum_type=IndexQuantum;
        if (image->alpha_trait!= UndefinedPixelTrait)
          {
            if (image->storage_class!= PseudoClass)
              {
                quantum_type=samples_per_pixel == 1? AlphaQuantum :
                  GrayAlphaQuantum;
              }
            else
              {
                quantum_type=IndexAlphaQuantum;
              }
          }
        else
          if (image->storage_class!= PseudoClass)
            {
              quantum_type=GrayQuantum;
            }
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          register const Quantum
            *magick_restrict p;

          p=GetVirtualPixels(image,0,y,image->columns,1,exception);
          if (p == (const Quantum *) NULL)
            break;
          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,
            quantum_type,pixels,exception);
          (void) length;
          if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case PHOTOMETRIC_SEPARATED:
      {
        for (i=0; i < (ssize_t) samples_per_pixel; i++)
        {
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            register const Quantum
              *magick_restrict p;

            p=GetVirtualPixels(image,0,y,image->columns,1,exception);
            if (p == (const Quantum *) NULL)
              break;
            if (image->colorspace!= CMYKColorspace)
              switch (i)
              {
                case 0: quantum_type=RedQuantum; break;
                case 1: quantum_type=GreenQuantum; break;
                case 2: quantum_type=BlueQuantum; break;
                case 3: quantum_type=AlphaQuantum; break;
                default: quantum_type=UndefinedQuantum; break;
              }
            else
              switch (i)
              {
                case 0: quantum_type=CyanQuantum; break;
                case 1: quantum_type=MagentaQuantum; break;
                case 2: quantum_type=YellowQuantum; break;
                case 3: quantum_type=BlackQuantum; break;
                case 4: quantum_type=AlphaQuantum; break;
                default: quantum_type=UndefinedQuantum; break;
              }
            length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,
              quantum_type,pixels,exception);
            (void) length;
            if (TIFFWritePixels(tiff,&tiff_info,y,i,image) == -1)
              break;
          }
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case PHOTOMETRIC_LOGL:
      case PHOTOMETRIC_LOGLUV:
      {
        quantum_type=IndexQuantum;
        if (image->alpha_trait!= UndefinedPixelTrait)
          {
            if (image->storage_class!= PseudoClass)
              {
                quantum_type=samples_per_pixel == 1? AlphaQuantum :
                  GrayAlphaQuantum;
              }
            else
              {
                quantum_type=IndexAlphaQuantum;
              }
          }
        else
          if (image->storage_class!= PseudoClass)
            {
              quantum_type=GrayQuantum;
            }
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          register const Quantum
            *magick_restrict p;

          p=GetVirtualPixels(image,0,y,image->columns,1,exception);
          if (p == (const Quantum *) NULL)
            break;
          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,
            quantum_type,pixels,exception);
          (void) length;
          if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case PHOTOMETRIC_YCBCR:
      {
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          register const Quantum
            *magick_restrict p;

          p=GetVirtualPixels(image,0,y,image->columns,1,exception);
          if (p == (const Quantum *) NULL)
            break;
          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,
            YQuantum,pixels,exception);
          (void) length;
          if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)
            break;
        }
        if (image->previous == (Image *) NULL)
          {
            status=SetImageProgress(image,SaveImageTag,100,400);
            if (status == MagickFalse)
              break;
          }
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          register const Quantum
            *magick_restrict p;

          p=GetVirtualPixels(image,0,y,image->columns,1,exception);
          if (p == (const Quantum *) NULL)
            break;
          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,
            CBQuantum,pixels,exception);
          (void) length;
          if (TIFFWritePixels(tiff,&tiff_info,y,1,image) == -1)
            break;
        }
        if (image->previous == (Image *) NULL)
          {
            status=SetImageProgress(image,SaveImageTag,200,400);
            if (status == MagickFalse)
              break;
          }
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          register const Quantum
            *magick_restrict p;

          p=GetVirtualPixels(image,0,y,image->columns,1,exception);
          if (p == (const Quantum *) NULL)
            break;
          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,
            CRQuantum,pixels,exception);
          (void) length;
          if (TIFFWritePixels(tiff,&tiff_info,y,2,image) == -1)
            break;
        }
        if (image->previous == (Image *) NULL)
          {
            status=SetImageProgress(image,SaveImageTag,300,400);
            if (status == MagickFalse)
              break;
          }
        if (image->alpha_trait!= UndefinedPixelTrait)
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            register const Quantum
              *magick_restrict p;

            p=GetVirtualPixels(image,0,y,image->columns,1,exception);
            if (p == (const Quantum *) NULL)
              break;
            length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,
              AlphaQuantum,pixels,exception);
            (void) length;
            if (TIFFWritePixels(tiff,&tiff_info,y,3,image) == -1)
              break;
          }
        if (image->previous == (Image *) NULL)
          {
            status=SetImageProgress(image,SaveImageTag,400,400);
            if (status == MagickFalse)
              break;
          }
        break;
      }
      default:
      {
        ThrowWriterException(CoderError,"UnsupportedTIFFImageType");
        break;
      }
    }
    if (TIFFWriteDirectory(tiff) == -1)
      ThrowWriterException(CoderError,"UnableToWriteTIFFDirectory");
    if (LocaleCompare(image_info->magick,"PTIF") == 0)
      {
        TIFFWritePTIFDirectory(tiff,image);
        TIFFWritePTIFImage(tiff,image);
      }
    if (LocaleCompare(image_info->magick,"PTIF")!= 0)
      {
        TIFFWritePTIFImage(tiff,image);
        TIFFWritePTIFDirectory(tiff,image);
      }
    if (LocaleCompare(image_info->magick,"PTIF") == 0)
      {
        TIFFWritePTIFImage(tiff,image);
        TIFFWritePTIFDirectory(tiff,image);
      }
    if (LocaleCompare(image_info->magick,"PTIF")!= 0)
      {
        TIFFWritePTIFDirectory(tiff,image);
        TIFFWritePTIFImage(tiff,image);
      }
    if (LocaleCompare(image_info->magick,"PTIF") == 0)
      {
        TIFFWritePTIFDirectory(tiff,image);
        TIFFWritePTIFImage(tiff,image);
      }
    if (LocaleCompare(image_info->magick,"PTIF")!= 0)
      {
        TIFFWritePTIFImage(tiff,image);
        TIFFWritePTIFDirectory(tiff,image);
      }
    if (LocaleCompare(image_info->magick,"PTIF") == 0)
      {
        TIFFWritePTIFImage(tiff,image);
        TIFFWritePTIFDirectory(tiff,image);
      }
    if (LocaleCompare(image_info->magick,"PTIF")!= 0)
      {
        TIFFWritePTIFDirectory(tiff,image);
        TIFFWritePTIFImage(tiff,image);
      }
    if (LocaleCompare(image_info->magick,"PTIF") == 0)
      {
        TIFFWritePTIFDirectory(tiff,image);
        TIFFWritePTIFImage(tiff,image);
      }
    if (LocaleCompare(image_info->magick,"PTIF")!= 0)
      {
        TIFFWritePTIFImage(tiff,image);
        TIFFWritePTIFDirectory(tiff,image);
      }
    if (LocaleCompare(image_info->magick,"PTIF") == 0)
      {
        TIFFWritePTIFImage(tiff,image);
        TIFFWritePTIFDirectory(tiff,image);
      }
    if (LocaleCompare(image_info->magick,"PTIF")!= 0)
      {
        TIFFWritePTIFDirectory(tiff,image);
        TIFFWritePTIFImage(tiff,image);
      }
    if (LocaleCompare(image_info->magick,"PTIF") == 0)
      {
        TIFFWritePTIFDirectory(tiff,image);
        TIFFWritePTIFImage(tiff,image);
      }
    if (LocaleCompare(image_info->magick,"PTIF")!= 0)
      {
        TIFFWritePTIFImage(tiff,image);
        TIFFWritePTIFDirectory(tiff,image);
      }
    if (LocaleCompare(image_info->magick,"PTIF") == 0)
      {
        TIFFWritePTIFImage(tiff,image);
        TIFFWritePTIFDirectory(tiff,image);
      }
    if (LocaleCompare(image_info->magick,"PTIF")!= 0)
      {
        TIFFWritePTIFDirectory(tiff,image);
        TIFFWritePTIFImage(tiff,image);
      }
    if (LocaleCompare(image_info->magick,"PTIF") == 0)
      {
        TIFFWritePTIFDirectory(tiff,image);
        TIFFWritePTIFImage(tiff,image);
      }
    if (LocaleCompare(image_info->magick,"PTIF")!= 0)
      {
        TIFFWritePTIFImage(tiff,image);
        TIFFWritePTIFDirectory(tiff,image);
      }