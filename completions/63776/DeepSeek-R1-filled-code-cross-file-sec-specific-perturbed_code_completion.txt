size_t expected_end = obj->address + obj->size;
                if (expected_end > bit_chain->size) {
                    LOG_ERROR("Object size exceeds buffer bounds: %zu > %zu",
                              expected_end, bit_chain->size);
                    obj->size = bit_chain->size - obj->address;
                    error |= DWG_ERR_INVALIDDWG;
                }

                if (bit_chain->byte != expected_end) {
                    size_t unknown_bytes = expected_end - bit_chain->byte;
                    if (unknown_bytes > 0 && unknown_bytes <= bit_chain->size - bit_chain->byte) {
                        obj->unknown_data = (BITCODE_TF*)malloc(unknown_bytes);
                        if (obj->unknown_data) {
                            memcpy(obj->unknown_data, bit_chain->chain + bit_chain->byte, unknown_bytes);
                            bit_chain->byte += unknown_bytes;
                            LOG_TRACE("Extracted %zu unknown bytes at end of object", unknown_bytes);
                        } else {
                            LOG_ERROR("Failed to allocate %zu bytes for unknown data", unknown_bytes);
                            error |= DWG_ERR_OUTOFMEM;
                        }
                    } else if (unknown_bytes > 0) {
                        LOG_ERROR("Invalid unknown bytes calculation: %zu remaining", unknown_bytes);
                        error |= DWG_ERR_INVALIDDWG;
                    }
                }

                SINCE(R_11) {
                    if (bit_chain->byte + 2 <= bit_chain->size) {
                        BITCODE_RC crc[2];
                        crc[0] = bit_read_RC(bit_chain);
                        crc[1] = bit_read_RC(bit_chain);
                        LOG_TRACE("CRC bytes: %02X%02X", crc[0], crc[1]);
                    } else {
                        LOG_ERROR("Missing CRC bytes at end of object");
                        error |= DWG_ERR_INVALIDDWG;
                    }
                }