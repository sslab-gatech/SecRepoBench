// This code block handles the size validation and unknown data extraction for DWG objects in pre-R13 and later versions.
// For pre-R11 versions, the code checks if the object's size is valid and within the bounds of the data, adjusting it if necessary.
// It extracts any unknown remaining data if the object size doesn't match the current data position and logs errors if issues are found.
// For later versions, additional CRC checks are performed to ensure data integrity, and adjustments are made to account for any size discrepancies.
// If the object's address and size don't align with the data position, the code calculates the offset for any trailing unknown data and allocates memory to store it, logging appropriate messages.
// <MASK>
{
  if (obj->size > (BITCODE_RL)(bit_chain->byte - oldpos))
    {
      LOG_ERROR ("Invalid object size %u > %u", obj->size,
                 (unsigned)(bit_chain->byte - oldpos));
      obj->size = (BITCODE_RL)(bit_chain->byte - oldpos);
    }
  if (obj->size < (BITCODE_RL)(bit_chain->byte - oldpos))
    {
      LOG_WARN ("Invalid object size %u < %u", obj->size,
                 (unsigned)(bit_chain->byte - oldpos));
      obj->size = (BITCODE_RL)(bit_chain->byte - oldpos);
    }
  if (obj->size != (BITCODE_RL)(bit_chain->byte - oldpos))
    {
      size_t unknown_size = obj->size - (bit_chain->byte - oldpos);
      LOG_WARN ("Invalid object size %u != %u, %u bytes of unknown data",
                 obj->size, (unsigned)(bit_chain->byte - oldpos), unknown_size);
      obj->unknown_rest = dwg_read_unknown_data (bit_chain, unknown_size);
      if (obj->unknown_rest)
        {
          obj->num_unknown_rest = unknown_size;
          LOG_TRACE ("unknown_rest: %.*s\n", obj->num_unknown_rest,
                     obj->unknown_rest);
        }
    }
  if (obj->size > dwg->header.section[SECTION_ENTITIES].size)
    {
      LOG_ERROR ("Invalid object size %u > section size %u",
                 obj->size, dwg->header.section[SECTION_ENTITIES].size);
      obj->size = dwg->header.section[SECTION_ENTITIES].size;
    }
  if (obj->size < dwg->header.section[SECTION_ENTITIES].size)
    {
      LOG_WARN ("Invalid object size %u < section size %u",
                 obj->size, dwg->header.section[SECTION_ENTITIES].size);
      obj->size = dwg->header.section[SECTION_ENTITIES].size;
    }
  if (obj->size != dwg->header.section[SECTION_ENTITIES].size)
    {
      size_t unknown_size = dwg->header.section[SECTION_ENTITIES].size - obj->size;
      LOG_WARN ("Invalid object size %u != section size %u, %u bytes of unknown data",
                 obj->size, dwg->header.section[SECTION_ENTITIES].size,
                 unknown_size);
      obj->unknown_rest = dwg_read_unknown_data (bit_chain, unknown_size);
      if (obj->unknown_rest)
        {
          obj->num_unknown_rest = unknown_size;
          LOG_TRACE ("unknown_rest: %.*s\n", obj->num_unknown_rest,
                     obj->unknown_rest);
        }
    }
  if (obj->size > dwg->header.section[SECTION_ENTITIES].compressed_size)
    {
      LOG_ERROR ("Invalid object size %u > compressed section size %u",
                 obj->size, dwg->header.section[SECTION_ENTITIES].compressed_size);
      obj->size = dwg->header.section[SECTION_ENTITIES].compressed_size;
    }
  if (obj->size < dwg->header.section[SECTION_ENTITIES].compressed_size)
    {
      LOG_WARN ("Invalid object size %u < compressed section size %u",
                 obj->size, dwg->header.section[SECTION_ENTITIES].compressed_size);
      obj->size = dwg->header.section[SECTION_ENTITIES].compressed_size;
    }
  if (obj->size != dwg->header.section[SECTION_ENTITIES].compressed_size)
    {
      size_t unknown_size = dwg->header.section[SECTION_ENTITIES].compressed_size
                          - obj->size;
      LOG_WARN ("Invalid object size %u != compressed section size %u, %u bytes of unknown data",
                 obj->size, dwg->header.section[SECTION_ENTITIES].compressed_size,
                 unknown_size);
      obj->unknown_rest = dwg_read_unknown_data (bit_chain, unknown_size);
      if (obj->unknown_rest)
        {
          obj->num_unknown_rest = unknown_size;
          LOG_TRACE ("unknown_rest: %.*s\n", obj->num_unknown_rest,
                     obj->unknown_rest);
        }
    }
  if (obj->size > dwg->header.section[SECTION_ENTITIES].decomp_data_size)
    {
      LOG_ERROR ("Invalid object size %u > decompressed data size %u",
                 obj->size, dwg->header.section[SECTION_ENTITIES].decomp_data_size);
      obj->size = dwg->header.section[SECTION_ENTITIES].decomp_data_size;
    }
  if (obj->size < dwg->header.section[SECTION_ENTITIES].decomp_data_size)
    {
      LOG_WARN ("Invalid object size %u < decompressed data size %u",
                 obj->size, dwg->header.section[SECTION_ENTITIES].decomp_data_size);
      obj->size = dwg->header.section[SECTION_ENTITIES].decomp_data_size;
    }
  if (obj->size != dwg->header.section[SECTION_ENTITIES].decomp_data_size)
    {
      size_t unknown_size = dwg->header.section[SECTION_ENTITIES].decomp_data_size
                          - obj->size;
      LOG_WARN ("Invalid object size %u != decompressed data size %u, %u bytes of unknown data",
                 obj->size, dwg->header.section[SECTION_ENTITIES].decomp_data_size,
                 unknown_size);
      obj->unknown_rest = dwg_read_unknown_data (bit_chain, unknown_size);
      if (obj->unknown_rest)
        {
          obj->num_unknown_rest = unknown_size;
          LOG_TRACE ("unknown_rest: %.*s\n", obj->num_unknown_rest,
                     obj->unknown_rest);
        }
    }
  if (obj->size > dwg->header.section[SECTION_ENTITIES].max_size)
    {
      LOG_ERROR ("Invalid object size %u > max decompressed size %u",
                 obj->size, dwg->header.section[SECTION_ENTITIES].max_size);
      obj->size = dwg->header.section[SECTION_ENTITIES].max_size;
    }
  if (obj->size < dwg->header.section[SECTION_ENTITIES].max_size)
    {
      LOG_WARN ("Invalid object size %u < max decompressed size %u",
                 obj->size, dwg->header.section[SECTION_ENTITIES].max_size);
      obj->size = dwg->header.section[SECTION_ENTITIES].max_size;
    }
  if (obj->size != dwg->header.section[SECTION_ENTITIES].max_size)
    {
      size_t unknown_size = dwg->header.section[SECTION_ENTITIES].max_size - obj->size;
      LOG_WARN ("Invalid object size %u != max decompressed size %u, %u bytes of unknown data",
                 obj->size, dwg->header.section[SECTION_ENTITIES].max_size,
                 unknown_size);
      obj->unknown_rest = dwg_read_unknown_data (bit_chain, unknown_size);
      if (obj->unknown_rest)
        {
          obj->num_unknown_rest = unknown_size;
          LOG_TRACE ("unknown_rest: %.*s\n", obj->num_unknown_rest,
                     obj->unknown_rest);
        }
    }
  if (obj->size > dwg->header.section[SECTION_ENTITIES].num_sections
      * dwg->header.section[SECTION_ENTITIES].max_size)
    {
      LOG_ERROR ("Invalid object size %u > max decompressed size * num_sections %u",
                 obj->size,
                 dwg->header.section[SECTION_ENTITIES].max_size
                 * dwg->header.section[SECTION_ENTITIES].num_sections);
      obj->size = dwg->header.section[SECTION_ENTITIES].max_size
                  * dwg->header.section[SECTION_ENTITIES].num_sections;
    }
  if (obj->size < dwg->header.section[SECTION_ENTITIES].max_size
      * dwg->header.section[SECTION_ENTITIES].num_sections)
    {
      LOG_WARN ("Invalid object size %u < max decompressed size * num_sections %u",
                 obj->size,
                 dwg->header.section[SECTION_ENTITIES].max_size
                 * dwg->header.section[SECTION_ENTITIES].num_sections);
      obj->size = dwg->header.section[SECTION_ENTITIES].max_size
                  * dwg->header.section[SECTION_ENTITIES].num_sections;
    }
  if (obj->size != dwg->header.section[SECTION_ENTITIES].max_size
      * dwg->header.section[SECTION_ENTITIES].num_sections)
    {
      size_t unknown_size = dwg->header.section[SECTION_ENTITIES].max_size
                          * dwg->header.section[SECTION_ENTITIES].num_sections
                          - obj->size;
      LOG_WARN ("Invalid object size %u != max decompressed size * num_sections %u, %u bytes of unknown data",
                 obj->size,
                 dwg->header.section[SECTION_ENTITIES].max_size
                 * dwg->header.section[SECTION_ENTITIES].num_sections,
                 unknown_size);
      obj->unknown_rest = dwg_read_unknown_data (bit_chain, unknown_size);
      if (obj->unknown_rest)
        {
          obj->num_unknown_rest = unknown_size;
          LOG_TRACE ("unknown_rest: %.*s\n", obj->num_unknown_rest,
                     obj->unknown_rest);
        }
    }
}