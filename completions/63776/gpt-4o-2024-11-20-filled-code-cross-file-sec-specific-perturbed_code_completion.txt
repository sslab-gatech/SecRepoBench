{
  // Validate object size and ensure it does not exceed the remaining data size
  if (obj->size > (dat->size - obj->address)) {
    LOG_ERROR("Object size exceeds remaining data size: obj->size=%u, remaining=%zu",
              obj->size, dat->size - obj->address);
    return DWG_ERR_INVALIDDWG;
  }

  // Check for unknown trailing data after the object
  size_t current_position = dat->byte;
  size_t expected_end_position = obj->address + obj->size;

  if (current_position < expected_end_position) {
    size_t unknown_data_size = expected_end_position - current_position;

    // Allocate memory for unknown data
    obj->unknown_data = (unsigned char *)malloc(unknown_data_size);
    if (!obj->unknown_data) {
      LOG_ERROR("Failed to allocate memory for unknown data of size %zu", unknown_data_size);
      return DWG_ERR_OUTOFMEM;
    }

    // Copy unknown data
    memcpy(obj->unknown_data, &dat->chain[current_position], unknown_data_size);
    obj->unknown_data_size = unknown_data_size;

    LOG_WARN("Unknown trailing data of size %zu detected and stored", unknown_data_size);

    // Advance the data pointer to the expected end position
    dat->byte = expected_end_position;
  } else if (current_position > expected_end_position) {
    LOG_ERROR("Object size mismatch: current_position=%zu, expected_end_position=%zu",
              current_position, expected_end_position);
    return DWG_ERR_INVALIDDWG;
  }

  // Perform CRC check for data integrity if applicable
  if (dat->version >= R_13) {
    uint32_t calculated_crc = calculate_crc32(&dat->chain[obj->address], obj->size - 4);
    uint32_t stored_crc = bit_read_RL(dat);

    if (calculated_crc != stored_crc) {
      LOG_ERROR("CRC mismatch: calculated=0x%x, stored=0x%x", calculated_crc, stored_crc);
      return DWG_ERR_CRC;
    }
  }
}