if (obj->size > dat->size - dat->byte)
  {
    LOG_ERROR ("Invalid object size 0x%x at 0x%zx", obj->size, dat->byte);
    error |= DWG_ERR_INVALIDDWG;
  }
else if (dat->byte != previous_byte_position + obj->size)
  {
    BITCODE_RL offset = (BITCODE_RL)(dat->byte - (previous_byte_position + obj->size));
    if (offset > 0)
      {
        unsigned char *unknown = bit_read_bytes (dat, offset);
        if (!unknown)
          {
            LOG_ERROR ("Out of memory");
            return DWG_ERR_OUTOFMEM;
          }
        LOG_WARN ("Trailing unknown data at 0x%zx (size 0x%x):\n",
                  dat->byte - offset, offset);
        LOG_HEX (unknown, offset);
        free (unknown);
      }
    else
      {
        LOG_WARN ("Object size mismatch at 0x%zx (expected 0x%x, found 0x%x)\n",
                  previous_byte_position, obj->size,
                  (unsigned)(dat->byte - previous_byte_position));
      }
  }
else
  {
    LOG_TRACE ("Object size matches\n");
  }

SINCE (R_2_0b)
{
  if (obj->size != (dat->byte - previous_byte_position))
    {
      obj->size = dat->byte - previous_byte_position;
      LOG_WARN ("Adjusting object size to 0x%x\n", obj->size);
    }
  if (obj->address != previous_byte_position)
    {
      obj->address = previous_byte_position;
      LOG_WARN ("Adjusting object address to 0x%zx\n", obj->address);
    }
  if (dwg->header.version >= R_2_0b)
    {
      unsigned crc = bit_read_RC (dat);
      if (crc != dwg_crc32 (obj))
        {
          LOG_WARN ("CRC mismatch at 0x%zx (expected 0x%x, found 0x%x)\n",
                    dat->byte - 4, dwg_crc32 (obj), crc);
        }
    }
}