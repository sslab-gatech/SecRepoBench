// This code block handles the size validation and unknown data extraction for DWG objects in pre-R13 and later versions.
// For pre-R11 versions, the code checks if the object's size is valid and within the bounds of the data, adjusting it if necessary.
// It extracts any unknown remaining data if the object size doesn't match the current data position and logs errors if issues are found.
// For later versions, additional CRC checks are performed to ensure data integrity, and adjustments are made to account for any size discrepancies.
// If the object's address and size don't align with the data position, the code calculates the offset for any trailing unknown data and allocates memory to store it, logging appropriate messages.

if (obj->type!= DWG_TYPE_JUMP_r11)
{
    SINCE (R_2_0b) // Pre R_2_0 doesn't contain size of entity
    {
        // Check if the object's size is valid and within the bounds of the data
        if (obj->size > (dat->size - dat->byte) || obj->size < 0)
        {
            LOG_ERROR("Invalid object size: %zu", obj->size);
            obj->size = (dat->size - dat->byte) & 0xFFFFFFFF;
        }

        // Extract any unknown remaining data if the object size doesn't match the current data position
        if (obj->size!= (dat->byte - previous_byte_position))
        {
            size_t unknown_size = obj->size - (dat->byte - previous_byte_position);
            if (unknown_size > 0)
            {
                obj->unknown_data = (unsigned char*)calloc(unknown_size, sizeof(unsigned char));
                if (!obj->unknown_data)
                {
                    LOG_ERROR("Out of memory");
                    return DWG_ERR_OUTOFMEM;
                }
                bit_read_bytes(dat, obj->unknown_data, unknown_size);
                LOG_TRACE("unknown_data [%zu]: ", unknown_size);
                LOG_TRACE_BYTES(obj->unknown_data, unknown_size);
                LOG_TRACE("\n");
            }
        }

        // Perform CRC checks for later versions to ensure data integrity
        SINCE (R_13)
        {
            BITCODE_CRC crc;
            crc = bit_read_CRC(dat);
            if (crc!= obj->crc)
            {
                LOG_ERROR("CRC mismatch: expected %zu, got %zu", obj->crc, crc);
                return DWG_ERR_VALUEOUTOFBOUNDS;
            }
        }

        // Adjust the object's size to account for any size discrepancies
        obj->size = (dat->byte - previous_byte_position) & 0xFFFFFFFF;
    }
    else
    {
        // For pre-R11 versions, the object's size is not stored in the data
        obj->size = (dat->byte - previous_byte_position) & 0xFFFFFFFF;
    }

    // Calculate the offset for any trailing unknown data and allocate memory to store it
    size_t offset = (dat->byte - previous_byte_position) - obj->size;
    if (offset > 0)
    {
        obj->trailing_unknown_data = (unsigned char*)calloc(offset, sizeof(unsigned char));
        if (!obj->trailing_unknown_data)
        {
            LOG_ERROR("Out of memory");
            return DWG_ERR_OUTOFMEM;
        }
        bit_read_bytes(dat, obj->trailing_unknown_data, offset);
        LOG_TRACE("trailing_unknown_data [%zu]: ", offset);
        LOG_TRACE_BYTES(obj->trailing_unknown_data, offset);
        LOG_TRACE("\n");
    }
}