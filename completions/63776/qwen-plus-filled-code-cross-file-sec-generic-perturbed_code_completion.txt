SINCE (R_11)
{
  BITCODE_RL expected_size = dat->byte - previous_byte_position;
  if (obj->size != expected_size)
    {
      LOG_WARN ("Object size mismatch: expected %" FORMAT_RL ", got %" FORMAT_RL "\n",
                expected_size, obj->size);
      if (expected_size > obj->size)
        {
          obj->size = expected_size;
          LOG_TRACE ("Adjusted object size to %" FORMAT_RL "\n", obj->size);
        }
      else
        {
          LOG_ERROR ("Object size is larger than expected\n");
          return DWG_ERR_INVALIDDWG;
        }
    }

  if (dat->byte + obj->size > dat->size)
    {
      LOG_ERROR ("Object extends beyond data buffer\n");
      return DWG_ERR_INVALIDDWG;
    }

  if (dat->byte < previous_byte_position + size)
    {
      size_t unknown_data_size = previous_byte_position + size - dat->byte;
      obj->unknown_data = malloc (unknown_data_size);
      if (!obj->unknown_data)
        {
          LOG_ERROR ("Failed to allocate memory for unknown data\n");
          return DWG_ERR_OUTOFMEM;
        }
      memcpy (obj->unknown_data, &dat->chain[dat->byte], unknown_data_size);
      LOG_TRACE ("Extracted %" PRIuSIZE " bytes of unknown data\n", unknown_data_size);
      dat->byte += unknown_data_size;
    }

  if (dat->byte != previous_byte_position + size)
    {
      LOG_ERROR ("Data position does not align with expected object size\n");
      return DWG_ERR_INVALIDDWG;
    }
}
else
{
  if (obj->size > (BITCODE_RL)(dat->size - dat->byte))
    {
      LOG_ERROR ("Object size exceeds remaining data buffer\n");
      return DWG_ERR_INVALIDDWG;
    }

  if (dat->byte + obj->size != previous_byte_position + size)
    {
      LOG_ERROR ("Data position and object size do not align\n");
      return DWG_ERR_INVALIDDWG;
    }
}