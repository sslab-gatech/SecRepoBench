{
  BITCODE_RL end_pos = obj->address + obj->size;
  if (end_pos < dat->byte)
    {
      LOG_ERROR ("Object size mismatch (end_pos < current position) for object type %d\n",
                 obj->type);
      error |= DWG_ERR_INVALIDDWG;
      break;
    }
  if (end_pos > dat->size)
    {
      LOG_WARN ("Object extends beyond data boundary for object type %d, adjusting size\n",
                obj->type);
      end_pos = dat->size;
      obj->size = end_pos - obj->address;
    }

  /* If there's leftover data within the object's declared size, decode it */
  if (dat->byte < end_pos)
    {
      size_t leftover = end_pos - dat->byte;
      LOG_TRACE ("Decoding %zu leftover bytes of unknown data for object type %d\n",
                 leftover, obj->type);

      error |= dwg_decode_unknown_bits (dat, obj);
      if (error)
        {
          LOG_ERROR ("Failed to decode unknown bits for object type %d\n", obj->type);
          error |= DWG_ERR_INVALIDDWG;
          break;
        }
      bit_set_position (dat, (bit_off_t)end_pos * 8);
    }
}