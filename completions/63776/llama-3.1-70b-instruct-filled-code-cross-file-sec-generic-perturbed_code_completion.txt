// This code block handles the size validation and unknown data extraction for DWG objects in pre-R13 and later versions.
// For pre-R11 versions, the code checks if the object's size is valid and within the bounds of the data, adjusting it if necessary.
// It extracts any unknown remaining data if the object size doesn't match the current data position and logs errors if issues are found.
// For later versions, additional CRC checks are performed to ensure data integrity, and adjustments are made to account for any size discrepancies.
// If the object's address and size don't align with the data position, the code calculates the offset for any trailing unknown data and allocates memory to store it, logging appropriate messages.

if (obj->size > (dat->size - dat->byte))
  {
    obj->size = (dat->size - dat->byte) & 0xFFFFFFFF;
    LOG_WARN ("Object size too large, adjusted to %d\n", obj->size);
  }
if (obj->size < 0)
  {
    LOG_ERROR ("Object size is negative: %d\n", obj->size);
    return DWG_ERR_VALUEOUTOFBOUNDS;
  }
if (obj->size == 0)
  {
    LOG_TRACE ("Object size is zero\n");
  }
if (obj->size > 0)
  {
    size_t offset = (dat->byte - obj->address) & 0xFFFFFFFF;
    if (offset > obj->size)
      {
        LOG_ERROR ("Object address and size do not match data position\n");
        return DWG_ERR_VALUEOUTOFBOUNDS;
      }
    if (offset < obj->size)
      {
        size_t unknown_size = obj->size - offset;
        unsigned char *unknown_data = bit_read_B (dat, unknown_size);
        if (!unknown_data)
          {
            LOG_ERROR ("Failed to allocate memory for unknown data\n");
            return DWG_ERR_OUTOFMEM;
          }
        obj->unknown_data = unknown_data;
        obj->unknown_size = unknown_size;
        LOG_TRACE ("Unknown data of size %zu found\n", unknown_size);
      }
  }
SINCE (R_11)
  {
    if (obj->size < 4)
      {
        LOG_ERROR ("Object size is too small for CRC check\n");
        return DWG_ERR_VALUEOUTOFBOUNDS;
      }
    BITCODE_RC crc = bit_read_RC (dat);
    if (crc!= obj->crc)
      {
        LOG_ERROR ("CRC check failed\n");
        return DWG_ERR_VALUEOUTOFBOUNDS;
      }
  }