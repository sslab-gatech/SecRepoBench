if (obj->type != DWG_TYPE_JUMP_r11)
  {
    SINCE (R_2_0b) // Pre R_2_0 doesn't contain size of entity
    {
      // Validate object size and adjust if necessary
      if (obj->size < 0 || obj->size > dat->size - dat->byte)
      {
        LOG_WARN ("Invalid object size %" PRIuSIZE ", adjusting\n", obj->size);
        obj->size = dat->size - dat->byte;
      }

      // Extract unknown remaining data if object size doesn't match current data position
      if (dat->byte + obj->size > dat->size)
      {
        size_t unknown_data_size = dat->size - dat->byte;
        LOG_WARN ("Extracting unknown data (%" PRIuSIZE " bytes)\n", unknown_data_size);
        obj->unknown_data = malloc(unknown_data_size);
        if (!obj->unknown_data)
        {
          LOG_ERROR ("Out of memory\n");
          return DWG_ERR_OUTOFMEM;
        }
        memcpy(obj->unknown_data, dat->chain + dat->byte, unknown_data_size);
        dat->byte += unknown_data_size;
      }
      else
      {
        dat->byte += obj->size;
      }

      // Perform additional CRC checks for later versions
      #ifdef HAVE_CRC32
      if (dat->version >= R_2000)
      {
        uint32_t crc = crc32(0L, Z_NULL, 0);
        crc = crc32(crc, dat->chain + dat->byte - obj->size, obj->size);
        if (crc != obj->crc32)
        {
          LOG_WARN ("CRC32 mismatch, expected 0x%08x, got 0x%08x\n",
                    obj->crc32, crc);
        }
      }
      #endif
    }
  }