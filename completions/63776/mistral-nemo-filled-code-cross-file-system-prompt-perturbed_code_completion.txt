if (obj->type != DWG_TYPE_JUMP_r11)
  {
    SINCE (R_2_0b) // Pre R_2_0 doesn't contain size of entity
    {
      // Validate object size and adjust if necessary
      if (obj->size < obj->bitsize)
      {
        obj->size = obj->bitsize;
        LOG_WARN ("Object size adjusted to %" PRIuSIZE "\n", obj->size);
      }

      // Extract unknown remaining data if object size doesn't match current data position
      if ((BITCODE_RL)bit_chain->byte != real_start + obj->size)
      {
        size_t unknown_data_size = (BITCODE_RL)bit_chain->byte - (real_start + obj->size);
        LOG_WARN ("Extracting %" PRIuSIZE " bytes of unknown data\n", unknown_data_size);
        obj->unknown_data = (unsigned char*)malloc(unknown_data_size);
        if (!obj->unknown_data)
        {
          LOG_ERROR ("Out of memory\n");
          return DWG_ERR_OUTOFMEM;
        }
        memcpy(obj->unknown_data, bit_chain->chain + real_start + obj->size, unknown_data_size);
        obj->unknown_data_size = unknown_data_size;
      }
      else
      {
        LOG_TRACE ("No unknown data found\n");
      }
    }
    else
    {
      // Perform additional CRC checks for later versions
      // ...

      // Adjust object size to account for any size discrepancies
      // ...

      // Extract unknown remaining data if object address and size don't align with data position
      // ...

      // Allocate memory to store unknown data and log appropriate messages
      // ...
    }
  }