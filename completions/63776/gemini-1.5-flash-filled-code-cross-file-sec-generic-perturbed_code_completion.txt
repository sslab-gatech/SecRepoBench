size_t curpos = bit_chain->byte;
                size_t obj_size = obj->size;
                if (obj_size > bit_chain->size - curpos)
                  {
                    LOG_ERROR ("Object size too big %" PRIuSIZE
                               " > %" PRIuSIZE,
                               obj_size, bit_chain->size - curpos);
                    return DWG_ERR_INVALIDDWG;
                  }
                if (obj_size < bit_chain->byte - oldpos)
                  {
                    LOG_WARN ("Object size too small %" PRIuSIZE
                              " < %" PRIuSIZE,
                              obj_size, bit_chain->byte - oldpos);
                    obj->size = bit_chain->byte - oldpos;
                  }
                if (obj_size != bit_chain->byte - oldpos)
                  {
                    size_t unknown_size = oldpos + obj_size - bit_chain->byte;
                    obj->unknown_data = (unsigned char *)malloc (unknown_size);
                    if (!obj->unknown_data)
                      {
                        LOG_ERROR ("Out of memory");
                        return DWG_ERR_OUTOFMEM;
                      }
                    memcpy (obj->unknown_data, &bit_chain->chain[bit_chain->byte],
                            unknown_size);
                    bit_chain->byte += unknown_size;
                    obj->unknown_data_size = unknown_size;
                    LOG_WARN ("Unknown data after object %" PRIuSIZE " bytes\n",
                              unknown_size);
                  }
                if (bit_chain->version >= R_2_0b)
                  {
                    BITCODE_RC crc;
                    crc = bit_read_RC (bit_chain);
                    if (crc != obj->crc)
                      {
                        LOG_ERROR ("CRC mismatch: %x != %x", crc, obj->crc);
                        return DWG_ERR_INVALIDDWG;
                      }
                  }