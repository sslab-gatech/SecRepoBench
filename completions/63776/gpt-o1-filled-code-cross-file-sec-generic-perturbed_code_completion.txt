{
  BITCODE_RL actual_size = (BITCODE_RL)((dat->byte - previous_byte_position) & 0xFFFFFFFF);

  /* Check for size mismatch. If the actual data read is less than the declared
     size, adjust obj->size to avoid overruns. If there's extra data (leftover),
     read it as unknown bits. */
  if (obj->size != actual_size)
    {
      if (actual_size < obj->size)
        {
          LOG_WARN ("Object size mismatch at index %u: declared %u, actual %u. Adjusting.\n",
                    obj->index, obj->size, actual_size);
          obj->size = actual_size;
        }
      else
        {
          BITCODE_RL leftover = actual_size - obj->size;
          LOG_TRACE ("Object index %u has leftover data: %u bytes\n",
                     obj->index, leftover);
          /* Ensure obj->size reflects the total consumed size */
          obj->size = actual_size;
          /* Decode the leftover portion as unknown bits for this object */
          if (dwg_decode_unknown_bits (dat, obj))
            {
              LOG_WARN ("Failed to decode leftover bits for object index %u\n",
                        obj->index);
            }
        }
    }

  /* Optional: For later versions, insert CRC or integrity checks here if needed */
}