{
  BITCODE_RL obj_size;
  obj_size = bit_read_RL(dat);
  LOG_TRACE("size: " FORMAT_RL "\n", obj_size);

  if (obj_size > 0 && obj_size <= (dat->size - obj->address)) {
    obj->size = obj_size;
    if (obj->address + obj_size > dat->size) {
      LOG_ERROR("Object size exceeds data size at address 0x%zx\n", obj->address);
      return DWG_ERR_INVALIDDWG;
    }
  } else {
    LOG_ERROR("Invalid object size %u at address 0x%zx\n", obj_size, obj->address);
    return DWG_ERR_INVALIDDWG;
  }

  if (obj->address + obj->size != dat->byte) {
    size_t unknown_size = (obj->address + obj->size) - dat->byte;
    if (unknown_size > 0) {
      obj->unknown_bits = (unsigned char *)malloc(unknown_size);
      if (!obj->unknown_bits) {
        LOG_ERROR("Out of memory for unknown bits\n");
        return DWG_ERR_OUTOFMEM;
      }
      memcpy(obj->unknown_bits, dat->chain + dat->byte, unknown_size);
      dat->byte += unknown_size;
      LOG_TRACE("Unknown data of size %zu extracted\n", unknown_size);
    }
  }
}