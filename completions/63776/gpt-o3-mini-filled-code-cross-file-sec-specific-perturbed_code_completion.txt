{
  /* Calculate the expected end position for this object */
  size_t expected_end = previous_byte_position + obj->size;
  if (expected_end > dat->size) {
    LOG_ERROR ("Object at index %u extends beyond the data buffer (expected end: 0x%zx, buffer size: 0x%zx)",
               obj->index, expected_end, dat->size);
    return DWG_ERR_INVALIDDWG;
  }
  /* If the current position is behind the expected end, extract the extra unknown data */
  if (dat->byte < expected_end) {
    size_t extra_bytes = expected_end - dat->byte;
    LOG_WARN ("Entity at index %u: decoded size is smaller than declared size: extracting %zu extra byte(s)",
              obj->index, extra_bytes);
    obj->unknown_bits = calloc (extra_bytes, 1);
    if (!obj->unknown_bits) {
      LOG_ERROR ("Out of memory while allocating %zu bytes for unknown entity data (object index %u)", extra_bytes, obj->index);
      return DWG_ERR_OUTOFMEM;
    }
    memcpy (obj->unknown_bits, dat->chain + dat->byte, extra_bytes);
    obj->num_unknown_bits = extra_bytes * 8;
    dat->byte += extra_bytes;
  }
  /* If we've advanced past the expected end, adjust the data pointer to maintain consistency */
  else if (dat->byte > expected_end) {
    LOG_WARN ("Entity at index %u: decoded data overruns declared size, adjusting position from 0x%zx to 0x%zx",
              obj->index, dat->byte, expected_end);
    dat->byte = expected_end;
  }
}