SINCE (R_11)
{
  BITCODE_RL expected_end = previous_byte_position + size;
  BITCODE_RL current_pos = dat->byte;

  if (current_pos > expected_end)
    {
      LOG_ERROR ("Object size exceeds expected bounds: %" PRIuSIZE " > %" PRIuSIZE "\n",
                 current_pos, expected_end);
      return DWG_ERR_INVALIDDWG;
    }
  else if (current_pos < expected_end)
    {
      size_t remaining_size = expected_end - current_pos;
      char *remaining_data = malloc(remaining_size);
      if (!remaining_data)
        {
          LOG_ERROR ("Memory allocation failed for remaining data.\n");
          return DWG_ERR_OUTOFMEM;
        }

      memcpy(remaining_data, &dat->chain[current_pos], remaining_size);
      LOG_TRACE ("Extracted unknown remaining data (%zu bytes): ", remaining_data);
      LOG_TRACE_TF (remaining_data, remaining_size);
      LOG_TRACE ("\n");

      free(remaining_data); // Free the allocated memory after processing
    }

  // Perform CRC checks for data integrity in later versions
  SINCE (R_2_0b)
    {
      uint32_t calculated_crc = calculate_CRC(&dat->chain[previous_byte_position], size);
      uint32_t stored_crc = bit_read_BL(dat); // Assuming CRC is stored as a BL type

      if (calculated_crc != stored_crc)
        {
          LOG_ERROR ("CRC check failed: calculated 0x%x, stored 0x%x\n",
                     calculated_crc, stored_crc);
          return DWG_ERR_DATACORRUPTED;
        }
    }
}