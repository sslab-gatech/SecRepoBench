SINCE (R_2_0b)
{
  // This code block handles the size validation and unknown data extraction for DWG objects in pre-R11 and later versions.
  // For pre-R11 versions, the code checks if the object's size is valid and within the bounds of the data, adjusting it if necessary.
  // It extracts any unknown remaining data if the object size doesn't match the current data position and logs errors if issues are found.
  // For later versions, additional CRC checks are performed to ensure data integrity, and adjustments are made to account for any size discrepancies.
  // If the object's address and size don't align with the data position, the code calculates the offset for any trailing unknown data and allocates memory to store it, logging appropriate messages.
  if (obj->type!= DWG_TYPE_JUMP_r11)
    {
      // Check if the object's size is valid and within the bounds of the data
      if (obj->size > (dat->byte - previous_byte_position) & 0xFFFFFFFF)
        {
          // If the object's size exceeds the available data, adjust it to the available data size
          obj->size = (dat->byte - previous_byte_position) & 0xFFFFFFFF;
          LOG_WARN ("Object size exceeds available data, adjusted to %d\n", obj->size);
        }
      // Check if the object's address and size align with the data position
      if (obj->address + obj->size!= dat->byte)
        {
          // Calculate the offset for any trailing unknown data
          size_t offset = obj->address + obj->size - dat->byte;
          // Allocate memory to store the unknown data
          Dwg_Object *unknown_obj = (Dwg_Object *)calloc (1, offset);
          if (!unknown_obj)
            {
              LOG_ERROR ("Out of memory\n");
              return DWG_ERR_OUTOFMEM;
            }
          unknown_obj->index = num;
          unknown_obj->parent = dwg;
          unknown_obj->address = dat->byte;
          unknown_obj->supertype = DWG_SUPERTYPE_ENTITY;
          unknown_obj->size = offset;
          unknown_obj->type = DWG_TYPE_UNUSED;
          // Add the unknown object to the data
          dwg->num_objects++;
          dwg->object[num] = *unknown_obj;
          num++;
          LOG_TRACE ("Unknown data extracted and stored in object %d\n", num);
        }
      // Extract any unknown remaining data if the object size doesn't match the current data position
      if (dat->byte < previous_byte_position + size)
        {
          // Calculate the remaining data size
          size_t remaining_size = previous_byte_position + size - dat->byte;
          // Allocate memory to store the remaining data
          Dwg_Object *remaining_obj = (Dwg_Object *)calloc (1, remaining_size);
          if (!remaining_obj)
            {
              LOG_ERROR ("Out of memory\n");
              return DWG_ERR_OUTOFMEM;
            }
          remaining_obj->index = num;
          remaining_obj->parent = dwg;
          remaining_obj->address = dat->byte;
          remaining_obj->supertype = DWG_SUPERTYPE_ENTITY;
          remaining_obj->size = remaining_size;
          remaining_obj->type = DWG_TYPE_UNUSED;
          // Add the remaining object to the data
          dwg->num_objects++;
          dwg->object[num] = *remaining_obj;
          num++;
          LOG_TRACE ("Unknown remaining data extracted and stored in object %d\n", num);
        }
    }
}