: %d", dwg->header.section_infohdr.num_desc);
      free (decomp);
      return DWG_ERR_VALUEOUTOFBOUNDS;
    }
  if (dwg->header.section_infohdr.num_desc2
      > 0xc0000000 / sizeof (Dwg_Section_Info))
    {
      LOG_ERROR ("Illegal num_desc2: %d", dwg->header.section_infohdr.num_desc2);
      free (decomp);
      return DWG_ERR_VALUEOUTOFBOUNDS;
    }
  if (dwg->header.section_infohdr.num_desc2 > dwg->header.section_infohdr.num_desc)
    {
      LOG_ERROR ("Illegal num_desc2: %d > num_desc: %d",
                 dwg->header.section_infohdr.num_desc2,
                 dwg->header.section_infohdr.num_desc);
      free (decomp);
      return DWG_ERR_VALUEOUTOFBOUNDS;
    }
  if (dwg->header.section_infohdr.num_desc > 0)
    {
      dwg->header.section_info = (Dwg_Section_Info *)calloc (
          dwg->header.section_infohdr.num_desc, sizeof (Dwg_Section_Info));
      if (!dwg->header.section_info)
        {
          LOG_ERROR ("Out of memory");
          free (decomp);
          return DWG_ERR_OUTOFMEM;
        }
      decomp_end = decomp + decomp_data_size;
      for (i = 0; i < dwg->header.section_infohdr.num_desc; i++)
        {
          if (ptr + 16 > decomp_end)
            {
              LOG_ERROR ("Invalid section_infohdr.num_desc: %d", i);
              free (decomp);
              return DWG_ERR_VALUEOUTOFBOUNDS;
            }
          bfr_read_32 (&dwg->header.section_info[i], &ptr, 16);
          LOG_TRACE ("Section[%2d]=%2d,", i, (int)dwg->header.section_info[i].id)
          LOG_TRACE (" size: %5u,", (unsigned)dwg->header.section_info[i].size)
          LOG_TRACE (" address: 0x%04lx\n",
                     (unsigned long)dwg->header.section_info[i].address)
          if (dwg->header.section_info[i].id > 0x7f)
            {
              LOG_ERROR ("Invalid section_infohdr.id: %d", i);
              free (decomp);
              return DWG_ERR_VALUEOUTOFBOUNDS;
            }
          if (dwg->header.section_info[i].size > 0x7c0000)
            {
              LOG_ERROR ("Invalid section_infohdr.size: %d", i);
              free (decomp);
              return DWG_ERR_VALUEOUTOFBOUNDS;
            }
          if (dwg->header.section_info[i].address > 0x7c0000)
            {
              LOG_ERROR ("Invalid section_infohdr.address: %d", i);
              free (decomp);
              return DWG_ERR_VALUEOUTOFBOUNDS;
            }
          if (dwg->header.section_info[i].size > 0)
            {
              section_number = dwg->header.section_info[i].id;
              data_size = dwg->header.section_info[i].size;
              offset = dwg->header.section_info[i].address;
              maxsize = section_max_decomp_size (dwg, section_number);
              if (data_size > maxsize)
                {
                  LOG_ERROR ("Invalid section_infohdr.size: %d", i);
                  free (decomp);
                  return DWG_ERR_VALUEOUTOFBOUNDS;
                }
              if (offset + data_size > dat->size)
                {
                  LOG_ERROR ("Invalid section_infohdr.address: %d", i);
                  free (decomp);
                  return DWG_ERR_VALUEOUTOFBOUNDS;
                }
              if (section_number == SECTION_APPINFOHISTORY)
                {
                  // TODO: read appinfohistory
                  LOG_WARN ("TODO: read appinfohistory");
                }
              else if (section_number == SECTION_APPINFO)
                {
                  // TODO: read appinfo
                  LOG_WARN ("TODO: read appinfo");
                }
              else if (section_number == SECTION_PREVIEW)
                {
                  // TODO: read preview
                  LOG_WARN ("TODO: read preview");
                }
              else if (section_number == SECTION_SUMMARYINFO)
                {
                  // TODO: read summaryinfo
                  LOG_WARN ("TODO: read summaryinfo");
                }
              else
                {
                  LOG_WARN ("TODO: read section_infohdr.id: %d", i);
                }
            }
        }
    }
  if (dwg->header.section_infohdr.num_desc2 > 0)
    {
      dwg->header.section_info2 = (Dwg_Section_Info *)calloc (
          dwg->header.section_infohdr.num_desc2, sizeof (Dwg_Section_Info));
      if (!dwg->header.section_info2)
        {
          LOG_ERROR ("Out of memory");
          free (decomp);
          return DWG_ERR_OUTOFMEM;
        }
      for (j = 0; j < dwg->header.section_infohdr.num_desc2; j++)
        {
          if (ptr + 16 > decomp_end)
            {
              LOG_ERROR ("Invalid section_infohdr.num_desc2: %d", j);
              free (decomp);
              return DWG_ERR_VALUEOUTOFBOUNDS;
            }
          bfr_read_32 (&dwg->header.section_info2[j], &ptr, 16);
          LOG_TRACE ("Section[%2d]=%2d,", j, (int)dwg->header.section_info2[j].id)
          LOG_TRACE (" size: %5u,", (unsigned)dwg->header.section_info2[j].size)
          LOG_TRACE (" address: 0x%04lx\n",
                     (unsigned long)dwg->header.section_info2[j].address)
        }
    }
  free (decomp);
  return 0;
}

static int
read_R2004_section (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,
                    BITCODE_RLd section_number)
{
  BITCODE_RC *decomp, *ptr, *decomp_end;
  BITCODE_BL i;
  int32_t data_size, maxsize;
  uint64_t offset;
  int error;

  if (section_number > 0x7f)
    {
      LOG_ERROR ("Invalid section_number: %d", section_number);
      return DWG_ERR_VALUEOUTOFBOUNDS;
    }
  if (section_number == SECTION_APPINFOHISTORY)
    {
      // TODO: read appinfohistory
      LOG_WARN ("TODO: read appinfohistory");
    }
  else if (section_number == SECTION_APPINFO)
    {
      // TODO: read appinfo
      LOG_WARN ("TODO: read appinfo");
    }
  else if (section_number == SECTION_PREVIEW)
    {
      // TODO: read preview
      LOG_WARN ("TODO: read preview");
    }
  else if (section_number == SECTION_SUMMARYINFO)
    {
      // TODO: read summaryinfo
      LOG_WARN ("TODO: read summaryinfo");
    }
  else
    {
      LOG_WARN ("TODO: read section_number: %d", section_number);
    }

  if (section_number == SECTION_APPINFOHISTORY)
    {
      data_size = dwg->r2004_header.appinfohistory_size;
      offset = dwg->r2004_header.appinfohistory_address;
    }
  else if (section_number == SECTION_APPINFO)
    {
      data_size = dwg->r2004_header.appinfo_size;
      offset = dwg->r2004_header.appinfo_address;
    }
  else if (section_number == SECTION_PREVIEW)
    {
      data_size = dwg->r2004_header.preview_size;
      offset = dwg->r2004_header.preview_address;
    }
  else if (section_number == SECTION_SUMMARYINFO)
    {
      data_size = dwg->r2004_header.summaryinfo_size;
      offset = dwg->r2004_header.summaryinfo_address;
    }
  else
    {
      LOG_ERROR ("Invalid section_number: %d", section_number);
      return DWG_ERR_VALUEOUTOFBOUNDS;
    }
  maxsize = section_max_decomp_size (dwg, section_number);
  if (data_size > maxsize)
    {
      LOG_ERROR ("Invalid data_size: %d", data_size);
      return DWG_ERR_VALUEOUTOFBOUNDS;
    }
  if (offset + data_size > dat->size)
    {
      LOG_ERROR ("Invalid offset: %d", offset);
      return DWG_ERR_VALUEOUTOFBOUNDS;
    }
  if (data_size > 0)
    {
      decomp = (BITCODE_RC *)calloc (data_size + 1024, sizeof (BITCODE_RC));
      if (!decomp)
        {
          LOG_ERROR ("Out of memory");
          return DWG_ERR_OUTOFMEM;
        }
      error = decompress_R2004_section (dat, decomp, data_size + 1024,
                                        data_size);
      if (error > DWG_ERR_CRITICAL || error == DWG_ERR_VALUEOUTOFBOUNDS)
        {
          free (decomp);
          return error;
        }
      ptr = decomp;
      decomp_end = decomp + data_size;
      for (i = 0; i < data_size; i++)
        {
          if (ptr + 1 > decomp_end)
            {
              LOG_ERROR ("Invalid data_size: %d", data_size);
              free (decomp);
              return DWG_ERR_VALUEOUTOFBOUNDS;
            }
          bit_write_RC (dat, *ptr);
          ptr++;
        }
      free (decomp);
    }
  return 0;
}

static int
read_R2004_section_map_checksum (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)
{
  BITCODE_RL checksum;
  BITCODE_RL checksum2;
  BITCODE_RL checksum3;
  BITCODE_RL checksum4;
  BITCODE_RL checksum5;
  BITCODE_RL checksum6;
  BITCODE_RL checksum7;
  BITCODE_RL checksum8;
  BITCODE_RL checksum9;
  BITCODE_RL checksum10;
  BITCODE_RL checksum11;
  BITCODE_RL checksum12;
  BITCODE_RL checksum13;
  BITCODE_RL checksum14;
  BITCODE_RL checksum15;
  BITCODE_RL checksum16;
  BITCODE_RL checksum17;
  BITCODE_RL checksum18;
  BITCODE_RL checksum19;
  BITCODE_RL checksum20;
  BITCODE_RL checksum21;
  BITCODE_RL checksum22;
  BITCODE_RL checksum23;
  BITCODE_RL checksum24;
  BITCODE_RL checksum25;
  BITCODE_RL checksum26;
  BITCODE_RL checksum27;
  BITCODE_RL checksum28;
  BITCODE_RL checksum29;
  BITCODE_RL checksum30;
  BITCODE_RL checksum31;
  BITCODE_RL checksum32;
  BITCODE_RL checksum33;
  BITCODE_RL checksum34;
  BITCODE_RL checksum35;
  BITCODE_RL checksum36;
  BITCODE_RL checksum37;
  BITCODE_RL checksum38;
  BITCODE_RL checksum39;
  BITCODE_RL checksum40;
  BITCODE_RL checksum41;
  BITCODE_RL checksum42;
  BITCODE_RL checksum43;
  BITCODE_RL checksum44;
  BITCODE_RL checksum45;
  BITCODE_RL checksum46;
  BITCODE_RL checksum47;
  BITCODE_RL checksum48;
  BITCODE_RL checksum49;
  BITCODE_RL checksum50;
  BITCODE_RL checksum51;
  BITCODE_RL checksum52;
  BITCODE_RL checksum53;
  BITCODE_RL checksum54;
  BITCODE_RL checksum55;
  BITCODE_RL checksum56;
  BITCODE_RL checksum57;
  BITCODE_RL checksum58;
  BITCODE_RL checksum59;
  BITCODE_RL checksum60;
  BITCODE_RL checksum61;
  BITCODE_RL checksum62;
  BITCODE_RL checksum63;
  BITCODE_RL checksum64;
  BITCODE_RL checksum65;
  BITCODE_RL checksum66;
  BITCODE_RL checksum67;
  BITCODE_RL checksum68;
  BITCODE_RL checksum69;
  BITCODE_RL checksum70;
  BITCODE_RL checksum71;
  BITCODE_RL checksum72;
  BITCODE_RL checksum73;
  BITCODE_RL checksum74;
  BITCODE_RL checksum75;
  BITCODE_RL checksum76;
  BITCODE_RL checksum77;
  BITCODE_RL checksum78;
  BITCODE_RL checksum79;
  BITCODE_RL checksum80;
  BITCODE_RL checksum81;
  BITCODE_RL checksum82;
  BITCODE_RL checksum83;
  BITCODE_RL checksum84;
  BITCODE_RL checksum85;
  BITCODE_RL checksum86;
  BITCODE_RL checksum87;
  BITCODE_RL checksum88;
  BITCODE_RL checksum89;
  BITCODE_RL checksum90;
  BITCODE_RL checksum91;
  BITCODE_RL checksum92;
  BITCODE_RL checksum93;
  BITCODE_RL checksum94;
  BITCODE_RL checksum95;
  BITCODE_RL checksum96;
  BITCODE_RL checksum97;
  BITCODE_RL checksum98;
  BITCODE_RL checksum99;
  BITCODE_RL checksum100;
  BITCODE_RL checksum101;
  BITCODE_RL checksum102;
  BITCODE_RL checksum103;
  BITCODE_RL checksum104;
  BITCODE_RL checksum105;
  BITCODE_RL checksum106;
  BITCODE_RL checksum107;
  BITCODE_RL checksum108;
  BITCODE_RL checksum109;
  BITCODE_RL checksum110;
  BITCODE_RL checksum111;
  BITCODE_RL checksum112;
  BITCODE_RL checksum113;
  BITCODE_RL checksum114;
  BITCODE_RL checksum115;
  BITCODE_RL checksum116;
  BITCODE_RL checksum117;
  BITCODE_RL checksum118;
  BITCODE_RL checksum119;
  BITCODE_RL checksum120