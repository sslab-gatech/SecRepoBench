size_t oldpos = dat->byte;
                if (obj->size > (dat->size - oldpos)) {
                    LOG_ERROR("Invalid object size: %u, exceeds buffer bounds.", obj->size);
                    return DWG_ERR_INVALIDDWG;
                }

                dat->byte += obj->size;

                if (dat->version < R_11)
                  {
                    if (obj->size != (dat->byte - previous_byte_position))
                      {
                        if (obj->size > (dat->byte - previous_byte_position))
                          {
                            long offset = obj->size - (dat->byte - previous_byte_position);
                            if (offset > 0 && (size_t)offset <= (dat->size - dat->byte))
                              {
                                obj->unknown = (char *)malloc (offset + 1);
                                if (obj->unknown)
                                  {
                                    memcpy (obj->unknown, dat->chain + dat->byte, offset);
                                    obj->unknown[offset] = 0;
                                    dat->byte += offset;
                                    LOG_TRACE ("unknown [%ld]: %s\n", offset, obj->unknown);
                                  }
                                else
                                  {
                                    LOG_ERROR ("Out of memory");
                                    return DWG_ERR_OUTOFMEM;
                                  }
                              }
                            else
                              {
                                LOG_ERROR ("Invalid object size");
                                return DWG_ERR_INVALIDDWG;
                              }
                          }
                        else
                          {
                            LOG_ERROR ("Invalid object size");
                            return DWG_ERR_INVALIDDWG;
                          }
                      }
                  }
                else
                  {
                    unsigned crc;
                    size_t current_byte_position = dat->byte;
                    dat->byte = previous_byte_position;
                    crc = dwg_crc32 (dat->chain + dat->byte, obj->size);
                    LOG_TRACE ("CRC32: %x\n", crc);
                    dat->byte = current_byte_position;
                    if (obj->crc != crc)
                      {
                        LOG_ERROR ("CRC mismatch: %x != %x\n", obj->crc, crc);
                        return DWG_ERR_INVALIDDWG;
                      }
                    if (obj->address + obj->size != dat->byte)
                      {
                        long offset
                            = (long)(obj->address + obj->size - dat->byte);
                        if (offset > 0 && (size_t)offset <= (dat->size - dat->byte))
                          {
                            obj->trail = (char *)malloc (offset + 1);
                            if (obj->trail)
                              {
                                memcpy (obj->trail, dat->chain + dat->byte, offset);
                                obj->trail[offset] = 0;
                                dat->byte += offset;
                                LOG_TRACE ("trailing [%ld]: %s\n", offset, obj->trail);
                              }
                            else
                              {
                                LOG_ERROR ("Out of memory");
                                return DWG_ERR_OUTOFMEM;
                              }
                          }
                        else if (offset < 0)
                          {
                            LOG_ERROR ("Invalid object size");
                            return DWG_ERR_INVALIDDWG;
                          }
                      }
                  }
                previous_byte_position = dat->byte;