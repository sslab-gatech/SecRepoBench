if (obj->type != DWG_TYPE_JUMP_r11)
{
  SINCE (R_2_0b) // Pre R_2_0 doesn't contain size of entity
  {
    // This code block handles the size validation and unknown data extraction for DWG objects in pre-R13 and later versions.
    // For pre-R11 versions, the code checks if the object's size is valid and within the bounds of the data, adjusting it if necessary.
    // It extracts any unknown remaining data if the object size doesn't match the current data position and logs errors if issues are found.
    // For later versions, additional CRC checks are performed to ensure data integrity, and adjustments are made to account for any size discrepancies.
    // If the object's address and size don't align with the data position, the code calculates the offset for any trailing unknown data and allocates memory to store it, logging appropriate messages.

    // Calculate the expected end position of the object
    BITCODE_RL expected_end = obj->address + obj->size;

    // Check if the object size is valid and within the bounds of the data
    if (expected_end <= dat->size)
    {
      // The object size is valid, no need for further adjustments
    }
    else if (expected_end > dat->size)
    {
      // The object size is invalid, adjust it to the end of the data
      LOG_WARN("Object size (%u) exceeds data size (%zu), adjusting to %zu",
               obj->size, dat->size, dat->size - obj->address);
      obj->size = (BITCODE_RL)(dat->size - obj->address);
    }

    // Check if the object's address and size align with the current data position
    if (dat->byte != obj->address)
    {
      // The object's address and size don't align, extract any trailing unknown data
      BITCODE_RL unknown_size = (BITCODE_RL)(obj->address + obj->size - dat->byte);
      if (unknown_size > 0)
      {
        LOG_TRACE("Extracting %u bytes of unknown data", unknown_size);
        obj->unknown_bits = bit_read_bits(dat, 8 * unknown_size);
        obj->num_unknown_bits = 8 * unknown_size;
      }
    }

    // Perform CRC checks for later versions
    SINCE (R_2_0b)
    {
      BITCODE_RL crc = bit_read_RL(dat);
      if (crc != dwg_crc(dat->chain + obj->address, obj->size))
      {
        LOG_ERROR("CRC mismatch for object at 0x%lx", obj->address);
        return DWG_ERR_WRONGCRC;
      }
    }
  }
}