obj->size = (dat->byte - previous_byte_position) & 0xFFFFFFFF;
                if ((BITCODE_RL)dat->byte > previous_byte_position + obj->size)
                  {
                    LOG_ERROR ("Object size %u too small, current byte "
                               "position 0x%zx\n",
                               obj->size, dat->byte);
                    obj->size = (dat->byte - previous_byte_position)
                                & 0xFFFFFFFF;
                  }
                else if ((BITCODE_RL)dat->byte
                         < previous_byte_position + obj->size)
                  {
                    BITCODE_RL offset = (previous_byte_position + obj->size)
                                         - dat->byte;
                    if (offset > 1024)
                      {
                        LOG_ERROR ("Object size %u too big, current byte "
                                   "position 0x%zx, offset %u\n",
                                   obj->size, dat->byte, offset);
                        obj->size = (dat->byte - previous_byte_position)
                                    & 0xFFFFFFFF;
                      }
                    else
                      {
                        LOG_WARN ("Object size %u too big, current byte "
                                  "position 0x%zx, offset %u\n",
                                  obj->size, dat->byte, offset);
                        if (obj->unknown_data)
                          free (obj->unknown_data);
                        obj->unknown_data = calloc (1, offset);
                        if (!obj->unknown_data)
                          {
                            LOG_ERROR ("Out of memory");
                            return DWG_ERR_OUTOFMEM;
                          }
                        bit_copy_bytes (dat, obj->unknown_data, offset);
                        dat->byte += offset;
                        obj->unknown_size = offset;
                      }
                  }
                SINCE (R_12)
                {
                  BITCODE_RC crc = bit_read_RC (dat);
                  LOG_TRACE ("CRC: 0x%x\n", crc);
                }
                if (num + 1 > dwg->num_objects)
                  break;
                break;
              }
              SINCE (R_13)
              {
                obj->size = (dat->byte - previous_byte_position) & 0xFFFFFFFF;
                if ((BITCODE_RL)dat->byte > previous_byte_position + obj->size)
                  {
                    LOG_ERROR ("Object size %u too small, current byte "
                               "position 0x%zx\n",
                               obj->size, dat->byte);
                    obj->size = (dat->byte - previous_byte_position)
                                & 0xFFFFFFFF;
                  }
                else if ((BITCODE_RL)dat->byte
                         < previous_byte_position + obj->size)
                  {
                    BITCODE_RL offset = (previous_byte_position + obj->size)
                                         - dat->byte;
                    LOG_WARN ("Object size %u too big, current byte "
                              "position 0x%zx, offset %u\n",
                              obj->size, dat->byte, offset);
                    if (obj->unknown_data)
                      free (obj->unknown_data);
                    obj->unknown_data = calloc (1, offset);
                    if (!obj->unknown_data)
                      {
                        LOG_ERROR ("Out of memory");
                        return DWG_ERR_OUTOFMEM;
                      }
                    bit_copy_bytes (dat, obj->unknown_data, offset);
                    dat->byte += offset;
                    obj->unknown_size = offset;
                  }
                if (num + 1 > dwg->num_objects)
                  break;
                break;