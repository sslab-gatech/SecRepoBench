{
  // Validate object size and address alignment
  if (obj->address + obj->size > dat->size)
  {
    LOG_ERROR("Object size exceeds data bounds: address 0x%zx, size 0x%x, data size 0x%zx",
              obj->address, obj->size, dat->size);
    return DWG_ERR_INVALIDDWG;
  }

  // Calculate the offset for any trailing unknown data
  size_t trailing_data_offset = (obj->address + obj->size) - dat->byte;
  if (trailing_data_offset > 0)
  {
    if (trailing_data_offset > dat->size - dat->byte)
    {
      LOG_ERROR("Trailing data offset exceeds buffer size: offset 0x%zx, buffer size 0x%zx",
                trailing_data_offset, dat->size - dat->byte);
      return DWG_ERR_INVALIDDWG;
    }

    // Allocate memory for unknown trailing data
    obj->unknown_data = (unsigned char *)malloc(trailing_data_offset);
    if (!obj->unknown_data)
    {
      LOG_ERROR("Out of memory while allocating unknown data buffer");
      return DWG_ERR_OUTOFMEM;
    }

    // Copy the unknown data and log it
    memcpy(obj->unknown_data, dat->chain + dat->byte, trailing_data_offset);
    LOG_TRACE("Unknown trailing data extracted: size 0x%zx", trailing_data_offset);

    // Advance the data pointer
    dat->byte += trailing_data_offset;
  }

  // Perform CRC validation if applicable
  if (dat->version >= R_13)
  {
    uint32_t calculated_crc = calculate_crc(dat->chain + obj->address, obj->size - 4);
    uint32_t stored_crc = bit_read_RL(dat);
    if (calculated_crc != stored_crc)
    {
      LOG_ERROR("CRC mismatch: calculated 0x%x, stored 0x%x", calculated_crc, stored_crc);
      return DWG_ERR_CRC;
    }
    LOG_TRACE("CRC validation passed: 0x%x", calculated_crc);
  }
}