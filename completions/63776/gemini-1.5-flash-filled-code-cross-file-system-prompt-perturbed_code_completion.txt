size_t unknown_data_offset;
                size_t unknown_data_size;
                unsigned char *unknown_data;

                if (dat->version < R_11)
                  {
                    if (obj->size > (dat->byte - previous_byte_position))
                      {
                        unknown_data_offset = obj->size;
                        unknown_data_size =
                            (dat->byte - previous_byte_position) - obj->size;
                        if (unknown_data_size > 0)
                          {
                            unknown_data = (unsigned char *)malloc (unknown_data_size);
                            if (!unknown_data)
                              {
                                LOG_ERROR ("Out of memory");
                                return DWG_ERR_OUTOFMEM;
                              }
                            memcpy (unknown_data,
                                   &dat->chain[previous_byte_position + obj->size],
                                   unknown_data_size);
                            obj->unknown_data = unknown_data;
                            obj->unknown_data_size = unknown_data_size;
                            LOG_WARN (
                                "Unknown data after object at offset 0x%zx, "
                                "size %zu\n",
                                previous_byte_position + obj->size,
                                unknown_data_size);
                          }
                      }
                    else if (obj->size < (dat->byte - previous_byte_position))
                      {
                        LOG_ERROR (
                            "Object size smaller than expected at offset 0x%zx, "
                            "size %zu < %zu\n",
                            previous_byte_position, obj->size,
                            (dat->byte - previous_byte_position));
                        return DWG_ERR_INVALIDDWG;
                      }
                  }
                else
                  {
                    BITCODE_RC crc;
                    BITCODE_RL size_check;
                    size_check = (BITCODE_RL)(dat->byte - previous_byte_position);
                    if (size_check != obj->size)
                      {
                        unknown_data_offset = obj->size;
                        unknown_data_size = size_check - obj->size;
                        if (unknown_data_size > 0)
                          {
                            unknown_data = (unsigned char *)malloc (unknown_data_size);
                            if (!unknown_data)
                              {
                                LOG_ERROR ("Out of memory");
                                return DWG_ERR_OUTOFMEM;
                              }
                            memcpy (unknown_data,
                                   &dat->chain[previous_byte_position + obj->size],
                                   unknown_data_size);
                            obj->unknown_data = unknown_data;
                            obj->unknown_data_size = unknown_data_size;
                            LOG_WARN (
                                "Unknown data after object at offset 0x%zx, "
                                "size %zu\n",
                                previous_byte_position + obj->size,
                                unknown_data_size);
                          }
                      }
                    crc = bit_read_RC (dat);
                    if (crc != obj->crc)
                      {
                        LOG_ERROR ("CRC mismatch for object at offset 0x%zx, "
                                   "expected 0x%x, got 0x%x\n",
                                   previous_byte_position, obj->crc, crc);
                        return DWG_ERR_INVALIDDWG;
                      }
                  }