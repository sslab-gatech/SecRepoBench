if (obj->size > 0 && obj->size < bit_chain->size
                    && obj->address + obj->size != bit_chain->byte)
                  {
                    size_t offset = obj->address + obj->size - bit_chain->byte;
                    LOG_WARN ("Unknown trailing data: %zu bytes", offset);
                    obj->unknown_rest = (unsigned char *)malloc (offset);
                    if (obj->unknown_rest)
                      {
                        memcpy (obj->unknown_rest, &bit_chain->chain[bit_chain->byte], offset);
                        obj->num_unknown_rest = offset;
                      }
                    else
                      {
                        LOG_ERROR ("Out of memory for unknown trailing data");
                        error |= DWG_ERR_OUTOFMEM;
                      }
                    bit_chain->byte += offset;
                  }
                else if (obj->size > 0 && obj->size < bit_chain->size
                         && obj->address + obj->size == bit_chain->byte)
                  {
                    LOG_TRACE ("No unknown trailing data\n");
                  }
                else
                  {
                    LOG_ERROR ("Invalid object size or address");
                    error |= DWG_ERR_VALUEOUTOFBOUNDS;
                  }
                if (bit_chain->byte < oldpos + size)
                  {
                    LOG_TRACE ("Unknown data after object: %zu bytes\n",
                               oldpos + size - bit_chain->byte);
                    bit_chain->byte = oldpos + size;
                  }
                if (bit_chain->byte > oldpos + size)
                  {
                    LOG_ERROR ("Object size overflow: %zu > %zu",
                               bit_chain->byte - oldpos, size);
                    error |= DWG_ERR_VALUEOUTOFBOUNDS;
                  }
              }
            }