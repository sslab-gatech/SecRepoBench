if (obj->type != DWG_TYPE_JUMP_r11)
  {
    SINCE (R_2_0b) // Pre R_2_0 doesn't contain size of entity
    {
      // Validate object size and adjust if necessary
      if (obj->size > dat->size - dat->byte)
      {
        LOG_WARN("Object size exceeds available data. Adjusting size.");
        obj->size = dat->size - dat->byte;
      }

      // Extract any unknown remaining data if object size doesn't match current data position
      if (obj->size != (dat->byte - previous_byte_position))
      {
        size_t unknown_data_size = obj->size - (dat->byte - previous_byte_position);
        LOG_WARN("Object size doesn't match current data position. Extracting unknown data (%zu bytes).", unknown_data_size);
        obj->unknown_data = bit_read_bytes(dat, unknown_data_size);
        if (!obj->unknown_data)
        {
          LOG_ERROR("Failed to extract unknown data.");
          return DWG_ERR_OUTOFMEM;
        }
      }

      // Perform additional CRC checks for later versions
      #ifdef HAVE_CRC32
      if (dat->version >= R_2000)
      {
        uint32_t crc = crc32(0L, (unsigned char*)obj->unknown_data, unknown_data_size);
        if (crc != obj->crc32)
        {
          LOG_WARN("CRC32 check failed. Data may be corrupted.");
        }
      }
      #endif

      // Calculate offset for any trailing unknown data and allocate memory to store it
      size_t trailing_unknown_data_size = dat->byte - (previous_byte_position + obj->size);
      if (trailing_unknown_data_size > 0)
      {
        LOG_WARN("Found trailing unknown data (%zu bytes). Allocating memory to store it.", trailing_unknown_data_size);
        obj->trailing_unknown_data = bit_read_bytes(dat, trailing_unknown_data_size);
        if (!obj->trailing_unknown_data)
        {
          LOG_ERROR("Failed to allocate memory for trailing unknown data.");
          return DWG_ERR_OUTOFMEM;
        }
      }
    }
  }