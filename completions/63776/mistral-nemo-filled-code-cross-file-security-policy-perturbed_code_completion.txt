if (obj->type != DWG_TYPE_JUMP_r11)
  {
    SINCE (R_2_0b) // Pre R_2_0 doesn't contain size of entity
    {
      // Validate object size and adjust if necessary
      if (obj->size > bit_chain->size - bit_chain->byte)
      {
        obj->size = bit_chain->size - bit_chain->byte;
        LOG_WARN ("Object size adjusted to %" PRIuRL " due to insufficient data\n", obj->size);
      }

      // Extract unknown remaining data if object size doesn't match current data position
      if (obj->size != (bit_chain->byte - oldpos))
      {
        size_t unknown_data_size = obj->size - (bit_chain->byte - oldpos);
        obj->unknown_data = bit_read_bytes (bit_chain, unknown_data_size);
        if (!obj->unknown_data)
        {
          LOG_ERROR ("Failed to extract unknown data\n");
          return DWG_ERR_OUTOFMEM;
        }
        LOG_TRACE ("Unknown data [%zu bytes]: ", unknown_data_size);
        LOG_TRACE_TF (obj->unknown_data, unknown_data_size);
        LOG_TRACE ("\n");
      }

      // Perform additional CRC checks for later versions
      #ifdef HAVE_CRC32
      if (dat->version >= R_2000)
      {
        uint32_t crc = bit_crc32 (bit_chain->byte, obj->size);
        if (crc != obj->crc32)
        {
          LOG_WARN ("CRC32 mismatch, expected 0x%08x, got 0x%08x\n", obj->crc32, crc);
        }
      }
      #endif

      // Calculate offset for trailing unknown data and allocate memory if necessary
      if (obj->size > 0 && (bit_chain->byte + obj->size) > bit_chain->size)
      {
        size_t offset = bit_chain->size - bit_chain->byte;
        obj->trailing_unknown_data = bit_read_bytes (bit_chain, offset);
        if (!obj->trailing_unknown_data)
        {
          LOG_ERROR ("Failed to extract trailing unknown data\n");
          return DWG_ERR_OUTOFMEM;
        }
        LOG_TRACE ("Trailing unknown data [%zu bytes]: ", offset);
        LOG_TRACE_TF (obj->trailing_unknown_data, offset);
        LOG_TRACE ("\n");
      }
    }
  }