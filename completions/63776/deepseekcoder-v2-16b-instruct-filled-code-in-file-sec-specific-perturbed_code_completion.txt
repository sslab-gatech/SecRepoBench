(data < end)
    {
      uint32_t n = *data++;
      sum1 = (sum1 + n) % 0xffff;
      sum2 = (sum2 + sum1) % 0xffff;
    }
  return (sum2 << 0x10) | sum1;
}

// index is the Section Number in the section map
static int
decode_section (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,
                BITCODE_RLd idx)
{
  Dwg_Section *section = find_section (dwg, idx);
  if (!section)
    {
      LOG_ERROR ("Section %d not found", idx);
      return DWG_ERR_SECTIONNOTFOUND;
    }
  if (section->address + section->size > dat->size)
    {
      LOG_ERROR ("Section %d address or size overflow: %" PRIu64 " + " FORMAT_RL
                 " > %" PRIuSIZE,
                 idx, section->address, section->size, dat->size);
      return DWG_ERR_SECTIONNOTFOUND;
    }
  dat->byte = section->address;
  dat->bit = 0;
  if (section->number == SECTION_THUMBNAIL)
    {
      if (bit_search_sentinel (dat, dwg_sentinel (DWG_SENTINEL_THUMBNAIL_BEGIN)))
        {
          size_t start_address = dat->byte;
          if (bit_search_sentinel (dat, dwg_sentinel (DWG_SENTINEL_THUMBNAIL_END)))
            {
              BITCODE_RL bmpsize;
              LOG_TRACE ("\n=======> Thumbnail:       %4zu\n", start_address - 16);
              if ((dat->byte - 16) < start_address)
                {
                  LOG_ERROR ("Illegal header.thumbnail_size: %" PRIuSIZE
                             " < %" PRIuSIZE,
                             dat->byte - 16, start_address);
                }
              else if ((dat->byte - 16) - start_address < 10)
                {
                  LOG_TRACE ("No header.thumbnail: %" PRIuSIZE " < 10",
                             dat->byte - 16 - start_address);
                }
              else
                {
                  BITCODE_RC type;
                  assert ((dat->byte - 16) >= start_address);
                  dwg->thumbnail.size = (dat->byte - 16) - start_address;
                  dwg->thumbnail.chain
                      = (unsigned char *)calloc (dwg->thumbnail.size, 1);
                  dwg->thumbnail.byte = 0;
                  if (!dwg->thumbnail.chain)
                    {
                      LOG_ERROR ("Out of memory");
                      return DWG_ERR_OUTOFMEM;
                    }
                  memcpy (dwg->thumbnail.chain, &dat->chain[start_address],
                          dwg->thumbnail.size);
                  dat->byte += dwg->thumbnail.size;
                  dwg_bmp (dwg, &bmpsize, &type);
                  if (bmpsize > dwg->thumbnail.size)
                    LOG_ERROR ("thumbnail size overflow: %i > %" PRIuSIZE "\n",
                               bmpsize, dwg->thumbnail.size)
                }
            }
        }
    }
  else if (section->number == SECTION_AUXHEADER)
    {
      if (dwg->header.version >= R_2004)
        {
          int i;
          Dwg_AuxHeader *_obj = &dwg->auxheader;
          Bit_Chain *hdl_dat = dat;
          size_t end_address = section->address + section->size;

          obj = NULL;
          dat->byte = section->address;
          LOG_TRACE ("\n"
                     "=======> AuxHeader:       %4zu\n",
                     dat->byte)
          LOG_TRACE ("         AuxHeader (end): %4zu\n", end_address)
          if (dat->size < end_address)
            {
              LOG_ERROR ("Invalid AuxHeader size: buffer overflow")
              return DWG_ERR_SECTIONNOTFOUND;
            }
          else
            {
              size_t old_size = dat->size;
              BITCODE_BL vcount;
              dat->size = end_address;
              // clang-format off
              #include "auxheader.spec"
              // clang-format on
              dat->size = old_size;
            }
        }
    }
  else if (section->number == SECTION_HEADER_R13)
    {
      dat->byte = section->address;
      dat->bit = 0;
      if (bit_search_sentinel (dat, dwg_sentinel (DWG_SENTINEL_HEADER_END)))
        {
          LOG_TRACE ("         HEADER (end):    %4u\n", (unsigned)dat->byte)
        }
    }
  else if (section->number == SECTION_CLASSES_R13)
    {
      dat->byte = section->address;
      dat->bit = 0;
      if (bit_search_sentinel (dat, dwg_sentinel (DWG_SENTINEL_CLASS_BEGIN)))
        {
          dat->byte += 16;
        }
      else
        {
          sentinel_size = 0;
          LOG_TRACE ("no class sentinel\n");
        }
      dat->bit = 0;
      size = bit_read_RL (dat);
      LOG_TRACE ("         Size : %" PRIuSIZE " [RL]\n", size);
      if (size
          != section->size - ((sentinel_size * 2) + 6))
        {
          endpos = section->address + section->size - sentinel_size;
          LOG_ERROR ("Invalid size %" PRIuSIZE ", should be: " FORMAT_RL
                     ", endpos: %" PRIuSIZE "\n",
                     size,
                     section->size - ((sentinel_size * 2) + 6),
                     endpos)
          return DWG_ERR_SECTIONNOTFOUND;
        }
      else
        endpos = dat->byte + size;
      LOG_INSANE ("endpos: %" PRIuSIZE, endpos);
      LOG_POS_ (INSANE);

      /* Read the classes
       */
      dwg->layout_type = 0;
      dwg->num_classes = 0;
#if 0
      SINCE (R_2004) { // dead code. looks better than the current.
        BITCODE_B btrue;
        BITCODE_BL max_num = bit_read_BL (dat);
        LOG_TRACE ("2004 max_num: " FORMAT_BL " [BL]\n", max_num);
        btrue = bit_read_B (dat); // always 1
        LOG_TRACE ("2004 btrue: " FORMAT_B " [B]\n", btrue);
      }
#endif
      while (dat->byte < endpos - 1)
        {
          BITCODE_BS i;
          Dwg_Class *klass;

          i = dwg->num_classes;
          if (i == 0)
            dwg->dwg_class = (Dwg_Class *)malloc (sizeof (Dwg_Class));
          else
            dwg->dwg_class = (Dwg_Class *)realloc (dwg->dwg_class,
                                                   (i + 1) * sizeof (Dwg_Class));
          if (!dwg->dwg_class)
            {
              LOG_ERROR ("Out of memory");
              return DWG_ERR_OUTOFMEM;
            }
          klass = &dwg->dwg_class[i];
          memset (klass, 0, sizeof (Dwg_Class));
          klass->number = bit_read_BS (dat);
          LOG_HANDLE ("number: " FORMAT_BS " [BS] ", klass->number);
          LOG_POS_ (HANDLE);
          klass->proxyflag = bit_read_BS (dat);
          LOG_HANDLE ("proxyflag: " FORMAT_BS " [BS] ", klass->proxyflag);
          LOG_POS_ (HANDLE);
          dwg_log_proxyflag (DWG_LOGLEVEL, DWG_LOGLEVEL_HANDLE, klass->proxyflag);
          if (dat->byte >= endpos)
            break;
          klass->appname = bit_read_TV (dat);
          LOG_HANDLE ("appname: %s [TV] ", klass->appname);
          LOG_POS_ (HANDLE);
          if (dat->byte >= endpos)
            {
              free (klass->appname);
              break;
            }
          LOG_HANDLE ("\n  ");
          klass->cppname = bit_read_TV (dat);
          LOG_HANDLE ("cppname: %s [TV] ", klass->cppname);
          LOG_POS_ (HANDLE);
          klass->dxfname = bit_read_TV (dat);
          LOG_HANDLE ("dxfname: %s [TV] ", klass->dxfname);
          LOG_POS_ (HANDLE);
          klass->is_zombie = bit_read_B (dat); // was_a_proxy
          LOG_HANDLE ("is_zombie: " FORMAT_B " [B] ", klass->is_zombie);
          LOG_POS_ (HANDLE);
          // 1f2 for entities, 1f3 for objects
          klass->item_class_id = bit_read_BS (dat);
          LOG_HANDLE ("item_class_id: " FORMAT_BS " [BS]", klass->item_class_id);
          LOG_POS_ (HANDLE);
          LOG_HANDLE ("\n");
          if (DWG_LOGLEVEL == DWG_LOGLEVEL_TRACE)
            {
              LOG (TRACE,
                   "Class %d 0x%x %s\n"
                   " %s \"%s\" %d 0x%x\n",
                   klass->number, klass->proxyflag, klass->dxfname, klass->cppname,
                   klass->appname, klass->is_zombie, klass->item_class_id)
            }

#if 0
      SINCE (R_2007) //? dead code it seems. see read_2004_section_classes()
      {
        klass->num_instances = bit_read_BL (dat);
        LOG_HANDLE ("num_instances: " FORMAT_BL " [BL]", klass->num_instances); LOG_POS_ (HANDLE);
        klass->dwg_version = bit_read_BL (dat); // nope: class_version
        klass->maint_version = bit_read_BL (dat);
        klass->unknown_1 = bit_read_BL (dat);
        klass->unknown_2 = bit_read_BL (dat);
        LOG_TRACE (
            " num_instances: %d, dwg/maint version: %d/%d, unk: %d/%d\n",
            klass->num_instances, klass->dwg_version, klass->maint_version,
            klass->unknown_1, klass->unknown_2);
      }
#endif

          if (klass->dxfname && strEQc ((const char *)klass->dxfname, "LAYOUT"))
            dwg->layout_type = klass->number;

          dwg->num_classes++;
          if (dwg->num_classes > 500)
            {
              LOG_ERROR ("number of classes is greater than 500");
              break;
            }
        }

      // Check Section CRC
      dat->byte = section->address + section->size - 18;
      dat->bit = 0;
      pvz = section->address + 16;
      if (!bit_check_CRC (dat, pvz, 0xC0C1))
        error |= DWG_ERR_WRONGCRC;

      dat->byte += 16;         // sentinel
      pvz = bit_read_RL (dat); // Unknown bitlong inter class and object
      LOG_TRACE ("unknown: 0x%04zx [RL] @%" PRIuSIZE "\n", pvz, dat->byte - 4)
      LOG_INFO ("Number of classes read: %u\n", dwg->num_classes)
    }
  return 0;
}

static int
decode_R2004 (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)
{
  int error = 0;
  BITCODE_BL i;
  BITCODE_RLd j;
  BITCODE_RLd num_sections = bit_read_RL (dat);
  LOG_TRACE ("num_sections: " FORMAT_RL " [RL]\n", num_sections)