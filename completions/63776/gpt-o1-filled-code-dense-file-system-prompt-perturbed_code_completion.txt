{
  /* Calculate this entity's size from the stream position. */
  obj->size = (dat->byte - obj->address) & 0xFFFFFFFF;

  /* Check for leftover (unknown) data. */
  {
    size_t endpos = obj->address + obj->size;
    if (endpos != dat->byte)
      {
        if (endpos < dat->byte)
          {
            LOG_ERROR ("Short read: endpos < dat->byte");
            error |= DWG_ERR_INVALIDDWG;
          }
        else
          {
            BITCODE_RL offset = endpos - dat->byte;
            obj->num_unknown_rest = offset * 8;
            obj->unknown_rest = (BITCODE_TF)calloc (offset + 1, 1);
            if (obj->unknown_rest)
              {
                memcpy (obj->unknown_rest, &dat->chain[dat->byte], offset);
                LOG_TRACE_TF (obj->unknown_rest, offset);
              }
            else
              {
                LOG_ERROR ("Out of memory");
                obj->num_unknown_rest = 0;
              }
            dat->byte += offset;
          }
      }
  }

  /* Perform CRC check for R_11 and later versions. */
  SINCE (R_11)
  {
    if (!bit_check_CRC (dat, obj->address, 0xC0C1))
      {
        LOG_ERROR ("Entity CRC mismatch");
        error |= DWG_ERR_WRONGCRC;
      }
    /* Restore data pointer after CRC check. */
    bit_set_position (dat, ((size_t)obj->address + obj->size) * 8);
  }
}