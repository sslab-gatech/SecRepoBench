// For pre-R11 versions, the code checks if the object's size is valid and within the bounds of the data, adjusting it if necessary.
PRE (R_11)
{
  if (obj->size > (dat->size - dat->byte))
    {
      LOG_WARN ("Object size too large, adjusting from %d to %zu\n",
                obj->size, dat->size - dat->byte);
      obj->size = (BITCODE_RL)(dat->size - dat->byte);
    }
  if (obj->size < 0)
    {
      LOG_ERROR ("Object size is negative: %d\n", obj->size);
      return DWG_ERR_VALUEOUTOFBOUNDS;
    }
  if (obj->size == 0)
    {
      LOG_TRACE ("Object size is zero\n");
    }
  else
    {
      // Extract any unknown remaining data if the object size doesn't match the current data position.
      if (obj->size!= (dat->byte - previous_byte_position))
        {
          LOG_WARN ("Object size mismatch, extracting unknown data\n");
          error |= dwg_decode_unknown_bits (dat, obj);
        }
    }
}
// For later versions, additional CRC checks are performed to ensure data integrity, and adjustments are made to account for any size discrepancies.
SINCE (R_11)
{
  if (obj->size > (dat->size - dat->byte))
    {
      LOG_WARN ("Object size too large, adjusting from %d to %zu\n",
                obj->size, dat->size - dat->byte);
      obj->size = (BITCODE_RL)(dat->size - dat->byte);
    }
  if (obj->size < 0)
    {
      LOG_ERROR ("Object size is negative: %d\n", obj->size);
      return DWG_ERR_VALUEOUTOFBOUNDS;
    }
  if (obj->size == 0)
    {
      LOG_TRACE ("Object size is zero\n");
    }
  else
    {
      // Calculate the offset for any trailing unknown data and allocate memory to store it.
      size_t offset = (dat->byte - previous_byte_position) - obj->size;
      if (offset > 0)
        {
          LOG_WARN ("Object size mismatch, extracting unknown data\n");
          obj->unknown_data = (unsigned char *)calloc (1, offset);
          if (!obj->unknown_data)
            {
              LOG_ERROR ("Out of memory\n");
              return DWG_ERR_OUTOFMEM;
            }
          obj->unknown_data_size = offset;
          memcpy (obj->unknown_data, dat->chain + previous_byte_position,
                  offset);
          LOG_TRACE ("unknown_data [%zu]: ", offset);
          LOG_TRACE_TF (obj->unknown_data, offset);
          LOG_TRACE ("\n");
        }
      // Perform CRC checks to ensure data integrity.
      if (dat->version >= R_2000)
        {
          BITCODE_CRC crc = bit_read_CRC (dat);
          if (crc!= obj->crc)
            {
              LOG_ERROR ("CRC mismatch: expected 0x%x, got 0x%x\n", obj->crc,
                         crc);
              return DWG_ERR_VALUEOUTOFBOUNDS;
            }
        }
    }
}