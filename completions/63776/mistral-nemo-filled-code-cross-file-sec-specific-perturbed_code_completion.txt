if (obj->type != DWG_TYPE_JUMP_r11)
  {
    SINCE (R_2_0b) // Pre R_2_0 doesn't contain size of entity
    {
      // Validate object size and adjust if necessary
      if (obj->size < 0 || obj->size > dat->size - dat->byte)
      {
        LOG_WARN ("Invalid object size %ld, adjusting\n", (long)obj->size);
        obj->size = dat->size - dat->byte;
      }

      // Extract any unknown remaining data if object size doesn't match current data position
      if (dat->byte + obj->size != previous_byte_position + size)
      {
        size_t unknown_data_size = previous_byte_position + size - (dat->byte + obj->size);
        LOG_WARN ("Extracting %zu bytes of unknown data\n", unknown_data_size);
        obj->unknown_data = bit_read_bytes(dat, unknown_data_size);
        if (!obj->unknown_data)
        {
          LOG_ERROR ("Failed to extract unknown data\n");
          return DWG_ERR_OUTOFMEM;
        }
      }

      // Perform additional CRC checks for later versions
      if (dat->version >= R_2000)
      {
        // TODO: Implement CRC checks for later versions
      }
    }

    // Calculate offset for any trailing unknown data and allocate memory to store it
    if (dat->byte + obj->size < previous_byte_position + size)
    {
      size_t unknown_data_offset = previous_byte_position + size - (dat->byte + obj->size);
      LOG_WARN ("Allocated %zu bytes for trailing unknown data\n", unknown_data_offset);
      obj->trailing_unknown_data = calloc(1, unknown_data_offset);
      if (!obj->trailing_unknown_data)
      {
        LOG_ERROR ("Failed to allocate memory for trailing unknown data\n");
        return DWG_ERR_OUTOFMEM;
      }
    }
  }