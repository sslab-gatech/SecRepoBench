PRE (R_11)
{
  obj->size = bit_read_RS (dat);
  if ((obj->address + obj->size) > end)
    {
      obj->size = (end - obj->address) & 0xffff;
      LOG_ERROR ("Invalid object size %u > %u, fixed to %u", 
                 (unsigned)(obj->address + obj->size),
                 (unsigned)end,
                 obj->size);
    }
}
VERSIONS (R_11, R_13b1)
{
  BITCODE_RS crc, crcc;
  obj->size = bit_read_RS (dat);
  LOG_TRACE ("size: %u [RS]\n", obj->size);
  if (obj->size == 0 || (obj->address + obj->size) > end)
    {
      obj->size = (dat->byte - previous_byte_position) & 0xFFFFFFFF;
      LOG_ERROR ("Invalid object size %u @%lx, fixed to %u", 
                 (unsigned)(obj->address + obj->size),
                 obj->address,
                 obj->size);
    }
  
  if (obj->address + obj->size != (BITCODE_RL)dat->byte)
    {
      long offset = (obj->address + obj->size) - dat->byte;
      if (offset > 0)
        {
          obj->unknown_bits = bit_read_TF (dat, offset);
          LOG_TRACE (" unknown: %ld bytes", offset);
          LOG_TRACE_TF (obj->unknown_bits, offset);
        }
      else if (offset < 0)
        {
          LOG_ERROR ("Overlapping object: %ld bytes", -offset);
          obj->size = (dat->byte - obj->address) & 0xFFFFFFFF;
        }
    }
  
  crc = bit_read_RS (dat);
  crcc = bit_calc_CRC (0xC0C1, &dat->chain[obj->address], obj->size);
  LOG_TRACE (" crc: %04X [RSx] vs calc. %04X\n", crc, crcc);
  if (crc != crcc)
    {
      LOG_WARN ("CRC mismatch %04X <-> %04X", crc, crcc);
      error |= DWG_ERR_WRONGCRC;
    }
}