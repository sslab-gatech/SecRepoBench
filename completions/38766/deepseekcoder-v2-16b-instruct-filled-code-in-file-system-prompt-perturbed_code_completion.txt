== '\010') {
			__archive_read_consume(a, 24);
			zip->unconsumed += 24;
		}
	}
	return (ARCHIVE_OK);
}

static int
zip_read_data(struct archive_read *a, const void **_buff, size_t *size,
    int64_t *offset)
{
	struct zip *zip = (struct zip *)(a->format->data);
	int r;

	if (zip->end_of_entry) {
		r = consume_optional_marker(a, zip);
		if (r != ARCHIVE_OK)
			return (r);
		zip->end_of_entry = 0;
	}

	if (zip->entry->compression == 0) {
		/* No compression. */
		r = zip_read_data_none(a, _buff, size, offset);
	} else {
		switch (zip->entry->compression) {
#if HAVE_ZLIB_H
		case 8: /* Deflate compression. */
			r = zip_read_data_deflate(a, _buff, size, offset);
			break;
#endif
#if HAVE_LZMA_H && HAVE_LIBLZMA
		case 14: /* ZIPx LZMA compression. */
			r = zip_read_data_zipx_lzma_alone(a, _buff, size, offset);
			break;
#endif
#ifdef HAVE_BZLIB_H
		case 12: /* BZIP2 compression. */
			r = zip_read_data_bzip2(a, _buff, size, offset);
			break;
#endif
#if HAVE_ZSTD_H && HAVE_LIBZSTD
		case 93: /* Zstandard (zstd) Compression. */
			r = zip_read_data_zstd(a, _buff, size, offset);
			break;
#endif
#if HAVE_LZMA_H && HAVE_LIBLZMA
		case 94: /* XZ compressed data. */
			r = zip_read_data_lzma(a, _buff, size, offset);
			break;
#endif
		case 95: /* JPEG compressed data. */
		case 96: /* WavPack compressed data. */
		case 97: /* JPEG compressed data. */
		case 98: /* PPMd version I, Rev 1. */
		case 99: /* WinZip AES encryption. */
		default:
			archive_set_error(&a->archive,
			    ARCHIVE_ERRNO_MISC,
			    "Unsupported ZIP compression method "
			    "(%d: %s)",
			    zip->entry->compression,
			    compression_name(zip->entry->compression));
			return (ARCHIVE_FAILED);
		}
	}

	if (r == ARCHIVE_OK && zip->entry_bytes_remaining == 0)
		zip->end_of_entry = 1;

	return (r);
}

/*
 * Read data from the current entry.
 */
static int
archive_read_format_zip_read_data(struct archive_read *a, const void **buff,
    size_t *size, int64_t *offset)
{
	int r;

	r = zip_read_data(a, buff, size, offset);
	if (r == ARCHIVE_OK && zip_entry_size_is_set(a) &&
	    zip->entry_uncompressed_bytes_read >= zip->entry->uncompressed_size)
		zip->end_of_entry = 1;
	return (r);
}

/*
 * Read data from the current entry.
 */
static int
archive_read_format_zip_read_data_block(struct archive_read *a,
    struct archive_read_block *block)
{
	const void *buff;
	size_t size;
	int64_t offset;
	int r;

	r = archive_read_format_zip_read_data(a, &buff, &size, &offset);
	if (r == ARCHIVE_OK) {
		block->buff = buff;
		block->size = size;
		block->offset = offset;
	}
	return (r);
}

/*
 * Read data from the current entry.
 */
static int
archive_read_format_zip_read_data_skip(struct archive_read *a)
{
	const void *buff;
	size_t size;
	int64_t offset;

	return archive_read_format_zip_read_data(a, &buff, &size, &offset);
}

/*
 * Read data from the current entry.
 */
static int
archive_read_format_zip_read_data_block_skip(struct archive_read *a)
{
	const void *buff;
	size_t size;
	int64_t offset;

	return archive_read_format_zip_read_data_block(a, &(struct archive_read_block){
		.buff = &buff,
		.size = &size,
		.offset = &offset,
	});
}

/*
 * Read data from the current entry.
 */
static int
archive_read_format_zip_read_data_block_direct(struct archive_read *a,
    struct archive_read_block *block)
{
	const void *buff;
	size_t size;
	int64_t offset;

	return archive_read_format_zip_read_data(a, &buff, &size, &offset);
}

/*
 * Read data from the current entry.
 */
static int
archive_read_format_zip_read_data_block_direct_skip(struct archive_read *a)
{
	const void *buff;
	size_t size;
	int64_t offset;

	return archive_read_format_zip_read_data_block_direct(a, &(struct archive_read_block){
		.buff = &buff,
		.size = &size,
		.offset = &offset,
	});
}

/*
 * Read data from the current entry.
 */
static int
archive_read_format_zip_read_data_block_direct_seek(struct archive_read *a,
    int64_t offset, int whence)
{
	const void *buff;
	size_t size;
	int64_t new_offset;

	if (whence == SEEK_SET)
		new_offset = offset;
	else if (whence == SEEK_CUR)
		new_offset = a->offset + offset;
	else if (whence == SEEK_END)
		new_offset = a->archive.size + offset;
	else
		return ARCHIVE_FAILED;

	return archive_read_format_zip_read_data(a, &buff, &size, &new_offset);
}

/*
 * Read data from the current entry.
 */
static int
archive_read_format_zip_read_data_block_direct_seek_skip(struct archive_read *a,
    int64_t offset, int whence)
{
	const void *buff;
	size_t size;
	int64_t new_offset;

	if (whence == SEEK_SET)
		new_offset = offset;
	else if (whence == SEEK_CUR)
		new_offset = a->offset + offset;
	else if (whence == SEEK_END)
		new_offset = a->archive.size + offset;
	else
		return ARCHIVE_FAILED;

	return archive_read_format_zip_read_data_block_direct(a, &(struct archive_read_block){
		.buff = &buff,
		.size = &size,
		.offset = &new_offset,
	});
}

/*
 * Read data from the current entry.
 */
static int
archive_read_format_zip_read_data_block_direct_seek_skip_seek(struct archive_read *a,
    int64_t offset, int whence)
{
	const void *buff;
	size_t size;
	int64_t new_offset;

	if (whence == SEEK_SET)
		new_offset = offset;
	else if (whence == SEEK_CUR)
		new_offset = a->offset + offset;
	else if (whence == SEEK_END)
		new_offset = a->archive.size + offset;
	else
		return ARCHIVE_FAILED;

	return archive_read_format_zip_read_data_block_direct_seek(a, offset, whence);
}

/*
 * Read data from the current entry.
 */
static int
archive_read_format_zip_read_data_block_direct_seek_skip_seek_skip(struct archive_read *a,
    int64_t offset, int whence)
{
	const void *buff;
	size_t size;
	int64_t new_offset;

	if (whence == SEEK_SET)
		new_offset = offset;
	else if (whence == SEEK_CUR)
		new_offset = a->offset + offset;
	else if (whence == SEEK_END)
		new_offset = a->archive.size + offset;
	else
		return ARCHIVE_FAILED;

	return archive_read_format_zip_read_data_block_direct_seek_skip(a, offset, whence);
}

/*
 * Read data from the current entry.
 */
static int
archive_read_format_zip_read_data_block_direct_seek_skip_seek_skip_skip(struct archive_read *a,
    int64_t offset, int whence)
{
	const void *buff;
	size_t size;
	int64_t new_offset;

	if (whence == SEEK_SET)
		new_offset = offset;
	else if (whence == SEEK_CUR)
		new_offset = a->offset + offset;
	else if (whence == SEEK_END)
		new_offset = a->archive.size + offset;
	else
		return ARCHIVE_FAILED;

	return archive_read_format_zip_read_data_block_direct_seek_skip(a, offset, whence);
}

/*
 * Read data from the current entry.
 */
static int
archive_read_format_zip_read_data_block_direct_seek_skip_seek_skip_skip_skip(struct archive_read *a,
    int64_t offset, int whence)
{
	const void *buff;
	size_t size;
	int64_t new_offset;

	if (whence == SEEK_SET)
		new_offset = offset;
	else if (whence == SEEK_CUR)
		new_offset = a->offset + offset;
	else if (whence == SEEK_END)
		new_offset = a->archive.size + offset;
	else
		return ARCHIVE_FAILED;

	return archive_read_format_zip_read_data_block_direct_seek_skip(a, offset, whence);
}

/*
 * Read data from the current entry.
 */
static int
archive_read_format_zip_read_data_block_direct_seek_skip_seek_skip_skip_skip_skip(struct archive_read *a,
    int64_t offset, int whence)
{
	const void *buff;
	size_t size;
	int64_t new_offset;

	if (whence == SEEK_SET)
		new_offset = offset;
	else if (whence == SEEK_CUR)
		new_offset = a->offset + offset;
	else if (whence == SEEK_END)
		new_offset = a->archive.size + offset;
	else
		return ARCHIVE_FAILED;

	return archive_read_format_zip_read_data_block_direct_seek_skip_skip(a, offset, whence);
}

/*
 * Read data from the current entry.
 */
static int
archive_read_format_zip_read_data_block_direct_seek_skip_seek_skip_skip_skip_skip_skip(struct archive_read *a,
    int64_t offset, int whence)
{
	const void *buff;
	size_t size;
	int64_t new_offset;

	if (whence == SEEK_SET)
		new_offset = offset;
	else if (whence == SEEK_CUR)
		new_offset = a->offset + offset;
	else if (whence == SEEK_END)
		new_offset = a->archive.size + offset;
	else
		return ARCHIVE_FAILED;

	return archive_read_format_zip_read_data_block_direct_seek_skip_skip(a, offset, whence);
}

/*
 * Read data from the current entry.
 */
static int
archive_read_format_zip_read_data_block_direct_seek_skip_seek_skip_skip_skip_skip_skip