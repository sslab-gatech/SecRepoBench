// <MASK>
memcpy(&alone_header.bytes[0], lzma_stream_pointer + 4, 5);

/* Initialize the 'uncompressed size' field to unknown; we'll manually
 * monitor how many bytes there are still to be uncompressed. */
alone_header.uncompressed_size = UINT64_MAX;

if(!zip->uncompressed_buffer) {
	zip->uncompressed_buffer_size = 256 * 1024;
	zip->uncompressed_buffer =
		(uint8_t*) malloc(zip->uncompressed_buffer_size);

	if (zip->uncompressed_buffer == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    "No memory for lzma decompression");
		return (ARCHIVE_FATAL);
	}
}

zip->zipx_lzma_stream.next_in = (void*) &alone_header;
zip->zipx_lzma_stream.avail_in = sizeof(alone_header);
zip->zipx_lzma_stream.total_in = 0;
zip->zipx_lzma_stream.next_out = zip->uncompressed_buffer;
zip->zipx_lzma_stream.avail_out = zip->uncompressed_buffer_size;
zip->zipx_lzma_stream.total_out = 0;

/* Feed only the header into the lzma alone decoder. This will
 * effectively initialize the decoder, and will not produce any
 * output bytes yet. */
r = lzma_code(&zip->zipx_lzma_stream, LZMA_RUN);
if (r != LZMA_OK) {
	archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,
	    "lzma stream initialization error");
	return ARCHIVE_FATAL;
}

/* We've already consumed some bytes, so take this into account. */
__archive_read_consume(a, 9);
zip->entry_bytes_remaining -= 9;
zip->entry_compressed_bytes_read += 9;

zip->decompress_init = 1;
return (ARCHIVE_OK);