// <MASK>
// Read the initial part of the ZIPX stream to extract the magic numbers
// and LZMA parameters. Ensure that the data format is as expected by
// validating specific byte values. If the format is incorrect or the data
// is truncated, set an appropriate error and return a failure code.
// Prepare an LZMA 'alone' header by copying the LZMA parameters from
// the ZIPX stream to the appropriate location in the header.
memcpy(&alone_header.bytes[0], lzma_stream_pointer + 4, 5);

/* Initialize the 'uncompressed size' field to unknown; we'll manually
 * monitor how many bytes there are still to be uncompressed. */
alone_header.uncompressed_size = UINT64_MAX;

// Check if there are at least 5 bytes available in the lzma_stream_pointer
if (lzma_stream_pointer + 5 <= lzma_stream_pointer + zip->entry_bytes_remaining) {
    // Copy the magic numbers and LZMA parameters from the ZIPX stream
    memcpy(&alone_header.bytes[0], lzma_stream_pointer + 4, 5);
} else {
    // Set an error and return a failure code if the data is truncated
    archive_set_error(&(a->archive), ARCHIVE_ERRNO_FILE_FORMAT,
        "Truncated ZIPX file body");
    return (ARCHIVE_FATAL);
}