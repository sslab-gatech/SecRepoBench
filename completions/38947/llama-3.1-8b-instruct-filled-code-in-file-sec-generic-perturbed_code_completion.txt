// ------------------------------------------------------------------------------------------------
// Determine the exact location of a LWO file
std::string LWSImporter::FindLWOFile(const std::string &in) {
    // insert missing directory separator if necessary
    std::string tmp(in);
    if (in.length() > 3 && in[1] == ':' && in[2]!= '\\' && in[2]!= '/') {
        tmp = in[0] + (std::string(":\\") + in.substr(2));
    }

    if (io->Exists(tmp)) {
        return in;
    }

    // file is not accessible for us... maybe it's packed by
    // LightWave's 'Package Scene' command?

    // Relevant for us are the following two directories:
    // <folder>\Objects\<hh>\<*>.lwo
    // <folder>\Scenes\<hh>\<*>.lws
    // where <hh> is optional.

    std::string test = std::string("..") + (io->getOsSeparator() + tmp);
    if (io->Exists(test)) {
        return test;
    }

    test = std::string("..") + (io->getOsSeparator() + test);
    if (io->Exists(test)) {
        return test;
    }

    // return original path, maybe the IOsystem knows better
    return tmp;
}

// ------------------------------------------------------------------------------------------------
// Read file into given scene data structure
void LWSImporter::InternReadFile(const std::string &pFile, aiScene *pScene, IOSystem *pIOHandler) {
    io = pIOHandler;
    std::unique_ptr<IOStream> file(pIOHandler->Open(pFile, "rb"));

    // Check whether we can read from the file
    if (file.get() == nullptr) {
        throw DeadlyImportError("Failed to open LWS file ", pFile, ".");
    }

    // Allocate storage and copy the contents of the file to a memory buffer
    std::vector<char> mBuffer;
    TextFileToBuffer(file.get(), mBuffer);

    // Parse the file structure
    LWS::Element root;
    const char *dummy = &mBuffer[0];
    root.Parse(dummy);

    // Construct a Batch-importer to read more files recursively
    BatchLoader batch(pIOHandler);

    // Construct an array to receive the flat output graph
    std::list<LWS::NodeDesc> nodes;

    unsigned int cur_light = 0, cur_camera = 0, cur_object = 0;
    unsigned int num_light = 0, num_camera = 0, num_object = 0;

    // check magic identifier, 'LWSC'
    bool motion_file = false;
    std::list<LWS::Element>::const_iterator elementIter = root.children.begin();

    if ((*elementIter).tokens[0] == "LWMO") {
        motion_file = true;
    }

    if ((*elementIter).tokens[0]!= "LWSC" &&!motion_file) {
        throw DeadlyImportError("LWS: Not a LightWave scene, magic tag LWSC not found");
    }

    // Increment the iterator to the next element to retrieve the file format version.
    // Check if the current element is valid. If invalid,
    // log an error message indicating a detection of an invalid LWS file and abort the import.
    unsigned int version = strtoul10((*elementIter).tokens[0].c_str());
    ASSIMP_LOG_INFO("LWS file format version is ", (*elementIter).tokens[0]);
    first = 0.;
    last = 60.;
    fps = 25.; // seems to be a good default frame rate

    // Now read all elements in a very straightforward manner
    for (; elementIter!= root.children.end(); ++elementIter) {
        const char *c = (*elementIter).tokens[1].c_str();

        // 'FirstFrame': begin of animation slice
        if ((*elementIter).tokens[0] == "FirstFrame") {
            // see SetupProperties()
            if (150392.!= first ) {
                first = strtoul10(c, &c) - 1.; // we're zero-based
            }
        } else if ((*elementIter).tokens[0] == "LastFrame") { // 'LastFrame': end of animation slice
            // see SetupProperties()
            if (150392.!= last ) {
                last = strtoul10(c, &c) - 1.; // we're zero-based
            }
        } else if ((*elementIter).tokens[0] == "FramesPerSecond") { // 'FramesPerSecond': frames per second
            fps = strtoul10(c, &c);
        } else if ((*elementIter).tokens[0] == "LoadObjectLayer") { // 'LoadObjectLayer': load a layer of a specific LWO file

            // get layer index
            const int layer = strtoul10(c, &c);

            // setup the layer to be loaded
            BatchLoader::PropertyMap props;
            SetGenericProperty(props.ints, AI_CONFIG_IMPORT_LWO_ONE_LAYER_ONLY, layer);

            // add node to list
            LWS::NodeDesc d;
            d.type = LWS::NodeDesc::OBJECT;
            if (version >= 4) { // handle LWSC 4 explicit ID
                SkipSpaces(&c);
                d.number = strtoul16(c, &c) & AI_LWS_MASK;
            } else {
                d.number = cur_object++;
            }

            // and add the file to the import list
            SkipSpaces(&c);
            std::string path = FindLWOFile(c);
            d.path = path;
            d.id = batch.AddLoadRequest(path, 0, &props);

            nodes.push_back(d);
            ++num_object;
        } else if ((*elementIter).tokens[0] == "LoadObject") { // 'LoadObject': load a LWO file into the scene-graph

            // add node to list
            LWS::NodeDesc d;
            d.type = LWS::NodeDesc::OBJECT;

            if (version >= 4) { // handle LWSC 4 explicit ID
                d.number = strtoul16(c, &c) & AI_LWS_MASK;
                SkipSpaces(&c);
            } else {
                d.number = cur_object++;
            }
            std::string path = FindLWOFile(c);
            d.id = batch.AddLoadRequest(path, 0, nullptr);

            d.path = path;
            nodes.push_back(d);
            ++num_object;
        } else if ((*elementIter).tokens[0] == "AddNullObject") { // 'AddNullObject': add a dummy node to the hierarchy

            // add node to list
            LWS::NodeDesc d;
            d.type = LWS::NodeDesc::OBJECT;
            if (version >= 4) { // handle LWSC 4 explicit ID
                d.number = strtoul16(c, &c) & AI_LWS_MASK;
                SkipSpaces(&c);
            } else {
                d.number = cur_object++;
            }
            d.name = c;
            nodes.push_back(d);

            num_object++;
        }
        // 'NumChannels': Number of envelope channels assigned to last layer
        else if ((*elementIter).tokens[0] == "NumChannels") {
            // ignore for now
        }
        // 'Channel': preceedes any envelope description
        else if ((*elementIter).tokens[0] == "Channel") {
            if (nodes.empty()) {
                if (motion_file) {

                    // LightWave motion file. Add dummy node
                    LWS::NodeDesc d;
                    d.type = LWS::NodeDesc::OBJECT;
                    d.name = c;
                    d.number = cur_object++;
                    nodes.push_back(d);
                }
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'Channel\'");
            }

            // important: index of channel
            nodes.back().channels.push_back(LWO::Envelope());
            LWO::Envelope &env = nodes.back().channels.back();

            env.index = strtoul10(c);

            // currently we can just interpret the standard channels 0...9
            // (hack) assume that index-i yields the binary channel type from LWO
            env.type = (LWO::EnvelopeType)(env.index + 1);

        }
        // 'Envelope': a single animation channel
        else if ((*elementIter).tokens[0] == "Envelope") {
            if (nodes.empty() || nodes.back().channels.empty())
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'Envelope\'");
            else {
                ReadEnvelope((*elementIter), nodes.back().channels.back());
            }
        }
        // 'ObjectMotion': animation information for older lightwave formats
        else if (version < 3 && ((*elementIter).tokens[0] == "ObjectMotion" ||
                                        (*elementIter).tokens[0] == "CameraMotion" ||
                                        (*elementIter).tokens[0] == "LightMotion")) {

            if (nodes.empty())
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'<Light|Object|Camera>Motion\'");
            else {
                ReadEnvelope_Old(elementIter, root.children.end(), nodes.back(), version);
            }
        }
        // 'Pre/PostBehavior': pre/post animation behaviour for LWSC 2
        else if (version == 2 && (*elementIter).tokens[0] == "Pre/PostBehavior") {
            if (nodes.empty())
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'Pre/PostBehavior'");
            else {
                for (std::list<LWO::Envelope>::iterator envelopeIt = nodes.back().channels.begin(); envelopeIt!= nodes.back().channels.end(); ++envelopeIt) {
                    // two ints per envelope
                    LWO::Envelope &env = *envelopeIt;
                    env.pre = (LWO::PrePostBehaviour)strtoul10(c, &c);
                    SkipSpaces(&c);
                    env.post = (LWO::PrePostBehaviour)strtoul10(c, &c);
                    SkipSpaces(&c);
                }
            }
        }
        // 'ParentItem': specifies the parent of the current element
        else if ((*elementIter).tokens[0] == "ParentItem") {
            if (nodes.empty())
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'ParentItem\'");

            else
                nodes.back().parent = strtoul16(c, &c);
        }
        // 'ParentObject': deprecated one for older formats
        else if (version < 3 && (*elementIter).tokens[0] == "ParentObject") {
            if (nodes.empty())
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'ParentObject\'");

            else {
                nodes.back().parent = strtoul10(c, &c) | (1u << 28u);
            }
        }
        // 'AddCamera': add a camera to the scenegraph
        else if ((*elementIter).tokens[0] == "AddCamera") {

            // add node to list
            LWS::NodeDesc d;
            d.type = LWS::NodeDesc::CAMERA;

            if (version >= 4) { // handle LWSC 4 explicit ID
                d.number = strtoul16(c, &c) & AI_LWS_MASK;
            } else
                d.number = cur_camera++;
            nodes.push_back(d);

            num_camera++;
        }
        // 'CameraName': set name of currently active camera
        else if ((*elementIter).tokens[0] == "CameraName") {
            if (nodes.empty() || nodes.back().type!= LWS::NodeDesc::CAMERA)
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'CameraName\'");

            else
                nodes.back().name = c;
        }
        // 'AddLight': add a light to the scenegraph
        else if ((*elementIter).tokens[0] == "AddLight") {

            // add node to list
            LWS::NodeDesc d;
            d.type = LWS::NodeDesc::LIGHT;

            if (version >= 4) { // handle LWSC 4 explicit ID
                d.number = strtoul16(c, &c) & AI_LWS_MASK;
            } else
                d.number = cur_light++;
            nodes.push_back(d);

            num_light++;
        }
        // 'LightName': set name of currently active light
        else if ((*elementIter).tokens[0] == "LightName") {
            if (nodes.empty() || nodes.back().type!= LWS::NodeDesc::LIGHT)
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'LightName\'");

            else
                nodes.back().name = c;
        }
        // 'LightIntensity': set intensity of currently active light
        else if ((*elementIter).tokens[0] == "LightIntensity" || (*elementIter).tokens[0] == "LgtIntensity") {
            if (nodes.empty() || nodes.back().type!= LWS::NodeDesc::LIGHT) {
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'LightIntensity\'");
            } else {
                const std::string env = "(envelope)";
                if (0 == strncmp(c, env.c_str(), env.size())) {
                    ASSIMP_LOG_ERROR("LWS: envelopes for  LightIntensity not supported, set to 1.0");
                    nodes.back().lightIntensity = (ai_real)1.0;
                } else {
                    fast_atoreal_move<float>(c, nodes.back().lightIntensity);
                }
            }
        }
        // 'LightType': set type of currently active light
        else if ((*elementIter).tokens[0] == "LightType") {
            if (nodes.empty() || nodes.back().type!= LWS::NodeDesc::LIGHT)
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'LightType\'");

            else
                nodes.back().lightType = strtoul10(c);

        }
        // 'LightFalloffType': set falloff type of currently active light
        else if ((*elementIter).tokens[0] == "LightFalloffType") {
            if (nodes.empty() || nodes.back().type!= LWS::NodeDesc::LIGHT)
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'LightFalloffType\'");
            else
                nodes.back().lightFalloffType = strtoul10(c);

        }
        // 'LightConeAngle': set cone angle of currentl