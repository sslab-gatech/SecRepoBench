Below is the content of a C/C++ function where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
void LWSImporter::InternReadFile(const std::string &pFile, aiScene *pScene, IOSystem *pIOHandler) {
    io = pIOHandler;
    std::unique_ptr<IOStream> file(pIOHandler->Open(pFile, "rb"));

    // Check whether we can read from the file
    if (file.get() == nullptr) {
        throw DeadlyImportError("Failed to open LWS file ", pFile, ".");
    }

    // Allocate storage and copy the contents of the file to a memory buffer
    std::vector<char> mBuffer;
    TextFileToBuffer(file.get(), mBuffer);

    // Parse the file structure
    LWS::Element root;
    const char *dummy = &mBuffer[0];
    root.Parse(dummy);

    // Construct a Batch-importer to read more files recursively
    BatchLoader batch(pIOHandler);

    // Construct an array to receive the flat output graph
    std::list<LWS::NodeDesc> nodes;

    unsigned int cur_light = 0, cur_camera = 0, cur_object = 0;
    unsigned int num_light = 0, num_camera = 0, num_object = 0;

    // check magic identifier, 'LWSC'
    bool motion_file = false;
    std::list<LWS::Element>::const_iterator elementIter = root.children.begin();

    if ((*elementIter).tokens[0] == "LWMO") {
        motion_file = true;
    }

    if ((*elementIter).tokens[0] != "LWSC" && !motion_file) {
        throw DeadlyImportError("LWS: Not a LightWave scene, magic tag LWSC not found");
    }

    // Increment the iterator to the next element to retrieve the file format version.
    // Check if the current element is valid. If invalid,
    // log an error message indicating a detection of an invalid LWS file and abort the import.
    // <MASK>
    unsigned int version = strtoul10((*elementIter).tokens[0].c_str());
    ASSIMP_LOG_INFO("LWS file format version is ", (*elementIter).tokens[0]);
    first = 0.;
    last = 60.;
    fps = 25.; // seems to be a good default frame rate

    // Now read all elements in a very straightforward manner
    for (; elementIter != root.children.end(); ++elementIter) {
        const char *c = (*elementIter).tokens[1].c_str();

        // 'FirstFrame': begin of animation slice
        if ((*elementIter).tokens[0] == "FirstFrame") {
            // see SetupProperties()
            if (150392. != first ) {
                first = strtoul10(c, &c) - 1.; // we're zero-based
            }
        } else if ((*elementIter).tokens[0] == "LastFrame") { // 'LastFrame': end of animation slice
            // see SetupProperties()
            if (150392. != last ) {
                last = strtoul10(c, &c) - 1.; // we're zero-based
            }
        } else if ((*elementIter).tokens[0] == "FramesPerSecond") { // 'FramesPerSecond': frames per second
            fps = strtoul10(c, &c);
        } else if ((*elementIter).tokens[0] == "LoadObjectLayer") { // 'LoadObjectLayer': load a layer of a specific LWO file

            // get layer index
            const int layer = strtoul10(c, &c);

            // setup the layer to be loaded
            BatchLoader::PropertyMap props;
            SetGenericProperty(props.ints, AI_CONFIG_IMPORT_LWO_ONE_LAYER_ONLY, layer);

            // add node to list
            LWS::NodeDesc d;
            d.type = LWS::NodeDesc::OBJECT;
            if (version >= 4) { // handle LWSC 4 explicit ID
                SkipSpaces(&c);
                d.number = strtoul16(c, &c) & AI_LWS_MASK;
            } else {
                d.number = cur_object++;
            }

            // and add the file to the import list
            SkipSpaces(&c);
            std::string path = FindLWOFile(c);
            d.path = path;
            d.id = batch.AddLoadRequest(path, 0, &props);

            nodes.push_back(d);
            ++num_object;
        } else if ((*elementIter).tokens[0] == "LoadObject") { // 'LoadObject': load a LWO file into the scene-graph

            // add node to list
            LWS::NodeDesc d;
            d.type = LWS::NodeDesc::OBJECT;

            if (version >= 4) { // handle LWSC 4 explicit ID
                d.number = strtoul16(c, &c) & AI_LWS_MASK;
                SkipSpaces(&c);
            } else {
                d.number = cur_object++;
            }
            std::string path = FindLWOFile(c);
            d.id = batch.AddLoadRequest(path, 0, nullptr);

            d.path = path;
            nodes.push_back(d);
            ++num_object;
        } else if ((*elementIter).tokens[0] == "AddNullObject") { // 'AddNullObject': add a dummy node to the hierarchy

            // add node to list
            LWS::NodeDesc d;
            d.type = LWS::NodeDesc::OBJECT;
            if (version >= 4) { // handle LWSC 4 explicit ID
                d.number = strtoul16(c, &c) & AI_LWS_MASK;
                SkipSpaces(&c);
            } else {
                d.number = cur_object++;
            }
            d.name = c;
            nodes.push_back(d);

            num_object++;
        }
        // 'NumChannels': Number of envelope channels assigned to last layer
        else if ((*elementIter).tokens[0] == "NumChannels") {
            // ignore for now
        }
        // 'Channel': preceedes any envelope description
        else if ((*elementIter).tokens[0] == "Channel") {
            if (nodes.empty()) {
                if (motion_file) {

                    // LightWave motion file. Add dummy node
                    LWS::NodeDesc d;
                    d.type = LWS::NodeDesc::OBJECT;
                    d.name = c;
                    d.number = cur_object++;
                    nodes.push_back(d);
                }
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'Channel\'");
            }

            // important: index of channel
            nodes.back().channels.push_back(LWO::Envelope());
            LWO::Envelope &env = nodes.back().channels.back();

            env.index = strtoul10(c);

            // currently we can just interpret the standard channels 0...9
            // (hack) assume that index-i yields the binary channel type from LWO
            env.type = (LWO::EnvelopeType)(env.index + 1);

        }
        // 'Envelope': a single animation channel
        else if ((*elementIter).tokens[0] == "Envelope") {
            if (nodes.empty() || nodes.back().channels.empty())
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'Envelope\'");
            else {
                ReadEnvelope((*elementIter), nodes.back().channels.back());
            }
        }
        // 'ObjectMotion': animation information for older lightwave formats
        else if (version < 3 && ((*elementIter).tokens[0] == "ObjectMotion" ||
                                        (*elementIter).tokens[0] == "CameraMotion" ||
                                        (*elementIter).tokens[0] == "LightMotion")) {

            if (nodes.empty())
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'<Light|Object|Camera>Motion\'");
            else {
                ReadEnvelope_Old(elementIter, root.children.end(), nodes.back(), version);
            }
        }
        // 'Pre/PostBehavior': pre/post animation behaviour for LWSC 2
        else if (version == 2 && (*elementIter).tokens[0] == "Pre/PostBehavior") {
            if (nodes.empty())
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'Pre/PostBehavior'");
            else {
                for (std::list<LWO::Envelope>::iterator envelopeIt = nodes.back().channels.begin(); envelopeIt != nodes.back().channels.end(); ++envelopeIt) {
                    // two ints per envelope
                    LWO::Envelope &env = *envelopeIt;
                    env.pre = (LWO::PrePostBehaviour)strtoul10(c, &c);
                    SkipSpaces(&c);
                    env.post = (LWO::PrePostBehaviour)strtoul10(c, &c);
                    SkipSpaces(&c);
                }
            }
        }
        // 'ParentItem': specifies the parent of the current element
        else if ((*elementIter).tokens[0] == "ParentItem") {
            if (nodes.empty())
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'ParentItem\'");

            else
                nodes.back().parent = strtoul16(c, &c);
        }
        // 'ParentObject': deprecated one for older formats
        else if (version < 3 && (*elementIter).tokens[0] == "ParentObject") {
            if (nodes.empty())
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'ParentObject\'");

            else {
                nodes.back().parent = strtoul10(c, &c) | (1u << 28u);
            }
        }
        // 'AddCamera': add a camera to the scenegraph
        else if ((*elementIter).tokens[0] == "AddCamera") {

            // add node to list
            LWS::NodeDesc d;
            d.type = LWS::NodeDesc::CAMERA;

            if (version >= 4) { // handle LWSC 4 explicit ID
                d.number = strtoul16(c, &c) & AI_LWS_MASK;
            } else
                d.number = cur_camera++;
            nodes.push_back(d);

            num_camera++;
        }
        // 'CameraName': set name of currently active camera
        else if ((*elementIter).tokens[0] == "CameraName") {
            if (nodes.empty() || nodes.back().type != LWS::NodeDesc::CAMERA)
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'CameraName\'");

            else
                nodes.back().name = c;
        }
        // 'AddLight': add a light to the scenegraph
        else if ((*elementIter).tokens[0] == "AddLight") {

            // add node to list
            LWS::NodeDesc d;
            d.type = LWS::NodeDesc::LIGHT;

            if (version >= 4) { // handle LWSC 4 explicit ID
                d.number = strtoul16(c, &c) & AI_LWS_MASK;
            } else
                d.number = cur_light++;
            nodes.push_back(d);

            num_light++;
        }
        // 'LightName': set name of currently active light
        else if ((*elementIter).tokens[0] == "LightName") {
            if (nodes.empty() || nodes.back().type != LWS::NodeDesc::LIGHT)
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'LightName\'");

            else
                nodes.back().name = c;
        }
        // 'LightIntensity': set intensity of currently active light
        else if ((*elementIter).tokens[0] == "LightIntensity" || (*elementIter).tokens[0] == "LgtIntensity") {
            if (nodes.empty() || nodes.back().type != LWS::NodeDesc::LIGHT) {
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'LightIntensity\'");
            } else {
                const std::string env = "(envelope)";
                if (0 == strncmp(c, env.c_str(), env.size())) {
                    ASSIMP_LOG_ERROR("LWS: envelopes for  LightIntensity not supported, set to 1.0");
                    nodes.back().lightIntensity = (ai_real)1.0;
                } else {
                    fast_atoreal_move<float>(c, nodes.back().lightIntensity);
                }
            }
        }
        // 'LightType': set type of currently active light
        else if ((*elementIter).tokens[0] == "LightType") {
            if (nodes.empty() || nodes.back().type != LWS::NodeDesc::LIGHT)
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'LightType\'");

            else
                nodes.back().lightType = strtoul10(c);

        }
        // 'LightFalloffType': set falloff type of currently active light
        else if ((*elementIter).tokens[0] == "LightFalloffType") {
            if (nodes.empty() || nodes.back().type != LWS::NodeDesc::LIGHT)
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'LightFalloffType\'");
            else
                nodes.back().lightFalloffType = strtoul10(c);

        }
        // 'LightConeAngle': set cone angle of currently active light
        else if ((*elementIter).tokens[0] == "LightConeAngle") {
            if (nodes.empty() || nodes.back().type != LWS::NodeDesc::LIGHT)
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'LightConeAngle\'");

            else
                nodes.back().lightConeAngle = fast_atof(c);

        }
        // 'LightEdgeAngle': set area where we're smoothing from min to max intensity
        else if ((*elementIter).tokens[0] == "LightEdgeAngle") {
            if (nodes.empty() || nodes.back().type != LWS::NodeDesc::LIGHT)
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'LightEdgeAngle\'");

            else
                nodes.back().lightEdgeAngle = fast_atof(c);

        }
        // 'LightColor': set color of currently active light
        else if ((*elementIter).tokens[0] == "LightColor") {
            if (nodes.empty() || nodes.back().type != LWS::NodeDesc::LIGHT)
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'LightColor\'");

            else {
                c = fast_atoreal_move<float>(c, (float &)nodes.back().lightColor.r);
                SkipSpaces(&c);
                c = fast_atoreal_move<float>(c, (float &)nodes.back().lightColor.g);
                SkipSpaces(&c);
                c = fast_atoreal_move<float>(c, (float &)nodes.back().lightColor.b);
            }
        }

        // 'PivotPosition': position of local transformation origin
        else if ((*elementIter).tokens[0] == "PivotPosition" || (*elementIter).tokens[0] == "PivotPoint") {
            if (nodes.empty())
                ASSIMP_LOG_ERROR("LWS: Unexpected keyword: \'PivotPosition\'");
            else {
                c = fast_atoreal_move<float>(c, (float &)nodes.back().pivotPos.x);
                SkipSpaces(&c);
                c = fast_atoreal_move<float>(c, (float &)nodes.back().pivotPos.y);
                SkipSpaces(&c);
                c = fast_atoreal_move<float>(c, (float &)nodes.back().pivotPos.z);
                // Mark pivotPos as set
                nodes.back().isPivotSet = true;
            }
        }
    }

    // resolve parenting
    for (std::list<LWS::NodeDesc>::iterator ndIt = nodes.begin(); ndIt != nodes.end(); ++ndIt) {

        // check whether there is another node which calls us a parent
        for (std::list<LWS::NodeDesc>::iterator dit = nodes.begin(); dit != nodes.end(); ++dit) {
            if (dit != ndIt && *ndIt == (*dit).parent) {
                if ((*dit).parent_resolved) {
                    // fixme: it's still possible to produce an overflow due to cross references ..
                    ASSIMP_LOG_ERROR("LWS: Found cross reference in scene-graph");
                    continue;
                }

                ndIt->children.push_back(&*dit);
                (*dit).parent_resolved = &*ndIt;
            }
        }
    }

    // find out how many nodes have no parent yet
    unsigned int no_parent = 0;
    for (std::list<LWS::NodeDesc>::iterator ndIt = nodes.begin(); ndIt != nodes.end(); ++ndIt) {
        if (!ndIt->parent_resolved) {
            ++no_parent;
        }
    }
    if (!no_parent) {
        throw DeadlyImportError("LWS: Unable to find scene root node");
    }

    // Load all subsequent files
    batch.LoadAll();

    // and build the final output graph by attaching the loaded external
    // files to ourselves. first build a master graph
    aiScene *master = new aiScene();
    aiNode *nd = master->mRootNode = new aiNode();

    // allocate storage for cameras&lights
    if (num_camera) {
        master->mCameras = new aiCamera *[master->mNumCameras = num_camera];
    }
    aiCamera **cams = master->mCameras;
    if (num_light) {
        master->mLights = new aiLight *[master->mNumLights = num_light];
    }
    aiLight **lights = master->mLights;

    std::vector<AttachmentInfo> attach;
    std::vector<aiNodeAnim *> anims;

    nd->mName.Set("<LWSRoot>");
    nd->mChildren = new aiNode *[no_parent];
    for (std::list<LWS::NodeDesc>::iterator ndIt = nodes.begin(); ndIt != nodes.end(); ++ndIt) {
        if (!ndIt->parent_resolved) {
            aiNode *ro = nd->mChildren[nd->mNumChildren++] = new aiNode();
            ro->mParent = nd;

            // ... and build the scene graph. If we encounter object nodes,
            // add then to our attachment table.
            BuildGraph(ro, *ndIt, attach, batch, cams, lights, anims);
        }
    }

    // create a master animation channel for us
    if (anims.size()) {
        master->mAnimations = new aiAnimation *[master->mNumAnimations = 1];
        aiAnimation *anim = master->mAnimations[0] = new aiAnimation();
        anim->mName.Set("LWSMasterAnim");

        // LWS uses seconds as time units, but we convert to frames
        anim->mTicksPerSecond = fps;
        anim->mDuration = last - (first - 1); /* fixme ... zero or one-based?*/

        anim->mChannels = new aiNodeAnim *[anim->mNumChannels = static_cast<unsigned int>(anims.size())];
        std::copy(anims.begin(), anims.end(), anim->mChannels);
    }

    // convert the master scene to RH
    MakeLeftHandedProcess monster_cheat;
    monster_cheat.Execute(master);

    // .. ccw
    FlipWindingOrderProcess flipper;
    flipper.Execute(master);

    // OK ... finally build the output graph
    SceneCombiner::MergeScenes(&pScene, master, attach,
            AI_INT_MERGE_SCENE_GEN_UNIQUE_NAMES | (!configSpeedFlag ? (
                                                                              AI_INT_MERGE_SCENE_GEN_UNIQUE_NAMES_IF_NECESSARY | AI_INT_MERGE_SCENE_GEN_UNIQUE_MATNAMES) :
                                                                      0));

    // Check flags
    if (!pScene->mNumMeshes || !pScene->mNumMaterials) {
        pScene->mFlags |= AI_SCENE_FLAGS_INCOMPLETE;

        if (pScene->mNumAnimations && !noSkeletonMesh) {
            // construct skeleton mesh
            SkeletonMeshBuilder builder(pScene);
        }
    }
}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// code/AssetLib/LWS/LWSLoader.cpp
void LWSImporter::SetupNodeName(aiNode *nd, LWS::NodeDesc &src) {
    const unsigned int combined = src.number | ((unsigned int)src.type) << 28u;

    // the name depends on the type. We break LWS's strange naming convention
    // and return human-readable, but still machine-parsable and unique, strings.
    if (src.type == LWS::NodeDesc::OBJECT) {

        if (src.path.length()) {
            std::string::size_type s = src.path.find_last_of("\\/");
            if (s == std::string::npos) {
                s = 0;
            } else {
                ++s;
            }
            std::string::size_type t = src.path.substr(s).find_last_of('.');

            nd->mName.length = ::ai_snprintf(nd->mName.data, MAXLEN, "%s_(%08X)", src.path.substr(s).substr(0, t).c_str(), combined);
            return;
        }
    }
    nd->mName.length = ::ai_snprintf(nd->mName.data, MAXLEN, "%s_(%08X)", src.name, combined);
}

// the below code fragment can be found in:
// code/AssetLib/LWS/LWSLoader.h
namespace LWS {

// ---------------------------------------------------------------------------
/** Represents an element in a LWS file.
 *
 *  This can either be a single data line - <name> <value> or a data
 *  group - { name <data_line0> ... n }
 */
class Element {
public:
    Element() {}

    // first: name, second: rest
    std::string tokens[2];
    std::list<Element> children;

    //! Recursive parsing function
    void Parse(const char *&buffer);
};

#define AI_LWS_MASK (0xffffffff >> 4u)

// ---------------------------------------------------------------------------
/** Represents a LWS scenegraph element
 */
struct NodeDesc {
    NodeDesc() :
            type(),
            id(),
            number(0),
            parent(0),
            name(),
            isPivotSet(false),
            lightColor(1.f, 1.f, 1.f),
            lightIntensity(1.f),
            lightType(0),
            lightFalloffType(0),
            lightConeAngle(45.f),
            lightEdgeAngle(),
            parent_resolved(nullptr) {}

    enum {

        OBJECT = 1,
        LIGHT = 2,
        CAMERA = 3,
        BONE = 4
    } type; // type of node

    // if object: path
    std::string path;
    unsigned int id;

    // number of object
    unsigned int number;

    // index of parent index
    unsigned int parent;

    // lights & cameras & dummies: name
    const char *name;

    // animation channels
    std::list<LWO::Envelope> channels;

    // position of pivot point
    aiVector3D pivotPos;
    bool isPivotSet;

    // color of light source
    aiColor3D lightColor;

    // intensity of light source
    float lightIntensity;

    // type of light source
    unsigned int lightType;

    // falloff type of light source
    unsigned int lightFalloffType;

    // cone angle of (spot) light source
    float lightConeAngle;

    // soft cone angle of (spot) light source
    float lightEdgeAngle;

    // list of resolved children
    std::list<NodeDesc *> children;

    // resolved parent node
    NodeDesc *parent_resolved;

    // for std::find()
    bool operator==(unsigned int num) const {
        if (!num)
            return false;
        unsigned int _type = num >> 28u;

        return _type == static_cast<unsigned int>(type) && (num & AI_LWS_MASK) == number;
    }
};

} // end namespace LWS

// ---------------------------------------------------------------------------
/** LWS (LightWave Scene Format) importer class.
 *
 *  This class does heavily depend on the LWO importer class. LWS files
 *  contain mainly descriptions how LWO objects are composed together
 *  in a scene.
*/
class LWSImporter : public BaseImporter {
public:
    LWSImporter();
    ~LWSImporter() override;

    // -------------------------------------------------------------------
    // Check whether we can read a specific file
    bool CanRead(const std::string &pFile, IOSystem *pIOHandler,
            bool checkSig) const override;

protected:
    // -------------------------------------------------------------------
    // Get list of supported extensions
    const aiImporterDesc *GetInfo() const override;

    // -------------------------------------------------------------------
    // Import file into given scene data structure
    void InternReadFile(const std::string &pFile, aiScene *pScene,
            IOSystem *pIOHandler) override;

    // -------------------------------------------------------------------
    // Setup import properties
    void SetupProperties(const Importer *pImp) override;

private:
    // -------------------------------------------------------------------
    // Read an envelope description
    void ReadEnvelope(const LWS::Element &dad, LWO::Envelope &out);

    // -------------------------------------------------------------------
    // Read an envelope description for the older LW file format
    void ReadEnvelope_Old(std::list<LWS::Element>::const_iterator &it,
            const std::list<LWS::Element>::const_iterator &end,
            LWS::NodeDesc &nodes,
            unsigned int version);

    // -------------------------------------------------------------------
    // Setup a nice name for a node
    void SetupNodeName(aiNode *nd, LWS::NodeDesc &src);

    // -------------------------------------------------------------------
    // Recursively build the scenegraph
    void BuildGraph(aiNode *nd,
            LWS::NodeDesc &src,
            std::vector<AttachmentInfo> &attach,
            BatchLoader &batch,
            aiCamera **&camOut,
            aiLight **&lightOut,
            std::vector<aiNodeAnim *> &animOut);

    // -------------------------------------------------------------------
    // Try several dirs until we find the right location of a LWS file.
    std::string FindLWOFile(const std::string &in);

private:
    bool configSpeedFlag;
    IOSystem *io;
    double first, last, fps;
    bool noSkeletonMesh;
};

}

// the below code fragment can be found in:
// code/AssetLib/LWS/LWSLoader.cpp
void LWSImporter::ReadEnvelope_Old(
        std::list<LWS::Element>::const_iterator &it,
        const std::list<LWS::Element>::const_iterator &end,
        LWS::NodeDesc &nodes,
        unsigned int /*version*/) {
    unsigned int num, sub_num;
    if (++it == end) goto unexpected_end;

    num = strtoul10((*it).tokens[0].c_str());
    for (unsigned int i = 0; i < num; ++i) {

        nodes.channels.push_back(LWO::Envelope());
        LWO::Envelope &envl = nodes.channels.back();

        envl.index = i;
        envl.type = (LWO::EnvelopeType)(i + 1);

        if (++it == end) {
            goto unexpected_end;
        }
        sub_num = strtoul10((*it).tokens[0].c_str());

        for (unsigned int n = 0; n < sub_num; ++n) {

            if (++it == end) goto unexpected_end;

            // parse value and time, skip the rest for the moment.
            LWO::Key key;
            const char *c = fast_atoreal_move<float>((*it).tokens[0].c_str(), key.value);
            SkipSpaces(&c);
            float f;
            fast_atoreal_move<float>((*it).tokens[0].c_str(), f);
            key.time = f;

            envl.keys.push_back(key);
        }
    }
    return;

unexpected_end:
    ASSIMP_LOG_ERROR("LWS: Encountered unexpected end of file while parsing object motion");
}

// the below code fragment can be found in:
// code/AssetLib/LWS/LWSLoader.cpp
std::string LWSImporter::FindLWOFile(const std::string &in) {
    // insert missing directory separator if necessary
    std::string tmp(in);
    if (in.length() > 3 && in[1] == ':' && in[2] != '\\' && in[2] != '/') {
        tmp = in[0] + (std::string(":\\") + in.substr(2));
    }

    if (io->Exists(tmp)) {
        return in;
    }

    // file is not accessible for us ... maybe it's packed by
    // LightWave's 'Package Scene' command?

    // Relevant for us are the following two directories:
    // <folder>\Objects\<hh>\<*>.lwo
    // <folder>\Scenes\<hh>\<*>.lws
    // where <hh> is optional.

    std::string test = std::string("..") + (io->getOsSeparator() + tmp);
    if (io->Exists(test)) {
        return test;
    }

    test = std::string("..") + (io->getOsSeparator() + test);
    if (io->Exists(test)) {
        return test;
    }

    // return original path, maybe the IOsystem knows better
    return tmp;
}

// the below code fragment can be found in:
// code/AssetLib/LWS/LWSLoader.cpp
LWSImporter::LWSImporter() :
        configSpeedFlag(),
        io(),
        first(),
        last(),
        fps(),
        noSkeletonMesh() {
    // nothing to do here
}
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).