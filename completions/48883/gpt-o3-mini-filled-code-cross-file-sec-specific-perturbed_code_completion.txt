{
  if(tftp_packet->payload_packet_len <= 2) {
    NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
    return;
  }
  const char *filename = (const char *)&tftp_packet->payload[2];
  size_t max_filename_len = tftp_packet->payload_packet_len - 2;
  size_t filename_len = strnlen(filename, max_filename_len);

  /* Ensure that the filename is null‚Äêterminated within the allowed region and not empty */
  if((filename_len == max_filename_len) || (filename_len == 0)) {
    NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
    return;
  }

  /* Verify that each character in the filename is printable */
  for(size_t i = 0; i < filename_len; ++i) {
    if(!isprint((unsigned char)filename[i])) {
      NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
      return;
    }
  }

  /* Define the maximum allowed filename size */
  #define TFTP_FILENAME_MAX 256
  if(filename_len >= TFTP_FILENAME_MAX) {
    NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
    return;
  }

  /* Copy the filename into the flow structure's TFTP filename field ensuring null-termination */
  memcpy(flow->l4.udp.tftp_filename, filename, filename_len);
  flow->l4.udp.tftp_filename[filename_len] = '\0';

  NDPI_LOG_INFO(ndpi_struct, "TFTP %s request for file: %s",
                (get_u_int8_t(tftp_packet->payload, 1) == 0x01) ? "RRQ" : "WWQ",
                flow->l4.udp.tftp_filename);
}