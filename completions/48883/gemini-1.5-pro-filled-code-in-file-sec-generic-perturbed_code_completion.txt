size_t filename_len = tftp_packet->payload_packet_len - 1 - mode_len - 2; // Subtract opcode, mode, and two null terminators

          if (filename_len == 0 || filename_len > 255) { // Check for reasonable filename length
            NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
            return;
          }

          for (size_t i = 2; i < filename_len + 2; ++i) {
            if (!isprint(tftp_packet->payload[i])) {
              NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
              return;
            }
          }

          // Ensure flow->ndpi_protocol_info.tftp.filename has enough space
          if (flow->ndpi_protocol_info.tftp.filename == NULL) {
            flow->ndpi_protocol_info.tftp.filename = (char *)ndpi_malloc(ndpi_struct, filename_len + 1);
            if (flow->ndpi_protocol_info.tftp.filename == NULL) {
              NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
              return;
            }
          } else if (strlen(flow->ndpi_protocol_info.tftp.filename) < filename_len) {
            char *new_filename = (char *)ndpi_realloc(ndpi_struct, flow->ndpi_protocol_info.tftp.filename, filename_len + 1);
            if (new_filename == NULL) {
              NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
              return;
            }
            flow->ndpi_protocol_info.tftp.filename = new_filename;
          }

          strncpy(flow->ndpi_protocol_info.tftp.filename, (const char *)&tftp_packet->payload[2], filename_len);
          flow->ndpi_protocol_info.tftp.filename[filename_len] = '\0';

          NDPI_LOG_INFO(ndpi_struct, "found TFTP RRQ/WRQ, filename: %s\n", flow->ndpi_protocol_info.tftp.filename);
          ndpi_int_tftp_add_connection(ndpi_struct, flow);