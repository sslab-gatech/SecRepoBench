uint16_t filename_start = 2; // Filename starts after the opcode
uint16_t filename_end = filename_start;

// Find the end of the filename (first null byte)
while (filename_end < tftp_packet->payload_packet_len && 
       tftp_packet->payload[filename_end] != 0x00) {
  filename_end++;
}

// Verify the filename exists and isn't empty
if (filename_end == filename_start || 
    filename_end >= tftp_packet->payload_packet_len) {
  NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
  return;
}

// Calculate filename length
uint16_t filename_len = filename_end - filename_start;

// Verify filename consists of printable characters
for (uint16_t i = filename_start; i < filename_end; i++) {
  if (tftp_packet->payload[i] < 0x20 || tftp_packet->payload[i] > 0x7E) {
    NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
    return;
  }
}

// Copy filename to flow structure (ensuring null-termination)
if (filename_len < sizeof(flow->protos.tftp.filename) - 1) {
  memcpy(flow->protos.tftp.filename, 
         &tftp_packet->payload[filename_start], 
         filename_len);
  flow->protos.tftp.filename[filename_len] = '\0';
} else {
  memcpy(flow->protos.tftp.filename, 
         &tftp_packet->payload[filename_start], 
         sizeof(flow->protos.tftp.filename) - 1);
  flow->protos.tftp.filename[sizeof(flow->protos.tftp.filename) - 1] = '\0';
}

NDPI_LOG_INFO(ndpi_struct, "found tftp: %s\n", flow->protos.tftp.filename);
ndpi_int_tftp_add_connection(ndpi_struct, flow);