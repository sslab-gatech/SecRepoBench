size_t filename_len = 0;

// Ensure there is enough payload to extract the filename.
if (tftp_packet->payload_packet_len < 3) {
  NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
  return;
}

// Determine the length of the filename by finding the first null terminator after the opcode and mode.
for (filename_len = 2; filename_len < tftp_packet->payload_packet_len - mode_len - 1; ++filename_len) {
  if (tftp_packet->payload[filename_len] == 0x00) {
    break;
  }
}

// Ensure that the filename ends with a null terminator and consists of printable characters.
if (filename_len >= tftp_packet->payload_packet_len - mode_len - 1 || 
    !is_printable_string((const char *)tftp_packet->payload + 2, filename_len)) {
  NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
  return;
}

// Copy the filename into the flow structure's TFTP filename field, ensuring null-termination.
if (flow->l4.udp.tftp_filename != NULL) {
  free(flow->l4.udp.tftp_filename);
}
flow->l4.udp.tftp_filename = malloc(filename_len + 1);
if (flow->l4.udp.tftp_filename == NULL) {
  NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
  return;
}
memcpy(flow->l4.udp.tftp_filename, &tftp_packet->payload[2], filename_len);
flow->l4.udp.tftp_filename[filename_len] = '\0';

NDPI_LOG_INFO(ndpi_struct, "detected TFTP RRQ/WWQ packet with filename: %s\n", flow->l4.udp.tftp_filename);

// Add the connection to the flow.
ndpi_int_tftp_add_connection(ndpi_struct, flow);