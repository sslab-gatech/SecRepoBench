size_t filename_len = 0;

// Determine the length of the filename
for (filename_len = 2; filename_len < tftp_packet->payload_packet_len - mode_len - 1; ++filename_len) {
    if (tftp_packet->payload[filename_len] == 0x00) {
        break;
    }
}

// Verify the filename is present and consists of printable characters
if (filename_len <= 2 || filename_len >= tftp_packet->payload_packet_len - mode_len - 1) {
    NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
    return;
}

// Ensure all characters in the filename are printable ASCII
for (size_t i = 2; i < filename_len; ++i) {
    if (!isprint(tftp_packet->payload[i]) || tftp_packet->payload[i] == 0x00) {
        NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
        return;
    }
}

// Copy the filename into the flow structure's TFTP filename field, ensuring null-termination
if (flow->l4.udp.tftp_filename != NULL) {
    ndpi_free(flow->l4.udp.tftp_filename);
}
flow->l4.udp.tftp_filename = (char *)ndpi_malloc(filename_len + 1);
if (flow->l4.udp.tftp_filename == NULL) {
    NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
    return;
}
memcpy(flow->l4.udp.tftp_filename, &tftp_packet->payload[2], filename_len);
flow->l4.udp.tftp_filename[filename_len] = '\0';

// Log the detection of a TFTP RRQ/WWQ packet and add the connection to the flow
NDPI_LOG_INFO(ndpi_struct, "found TFTP RRQ/WWQ with filename: %s\n", flow->l4.udp.tftp_filename);
ndpi_int_tftp_add_connection(ndpi_struct, flow);