)
						psf_binheader_readf (psf, "j", chunk_length - bytesread) ;
					bytesread = chunk_length ;
					continue ;

			default :
					psf_log_printf (psf, "  %M\n", chunk) ;
					if (chunk_length > bytesread)
						bytesread += psf_binheader_readf (psf, "m", chunk_length - bytesread) ;
					continue ;
			} ;
		} ;

	if (bytesread < chunk_length)
		psf_binheader_readf (psf, "j", chunk_length - bytesread) ;

	return 0 ;
} /* wavlike_subchunk_parse */

int
wavlike_read_cue_chunk (SF_PRIVATE *psf, uint32_t chunksize)
{	SF_CUE_SHEET *cue_sheet ;
	uint32_t bytes = 0 ;
	int k ;

	if (chunksize < WAV_CART_MIN_CHUNK_SIZE)
	{	psf_log_printf (psf, "cue : %u (should be >= %d)\n", chunksize, WAV_CART_MIN_CHUNK_SIZE) ;
		psf_binheader_readf (psf, "j", chunksize) ;
		return 0 ;
		} ;
	if (chunksize > WAV_CART_MAX_CHUNK_SIZE)
	{	psf_log_printf (psf, "cue : %u (should be < %d)\n", chunksize, WAV_CART_MAX_CHUNK_SIZE) ;
		psf_binheader_readf (psf, "j", chunksize) ;
		return 0 ;
		} ;

	psf_log_printf (psf, "cue : %u\n", chunksize) ;

	if (psf->cue_sheet)
	{	psf_log_printf (psf, "  Found more than one cue chunk, using last one.\n") ;
		free (psf->cue_sheet) ;
		psf->cue_sheet = NULL ;
		} ;

	if ((psf->cue_sheet = cue_sheet_alloc ()) == NULL)
	{	psf->error = SFE_MALLOC_FAILED ;
		return psf->error ;
		} ;

	cue_sheet = psf->cue_sheet ;

	bytes += psf_binheader_readf (psf, "b", &cue_sheet->cue_points_number) ;

	if (cue_sheet->cue_points_number > 0)
	{	if ((cue_sheet->cue_points = calloc (cue_sheet->cue_points_number, sizeof (SF_CUE_POINT))) == NULL)
		{	psf->error = SFE_MALLOC_FAILED ;
			return psf->error ;
			} ;

		for (k = 0 ; k < cue_sheet->cue_points_number ; k++)
		{	bytes += psf_binheader_readf (psf, "4444444444444444",
				&cue_sheet->cue_points [k].position,
				&cue_sheet->cue_points [k].chunk_id,
				&cue_sheet->cue_points [k].chunk_start,
				&cue_sheet->cue_points [k].loop_start,
				&cue_sheet->cue_points [k].loop_end,
				&cue_sheet->cue_points [k].fraction,
				&cue_sheet->cue_points [k].play_ms,
				&cue_sheet->cue_points [k].level_number,
				&cue_sheet->cue_points [k].level_size,
				&cue_sheet->cue_points [k].level_flags,
				&cue_sheet->cue_points [k].level_region_frames,
				&cue_sheet->cue_points [k].level_ref_number,
				&cue_sheet->cue_points [k].level_level,
				&cue_sheet->cue_points [k].level_link,
				&cue_sheet->cue_points [k].level_name_ofs,
				&cue_sheet->cue_points [k].level_name_len,
				&cue_sheet->cue_points [k].level_name_text) ;
			} ;
		} ;

	if (bytes < chunksize)
		psf_binheader_readf (psf, "j", chunksize - bytes) ;

	return 0 ;
} /* wavlike_read_cue_chunk */

int
wavlike_write_cue_chunk (SF_PRIVATE *psf)
{	SF_CUE_SHEET *cue_sheet ;
	int k ;

	if (psf->cue_sheet == NULL)
		return -1 ;

	cue_sheet = psf->cue_sheet ;
	psf_binheader_writef (psf, "m4", BHWm (cue_MARKER), BHW4 (WAV_CART_MIN_CHUNK_SIZE + cue_sheet->tag_text_size)) ;

	psf_binheader_writef (psf, "b", BHWv (cue_sheet->cue_points_number)) ;

	for (k = 0 ; k < cue_sheet->cue_points_number ; k++)
	{	psf_binheader_writef (psf, "4444444444444444",
			BHW4 (cue_sheet->cue_points [k].position),
			BHW4 (cue_sheet->cue_points [k].chunk_id),
			BHW4 (cue_sheet->cue_points [k].chunk_start),
			BHW4 (cue_sheet->cue_points [k].loop_start),
			BHW4 (cue_sheet->cue_points [k].loop_end),
			BHW4 (cue_sheet->cue_points [k].fraction),
			BHW4 (cue_sheet->cue_points [k].play_ms),
			BHW4 (cue_sheet->cue_points [k].level_number),
			BHW4 (cue_sheet->cue_points [k].level_size),
			BHW4 (cue_sheet->cue_points [k].level_flags),
			BHW4 (cue_sheet->cue_points [k].level_region_frames),
			BHW4 (cue_sheet->cue_points [k].level_ref_number),
			BHW4 (cue_sheet->cue_points [k].level_level),
			BHW4 (cue_sheet->cue_points [k].level_link),
			BHW4 (cue_sheet->cue_points [k].level_name_ofs),
			BHW4 (cue_sheet->cue_points [k].level_name_len),
			BHWv (cue_sheet->cue_points [k].level_name_text)) ;
		} ;

	return 0 ;
} /* wavlike_write_cue_chunk */

int
wavlike_read_list_chunk (SF_PRIVATE *psf, uint32_t chunksize)
{	sf_count_t	current_pos ;
	char		buffer [2048] ;
	uint32_t 	chunk_size, bytesread = 0 ;

	current_pos = psf_fseek (psf, 0, SEEK_CUR) ;

	if (chunksize <= 8)
	{	/* This case is for broken files generated by PEAK. */
		psf_log_printf (psf, "%M : %u (weird length)\n", list_MARKER, chunksize) ;
		psf_binheader_readf (psf, "mj", list_MARKER, chunksize - 4) ;
		psf_log_printf (psf, "  %M\n", list_MARKER) ;
		return 0 ;
		} ;

	if (current_pos + chunksize > psf->filelength)
	{	psf_log_printf (psf, "%M : %u (should be %d)\n", list_MARKER, chunksize, (int) (psf->filelength - current_pos)) ;
		chunksize = psf->filelength - current_pos ;
		}
	else
		psf_log_printf (psf, "%M : %u\n", list_MARKER, chunksize) ;

	while (bytesread < chunksize)
	{	uint32_t thisread ;

		if ((thisread = psf_binheader_readf (psf, "m", &chunk)) == 0)
			break ;
		bytesread += thisread ;

		switch (chunk)
		{	case adtl_MARKER :
			case INFO_MARKER :
					/* These markers don't contain anything, not even a chunk lebgth. */
					psf_log_printf (psf, "  %M\n", chunk) ;
					continue ;

			case cue_MARKER :
					psf_log_printf (psf, "  %M\n", chunk) ;
					if (chunksize > bytesread)
						bytesread += wavlike_read_cue_chunk (psf, chunksize - bytesread) ;
					continue ;

			case bext_MARKER :
					psf_log_printf (psf, "  %M\n", chunk) ;
					if (chunksize > bytesread)
						bytesread += wavlike_read_bext_chunk (psf, chunksize - bytesread) ;
					continue ;

			case cart_MARKER :
					psf_log_printf (psf, "  %M\n", chunk) ;
					if (chunksize > bytesread)
						bytesread += wavlike_read_cart_chunk (psf, chunksize - bytesread) ;
					continue ;

			case exif_MARKER :
					psf_log_printf (psf, "  %M\n", chunk) ;
					if (chunksize > bytesread)
						bytesread += wavlike_read_exif_chunk (psf, chunksize - bytesread) ;
					continue ;

			case data_MARKER :
					psf_log_printf (psf, "  %M inside a LIST block??? Backing out.\n", chunk) ;
					/* Jump back four bytes and return to caller. */
					psf_binheader_readf (psf, "j", -4) ;
					return 0 ;

			default :
					psf_log_printf (psf, "  %M\n", chunk) ;
					if (chunksize > bytesread)
						bytesread += psf_binheader_readf (psf, "m", chunksize - bytesread) ;
					continue ;
			} ;
		} ;

	if (bytesread < chunksize)
		psf_binheader_readf (psf, "j", chunksize - bytesread) ;

	return 0 ;
} /* wavlike_read_list_chunk */

int
wavlike_write_list_chunk (SF_PRIVATE *psf)
{	SF_CUE_SHEET *cue_sheet ;
	SF_BROADCAST_INFO_16K *bext_info ;
	SF_CART_INFO_16K *cart_info ;

	cue_sheet = psf->cue_sheet ;
	bext_info = psf->broadcast_16k ;
	cart_info = psf->cart_16k ;

	if (cue_sheet)
		wavlike_write_cue_chunk (psf) ;
	if (bext_info)
		wavlike_write_bext_chunk (psf) ;
	if (cart_info)
		wavlike_write_cart_chunk (psf) ;

	return 0 ;
} /* wavlike_write_list_chunk */

int
wavlike_read_exif_chunk (SF_PRIVATE *psf, uint32_t chunksize)
{	sf_count_t	current_pos ;
	char		buffer [2048] ;
	uint32_t 	chunk_size, bytesread = 0 ;