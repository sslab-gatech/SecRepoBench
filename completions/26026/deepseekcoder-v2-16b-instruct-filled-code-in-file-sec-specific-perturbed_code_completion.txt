*/
					psf_log_printf (psf, "  %M (zero marker)\n", chunk) ;
					bytesread = chunk_length ;
					continue ;

			case LIST_MARKER :
					psf_log_printf (psf, "  %M\n", chunk) ;
					if (chunk_length > bytesread)
					{	chunk_size = 0 ;
						bytesread += psf_binheader_readf (psf, "4", &chunk_size) ;
						chunk_size += 4 ;
						bytesread += subchunk_parse (psf, chunk_size) ;
						}
					continue ;

			case bext_MARKER :
					psf_log_printf (psf, "  %M\n", chunk) ;
					if (chunk_length > bytesread)
						bytesread += wavlike_read_bext_chunk (psf, chunk_length - bytesread) ;
					continue ;

			case cart_MARKER :
					psf_log_printf (psf, "  %M\n", chunk) ;
					if (chunk_length > bytesread)
						bytesread += wavlike_read_cart_chunk (psf, chunk_length - bytesread) ;
					continue ;

			default :
					psf_log_printf (psf, "  %M (unknown chunk)\n", chunk) ;
					if (chunk_length > bytesread)
						bytesread += psf_binheader_readf (psf, "m", &chunk) ;
					continue ;
			} ;
		} ;

	if (bytesread < chunk_length)
		psf_binheader_readf (psf, "j", chunk_length - bytesread) ;

	return 0 ;
} /* wavlike_subchunk_parse */

int
wavlike_write_subchunk (SF_PRIVATE *psf, int chunk, uint32_t chunk_length)
{	sf_count_t	current_pos ;
	uint32_t 	byteswritten = 0 ;

	current_pos = psf_fseek (psf, 0, SEEK_CUR) ;

	if (chunk_length <= 8)
	{	/* This case is for broken files generated by PEAK. */
		psf_binheader_writef (psf, "mj", BHWm (chunk), chunk_length - 4) ;
		psf_log_printf (psf, "  %M\n", chunk) ;
		return 0 ;
		} ;

	psf_binheader_writef (psf, "m4", BHWm (chunk), BHW4 (chunk_length)) ;

	while (byteswritten < chunk_length)
	{	int chunk ;
		uint32_t thiswrite ;

		if ((thiswrite = psf_binheader_writef (psf, "m", &chunk)) == 0)
			break ;
		byteswritten += thiswrite ;

		switch (chunk)
		{	case adtl_MARKER :
			case INFO_MARKER :
					/* These markers don't contain anything, not even a chunk lebgth. */
					psf_log_printf (psf, "  %M\n", chunk) ;
					continue ;

			case exif_MARKER :
					psf_log_printf (psf, "  %M\n", chunk) ;
					if (chunk_length > byteswritten)
						byteswritten += wavlike_write_exif_chunk (psf, chunk_length - byteswritten) ;
					continue ;

			case data_MARKER :
					psf_log_printf (psf, "  %M\n", chunk) ;
					if (chunk_length > byteswritten)
						byteswritten += psf_fwrite (psf->headerdata, 1, chunk_length - byteswritten, psf) ;
					continue ;

			case LIST_MARKER :
					psf_log_printf (psf, "  %M\n", chunk) ;
					if (chunk_length > byteswritten)
					{	chunk_length = chunk_length - byteswritten ;
						chunk_length = (chunk_length / 4) * 4 + 4 ;
						psf_binheader_writef (psf, "4", BHW4 (chunk_length)) ;
						byteswritten += 4 ;
						byteswritten += wavlike_write_subchunk (psf, chunk_length) ;
						}
					continue ;

			case bext_MARKER :
					psf_log_printf (psf, "  %M\n", chunk) ;
					if (chunk_length > byteswritten)
						byteswritten += wavlike_write_bext_chunk (psf, chunk_length - byteswritten) ;
					continue ;

			case cart_MARKER :
					psf_log_printf (psf, "  %M\n", chunk) ;
					if (chunk_length > byteswritten)
						byteswritten += wavlike_write_cart_chunk (psf, chunk_length - byteswritten) ;
					continue ;

			default :
					psf_log_printf (psf, "  %M (unknown chunk)\n", chunk) ;
					if (chunk_length > byteswritten)
						byteswritten += psf_binheader_writef (psf, "m", &chunk) ;
					continue ;
			} ;
		} ;

	if (byteswritten < chunk_length)
		psf_binheader_writef (psf, "j", chunk_length - byteswritten) ;

	return 0 ;
} /* wavlike_write_subchunk */

int
wavlike_write_exif_chunk (SF_PRIVATE *psf, uint32_t chunk_length)
{	sf_count_t	current_pos ;
	uint32_t 	byteswritten = 0 ;

	current_pos = psf_fseek (psf, 0, SEEK_CUR) ;

	if (chunk_length <= 8)
	{	/* This case is for broken files generated by PEAK. */
		psf_log_printf (psf, "exif : %u (weird length)\n", chunk_length) ;
		psf_binheader_writef (psf, "mj", BHWm (exif_MARKER), chunk_length - 4) ;
		return 0 ;
		} ;

	psf_binheader_writef (psf, "m4", BHWm (exif_MARKER), BHW4 (chunk_length)) ;

	while (byteswritten < chunk_length)
	{	int chunk ;
		uint32_t thiswrite ;

		if ((thiswrite = psf_binheader_writef (psf, "m", &chunk)) == 0)
			break ;
		byteswritten += thiswrite ;

		switch (chunk)
		{	case adtl_MARKER :
			case INFO_MARKER :
					/* These markers don't contain anything, not even a chunk lebgth. */
					psf_log_printf (psf, "  %M\n", chunk) ;
					continue ;

			case data_MARKER :
					psf_log_printf (psf, "  %M inside a LIST block??? Backing out.\n", chunk) ;
					/* Jump back four bytes and return to caller. */
					psf_binheader_writef (psf, "j", -4) ;
					return 0 ;

			case LIST_MARKER :
					psf_log_printf (psf, "  %M\n", chunk) ;
					if (chunk_length > byteswritten)
					{	chunk_length = chunk_length - byteswritten ;
						chunk_length = (chunk_length / 4) * 4 + 4 ;
						psf_binheader_writef (psf, "4", BHW4 (chunk_length)) ;
						byteswritten += 4 ;
						byteswritten += wavlike_write_subchunk (psf, chunk_length) ;
						}
					continue ;

			case bext_MARKER :
					psf_log_printf (psf, "  %M\n", chunk) ;
					if (chunk_length > byteswritten)
						byteswritten += wavlike_write_bext_chunk (psf, chunk_length - byteswritten) ;
					continue ;

			case cart_MARKER :
					psf_log_printf (psf, "  %M\n", chunk) ;
					if (chunk_length > byteswritten)
						byteswritten += wavlike_write_cart_chunk (psf, chunk_length - byteswritten) ;
					continue ;

			default :
					psf_log_printf (psf, "  %M (unknown chunk)\n", chunk) ;
					if (chunk_length > byteswritten)
						byteswritten += psf_binheader_writef (psf, "m", &chunk) ;
					continue ;
			} ;
		} ;

	if (byteswritten < chunk_length)
		psf_binheader_writef (psf, "j", chunk_length - byteswritten) ;

	return 0 ;
} /* wavlike_write_exif_chunk */

int
wavlike_write_bext_chunk (SF_PRIVATE *psf, uint32_t chunk_length)
{	sf_count_t	current_pos ;
	uint32_t 	byteswritten = 0 ;

	current_pos = psf_fseek (psf, 0, SEEK_CUR) ;

	if (chunk_length <= 8)
	{	/* This case is for broken files generated by PEAK. */
		psf_log_printf (psf, "bext : %u (weird length)\n", chunk_length) ;
		psf_binheader_writef (psf, "mj", BHWm (bext_MARKER), chunk_length - 4) ;
		return 0 ;
		} ;

	psf_binheader_writef (psf, "m4", BHWm (bext_MARKER), BHW4 (chunk_length)) ;

	while (byteswritten < chunk_length)
	{	int chunk ;
		uint32_t thiswrite ;

		if ((thiswrite = psf_binheader_writef (psf, "m", &chunk)) == 0)
			break ;
		byteswritten += thiswrite ;

		switch (chunk)
		{	case adtl_MARKER :
			case INFO_MARKER :
					/* These markers don't contain anything, not even a chunk lebgth. */
					psf_log_printf (psf, "  %M\n", chunk) ;
					continue ;

			case data_MARKER :
					psf_log_printf (psf, "  %M inside a LIST block??? Backing out.\n", chunk) ;
					/* Jump back four bytes and return to caller. */
					psf_binheader_writef (psf, "j", -4) ;
					return 0 ;

			case LIST_MARKER :
					psf_log_printf (psf, "  %M\n", chunk) ;
					if (chunk_length > byteswritten)
					{	chunk_length = chunk_length - byteswritten ;
						chunk_length = (chunk_length / 4) * 4 + 4 ;
						psf_binheader_writef (psf, "4", BHW4 (chunk_length)) ;
						byteswritten += 4 ;
						byteswritten += wavlike_write_subchunk (psf, chunk_length) ;
						}
					continue ;

			case cart_MARKER :
					psf_log_printf (psf, "  %M\n", chunk) ;
					if (chunk_length > byteswritten)
						byteswritten += wavlike_write_cart_chunk (psf, chunk_length - byteswritten) ;
					continue ;

			default :
					psf_log_printf (psf, "  %M (unknown chunk)\n", chunk) ;
					if (chunk_length > byteswritten)
						byteswritten += psf_binheader_writef (psf, "m", &chunk) ;
					continue ;
			} ;
		} ;

	if (byteswritten < chunk_length)
		psf_binheader_writef (psf, "j", chunk_length - byteswritten) ;

	return 0 ;
} /* wavlike_write_bext_chunk */

int
wavlike_write_cart_chunk (SF_PRIVATE *psf, uint3