chunk_length - bytesread) ;
					continue ;

			default :
					psf_log_printf (psf, "  %M\n", chunk) ;
					if (chunk_length > bytesread)
						bytesread += psf_binheader_readf (psf, "mj", &chunk, chunk_length - bytesread) ;
					continue ;
			} ;
		} ;

	if (bytesread < chunk_length)
		psf_binheader_readf (psf, "j", chunk_length - bytesread) ;

	return 0 ;
} /* wavlike_subchunk_parse */

int
wavlike_read_cue_chunk (SF_PRIVATE *psf, uint32_t chunksize)
{	SF_CUE_SHEET *cue_sheet ;
	uint32_t bytes = 0 ;
	int k ;

	if (chunksize < WAV_CART_MIN_CHUNK_SIZE)
	{	psf_log_printf (psf, "cue : %u (should be >= %d)\n", chunksize, WAV_CART_MIN_CHUNK_SIZE) ;
		psf_binheader_readf (psf, "j", chunksize) ;
		return 0 ;
		} ;
	if (chunksize > WAV_CART_MAX_CHUNK_SIZE)
	{	psf_log_printf (psf, "cue : %u (should be < %d)\n", chunksize, WAV_CART_MAX_CHUNK_SIZE) ;
		psf_binheader_readf (psf, "j", chunksize) ;
		return 0 ;
		} ;

	psf_log_printf (psf, "cue : %u\n", chunksize) ;

	if (psf->cue_sheet)
	{	psf_log_printf (psf, "  Found more than one cue chunk, using last one.\n") ;
		free (psf->cue_sheet) ;
		psf->cue_sheet = NULL ;
		} ;

	if ((psf->cue_sheet = cue_sheet_alloc ()) == NULL)
	{	psf->error = SFE_MALLOC_FAILED ;
		return psf->error ;
		} ;

	cue_sheet = psf->cue_sheet ;

	bytes += psf_binheader_readf (psf, "b", &cue_sheet->cue_points, sizeof (cue_sheet->cue_points)) ;
	bytes += psf_binheader_readf (psf, "b", &cue_sheet->type, sizeof (cue_sheet->type)) ;
	bytes += psf_binheader_readf (psf, "b", &cue_sheet->number_of_indices, sizeof (cue_sheet->number_of_indices)) ;

	for (k = 0 ; k < cue_sheet->number_of_indices ; k++)
	{	bytes += psf_binheader_readf (psf, "442", &cue_sheet->indices [k].position, &cue_sheet->indices [k].number, &cue_sheet->indices [k].size) ;
		bytes += psf_binheader_readf (psf, "b", &cue_sheet->indices [k].name, sizeof (cue_sheet->indices [k].name)) ;
		} ;

	if (bytes < chunksize)
		psf_binheader_readf (psf, "j", chunksize - bytes) ;

	return 0 ;
} /* wavlike_read_cue_chunk */

int
wavlike_write_cue_chunk (SF_PRIVATE *psf)
{	SF_CUE_SHEET *cue_sheet ;
	int k ;

	if (psf->cue_sheet == NULL)
		return -1 ;

	cue_sheet = psf->cue_sheet ;
	psf_binheader_writef (psf, "m4", BHWm (cue_MARKER), BHW4 (WAV_CART_MIN_CHUNK_SIZE + cue_sheet->total_size)) ;
	psf_binheader_writef (psf, "b", BHWv (&cue_sheet->cue_points), BHWz (sizeof (cue_sheet->cue_points))) ;
	psf_binheader_writef (psf, "b", BHWv (&cue_sheet->type), BHWz (sizeof (cue_sheet->type))) ;
	psf_binheader_writef (psf, "b", BHWv (&cue_sheet->number_of_indices), BHWz (sizeof (cue_sheet->number_of_indices))) ;

	for (k = 0 ; k < cue_sheet->number_of_indices ; k++)
	{	psf_binheader_writef (psf, "442", BHW4 (cue_sheet->indices [k].position), BHW2 (cue_sheet->indices [k].number), BHW2 (cue_sheet->indices [k].size)) ;
		psf_binheader_writef (psf, "b", BHWv (cue_sheet->indices [k].name), BHWz (sizeof (cue_sheet->indices [k].name))) ;
		} ;

	return 0 ;
} /* wavlike_write_cue_chunk */

int
wavlike_read_list_chunk (SF_PRIVATE *psf, uint32_t chunksize)
{	sf_count_t	current_pos ;
	char		buffer [2048] ;
	uint32_t 	chunk_size, bytesread = 0 ;

	current_pos = psf_fseek (psf, 0, SEEK_CUR) ;

	if (chunksize < 8)
	{	psf_log_printf (psf, "list : %u (should be >= 8)\n", chunksize) ;
		psf_binheader_readf (psf, "mj", 0, chunksize) ;
		return 0 ;
		} ;

	if (current_pos + chunksize > psf->filelength)
	{	psf_log_printf (psf, "list : %u (should be <= %d)\n", chunksize, (int) (psf->filelength - current_pos)) ;
		chunksize = psf->filelength - current_pos ;
		}
	else
		psf_log_printf (psf, "list : %u\n", chunksize) ;

	while (bytesread < chunksize)
	{	uint32_t thisread ;

		if ((thisread = psf_binheader_readf (psf, "m", &chunk)) == 0)
			break ;
		bytesread += thisread ;

		switch (chunk)
		{	case adtl_MARKER :
			case INFO_MARKER :
			case exif_MARKER :
			case data_MARKER :
					/* These markers don't contain anything, not even a chunk length. */
					psf_log_printf (psf, "  %M\n", chunk) ;
					continue ;

			default :
					psf_log_printf (psf, "  %M\n", chunk) ;
					if (chunksize > bytesread)
						bytesread += psf_binheader_readf (psf, "mj", &chunk, chunksize - bytesread) ;
					continue ;
			} ;
		} ;

	if (bytesread < chunksize)
		psf_binheader_readf (psf, "j", chunksize - bytesread) ;

	return 0 ;
} /* wavlike_read_list_chunk */

int
wavlike_write_list_chunk (SF_PRIVATE *psf, int chunk)
{	psf_binheader_writef (psf, "m4", BHWm (list_MARKER), BHW4 (4)) ;
	psf_binheader_writef (psf, "m", BHWm (chunk)) ;
	return 0 ;
} /* wavlike_write_list_chunk */

int
wavlike_read_cue_point (SF_PRIVATE *psf, uint32_t chunksize)
{	SF_CUE_POINT *cue_point ;
	uint32_t bytes = 0 ;

	if (chunksize < sizeof (SF_CUE_POINT))
	{	psf_log_printf (psf, "cue point : %u (should be >= %d)\n", chunksize, (int) sizeof (SF_CUE_POINT)) ;
		psf_binheader_readf (psf, "mj", 0, chunksize) ;
		return 0 ;
		} ;

	if (chunksize > 0xFFFFFFFF)
	{	psf_log_printf (psf, "cue point : %u (should be < %d)\n", chunksize, 0xFFFFFFFF) ;
		psf_binheader_readf (psf, "mj", 0, chunksize) ;
		return 0 ;
		} ;

	psf_log_printf (psf, "cue point : %u\n", chunksize) ;

	if (psf->cue_point)
	{	psf_log_printf (psf, "  Found more than one cue point, using last one.\n") ;
		free (psf->cue_point) ;
		psf->cue_point = NULL ;
		} ;

	if ((psf->cue_point = cue_point_alloc ()) == NULL)
	{	psf->error = SFE_MALLOC_FAILED ;
		return psf->error ;
		} ;

	cue_point = psf->cue_point ;

	bytes += psf_binheader_readf (psf, "442", &cue_point->position, &cue_point->number, &cue_point->size) ;
	bytes += psf_binheader_readf (psf, "b", &cue_point->name, sizeof (cue_point->name)) ;

	if (bytes < chunksize)
		psf_binheader_readf (psf, "j", chunksize - bytes) ;

	return 0 ;
} /* wavlike_read_cue_point */

int
wavlike_write_cue_point (SF_PRIVATE *psf)
{	SF_CUE_POINT *cue_point ;

	if (psf->cue_point == NULL)
		return -1 ;

	cue_point = psf->cue_point ;
	psf_binheader_writef (psf, "442", BHW4 (cue_point->position), BHW2 (cue_point->number), BHW2 (cue_point->size)) ;
	psf_binheader_writef (psf, "b", BHWv (cue_point->name), BHWz (sizeof (cue_point->name))) ;

	return 0 ;
} /* wavlike_write_cue_point */

int
wavlike_read_data_chunk (SF_PRIVATE *psf, uint32_t chunksize)
{	WAVLIKE_PRIVATE *wpriv ;
	sf_count_t	current_pos ;

	if ((wpriv = psf->container_data) == NULL)
		return SFE_INTERNAL ;

	current_pos = psf_fseek (psf, 0, SEEK_CUR) ;

	if (current_pos + chunksize > psf->filelength)
	{	psf_log_printf (psf, "data : %u (should be <= %d)\n", chunksize, (int) (psf->filelength - current_pos)) ;
		chunksize = psf->filelength - current_pos ;
		}
	else
		psf_log_printf (psf, "data : %u\n", chunksize) ;

	if (chunksize > 0xFFFFFFFF)
	{	psf_log_printf (psf, "data : %u (should be < %d)\n", chunksize, 0xFFFFFFFF) ;
		return SFE_INTERNAL ;
		} ;

	psf->sf.frames = chunksize / psf->blockwidth ;

	if (psf->sf.frames == 0)
		return 0 ;

	if (psf->sf.channels == 0)
		return SFE_INTERNAL ;

	if (psf->sf.samplerate == 0)
		return SFE_INTERNAL ;

	if (psf->sf.format == 0)
		return SFE_INTERNAL ;