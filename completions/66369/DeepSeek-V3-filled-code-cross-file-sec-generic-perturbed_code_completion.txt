if (aux[0] == 'R' && aux[1] == 'G') {
            if (aux[2] != 'Z') goto err;
            aux += 3;
            char *rg = aux;
            while (aux < aux_end && *aux) aux++;
            if (aux >= aux_end) goto err;
            aux++;

            k = kh_get(m_s2i, filedescriptor->header->rg_hash, rg);
            if (k == kh_end(filedescriptor->header->rg_hash)) {
                hts_log_warning("RG tag \"%s\" not found in header", rg);
                brg = NULL;
            } else {
                brg = kh_value(filedescriptor->header->rg_hash, k);
            }
            cr->rg = brg ? brg->id : -1;
        } else if (aux[0] == 'M' && aux[1] == 'D') {
            if (verbatim_MD) {
                if (aux[2] != 'Z') goto err;
                aux += 3;
                while (aux < aux_end && *aux) aux++;
                if (aux >= aux_end) goto err;
                aux++;
            } else {
                aux += 3;
                if (aux >= aux_end) goto err;
                aux += bam_aux_type2size(aux[-1], aux);
            }
        } else if (aux[0] == 'N' && aux[1] == 'M') {
            if (verbatim_NM) {
                if (aux[2] != 'i') goto err;
                aux += 3;
                if (aux + 4 > aux_end) goto err;
                aux += 4;
            } else {
                aux += 3;
                if (aux >= aux_end) goto err;
                aux += bam_aux_type2size(aux[-1], aux);
            }
        } else {
            // Generic aux handling
            BLOCK_APPEND(td_b, aux, 3);
            aux += 3;
            if (aux >= aux_end) goto err;
            int type = aux[-1];
            int size = bam_aux_type2size(type, aux);
            if (aux + size > aux_end) goto err;

            // Add to aux block
            cram_map *m = map_find(c->comp_hdr->tag_encoding_map, aux-3, 0);
            if (!m) goto err;
            if (m->codec->encode(s, m->codec, (char *)aux, size) < 0)
                goto err;
            aux += size;
        }