// RG:Z
    // This code block handles the processing of auxiliary tags during CRAM
    // encoding. It checks the presence of specific tags like RG (Read Group),
    // MD (Mismatch Description), and NM (Number of Mismatches) and applies
    // specific logic to either store them directly, append special markers,
    // or log warnings if expected header records are missing. The block also
    // manages the encoding of auxiliary data, creating and using codecs based
    // on the tag's type (e.g., string, integer, float). For container-level
    // tracking, it adds integer keys to a tag map and uses these keys to
    // initialize and configure the codecs, updating both slice-level and
    // global CRAM metrics as appropriate. Each auxiliary tag's data is then
    // appended to the corresponding blocks designated for external storage.
    while (aux_end - aux >= 1 && aux[0] != 0) {
        int r;

        // Room for code + type + at least 1 byte of data
        if (aux - orig >= aux_size - 3)
            goto err;

        // RG:Z
        if (aux[0] == 'R' && aux[1] == 'G' && aux[2] == 'Z') {
            // Store RG tag directly
            BLOCK_APPEND(s->aux_blk, aux, 3);
            BLOCK_APPEND(s->aux_blk, orig + 3, aux_end - 3);
            BLOCK_APPEND_CHAR(s->aux_blk, '\0');
            cr->aux_size += 3 + (aux_end - 3) + 1;
            cr->rg = -1; // prevents auto-add later
        } else if (aux[0] == 'M' && aux[1] == 'D') {
            // MD tag, store as verbatim or use special marker based on '*' flag
            if (aux[2] == '*') {
                BLOCK_APPEND(s->aux_blk, aux, 3);
                BLOCK_APPEND_CHAR(s->aux_blk, '\0');
                cr->aux_size += 3 + 1;
                *has_MD = 1;
            } else {
                // Store MD tag directly
                BLOCK_APPEND(s->aux_blk, aux, 3);
                BLOCK_APPEND(s->aux_blk, orig + 3, aux_end - 3);
                BLOCK_APPEND_CHAR(s->aux_blk, '\0');
                cr->aux_size += 3 + (aux_end - 3) + 1;
            }
        } else if (aux[0] == 'N' && aux[1] == 'M') {
            // NM tag, store as verbatim or use special marker based on '*' flag
            if (aux[2] == '*') {
                BLOCK_APPEND(s->aux_blk, aux, 3);
                BLOCK_APPEND_CHAR(s->aux_blk, '\0');
                cr->aux_size += 3 + 1;
                *has_NM = 1;
            } else {
                // Store NM tag directly
                BLOCK_APPEND(s->aux_blk, aux, 3);
                BLOCK_APPEND(s->aux_blk, orig + 3, aux_end - 3);
                BLOCK_APPEND_CHAR(s->aux_blk, '\0');
                cr->aux_size += 3 + (aux_end - 3) + 1;
            }
        } else {
            // Unknown tag, log warning and skip
            hts_log_warning("Unknown auxiliary tag: %s", aux);
        }

        aux += 3;
    }