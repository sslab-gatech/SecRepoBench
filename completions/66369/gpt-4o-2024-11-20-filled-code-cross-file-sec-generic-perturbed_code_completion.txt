// Extract the tag name and type
        char tag[3];
        tag[0] = aux[0];
        tag[1] = aux[1];
        tag[2] = aux[2];

        // Check if the tag is RG (Read Group)
        if (tag[0] == 'R' && tag[1] == 'G' && tag[2] == 'Z') {
            if (!brg) {
                brg = sam_hrecs_find_rg(filedescriptor->header->hrecs, aux + 3);
                if (!brg) {
                    hts_log_warning("RG tag refers to unknown read group '%s'", aux + 3);
                }
            }
        }

        // Handle NM (Number of Mismatches) tag
        if (tag[0] == 'N' && tag[1] == 'M' && (tag[2] == 'C' || tag[2] == 'I')) {
            if (verbatim_NM) {
                BLOCK_APPEND(td_b, aux, 3);
                BLOCK_APPEND(td_b, aux + 3, 1);
            } else if (NM >= 0) {
                BLOCK_APPEND(td_b, "NM", 2);
                BLOCK_APPEND_CHAR(td_b, 'C');
                BLOCK_APPEND_CHAR(td_b, NM);
            }
        }

        // Handle MD (Mismatch Description) tag
        if (tag[0] == 'M' && tag[1] == 'D' && tag[2] == 'Z') {
            if (verbatim_MD) {
                BLOCK_APPEND(td_b, aux, 3);
                BLOCK_APPEND(td_b, aux + 3, strlen(aux + 3) + 1);
            } else if (MD && MD->l) {
                BLOCK_APPEND(td_b, "MD", 2);
                BLOCK_APPEND_CHAR(td_b, 'Z');
                BLOCK_APPEND(td_b, MD->s, MD->l + 1);
            }
        }

        // Append the tag to the slice auxiliary block
        r = cram_add_aux_data(s, cr, aux, aux_end - aux);
        if (r < 0)
            goto err;

        // Move to the next tag
        aux += 3;
        if (tag[2] == 'Z' || tag[2] == 'H') {
            while (aux < aux_end && *aux)
                aux++;
            aux++;
        } else if (tag[2] == 'B') {
            int32_t count;
            memcpy(&count, aux + 1, 4);
            aux += 5 + count * aux[0];
        } else {
            aux += 1;
        }