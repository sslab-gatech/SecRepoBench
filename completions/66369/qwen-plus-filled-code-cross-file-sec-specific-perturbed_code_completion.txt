key = aux;
while (*key && key < aux_end) {
    if (key[0] == 'R' && key[1] == 'G' && key[2] == ':') {
        // Extract RG value and check header for corresponding record
        char *rg_value = strchr(key, ':') + 1;
        rg_value[strcspn(rg_value, "\0")] = '\0'; // Ensure null-termination

        sam_hrec_t *hrec = sam_hdr_find_rec(j->fd->header, "RG", rg_value);
        if (!hrec) {
            hts_log_warning("Read group '%s' not found in SAM header", rg_value);
        } else {
            brg = sam_hrec_parse(hrec, NULL);
        }
        break; // Assuming only one RG tag per record
    }
    key += strlen(key) + 1; // Move to next tag
}

if (!brg) {
    brg = sam_hdr_first_rec(j->fd->header, "RG", NULL);
    if (!brg) {
        hts_log_warning("No read groups defined in SAM header");
    }
}

// Process MD and NM tags if necessary
if (verbatim_MD && aux_size > 0) {
    key = aux;
    while (*key && key < aux_end) {
        if (key[0] == 'M' && key[1] == 'D' && key[2] == ':') {
            // Handle MD tag
            MD->l = 0;
            kputsn(key+4, strcspn(key+4, "\0"), MD);
            break;
        }
        key += strlen(key) + 1;
    }
}

if (verbatim_NM && aux_size > 0) {
    key = aux;
    while (*key && key < aux_end) {
        if (key[0] == 'N' && key[1] == 'M' && key[2] == ':') {
            // Handle NM tag
            NM = strtol(key+4, NULL, 10);
            break;
        }
        key += strlen(key) + 1;
    }
}