if (aux[0] == 'R' && aux[1] == 'G' && aux[2] == 'Z') {
            char *rg = aux + 3;
            size_t rg_len = strlen(rg);
            sam_hrec_rg_t *hrec_rg = sam_hdr_find_rg(filedescriptor->header, rg);
            if (hrec_rg) {
                brg = hrec_rg;
                BLOCK_APPEND(td_b, "RG*", 3);
                cram_map *m = map_find(c->comp_hdr->tag_encoding_map, "RG*", ('R'<<16)|('G'<<8)|'*');
                if (!m) {
                    m = cram_new_map(DS_aux, "RG*");
                    m->codec = cram_integer_encoder_init(filedescriptor, E_INT, 32, 0, 0);
                    kh_put(m_s2i, c->comp_hdr->tag_encoding_map, strdup("RG*"), &k);
                }
                int32_t rg_id = hrec_rg->id;
                int out_sz = 4;
                m->codec->encode(s, m->codec, BLOCK_DATA(s->aux_blk) + BLOCK_SIZE(s->aux_blk), &rg_id, &out_sz);
                BLOCK_SIZE(s->aux_blk) += out_sz;
                cr->aux_size += out_sz;
            } else {
                hts_log_warning("RG tag '%s' not found in header", rg);
                BLOCK_APPEND(td_b, "RGZ", 3);
                cram_map *m = map_find(c->comp_hdr->tag_encoding_map, "RGZ", ('R'<<16)|('G'<<8)|'Z');
                if (!m) {
                    m = cram_new_map(DS_aux, "RGZ");
                    m->codec = cram_external_encoder_init(filedescriptor, E_BYTE_ARRAY, 0, 0);
                    kh_put(m_s2i, c->comp_hdr->tag_encoding_map, strdup("RGZ"), &k);
                }
                int out_sz = rg_len + 1;
                m->codec->encode(s, m->codec, BLOCK_DATA(s->aux_blk) + BLOCK_SIZE(s->aux_blk), rg, &out_sz);
                BLOCK_SIZE(s->aux_blk) += out_sz;
                cr->aux_size += out_sz;
            }
            aux += 3 + rg_len + 1;
            continue;
        }

        if ((aux[0] == 'N' && aux[1] == 'M' && !verbatim_NM) ||
            (aux[0] == 'M' && aux[1] == 'D' && !verbatim_MD)) {
            char type = aux[2];
            if (type == 'i' || type == 'Z') {
                aux += 3 + (type == 'i' ? 4 : strlen(aux+3)+1);
                continue;
            }
        }

        char tag[3] = {aux[0], aux[1], aux[2]};
        BLOCK_APPEND(td_b, tag, 3);
        uint32_t id = (tag[0]<<16) | (tag[1]<<8) | tag[2];
        cram_map *m = map_find(c->comp_hdr->tag_encoding_map, tag, id);
        if (!m) {
            m = cram_new_map(DS_aux, tag);
            switch (tag[2]) {
            case 'Z': case 'H':
                m->codec = cram_external_encoder_init(filedescriptor, E_BYTE_ARRAY, 0, 0);
                break;
            case 'A': case 'c': case 'C': case 's': case 'S': case 'i': case 'I': case 'f':
                m->codec = cram_integer_encoder_init(filedescriptor, E_INT, 32, 0, 0);
                break;
            case 'B':
                m->codec = cram_byte_array_encoder_init(filedescriptor, E_BYTE_ARRAY, 0, 0);
                break;
            default:
                goto err;
            }
            kh_put(m_s2i, c->comp_hdr->tag_encoding_map, strndup(tag, 3), &k);
        }

        char *data = aux + 3;
        int data_len = 0;
        switch (tag[2]) {
        case 'Z': case 'H':
            data_len = strlen(data) + 1;
            break;
        case 'A': data_len = 1; break;
        case 'c': case 'C': data_len = 1; break;
        case 's': case 'S': data_len = 2; break;
        case 'i': case 'I': case 'f': data_len = 4; break;
        case 'B': {
            char subtype = data[0];
            int32_t count = *(int32_t *)(data + 1);
            data_len = 1 + 4 + count * bam_aux_type2size(subtype);
            break;
        }
        default:
            goto err;
        }

        int out_sz = data_len;
        m->codec->encode(s, m->codec, BLOCK_DATA(s->aux_blk) + BLOCK_SIZE(s->aux_blk), data, &out_sz);
        BLOCK_SIZE(s->aux_blk) += out_sz;
        cr->aux_size += out_sz;
        aux += 3 + data_len;