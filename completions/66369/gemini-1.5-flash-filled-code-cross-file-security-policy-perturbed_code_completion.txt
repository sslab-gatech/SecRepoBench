key = aux;
        k = kh_get(m_s2i, c->comp_hdr->TD_hash, key);
        if (k == kh_end(c->comp_hdr->TD_hash)) {
            int new;
            k = kh_put(m_s2i, c->comp_hdr->TD_hash, key, &new);
            if (new < 0)
                goto err;
            else if (new == 0) {
                // Key already exists.
                // This should not happen, but if it does, we'll just skip
                // this tag.
                aux += 3 + bam_aux2size(aux);
                continue;
            }
            c->comp_hdr->nTL++;
        }
        int len = bam_aux2size(aux);
        cram_map *tm = map_find(c->comp_hdr->tag_encoding_map, key,
                                 (key[0]<<16) | (key[1]<<8) | key[2]);
        if (!tm) {
            // Should not happen, but if it does, we'll just skip this tag.
            aux += 3 + len;
            continue;
        }
        if (tm->codec == NULL) {
            // Should not happen, but if it does, we'll just skip this tag.
            aux += 3 + len;
            continue;
        }
        if (len > 100000000) {
            hts_log_error("auxiliary tag \"%s\" size %d is too large", key, len);
            goto err;
        }
        if (BLOCK_SIZE(td_b) + len + 3 > TD_blk_size) {
            // Reallocate td_b if necessary.
            int new_size = TD_blk_size * 2;
            char *new_data = (char *)realloc(BLOCK_DATA(td_b), new_size);
            if (!new_data)
                goto block_err;
            BLOCK_DATA(td_b) = new_data;
            TD_blk_size = new_size;
        }
        BLOCK_APPEND(td_b, aux, len + 3);
        BLOCK_APPEND_INT(s->aux_blk, kh_val(c->comp_hdr->TD_hash, k));
        aux += 3 + len;