char *val;
        int len;
        cram_map *tm;

        if (aux[1] == 0)
            goto err;

        // RG tag
        if (aux[0] == 'R' && aux[1] == 'G') {
            char *id;
            aux += 3;
            val = aux;
            while (*aux) aux++;
            aux++;
            len = aux - val;

            id = string_ndup(c->comp_hdr->TD_keys, val, len);
            if (!id)
                goto block_err;

            k = kh_get(m_s2i, c->comp_hdr->RG_hash, id);
            if (k == kh_end(c->comp_hdr->RG_hash)) {
                if (filedescriptor->ignore_missing_sam_records) {
                    hts_log_warning("Missing RG ID '%s' in SAM header", id);
                    free(id);
                    continue;
                } else {
                    hts_log_error("Missing RG ID '%s' in SAM header", id);
                    free(id);
                    goto err;
                }
            }
            free(id);

            if (!brg)
                brg = sam_hdr_find_hrec(filedescriptor->header,
                                        SAM_HREC_RG,
                                        sam_hdr_line_name(filedescriptor->header,
                                                          SAM_HREC_RG,
                                                          kh_key(c->comp_hdr->RG_hash, k)));
            continue;
        }

        // MD / NM tags
        if ((aux[0] == 'M' && aux[1] == 'D' && verbatim_MD) ||
            (aux[0] == 'N' && aux[1] == 'M' && verbatim_NM)) {
            aux += 3;
            while (*aux) aux++;
            aux++;
            continue;
        }

        // Append key to TD block
        BLOCK_APPEND(td_b, aux, 3);
        aux += 3;

        // Find the tag in the tag_encoding_map
        int32_t id = (BLOCK_DATA(td_b)[TD_blk_size]<<16) |
                     (BLOCK_DATA(td_b)[TD_blk_size+1]<<8) |
                     BLOCK_DATA(td_b)[TD_blk_size+2];

        k = kh_get(m_i2s, c->comp_hdr->TD_code_hash, id);
        if (k == kh_end(c->comp_hdr->TD_code_hash)) {
            // New tag
            tm = calloc(1, sizeof(*tm));
            if (!tm)
                goto block_err;

            // Codec will be initialised later
            tm->codec = NULL;
            tm->id = c->comp_hdr->n_codecs++;
            if (cram_stats_add(c->stats[DS_aux], tm->id) < 0)
                goto block_err;

            k = kh_put(m_i2s, c->comp_hdr->TD_code_hash, id, &new);
            if (new < 0) {
                free(tm);
                goto err;
            }
            kh_val(c->comp_hdr->TD_code_hash, k) = tm;

            k = kh_put(m_i2i, c->comp_hdr->TD_code_id_hash, tm->id, &new);
             if (new < 0) {
                 free(tm);
                 goto err;
             }
             kh_val(c->comp_hdr->TD_code_id_hash, k) = id;

            //printf("New tag %c%c%c => %d\n", aux[-3], aux[-2], aux[-1], tm->id);
        } else {
            tm = kh_val(c->comp_hdr->TD_code_hash, k);
            if (cram_stats_add(c->stats[DS_aux], tm->id) < 0)
                goto block_err;
        }

        switch(*aux++) {
        case 'A': case 'c': case 'C':
            BLOCK_APPEND_CHAR(s->aux_blk, aux[-1]);
            c->s_aux_bytes++;
            break;

        case 's': case 'S':
            BLOCK_APPEND(s->aux_blk, aux-1, 2);
            c->s_aux_bytes += 2;
            aux++;
            break;

        case 'i': case 'I': case 'f':
            BLOCK_APPEND(s->aux_blk, aux-1, 4);
            c->s_aux_bytes += 4;
            aux += 3;
            break;

        case 'Z': case 'H':
            val = aux;
            while (*aux) aux++;
            len = aux - val;
            aux++;
            BLOCK_APPEND_CHAR(s->aux_blk, val[-1]);
            BLOCK_APPEND(s->aux_blk, val, len);
            BLOCK_APPEND_CHAR(s->aux_blk, 0);
            c->s_aux_bytes += len + 2;
            break;

        case 'B':
            {
                char type = *aux++;
                int32_t n;
                BLOCK_APPEND_CHAR(s->aux_blk, val[-1]);
                BLOCK_APPEND_CHAR(s->aux_blk, type);
                memcpy(&n, aux, 4);
                aux += 4;
                BLOCK_APPEND(s->aux_blk, &n, 4);

                c->s_aux_bytes += 6;

                switch(type) {
                case 'c': case 'C': case 's': case 'S':
                    BLOCK_APPEND(s->aux_blk, aux, n);
                    c->s_aux_bytes += n;
                    aux += n;
                    break;
                case 'i': case 'I': case 'f':
                    BLOCK_APPEND(s->aux_blk, aux, 4*n);
                    c->s_aux_bytes += 4*n;
                    aux += 4*n;
                    break;
                default:
                    fprintf(stderr, "Unknown aux type '%c'\n", type);
                    goto err;
                }
                break;
            }

        default:
            fprintf(stderr, "Unknown aux type '%c'\n", aux[-1]);
            goto err;
        }