// Check for and process the various aux tags we recognise
// and store in external blocks
if (aux[0] == 'R' && aux[1] == 'G' && aux[2] == 'Z') {
    // RG tag. Store the read group name for later reference.
    size_t len = strlen(aux + 3) + 1;
    brg = sam_hrec_find_rg(fd->header, aux + 3);
    BLOCK_APPEND(td_b, aux, 3 + len);
    aux += 3 + len;
} else if (aux[0] == 'M' && aux[1] == 'D' && aux[2] == 'Z') {
    // MD tag.  If verbatim_MD is set, store it directly in the slice.
    if (verbatim_MD) {
        int len = strlen(aux + 3) + 1;
        if (MD->m == 0)
            kstr_init(MD);
        kstr_add(MD, aux + 3);
        kstr_addchar(MD, '\0');
        BLOCK_APPEND(s->aux_blk, aux, 3 + len);
        aux += 3 + len;
    } else {
        // Not verbatim.  Use a codec.
        int len = 0;
        char type = aux[2];
        if (type == 'Z') {
            len = strlen(aux + 3) + 1;
        } else if (type == 'B' || type == 'i' || type == 'I') {
            len = 5;
        } else {
            hts_log_error("Unknown MD type '%c'", type);
            goto err;
        }
        k = kh_get(m_s2i, c->comp_hdr->TD_hash, "MD");
        if (k == kh_end(c->comp_hdr->TD_hash)) {
            int i;
            // Create and register the MD tag
            k = kh_put(m_s2i, c->comp_hdr->TD_hash, "MD", &new);
            if (new < 0) {
                hts_log_error("Failed to add MD tag to TD hash");
                goto err;
            }
            c->comp_hdr->nTL++;
            kh_val(c->comp_hdr->TD_hash, k) = c->comp_hdr->nTL-1;
            BLOCK_APPEND_CHAR(td_b, 'M');
            BLOCK_APPEND_CHAR(td_b, 'D');
            BLOCK_APPEND_CHAR(td_b, type);
            for (i = 3; i < len; i++)
                BLOCK_APPEND_CHAR(td_b, aux[i]);
            // Initialise the MD codec
            c->comp_hdr->codecs[DS_TD] = 
                cram_init_codec(c->comp_hdr->codecs[DS_TD], 
                                aux[0], aux[1], aux[2], 
                                BLOCK_DATA(td_b) + TD_blk_size, 
                                len, 
                                c->comp_hdr->params);
            if (!c->comp_hdr->codecs[DS_TD]) {
                hts_log_error("Couldn't create MD codec");
                goto err;
            }
        }
        // Encode the MD value
        if (cram_encode_aux_block(s, c->comp_hdr->codecs[DS_TD], 
                                  aux + 3, len, 
                                  c->comp_hdr->params) != 0) {
            hts_log_error("Failed to encode MD tag");
            goto err;
        }
        aux += 3 + len;
    }
} else if (aux[0] == 'N' && aux[1] == 'M' && aux[2] == 'i') {
    // NM tag.  If verbatim_NM is set, store it directly in the slice.
    if (verbatim_NM) {
        int len = 5;
        BLOCK_APPEND(s->aux_blk, aux, len);
        aux += len;
    } else {
        // Not verbatim.  Use a codec.
        k = kh_get(m_s2i, c->comp_hdr->TD_hash, "NM");
        if (k == kh_end(c->comp_hdr->TD_hash)) {
            int i;
            // Create and register the NM tag
            k = kh_put(m_s2i, c->comp_hdr->TD_hash, "NM", &new);
            if (new < 0) {
                hts_log_error("Failed to add NM tag to TD hash");
                goto err;
            }
            c->comp_hdr->nTL++;
            kh_val(c->comp_hdr->TD_hash, k) = c->comp_hdr->nTL-1;
            BLOCK_APPEND_CHAR(td_b, 'N');
            BLOCK_APPEND_CHAR(td_b, 'M');
            BLOCK_APPEND_CHAR(td_b, aux[2]);
            for (i = 3; i < 5; i++)
                BLOCK_APPEND_CHAR(td_b, aux[i]);
            // Initialise the NM codec
            c->comp_hdr->codecs[DS_TD] = 
                cram_init_codec(c->comp_hdr->codecs[DS_TD], 
                                aux[0], aux[1], aux[2], 
                                BLOCK_DATA(td_b) + TD_blk_size, 
                                5, 
                                c->comp_hdr->params);
            if (!c->comp_hdr->codecs[DS_TD]) {
                hts_log_error("Couldn't create NM codec");
                goto err;
            }
        }
        // Encode the NM value
        if (cram_encode_aux_block(s, c->comp_hdr->codecs[DS_TD], 
                                  aux + 3, 5, 
                                  c->comp_hdr->params) != 0) {
            hts_log_error("Failed to encode NM tag");
            goto err;
        }
        aux += 5;
    }
} else {
    // Other tags.  Use existing tag codec if we have one.
    int len = 0;
    char type = aux[2];
    if (type == 'Z') {
        len = strlen(aux + 3) + 1;
    } else if (type == 'B' || type == 'i' || type == 'I') {
        len = 5;
    } else if (type == 'C' || type == 'c') {
        len = 4;
    } else if (type == 'f') {
        len = 5;
    } else if (type == 'H') {
        len = (strlen(aux + 3) / 2) + 1;
    } else {
        hts_log_error("Unknown aux type '%c'", type);
        goto err;
    }
    k = kh_get(m_s2i, c->comp_hdr->TD_hash, key);
    if (k != kh_end(c->comp_hdr->TD_hash)) {
        // Existing tag.  Use the existing codec.
        if (cram_encode_aux_block(s, c->comp_hdr->codecs[kh_val(c->comp_hdr->TD_hash, k)], 
                                  aux + 3, len, 
                                  c->comp_hdr->params) != 0) {
            hts_log_error("Failed to encode tag %c%c%c", aux[0], aux[1], aux[2]);
            goto err;
        }
    } else {
        // New tag.  Create a new codec and add to list.
        int i;
        k = kh_put(m_s2i, c->comp_hdr->TD_hash, key, &new);
        if (new < 0) {
            hts_log_error("Failed to add %c%c%c tag to TD hash", aux[0], aux[1], aux[2]);
            goto err;
        }
        c->comp_hdr->nTL++;
        kh_val(c->comp_hdr->TD_hash, k) = c->comp_hdr->nTL-1;
        BLOCK_APPEND_CHAR(td_b, aux[0]);
        BLOCK_APPEND_CHAR(td_b, aux[1]);
        BLOCK_APPEND_CHAR(td_b, aux[2]);
        for (i = 3; i < len; i++)
            BLOCK_APPEND_CHAR(td_b, aux[i]);
        c->comp_hdr->codecs[DS_TD] = 
            cram_init_codec(c->comp_hdr->codecs[DS_TD], 
                            aux[0], aux[1], aux[2], 
                            BLOCK_DATA(td_b) + TD_blk_size, 
                            len, 
                            c->comp_hdr->params);
        if (!c->comp_hdr->codecs[DS_TD]) {
            hts_log_error("Couldn't create codec for %c%c%c", aux[0], aux[1], aux[2]);
            goto err;
        }
        // Encode the value
        if (cram_encode_aux_block(s, c->comp_hdr->codecs[DS_TD], 
                                  aux + 3, len, 
                                  c->comp_hdr->params) != 0) != 0) {
            hts_log_error("Failed to encode tag %c%c%c", aux[0], aux[1], aux[2]);
            goto err;
        }
    }
    aux += len;
}