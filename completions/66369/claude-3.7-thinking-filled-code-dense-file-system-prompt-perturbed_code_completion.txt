if (aux[0] == 'R' && aux[1] == 'G' && aux[2] == 'Z') {
    char *rg = (char *)aux+3;
    char *rg_end = rg;
    while (rg_end < aux_end && *rg_end) rg_end++;
    if (rg_end >= aux_end) goto err;
    
    sam_hrecs_t *bfd = filedescriptor->header->hrecs;
    brg = sam_hrecs_find_rg_id(bfd, rg, rg_end - rg);
    if (!brg) {
        if (rg[0] != '\0')
            hts_log_warning("Read group \"%.*s\" not defined in header", (int)(rg_end - rg), rg);
    }
}

BLOCK_APPEND(td_b, aux, 3);

// Find the tag encoding map entry
int key_type = (aux[0]<<16) | (aux[1]<<8) | aux[2];
khint_t k_type = kh_get(m_s2i, c->comp_hdr->tag_encoding_map, key_type);
cram_map *m;

if (k_type == kh_end(c->comp_hdr->tag_encoding_map)) {
    // New key
    m = calloc(1, sizeof(*m));
    if (!m)
        goto err;
    
    // Store the key
    m->key = (char *)aux;
    
    // Create the codec
    if (!(m->codec = cram_encoder_init(E_EXTERNAL, NULL, E_BYTE_ARRAY, 
                                       (void *)filedescriptor->version)))
        goto err;
    
    k_type = kh_put(m_s2i, c->comp_hdr->tag_encoding_map, key_type, &new);
    if (new < 0)
        goto err;
    
    kh_val(c->comp_hdr->tag_encoding_map, k_type) = m;
} else {
    m = kh_val(c->comp_hdr->tag_encoding_map, k_type);
    if (!m)
        goto err;
}

// Append the tag data
switch(aux[2]) {
case 'A': case 'c': case 'C':
    if (aux + 4 > aux_end) goto err;
    r |= m->codec->encode(s, m->codec, aux+3, 1);
    aux += 4;
    break;
    
case 's': case 'S':
    if (aux + 5 > aux_end) goto err;
    r |= m->codec->encode(s, m->codec, aux+3, 2);
    aux += 5;
    break;
    
case 'i': case 'I': case 'f':
    if (aux + 7 > aux_end) goto err;
    r |= m->codec->encode(s, m->codec, aux+3, 4);
    aux += 7;
    break;
    
case 'd':
    if (aux + 11 > aux_end) goto err;
    r |= m->codec->encode(s, m->codec, aux+3, 8);
    aux += 11;
    break;
    
case 'Z': case 'H':
    {
        char *s_end = (char *)aux+3;
        while (s_end < (char *)aux_end && *s_end) s_end++;
        if (s_end >= (char *)aux_end) goto err;
        r |= m->codec->encode(s, m->codec, aux+3, s_end+1-(char *)(aux+3));
        aux = (unsigned char *)(s_end+1);
        break;
    }
    
case 'B':
    {
        int type2 = aux[3], items;
        if (aux + 8 > aux_end) goto err;
        items = (aux[4]) | (aux[5]<<8) | (aux[6]<<16) | (aux[7]<<24);
        if (items < 0) goto err;
        
        switch (type2) {
        case 'c': case 'C':
            if (aux + 8 + items > aux_end) goto err;
            r |= m->codec->encode(s, m->codec, aux+3, items+5);
            aux += 8 + items;
            break;
            
        case 's': case 'S':
            if (aux + 8 + 2*items > aux_end) goto err;
            r |= m->codec->encode(s, m->codec, aux+3, items*2+5);
            aux += 8 + 2*items;
            break;
            
        case 'i': case 'I': case 'f':
            if (aux + 8 + 4*items > aux_end) goto err;
            r |= m->codec->encode(s, m->codec, aux+3, items*4+5);
            aux += 8 + 4*items;
            break;
            
        default:
            hts_log_error("Unknown sub-type '%c' for aux type 'B'", type2);
            goto err;
        }
        break;
    }
    
default:
    hts_log_error("Unknown aux type '%c'", aux[2]);
    goto err;
}

cr->aux_size += (int)(aux - orig) - aux_size;