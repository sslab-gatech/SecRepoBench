if (aux[0] == 'R' && aux[1] == 'G' && aux[2] == 'Z') {
    char *rg = (char *)bam_aux2Z(aux);
    if (!rg) {
        hts_log_warning("RG tag present but no read group");
        goto err;
    }
    brg = sam_hrecs_find_rg(filedescriptor->header->hrecs, rg);
    if (!brg) {
        hts_log_warning("RG tag present but no @RG header line for %s", rg);
        goto err;
    }
    cr->rg = brg->id;
    aux += 4 + strlen(rg);
} else if (aux[0] == 'M' && aux[1] == 'D' && aux[2] == 'Z') {
    if (verbatim_MD) {
        BLOCK_APPEND(td_b, aux, 3);
        BLOCK_APPEND(s->aux_blk, aux+3, strlen(aux+3)+1);
    } else {
        BLOCK_APPEND(td_b, aux, 3);
        BLOCK_APPEND_CHAR(td_b, '*');
    }
    aux += 4 + strlen(aux+3);
} else if (aux[0] == 'N' && aux[1] == 'M' && aux[2] == 'i') {
    if (verbatim_NM) {
        BLOCK_APPEND(td_b, aux, 3);
        BLOCK_APPEND(s->aux_blk, aux+3, 4);
    } else {
        BLOCK_APPEND(td_b, aux, 3);
        BLOCK_APPEND_CHAR(td_b, '*');
    }
    aux += 7;
} else {
    BLOCK_APPEND(td_b, aux, 3);
    cram_map *m = map_find(c->comp_hdr->tag_encoding_map, aux, (aux[0]<<16)|(aux[1]<<8)|aux[2]);
    if (!m) {
        hts_log_error("No codec found for aux tag %c%c%c", aux[0], aux[1], aux[2]);
        goto err;
    }
    if (!m->codec) {
        hts_log_error("No codec initialized for aux tag %c%c%c", aux[0], aux[1], aux[2]);
        goto err;
    }
    int data_len = bam_aux_type2size(aux[2]);
    if (data_len < 0) {
        if (aux[2] == 'Z' || aux[2] == 'H') {
            data_len = strlen(aux+3) + 1;
        } else {
            hts_log_error("Unknown aux type %c", aux[2]);
            goto err;
        }
    }
    if (m->codec->encode(s, m->codec, s->aux_blk, aux+3, &data_len) < 0) {
        hts_log_error("Failed to encode aux data");
        goto err;
    }
    aux += 3 + data_len;
}