// Encode aux tags
khash_t(m_s2i) *tm = c->comp_hdr->TD_hash;
if (tm) {
    khint_t k;
    for (k = kh_begin(tm); k != kh_end(tm); k++) {
        if (kh_exist(tm, k)) {
            char *key = kh_key(tm, k);
            int id = kh_val(tm, k);

            cram_tag_map *tm = kh_val(c->tags_used, k);
            if (!tm->blk) {
                tm->blk = cram_new_block(EXTERNAL, DS_aux + id*2);
                if (!tm->blk) return -1;
            }

            if (cram_stats_add(c->stats[DS_aux + id*2], strlen(key)) < 0)
                return -1;
            BLOCK_APPEND(tm->blk, key, strlen(key)+1);

            if (!tm->blk2) {
                tm->blk2 = cram_new_block(EXTERNAL, DS_aux + id*2 + 1);
                if (!tm->blk2) return -1;
            }

            int type = *aux++;
            int size = 0;
            switch (type) {
            case 'c': case 'C':
                size = 1;
                break;
            case 's': case 'S':
                size = 2;
                break;
            case 'i': case 'I':
                size = 4;
                break;
            case 'f':
                size = 4;
                break;
            case 'd':
                size = 8;
                break;
            case 'Z': case 'H':
                while (*aux++);
                size = aux - orig - 1;
                break;
            case 'B':
                type = *aux++;
                size = bam_get_l_aux_type(type) * bam_get_l_aux_count(aux);
                aux += size;
                break;
            default:
                hts_log_error("Unhandled SAM aux type '%c'", type);
                return -1;
            }

            if (cram_stats_add(c->stats[DS_aux + id*2 + 1], size) < 0)
                return -1;
            BLOCK_APPEND(tm->blk2, orig, size);
            orig += size;
        }
    }
}