if (aux[0] == 'R' && aux[1] == 'G') {
    brg = sam_hrecs_find_rg(filedescriptor->header->hrecs, aux+3);
    if (!brg) {
        hts_log_warning("RG:Z: tag '%s' not present in header", aux+3);
    }
}

if (aux[0] == 'M' && aux[1] == 'D' && aux[2] == 'Z') {
    if (verbatim_MD) {
        if (MD) {
            kstring_t *ks = MD;
            ks->l = 0;
            kputsn(aux+3, aux_end - (aux+3), ks);
        }
    } else {
        if (no_ref) {
            hts_log_warning("MD tag found but no reference available");
        }
    }
}

if (aux[0] == 'N' && aux[1] == 'M') {
    if (verbatim_NM) {
        char *cp = aux+2;
        if (*cp == 'C') {
            NM = *(cp+1);
        } else if (*cp == 'S') {
            NM = *(int16_t *)(cp+1);
        } else if (*cp == 'I') {
            NM = *(int32_t *)(cp+1);
        } else {
            hts_log_warning("Unhandled type code for NM tag");
        }
    } else {
        if (no_ref) {
            hts_log_warning("NM tag found but no reference available");
        }
    }
}

// Encode aux key
BLOCK_APPEND(td_b, aux, 2);

// Add to tag map
int key = (aux[0]<<8)|aux[1];
khint_t k = kh_put(m_tagmap, c->tags_used, key, &r);
if (r >= 0) {
    if (r == 1)
        kh_val(c->tags_used, k) = 1;
    else
        kh_val(c->tags_used, k)++;
}

// Encode aux value
cram_codec *codec = cram_encoder_init(cram_data_type(aux+2), 
                                      c->comp_hdr->codecs[DS_aux],
                                      aux+2, aux_end - aux - 2,
                                      filedescriptor->version);
if (!codec)
    return NULL;

r |= codec->store(codec, aux+2, aux_end - aux - 2);
if (r)
    return NULL;

aux = aux_end;

if (CRAM_MAJOR_VERS(filedescriptor->version) >= 3) {
    r |= cram_stats_add(c->stats[DS_aux], codec->byte);
    if (r)
        return NULL;
}

// Move to next tag
aux += 3;
while (aux < aux_end && *aux)
    aux++;
aux++;

if (r)
    return NULL;