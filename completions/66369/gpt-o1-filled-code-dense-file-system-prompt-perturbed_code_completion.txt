{
    /* We'll parse through the aux data, handling special tags (RG, MD, NM)
     * according to whether we need to preserve them verbatim or skip them.
     * All other tags are passed through as-is.
     */
    while (aux + 3 < aux_end && aux[0] != 0) {
        char t1 = aux[0];
        char t2 = aux[1];
        char type = aux[2];
        char *data = aux + 3;
        char *endp;
        int skip = 0;

        /* If the buffer ends unexpectedly, bail out. */
        if (data >= aux_end)
            goto err;

        /* Special-case logic for some known tags. */
        if (t1 == 'R' && t2 == 'G' && type == 'Z') {
            /* Attempt to parse the read group name and see if it exists. */
            for (endp = data; endp < aux_end && *endp; endp++)
                ;
            if (endp >= aux_end)
                goto err;

            /* Find the RG in the header (if present). */
            {
                /* Temporary null-terminate and look up. */
                const char *rg_key = data;
                sam_hrec_rg_t *rg_entry = sam_hrecs_find_rg(filedescriptor->header->hrecs, rg_key);
                if (rg_entry)
                    brg = rg_entry; /* remember for the caller */
            }

            /* We always store RG:Z if present. */
        } else if (t1 == 'M' && t2 == 'D' && type == 'Z') {
            /* Skip MD if we aren't preserving it verbatim. */
            if (!verbatim_MD) skip = 1;
        } else if (t1 == 'N' && t2 == 'M') {
            /* Skip NM if we aren't preserving it verbatim. */
            if (!verbatim_NM) skip = 1;
        }

        /* Now determine how much data to skip or store. */
        if (type == 'Z' || type == 'H') {
            /* Null-terminated string. */
            for (endp = data; endp < aux_end && *endp; endp++)
                ;
            if (endp >= aux_end)
                goto err;
            endp++; /* include null terminator in length */
        } else if (type == 'B') {
            /* Typed array. B:<type><len><data...> */
            /* The first byte is the element type, the next 4 bytes (little-endian)
             * is the number of elements, and then we have that many elements.
             */
            if (data + 5 > aux_end)
                goto err;
            int32_t count = le_to_i32(data + 1);
            /* Each element depends on data[0].  Could check 'cCsSiIf' etc. */
            int elsize = 0;
            switch (data[0]) {
            case 'c': case 'C': elsize = 1; break;
            case 's': case 'S': elsize = 2; break;
            case 'i': case 'I': case 'f': elsize = 4; break;
            default:
                goto err; /* unsupported sub-type */
            }
            endp = data + 1 + 4 + (int64_t)count * elsize;
            if (endp > aux_end)
                goto err;
        } else {
            /* Scalar integer or float. */
            switch (type) {
            case 'A': /* char */
            case 'c': case 'C': /* 1-byte int */
                endp = data + 1; 
                break;
            case 's': case 'S': /* 2-byte int */
                endp = data + 2; 
                break;
            case 'i': case 'I': case 'f': /* 4-byte int / float */
                endp = data + 4; 
                break;
            case 'd': /* 8-byte float (double) */
                endp = data + 8; 
                break;
            default:
                goto err; /* Unknown type */
            }
            if (endp > aux_end)
                goto err;
        }

        if (!skip) {
            /* Store the tag/type triple (3 bytes) in the TD block. */
            BLOCK_APPEND(td_b, aux, 3);

            /* And store the actual data in s->aux_blk. */
            BLOCK_APPEND(s->aux_blk, data, endp - data);

            cr->aux_size += 3 + (endp - data);
        }

        /* Move on to the next tag. */
        aux = endp;
    }

    /* This line was in the masked snippet; seemingly a leftover. */
    tm->blk->m = tm->m;
}