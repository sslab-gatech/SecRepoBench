// Ensure we have enough space in the block for the tag
        if (BLOCK_SIZE(td_b) + 3 > BLOCK_MAX_SIZE(td_b)) {
            hts_log_error("TD block size overflow");
            goto err;
        }

        // Append the tag key (2 characters + type)
        BLOCK_APPEND_CHAR(td_b, aux[0]);
        BLOCK_APPEND_CHAR(td_b, aux[1]);
        BLOCK_APPEND_CHAR(td_b, aux[2]);

        // Process the tag value based on its type
        switch (aux[2]) {
        case 'A': // Character
            if (aux_end - aux < 4)
                goto err;
            BLOCK_APPEND_CHAR(s->aux_blk, aux[3]);
            aux += 4;
            break;

        case 'C': // Unsigned 8-bit integer
        case 'c': // Signed 8-bit integer
            if (aux_end - aux < 4)
                goto err;
            BLOCK_APPEND_CHAR(s->aux_blk, aux[3]);
            aux += 4;
            break;

        case 'S': // Unsigned 16-bit integer
        case 's': // Signed 16-bit integer
            if (aux_end - aux < 5)
                goto err;
            BLOCK_APPEND(s->aux_blk, aux + 3, 2);
            aux += 5;
            break;

        case 'I': // Unsigned 32-bit integer
        case 'i': // Signed 32-bit integer
            if (aux_end - aux < 7)
                goto err;
            BLOCK_APPEND(s->aux_blk, aux + 3, 4);
            aux += 7;
            break;

        case 'f': // 32-bit float
            if (aux_end - aux < 7)
                goto err;
            BLOCK_APPEND(s->aux_blk, aux + 3, 4);
            aux += 7;
            break;

        case 'Z': // String
        case 'H': // Hex string
            aux += 3;
            while (aux < aux_end && *aux) {
                BLOCK_APPEND_CHAR(s->aux_blk, *aux++);
            }
            if (aux >= aux_end)
                goto err;
            BLOCK_APPEND_CHAR(s->aux_blk, '\0');
            aux++;
            break;

        case 'B': { // Array
            int32_t count, bytes_per_element;
            if (aux_end - aux < 8)
                goto err;
            BLOCK_APPEND_CHAR(s->aux_blk, aux[3]); // Element type
            memcpy(&count, aux + 4, 4);
            BLOCK_APPEND(s->aux_blk, aux + 4, 4); // Element count
            aux += 8;

            switch (aux[-5]) {
            case 'c': case 'C': bytes_per_element = 1; break;
            case 's': case 'S': bytes_per_element = 2; break;
            case 'i': case 'I': case 'f': bytes_per_element = 4; break;
            default: goto err;
            }

            if (aux_end - aux < count * bytes_per_element)
                goto err;
            BLOCK_APPEND(s->aux_blk, aux, count * bytes_per_element);
            aux += count * bytes_per_element;
            break;
        }

        default:
            hts_log_warning("Unknown aux type '%c'", aux[2]);
            goto err;
        }