// RG:Z
if (aux[0] == 'R' && aux[1] == 'G' && aux[2] == 'Z') {
    int rg_id = -1;
    char *rg = NULL;
    int rg_len = 0;

    // Check if the RG tag is properly null-terminated
    if (aux_size - (aux - orig) < 3) {
        goto err;
    }

    // Extract the RG tag value
    rg = aux + 3;
    rg_len = strlen(rg);

    // Check if the RG tag value is within the buffer limits
    if (rg_len > aux_size - (aux - orig) - 3) {
        goto err;
    }

    // Find the corresponding RG ID
    for (int i = 0; i < c->comp_hdr->nRG; i++) {
        if (strcmp(c->comp_hdr->RG[i], rg) == 0) {
            rg_id = i;
            break;
        }
    }

    // If the RG ID is not found, log a warning and skip this tag
    if (rg_id == -1) {
        hts_log_warning("Unknown RG ID: %s", rg);
        aux += 3 + rg_len + 1; // Skip the RG tag
        continue;
    }

    // Add the RG ID to the tag map
    k = kh_put(m_s2i, c->comp_hdr->TD_hash, rg, &new);
    if (new < 0) {
        goto err;
    } else if (new == 0) {
        BLOCK_SIZE(td_b) = TD_blk_size;
    } else {
        kh_val(c->comp_hdr->TD_hash, k) = c->comp_hdr->nTL;
        c->comp_hdr->nTL++;
    }

    // Append the RG ID to the TD block
    BLOCK_APPEND_CHAR(td_b, rg_id);

    // Update the aux pointer
    aux += 3 + rg_len + 1; // Skip the RG tag
}

// MD:Z
else if (aux[0] == 'M' && aux[1] == 'D' && aux[2] == 'Z') {
    int md_len = 0;

    // Check if the MD tag is properly null-terminated
    if (aux_size - (aux - orig) < 3) {
        goto err;
    }

    // Extract the MD tag value
    md_len = strlen(aux + 3);

    // Check if the MD tag value is within the buffer limits
    if (md_len > aux_size - (aux - orig) - 3) {
        goto err;
    }

    // Add the MD tag to the tag map
    k = kh_put(m_s2i, c->comp_hdr->TD_hash, "MDZ", &new);
    if (new < 0) {
        goto err;
    } else if (new == 0) {
        BLOCK_SIZE(td_b) = TD_blk_size;
    } else {
        kh_val(c->comp_hdr->TD_hash, k) = c->comp_hdr->nTL;
        c->comp_hdr->nTL++;
    }

    // Append the MD tag to the TD block
    BLOCK_APPEND_CHAR(td_b, 1); // 1 indicates MD:Z

    // Update the aux pointer
    aux += 3 + md_len + 1; // Skip the MD tag
}

// NM:i
else if (aux[0] == 'N' && aux[1] == 'M' && aux[2] == 'i') {
    int nm = 0;

    // Check if the NM tag is properly null-terminated
    if (aux_size - (aux - orig) < 3) {
        goto err;
    }

    // Extract the NM tag value
    nm = atoi(aux + 3);

    // Add the NM tag to the tag map
    k = kh_put(m_s2i, c->comp_hdr->TD_hash, "NMI", &new);
    if (new < 0) {
        goto err;
    } else if (new == 0) {
        BLOCK_SIZE(td_b) = TD_blk_size;
    } else {
        kh_val(c->comp_hdr->TD_hash, k) = c->comp_hdr->nTL;
        c->comp_hdr->nTL++;
    }

    // Append the NM tag to the TD block
    BLOCK_APPEND_CHAR(td_b, nm);

    // Update the aux pointer
    aux += 3 + strlen(aux + 3) + 1; // Skip the NM tag
}

// Other tags
else {
    // Add the tag to the tag map
    k = kh_put(m_s2i, c->comp_hdr->TD_hash, aux, &new);
    if (new < 0) {
        goto err;
    } else if (new == 0) {
        BLOCK_SIZE(td_b) = TD_blk_size;
    } else {
        kh_val(c->comp_hdr->TD_hash, k) = c->comp_hdr->nTL;
        c->comp_hdr->nTL++;
    }

    // Append the tag to the TD block
    BLOCK_APPEND_CHAR(td_b, 0); // 0 indicates other tags

    // Update the aux pointer
    aux += 3 + strlen(aux + 3) + 1; // Skip the tag
}