// Extract the tag name and type
        char tag[3];
        tag[0] = aux[0];
        tag[1] = aux[1];
        tag[2] = aux[2];
        aux += 3;

        // Handle RG:Z (Read Group) tag
        if (tag[0] == 'R' && tag[1] == 'G' && tag[2] == 'Z') {
            char *rg = aux;
            while (aux < aux_end && *aux)
                aux++;
            aux++;

            if (aux > aux_end)
                goto err;

            // Find or create RG entry
            if (filedescriptor->header) {
                brg = sam_hrecs_find_rg(filedescriptor->header->hrecs, rg);
                if (!brg) {
                    hts_log_warning("Unknown RG tag \"%s\"", rg);
                }
            }
        }

        // Handle MD:Z (Mismatch Description) tag
        if (tag[0] == 'M' && tag[1] == 'D' && tag[2] == 'Z') {
            if (verbatim_MD) {
                // Store verbatim MD tag
                BLOCK_APPEND(td_b, tag, 3);
                BLOCK_APPEND(td_b, aux, strlen(aux) + 1);
            }
            aux += strlen(aux) + 1;
            continue;
        }

        // Handle NM:i (Number of Mismatches) tag
        if (tag[0] == 'N' && tag[1] == 'M' && tag[2] == 'i') {
            if (verbatim_NM) {
                // Store verbatim NM tag
                BLOCK_APPEND(td_b, tag, 3);
                BLOCK_APPEND(td_b, aux, 4);
            }
            aux += 4;
            continue;
        }

        // Default: store the tag in the tag dictionary block
        BLOCK_APPEND(td_b, tag, 3);
        switch (tag[2]) {
        case 'A': case 'C': case 'c': case 'S': case 's':
        case 'I': case 'i': case 'f': case 'd': case 'Z':
        case 'H': case 'B':
            r = cram_encode_aux_item(td_b, &aux, aux_end, tag[2]);
            if (r < 0)
                goto err;
            break;

        default:
            hts_log_error("Unknown aux type '%c'", tag[2]);
            goto err;
        }