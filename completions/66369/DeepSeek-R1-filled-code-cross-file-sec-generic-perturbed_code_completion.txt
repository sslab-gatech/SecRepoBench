// Process each auxiliary tag
while (aux_end - aux >= 1 && aux[0] != 0) {
    int r;
    char tag[3];
    memcpy(tag, aux, 3);
    aux += 3;

    // Handle RG:Z tag
    if (tag[0] == 'R' && tag[1] == 'G' && tag[2] == 'Z') {
        char *rg_val = aux;
        size_t rg_len = strlen(rg_val);
        aux += rg_len + 1;

        brg = sam_hdr_find_rg(filedescriptor->header, rg_val);
        if (!brg) {
            hts_log_warning("RG tag '%.*s' not found in header", (int)rg_len, rg_val);
        } else {
            BLOCK_APPEND(td_b, "RGZ", 3);
            cram_codec *codec = c->comp_hdr->codecs[DS_RG];
            if (codec && codec->encode(s, codec, &brg->id, sizeof(int32_t)) < 0)
                goto err;
        }
        continue;
    }

    // Handle MD:Z tag
    if (tag[0] == 'M' && tag[1] == 'D' && tag[2] == 'Z') {
        if (verbatim_MD) {
            BLOCK_APPEND(td_b, "MD*", 3);
            cram_codec *codec = c->comp_hdr->codecs[DS_MD];
            if (codec && codec->encode(s, codec, MD->s, MD->l + 1) < 0)
                goto err;
        }
        aux += strlen(aux) + 1;
        continue;
    }

    // Handle NM:i tag
    if (tag[0] == 'N' && tag[1] == 'M' && tag[2] == 'i') {
        if (verbatim_NM) {
            BLOCK_APPEND(td_b, "NM*", 3);
            cram_codec *codec = c->comp_hdr->codecs[DS_NM];
            if (codec && codec->encode(s, codec, &NM, sizeof(int)) < 0)
                goto err;
        }
        aux += 4;
        continue;
    }

    // Generic tag handling
    BLOCK_APPEND(td_b, tag, 3);
    cram_codec *codec = map_find_codec(c->comp_hdr->tag_encoding_map, tag);
    if (!codec) goto err;

    size_t data_len = aux_type_size(tag[2], aux, aux_end);
    if (data_len == 0 || aux + data_len > aux_end) goto err;

    if (codec->encode(s, codec, aux, data_len) < 0)
        goto err;
    aux += data_len;
}