// RG:Z
    // This code block handles the processing of auxiliary tags during CRAM
    // encoding. It checks the presence of specific tags like RG (Read Group),
    // MD (Mismatch Description), and NM (Number of Mismatches) and applies
    // specific logic to either store them directly, append special markers,
    // or log warnings if expected header records are missing. The block also
    // manages the encoding of auxiliary data, creating and using codecs based
    // on the tag's type (e.g., string, integer, float). For container-level
    // tracking, it adds integer keys to a tag map and uses these keys to
    // initialize and configure the codecs, updating both slice-level and
    // global CRAM metrics as appropriate. Each auxiliary tag's data is then
    // appended to the corresponding blocks designated for external storage.
    // <MASK>
    tm->blk->m = tm->m;
    if (orig[0] == 'R' && orig[1] == 'G') {
        // RG is variable size, but known already.  Insert now
        const char *rg = sam_hdr_line_name(fd->header, "RG", cr->rg);
        if (!rg)
            continue;

        size_t rg_len = strlen(rg);
        BLOCK_APPEND(s->aux_blk, (char *)orig, 3);
        BLOCK_APPEND(s->aux_blk, rg, rg_len);
        BLOCK_APPEND_CHAR(s->aux_blk, '\0');
        cr->aux_size += 3 + rg_len + 1;
        cr->rg = -1; // prevents auto-add later
        continue;
    } else if (orig[0] == 'M' && orig[1] == 'D') {
        // MD is variable size, but known already.  Insert now
        const char *md = sam_hdr_line_name(fd->header, "MD", cr->md);
        if (!md)
            continue;

        size_t md_len = strlen(md);
        BLOCK_APPEND(s->aux_blk, (char *)orig, 3);
        BLOCK_APPEND(s->aux_blk, md, md_len);
        BLOCK_APPEND_CHAR(s->aux_blk, '\0');
        cr->aux_size += 3 + md_len + 1;
        cr->md = -1; // prevents auto-add later
        continue;
    } else if (orig[0] == 'N' && orig[1] == 'M') {
        // NM is variable size, but known already.  Insert now
        const char *nm = sam_hdr_line_name(fd->header, "NM", cr->nm);
        if (!nm)
            continue;

        size_t nm_len = strlen(nm);
        BLOCK_APPEND(s->aux_blk, (char *)orig, 3);
        BLOCK_APPEND(s->aux_blk, nm, nm_len);
        BLOCK_APPEND_CHAR(s->aux_blk, '\0');
        cr->aux_size += 3 + nm_len + 1;
        cr->nm = -1; // prevents auto-add later
        continue;
    } else {
        // Unknown size.  We'll insert MD into stream later.
        BLOCK_APPEND(s->aux_blk, (char *)orig, 3);
        cr->aux_size += 3;
    }