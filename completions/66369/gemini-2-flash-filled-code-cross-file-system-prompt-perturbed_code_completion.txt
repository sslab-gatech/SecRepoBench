char type = *aux++;
        char tag[3];
        cram_map *tm;

        tag[0] = aux[-2];
        tag[1] = aux[-1];
        tag[2] = type;

        int32_t id = (tag[0]<<16) | (tag[1]<<8) | tag[2];

        k = kh_get(m_s2i, c->comp_hdr->TD_hash, tag);
        if (k == kh_end(c->comp_hdr->TD_hash)) {
            // New key
            BLOCK_APPEND(td_b, tag, 2);
            BLOCK_APPEND_CHAR(td_b, type);
        } else {
            // Existing key
            BLOCK_SIZE(td_b) = TD_blk_size;
            //printf("Dup tag %c%c%c\n", tag[0], tag[1], tag[2]);
        }

        tm = map_find(c->comp_hdr->tag_encoding_map, tag, id);
        if (!tm) {
            tm = calloc(1, sizeof(*tm));
            if (!tm)
                goto block_err;
            tm->id = id;
            tm->tag[0] = tag[0];
            tm->tag[1] = tag[1];
            tm->tag[2] = tag[2];
            map_insert(c->comp_hdr->tag_encoding_map, tm);
        }

        if (!tm->codec) {
            // First time we've seen this tag, so create a codec for it.
            // We initialise the codec with a dummy block, which will be
            // replaced later.
            cram_codec *codec;
            cram_block *blk = cram_new_block(EXTERNAL);
            if (!blk)
                goto block_err;
            BLOCK_SIZE(blk) = 0;
            codec = cram_get_codec(filedescriptor, s, c->comp_hdr,
                                     type, (void *)blk, &r);
            if (!codec) {
                cram_free_block(blk);
                goto block_err;
            }
            codec->codec = -1; // unset
            tm->codec = codec;
            tm->blk = blk;
        }

        // Append data to slice aux block
        if (tm->blk->offset == 0) {
            tm->blk->offset = s->aux_offset;
            s->aux_offset += 8; // placeholder
        }

        if (tm->codec->encode(s, tm->codec, aux, &r) < 0)
            goto block_err;

        if (r < 0)
            goto block_err;

        switch(type) {
        case 'A': case 'c': case 'C':
            aux++;
            break;
        case 's': case 'S':
            aux += 2;
            break;
        case 'i': case 'I': case 'f':
            aux += 4;
            break;
        case 'l': case 'L':
            aux += 4;
            break;
        case 'j': case 'J':
            aux += 8;
            break;
        case 'Z': case 'H':
            while (*aux)
                aux++;
            aux++;
            break;
        case 'B': {
            int n;
            char btype = *aux++;
            n = le32toh(*(int32_t *)aux);
            aux += 4;
            aux += n * cram_type_size(btype);
            break;
        }
        default:
            hts_log_warning("Unknown aux type '%c'", type);
            goto err;
        }

        s->s_aux_bytes += aux - (char *)BLOCK_END(s->aux_blk);
        cr->aux_size += aux - (char *)BLOCK_END(s->aux_blk);
        BLOCK_SIZE(s->aux_blk) += aux - (char *)BLOCK_END(s->aux_blk);
        if (cram_stats_add(c->stats[DS_aux], aux - (char *)BLOCK_END(s->aux_blk)) < 0)
            goto block_err;
        if (BLOCK_SIZE(s->aux_blk) > (1u<<31)) {
            hts_log_error("CRAM->BAM aux block size overflow");
            goto block_err;
        }