key = (char *)aux;
        if (aux_end - aux < 3)
            goto err;

        if (key[0] == 'R' && key[1] == 'G' && key[2] == 'Z') {
            if (!brg) {
                brg = filedescriptor->header->hrecs->rg[cr->rg];
                if (!brg) {
                    if (cram_add_rg(filedescriptor, cr->rg, (char *)aux + 3))
                        goto err;
                    brg = filedescriptor->header->hrecs->rg[cr->rg];
                    if (!brg)
                        goto err;
                }
            }
        }

        if (key[0] == 'M' && key[1] == 'D' && verbatim_MD) {
            if (verbatim_MD < 0) {
                key[2] = '*';
            } else if (MD) {
                aux = (char *)MD->s;
                aux_size = MD->l;
                aux_end = aux + aux_size;
            }
        }

        if (key[0] == 'N' && key[1] == 'M' && verbatim_NM) {
            if (verbatim_NM < 0) {
                key[2] = '*';
            } else if (NM != -1) {
                char tmp[12], *tp = tmp;
                int l = sprintf(tp, "i%d", NM);
                aux = tp;
                aux_size = l;
                aux_end = aux + aux_size;
            }
        }

        cram_tag_map *tm = cram_new_tag_map(filedescriptor, key);
        if (!tm)
            goto err;

        r = tm->codec->encode(s, tm->codec, (char *)aux + 3,
                              aux_end - (aux + 3));
        if (r != 0)
            goto err;

        BLOCK_APPEND(td_b, key, 3);
        TD_blk_size = BLOCK_SIZE(td_b);

        aux = (char *)aux_end;
        while (aux < (char *)bam_aux(b) + bam_get_l_aux(b) && *aux)
            aux++;
        aux++; // skip null terminator too.

        if (cram_stats_add(c->stats[DS_aux], aux_end - (aux + 3)) < 0)
            goto block_err;