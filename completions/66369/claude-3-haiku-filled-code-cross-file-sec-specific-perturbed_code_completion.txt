// Copy aux keys to td_b and aux values to slice aux blocks
while (aux_end - aux >= 1 && aux[0] != 0) {
    int r;

    // Room for code + type + at least 1 byte of data
    if (aux - orig >= aux_size - 3)
        goto err;

    // RG:Z
    if (aux[0] == 'R' && aux[1] == 'G' && aux[2] == 'Z') {
        // Read group
        char *rg = aux + 3;
        int rg_len = strlen(rg) + 1;
        brg = sam_hdr_find_rg(filedescriptor->header, rg);
        if (!brg) {
            // Add new read group
            brg = sam_hdr_add_rg(filedescriptor->header, rg);
            if (!brg)
                goto err;
        }
        BLOCK_APPEND(s->aux_blk, "RG", 2);
        BLOCK_APPEND_CHAR(s->aux_blk, 'Z');
        BLOCK_APPEND(s->aux_blk, rg, rg_len);
        cr->rg = brg->id;
    } else if (aux[0] == 'M' && aux[1] == 'D' && aux[2] == 'Z') {
        // MD:Z
        if (verbatim_MD) {
            BLOCK_APPEND(s->aux_blk, aux, aux_size - (aux - orig));
            cr->aux_size += aux_size - (aux - orig);
        } else {
            kstring_t *md = MD;
            if (!md) {
                md = malloc(sizeof(*md));
                if (!md)
                    goto err;
                ks_initialize(md);
            }
            r = cram_decode_MD(filedescriptor, b, md, aux + 3);
            if (r < 0)
                goto err;
            BLOCK_APPEND(s->aux_blk, "MD", 2);
            BLOCK_APPEND_CHAR(s->aux_blk, 'Z');
            BLOCK_APPEND(s->aux_blk, md->s, md->l);
            cr->aux_size += 3 + md->l;
            if (MD == NULL)
                ks_free(md);
        }
    } else if (aux[0] == 'N' && aux[1] == 'M' && aux[2] == 'i') {
        // NM:i
        if (verbatim_NM) {
            BLOCK_APPEND(s->aux_blk, aux, aux_size - (aux - orig));
            cr->aux_size += aux_size - (aux - orig);
        } else {
            int32_t nm = 0;
            r = cram_decode_NM(filedescriptor, b, &nm, aux + 3);
            if (r < 0)
                goto err;
            BLOCK_APPEND(s->aux_blk, "NM", 2);
            BLOCK_APPEND_CHAR(s->aux_blk, 'i');
            BLOCK_APPEND(s->aux_blk, (char *)&nm, 4);
            cr->aux_size += 6;
        }
    } else {
        // Other aux tags
        int key = (aux[0] << 16) | (aux[1] << 8) | aux[2];
        cram_map *m = map_find(c->comp_hdr->tag_encoding_map, aux, key);
        if (!m)
            goto err;

        BLOCK_APPEND(s->aux_blk, aux, 3);
        if (!m->codec || m->codec->decode(s, m->codec, td_b, s->aux_blk, &r) != 0)
            goto err;
        cr->aux_size += r + 3;
    }

    aux += 3;
    while (*aux != 0)
        aux++;
    aux++;
}

tm->blk->m = tm->m;