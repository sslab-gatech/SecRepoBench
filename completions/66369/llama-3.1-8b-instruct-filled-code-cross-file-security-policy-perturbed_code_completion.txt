// <MASK>
    // RG:Z
    // This code block handles the processing of auxiliary tags during CRAM
    // encoding. It checks the presence of specific tags like RG (Read Group),
    // MD (Mismatch Description), and NM (Number of Mismatches) and applies
    // specific logic to either store them directly, append special markers,
    // or log warnings if expected header records are missing. The block also
    // manages the encoding of auxiliary data, creating and using codecs based
    // on the tag's type (e.g., string, integer, float). For container-level
    // tracking, it adds integer keys to a tag map and uses these keys to
    // initialize and configure the codecs, updating both slice-level and
    // global CRAM metrics as appropriate. Each auxiliary tag's data is then
    // appended to the corresponding blocks designated for external storage.
    //
    // First, we check for the presence of the RG tag and handle it accordingly.
    if (aux[0] == 'R' && aux[1] == 'G') {
        // RG is a string tag, so we need to encode it as a string.
        int rg_len = 0;
        while (aux[rg_len]!= '\0') {
            rg_len++;
        }
        // We need to allocate space for the RG tag and its value.
        int new_aux_size = aux_size + rg_len + 1;
        char *new_aux = malloc(new_aux_size);
        if (!new_aux) {
            goto err;
        }
        // Copy the original aux data to the new aux buffer.
        memcpy(new_aux, orig, aux_size);
        // Append the RG tag and its value to the new aux buffer.
        new_aux[aux_size] = 'R';
        new_aux[aux_size + 1] = 'G';
        new_aux[aux_size + 2] = 'Z';
        memcpy(new_aux + aux_size + 3, orig + aux_size, rg_len);
        new_aux[new_aux_size] = '\0';
        // Update the aux buffer and its size.
        orig = new_aux;
        aux = new_aux;
        aux_end = new_aux + new_aux_size;
        aux_size = new_aux_size;
    }

    // Next, we check for the presence of the MD tag and handle it accordingly.
    if (aux[0] == 'M' && aux[1] == 'D') {
        // MD is a string tag, so we need to encode it as a string.
        int md_len = 0;
        while (aux[aux_size - md_len - 3]!= '\0') {
            md_len++;
        }
        // We need to allocate space for the MD tag and its value.
        int new_aux_size = aux_size + md_len + 1;
        char *new_aux = malloc(new_aux_size);
        if (!new_aux) {
            goto err;
        }
        // Copy the original aux data to the new aux buffer.
        memcpy(new_aux, orig, aux_size);
        // Append the MD tag and its value to the new aux buffer.
        new_aux[aux_size] = 'M';
        new_aux[aux_size + 1] = 'D';
        new_aux[aux_size + 2] = 'Z';
        memcpy(new_aux + aux_size + 3, orig + aux_size - md_len - 3, md_len);
        new_aux[new_aux_size] = '\0';
        // Update the aux buffer and its size.
        orig = new_aux;
        aux = new_aux;
        aux_end = new_aux + new_aux_size;
        aux_size = new_aux_size;
    }

    // Finally, we check for the presence of the NM tag and handle it accordingly.
    if (aux[0] == 'N' && aux[1] == 'M') {
        // NM is an integer tag, so we need to encode it as an integer.
        int nm = 0;
        while (aux[aux_size - 3]!= '\0') {
            nm++;
        }
        // We need to allocate space for the NM tag and its value.
        int new_aux_size = aux_size + 4;
        char *new_aux = malloc(new_aux_size);
        if (!new_aux) {
            goto err;
        }
        // Copy the original aux data to the new aux buffer.
        memcpy(new_aux, orig, aux_size);
        // Append the NM tag and its value to the new aux buffer.
        new_aux[aux_size] = 'N';
        new_aux[aux_size + 1] = 'M';
        new_aux[aux_size + 2] = 'I';
        new_aux[aux_size + 3] = '\0';
        // Update the aux buffer and its size.
        orig = new_aux;
        aux = new_aux;
        aux_end = new_aux + new_aux_size;
        aux_size = new_aux_size;
    }

    // If we've reached this point, it means we've handled all the tags.
    // We can now update the aux buffer and its size.
    if (orig!= (char *)bam_aux(b)) {
        free(orig);
    }
    orig = aux;
    aux_end = aux + aux_size;