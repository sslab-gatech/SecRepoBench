// Process auxiliary tags
        while (aux_end - aux >= 1 && aux[0] != 0) {
            int tag_size = 3; // Initial size for tag (2 chars + type)
            char tag[3] = { aux[0], aux[1], aux[2] };
            aux += 3; // Move past the tag

            // Determine the size of the data associated with the tag
            if (aux_end - aux < 1) goto err; // Ensure there's data
            char type = aux[0];
            aux++; // Move past the type

            if (type == 'Z' || type == 'H') {
                // String type, find the null terminator
                const char *str_start = aux;
                while (aux < aux_end && *aux != 0) {
                    aux++;
                }
                tag_size += (aux - str_start) + 1; // +1 for null terminator
                aux++; // Move past the null terminator
            } else if (type == 'i' || type == 'f') {
                tag_size += sizeof(int32_t); // Integer or float
                aux += sizeof(int32_t);
            } else {
                // Handle other types as needed
                goto err; // Unknown type
            }

            // Ensure we have enough space in the target block
            if (BLOCK_SIZE(s->aux_blk) + tag_size > MAX_AUX_SIZE) {
                hts_log_error("Auxiliary block size exceeded");
                goto block_err;
            }

            // Append the tag and its data to the auxiliary block
            BLOCK_APPEND(s->aux_blk, tag, tag_size);
            cr->aux_size += tag_size;
        }