// Copy aux keys to td_b and aux values to slice aux blocks
while (aux_end - aux >= 1 && aux[0] != 0) {
    int r;

    // Room for code + type + at least 1 byte of data
    if (aux - orig >= aux_size - 3)
        goto err;

    // RG:Z
    if (aux[0] == 'R' && aux[1] == 'G' && aux[2] == 'Z') {
        int rg_len = 0;
        const char *rg_start = aux + 3;

        // Find the end of the RG:Z tag
        while (aux_end - (aux + 3) > 0 && *(aux + 3 + rg_len) != 0) {
            rg_len++;
        }

        if (rg_len > 0) {
            char *rg_key = malloc(4);
            if (!rg_key)
                goto err;
            memcpy(rg_key, "RG:", 3);
            rg_key[3] = '\0';

            char *rg_value = malloc(rg_len + 1);
            if (!rg_value) {
                free(rg_key);
                goto err;
            }
            memcpy(rg_value, rg_start, rg_len);
            rg_value[rg_len] = '\0';

            BLOCK_APPEND(td_b, rg_key, 3);
            BLOCK_APPEND(td_b, rg_value, rg_len);
            BLOCK_APPEND_CHAR(td_b, '\0');

            free(rg_key);
            free(rg_value);
        }

        // Skip the RG:Z tag
        aux += 3 + rg_len + 1;
        continue;
    }

    // MD:Z
    if (aux[0] == 'M' && aux[1] == 'D' && aux[2] == 'Z') {
        int md_len = 0;
        const char *md_start = aux + 3;

        // Find the end of the MD:Z tag
        while (aux_end - (aux + 3) > 0 && *(aux + 3 + md_len) != 0) {
            md_len++;
        }

        if (md_len > 0) {
            char *md_key = malloc(4);
            if (!md_key)
                goto err;
            memcpy(md_key, "MD:", 3);
            md_key[3] = '\0';

            char *md_value = malloc(md_len + 1);
            if (!md_value) {
                free(md_key);
                goto err;
            }
            memcpy(md_value, md_start, md_len);
            md_value[md_len] = '\0';

            BLOCK_APPEND(td_b, md_key, 3);
            BLOCK_APPEND(td_b, md_value, md_len);
            BLOCK_APPEND_CHAR(td_b, '\0');

            free(md_key);
            free(md_value);
        }

        // Skip the MD:Z tag
        aux += 3 + md_len + 1;
        continue;
    }

    // NM:i
    if (aux[0] == 'N' && aux[1] == 'M' && aux[2] == 'i') {
        int nm_len = 0;
        const char *nm_start = aux + 3;

        // Find the end of the NM:i tag
        while (aux_end - (aux + 3) > 0 && *(aux + 3 + nm_len) != 0) {
            nm_len++;
        }

        if (nm_len > 0) {
            char *nm_key = malloc(4);
            if (!nm_key)
                goto err;
            memcpy(nm_key, "NM:", 3);
            nm_key[3] = '\0';

            char *nm_value = malloc(nm_len + 1);
            if (!nm_value) {
                free(nm_key);
                goto err;
            }
            memcpy(nm_value, nm_start, nm_len);
            nm_value[nm_len] = '\0';

            BLOCK_APPEND(td_b, nm_key, 3);
            BLOCK_APPEND(td_b, nm_value, nm_len);
            BLOCK_APPEND_CHAR(td_b, '\0');

            free(nm_key);
            free(nm_value);
        }

        // Skip the NM:i tag
        aux += 3 + nm_len + 1;
        continue;
    }

    // Skip other tags
    aux += 3;
}

// FIXME: sort BLOCK_DATA(td_b) by char[3] triples

// And and increment TD hash entry
BLOCK_APPEND_CHAR(td_b, 0);

// Duplicate key as BLOCK_DATA() can be realloced to a new pointer.
key = string_ndup(c->comp_hdr->TD_keys,
                  (char *)BLOCK_DATA(td_b) + TD_blk_size,
                  BLOCK_SIZE(td_b) - TD_blk_size);
if (!key)
    goto block_err;
k = kh_put(m_s2i, c->comp_hdr->TD_hash, key, &new);
if (new < 0) {
    goto err;
} else if (new == 0) {
    BLOCK_SIZE(td_b) = TD_blk_size;
} else {
    kh_val(c->comp_hdr->TD_hash, k) = c->comp_hdr->nTL;
    c->comp_hdr->nTL++;
}

cr->TL = kh_val(c->comp_hdr->TD_hash, k);
if (cram_stats_add(c->stats[DS_TL], cr->TL) < 0)
    goto block_err;

if (orig != (char *)bam_aux(b))
    free(orig);

if (err) *err = 0;

return brg;

err:
block_err:
if (orig != (char *)bam_aux(b))
    free(orig);
return NULL;