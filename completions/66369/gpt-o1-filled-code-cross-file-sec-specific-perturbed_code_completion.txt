while (aux < aux_end && aux[0]) {
    /* Ensure we have enough bytes for tag1, tag2, and type */
    if (aux_end - aux < 3)
        goto err;

    char t1 = aux[0], t2 = aux[1], ttype = aux[2];
    aux += 3;

    /* If we can't safely read even one data byte, bail */
    if (aux_end - aux < 1)
        goto err;

    /* Check for RG:Z to set brg if available in header */
    if (t1 == 'R' && t2 == 'G' && ttype == 'Z') {
        brg = sam_hdr_find_rg(filedescriptor->header, aux);
        if (!brg) {
            hts_log_warning("RG tag refers to read group '%s' missing in header", aux);
        }
    }

    /* For NM/MD, skip data if not verbatim, but emit placeholder */
    if ((t1 == 'N' && t2 == 'M' && !verbatim_NM) ||
        (t1 == 'M' && t2 == 'D' && !verbatim_MD)) {
        BLOCK_APPEND(td_b, &t1, 1);
        BLOCK_APPEND(td_b, &t2, 1);
        BLOCK_APPEND_CHAR(td_b, '*');

        /* Skip over the data for this tag safely */
        switch (ttype) {
        case 'A': case 'c': case 'C':
            if (aux_end - aux < 1) goto err;
            aux++;
            break;
        case 's': case 'S':
            if (aux_end - aux < 2) goto err;
            aux += 2;
            break;
        case 'i': case 'I': case 'f':
            if (aux_end - aux < 4) goto err;
            aux += 4;
            break;
        case 'd':
            if (aux_end - aux < 8) goto err;
            aux += 8;
            break;
        case 'Z': case 'H':
            /* Skip until we find a null terminator */
            while (aux < aux_end && *aux)
                aux++;
            if (aux < aux_end) aux++; /* consume the terminator if present */
            break;
        case 'B': {
            /* Arrays: type + 4-byte count + data */
            if (aux_end - aux < 5) goto err;
            /* skip the sub-type (1 byte) + count (4 bytes) */
            int32_t n;
            memcpy(&n, aux+1, 4);
            aux += 5;
            /* Each element depends on sub-type size */
            int elem_size;
            switch (*aux-5) {
            case 'c': case 'C': case 'A': elem_size = 1; break;
            case 's': case 'S': elem_size = 2; break;
            case 'i': case 'I': case 'f': elem_size = 4; break;
            case 'd': elem_size = 8; break;
            default: goto err;
            }
            if (n < 0 || (aux_end - aux) < (int64_t)n * elem_size) goto err;
            aux += n * elem_size;
            break;
        }
        default:
            goto err;
        }
    } else {
        /* Store the tag triple in TD block */
        BLOCK_APPEND(td_b, &t1, 1);
        BLOCK_APPEND(td_b, &t2, 1);
        BLOCK_APPEND(td_b, &ttype, 1);

        /* Copy the tag's value to the slice's aux block */
        switch (ttype) {
        case 'A': case 'c': case 'C':
            if (aux_end - aux < 1) goto err;
            BLOCK_APPEND(s->aux_blk, aux, 1);
            aux++;
            break;
        case 's': case 'S':
            if (aux_end - aux < 2) goto err;
            BLOCK_APPEND(s->aux_blk, aux, 2);
            aux += 2;
            break;
        case 'i': case 'I': case 'f':
            if (aux_end - aux < 4) goto err;
            BLOCK_APPEND(s->aux_blk, aux, 4);
            aux += 4;
            break;
        case 'd':
            if (aux_end - aux < 8) goto err;
            BLOCK_APPEND(s->aux_blk, aux, 8);
            aux += 8;
            break;
        case 'Z': case 'H': {
            /* Copy null-terminated string or hex data */
            char *z = aux;
            while (z < aux_end && *z)
                z++;
            if (z == aux_end) goto err; /* no terminator */
            size_t len = z - aux + 1;   /* includes terminator */
            BLOCK_APPEND(s->aux_blk, aux, len);
            aux += len;
            break;
        }
        case 'B': {
            /* Arrays: type + 4-byte count + data */
            if (aux_end - aux < 5) goto err;
            BLOCK_APPEND(s->aux_blk, aux, 5);
            int32_t n;
            memcpy(&n, aux+1, 4);
            aux += 5;
            if (n < 0) goto err;
            /* sub-type is in the first byte of the array data */
            int elem_size;
            switch (s->aux_blk->data[s->aux_blk->byte-5]) {
            case 'c': case 'C': case 'A': elem_size = 1; break;
            case 's': case 'S':           elem_size = 2; break;
            case 'i': case 'I': case 'f': elem_size = 4; break;
            case 'd':                     elem_size = 8; break;
            default: goto err;
            }
            if (aux_end - aux < (int64_t)n * elem_size) goto err;
            BLOCK_APPEND(s->aux_blk, aux, n * elem_size);
            aux += n * elem_size;
            break;
        }
        default:
            goto err;
        }
    }
}

/* Final update after processing all tags */
tm->blk->m = tm->m;