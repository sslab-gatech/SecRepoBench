if (aux[0] == 'R' && aux[1] == 'G' && aux[2] == 'Z') {
            if (!(brg = sam_hrecs_find_rg(filedescriptor->header->hrecs, aux+3))) {
                hts_log_warning("Read group %s not found in header", aux+3);
            }
        }

        if (aux[0] == 'M' && aux[1] == 'D' && aux[2] == 'Z') {
            if (verbatim_MD) {
                if (BLOCK_APPEND(s->aux_blk, aux, 3) < 0) goto block_err;
                if (BLOCK_APPEND(s->aux_blk, aux+3, strlen(aux+3)+1) < 0) goto block_err;
            }
            aux += 3 + strlen(aux+3) + 1;
            continue;
        }

        if (aux[0] == 'N' && aux[1] == 'M' && aux[2] == 'i') {
            if (verbatim_NM) {
                if (BLOCK_APPEND(s->aux_blk, aux, 3) < 0) goto block_err;
                if (BLOCK_APPEND(s->aux_blk, aux+3, 4) < 0) goto block_err;
            }
            aux += 3 + 4;
            continue;
        }

        if (aux[0] == 'S' && aux[1] == 'A' && aux[2] == 'Z') {
            if (BLOCK_APPEND(s->aux_blk, aux, 3) < 0) goto block_err;
            if (BLOCK_APPEND(s->aux_blk, aux+3, strlen(aux+3)+1) < 0) goto block_err;
            aux += 3 + strlen(aux+3) + 1;
            continue;
        }

        int32_t i32;
        uint32_t u32;
        float f;
        double d;
        char *aux_key = aux;
        aux += 2;

        if (aux_end - aux < 1) goto err;
        switch (*aux++) {
        case 'A':
            if (aux_end - aux < 1) goto err;
            if (BLOCK_APPEND(s->aux_blk, aux_key, 3) < 0) goto block_err;
            if (BLOCK_APPEND(s->aux_blk, aux, 1) < 0) goto block_err;
            aux++;
            break;

        case 'C':
            if (aux_end - aux < 1) goto err;
            if (BLOCK_APPEND(s->aux_blk, aux_key, 3) < 0) goto block_err;
            if (BLOCK_APPEND(s->aux_blk, aux, 1) < 0) goto block_err;
            aux++;
            break;

        case 'c':
            if (aux_end - aux < 1) goto err;
            if (BLOCK_APPEND(s->aux_blk, aux_key, 3) < 0) goto block_err;
            if (BLOCK_APPEND(s->aux_blk, aux, 1) < 0) goto block_err;
            aux++;
            break;

        case 'S':
            if (aux_end - aux < 2) goto err;
            if (BLOCK_APPEND(s->aux_blk, aux_key, 3) < 0) goto block_err;
            if (BLOCK_APPEND(s->aux_blk, aux, 2) < 0) goto block_err;
            aux += 2;
            break;

        case 's':
            if (aux_end - aux < 2) goto err;
            if (BLOCK_APPEND(s->aux_blk, aux_key, 3) < 0) goto block_err;
            if (BLOCK_APPEND(s->aux_blk, aux, 2) < 0) goto block_err;
            aux += 2;
            break;

        case 'I':
            if (aux_end - aux < 4) goto err;
            if (BLOCK_APPEND(s->aux_blk, aux_key, 3) < 0) goto block_err;
            if (BLOCK_APPEND(s->aux_blk, aux, 4) < 0) goto block_err;
            aux += 4;
            break;

        case 'i':
            if (aux_end - aux < 4) goto err;
            if (BLOCK_APPEND(s->aux_blk, aux_key, 3) < 0) goto block_err;
            if (BLOCK_APPEND(s->aux_blk, aux, 4) < 0) goto block_err;
            aux += 4;
            break;

        case 'f':
            if (aux_end - aux < 4) goto err;
            if (BLOCK_APPEND(s->aux_blk, aux_key, 3) < 0) goto block_err;
            if (BLOCK_APPEND(s->aux_blk, aux, 4) < 0) goto block_err;
            aux += 4;
            break;

        case 'd':
            if (aux_end - aux < 8) goto err;
            if (BLOCK_APPEND(s->aux_blk, aux_key, 3) < 0) goto block_err;
            if (BLOCK_APPEND(s->aux_blk, aux, 8) < 0) goto block_err;
            aux += 8;
            break;

        case 'Z': case 'H':
            if (BLOCK_APPEND(s->aux_blk, aux_key, 3) < 0) goto block_err;
            if (BLOCK_APPEND(s->aux_blk, aux, strlen(aux)+1) < 0) goto block_err;
            aux += strlen(aux)+1;
            break;

        case 'B': {
            int type = *aux++;
            int32_t count;
            if (aux_end - aux < 4) goto err;
            count = le_to_i32(aux);
            aux += 4;

            if (BLOCK_APPEND(s->aux_blk, aux_key, 3) < 0) goto block_err;
            if (BLOCK_APPEND_CHAR(s->aux_blk, 'B') < 0) goto block_err;
            if (BLOCK_APPEND_CHAR(s->aux_blk, type) < 0) goto block_err;
            if (BLOCK_APPEND(s->aux_blk, &count, 4) < 0) goto block_err;

            switch (type) {
            case 'c': case 'C':
                if (aux_end - aux < count) goto err;
                if (BLOCK_APPEND(s->aux_blk, aux, count) < 0) goto block_err;
                aux += count;
                break;

            case 's': case 'S':
                if (aux_end - aux < count*2) goto err;
                if (BLOCK_APPEND(s->aux_blk, aux, count*2) < 0) goto block_err;
                aux += count*2;
                break;

            case 'i': case 'I': case 'f':
                if (aux_end - aux < count*4) goto err;
                if (BLOCK_APPEND(s->aux_blk, aux, count*4) < 0) goto block_err;
                aux += count*4;
                break;

            default:
                hts_log_error("Unknown sub-type '%c' for aux type 'B'", type);
                goto err;
            }
            break;
        }

        default:
            hts_log_error("Unknown aux type '%c'", aux[-1]);
            goto err;
        }

        int key = (aux_key[0]<<16) | (aux_key[1]<<8) | aux_key[2];
        k = kh_put(m_s2i, c->tags_used, key, &new);
        if (-1 == new) goto err;
        if (new) {
            cram_tag_map *tm = malloc(sizeof(*tm));
            if (!tm) goto err;
            kh_val(c->tags_used, k) = tm;
            tm->codec = NULL;
            tm->blk = cram_new_block(EXTERNAL, key);
            if (!tm->blk) goto err;
            tm->blk2 = NULL;
            tm->m = 0;
        }
        cram_tag_map *tm = kh_val(c->tags_used, k);
        if (BLOCK_APPEND(tm->blk, aux_key, aux-aux_key) < 0) goto block_err;
    }