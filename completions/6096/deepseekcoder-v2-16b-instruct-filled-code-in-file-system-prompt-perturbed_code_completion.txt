}

static double FxEvaluateSubexpression(FxInfo *fx_info,const PixelChannel channel,
  const ssize_t x,const ssize_t y,const char *expression,size_t *depth,
  double *alpha,ExceptionInfo *exception)
{
  char
    *p,
    *q,
    subexpression[MagickPathExtent];

  const char
    *value;

  size_t
    level;

  p=expression;
  level=0;
  while ((*p != '\0') &&
         ((level != 1) || (strchr(")",(int) *p) == (char *) NULL)))
  {
    if (strchr("(",(int) *p) != (char *) NULL)
      level++;
    else
      if (strchr(")",(int) *p) != (char *) NULL)
        level--;
    p++;
  }
  if (*p == '\0')
    (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
      "UnbalancedParenthesis","`%s'",expression);
  *p='\0';
  p++;
  if (strchr("+-",(int) *p) != (char *) NULL)
    {
      char
        op;

      op=*p;
      p++;
      *alpha=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth,alpha,
        exception);
      if (op == '+')
        {
          double
            beta;

          beta=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth,alpha,
            exception);
          *alpha+=beta;
        }
      else
        {
          double
            beta;

          beta=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth,alpha,
            exception);
          *alpha-=beta;
        }
      return(*alpha);
    }
  if (strchr("*/",(int) *p) != (char *) NULL)
    {
      char
        op;

      op=*p;
      p++;
      *alpha=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth,alpha,
        exception);
      if (op == '*')
        {
          double
            beta;

          beta=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth,alpha,
            exception);
          *alpha*=beta;
        }
      else
        {
          double
            beta;

          beta=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth,alpha,
            exception);
          *alpha/=beta;
        }
      return(*alpha);
    }
  if (strchr("^",(int) *p) != (char *) NULL)
    {
      p++;
      *alpha=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth,alpha,
        exception);
      *alpha=pow(*alpha,*(alpha+1));
      return(*alpha);
    }
  if (strchr("!",(int) *p) != (char *) NULL)
    {
      p++;
      *alpha=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth,alpha,
        exception);
      *alpha=1.0-*alpha;
      return(*alpha);
    }
  if (strchr("~",(int) *p) != (char *) NULL)
    {
      p++;
      *alpha=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth,alpha,
        exception);
      *alpha=-(*alpha);
      return(*alpha);
    }
  if (strchr("&",(int) *p) != (char *) NULL)
    {
      p++;
      *alpha=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth,alpha,
        exception);
      *alpha=(*alpha != 0.0);
      return(*alpha);
    }
  if (strchr("|",(int) *p) != (char *) NULL)
    {
      p++;
      *alpha=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth,alpha,
        exception);
      *alpha=(*alpha != 0.0);
      return(*alpha);
    }
  if (strchr(".",(int) *p) != (char *) NULL)
    {
      p++;
      q=subexpression;
      while (isdigit((int) *p) != 0)
        *q++=*p++;
      *q='\0';
      *alpha=StringToDouble(subexpression,(char **) NULL);
      return(*alpha);
    }
  if (strchr("0123456789",(int) *p) != (char *) NULL)
    {
      q=subexpression;
      while (isdigit((int) *p) != 0)
        *q++=*p++;
      *q='\0';
      *alpha=StringToDouble(subexpression,(char **) NULL);
      return(*alpha);
    }
  if (*p == '(')
    {
      p++;
      *alpha=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth,alpha,
        exception);
      if (*p != ')')
        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
          "UnbalancedParenthesis","`%s'",expression);
      p++;
      return(*alpha);
    }
  if (*p == '[')
    {
      p++;
      q=subexpression;
      while (*p != '\0')
      {
        if (*p == '[')
          level++;
        else
          if (*p == ']')
            {
              level--;
              if (level == 0)
                break;
            }
        *q++=*p++;
      }
      *q='\0';
      p++;
      *alpha=FxEvaluateSubexpression(fx_info,channel,x,y,subexpression,depth,
        alpha,exception);
      return(*alpha);
    }
  if (*p == '{')
    {
      p++;
      q=subexpression;
      while (*p != '\0')
      {
        if (*p == '{')
          level++;
        else
          if (*p == '}')
            {
              level--;
              if (level == 0)
                break;
            }
        *q++=*p++;
      }
      *q='\0';
      p++;
      *alpha=FxEvaluateSubexpression(fx_info,channel,x,y,subexpression,depth,
        alpha,exception);
      return(*alpha);
    }
  if (*p == '\'')
    {
      p++;
      q=subexpression;
      while ((*p != '\'') && (*p != '\0'))
        *q++=*p++;
      if (*p == '\'')
        p++;
      *q='\0';
      *alpha=FxGetSymbol(fx_info,channel,x,y,subexpression,exception);
      return(*alpha);
    }
  *alpha=FxGetSymbol(fx_info,channel,x,y,p,exception);
  return(*alpha);
}

static double FxEvaluateExpression(FxInfo *fx_info,double *alpha,
  ExceptionInfo *exception)
{
  char
    *p,
    subexpression[MagickPathExtent];

  size_t
    depth;

  p=fx_info->expression;
  depth=0;
  *alpha=FxEvaluateSubexpression(fx_info,UndefinedPixelChannel,0,0,p,
    &depth,alpha,exception);
  return(*alpha);
}

static double FxEvaluateChannelExpression(FxInfo *fx_info,
  const PixelChannel channel,const ssize_t x,const ssize_t y,
  double *alpha,ExceptionInfo *exception)
{
  char
    *p,
    subexpression[MagickPathExtent];

  size_t
    depth;

  p=fx_info->expression;
  depth=0;
  *alpha=FxEvaluateSubexpression(fx_info,channel,x,y,p,
    &depth,alpha,exception);
  return(*alpha);
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%     G e n e r a t e D i f f e r e n t i a l N o i s e                       %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  GenerateDifferentialNoise() generates differential noise.
%
%  The format of the GenerateDifferentialNoise method is:
%
%      double GenerateDifferentialNoise(RandomInfo *random_info,
%        const Quantum pixel,const NoiseType noise_type,const double attenuate)
%
%  A description of each parameter follows:
%
%    o random_info: the random number generator state.
%
%    o pixel: the pixel value.
%
%    o noise_type: the type of noise: Uniform, Gaussian, Multiplicative,
%      Impulse, Laplacian, or Poisson.
%
%    o attenuate: attenuate the random distribution.
%
*/
static double GenerateDifferentialNoise(RandomInfo *random_info,
  const Quantum pixel,const NoiseType noise_type,const double attenuate)
{
  double
    noise;

  switch (noise_type)
  {
    case UniformNoise:
      noise=RandomDouble(random_info);
      noise=2.0*noise-1.0;
      noise*=attenuate;
      return(noise);
    case GaussianNoise:
      noise=RandomDouble(random_info);
      noise=2.0*noise-1.0;
      noise=GaussianRandom(noise);
      noise*=attenuate;
      return(noise);
    case MultiplicativeNoise:
      noise=RandomDouble(random_info);
      noise=2.0*noise-1.0;
      noise*=attenuate;
      noise*=pixel;
      return(noise);
    case ImpulseNoise:
      noise=RandomDouble(random_info);
      if (noise < 0.5)
        return(0.0);
      return(pixel);
    case LaplacianNoise:
      noise=RandomDouble(random_info);
      noise=2.0*noise-1.0;
      noise=LaplacianRandom(noise);
      noise*=attenuate;
      return(noise);
    case PoissonNoise:
      noise=RandomDouble(random_info);
      noise=PoissonRandom(pixel,noise);
      noise*=attenuate;
      return(noise);
    default:
      return(0.0);
  }
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%     I n i t i a l i z e C o m p o s i t e O p e r a t o r S t a t e           %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  InitializeCompositeOperatorState() initializes the composite operator
%  state.
%
%  The format of the InitializeCompositeOperatorState method is:
%
%      MagickBooleanType InitializeCompositeOperatorState(void)
%
*/
MagickPrivate MagickBooleanType InitializeCompositeOperatorState(void)
{
  if (composite_info.initialized == MagickFalse)
    {
      composite_info.initialized=MagickTrue;
      composite_info.operators[AddCompositeOp].blend=128;
      composite_info.operators[AddCompositeOp].code=AddCompositeOp;
      composite_info.operators[AtopCompositeOp].blend=128;
      composite_info.operators[AtopCompositeOp].code=AtopCompositeOp;
      composite_info.operators[BlendCompositeOp].blend=128;
      composite_info.operators[BlendCompositeOp].code=BlendCompositeOp;
      composite_info.operators[BumpmapCompositeOp].blend=128;
      composite_info.operators[BumpmapCompositeOp].code=BumpmapCompositeOp;
      composite_info.operators[ChangeMaskCompositeOp].blend=128;
      composite_info.operators[ChangeMaskCompositeOp].code=ChangeMaskCompositeOp;
      composite_info.operators[ClearCompositeOp].blend=0;
      composite_info.operators[ClearCompositeOp].code=ClearCompositeOp;
      composite_info.operators[ColorBurn