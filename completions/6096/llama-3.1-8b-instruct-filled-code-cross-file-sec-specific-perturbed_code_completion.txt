// Check if the expression starts with a parenthesis '('.
  // If it does, increase the recursion depth counter.
  // Throw an exception if the recursion depth exceeds the maximum allowed depth.
  // Copy the expression without the outer parentheses to a subexpression string.
  // Evaluate the subexpression recursively by calling FxEvaluateSubexpression.
  // Decrease the recursion depth counter after evaluation.
  // Return the result of the evaluated subexpression.
  switch (*expression)
  {
    case '(':
    {
      if (*recursion_depth >= FxMaxParenthesisDepth)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            "RecursionDepthExceeded","`%s'",expression);
          FxResult(0.0);
        }
      *recursion_depth++;
      subexpression=AcquireString((const char *) NULL);
      (void) CopyMagickString(subexpression,expression+1,MagickPathExtent);
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,subexpression,recursion_depth,
        beta,exception);
      *recursion_depth--;
      FxResult(alpha);
    }
    case ')':
    {
      if (*recursion_depth == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            "ParenthesisMismatch","`%s'",expression);
          FxResult(0.0);
        }
      *recursion_depth--;
      FxResult(0.0);
    }
    default:
      break;
  }