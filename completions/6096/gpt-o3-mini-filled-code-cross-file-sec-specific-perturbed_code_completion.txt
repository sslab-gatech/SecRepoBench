if (*expression == '(')
{
  (*recursion_depth)++;
  if (*recursion_depth > FxMaxParenthesisDepth)
  {
    (void) ThrowMagickException(exception, GetMagickModule(), OptionError,
      "ParenthesisDepthExceeded", "`%s'", expression);
    FxResult(0.0);
  }
  /* Find the matching closing parenthesis. */
  const char *p_end = expression + 1;
  int paren_depth = 1;
  while (*p_end != '\0' && paren_depth > 0)
  {
    if (*p_end == '(')
      paren_depth++;
    else if (*p_end == ')')
      paren_depth--;
    p_end++;
  }
  if (paren_depth != 0)
  {
    (void) ThrowMagickException(exception, GetMagickModule(), OptionError,
      "UnbalancedParentheses", "`%s'", expression);
    FxResult(0.0);
  }
  /* Copy the expression without the outer parentheses */
  size_t len = (size_t)(p_end - expression) - 2;
  if (len >= MagickPathExtent)
    len = MagickPathExtent - 1;
  memmove(subexpression, expression + 1, len);
  subexpression[len] = '\0';
  double value = FxEvaluateSubexpression(fx_info, channel, x, y, subexpression,
    recursion_depth, beta, exception);
  (*recursion_depth)--;
  FxResult(value);
}