if (*expression == '(')
{
  /*
    Increase recursion depth and check if it exceeds the maximum allowed.
  */
  expression++;
  (*recursion_depth)++;
  if (*recursion_depth > FxMaxParenthesisDepth)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
        "ExpressionRecursionDepthExceeded","`%s'",expression);
      FxResult(0.0);
    }

  /*
    Find the matching closing parenthesis.
  */
  {
    size_t level=1;
    const char *start=expression;
    while ((*expression != '\0') && (level > 0))
      {
        if (*expression == '(')
          level++;
        else
          if (*expression == ')')
            level--;
        expression++;
      }
    if (level != 0)
      {
        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
          "UnableToParseExpression","`%s'",start-1);
        FxResult(0.0);
      }
    {
      /*
        Extract the subexpression without parentheses.
      */
      size_t length=(size_t) (expression-1 - start);
      if (length >= MagickPathExtent)
        length=MagickPathExtent-1;
      (void) CopyMagickString(subexpression,start,length+1);
      subexpression[length]='\0';
    }
  }

  /*
    Evaluate the subexpression recursively and decrease recursion depth.
  */
  alpha=FxEvaluateSubexpression(fx_info,channel,x,y,subexpression,
    recursion_depth,beta,exception);
  (*recursion_depth)--;
  FxResult(alpha);
}