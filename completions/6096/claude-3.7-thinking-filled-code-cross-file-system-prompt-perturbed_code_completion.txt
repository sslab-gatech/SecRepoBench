if (*expression == '(')
{
  register const char *e = expression + 1;
  size_t depth = 1;
  
  (*recursion_depth)++;
  if (*recursion_depth > FxMaxParenthesisDepth)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
        "UnableToParseExpression","`%s'",expression);
      FxResult(0.0);
    }
  
  // Find the matching closing parenthesis
  while ((*e != '\0') && (depth > 0))
  {
    if (*e == '(')
      depth++;
    else if (*e == ')')
      depth--;
    if (depth > 0)
      e++;
  }
  
  if (depth > 0)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
        "UnableToParseExpression","`%s'",expression);
      FxResult(0.0);
    }
  
  // Copy the subexpression without the outer parentheses
  (void) CopyMagickString(subexpression, expression + 1, (size_t) (e - expression));
  
  alpha = FxEvaluateSubexpression(fx_info, channel, x, y, subexpression,
    recursion_depth, beta, exception);
    
  (*recursion_depth)--;
  
  FxResult(alpha);
}