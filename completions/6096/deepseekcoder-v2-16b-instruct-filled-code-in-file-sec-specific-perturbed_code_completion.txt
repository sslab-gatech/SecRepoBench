);
  if (value != (const char *) NULL)
    return(QuantumScale*StringToDouble(value,(char **) NULL));
  (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
    "UndefinedSymbol","`%s'",symbol);
  return(0.0);
}

static double FxEvaluateSubexpression(FxInfo *fx_info,const PixelChannel channel,
  const ssize_t x,const ssize_t y,const char *expression,size_t *depth,
  double *alpha,ExceptionInfo *exception)
{
  char
    *p,
    *q,
    subexpression[MagickPathExtent];

  double
    beta,
    gamma,
    value;

  size_t
    level;

  p=expression;
  level=0;
  while ((*p != '\0') &&
         ((level != 1) || (strchr(")",(int) *p) == (char *) NULL)))
  {
    if (strchr("(",(int) *p) != (char *) NULL)
      level++;
    else
      if (strchr(")",(int) *p) != (char *) NULL)
        level--;
    p++;
  }
  if (*p == '\0')
    (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
      "UnbalancedParenthesis","`%s'",expression);
  *p='\0';
  p++;
  if (strchr("+-",(int) *p) != (char *) NULL)
    {
      char
        operator;

      operator=*p;
      p++;
      beta=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth,alpha,exception);
      if (operator == '+')
        return(*alpha+beta);
      return(*alpha-beta);
    }
  if (strchr("*/",(int) *p) != (char *) NULL)
    {
      char
        operator;

      operator=*p;
      p++;
      beta=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth,alpha,exception);
      if (operator == '*')
        return(*alpha*beta);
      return(*alpha/beta);
    }
  if (strchr("^",(int) *p) != (char *) NULL)
    {
      p++;
      beta=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth,alpha,exception);
      return(pow(*alpha,beta));
    }
  if (strchr("~",(int) *p) != (char *) NULL)
    {
      p++;
      beta=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth,alpha,exception);
      return(-beta);
    }
  if (strchr("!",(int) *p) != (char *) NULL)
    {
      p++;
      beta=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth,alpha,exception);
      return(1.0-beta);
    }
  if (strchr("&",(int) *p) != (char *) NULL)
    {
      p++;
      beta=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth,alpha,exception);
      return((*alpha != 0.0) && (beta != 0.0) ? 1.0 : 0.0);
    }
  if (strchr("|",(int) *p) != (char *) NULL)
    {
      p++;
      beta=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth,alpha,exception);
      return((*alpha != 0.0) || (beta != 0.0) ? 1.0 : 0.0);
    }
  if (strchr("(",(int) *p) != (char *) NULL)
    {
      p++;
      q=subexpression;
      level=1;
      while ((*p != '\0') && (level != 0))
      {
        if (strchr("(",(int) *p) != (char *) NULL)
          level++;
        else
          if (strchr(")",(int) *p) != (char *) NULL)
            level--;
        *q++=*p++;
      }
      *q='\0';
      p++;
      beta=FxEvaluateSubexpression(fx_info,channel,x,y,subexpression,depth,
        alpha,exception);
      if (strchr("+-",(int) *p) != (char *) NULL)
        {
          char
            operator;

          operator=*p;
          p++;
          gamma=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth,alpha,
            exception);
          if (operator == '+')
            return(beta+gamma);
          return(beta-gamma);
        }
      if (strchr("*/",(int) *p) != (char *) NULL)
        {
          char
            operator;

          operator=*p;
          p++;
          gamma=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth,alpha,
            exception);
          if (operator == '*')
            return(beta*gamma);
          return(beta/gamma);
        }
      if (strchr("^",(int) *p) != (char *) NULL)
        {
          p++;
          gamma=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth,alpha,
            exception);
          return(pow(beta,gamma));
        }
      return(beta);
    }
  if (strchr("0123456789",(int) *p) != (char *) NULL)
    {
      value=StringToDouble(p,(char **) NULL);
      while ((*p != '\0') && (strchr("0123456789.",(int) *p) != (char *) NULL))
        p++;
      if (*p == '.')
        p++;
      while ((*p != '\0') && (strchr("0123456789",(int) *p) != (char *) NULL))
        p++;
      return(value);
    }
  if (strchr(".",(int) *p) != (char *) NULL)
    {
      p++;
      while ((*p != '\0') && (strchr("0123456789",(int) *p) != (char *) NULL))
        p++;
      return(0.0);
    }
  if (strchr("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
      (int) *p) != (char *) NULL)
    {
      value=FxGetSymbol(fx_info,channel,x,y,p,exception);
      while ((*p != '\0') &&
             (strchr("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
               (int) *p) != (char *) NULL))
        p++;
      return(value);
    }
  (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
    "UnableToParseExpression","`%s'",expression);
  return(0.0);
}

static double FxEvaluateChannelExpression(FxInfo *fx_info,
  const PixelChannel channel,const ssize_t x,const ssize_t y,
  double *alpha,ExceptionInfo *exception)
{
  char
    expression[MagickPathExtent];

  size_t
    depth;

  depth=0;
  (void) CopyMagickString(expression,fx_info->expression,MagickPathExtent);
  *alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression,&depth,alpha,
    exception);
  return(*alpha);
}

static double FxEvaluateExpression(FxInfo *fx_info,double *alpha,
  ExceptionInfo *exception)
{
  char
    expression[MagickPathExtent];

  size_t
    depth;

  depth=0;
  (void) CopyMagickString(expression,fx_info->expression,MagickPathExtent);
  *alpha=FxEvaluateSubexpression(fx_info,(PixelChannel) UndefinedPixelChannel,
    (ssize_t) -1,(ssize_t) -1,expression,&depth,alpha,exception);
  return(*alpha);
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%     G e n e r a t e D i f f e r e n t i a l N o i s e                       %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  GenerateDifferentialNoise() generates differential noise.
%
%  The format of the GenerateDifferentialNoise method is:
%
%      double GenerateDifferentialNoise(RandomInfo *random_info,
%        const Quantum pixel,const NoiseType noise_type,const double attenuate)
%
%  A description of each parameter follows:
%
%    o random_info: the random number generator state.
%
%    o pixel: the pixel value.
%
%    o noise_type: the type of noise: Uniform, Gaussian, Multiplicative,
%      Impulse, Laplacian, or Poisson.
%
%    o attenuate: attenuate the random distribution.
%
*/
static double GenerateDifferentialNoise(RandomInfo *random_info,
  const Quantum pixel,const NoiseType noise_type,const double attenuate)
{
  double
    noise;

  switch (noise_type)
  {
    case UniformNoise:
      noise=RandomDouble(random_info);
      noise=(noise-0.5)*attenuate;
      break;
    case GaussianNoise:
      noise=RandomDouble(random_info);
      noise=(noise-0.5)*attenuate;
      break;
    case MultiplicativeNoise:
      noise=RandomDouble(random_info);
      noise=(noise-0.5)*attenuate;
      noise*=pixel;
      break;
    case ImpulseNoise:
      noise=RandomDouble(random_info);
      if (noise < attenuate)
        noise=0.0;
      else
        noise=pixel;
      break;
    case LaplacianNoise:
      noise=RandomDouble(random_info);
      noise=(noise-0.5)*attenuate;
      noise*=fabs(noise);
      break;
    case PoissonNoise:
      noise=RandomDouble(random_info);
      noise=floor(pixel+pixel*(noise-0.5)*attenuate);
      break;
    default:
      noise=0.0;
      break;
  }
  return(noise);
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%     I n i t i a l i z e C o l o r M a t r i x                               %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  InitializeColorMatrix() initializes a color matrix.
%
%  The format of the InitializeColorMatrix method is:
%
%      void InitializeColorMatrix(double color_matrix[6][6])
%
%  A description of each parameter follows:
%
%    o color_matrix: the color matrix.
%
*/
static void InitializeColorMatrix(double color_matrix[6][6])
{
  register ssize_t
    i,
    j;

  for (i=0; i < 6; i++)
    for (j=0; j < 6; j++)
      color_matrix[i][j]=0.0;
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%     I n i t i a l i z e F x I n f o                                         %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  InitializeFxInfo() initializes an FxInfo structure.
%
%  The format of the InitializeFxInfo method is:
%
%      void InitializeFxInfo(FxInfo *fx_info)
%
%  A description of each parameter follows:
%
%    o fx_info: the fx info.
%
*/
static void InitializeFxInfo(FxInfo *fx_info)
{
  fx_info->colors=NewSplayTree(CompareSplayTreeString,RelinquishMagickMemory,
    RelinquishMagickMemory);
  fx_