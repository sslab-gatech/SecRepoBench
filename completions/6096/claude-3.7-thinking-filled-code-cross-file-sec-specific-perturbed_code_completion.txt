if (*expression == '(')
{
  const char *p;
  size_t parenthesis_depth = 1;  // We start with one open parenthesis
  
  (*recursion_depth)++;
  if (*recursion_depth > FxMaxParenthesisDepth)
  {
    (void) ThrowMagickException(exception, GetMagickModule(), OptionError,
      "ParenthesisNestedTooDeeply", "`%s'", expression);
    FxResult(0.0);
  }
  
  // Find the matching closing parenthesis
  p = expression + 1;
  while (*p != '\0')
  {
    if (*p == '(')
      parenthesis_depth++;
    else if (*p == ')')
    {
      parenthesis_depth--;
      if (parenthesis_depth == 0)
        break;
    }
    p++;
  }
  
  if (parenthesis_depth != 0)
  {
    (void) ThrowMagickException(exception, GetMagickModule(), OptionError,
      "UnbalancedParenthesis", "`%s'", expression);
    FxResult(0.0);
  }
  
  // Copy the inner expression (without the outer parentheses)
  (void) CopyMagickString(subexpression, expression + 1, 
                        MagickMin((size_t)(p - expression), MagickPathExtent));
  
  // Evaluate the subexpression
  alpha = FxEvaluateSubexpression(fx_info, channel, x, y, subexpression,
    recursion_depth, beta, exception);
  
  (*recursion_depth)--;
  FxResult(alpha);
}