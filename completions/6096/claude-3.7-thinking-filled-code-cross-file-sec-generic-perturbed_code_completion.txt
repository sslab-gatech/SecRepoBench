if (*expression == '(')
{
  const char *p;
  size_t depth;

  (*recursion_depth)++;
  if (*recursion_depth > FxMaxParenthesisDepth)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
        "ParenthesisNestedTooDeeply","`%s'",expression);
      FxResult(0.0);
    }
  
  /* Find the matching closing parenthesis */
  p = expression + 1;
  depth = 1;
  while ((*p != '\0') && (depth > 0))
  {
    if (*p == '(')
      depth++;
    else if (*p == ')')
      depth--;
    if (depth > 0)
      p++;
  }
  
  if (depth != 0)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
        "UnbalancedParenthesis","`%s'",expression);
      FxResult(0.0);
    }
  
  /* Copy the content between parentheses to subexpression */
  (void) CopyMagickString(subexpression, expression + 1, (size_t) (p - expression));
  
  gamma = FxEvaluateSubexpression(fx_info, channel, x, y, subexpression,
    recursion_depth, beta, exception);
  
  (*recursion_depth)--;
  FxResult(gamma);
}