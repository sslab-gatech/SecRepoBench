if (*expression == '(')
{
  /*
    Increase recursion depth.  Throw if we exceed the maximum allowed depth.
  */
  (*recursion_depth)++;
  if (*recursion_depth > FxMaxParenthesisDepth)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
        "SubexpressionRecursionDepthExceeded","`%s'",expression);
      FxResult(0.0);
    }

  /*
    Find the corresponding closing parenthesis, ensuring nested parentheses
    are matched. If unmatched, throw an exception.
  */
  {
    const char
      *start = expression + 1,
      *end = start;

    size_t
      level = 1;

    while ((*end != '\0') && (level > 0))
      {
        if (*end == '(')
          level++;
        else if (*end == ')')
          level--;
        end++;
      }
    if (level != 0)
      {
        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
          "UnableToParseExpression","`%s'",expression);
        FxResult(0.0);
      }

    /*
      Copy everything between the outer parentheses into subexpression, then
      evaluate that subexpression recursively.
    */
    {
      size_t length = (size_t) (end - 1 - start);
      if (length >= MagickPathExtent)
        length = MagickPathExtent - 1;
      (void) CopyMagickString(subexpression, start, length + 1);
      subexpression[length] = '\0';
      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,subexpression,
        recursion_depth,beta,exception);
    }
  }

  /*
    Decrease recursion depth and return the subexpression result.
  */
  (*recursion_depth)--;
  FxResult(alpha);
}