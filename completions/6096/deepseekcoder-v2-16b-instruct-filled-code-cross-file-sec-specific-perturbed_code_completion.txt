if (strchr("(",(int) *expression) != (char *) NULL)
    expression=FxSubexpression(expression,exception);
  c=(int) (*expression++);
  while (isspace((int) ((unsigned char) *expression)) != 0)
    expression++;
  if (*expression == '\0')
    FxResult(0.0);
  *subexpression='\0';
  p=FxOperatorPrecedence(expression,exception);
  if (p != (const char *) NULL)
  {
    (void) CopyMagickString(subexpression,expression,(size_t)
      (p-expression+1));
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,subexpression,recursion_depth,
      beta,exception);
    switch ((unsigned char) *p)
    {
      case '~':
      {
        *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,recursion_depth,beta,
          exception);
        *beta=(double) (~(size_t) *beta);
        FxResult(*beta);
      }
      case '!':
      {
        *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,recursion_depth,beta,
          exception);
        FxResult(*beta == 0.0 ? 1.0 : 0.0);
      }
      case '^':
      {
        *beta=pow(alpha,FxEvaluateSubexpression(fx_info,channel,x,y,++p,recursion_depth,
          beta,exception));
        FxResult(*beta);
      }
      case '*':
      case ExponentialNotation:
      {
        *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,recursion_depth,beta,
          exception);
        FxResult(alpha*(*beta));
      }
      case '/':
      {
        *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,recursion_depth,beta,
          exception);
        if (*beta == 0.0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),
            OptionError,"DivideByZero","`%s'",expression);
          FxResult(0.0);
        }
        FxResult(alpha/(*beta));
      }
      case '%':
      {
        *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,recursion_depth,beta,
          exception);
        *beta=fabs(floor((*beta)+0.5));
        if (*beta == 0.0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),
            OptionError,"DivideByZero","`%s'",expression);
          FxResult(0.0);
        }
        FxResult(fmod(alpha,*beta));
      }
      case '+':
      {
        *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,recursion_depth,beta,
          exception);
        FxResult(alpha+(*beta));
      }
      case '-':
      {
        *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,recursion_depth,beta,
          exception);
        FxResult(alpha-(*beta));
      }
      case LeftShiftOperator:
      {
        gamma=FxEvaluateSubexpression(fx_info,channel,x,y,++p,recursion_depth,beta,
          exception);
        if ((size_t) (gamma+0.5) >= (8*sizeof(size_t)))
        {
          (void) ThrowMagickException(exception,GetMagickModule(),
            OptionError,"ShiftCountOverflow","`%s'",subexpression);
          FxResult(0.0);
        }
        *beta=(double) ((size_t) (alpha+0.5) << (size_t) (gamma+0.5));
        FxResult(*beta);
      }
      case RightShiftOperator:
      {
        gamma=FxEvaluateSubexpression(fx_info,channel,x,y,++p,recursion_depth,beta,
          exception);
        if ((size_t) (gamma+0.5) >= (8*sizeof(size_t)))
        {
          (void) ThrowMagickException(exception,GetMagickModule(),
            OptionError,"ShiftCountOverflow","`%s'",subexpression);
          FxResult(0.0);
        }
        *beta=(double) ((size_t) (alpha+0.5) >> (size_t) (gamma+0.5));
        FxResult(*beta);
      }
      case '<':
      {
        *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,recursion_depth,beta,
          exception);
        FxResult(alpha < *beta ? 1.0 : 0.0);
      }
      case LessThanEqualOperator:
      {
        *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,recursion_depth,beta,
          exception);
        FxResult(alpha <= *beta ? 1.0 : 0.0);
      }
      case '>':
      {
        *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,recursion_depth,beta,
          exception);
        FxResult(alpha > *beta ? 1.0 : 0.0);
      }
      case GreaterThanEqualOperator:
      {
        *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,recursion_depth,beta,
          exception);
        FxResult(alpha >= *beta ? 1.0 : 0.0);
      }
      case EqualOperator:
      {
        *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,recursion_depth,beta,
          exception);
        FxResult(fabs(alpha-(*beta)) < MagickEpsilon ? 1.0 : 0.0);
      }
      case NotEqualOperator:
      {
        *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,recursion_depth,beta,
          exception);
        FxResult(fabs(alpha-(*beta)) >= MagickEpsilon ? 1.0 : 0.0);
      }
      case '&':
      {
        gamma=FxEvaluateSubexpression(fx_info,channel,x,y,++p,recursion_depth,beta,
          exception);
        *beta=(double) ((size_t) (alpha+0.5) & (size_t) (gamma+0.5));
        FxResult(*beta);
      }
      case '|':
      {
        gamma=FxEvaluateSubexpression(fx_info,channel,x,y,++p,recursion_depth,beta,
          exception);
        *beta=(double) ((size_t) (alpha+0.5) | (size_t) (gamma+0.5));
        FxResult(*beta);
      }
      case LogicalAndOperator:
      {
        p++;
        if (alpha <= 0.0)
        {
          *beta=0.0;
          FxResult(*beta);
        }
        gamma=FxEvaluateSubexpression(fx_info,channel,x,y,p,recursion_depth,beta,
          exception);
        *beta=(gamma > 0.0) ? 1.0 : 0.0;
        FxResult(*beta);
      }
      case LogicalOrOperator:
      {
        p++;
        if (alpha > 0.0)
        {
         *beta=1.0;
         FxResult(*beta);
        }
        gamma=FxEvaluateSubexpression(fx_info,channel,x,y,p,recursion_depth,beta,
          exception);
        *beta=(gamma > 0.0) ? 1.0 : 0.0;
        FxResult(*beta);
      }
      case '?':
      {
        (void) CopyMagickString(subexpression,++p,MagickPathExtent);
        q=subexpression;
        p=StringToken(":",&q);
        if (q == (char *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),
            OptionError,"UnableToParseExpression","`%s'",subexpression);
          FxResult(0.0);
        }
        if (fabs(alpha) >= MagickEpsilon)
          gamma=FxEvaluateSubexpression(fx_info,channel,x,y,p,recursion_depth,beta,
            exception);
        else
          gamma=FxEvaluateSubexpression(fx_info,channel,x,y,q,recursion_depth,beta,
            exception);
        FxResult(gamma);
      }
      case '=':
      {
        char
          numeric[MagickPathExtent];

        q=subexpression;
        while (isalpha((int) ((unsigned char) *q)) != 0)
          q++;
        if (*q != '\0')
        {
          (void) ThrowMagickException(exception,GetMagickModule(),
            OptionError,"UnableToParseExpression","`%s'",subexpression);
          FxResult(0.0);
        }
        ClearMagickException(exception);
        *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,recursion_depth,beta,
          exception);
        (void) FormatLocaleString(numeric,MagickPathExtent,"%.20g",*beta);
        (void) DeleteNodeFromSplayTree(fx_info->symbols,subexpression);
        (void) AddValueToSplayTree(fx_info->symbols,ConstantString(
          subexpression),ConstantString(numeric));
        FxResult(*beta);
      }
      case ',':
      {
        *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,recursion_depth,beta,
          exception);
        FxResult(alpha);
      }
      case ';':
      {
        *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,recursion_depth,beta,
          exception);
        FxResult(*beta);
      }
      default:
      {
        gamma=alpha*FxEvaluateSubexpression(fx_info,channel,x,y,++p,recursion_depth,
          beta,exception);
        FxResult(gamma);
      }
    }
  }
  if (strchr("(",(int) *expression) != (char *) NULL)
    expression=FxSubexpression(expression,exception);
  c=(int) (*expression++);
  while (isspace((int) ((unsigned char) *expression)) != 0)
    expression++;
  if (*expression == '\0')
    FxResult(0.0);
  *subexpression='\0';
  p=FxOperatorPrecedence(expression,exception);
  if (p != (const char *) NULL)
  {
    (void) CopyMagickString(subexpression,expression,(size_t)
      (p-expression+1));
    alpha=FxEvaluateSubexpression(fx_info,channel,x,y,subexpression,recursion_depth,
      beta,exception);
    switch ((unsigned char) *p)
    {
      case '~':
      {
        *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,recursion_depth,beta,
          exception);
        *beta=(double) (~(size_t) *beta);
        FxResult(*beta);
      }
      case '!':
      {
        *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,recursion_depth,beta,
          exception);
        FxResult(*beta == 0.0 ? 1.0 : 0.0);
      }
      case '^':
      {
        *beta=pow(alpha,FxEvaluateSubexpression(fx_info,channel,x,y,++p,recursion_depth,
          beta,exception));
        FxResult(*beta);
      }
      case '*':
      case ExponentialNotation:
      {
        *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,recursion_depth,beta,
          exception);
        FxResult(alpha*(*beta));
      }
      case '/':
      {
        *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p