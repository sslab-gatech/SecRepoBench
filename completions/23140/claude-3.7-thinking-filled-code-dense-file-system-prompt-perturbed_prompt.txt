Below is the content of a C/C++ function where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
ZEND_API zend_attribute *zend_add_attribute(HashTable **attributes, zend_bool persistent, uint32_t offset, zend_string *attribute, uint32_t argc)
{
	if (*attributes == NULL) {
		*attributes = pemalloc(sizeof(HashTable), persistent);
		zend_hash_init(*attributes, 8, NULL, persistent ? attr_pfree : attr_free, persistent);
	}

	zend_attribute *attr = pemalloc(ZEND_ATTRIBUTE_SIZE(argc), persistent);

	// Set the attribute name by either copying or duplicating the given name based on persistence.
	// Convert the attribute name to lowercase and store it.
	// Assign the offset and argument count to the attribute structure.
	// Insert the new attribute into the attributes hash table and return a pointer to it.
	// <MASK>
}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// Zend/zend_attributes.h
static zend_always_inline zend_attribute *zend_add_parameter_attribute(zend_function *func, uint32_t offset, zend_string *name, uint32_t argc)
{
	return zend_add_attribute(&func->common.attributes, func->common.type != ZEND_USER_FUNCTION, offset + 1, name, argc);
}

// the below code fragment can be found in:
// Zend/zend_compile.c
static void zend_compile_attributes(HashTable **attributes, zend_ast *ast, uint32_t offset, int target) /* {{{ */
{
	zend_ast_list *list = zend_ast_get_list(ast);
	uint32_t i, j;

	ZEND_ASSERT(ast->kind == ZEND_AST_ATTRIBUTE_LIST);

	for (i = 0; i < list->children; i++) {
		zend_ast *el = list->child[i];
		zend_string *name = zend_resolve_class_name_ast(el->child[0]);
		zend_ast_list *args = el->child[1] ? zend_ast_get_list(el->child[1]) : NULL;

		zend_attribute *attr = zend_add_attribute(attributes, 0, offset, name, args ? args->children : 0);
		zend_string_release(name);

		// Populate arguments
		if (args) {
			ZEND_ASSERT(args->kind == ZEND_AST_ARG_LIST);

			for (j = 0; j < args->children; j++) {
				zend_const_expr_to_zval(&attr->argv[j], args->child[j]);
			}
		}

		// Validate internal attribute
		zend_attributes_internal_validator validator = zend_attribute_get_validator(attr->lcname);

		if (validator != NULL) {
			validator(attr, target);
		}
	}
}

// the below code fragment can be found in:
// Zend/zend_attributes.c
static zend_attribute *get_attribute(HashTable *attributes, zend_string *lcname, uint32_t offset)
{
	if (attributes) {
		zend_attribute *attr;

		ZEND_HASH_FOREACH_PTR(attributes, attr) {
			if (attr->offset == offset && zend_string_equals(attr->lcname, lcname)) {
				return attr;
			}
		} ZEND_HASH_FOREACH_END();
	}

	return NULL;
}

// the below code fragment can be found in:
// Zend/zend_attributes.c
static zend_always_inline void free_attribute(zend_attribute *attr, int persistent)
{
	uint32_t i;

	zend_string_release(attr->name);
	zend_string_release(attr->lcname);

	for (i = 0; i < attr->argc; i++) {
		zval_ptr_dtor(&attr->argv[i]);
	}

	pefree(attr, persistent);
}

// the below code fragment can be found in:
// Zend/zend_attributes.c
ZEND_API zend_attribute *zend_get_parameter_attribute(HashTable *attributes, zend_string *lcname, uint32_t offset)
{
	return get_attribute(attributes, lcname, offset + 1);
}
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).