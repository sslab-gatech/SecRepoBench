if (LocaleCompare("class",token) == 0)
{
    const char
        *mvg_class;

    (void) GetNextToken(q,&q,extent,token);
    if (*token == '\0')
    {
        status=MagickFalse;
        break;
    }
    // Check if the current token matches the graphic context ID, break if true.
    // Retrieve the MVG class definition from the macros using the token.
    // If the class definition is found,
    // inject the class elements into the stream.
    // Concatenate the MVG class to the elements string, followed by the remaining content.
    // Free the previous primitive string and update it with the new elements.
    // Adjust the stream pointer to the new position in the modified primitive.
    mvg_class = (const char *) GetValueFromSplayTree(macros, token);
    if (mvg_class!= (const char *) NULL)
    {
        char *new_primitive = AcquireString(primitive);
        size_t new_primitive_len = strlen(primitive) + strlen(mvg_class) + strlen(q) + 1;
        new_primitive = (char *) ResizeQuantumMemory(new_primitive, new_primitive_len, sizeof(*new_primitive));
        if (new_primitive == (char *) NULL)
        {
            (void) ThrowMagickException(exception, GetMagickModule(), ResourceLimitError, "MemoryAllocationFailed", "`%s'", image->filename);
            break;
        }
        (void) CopyMagickString(new_primitive, primitive, strlen(primitive) + 1);
        (void) CopyMagickString(new_primitive + strlen(primitive), mvg_class, strlen(mvg_class) + 1);
        (void) CopyMagickString(new_primitive + strlen(primitive) + strlen(mvg_class), q, strlen(q) + 1);
        primitive = DestroyString(primitive);
        primitive = new_primitive;
        q = new_primitive + strlen(primitive) - strlen(q);
    }
    break;
}