Below is the content of a C/C++ function where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
static int multiline_parser_conf_file(const char *cfg, struct flb_cf *cf,
                                      struct flb_config *config)
{
    int ret;
    int type;
    flb_sds_t name;
    flb_sds_t match_string;
    int negate;
    flb_sds_t key_content;
    flb_sds_t key_pattern;
    flb_sds_t key_group;
    flb_sds_t parser;
    flb_sds_t bool_str;
    int flush_timeout;
    struct flb_parser *parser_ctx = NULL;
    struct mk_list *head;
    struct flb_cf_section *s;
    struct flb_ml_parser *ml_parser;

    /* read all 'multiline_parser' sections */
    mk_list_foreach(head, &cf->multiline_parsers) {
        ml_parser = NULL;
        name = NULL;
        type = -1;
        match_string = NULL;
        negate = FLB_FALSE;
        key_content = NULL;
        key_pattern = NULL;
        key_group = NULL;
        parser = NULL;
        flush_timeout = -1;
        bool_str = NULL;

        s = mk_list_entry(head, struct flb_cf_section, _head_section);

        /* name */
        name = get_parser_key(config, cf, s, "name");
        if (!name) {
            flb_error("[multiline_parser] no 'name' defined in file '%s'", cfg);
            goto fconf_error;
        }

        // Retrieve the 'type' key from the configuration section.
        // If the 'type' is not found, log an error and exit with a failure.
        // Convert the type string to its corresponding integer value.
        // If the conversion fails, log an error and exit with a failure.
        // Proceed to handle the 'match_string' key retrieval.
        // <MASK>
        match_string = get_parser_key(config, cf, s, "match_string");

        /* negate */
        bool_str = get_parser_key(config, cf, s, "negate");
        if (bool_str) {
            negate = flb_utils_bool(bool_str);
            flb_sds_destroy(bool_str);
        }

        /* key_content */
        key_content = get_parser_key(config, cf, s, "key_content");

        /* key_pattern */
        key_pattern = get_parser_key(config, cf, s, "key_pattern");

        /* key_group */
        key_group = get_parser_key(config, cf, s, "key_group");

        /* parser */
        parser = get_parser_key(config, cf, s, "parser");

        /* flush_timeout */
        bool_str = get_parser_key(config, cf, s, "flush_timeout");
        if (bool_str) {
            flush_timeout = atoi(bool_str);
        }

        if (parser) {
            parser_ctx = flb_parser_get(parser, config);
        }
        ml_parser = flb_ml_parser_create(config, name, type, match_string,
                                         negate, flush_timeout, key_content,
                                         key_group, key_pattern,
                                         parser_ctx, parser);
        if (!ml_parser) {
            goto fconf_error;
        }

        /* if type is regex, process rules */
        if (type == FLB_ML_REGEX) {
            ret = multiline_load_regex_rules(ml_parser, s, config);
            if (ret != 0) {
                goto fconf_error;
            }
        }

        flb_sds_destroy(name);
        flb_sds_destroy(match_string);
        flb_sds_destroy(key_content);
        flb_sds_destroy(key_pattern);
        flb_sds_destroy(key_group);
        flb_sds_destroy(parser);
        flb_sds_destroy(bool_str);
    }

    return 0;

 fconf_error:
    if (ml_parser) {
        flb_ml_parser_destroy(ml_parser);
    }
    flb_sds_destroy(name);
    flb_sds_destroy(match_string);
    flb_sds_destroy(key_content);
    flb_sds_destroy(key_pattern);
    flb_sds_destroy(key_group);
    flb_sds_destroy(parser);
    flb_sds_destroy(bool_str);

    return -1;
}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/flb_parser.c
static int multiline_load_regex_rules(struct flb_ml_parser *ml_parser,
                                      struct flb_cf_section *section,
                                      struct flb_config *config)
{
    int ret;
    char *to_state = NULL;
    struct mk_list list;
    struct mk_list *head;
    struct flb_kv *entry;
    struct flb_slist_entry *from_state;
    struct flb_slist_entry *regex_pattern;
    struct flb_slist_entry *tmp;

    mk_list_foreach(head, &section->properties) {
        entry = mk_list_entry(head, struct flb_kv, _head);

        /* only process 'rule' keys */
        if (strcasecmp(entry->key, "rule") != 0) {
            continue;
        }

        mk_list_init(&list);
        ret = flb_slist_split_tokens(&list, entry->val, 3);
        if (ret == -1) {
            flb_error("[multiline parser: %s] invalid section on key '%s'",
                      ml_parser->name, entry->key);
            return -1;
        }

        /* Get entries from the line */
        from_state    = flb_slist_entry_get(&list, 0);
        regex_pattern = flb_slist_entry_get(&list, 1);
        tmp = flb_slist_entry_get(&list, 2);
        if (tmp) {
            to_state  = tmp->str;
        }
        else {
            to_state = NULL;
        }

        if (!from_state) {
            flb_error("[multiline parser: %s] 'from_state' is mandatory",
                      ml_parser->name);
            flb_slist_destroy(&list);
            return -1;
        }

        if (!regex_pattern) {
            flb_error("[multiline parser: %s] 'regex_pattern' is mandatory",
                      ml_parser->name);
            flb_slist_destroy(&list);
            return -1;
        }

        ret = flb_ml_rule_create(ml_parser,
                                 from_state->str,
                                 regex_pattern->str,
                                 to_state,
                                 NULL);
        if (ret == -1) {
            flb_error("[multiline parser: %s] error creating rule",
                      ml_parser->name);
            flb_slist_destroy(&list);
            return -1;
        }

        flb_slist_destroy(&list);
    }

    /* Map the rules (mandatory for regex rules) */
    ret = flb_ml_parser_init(ml_parser);
    if (ret != 0) {
        flb_error("[multiline parser: %s] invalid mapping rules, check the states",
                  ml_parser->name);
        return -1;
    }

    return 0;
}

// the below code fragment can be found in:
// src/multiline/flb_ml_parser.c
struct flb_ml_parser *flb_ml_parser_get(struct flb_config *ctx, char *name)
{
    struct mk_list *head;
    struct flb_ml_parser *ml_parser;

    mk_list_foreach(head, &ctx->multiline_parsers) {
        ml_parser = mk_list_entry(head, struct flb_ml_parser, _head);
        if (strcasecmp(ml_parser->name, name) == 0) {
            return ml_parser;
        }
    }

    return NULL;
}

// the below code fragment can be found in:
// src/multiline/flb_ml_parser.c
int flb_ml_parser_instance_destroy(struct flb_ml_parser_ins *ins)
{
    struct mk_list *tmp;
    struct mk_list *head;
    struct flb_ml_stream *stream;

    /* Destroy streams */
    mk_list_foreach_safe(head, tmp, &ins->streams) {
        stream = mk_list_entry(head, struct flb_ml_stream, _head);
        flb_ml_stream_destroy(stream);
    }

    if (ins->key_content) {
        flb_sds_destroy(ins->key_content);
    }
    if (ins->key_pattern) {
        flb_sds_destroy(ins->key_pattern);
    }
    if (ins->key_group) {
        flb_sds_destroy(ins->key_group);
    }

    flb_free(ins);

    return 0;
}

// the below code fragment can be found in:
// src/multiline/flb_ml_mode.c
struct flb_ml_mode *flb_ml_parser_create(struct flb_config *ctx,
                                         char *name,
                                         int type, char *match_str, int negate,
                                         int flush_ms,
                                         char *key_content,
                                         char *key_group,
                                         char *key_pattern,
                                         struct flb_parser *parser_ctx,
                                         char *parser_name)
{
    struct flb_ml_mode *ml;

    ml = flb_calloc(1, sizeof(struct flb_ml));
    if (!ml) {
        flb_errno();
        return NULL;
    }
    ml->name = flb_sds_create(name);
    ml->type = type;

    if (match_str) {
        ml->match_str = flb_sds_create(match_str);
        if (!ml->match_str) {
            flb_free(ml);
            return NULL;
        }
    }

    ml->parser = parser_ctx;
    if (parser_name) {
        ml->parser_name = flb_sds_create(parser_name);
    }

    ml->negate = negate;
    mk_list_init(&ml->streams);
    mk_list_init(&ml->regex_rules);
    mk_list_add(&ml->_head, &ctx->multilines);

    if (key_content) {
        ml->key_content = flb_sds_create(key_content);
        if (!ml->key_content) {
            flb_ml_destroy(ml);
            return NULL;
        }
    }

    if (key_group) {
        ml->key_group = flb_sds_create(key_group);
        if (!ml->key_group) {
            flb_ml_destroy(ml);
            return NULL;
        }
    }

    if (key_pattern) {
        ml->key_pattern = flb_sds_create(key_pattern);
        if (!ml->key_pattern) {
            flb_ml_destroy(ml);
            return NULL;
        }
    }
    return ml;
}

// the below code fragment can be found in:
// src/multiline/flb_ml_parser.c
int flb_ml_parser_instance_set(struct flb_ml_parser_ins *p, char *prop, char *val)
{
    if (strcasecmp(prop, "key_content") == 0) {
        if (p->key_content) {
            flb_sds_destroy(p->key_content);
        }
        p->key_content = flb_sds_create(val);
    }
    else if (strcasecmp(prop, "key_pattern") == 0) {
        if (p->key_pattern) {
            flb_sds_destroy(p->key_pattern);
        }
        p->key_pattern = flb_sds_create(val);
    }
    else if (strcasecmp(prop, "key_group") == 0) {
        if (p->key_group) {
            flb_sds_destroy(p->key_group);
        }
        p->key_group = flb_sds_create(val);
    }
    else {
        return -1;
    }

    return 0;
}
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).