if (status == MagickFalse)
    {
      TIFFClose(tiff);
      return(DestroyImageList(image));
    }
  if (image_info->ping != MagickFalse)
    {
      if (image_info->number_scenes != 0)
        if (image->scene >= (image_info->scene+image_info->number_scenes-1))
          break;
      goto next_tiff_frame;
    }
  status=SetImageExtent(image,image->columns,image->rows,exception);
  if (status == MagickFalse)
    {
      TIFFClose(tiff);
      return(DestroyImageList(image));
    }
  status=SetImageColorspace(image,image->colorspace,exception);
  status&=ResetImagePixels(image,exception);
  if (status == MagickFalse)
    {
      TIFFClose(tiff);
      return(DestroyImageList(image));
    }
  /*
    Allocate memory for the image and pixel buffer.
  */
  quantum_info=AcquireQuantumInfo(image_info,image);
  if (quantum_info == (QuantumInfo *) NULL)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  if (sample_format == SAMPLEFORMAT_UINT)
    status=SetQuantumFormat(image,quantum_info,UnsignedQuantumFormat);
  if (sample_format == SAMPLEFORMAT_INT)
    status=SetQuantumFormat(image,quantum_info,SignedQuantumFormat);
  if (sample_format == SAMPLEFORMAT_IEEEFP)
    status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);
  if (status == MagickFalse)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  status=MagickTrue;
  switch (photometric)
  {
    case PHOTOMETRIC_MINISBLACK:
    {
      quantum_info->min_is_white=MagickFalse;
      break;
    }
    case PHOTOMETRIC_MINISWHITE:
    {
      quantum_info->min_is_white=MagickTrue;
      break;
    }
    default:
      break;
  }
  tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_EXTRASAMPLES,&extra_samples,
    &sample_info,sans);
  if (tiff_status == 1)
    {
      (void) SetImageProperty(image,"tiff:alpha","unspecified",exception);
      if (extra_samples == 0)
        {
          if ((samples_per_pixel == 4) && (photometric == PHOTOMETRIC_RGB))
            image->alpha_trait=BlendPixelTrait;
        }
      else
        for (i=0; i < extra_samples; i++)
        {
          image->alpha_trait=BlendPixelTrait;
          if (sample_info[i] == EXTRASAMPLE_ASSOCALPHA)
            {
              SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);
              (void) SetImageProperty(image,"tiff:alpha","associated",
                exception);
            }
          else
            if (sample_info[i] == EXTRASAMPLE_UNASSALPHA)
              {
                SetQuantumAlphaType(quantum_info,DisassociatedQuantumAlpha);
                (void) SetImageProperty(image,"tiff:alpha","unassociated",
                  exception);
              }
        }
    }
  if (image->alpha_trait != UndefinedPixelTrait)
    (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);
  method=ReadGenericMethod;
  rows_per_strip=(uint32) image->rows;
  if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip) == 1)
    {
      char
        buffer[MagickPathExtent];

      (void) FormatLocaleString(buffer,MagickPathExtent,"%u",
        (unsigned int) rows_per_strip);
      (void) SetImageProperty(image,"tiff:rows-per-strip",buffer,exception);
      method=ReadStripMethod;
      if (rows_per_strip > (uint32) image->rows)
        rows_per_strip=(uint32) image->rows;
    }
  if (TIFFIsTiled(tiff) != MagickFalse)
    method=ReadTileMethod;
  if (image->compression == JPEGCompression)
    method=GetJPEGMethod(image,tiff,photometric,bits_per_sample,
      samples_per_pixel);
  if ((photometric == PHOTOMETRIC_LOGLUV) ||
      (photometric == PHOTOMETRIC_YCBCR))
    method=ReadGenericMethod;
  quantum_info->endian=LSBEndian;
  quantum_type=RGBQuantum;
  if (TIFFScanlineSize(tiff) <= 0)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  if ((1.0*TIFFScanlineSize(tiff)) > (2.53*GetBlobSize(image)))
    ThrowTIFFException(CorruptImageError,"InsufficientImageDataInFile");
  number_pixels=MagickMax(TIFFScanlineSize(tiff),MagickMax((ssize_t)
    image->columns*samples_per_pixel*pow(2.0,ceil(log(bits_per_sample)/
    log(2.0))),image->columns*rows_per_strip));
  pixel_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));
  if (pixel_info == (MemoryInfo *) NULL)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
  (void) memset(pixels,0,number_pixels*sizeof(uint32));
  quantum_type=IndexQuantum;
  pad=(size_t) MagickMax((ssize_t) samples_per_pixel-1,0);
  if (image->alpha_trait != UndefinedPixelTrait)
    {
      if (image->storage_class == PseudoClass)
        quantum_type=IndexAlphaQuantum;
      else
        quantum_type=samples_per_pixel == 1 ? AlphaQuantum : GrayAlphaQuantum;
    }
  else
    if (image->storage_class != PseudoClass)
      quantum_type=GrayQuantum;
  if ((samples_per_pixel > 2) && (interlace != PLANARCONFIG_SEPARATE))
    {
      pad=(size_t) MagickMax((size_t) samples_per_pixel-3,0);
      quantum_type=RGBQuantum;
      if (image->alpha_trait != UndefinedPixelTrait)
        {
          quantum_type=RGBAQuantum;
          pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);
        }
      if (image->colorspace == CMYKColorspace)
        {
          pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);
          quantum_type=CMYKQuantum;
          if (image->alpha_trait != UndefinedPixelTrait)
            {
              quantum_type=CMYKAQuantum;
              pad=(size_t) MagickMax((size_t) samples_per_pixel-5,0);
            }
        }
      status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7) >> 3));
      if (status == MagickFalse)
        ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
    }
  switch (method)
  {
    case ReadYCCKMethod:
      {
        /*
          Convert YCC TIFF image.
        */
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          register Quantum
            *magick_restrict q;

          register ssize_t
            x;

          unsigned char
            *p;

          tiff_status=TIFFReadPixels(tiff,0,y,(char *) pixels);
          if (tiff_status == -1)
            break;
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          p=pixels;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelCyan(image,ScaleCharToQuantum(ClampYCC((double) *p+
              (1.402*(double) *(p+2))-179.456)),q);
            SetPixelMagenta(image,ScaleCharToQuantum(ClampYCC((double) *p-
              (0.34414*(double) *(p+1))-(0.71414*(double ) *(p+2))+
              135.45984)),q);
            SetPixelYellow(image,ScaleCharToQuantum(ClampYCC((double) *p+
              (1.772*(double) *(p+1))-226.816)),q);
            SetPixelBlack(image,ScaleCharToQuantum((unsigned char) *(p+3)),q);
            q+=GetPixelChannels(image);
            p+=4;
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
    case ReadStripMethod:
      {
        register unsigned char
          *p;

        size_t
          extent;

        ssize_t
          stride,
          strip_id;

        tsize_t
          strip_size;

        unsigned char
          *strip_pixels;

        /*
          Convert stripped TIFF image.
        */
        extent=TIFFStripSize(tiff);
#if defined(TIFF_VERSION_BIG)
        extent+=image->columns*sizeof(uint64);
#else
        extent+=image->columns*sizeof(uint32);
#endif
        strip_pixels=(unsigned char *) AcquireQuantumMemory(extent,
          sizeof(*strip_pixels));
        if (strip_pixels == (unsigned char *) NULL)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        (void) memset(strip_pixels,0,extent*sizeof(*strip_pixels));
        stride=TIFFVStripSize(tiff,1);
        strip_id=0;
        p=strip_pixels;
        for (i=0; i < (ssize_t) samples_per_pixel; i++)
        {
          size_t
            rows_remaining;

          switch (i)
          {
            case 0: break;
            case 1: quantum_type=GreenQuantum; break;
            case 2: quantum_type=BlueQuantum; break;
            case 3:
            {
              if (image->colorspace == CMYKColorspace)
                quantum_type=BlackQuantum;
              break;
            }
            case 4: quantum_type=AlphaQuantum; break;
          }
          rows_remaining=0;
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            register Quantum
              *magick_restrict q;

            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);
            if (q == (Quantum *) NULL)
              break;
            if (rows_remaining == 0)
              {
                strip_size=TIFFReadEncodedStrip(tiff,strip_id,strip_pixels,
                  TIFFStripSize(tiff));
                if (strip_size == -1)
                  break;
                rows_remaining=rows_per_strip;
                if ((y+rows_per_strip) > image->rows)
                  rows_remaining=(rows_per_strip-(y+rows_per_strip-
                    image->rows));
                p=strip_pixels;
                strip_id++;
              }
            (void) ImportQuantumPixels(image,(CacheView *) NULL,
              quantum_info,quantum_type,p,exception);
            p+=stride;
            rows_remaining--;
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
          }
          if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))
            break;
        }
        strip_pixels=(unsigned char *) RelinquishMagickMemory(strip_pixels);
        break;
      }
    case ReadTileMethod:
      {
        register unsigned char
          *p;

        size_t
          extent;

        uint32
          columns,
          rows;

        unsigned char
          *tile_pixels;

        /*
          Convert tiled TIFF image.
        */
        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||
            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))
          ThrowTIFFException(CoderError,"ImageIsNotTiled");
        if ((AcquireMagickResource(WidthResource,columns) == MagickFalse) ||
            (AcquireMagickResource(HeightResource,rows) == MagickFalse))
          ThrowTIFFException(ImageError,"WidthOrHeightExceedsLimit");
        number_pixels=(MagickSizeType) columns*rows;
        if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels)) != MagickFalse)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        extent=TIFFTileSize(tiff);
#if defined(TIFF_VERSION_BIG)
        extent+=columns*sizeof(uint64);
#else
        extent+=columns*sizeof(uint32);
#endif
        tile_pixels=(unsigned char *) AcquireQuantumMemory(extent,
          sizeof(*tile_pixels));
        if (tile_pixels == (unsigned char *) NULL)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        (void) memset(tile_pixels,0,extent*sizeof(*tile_pixels));
        for (i=0; i < (ssize_t) samples_per_pixel; i++)
        {
          switch (i)
          {
            case 0: break;