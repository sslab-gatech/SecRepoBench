/* Check if the TIFF file is byte-swapped and, if so, swap the byte order of the IPTC profile data */
unsigned char *iptc_profile = NULL;
MagickBooleanType byte_swap = MagickFalse;

#if defined(MAGICKCORE_HAVE_TIFFISBIGENDIAN)
if (TIFFIsBigEndian(tiff) == 0)
  byte_swap = MagickTrue;  /* Little endian TIFF */
#endif

if (byte_swap == MagickTrue)
{
  /* Need to swap byte order */
  iptc_profile = (unsigned char *) AcquireQuantumMemory(length, sizeof(unsigned char));
  if (iptc_profile == (unsigned char *) NULL)
    return(MagickFalse);
  
  /* Copy and swap bytes - safe version that handles odd length */
  for (size_t i = 0; i < length-1; i+=2)
  {
    iptc_profile[i] = profile[i+1];
    iptc_profile[i+1] = profile[i];
  }
  
  /* If length is odd, copy the last byte as-is */
  if (length % 2 != 0)
    iptc_profile[length-1] = profile[length-1];
  
  /* Read the IPTC profile into the image */
  status = ReadProfile(img, "iptc", iptc_profile, (ssize_t) length, exception);
  
  /* Free the temporary profile data */
  iptc_profile = (unsigned char *) RelinquishMagickMemory(iptc_profile);
}
else
{
  /* TIFF is big-endian, IPTC is already in right endianness */
  status = ReadProfile(img, "iptc", profile, (ssize_t) length, exception);
}