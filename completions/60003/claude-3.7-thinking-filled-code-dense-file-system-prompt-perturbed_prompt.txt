Below is the content of a C/C++ function where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
static void ndpi_search_line(struct ndpi_detection_module_struct *detectionmodulestruct,
                             struct ndpi_flow_struct *flow)
{
  struct ndpi_packet_struct const * const packet = &detectionmodulestruct->packet;

  NDPI_LOG_DBG(detectionmodulestruct, "searching LineCall\n");

  if(packet->iph && (flow->guessed_protocol_id_by_ip == NDPI_PROTOCOL_LINE)) {
    /*
      The heuristic below (coming from reverse engineering packet traces)
      will apply only to IPv4 and Line IP addresses. This is to avoid puttin
      false positives in other nDPI-decoded protocols.
    */

    // Check the packet's payload against several specific patterns and lengths
    // to determine if it matches known criteria for Line protocol packets.
    // If a match is found, add the connection using ndpi_int_line_add_connection()
    // to indicate that the flow is associated with the Line protocol, and exit
    // the function early. These patterns involve checking specific byte values
    // at certain payload offsets and comparing payload lengths.
    // <MASK>
  }

  /* Some "random" UDP packets before the standard RTP stream:
     it seems that the 4th bytes of these packets is some kind of packet
     number. Look for 4 packets per direction with consecutive numbers. */
  if(packet->payload_packet_len > 10) {
    if(flow->l4.udp.line_pkts[packet->packet_direction] == 0) {
      flow->l4.udp.line_base_cnt[packet->packet_direction] = packet->payload[3];
      flow->l4.udp.line_pkts[packet->packet_direction] += 1;
      return;
    } else {
      /* It might be a RTP/RTCP packet. Ignore it and keep looking for the
         LINE packet numbers */
      /* Basic RTP detection */
      if((packet->payload[0] >> 6) == 2 && /* Version 2 */
         (packet->payload[1] == 201 || /* RTCP, Receiver Report */
          packet->payload[1] == 200 || /* RTCP, Sender Report */
          is_valid_rtp_payload_type(packet->payload[1] & 0x7F)) /* RTP */) {
        NDPI_LOG_DBG(detectionmodulestruct, "Probably RTP; keep looking for LINE");
        return;
      } else {
        if((u_int8_t)(flow->l4.udp.line_base_cnt[packet->packet_direction] +
                      flow->l4.udp.line_pkts[packet->packet_direction]) == packet->payload[3]) {
          flow->l4.udp.line_pkts[packet->packet_direction] += 1;
          if(flow->l4.udp.line_pkts[0] >= 4 && flow->l4.udp.line_pkts[1] >= 4) {
            /* To avoid false positives: usually "base pkt numbers" per-direction are different */
            if(flow->l4.udp.line_base_cnt[0] != flow->l4.udp.line_base_cnt[1])
              ndpi_int_line_add_connection(detectionmodulestruct, flow);
            else
              NDPI_EXCLUDE_PROTO(detectionmodulestruct, flow);
	  }
          return;
        }
      }
    }
  }

  NDPI_EXCLUDE_PROTO(detectionmodulestruct, flow);
  return;
}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/lib/protocols/rtsp.c
static void ndpi_search_rtsp_tcp_udp(struct ndpi_detection_module_struct *ndpi_struct,
				     struct ndpi_flow_struct *flow)
{
  struct ndpi_packet_struct *packet = &ndpi_struct->packet;

  NDPI_LOG_DBG(ndpi_struct, "search RTSP\n");

  if (packet->parsed_lines == 0)
  {
    ndpi_parse_packet_line_info(ndpi_struct, flow);
  }

  if (packet->parsed_lines > 0 &&
      (LINE_ENDS(packet->line[0], "RTSP/1.0") != 0 ||
       LINE_ENDS(packet->accept_line, "application/x-rtsp-tunnelled") != 0 ||
       LINE_ENDS(packet->content_line, "application/x-rtsp-tunnelled") != 0))
  {
    ndpi_int_rtsp_add_connection(ndpi_struct, flow);

    /* Extract some metadata HTTP-like */
    if(packet->user_agent_line.ptr != NULL)
      ndpi_user_agent_set(flow, packet->user_agent_line.ptr, packet->user_agent_line.len);

    return;
  }

  if (flow->rtsprdt_stage == 0
      && !(flow->detected_protocol_stack[0] == NDPI_PROTOCOL_RTCP)
      ) {
    flow->rtsprdt_stage = 1 + packet->packet_direction;
    NDPI_LOG_DBG2(ndpi_struct, "maybe handshake 1; need next packet, return\n");
    return;
  }

  if (flow->packet_counter < 3 && flow->rtsprdt_stage == 1 + packet->packet_direction) {

    NDPI_LOG_DBG2(ndpi_struct, "maybe handshake 2; need next packet\n");
    return;
  }

  if (packet->payload_packet_len > 20 && flow->rtsprdt_stage == 2 - packet->packet_direction) {
    char buf[32] = { 0 };
    u_int len = packet->payload_packet_len;

    if(len >= (sizeof(buf)-1)) len = sizeof(buf)-1;
    strncpy(buf, (const char*)packet->payload, len);

    // RTSP Server Message
    if((memcmp(packet->payload, "RTSP/1.0 ", 9) == 0)
       || (strstr(buf, "rtsp://") != NULL)) {
      NDPI_LOG_DBG2(ndpi_struct, "found RTSP/1.0 \n");
      NDPI_LOG_INFO(ndpi_struct, "found RTSP\n");
      ndpi_int_rtsp_add_connection(ndpi_struct, flow);
      return;
    }
  }

  if (packet->udp != NULL && flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN
      && ((NDPI_COMPARE_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, NDPI_PROTOCOL_RTP) == 0)
	  || (NDPI_COMPARE_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, NDPI_PROTOCOL_RTCP) == 0)
	  )) {
    NDPI_LOG_DBG2(ndpi_struct,
	     "maybe RTSP RTP, RTSP RTCP, RDT; need next packet.\n");
    return;
  }


  NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
  return;
}

// the below code fragment can be found in:
// src/lib/protocols/rtcp.c
static void ndpi_search_rtcp(struct ndpi_detection_module_struct *ndpi_struct,
			     struct ndpi_flow_struct *flow)
{
  struct ndpi_packet_struct *packet = &ndpi_struct->packet;
  u_int16_t dport = 0, sport = 0;

  NDPI_LOG_DBG(ndpi_struct, "search RTCP\n");

  if(packet->tcp != NULL) {
    sport = ntohs(packet->tcp->source), dport = ntohs(packet->tcp->dest);
    NDPI_LOG_DBG2(ndpi_struct, "calculating dport over tcp\n");

    if(packet->payload_packet_len > 13 && (sport == 554 || dport == 554) &&
       packet->payload[0] == 0x00 && packet->payload[1] == 0x00 &&
       packet->payload[2] == 0x01 && packet->payload[3] == 0x01 &&
       packet->payload[4] == 0x08 && packet->payload[5] == 0x0a &&
       packet->payload[6] == 0x00 && packet->payload[7] == 0x01) {
      NDPI_LOG_INFO(ndpi_struct, "found rtcp\n");
      ndpi_int_rtcp_add_connection(ndpi_struct, flow);
    }

    if(flow->packet_counter > 3)
      NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
  } else if(packet->udp != NULL) {
    /* Let's check first the RTCP packet length */
    u_int16_t len, offset = 0, rtcp_section_len;
    
    while(offset + 3 < packet->payload_packet_len) {
      len = packet->payload[2+offset] * 256 + packet->payload[2+offset+1];
      rtcp_section_len = (len + 1) * 4;
      
      if(((offset+rtcp_section_len) > packet->payload_packet_len) || (rtcp_section_len == 0) || (len == 0)) {
        NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
	return;
      } else
	offset += rtcp_section_len;
    }
    
    NDPI_LOG_DBG2(ndpi_struct, "calculating dport over udp\n");
    /* TODO changed a pair of length condition to the && from ||. Is it correct? */
    if(((packet->payload_packet_len >= 28 && packet->payload_packet_len <= 1200) &&
	((packet->payload[0] == 0x80) && ((packet->payload[1] == 0xc8) || (packet->payload[1] == 0xc9)) && (packet->payload[2] == 0x00)))
       || (packet->payload_packet_len >= 3 && ((packet->payload[0] == 0x81) && ((packet->payload[1] == 0xc8) || (packet->payload[1] == 0xc9))
	    && (packet->payload[2] == 0x00)))) {
      NDPI_LOG_INFO(ndpi_struct, "found rtcp\n");
      ndpi_int_rtcp_add_connection(ndpi_struct, flow);
    }

    if(flow->packet_counter > 3)
      NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
  }
}

// the below code fragment can be found in:
// src/lib/protocols/netflow.c
static void ndpi_search_netflow(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow)
{
  struct ndpi_packet_struct *packet = &ndpi_struct->packet;
  // const u_int8_t *packet_payload = packet->payload;
  u_int32_t payload_len = packet->payload_packet_len;
  time_t now;
  struct timeval now_tv;

  NDPI_LOG_DBG(ndpi_struct, "search netflow\n");

  if((packet->udp != NULL) && (payload_len >= 24)) {
    u_int16_t version = (packet->payload[0] << 8) + packet->payload[1], uptime_offset;
    u_int32_t when, *_when;
    u_int16_t n = (packet->payload[2] << 8) + packet->payload[3], expected_len = 0;

    switch(version) {
    case 1:
    case 5:
    case 7:
    case 9:
      if((n == 0) || (n > 30)) {
	NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
	return;
      }
      
      switch(version) {
      case 1:
	expected_len = n * sizeof(struct flow_ver1_rec) + 16 /* header */;
	break;

      case 5:
	expected_len = n * sizeof(struct flow_ver5_rec) + 24 /* header */;
	break;

      case 7:
	expected_len = n * sizeof(struct flow_ver7_rec) + 24 /* header */;
	break;

      case 9:
	/* We need to check the template */
	break;
      }

      if((expected_len > 0) && (expected_len != payload_len)) {
	NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
	return;
      }

      uptime_offset = 8;
      break;

    case 10: /* IPFIX */
      {      
	u_int16_t ipfix_len = n;

	if(ipfix_len != payload_len) {
	  NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
	  return;
	}
      }    
      uptime_offset = 4;
      break;
      
    default:
      NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
      return;
    }

    _when = (u_int32_t*)&packet->payload[uptime_offset]; /* Sysuptime */
    when = ntohl(*_when);

    do_gettimeofday(&now_tv);
    now = now_tv.tv_sec;

    if(((version == 1) && (when == 0))
       || ((when >= 946684800 /* 1/1/2000 */) && (when <= (u_int32_t)now))) {
      NDPI_LOG_INFO(ndpi_struct, "found netflow\n");
      ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_NETFLOW, NDPI_PROTOCOL_UNKNOWN, NDPI_CONFIDENCE_DPI);
      return;
    }
  } else
    NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
}

// the below code fragment can be found in:
// src/lib/protocols/rtp.c
static void ndpi_search_rtp(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow)
{
  struct ndpi_packet_struct *packet = &ndpi_struct->packet;
  u_int16_t source = ntohs(packet->udp->source);
  u_int16_t dest = ntohs(packet->udp->dest);

  // printf("==> %s()\n", __FUNCTION__);

  /* printf("*** %s(pkt=%d)\n", __FUNCTION__, flow->packet_counter); */

  if((source != 30303) && (dest != 30303 /* Avoid to mix it with Ethereum that looks alike */)
     && (dest > 1023)
     )
    ndpi_rtp_search(ndpi_struct, flow, packet->payload, packet->payload_packet_len);
  else
    NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
}

// the below code fragment can be found in:
// src/lib/protocols/drda.c
static void ndpi_search_drda(struct ndpi_detection_module_struct *ndpi_struct,
			     struct ndpi_flow_struct *flow)
{
  struct ndpi_packet_struct * packet = &ndpi_struct->packet;
  u_int16_t payload_len = packet->payload_packet_len;
  u_int count = 0; // prevent integer overflow

  NDPI_LOG_DBG(ndpi_struct, "search DRDA\n");
  
  if(packet->tcp != NULL) {

    /* check port */
    if(payload_len >= sizeof(struct ndpi_drda_hdr)) {

      struct ndpi_drda_hdr * drda = (struct ndpi_drda_hdr *) packet->payload;

      u_int16_t len = ntohs(drda->length);

      /* check first header */
      if(len != ntohs(drda->length2) + 6 ||
	 drda->magic != 0xd0)
	goto no_drda;

      /* check if there are more drda headers */
      if(payload_len > len) {

	count = len;

	while(count + sizeof(struct ndpi_drda_hdr) < payload_len)
	{
	  /* update info */
	  drda = (struct ndpi_drda_hdr *)(packet->payload + count);
	  len = ntohs(drda->length);

	  if(len != ntohs(drda->length2) + 6 ||
	     drda->magic != 0xd0)
	    goto no_drda;
	  
	  count += len;
	}
	if(count != payload_len) goto no_drda;
      }
      NDPI_LOG_INFO(ndpi_struct, "found DRDA\n");
      ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_DRDA, NDPI_PROTOCOL_UNKNOWN, NDPI_CONFIDENCE_DPI);
      return;
    }
  }

 no_drda:
  NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
}
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).