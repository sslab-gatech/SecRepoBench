u_int offset = ip_offset+ip_len+sizeof(struct ndpi_udphdr);
      u_int16_t tzsp_version, tzsp_type, ether_type;

      if((offset + 4) > header->caplen)
	break;

      tzsp_version = ntohs(*((u_int16_t*)&packet[offset]));
      tzsp_type = ntohs(*((u_int16_t*)&packet[offset + 2]));

      if((tzsp_version == 1) && (tzsp_type == 0)) {
	offset += 4;

	while((offset + 4) < header->caplen) {
	  u_int16_t tag_type = ntohs(*((u_int16_t*)&packet[offset]));
	  u_int16_t tag_len = ntohs(*((u_int16_t*)&packet[offset + 2]));

	  if(tag_type == 0) /* TZSP_TAG_END */
	    break;
	  else if(tag_type == 1) { /* TZSP_TAG_PADDING */
	    offset += 4;
	  } else if(tag_type == 2) { /* TZSP_TAG_8021Q */
	    offset += (4 + tag_len);
	  } else if(tag_type == 3) { /* TZSP_TAG_POSSIBLE_ERROR */
	    offset += (4 + tag_len);
	  } else if (tag_type == 4) { /* TZSP_TAG_RADIOTAP */
	    offset += (4 + tag_len);
	  } else if (tag_type == 5) { /* TZSP_TAG_AVS */
	    offset += (4 + tag_len);
	  } else if (tag_type == 6) { /* TZSP_TAG_WLAN_RADIO */
	    offset += (4 + tag_len);
	  } else if (tag_type == 7) { /* TZSP_TAG_FTM */
	    offset += (4 + tag_len);
	  } else if (tag_type == 8) { /* TZSP_TAG_META */
	    offset += (4 + tag_len);
	  } else if (tag_type == 9) { /* TZSP_TAG_EPB */
	    offset += (4 + tag_len);
	  } else if (tag_type == 10) { /* TZSP_TAG_PACKET_START */
	    offset += (4 + tag_len);
	  } else if (tag_type == 11) { /* TZSP_TAG_PACKET_END */
	    offset += (4 + tag_len);
	  } else if (tag_type == 12) { /* TZSP_TAG_INTERFACE_ID */
	    offset += (4 + tag_len);
	  } else if (tag_type == 13) { /* TZSP_TAG_INTERFACE_NAME */
	    offset += (4 + tag_len);
	  } else if (tag_type == 14) { /* TZSP_TAG_COMMENT */
	    offset += (4 + tag_len);
	  } else if (tag_type == 15) { /* TZSP_TAG_ERROR */
	    offset += (4 + tag_len);
	  } else if (tag_type == 16) { /* TZSP_TAG_TIMESTAMP */
	    offset += (4 + tag_len);
	  } else {
	    offset += (4 + tag_len);
	  }

	  if(tag_len == 0)
	    break;
	}

	if((offset + sizeof(struct ndpi_ethhdr)) <= header->caplen) {
	  ethernet = (struct ndpi_ethhdr*)&packet[offset];
	  ether_type = ntohs(ethernet->h_proto);

	  if((ether_type == ETH_P_IP) || (ether_type == ETH_P_IPV6) || (ether_type == VLAN)) {
	    eth_offset = offset;
	    datalink_type = DLT_EN10MB;
	    goto datalink_check;
	  }
	}
      }
      break;