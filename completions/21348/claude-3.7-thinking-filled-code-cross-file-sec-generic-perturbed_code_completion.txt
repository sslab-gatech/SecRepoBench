/* TZSP */
tunnel_type = ndpi_tzsp_tunnel;
u_int offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);

/* Ensure we have enough data for the TZSP header */
if(offset + 5 > header->caplen)
  return(detected_protocol); /* Too short for TZSP header */

/* TZSP header:
 * version (1 byte) + type (1 byte) + protocol (2 bytes) */
u_int8_t version = packet[offset];
u_int8_t tzsp_type = packet[offset + 1];

/* Only version 1 and type 0 (encapsulated Ethernet) is supported */
if(version != 1 || tzsp_type != 0)
  return(detected_protocol);

offset += 4; /* Skip past the TZSP header fields */

/* Process tags */
while(offset < header->caplen) {
  u_int8_t tag_type = packet[offset];
  offset++; /* Move past the tag type */
  
  /* Tag type 1 is the END tag */
  if(tag_type == 1) {
    /* End of tags, the encapsulated Ethernet frame follows */
    break;
  }
  
  /* Tag type 0 is PADDING, just skip one byte */
  else if(tag_type == 0) {
    /* Do nothing, just skip this single-byte tag */
  }
  
  /* Other tag types have a length field */
  else {
    /* Ensure we have space for the tag length field */
    if(offset >= header->caplen)
      return(detected_protocol);
    
    u_int8_t tag_len = packet[offset];
    offset++; /* Move past the tag length */
    
    /* Skip the rest of the tag data */
    if(tag_len > 0) {
      /* Ensure we don't go past the packet boundary */
      if(offset + tag_len > header->caplen)
        return(detected_protocol);
      
      offset += tag_len;
    }
  }
}

/* If we have enough data for an Ethernet frame */
if(offset + 14 <= header->caplen) {
  eth_offset = offset; /* Set the Ethernet frame offset */
  datalink_type = DLT_EN10MB; /* Set the datalink type to Ethernet */
  goto datalink_check; /* Restart the datalink processing */
}