u_int offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);
      
      if(offset + 2 >= header->caplen) break;
      
      if(packet[offset] == 1 /* TZSP v1 */ && packet[offset+1] == 0 /* ENCAP */) {
        offset += 2; /* Skip version and type */
        
        while(offset < header->caplen) {
          u_int8_t tag_type = packet[offset++];
          if(tag_type == 0) break; /* END tag */
          
          if(offset >= header->caplen) break;
          u_int8_t tag_len = packet[offset++];
          
          if(tag_type == 2 /* PADDING */) {
            offset += tag_len;
            if(tag_len == 0) break; /* Variable length padding */
          } else {
            offset += tag_len;
          }
          
          if(offset > header->caplen) break;
        }
        
        if(offset + sizeof(struct ndpi_ethhdr) <= header->caplen) {
          eth_offset = offset;
          datalink_type = DLT_EN10MB;
          goto datalink_check;
        }
      }