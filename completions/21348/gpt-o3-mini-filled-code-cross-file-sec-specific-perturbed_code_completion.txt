{
  u_int tzsp_offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);
  if (header->caplen < tzsp_offset + 2)
    return(detected_protocol);

  /* Read TZSP version and type */
  u_int8_t tzsp_version = packet[tzsp_offset++];
  u_int8_t tzsp_type = packet[tzsp_offset++];

  /* Verify TZSP version (only version 1 is supported) */
  if (tzsp_version != 1)
    return(detected_protocol);

  /* Process TZSP tags */
  while (tzsp_offset < header->caplen) {
    u_int8_t tag_type = packet[tzsp_offset++];
    /* Tag type 1 indicates the end of the tag list */
    if (tag_type == 1)
      break;
    /* Tag type 0 is padding; no length field present */
    else if (tag_type == 0)
      continue;
    else {
      if (tzsp_offset >= header->caplen)
        return(detected_protocol);
      u_int8_t tag_len = packet[tzsp_offset++];
      if (header->caplen < tzsp_offset + tag_len)
        return(detected_protocol);
      tzsp_offset += tag_len;
    }
  }

  /* Ensure there is enough space for an encapsulated Ethernet header */
  if (header->caplen < tzsp_offset + sizeof(struct ndpi_ethhdr))
    return(detected_protocol);

  eth_offset = tzsp_offset;
  goto datalink_check;
}