{
  /* Parse the initial TZSP header (4 bytes). Check boundaries to avoid overreads. */
  u_int tzsp_offset = offset;
  if(header->caplen < tzsp_offset + 4) {
    /* Not enough data for TZSP header, skip. */
    break;
  }

  /* Extract TZSP version, type, and encapsulated protocol */
  u_int8_t tzsp_version = packet[tzsp_offset];
  u_int8_t tzsp_type    = packet[tzsp_offset + 1];
  u_int16_t tzsp_encapsulated = (packet[tzsp_offset + 2] << 8) | packet[tzsp_offset + 3];
  tzsp_offset += 4;

  /* For TZSP, version should be 1, type 0 = Received Tag list, and 1 = Ethernet encapsulation */
  if(tzsp_version != 1 || tzsp_type != 0 || tzsp_encapsulated != 1) {
    /* Not a valid TZSP-encapsulated Ethernet frame, skip. */
    break;
  }

  /* TZSP has a list of tags. Each tag is: 1 byte tag_type, 1 byte tag_length, then tag_length bytes of data.
   * We read until we see the End tag (type = 1) or run out of packet data. */
  while(tzsp_offset + 2 <= header->caplen) {
    u_int8_t tag_type = packet[tzsp_offset++];
    u_int8_t tag_len  = packet[tzsp_offset++];

    /* End tag */
    if(tag_type == 1) {
      break;
    }

    /* PADDING tag or unknown tag: skip its contents safely. */
    if(tzsp_offset + tag_len > header->caplen) {
      /* Tag extends beyond captured data, skip. */
      break;
    }
    tzsp_offset += tag_len;
  }

  /* Now tzsp_offset should point to the start of the encapsulated Ethernet frame. Check boundary. */
  if(tzsp_offset >= header->caplen) {
    /* No Ethernet data remains to parse, skip. */
    break;
  }

  /* Pretend the next portion is an Ethernet (DLT_EN10MB) frame starting at tzsp_offset. */
  datalink_type = DLT_EN10MB;
  eth_offset = tzsp_offset;
  goto datalink_check;
}