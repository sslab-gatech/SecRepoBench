static void
ndpi_workflow_process_packet(struct ndpi_workflow * workflow,
                             const struct pcap_pkthdr *header,
                             const u_char *packet) {
 ...
  /* Check for TZSP (TaZman Sniffer Protocol) encapsulation in UDP packets.
     Calculate the initial offset for the TZSP header within the UDP payload.
     Verify the TZSP version and type, and that it encapsulates Ethernet frames.
     Iterate through the TZSP tags in the packet, adjusting the offset as needed.
     Handle different tag types, stopping at the END tag or processing PADDING tags.
     If a valid encapsulated Ethernet frame is found, adjust the eth_offset and
     jump back to datalink type checking for further processing of the encapsulated frame.
  */
  if((sport == TZSP_PORT) || (dport == TZSP_PORT)) {
    /* We only support version 1 of the TZSP protocol */
    u_int8_t tzsp_version = packet[offset + 1];
    if(tzsp_version!= 1) {
      /* Unsupported version, skip this packet */
      workflow->stats.total_discarded_bytes +=  header->len;
      return;
    }

    /* Check the packet type */
    u_int8_t packet_type = packet[offset + 2];
    if(packet_type!= 0x01) {
      /* Only support Ethernet frames */
      workflow->stats.total_discarded_bytes +=  header->len;
      return;
    }

    /* Check the packet length */
    u_int16_t packet_len = (packet[offset + 3] << 8) | packet[offset + 4];
    if(packet_len > header->caplen - offset - 5) {
      /* Packet length is too large, skip this packet */
      workflow->stats.total_discarded_bytes +=  header->len;
      return;
    }

    /* Check the packet flags */
    u_int8_t packet_flags = packet[offset + 5];
    if(packet_flags & 0x01) {
      /* PADDING tag, skip this packet */
      workflow->stats.total_discarded_bytes +=  header->len;
      return;
    }

    /* Check the packet type */
    u_int8_t packet_type = packet[offset + 6];
    if(packet_type!= 0x01) {
      /* Only support Ethernet frames */
      workflow->stats.total_discarded_bytes +=  header->len;
      return;
    }

    /* Adjust the offset to point to the encapsulated Ethernet frame */
    offset += 7;

    /* Check the Ethernet frame length */
    u_int16_t eth_len = (packet[offset + 12] << 8) | packet[offset + 13];
    if(eth_len > header->caplen - offset - 14) {
      /* Ethernet frame length is too large, skip this packet */
      workflow->stats.total_discarded_bytes +=  header->len;
      return;
    }

    /* Adjust the eth_offset to point to the encapsulated Ethernet frame */
    eth_offset = offset + 14;

    /* Jump back to datalink type checking for further processing of the encapsulated frame */
    goto datalink_check;
  }
 ...
}