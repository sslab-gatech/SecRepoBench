u_int offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);
u_int8_t version = packet[offset];
u_int8_t type = packet[offset + 1];

if(((version == 1) || (version == 2) || (version == 3)) && (type == 0)) {
  u_int16_t inner_type;
  offset += 4;

  while(offset < header->caplen) {
    u_int8_t tag_type = packet[offset];
    u_int16_t tag_len;

    if(tag_type == 0) /* END */
      break;
    else if(tag_type == 1) { /* PADDING */
      offset++;
      continue;
    }

    tag_len = (packet[offset + 1] << 8) + packet[offset + 2];
    if(tag_len > header->caplen) break;
    if((tag_type == 0xA) && (tag_len == 0x10)) {
      /* Ethernet frame */
      eth_offset = offset + 4;
      inner_type = ntohs(*((u_int16_t*)&packet[offset + 4 + 2]));
      if((inner_type == ETH_P_IP) || (inner_type == ETH_P_IPV6)) {
        datalink_type = DLT_EN10MB;
        goto datalink_check;
      }
    }
    offset += tag_len;
  }
}