// Check for TZSP (TaZman Sniffer Protocol) encapsulation in UDP packets.
      u_int offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);

      // Ensure the packet is large enough to contain the TZSP header
      if (offset + 2 > header->caplen) {
        return detected_protocol; // Too short for TZSP header
      }

      // Verify TZSP version and type
      u_int8_t tzsp_version = packet[offset];
      u_int8_t tzsp_type = packet[offset + 1];

      if (tzsp_version != 1 || tzsp_type != 0) {
        return detected_protocol; // Not a valid TZSP packet
      }

      offset += 2; // Move past TZSP version and type

      // Parse TZSP tags
      while (offset < header->caplen) {
        if (packet[offset] == 1) { // END tag
          offset++;
          break;
        } else if (packet[offset] == 0) { // PADDING tag
          offset++;
        } else {
          // Skip over the tag type and length
          if (offset + 2 > header->caplen) {
            return detected_protocol; // Malformed TZSP tag
          }
          u_int8_t tag_length = packet[offset + 1];
          offset += 2 + tag_length;
        }
      }

      // Ensure the encapsulated Ethernet frame is present
      if (offset + sizeof(struct ndpi_ethhdr) > header->caplen) {
        return detected_protocol; // Too short for Ethernet frame
      }

      // Adjust eth_offset to point to the encapsulated Ethernet frame
      eth_offset = offset;
      goto datalink_check; // Reprocess the encapsulated frame