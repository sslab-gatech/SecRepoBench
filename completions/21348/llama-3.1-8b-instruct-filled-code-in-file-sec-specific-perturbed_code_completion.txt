static void
ndpi_workflow_process_packet(struct ndpi_workflow * workflow,
                             const struct pcap_pkthdr *header,
                             const u_char *packet) {
  // Check for TZSP (TaZman Sniffer Protocol) encapsulation in UDP packets.
  // Calculate the initial offset for the TZSP header within the UDP payload.
  // Verify the TZSP version and type, and that it encapsulates Ethernet frames.
  // Iterate through the TZSP tags in the packet, adjusting the offset as needed.
  // Handle different tag types, stopping at the END tag or processing PADDING tags.
  // If a valid encapsulated Ethernet frame is found, adjust the eth_offset and
  // jump back to datalink type checking for further processing of the encapsulated frame.
  if (workflow->prefs.decode_tunnels && (proto == IPPROTO_UDP)) {
    if (header->caplen < ip_offset + ip_len + sizeof(struct ndpi_udphdr))
      return (detected_protocol); /* Too short for UDP header */
    struct ndpi_udphdr *udp = (struct ndpi_udphdr *)&packet[ip_offset + ip_len];
    u_int16_t sport = ntohs(udp->source), dport = ntohs(udp->dest);

    if ((sport == TZSP_PORT) || (dport == TZSP_PORT)) {
      u_int offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);
      u_int16_t msg_len = packet[offset + 1] >> 1;

      offset += msg_len;

      if (packet[offset] == 0x02) {
        /* IEEE 802.11 Data */

        offset += 24;
        /* LLC header is 8 bytes */
        type = ntohs((u_int16_t) * ((u_int16_t *) &packet[offset + 6]));

        ip_offset = offset + 8;

        tunnel_type = ndpi_tzsp_tunnel;
        goto iph_check;
      }
    }
  }

  /* process the packet */
  return (packet_processing(workflow, time, vlan_id, tunnel_type, iph, iph6,
                            ip_offset, header->caplen - ip_offset,
                            header->caplen, header, packet, header->ts));
}