u_int offset = ip_offset+ip_len+sizeof(struct ndpi_udphdr);
      u_int16_t tzsp_version, tzsp_type, eth_type;

      if((offset + 4) > header->caplen)
        break;

      tzsp_version = ntohs(*((u_int16_t*)&packet[offset]));
      tzsp_type = ntohs(*((u_int16_t*)&packet[offset + 2]));

      if((tzsp_version == 1) && (tzsp_type == 0)) {
        offset += 4; // Skip TZSP header

        while(offset + 4 <= header->caplen) {
          u_int16_t tag_type = ntohs(*((u_int16_t*)&packet[offset]));
          u_int16_t tag_length = ntohs(*((u_int16_t*)&packet[offset + 2]));

          if(tag_type == 0) // TZSP_TAG_END
            break;
          else if(tag_type == 1) { // TZSP_TAG_PADDING
            offset += 4;
          } else if(tag_type == 2) { // TZSP_TAG_8021Q
            offset += 4 + tag_length;
          } else if(tag_type == 3) { // TZSP_TAG_IP_HDR
            offset += 4 + tag_length;
          } else if(tag_type == 4) { // TZSP_TAG_FRAME
            if (tag_length + offset + 4 > header->caplen) {
              break;
            }
            eth_offset = offset + 4;
            datalink_type = DLT_EN10MB;
            goto datalink_check;
          } else {
            offset += 4 + tag_length;
          }
          if(tag_length > header->caplen)
            break;
        }
      }
      break;