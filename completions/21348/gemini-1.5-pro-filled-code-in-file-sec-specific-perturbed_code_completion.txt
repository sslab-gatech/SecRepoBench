u_int offset = ip_offset+ip_len+sizeof(struct ndpi_udphdr);

      if((offset+4) < header->caplen) {
	u_int8_t  version = packet[offset];
	u_int8_t  type    = packet[offset+1]; /* 0x00 = Ethernet */
	u_int16_t tzsp_len = ntohs(*((u_int16_t*)&packet[offset+2]));

	if((version == 1 || version == 2) && type == 0 && tzsp_len > 0) {
	  offset += 4;

	  while(offset < header->caplen) {
	    u_int8_t tag_type = packet[offset];
	    u_int8_t tag_len  = packet[offset+1];

	    if(tag_type == 0 /* END */)
	      break;
	    else if(tag_type == 1 /* PADDING */) {
	      offset += tag_len + 2;
	    } else {
	      offset += tag_len + 2;
	    }
	  }

	  if(offset < header->caplen) {
	    eth_offset = offset;
	    datalink_type = DLT_EN10MB;
	    tunnel_type = ndpi_tzsp_tunnel;
	    goto datalink_check;
	  }
	}
      }