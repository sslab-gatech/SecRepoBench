u_int offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);
if (offset + 4 > header->caplen) {
  return(detected_protocol); /* Too short for TZSP header */
}

/* Check if it's a valid TZSP packet */
if (*((u_int32_t*)&packet[offset]) != htonl(0x7E5EE1)) {
  return(detected_protocol); /* Invalid TZSP signature */
}
offset += 4;

/* Read the length of the encapsulated frame */
u_int16_t frame_length = ntohs(*(u_int16_t*)&packet[offset]);
offset += 2;

/* Ensure we have enough data for the encapsulated frame */
if (offset + frame_length > header->caplen) {
  return(detected_protocol); /* Truncated encapsulated frame */
}

/* Process TZSP tags */
while (offset < header->caplen) {
  u_int8_t tag_type = packet[offset++];
  u_int8_t tag_length = packet[offset++];

  if (tag_type == 0x00) { /* END tag */
    break;
  } else if (tag_type == 0xFF) { /* PADDING tag */
    offset += tag_length - 2; /* Skip padding bytes */
  } else {
    offset += tag_length - 2; /* Skip other tag data */
  }
}

/* Adjust eth_offset for the encapsulated Ethernet frame */
eth_offset = offset;

/* Re-check datalink type for the encapsulated frame */
datalink_type = DLT_EN10MB;
goto datalink_check;