u_int offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);
u_int16_t tzsp_type, encapsulated_proto;
u_int8_t version;

if (offset + 4 > header->caplen) {
  return(detected_protocol); /* Too short for TZSP */
}

version = packet[offset];
tzsp_type = ntohs(*((u_int16_t*)&packet[offset+2]));

if ((version != 1) || (tzsp_type != 0)) {
  return(detected_protocol); /* Not TZSP version 1 or not TZSP_TYPE_RECEIVED_TAG_LIST */
}

offset += 4;

while (offset < header->caplen) {
  u_int8_t tag_type = packet[offset];
  
  if (tag_type == 1) { /* TZSP_TAG_END */
    break;
  }
  
  if (tag_type == 0) { /* TZSP_TAG_PADDING */
    offset++;
    continue;
  }
  
  if (offset + 2 > header->caplen) {
    return(detected_protocol); /* Malformed packet */
  }
  
  u_int8_t tag_len = packet[offset+1];
  
  if (tag_type == 0x0a) { /* TZSP_TAG_PROTOCOL */
    if (tag_len != 1 || offset + 3 > header->caplen) {
      return(detected_protocol); /* Malformed packet */
    }
    encapsulated_proto = packet[offset+2];
    break;
  }
  
  offset += tag_len + 2;
}

if (encapsulated_proto == 1) { /* TZSP_ENCAP_ETHERNET */
  if (offset + 14 <= header->caplen) {
    eth_offset = offset;
    datalink_type = DLT_EN10MB;
    goto datalink_check;
  }
}

/* If we reach here, it's not a valid TZSP packet we can handle */
return(detected_protocol);