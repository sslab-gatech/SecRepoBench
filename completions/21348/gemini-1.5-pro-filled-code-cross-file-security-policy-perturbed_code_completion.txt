u_int offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);
      u_int8_t version = packet[offset];
      u_int8_t type = packet[offset + 1];

      if (version == 0 && type == 1 && header->caplen >= offset + 16) { //check version, type and tzsp header length
          u_int16_t tzsp_len = ntohs(*(u_int16_t*)(packet + offset + 2));
          offset += 4; // Move past version, type, and length fields

          while (header->caplen >= offset + 4) { //ensure enough space for tag header
              u_int16_t tag_type = ntohs(*(u_int16_t*)(packet + offset));
              u_int16_t tag_len = ntohs(*(u_int16_t*)(packet + offset + 2));

              if (tag_type == 0) { //end tag
                  break;
              } else if (tag_type == 1) { //padding tag, do nothing
                  //ignore padding
              } else if (header->caplen >= offset + tag_len + 4) { //check total length with tag length
                  if (tag_type == 2) {
                      eth_offset = offset + 4;
                      datalink_type = DLT_EN10MB;
                      tunnel_type = ndpi_tzsp_tunnel;
                      goto datalink_check;
                  }
              }
              offset += tag_len + 4;
          }
      }