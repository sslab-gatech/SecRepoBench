case TZSP_PORT:
      // Check for TZSP (TaZman Sniffer Protocol) encapsulation in UDP packets.
      // Calculate the initial offset for the TZSP header within the UDP payload.
      // Verify the TZSP version and type, and that it encapsulates Ethernet frames.
      // Iterate through the TZSP tags in the packet, adjusting the offset as needed.
      // Handle different tag types, stopping at the END tag or processing PADDING tags.
      // If a valid encapsulated Ethernet frame is found, adjust the eth_offset and
      // jump back to datalink type checking for further processing of the encapsulated frame.
      u_int offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);
      u_int8_t tzsp_version = packet[offset];
      u_int8_t tzsp_type = packet[offset + 1];
      if (tzsp_version == 0x01 && tzsp_type == 0x00) {
        // TZSP version 1, TZSP_TYPE_ENCAPSULATED
        offset += 4; // Skip TZSP header
        while (offset < header->caplen) {
          u_int8_t tag_type = packet[offset];
          u_int8_t tag_len = packet[offset + 1];
          if (tag_type == 0x00) {
            // TZSP_TAG_END
            break;
          } else if (tag_type == 0x01) {
            // TZSP_TAG_PADDING
            offset += 2;
          } else {
            // Other tag types
            offset += tag_len + 2;
          }
        }
        if (offset + sizeof(struct ndpi_ethhdr) <= header->caplen) {
          ethernet = (struct ndpi_ethhdr *) &packet[offset];
          eth_offset = offset;
          goto datalink_check;
        }
      }
      break;