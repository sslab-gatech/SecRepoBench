if((sport == TZSP_PORT) || (dport == TZSP_PORT)) {
  u_int offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);

  if(offset + 4 > header->caplen)
    return(detected_protocol); // Too short for TZSP header

  if(packet[offset] != 0x01 || packet[offset + 1] != 0x01) {
    // Invalid TZSP version or type
    return(detected_protocol);
  }

  offset += 2; // Skip past the version and type bytes

  while(1) {
    u_int8_t tag_type = packet[offset];
    u_int16_t tag_length;

    if(offset + 2 > header->caplen)
      return(detected_protocol); // Incomplete tag header

    tag_length = ntohs(*(u_int16_t*)&packet[offset + 1]);

    if(tag_type == 0x00) { // END tag
      break;
    } else if(tag_type == 0xFF) { // Padding tag
      offset += 3 + tag_length;
      continue;
    }

    offset += 3 + tag_length;
  }

  eth_offset = offset;

  if(header->caplen < eth_offset + sizeof(struct ndpi_ethhdr))
    return(detected_protocol); // Too short for encapsulated Ethernet frame

  goto datalink_check;
}