// <MASK>
// Check for TZSP (TaZman Sniffer Protocol) encapsulation in UDP packets.
// Calculate the initial offset for the TZSP header within the UDP payload.
// Verify the TZSP version and type, and that it encapsulates Ethernet frames.
// Iterate through the TZSP tags in the packet, adjusting the offset as needed.
// Handle different tag types, stopping at the END tag or processing PADDING tags.
// If a valid encapsulated Ethernet frame is found, adjust the eth_offset and
// jump back to datalink type checking for further processing of the encapsulated frame.

u_int offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);
u_int8_t tzsp_version = packet[offset];
u_int8_t tzsp_type = packet[offset + 1];

if (tzsp_version == 0x01 && tzsp_type == 0x01) { // TZSP version 1, TZSP type 1 (encapsulated frames)
    offset += 2; // Skip TZSP version and type

    while (offset < header->caplen) {
        u_int8_t tag_type = packet[offset];
        u_int8_t tag_len = packet[offset + 1];

        switch (tag_type) {
        case 0x00: // PADDING
            offset += tag_len;
            break;
        case 0x01: // END
            goto datalink_check;
        case 0x09: // VLAN
            vlan_id = (packet[offset + 2] << 8) | packet[offset + 3];
            offset += tag_len;
            break;
        case 0x03: // PACKET_ID
        case 0x04: // TIMESTAMP
        case 0x05: // HOSTNAME
        case 0x06: // PORT
        case 0x07: // ENCAPSULATED
            offset += tag_len;
            break;
        default:
            // Unknown tag, skip it
            offset += tag_len;
            break;
        }
    }
}

datalink_check:
// Jump back to datalink type checking for further processing of the encapsulated frame
eth_offset = offset - sizeof(struct ndpi_ethhdr);
goto datalink_check;