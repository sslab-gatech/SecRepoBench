if((sport == TZSP_PORT) || (dport == TZSP_PORT)) {
    // Check for TZSP (TaZman Sniffer Protocol) encapsulation in UDP packets.
    // Calculate the initial offset for the TZSP header within the UDP payload.
    u_int offset = ip_offset+ip_len+sizeof(struct ndpi_udphdr);

    // Verify the TZSP version and type, and that it encapsulates Ethernet frames.
    if((offset+40) < header->caplen && packet[offset] == 0x00 && packet[offset+1] == 0x00) {
      u_int16_t msg_len = packet[offset+2] << 8 | packet[offset+3];
      offset += 4;

      if(msg_len + offset > header->caplen) {
        // Invalid TZSP packet, discard it
        workflow->stats.total_discarded_bytes +=  header->len;
        return(detected_protocol);
      }

      // Iterate through the TZSP tags in the packet, adjusting the offset as needed.
      while(offset < msg_len + offset) {
        u_int8_t tag_type = packet[offset];
        u_int16_t tag_len = packet[offset+1] << 8 | packet[offset+2];

        if(tag_len + offset > msg_len + offset) {
          // Invalid TZSP tag, discard the packet
          workflow->stats.total_discarded_bytes +=  header->len;
          return(detected_protocol);
        }

        offset += 3;

        switch(tag_type) {
          case TZSP_TAG_END:
            // End of TZSP tags, process the encapsulated Ethernet frame
            eth_offset = offset;
            goto datalink_check;
          case TZSP_TAG_PADDING:
            // Skip padding tags
            offset += tag_len;
            break;
          default:
            // Unknown tag type, discard the packet
            workflow->stats.total_discarded_bytes +=  header->len;
            return(detected_protocol);
        }
      }
    }
  }