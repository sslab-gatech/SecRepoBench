u_int offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);

if((offset + 4) > header->caplen) return detected_protocol; /* TZSP header check */

u_int8_t version = packet[offset];
u_int8_t tzsp_type = packet[offset+1];
u_int16_t encap_type = ntohs(*(u_int16_t*)&packet[offset+2]);

if(version != 1 || tzsp_type != 0 || encap_type != 1) {
    return detected_protocol; /* Not valid TZSP encapsulation */
}

offset += 4; /* Move past base TZSP header */

/* Process TZSP tags */
while(offset + 2 <= header->caplen) {
    u_int8_t tag_type = packet[offset];
    u_int8_t tag_len = packet[offset+1];
    offset += 2;

    if(tag_type == 0) break; /* END tag */
    if(tag_type == 1) tag_len = 0; /* PADDING tag has no data */

    if(tag_len > 0) {
        if(offset + tag_len > header->caplen) break; /* Tag length overflow */
        offset += tag_len;
    }
}

if(offset > header->caplen) return detected_protocol; /* Invalid tag processing */

/* Set new offsets for encapsulated Ethernet frame */
eth_offset = offset;
datalink_type = DLT_EN10MB;
goto datalink_check;