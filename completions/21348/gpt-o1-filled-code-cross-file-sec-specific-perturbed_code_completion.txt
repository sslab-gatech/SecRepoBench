{
        /* TzSP (TaZman Sniffer Protocol) dissection */
        u_int offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);

        /* Ensure there's enough space for the TZSP header (4 bytes). */
        if(offset + 4 > header->caplen) {
          return(detected_protocol);
        }

        /* Read TZSP header fields: version (1 byte), type (1 byte), encap (2 bytes). */
        uint8_t tzsp_version = packet[offset];
        uint8_t tzsp_type    = packet[offset + 1];
        uint16_t tzsp_encap  = ntohs(*(uint16_t*)&packet[offset + 2]);

        /* Currently handle only version 1, type 0 (received), Ethernet encapsulation (encap=1). */
        if((tzsp_version != 1) || (tzsp_type != 0) || (tzsp_encap != 1)) {
          /* Not recognized or not Ethernet encapsulation, skip. */
          return(detected_protocol);
        }
        offset += 4; /* Move past TZSP header. */

        /* Parse TZSP tags until we reach the END tag (tag_type=1) or run out of data. */
        while(1) {
          /* Ensure there's enough space for the tag header (2 bytes). */
          if(offset + 2 > header->caplen) {
            return(detected_protocol);
          }

          uint8_t tag_type = packet[offset];
          uint8_t tag_len  = packet[offset + 1];
          offset += 2;

          /* Validate tag length. */
          if(offset + tag_len > header->caplen) {
            return(detected_protocol);
          }

          /* The END tag signals the next bytes are the Ethernet frame. */
          if(tag_type == 1 /* END tag */) {
            offset += tag_len; /* Skip tag payload if any. */
            break;
          } else {
            /* Skip any other tag and continue. */
            offset += tag_len;
          }
        }

        /* Verify we still have data for an Ethernet frame. */
        if(offset >= header->caplen) {
          return(detected_protocol);
        }

        /* Point to the encapsulated Ethernet frame and re-run the data link check. */
        eth_offset = offset;
        datalink_type = DLT_EN10MB;
        goto datalink_check;
      }