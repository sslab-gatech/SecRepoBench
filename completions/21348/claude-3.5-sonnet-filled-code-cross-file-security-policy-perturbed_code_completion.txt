u_int offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);
u_int16_t tzsp_type, encapsulated_proto;
u_int8_t version;

if (offset + 4 > header->caplen) {
  return(detected_protocol); // Too short for TZSP header
}

version = packet[offset];
tzsp_type = ntohs(*((u_int16_t*)&packet[offset+2]));

if ((version == 1) && (tzsp_type == 0)) { // TZSP v1, TYPE_RECEIVED_TAG_LIST
  offset += 4;

  while (offset < header->caplen) {
    u_int8_t tag_type = packet[offset];
    
    if (tag_type == 1) { // TAG_END
      break;
    }

    if (tag_type == 0) { // TAG_PADDING
      offset++;
      continue;
    }

    if (offset + 2 > header->caplen) {
      return(detected_protocol); // Invalid packet structure
    }

    u_int8_t tag_len = packet[offset+1];
    
    if (tag_type == 0x0c) { // TAG_RAW_RSSI
      if (offset + 2 + tag_len > header->caplen) {
        return(detected_protocol); // Invalid packet structure
      }
      offset += 2 + tag_len;
    } else if (tag_type == 0x0f) { // TAG_ENCAPSULATION
      if (offset + 3 > header->caplen) {
        return(detected_protocol); // Invalid packet structure
      }
      encapsulated_proto = packet[offset+2];
      offset += 3;

      if (encapsulated_proto == 1) { // Ethernet
        eth_offset = offset;
        datalink_type = DLT_EN10MB;
        goto datalink_check;
      }
      break;
    } else {
      if (offset + 2 + tag_len > header->caplen) {
        return(detected_protocol); // Invalid packet structure
      }
      offset += 2 + tag_len;
    }
  }
}