static void
ndpi_workflow_process_packet(struct ndpi_workflow * workflow,
                             const struct pcap_pkthdr *header,
                             const u_char *packet) {
 ...
  /* Check for TZSP (TaZman Sniffer Protocol) encapsulation in UDP packets.
   * Calculate the initial offset for the TZSP header within the UDP payload.
   * Verify the TZSP version and type, and that it encapsulates Ethernet frames.
   * Iterate through the TZSP tags in the packet, adjusting the offset as needed.
   * Handle different tag types, stopping at the END tag or processing PADDING tags.
   * If a valid encapsulated Ethernet frame is found, adjust the eth_offset and
   * jump back to datalink type checking for further processing of the encapsulated frame.
   */
  else if((sport == TZSP_PORT) || (dport == TZSP_PORT)) {
    // Check for TZSP (TaZman Sniffer Protocol) encapsulation in UDP packets.
    // Calculate the initial offset for the TZSP header within the UDP payload.
    // Verify the TZSP version and type, and that it encapsulates Ethernet frames.
    // Iterate through the TZSP tags in the packet, adjusting the offset as needed.
    // Handle different tag types, stopping at the END tag or processing PADDING tags.
    // If a valid encapsulated Ethernet frame is found, adjust the eth_offset and
    // jump back to datalink type checking for further processing of the encapsulated frame.
    u_int offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);
    if((offset + 40) < header->caplen) {
      u_int16_t msg_len = packet[offset + 1] >> 1;
      offset += msg_len;
      if(packet[offset] == 0x02) {
        /* IEEE 802.11 Data */
        offset += 24;
        /* LLC header is 8 bytes */
        type = ntohs((u_int16_t)*((u_int16_t*)&packet[offset + 6]));
        ip_offset = offset + 8;
        tunnel_type = ndpi_tzsp_tunnel;
        goto iph_check;
      }
    }
  }
 ...
}