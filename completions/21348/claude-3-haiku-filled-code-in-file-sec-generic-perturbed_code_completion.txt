case TZSP_PORT:
      // Check for TZSP (TaZman Sniffer Protocol) encapsulation in UDP packets.
      // Calculate the initial offset for the TZSP header within the UDP payload.
      u_int offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);
      // Verify the TZSP version and type, and that it encapsulates Ethernet frames.
      if (packet[offset] == 0x01 && packet[offset+1] == 0x00 && packet[offset+2] == 0x00) {
        // Iterate through the TZSP tags in the packet, adjusting the offset as needed.
        offset += 4;
        while (offset < header->caplen) {
          u_int8_t tag = packet[offset];
          u_int8_t len = packet[offset+1];
          // Handle different tag types, stopping at the END tag or processing PADDING tags.
          if (tag == 0) { // END tag
            break;
          } else if (tag == 1) { // PADDING tag
            offset += 2;
          } else {
            // If a valid encapsulated Ethernet frame is found, adjust the eth_offset and
            // jump back to datalink type checking for further processing of the encapsulated frame.
            if (tag == 0x09) { // VLAN tag
              vlan_id = (packet[offset+2] << 8) + packet[offset+3];
              eth_offset = offset + 4;
              datalink_type = DLT_EN10MB;
              goto datalink_check;
            }
            offset += len + 2;
          }
        }
      }
      break;