// Calculate the initial offset for the TZSP header within the UDP payload.
u_int tzsp_offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);

// Verify the TZSP version and type, and that it encapsulates Ethernet frames.
if (header->caplen < tzsp_offset + 4) {
  return(detected_protocol); /* Too short for TZSP header*/
}
u_int16_t tzsp_version = ntohs(*(u_int16_t*)&packet[tzsp_offset]);
u_int16_t tzsp_type = ntohs(*(u_int16_t*)&packet[tzsp_offset + 2]);
if (tzsp_version!= TZSP_VERSION || tzsp_type!= TZSP_TYPE_ETHERNET) {
  return(detected_protocol); /* Invalid TZSP version or type*/
}

// Iterate through the TZSP tags in the packet, adjusting the offset as needed.
u_int tzsp_tag_offset = tzsp_offset + 4;
while (tzsp_tag_offset < header->caplen) {
  u_int8_t tzsp_tag_type = packet[tzsp_tag_offset];
  u_int8_t tzsp_tag_len = packet[tzsp_tag_offset + 1];

  // Handle different tag types, stopping at the END tag or processing PADDING tags.
  if (tzsp_tag_type == TZSP_TAG_END) {
    break;
  } else if (tzsp_tag_type == TZSP_TAG_PADDING) {
    tzsp_tag_offset += tzsp_tag_len + 2;
  } else {
    tzsp_tag_offset += tzsp_tag_len + 2;
  }
}

// If a valid encapsulated Ethernet frame is found, adjust the eth_offset and
// jump back to datalink type checking for further processing of the encapsulated frame.
if (tzsp_tag_offset < header->caplen) {
  eth_offset = tzsp_offset + 4;
  goto datalink_check;
}