// <MASK>
else if((sport == TZSP_PORT) || (dport == TZSP_PORT)) {
  // Check for TZSP (TaZman Sniffer Protocol) encapsulation in UDP packets.
  // Calculate the initial offset for the TZSP header within the UDP payload.
  // Verify the TZSP version and type, and that it encapsulates Ethernet frames.
  // Iterate through the TZSP tags in the packet, adjusting the offset as needed.
  // Handle different tag types, stopping at the END tag or processing PADDING tags.
  // If a valid encapsulated Ethernet frame is found, adjust the eth_offset and
  // jump back to datalink type checking for further processing of the encapsulated frame.
  u_int offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);
  if (header->caplen < offset + 4) {
    return(detected_protocol); /* Too short for TZSP header */
  }
  u_int32_t tzsp_version = ntohl(*((u_int32_t*)&packet[offset]));
  if (tzsp_version!= 0x00000001) {
    return(detected_protocol); /* Unknown TZSP version */
  }
  u_int8_t tzsp_type = packet[offset + 4];
  if (tzsp_type!= 0x01) {
    return(detected_protocol); /* Unknown TZSP type */
  }
  if (header->caplen < offset + 8) {
    return(detected_protocol); /* Too short for encapsulated frame */
  }
  u_int32_t encapsulated_len = ntohl(*((u_int32_t*)&packet[offset + 8]));
  if (encapsulated_len > header->caplen - offset - 8) {
    return(detected_protocol); /* Encapsulated frame too long */
  }
  u_int8_t *encapsulated_frame = &packet[offset + 12];
  u_int16_t encapsulated_ethertype = (encapsulated_frame[0] << 8) + encapsulated_frame[1];
  if (encapsulated_ethertype!= ETH_P_IP && encapsulated_ethertype!= ETH_P_IPV6) {
    return(detected_protocol); /* Encapsulated frame is not an IP packet */
  }
  // Adjust the eth_offset and jump back to datalink type checking
  eth_offset = offset + 12;
  goto datalink_check;
}