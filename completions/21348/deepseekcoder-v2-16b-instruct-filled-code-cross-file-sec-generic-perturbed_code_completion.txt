case TZSP:
    // Initialize the offset for the TZSP header
    u_int offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);

    // Check if the packet has enough data to contain a TZSP header
    if (header->caplen < offset + 4) {
      return detected_protocol; // Too short for TZSP header
    }

    // Extract the TZSP version and type
    u_int8_t version = packet[offset] >> 1;
    u_int8_t type = packet[offset + 1];

    // Check if the TZSP version is supported (assuming version 1 is supported)
    if (version != 1) {
      return detected_protocol; // Unsupported TZSP version
    }

    // Process the TZSP header and payload
    // Iterate through the TZSP tags in the packet, adjusting the offset as needed
    while (type != END_TAG) {
      if (type == PADDING_TAG) {
        // Skip PADDING tags
        offset += 1;
      } else if (type == ETHERNET_FRAME_TAG) {
        // Extract the encapsulated Ethernet frame
        u_int16_t eth_len = ntohs(*(u_int16_t*)(&packet[offset + 2]));
        u_int16_t eth_offset = offset + 4; // Assuming the Ethernet header is 14 bytes long

        // Adjust the eth_offset if necessary (e.g., for VLAN tags)
        // This is a simplified example; in a real scenario, you might need to handle VLAN tags and other extensions

        // Update the packet pointer and length
        packet = &packet[eth_offset];
        header->caplen = header->len = eth_len;

        // Recheck the datalink type and process the encapsulated frame
        datalink_type = DLT_EN10MB;
        goto datalink_check;
      } else {
        // Unsupported TZSP tag type
        return detected_protocol;
      }

      // Check if the packet has enough data to continue
      if (header->caplen < offset + 4) {
        return detected_protocol; // Too short to read the next tag
      }

      // Read the next tag
      version = packet[offset] >> 1;
      type = packet[offset + 1];
      offset += 2;
    }

    // Process the encapsulated Ethernet frame
    // Assuming the encapsulated frame is now in the 'packet' buffer
    // Update the eth_offset and proceed with the normal packet processing
    eth_offset = eth_offset;
    goto ether_type_check;