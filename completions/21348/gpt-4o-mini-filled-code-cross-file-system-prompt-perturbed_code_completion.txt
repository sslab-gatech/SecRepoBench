u_int offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);
      if (header->caplen < offset + 4) {
        return detected_protocol; // Too short for TZSP header
      }

      // Check TZSP version and type
      if (packet[offset] == 0x20) { // TZSP version 1
        offset += 4; // Skip TZSP header
        while (offset < header->caplen) {
          u_int8_t tag_type = packet[offset];
          u_int16_t tag_length = (packet[offset + 1] << 8) | packet[offset + 2];

          if (tag_type == 0xFF) { // END tag
            break;
          } else if (tag_type == 0x01) { // Ethernet frame tag
            if (header->caplen < offset + tag_length + 4) {
              return detected_protocol; // Too short for encapsulated Ethernet frame
            }
            eth_offset = offset + 4; // Adjust eth_offset to point to the Ethernet frame
            goto datalink_check; // Recheck datalink type
          }

          offset += tag_length + 4; // Move to the next tag
        }
      }