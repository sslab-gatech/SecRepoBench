u_int offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);
if (offset + 4 < header->caplen) {
  u_int8_t version = packet[offset];
  u_int8_t type = packet[offset + 1];
  u_int16_t encapsulated_protocol = ntohs(*((u_int16_t*)&packet[offset + 2]));
  
  if (version == 1 && type == 0 && encapsulated_protocol == 1) { // TZSP v1, TYPE_RECEIVED, ENCAP_ETHERNET
    offset += 4; // Skip TZSP header
    
    while (offset < header->caplen - 1) {
      u_int8_t tag_type = packet[offset];
      
      if (tag_type == 1) { // TAG_END
        offset += 1;
        break;
      } else if (tag_type == 0) { // TAG_PADDING
        offset += 1;
      } else {
        if (offset + 2 > header->caplen) break;
        u_int8_t tag_length = packet[offset + 1];
        offset += 2 + tag_length;
      }
    }
    
    if (offset < header->caplen) {
      eth_offset = offset;
      goto datalink_check;
    }
  }
}