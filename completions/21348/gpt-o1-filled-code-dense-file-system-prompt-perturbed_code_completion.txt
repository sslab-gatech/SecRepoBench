{
  u_int offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);

  /* Check that we have enough bytes for the TZSP header. */
  if(offset + 4 > header->caplen)
    break;

  /* Parse TZSP header fields. */
  u_int8_t tzsp_version = packet[offset];
  u_int8_t tzsp_type    = packet[offset + 1];
  u_int16_t tzsp_encap  = (packet[offset + 2] << 8) | packet[offset + 3];
  offset += 4;

  /* We only handle TZSP version 1 and Received Packet (type 0). */
  if(tzsp_version != 1 || tzsp_type != 0)
    break;

  /* Process TZSP tags until we encounter the END tag or run out of data. */
  while(offset + 2 <= header->caplen) {
    u_int8_t tag_type = packet[offset];
    u_int8_t tag_len  = packet[offset + 1];
    offset += 2;

    if(tag_type == 1 /* END tag */) {
      break;
    } else if(tag_type == 0 /* PADDING tag */) {
      /* Nothing special to do here. */
    } else {
      /* Skip over this tag's data. */
      if(offset + tag_len > header->caplen)
        break;
      offset += tag_len;
    }
  }

  /* If encapsulation type is Ethernet, adjust offsets for further processing. */
  if(tzsp_encap == 1) {
    eth_offset = offset;
    datalink_type = DLT_EN10MB;
    goto datalink_check;
  }
}