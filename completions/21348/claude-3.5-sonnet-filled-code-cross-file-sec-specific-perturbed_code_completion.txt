u_int offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);
u_int16_t tzsp_type, encapsulated_proto;
u_int8_t version;

if (offset + 4 > header->caplen) {
  return(detected_protocol); // Too short for TZSP header
}

version = packet[offset];
tzsp_type = ntohs(*((u_int16_t*)&packet[offset+2]));

if ((version != 1) || (tzsp_type != 0)) {
  return(detected_protocol); // Not TZSP version 1 or not encapsulating Ethernet
}

offset += 4;

while (offset < header->caplen) {
  u_int8_t tag_type = packet[offset];
  offset++;

  if (tag_type == 1) { // TZSP_TAG_END
    break;
  } else if (tag_type == 0) { // TZSP_TAG_PADDING
    continue;
  } else {
    if (offset + 1 >= header->caplen) {
      return(detected_protocol); // Invalid packet structure
    }
    u_int8_t tag_len = packet[offset];
    offset += tag_len + 1;
  }
}

if (offset + 14 <= header->caplen) { // Minimum Ethernet frame size
  eth_offset = offset;
  encapsulated_proto = ntohs(*((u_int16_t*)&packet[offset + 12]));
  if (encapsulated_proto == ETH_P_IP || encapsulated_proto == ETH_P_IPV6) {
    datalink_type = DLT_EN10MB;
    goto datalink_check;
  }
}

return(detected_protocol); // No valid Ethernet frame found