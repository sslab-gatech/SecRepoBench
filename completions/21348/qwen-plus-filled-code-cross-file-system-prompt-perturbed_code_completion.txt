u_int offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);
u_int8_t tzsp_version, tzsp_type;

/* Check if the packet contains a TZSP header */
if (offset + 2 > header->caplen)
  return(detected_protocol); /* Too short for TZSP header */

tzsp_version = packet[offset] >> 4;
tzsp_type = packet[offset] & 0x0F;

if (tzsp_version != 1 || tzsp_type != 6) /* Only process version 1 encapsulated Ethernet frames */
  return(detected_protocol);

offset += 2; /* Skip TZSP version and type */

/* Process TZSP tags */
while (offset < header->caplen) {
  u_int8_t tag_id = packet[offset++];
  u_int16_t tag_len = packet[offset++] << 8 | packet[offset++];

  if (tag_id == 0) { /* END tag */
    break;
  } else if (tag_id == 1) { /* PADDING tag */
    offset += tag_len; /* Skip padding */
  } else {
    offset += tag_len; /* Skip other tags */
  }
}

/* Check if we have an encapsulated Ethernet frame after the tags */
if (header->caplen - offset < sizeof(struct ndpi_ethhdr))
  return(detected_protocol); /* Too short for encapsulated Ethernet frame */

eth_offset = offset - ip_offset;
datalink_type = DLT_EN10MB; /* Treat the encapsulated frame as Ethernet */
goto datalink_check;