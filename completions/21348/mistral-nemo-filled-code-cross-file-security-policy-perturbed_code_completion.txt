/* Check for TZSP (TaZman Sniffer Protocol) encapsulation in UDP packets.
     Calculate the initial offset for the TZSP header within the UDP payload.
     Verify the TZSP version and type, and that it encapsulates Ethernet frames.
     Iterate through the TZSP tags in the packet, adjusting the offset as needed.
     Handle different tag types, stopping at the END tag or processing PADDING tags.
     If a valid encapsulated Ethernet frame is found, adjust the eth_offset and
     jump back to datalink type checking for further processing of the encapsulated frame. */
  if((sport == TZSP_PORT) || (dport == TZSP_PORT)) {
    u_int offset = ip_offset+ip_len+sizeof(struct ndpi_udphdr);
    u_int8_t version = packet[offset];
    u_int8_t type = packet[offset+1];

    if((version == TZSP_VERSION) && (type == TZSP_TYPE_ETHERNET)) {
      offset += 2;
      u_int16_t tag_type, tag_len;

      while(offset < header->caplen) {
	tag_type = ntohs(*((u_int16_t*)&packet[offset]));
	tag_len = ntohs(*((u_int16_t*)&packet[offset+2]));

	if(tag_type == TZSP_TAG_END) {
	  break;
	} else if(tag_type == TZSP_TAG_PADDING) {
	  offset += tag_len;
	} else {
	  offset += 4; /* skip tag_type and tag_len */
	}

	if(offset + tag_len > header->caplen) {
	  // printf("WARNING: TZSP tag too long (packet_id=%u)!\n", (unsigned int)workflow->stats.raw_packet_count);
	  break;
	}
      }

      if(offset < header->caplen) {
	eth_offset = offset;
	goto datalink_check;
      }
    }
  }