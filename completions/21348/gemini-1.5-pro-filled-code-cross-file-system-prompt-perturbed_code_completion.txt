u_int offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);
      u_int8_t version = packet[offset];
      u_int8_t type = packet[offset + 1];

      if (version == TZSP_VERSION && type == TZSP_TYPE_ETHERNET) {
        tunnel_type = ndpi_tzsp_tunnel;

        offset += 4; // Skip version, type, and protocol fields

        while (offset < header->caplen) {
          u_int16_t tag_type = ntohs(*(u_int16_t *)(packet + offset));
          u_int16_t tag_len = ntohs(*(u_int16_t *)(packet + offset + 2));

          if (tag_type == TZSP_TAG_END) {
            break;
          } else if (tag_type == TZSP_TAG_PADDING) {
            offset += 4 + tag_len;
          } else {
            // Handle other tag types if needed
            offset += 4 + tag_len;
          }
        }

        if (offset < header->caplen) {
          eth_offset = offset;
          datalink_type = DLT_EN10MB;
          goto datalink_check;
        }
      }