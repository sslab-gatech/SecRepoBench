if((sport == TZSP_PORT) || (dport == TZSP_PORT)) {
    // Check for TZSP (TaZman Sniffer Protocol) encapsulation in UDP packets.
    // Calculate the initial offset for the TZSP header within the UDP payload.
    // Verify the TZSP version and type, and that it encapsulates Ethernet frames.
    // Iterate through the TZSP tags in the packet, adjusting the offset as needed.
    // Handle different tag types, stopping at the END tag or processing PADDING tags.
    // If a valid encapsulated Ethernet frame is found, adjust the eth_offset and
    // jump back to datalink type checking for further processing of the encapsulated frame.
    u_int8_t *payload = (u_int8_t*)&packet[ip_offset+ip_len+sizeof(struct ndpi_udphdr)];
    u_int16_t payload_len = header->caplen - (ip_offset + ip_len + sizeof(struct ndpi_udphdr));
    u_int16_t offset = 0;

    while(offset < payload_len) {
      u_int8_t tag_type = payload[offset];
      u_int16_t tag_len = payload[offset+1];

      if(tag_type == TZSP_END_TAG) {
        break;
      } else if(tag_type == TZSP_PADDING_TAG) {
        offset += tag_len;
      } else if(tag_type == TZSP_ETH_TAG) {
        if(tag_len >= sizeof(struct ndpi_ethhdr)) {
          struct ndpi_ethhdr *eth = (struct ndpi_ethhdr *)&payload[offset];
          eth_offset = offset;
          type = ntohs(eth->h_proto);
          goto ether_type_check;
        }
        offset += tag_len;
      } else {
        // Unknown tag type
        offset += tag_len;
      }
    }
  }