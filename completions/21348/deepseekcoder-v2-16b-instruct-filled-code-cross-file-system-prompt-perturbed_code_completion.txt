if((sport == TZSP_PORT) || (dport == TZSP_PORT)) {
      // Check for TZSP (TaZman Sniffer Protocol) encapsulation in UDP packets.
      // Calculate the initial offset for the TZSP header within the UDP payload.
      // Verify the TZSP version and type, and that it encapsulates Ethernet frames.
      // Iterate through the TZSP tags in the packet, adjusting the offset as needed.
      // Handle different tag types, stopping at the END tag or processing PADDING tags.
      // If a valid encapsulated Ethernet frame is found, adjust the eth_offset and
      // jump back to datalink type checking for further processing of the encapsulated frame.
      u_int offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);
      u_int8_t *eth_frame = &packet[eth_offset];
      u_int8_t *tzsp_header = &packet[offset];
      u_int8_t tzsp_version = tzsp_header[0] >> 4;
      u_int8_t tzsp_type = tzsp_header[0] & 0x0F;

      if(tzsp_version == 1 && tzsp_type == 0x01) { // TZSP version 1, Type 1 (Ethernet frame encapsulation)
        u_int8_t eth_dst[6], eth_src[6], eth_type[2];
        memcpy(eth_dst, &tzsp_header[1], 6);
        memcpy(eth_src, &tzsp_header[7], 6);
        memcpy(eth_type, &tzsp_header[13], 2);

        // Check if the encapsulated Ethernet frame is valid
        if(eth_dst[0] != 0 || eth_src[0] != 0 || eth_type[0] == 0 || eth_type[0] > 0x06) {
          // Invalid Ethernet frame, discard the packet
          workflow->stats.total_discarded_bytes += header->len;
          return detected_protocol;
        }

        // Adjust the eth_offset to point to the encapsulated Ethernet frame
        eth_offset = offset + 14; // Skip the TZSP header
        goto datalink_check;
      }
    }