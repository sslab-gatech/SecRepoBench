u_int offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);
      if (header->caplen < offset + 2)
        return(detected_protocol); /* Too short for TZSP header */

      u_int8_t version = packet[offset];
      u_int8_t type = packet[offset + 1];

      if (version == 1 && type == 0) { /* Ethernet frames */
        offset += 2; /* Skip version and type */

        while (offset < header->caplen) {
          u_int8_t tag_type = packet[offset];
          u_int8_t tag_len = packet[offset + 1];

          if (tag_type == 1) { /* END tag */
            offset += 2;
            break;
          } else if (tag_type == 0) { /* PADDING tag */
            offset += 1;
          } else {
            offset += 2 + tag_len;
          }
        }

        if (offset < header->caplen) {
          eth_offset = offset;
          goto datalink_check;
        }
      }