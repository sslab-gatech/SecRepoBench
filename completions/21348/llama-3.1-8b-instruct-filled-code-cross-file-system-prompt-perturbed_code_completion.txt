// Check for TZSP (TaZman Sniffer Protocol) encapsulation in UDP packets.
// Calculate the initial offset for the TZSP header within the UDP payload.
// Verify the TZSP version and type, and that it encapsulates Ethernet frames.
// Iterate through the TZSP tags in the packet, adjusting the offset as needed.
// Handle different tag types, stopping at the END tag or processing PADDING tags.
// If a valid encapsulated Ethernet frame is found, adjust the eth_offset and
// jump back to datalink type checking for further processing of the encapsulated frame.
// <MASK>
if((sport == TZSP_PORT) || (dport == TZSP_PORT)) {
  u_int offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);
  u_int8_t version = packet[offset];
  u_int8_t type = packet[offset+1];
  u_int8_t flags = packet[offset+2];

  if(version == 0x01 && type == 0x01) {
    // Check for Ethernet frame encapsulation
    if(packet[offset+3] == 0x00 && packet[offset+4] == 0x00) {
      // Calculate the length of the encapsulated Ethernet frame
      u_int16_t eth_len = (packet[offset+5] << 8) + packet[offset+6];

      // Check if the encapsulated frame is long enough to contain an Ethernet header
      if(eth_len >= 14) {
        // Adjust the offset to point to the start of the encapsulated Ethernet frame
        offset += 7;

        // Check if the encapsulated frame is a valid Ethernet frame
        if(packet[offset] == 0x00 && packet[offset+1] == 0x00 && packet[offset+2] == 0x06) {
          // Adjust the eth_offset to point to the start of the encapsulated Ethernet frame
          eth_offset = offset;

          // Jump back to datalink type checking for further processing of the encapsulated frame
          goto datalink_check;
        }
      }
    }
  }
}