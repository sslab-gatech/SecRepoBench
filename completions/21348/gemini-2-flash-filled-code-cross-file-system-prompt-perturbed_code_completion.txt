u_int offset = ip_offset+ip_len+sizeof(struct ndpi_udphdr);
      u_int16_t tzsp_version, tzsp_type, tag_type, tag_len;

      if((offset + 4) > header->caplen)
	return(detected_protocol);

      tzsp_version = ntohs(*((u_int16_t*)&packet[offset]));
      tzsp_type = ntohs(*((u_int16_t*)&packet[offset+2]));

      if((tzsp_version == TZSP_VERSION) && (tzsp_type == TZSP_TYPE_ETHERNET)) {
	offset += 4;

	while(offset < header->caplen) {
	  if((offset + 4) > header->caplen)
	    return(detected_protocol);

	  tag_type = ntohs(*((u_int16_t*)&packet[offset]));
	  tag_len = ntohs(*((u_int16_t*)&packet[offset+2]));

	  if(tag_type == TZSP_TAG_END)
	    break;
	  else if(tag_type == TZSP_TAG_PADDING) {
	    offset += 4;
	    continue;
	  } else if(tag_len == 0)
	    break;
	  else {
	    offset += 4 + tag_len;
	  }
	}

	eth_offset = offset;
	datalink_type = DLT_EN10MB;
	goto datalink_check;
      }