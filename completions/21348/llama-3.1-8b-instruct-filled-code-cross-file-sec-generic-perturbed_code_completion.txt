// <MASK>
else if((sport == TZSP_PORT) || (dport == TZSP_PORT)) {
  // Check for TZSP (TaZman Sniffer Protocol) encapsulation in UDP packets.
  // Calculate the initial offset for the TZSP header within the UDP payload.
  // Verify the TZSP version and type, and that it encapsulates Ethernet frames.
  // Iterate through the TZSP tags in the packet, adjusting the offset as needed.
  // Handle different tag types, stopping at the END tag or processing PADDING tags.
  // If a valid encapsulated Ethernet frame is found, adjust the eth_offset and
  // jump back to datalink type checking for further processing of the encapsulated frame.
  u_int offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);
  if (header->caplen < offset + 4) {
    return(detected_protocol); /* Too short for TZSP header */
  }
  u_int32_t tzsp_version = ntohl(*((u_int32_t*)&packet[offset]));
  if (tzsp_version!= 0x00000001) {
    return(detected_protocol); /* Unknown TZSP version */
  }
  u_int8_t tzsp_type = packet[offset + 4];
  if (tzsp_type!= 0x01) {
    return(detected_protocol); /* Unknown TZSP type */
  }
  if (header->caplen < offset + 8) {
    return(detected_protocol); /* Too short for encapsulated frame */
  }
  u_int32_t encapsulated_len = ntohl(*((u_int32_t*)&packet[offset + 8]));
  if (encapsulated_len > header->caplen - offset - 8) {
    return(detected_protocol); /* Encapsulated frame too long */
  }
  u_int32_t encapsulated_offset = offset + 12;
  if (header->caplen < encapsulated_offset + encapsulated_len) {
    return(detected_protocol); /* Too short for encapsulated frame */
  }
  struct ndpi_ethhdr *encapsulated_eth = (struct ndpi_ethhdr*)&packet[encapsulated_offset];
  if (ntohs(encapsulated_eth->h_proto)!= ETH_P_IP && ntohs(encapsulated_eth->h_proto)!= ETH_P_IPV6) {
    return(detected_protocol); /* Encapsulated frame is not IP or IPv6 */
  }
  ip_offset = encapsulated_offset;
  type = ntohs(encapsulated_eth->h_proto);
  goto iph_check;
}