u_int offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);
    
    if((offset + 6) > header->caplen) break;  // Minimum TZSP header check
    
    u_int8_t version = packet[offset];
    u_int8_t tzsp_type = packet[offset + 1];
    u_int32_t encap_type = ntohl(*((u_int32_t*)&packet[offset + 2]));
    offset += 6;  // Skip TZSP header
    
    if(version != 1 || encap_type != 0x01) break;  // Validate version and Ethernet encapsulation
    
    // Process TZSP tags
    while(offset < header->caplen) {
        u_int8_t tag_type = packet[offset];
        if(tag_type == 0x01) {  // END tag
            offset++;
            break;
        } else if(tag_type == 0x00) {  // PADDING tag
            offset++;
        } else {
            if((offset + 2) > header->caplen) break;
            u_int8_t tag_len = packet[offset + 1];
            offset += 2 + tag_len;  // Skip tag header and data
            if(offset > header->caplen) break;
        }
    }
    
    // Validate encapsulated Ethernet frame
    if((offset + sizeof(struct ndpi_ethhdr)) > header->caplen) break;
    
    eth_offset = offset;
    datalink_type = DLT_EN10MB;
    goto datalink_check;