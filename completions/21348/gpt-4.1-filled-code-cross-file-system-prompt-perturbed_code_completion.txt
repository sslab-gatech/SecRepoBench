// TZSP (TaZman Sniffer Protocol) encapsulation
      u_int offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);
      if(offset + 4 > header->caplen)
        return(detected_protocol); // Not enough data for TZSP header

      u_int8_t tzsp_version = packet[offset];
      u_int8_t tzsp_type = packet[offset+1];
      u_int16_t tzsp_encap = (packet[offset+2] << 8) | packet[offset+3];
      offset += 4;

      // Only handle TZSP version 1, type 0 (received packet), encapsulated Ethernet (encap 1)
      if(tzsp_version == 1 && tzsp_type == 0 && tzsp_encap == 1) {
        // Skip TZSP tags
        while(offset < header->caplen) {
          u_int8_t tag_type = packet[offset];
          offset++;
          if(tag_type == 1) { // END tag
            break;
          } else if(tag_type == 0) { // PADDING tag
            continue;
          } else {
            if(offset >= header->caplen)
              return(detected_protocol);
            u_int8_t tag_len = packet[offset];
            offset++;
            offset += tag_len;
          }
        }
        // After tags, the encapsulated Ethernet frame starts
        if(offset + sizeof(struct ndpi_ethhdr) <= header->caplen) {
          eth_offset = offset;
          datalink_type = DLT_EN10MB;
          goto datalink_check;
        }
      }