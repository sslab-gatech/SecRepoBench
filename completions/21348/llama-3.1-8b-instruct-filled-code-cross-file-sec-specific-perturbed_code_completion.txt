// Check for TZSP (TaZman Sniffer Protocol) encapsulation in UDP packets.
// Calculate the initial offset for the TZSP header within the UDP payload.
// Verify the TZSP version and type, and that it encapsulates Ethernet frames.
// Iterate through the TZSP tags in the packet, adjusting the offset as needed.
// Handle different tag types, stopping at the END tag or processing PADDING tags.
// If a valid encapsulated Ethernet frame is found, adjust the eth_offset and
// jump back to datalink type checking for further processing of the encapsulated frame.
// <MASK>
else if(sport == TZSP_PORT) {
  // Calculate the initial offset for the TZSP header within the UDP payload.
  u_int offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);

  // Verify the TZSP version and type, and that it encapsulates Ethernet frames.
  if((offset + 4) < header->caplen) {
    u_int16_t version = ntohs(*((u_int16_t*)&packet[offset]));

    if(version == 0x0001) {
      u_int16_t type = ntohs(*((u_int16_t*)&packet[offset+2]));

      if(type == 0x0001) {
        // Iterate through the TZSP tags in the packet, adjusting the offset as needed.
        while((offset + 4) < header->caplen) {
          u_int16_t tag_type = ntohs(*((u_int16_t*)&packet[offset+4]));

          switch(tag_type) {
          case 0x0000: // END
            break;
          case 0x0001: // PADDING
            offset += 4;
            break;
          case 0x0002: // ETHERNET
            // Adjust the eth_offset and jump back to datalink type checking.
            eth_offset = offset + 4;
            goto datalink_check;
            break;
          default:
            // Handle unknown tag types.
            offset += 4;
            break;
          }

          // Check if the END tag has been reached.
          if(tag_type == 0x0000)
            break;
        }
      }
    }
  }
}