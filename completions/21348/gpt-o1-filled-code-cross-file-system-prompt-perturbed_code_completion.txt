{
  u_int tzsp_offset = offset;

  /* check if we have enough room for the basic TZSP header (4 bytes) */
  if(tzsp_offset + 4 > header->caplen)
    return(detected_protocol);

  /* parse TZSP header */
  u_int8_t tzsp_version = packet[tzsp_offset];
  u_int8_t tzsp_type = packet[tzsp_offset + 1];
  u_int16_t tzsp_encap = (packet[tzsp_offset + 2] << 8) + packet[tzsp_offset + 3];
  tzsp_offset += 4;

  /* confirm it's a TZSP version 1 'received packet', encapsulating Ethernet frames */
  if(tzsp_version != 1 || tzsp_type != 0 || tzsp_encap != 1)
    break; /* not a valid TZSP-encapsulated Ethernet frame, ignore */

  /* read TZSP tags until we hit the END tag or run out of data */
  while(tzsp_offset + 2 <= header->caplen) {
    u_int8_t tag_type = packet[tzsp_offset];
    u_int8_t tag_len = packet[tzsp_offset + 1];
    tzsp_offset += 2;

    if(tzsp_offset + tag_len > header->caplen)
      break; /* truncated tag, bail out */

    /* END tag (1) terminates tag list */
    if(tag_type == 1) {
      tzsp_offset += tag_len;
      break;
    }
    /* Skip over any other tags (including padding tags) */
    tzsp_offset += tag_len;
  }

  /*
   * At this point, tzsp_offset should point to the encapsulated frame.
   * Adjust offsets to treat the encapsulated data as an ethernet frame.
   */
  eth_offset = tzsp_offset;
  datalink_type = DLT_EN10MB;
  goto datalink_check;
}