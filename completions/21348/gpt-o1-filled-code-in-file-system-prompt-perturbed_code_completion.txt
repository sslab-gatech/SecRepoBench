{
  /* Check TZSP header within the UDP payload. */
  u_int offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);
  /* Ensure there's room for the TZSP header. */
  if (offset + 4 <= header->caplen) {
    /* TZSP header: [version (1 byte)] [type (1 byte)] [encap (2 bytes)] */
    uint8_t tzsp_version = packet[offset];
    uint8_t tzsp_type    = packet[offset + 1];
    uint16_t tzsp_encap  = ntohs(*(uint16_t *)&packet[offset + 2]);
    offset += 4;

    /* Version 1, type 0 (Received tag), encap=1 (Ethernet) are expected. */
    if ((tzsp_version == 1) && (tzsp_type == 0) && (tzsp_encap == 1)) {
      /* TZSP tags follow. Each tag: [type (1 byte)] [length (1 byte)] [data (N bytes)], ends at tag_type=1 (END). */
      while (offset + 2 <= header->caplen) {
        uint8_t tag_type = packet[offset];
        uint8_t tag_len  = packet[offset + 1];
        offset += 2;

        /* Stop if we see an END tag. */
        if (tag_type == 1) {
          break;
        } else if (tag_type == 0) {
          /* Padding, do nothing but don't advance beyond header. */
        } else {
          /* Other tags, skip them by their length. */
          offset += tag_len;
          if (offset > header->caplen)
            break;
        }
      }

      /* If we still have data left, treat that as an Ethernet frame. */
      if (offset < header->caplen) {
        datalink_type = DLT_EN10MB;
        eth_offset    = offset;
        goto datalink_check;
      }
    }
  }
}