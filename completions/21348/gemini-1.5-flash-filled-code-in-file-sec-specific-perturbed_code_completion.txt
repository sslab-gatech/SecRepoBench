u_int offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);
      u_int8_t version = packet[offset];
      u_int8_t type = packet[offset + 1];

      if (version == 1 && type == 1) {
        // Valid TZSP header found.
        // Process TZSP tags and encapsulated Ethernet frames.
        u_int tzsp_offset = offset + 2; // Skip version and type.
        while (1) {
          u_int8_t tag_type = packet[tzsp_offset];
          u_int16_t tag_len = ntohs(*(u_int16_t*)(packet + tzsp_offset + 1));
          if (tag_type == 0x00) { // END tag
            break;
          } else if (tag_type == 0x01) { // PADDING tag
            tzsp_offset += tag_len + 4; // Skip padding.
          } else if (tag_type == 0x02) { // ETHERNET tag
            if (tag_len >= sizeof(struct ndpi_ethhdr)) {
              // Encapsulated Ethernet frame found.
              eth_offset = tzsp_offset + 4; // Adjust eth_offset.
              datalink_type = DLT_EN10MB; // Set datalink type.
              goto datalink_check;
            } else {
              // Invalid Ethernet frame length.
              break;
            }
          } else {
            // Unknown tag type.
            break;
          }
        }
      }