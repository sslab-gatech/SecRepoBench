u_int offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);
      
      /* Check TZSP header */
      if((offset + 4) > header->caplen) break; /* Too short for TZSP header */
      
      /* Verify TZSP version (1) and type (encapsulated Ethernet) */
      if(packet[offset] != 0x01 || packet[offset+1] != 0x00) break;
      
      offset += 4; /* Skip version, type, and encap */
      
      /* Process TZSP tags */
      while(offset < header->caplen) {
        u_int8_t tag_type = packet[offset];
        u_int8_t tag_len;
        
        if(tag_type == 0x01) { /* END tag */
          break;
        } else if(tag_type == 0x00) { /* PADDING tag */
          offset++;
          continue;
        }
        
        if((offset + 1) >= header->caplen) break; /* Invalid tag */
        tag_len = packet[offset+1];
        
        if((offset + 2 + tag_len) > header->caplen) break; /* Tag exceeds packet */
        offset += 2 + tag_len; /* Skip tag header and data */
      }
      
      /* Check if we have enough space for Ethernet header */
      if((offset + sizeof(struct ndpi_ethhdr)) > header->caplen) break;
      
      /* Found encapsulated Ethernet frame */
      eth_offset = offset;
      datalink_type = DLT_EN10MB;
      goto datalink_check;