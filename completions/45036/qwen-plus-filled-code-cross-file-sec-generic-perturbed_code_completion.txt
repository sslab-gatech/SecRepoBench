case ETH_P_MPLS_UNI:
  network_flow->stats.mpls_count++;
  type = ETH_P_IP; // Assuming MPLS carries IP packets, adjust if necessary
  ip_offset += sizeof(mpls); // Adjust IP offset past the MPLS label

  // Extract and convert MPLS labels from network to host byte order
  mpls.u32 = ntohl(*(uint32_t*)&packet[ip_offset - sizeof(mpls)]);
  
  // Iterate through MPLS labels until the bottom-of-stack (BoS) bit is set
  while (!(mpls.mpls.bos)) {
    if ((ip_offset + sizeof(mpls)) > header->caplen) {
      return(nproto); // Not enough data for another MPLS label
    }
    mpls.u32 = ntohl(*(uint32_t*)&packet[ip_offset]);
    ip_offset += sizeof(mpls);
  }

  recheck_type = 1;
  break;