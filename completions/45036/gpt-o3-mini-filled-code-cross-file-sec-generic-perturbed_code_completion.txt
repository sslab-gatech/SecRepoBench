{
  if(header->caplen < ip_offset + 4)
    return(nproto); /* Not enough data for MPLS header */

  /* Update MPLS packet statistics */
  network_flow->stats.mpls_count++;

  /* Process MPLS labels */
  do {
    if(header->caplen < ip_offset + 4)
      return(nproto); /* Not enough data for another MPLS label */
    mpls.u32 = ntohl(*(uint32_t *)(&packet[ip_offset]));
    /* Check bottom-of-stack bit: bit 8 of the 32-bit header */
    if (((mpls.u32 >> 8) & 0x1) == 1) {
      ip_offset += 4;
      break;
    }
    ip_offset += 4;
  } while(ip_offset + 4 <= header->caplen);

  type = ETH_P_IP;
  recheck_type = 1;
  break;
}