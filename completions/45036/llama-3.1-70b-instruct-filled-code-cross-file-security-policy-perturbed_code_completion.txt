case ETH_P_MPLS_UNI:
case ETH_P_MPLS_MULTI:
  {
    u_int32_t mpls_label;
    u_int8_t mpls_label_count = 0;

    if(header->caplen < ip_offset + sizeof(struct ndpi_mpls_header))
      return(nproto); /* Too short for MPLS header*/

    mpls.u32 = *((u_int32_t*)&packet[ip_offset]);
    mpls_label = ntohl(mpls.u32);

    ip_offset += sizeof(struct ndpi_mpls_header);

    while((mpls_label & 0x0000FFFF)!= 0xFFFF) {
      if(header->caplen < ip_offset + sizeof(struct ndpi_mpls_header))
        return(nproto); /* Too short for MPLS header*/

      mpls.u32 = *((u_int32_t*)&packet[ip_offset]);
      mpls_label = ntohl(mpls.u32);

      ip_offset += sizeof(struct ndpi_mpls_header);
      mpls_label_count++;
    }

    network_flow->stats.mpls_count += mpls_label_count;

    type = ETH_P_IP;
    recheck_type = 1;
    break;
  }