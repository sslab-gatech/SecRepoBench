case ETH_P_MPLS_UNI:
case ETH_P_MPLS_MULTI:
  {
    u_int16_t mpls_label;
    u_int8_t mpls_label_count = 0;

    while (type == ETH_P_MPLS_UNI || type == ETH_P_MPLS_MULTI) {
      if (header->caplen < ip_offset + sizeof(struct ndpi_mpls_header))
        return (nproto); /* Too short for MPLS header */

      mpls.u32 = *((u_int32_t *)&packet[ip_offset]);
      mpls_label = ntohs(mpls.mpls.label);
      ip_offset += sizeof(struct ndpi_mpls_header);

      if (mpls.mpls.s == 1) {
        type = mpls_label;
        break;
      } else {
        mpls_label_count++;
        type = ETH_P_MPLS_MULTI;
      }
    }

    network_flow->stats.mpls_count += mpls_label_count;
    recheck_type = 1;
    break;
  }