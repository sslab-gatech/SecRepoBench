case ETH_P_MPLS_UNI:
  {
    u_int32_t label_count = 0;
    u_int32_t offset = ip_offset;

    while (offset + sizeof(mpls) <= header->caplen) {
      mpls.u32 = ntohl(*((u_int32_t*)&packet[offset]));
      if ((mpls.mpls.label & 0x001) == 0x001) { // Bottom-of-Stack (BoS) bit set
        type = IPPROTO_IP; // Assuming the last MPLS label is followed by IP
        ip_offset = offset + sizeof(mpls);
        network_flow->stats.mpls_packet_count++;
        break;
      }
      offset += sizeof(mpls);
      label_count++;
      
      if (label_count > MAX_MPLS_LABELS) { // Prevent potential infinite loop or excessive labels
        return(nproto);
      }
    }

    if (offset >= header->caplen) {
      return(nproto); // Not enough data for MPLS labels
    }
  }
  recheck_type = 1;
  break;