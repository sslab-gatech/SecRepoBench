}
}

/* ****************************************************** */

void ndpi_process_packet(struct ndpi_workflow * workflow, const u_int8_t *packet,
			 u_int32_t packet_len, pkt_timeval when) {
  struct ndpi_iphdr iph;
  struct ndpi_ipv6hdr iph6;
  struct ndpi_tcphdr *tcph = NULL;
  struct ndpi_udphdr *udph = NULL;
  u_int16_t sport, dport;
  u_int8_t proto;
  u_int8_t *payload;
  u_int16_t payload_len;
  u_int8_t src_to_dst_direction;
  u_int32_t packet_id = 0;

  if(packet_len < 20)
    return;

  if(packet[0] == 0x45) {
    /* IPv4 */
    iph = *(struct ndpi_iphdr *)packet;
    src_to_dst_direction = 1;
    process_ndpi_collected_info(workflow,
				get_ndpi_flow_info(workflow, IPVERSION, 0, NDPI_PACKET_TUNNEL_NONE,
						   &iph, NULL, 0, packet_len,
						   packet_len, 0, &tcph, &udph,
						   &sport, &dport, &proto, &payload,
						   &payload_len, &src_to_dst_direction, when),
				NULL);
  } else if(packet[0] == 0x60) {
    /* IPv6 */
    iph6 = *(struct ndpi_ipv6hdr *)packet;
    src_to_dst_direction = 1;
    process_ndpi_collected_info(workflow,
				get_ndpi_flow_info6(workflow, 0, NDPI_PACKET_TUNNEL_NONE,
						    &iph6, 0, packet_len,
						    &tcph, &udph, &sport, &dport,
						    &proto, &payload, &payload_len,
						    &src_to_dst_direction, when),
				NULL);
  }
}

/* ****************************************************** */

void ndpi_process_packet_vlan(struct ndpi_workflow * workflow, const u_int8_t *packet,
			      u_int32_t packet_len, u_int16_t vlan_id, pkt_timeval when) {
  struct ndpi_iphdr iph;
  struct ndpi_ipv6hdr iph6;
  struct ndpi_tcphdr *tcph = NULL;
  struct ndpi_udphdr *udph = NULL;
  u_int16_t sport, dport;
  u_int8_t proto;
  u_int8_t *payload;
  u_int16_t payload_len;
  u_int8_t src_to_dst_direction;
  u_int32_t packet_id = 0;

  if(packet_len < 20)
    return;

  if(packet[0] == 0x45) {
    /* IPv4 */
    iph = *(struct ndpi_iphdr *)packet;
    src_to_dst_direction = 1;
    process_ndpi_collected_info(workflow,
				get_ndpi_flow_info(workflow, IPVERSION, vlan_id, NDPI_PACKET_TUNNEL_NONE,
						   &iph, NULL, 0, packet_len,
						   packet_len, 0, &tcph, &udph,
						   &sport, &dport, &proto, &payload,
						   &payload_len, &src_to_dst_direction, when),
				NULL);
  } else if(packet[0] == 0x60) {
    /* IPv6 */
    iph6 = *(struct ndpi_ipv6hdr *)packet;
    src_to_dst_direction = 1;
    process_ndpi_collected_info(workflow,
				get_ndpi_flow_info6(workflow, vlan_id, NDPI_PACKET_TUNNEL_NONE,
						    &iph6, 0, packet_len,
						    &tcph, &udph, &sport, &dport,
						    &proto, &payload, &payload_len,
						    &src_to_dst_direction, when),
				NULL);
  }
}

/* ****************************************************** */

void ndpi_process_packet_tunnel(struct ndpi_workflow * workflow, const u_int8_t *packet,
				u_int32_t packet_len, ndpi_packet_tunnel tunnel_type, pkt_timeval when) {
  struct ndpi_iphdr iph;
  struct ndpi_ipv6hdr iph6;
  struct ndpi_tcphdr *tcph = NULL;
  struct ndpi_udphdr *udph = NULL;
  u_int16_t sport, dport;
  u_int8_t proto;
  u_int8_t *payload;
  u_int16_t payload_len;
  u_int8_t src_to_dst_direction;
  u_int32_t packet_id = 0;

  if(packet_len < 20)
    return;

  if(packet[0] == 0x45) {
    /* IPv4 */
    iph = *(struct ndpi_iphdr *)packet;
    src_to_dst_direction = 1;
    process_ndpi_collected_info(workflow,
				get_ndpi_flow_info(workflow, IPVERSION, 0, tunnel_type,
						   &iph, NULL, 0, packet_len,
						   packet_len, 0, &tcph, &udph,
						   &sport, &dport, &proto, &payload,
						   &payload_len, &src_to_dst_direction, when),
				NULL);
  } else if(packet[0] == 0x60) {
    /* IPv6 */
    iph6 = *(struct ndpi_ipv6hdr *)packet;
    src_to_dst_direction = 1;
    process_ndpi_collected_info(workflow,
				get_ndpi_flow_info6(workflow, 0, tunnel_type,
						    &iph6, 0, packet_len,
						    &tcph, &udph, &sport, &dport,
						    &proto, &payload, &payload_len,
						    &src_to_dst_direction, when),
				NULL);
  }
}

/* ****************************************************** */

void ndpi_process_packet_vlan_tunnel(struct ndpi_workflow * workflow, const u_int8_t *packet,
				     u_int32_t packet_len, u_int16_t vlan_id, ndpi_packet_tunnel tunnel_type, pkt_timeval when) {
  struct ndpi_iphdr iph;
  struct ndpi_ipv6hdr iph6;
  struct ndpi_tcphdr *tcph = NULL;
  struct ndpi_udphdr *udph = NULL;
  u_int16_t sport, dport;
  u_int8_t proto;
  u_int8_t *payload;
  u_int16_t payload_len;
  u_int8_t src_to_dst_direction;
  u_int32_t packet_id = 0;

  if(packet_len < 20)
    return;

  if(packet[0] == 0x45) {
    /* IPv4 */
    iph = *(struct ndpi_iphdr *)packet;
    src_to_dst_direction = 1;
    process_ndpi_collected_info(workflow,
				get_ndpi_flow_info(workflow, IPVERSION, vlan_id, tunnel_type,
						   &iph, NULL, 0, packet_len,
						   packet_len, 0, &tcph, &udph,
						   &sport, &dport, &proto, &payload,
						   &payload_len, &src_to_dst_direction, when),
				NULL);
  } else if(packet[0] == 0x60) {
    /* IPv6 */
    iph6 = *(struct ndpi_ipv6hdr *)packet;
    src_to_dst_direction = 1;
    process_ndpi_collected_info(workflow,
				get_ndpi_flow_info6(workflow, vlan_id, tunnel_type,
						    &iph6, 0, packet_len,
						    &tcph, &udph, &sport, &dport,
						    &proto, &payload, &payload_len,
						    &src_to_dst_direction, when),
				NULL);
  }
}

/* ****************************************************** */

void ndpi_process_packet_vlan_tunnel_csv(struct ndpi_workflow * workflow, const u_int8_t *packet,
					 u_int32_t packet_len, u_int16_t vlan_id, ndpi_packet_tunnel tunnel_type, FILE * csv_fp, pkt_timeval when) {
  struct ndpi_iphdr iph;
  struct ndpi_ipv6hdr iph6;
  struct ndpi_tcphdr *tcph = NULL;
  struct ndpi_udphdr *udph = NULL;
  u_int16_t sport, dport;
  u_int8_t proto;
  u_int8_t *payload;
  u_int16_t payload_len;
  u_int8_t src_to_dst_direction;
  u_int32_t packet_id = 0;

  if(packet_len < 20)
    return;

  if(packet[0] == 0x45) {
    /* IPv4 */
    iph = *(struct ndpi_iphdr *)packet;
    src_to_dst_direction = 1;
    process_ndpi_collected_info(workflow,
				get_ndpi_flow_info(workflow, IPVERSION, vlan_id, tunnel_type,
						   &iph, NULL, 0, packet_len,
						   packet_len, 0, &tcph, &udph,
						   &sport, &dport, &proto, &payload,
						   &payload_len, &src_to_dst_direction, when),
				csv_fp);
  } else if(packet[0] == 0x60) {
    /* IPv6 */
    iph6 = *(struct ndpi_ipv6hdr *)packet;
    src_to_dst_direction = 1;
    process_ndpi_collected_info(workflow,
				get_ndpi_flow_info6(workflow, vlan_id, tunnel_type,
						    &iph6, 0, packet_len,
						    &tcph, &udph, &sport, &dport,
						    &proto, &payload, &payload_len,
						    &src_to_dst_direction, when),
				csv_fp);
  }
}

/* ****************************************************** */

void ndpi_process_packet_csv(struct ndpi_workflow * workflow, const u_int8_t *packet,
			     u_int32_t packet_len, FILE * csv_fp, pkt_timeval when) {
  struct ndpi_iphdr iph;
  struct ndpi_ipv6hdr iph6;
  struct ndpi_tcphdr *tcph = NULL;
  struct ndpi_udphdr *udph = NULL;
  u_int16_t sport, dport;
  u_int8_t proto;
  u_int8_t *payload;
  u_int16_t payload_len;
  u_int8_t src_to_dst_direction;
  u_int32_t packet_id = 0;

  if(packet_len < 20)
    return;

  if(packet[0] == 0x45) {
    /* IPv4 */
    iph = *(struct ndpi_iphdr *)packet;
    src_to_dst_direction = 1;
    process_ndpi_collected_info(workflow,
				get_ndpi_flow_info(workflow,