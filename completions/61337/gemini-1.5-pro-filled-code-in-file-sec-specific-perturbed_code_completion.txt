{
            if (encoding_guess != NULL) {
                handler = xmlFindCharEncodingHandler((const char *)encoding_guess);
                if (handler != NULL) {
                    if (xmlStrcasecmp(encoding_guess, BAD_CAST "UTF-8")) {
                        xmlSwitchToEncoding(ctxt, handler);
                    }
                } else {
                    htmlParseErr(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
                                "Unsupported encoding %s\n", encoding_guess, NULL);
                }
                xmlFree(encoding_guess);
            } else {
                htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,
                            "No encoding detected\n", NULL, NULL);
            }
        }

        if (ctxt->input->buf != NULL) {
            *len = ctxt->input->buf->encoder->read(ctxt->input->buf->context,
                                                (char *) ctxt->input->cur,
                                                ctxt->input->end - ctxt->input->cur);
            if (*len < 0) {
                *len = 0;
                ctxt->errNo = XML_ERR_INVALID_ENCODING;
                if (ctxt->input->buf->encoder->close != NULL)
                    ctxt->input->buf->encoder->close(ctxt->input->buf->context);
                ctxt->input->buf->encoder = NULL;
                ctxt->input->buf->context = NULL;
            }
        } else {
            *len = 0;
        }
        if (*len == 0) {
            *len = 1;
        }
        return(*ctxt->input->cur);