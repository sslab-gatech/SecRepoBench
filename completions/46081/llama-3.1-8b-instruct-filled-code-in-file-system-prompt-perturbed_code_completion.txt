MagickBooleanType SetQuantumDepth(const Image *image,
  QuantumInfo *quantumdata,const size_t depth)
{
  size_t
    extent,
    quantum;

  /*
    Allocate the quantum pixel buffer.
  */
  assert(image!= (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug!= MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
  assert(quantumdata!= (QuantumInfo *) NULL);
  assert(quantumdata->signature == MagickCoreSignature);
  quantumdata->depth=MagickMin(depth,64);
  extent=GetQuantumExtent(image,quantumdata,quantumdata->format);
  quantum=extent*quantumdata->depth;
  if (quantum > image->columns*image->rows)
    {
      quantumdata->depth=MagickMin(quantum/(image->columns*image->rows),64);
      extent=GetQuantumExtent(image,quantumdata,quantumdata->format);
      quantum=extent*quantumdata->depth;
    }
  if (quantumdata->pixels!= (MemoryInfo **) NULL)
    {
      ssize_t
        i;

      for (i=0; i < (ssize_t) quantumdata->number_threads; i++)
        {
          unsigned char
            *pixels;

          quantumdata->pixels[i]=RelinquishVirtualMemory(quantumdata->pixels[i]);
        }
      quantumdata->pixels=(MemoryInfo **) RelinquishMagickMemory(quantumdata->pixels);
    }
  quantumdata->pixels=(MemoryInfo **) AcquireQuantumMemory(
    quantumdata->number_threads,sizeof(*quantumdata->pixels));
  if (quantumdata->pixels == (MemoryInfo **) NULL)
    return(MagickFalse);
  for (i=0; i < (ssize_t) quantumdata->number_threads; i++)
    {
      unsigned char
        *pixels;

      quantumdata->pixels[i]=AcquireVirtualMemory(extent+1,sizeof(*pixels));
      if (quantumdata->pixels[i] == (MemoryInfo *) NULL)
        {
          DestroyQuantumPixels(quantumdata);
          return(MagickFalse);
        }
      pixels=(unsigned char *)  GetVirtualMemoryBlob(quantumdata->pixels[i]);
      (void) memset(pixels,0,(extent+1)*sizeof(*pixels));
      pixels[extent]=QuantumSignature;
    }
  return(MagickTrue);
}