{
  MagickBooleanType
    status = MagickTrue;

  size_t
    set_depth = depth,
    channels = 5,   /* maximum for CMYKA */
    packet_size,
    extent;

  /* Adjust depth based on format (especially floating point). */
  if (quantumdata->format == FloatingPointQuantumFormat)
    {
      if (set_depth <= 16)
        set_depth = 16;
      else if (set_depth <= 32)
        set_depth = 32;
      else
        set_depth = 64;
    }
  else
    {
      if (set_depth < 1)
        set_depth = 1;
      else if (set_depth > 32)
        set_depth = 32;
    }

  quantumdata->depth = set_depth;

  /*
    Calculate required memory extent for quantum pixels using the
    maximum potential channels plus any padding.
  */
  packet_size = channels + quantumdata->pad;
  if (quantumdata->pack == MagickFalse)
    extent = (size_t) (packet_size * image->columns *
      ((quantumdata->depth + 7) / 8));
  else
    extent = (size_t) (((packet_size * image->columns *
      quantumdata->depth) + 7) / 8);

  /* Free old pixels if they exist, then allocate new pixel buffers. */
  if (quantumdata->pixels != (MemoryInfo **) NULL)
    DestroyQuantumPixels(quantumdata);

  status = AcquireQuantumPixels(quantumdata, extent);
  if (status == MagickFalse)
    return MagickFalse;

  /*
    Reset quantum state after changing depth.
  */
  ResetQuantumState(quantumdata);

  return MagickTrue;
}