MagickBooleanType
    status = MagickTrue;

  /*
    If the requested format is floating-point, adjust to a valid depth.
  */
  if (quantumdata->format == FloatingPointQuantumFormat)
    {
      if (quantumdata->depth <= 16)
        quantumdata->depth=16;
      else if (quantumdata->depth <= 32)
        quantumdata->depth=32;
      else
        quantumdata->depth=64;
    }

  /*
    Calculate the memory required for quantum pixels based on number of
    channels, depth, and image dimensions. Reallocate if needed.
  */
  {
    size_t
      channels = (size_t) GetPixelChannels(image),
      packet_size = (quantumdata->depth/8)*channels,
      total_pixels = (size_t) image->columns*image->rows;

    extent=total_pixels*packet_size;
    if (extent > quantumdata->extent)
      {
        unsigned char
          *new_pixels;

        new_pixels=(unsigned char *) ResizeQuantumMemory(quantumdata->pixels,
          extent,sizeof(*new_pixels));
        if (new_pixels == (unsigned char *) NULL)
          return(MagickFalse);
        quantumdata->pixels=new_pixels;
        quantumdata->extent=extent;
      }
  }
  return(status);