{
  switch (quantumdata->format)
  {
    case FloatingPointQuantumFormat:
    {
      if (quantumdata->depth > 32)
        quantumdata->depth=64;
      else
        quantumdata->depth=32;
      break;
    }
    case ComplexQuantumFormat:
    {
      if (quantumdata->depth > 64)
        quantumdata->depth=128;
      else
        quantumdata->depth=64;
      break;
    }
    default:
      break;
  }
  quantum=(size_t) image->channels*GetQuantumDepth(quantumdata);
  extent=quantumdata->pad;
  if ((quantum % 8) != 0)
    extent++;
  quantum=(quantum/8)+extent;
  if (quantumdata->format == ComplexQuantumFormat)
    quantum*=2;
  if (image->storage_class == DirectClass)
    quantum=image->colors*quantum;
  else
    quantum=image->columns*image->rows*quantum;
  if (quantum == 0)
    return(MagickTrue);
  if (quantum > image->quantum_pixels)
    {
      void
        *pixels;

      pixels=AcquireAlignedMemory(Max(1,quantum/image->columns),
        image->columns*sizeof(*image->pixels));
      if (pixels == (void *) NULL)
        return(MagickFalse);
      if (image->pixels != (unsigned char *) NULL)
        RelinquishAlignedMemory(image->pixels);
      image->pixels=(unsigned char *) pixels;
      image->quantum_pixels=quantum;
    }
  return(MagickTrue);
}