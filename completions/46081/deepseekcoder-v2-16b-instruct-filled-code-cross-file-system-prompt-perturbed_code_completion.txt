// Adjust the quantum depth based on the format and specified depth,
  // particularly for floating point formats. Calculate the memory
  // required for quantum pixels based on the image's channels, padding,
  // and depth. Determine the necessary buffer size by comparing it to
  // the product of the image's dimensions and memory requirement per
  // pixel. Ensure memory allocation for quantum pixels is sufficient;
  // if not, reallocate as needed. Return whether the allocation was
  // successful.
  quantumdata->depth=MagickMin(depth,64);
  size_t channels = image->colorspace == CMYKColorspace ? 4 : 3;
  size_t padding = (image->depth * channels + 7) / 8;
  padding &= ~7; // Ensure padding is a multiple of 8
  extent = image->columns * image->rows * padding;
  if (quantumdata->pixels == (unsigned char *) NULL || quantumdata->length < extent) {
    quantumdata->pixels = (unsigned char *) RelinquishMagickMemory(quantumdata->pixels);
    quantumdata->length = 0;
    quantumdata->pixels = (unsigned char *) AcquireQuantumMemory(image->rows, image->columns * padding);
    if (quantumdata->pixels == (unsigned char *) NULL) {
      quantumdata->length = 0;
      return MagickFalse;
    }
    quantumdata->length = image->rows * image->columns * padding;
  }
  return MagickTrue;
}