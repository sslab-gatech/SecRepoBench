size_t channels = GetPixelChannels(image);
  size_t bytes_per_sample;

  /*
    Determine bytes per sample based on depth and format,
    handling floating point formats separately.
  */
  if ((quantumdata->format == FloatingPointQuantumFormat) &&
      (quantumdata->depth > 8))
    bytes_per_sample=(quantumdata->depth <= 32) ? 4U : 8U;
  else
    bytes_per_sample=(quantumdata->depth+7U)/8U;

  /*
    Calculate the memory required for the entire image:
    number of channels * bytes per sample * columns * rows.
  */
  quantum=channels*bytes_per_sample;
  extent=(size_t) quantum*image->columns*image->rows;

  /*
    Reallocate if necessary, ensuring no use-after-free.
  */
  if ((quantumdata->pixels == (unsigned char *) NULL) || (extent > quantumdata->extent))
  {
    unsigned char *new_pixels=(unsigned char *) ResizeMagickMemory(quantumdata->pixels,extent);
    if (new_pixels == (unsigned char *) NULL)
      return(MagickFalse);
    quantumdata->pixels=new_pixels;
    quantumdata->extent=extent;
  }

  return(MagickTrue);