{
    size_t
      channels,
      row_extent;
    unsigned char
      *buffer;

    /* Determine bytes per sample based on format and depth */
    if (quantumdata->format == FloatingPointQuantumFormat)
      quantum=(quantumdata->depth <= 32) ? 4 : 8;
    else
      quantum=(quantumdata->depth+7)/8;

    /* For simplicity, assume 'channels' can be taken from the image struct */
    channels=(size_t) image->channels; /* Adjust this if there's a helper function */

    /* Safely calculate the buffer size for one row */
    if ((image->columns != 0) && (channels > (SIZE_MAX / image->columns)))
      return(MagickFalse);
    if (((size_t) image->columns*channels) > (SIZE_MAX / quantum))
      return(MagickFalse);
    row_extent=(size_t) image->columns*channels*quantum;

    /* Reallocate the quantum buffer if needed */
    if (row_extent > quantumdata->extent)
      {
        buffer=(unsigned char *) ResizeQuantumMemory(quantumdata->pixels,
          row_extent,sizeof(*buffer));
        if (buffer == (unsigned char *) NULL)
          return(MagickFalse);
        quantumdata->pixels=buffer;
        quantumdata->extent=row_extent;
      }
    return(MagickTrue);
  }