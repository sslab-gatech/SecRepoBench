{
  size_t
    pixel_size,
    quantum_pixels_length;
  ssize_t
    number_channels;

  /* Determine the number of channels based on the quantum format.
     This may be adjusted as needed depending on the image format. */
  switch (quantumdata->format)
  {
    case GrayQuantum:
    case IndexQuantum:
      number_channels=1;
      break;
    case GrayAlphaQuantum:
    case IndexAlphaQuantum:
      number_channels=2;
      break;
    case RGBQuantum:
      number_channels=3;
      break;
    case RGBAQuantum:
    default:
      number_channels=4;
      break;
  }

  /* Calculate bytes required per channel from the quantum depth. */
  pixel_size=(quantumdata->depth+7)/8;

  /* Compute the total memory needed for quantum pixels. */
  quantum_pixels_length=image->columns*image->rows*(size_t) number_channels*pixel_size;
  if (quantum_pixels_length == 0)
    return(MagickFalse);

  /* Allocate or reallocate the quantum pixel buffer as necessary. */
  if (quantumdata->pixels == (unsigned char *) NULL)
  {
    quantumdata->pixels=(unsigned char *)
      AcquireQuantumMemory(quantum_pixels_length, sizeof(*quantumdata->pixels));
    if (quantumdata->pixels == (unsigned char *) NULL)
      return(MagickFalse);
    quantumdata->pixels_length=quantum_pixels_length;
  }
  else if (quantumdata->pixels_length < quantum_pixels_length)
  {
    unsigned char
      *new_pixels;

    new_pixels=(unsigned char *)
      ResizeQuantumMemory(quantumdata->pixels, quantum_pixels_length,
        sizeof(*quantumdata->pixels));
    if (new_pixels == (unsigned char *) NULL)
    {
      quantumdata->pixels=DestroyQuantumMemory(quantumdata->pixels);
      return(MagickFalse);
    }
    quantumdata->pixels=new_pixels;
    quantumdata->pixels_length=quantum_pixels_length;
  }
  return(MagickTrue);
}