/*
  Adjust the quantum depth based on the format and specified depth,
  particularly for floating point formats.
*/
if (quantumdata->format == FloatingPointQuantumFormat)
  quantumdata->depth=64;
else
  quantumdata->depth=MagickMin(depth,16);
/*
  Calculate the memory required for quantum pixels based on the image's
  channels, padding, and depth.
*/
extent=image->channels*quantumdata->depth/8;
if ((image->columns % 8)!= 0)
  extent=(image->columns*quantumdata->depth+63)/64;
else
  extent=(image->columns*quantumdata->depth)/64;
/*
  Determine the necessary buffer size by comparing it to the product of
  the image's dimensions and memory requirement per pixel.
*/
quantum=(size_t) image->columns*image->rows*extent;
if (quantum > quantumdata->quantum)
  {
    quantumdata->quantum=quantum;
    quantumdata->pixel=ReallocateQuantumMemory(quantumdata->pixel,
      quantumdata->quantum*sizeof(*quantumdata->pixel));
    if (quantumdata->pixel == (Quantum *) NULL)
      return(MagickFalse);
  }
return(MagickTrue);