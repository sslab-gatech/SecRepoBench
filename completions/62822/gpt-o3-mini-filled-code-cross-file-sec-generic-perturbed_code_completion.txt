{
  const unsigned char *sptr, *sptr0;
  char *dptr, *dptr0;
  int bits_to_process, available_bits, bytes_used;

  if (count == -1)
    count = slen * 8;

  sptr = (const unsigned char *)src;
  sptr0 = sptr;

  /* Determine how many source bytes are needed to produce count bits */
  bytes_used = (count + 7) / 8;
  if (bytes_used > slen)
    bytes_used = slen;
  available_bits = bytes_used * 8;
  bits_to_process = (count > available_bits) ? available_bits : count;

  dst = mrb_str_new(mrbstate, NULL, count);
  dptr = RSTRING_PTR(dst);
  dptr0 = dptr;

  for (int i = 0; i < bits_to_process; i++) {
    int byte_index = i / 8;
    int bit_index = i % 8;
    unsigned char byte = sptr[byte_index];
    int bit;

    if (flags & PACK_FLAG_LSB) {
      bit = (byte >> bit_index) & 1;
    }
    else {
      bit = (byte >> (7 - bit_index)) & 1;
    }
    *dptr++ = bit ? '1' : '0';
  }

  /* If requested count exceeds the available bits, pad the rest with '0' */
  for (int i = bits_to_process; i < count; i++) {
    *dptr++ = '0';
  }

  sptr += bytes_used;
}