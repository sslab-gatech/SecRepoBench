const char *sptr = (const char*)src;
  const char *sptr0 = sptr;
  int slen = slen;
  mrb_value dst;
  char *dptr;
  char *dptr0;
  int count = count;

  if (count == -1) {
    count = slen * 8;
  }
  else if (slen * 8 < count) {
    // Raise an error if the specified count exceeds the available bits in the source.
    mrb_raisef(mrbstate, E_ARGUMENT_ERROR, "too short source string for %S unpack", mrb_str_new_lit(mrbstate, "b*"));
  }

  dst = mrb_str_new(mrbstate, NULL, count);
  dptr = RSTRING_PTR(dst);
  dptr0 = dptr;

  for (int i = 0; i < count; ++i) {
    int bit;
    if (flags & PACK_FLAG_LSB) {
      bit = (*sptr >> (i%8)) & 1;
    } else {
      bit = (*sptr >> (7 - (i%8))) & 1;
    }
    *dptr++ = bit ? '1' : '0';
    if ((i + 1) % 8 == 0) {
      sptr++;
    }
  }