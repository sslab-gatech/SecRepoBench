const unsigned char *sptr = (const unsigned char *)src;
  const unsigned char *sptr0 = sptr;
  mrb_value dst = mrb_str_new_capa(mrbstate, count);
  char *dptr = RSTRING_PTR(dst);
  char *dptr0 = dptr;

  if (count == -1) {
    count = slen * 8;
  }
  else if (slen * 8 < count) {
    // Raise an error if the specified count exceeds the available bits in the source.
    mrb_raisef(mrbstate, E_ARGUMENT_ERROR, "too short source string for %S unpack", mrb_str_new_cstr(mrbstate, "b*"));
  }

  unsigned int byte = 0;
  for (int i = 0; i < count; ++i) {
    if (flags & PACK_FLAG_LSB) {
      byte |= ((*sptr >> (i % 8)) & 1) << (7 - (i % 8));
      if ((i + 1) % 8 == 0) {
        *dptr++ = (char)(byte & 0xff);
        byte = 0;
        sptr++;
      }
    }
    else {
      byte |= ((*sptr >> (7 - (i % 8))) & 1) << (i % 8);

      if ((i + 1) % 8 == 0) {
        *dptr++ = (char)(byte & 0xff);
        byte = 0;
        sptr++;
      }
    }
  }