static int
unpack_bstr(mrb_state *mrbstate, const void *src, int slen, mrb_value ary, int count, unsigned int flags)
{
  // Unpack the binary data from the source into a string representation of bits.
  // The binary data is read from the source pointer, `src`, and the number of bits to unpack is determined by `count`.
  // If `count` is not specified, it defaults to the length of the source data multiplied by 8.
  // Create a new string `dst` to hold the unpacked bit representation with a length of `count`.
  // Iterate over each bit in the specified range and convert it to a character '0' or '1' based on the value of each bit.
  // Handle the conversion based on the specified `flags`, where `PACK_FLAG_LSB` indicates whether to read the least significant or most significant bits first.
  // Append the resulting string to the array `ary` and return the number of bytes read from the source.
  mrb_value dst;
  const char *sptr = (const char*)src;
  int dlen = 0;
  int dptr = 0;

  if (count == -1) {
    count = slen * 8;
  }
  else if (slen > count) {
    slen = count;
  }

  if (flags & PACK_FLAG_LSB) {
    for (int i = 0; i < slen; i++) {
      if (sptr[i] & 1) {
        dptr++;
      }
      if (dptr & 7) {
        dptr >>= 1;
      }
      else {
        char c = (char)(dptr & 0xff);
        dst = mrb_str_new(mrbstate, &c, 1);
        mrb_ary_push(mrbstate, ary, dst);
        dptr = 0;
      }
    }
  }
  else {
    for (int i = 0; i < slen; i++) {
      if (sptr[i] & 1) {
        dptr |= 1;
      }
      else {
        dptr |= 0;
      }
      if (dptr & 0x7f) {
        dptr <<= 1;
      }
      else {
        char c = (char)(dptr & 0xff);
        dst = mrb_str_new(mrbstate, &c, 1);
        mrb_ary_push(mrbstate, ary, dst);
        dptr = 0;
      }
    }
  }

  return (int)(sptr - (const char*)src);
}