// Create a new string `dst` to hold the unpacked bit representation with a length of `count`.
  dst = mrb_str_new(mrbstate, NULL, count);
  char *dptr = RSTRING_PTR(dst);
  char *dptr0 = dptr;

  // Iterate over each bit in the specified range and convert it to a character '0' or '1' based on the value of each bit.
  unsigned char byte = 0;
  int bit_count = 0;
  for (int i = 0; i < count; i++) {
    if (flags & PACK_FLAG_LSB) {
      byte |= ((const unsigned char *)src)[i / 8] << (i % 8);
    } else {
      byte |= ((const unsigned char *)src)[i / 8] << (7 - (i % 8));
    }
    bit_count++;
    if (bit_count == 8) {
      *dptr++ = (char)(byte & 0xff);
      byte = 0;
      bit_count = 0;
    }
  }
  if (bit_count > 0) {
    *dptr++ = (char)(byte << (8 - bit_count));
  }

  // Resize the string `dst` to the actual length of the unpacked data.
  dst = mrb_str_resize(mrbstate, dst, (mrb_int)(dptr - dptr0));
  mrb_ary_push(mrbstate, ary, dst);
  return (int)(sptr - sptr0);