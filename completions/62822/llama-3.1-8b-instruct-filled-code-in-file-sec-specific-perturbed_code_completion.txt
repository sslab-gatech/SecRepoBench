static int
unpack_bstr(mrb_state *mrbstate, const void *src, int slen, mrb_value ary, int count, unsigned int flags)
{
  // Unpack the binary data from the source into a string representation of bits.
  // The binary data is read from the source pointer, `src`, and the number of bits to unpack is determined by `count`.
  // If `count` is not specified, it defaults to the length of the source data multiplied by 8.
  // Create a new string `dst` to hold the unpacked bit representation with a length of `count`.
  // Iterate over each bit in the specified range and convert it to a character '0' or '1' based on the value of each bit.
  // Handle the conversion based on the specified `flags`, where `PACK_FLAG_LSB` indicates whether to read the least significant or most significant bits first.
  // Append the resulting string to the array `ary` and return the number of bytes read from the source.
  mrb_value dst;
  int dlen;
  unsigned long l;
  int i, padding;
  unsigned char c, ch[4];
  const char *sptr, *sptr0;
  char *dptr, *dptr0;

  sptr0 = sptr = (const char*)src;

  dlen = slen / 8 * 8;  /* an estimated value - may be shorter */
  dst = mrb_str_new(mrb, NULL, dlen);
  dptr0 = dptr = RSTRING_PTR(dst);

  padding = 0;
  while (slen >= 8) {
    for (i = 0; i < 8; i++) {
      do {
        if (slen-- == 0)
          goto done;
        c = *sptr++;
        if (c >= sizeof(base64_dec_tab))
          continue;
        ch[i] = base64_dec_tab[c];
        if (ch[i] == PACK_BASE64_PADDING) {
          ch[i] = 0;
          padding++;
        }
      } while (c >= sizeof(base64_dec_tab) || ch[i] == PACK_BASE64_IGNORE);
    }

    l = (ch[0] << 18) + (ch[1] << 12) + (ch[2] << 6) + ch[3];

    if (padding == 0) {
      *dptr++ = (l >> 16) & 0xff;
      *dptr++ = (l >> 8) & 0xff;
      *dptr++ = l & 0xff;
    }
    else if (padding == 1) {
      *dptr++ = (l >> 16) & 0xff;
      *dptr++ = (l >> 8) & 0xff;
      break;
    }
    else {
      *dptr++ = (l >> 16) & 0xff;
      break;
    }
  }

done:
  dst = mrb_str_resize(mrb, dst, (mrb_int)(dptr - dptr0));
  mrb_ary_push(mrb, ary, dst);
  return (int)(sptr - sptr0);
}