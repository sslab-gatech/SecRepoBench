{
  mrb_value dst;
  char *dptr, *dptr0;
  const unsigned char *sptr, *sptr0;

  /* Determine the total number of bits to unpack. */
  if (count < 0) {
    count = slen * 8;
  }
  if (count < 0) {
    count = 0;  /* safeguard in case slen is zero or negative */
  }

  /* Create a new string to store the bit representation. */
  dst = mrb_str_new(mrbstate, NULL, count);
  dptr = RSTRING_PTR(dst);
  dptr0 = dptr;

  /* Set up source pointers. */
  sptr = (const unsigned char *)src;
  sptr0 = sptr;

  /* Unpack bits from each byte while we have data and bits left to read. */
  while (slen > 0 && count > 0) {
    unsigned char c = *sptr;
    int bits_to_read = (count > 8 ? 8 : count);

    for (int i = 0; i < bits_to_read; i++) {
      int bit;
      if (flags & PACK_FLAG_LSB) {
        bit = (c >> i) & 1;
      }
      else {
        bit = (c >> (7 - i)) & 1;
      }
      *dptr++ = bit ? '1' : '0';
    }

    count -= bits_to_read;
    slen--;
    sptr++;
  }
}