static int
unpack_bstr(mrb_state *mrbstate, const void *src, int slen, mrb_value ary, int count, unsigned int flags)
{
  // Unpack the binary data from the source into a string representation of bits.
  // The binary data is read from the source pointer, `src`, and the number of bits to unpack is determined by `count`.
  // If `count` is not specified, it defaults to the length of the source data multiplied by 8.
  // Create a new string `dst` to hold the unpacked bit representation with a length of `count`.
  // Iterate over each bit in the specified range and convert it to a character '0' or '1' based on the value of each bit.
  // Handle the conversion based on the specified `flags`, where `PACK_FLAG_LSB` indicates whether to read the least significant or most significant bits first.
  // Append the resulting string to the array `ary` and return the number of bytes read from the source.
  mrb_value dst;
  const char *sptr = (const char*)src;
  char *dptr, *dptr0;
  int dlen = 0;

  if (count == -1) {
    count = slen * 8;
  }
  else if (slen > count) {
    slen = count;
  }

  dst = mrb_str_new(mrbstate, NULL, count);
  dptr = RSTRING_PTR(dst);
  dptr0 = dptr;

  unsigned int byte = 0;
  for (int i=0; i++ < slen; sptr++) {
    if (flags & PACK_FLAG_LSB) {
      if (*sptr & 1)
        byte |= 128;
      if (i & 7)
        byte >>= 1;
      else {
        char c = (char)(byte&0xff);
        *dptr++ = c;
        byte = 0;
      }
    }
    else {
      byte |= *sptr & 1;
      if (i & 7)
        byte <<= 1;
      else {
        char c = (char)(byte&0xff);
        *dptr++ = c;
        byte = 0;
      }
    }
  }
  if (slen & 7) {
    if (flags & PACK_FLAG_LSB) {
      byte >>= 7 - (slen & 7);
    }
    else {
      byte <<= 7 - (slen & 7);
    }
    char c = (char)(byte&0xff);
    *dptr++ = c;
  }

  dst = mrb_str_resize(mrbstate, dst, (mrb_int)(dptr - dptr0));
  mrb_ary_push(mrbstate, ary, dst);
  return (int)(sptr - (const char*)src);
}