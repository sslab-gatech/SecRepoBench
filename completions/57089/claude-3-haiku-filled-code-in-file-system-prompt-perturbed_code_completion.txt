// <MASK>
    // Flush the buffer if it reaches the maximum size, sending its contents as CDATA or characters using SAX callbacks.
    // Reset the buffer index afterwards.
    // Move to the next character in the input.
    if (nbchar >= HTML_PARSER_BIG_BUFFER_SIZE) {
        buf[nbchar] = 0;

        /*
         * Ok the segment is to be consumed as chars.
         */
        if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {
            if (areBlanks(ctxt, buf, nbchar)) {
                if (ctxt->keepBlanks) {
                    if (ctxt->sax->characters != NULL)
                        ctxt->sax->characters(ctxt->userData, buf, nbchar);
                } else {
                    if (ctxt->sax->ignorableWhitespace != NULL)
                        ctxt->sax->ignorableWhitespace(ctxt->userData,
                                                       buf, nbchar);
                }
            } else {
                htmlCheckParagraph(ctxt);
                if (ctxt->sax->characters != NULL)
                    ctxt->sax->characters(ctxt->userData, buf, nbchar);
            }
        }
        nbchar = 0;
    }
    NEXTL(l);
    chunk++;
    if (chunk > HTML_PARSER_BUFFER_SIZE) {
        chunk = 0;
        SHRINK;
        GROW;
    }