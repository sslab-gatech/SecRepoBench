NULL);
                        htmlParseDocTypeDecl(ctxt);
                        ctxt->instate = XML_PARSER_PROLOG;
#ifdef DEBUG_PUSH
                        xmlGenericError(xmlGenericErrorContext,
                            "HPP: entering PROLOG\n");
#endif
                        break;
                    }
                    if ((UPP(2) == '-') && (UPP(3) == '-')) {
                        if ((!terminate) &&
                            (htmlParseLookupCommentEnd(ctxt) < 0))
                            goto done;
#ifdef DEBUG_PUSH
                        xmlGenericError(xmlGenericErrorContext,
                            "HPP: Parsing Comment\n");
#endif
                        htmlParseComment(ctxt);
                        ctxt->instate = XML_PARSER_CONTENT;
                        break;
                    }
                    if (avail < 9)
                        goto done;
                    if ((UPP(2) == 'C') && (UPP(3) == 'D') &&
                        (UPP(4) == 'A') && (UPP(5) == 'T') &&
                        (UPP(6) == 'A') && (UPP(7) == '[')) {
                        if ((!terminate) &&
                            (htmlParseLookupSequence(ctxt, ']', 0, 0, 0) < 0))
                            goto done;
                        htmlParseCdataSection(ctxt);
                        ctxt->instate = XML_PARSER_CONTENT;
                        break;
                    }
                    if (avail < 4)
                        goto done;
                    htmlParseErr(ctxt, XML_HTML_UNKNOWN_TAG,
                                 "Unimplemented block %s\n", in->cur, NULL);
                    htmlParseLookupSequence(ctxt, '>', 0, 0, 0);
                    ctxt->instate = XML_PARSER_CONTENT;
                    break;
                } else if ((cur == '<') && (next == '/')) {
		    ctxt->instate = XML_PARSER_END_TAG;
		    ctxt->checkIndex = 0;
#ifdef DEBUG_PUSH
		    xmlGenericError(xmlGenericErrorContext,
			    "HPP: entering END_TAG\n");
#endif
		} else if ((cur == '<') && (next == '?')) {
		    if ((!terminate) &&
		        (htmlParseLookupSequence(ctxt, '>', 0, 0, 0) < 0))
			goto done;
#ifdef DEBUG_PUSH
		    xmlGenericError(xmlGenericErrorContext,
			    "HPP: Parsing PI\n");
#endif
		    htmlParsePI(ctxt);
		    ctxt->instate = XML_PARSER_CONTENT;
		} else if ((cur == '<') && (next!= '!')) {
		    ctxt->instate = XML_PARSER_START_TAG;
#ifdef DEBUG_PUSH
		    xmlGenericError(xmlGenericErrorContext,
			    "HPP: entering START_TAG\n");
#endif
		} else if (cur == '&') {
		    if ((!terminate) && (htmlParseLookupChar(ctxt, ';') < 0))
			goto done;
		    htmlParseEntityRef(ctxt);
		} else {
		    if ((ctxt->sax!= NULL) && (ctxt->sax->characters!= NULL))
			htmlParseCharData(ctxt);
		}
		break;
	    }
            case XML_PARSER_END_TAG: {
	        const xmlChar *name;
		int failed;

		/*
		 * no chars in buffer
		 */
		if (avail < 1)
		    goto done;
		/*
		 * not enough chars in buffer
		 */
		if (avail < 2) {
		    if (!terminate)
			goto done;
		    else
			next ='';
		} else {
		    next = in->cur[1];
		}
		cur = in->cur[0];
	        if (cur!= '<') {
		    ctxt->instate = XML_PARSER_CONTENT;
#ifdef DEBUG_PUSH
		    xmlGenericError(xmlGenericErrorContext,
			    "HPP: entering CONTENT\n");
#endif
		    break;
		}
		if ((!terminate) &&
		    (htmlParseLookupSequence(ctxt, '>', 0, 0, 1) < 0))
		    goto done;

		failed = htmlParseEndTag(ctxt);
		name = ctxt->name;
		if ((failed == -1) ||
		    (name == NULL)) {
		    if (CUR == '>')
			NEXT;
		    break;
		}

		/*
		 * Check for an Empty Element labeled the XML/SGML way
		 */
		if ((CUR == '/') && (NXT(1) == '>')) {
		    SKIP(2);
		    if ((ctxt->sax!= NULL) && (ctxt->sax->endElement!= NULL))
			ctxt->sax->endElement(ctxt->userData, name);
		    htmlnamePop(ctxt);
		    ctxt->instate = XML_PARSER_CONTENT;
#ifdef DEBUG_PUSH
		    xmlGenericError(xmlGenericErrorContext,
			    "HPP: entering CONTENT\n");
#endif
		    break;
		}

		if (CUR == '>') {
		    NEXT;
		} else {
		    htmlParseErr(ctxt, XML_ERR_GT_REQUIRED,
		                 "Couldn't find end of End Tag %s\n",
				 name, NULL);

		    /*
		     * end of parsing of this node.
		     */
		    if (xmlStrEqual(name, ctxt->name)) {
			nodePop(ctxt);
			htmlnamePop(ctxt);
		    }

		    if (ctxt->record_info)
		        htmlNodeInfoPush(ctxt, &node_info);

		    ctxt->instate = XML_PARSER_CONTENT;
#ifdef DEBUG_PUSH
		    xmlGenericError(xmlGenericErrorContext,
			    "HPP: entering CONTENT\n");
#endif
		    break;
		}

		/*
		 * Check for an Empty Element from DTD definition
		 */
		if ((ctxt->sax!= NULL) && (ctxt->sax->endElement!= NULL))
		    ctxt->sax->endElement(ctxt->userData, name);
		htmlnamePop(ctxt);
                if (ctxt->record_info)
	            htmlNodeInfoPush(ctxt, &node_info);

		ctxt->instate = XML_PARSER_CONTENT;
#ifdef DEBUG_PUSH
		xmlGenericError(xmlGenericErrorContext,
			"HPP: entering CONTENT\n");
#endif
                break;
	    }
            case XML_PARSER_CDATA_SECTION: {
	        /*
		 * The Push mode need to have the SAX callback for
		 * cdataBlock merge back contiguous callbacks.
		 */
		const xmlChar *term;

                if (terminate) {
                    /*
                     * Don't call htmlParseLookupSequence. If 'terminate'
                     * is set, checkIndex is invalid.
                     */
                    term = BAD_CAST strstr((const char *) ctxt->input->cur,
                                           "]]>");
                } else {
		    term = htmlParseLookupSequence(ctxt, ']', 0, 0, 0);
                }

		if (term == NULL) {
		    int tmp, size;

                    if (terminate) {
                        /* Unfinished CDATA section */
                        size = ctxt->input->end - ctxt->input->cur;
                    } else {
                        if (avail < HTML_PARSER_BIG_BUFFER_SIZE + 2)
                            goto done;
                        ctxt->checkIndex = 0;
                        /* XXX: Why don't we pass the full buffer? */
                        size = HTML_PARSER_BIG_BUFFER_SIZE;
                    }
                    tmp = htmlCheckCdataPush(ctxt->input->cur, size, 0);
                    if (tmp <= 0) {
                        tmp = -tmp;
                        ctxt->input->cur += tmp;
                        goto encoding_error;
                    }
                    if ((ctxt->sax!= NULL) && (!ctxt->disableSAX)) {
                        if (ctxt->sax->cdataBlock!= NULL)
                            ctxt->sax->cdataBlock(ctxt->userData,
                                                  ctxt->input->cur, tmp);
                        else if (ctxt->sax->characters!= NULL)
                            ctxt->sax->characters(ctxt->userData,
                                                  ctxt->input->cur, tmp);
                    }
                    if (ctxt->instate == XML_PARSER_EOF)
                        goto done;
                    SKIPL(tmp);
		} else {
                    int base = term - CUR_PTR;
		    int tmp;

		    tmp = htmlCheckCdataPush(ctxt->input->cur, base, 1);
		    if ((tmp < 0) || (tmp!= base)) {
			tmp = -tmp;
			ctxt->input->cur += tmp;
			goto encoding_error;
		    }
		    if ((ctxt->sax!= NULL) && (base == 0) &&
		        (ctxt->sax->cdataBlock!= NULL) &&
		        (!ctxt->disableSAX)) {
			/*
			 * Special case to provide identical behaviour
			 * between pull and push parsers on enpty CDATA
			 * sections
			 */
			 if ((ctxt->input->cur - ctxt->input->base >= 9) &&
			     (!strncmp((const char *)&ctxt->input->cur[-9],
			               "<![CDATA[", 9)))
			     ctxt->sax->cdataBlock(ctxt->userData,
			                           BAD_CAST "", 0);
		    } else if ((ctxt->sax!= NULL) && (base > 0) &&
			(!ctxt->disableSAX)) {
			if (ctxt->sax->cdataBlock!= NULL)
			    ctxt->sax->cdataBlock(ctxt->userData,
						  ctxt->input->cur, base);
			else if (ctxt->sax->characters!= NULL)
			    ctxt->sax->characters(ctxt->userData,
						  ctxt->input->cur, base);
		    }
		    if (ctxt->instate == XML_PARSER_EOF)
			goto done;
		    SKIPL(base + 3);
		    ctxt->instate = XML_PARSER_CONTENT;
#ifdef DEBUG_PUSH
		    xmlGenericError(xmlGenericErrorContext,
			    "HPP: entering CONTENT\n");
#endif
		}
		break;
	    }
            case XML_PARSER_MISC:
            case XML_PARSER_PROLOG:
            case XML_PARSER_EPILOG:
		SKIP_BLANKS;
		if (in->buf == NULL)
		    avail = in->length - (in->cur - in->base);
		else
		    avail = (ptrdiff_t)xmlBufUse(in->buf->buffer) -
                            (in->cur - in->base);
		if (avail < 2)
		    goto done;
		cur = in->cur[0];
		next = in->cur[1];
	        if ((cur == '<') && (next == '?')) {
		    if ((!terminate) &&
		        (htmlParseLookupSequence(ctxt, '>', 0, 0, 0) < 0))
			goto done;
#ifdef DEBUG_PUSH
		    xmlGenericError(xmlGenericErrorContext,
			    "HPP: Parsing PI\n");
#endif
		    htmlParsePI(ctxt);
		    if (ctxt->instate == XML_PARSER_EOF)
			goto done;
		} else if ((cur == '<') && (next == '!') &&
		    (in->cur[2] == '-') && (in->cur[3] == '-')) {
		    if ((!terminate) &&
		        (htmlParseLookupCommentEnd(ctxt) < 0))
			goto done;
#ifdef DEBUG_PUSH
		    xmlGenericError(xmlGenericErrorContext,
			    "HPP: Parsing Comment\n");
#endif
		    htmlParseComment(ctxt);
		    if (ctxt->instate == XML_PARSER_EOF)
			goto done;
		} else if ((ctxt->instate == XML_PARSER_MISC) &&
                    (cur == '<') && (next == '!') &&
		    (in->cur[2] == 'D') && (in->cur[3] == 'O') &&
		    (in->cur[4] == 'C') && (in->cur[5] == 'T') &&
		    (in->cur[6] == 'Y') && (in->cur[7] == 'P') &&
		    (in->cur[8] == 'E')) {
		    if ((!terminate) &&
		        (htmlParseLookupSequence(ctxt, '>', 0, 0, 1) < 0))
			goto done;
#ifdef DEBUG_PUSH
		    xmlGenericError(xmlGenericErrorContext,
			    "HPP: Parsing internal subset\n");
#endif
		    htmlParseDocTypeDecl(ctxt);
		    if (ctxt->instate == XML_PARSER_EOF)
			goto done;
		    if (RAW == '[') {
			ctxt->instate = XML_PARSER_DTD;
#ifdef DEBUG_PUSH
			xmlGenericError(xmlGenericErrorContext,
				"HPP: entering DTD\n");
#endif
		    } else {
			/*
			 * Create and update the external subset.
			 */
			ctxt->inSubset = 2;
			if ((ctxt->sax) && (!ctxt->disableSAX) &&
			    (ctxt->sax->externalSubset!= NULL))
			    ctxt->sax->externalSubset(ctxt->userData,
				    ctxt->intSubName, ctxt->extSubSystem,
				    ctxt->extSubURI);
			ctxt->inSubset = 0;
			htmlCleanSpecialAttr(ctxt);
			ctxt->instate = XML_PARSER_PROLOG;
#ifdef DEBUG_PUSH
			xmlGenericError(xmlGenericErrorContext,
				"HPP: entering PROLOG\n");
#endif
		    }
		} else if ((cur == '<') && (next == '!') &&
		           (avail <
                            (ctxt->instate == XML_PARSER_MISC? 9 : 4))) {
		    goto done;
		} else if (ctxt->instate == XML_PARSER_EPILOG) {
		    htmlParseErr(ctxt, XML_ERR_DOCUMENT_END,
		                 "Extra content at the end of the document\n",
				 NULL, NULL);
		    ctxt->errNo = XML_ERR_DOCUMENT_END;
		    ctxt->wellFormed = 0;
		    ctxt->instate = XML_PARSER_EOF;
#ifdef DEBUG_PUSH
		    xmlGenericError(xmlGenericErrorContext,
			    "HPP: entering EOF\n");
#endif
		    if ((ctxt->sax) && (ctxt->sax->endDocument!= NULL))
			ctxt->sax->endDocument(ctxt->userData);
		    goto done;
                } else {
		    ctxt->instate = XML_PARSER_START_TAG;
#ifdef DEBUG_PUSH
		    xmlGenericError(xmlGenericErrorContext,
			    "HPP: entering START_TAG\n");
#endif
		}
		break;
            case XML_PARSER_DTD: {
                if ((!terminate) &&
                    (htmlParseLookupInternalSubset(ctxt) < 0))
                    goto done;
		htmlParseInternalSubset(ctxt);
		if (ctxt->instate == XML_PARSER_EOF)
		    goto done;
		ctxt->inSubset = 2;
		if ((ctxt->sax) && (!