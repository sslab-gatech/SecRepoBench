if (ctxt->errNo != XML_ERR_OK) {
    xmlHaltParser(ctxt);
    return (ctxt->errNo);
}

if (ctxt->input == NULL) {
    xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, "No input\n");
    xmlHaltParser(ctxt);
    return (ctxt->errNo);
}

if (ctxt->input->end - ctxt->input->cur < 4) {
    xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, "Not enough data\n");
    xmlHaltParser(ctxt);
    return (ctxt->errNo);
}

if (ctxt->input->cur[0] != '<' || ctxt->input->cur[1] != '?' || ctxt->input->cur[2] != 'x' || ctxt->input->cur[3] != 'm' || ctxt->input->cur[4] != 'l') {
    xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, "Not an XML declaration\n");
    xmlHaltParser(ctxt);
    return (ctxt->errNo);
}

ctxt->instate = XML_PARSER_PROLOG;
xmlParseProlog(ctxt);
if (ctxt->instate == XML_PARSER_EOF)
    return (ctxt->errNo);

if (ctxt->input->cur - ctxt->input->base > 4096) {
    xmlParserInputShrink(ctxt->input);
}

while (ctxt->instate != XML_PARSER_EOF) {
    if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))
        return (ctxt->errNo);

    if (ctxt->input == NULL)
        break;

    if (ctxt->input->buf == NULL)
        avail = ctxt->input->length - (ctxt->input->cur - ctxt->input->base);
    else {
        /*
         * If we are operating on converted input, try to flush
         * remaining chars to avoid them stalling in the non-converted
         * buffer. But do not do this in document start where
         * encoding="..." may not have been read and we work on a
         * guessed encoding.
         */
        if ((ctxt->instate != XML_PARSER_START) &&
            (ctxt->input->buf->raw != NULL) &&
            (xmlBufIsEmpty(ctxt->input->buf->raw) == 0)) {
            size_t base = xmlBufGetInputBase(ctxt->input->buf->buffer, ctxt->input);
            size_t current = ctxt->input->cur - ctxt->input->base;

            xmlParserInputBufferPush(ctxt->input->buf, 0, "");
            xmlBufSetInputBaseCur(ctxt->input->buf->buffer, ctxt->input, base, current);
        }
        avail = xmlBufUse(ctxt->input->buf->buffer) - (ctxt->input->cur - ctxt->input->base);
    }
    if (avail < 1)
        goto done;

    switch (ctxt->instate) {
        case XML_PARSER_EOF:
            /*
             * Document parsing is done !
             */
            goto done;
        case XML_PARSER_START:
            if (ctxt->charset == XML_CHAR_ENCODING_NONE) {
                xmlChar start[4];
                xmlCharEncoding enc;

                /*
                 * Very first chars read from the document flow.
                 */
                if (avail < 4)
                    goto done;

                /*
                 * Get the 4 first bytes and decode the charset
                 * if enc != XML_CHAR_ENCODING_NONE
                 * plug some encoding conversion routines,
                 * else xmlSwitchEncoding will set to (default)
                 * UTF8.
                 */
                start[0] = RAW;
                start[1] = NXT(1);
                start[2] = NXT(2);
                start[3] = NXT(3);
                enc = xmlDetectCharEncoding(start, 4);
                xmlSwitchEncoding(ctxt, enc);
                break;
            }

            if (avail < 2)
                goto done;
            cur = ctxt->input->cur[0];
            next = ctxt->input->cur[1];
            if (cur == 0) {
                if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))
                    ctxt->sax->setDocumentLocator(ctxt->userData, &xmlDefaultSAXLocator);
                xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);
                xmlHaltParser(ctxt);
#ifdef DEBUG_PUSH
                xmlGenericError(xmlGenericErrorContext,
                        "PP: entering EOF\n");
#endif
                if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))
                    ctxt->sax->endDocument(ctxt->userData);
                goto done;
            }
            if ((cur == '<') && (next == '?')) {
                /* PI or XML decl */
                if (avail < 5) goto done;
                if ((!terminate) &&
                        (!xmlParseLookupString(ctxt, 2, "?>", 2)))
                    goto done;
                if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))
                    ctxt->sax->setDocumentLocator(ctxt->userData, &xmlDefaultSAXLocator);
                if ((ctxt->input->cur[2] == 'x') &&
                    (ctxt->input->cur[3] == 'm') &&
                    (ctxt->input->cur[4] == 'l') &&
                    (IS_BLANK_CH(ctxt->input->cur[5]))) {
                    ret += 5;
#ifdef DEBUG_PUSH
                    xmlGenericError(xmlGenericErrorContext,
                            "PP: Parsing XML Decl\n");
#endif
                    xmlParseXMLDecl(ctxt);
                    if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {
                        /*
                         * The XML REC instructs us to stop parsing right
                         * here
                         */
                        xmlHaltParser(ctxt);
                        return(0);
                    }
                    ctxt->standalone = ctxt->input->standalone;
                    if ((ctxt->encoding == NULL) &&
                        (ctxt->input->encoding != NULL))
                        ctxt->encoding = xmlStrdup(ctxt->input->encoding);
                    if ((ctxt->sax) && (ctxt->sax->startDocument) &&
                        (!ctxt->disableSAX))
                        ctxt->sax->startDocument(ctxt->userData);
                    ctxt->instate = XML_PARSER_MISC;
#ifdef DEBUG_PUSH
                    xmlGenericError(xmlGenericErrorContext,
                            "PP: entering MISC\n");
#endif
                } else {
                    ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);
                    if ((ctxt->sax) && (ctxt->sax->startDocument) &&
                        (!ctxt->disableSAX))
                        ctxt->sax->startDocument(ctxt->userData);
                    ctxt->instate = XML_PARSER_MISC;
#ifdef DEBUG_PUSH
                    xmlGenericError(xmlGenericErrorContext,
                            "PP: entering MISC\n");
#endif
                }
            } else {
                if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))
                    ctxt->sax->setDocumentLocator(ctxt->userData, &xmlDefaultSAXLocator);
                ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);
                if ((ctxt->sax) && (ctxt->sax->startDocument) &&
                    (!ctxt->disableSAX))
                    ctxt->sax->startDocument(ctxt->userData);
                ctxt->instate = XML_PARSER_MISC;
#ifdef DEBUG_PUSH
                xmlGenericError(xmlGenericErrorContext,
                        "PP: entering MISC\n");
#endif
            }
            break;
        case XML_PARSER_MISC:
            SKIP_BLANKS;
            if (ctxt->input->buf == NULL)
                avail = ctxt->input->length - (ctxt->input->cur - ctxt->input->base);
            else
                avail = xmlBufUse(ctxt->input->buf->buffer) - (ctxt->input->cur - ctxt->input->base);
            if (avail < 2)
                goto done;
            cur = ctxt->input->cur[0];
            next = ctxt->input->cur[1];
            if ((cur == '<') && (next == '?')) {
                if ((!terminate) &&
                        (!xmlParseLookupString(ctxt, 2, "?>", 2)))
                    goto done;
#ifdef DEBUG_PUSH
                xmlGenericError(xmlGenericErrorContext,
                        "PP: Parsing PI\n");
#endif
                xmlParsePI(ctxt);
                if (ctxt->instate == XML_PARSER_EOF)
                    goto done;
            } else if ((cur == '<') && (next == '!') &&
                       (ctxt->input->cur[2] == '-') &&
                       (ctxt->input->cur[3] == '-')) {
                if ((!terminate) &&
                        (!xmlParseLookupString(ctxt, 4, "-->", 3)))
                    goto done;
#ifdef DEBUG_PUSH
                xmlGenericError(xmlGenericErrorContext,
                        "PP: Parsing Comment\n");
#endif
                xmlParseComment(ctxt);
                if (ctxt->instate == XML_PARSER_EOF)
                    goto done;
            } else if ((ctxt->instate == XML_PARSER_MISC) &&
                       (cur == '<') && (next == '!') &&
                       (ctxt->input->cur[2] == 'D') &&
                       (ctxt->input->cur[3] == 'O') &&
                       (ctxt->input->cur[4] == 'C') &&
                       (ctxt->input->cur[5] == 'T') &&
                       (ctxt->input->cur[6] == 'Y') &&
                       (ctxt->input->cur[7] == 'P') &&
                       (ctxt->input->cur[8] == 'E')) {
                if ((!terminate) && (!xmlParseLookupGt(ctxt)))
                    goto done;
#ifdef DEBUG_PUSH
                xmlGenericError(xmlGenericErrorContext,
                        "PP: Parsing internal subset\n");
#endif
                ctxt->inSubset = 1;
                xmlParseDocTypeDecl(ctxt);
                if (ctxt->instate == XML_PARSER_EOF)
                    goto done;
                if (RAW == '[') {
                    ctxt->instate = XML_PARSER_DTD;
#ifdef DEBUG_PUSH
                    xmlGenericError(xmlGenericErrorContext,
                            "PP: entering DTD\n");
#endif
                } else {
                    /*
                     * Create and update the external subset.
                     */
                    ctxt->inSubset = 2;
                    if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&
                        (ctxt->sax->externalSubset != NULL))
                        ctxt->sax->externalSubset(ctxt->userData,
                                ctxt->intSubName, ctxt->extSubSystem,
                                ctxt->extSubURI);
                    ctxt->inSubset = 0;
                    xmlCleanSpecialAttr(ctxt);
                    ctxt->instate = XML_PARSER_PROLOG;
#ifdef DEBUG_PUSH
                    xmlGenericError(xmlGenericErrorContext,
                            "PP: entering PROLOG\n");
#endif
                }
            } else if ((cur == '<') && (next == '!') &&
                      (avail <
                          (ctxt->instate == XML_PARSER_MISC ? 9 : 4))) {
                goto done;
            } else if (ctxt->instate == XML_PARSER_EPILOG) {
                xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);
                xmlHaltParser(ctxt);
#ifdef DEBUG_PUSH
                xmlGenericError(xmlGenericErrorContext,
                        "PP: entering EOF\n");
#endif
                if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))
                    ctxt->sax->endDocument(ctxt->userData);
                goto done;
            } else {
                ctxt->instate = XML_PARSER_START_TAG;
#ifdef DEBUG_PUSH
                xmlGenericError(xmlGenericErrorContext,
                        "PP: entering START_TAG\n");
#endif
            }
            break;
        case XML_PARSER_PROLOG:
            SKIP_BLANKS;
            if (ctxt->input->buf == NULL)
                avail = ctxt->input->length - (ctxt->input->cur - ctxt->input->base);
            else
                avail = xmlBufUse(ctxt->input->buf->buffer) - (ctxt->input->cur - ctxt->input->base);
            if (avail < 2)
                goto done;
            cur = ctxt->input->cur[0];
            next = ctxt->input->cur[1];
            if ((cur == '<') && (next == '?')) {
                if ((!terminate) &&
                        (!xmlParseLookupString(ctxt, 2, "?>", 2)))
                    goto done;
#ifdef DEBUG_PUSH
                xmlGenericError(xmlGenericErrorContext,
                        "PP: Parsing PI\n");
#endif
                xmlParsePI(ctxt);
                if (ctxt->instate == XML_PARSER_EOF)
                    goto done;
            } else if ((cur == '<') && (next == '!') &&
                       (ctxt->input->cur[2] == '-') &&
                       (ctxt->input->cur[3] == '-')) {
                if ((!terminate) &&
                        (!xm