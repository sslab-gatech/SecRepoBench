just removed
 */
xmlNodePtr
nodePop(xmlParserCtxtPtr ctxt)
{
    xmlNodePtr ret;

    if (ctxt == NULL)
        return(NULL);
    if (ctxt->nodeNr <= 0)
        return (NULL);
    ctxt->nodeNr--;
    if (ctxt->nodeNr > 0)
        ctxt->node = ctxt->nodeTab[ctxt->nodeNr - 1];
    else
        ctxt->node = NULL;
    ret = ctxt->nodeTab[ctxt->nodeNr];
    ctxt->nodeTab[ctxt->nodeNr] = NULL;
    return (ret);
}

/**
 * xmlParseStringEntityRef:
 * @ctxt:  an XML parser context
 * @str:  the string to parse
 *
 * Parse a string entity reference.
 *
 * Returns the entity or NULL in case of error
 */
static xmlEntityPtr
xmlParseStringEntityRef(xmlParserCtxtPtr ctxt, const xmlChar **str)
{
    xmlEntityPtr ret;
    const xmlChar *cur;
    int len;

    if (ctxt == NULL) return(NULL);
    cur = *str;
    if ((cur == NULL) || (*cur == 0))
        return(NULL);

    if ((cur[0] == '&') && (cur[1] == '#')) {
        int base;
        int value;
        int c;

        cur += 2;
        if ((cur[0] == 'x') || (cur[0] == 'X')) {
            base = 16;
            cur++;
        } else {
            base = 10;
        }
        value = 0;
        while ((c = cur[0]) != 0) {
            if ((c >= '0') && (c <= '9')) {
                value = value * base + (c - '0');
            } else if ((c >= 'a') && (c <= 'f')) {
                value = value * base + (c - 'a' + 10);
            } else if ((c >= 'A') && (c <= 'F')) {
                value = value * base + (c - 'A' + 10);
            } else {
                break;
            }
            cur++;
        }
        if (c == 0) {
            *str = cur;
            ret = xmlNewEntity(NULL, NULL, value, 0, 0, 0, 0, 0, 0, 0);
            if (ret == NULL)
                xmlErrMemory(ctxt, NULL);
            return(ret);
        }
    } else {
        len = 0;
        while ((cur[len] != 0) && (cur[len] != ';'))
            len++;
        if (cur[len] == ';')
            len++;
        if (len == 0)
            return(NULL);
        *str = cur + len;
        ret = xmlGetPredefinedEntity(cur);
        if (ret == NULL) {
            xmlErrMemory(ctxt, NULL);
            return(NULL);
        }
        return(ret);
    }
    return(NULL);
}

/**
 * xmlParseEntityRef:
 * @ctxt:  an XML parser context
 *
 * Parse an entity reference.
 *
 * Returns the entity or NULL in case of error
 */
static xmlEntityPtr
xmlParseEntityRef(xmlParserCtxtPtr ctxt)
{
    xmlEntityPtr ret;
    const xmlChar *cur;

    if (ctxt == NULL) return(NULL);
    cur = ctxt->input->cur;
    if ((cur == NULL) || (*cur == 0))
        return(NULL);

    if ((cur[0] == '&') && (cur[1] == '#')) {
        int base;
        int value;
        int c;

        cur += 2;
        if ((cur[0] == 'x') || (cur[0] == 'X')) {
            base = 16;
            cur++;
        } else {
            base = 10;
        }
        value = 0;
        while ((c = cur[0]) != 0) {
            if ((c >= '0') && (c <= '9')) {
                value = value * base + (c - '0');
            } else if ((c >= 'a') && (c <= 'f')) {
                value = value * base + (c - 'a' + 10);
            } else if ((c >= 'A') && (c <= 'F')) {
                value = value * base + (c - 'A' + 10);
            } else {
                break;
            }
            cur++;
        }
        if (c == 0) {
            ctxt->input->cur = cur;
            ret = xmlNewEntity(NULL, NULL, value, 0, 0, 0, 0, 0, 0, 0);
            if (ret == NULL)
                xmlErrMemory(ctxt, NULL);
            return(ret);
        }
    } else {
        if (cur[0] == '&') {
            cur++;
            if (cur[0] == 0)
                return(NULL);
            ret = xmlGetPredefinedEntity(cur);
            if (ret == NULL) {
                xmlErrMemory(ctxt, NULL);
                return(NULL);
            }
            return(ret);
        }
    }
    return(NULL);
}

/**
 * xmlParseElementStart:
 * @ctxt:  an XML parser context
 *
 * Parse an element start tag.
 *
 * Returns 0 if the element is correctly parsed, -1 in case of error
 */
static int
xmlParseElementStart(xmlParserCtxtPtr ctxt)
{
    int c;
    int len;
    int attcount;
    int attallocs;
    int options;
    xmlChar *name;
    xmlChar *prefix = NULL;
    xmlChar *URI = NULL;
    xmlChar *base = NULL;
    xmlChar *cur;
    xmlChar *end;
    xmlChar *value;
    xmlEntityPtr entity;
    xmlNsPtr ns;
    xmlStartTag *start;

    if (ctxt == NULL) return(-1);
    if (ctxt->instate != XML_PARSER_CONTENT) {
        xmlFatalErr(ctxt, XML_ERR_UNEXPECTED_STATE, NULL);
        return(-1);
    }
    ctxt->node = xmlNewNode(NULL, NULL);
    if (ctxt->node == NULL)
        return(-1);
    if (nodePush(ctxt, ctxt->node) < 0) {
        xmlFreeNode(ctxt->node);
        ctxt->node = NULL;
        return(-1);
    }
    ctxt->node->doc = ctxt->doc;
    ctxt->node->type = XML_ELEMENT_NODE;
    ctxt->node->parent = ctxt->nodePopped;
    ctxt->nodePopped = NULL;

    start = (xmlStartTag *) xmlMalloc(sizeof(xmlStartTag));
    if (start == NULL) {
        xmlFreeNode(ctxt->node);
        ctxt->node = NULL;
        return(-1);
    }
    start->prefix = NULL;
    start->URI = NULL;
    start->line = ctxt->input->line;
    start->nsNr = 0;

    /*
     * Parse the element name
     */
    cur = ctxt->input->cur;
    if ((cur == NULL) || (*cur == 0)) {
        xmlFree(start);
        xmlFreeNode(ctxt->node);
        ctxt->node = NULL;
        return(-1);
    }
    end = cur;
    while ((*end != 0) && (*end != ' ') && (*end != '>') && (*end != '/'))
        end++;
    len = end - cur;
    if (len == 0) {
        xmlFree(start);
        xmlFreeNode(ctxt->node);
        ctxt->node = NULL;
        return(-1);
    }
    name = xmlStrndup(cur, len);
    if (name == NULL) {
        xmlFree(start);
        xmlFreeNode(ctxt->node);
        ctxt->node = NULL;
        return(-1);
    }
    ctxt->input->cur = end;

    /*
     * Parse the attributes
     */
    attcount = 0;
    attallocs = 0;
    while ((cur = ctxt->input->cur) != NULL) {
        if ((*cur == ' ') || (*cur == '>') || (*cur == '/')) {
            if ((cur[0] == '>') && (cur[1] == '-') && (cur[2] == '-')) {
                /*
                 * Comment
                 */
                ctxt->input->cur = cur + 3;
                xmlParseComment(ctxt);
                continue;
            }
            if ((cur[0] == '>') && (cur[1] == ']') && (cur[2] == ']') &&
                (cur[3] == '>')) {
                /*
                 * CDATA
                 */
                ctxt->input->cur = cur + 4;
                xmlParseCDATA(ctxt);
                continue;
            }
            if ((cur[0] == '>') && (cur[1] == '?') && (cur[2] == '?')) {
                /*
                 * PI
                 */
                ctxt->input->cur = cur + 3;
                xmlParsePI(ctxt);
                continue;
            }
            break;
        }
        if (*cur == '<') {
            xmlFatalErr(ctxt, XML_ERR_UNEXPECTED_CHAR, NULL);
            xmlFree(start);
            xmlFreeNode(ctxt->node);
            xmlFree(name);
            ctxt->node = NULL;
            return(-1);
        }
        if (*cur == '&') {
            entity = xmlParseEntityRef(ctxt);
            if (entity == NULL) {
                xmlFatalErr(ctxt, XML_ERR_UNEXPECTED_CHAR, NULL);
                xmlFree(start);
                xmlFreeNode(ctxt->node);
                xmlFree(name);
                ctxt->node = NULL;
                return(-1);
            }
            value = xmlStrndup(entity->content, entity->length);
            xmlFree(entity);
            if (value == NULL) {
                xmlFatalErr(ctxt, XML_ERR_NO_MEMORY, NULL);
                xmlFree(start);
                xmlFreeNode(ctxt->node);
                xmlFree(name);
                ctxt->node = NULL;
                return(-1);
            }
            xmlAddChild(ctxt->node, xmlNewText(value));
            continue;
        }
        if (*cur == '/') {
            ctxt->input->cur = cur + 1;
            if ((*ctxt->input->cur == '>') || (*ctxt->input->cur == 0)) {
                xmlFatalErr(ctxt, XML_ERR_UNEXPECTED_CHAR, NULL);
                xmlFree(start);
                xmlFreeNode(ctxt->node);
                xmlFree(name);
                ctxt->node = NULL;
                return(-1);
            }
            break;
        }
        if (*cur == '>') {
            ctxt->input->cur = cur + 1;
            break;
        }
        if (*cur == ' ') {
            ctxt->input->cur = cur + 1;
            break;
        }
        if (*cur == '\"') {
            ctxt->input->cur = cur + 1;
            value = xmlParseAttValue(ctxt, cur);
            if (value == NULL) {
                xmlFatalErr(ctxt, XML_ERR_UNEXPECTED_CHAR, NULL);
                xmlFree(start);
                xmlFreeNode(ctxt->node);
                xmlFree(name);
                ctxt->node = NULL;
                return(-1);
            }
            xmlAddChild(ctxt->node, xmlNewText(value));
            continue;
        }
        if (*cur == '\'') {
            ctxt->input->cur = cur + 1;
            value = xmlParseAttValue(ctxt, cur);
            if (value == NULL) {
                xmlFatalErr(ctxt, XML_ERR_UNEXPECTED_CHAR, NULL);
                xmlFree(start);
                xmlFreeNode(ctxt->node);
                xmlFree(name);
                ctxt->node = NULL;
                return(-1);
            }
            xmlAddChild(ctxt->node, xmlNewText(value));
            continue;
        }
        if (*cur == '=') {
            ctxt->input->cur = cur + 1;
            continue;
        }
        if (*cur == '?') {
            ctxt->input->cur = cur + 1;