nodePop:
 * @ctxt: an XML parser context
 *
 * Pops the top element node from the node stack
 *
 * Returns the node just removed
 */
xmlNodePtr
nodePop(xmlParserCtxtPtr ctxt)
{
    xmlNodePtr ret;

    if (ctxt == NULL)
        return(NULL);
    if (ctxt->nodeNr <= 0)
        return (NULL);
    ctxt->nodeNr--;
    if (ctxt->nodeNr > 0)
        ctxt->node = ctxt->nodeTab[ctxt->nodeNr - 1];
    else
        ctxt->node = NULL;
    ret = ctxt->nodeTab[ctxt->nodeNr];
    ctxt->nodeTab[ctxt->nodeNr] = NULL;
    return (ret);
}

/**
 * xmlParseStringEntityRef:
 * @ctxt:  an XML parser context
 * @str:  the string to parse
 *
 * Parse a string entity reference.
 *
 * Returns the entity or NULL in case of error
 */
static xmlEntityPtr
xmlParseStringEntityRef(xmlParserCtxtPtr ctxt, const xmlChar **str)
{
    xmlEntityPtr ret;
    const xmlChar *cur;
    int len;

    if (ctxt == NULL) return(NULL);
    cur = *str;
    if ((cur == NULL) || (*cur == 0))
        return(NULL);

    if ((cur[0] == '&') && (cur[1] == '#')) {
        int base;
        int value;
        int c;

        cur += 2;
        if ((cur[0] == 'x') || (cur[0] == 'X')) {
            base = 16;
            cur++;
        } else {
            base = 10;
        }
        value = 0;
        while ((c = cur[0]) != 0) {
            if ((c >= '0') && (c <= '9')) {
                value = value * base + (c - '0');
            } else if ((c >= 'a') && (c <= 'f')) {
                value = value * base + (c - 'a' + 10);
            } else if ((c >= 'A') && (c <= 'F')) {
                value = value * base + (c - 'A' + 10);
            } else {
                break;
            }
            cur++;
        }
        if (c == 0) {
            *str = cur;
            ret = xmlNewEntity(ctxt->dict, NULL, value, 1);
            if (ret == NULL)
                xmlErrMemory(ctxt, NULL);
            return(ret);
        }
    }
    len = xmlStrlen(cur);
    if (len == 0) {
        *str = cur;
        return(NULL);
    }
    ret = xmlNewEntity(ctxt->dict, NULL, 0, 0);
    if (ret == NULL) {
        xmlErrMemory(ctxt, NULL);
        return(NULL);
    }
    ret->name = xmlStrndup(cur, len);
    if (ret->name == NULL) {
        xmlFreeEntity(ret);
        xmlErrMemory(ctxt, NULL);
        return(NULL);
    }
    *str = cur + len;
    return(ret);
}

/**
 * xmlParseEntityRef:
 * @ctxt:  an XML parser context
 *
 * Parse an entity reference.
 *
 * Returns the entity or NULL in case of error
 */
static xmlEntityPtr
xmlParseEntityRef(xmlParserCtxtPtr ctxt)
{
    xmlEntityPtr ret;
    const xmlChar *cur;

    if (ctxt == NULL) return(NULL);
    cur = ctxt->input->cur;
    if ((cur == NULL) || (*cur == 0))
        return(NULL);

    if ((cur[0] == '&') && (cur[1] == '#')) {
        int base;
        int value;
        int c;

        cur += 2;
        if ((cur[0] == 'x') || (cur[0] == 'X')) {
            base = 16;
            cur++;
        } else {
            base = 10;
        }
        value = 0;
        while ((c = cur[0]) != 0) {
            if ((c >= '0') && (c <= '9')) {
                value = value * base + (c - '0');
            } else if ((c >= 'a') && (c <= 'f')) {
                value = value * base + (c - 'a' + 10);
            } else if ((c >= 'A') && (c <= 'F')) {
                value = value * base + (c - 'A' + 10);
            } else {
                break;
            }
            cur++;
        }
        if (c == 0) {
            ctxt->input->cur = cur;
            ret = xmlNewEntity(ctxt->dict, NULL, value, 1);
            if (ret == NULL)
                xmlErrMemory(ctxt, NULL);
            return(ret);
        }
    }
    if (cur[0] == '&') {
        const xmlChar *end;

        cur++;
        end = xmlStrchr(cur, ';');
        if (end == NULL) {
            ctxt->input->cur = cur - 1;
            return(NULL);
        }
        ret = xmlGetPredefinedEntity(ctxt->dict, cur, end - cur + 1);
        if (ret == NULL) {
            ctxt->input->cur = cur - 1;
            return(NULL);
        }
        ctxt->input->cur = end + 1;
        return(ret);
    }
    return(NULL);
}

/**
 * xmlParseCharData:
 * @ctxt:  an XML parser context
 * @len:  the length of the data
 * @data:  the data to parse
 *
 * Parse a chunk of character data.
 *
 * Returns the number of characters parsed or -1 in case of error
 */
static int
xmlParseCharData(xmlParserCtxtPtr ctxt, int len, const xmlChar *data)
{
    int i;
    xmlChar *cur;
    xmlChar *end;

    if (ctxt == NULL) return(-1);
    if (len <= 0) return(0);
    if (ctxt->instate == XML_PARSER_EOF)
        return(-1);

    if (ctxt->input->end == ctxt->input->cur) {
        if (ctxt->input->next == ctxt->input->end) {
            ctxt->input->cur = ctxt->input->end;
            return(-1);
        }
        xmlParserInputBufferLoad(ctxt->input->buffer, ctxt->input->next);
        ctxt->input->end = ctxt->input->buffer->end;
        ctxt->input->cur = ctxt->input->buffer->cur;
        ctxt->input->next = ctxt->input->buffer->next;
    }

    cur = ctxt->input->cur;
    end = ctxt->input->end;

    for (i = 0;i < len;i++) {
        if (cur >= end) {
            if (ctxt->input->next == ctxt->input->end) {
                ctxt->input->cur = ctxt->input->end;
                return(i);
            }
            xmlParserInputBufferLoad(ctxt->input->buffer, ctxt->input->next);
            ctxt->input->end = ctxt->input->buffer->end;
            ctxt->input->cur = ctxt->input->buffer->cur;
            ctxt->input->next = ctxt->input->buffer->next;
            cur = ctxt->input->cur;
            end = ctxt->input->end;
        }
        if (cur >= end) {
            ctxt->input->cur = ctxt->input->end;
            return(i);
        }
        if (*cur == 0x00) {
            xmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END, NULL);
            ctxt->input->cur = ctxt->input->end;
            return(i);
        }
        cur++;
    }
    ctxt->input->cur = cur;
    return(len);
}

/**
 * xmlParseChunk:
 * @ctxt:  an XML parser context
 * @chunk:  the chunk of data to parse
 * @len:  the length of the chunk
 *
 * Parse a chunk of data.
 *
 * Returns the number of characters parsed or -1 in case of error
 */
static int
xmlParseChunk(xmlParserCtxtPtr ctxt, const char *chunk, int len)
{
    int ret;

    if (ctxt == NULL) return(-1);
    if (chunk == NULL) return(-1);
    if (len <= 0) return(0);

    ret = xmlParseCharData(ctxt, len, (const xmlChar *) chunk);
    if (ret < 0) {
        if (ctxt->input->cur == ctxt->input->end) {
            if (ctxt->input->next == ctxt->input->end) {
                ctxt->input->cur = ctxt->input->end;
                return(-1);
            }
            xmlParserInputBufferLoad(ctxt->input->buffer, ctxt->input->next);
            ctxt->input->end = ctxt->input->buffer->end;
            ctxt->input->cur = ctxt->input->buffer->cur;
            ctxt->input->next = ctxt->input->buffer->next;
        }
        if (ctxt->input->cur == ctxt->input->end) {
            ctxt->input->cur = ctxt->input->end;
            return(-1);
        }
    }
    return(ret);
}

/**
 * xmlParseDocument:
 * @ctxt:  an XML parser context
 *
 * Parse the document.
 *
 * Returns 0 if the document is well formed, -1 in case of error
 */
static int
xmlParseDocument(xmlParserCtxtPtr ctxt)
{
    int ret;

    if (ctxt == NULL) return(-1);
    if (ctxt->input == NULL) return(-1);
    if (ctxt->input->cur == ctxt->input->end) {
        if (ctxt->input->next == ctxt->input->end) {
            ctxt->input->cur = ctxt->input->end;
            return(0);
        }
        xmlParserInputBufferLoad(ctxt->input->buffer, ctxt->input->next);
        ctxt->input->end = ctxt->input->buffer->end;
        ctxt->input->cur = ctxt->input->buffer->cur;
        ctxt->input->next = ctxt->input->buffer->next;
    }
    if (ctxt->input->cur == ctxt->input->end) {
        ctxt->input->cur = ctxt->input->end;
        return(0);
    }
    ret = xmlParseMarkupDecl(ctxt);
    if (ret != 0) {
        ctxt->input->cur = ctxt->input->end;
        return(ret);
    }
    ret = xmlParseDocTypeDecl(ctxt);
    if (ret != 0) {
        ctxt->input->cur = ctxt->input->end;
        return(ret);
    }
    ret = xmlParseElementContent(ctxt);
    if (ret != 0) {
        ctxt->input->cur = ctxt->input->end;
        return(ret);
    }
    ret = xmlParseElement(ctxt);
    if (ret != 0) {
        ctxt->input->cur = ctxt->input->end;
        return(ret);
    }
    if (ctxt->input->cur != ctxt->input->end) {
        xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);
        ctxt->input->cur = ctxt->input->end;
        return(-1);
    }
    ctxt->input->cur = ctxt->input->end;
    return(0);
}

/**
 * xmlParseElement:
 * @ctxt:  an XML parser context
 *
 * Parse an element.
 *
 * Returns 0 if the element is well formed, -1 in case of error
 */
static int
xmlParseElement(xmlParserCtxtPtr ctxt)
{
    int ret;

    if (ctxt == NULL) return(-1);
    if (ctxt->input == NULL) return(-1);
    if (ctxt->input->cur == ctxt->input->end) {
        if (ctxt->input->next == ctxt->input->end) {
            ctxt->input->cur = ctxt->input->