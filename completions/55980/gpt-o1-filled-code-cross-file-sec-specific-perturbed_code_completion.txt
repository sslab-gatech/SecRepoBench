encoding_error: {
    /* Collect a small snippet of problematic bytes (up to 16) safely. */
    char errorSnippet[17];
    int i = 0;
    int available = (int)(ctxt->input->end - ctxt->input->cur);
    int maxLen = (available < 16) ? available : 16;

    for (i = 0; i < maxLen; i++) {
        /* Stop if encountering a null terminator (very unlikely in raw input). */
        if (ctxt->input->cur[i] == '\0')
            break;
        /* Use a placeholder if the byte is non-printable in ASCII. */
        errorSnippet[i] = (isprint((unsigned char)ctxt->input->cur[i])) ?
                          ctxt->input->cur[i] : '?';
    }
    errorSnippet[i] = '\0';

    /* Build an error message that indicates where the invalid bytes start. */
    {
        char errorMsg[128];
        snprintf(errorMsg, sizeof(errorMsg),
                 "Invalid or unsupported encoding near byte offset %ld, found bytes: \"%s\"",
                 (long)(ctxt->input->cur - ctxt->input->base),
                 errorSnippet);

        /* Report an encoding error and halt parsing. */
        xmlFatalErrMsg(ctxt, XML_ERR_INVALID_ENCODING, errorMsg);
        xmlHaltParser(ctxt);
    }
}
goto done;