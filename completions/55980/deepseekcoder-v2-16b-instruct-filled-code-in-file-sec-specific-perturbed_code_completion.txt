ctxt->nodeNr++);
}
/**
 * nodePop:
 * @ctxt: an XML parser context
 *
 * Pops the top element node from the node stack
 *
 * Returns the node just removed
 */
xmlNodePtr
nodePop(xmlParserCtxtPtr ctxt)
{
    xmlNodePtr ret;

    if (ctxt == NULL)
        return(NULL);
    if (ctxt->nodeNr <= 0)
        return (NULL);
    ctxt->nodeNr--;
    if (ctxt->nodeNr > 0)
        ctxt->node = ctxt->nodeTab[ctxt->nodeNr - 1];
    else
        ctxt->node = NULL;
    ret = ctxt->nodeTab[ctxt->nodeNr];
    ctxt->nodeTab[ctxt->nodeNr] = NULL;
    return (ret);
}

/**
 * xmlParseStringEntityRef:
 * @ctxt:  the parser context
 * @str:  the string to parse
 *
 * Parse a string entity reference.
 *
 * Returns the entity or NULL in case of error
 */
static xmlEntityPtr
xmlParseStringEntityRef(xmlParserCtxtPtr ctxt, const xmlChar **str)
{
    xmlEntityPtr ret;
    xmlChar *tmp;
    int len;

    if ((ctxt == NULL) || (str == NULL) || (*str == NULL))
        return(NULL);

    len = xmlStrlen(*str);
    if (len == 0)
        return(NULL);

    tmp = xmlStrndup(*str, len);
    if (tmp == NULL) {
        xmlErrMemory(ctxt, NULL);
        return(NULL);
    }
    ret = xmlCreateEntity(ctxt->dict, tmp, len, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    if (ret == NULL) {
        xmlFree(tmp);
        return(NULL);
    }
    ret->etype = XML_INTERNAL_PREDEFINED_ENTITY;
    ret->content = tmp;
    ret->length = len;
    *str += len;
    return(ret);
}

/**
 * xmlParseEntityRef:
 * @ctxt:  the parser context
 *
 * Parse an entity reference.
 *
 * Returns the entity or NULL in case of error
 */
static xmlEntityPtr
xmlParseEntityRef(xmlParserCtxtPtr ctxt)
{
    xmlEntityPtr ret;
    const xmlChar *cur;
    int len;

    if (ctxt == NULL)
        return(NULL);

    cur = ctxt->input->cur;
    if ((cur == NULL) || (*cur == 0))
        return(NULL);

    if (*cur == '&') {
        cur++;
        if ((cur[0] == '#') && (cur[1] == 'x')) {
            cur += 2;
            ret = xmlParseCharRef(ctxt, &cur);
            if (ret != NULL) {
                if ((ret->type == XML_INTERNAL_PREDEFINED_ENTITY) &&
                    (ret->content != NULL)) {
                    xmlFree((xmlChar *) ret->content);
                    ret->content = NULL;
                }
                return(ret);
            }
        } else if ((cur[0] == '#')) {
            cur++;
            ret = xmlParseCharRef(ctxt, &cur);
            if (ret != NULL) {
                if ((ret->type == XML_INTERNAL_PREDEFINED_ENTITY) &&
                    (ret->content != NULL)) {
                    xmlFree((xmlChar *) ret->content);
                    ret->content = NULL;
                }
                return(ret);
            }
        } else {
            ret = xmlParseStringEntityRef(ctxt, &cur);
            if (ret != NULL) {
                if ((ret->type == XML_INTERNAL_PREDEFINED_ENTITY) &&
                    (ret->content != NULL)) {
                    xmlFree((xmlChar *) ret->content);
                    ret->content = NULL;
                }
                return(ret);
            }
        }
    }
    return(NULL);
}

/**
 * xmlParseCharRef:
 * @ctxt:  the parser context
 * @cur:  the current position in the buffer
 *
 * Parse a character reference.
 *
 * Returns the entity or NULL in case of error
 */
static xmlEntityPtr
xmlParseCharRef(xmlParserCtxtPtr ctxt, const xmlChar **cur)
{
    xmlEntityPtr ret;
    int value;
    const xmlChar *start;

    start = *cur;
    if ((*cur == NULL) || (**cur == 0))
        return(NULL);

    if (!isdigit(**cur))
        return(NULL);
    value = 0;
    while (isdigit(**cur)) {
        value = value * 10 + (**cur - '0');
        (*cur)++;
    }
    if ((**cur == ';') || (**cur == 0)) {
        ret = xmlNewEntity(ctxt->dict, NULL, value, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        if (ret == NULL) {
            *cur = start;
            return(NULL);
        }
        ret->etype = XML_INTERNAL_PREDEFINED_ENTITY;
        return(ret);
    }
    if ((**cur == ' ') || (**cur == '\n') || (**cur == '\r') ||
        (**cur == '\t')) {
        *cur = start;
        return(NULL);
    }
    return(NULL);
}

/**
 * xmlParseElementStart:
 * @ctxt:  the parser context
 *
 * Parse an element start tag.
 *
 * Returns 0 in case of success and -1 in case of error
 */
static int
xmlParseElementStart(xmlParserCtxtPtr ctxt)
{
    xmlStartTag tag;
    int ret;
    int i;
    xmlChar *name;
    xmlChar *prefix = NULL;
    xmlChar *URI = NULL;
    xmlChar *value;
    xmlChar *cur;
    xmlChar *end;
    xmlChar *att_name;
    xmlChar *att_value;
    xmlChar *att_prefix = NULL;
    xmlChar *att_URI = NULL;
    xmlChar *att_cur;
    xmlChar *att_end;
    xmlChar *att_name_end;
    xmlChar *att_value_start;
    xmlChar *att_value_end;
    xmlChar *att_quote = NULL;
    int att_len;
    int att_name_len;
    int att_value_len;
    int att_count = 0;
    int att_alloc = 0;
    int att_max = 0;
    int att_index = 0;
    int att_start = 0;
    int att_end_index = 0;
    int att_end_start = 0;
    int att_end_len = 0;
    int att_end_alloc = 0;
    int att_end_max = 0;
    int att_end_count = 0;
    int att_end_index_max = 0;
    int att_end_index_count = 0;
    int att_end_index_alloc = 0;
    int att_end_index_max_alloc = 0;
    int att_end_index_start = 0;
    int att_end_index_len = 0;
    int att_end_index_count_max = 0;
    int att_end_index_count_alloc = 0;
    int att_end_index_count_max_alloc = 0;
    int att_end_index_count_start = 0;
    int att_end_index_count_len = 0;
    int att_end_index_count_max_len = 0;
    int att_end_index_count_alloc_max = 0;
    int att_end_index_count_start_max = 0;
    int att_end_index_count_len_max = 0;
    int att_end_index_count_max_len_max = 0;
    int att_end_index_count_alloc_max_len = 0;
    int att_end_index_count_start_max_len = 0;
    int att_end_index_count_len_max_len = 0;
    int att_end_index_count_max_len_max_len = 0;
    int att_end_index_count_alloc_max_len_max = 0;
    int att_end_index_count_start_max_len_max = 0;
    int att_end_index_count_len_max_len_max = 0;
    int att_end_index_count_max_len_max_len = 0;
    int att_end_index_count_alloc_max_len_max_len = 0;
    int att_end_index_count_start_max_len_max_len = 0;
    int att_end_index_count_len_max_len_max_len = 0;
    int att_end_index_count_max_len_max_len_max = 0;
    int att_end_index_count_alloc_max_len_max_len_max = 0;
    int att_end_index_count_start_max_len_max_len_max = 0;
    int att_end_index_count_len_max_len_max_len_max = 0;
    int att_end_index_count_max_len_max_len_max_len = 0;
    int att_end_index_count_alloc_max_len_max_len_max_len = 0;
    int att_end_index_count_start_max_len_max_len_max_len = 0;
    int att_end_index_count_len_max_len_max_len_max_len = 0;
    int att_end_index_count_max_len_max_len_max_len_max = 0;
    int att_end_index_count_alloc_max_len_max_len_max_len_max = 0;
    int att_end_index_count_start_max_len_max_len_max_len_max = 0;
    int att_end_index_count_len_max_len_max_len_max_len_max = 0;
    int att_end_index_count_max_len_max_len_max_len_max_len = 0;
    int att_end_index_count_alloc_max_len_max_len_max_len_max_len = 0;
    int att_end_index_count_start_max_len_max_len_max_len_max_len = 0;
    int att_end_index_count_len_max_len_max_len_max_len_max = 0;
    int att_end_index_count_max_len_max_len_max_len_max_len = 0;
    int att_end_index_count_alloc_max_len_max_len_max_len_max_len = 0;
    int att_end_index_count_start_max_len_max_len_max_len_max_len = 0;
    int att_end_index_count_len_max_len_max_len_max_len_max = 0;
    int att_end_index_count_max_len_max_len_max_len_max_len = 0;
    int att_end_index_count_alloc_max_len_max_len_max_len_max_len = 0;
    int att_end_index_count_start_max_len_max_len_max_len_max_len = 0;
    int att_end_index_count_len_max_len_max_len_max_len_max = 0;
    int att_end_index_count_max_len_max_len_max_len_max_len = 0;
    int att_end_index_count_alloc_max_len_max_len_max_len_max_len = 0;
    int att_end_index_count_start_max_len_max_len_max_len_max_len = 0;
    int att_end_index_count_len_max_len_max_len_max_len_max = 0;
    int att_end_index_count_max_len_max_len_max_len_max_len = 0;