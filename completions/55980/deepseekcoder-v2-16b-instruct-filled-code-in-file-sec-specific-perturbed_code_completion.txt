);
    }
    ctxt->nodeTab[ctxt->nodeNr++] = value;
    return (ctxt->nodeNr - 1);
}
/**
 * nodePop:
 * @ctxt: an XML parser context
 *
 * Pops the top element node from the node stack
 *
 * Returns the node just removed
 */
xmlNodePtr
nodePop(xmlParserCtxtPtr ctxt)
{
    xmlNodePtr ret;

    if (ctxt == NULL)
        return(NULL);
    if (ctxt->nodeNr <= 0)
        return (NULL);
    ctxt->nodeNr--;
    ret = ctxt->nodeTab[ctxt->nodeNr];
    ctxt->nodeTab[ctxt->nodeNr] = NULL;
    return (ret);
}

/**
 * xmlParseStringEntityRef:
 * @ctxt:  the parser context
 * @str:  the string to parse
 *
 * Parse a string entity reference.
 *
 * Returns the entity or NULL in case of error
 */
static xmlEntityPtr
xmlParseStringEntityRef(xmlParserCtxtPtr ctxt, const xmlChar **str)
{
    xmlEntityPtr ret;
    const xmlChar *cur;
    int len;

    if (ctxt == NULL) return(NULL);
    cur = *str;
    if ((cur == NULL) || (*cur == 0))
        return(NULL);

    if ((cur[0] == '&') && (cur[1] == '#')) {
        int base;
        int value;
        int c;

        cur += 2;
        if ((cur[0] == 'x') || (cur[0] == 'X')) {
            base = 16;
            cur++;
        } else {
            base = 10;
        }
        value = 0;
        while ((c = cur[0]) != 0) {
            if ((c >= '0') && (c <= '9')) {
                value = value * base + (c - '0');
            } else if ((c >= 'a') && (c <= 'f')) {
                value = value * base + (c - 'a' + 10);
            } else if ((c >= 'A') && (c <= 'F')) {
                value = value * base + (c - 'A' + 10);
            } else {
                break;
            }
            cur++;
        }
        if (c == 0) {
            *str = cur;
            ret = xmlNewEntity(NULL, NULL, value, 0, 0, 0, 0, 0, 0, 0);
            if (ret == NULL)
                xmlErrMemory(ctxt, NULL);
            return(ret);
        }
    }
    len = xmlStrlen(cur);
    if (len == 0) {
        *str = cur;
        return(NULL);
    }
    ret = xmlNewEntity(NULL, NULL, 0, cur, len, 0, 0, 0, 0, 0);
    if (ret == NULL)
        xmlErrMemory(ctxt, NULL);
    *str = cur + len;
    return(ret);
}

/**
 * xmlParseEntityRef:
 * @ctxt:  the parser context
 * @str:  the string to parse
 *
 * Parse an entity reference.
 *
 * Returns the entity or NULL in case of error
 */
static xmlEntityPtr
xmlParseEntityRef(xmlParserCtxtPtr ctxt, const xmlChar **str)
{
    xmlEntityPtr ret;
    const xmlChar *cur;
    int len;

    if (ctxt == NULL) return(NULL);
    cur = *str;
    if ((cur == NULL) || (*cur == 0))
        return(NULL);

    if ((cur[0] == '&') && (cur[1] == '#')) {
        int base;
        int value;
        int c;

        cur += 2;
        if ((cur[0] == 'x') || (cur[0] == 'X')) {
            base = 16;
            cur++;
        } else {
            base = 10;
        }
        value = 0;
        while ((c = cur[0]) != 0) {
            if ((c >= '0') && (c <= '9')) {
                value = value * base + (c - '0');
            } else if ((c >= 'a') && (c <= 'f')) {
                value = value * base + (c - 'a' + 10);
            } else if ((c >= 'A') && (c <= 'F')) {
                value = value * base + (c - 'A' + 10);
            } else {
                break;
            }
            cur++;
        }
        if (c == 0) {
            *str = cur;
            ret = xmlNewEntity(NULL, NULL, value, 0, 0, 0, 0, 0, 0, 0);
            if (ret == NULL)
                xmlErrMemory(ctxt, NULL);
            return(ret);
        }
    }
    len = xmlStrlen(cur);
    if (len == 0) {
        *str = cur;
        return(NULL);
    }
    ret = xmlNewEntity(NULL, NULL, 0, cur, len, 0, 0, 0, 0, 0);
    if (ret == NULL)
        xmlErrMemory(ctxt, NULL);
    *str = cur + len;
    return(ret);
}

/**
 * xmlParseCharData:
 * @ctxt:  the parser context
 * @str:  the string to parse
 *
 * Parse a character data.
 *
 * Returns the character data or NULL in case of error
 */
static xmlChar *
xmlParseCharData(xmlParserCtxtPtr ctxt, const xmlChar **str)
{
    xmlChar *ret;
    const xmlChar *cur;
    int len;

    if (ctxt == NULL) return(NULL);
    cur = *str;
    if ((cur == NULL) || (*cur == 0))
        return(NULL);

    len = xmlStrlen(cur);
    if (len == 0) {
        *str = cur;
        return(NULL);
    }
    ret = xmlStrndup(cur, len);
    if (ret == NULL)
        xmlErrMemory(ctxt, NULL);
    *str = cur + len;
    return(ret);
}

/**
 * xmlParseElementContent:
 * @ctxt:  the parser context
 * @str:  the string to parse
 *
 * Parse an element content.
 *
 * Returns the element content or NULL in case of error
 */
static xmlChar *
xmlParseElementContent(xmlParserCtxtPtr ctxt, const xmlChar **str)
{
    xmlChar *ret;
    const xmlChar *cur;
    int len;

    if (ctxt == NULL) return(NULL);
    cur = *str;
    if ((cur == NULL) || (*cur == 0))
        return(NULL);

    len = xmlStrlen(cur);
    if (len == 0) {
        *str = cur;
        return(NULL);
    }
    ret = xmlStrndup(cur, len);
    if (ret == NULL)
        xmlErrMemory(ctxt, NULL);
    *str = cur + len;
    return(ret);
}

/**
 * xmlParseElementDecl:
 * @ctxt:  the parser context
 * @str:  the string to parse
 *
 * Parse an element declaration.
 *
 * Returns the element declaration or NULL in case of error
 */
static xmlChar *
xmlParseElementDecl(xmlParserCtxtPtr ctxt, const xmlChar **str)
{
    xmlChar *ret;
    const xmlChar *cur;
    int len;

    if (ctxt == NULL) return(NULL);
    cur = *str;
    if ((cur == NULL) || (*cur == 0))
        return(NULL);

    len = xmlStrlen(cur);
    if (len == 0) {
        *str = cur;
        return(NULL);
    }
    ret = xmlStrndup(cur, len);
    if (ret == NULL)
        xmlErrMemory(ctxt, NULL);
    *str = cur + len;
    return(ret);
}

/**
 * xmlParseAttValue:
 * @ctxt:  the parser context
 * @str:  the string to parse
 *
 * Parse an attribute value.
 *
 * Returns the attribute value or NULL in case of error
 */
static xmlChar *
xmlParseAttValue(xmlParserCtxtPtr ctxt, const xmlChar **str)
{
    xmlChar *ret;
    const xmlChar *cur;
    int len;

    if (ctxt == NULL) return(NULL);
    cur = *str;
    if ((cur == NULL) || (*cur == 0))
        return(NULL);

    len = xmlStrlen(cur);
    if (len == 0) {
        *str = cur;
        return(NULL);
    }
    ret = xmlStrndup(cur, len);
    if (ret == NULL)
        xmlErrMemory(ctxt, NULL);
    *str = cur + len;
    return(ret);
}

/**
 * xmlParseCharRef:
 * @ctxt:  the parser context
 * @str:  the string to parse
 *
 * Parse a character reference.
 *
 * Returns the character or -1 in case of error
 */
static int
xmlParseCharRef(xmlParserCtxtPtr ctxt, const xmlChar **str)
{
    const xmlChar *cur;
    int base;
    int value;
    int c;

    if (ctxt == NULL) return(-1);
    cur = *str;
    if ((cur == NULL) || (*cur == 0))
        return(-1);

    if ((cur[0] == '&#') && ((cur[1] == 'x') || (cur[1] == 'X'))) {
        base = 16;
        cur += 2;
    } else {
        base = 10;
        cur += 1;
    }
    value = 0;
    while ((c = cur[0]) != 0) {
        if ((c >= '0') && (c <= '9')) {
            value = value * base + (c - '0');
        } else if ((c >= 'a') && (c <= 'f')) {
            value = value * base + (c - 'a' + 10);
        } else if ((c >= 'A') && (c <= 'F')) {
            value = value * base + (c - 'A' + 10);
        } else {
            break;
        }
        cur++;
    }
    if (c == 0) {
        *str = cur;
        return(-1);
    }
    *str = cur;
    return(value);
}

/**
 * xmlParseEntityRefInternal:
 * @ctxt:  the parser context
 * @str:  the string to parse
 *
 * Parse an internal entity reference.
 *
 * Returns the entity or NULL in case of error
 */
static xmlEntityPtr
xmlParseEntityRefInternal(xmlParserCtxtPtr ctxt, const xmlChar **str)
{
    xmlEntityPtr ret;
    const xmlChar *cur;
    int len;

    if (ctxt == NULL) return(NULL);
    cur = *str;
    if ((cur == NULL) || (*cur == 0))
        return(NULL);

    len = xmlStrlen(cur);
    if (len == 0) {
        *str = cur;
        return(NULL);
    }
    ret = xmlNewEntity(NULL, NULL, 0, cur, len, 0, 0, 0, 0, 0);
    if (ret == NULL)
        xmlErrMemory(ctxt, NULL);
    *str = cur + len;
    return(ret);
}

/**
 * xmlParseEntityRef:
 * @ctxt:  the parser context
 * @str:  the string to parse
 *
 * Parse an entity reference.
 *
 * Returns the entity or NULL in case of error
 */
static xmlEntityPtr
xmlParseEntityRef(xmlParserCtxtPtr ctxt, const xmlChar **str)
{
    xmlEntityPtr ret;
    const xmlChar *cur;
    int len;

    if (ctxt == NULL) return(NULL);
    cur = *str;
    if ((cur == NULL) || (*cur == 0))
        return(NULL);

    len = xmlStrlen(cur);
    if (len == 0) {
        *str = cur;
        return(NULL);
    }
    ret = xml