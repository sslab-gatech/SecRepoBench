case ReadStripMethod:
      {
        tstrip_t number_strips = TIFFNumberOfStrips(tiff);
        tsize_t strip_size;
        ssize_t row_offset = 0;
        for (tstrip_t strip = 0; strip < number_strips; strip++)
        {
          strip_size = TIFFStripSize(tiff);
          if (TIFFReadEncodedStrip(tiff, strip, pixels, strip_size) < 0)
            {
              status=MagickFalse;
              break;
            }
          /* Import the strip's data into the image. */
          {
            ssize_t rows_to_read = (ssize_t) rows_per_strip;
            if ((row_offset + rows_per_strip) > (ssize_t) image->rows)
              rows_to_read = (ssize_t) (image->rows - row_offset);
            for (y=0; y < rows_to_read; y++)
            {
              Quantum *q=QueueAuthenticPixels(image,0,row_offset+y,
                image->columns,1,exception);
              if (q == (Quantum *) NULL)
                {
                  status=MagickFalse;
                  break;
                }
              (void) ImportQuantumPixels(image,(CacheView *) NULL,
                quantum_info,quantum_type,pixels + (y*scanline_size),exception);
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                {
                  status=MagickFalse;
                  break;
                }
              if (image->previous == (Image *) NULL)
                {
                  MagickBooleanType proceed=SetImageProgress(image,
                    LoadImageTag,(MagickOffsetType) (row_offset + y),
                    image->rows);
                  if (proceed == MagickFalse)
                    {
                      status=MagickFalse;
                      break;
                    }
                }
              if (status == MagickFalse)
                break;
            }
            row_offset+=rows_to_read;
            if (status == MagickFalse)
              break;
          }
        }
        break;
      }
      case ReadTileMethod:
      {
        uint32 tile_width = TIFFTileWidth(tiff);
        uint32 tile_height = TIFFTileLength(tiff);
        uint32 row, col;
        for (row=0; row < (uint32) image->rows; row += tile_height)
        {
          for (col=0; col < (uint32) image->columns; col += tile_width)
          {
            if (TIFFReadTile(tiff,pixels,col,row,0,0) == -1)
              {
                status=MagickFalse;
                break;
              }
            /* Import the tile's data into the image. */
            {
              uint32 i, j;
              uint32 actual_tile_width = (col + tile_width) > image->columns ?
                (uint32) (image->columns - col) : tile_width;
              uint32 actual_tile_height = (row + tile_height) > image->rows ?
                (uint32) (image->rows - row) : tile_height;
              for (j=0; j < actual_tile_height; j++)
              {
                ssize_t y_offset = (ssize_t) (row + j);
                Quantum *q=QueueAuthenticPixels(image,(ssize_t) col,
                  y_offset,actual_tile_width,1,exception);
                if (q == (Quantum *) NULL)
                  {
                    status=MagickFalse;
                    break;
                  }
                (void) ImportQuantumPixels(image,(CacheView *) NULL,
                  quantum_info,quantum_type,pixels + (j*scanline_size),
                  exception);
                if (SyncAuthenticPixels(image,exception) == MagickFalse)
                  {
                    status=MagickFalse;
                    break;
                  }
                if ((image->previous == (Image *) NULL) &&
                    (SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                    y_offset,image->rows) == MagickFalse))
                  {
                    status=MagickFalse;
                    break;
                  }
                if (status == MagickFalse)
                  break;
              }
            }
            if (status == MagickFalse)
              break;
          }
          if (status == MagickFalse)
            break;
        }
        break;
      }
      case ReadGenericMethod:
      default:
      {
        /*
          Use TIFFReadRGBAImage to read the entire image as RGBA, then
          translate into the desired quantum type.
        */
        if (TIFFReadRGBAImage(tiff,(uint32) image->columns,
            (uint32) image->rows,(uint32 *) pixels,0) == 0)
          {
            TIFFClose(tiff);
            ThrowReaderException(CorruptImageError,"UnableToReadImageData");
          }
        /* Convert the RGBA pixels into the Quantum format. */
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          Quantum *q = QueueAuthenticPixels(image,0,(ssize_t) y,
            image->columns,1,exception);
          if (q == (Quantum *) NULL)
            {
              status=MagickFalse;
              break;
            }
          (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
            RGBAQuantum,pixels + (image->rows-1-y)*(scanline_size),exception);
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            {
              status=MagickFalse;
              break;
            }
          if (image->previous == (Image *) NULL)
            {
              MagickBooleanType proceed=SetImageProgress(image,LoadImageTag,
                (MagickOffsetType) y,image->rows);
              if (proceed == MagickFalse)
                {
                  status=MagickFalse;
                  break;
                }
            }
        }
        break;
      }