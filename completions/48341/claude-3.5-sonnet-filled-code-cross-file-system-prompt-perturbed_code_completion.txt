case ReadStripMethod:
{
  size_t
    number_pixels,
    strip_size;

  ssize_t
    count,
    strip;

  unsigned char
    *strip_pixels;

  number_pixels=image->columns*rows_per_strip;
  strip_size=TIFFStripSize(tiff);
  strip_pixels=(unsigned char *) AcquireQuantumMemory(strip_size,
    sizeof(*strip_pixels));
  if (strip_pixels == (unsigned char *) NULL)
    ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
  for (y=0; y < (ssize_t) image->rows; y+=rows_per_strip)
  {
    strip=TIFFComputeStrip(tiff,y,0);
    count=TIFFReadEncodedStrip(tiff,strip,strip_pixels,strip_size);
    if (count <= 0)
      break;
    for (i=0; i < (ssize_t) count; i+=samples_per_pixel)
    {
      ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,quantum_type,
        strip_pixels+i,exception);
      if (SyncAuthenticPixels(image,exception) == MagickFalse)
        break;
    }
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  strip_pixels=(unsigned char *) RelinquishMagickMemory(strip_pixels);
  break;
}
case ReadTileMethod:
{
  size_t
    number_pixels,
    tile_size;

  ssize_t
    count;

  uint32
    tile_columns,
    tile_rows;

  unsigned char
    *tile_pixels;

  if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&tile_columns) != 1) ||
      (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&tile_rows) != 1))
    ThrowReaderException(CoderError,"ImageIsNotTiled");
  number_pixels=tile_columns*tile_rows;
  tile_size=TIFFTileSize(tiff);
  tile_pixels=(unsigned char *) AcquireQuantumMemory(tile_size,
    sizeof(*tile_pixels));
  if (tile_pixels == (unsigned char *) NULL)
    ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
  for (y=0; y < (ssize_t) image->rows; y+=tile_rows)
  {
    for (x=0; x < (ssize_t) image->columns; x+=tile_columns)
    {
      count=TIFFReadTile(tiff,tile_pixels,x,y,0,0);
      if (count <= 0)
        break;
      for (i=0; i < (ssize_t) count; i+=samples_per_pixel)
      {
        ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,quantum_type,
          tile_pixels+i,exception);
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
      }
    }
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  tile_pixels=(unsigned char *) RelinquishMagickMemory(tile_pixels);
  break;
}
case ReadGenericMethod:
default:
{
  uint32
    *pixels;

  pixels=(uint32 *) AcquireQuantumMemory(image->columns,
    image->rows*sizeof(*pixels));
  if (pixels == (uint32 *) NULL)
    ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
  (void) TIFFReadRGBAImage(tiff,(uint32) image->columns,
    (uint32) image->rows,pixels,0);
  /*
    Convert image to DirectClass pixel packets.
  */
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    Quantum
      *magick_restrict q;

    ssize_t
      x;

    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
    if (q == (Quantum *) NULL)
      break;
    for (x=0; x < (ssize_t) image->columns; x++)
    {
      SetPixelRed(image,ScaleCharToQuantum(TIFFGetR(pixels[y*
        image->columns+x])),q);
      SetPixelGreen(image,ScaleCharToQuantum(TIFFGetG(pixels[y*
        image->columns+x])),q);
      SetPixelBlue(image,ScaleCharToQuantum(TIFFGetB(pixels[y*
        image->columns+x])),q);
      SetPixelAlpha(image,ScaleCharToQuantum(TIFFGetA(pixels[y*
        image->columns+x])),q);
      q+=GetPixelChannels(image);
    }
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  pixels=(uint32 *) RelinquishMagickMemory(pixels);
  break;
}