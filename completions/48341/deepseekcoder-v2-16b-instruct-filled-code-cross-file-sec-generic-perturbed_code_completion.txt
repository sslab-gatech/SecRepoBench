// Handle the reading of TIFF image data based on the specified method.
    // For ReadStripMethod, read the image data by processing each strip of the TIFF file.
    // Allocate memory to store strip data and iterate through each sample per pixel.
    // Import the quantum pixels for each strip, updating the image's authentic pixels accordingly.
    // For ReadTileMethod, read the image data by processing each tile of the TIFF file.
    // Allocate memory to store tile data and iterate through each sample per pixel.
    // Import the quantum pixels for each tile, ensuring the image's authentic pixels are updated.
    // For ReadGenericMethod and default cases, read the image data using the TIFFReadRGBAImage function.
    // This method processes the entire image at once, assigning the pixel values to the image's authentic pixels.
    // For all methods, manage memory allocation and deallocation for the pixel data, ensuring efficient resource usage.
    // Ensure progress is tracked and updated, allowing for cancellation if needed.
    pixels=(unsigned char *) GetQuantumPixels(quantum_info);
    tiff_info.scanline=(unsigned char *) GetQuantumPixels(quantum_info);
    switch (photometric)
    {
      case PHOTOMETRIC_CIELAB:
      case PHOTOMETRIC_YCBCR:
      case PHOTOMETRIC_RGB:
      {
        /*
          RGB TIFF image.
        */
        switch (image_info->interlace)
        {
          case NoInterlace:
          default:
          {
            quantum_type=RGBQuantum;
            if (image->alpha_trait != UndefinedPixelTrait)
              quantum_type=RGBAQuantum;
            if (image->number_meta_channels != 0)
              {
                quantum_type=MultispectralQuantum;
                (void) SetQuantumPad(image,quantum_info,0);
              }
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              const Quantum
                *magick_restrict q;

              ssize_t
                x;

              unsigned char
                *p;

              tiff_status=TIFFReadPixels(tiff,0,y,(char *) pixels);
              if (tiff_status == -1)
                break;
              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
              if (q == (Quantum *) NULL)
                break;
              p=pixels;
              for (x=0; x < (ssize_t) image->columns; x++)
              {
                SetPixelRed(image,ScaleCharToQuantum(ClampRGB((double) *p)),q);
                SetPixelGreen(image,ScaleCharToQuantum(ClampRGB((double) *(p+1))),q);
                SetPixelBlue(image,ScaleCharToQuantum(ClampRGB((double) *(p+2))),q);
                if (image->alpha_trait != UndefinedPixelTrait)
                  SetPixelAlpha(image,ScaleCharToQuantum((unsigned char) *(p+3)),q);
                q+=GetPixelChannels(image);
                p+=4;
              }
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
              if (image->previous == (Image *) NULL)
                {
                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                    image->rows);
                  if (status == MagickFalse)
                    break;
                }
            }
            break;
          }
          case PlaneInterlace:
          case PartitionInterlace:
          {
            /*
              Plane interlacing:  RRRRRR...GGGGGG...BBBBBB...
            */
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              const Quantum
                *magick_restrict q;

              ssize_t
                x;

              unsigned char
                *p;

              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
              if (q == (Quantum *) NULL)
                break;
              p=pixels;
              for (x=0; x < (ssize_t) image->columns; x++)
              {
                SetPixelRed(image,ScaleCharToQuantum(ClampRGB((double) *p)),q);
                SetPixelGreen(image,ScaleCharToQuantum(ClampRGB((double) *(p+1))),q);
                SetPixelBlue(image,ScaleCharToQuantum(ClampRGB((double) *(p+2))),q);
                if (image->alpha_trait != UndefinedPixelTrait)
                  SetPixelAlpha(image,ScaleCharToQuantum((unsigned char) *(p+3)),q);
                q+=GetPixelChannels(image);
                p+=4;
              }
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
            }
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,LoadImageTag,100,400);
                if (status == MagickFalse)
                  break;
              }
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              const Quantum
                *magick_restrict q;

              ssize_t
                x;

              unsigned char
                *p;

              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
              if (q == (Quantum *) NULL)
                break;
              p=pixels;
              for (x=0; x < (ssize_t) image->columns; x++)
              {
                SetPixelGreen(image,ScaleCharToQuantum(ClampRGB((double) *(p+1))),q);
                SetPixelBlue(image,ScaleCharToQuantum(ClampRGB((double) *(p+2))),q);
                if (image->alpha_trait != UndefinedPixelTrait)
                  SetPixelAlpha(image,ScaleCharToQuantum((unsigned char) *(p+3)),q);
                q+=GetPixelChannels(image);
                p+=4;
              }
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
            }
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,LoadImageTag,200,400);
                if (status == MagickFalse)
                  break;
              }
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              const Quantum
                *magick_restrict q;

              ssize_t
                x;

              unsigned char
                *p;

              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
              if (q == (Quantum *) NULL)
                break;
              p=pixels;
              for (x=0; x < (ssize_t) image->columns; x++)
              {
                SetPixelBlue(image,ScaleCharToQuantum(ClampRGB((double) *(p+2))),q);
                if (image->alpha_trait != UndefinedPixelTrait)
                  SetPixelAlpha(image,ScaleCharToQuantum((unsigned char) *(p+3)),q);
                q+=GetPixelChannels(image);
                p+=4;
              }
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
            }
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,LoadImageTag,300,400);
                if (status == MagickFalse)
                  break;
              }
            if (image->alpha_trait != UndefinedPixelTrait)
              for (y=0; y < (ssize_t) image->rows; y++)
              {
                const Quantum
                  *magick_restrict q;

                ssize_t
                  x;

                unsigned char
                  *p;

                q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
                if (q == (Quantum *) NULL)
                  break;
                p=pixels;
                for (x=0; x < (ssize_t) image->columns; x++)
                {
                  SetPixelAlpha(image,ScaleCharToQuantum((unsigned char) *(p+3)),q);
                  q+=GetPixelChannels(image);
                  p+=4;
                }
                if (SyncAuthenticPixels(image,exception) == MagickFalse)
                  break;
              }
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,LoadImageTag,400,400);
                if (status == MagickFalse)
                  break;
              }
            break;
          }
        }
        break;
      }
      case PHOTOMETRIC_SEPARATED:
      {
        /*
          CMYK TIFF image.
        */
        quantum_type=CMYKQuantum;
        if (image->alpha_trait != UndefinedPixelTrait)
          quantum_type=CMYKAQuantum;
        if (image->number_meta_channels != 0)
          {
            quantum_type=MultispectralQuantum;
            (void) SetQuantumPad(image,quantum_info,0);
          }
        if (image->colorspace != CMYKColorspace)
          (void) TransformImageColorspace(image,CMYKColorspace,exception);
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          const Quantum
            *magick_restrict q;

          ssize_t
            x;

          unsigned char
            *p;

          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          p=pixels;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelCyan(image,ScaleCharToQuantum(ClampCMYK((double) *p)),q);
            SetPixelMagenta(image,ScaleCharToQuantum(ClampCMYK((double) *(p+1))),q);
            SetPixelYellow(image,ScaleCharToQuantum(ClampCMYK((double) *(p+2))),q);
            SetPixelBlack(image,ScaleCharToQuantum(ClampCMYK((double) *(p+3))),q);
            if (image->alpha_trait != UndefinedPixelTrait)
              SetPixelAlpha(image,ScaleCharToQuantum((unsigned char) *(p+4)),q);
            q+=GetPixelChannels(image);
            p+=5;
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
        }
        break;
      }
      case PHOTOMETRIC_PALETTE:
      {
        uint16
          *blue,
          *green,
          *red;

        /*
          Colormapped TIFF image.
        */
        red=(uint16 *) AcquireQuantumMemory(65536,sizeof(*red));
        green=(uint16 *) AcquireQuantumMemory(65536,sizeof(*green));
        blue=(uint16 *) AcquireQuantumMemory(65536,sizeof(*blue));
        if ((red == (uint16 *) NULL) || (green == (uint16 *) NULL) ||
            (blue == (uint16 *) NULL))
          {
            if (red != (uint16 *) NULL)
              red=(uint16 *) RelinquishMagickMemory(red);
            if (green != (uint16 *) NULL)
              green=(uint16 *) RelinquishMagickMemory(green);
            if (blue != (uint16 *) NULL)
              blue=(uint16 *) RelinquishMagickMemory(blue);
            ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
          }
        /*
          Initialize TIFF colormap.
        */
        (void) memset(red,0,65536*sizeof(*red));
        (void) memset(green,0,65536*sizeof(*green));
        (void) memset(blue,0,65536*sizeof(*blue));
        for (i=0; i < (ssize_t) image->colors; i++)
        {
          red[i]=ScaleQuantumToShort(image->colormap[i].red);
          green[i]=ScaleQuantumToShort(image->colormap[i].green);
          blue[i]=ScaleQuantumToShort(image->colormap[i].blue);
        }
        (void) TIFFSetField(tiff,TIFFTAG_COLORMAP,red,green,blue);
        red=(uint16 *) RelinquishMagickMemory(red);
        green=(uint16 *) RelinquishMagickMemory(green);
        blue=(uint16 *) RelinquishMagickMemory(blue);
      }
      default:
      {
        /*