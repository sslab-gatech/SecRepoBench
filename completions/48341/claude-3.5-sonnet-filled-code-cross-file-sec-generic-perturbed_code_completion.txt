case ReadStripMethod:
{
  size_t
    strip_size;

  unsigned char
    *strip;

  strip_size=TIFFStripSize(tiff);
  strip=(unsigned char *) AcquireMagickMemory(strip_size);
  if (strip == (unsigned char *) NULL)
    ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
  for (y=0; y < (ssize_t) image->rows; y+=rows_per_strip)
  {
    size_t
      length;

    ssize_t
      count;

    tiff_status=TIFFReadEncodedStrip(tiff,(uint32) TIFFComputeStrip(tiff,y,0),
      strip,(size_t) -1);
    if (tiff_status == -1)
      break;
    count=MagickMin((ssize_t) rows_per_strip,(ssize_t) image->rows-y);
    for (i=0; i < count; i++)
    {
      length=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
        quantum_type,strip+i*TIFFScanlineSize(tiff),exception);
      if (length != TIFFScanlineSize(tiff))
        break;
      status=SetImageExtent(image,image->columns,y+i+1,exception);
      if (status == MagickFalse)
        break;
      status=SyncAuthenticPixels(image,exception);
      if (status == MagickFalse)
        break;
    }
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  strip=(unsigned char *) RelinquishMagickMemory(strip);
  break;
}
case ReadTileMethod:
{
  uint32
    tile_height,
    tile_width;

  unsigned char
    *tile;

  if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&tile_width) != 1) ||
      (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&tile_height) != 1))
    ThrowReaderException(CoderError,"ImageIsNotTiled");
  tile=(unsigned char *) AcquireMagickMemory(TIFFTileSize(tiff));
  if (tile == (unsigned char *) NULL)
    ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
  for (y=0; y < (ssize_t) image->rows; y+=tile_height)
  {
    for (x=0; x < (ssize_t) image->columns; x+=tile_width)
    {
      tiff_status=TIFFReadTile(tiff,tile,(uint32) x,(uint32) y,0,0);
      if (tiff_status == -1)
        break;
      ImportTilePixels(image,quantum_info,quantum_type,tile,tile_width,
        tile_height,x,y,exception);
    }
    if (tiff_status == -1)
      break;
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  tile=(unsigned char *) RelinquishMagickMemory(tile);
  break;
}
case ReadGenericMethod:
default:
{
  uint32
    *pixels;

  pixels=(uint32 *) AcquireQuantumMemory(image->columns,image->rows*
    sizeof(uint32));
  if (pixels == (uint32 *) NULL)
    ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
  (void) TIFFReadRGBAImage(tiff,(uint32) image->columns,
    (uint32) image->rows,pixels,0);
  ImportImagePixels(image,0,0,image->columns,image->rows,
    "RGBO",UnsignedIntegerPixel,pixels,exception);
  pixels=(uint32 *) RelinquishMagickMemory(pixels);
  break;
}