case ReadStripMethod:
{
  size_t
    strip_size;

  unsigned char
    *strip;

  strip_size=TIFFStripSize(tiff);
  strip=(unsigned char *) AcquireQuantumMemory(strip_size,sizeof(*strip));
  if (strip == (unsigned char *) NULL)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    Quantum
      *q;

    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
    if (q == (Quantum *) NULL)
      break;
    if (TIFFReadEncodedStrip(tiff,TIFFComputeStrip(tiff,y,0),strip,
        (size_t) -1) == -1)
      break;
    (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
      quantum_type,strip,exception);
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  strip=(unsigned char *) RelinquishMagickMemory(strip);
  break;
}
case ReadTileMethod:
{
  uint32
    tile_height,
    tile_width;

  size_t
    tile_size;

  unsigned char
    *tile;

  if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&tile_width) != 1) ||
      (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&tile_height) != 1))
    ThrowTIFFException(CoderError,"ImageIsNotTiled");
  tile_size=TIFFTileSize(tiff);
  tile=(unsigned char *) AcquireQuantumMemory(tile_size,sizeof(*tile));
  if (tile == (unsigned char *) NULL)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  
  for (y=0; y < (ssize_t) image->rows; y+=tile_height)
  {
    ssize_t
      x;

    for (x=0; x < (ssize_t) image->columns; x+=tile_width)
    {
      if (TIFFReadTile(tiff,tile,(uint32) x,(uint32) y,0,0) == -1)
        break;
      ImportTilePixels(image,quantum_info,quantum_type,tile,x,y,
        MagickMin(tile_width,image->columns-x),
        MagickMin(tile_height,image->rows-y),exception);
    }
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  tile=(unsigned char *) RelinquishMagickMemory(tile);
  break;
}
case ReadGenericMethod:
default:
{
  uint32
    *pixels;

  pixels=(uint32 *) AcquireQuantumMemory(image->columns,
    image->rows*sizeof(*pixels));
  if (pixels == (uint32 *) NULL)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  (void) TIFFReadRGBAImage(tiff,(uint32) image->columns,
    (uint32) image->rows,pixels,0);
  ImportImagePixels(image,0,0,image->columns,image->rows,
    "RGBA",UnsignedIntegerPixel,pixels,exception);
  pixels=(uint32 *) RelinquishMagickMemory(pixels);
  break;
}