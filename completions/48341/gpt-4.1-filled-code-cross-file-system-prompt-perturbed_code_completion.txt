case ReadStripMethod:
      {
        /*
          Read TIFF image data by strips.
        */
        uint32
          strip,
          number_strips;

        tsize_t
          strip_size;

        number_strips=TIFFNumberOfStrips(tiff);
        strip_size=TIFFStripSize(tiff);
        if ((number_strips == 0) || (strip_size <= 0))
          ThrowTIFFException(CorruptImageError,"CorruptImage");
        for (strip=0; strip < number_strips; strip++)
        {
          tsize_t
            count;

          count=TIFFReadEncodedStrip(tiff,strip,pixels,strip_size);
          if (count == -1)
            {
              tiff_status=-1;
              break;
            }
          /*
            Import quantum pixels for this strip.
          */
          {
            ssize_t
              y_offset,
              rows_in_strip;

            y_offset=(ssize_t) (strip*rows_per_strip);
            rows_in_strip=(ssize_t) MagickMin(rows_per_strip,(uint32) (image->rows-y_offset));
            for (y=0; y < rows_in_strip; y++)
            {
              Quantum
                *q;

              q=QueueAuthenticPixels(image,0,y_offset+y,image->columns,1,exception);
              if (q == (Quantum *) NULL)
                {
                  tiff_status=-1;
                  break;
                }
              (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,quantum_type,pixels+y*scanline_size,exception);
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                {
                  tiff_status=-1;
                  break;
                }
              if (image->previous == (Image *) NULL)
                {
                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) (y_offset+y),image->rows);
                  if (status == MagickFalse)
                    {
                      tiff_status=-1;
                      break;
                    }
                }
            }
            if (tiff_status == -1)
              break;
          }
        }
        break;
      }
      case ReadTileMethod:
      {
        /*
          Read TIFF image data by tiles.
        */
        uint32
          tile_width,
          tile_length,
          x,
          y;

        tsize_t
          tile_size;

        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&tile_width) != 1) ||
            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&tile_length) != 1))
          ThrowTIFFException(CoderError,"ImageIsNotTiled");
        tile_size=TIFFTileSize(tiff);
        if (tile_size <= 0)
          ThrowTIFFException(CorruptImageError,"CorruptImage");
        for (y=0; y < image->rows; y+=tile_length)
        {
          for (x=0; x < image->columns; x+=tile_width)
          {
            tsize_t
              count;

            count=TIFFReadTile(tiff,pixels,x,y,0,0);
            if (count == -1)
              {
                tiff_status=-1;
                break;
              }
            {
              ssize_t
                tile_y,
                tile_rows;

              tile_rows=(ssize_t) MagickMin(tile_length,(size_t) (image->rows-y));
              for (tile_y=0; tile_y < tile_rows; tile_y++)
              {
                Quantum
                  *q;

                q=QueueAuthenticPixels(image,x,y+tile_y,MagickMin(tile_width,(size_t) (image->columns-x)),1,exception);
                if (q == (Quantum *) NULL)
                  {
                    tiff_status=-1;
                    break;
                  }
                (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,quantum_type,pixels+tile_y*scanline_size,exception);
                if (SyncAuthenticPixels(image,exception) == MagickFalse)
                  {
                    tiff_status=-1;
                    break;
                  }
                if (image->previous == (Image *) NULL)
                  {
                    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) (y+tile_y),image->rows);
                    if (status == MagickFalse)
                      {
                        tiff_status=-1;
                        break;
                      }
                  }
              }
              if (tiff_status == -1)
                break;
            }
          }
          if (tiff_status == -1)
            break;
        }
        break;
      }
      case ReadGenericMethod:
      default:
      {
        /*
          Read TIFF image data using TIFFReadRGBAImage.
        */
        uint32
          *raster;

        raster=(uint32 *) pixels;
        if (TIFFReadRGBAImageOriented(tiff,(uint32) image->columns,(uint32) image->rows,raster,ORIENTATION_TOPLEFT,0) == 0)
          {
            tiff_status=-1;
            break;
          }
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          Quantum
            *q;

          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            {
              tiff_status=-1;
              break;
            }
          (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,quantum_type,(unsigned char *) (raster+y*image->columns*sizeof(uint32)),exception);
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            {
              tiff_status=-1;
              break;
            }
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,image->rows);
              if (status == MagickFalse)
                {
                  tiff_status=-1;
                  break;
                }
            }
        }
        break;
      }