switch (method)
{
  case ReadStripMethod:
  {
    size_t
      strip_size;

    strip_size=TIFFStripSize(tiff);
    if (strip_size <= 0)
      ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
    pixel_info=AcquireVirtualMemory(strip_size,sizeof(uint32));
    if (pixel_info == (MemoryInfo *) NULL)
      ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
    (void) memset(pixels,0,strip_size*sizeof(uint32));
    for (y=0; y < (ssize_t) image->rows; y+=rows_per_strip)
    {
      Quantum
        *magick_restrict q;

      ssize_t
        x;

      unsigned char
        *p;

      tiff_status=TIFFReadEncodedStrip(tiff,y,pixels);
      if (tiff_status == -1)
        break;
      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
      if (q == (Quantum *) NULL)
        break;
      p=pixels;
      for (x=0; x < (ssize_t) image->columns; x++)
      {
        SetPixelRed(image,ScaleCharToQuantum(*p),q);
        SetPixelGreen(image,ScaleCharToQuantum(*(p+1)),q);
        SetPixelBlue(image,ScaleCharToQuantum(*(p+2)),q);
        if (image->alpha_trait!= UndefinedPixelTrait)
          SetPixelAlpha(image,ScaleCharToQuantum(*(p+3)),q);
        q+=GetPixelChannels(image);
        p+=samples_per_pixel;
      }
      if (SyncAuthenticPixels(image,exception) == MagickFalse)
        break;
      if (image->previous == (Image *) NULL)
        {
          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
            image->rows);
          if (status == MagickFalse)
            break;
        }
    }
    break;
  }
  case ReadTileMethod:
  {
    size_t
      tile_size;

    tile_size=TIFFTileSize(tiff);
    if (tile_size <= 0)
      ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
    pixel_info=AcquireVirtualMemory(tile_size,sizeof(uint32));
    if (pixel_info == (MemoryInfo *) NULL)
      ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
    (void) memset(pixels,0,tile_size*sizeof(uint32));
    for (y=0; y < (ssize_t) image->rows; y+=image->tile_height)
    {
      ssize_t
        x;

      for (x=0; x < (ssize_t) image->columns; x+=image->tile_width)
      {
        Quantum
          *magick_restrict q;

        tiff_status=TIFFReadEncodedTile(tiff,x,y,pixels);
        if (tiff_status == -1)
          break;
        q=QueueAuthenticPixels(image,x,y,image->tile_width,image->tile_height,
          exception);
        if (q == (Quantum *) NULL)
          break;
        (void) ImportQuantumPixels(image,quantum_info,quantum_type,pixels,
          GetQuantumPixelCache(q),exception);
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
        if (image->previous == (Image *) NULL)
          {
            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
              image->rows);
            if (status == MagickFalse)
              break;
          }
      }
    }
    break;
  }
  case ReadGenericMethod:
  default:
  {
    tiff_status=TIFFReadRGBAImage(tiff,image->columns,image->rows,pixels,
      samples_per_pixel);
    if (tiff_status == -1)
      break;
    if (image->alpha_trait!= UndefinedPixelTrait)
      {
        Quantum
          *magick_restrict q;

        q=QueueAuthenticPixels(image,0,0,image->columns,image->rows,exception);
        if (q == (Quantum *) NULL)
          break;
        (void) ImportQuantumPixels(image,quantum_info,quantum_type,pixels,
          GetQuantumPixelCache(q),exception);
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
      }
    break;
  }
}