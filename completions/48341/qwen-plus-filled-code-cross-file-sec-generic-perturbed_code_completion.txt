case ReadStripMethod:
      {
        /*
          Convert stripped TIFF image.
        */
        uint32
          strip;

        size_t
          length,
          strip_size;

        strip_size=TIFFStripSize(tiff);
        if (strip_size <= 0)
          break;
        pixels=(unsigned char *) RelinquishMagickMemory(pixels);
        pixel_info=AcquireVirtualMemory(strip_size,sizeof(uint32));
        if (pixel_info == (MemoryInfo *) NULL)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
        for (strip=0; strip < (uint32) TIFFNumberOfStrips(tiff); strip++)
        {
          ssize_t
            y;

          Quantum
            *q;

          ssize_t
            count;

          tiff_status=TIFFReadEncodedStrip(tiff,strip,(void *) pixels,strip_size);
          if (tiff_status == -1)
            break;
          count=0;
          q=QueueAuthenticPixels(image,0,(ssize_t) TIFFComputeStripRowOffset(
            tiff,strip),image->columns,TIFFComputeStripRowHeight(tiff,strip),
            exception);
          if (q == (Quantum *) NULL)
            break;
          length=image->columns*GetPixelChannels(image);
          for (y=0; y < (ssize_t) TIFFComputeStripRowHeight(tiff,strip); y++)
          {
            ImportQuantumPixels(image,(CacheView *) NULL,&count,quantum_info,
              quantum_type,pixels+(size_t) TIFFScanlineSize(tiff)*y,exception);
            SetQuantumPixels(image,q);
            q+=GetImagePixelsPerLine(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImagesTag,TIFFComputeStripRow(
                tiff,strip),image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case ReadTileMethod:
      {
        /*
          Convert tiled TIFF image.
        */
        uint32
          tile;

        size_t
          length,
          tile_size;

        tile_size=TIFFTileSize(tiff);
        if (tile_size <= 0)
          break;
        pixels=(unsigned char *) RelinquishMagickMemory(pixels);
        pixel_info=AcquireVirtualMemory(tile_size,sizeof(uint32));
        if (pixel_info == (MemoryInfo *) NULL)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
        for (tile=0; tile < (uint32) TIFFNumberOfTiles(tiff); tile++)
        {
          ssize_t
            x,
            y;

          Quantum
            *q;

          ssize_t
            count;

          tiff_status=TIFFReadEncodedTile(tiff,tile,(void *) pixels,tile_size);
          if (tiff_status == -1)
            break;
          count=0;
          q=QueueAuthenticPixels(image,TIFFComputeTileX(tiff,tile),
            TIFFComputeTileY(tiff,tile),TIFFComputeTileWidth(tiff,tile),
            TIFFComputeTileHeight(tiff,tile),exception);
          if (q == (Quantum *) NULL)
            break;
          length=TIFFComputeTileWidth(tiff,tile)*GetPixelChannels(image);
          for (y=0; y < (ssize_t) TIFFComputeTileHeight(tiff,tile); y++)
          {
            ImportQuantumPixels(image,(CacheView *) NULL,&count,quantum_info,
              quantum_type,pixels+(size_t) TIFFScanlineSize(tiff)*y,exception);
            SetQuantumPixels(image,q);
            q+=GetImagePixelsPerLine(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImagesTag,(MagickOffsetType) tile,
                TIFFNumberOfTiles(tiff));
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      default:
      {
        if ((TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32) 
          image->rows,(uint32 *) pixels,MagickTrue) == MagickFalse)
          break;
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          const Quantum
            *magick_restrict p;

          Quantum
            *magick_restrict q;

          register ssize_t
            x;

          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          p=pixels+y*(ssize_t) image->columns;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelRed(image,ScaleCharToQuantum((unsigned char) 
              GetPixelRed(p),q);
            SetPixelGreen(image,ScaleCharToQuantum((unsigned char) 
              GetPixelGreen(p),q);
            SetPixelBlue(image,ScaleCharToQuantum((unsigned char) 
              GetPixelBlue(p),q);
            if (image->alpha_trait != UndefinedPixelTrait)
              SetPixelAlpha(image,ScaleCharToQuantum((unsigned char) 
                GetPixelAlpha(p),q);
            p++;
            q+=GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImagesTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }