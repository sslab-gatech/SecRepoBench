case ReadStripMethod:
{
  size_t
    number_pixels,
    strip_size;

  tsize_t
    strip_size;

  unsigned char
    *strip_pixels;

  number_pixels=image->columns*image->rows;
  strip_size=TIFFStripSize(tiff);
  strip_pixels=(unsigned char *) AcquireQuantumMemory(strip_size,sizeof(*strip_pixels));
  if (strip_pixels == (unsigned char *) NULL)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");

  for (y=0; y < (ssize_t) image->rows; y+=rows_per_strip)
  {
    size_t
      length;

    ssize_t
      count;

    length=TIFFReadEncodedStrip(tiff,(tstrip_t) TIFFComputeStrip(tiff,y,0),
      strip_pixels,strip_size);
    if (length == -1)
      break;
    count=TIFFIsTiled(tiff) ? (ssize_t) length : (ssize_t) MagickMin((size_t) length,
      strip_size);
    for (i=0; i < count; i+=samples_per_pixel)
    {
      ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,quantum_type,
        strip_pixels+i,exception);
      if (SyncAuthenticPixels(image,exception) == MagickFalse)
        break;
    }
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  strip_pixels=(unsigned char *) RelinquishMagickMemory(strip_pixels);
  break;
}
case ReadTileMethod:
{
  uint32
    tile_width,
    tile_height;

  size_t
    number_pixels,
    tile_size;

  unsigned char
    *tile_pixels;

  if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&tile_width) != 1) ||
      (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&tile_height) != 1))
    ThrowTIFFException(CoderError,"ImageIsNotTiled");
  number_pixels=tile_width*tile_height;
  tile_size=TIFFTileSize(tiff);
  tile_pixels=(unsigned char *) AcquireQuantumMemory(tile_size,sizeof(*tile_pixels));
  if (tile_pixels == (unsigned char *) NULL)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");

  for (y=0; y < (ssize_t) image->rows; y+=tile_height)
  {
    for (x=0; x < (ssize_t) image->columns; x+=tile_width)
    {
      size_t
        length;

      ssize_t
        count;

      length=TIFFReadTile(tiff,tile_pixels,(uint32) x,(uint32) y,0,0);
      if (length == -1)
        break;
      count=(ssize_t) MagickMin((size_t) length,tile_size);
      for (i=0; i < count; i+=samples_per_pixel)
      {
        ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,quantum_type,
          tile_pixels+i,exception);
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
      }
    }
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  tile_pixels=(unsigned char *) RelinquishMagickMemory(tile_pixels);
  break;
}
case ReadGenericMethod:
default:
{
  if (TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32) image->rows,
    (uint32 *) pixels,0) == 0)
    ThrowTIFFException(CoderError,"ImageIsNotTiled");
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    Quantum
      *magick_restrict q;

    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
    if (q == (Quantum *) NULL)
      break;
    for (x=0; x < (ssize_t) image->columns; x++)
    {
      SetPixelRed(image,ScaleCharToQuantum(TIFFGetR(pixels[y*image->columns+x])),q);
      SetPixelGreen(image,ScaleCharToQuantum(TIFFGetG(pixels[y*image->columns+x])),q);
      SetPixelBlue(image,ScaleCharToQuantum(TIFFGetB(pixels[y*image->columns+x])),q);
      SetPixelAlpha(image,ScaleCharToQuantum(TIFFGetA(pixels[y*image->columns+x])),q);
      q+=GetPixelChannels(image);
    }
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  break;
}