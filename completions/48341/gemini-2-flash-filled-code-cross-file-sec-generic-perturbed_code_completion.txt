case ReadStripMethod:
      {
        /*
          Read image one strip at a time.
        */
        for (y=0; y < (ssize_t) image->rows; y+=rows_per_strip)
        {
          MagickSizeType
            row;

          Quantum
            *magick_restrict q;

          ssize_t
            j;

          /*
            Import strip as a scanline.
          */
          row=(MagickSizeType) MagickMin((ssize_t) rows_per_strip,
            (ssize_t) image->rows-y);
          tiff_status=TIFFReadEncodedStrip(tiff,(tstrip_t) (y/rows_per_strip),
            pixels,(tsize_t) (row*scanline_size));
          if (tiff_status == -1)
            break;
          for (j=0; j < (ssize_t) row; j++)
          {
            q=QueueAuthenticPixels(image,0,y+j,image->columns,1,exception);
            if (q == (Quantum *) NULL)
              break;
            status=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
              quantum_type,pixels+j*scanline_size,exception);
            if (status == MagickFalse)
              break;
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
          }
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case ReadTileMethod:
      {
        ssize_t
          tile_rows;

        /*
          Read image one tile at a time.
        */
        tile_rows=rows_per_strip;
        for (y=0; y < (ssize_t) image->rows; y+=tile_rows)
        {
          MagickSizeType
            row;

          Quantum
            *magick_restrict q;

          ssize_t
            x,
            j;

          uint32
            tile_columns;

          /*
            Import tile as a scanline.
          */
          row=(MagickSizeType) MagickMin((ssize_t) tile_rows,
            (ssize_t) image->rows-y);
          tile_columns=(uint32) image->columns;
          for (x=0; x < (ssize_t) image->columns; x+=tile_columns)
          {
            size_t
              tile_size;

            uint32
              column;

            column=(uint32) MagickMin((ssize_t) tile_columns,
              (ssize_t) image->columns-x);
            tile_size=(size_t) TIFFTileSize(tiff);
            tiff_status=TIFFReadEncodedTile(tiff,TIFFComputeTile(tiff,
              (uint32) x,(uint32) y,(tsample_t) 0),(char *) pixels,(tsize_t)
              tile_size);
            if (tiff_status == -1)
              break;
            for (j=0; j < (ssize_t) row; j++)
            {
              q=QueueAuthenticPixels(image,x,y+j,column,1,exception);
              if (q == (Quantum *) NULL)
                break;
              status=ImportQuantumPixels(image,(CacheView *) NULL,
                quantum_info,quantum_type,pixels+j*scanline_size,exception);
              if (status == MagickFalse)
                break;
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
            }
          }
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case ReadYCCKMethod:
        break;
      case ReadGenericMethod:
      default:
      {
        /*
          Read image as a whole (scanline at a time).
        */
        tiff_status=TIFFReadRGBAImage(tiff,(uint32) image->columns,
          (uint32) image->rows,(uint32 *) pixels,0);
        if (tiff_status == -1)
          break;
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          Quantum
            *magick_restrict q;

          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          status=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
            quantum_type,pixels+y*image->columns*sizeof(uint32),exception);
          if (status == MagickFalse)
            break;
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }