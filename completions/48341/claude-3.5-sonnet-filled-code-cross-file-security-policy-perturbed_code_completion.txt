case ReadStripMethod:
{
  size_t
    strip_size;

  strip_size=TIFFStripSize(tiff);
  pixels=(unsigned char *) AcquireQuantumMemory(strip_size,sizeof(*pixels));
  if (pixels == (unsigned char *) NULL)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  for (y=0; y < (ssize_t) image->rows; y+=rows_per_strip)
  {
    size_t
      length;

    ssize_t
      count;

    tiff_status=TIFFReadEncodedStrip(tiff,(uint32) TIFFComputeStrip(tiff,y,0),
      pixels,strip_size);
    if (tiff_status == -1)
      break;
    count=(ssize_t) MagickMin((size_t) tiff_status,strip_size);
    for (i=0; i < count; i+=length)
    {
      length=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
        quantum_type,pixels+i,exception);
      if (SyncAuthenticPixels(image,exception) == MagickFalse)
        break;
    }
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  pixels=(unsigned char *) RelinquishMagickMemory(pixels);
  break;
}
case ReadTileMethod:
{
  uint32
    tile_width,
    tile_height;

  size_t
    tile_size;

  TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&tile_width);
  TIFFGetField(tiff,TIFFTAG_TILELENGTH,&tile_height);
  tile_size=TIFFTileSize(tiff);
  pixels=(unsigned char *) AcquireQuantumMemory(tile_size,sizeof(*pixels));
  if (pixels == (unsigned char *) NULL)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  for (y=0; y < (ssize_t) image->rows; y+=tile_height)
  {
    for (x=0; x < (ssize_t) image->columns; x+=tile_width)
    {
      size_t
        length;

      ssize_t
        count;

      tiff_status=TIFFReadTile(tiff,pixels,(uint32) x,(uint32) y,0,0);
      if (tiff_status == -1)
        break;
      count=(ssize_t) MagickMin((size_t) tiff_status,tile_size);
      for (i=0; i < count; i+=length)
      {
        length=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
          quantum_type,pixels+i,exception);
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
      }
    }
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  pixels=(unsigned char *) RelinquishMagickMemory(pixels);
  break;
}
case ReadGenericMethod:
default:
{
  uint32
    *p;

  /*
    Convert TIFF image to DirectClass MIFF image.
  */
  number_pixels=(MagickSizeType) image->columns*image->rows;
  if ((number_pixels*sizeof(uint32)) != (MagickSizeType) ((size_t)
      (number_pixels*sizeof(uint32))))
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  pixel_info=AcquireVirtualMemory(image->columns,image->rows*
    sizeof(uint32));
  if (pixel_info == (MemoryInfo *) NULL)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  p=(uint32 *) GetVirtualMemoryBlob(pixel_info);
  if (TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32) image->rows,
      p,0) == 0)
    {
      pixel_info=RelinquishVirtualMemory(pixel_info);
      ThrowTIFFException(CoderError,"ImageIsNotTIFF");
    }
  /*
    Convert image to DirectClass pixel packets.
  */
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    Quantum
      *magick_restrict q;

    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
    if (q == (Quantum *) NULL)
      break;
    for (x=0; x < (ssize_t) image->columns; x++)
    {
      SetPixelRed(image,ScaleCharToQuantum(TIFFGetR(*p)),q);
      SetPixelGreen(image,ScaleCharToQuantum(TIFFGetG(*p)),q);
      SetPixelBlue(image,ScaleCharToQuantum(TIFFGetB(*p)),q);
      SetPixelAlpha(image,ScaleCharToQuantum(TIFFGetA(*p)),q);
      p++;
      q+=GetPixelChannels(image);
    }
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  pixel_info=RelinquishVirtualMemory(pixel_info);
  break;
}