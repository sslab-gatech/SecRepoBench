case ReadStripMethod:
      {
        uint32 num_strips = TIFFNumberOfStrips(tiff);
        uint32 row = 0;
        for (uint32 strip = 0; strip < num_strips; strip++)
        {
          tsize_t count;
          count=TIFFReadEncodedStrip(tiff,strip,pixels,(tsize_t)-1);
          if (count == -1)
            break;
          /*
            Process each row in this strip.
          */
          uint32 rows_this_strip = rows_per_strip;
          if (row + rows_this_strip > (uint32) image->rows)
            rows_this_strip=(uint32) image->rows-row;
          for (i=0; i < (ssize_t) rows_this_strip; i++)
          {
            Quantum
              *magick_restrict q;

            q=QueueAuthenticPixels(image,0,row+i,image->columns,1,exception);
            if (q == (Quantum *) NULL)
              break;
            (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
              quantum_type,(pixels + i*(image->columns*samples_per_pixel*
              ((bits_per_sample+7)/8))),exception);
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
            if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                (row+i),image->rows);
              if (status == MagickFalse)
                break;
            }
          }
          row+=rows_this_strip;
          if (row >= (uint32) image->rows)
            break;
          if (image->previous == (Image *) NULL && status == MagickFalse)
            break;
        }
        break;
      }
      case ReadTileMethod:
      {
        uint32 tile_width, tile_length;
        (void) TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&tile_width);
        (void) TIFFGetField(tiff,TIFFTAG_TILELENGTH,&tile_length);
        for (y=0; y < (ssize_t) image->rows; y+=(ssize_t) tile_length)
        {
          ssize_t
            tile_row_limit = (ssize_t) MagickMin((ssize_t) tile_length,
              (ssize_t) (image->rows-y));

          for (i=0; i < (ssize_t) image->columns; i+=(ssize_t) tile_width)
          {
            ssize_t
              tile_col_limit = (ssize_t) MagickMin((ssize_t) tile_width,
                (ssize_t) (image->columns-i));

            tiff_status=(int) TIFFReadTile(tiff,pixels,(uint32) i,(uint32) y,
              0,0);
            if (tiff_status < 0)
              break;
            /*
              Process the tile we just read.
            */
            for (ssize_t tile_row=0; tile_row < tile_row_limit; tile_row++)
            {
              Quantum
                *magick_restrict q;

              q=QueueAuthenticPixels(image,(ssize_t) i,y+tile_row,
                (size_t) tile_col_limit,1,exception);
              if (q == (Quantum *) NULL)
                break;
              (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
                quantum_type,(pixels + tile_row*(tile_width*samples_per_pixel*
                ((bits_per_sample+7)/8))),exception);
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
            }
            if (tiff_status < 0)
              break;
          }
          if (image->previous == (Image *) NULL)
          {
            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
              image->rows);
            if (status == MagickFalse)
              break;
          }
          if (tiff_status < 0 || status == MagickFalse)
            break;
        }
        break;
      }
      case ReadGenericMethod:
      default:
      {
        /*
          Use TIFFReadRGBAImage or a similar generic approach.
        */
        unsigned char
          *raster;

        raster=(unsigned char *) AcquireQuantumMemory((size_t) image->columns,
          (size_t) image->rows*sizeof(uint32));
        if (raster == (unsigned char *) NULL)
          {
            status=MagickFalse;
            break;
          }
        if (TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32) image->rows,
            (uint32 *) raster,0) != 0)
          {
            /*
              Transfer data from raster to the image.
            */
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              Quantum
                *magick_restrict q;

              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
              if (q == (Quantum *) NULL)
                {
                  status=MagickFalse;
                  break;
                }
              for (i=0; i < (ssize_t) image->columns; i++)
              {
                uint32 pixel=((uint32 *) raster)[(size_t) y*image->columns+i];
                SetPixelRed(image,ScaleCharToQuantum((unsigned char)
                  TIFFGetR(pixel)),q);
                SetPixelGreen(image,ScaleCharToQuantum((unsigned char)
                  TIFFGetG(pixel)),q);
                SetPixelBlue(image,ScaleCharToQuantum((unsigned char)
                  TIFFGetB(pixel)),q);
                if (image->alpha_trait != UndefinedPixelTrait)
                  SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)
                    TIFFGetA(pixel)),q);
                q+=GetPixelChannels(image);
              }
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                {
                  status=MagickFalse;
                  break;
                }
              if ((image->previous == (Image *) NULL) && (SetImageProgress(
                   image,LoadImageTag,(MagickOffsetType) y,image->rows)
                   == MagickFalse))
                {
                  status=MagickFalse;
                  break;
                }
              if (status == MagickFalse)
                break;
            }
          }
        else
          status=MagickFalse;
        raster=(unsigned char *) RelinquishMagickMemory(raster);
        break;
      }