switch (method)
{
  case ReadStripMethod:
  {
    /*
      Read image data by processing each strip of the TIFF file.
    */
    for (y = 0; y < (ssize_t) image->rows; y += rows_per_strip)
    {
      ssize_t
        length,
        strip_size;

      strip_size = TIFFReadEncodedStrip(tiff, y / rows_per_strip, pixels,
        (tsize_t) -1);
      if (strip_size < 0)
        break;
      length = ImportQuantumPixels(image, (CacheView *) NULL, quantum_info,
        quantum_type, pixels);
      if (length != (ssize_t) image->columns * samples_per_pixel)
        break;
      if (SetImagePixels(image, 0, y, image->columns, rows_per_strip < image->rows - y ?
        rows_per_strip : image->rows - y, exception) == MagickFalse)
        break;
      if (SyncImagePixels(image, exception) == MagickFalse)
        break;
      if (image->previous == (Image *) NULL)
      {
        status = SetImageProgress(image, LoadImageTag, y, image->rows);
        if (status == MagickFalse)
          break;
      }
    }
    break;
  }
  case ReadTileMethod:
  {
    /*
      Read image data by processing each tile of the TIFF file.
    */
    for (y = 0; y < (ssize_t) image->rows; y += rows_per_strip)
    {
      for (x = 0; x < (ssize_t) image->columns; x += image->columns)
      {
        ssize_t
          length,
          tile_size;

        tile_size = TIFFReadEncodedTile(tiff, (uint32) (y / rows_per_strip) *
          TIFFhowmany(image->columns, 64U) + (x / 64), pixels, (tsize_t) -1);
        if (tile_size < 0)
          break;
        length = ImportQuantumPixels(image, (CacheView *) NULL, quantum_info,
          quantum_type, pixels);
        if (length != (ssize_t) image->columns * samples_per_pixel)
          break;
        if (SetImagePixels(image, x, y, image->columns < x + 64 ? image->columns - x : 64,
          rows_per_strip < image->rows - y ? rows_per_strip : image->rows - y, exception) ==
          MagickFalse)
          break;
        if (SyncImagePixels(image, exception) == MagickFalse)
          break;
      }
      if (image->previous == (Image *) NULL)
      {
        status = SetImageProgress(image, LoadImageTag, y, image->rows);
        if (status == MagickFalse)
          break;
      }
    }
    break;
  }
  case GetJPEGMethod:
  case ReadGenericMethod:
  default:
  {
    /*
      Read image data using the TIFFReadRGBAImage function.
    */
    if (TIFFReadRGBAImage(tiff, image->columns, image->rows, (uint32 *) pixels, 0) == 0)
      ThrowTIFFException(CorruptImageError, "ImageDataHasBeenDeleted");
    (void) ImportQuantumPixels(image, (CacheView *) NULL, quantum_info, quantum_type, pixels);
    if (SetImagePixels(image, 0, 0, image->columns, image->rows, exception) == MagickFalse)
      break;
    if (SyncImagePixels(image, exception) == MagickFalse)
      break;
    break;
  }
}