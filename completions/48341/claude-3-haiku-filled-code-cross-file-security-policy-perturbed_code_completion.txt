switch (method)
{
  case ReadStripMethod:
  {
    /*
      Read image data by processing each strip of the TIFF file.
    */
    for (y = 0; y < (ssize_t) image->rows; y += rows_per_strip)
    {
      ssize_t
        length,
        strip_size;

      strip_size = TIFFReadEncodedStrip(tiff, y / rows_per_strip, pixels,
        (tsize_t) -1);
      if (strip_size < 0)
        ThrowTIFFException(CorruptImageError, "UnableToReadImageData");
      length = ImportQuantumPixels(image, (CacheView *) NULL, quantum_info,
        quantum_type, pixels);
      if (length != (ssize_t) image->columns * samples_per_pixel)
        ThrowTIFFException(CorruptImageError, "UnableToReadImageData");
      if (SetPixelVirtualMethod(image, UndefinedVirtualPixelMethod, 0, y,
          image->columns, rows_per_strip, exception) == MagickFalse)
        break;
      if (SyncAuthenticPixels(image, exception) == MagickFalse)
        break;
      if (image->previous == (Image *) NULL)
      {
        status = SetImageProgress(image, LoadImageTag, y, image->rows);
        if (status == MagickFalse)
          break;
      }
    }
    break;
  }
  case ReadTileMethod:
  {
    /*
      Read image data by processing each tile of the TIFF file.
    */
    for (y = 0; y < (ssize_t) image->rows; y += rows_per_strip)
    {
      for (x = 0; x < (ssize_t) image->columns; x += image->columns)
      {
        ssize_t
          length,
          tile_size;

        tile_size = TIFFReadEncodedTile(tiff, (uint32) (y / rows_per_strip) *
          TIFFhowmany(image->columns, 32U) + (x / 32U), pixels, (tsize_t) -1);
        if (tile_size < 0)
          ThrowTIFFException(CorruptImageError, "UnableToReadImageData");
        length = ImportQuantumPixels(image, (CacheView *) NULL, quantum_info,
          quantum_type, pixels);
        if (length != (ssize_t) image->columns * samples_per_pixel)
          ThrowTIFFException(CorruptImageError, "UnableToReadImageData");
        if (SetPixelVirtualMethod(image, UndefinedVirtualPixelMethod, x, y,
            MagickMin(image->columns - x, 32U), MagickMin(rows_per_strip,
            image->rows - y), exception) == MagickFalse)
          break;
        if (SyncAuthenticPixels(image, exception) == MagickFalse)
          break;
      }
      if (image->previous == (Image *) NULL)
      {
        status = SetImageProgress(image, LoadImageTag, y, image->rows);
        if (status == MagickFalse)
          break;
      }
    }
    break;
  }
  case GetJPEGMethod:
  {
    /*
      Read JPEG-compressed TIFF image.
    */
#if defined(JPEG_SUPPORT)
    status = ReadJPEGImage(image_info, image, tiff, photometric, bits_per_sample,
      samples_per_pixel, exception);
    if (status == MagickFalse)
      ThrowTIFFException(CorruptImageError, "UnableToReadImageData");
#else
    ThrowTIFFException(CoderError, "JPEGLibraryIsNotAvailable");
#endif
    break;
  }
  case ReadGenericMethod:
  default:
  {
    /*
      Read entire image at once using TIFFReadRGBAImage.
    */
    if (TIFFReadRGBAImage(tiff, (uint32) image->columns, (uint32) image->rows,
        (uint32 *) pixels, 0) == 0)
      ThrowTIFFException(CorruptImageError, "UnableToReadImageData");
    (void) ImportQuantumPixels(image, (CacheView *) NULL, quantum_info,
      RGBAQuantum, pixels);
    break;
  }
}