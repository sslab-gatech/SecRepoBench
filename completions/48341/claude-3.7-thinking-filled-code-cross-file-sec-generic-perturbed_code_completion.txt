case ReadStripMethod:
{
  /*
    Read TIFF image with scanline API.
  */
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    Quantum
      *magick_restrict q;

    tiff_status=TIFFReadScanline(tiff,pixels,(uint32) y,0);
    if (tiff_status == -1)
      break;
    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
    if (q == (Quantum *) NULL)
      break;
    if (ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,quantum_type,
          pixels,exception) == MagickFalse)
      break;
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  break;
}
case ReadTileMethod:
{
  /*
    Read TIFF image with tile API.
  */
  uint32
    tile_width,
    tile_height;

  if (TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&tile_width) != 1)
    ThrowTIFFException(CoderError,"TileWidthNotSet");
  if (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&tile_height) != 1)
    ThrowTIFFException(CoderError,"TileLengthNotSet");
  
  for (y=0; y < (ssize_t) image->rows; y+=tile_height)
  {
    for (x=0; x < (ssize_t) image->columns; x+=tile_width)
    {
      /*
        Read a tile of pixels.
      */
      tiff_status=TIFFReadTile(tiff,pixels,(uint32) x,(uint32) y,0,0);
      if (tiff_status == -1)
        break;
      
      /*
        Transfer tile to the image.
      */
      for (i=0; i < (ssize_t) tile_height; i++)
      {
        Quantum
          *magick_restrict q;

        size_t
          width;

        if ((y+i) >= (ssize_t) image->rows)
          break;
        
        width=tile_width;
        if ((x+width) > image->columns)
          width=image->columns-x;
        
        q=QueueAuthenticPixels(image,x,y+i,width,1,exception);
        if (q == (Quantum *) NULL)
          break;
        
        (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
          quantum_type,(const unsigned char *) pixels+i*TIFFTileRowSize(tiff),
          exception);
        
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
      }
      if (i < (ssize_t) tile_height)
        break;
    }
    if (x < (ssize_t) image->columns)
      break;
    
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  break;
}
case ReadGenericMethod:
default:
{
  uint32
    *p;

  /*
    Convert TIFF pixels to MIFF pixels.
  */
  p=(uint32 *) pixels;
  if (TIFFReadRGBAImageOriented(tiff,(uint32) image->columns,
      (uint32) image->rows,p,ORIENTATION_TOPLEFT,0) == 0)
    break;
  
  /*
    Convert TIFF pixels to MIFF pixels.
  */
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    Quantum
      *magick_restrict q;

    ssize_t
      x;

    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
    if (q == (Quantum *) NULL)
      break;
    for (x=0; x < (ssize_t) image->columns; x++)
    {
      SetPixelRed(image,ScaleCharToQuantum((unsigned char)
        TIFFGetR(p[y*image->columns+x])),q);
      SetPixelGreen(image,ScaleCharToQuantum((unsigned char)
        TIFFGetG(p[y*image->columns+x])),q);
      SetPixelBlue(image,ScaleCharToQuantum((unsigned char)
        TIFFGetB(p[y*image->columns+x])),q);
      if (image->alpha_trait != UndefinedPixelTrait)
        SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)
          TIFFGetA(p[y*image->columns+x])),q);
      q+=GetPixelChannels(image);
    }
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  break;
}