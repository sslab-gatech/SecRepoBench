switch (method)
{
  case ReadStripMethod:
  {
    /*
      Read image data by processing each strip of the TIFF file.
    */
    for (y = 0; y < (ssize_t)image->rows; y += rows_per_strip)
    {
      ssize_t strip_size = MagickMin(rows_per_strip, image->rows - y);
      tiff_status = TIFFReadEncodedStrip(tiff, y / rows_per_strip, pixels, strip_size * scanline_size);
      if (tiff_status == -1)
        break;

      for (i = 0; i < strip_size; i++)
      {
        Quantum *q = QueueAuthenticPixels(image, 0, y + i, image->columns, 1, exception);
        if (q == (Quantum *)NULL)
          break;

        ImportQuantumPixels(image, (CacheView *)NULL, quantum_info, quantum_type, pixels + i * scanline_size, exception);
        if (SyncAuthenticPixels(image, exception) == MagickFalse)
          break;

        if (image->previous == (Image *)NULL)
        {
          status = SetImageProgress(image, LoadImageTag, (MagickOffsetType)y + i, image->rows);
          if (status == MagickFalse)
            break;
        }
      }
    }
    break;
  }
  case ReadTileMethod:
  {
    /*
      Read image data by processing each tile of the TIFF file.
    */
    uint32 tile_width, tile_height;
    (void)TIFFGetField(tiff, TIFFTAG_TILEWIDTH, &tile_width);
    (void)TIFFGetField(tiff, TIFFTAG_TILELENGTH, &tile_height);

    for (y = 0; y < (ssize_t)image->rows; y += tile_height)
    {
      for (i = 0; i < (ssize_t)image->columns; i += tile_width)
      {
        tiff_status = TIFFReadTile(tiff, pixels, i, y, 0, 0);
        if (tiff_status == -1)
          break;

        Quantum *q = QueueAuthenticPixels(image, i, y, MagickMin(tile_width, image->columns - i), MagickMin(tile_height, image->rows - y), exception);
        if (q == (Quantum *)NULL)
          break;

        ImportQuantumPixels(image, (CacheView *)NULL, quantum_info, quantum_type, pixels, exception);
        if (SyncAuthenticPixels(image, exception) == MagickFalse)
          break;

        if (image->previous == (Image *)NULL)
        {
          status = SetImageProgress(image, LoadImageTag, (MagickOffsetType)(y * image->columns + i), image->columns * image->rows);
          if (status == MagickFalse)
            break;
        }
      }
    }
    break;
  }
  case ReadGenericMethod:
  default:
  {
    /*
      Read image data using the TIFFReadRGBAImage function.
    */
    tiff_status = TIFFReadRGBAImage(tiff, image->columns, image->rows, (uint32 *)pixels, 0);
    if (tiff_status == 0)
      break;

    for (y = 0; y < (ssize_t)image->rows; y++)
    {
      Quantum *q = QueueAuthenticPixels(image, 0, image->rows - y - 1, image->columns, 1, exception);
      if (q == (Quantum *)NULL)
        break;

      ImportQuantumPixels(image, (CacheView *)NULL, quantum_info, quantum_type, pixels + y * image->columns * 4, exception);
      if (SyncAuthenticPixels(image, exception) == MagickFalse)
        break;

      if (image->previous == (Image *)NULL)
      {
        status = SetImageProgress(image, LoadImageTag, (MagickOffsetType)y, image->rows);
        if (status == MagickFalse)
          break;
      }
    }
    break;
  }
}