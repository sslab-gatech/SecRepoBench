case ReadStripMethod:
      {
        uint32
          *byte_count = NULL,
          *strip_offsets = NULL;

        tiff_status=TIFFGetField(tiff,TIFFTAG_STRIPOFFSETS,&strip_offsets);
        if (tiff_status != 1)
          ThrowTIFFException(CorruptImageError,"ImageTypeNotSupported");
        tiff_status=TIFFGetField(tiff,TIFFTAG_STRIPBYTECOUNTS,&byte_count);
        if (tiff_status != 1)
          ThrowTIFFException(CorruptImageError,"ImageTypeNotSupported");
        for (i=0; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)
        {
          tsize_t
            strip_size;

          strip_size=TIFFReadEncodedStrip(tiff,(tstrip_t) i,pixels,
            (tsize_t) byte_count[i]);
          if (strip_size < 0)
            break;
          for (y=0; y < (ssize_t) rows_per_strip; y++)
          {
            Quantum
              *magick_restrict q;

            ssize_t
              x;

            if ((i*rows_per_strip+y) >= (ssize_t) image->rows)
              break;
            q=QueueAuthenticPixels(image,0,i*rows_per_strip+y,image->columns,1,
              exception);
            if (q == (Quantum *) NULL)
              break;
            (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
              quantum_type,pixels+y*scanline_size,exception);
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
          }
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) i,
                TIFFNumberOfStrips(tiff));
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case ReadTileMethod:
      {
        uint32
          *byte_count = NULL,
          *tile_offsets = NULL;

        tiff_status=TIFFGetField(tiff,TIFFTAG_TILEOFFSETS,&tile_offsets);
        if (tiff_status != 1)
          ThrowTIFFException(CorruptImageError,"ImageTypeNotSupported");
        tiff_status=TIFFGetField(tiff,TIFFTAG_TILEBYTECOUNTS,&byte_count);
        if (tiff_status != 1)
          ThrowTIFFException(CorruptImageError,"ImageTypeNotSupported");
        for (i=0; i < (ssize_t) TIFFNumberOfTiles(tiff); i++)
        {
          tsize_t
            tile_size;

          tile_size=TIFFReadEncodedTile(tiff,(ttile_t) i,pixels,
            (tsize_t) byte_count[i]);
          if (tile_size < 0)
            break;
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            Quantum
              *magick_restrict q;

            ssize_t
              x;

            if ((i*rows_per_strip+y) >= (ssize_t) image->rows)
              break;
            q=QueueAuthenticPixels(image,0,i*rows_per_strip+y,image->columns,1,
              exception);
            if (q == (Quantum *) NULL)
              break;
            (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
              quantum_type,pixels+y*scanline_size,exception);
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
          }
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) i,
                TIFFNumberOfTiles(tiff));
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case ReadGenericMethod:
      default:
      {
        if (TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32) image->rows,
            (uint32 *) pixels,0) == 0)
          ThrowTIFFException(CorruptImageError,"UnableToReadImageData");
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          Quantum
            *magick_restrict q;

          ssize_t
            x;

          q=QueueAuthenticPixels(image,0,image->rows-y-1,image->columns,1,
            exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelRed(image,ScaleCharToQuantum((unsigned char)
              TIFFGetR(pixels[x])),q);
            SetPixelGreen(image,ScaleCharToQuantum((unsigned char)
              TIFFGetG(pixels[x])),q);
            SetPixelBlue(image,ScaleCharToQuantum((unsigned char)
              TIFFGetB(pixels[x])),q);
            SetPixelAlpha(image,OpaqueAlpha,q);
            q+=GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }