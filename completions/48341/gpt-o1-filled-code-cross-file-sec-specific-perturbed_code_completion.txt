case ReadStripMethod:
      {
        uint32 strip_count=TIFFNumberOfStrips(tiff);
        uint32 strip_height=(rows_per_strip > 0 ? rows_per_strip : 1);
        uint32 current_row=0;
        for (uint32 strip=0; strip < strip_count; strip++)
        {
          tsize_t len=TIFFReadEncodedStrip(tiff,strip,pixels,(tsize_t) -1);
          if (len < 0)
            {
              tiff_status=(-1);
              break;
            }
          /* Process each row in the strip */
          for (y=0; y < (ssize_t) strip_height && current_row < image->rows; y++, current_row++)
          {
            Quantum *q=QueueAuthenticPixels(image,0,(ssize_t) current_row,
              image->columns,1,exception);
            if (q == (Quantum *) NULL)
              {
                tiff_status=(-1);
                break;
              }
            (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
              quantum_type,pixels+y*(scanline_size),exception);
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              {
                tiff_status=(-1);
                break;
              }
            if (image->previous == (Image *) NULL)
              {
                MagickBooleanType proceed=SetImageProgress(image,LoadImageTag,
                  (MagickOffsetType) current_row,image->rows);
                if (proceed == MagickFalse)
                  {
                    tiff_status=(-1);
                    break;
                  }
              }
          }
          if (tiff_status == -1)
            break;
        }
        break;
      }
      case ReadTileMethod:
      {
        uint32 tile_count=TIFFNumberOfTiles(tiff);
        if (tile_count == 0)
          {
            tiff_status=(-1);
            break;
          }
        for (uint32 tile=0; tile < tile_count; tile++)
        {
          tsize_t len=TIFFReadEncodedTile(tiff,tile,pixels,(tsize_t) -1);
          if (len < 0)
            {
              tiff_status=(-1);
              break;
            }
          /* Determine tile geometry */
          uint32 tile_width, tile_height;
          (void) TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&tile_width);
          (void) TIFFGetField(tiff,TIFFTAG_TILELENGTH,&tile_height);
          /* Compute tile position */
          uint32 ty=(tile*tile_height)/image->columns*tile_height;
          uint32 tx=(tile*tile_width)%image->columns;
          /* Write tile rows into image */
          for (y=0; y < (ssize_t) tile_height; y++)
          {
            uint32 row=ty+y;
            if (row >= image->rows)
              break;
            Quantum *q=QueueAuthenticPixels(image,(ssize_t) tx,(ssize_t) row,
              MagickMin(tile_width,(uint32) image->columns-tx),1,exception);
            if (q == (Quantum *) NULL)
              {
                tiff_status=(-1);
                break;
              }
            (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
              quantum_type,pixels+y*(scanline_size),exception);
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              {
                tiff_status=(-1);
                break;
              }
          }
          if (tiff_status == -1)
            break;
          if (image->previous == (Image *) NULL)
            {
              MagickBooleanType proceed=SetImageProgress(image,LoadImageTag,
                (MagickOffsetType) tile,tile_count);
              if (proceed == MagickFalse)
                {
                  tiff_status=(-1);
                  break;
                }
            }
        }
        break;
      }
      case ReadGenericMethod:
      default:
      {
        /* Use TIFFReadRGBAImage to read the entire image at once */
        if (TIFFReadRGBAImage(tiff,width,height,(uint32 *) pixels,0) == 0)
          {
            tiff_status=(-1);
            break;
          }
        for (y=0; y < (ssize_t) height; y++)
        {
          Quantum *q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            {
              tiff_status=(-1);
              break;
            }
          (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
            quantum_type,(unsigned char *) &((uint32 *) pixels)[y*(size_t) width],
            exception);
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            {
              tiff_status=(-1);
              break;
            }
          if (image->previous == (Image *) NULL)
            {
              MagickBooleanType proceed=SetImageProgress(image,LoadImageTag,
                (MagickOffsetType) y,image->rows);
              if (proceed == MagickFalse)
                {
                  tiff_status=(-1);
                  break;
                }
            }
        }
        break;
      }