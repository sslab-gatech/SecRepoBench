case ReadStripMethod:
{
  size_t
    strip_size;

  strip_size=TIFFStripSize(tiff);
  if (strip_size == 0)
    ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
  pixels=(unsigned char *) AcquireMagickMemory(strip_size);
  if (pixels == (unsigned char *) NULL)
    ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
  for (y=0; y < (ssize_t) image->rows; y+=rows_per_strip)
  {
    size_t
      length;

    ssize_t
      count;

    rows=MagickMin(rows_per_strip,(size_t) (image->rows-y));
    count=TIFFReadEncodedStrip(tiff,(uint32) TIFFComputeStrip(tiff,(uint32) y,
      0),pixels,strip_size);
    if (count <= 0)
      break;
    length=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
      quantum_type,pixels,exception);
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  pixels=(unsigned char *) RelinquishMagickMemory(pixels);
  break;
}
case ReadTileMethod:
{
  uint32
    tile_height,
    tile_width;

  if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&tile_width) != 1) ||
      (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&tile_height) != 1))
    ThrowReaderException(CoderError,"ImageIsNotTiled");
  pixels=(unsigned char *) AcquireMagickMemory(TIFFTileSize(tiff));
  if (pixels == (unsigned char *) NULL)
    ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
  for (y=0; y < (ssize_t) image->rows; y+=tile_height)
  {
    for (x=0; x < (ssize_t) image->columns; x+=tile_width)
    {
      ssize_t
        count;

      count=TIFFReadTile(tiff,pixels,(uint32) x,(uint32) y,0,0);
      if (count < 0)
        break;
      ImportTilePixels(image,quantum_info,quantum_type,pixels,exception);
    }
    if (x < (ssize_t) image->columns)
      break;
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  pixels=(unsigned char *) RelinquishMagickMemory(pixels);
  break;
}
case ReadGenericMethod:
default:
{
  uint32
    *p;

  /*
    Convert TIFF image to DirectClass MIFF image.
  */
  number_pixels=(MagickSizeType) image->columns*image->rows;
  if ((number_pixels*sizeof(uint32)) != (MagickSizeType) ((size_t)
      (number_pixels*sizeof(uint32))))
    ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
  pixel_info=AcquireVirtualMemory(image->columns,image->rows*
    sizeof(uint32));
  if (pixel_info == (MemoryInfo *) NULL)
    ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
  p=(uint32 *) GetVirtualMemoryBlob(pixel_info);
  if (TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32) image->rows,
      p,0) == 0)
    {
      pixel_info=RelinquishVirtualMemory(pixel_info);
      ThrowReaderException(CoderError,"MemoryAllocationFailed");
    }
  /*
    Convert image to DirectClass pixel packets.
  */
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    Quantum
      *q;

    ssize_t
      x;

    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
    if (q == (Quantum *) NULL)
      break;
    for (x=0; x < (ssize_t) image->columns; x++)
    {
      SetPixelRed(image,ScaleCharToQuantum(TIFFGetR(*p)),q);
      SetPixelGreen(image,ScaleCharToQuantum(TIFFGetG(*p)),q);
      SetPixelBlue(image,ScaleCharToQuantum(TIFFGetB(*p)),q);
      SetPixelAlpha(image,ScaleCharToQuantum(TIFFGetA(*p)),q);
      p++;
      q+=GetPixelChannels(image);
    }
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  pixel_info=RelinquishVirtualMemory(pixel_info);
  break;
}