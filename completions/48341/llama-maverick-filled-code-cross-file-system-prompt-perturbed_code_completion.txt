case ReadStripMethod:
  {
    uint32
      strip;

    /*
      Read image based on strip.
    */
    for (y=0; y < (ssize_t) image->rows; y+=rows_per_strip)
    {
      Quantum
        *magick_restrict q;

      ssize_t
        x;

      tiff_status=TIFFReadEncodedStrip(tiff,(uint32) (y/rows_per_strip),
        (unsigned char *) pixels,TIFFStripSize(tiff));
      if (tiff_status == -1)
        break;
      strip=TIFFComputeStrip(tiff,(uint32) y,0);
      for (i=0; i < (ssize_t) samples_per_pixel; i++)
      {
        size_t
          bytes_per_pixel,
          remainder;

        ssize_t
          offset,
          y;

        bytes_per_pixel=bits_per_sample >> 3;
        offset=(ssize_t) (i*bytes_per_pixel);
        remainder=(size_t) (scanline_size-(image->columns+pad)*bytes_per_pixel);
        if ((remainder > scanline_size) || (remainder < 0))
          {
            status=MagickFalse;
            break;
          }
        for (y=0; y < (ssize_t) rows_per_strip; y++)
        {
          ssize_t
            x;

          unsigned char
            *p;

          if ((y > 0) || (strip > 0))
            (void) memcpy(pixels,((unsigned char *) pixels)+scanline_size,
              scanline_size);
          p=pixels;
          if (planar_configuration == PLANARCONFIG_SEPARATE)
            p=(unsigned char *) pixels+offset;
          q=QueueAuthenticPixels(image,0,(ssize_t) (y+i*rows_per_strip),
            image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            if (bits_per_sample <= 8)
              SetPixelChannel(image,quantum_info->channel_map[i].channel,
                ScaleCharToQuantum(*p),q);
            else
              if (bits_per_sample == 16)
                SetPixelChannel(image,quantum_info->channel_map[i].channel,
                  ScaleShortToQuantum((unsigned short) ((*p << 8) | *(p+1))),
                  q);
              else
                SetPixelChannel(image,quantum_info->channel_map[i].channel,
                  ScaleLongToQuantum((unsigned int) ((*p << 24) |
                  (*(p+1) << 16) | (*(p+2) << 8) | *(p+3))),q);
            SetPixelChannels(image,q);
            p+=bytes_per_pixel;
            q+=GetPixelChannels(image);
          }
          if (planar_configuration == PLANARCONFIG_SEPARATE)
            p=(unsigned char *) pixels+((i+1)*scanline_size);
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
        }
      }
      if (image->previous == (Image *) NULL)
        {
          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
            image->rows);
          if (status == MagickFalse)
            break;
        }
    }
    break;
  }
case ReadTileMethod:
  {
    uint32
      columns,
      rows,
      tile_width,
      tile_height;

    size_t
      tile_image_size;

    unsigned char
      *tile_data;

    /*
      Read image based on tile.
    */
    tile_width=TIFFTileRowSize(tiff);
    tile_height=TIFFTileSize(tiff);
    tile_image_size=MagickMax((MagickSizeType) tile_width*tile_height,
      number_pixels);
    tile_data=(unsigned char *) NULL;
    if (tile_image_size != 0)
      tile_data=(unsigned char *) AcquireQuantumMemory(tile_image_size,
        sizeof(*tile_data));
    if (tile_data == (unsigned char *) NULL)
      ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
    for (y=0; y < (ssize_t) image->rows; y+=rows)
    {
      Quantum
        *magick_restrict q;

      ssize_t
        x;

      uint32
        tile_y;

      rows=TIFFComputeTile(tiff,(uint32) y,0,0,0);
      tile_y=TIFFComputeTile(tiff,(uint32) y,0,0,1);
      tiff_status=TIFFReadEncodedTile(tiff,rows,tile_data,tile_image_size);
      if (tiff_status == -1)
        break;
      for (i=0; i < (ssize_t) samples_per_pixel; i++)
      {
        size_t
          bytes_per_pixel;

        ssize_t
          offset,
          y;

        bytes_per_pixel=bits_per_sample >> 3;
        offset=(ssize_t) (i*bytes_per_pixel);
        for (y=0; y < (ssize_t) MagickMin((size_t) rows,image->rows-(ssize_t)
          tile_y); y++)
        {
          ssize_t
            x;

          unsigned char
            *p;

          p=tile_data+(y*tile_width);
          if (planar_configuration == PLANARCONFIG_SEPARATE)
            p=tile_data+(offset+y*tile_image_size);
          q=QueueAuthenticPixels(image,0,(ssize_t) (tile_y+y),image->columns,
            1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            if (bits_per_sample <= 8)
              SetPixelChannel(image,quantum_info->channel_map[i].channel,
                ScaleCharToQuantum(*p),q);
            else
              if (bits_per_sample == 16)
                SetPixelChannel(image,quantum_info->channel_map[i].channel,
                  ScaleShortToQuantum((unsigned short) ((*p << 8) | *(p+1))),
                  q);
              else
                SetPixelChannel(image,quantum_info->channel_map[i].channel,
                  ScaleLongToQuantum((unsigned int) ((*p << 24) |
                  (*(p+1) << 16) | (*(p+2) << 8) | *(p+3))),q);
            SetPixelChannels(image,q);
            p+=bytes_per_pixel;
            q+=GetPixelChannels(image);
          }
          if (planar_configuration == PLANARCONFIG_SEPARATE)
            p=tile_data+(offset+(y+1)*tile_image_size);
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
        }
      }
      if (image->previous == (Image *) NULL)
        {
          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
            image->rows);
          if (status == MagickFalse)
            break;
        }
    }
    tile_data=(unsigned char *) RelinquishMagickMemory(tile_data);
    break;
  }
case ReadGenericMethod:
default:
  {
    /*
      Convert TIFF image to DirectClass MIFF image.
    */
    if ((photometric == PHOTOMETRIC_YCBCR) ||
        (photometric == PHOTOMETRIC_CIELAB))
      {
        /*
          TIFF YCbCr or Lab image: convert to RGB.
        */
        (void) TIFFReadRGBAImageOriented(tiff,image->columns,image->rows,
          (uint32 *) pixels,ORIENTATION_TOPLEFT,exception);
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          Quantum
            *magick_restrict q;

          ssize_t
            x;

          unsigned int
            *p;

          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          p=(unsigned int *) pixels+(image->rows-y-1)*image->columns;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelRed(image,ScaleCharToQuantum(TIFFGetR(*p)),q);
            SetPixelGreen(image,ScaleCharToQuantum(TIFFGetG(*p)),q);
            SetPixelBlue(image,ScaleCharToQuantum(TIFFGetB(*p)),q);
            if (image->alpha_trait != UndefinedPixelTrait)
              SetPixelAlpha(image,ScaleCharToQuantum(TIFFGetA(*p)),q);
            SetPixelChannels(image,q);
            p++;
            q+=GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
        }
      }
    else
      {
        uint16_t
          planar_configuration;

        /*
          General handling of TIFFReadPixels.
        */
        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_PLANARCONFIG,
          &planar_configuration,sans);
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          Quantum
            *magick_restrict q;

          ssize_t
            x;

          unsigned char
            *p;

          tiff_status=TIFFReadPixels(tiff,0,y,(char *) pixels);
          if (tiff_status == -1)
            break;
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          p=pixels;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            for (i=0; i < (ssize_t) samples_per_pixel; i++)
            {
              ssize_t
                value;

              value=GetPixelChannelChannel(image,
                quantum_info->channel_map[i].channel,q);
              if (bits_per_sample <= 8)
                value=ScaleCharToQuantum(*p);
              else
                if (bits_per_sample == 16)
                  value=ScaleShortToQuantum((unsigned short) ((*p << 8) |
                    *(p+1)));
                else
                  value=ScaleLongToQuantum((unsigned int) ((*p << 24) |
                    (*(p+1) << 16) | (*(p+2) << 8) | *(p+3)));
              SetPixelChannel(image,quantum_info->channel_map[i].channel,
                value,q);
              p+=bytes_per_pixel;
            }
            SetPixelChannels(image,q);
            q+=GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
      }
    break;
  }