case ReadStripMethod:
{
  /*
    Convert TIFF image by processing each strip.
  */
  size_t
    strip_size;

  ssize_t
    y_start,
    y_end;

  unsigned char
    *strip_pixels;

  /*
    Allocate memory for a single strip.
  */
  strip_size=TIFFStripSize(tiff);
  if (strip_size <= 0)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  MemoryInfo
    *strip_info = AcquireVirtualMemory(strip_size,1);
  if (strip_info == (MemoryInfo *) NULL)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  strip_pixels=(unsigned char *) GetVirtualMemoryBlob(strip_info);

  for (y=0; y < (ssize_t) image->rows; y += rows_per_strip)
  {
    Quantum
      *magick_restrict q;

    ssize_t
      x;

    unsigned char
      *p;

    y_start=y;
    y_end=MagickMin((size_t) y+rows_per_strip, image->rows);
    tiff_status=TIFFReadEncodedStrip(tiff,(uint32) y,strip_pixels,strip_size);
    if (tiff_status == -1)
      break;

    for (ssize_t j = y_start; j < y_end; j++)
    {
      q=QueueAuthenticPixels(image,0,j,image->columns,1,exception);
      if (q == (Quantum *) NULL)
        break;

      p=strip_pixels + (j-y_start)*image->columns*samples_per_pixel*(bits_per_sample / 8);

      for (x=0; x < (ssize_t) image->columns; x++)
      {
        if (samples_per_pixel == 1)
        {
          SetPixelGray(image,ScaleCharToQuantum(*p),q);
        }
        else if (samples_per_pixel == 3)
        {
          SetPixelRed(image,ScaleCharToQuantum(*(p+2)),q);
          SetPixelGreen(image,ScaleCharToQuantum(*(p+1)),q);
          SetPixelBlue(image,ScaleCharToQuantum(*(p+0)),q);
        }
        else if (samples_per_pixel == 4 && image->alpha_trait != UndefinedPixelTrait)
        {
          SetPixelRed(image,ScaleCharToQuantum(*(p+3)),q);
          SetPixelGreen(image,ScaleCharToQuantum(*(p+2)),q);
          SetPixelBlue(image,ScaleCharToQuantum(*(p+1)),q);
          SetPixelAlpha(image,ScaleCharToQuantum(*(p+0)),q);
        }
        q+=GetPixelChannels(image);
        p+=samples_per_pixel*(bits_per_sample / 8);
      }

      if (SyncAuthenticPixels(image,exception) == MagickFalse)
        break;

      if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) j,
          image->rows);
        if (status == MagickFalse)
          break;
      }
    }
  }
  RelinquishVirtualMemory(strip_info);
  break;
}
case ReadTileMethod:
{
  /*
    Convert TIFF image by processing each tile.
  */
  uint32
    tile_width,
    tile_height;

  size_t
    tile_size;

  ssize_t
    x_start,
    x_end,
    y_start,
    y_end;

  unsigned char
    *tile_pixels;

  /* Get tile dimensions */
  if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&tile_width) != 1) ||
      (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&tile_height) != 1))
    ThrowTIFFException(CorruptImageError,"ImproperImageHeader");

  /*
    Allocate memory for a single tile.
  */
  tile_size=TIFFTileSize(tiff);
  if (tile_size <= 0)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  MemoryInfo
    *tile_info = AcquireVirtualMemory(tile_size,1);
  if (tile_info == (MemoryInfo *) NULL)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  tile_pixels=(unsigned char *) GetVirtualMemoryBlob(tile_info);

  for (y=0; y < (ssize_t) image->rows; y += (ssize_t) tile_height)
  {
    y_start=y;
    y_end=MagickMin((size_t) y+tile_height, image->rows);

    for (ssize_t x=0; x < (ssize_t) image->columns; x += (ssize_t) tile_width)
    {
      x_start=x;
      x_end=MagickMin((size_t) x+tile_width, image->columns);

      tiff_status=TIFFReadEncodedTile(tiff,(ttile_t)((y/tile_height)*(image->columns/tile_width)+(x/tile_width)),
                                      tile_pixels,tile_size);
      if (tiff_status == -1)
        break;

      for (ssize_t j = y_start; j < y_end; j++)
      {
        Quantum
          *magick_restrict q;

        ssize_t
          x_tile;

        unsigned char
          *p;

        q=QueueAuthenticPixels(image,x_start,j,x_end-x_start,1,exception);
        if (q == (Quantum *) NULL)
          break;

        p=tile_pixels + ((j-y_start)*tile_width+x-x_start)*samples_per_pixel*(bits_per_sample / 8);

        for (x_tile=0; x_tile < (ssize_t)(x_end-x_start); x_tile++)
        {
          if (samples_per_pixel == 1)
          {
            SetPixelGray(image,ScaleCharToQuantum(*p),q);
          }
          else if (samples_per_pixel == 3)
          {
            SetPixelRed(image,ScaleCharToQuantum(*(p+2)),q);
            SetPixelGreen(image,ScaleCharToQuantum(*(p+1)),q);
            SetPixelBlue(image,ScaleCharToQuantum(*(p+0)),q);
          }
          else if (samples_per_pixel == 4 && image->alpha_trait != UndefinedPixelTrait)
          {
            SetPixelRed(image,ScaleCharToQuantum(*(p+3)),q);
            SetPixelGreen(image,ScaleCharToQuantum(*(p+2)),q);
            SetPixelBlue(image,ScaleCharToQuantum(*(p+1)),q);
            SetPixelAlpha(image,ScaleCharToQuantum(*(p+0)),q);
          }
          q+=GetPixelChannels(image);
          p+=samples_per_pixel*(bits_per_sample / 8);
        }

        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;

        if (image->previous == (Image *) NULL)
        {
          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) j,
            image->rows);
          if (status == MagickFalse)
            break;
        }
      }
    }
  }
  RelinquishVirtualMemory(tile_info);
  break;
}
case ReadGenericMethod:
default:
{
  /*
    Convert entire TIFF image using TIFFReadRGBAImage.
  */
  unsigned char
    *rgba_buffer;

  MemoryInfo
    *buffer_info;

  buffer_info=AcquireVirtualMemory(image->columns*image->rows,
    sizeof(uint32));
  if (buffer_info == (MemoryInfo *) NULL)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  rgba_buffer=(unsigned char *) GetVirtualMemoryBlob(buffer_info);

  if (TIFFReadRGBAImage(tiff,image->columns,image->rows,(uint32 *) rgba_buffer,
    samples_per_pixel > 1 ? TIFF_RGB_SCALE : TIFF_GRAY_SCALE) != 1)
    ThrowTIFFException(CorruptImageError,"UnableToReadImageData");

  for (y=0; y < (ssize_t) image->rows; y++)
  {
    Quantum
      *magick_restrict q;

    ssize_t
      x;

    const uint32
      *magick_restrict r;

    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
    if (q == (Quantum *) NULL)
      break;
    r=(const uint32 *) (rgba_buffer+(image->columns*(image->rows-1-y)));
    for (x=0; x < (ssize_t) image->columns; x++)
    {
      if (samples_per_pixel == 1)
      {
        SetPixelGray(image,ScaleQuantumToChar((Quantum) TIFFGetR(*r)),q);
      }
      else if (samples_per_pixel == 3)
      {
        SetPixelRed(image,ScaleQuantumToChar((Quantum) TIFFGetR(*r)),q);
        SetPixelGreen(image,ScaleQuantumToChar((Quantum) TIFFGetG(*r)),q);
        SetPixelBlue(image,ScaleQuantumToChar((Quantum) TIFFGetB(*r)),q);
      }
      else if (samples_per_pixel == 4 && image->alpha_trait != UndefinedPixelTrait)
      {
        SetPixelRed(image,ScaleQuantumToChar((Quantum) TIFFGetR(*r)),q);
        SetPixelGreen(image,ScaleQuantumToChar((Quantum) TIFFGetG(*r)),q);
        SetPixelBlue(image,ScaleQuantumToChar((Quantum) TIFFGetB(*r)),q);
        SetPixelAlpha(image,ScaleQuantumToChar((Quantum) TIFFGetA(*r)),q);
      }
      r++;
      q+=GetPixelChannels(image);
    }
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    if (image->previous == (Image *) NULL)
    {
      status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
        image->rows);
      if (status == MagickFalse)
        break;
    }
  }
  RelinquishVirtualMemory(buffer_info);
  break;
}