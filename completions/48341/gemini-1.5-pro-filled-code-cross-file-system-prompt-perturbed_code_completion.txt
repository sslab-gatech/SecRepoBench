case ReadStripMethod:
      {
        size_t
          number_pixels;

        /*
          Convert stripped TIFF image.
        */
        if (planar_configuration == PLANARCONFIG_SEPARATE)
          for (i=0; i < (ssize_t) samples_per_pixel; i++)
          {
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              Quantum
                *magick_restrict q;

              tiff_status=TIFFReadScanline(tiff,(char *) pixels,y,i);
              if (tiff_status == -1)
                break;
              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
              if (q == (Quantum *) NULL)
                break;
              number_pixels=ImportQuantumPixels(image,(CacheView *) NULL,
                quantum_info,quantum_type,pixels,exception);
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
              if (image->previous == (Image *) NULL)
                {
                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                    y,image->rows);
                  if (status == MagickFalse)
                    break;
                }
            }
            if (status == MagickFalse)
              break;
          }
        else
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            Quantum
              *magick_restrict q;

            tiff_status=TIFFReadScanline(tiff,(char *) pixels,y,0);
            if (tiff_status == -1)
              break;
            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
            if (q == (Quantum *) NULL)
              break;
            number_pixels=ImportQuantumPixels(image,(CacheView *) NULL,
              quantum_info,quantum_type,pixels,exception);
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                  image->rows);
                if (status == MagickFalse)
                  break;
              }
          }
        break;
      }
      case ReadTileMethod:
      {
        size_t
          number_pixels;

        unsigned char
          *p;

        /*
          Convert tiled TIFF image.
        */
        if (planar_configuration == PLANARCONFIG_SEPARATE)
          for (i=0; i < (ssize_t) samples_per_pixel; i++)
          {
            for (y=0; y < (ssize_t) image->rows; y+=rows_per_strip)
            {
              Quantum
                *magick_restrict q;

              size_t
                rows_remaining;

              rows_remaining=image->rows-y;
              if (rows_remaining > rows_per_strip)
                rows_remaining=rows_per_strip;
              for (x=0; x < (ssize_t) image->columns; x+=scanline_size)
              {
                size_t
                  columns_remaining;

                columns_remaining=image->columns-x;
                if (columns_remaining > scanline_size)
                  columns_remaining=scanline_size;
                tiff_status=TIFFReadTile(tiff,(char *) pixels,x,y,0,i);
                if (tiff_status == -1)
                  break;
                p=pixels;
                for (j=0; j < (ssize_t) rows_remaining; j++)
                {
                  q=QueueAuthenticPixels(image,x,y+j,columns_remaining,1,
                    exception);
                  if (q == (Quantum *) NULL)
                    break;
                  number_pixels=ImportQuantumPixels(image,(CacheView *) NULL,
                    quantum_info,quantum_type,p,exception);
                  p+=scanline_size;
                  if (SyncAuthenticPixels(image,exception) == MagickFalse)
                    break;
                }
              }
              if (status == MagickFalse)
                break;
            }
            if (status == MagickFalse)
              break;
          }
        else
          for (y=0; y < (ssize_t) image->rows; y+=rows_per_strip)
          {
            Quantum
              *magick_restrict q;

            size_t
              rows_remaining;

            rows_remaining=image->rows-y;
            if (rows_remaining > rows_per_strip)
              rows_remaining=rows_per_strip;
            for (x=0; x < (ssize_t) image->columns; x+=scanline_size)
            {
              size_t
                columns_remaining;

              p=pixels;
              columns_remaining=image->columns-x;
              if (columns_remaining > scanline_size)
                columns_remaining=scanline_size;
              tiff_status=TIFFReadTile(tiff,(char *) pixels,x,y,0,0);
              if (tiff_status == -1)
                break;
              for (j=0; j < (ssize_t) rows_remaining; j++)
              {
                q=QueueAuthenticPixels(image,x,y+j,columns_remaining,1,
                  exception);
                if (q == (Quantum *) NULL)
                  break;
                number_pixels=ImportQuantumPixels(image,(CacheView *) NULL,
                  quantum_info,quantum_type,p,exception);
                p+=scanline_size;
                if (SyncAuthenticPixels(image,exception) == MagickFalse)
                  break;
              }
            }
            if (status == MagickFalse)
              break;
          }
        break;
      }
      case ReadGenericMethod:
      default:
      {
        status=TIFFReadRGBAImage(tiff,image,pixels,exception);
        break;
      }