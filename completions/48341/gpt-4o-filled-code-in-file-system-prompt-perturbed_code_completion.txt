case ReadStripMethod:
      {
        /*
          Convert stripped TIFF image.
        */
        for (i=0; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)
        {
          tmsize_t
            strip_size;

          strip_size=TIFFReadEncodedStrip(tiff,(tstrip_t) i,pixels,
            (tsize_t) -1);
          if (strip_size < 0)
            break;
          for (y=0; y < (ssize_t) rows_per_strip; y++)
          {
            Quantum
              *magick_restrict q;

            ssize_t
              x;

            q=QueueAuthenticPixels(image,0,(ssize_t) (i*rows_per_strip+y),
              image->columns,1,exception);
            if (q == (Quantum *) NULL)
              break;
            length=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
              quantum_type,pixels+y*scanline_size,exception);
            (void) length;
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
          }
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) i,
                TIFFNumberOfStrips(tiff));
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case ReadTileMethod:
      {
        /*
          Convert tiled TIFF image.
        */
        uint32
          columns,
          rows;

        tmsize_t
          tile_size;

        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||
            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))
          ThrowTIFFException(CoderError,"ImageIsNotTiled");
        tile_size=TIFFTileSize(tiff);
        for (y=0; y < (ssize_t) image->rows; y+=rows)
        {
          for (x=0; x < (ssize_t) image->columns; x+=columns)
          {
            tiff_status=TIFFReadTile(tiff,pixels,(uint32) x,(uint32) y,0,0);
            if (tiff_status < 0)
              break;
            for (i=0; i < (ssize_t) rows; i++)
            {
              Quantum
                *magick_restrict q;

              ssize_t
                x_offset;

              q=QueueAuthenticPixels(image,x,(ssize_t) (y+i),columns,1,
                exception);
              if (q == (Quantum *) NULL)
                break;
              x_offset=(ssize_t) (i*columns*TIFFScanlineSize(tiff)/tile_size);
              length=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
                quantum_type,pixels+x_offset,exception);
              (void) length;
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
            }
          }
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case ReadGenericMethod:
      default:
      {
        /*
          Convert entire image.
        */
        if (TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32) image->rows,
            (uint32 *) pixels,0) == 0)
          ThrowTIFFException(CorruptImageError,"UnableToReadImageData");
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          Quantum
            *magick_restrict q;

          ssize_t
            x;

          q=QueueAuthenticPixels(image,0,(ssize_t) (image->rows-y-1),
            image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelRed(image,ScaleCharToQuantum((unsigned char)
              TIFFGetR(pixels[y*image->columns+x])),q);
            SetPixelGreen(image,ScaleCharToQuantum((unsigned char)
              TIFFGetG(pixels[y*image->columns+x])),q);
            SetPixelBlue(image,ScaleCharToQuantum((unsigned char)
              TIFFGetB(pixels[y*image->columns+x])),q);
            SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)
              TIFFGetA(pixels[y*image->columns+x])),q);
            q+=GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }