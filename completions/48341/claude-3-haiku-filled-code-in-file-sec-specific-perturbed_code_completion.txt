switch (method)
{
  case ReadStripMethod:
  {
    /*
      Read image data by processing each strip of the TIFF file.
    */
    for (y=0; y < (ssize_t) image->rows; y++)
    {
      Quantum
        *magick_restrict q;

      ssize_t
        x;

      tiff_status=TIFFReadScanline(tiff,pixels,(uint32) y,0);
      if (tiff_status == -1)
        break;
      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
      if (q == (Quantum *) NULL)
        break;
      for (x=0; x < (ssize_t) image->columns; x++)
      {
        SetPixelRed(image,ScaleShortToQuantum(((unsigned short *) pixels)[x*
          samples_per_pixel]),q);
        SetPixelGreen(image,ScaleShortToQuantum(((unsigned short *) pixels)[x*
          samples_per_pixel+1]),q);
        SetPixelBlue(image,ScaleShortToQuantum(((unsigned short *) pixels)[x*
          samples_per_pixel+2]),q);
        if (image->alpha_trait != UndefinedPixelTrait)
          SetPixelAlpha(image,ScaleShortToQuantum(((unsigned short *) pixels)[x*
            samples_per_pixel+3]),q);
        q+=GetPixelChannels(image);
      }
      if (SyncAuthenticPixels(image,exception) == MagickFalse)
        break;
      if (image->previous == (Image *) NULL)
        {
          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
            image->rows);
          if (status == MagickFalse)
            break;
        }
    }
    break;
  }
  case ReadTileMethod:
  {
    /*
      Read image data by processing each tile of the TIFF file.
    */
    for (y=0; y < (ssize_t) image->rows; y+=tiff_info.tile_geometry.height)
    {
      for (x=0; x < (ssize_t) image->columns; x+=tiff_info.tile_geometry.width)
      {
        Quantum
          *magick_restrict q;

        tiff_status=TIFFReadTile(tiff,tiff_info.pixels,x,y,0,0);
        if (tiff_status == -1)
          break;
        q=GetAuthenticPixels(image,x,y,MagickMin(tiff_info.tile_geometry.width,
          image->columns-x),MagickMin(tiff_info.tile_geometry.height,
          image->rows-y),exception);
        if (q == (Quantum *) NULL)
          break;
        length=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
          quantum_type,tiff_info.pixels,exception);
        (void) length;
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
        if (image->previous == (Image *) NULL)
          {
            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
              (y*image->columns+x),image->columns*image->rows);
            if (status == MagickFalse)
              break;
          }
      }
    }
    break;
  }
  case ReadGenericMethod:
  default:
  {
    /*
      Read image data using the TIFFReadRGBAImage function.
    */
    if (TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32) image->rows,
        (uint32 *) pixels,0) == 0)
      ThrowTIFFException(CorruptImageError,"InsufficientImageDataInFile");
    for (y=0; y < (ssize_t) image->rows; y++)
    {
      Quantum
        *magick_restrict q;

      q=QueueAuthenticPixels(image,0,image->rows-y-1,image->columns,1,
        exception);
      if (q == (Quantum *) NULL)
        break;
      for (x=0; x < (ssize_t) image->columns; x++)
      {
        SetPixelRed(image,ScaleCharToQuantum((unsigned char)
          (pixels[(y*image->columns)+x])),q);
        SetPixelGreen(image,ScaleCharToQuantum((unsigned char)
          (pixels[(y*image->columns)+x]>>8)),q);
        SetPixelBlue(image,ScaleCharToQuantum((unsigned char)
          (pixels[(y*image->columns)+x]>>16)),q);
        SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)
          (pixels[(y*image->columns)+x]>>24)),q);
        q+=GetPixelChannels(image);
      }
      if (SyncAuthenticPixels(image,exception) == MagickFalse)
        break;
      if (image->previous == (Image *) NULL)
        {
          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
            image->rows);
          if (status == MagickFalse)
            break;
        }
    }
    break;
  }
}