// Handle the reading of TIFF image data based on the specified method.
    // For ReadStripMethod, read the image data by processing each strip of the TIFF file.
    // Allocate memory to store strip data and iterate through each sample per pixel.
    // Import the quantum pixels for each strip, updating the image's authentic pixels accordingly.
    // For ReadTileMethod, read the image data by processing each tile of the TIFF file.
    // Allocate memory to store tile data and iterate through each sample per pixel.
    // Import the quantum pixels for each tile, ensuring the image's authentic pixels are updated.
    // For ReadGenericMethod and default cases, read the image data using the TIFFReadRGBAImage function.
    // This method processes the entire image at once, assigning the pixel values to the image's authentic pixels.
    // For all methods, manage memory allocation and deallocation for the pixel data, ensuring efficient resource usage.
    // Ensure progress is tracked and updated, allowing for cancellation if needed.
    switch (method)
    {
      case ReadStripMethod:
      {
        // Allocate memory to store strip data and iterate through each sample per pixel.
        // Import the quantum pixels for each strip, updating the image's authentic pixels accordingly.
        for (y = 0; y < (ssize_t) image->rows; y++)
        {
          Quantum *magick_restrict q;
          ssize_t x;
          unsigned char *p;
          tiff_status = TIFFReadPixels(tiff, 0, y, (char *) pixels);
          if (tiff_status == -1)
            break;
          q = QueueAuthenticPixels(image, 0, y, image->columns, 1, exception);
          if (q == (Quantum *) NULL)
            break;
          p = pixels;
          for (x = 0; x < (ssize_t) image->columns; x++)
          {
            SetPixelCyan(image, ScaleCharToQuantum(ClampYCC((double) *p +
              (1.402 * (double) *(p + 2)) - 179.456)), q);
            SetPixelMagenta(image, ScaleCharToQuantum(ClampYCC((double) *p -
              (0.34414 * (double) *(p + 1)) - (0.71414 * (double) *(p + 2)) +
              135.45984)), q);
            SetPixelYellow(image, ScaleCharToQuantum(ClampYCC((double) *p +
              (1.772 * (double) *(p + 1)) - 226.816)), q);
            SetPixelBlack(image, ScaleCharToQuantum((unsigned char) *(p + 3)), q);
            q += GetPixelChannels(image);
            p += 4;
          }
          if (SyncAuthenticPixels(image, exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
          {
            status = SetImageProgress(image, LoadImageTag, (MagickOffsetType) y,
              image->rows);
            if (status == MagickFalse)
              break;
          }
        }
        break;
      }
      case ReadTileMethod:
      {
        // Allocate memory to store tile data and iterate through each sample per pixel.
        // Import the quantum pixels for each tile, ensuring the image's authentic pixels are updated.
        uint32 tile_width, tile_height;
        if ((TIFFGetField(tiff, TIFFTAG_TILEWIDTH, &tile_width) != 1) ||
            (TIFFGetField(tiff, TIFFTAG_TILELENGTH, &tile_height) != 1))
          ThrowTIFFException(CoderError, "ImageIsNotTiled");
        if ((AcquireMagickResource(WidthResource, tile_width) == MagickFalse) ||
            (AcquireMagickResource(HeightResource, tile_height) == MagickFalse))
          ThrowTIFFException(ImageError, "WidthOrHeightExceedsLimit");
        method = ReadTileMethod;
        break;
      }
      case ReadGenericMethod:
      case default:
      {
        // Read the image data using the TIFFReadRGBAImage function.
        // This method processes the entire image at once, assigning the pixel values to the image's authentic pixels.
        if (TIFFReadRGBAImage(tiff, image->columns, image->rows, (uint32 **) pixels, 0) == 0)
          ThrowTIFFException(CorruptImageError, "CorruptImage");
        for (y = 0; y < (ssize_t) image->rows; y++)
        {
          Quantum *magick_restrict q;
          ssize_t x;
          q = QueueAuthenticPixels(image, 0, y, image->columns, 1, exception);
          if (q == (Quantum *) NULL)
            break;
          for (x = 0; x < (ssize_t) image->columns; x++)
          {
            unsigned char *p = &pixels[y * image->columns * GetPixelChannels(image) + x * GetPixelChannels(image)];
            if (image->storage_class == PseudoClass)
            {
              if (image->alpha_trait != UndefinedPixelTrait)
              {
                if (image->storage_class == PseudoClass)
                  quantum_type = IndexAlphaQuantum;
                else
                  quantum_type = GrayAlphaQuantum;
              }
              else
                quantum_type = IndexQuantum;
            }
            SetPixelRed(image, ScaleCharToQuantum(p[0]), q);
            SetPixelGreen(image, ScaleCharToQuantum(p[1]), q);
            SetPixelBlue(image, ScaleCharToQuantum(p[2]), q);
            if (image->alpha_trait != UndefinedPixelTrait)
              SetPixelAlpha(image, ScaleCharToQuantum(p[3]), q);
            q += GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image, exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
          {
            status = SetImageProgress(image, LoadImageTag, (MagickOffsetType) y,
              image->rows);
            if (status == MagickFalse)
              break;
          }
        }
        break;
      }
    }