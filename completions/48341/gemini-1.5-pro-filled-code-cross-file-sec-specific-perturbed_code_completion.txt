case ReadStripMethod:
      {
        /*
          Convert stripped TIFF image.
        */
        i=0;
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          Quantum
            *magick_restrict q;

          tiff_status=TIFFReadScanline(tiff,(char *) pixels,y,0);
          if (tiff_status == -1)
            break;
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
            quantum_type,pixels,exception);
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
          i++;
        }
        break;
      }
      case ReadTileMethod:
      {
        uint32
          *tile_pixels,
          columns,
          rows;

        size_t
          number_pixels;

        /*
          Convert tiled TIFF image.
        */
        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||
            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))
          ThrowTIFFException(CoderError,"ImageIsNotTiled");
        number_pixels=(MagickSizeType) columns*rows;
        if (AcquireMagickResource(WidthResource,columns) == MagickFalse)
          ThrowTIFFException(ImageError,"WidthOrHeightExceedsLimit");
        if (AcquireMagickResource(HeightResource,rows) == MagickFalse)
          ThrowTIFFException(ImageError,"WidthOrHeightExceedsLimit");
        tile_pixels=(uint32 *) AcquireQuantumMemory(number_pixels,
          sizeof(*tile_pixels));
        if (tile_pixels == (uint32 *) NULL)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        for (y=0; y < (ssize_t) image->rows; y+=rows)
        {
          ssize_t
            x;

          size_t
            rows_remaining;

          rows_remaining=image->rows-y;
          if (rows_remaining < rows)
            if (AcquireMagickResource(HeightResource,rows_remaining) == MagickFalse)
              ThrowTIFFException(ImageError,"WidthOrHeightExceedsLimit");
          for (x=0; x < (ssize_t) image->columns; x+=columns)
          {
            size_t
              columns_remaining;

            columns_remaining=image->columns-x;
            if (columns_remaining < columns)
              if (AcquireMagickResource(WidthResource,columns_remaining) == MagickFalse)
                ThrowTIFFException(ImageError,"WidthOrHeightExceedsLimit");
            tiff_status=TIFFReadTile(tiff,(char *) tile_pixels,x,y,0,0);
            if (tiff_status == -1)
              break;
            (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
              quantum_type,(unsigned char *) tile_pixels,exception);
          }
          if (tiff_status == -1)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        tile_pixels=(uint32 *) RelinquishMagickMemory(tile_pixels);
        break;
      }
      case ReadGenericMethod:
      default:
      {
        status=TIFFReadRGBAImage(tiff,image,pixels,exception);
        break;
      }