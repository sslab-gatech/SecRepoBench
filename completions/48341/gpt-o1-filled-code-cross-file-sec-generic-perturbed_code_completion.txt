case ReadStripMethod:
      {
        /* Process each strip of the TIFF file. */
        uint32 number_strips=TIFFNumberOfStrips(tiff);
        uint32 rows_in_strip=0;
        uint32 row_offset=0;
        for (i=0; i < (ssize_t) number_strips; i++)
        {
          tsize_t strip_size=(tsize_t) TIFFStripSize(tiff);
          tmsize_t count=TIFFReadEncodedStrip(tiff,(tstrip_t)i,pixels,strip_size);
          if (count < 0)
            {
              tiff_status=-1;
              break;
            }
          rows_in_strip=(uint32) MagickMin(rows_per_strip,(uint32) (image->rows-row_offset));
          for (y=0; y < (ssize_t) rows_in_strip; y++)
          {
            Quantum *magick_restrict q=QueueAuthenticPixels(image,0,y+row_offset,
              image->columns,1,exception);
            if (q == (Quantum *) NULL)
              {
                tiff_status=-1;
                break;
              }
            if (ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
                quantum_type,pixels+(y*scanline_size),exception) == MagickFalse)
              {
                tiff_status=-1;
                break;
              }
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              {
                tiff_status=-1;
                break;
              }
          }
          if (tiff_status == -1)
            break;
          row_offset+=rows_in_strip;
          if (row_offset >= (uint32) image->rows)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) row_offset,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case ReadTileMethod:
      {
        /* Process each tile of the TIFF file. */
        uint32 tile_width, tile_height;
        TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&tile_width);
        TIFFGetField(tiff,TIFFTAG_TILELENGTH,&tile_height);
        for (uint32 tile_y=0; tile_y < (uint32) image->rows; tile_y+=tile_height)
        {
          for (uint32 tile_x=0; tile_x < (uint32) image->columns; tile_x+=tile_width)
          {
            tmsize_t count=TIFFReadTile(tiff,pixels,tile_x,tile_y,0,0);
            if (count < 0)
              {
                tiff_status=-1;
                break;
              }
            /* Import tile data into the image, row by row. */
            for (y=0; y < (ssize_t) tile_height; y++)
            {
              if ((tile_y+y) >= image->rows)
                break;
              Quantum *magick_restrict q=QueueAuthenticPixels(image,tile_x,tile_y+y,
                MagickMin(tile_width,(uint32) (image->columns - tile_x)),1,exception);
              if (q == (Quantum *) NULL)
                {
                  tiff_status=-1;
                  break;
                }
              if (ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
                  quantum_type,pixels+(y*(scanline_size)),exception) == MagickFalse)
                {
                  tiff_status=-1;
                  break;
                }
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                {
                  tiff_status=-1;
                  break;
                }
            }
            if (tiff_status == -1)
              break;
          }
          if (tiff_status == -1)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) tile_y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case ReadGenericMethod:
      default:
      {
        /* Read entire image using TIFFReadRGBAImage for RGBA data. */
        uint32 *raster=(uint32 *) AcquireQuantumMemory((size_t) image->columns,
          image->rows*sizeof(*raster));
        if (raster == (uint32 *) NULL)
          {
            tiff_status=-1;
            break;
          }
        if (TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32) image->rows,
            raster,0) == 0)
          {
            raster=(uint32 *) RelinquishMagickMemory(raster);
            tiff_status=-1;
            break;
          }
        /* Convert RGBA to image pixels row by row. */
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          Quantum *magick_restrict q=QueueAuthenticPixels(image,0,y,image->columns,
            1,exception);
          if (q == (Quantum *) NULL)
            {
              tiff_status=-1;
              break;
            }
          if (ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,quantum_type,
              (unsigned char *) (raster+(y*(ssize_t) image->columns)),exception)
              == MagickFalse)
            {
              tiff_status=-1;
              break;
            }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            {
              tiff_status=-1;
              break;
            }
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        raster=(uint32 *) RelinquishMagickMemory(raster);
        break;
      }