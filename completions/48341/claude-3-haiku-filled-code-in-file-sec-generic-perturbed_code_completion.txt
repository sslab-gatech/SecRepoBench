switch (method)
{
  case ReadStripMethod:
  {
    /*
      Read image data by processing each strip of the TIFF file.
    */
    for (y=0; y < (ssize_t) image->rows; y+=rows_per_strip)
    {
      Quantum
        *magick_restrict q;

      ssize_t
        i,
        j,
        strip_size;

      strip_size=MagickMin((ssize_t) rows_per_strip,(ssize_t) image->rows-y);
      tiff_status=TIFFReadScanline(tiff,pixels,(uint32) y,0);
      if (tiff_status == -1)
        break;
      q=QueueAuthenticPixels(image,0,y,image->columns,strip_size,exception);
      if (q == (Quantum *) NULL)
        break;
      for (i=0; i < strip_size; i++)
      {
        for (j=0; j < (ssize_t) image->columns; j++)
        {
          SetPixelRed(image,ScaleQuantumToChar(pixels[j]),q);
          SetPixelGreen(image,ScaleQuantumToChar(pixels[j+1]),q);
          SetPixelBlue(image,ScaleQuantumToChar(pixels[j+2]),q);
          if (image->alpha_trait != UndefinedPixelTrait)
            SetPixelAlpha(image,ScaleQuantumToChar(pixels[j+3]),q);
          q+=GetPixelChannels(image);
        }
        pixels+=image->columns*GetPixelChannels(image);
      }
      if (SyncAuthenticPixels(image,exception) == MagickFalse)
        break;
      if (image->previous == (Image *) NULL)
        {
          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
            image->rows);
          if (status == MagickFalse)
            break;
        }
    }
    break;
  }
  case ReadTileMethod:
  {
    /*
      Read image data by processing each tile of the TIFF file.
    */
    for (y=0; y < (ssize_t) image->rows; y+=tiff_info.tile_geometry.height)
    {
      Quantum
        *magick_restrict q;

      ssize_t
        i,
        j,
        tile_height;

      tile_height=MagickMin((ssize_t) tiff_info.tile_geometry.height,
        (ssize_t) image->rows-y);
      for (i=0; i < (ssize_t) tiff_info.tile_geometry.width;
           i+=tiff_info.tile_geometry.width)
      {
        tiff_status=TIFFReadTile(tiff,tiff_info.pixels,
          (uint32) i,(uint32) y,0,0);
        if (tiff_status == -1)
          break;
        q=QueueAuthenticPixels(image,i,y,
          MagickMin((ssize_t) tiff_info.tile_geometry.width,
          (ssize_t) image->columns-i),tile_height,exception);
        if (q == (Quantum *) NULL)
          break;
        for (j=0; j < tile_height; j++)
        {
          for (i=0; i < (ssize_t) tiff_info.tile_geometry.width; i++)
          {
            SetPixelRed(image,ScaleQuantumToChar(tiff_info.pixels[i]),q);
            SetPixelGreen(image,ScaleQuantumToChar(tiff_info.pixels[i+1]),q);
            SetPixelBlue(image,ScaleQuantumToChar(tiff_info.pixels[i+2]),q);
            if (image->alpha_trait != UndefinedPixelTrait)
              SetPixelAlpha(image,ScaleQuantumToChar(tiff_info.pixels[i+3]),q);
            q+=GetPixelChannels(image);
          }
          tiff_info.pixels+=TIFFTileRowSize(tiff);
        }
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
      }
      if (image->previous == (Image *) NULL)
        {
          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
            image->rows);
          if (status == MagickFalse)
            break;
        }
    }
    break;
  }
  case ReadGenericMethod:
  default:
  {
    /*
      Read image data using the TIFFReadRGBAImage function.
    */
    if (TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32) image->rows,
        (uint32 *) pixels,0) == 0)
      {
        ThrowTIFFException(CorruptImageError,"InsufficientImageDataInFile");
        break;
      }
    for (y=0; y < (ssize_t) image->rows; y++)
    {
      Quantum
        *magick_restrict q;

      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
      if (q == (Quantum *) NULL)
        break;
      for (x=0; x < (ssize_t) image->columns; x++)
      {
        SetPixelRed(image,ScaleCharToQuantum(TIFFGetR(pixels[x+(image->rows-y-1)*
          image->columns])),q);
        SetPixelGreen(image,ScaleCharToQuantum(TIFFGetG(pixels[x+(image->rows-y-1)*
          image->columns])),q);
        SetPixelBlue(image,ScaleCharToQuantum(TIFFGetB(pixels[x+(image->rows-y-1)*
          image->columns])),q);
        if (image->alpha_trait != UndefinedPixelTrait)
          SetPixelAlpha(image,ScaleCharToQuantum(TIFFGetA(pixels[x+(image->rows-y-1)*
            image->columns])),q);
        q+=GetPixelChannels(image);
      }
      if (SyncAuthenticPixels(image,exception) == MagickFalse)
        break;
      if (image->previous == (Image *) NULL)
        {
          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
            image->rows);
          if (status == MagickFalse)
            break;
        }
    }
    break;
  }
}