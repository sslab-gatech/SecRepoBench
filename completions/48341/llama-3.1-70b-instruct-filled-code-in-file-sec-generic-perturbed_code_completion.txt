case ReadStripMethod:
{
  /*
    Read TIFF image by processing each strip of the TIFF file.
  */
  size_t
    strip_size;

  ssize_t
    i,
    j;

  unsigned char
    *strip;

  strip_size=TIFFStripSize(tiff);
  strip=(unsigned char *) AcquireQuantumMemory((size_t) strip_size,
    sizeof(*strip));
  if (strip == (unsigned char *) NULL)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  for (i=0; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)
  {
    ssize_t
      count;

    count=(ssize_t) TIFFReadRawStrip(tiff,(uint32) i,strip,strip_size);
    if (count < 0)
      break;
    for (j=0; j < (ssize_t) count; j++)
      pixels[j]=strip[j];
    if (TIFFIsTiled(tiff)!= MagickFalse)
      {
        size_t
          bytes_per_pixel;

        bytes_per_pixel=TIFFTileSize(tiff)/(ssize_t) (
          tiff_info.tile_geometry.height*tiff_info.tile_geometry.width);
        for (j=0; j < (ssize_t) tiff_info.tile_geometry.height; j++)
        {
          size_t
            k;

          for (k=0; k < (ssize_t) tiff_info.tile_geometry.width; k++)
          {
            if (bytes_per_pixel == 0)
              {
                pixels[j*TIFFScanlineSize(tiff)+(k/8)]=(unsigned char) (
                  (strip[j*TIFFTileRowSize(tiff)+(k/8)] >> (7-(k % 8))) & 0x01);
                continue;
              }
            (void) memcpy(pixels+(j*TIFFScanlineSize(tiff)+(k*bytes_per_pixel)),
              strip+(j*TIFFTileRowSize(tiff)+(k*bytes_per_pixel)),
              (size_t) bytes_per_pixel);
          }
        }
      }
    if (TIFFIsTiled(tiff) == MagickFalse)
      {
        size_t
          bytes_per_pixel;

        bytes_per_pixel=TIFFScanlineSize(tiff)/(ssize_t) image->columns;
        for (j=0; j < (ssize_t) image->rows; j++)
        {
          size_t
            k;

          for (k=0; k < (ssize_t) image->columns; k++)
          {
            if (bytes_per_pixel == 0)
              {
                pixels[j*TIFFScanlineSize(tiff)+(k/8)]=(unsigned char) (
                  (strip[j*TIFFScanlineSize(tiff)+(k/8)] >> (7-(k % 8))) & 0x01);
                continue;
              }
            (void) memcpy(pixels+(j*TIFFScanlineSize(tiff)+(k*bytes_per_pixel)),
              strip+(j*TIFFScanlineSize(tiff)+(k*bytes_per_pixel)),
              (size_t) bytes_per_pixel);
          }
        }
      }
    if (TIFFIsTiled(tiff)!= MagickFalse)
      {
        size_t
          number_tiles,
          tile_width;

        number_tiles=(image->columns+tiff_info.tile_geometry.width)/
          tiff_info.tile_geometry.width;
        tile_width=(i == (ssize_t) (number_tiles-1))? image->columns-(i*
          tiff_info.tile_geometry.width) : tiff_info.tile_geometry.width;
        for (j=0; j < (ssize_t) ((i % tiff_info.tile_geometry.height)+1); j++)
        {
          size_t
            k;

          for (k=0; k < (ssize_t) tile_width; k++)
          {
            if (bytes_per_pixel == 0)
              {
                pixels[j*TIFFScanlineSize(tiff)+(i*tiff_info.tile_geometry.width+
                  k)/8]=(unsigned char) ((strip[j*TIFFTileRowSize(tiff)+(i*
                  tiff_info.tile_geometry.width+k)/8] >> (7-((i*
                  tiff_info.tile_geometry.width+k) % 8))) & 0x01);
                continue;
              }
            (void) memcpy(pixels+(j*TIFFScanlineSize(tiff)+(i*
              tiff_info.tile_geometry.width+k)*bytes_per_pixel),strip+(j*
              TIFFTileRowSize(tiff)+(i*tiff_info.tile_geometry.width+k)*
              bytes_per_pixel),(size_t) bytes_per_pixel);
          }
        }
      }
    if (TIFFIsTiled(tiff) == MagickFalse)
      {
        size_t
          bytes_per_pixel;

        bytes_per_pixel=TIFFScanlineSize(tiff)/(ssize_t) image->columns;
        for (j=0; j < (ssize_t) image->rows; j++)
        {
          size_t
            k;

          for (k=0; k < (ssize_t) image->columns; k++)
          {
            if (bytes_per_pixel == 0)
              {
                pixels[j*TIFFScanlineSize(tiff)+k/8]=(unsigned char) (
                  (strip[j*TIFFScanlineSize(tiff)+k/8] >> (7-(k % 8))) & 0x01);
                continue;
              }
            (void) memcpy(pixels+(j*TIFFScanlineSize(tiff)+k*bytes_per_pixel),
              strip+(j*TIFFScanlineSize(tiff)+k*bytes_per_pixel),
              (size_t) bytes_per_pixel);
          }
        }
      }
    if (TIFFIsTiled(tiff)!= MagickFalse)
      {
        size_t
          number_tiles,
          tile_width;

        number_tiles=(image->columns+tiff_info.tile_geometry.width)/
          tiff_info.tile_geometry.width;
        tile_width=(i == (ssize_t) (number_tiles-1))? image->columns-(i*
          tiff_info.tile_geometry.width) : tiff_info.tile_geometry.width;
        for (j=0; j < (ssize_t) ((i % tiff_info.tile_geometry.height)+1); j++)
        {
          size_t
            k;

          for (k=0; k < (ssize_t) tile_width; k++)
          {
            if (bytes_per_pixel == 0)
              {
                pixels[j*TIFFScanlineSize(tiff)+(i*tiff_info.tile_geometry.width+
                  k)/8]=(unsigned char) ((strip[j*TIFFTileRowSize(tiff)+(i*
                  tiff_info.tile_geometry.width+k)/8] >> (7-((i*
                  tiff_info.tile_geometry.width+k) % 8))) & 0x01);
                continue;
              }
            (void) memcpy(pixels+(j*TIFFScanlineSize(tiff)+(i*
              tiff_info.tile_geometry.width+k)*bytes_per_pixel),strip+(j*
              TIFFTileRowSize(tiff)+(i*tiff_info.tile_geometry.width+k)*
              bytes_per_pixel),(size_t) bytes_per_pixel);
          }
        }
      }
    if (TIFFIsTiled(tiff) == MagickFalse)
      {
        size_t
          bytes_per_pixel;

        bytes_per_pixel=TIFFScanlineSize(tiff)/(ssize_t) image->columns;
        for (j=0; j < (ssize_t) image->rows; j++)
        {
          size_t
            k;

          for (k=0; k < (ssize_t) image->columns; k++)
          {
            if (bytes_per_pixel == 0)
              {
                pixels[j*TIFFScanlineSize(tiff)+k/8]=(unsigned char) (
                  (strip[j*TIFFScanlineSize(tiff)+k/8] >> (7-(k % 8))) & 0x01);
                continue;
              }
            (void) memcpy(pixels+(j*TIFFScanlineSize(tiff)+k*bytes_per_pixel),
              strip+(j*TIFFScanlineSize(tiff)+k*bytes_per_pixel),
              (size_t) bytes_per_pixel);
          }
        }
      }
    if (TIFFIsTiled(tiff)!= MagickFalse)
      {
        size_t
          number_tiles,
          tile_width;

        number_tiles=(image->columns+tiff_info.tile_geometry.width)/
          tiff_info.tile_geometry.width;
        tile_width=(i == (ssize_t) (number_tiles-1))? image->columns-(i*
          tiff_info.tile_geometry.width) : tiff_info.tile_geometry.width;
        for (j=0; j < (ssize_t) ((i % tiff_info.tile_geometry.height)+1); j++)
        {
          size_t
            k;

          for (k=0; k < (ssize_t) tile_width; k++)
          {
            if (bytes_per_pixel == 0)
              {
                pixels[j*TIFFScanlineSize(tiff)+(i*tiff_info.tile_geometry.width+
                  k)/8]=(unsigned char) ((strip[j*TIFFTileRowSize(tiff)+(i*
                  tiff_info.tile_geometry.width+k)/8] >> (7-((i*
                  tiff_info.tile_geometry.width+k) % 8))) & 0x01);
                continue;
              }
            (void) memcpy(pixels+(j*TIFFScanlineSize(tiff)+(i*
              tiff_info.tile_geometry.width+k)*bytes_per_pixel),strip+(j*
              TIFFTileRowSize(tiff)+(i*tiff_info.tile_geometry.width+k)*
              bytes_per_pixel),(size_t) bytes_per_pixel);
          }
        }
      }
    if (TIFFIsTiled(tiff) == MagickFalse)
      {
        size_t
          bytes_per_pixel;

        bytes_per_pixel=TIFFScanlineSize(tiff)/(ssize_t) image->columns;
        for (j=0; j < (ssize_t) image->rows; j++)
        {
          size_t
            k;

          for (k=0; k < (ssize_t) image->columns; k++)
          {
            if (bytes_per_pixel == 0)
              {
                pixels[j*TIFFScanlineSize(tiff)+k/8]=(unsigned char) (
                  (strip[j*TIFFScanlineSize(tiff)+k/8] >> (7-(k % 8))) & 0x01);
                continue;
              }
            (void) memcpy(pixels+(j*TIFFScanlineSize(tiff)+k*bytes_per_pixel),
              strip+(j*TIFFScanlineSize(tiff)+k*bytes_per_pixel),
              (size_t) bytes_per_pixel);
          }
        }
      }
    if (TIFFIsTiled(tiff)!= MagickFalse)
      {
        size_t
          number_tiles,
          tile_width;

        number_tiles=(image->columns+tiff_info.tile_geometry.width)/
          tiff_info.tile_geometry.width;
        tile_width=(i == (ssize_t) (number_tiles-1))? image->columns-(i*
          tiff_info.tile_geometry.width) : tiff_info.tile_geometry.width;
        for (j=0; j < (ssize_t) ((i % tiff_info.tile_geometry.height)+1); j++)
        {
          size_t
            k;

          for (k=0; k < (ssize_t) tile_width; k++)
          {
            if (bytes_per_pixel == 0)
              {
                pixels[j*TIFFScanlineSize(tiff)+(i*tiff_info.tile_geometry.width+
                  k)/8]=(unsigned char) ((strip[j*TIFFTileRowSize(tiff)+(i*
                  tiff_info.tile_geometry.width+k)/8] >> (7-((i*
                  tiff_info.tile_geometry.width+k) % 8))) & 0x01);
                continue;
              }
            (void) memcpy(pixels+(j*TIFFScanlineSize(tiff)+(i*
              tiff_info.tile_geometry.width+k)*bytes_per_pixel),strip+(j*
              TIFFTileRowSize(tiff)+(i*tiff_info.tile_geometry.width+k)*
              bytes_per_pixel),(size_t) bytes_per_pixel);
          }
        }
      }
    if (TIFFIsTiled(tiff) == MagickFalse)
      {
        size_t
          bytes_per_pixel;

        bytes_per_pixel=TIFFScanlineSize(tiff)/(ssize_t) image->columns;
        for (j=0; j < (ssize_t) image->rows; j++)
        {
          size_t
            k;

          for (k=0; k < (ssize_t) image->columns; k++)
          {
            if (bytes_per_pixel == 0)
              {
                pixels[j*TIFFScanlineSize(tiff)+k/8]=(unsigned char) (
                  (strip[j*TIFFScanlineSize(tiff)+k/8] >> (7-(k % 8))) & 0x01);
                continue;
              }
            (void) memcpy(pixels+(j*TIFFScanlineSize(tiff)+k*bytes_per_pixel),
              strip+(j*TIFFScanlineSize(tiff)+k*bytes_per_pixel),
              (size_t) bytes_per_pixel);
          }
        }
      }
    if (TIFFIsTiled(tiff)!= MagickFalse)
      {
        size_t
          number_tiles,
          tile_width;

        number_tiles=(image->columns+tiff_info.tile_geometry.width)/
          tiff_info.tile_geometry.width;
        tile_width=(i == (ssize_t) (number_tiles-1))? image->columns-(i*
          tiff_info.tile_geometry.width) : tiff_info.tile_geometry.width;
        for (j=0; j < (ssize_t) ((i % tiff_info.tile_geometry.height)+1); j++)
        {
          size_t
            k;

          for (k=0; k < (ssize_t) tile_width; k++)
          {
            if (bytes_per_pixel == 0)
              {
                pixels[j*TIFFScanlineSize(tiff)+(i*tiff_info.tile_geometry.width+
                  k)/8]=(unsigned char) ((strip[j*TIFFTileRowSize(tiff)+(i*
                  tiff_info.tile_geometry.width+k)/8] >> (7-((i*
                  tiff_info.tile_geometry.width+k) % 8))) & 0x01);
                continue;
              }
            (void) memcpy(pixels+(j*TIFFScanlineSize(