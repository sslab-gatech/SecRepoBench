switch (method)
{
  case ReadStripMethod:
  {
    /*
      Read image data by processing each strip of the TIFF file.
    */
    for (y=0; y < (ssize_t) image->rows; y++)
    {
      Quantum
        *magick_restrict q;

      ssize_t
        x;

      tiff_status=TIFFReadScanline(tiff,tiff_info.scanline,(uint32) y,0);
      if (tiff_status == -1)
        break;
      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
      if (q == (Quantum *) NULL)
        break;
      for (x=0; x < (ssize_t) image->columns; x++)
      {
        SetPixelRed(image,ScaleShortToQuantum(tiff_info.scanline[x*samples_per_pixel]),q);
        SetPixelGreen(image,ScaleShortToQuantum(tiff_info.scanline[x*samples_per_pixel+1]),q);
        SetPixelBlue(image,ScaleShortToQuantum(tiff_info.scanline[x*samples_per_pixel+2]),q);
        if (image->alpha_trait != UndefinedPixelTrait)
          SetPixelAlpha(image,ScaleShortToQuantum(tiff_info.scanline[x*samples_per_pixel+
            (image->number_meta_channels != 0 ? image->number_meta_channels : 3)]),q);
        q+=GetPixelChannels(image);
      }
      if (SyncAuthenticPixels(image,exception) == MagickFalse)
        break;
      if (image->previous == (Image *) NULL)
        {
          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
            image->rows);
          if (status == MagickFalse)
            break;
        }
    }
    break;
  }
  case ReadTileMethod:
  {
    /*
      Read image data by processing each tile of the TIFF file.
    */
    for (y=0; y < (ssize_t) image->rows; y+=tiff_info.tile_geometry.height)
    {
      for (i=0; i < (ssize_t) ((image->columns+tiff_info.tile_geometry.width-1)/
           tiff_info.tile_geometry.width); i++)
      {
        Quantum
          *magick_restrict q;

        ssize_t
          x;

        tiff_status=TIFFReadTile(tiff,tiff_info.pixels,(uint32) (i*
          tiff_info.tile_geometry.width),(uint32) y,0,0);
        if (tiff_status == -1)
          break;
        q=QueueAuthenticPixels(image,i*tiff_info.tile_geometry.width,y,
          MagickMin(tiff_info.tile_geometry.width,(size_t) (image->columns-
          i*tiff_info.tile_geometry.width)),
          MagickMin(tiff_info.tile_geometry.height,(size_t) (image->rows-y)),
          exception);
        if (q == (Quantum *) NULL)
          break;
        for (x=0; x < (ssize_t) (tiff_info.tile_geometry.width*
             tiff_info.tile_geometry.height); x++)
        {
          SetPixelRed(image,ScaleShortToQuantum(tiff_info.pixels[x*samples_per_pixel]),q);
          SetPixelGreen(image,ScaleShortToQuantum(tiff_info.pixels[x*samples_per_pixel+1]),q);
          SetPixelBlue(image,ScaleShortToQuantum(tiff_info.pixels[x*samples_per_pixel+2]),q);
          if (image->alpha_trait != UndefinedPixelTrait)
            SetPixelAlpha(image,ScaleShortToQuantum(tiff_info.pixels[x*samples_per_pixel+
              (image->number_meta_channels != 0 ? image->number_meta_channels : 3)]),q);
          q+=GetPixelChannels(image);
        }
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
      }
      if (image->previous == (Image *) NULL)
        {
          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
            image->rows);
          if (status == MagickFalse)
            break;
        }
    }
    break;
  }
  case ReadGenericMethod:
  default:
  {
    /*
      Read image data using the TIFFReadRGBAImage function.
    */
    if (TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32) image->rows,
        (uint32 *) pixels,0) == 0)
      ThrowTIFFException(CorruptImageError,"InsufficientImageDataInFile");
    for (y=0; y < (ssize_t) image->rows; y++)
    {
      Quantum
        *magick_restrict q;

      ssize_t
        x;

      q=QueueAuthenticPixels(image,0,image->rows-y-1,image->columns,1,exception);
      if (q == (Quantum *) NULL)
        break;
      for (x=0; x < (ssize_t) image->columns; x++)
      {
        SetPixelRed(image,ScaleCharToQuantum(TIFFGetR(pixels[y*image->columns+x])),q);
        SetPixelGreen(image,ScaleCharToQuantum(TIFFGetG(pixels[y*image->columns+x])),q);
        SetPixelBlue(image,ScaleCharToQuantum(TIFFGetB(pixels[y*image->columns+x])),q);
        SetPixelAlpha(image,ScaleCharToQuantum(TIFFGetA(pixels[y*image->columns+x])),q);
        q+=GetPixelChannels(image);
      }
      if (SyncAuthenticPixels(image,exception) == MagickFalse)
        break;
      if (image->previous == (Image *) NULL)
        {
          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
            image->rows);
          if (status == MagickFalse)
            break;
        }
    }
    break;
  }
}