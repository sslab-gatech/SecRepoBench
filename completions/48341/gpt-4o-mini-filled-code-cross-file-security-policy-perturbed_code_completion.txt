case ReadStripMethod:
      {
        for (y = 0; y < (ssize_t) image->rows; y += rows_per_strip)
        {
          ssize_t strip_height = MagickMin(rows_per_strip, image->rows - y);
          tiff_status = TIFFReadScanline(tiff, pixels, y);
          if (tiff_status < 0)
            break;

          Quantum *q = QueueAuthenticPixels(image, 0, y, image->columns, strip_height, exception);
          if (q == (Quantum *) NULL)
            break;

          for (ssize_t x = 0; x < (ssize_t) image->columns; x++)
          {
            for (ssize_t s = 0; s < samples_per_pixel; s++)
            {
              SetPixelChannel(image, s, ScaleCharToQuantum(pixels[x * samples_per_pixel + s]), q);
            }
            q += GetPixelChannels(image);
          }

          if (SyncAuthenticPixels(image, exception) == MagickFalse)
            break;

          if (image->previous == (Image *) NULL)
          {
            status = SetImageProgress(image, LoadImageTag, (MagickOffsetType) y, image->rows);
            if (status == MagickFalse)
              break;
          }
        }
        break;
      }
      case ReadTileMethod:
      {
        uint32 tile_width, tile_height;
        if (TIFFGetField(tiff, TIFFTAG_TILEWIDTH, &tile_width) != 1 ||
            TIFFGetField(tiff, TIFFTAG_TILELENGTH, &tile_height) != 1)
          ThrowTIFFException(CoderError, "ImageIsNotTiled");

        for (y = 0; y < (ssize_t) image->rows; y += tile_height)
        {
          ssize_t tile_height_actual = MagickMin(tile_height, image->rows - y);
          for (ssize_t x = 0; x < (ssize_t) image->columns; x += tile_width)
          {
            tiff_status = TIFFReadTile(tiff, pixels, x, y, 0, 0);
            if (tiff_status < 0)
              break;

            Quantum *q = QueueAuthenticPixels(image, x, y, tile_width, tile_height_actual, exception);
            if (q == (Quantum *) NULL)
              break;

            for (ssize_t tx = 0; tx < tile_width; tx++)
            {
              for (ssize_t s = 0; s < samples_per_pixel; s++)
              {
                SetPixelChannel(image, s, ScaleCharToQuantum(pixels[tx * samples_per_pixel + s]), q);
              }
              q += GetPixelChannels(image);
            }

            if (SyncAuthenticPixels(image, exception) == MagickFalse)
              break;

            if (image->previous == (Image *) NULL)
            {
              status = SetImageProgress(image, LoadImageTag, (MagickOffsetType) y, image->rows);
              if (status == MagickFalse)
                break;
            }
          }
        }
        break;
      }
      default:
      {
        tiff_status = TIFFReadRGBAImage(tiff, image->columns, image->rows, (uint32 *) pixels, 0);
        if (tiff_status == 0)
          ThrowTIFFException(CorruptImageError, "UnableToReadImageData");

        Quantum *q = QueueAuthenticPixels(image, 0, 0, image->columns, image->rows, exception);
        if (q == (Quantum *) NULL)
          break;

        for (ssize_t y = 0; y < (ssize_t) image->rows; y++)
        {
          for (ssize_t x = 0; x < (ssize_t) image->columns; x++)
          {
            uint32 pixel = ((uint32 *) pixels)[y * image->columns + x];
            SetPixelRed(image, ScaleCharToQuantum((pixel >> 16) & 0xff), q);
            SetPixelGreen(image, ScaleCharToQuantum((pixel >> 8) & 0xff), q);
            SetPixelBlue(image, ScaleCharToQuantum(pixel & 0xff), q);
            SetPixelAlpha(image, ScaleCharToQuantum((pixel >> 24) & 0xff), q);
            q += GetPixelChannels(image);
          }
        }

        if (SyncAuthenticPixels(image, exception) == MagickFalse)
          break;

        if (image->previous == (Image *) NULL)
        {
          status = SetImageProgress(image, LoadImageTag, (MagickOffsetType) y, image->rows);
          if (status == MagickFalse)
            break;
        }
        break;
      }