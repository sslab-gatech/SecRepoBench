case ReadStripMethod:
      {
        for (y = 0; y < (ssize_t) image->rows; y += rows_per_strip)
        {
          ssize_t strip_height = MagickMin(rows_per_strip, image->rows - y);
          unsigned char *strip_pixels = (unsigned char *) AcquireQuantumMemory(strip_height * image->columns * samples_per_pixel, sizeof(unsigned char));
          if (strip_pixels == (unsigned char *) NULL)
            ThrowTIFFException(ResourceLimitError, "MemoryAllocationFailed");

          tiff_status = TIFFReadScanline(tiff, strip_pixels, y);
          if (tiff_status == -1)
          {
            strip_pixels = RelinquishMagickMemory(strip_pixels);
            break;
          }

          Quantum *q = QueueAuthenticPixels(image, 0, y, image->columns, strip_height, exception);
          if (q == (Quantum *) NULL)
          {
            strip_pixels = RelinquishMagickMemory(strip_pixels);
            break;
          }

          for (ssize_t x = 0; x < (ssize_t) image->columns; x++)
          {
            for (ssize_t s = 0; s < samples_per_pixel; s++)
            {
              q[x * samples_per_pixel + s] = ScaleCharToQuantum(strip_pixels[x * samples_per_pixel + s]);
            }
          }

          if (SyncAuthenticPixels(image, exception) == MagickFalse)
          {
            strip_pixels = RelinquishMagickMemory(strip_pixels);
            break;
          }

          strip_pixels = RelinquishMagickMemory(strip_pixels);
          if (image->previous == (Image *) NULL)
          {
            status = SetImageProgress(image, LoadImageTag, (MagickOffsetType) y, image->rows);
            if (status == MagickFalse)
              break;
          }
        }
        break;
      }
      case ReadTileMethod:
      {
        // Similar logic for reading tiles
        break;
      }
      default:
      {
        // Fallback for generic reading
        break;
      }