case ReadStripMethod:
{
  /*
    Read TIFF image as strips.
  */
  for (y=0; y < (ssize_t) image->rows; y+=rows_per_strip)
  {
    size_t
      length;

    tiff_status=TIFFReadEncodedStrip(tiff,(tstrip_t)(y/rows_per_strip),
      pixels,(tsize_t) TIFFStripSize(tiff));
    if (tiff_status == -1)
      break;
    length=(size_t) MagickMin((ssize_t) rows_per_strip,(ssize_t) image->rows-y);
    for (i=0; i < (ssize_t) length; i++)
    {
      Quantum
        *magick_restrict q;

      q=QueueAuthenticPixels(image,0,y+i,image->columns,1,exception);
      if (q == (Quantum *) NULL)
        break;
      (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
        quantum_type,pixels+(i*TIFFScanlineSize(tiff)),exception);
      if (SyncAuthenticPixels(image,exception) == MagickFalse)
        break;
    }
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  break;
}
case ReadTileMethod:
{
  /*
    Read TIFF image as tiles.
  */
  uint32
    tile_width,
    tile_height;

  if (TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&tile_width) != 1)
    ThrowTIFFException(CoderError,"ImageIsNotTiled");
  if (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&tile_height) != 1)
    ThrowTIFFException(CoderError,"ImageIsNotTiled");
  for (y=0; y < (ssize_t) image->rows; y+=tile_height)
  {
    for (x=0; x < (ssize_t) image->columns; x+=tile_width)
    {
      tiff_status=TIFFReadTile(tiff,pixels,(uint32) x,(uint32) y,0,0);
      if (tiff_status == -1)
        break;
      for (i=0; i < (ssize_t) tile_height; i++)
      {
        size_t
          length;

        Quantum
          *magick_restrict q;

        ssize_t
          offset;

        offset=(ssize_t) (i*TIFFTileRowSize(tiff));
        length=image->columns;
        if ((x+length) > image->columns)
          length=image->columns-x;
        length=MagickMin(tile_width,length);
        if ((y+i) >= image->rows)
          continue;
        q=QueueAuthenticPixels(image,x,y+i,length,1,exception);
        if (q == (Quantum *) NULL)
          break;
        (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
          quantum_type,pixels+offset,exception);
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
      }
    }
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  break;
}
case ReadGenericMethod:
default:
{
  /*
    Read TIFF image with TIFFReadRGBAImage.
  */
  uint32
    *p;

  if ((photometric == PHOTOMETRIC_PALETTE) &&
      (sample_format != SAMPLEFORMAT_UINT))
    ThrowTIFFException(CoderError,"UnsupportedSampleFormat");
  p=(uint32 *) pixels;
  tiff_status=TIFFReadRGBAImage(tiff,(uint32) image->columns,
    (uint32) image->rows,p,0);
  if (tiff_status == -1)
    break;
  /*
    Convert image to DirectClass MIFF format.
  */
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    Quantum
      *magick_restrict q;

    ssize_t
      x;

    p=(uint32 *) (pixels+((image->rows-y-1)*sizeof(uint32)*image->columns));
    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
    if (q == (Quantum *) NULL)
      break;
    for (x=0; x < (ssize_t) image->columns; x++)
    {
      SetPixelRed(image,ScaleCharToQuantum(TIFFGetR(*p)),q);
      SetPixelGreen(image,ScaleCharToQuantum(TIFFGetG(*p)),q);
      SetPixelBlue(image,ScaleCharToQuantum(TIFFGetB(*p)),q);
      if (image->alpha_trait != UndefinedPixelTrait)
        SetPixelAlpha(image,ScaleCharToQuantum(TIFFGetA(*p)),q);
      p++;
      q+=GetPixelChannels(image);
    }
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  break;
}