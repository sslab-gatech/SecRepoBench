if(flow->protos.tls_quic.browser_heuristics.is_safari_tls) {
  char str[64];
  char unknown_cipher[8];

  snprintf(str, sizeof(str), "Cipher %s", ndpi_cipher2str(ja.client.cipher[0], unknown_cipher));
  ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_WEAK_CIPHER, str);
}

flow->protos.tls_quic.server_cipher = ja.client.cipher[0];

offset += 2 + 1;

if((offset + 1) < packet->payload_packet_len) /* +1 because we are goint to read 2 bytes */
  tot_extension_len = ntohs(*((u_int16_t*)&packet->payload[offset]));
else
  tot_extension_len = 0;

offset += 2;

for(i=0; i<tot_extension_len; ) {
  u_int16_t extension_id;
  u_int32_t extension_len;

  if((offset+4) > packet->payload_packet_len) break;

  extension_id  = ntohs(*((u_int16_t*)&packet->payload[offset]));
  extension_len = ntohs(*((u_int16_t*)&packet->payload[offset+2]));
  if(offset+4+extension_len > packet->payload_packet_len) {
    break;
  }

  if(ja.client.num_tls_extensions < MAX_NUM_JA)
    ja.client.tls_extension[ja.client.num_tls_extensions++] = extension_id;

#ifdef DEBUG_TLS
  printf("[TLS] Extensions: found extension_id: %u/0x%04X][len: %u]\n",
         extension_id, extension_id, extension_len);
#endif
  checkExtensions(ndpi_struct, flow, is_dtls, extension_id, extension_len, offset + 4);

  if(extension_id == 43 /* supported versions */) {
    if(extension_len >= 2) {
      u_int16_t tls_version = ntohs(*((u_int16_t*)&packet->payload[offset+4]));

#ifdef DEBUG_TLS
      printf("[TLS] Extensions: [TLS version: 0x%04X]\n", tls_version);
#endif

      flow->protos.tls_quic.ssl_version = ja.client.tls_supported_version = tls_version;
    }
  } else if(extension_id == 16 /* application_layer_protocol_negotiation (ALPN) */ &&
            offset + 6 < packet->payload_packet_len) {
    u_int16_t sessoffset = offset+4;
    u_int16_t tot_alpn_len = ntohs(*((u_int16_t*)&packet->payload[sessoffset]));
    char alpn_str[256];
    u_int16_t alpn_str_len = 0, i;

#ifdef DEBUG_TLS
    printf("[TLS] Extensions: [ALPN: block_len=%u/len=%u]\n", extension_len, tot_alpn_len);
#endif
    sessoffset += 2;
    tot_alpn_len += sessoffset;

    if(tot_alpn_len > packet->payload_packet_len)
      return 0;

    while(sessoffset < tot_alpn_len && sessoffset < total_len) {
      u_int8_t alpn_i, alpn_len = packet->payload[sessoffset++];

      if((sessoffset + alpn_len) <= tot_alpn_len &&
         (sessoffset + alpn_len) <= total_len) {
#ifdef DEBUG_TLS
        printf("[TLS] Extensions: [ALPN: %u]\n", alpn_len);
#endif

        if(((uint32_t)alpn_str_len+alpn_len+1) < (sizeof(alpn_str)-1)) {
          if(alpn_str_len > 0) {
            alpn_str[alpn_str_len] = ',';
            alpn_str_len++;
          }

          for(alpn_i=0; alpn_i<alpn_len; alpn_i++)
            alpn_str[alpn_str_len+alpn_i] = packet->payload[sessoffset+alpn_i];

          sessoffset += alpn_len, alpn_str_len += alpn_len;;
        } else
          break;
      } else
        break;
    } /* while */

    alpn_str[alpn_str_len] = '\0';

#ifdef DEBUG_TLS
    printf("[TLS] Extensions: [ALPN: %s][len: %u]\n", alpn_str, alpn_str_len);
#endif
    if(ndpi_normalize_printable_string(alpn_str, alpn_str_len) == 0)
      ndpi_set_risk(ndpi_struct, flow, NDPI_INVALID_CHARACTERS, alpn_str);

    if(flow->protos.tls_quic.negotiated_alpn == NULL)
      flow->protos.tls_quic.negotiated_alpn = ndpi_strdup(alpn_str);

    /* Check ALPN only if not already checked (client-side) */
    if(flow->protos.tls_quic.negotiated_alpn != NULL &&
       flow->protos.tls_quic.advertised_alpns == NULL)
      tlsCheckUncommonALPN(ndpi_struct, flow, flow->protos.tls_quic.negotiated_alpn);

    alpn_str_len = ndpi_min(sizeof(ja.client.alpn), (size_t)alpn_str_len);
    memcpy(ja.client.alpn, alpn_str, alpn_str_len);
    if(alpn_str_len > 0)
      ja.client.alpn[alpn_str_len - 1] = '\0';

    /* Replace , with - as in JA3 */
    for(i=0; ja.client.alpn[i] != '\0'; i++)
      if(ja.client.alpn[i] == ',') ja.client.alpn[i] = '-';
  } else if(extension_id == 11 /* ec_point_formats groups */) {
    u_int16_t sessoffset = offset+4 + 1;

#ifdef DEBUG_TLS
    printf("[TLS] Extensions: [EllipticCurveFormat: len=%u]\n", extension_len);
#endif
    if((sessoffset+extension_len-1) <= total_len) {
      for(i=0; i<(u_int32_t)extension_len-1 && sessoffset+i < total_len; i++) {
        u_int8_t s_group = packet->payload[sessoffset+i];

#ifdef DEBUG_TLS
        printf("[TLS] Extensions: [EllipticCurveFormat: %u]\n", s_group);
#endif

        if(ja.client.num_elliptic_curve_point_format < MAX_NUM_JA)
          ja.client.elliptic_curve_point_format[ja.client.num_elliptic_curve_point_format++] = s_group;
        else {
          invalid_ja = 1;
#ifdef DEBUG_TLS
          printf("[TLS] Extensions: Invalid num elliptic %u\n", ja.client.num_elliptic_curve_point_format);
#endif
        }
      }
    } else {
      invalid_ja = 1;
#ifdef DEBUG_TLS
      printf("[TLS] Extensions: Invalid len %u vs %u\n", sessoffset+extension_len, total_len);
#endif
    }
  }

  i += 4 + extension_len, offset += 4 + extension_len;
} /* for */

if(!invalid_ja) {
  /* Compute JA3 client */
  int rc;

compute_ja3c:
  ja_str_len = ndpi_snprintf(ja_str, JA_STR_LEN, "%u,", ja.client.tls_handshake_version);

  for(i=0; i<ja.client.num_ciphers; i++) {
    rc = ndpi_snprintf(&ja_str[ja_str_len], JA_STR_LEN-ja_str_len, "%s%u",
                       (i > 0) ? "-" : "", ja.client.cipher[i]);
    if((rc > 0) && (ja_str_len + rc < JA_STR_LEN)) ja_str_len += rc; else break;
  }

  rc = ndpi_snprintf(&ja_str[ja_str_len], JA_STR_LEN-ja_str_len, ",");
  if((rc > 0) && (ja_str_len + rc < JA_STR_LEN)) ja_str_len += rc;

  /* ********** */

  for(i=0; i<ja.client.num_tls_extensions; i++) {
    rc = ndpi_snprintf(&ja_str[ja_str_len], JA_STR_LEN-ja_str_len, "%s%u",
                       (i > 0) ? "-" : "", ja.client.tls_extension[i]);
    if((rc > 0) && (ja_str_len + rc < JA_STR_LEN)) ja_str_len += rc; else break;
  }

  rc = ndpi_snprintf(&ja_str[ja_str_len], JA_STR_LEN-ja_str_len, ",");
  if((rc > 0) && (ja_str_len + rc < JA_STR_LEN)) ja_str_len += rc;

  /* ********** */

  for(i=0; i<ja.client.num_elliptic_curve; i++) {
    rc = ndpi_snprintf(&ja_str[ja_str_len], JA_STR_LEN-ja_str_len, "%s%u",
                       (i > 0) ? "-" : "", ja.client.elliptic_curve[i]);
    if((rc > 0) && (ja_str_len + rc < JA_STR_LEN)) ja_str_len += rc; else break;
  }

  rc = ndpi_snprintf(&ja_str[ja_str_len], JA_STR_LEN-ja_str_len, ",");
  if((rc > 0) && (ja_str_len + rc < JA_STR_LEN)) ja_str_len += rc;

  for(i=0; i<ja.client.num_elliptic_curve_point_format; i++) {
    rc = ndpi_snprintf(&ja_str[ja_str_len], JA_STR_LEN-ja_str_len, "%s%u",
                       (i > 0) ? "-" : "", ja.client.elliptic_curve_point_format[i]);
    if((rc > 0) && (ja_str_len + rc < JA_STR_LEN)) ja_str_len += rc; else break;
  }

  ndpi_MD5Init(&ctx);
  ndpi_MD5Update(&ctx, (const unsigned char *)ja_str, strlen(ja_str));
  ndpi_MD5Final(md5_hash, &ctx);

  for(i=0, j=0; i<16; i++) {
    int rc = ndpi_snprintf(&flow->protos.tls_quic.ja3_client[j],
                           sizeof(flow->protos.tls_quic.ja3_client)-j, "%02x",
                           md5_hash[i]);
    if(rc <= 0) break; else j += rc;
  }

#ifdef DEBUG_JA
  printf("[JA3] Client: %s \n", flow->protos.tls_quic.ja3_client);
#endif

  if(ndpi_struct->malicious_ja3_hashmap != NULL) {
    u_int16_t rc1 = ndpi_hash_find_entry(ndpi_struct->malicious_ja3_hashmap,
                                         flow->protos.tls_quic.ja3_client,
                                         NDPI_ARRAY_LENGTH(flow->protos.tls_quic.ja3_client) - 1,
                                         NULL);

    if(rc1 == 0)
      ndpi_set_risk(ndpi_struct, flow, NDPI_MALICIOUS_JA3, flow->protos.tls_quic.ja3_client);
  }

  ndpi_compute_ja4(ndpi_struct, flow, quic_version, &ja);
  /* End JA3/JA4 */
}

if((flow->protos.tls_quic.ssl_version >= 0x0303) /* >= TLSv1.2 */
   && (flow->protos.tls_quic.advertised_alpns == NULL) /* No ALPN */) {
  ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_NOT_CARRYING_HTTPS, "No ALPN");
}

if(flow->protos.tls_quic.encrypted_sni.esni &&
   flow->host_server_name[0] != '\0') {
  ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_SUSPICIOUS_ESNI_USAGE, "Found ESNI w/o SNI");
}

if(flow->host_server_name[0] == '\0'
   && (flow->protos.tls_quic.ssl_version >= 0x0302) /* TLSv1.1 */
   && (flow->protos.tls_quic.encrypted_sni.esni == NULL) /* No ESNI */) {
  /* This is a bit suspicious */
  ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_MISSING_SNI, NULL);

  if(flow->protos.tls_quic.advertised_alpns != NULL) {
    char buf[256], *tmp, *item;

    snprintf(buf, sizeof(buf), "%s", flow->protos.tls_quic.advertised_alpns);

    item = strtok_r(buf, ",", &tmp);

    while(item != NULL) {
      if(item[0] == 'h') {
        /* Example 'h2' */
        ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_ALPN_SNI_MISMATCH, NULL);
        break;
      } else
        item = strtok_r(NULL, ",", &tmp);
    }
  }
}

return(2 /* Client Certificate */);