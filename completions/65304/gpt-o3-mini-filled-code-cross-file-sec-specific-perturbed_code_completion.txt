{
  /* Securely extract signature algorithms into a temporary buffer */
  u_int16_t sig_algos[MAX_NUM_TLS_SIGNATURE_ALGORITHMS];
  size_t num_algos = 0;
  /* Ensure we do not exceed the packet buffer nor our fixed array size */
  for (i = 0; i < tot_signature_algorithms_len &&
       (sessoffset + i + 1) < packet->payload_packet_len; i += 2) {
    if (num_algos < MAX_NUM_TLS_SIGNATURE_ALGORITHMS) {
      sig_algos[num_algos++] = ntohs(*((u_int16_t *)&packet->payload[sessoffset + i]));
    } else {
      /* Exceeded our capacity; mark the JA as invalid and break out */
      invalid_ja = 1;
      break;
    }
  }

  /* Optionally, store the extracted signature algorithms into the dedicated structure */
  for (j = 0; j < num_algos; j++) {
    ja.client.signature_algorithms[j] = sig_algos[j];
  }
  ja.client.num_signature_algorithms = num_algos;

  /* Build a string representation (hex format) for logging or further processing */
  ja.client.signature_algorithms_str[0] = '\0';
  for (j = 0; j < num_algos; j++) {
    int rc = ndpi_snprintf(&ja.client.signature_algorithms_str[strlen(ja.client.signature_algorithms_str)],
                             sizeof(ja.client.signature_algorithms_str) - strlen(ja.client.signature_algorithms_str),
                             "%s0x%04X", (j > 0) ? "," : "", sig_algos[j]);
    if (rc <= 0)
      break;
  }
}