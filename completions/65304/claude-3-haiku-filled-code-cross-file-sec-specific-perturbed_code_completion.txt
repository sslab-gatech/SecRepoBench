// Extract the signature algorithms from the packet payload starting from the given offset.
// Calculate the number of signature algorithms and store it in the appropriate field.
// Optionally, copy the signature algorithms into a dedicated structure if a specific flag is enabled.
// Convert each signature algorithm to a string format and append it to a string buffer for logging or further processing.

u_int16_t tot_signature_algorithms_len = ntohs(*((u_int16_t*)&packet->payload[sessoffset]));
sessoffset += 2;
tot_signature_algorithms_len = ndpi_min((sizeof(ja.client.signature_algorithms_str) / 2) - 1, tot_signature_algorithms_len);

size_t sa_size = ndpi_min(tot_signature_algorithms_len / 2, MAX_NUM_TLS_SIGNATURE_ALGORITHMS);
ja.client.num_signature_algorithms = 0;

for(i=0; i<tot_signature_algorithms_len && sessoffset + (int)i + 2 < packet->payload_packet_len; i+=2) {
  u_int16_t signature_algo = (u_int16_t)ntohs(*((u_int16_t*)&packet->payload[sessoffset+i]));

  if(ja.client.num_signature_algorithms < sa_size) {
    ja.client.signature_algorithms[ja.client.num_signature_algorithms++] = signature_algo;

    int rc = ndpi_snprintf(&ja.client.signature_algorithms_str[i], sizeof(ja.client.signature_algorithms_str) - i, "%s%04X",
                           (i > 0) ? "-" : "", signature_algo);
    if(rc <= 0) break;
  } else {
    break;
  }
}

if(i > 0 && i >= tot_signature_algorithms_len) {
  ja.client.signature_algorithms_str[i*2 - 1] = '\0';
} else {
  ja.client.signature_algorithms_str[i*2] = '\0';
}