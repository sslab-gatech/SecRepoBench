Below is the content of a C/C++ function where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
static int node_from_openstep(parse_ctx parse_context, plist_t *plist)
{
    plist_t subnode = NULL;
    const char *p = NULL;
    while (parse_context->pos < parse_context->end && !parse_context->err) {
        parse_skip_ws(parse_context);
        if (parse_context->pos >= parse_context->end) {
            break;
        }
        plist_data_t data = plist_new_plist_data();
        if (*parse_context->pos == '{') {
            data->type = PLIST_DICT;
            subnode = plist_new_node(data);
            parse_context->pos++;
            parse_dict_data(parse_context, subnode);
            if (parse_context->err) {
                goto err_out;
            }
            if (parse_context->pos >= parse_context->end) {
                PLIST_OSTEP_ERR("EOF while parsing dictionary terminator '}' at offset %ld\n", parse_context->pos - parse_context->start);
                parse_context->err++;
                break;
            }
            if (*parse_context->pos != '}') {
                PLIST_OSTEP_ERR("Missing terminating '}' at offset %ld\n", parse_context->pos - parse_context->start);
                parse_context->err++;
                goto err_out;
            }
            parse_context->pos++;
            *plist = subnode;
            parse_skip_ws(parse_context);
            break;
        } else if (*parse_context->pos == '(') {
            data->type = PLIST_ARRAY;
            subnode = plist_new_node(data);
            parse_context->pos++;
            plist_t tmp = NULL;
            while (parse_context->pos < parse_context->end && !parse_context->err) {
                parse_skip_ws(parse_context);
                if (parse_context->pos >= parse_context->end || *parse_context->pos == ')') {
                    break;
                }
                parse_context->err = node_from_openstep(parse_context, &tmp);
                if (parse_context->err != 0) {
                    break;
                }
                if (!tmp) {
                    parse_context->err++;
                    break;
                }
                plist_array_append_item(subnode, tmp);
                tmp = NULL;
                parse_skip_ws(parse_context);
                if (parse_context->pos >= parse_context->end) {
                    PLIST_OSTEP_ERR("EOF while parsing array item delimiter ',' at offset %ld\n", parse_context->pos - parse_context->start);
                    parse_context->err++;
                    break;
                }
                if (*parse_context->pos != ',') {
                    break;
                }
                parse_context->pos++;
            }
	    plist_free(tmp);
	    tmp = NULL;
            if (parse_context->err) {
                goto err_out;
            }
            if (parse_context->pos >= parse_context->end) {
                PLIST_OSTEP_ERR("EOF while parsing array terminator ')' at offset %ld\n", parse_context->pos - parse_context->start);
                parse_context->err++;
                break;
            }
            if (*parse_context->pos != ')') {
                PLIST_OSTEP_ERR("Missing terminating ')' at offset %ld\n", parse_context->pos - parse_context->start);
                parse_context->err++;
                goto err_out;
            }
            parse_context->pos++;
            *plist = subnode;
            parse_skip_ws(parse_context);
            break;
        } else if (*parse_context->pos == '<') {
            data->type = PLIST_DATA;
            parse_context->pos++;
            bytearray_t *bytes = byte_array_new(256);
            while (parse_context->pos < parse_context->end && !parse_context->err) {
                parse_skip_ws(parse_context);
                if (parse_context->pos >= parse_context->end) {
                    PLIST_OSTEP_ERR("EOF while parsing data terminator '>' at offset %ld\n", parse_context->pos - parse_context->start);
                    parse_context->err++;
                    break;
                }
                if (*parse_context->pos == '>') {
                    break;
                }
                if (!isxdigit(*parse_context->pos)) {
                    PLIST_OSTEP_ERR("Invalid byte group in data at offset %ld\n", parse_context->pos - parse_context->start);
                    parse_context->err++;
                    break;
                }
                uint8_t b = HEX_DIGIT(*parse_context->pos);
                parse_context->pos++;
                if (parse_context->pos >= parse_context->end) {
                    PLIST_OSTEP_ERR("Unexpected end of data at offset %ld\n", parse_context->pos - parse_context->start);
                    parse_context->err++;
                    break;
                }
                if (!isxdigit(*parse_context->pos)) {
                    PLIST_OSTEP_ERR("Invalid byte group in data at offset %ld\n", parse_context->pos - parse_context->start);
                    parse_context->err++;
                    break;
                }
                b = (b << 4) + HEX_DIGIT(*parse_context->pos);
                byte_array_append(bytes, &b, 1);
                parse_context->pos++;
            }
            // Check for errors after parsing the data. 
            // If any errors are found, free the allocated byte array and plist data, and exit with an error.
            // If the terminator '>' is not found, free the allocated resources, log an error message, 
            // increment the error count, and exit with an error.
            // <MASK>
            parse_context->pos++;
            data->buff = bytes->data;
            data->length = bytes->len;
            bytes->data = NULL;
            byte_array_free(bytes);
            *plist = plist_new_node(data);
            parse_skip_ws(parse_context);
            break;
        } else if (*parse_context->pos == '"' || *parse_context->pos == '\'') {
            char c = *parse_context->pos;
            parse_context->pos++;
            p = parse_context->pos;
            int num_escapes = 0;
            while (parse_context->pos < parse_context->end) {
                if (*parse_context->pos == '\\') {
                    num_escapes++;
                }
                if ((*parse_context->pos == c) && (*(parse_context->pos-1) != '\\')) {
                    break;
                }
                parse_context->pos++;
            }
            if (parse_context->pos >= parse_context->end) {
                plist_free_data(data);
                PLIST_OSTEP_ERR("EOF while parsing quoted string at offset %ld\n", parse_context->pos - parse_context->start);
                parse_context->err++;
                goto err_out;
            }
            if (*parse_context->pos != c) {
                plist_free_data(data);
                PLIST_OSTEP_ERR("Missing closing quote (%c) at offset %ld\n", c, parse_context->pos - parse_context->start);
                parse_context->err++;
                goto err_out;
            }
            size_t slen = parse_context->pos - p;
            parse_context->pos++; // skip the closing quote
            char* strbuf = malloc(slen+1);
            if (num_escapes > 0) {
                size_t i = 0;
                size_t o = 0;
                while (i < slen) {
                    if (p[i] == '\\') {
                        /* handle escape sequence */
                        i++;
                        switch (p[i]) {
                            case '0':
                            case '1':
                            case '2':
                            case '3':
                            case '4':
                            case '5':
                            case '6':
                            case '7': {
                                // max 3 digits octal
                                unsigned char chr = 0;
                                int maxd = 3;
                                while ((i < slen) && (p[i] >= '0' && p[i] <= '7') && --maxd) {
                                    chr = (chr << 3) + p[i] - '0';
                                    i++;
                                }
                                strbuf[o++] = (char)chr;
                            }   break;
                            case 'U': {
                                i++;
                                // max 4 digits hex
                                uint16_t wchr = 0;
                                int maxd = 4;
                                while ((i < slen) && isxdigit(p[i]) && maxd--) {
                                    wchr = (wchr << 4) + ((p[i] <= '9') ? (p[i] - '0') : ((p[i] <= 'F') ? (p[i] - 'A' + 10) : (p[i] - 'a' + 10)));
                                    i++;
                                }
                                if (wchr >= 0x800) {
                                    strbuf[o++] = (char)(0xE0 + ((wchr >> 12) & 0xF));
                                    strbuf[o++] = (char)(0x80 + ((wchr >> 6) & 0x3F));
                                    strbuf[o++] = (char)(0x80 + (wchr & 0x3F));
                                } else if (wchr >= 0x80) {
                                    strbuf[o++] = (char)(0xC0 + ((wchr >> 6) & 0x1F));
                                    strbuf[o++] = (char)(0x80 + (wchr & 0x3F));
                                } else {
                                    strbuf[o++] = (char)(wchr & 0x7F);
                                }
                            }   break;
                            case 'a': strbuf[o++] = '\a'; i++; break;
                            case 'b': strbuf[o++] = '\b'; i++; break;
                            case 'f': strbuf[o++] = '\f'; i++; break;
                            case 'n': strbuf[o++] = '\n'; i++; break;
                            case 'r': strbuf[o++] = '\r'; i++; break;
                            case 't': strbuf[o++] = '\t'; i++; break;
                            case 'v': strbuf[o++] = '\v'; i++; break;
                            case '"': strbuf[o++] = '"';  i++; break;
                            case '\'': strbuf[o++] = '\''; i++; break;
                            default:
                                break;
                        }
                    } else {
                        strbuf[o++] = p[i++];
                    }
                }
                strbuf[o] = '\0';
                slen = o;
            } else {
                strncpy(strbuf, p, slen);
                strbuf[slen] = '\0';
            }
            data->type = PLIST_STRING;
            data->strval = strbuf;
            data->length = slen;
            *plist = plist_new_node(data);
            parse_skip_ws(parse_context);
            break;
        } else {
            // unquoted string
            size_t slen = 0;
            parse_skip_ws(parse_context);
            p = parse_context->pos;
            while (parse_context->pos < parse_context->end) {
                if (!allowed_unquoted_chars[(uint8_t)*parse_context->pos]) {
                    break;
                }
                parse_context->pos++;
            }
            slen = parse_context->pos-p;
            if (slen > 0) {
                data->type = PLIST_STRING;
                data->strval = strndup(p, slen);
                data->length = slen;
                *plist = plist_new_node(data);
                parse_skip_ws(parse_context);
                break;
            } else {
                plist_free_data(data);
                PLIST_OSTEP_ERR("Unexpected character when parsing unquoted string at offset %ld\n", parse_context->pos - parse_context->start);
                parse_context->err++;
                break;
            }
        }
        parse_context->pos++;
    }

err_out:
    if (parse_context->err) {
        plist_free(subnode);
        plist_free(*plist);
        *plist = NULL;
        return PLIST_ERR_PARSE;
    }
    return PLIST_ERR_SUCCESS;
}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/oplist.c
PLIST_API int plist_from_openstep(const char *plist_ostep, uint32_t length, plist_t * plist)
{
    if (!plist) {
        return PLIST_ERR_INVALID_ARG;
    }
    *plist = NULL;
    if (!plist_ostep || (length == 0)) {
        return PLIST_ERR_INVALID_ARG;
    }

    struct _parse_ctx ctx = { plist_ostep, plist_ostep, plist_ostep + length, 0 };

    int err = node_from_openstep(&ctx, plist);
    if (err == 0) {
        if (!*plist) {
            /* whitespace only file is considered an empty dictionary */
            *plist = plist_new_dict();
        } else if (ctx.pos < ctx.end && *ctx.pos == '=') {
            /* attempt to parse this as 'strings' data */
            plist_free(*plist);
            *plist = NULL;
            plist_t pl = plist_new_dict();
            ctx.pos = plist_ostep;
            parse_dict_data(&ctx, pl);
            if (ctx.err > 0) {
                plist_free(pl);
                PLIST_OSTEP_ERR("Failed to parse strings data\n");
                err = PLIST_ERR_PARSE;
            } else {
                *plist = pl;
            }
        }
    }

    return err;
}

// the below code fragment can be found in:
// src/xplist.c
static int unescape_entities(char *str, size_t *length)
{
    size_t i = 0;
    size_t len = *length;
    while (len > 0 && i < len-1) {
        if (str[i] == '&') {
            char *entp = str + i + 1;
            while (i < len && str[i] != ';') {
                i++;
            }
            if (i >= len) {
                PLIST_XML_ERR("Invalid entity sequence encountered (missing terminating ';')\n");
                return -1;
            }
            if (str+i >= entp+1) {
                int entlen = str+i - entp;
                int bytelen = 1;
                if (!strncmp(entp, "amp", 3)) {
                    /* the '&' is already there */
                } else if (!strncmp(entp, "apos", 4)) {
                    *(entp-1) = '\'';
                } else if (!strncmp(entp, "quot", 4)) {
                    *(entp-1) = '"';
                } else if (!strncmp(entp, "lt", 2)) {
                    *(entp-1) = '<';
                } else if (!strncmp(entp, "gt", 2)) {
                    *(entp-1) = '>';
                } else if (*entp == '#') {
                    /* numerical  character reference */
                    uint64_t val = 0;
                    char* ep = NULL;
                    if (entlen > 8) {
                        PLIST_XML_ERR("Invalid numerical character reference encountered, sequence too long: &%.*s;\n", entlen, entp);
                        return -1;
                    }
                    if (*(entp+1) == 'x' || *(entp+1) == 'X') {
                        if (entlen < 3) {
                            PLIST_XML_ERR("Invalid numerical character reference encountered, sequence too short: &%.*s;\n", entlen, entp);
                            return -1;
                        }
                        val = strtoull(entp+2, &ep, 16);
                    } else {
                        if (entlen < 2) {
                            PLIST_XML_ERR("Invalid numerical character reference encountered, sequence too short: &%.*s;\n", entlen, entp);
                            return -1;
                        }
                        val = strtoull(entp+1, &ep, 10);
                    }
                    if (val == 0 || val > 0x10FFFF || ep-entp != entlen) {
                        PLIST_XML_ERR("Invalid numerical character reference found: &%.*s;\n", entlen, entp);
                        return -1;
                    }
                    /* convert to UTF8 */
                    if (val >= 0x10000) {
                        /* four bytes */
                        *(entp-1) = (char)(0xF0 + ((val >> 18) & 0x7));
                        *(entp+0) = (char)(0x80 + ((val >> 12) & 0x3F));
                        *(entp+1) = (char)(0x80 + ((val >> 6) & 0x3F));
                        *(entp+2) = (char)(0x80 + (val & 0x3F));
                        entp+=3;
                        bytelen = 4;
                    } else if (val >= 0x800) {
                        /* three bytes */
                        *(entp-1) = (char)(0xE0 + ((val >> 12) & 0xF));
                        *(entp+0) = (char)(0x80 + ((val >> 6) & 0x3F));
                        *(entp+1) = (char)(0x80 + (val & 0x3F));
                        entp+=2;
                        bytelen = 3;
                    } else if (val >= 0x80) {
                        /* two bytes */
                        *(entp-1) = (char)(0xC0 + ((val >> 6) & 0x1F));
                        *(entp+0) = (char)(0x80 + (val & 0x3F));
                        entp++;
                        bytelen = 2;
                    } else {
                        /* one byte */
                        *(entp-1) = (char)(val & 0x7F);
                    }
                } else {
                    PLIST_XML_ERR("Invalid entity encountered: &%.*s;\n", entlen, entp);
                    return -1;
                }
                memmove(entp, str+i+1, len - i);
                i -= entlen+1 - bytelen;
                len -= entlen+2 - bytelen;
                continue;
            } else {
                PLIST_XML_ERR("Invalid empty entity sequence &;\n");
                return -1;
            }
        }
        i++;
    }
    *length = len;
    return 0;
}

// the below code fragment can be found in:
// src/xplist.c
PLIST_API plist_err_t plist_from_xml(const char *plist_xml, uint32_t length, plist_t * plist)
{
    if (!plist) {
        return PLIST_ERR_INVALID_ARG;
    }
    *plist = NULL;
    if (!plist_xml || (length == 0)) {
        return PLIST_ERR_INVALID_ARG;
    }

    struct _parse_ctx ctx = { plist_xml, plist_xml + length, 0 };

    return node_from_xml(&ctx, plist);
}

// the below code fragment can be found in:
// src/jsmn.c
jsmnerr_t jsmn_parse(jsmn_parser *parser, const char *js, unsigned int length, jsmntok_t *tokens,
		unsigned int num_tokens) {
	jsmnerr_t r;
	int i;
	jsmntok_t *token;

	parser->end = length;

	for (; (parser->end > 0 && parser->pos < parser->end) && js[parser->pos] != '\0'; parser->pos++) {
		char c;
		jsmntype_t type;

		c = js[parser->pos];
		switch (c) {
			case '{': case '[':
				token = jsmn_alloc_token(parser, tokens, num_tokens);
				if (token == NULL)
					return JSMN_ERROR_NOMEM;
				if (parser->toksuper != -1) {
					tokens[parser->toksuper].size++;
#ifdef JSMN_PARENT_LINKS
					token->parent = parser->toksuper;
#endif
				}
				token->type = (c == '{' ? JSMN_OBJECT : JSMN_ARRAY);
				token->start = parser->pos;
				parser->toksuper = parser->toknext - 1;
				break;
			case '}': case ']':
				type = (c == '}' ? JSMN_OBJECT : JSMN_ARRAY);
#ifdef JSMN_PARENT_LINKS
				if (parser->toknext < 1) {
					return JSMN_ERROR_INVAL;
				}
				token = &tokens[parser->toknext - 1];
				for (;;) {
					if (token->start != -1 && token->end == -1) {
						if (token->type != type) {
							return JSMN_ERROR_INVAL;
						}
						token->end = parser->pos + 1;
						parser->toksuper = token->parent;
						break;
					}
					if (token->parent == -1) {
						break;
					}
					token = &tokens[token->parent];
				}
#else
				for (i = parser->toknext - 1; i >= 0; i--) {
					token = &tokens[i];
					if (token->start != -1 && token->end == -1) {
						if (token->type != type) {
							return JSMN_ERROR_INVAL;
						}
						parser->toksuper = -1;
						token->end = parser->pos + 1;
						break;
					}
				}
				/* Error if unmatched closing bracket */
				if (i == -1) return JSMN_ERROR_INVAL;
				for (; i >= 0; i--) {
					token = &tokens[i];
					if (token->start != -1 && token->end == -1) {
						parser->toksuper = i;
						break;
					}
				}
#endif
				break;
			case '\"':
				r = jsmn_parse_string(parser, js, tokens, num_tokens);
				if (r < 0) return r;
				if (parser->toksuper != -1)
					tokens[parser->toksuper].size++;
				break;
			case '\t' : case '\r' : case '\n' : case ':' : case ',': case ' ':
				break;
#ifdef JSMN_STRICT
			/* In strict mode primitives are: numbers and booleans */
			case '-': case '0': case '1' : case '2': case '3' : case '4':
			case '5': case '6': case '7' : case '8': case '9':
			case 't': case 'f': case 'n' :
#else
			/* In non-strict mode every unquoted value is a primitive */
			default:
#endif
				r = jsmn_parse_primitive(parser, js, tokens, num_tokens);
				if (r < 0) return r;
				if (parser->toksuper != -1)
					tokens[parser->toksuper].size++;
				break;

#ifdef JSMN_STRICT
			/* Unexpected char in strict mode */
			default:
				return JSMN_ERROR_INVAL;
#endif

		}
	}

	for (i = parser->toknext - 1; i >= 0; i--) {
		/* Unmatched opened object or array */
		if (tokens[i].start != -1 && tokens[i].end == -1) {
			return JSMN_ERROR_PART;
		}
	}

	return JSMN_SUCCESS;
}

// the below code fragment can be found in:
// src/oplist.c
static void parse_dict_data(parse_ctx ctx, plist_t dict)
{
    plist_t key = NULL;
    plist_t val = NULL;
    while (ctx->pos < ctx->end && !ctx->err) {
        parse_skip_ws(ctx);
        if (ctx->pos >= ctx->end || *ctx->pos == '}') {
            break;
        }
        key = NULL;
        ctx->err = node_from_openstep(ctx, &key);
        if (ctx->err != 0) {
            break;
        }
        if (!PLIST_IS_STRING(key)) {
            PLIST_OSTEP_ERR("Invalid type for dictionary key at offset %ld\n", ctx->pos - ctx->start);
            ctx->err++;
            break;
        }
        parse_skip_ws(ctx);
        if (ctx->pos >= ctx->end) {
            PLIST_OSTEP_ERR("EOF while parsing dictionary '=' delimiter at offset %ld\n", ctx->pos - ctx->start);
            ctx->err++;
            break;
        }
        if (*ctx->pos != '=') {
            PLIST_OSTEP_ERR("Missing '=' while parsing dictionary item at offset %ld\n", ctx->pos - ctx->start);
            ctx->err++;
            break;
        }
        ctx->pos++;
        if (ctx->pos >= ctx->end) {
            PLIST_OSTEP_ERR("EOF while parsing dictionary item at offset %ld\n", ctx->pos - ctx->start);
            ctx->err++;
            break;
        }
        val = NULL;
        ctx->err = node_from_openstep(ctx, &val);
        if (ctx->err != 0) {
            break;
        }
        if (!val) {
            PLIST_OSTEP_ERR("Missing value for dictionary item at offset %ld\n", ctx->pos - ctx->start);
            ctx->err++;
            break;
        }
        parse_skip_ws(ctx);
        if (ctx->pos >= ctx->end) {
            PLIST_OSTEP_ERR("EOF while parsing dictionary item terminator ';' at offset %ld\n", ctx->pos - ctx->start);
            ctx->err++;
            break;
        }
        if (*ctx->pos != ';') {
            PLIST_OSTEP_ERR("Missing terminating ';' while parsing dictionary item at offset %ld\n", ctx->pos - ctx->start);
            ctx->err++;
            break;
        }

        plist_dict_set_item(dict, plist_get_string_ptr(key, NULL), val);
        plist_free(key);
        key = NULL;
        val = NULL;

        ctx->pos++;
    }
    plist_free(key);
    plist_free(val);
}
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).