_TYPE_ERROR, "non integer addition");
#else
    return mrb_float_value(mrb, mrb_as_float(mrb, x) + mrb_as_float(mrb, y));
#endif
  }
}

/* 15.2.8.3.1  */
/*
 * call-seq:
 *   int + numeric  ->  numeric_result
 *
 * Performs addition: the class of the resulting object depends on
 * the class of <code>numeric</code> and on the magnitude of the
 * result.
 */

static mrb_value
int_add(mrb_state *mrb, mrb_value x)
{
  mrb_value y = mrb_get_arg1(mrb);

#ifdef MRB_USE_BIGINT
  if (mrb_bigint_p(x)) {
    return mrb_bint_add(mrb, x, y);
  }
#endif
  return mrb_int_add(mrb, x, y);
}

mrb_value
mrb_int_sub(mrb_state *mrb, mrb_value x, mrb_value y)
{
  mrb_int a;

  a = mrb_integer(x);
  if (mrb_integer_p(y)) {
    mrb_int b, c;

    if (a == 0) return mrb_int_value(mrb, -mrb_integer(y));
    b = mrb_integer(y);
    if (b == 0) return x;
    if (mrb_int_sub_overflow(a, b, &c)) {
#ifdef MRB_USE_BIGINT
      x = mrb_bint_new_int(mrb, a);
      return mrb_bint_sub(mrb, x, y);
#else
      mrb_int_overflow(mrb, "subtraction");
#endif
    }
    return mrb_int_value(mrb, c);
  }
  switch (mrb_type(y)) {
#ifdef MRB_USE_BIGINT
  case MRB_TT_BIGINT:
    return mrb_bint_sub(mrb, x, y);
#endif
#ifdef MRB_USE_RATIONAL
  case MRB_TT_RATIONAL:
    return mrb_rational_sub(mrb, x, y);
#endif
#ifdef MRB_USE_COMPLEX
  case MRB_TT_COMPLEX:
    return mrb_complex_sub(mrb, x, y);
#endif
  default:
#ifdef MRB_NO_FLOAT
    mrb_raise(mrb, E_TYPE_ERROR, "non integer subtraction");
#else
    return mrb_float_value(mrb, mrb_as_float(mrb, x) - mrb_as_float(mrb, y));
#endif
  }
}

/* 15.2.8.3.2  */
/*
 * call-seq:
 *   int - numeric  ->  numeric_result
 *
 * Performs subtraction: the class of the resulting object depends on
 * the class of <code>numeric</code> and on the magnitude of the
 * result.
 */

static mrb_value
int_sub(mrb_state *mrb, mrb_value x)
{
  mrb_value y = mrb_get_arg1(mrb);

#ifdef MRB_USE_BIGINT
  if (mrb_bigint_p(x)) {
    return mrb_bint_sub(mrb, x, y);
  }
#endif
  return mrb_int_sub(mrb, x, y);
}

mrb_value
mrb_int_cmp(mrb_state *mrb, mrb_value x, mrb_value y)
{
  mrb_int a, b;

  a = mrb_integer(x);
  b = mrb_integer(y);
  if (a < b) return mrb_fixnum_value(-1);
  if (a > b) return mrb_fixnum_value(1);
  return mrb_fixnum_value(0);
}

/* 15.2.8.3.14 */
/*
 * call-seq:
 *   int <=> other  ->  integer
 *
 * Returns -1, 0, or 1 depending on whether <i>int</i> is less than,
 * equal to, or greater than <i>other</i>. This is the basis for
 * the methods <code><</code>, <code>==</code>, and <code>></code>,
 * which perform comparison.
 */

static mrb_value
int_cmp(mrb_state *mrb, mrb_value x)
{
  mrb_value y = mrb_get_arg1(mrb);

#ifdef MRB_USE_BIGINT
  if (mrb_bigint_p(x)) {
    return mrb_bint_cmp(mrb, x, y);
  }
#endif
  return mrb_int_cmp(mrb, x, y);
}

/* 15.2.8.3.15 */
/*
 * call-seq:
 *   int < other  ->  true or false
 *
 * Returns <code>true</code> if <i>int</i> is less than <i>other</i>.
 */

static mrb_value
int_lt(mrb_state *mrb, mrb_value x)
{
  mrb_value y = mrb_get_arg1(mrb);

#ifdef MRB_USE_BIGINT
  if (mrb_bigint_p(x)) {
    return mrb_bool_value(mrb_bint_cmp(mrb, x, y) < 0);
  }
#endif
  return mrb_bool_value(mrb_integer(x) < mrb_integer(y));
}

/* 15.2.8.3.16 */
/*
 * call-seq:
 *   int <= other  ->  true or false
 *
 * Returns <code>true</code> if <i>int</i> is less than or equal to
 * <i>other</i>.
 */

static mrb_value
int_le(mrb_state *mrb, mrb_value x)
{
  mrb_value y = mrb_get_arg1(mrb);

#ifdef MRB_USE_BIGINT
  if (mrb_bigint_p(x)) {
    return mrb_bool_value(mrb_bint_cmp(mrb, x, y) <= 0);
  }
#endif
  return mrb_bool_value(mrb_integer(x) <= mrb_integer(y));
}

/* 15.2.8.3.17 */
/*
 * call-seq:
 *   int > other  ->  true or false
 *
 * Returns <code>true</code> if <i>int</i> is greater than <i>other</i>.
 */

static mrb_value
int_gt(mrb_state *mrb, mrb_value x)
{
  mrb_value y = mrb_get_arg1(mrb);

#ifdef MRB_USE_BIGINT
  if (mrb_bigint_p(x)) {
    return mrb_bool_value(mrb_bint_cmp(mrb, x, y) > 0);
  }
#endif
  return mrb_bool_value(mrb_integer(x) > mrb_integer(y));
}

/* 15.2.8.3.18 */
/*
 * call-seq:
 *   int >= other  ->  true or false
 *
 * Returns <code>true</code> if <i>int</i> is greater than or equal to
 * <i>other</i>.
 */

static mrb_value
int_ge(mrb_state *mrb, mrb_value x)
{
  mrb_value y = mrb_get_arg1(mrb);

#ifdef MRB_USE_BIGINT
  if (mrb_bigint_p(x)) {
    return mrb_bool_value(mrb_bint_cmp(mrb, x, y) >= 0);
  }
#endif
  return mrb_bool_value(mrb_integer(x) >= mrb_integer(y));
}

/* 15.2.8.3.19 */
/*
 * call-seq:
 *   int.between?(min, max)  ->  true or false
 *
 * Returns <code>true</code> if <i>int</i> is greater than or equal to
 * <code>min</code> and less than or equal to <code>max</code>.
 */

static mrb_value
int_between(mrb_state *mrb, mrb_value x)
{
  mrb_value min, max;

  mrb_get_args(mrb, "oo", &min, &max);
  if (mrb_integer_p(min) && mrb_integer_p(max)) {
    mrb_int a = mrb_integer(x);
    mrb_int b = mrb_integer(min);
    mrb_int c = mrb_integer(max);

    return mrb_bool_value(b <= a && a <= c);
  }
  mrb_raise(mrb, E_ARGUMENT_ERROR, "wrong argument type");
}

/* 15.2.8.3.20 */
/*
 * call-seq:
 *   int.downto(limit) { |i| block }  ->  int
 *
 * Iterates the given block, passing decreasing values from <i>int</i>
 * to <i>limit</i>. Returns <i>int</i>.
 *
 *   5.downto(1) { |n| print n, " " }
 *
 * <em>produces:</em>
 *
 *    5 4 3 2 1
 */

static mrb_value
int_downto(mrb_state *mrb, mrb_value num)
{
  mrb_int limit, i;

  mrb_get_args(mrb, "i", &limit);
  i = mrb_integer(num);
  while (i >= limit) {
    mrb_yield(mrb, mrb_fixnum_value(i));
    i--;
  }
  return num;
}

/* 15.2.8.3.21 */
/*
 * call-seq:
 *   int.upto(limit) { |i| block }  ->  int
 *
 * Iterates the given block, passing increasing values from <i>int</i>
 * to <i>limit</i>. Returns <i>int</i>.
 *
 *   1.upto(5) { |n| print n, " " }
 *
 * <em>produces:</em>
 *
 *    1 2 3 4 5
 */

static mrb_value
int_upto(mrb_state *mrb, mrb_value num)
{
  mrb_int limit, i;

  mrb_get_args(mrb, "i", &limit);
  i = mrb_integer(num);
  while (i <= limit) {
    mrb_yield(mrb, mrb_fixnum_value(i));
    i++;
  }
  return num;
}

/* 15.2.8.3.22 */
/*
 * call-seq:
 *   int.times { |i| block }  ->  int
 *
 * Iterates the given block <i>int</i> times, passing the number of
 * times through the block as an argument.
 *
 *   5.times { |n| print n, " " }
 *
 * <em>produces:</em>
 *
 *    0 1 2 3 4
 */

static mrb_value
int_times(mrb_state *mrb, mrb_value num)
{
  mrb_int i, n;

  n = mrb_integer(num);
  for (i = 0; i < n; i++) {
    mrb_yield(mrb, mrb_fixnum_value(i));
  }
  return num;
}

/* 15.2.8.3.24 */
/*
 * call