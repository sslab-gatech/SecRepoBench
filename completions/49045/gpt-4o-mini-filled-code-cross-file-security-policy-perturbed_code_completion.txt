mrb_int num;
mrb_int base = 10; // default base

mrb_get_args(mrb, "i|i", &num, &base);

// Validate base to prevent overflow and ensure it's within acceptable range
if (base < 2 || base > 36) {
  mrb_raise(mrb, E_ARGUMENT_ERROR, "base must be between 2 and 36");
}

// Check for potential overflow when converting to string
char buffer[65]; // Sufficient buffer for base 2 to base 36
char *ptr = buffer + sizeof(buffer) - 1;
*ptr = '\0';

mrb_int n = num;
do {
  mrb_int digit = n % base;
  *(--ptr) = (digit < 10) ? (digit + '0') : (digit - 10 + 'a');
  n /= base;
} while (n != 0);

return mrb_str_new_cstr(mrb, ptr);