if(msg_type == 0x0a) /* AS-REQ */ {
#ifdef KERBEROS_DEBUG
  printf("[Kerberos] Processing AS-REQ\n");
#endif

  if(body_offset < packet->payload_packet_len) {
    u_int16_t name_offset;

    name_offset = body_offset + 13;
    for(i=0; i<20; i++) if(packet->payload[name_offset]!= 0x1b) name_offset++; /* ASN.1 */

#ifdef KERBEROS_DEBUG
    printf("name_offset=%u [%02X %02X] [byte 0 must be 0x1b]\n", name_offset, packet->payload[name_offset], packet->payload[name_offset+1]);
#endif

    if(name_offset < packet->payload_packet_len) {
      u_int cname_len;

      name_offset += 1;
      if(packet->payload[name_offset+1] <'') /* Isn't printable? */
        name_offset++;

      if(packet->payload[name_offset+1] == 0x1b)
        name_offset += 2;
      
      cname_len = packet->payload[name_offset];

      if((cname_len+name_offset) < packet->payload_packet_len) {
        u_int realm_len, realm_offset;
        char cname_str[48];
        u_int8_t num_cname = 0;

        while(++num_cname <= 2) {
          if(cname_len > sizeof(cname_str)-1)
            cname_len = sizeof(cname_str)-1;

          strncpy(cname_str, (char*)&packet->payload[name_offset+1], cname_len);
          cname_str[cname_len] = '\0';
          for(i=0; i<cname_len; i++) cname_str[i] = tolower(cname_str[i]);

#ifdef KERBEROS_DEBUG
          printf("[AS-REQ][s/dport: %u/%u][Kerberos Cname][len: %u][%s]\n", sport, dport, cname_len, cname_str);
#endif

          if(((strcmp(cname_str, "host") == 0) || (strcmp(cname_str, "ldap") == 0)) && (packet->payload[name_offset+1+cname_len] == 0x1b)) {
            name_offset += cname_len + 2;
            cname_len = packet->payload[name_offset];
          } else
            break;
        }

        realm_offset = cname_len + name_offset + 3;

        /* if cname does not end with a $ then it's a username */
        if(cname_len && cname_str[cname_len-1] == '$') {
          cname_str[cname_len-1] = '\0';
          snprintf(kerberos_flow->protos.kerberos.hostname, sizeof(kerberos_flow->protos.kerberos.hostname), "%s", cname_str);
        } else
          snprintf(kerberos_flow->protos.kerberos.username, sizeof(kerberos_flow->protos.kerberos.username), "%s", cname_str);

        // Extract and process the Kerberos realm from the packet payload.
        // Locate the starting position of the realm data using ASN.1 encoding markers.
        // Determine the length of the realm and ensure it is within the packet bounds.
        // Copy the realm string from the packet payload, convert it to lowercase, and store it in the flow's Kerberos domain field.
        // <MASK>
        if (realm_offset < packet->payload_packet_len) {
          u_int8_t realm_len = packet->payload[realm_offset];
          char realm_str[48];

          if (realm_len > sizeof(realm_str) - 1)
            realm_len = sizeof(realm_str) - 1;

          realm_offset += 1;
          strncpy(realm_str, (char*)&packet->payload[realm_offset], realm_len);
          realm_str[realm_len] = '\0';
          for (i = 0; i < realm_len; i++) realm_str[i] = tolower(realm_str[i]);

#ifdef KERBEROS_DEBUG
          printf("[AS-REQ][s/dport: %u/%u][Kerberos Realm][len: %u][%s]\n", sport, dport, realm_len, realm_str);
#endif

          snprintf(kerberos_flow->protos.kerberos.domain, sizeof(kerberos_flow->protos.kerberos.domain), "%s", realm_str);
        }
      }
    }
  }
} else if(msg_type == 0x0c) /* TGS-REQ */ {
#ifdef KERBEROS_DEBUG
  printf("[Kerberos] Processing TGS-REQ\n");
#endif

  if(body_offset < packet->payload_packet_len) {
    u_int name_offset, padding_offset = body_offset + 4;

    name_offset = padding_offset;
    for(i=0; i<14; i++) if(packet->payload[name_offset]!= 0x1b) name_offset++; /* ASN.1 */

#ifdef KERBEROS_DEBUG
    printf("name_offset=%u [%02X %02X] [byte 0 must be 0x1b]\n", name_offset, packet->payload[name_offset], packet->payload[name_offset+1]);
#endif

    if(name_offset < packet->payload_packet_len) {
      u_int realm_len;

      name_offset++;
      realm_len = packet->payload[name_offset];

      if((realm_len+name_offset) < packet->payload_packet_len) {
        char realm_str[48];

        if(realm_len > sizeof(realm_str)-1)
          realm_len = sizeof(realm_str)-1;

        name_offset += 1;

        strncpy(realm_str, (char*)&packet->payload[name_offset], realm_len);
        realm_str[realm_len] = '\0';
        for(i=0; i<realm_len; i++) realm_str[i] = tolower(realm_str[i]);

#ifdef KERBEROS_DEBUG
        printf("[TGS-REQ][s/dport: %u/%u][Kerberos Realm][len: %u][%s]\n", sport, dport, realm_len, realm_str);
#endif
        snprintf(kerberos_flow->protos.kerberos.domain, sizeof(kerberos_flow->protos.kerberos.domain), "%s", realm_str);

        /* If necessary we can decode sname */
        if(kerberos_flow->kerberos_buf.pktbuf) {
          ndpi_free(kerberos_flow->kerberos_buf.pktbuf);
          packet->payload = original_packet_payload;
          packet->payload_packet_len = original_payload_packet_len;
        }
        kerberos_flow->kerberos_buf.pktbuf = NULL;
      }
    }

    if(packet->udp)
      ndpi_int_kerberos_add_connection(ndpi_struct, kerberos_flow);

    /* We set the protocol in the response */
    if(kerberos_flow->kerberos_buf.pktbuf!= NULL) {
      ndpi_free(kerberos_flow->kerberos_buf.pktbuf);
      packet->payload = original_packet_payload;
      packet->payload_packet_len = original_payload_packet_len;
      kerberos_flow->kerberos_buf.pktbuf = NULL;
    }
    
    return;
  }
} else if(msg_type == 0x0d) /* TGS-REP */ {
  u_int16_t pad_data_len, cname_offset;
  
#ifdef KERBEROS_DEBUG
  printf("[Kerberos] Processing TGS-REP\n");
#endif

  koffsetp = koffset + 4;
  pad_data_len = packet->payload[koffsetp];
  /* Skip realm already filled in request */
  cname_offset = pad_data_len + koffsetp + 15;

  if(cname_offset < packet->payload_packet_len) {
    u_int8_t cname_len = packet->payload[cname_offset];

    if((cname_offset+cname_offset) < packet->payload_packet_len) {
      char cname_str[48];
      
      if(cname_len > sizeof(cname_str)-1)
        cname_len = sizeof(cname_str)-1;

      strncpy(cname_str, (char*)&packet->payload[cname_offset+1], cname_len);
      cname_str[cname_len] = '\0';
      for(i=0; i<cname_len; i++) cname_str[i] = tolower(cname_str[i]);

#ifdef KERBEROS_DEBUG
      printf("[TGS-REP][s/dport: %u/%u][Kerberos Cname][len: %u][%s]\n",
             sport, dport, cname_len, cname_str);
#endif

      if(cname_len && cname_str[cname_len-1] == '$') {
        cname_str[cname_len-1] = '\0';
        snprintf(kerberos_flow->protos.kerberos.hostname, sizeof(kerberos_flow->protos.kerberos.hostname), "%s", cname_str);
      } else
        snprintf(kerberos_flow->protos.kerberos.username, sizeof(kerberos_flow->protos.kerberos.username), "%s", cname_str);

      ndpi_int_kerberos_add_connection(ndpi_struct, kerberos_flow);
    }
  }
}