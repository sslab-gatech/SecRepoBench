if(msg_type == 0x0a) /* AS-REQ */ {
#ifdef KERBEROS_DEBUG
  printf("[Kerberos] Processing AS-REQ\n");
#endif

  if(body_offset < packet->payload_packet_len) {
    u_int16_t name_offset;

    name_offset = body_offset + 13;
    for(i=0; i<20; i++) if(packet->payload[name_offset]!= 0x1b) name_offset++; /* ASN.1 */

#ifdef KERBEROS_DEBUG
    printf("name_offset=%u [%02X %02X] [byte 0 must be 0x1b]\n", name_offset, packet->payload[name_offset], packet->payload[name_offset+1]);
#endif

    if(name_offset < packet->payload_packet_len) {
      u_int cname_len;

      name_offset += 1;
      if(packet->payload[name_offset+1] <'') /* Isn't printable? */
        name_offset++;

      if(packet->payload[name_offset+1] == 0x1b)
        name_offset += 2;
      
      cname_len = packet->payload[name_offset];

      if((cname_len+name_offset) < packet->payload_packet_len) {
        u_int realm_len, realm_offset;
        char cname_str[48];
        u_int8_t num_cname = 0;

        while(++num_cname <= 2) {
          if(cname_len > sizeof(cname_str)-1)
            cname_len = sizeof(cname_str)-1;

          strncpy(cname_str, (char*)&packet->payload[name_offset+1], cname_len);
          cname_str[cname_len] = '\0';
          for(i=0; i<cname_len; i++) cname_str[i] = tolower(cname_str[i]);

#ifdef KERBEROS_DEBUG
          printf("[AS-REQ][s/dport: %u/%u][Kerberos Cname][len: %u][%s]\n", sport, dport, cname_len, cname_str);
#endif

          if(((strcmp(cname_str, "host") == 0) || (strcmp(cname_str, "ldap") == 0)) && (packet->payload[name_offset+1+cname_len] == 0x1b)) {
            name_offset += cname_len + 2;
            cname_len = packet->payload[name_offset];
          } else
            break;
        }

        realm_offset = cname_len + name_offset + 3;

        /* if cname does not end with a $ then it's a username */
        if(cname_len && cname_str[cname_len-1] == '$') {
          cname_str[cname_len-1] = '\0';
          snprintf(kerberos_flow->protos.kerberos.hostname, sizeof(kerberos_flow->protos.kerberos.hostname), "%s", cname_str);
        } else
          snprintf(kerberos_flow->protos.kerberos.username, sizeof(kerberos_flow->protos.kerberos.username), "%s", cname_str);

        // Extract and process the Kerberos realm from the packet payload.
        // Locate the starting position of the realm data using ASN.1 encoding markers.
        // Determine the length of the realm and ensure it is within the packet bounds.
        // Copy the realm string from the packet payload, convert it to lowercase, and store it in the flow's Kerberos domain field.
        // <MASK>
        if (realm_offset + realm_len <= packet->payload_packet_len) {
          char realm_str[48];
          strncpy(realm_str, (char*)&packet->payload[realm_offset], realm_len);
          realm_str[realm_len] = '\0';
          for (i = 0; i < realm_len; i++) realm_str[i] = tolower(realm_str[i]);
          snprintf(kerberos_flow->protos.kerberos.domain, sizeof(kerberos_flow->protos.kerberos.domain), "%s", realm_str);
        }
      }
    }
  } 
}