Below is the content of a C/C++ function where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
static int search_valid_dns(struct ndpi_detection_module_struct *ndpi_struct,
			    struct ndpi_flow_struct *flow,
			    struct ndpi_dns_packet_header *dns_header,
			    int payload_offset, u_int8_t *is_query) {
  int offset = payload_offset;

  memcpy(dns_header, (struct ndpi_dns_packet_header*)&flow->packet.payload[offset],
	 sizeof(struct ndpi_dns_packet_header));

  dns_header->tr_id = ntohs(dns_header->tr_id);
  dns_header->flags = ntohs(dns_header->flags);
  dns_header->num_queries = ntohs(dns_header->num_queries);
  dns_header->num_answers = ntohs(dns_header->num_answers);
  dns_header->authority_rrs = ntohs(dns_header->authority_rrs);
  dns_header->additional_rrs = ntohs(dns_header->additional_rrs);

  offset += sizeof(struct ndpi_dns_packet_header);

  /* 0x0000 QUERY */
  if((dns_header->flags & FLAGS_MASK) == 0x0000)
    *is_query = 1;
  /* 0x8000 RESPONSE */
  else if((dns_header->flags & FLAGS_MASK) == 0x8000)
    *is_query = 0;
  else
    return(1 /* invalid */);

  if(*is_query) {
    /* DNS Request */
    if((dns_header->num_queries > 0) && (dns_header->num_queries <= NDPI_MAX_DNS_REQUESTS)
       && (((dns_header->flags & 0x2800) == 0x2800 /* Dynamic DNS Update */)
	   || ((dns_header->num_answers == 0) && (dns_header->authority_rrs == 0)))) 
	   // Extract the query type from the DNS query section of the packet.
	   // Iterate over the payload starting from the current offset until a null character is found.
	   // Once the null character is found, increment the offset and read the query type.
	   // Optionally, log the query type for debugging purposes.
	   // Ensure the operation is performed within the packet's payload length.
	   // <MASK>
 else
      return(1 /* invalid */);
  } else {
    /* DNS Reply */
    flow->protos.dns.reply_code = dns_header->flags & 0x0F;

    if((dns_header->num_queries > 0) && (dns_header->num_queries <= NDPI_MAX_DNS_REQUESTS) /* Don't assume that num_queries must be zero */
       && (((dns_header->num_answers > 0) && (dns_header->num_answers <= NDPI_MAX_DNS_REQUESTS))
	   || ((dns_header->authority_rrs > 0) && (dns_header->authority_rrs <= NDPI_MAX_DNS_REQUESTS))
	   || ((dns_header->additional_rrs > 0) && (dns_header->additional_rrs <= NDPI_MAX_DNS_REQUESTS)))
       ) {
      /* This is a good reply: we dissect it both for request and response */

      /* Leave the statement below commented necessary in case of call to ndpi_get_partial_detection() */
      offset++;

      if(flow->packet.payload[offset] != '\0') {
	while((offset < flow->packet.payload_packet_len)
	      && (flow->packet.payload[offset] != '\0')) {
	  offset++;
	}

	offset++;
      }

      offset += 4;

      if(dns_header->num_answers > 0) {
	u_int16_t rsp_type;
	u_int16_t num;

	for(num = 0; num < dns_header->num_answers; num++) {
	  u_int16_t data_len;

	  if((offset+6) >= flow->packet.payload_packet_len) {
	    break;
	  }

	  if((data_len = getNameLength(offset, flow->packet.payload, flow->packet.payload_packet_len)) == 0) {
	    break;
	  } else
	    offset += data_len;

	  if((offset+2) >= flow->packet.payload_packet_len) {
	    break;
	  }
	  rsp_type = get16(&offset, flow->packet.payload);
	  flow->protos.dns.rsp_type = rsp_type;

	  /* here x points to the response "class" field */
	  if((offset+12) <= flow->packet.payload_packet_len) {
	    offset += 6;
	    data_len = get16(&offset, flow->packet.payload);
	    
	    if((offset + data_len) <= flow->packet.payload_packet_len) {
	      // printf("[rsp_type: %u][data_len: %u]\n", rsp_type, data_len);

	      if(rsp_type == 0x05 /* CNAME */) {
		offset += data_len;
		continue; /* Skip CNAME */
	      }
	      
	      if((((rsp_type == 0x1) && (data_len == 4)) /* A */
#ifdef NDPI_DETECTION_SUPPORT_IPV6
		  || ((rsp_type == 0x1c) && (data_len == 16)) /* AAAA */
#endif
		  )) {
		memcpy(&flow->protos.dns.rsp_addr, flow->packet.payload + offset, data_len);
	      }
	    }
	  }
	  
	  break;
	}
      }
     
      if((flow->packet.detected_protocol_stack[0] == NDPI_PROTOCOL_DNS)
	 || (flow->packet.detected_protocol_stack[1] == NDPI_PROTOCOL_DNS)) {
	/* Request already set the protocol */
	// flow->extra_packets_func = NULL; /* Removed so the caller can keep dissecting DNS flows */
      } else {
	/* We missed the request */
	u_int16_t s_port = flow->packet.udp ? ntohs(flow->packet.udp->source) : ntohs(flow->packet.tcp->source);
	
	ndpi_set_detected_protocol(ndpi_struct, flow,
				   (s_port == 5355) ? NDPI_PROTOCOL_LLMNR : NDPI_PROTOCOL_DNS,
				   NDPI_PROTOCOL_UNKNOWN);
      }
    } else
      return(1 /* invalid */);
  }

  /* Valid */
  return(0);
}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/lib/protocols/dns.c
static void ndpi_search_dns(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow) {
  int payload_offset;
  u_int8_t is_query;
  u_int16_t s_port = 0, d_port = 0;

  NDPI_LOG_DBG(ndpi_struct, "search DNS\n");

  if(flow->packet.udp != NULL) {
    s_port = ntohs(flow->packet.udp->source);
    d_port = ntohs(flow->packet.udp->dest);
    payload_offset = 0;
  } else if(flow->packet.tcp != NULL) /* pkt size > 512 bytes */ {
    s_port = ntohs(flow->packet.tcp->source);
    d_port = ntohs(flow->packet.tcp->dest);
    payload_offset = 2;
  } else {
    NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
    return;
  }

  if((s_port == 53 || d_port == 53 || d_port == 5355)
     && (flow->packet.payload_packet_len > sizeof(struct ndpi_dns_packet_header)+payload_offset)) {
    struct ndpi_dns_packet_header dns_header;
    int j = 0, max_len, off;
    int invalid = search_valid_dns(ndpi_struct, flow, &dns_header, payload_offset, &is_query);
    ndpi_protocol ret;

    ret.master_protocol   = NDPI_PROTOCOL_UNKNOWN;
    ret.app_protocol      = (d_port == 5355) ? NDPI_PROTOCOL_LLMNR : NDPI_PROTOCOL_DNS;

    if(invalid) {
      NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
      return;
    }

    /* extract host name server */
    max_len = sizeof(flow->host_server_name)-1;
    off = sizeof(struct ndpi_dns_packet_header) + payload_offset;
    
    while(j < max_len && off < flow->packet.payload_packet_len && flow->packet.payload[off] != '\0') {
      uint8_t c, cl = flow->packet.payload[off++];

      if( (cl & 0xc0) != 0 || // we not support compressed names in query
	  off + cl  >= flow->packet.payload_packet_len) {
	j = 0;
	break;
      }

      if(j && j < max_len) flow->host_server_name[j++] = '.';

      while(j < max_len && cl != 0) {
	u_int32_t shift;
	
	c = flow->packet.payload[off++];
	shift = ((u_int32_t) 1) << (c & 0x1f);
	flow->host_server_name[j++] = tolower((dns_validchar[c >> 5] & shift) ? c : '_');
	cl--;
      }
    }
    flow->host_server_name[j] = '\0';

    if(j > 0) {
      ndpi_protocol_match_result ret_match;

      ret.app_protocol = ndpi_match_host_subprotocol(ndpi_struct, flow,
						     (char *)flow->host_server_name,
						     strlen((const char*)flow->host_server_name),
						     &ret_match,
						     NDPI_PROTOCOL_DNS);

      if(ret_match.protocol_category != NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)
	flow->category = ret_match.protocol_category;

      if(ret.app_protocol == NDPI_PROTOCOL_UNKNOWN)
	ret.master_protocol = (d_port == 5355) ? NDPI_PROTOCOL_LLMNR : NDPI_PROTOCOL_DNS;
      else
	ret.master_protocol = NDPI_PROTOCOL_DNS;
    }

    /* Report if this is a DNS query or reply */
    flow->protos.dns.is_query = is_query;

    if(is_query) {
      /* In this case we say that the protocol has been detected just to let apps carry on with their activities */
      ndpi_set_detected_protocol(ndpi_struct, flow, ret.app_protocol, ret.master_protocol);

      /* This is necessary to inform the core to call this dissector again */
      flow->check_extra_packets = 1;

      /* Don't use just 1 as in TCP DNS more packets could be returned (e.g. ACK). */
      flow->max_extra_packets_to_check = 5;
      flow->extra_packets_func = search_dns_again;
      return; /* The response will set the verdict */
    }

    flow->protos.dns.num_queries = (u_int8_t)dns_header.num_queries,
      flow->protos.dns.num_answers = (u_int8_t) (dns_header.num_answers + dns_header.authority_rrs + dns_header.additional_rrs);

#ifdef DNS_DEBUG
    NDPI_LOG_DBG2(ndpi_struct, "[num_queries=%d][num_answers=%d][reply_code=%u][rsp_type=%u][host_server_name=%s]\n",
		  flow->protos.dns.num_queries, flow->protos.dns.num_answers,
		  flow->protos.dns.reply_code, flow->protos.dns.rsp_type, flow->host_server_name
		  );
#endif

    if(flow->packet.detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {
      /**
	 Do not set the protocol with DNS if ndpi_match_host_subprotocol() has
	 matched a subprotocol
      **/
      NDPI_LOG_INFO(ndpi_struct, "found DNS\n");
      ndpi_set_detected_protocol(ndpi_struct, flow, ret.app_protocol, ret.master_protocol);
    } else {
      if((flow->packet.detected_protocol_stack[0] == NDPI_PROTOCOL_DNS)
	 || (flow->packet.detected_protocol_stack[1] == NDPI_PROTOCOL_DNS))
	;
      else
	NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
    }
  }
}

// the below code fragment can be found in:
// src/lib/protocols/dns.c
static int search_dns_again(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow) {
  /* possibly dissect the DNS reply */
  ndpi_search_dns(ndpi_struct, flow);

  /* Possibly more processing */
  return(1);
}

// the below code fragment can be found in:
// src/lib/protocols/mdns_proto.c
static int ndpi_int_check_mdns_payload(struct ndpi_detection_module_struct
				       *ndpi_struct, struct ndpi_flow_struct *flow) {
  struct ndpi_packet_struct *packet = &flow->packet;
  struct mdns_header *h = (struct mdns_header*)packet->payload;
  u_int16_t questions = ntohs(h->questions), answers = ntohs(h->answers);

  if((questions > NDPI_MAX_MDNS_REQUESTS)
     || (answers > NDPI_MAX_MDNS_REQUESTS))
    return(0);
  
  if((packet->payload[2] & 0x80) == 0) {
    NDPI_LOG_INFO(ndpi_struct, "found MDNS with question query\n");
    return 1;    
  } else if((packet->payload[2] & 0x80) != 0) {
    char answer[256];
    int i, j, len;

    for(i=13, j=0; (i < packet->payload_packet_len) && (i < (sizeof(answer)-1)) && (packet->payload[i] != 0); i++)
      answer[j++] = (packet->payload[i] < 13) ? '.' : packet->payload[i];
	
    answer[j] = '\0';

    /* printf("==> [%d] %s\n", j, answer);  */

    len = ndpi_min(sizeof(flow->protos.mdns.answer)-1, j);
    strncpy(flow->protos.mdns.answer, (const char *)answer, len);
    flow->protos.mdns.answer[len] = '\0';
    
    NDPI_LOG_INFO(ndpi_struct, "found MDNS with answer query\n");
    return 1;
  }
  
  return 0;
}

// the below code fragment can be found in:
// src/lib/protocols/mdns_proto.c
void ndpi_search_mdns(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow)
{
  struct ndpi_packet_struct *packet = &flow->packet;
  NDPI_LOG_DBG(ndpi_struct, "search MDNS\n");

  /**
     information from http://www.it-administrator.de/lexikon/multicast-dns.html 
  */
  
  /* check if UDP packet */
  if(packet->udp != NULL) {   
    /* read destination port */
    u_int16_t sport = ntohs(packet->udp->source);
    u_int16_t dport = ntohs(packet->udp->dest);

    /* check standard MDNS ON port 5353 */
    if(((dport == 5353) || (sport == 5353))
       && (packet->payload_packet_len >= 12)) {
      if(packet->iph != NULL) {
	if(ndpi_int_check_mdns_payload(ndpi_struct, flow) == 1) {
	  ndpi_int_mdns_add_connection(ndpi_struct, flow);
	  return;
	}
      }
#ifdef NDPI_DETECTION_SUPPORT_IPV6
      if(packet->iphv6 != NULL) {
	u_int32_t daddr_0 = packet->iphv6->ip6_dst.u6_addr.u6_addr32[0];

	if(daddr_0 == htonl(0xff020000) /* && daddr[1] == 0 && daddr[2] == 0 && daddr[3] == htonl(0xfb) */) {

	  NDPI_LOG_INFO(ndpi_struct, "found MDNS with destination address ff02::fb\n");
	  
	  if(ndpi_int_check_mdns_payload(ndpi_struct, flow) == 1) {
	    ndpi_int_mdns_add_connection(ndpi_struct, flow);
	    return;
	  }
	}
      }
#endif
    }
  }
  
  NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
}

// the below code fragment can be found in:
// src/lib/protocols/dhcp.c
void ndpi_search_dhcp_udp(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow)
{
  struct ndpi_packet_struct *packet = &flow->packet;

  NDPI_LOG_DBG(ndpi_struct, "search DHCP\n");

  /* this detection also works for asymmetric dhcp traffic */

  /*check standard DHCP 0.0.0.0:68 -> 255.255.255.255:67 */
  if(packet->udp) {
    dhcp_packet_t *dhcp = (dhcp_packet_t*)packet->payload;

    if((packet->payload_packet_len >= 244 /* 244 is the offset of options[0] in dhcp_packet_t */)
       && (packet->udp->source == htons(67) || packet->udp->source == htons(68))
       && (packet->udp->dest == htons(67) || packet->udp->dest == htons(68))
       && (dhcp->magic == htonl(DHCP_OPTION_MAGIC_NUMBER))) {
      u_int i = 0, foundValidMsgType = 0;

      u_int dhcp_options_size = ndpi_min(DHCP_VEND_LEN /* maximum size of options in dhcp_packet_t */,
					 packet->payload_packet_len - 244);

      while(i + 1 /* for the len */ < dhcp_options_size) {
	u_int8_t id  = dhcp->options[i];

	if(id == 0xFF)
	  break;
	else {
	  /* Prevent malformed packets to cause out-of-bounds accesses */
	  u_int8_t len = ndpi_min(dhcp->options[i+1] /* len as found in the packet */,
				  dhcp_options_size - (i+2) /* 1 for the type and 1 for the value */);

	  if(len == 0) break;

#ifdef DHCP_DEBUG
	  NDPI_LOG_DBG2(ndpi_struct, "[DHCP] Id=%d [len=%d]\n", id, len);
#endif

	  if(id == 53 /* DHCP Message Type */) {
	    u_int8_t msg_type = dhcp->options[i+2];

	    if(msg_type <= 8) foundValidMsgType = 1;
	  } else if(id == 55 /* Parameter Request List / Fingerprint */) {
	    u_int idx, offset = 0;
	    
	    for(idx = 0; idx < len && offset < sizeof(flow->protos.dhcp.fingerprint) - 2; idx++) {
	      int rc = snprintf((char*)&flow->protos.dhcp.fingerprint[offset],
				sizeof(flow->protos.dhcp.fingerprint) - offset,
				"%s%u", (idx > 0) ? "," : "",
				(unsigned int)dhcp->options[i+2+idx] & 0xFF);
	      
	      if(rc < 0) break; else offset += rc;
	    }
	    
	    flow->protos.dhcp.fingerprint[sizeof(flow->protos.dhcp.fingerprint) - 1] = '\0';	    
	  } else if(id == 60 /* Class Identifier */) {
	    char *name = (char*)&dhcp->options[i+2];
	    int j = 0;
	    
	    j = ndpi_min(len, sizeof(flow->protos.dhcp.class_ident)-1);
	    strncpy((char*)flow->protos.dhcp.class_ident, name, j);
	    flow->protos.dhcp.class_ident[j] = '\0';
	  } else if(id == 12 /* Host Name */) {
	    char *name = (char*)&dhcp->options[i+2];
	    int j = 0;
	    
#ifdef DHCP_DEBUG
	    NDPI_LOG_DBG2(ndpi_struct, "[DHCP] '%.*s'\n",name,len);
	      //	    while(j < len) { printf( "%c", name[j]); j++; }; printf("\n");
#endif
	    j = ndpi_min(len, sizeof(flow->host_server_name)-1);
	    strncpy((char*)flow->host_server_name, name, j);
	    flow->host_server_name[j] = '\0';	    
	  }

	  i += len + 2;
	}
      }

      //get_u_int16_t(packet->payload, 240) == htons(0x3501)) {

      if(foundValidMsgType) {
	NDPI_LOG_INFO(ndpi_struct, "found DHCP\n");
	ndpi_int_dhcp_add_connection(ndpi_struct, flow);
      }
      return;
    }
  }

  NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
}
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).