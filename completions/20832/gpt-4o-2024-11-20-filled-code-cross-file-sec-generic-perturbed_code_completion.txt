// Ensure the offset is within the payload length
      if (offset >= flow->packet.payload_packet_len) {
        return 1; // invalid
      }

      // Iterate over the payload to find the end of the query name
      while ((offset < flow->packet.payload_packet_len) && (flow->packet.payload[offset] != '\0')) {
        offset++;
      }

      // Ensure the null character was found and increment offset
      if (offset >= flow->packet.payload_packet_len || flow->packet.payload[offset] != '\0') {
        return 1; // invalid
      }
      offset++;

      // Ensure there is enough space for the query type and class fields
      if ((offset + 4) > flow->packet.payload_packet_len) {
        return 1; // invalid
      }

      // Read the query type (2 bytes)
      u_int16_t query_type = (flow->packet.payload[offset] << 8) | flow->packet.payload[offset + 1];
      offset += 2;

      // Read the query class (2 bytes, typically 0x0001 for IN)
      u_int16_t query_class = (flow->packet.payload[offset] << 8) | flow->packet.payload[offset + 1];
      offset += 2;

      // Optionally log the query type and class for debugging
#ifdef DEBUG_DNS
      printf("DNS Query Type: %u, Class: %u\n", query_type, query_class);
#endif

      // Validate the query type and class if necessary (e.g., ensure they are within expected ranges)
      if (query_class != 0x0001) { // Only handle Internet (IN) class
        return 1; // invalid
      }