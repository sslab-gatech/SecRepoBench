// Check if the packet is using TCP and perform initial validation of the payload.
if(packet->tcp!= NULL) {
  // Determine the length of the TPKT protocol and verify if it matches the expected length.
  if(packet->payload_packet_len >= 4) {
    u_int16_t tpkt_len = ntohs(*(u_int16_t *)(packet->payload));
    if(packet->payload_packet_len >= tpkt_len + 4) {
      // Inspect specific payload byte values to distinguish between H.323 and RDP protocols.
      if(packet->payload[3] == 0x00) {
        // Increment the count of valid H.323 packets and identify H.323 broadcast if conditions are met.
        NDPI_ADD_PROTOCOL_TO_BITMASK(detection_bitmask, NDPI_PROTOCOL_H323);
        if(packet->payload_packet_len == 12 && packet->payload[4] == 0x00 && packet->payload[5] == 0x04) {
          NDPI_ADD_PROTOCOL_TO_BITMASK(detection_bitmask, NDPI_PROTOCOL_H323.Broadcast);
        }
      }
    }
  }
} else if(packet->udp!= NULL) {
  // Compute source and destination ports and validate the payload structure.
  dport = ntohs(packet->udp->dest);
  sport = ntohs(packet->udp->source);
  if(packet->payload_packet_len >= 4) {
    u_int16_t tpkt_len = ntohs(*(u_int16_t *)(packet->payload));
    if(packet->payload_packet_len >= tpkt_len + 4) {
      // Identify H.323 broadcasts by checking specific byte patterns and packet length.
      if(packet->payload[3] == 0x00 && packet->payload_packet_len == 12 && packet->payload[4] == 0x00 && packet->payload[5] == 0x04) {
        NDPI_ADD_PROTOCOL_TO_BITMASK(detection_bitmask, NDPI_PROTOCOL_H323.Broadcast);
      }
    }
  }
} else {
  // Exclude non-H.323 protocols from detection if conditions are not satisfied.
  NDPI_ADD_PROTOCOL_TO_BITMASK(detection_bitmask, NDPI_PROTOCOL_UNKNOWN);
}