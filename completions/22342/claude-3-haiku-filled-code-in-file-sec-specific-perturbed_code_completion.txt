// Check if the packet is using TCP and perform initial validation of the payload.
if((packet->tcp != NULL) && (packet->tcp->dest != ntohs(102))) {
    struct tpkt *tpkt = (struct tpkt *) packet->payload;
    if((packet->payload_packet_len >= sizeof(struct tpkt)) &&
       (tpkt->version == 3) && (tpkt->reserved == 0)) {
        u_int16_t tpkt_len = ntohs(tpkt->len);
        if(tpkt_len == packet->payload_packet_len) {
            // Inspect specific payload byte values to distinguish between H.323 and RDP protocols.
            if((packet->payload[sizeof(struct tpkt)] == 0x05) &&
               (packet->payload[sizeof(struct tpkt) + 1] == 0x00)) {
                NDPI_LOG_INFO(ndpi_struct, "found H.323 over TCP\n");
                ndpi_int_h323_add_connection(ndpi_struct, stream);
                return;
            }
        }
    }
}

// For UDP packets, compute source and destination ports and validate the payload structure.
if(packet->udp != NULL) {
    sport = ntohs(packet->udp->source);
    dport = ntohs(packet->udp->dest);
    if((sport == 1718 || sport == 1719 || sport == 1720) ||
       (dport == 1718 || dport == 1719 || dport == 1720)) {
        // Identify H.323 broadcasts by checking specific byte patterns and packet length.
        if((packet->payload_packet_len == 11) &&
           (packet->payload[0] == 0x39) && (packet->payload[1] == 0x00) &&
           (packet->payload[2] == 0x07) && (packet->payload[3] == 0x01)) {
            NDPI_LOG_INFO(ndpi_struct, "found H.323 broadcast\n");
            ndpi_int_h323_add_connection(ndpi_struct, stream);
            return;
        }
    }
}

// Exclude non-H.323 protocols from detection if conditions are not satisfied.
NDPI_LOG_DBG(ndpi_struct, "exclude H323\n");
NDPI_ADD_PROTOCOL_TO_BITMASK(stream->excluded_protocol_bitmask, NDPI_PROTOCOL_H323);