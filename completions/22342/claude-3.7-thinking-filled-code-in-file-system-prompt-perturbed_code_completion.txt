{
    if(packet->payload_packet_len >= sizeof(struct tpkt)) {
      const struct tpkt *tpkt = (struct tpkt*)packet->payload;
      u_int16_t len = ntohs(tpkt->len);

      // Check TPKT protocol (H.323 uses TPKT as a transport layer)
      if(tpkt->version == 3) {
        // Valid TPKT version
        if(len == packet->payload_packet_len) {
          // Length matches, good sign
          if(packet->payload_packet_len >= 5) {
            // Check for possible H.323 vs RDP
            if(packet->payload[4] != 0xFF /* RDP Magic */) {
              NDPI_LOG_INFO(ndpi_struct, "found H323\n");
              ndpi_set_detected_protocol(ndpi_struct, stream, NDPI_PROTOCOL_H323, NDPI_PROTOCOL_UNKNOWN);
              return;
            }
          }
        }
      }
    } else if(packet->udp != NULL) {
      sport = ntohs(packet->udp->source);
      dport = ntohs(packet->udp->dest);

      // H.323 most commonly uses ports 1719 (GRQ) and 1720 (Q.931)
      if((sport == 1719 || dport == 1719 || sport == 1720 || dport == 1720) && 
         packet->payload_packet_len >= 4) {
        if(packet->payload[0] == 0x16 && packet->payload[1] == 0x80 && 
           packet->payload[2] == 0x00 && packet->payload[3] == 0x00) {
          NDPI_LOG_INFO(ndpi_struct, "found H323 broadcast\n");
          ndpi_set_detected_protocol(ndpi_struct, stream, NDPI_PROTOCOL_H323, NDPI_PROTOCOL_UNKNOWN);
          return;
        }
      }
    }

    // Exclude H.323 if conditions are not met
    NDPI_EXCLUDE_PROTO(ndpi_struct, stream);
  }