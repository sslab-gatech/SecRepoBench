// Determine the length of the TPKT protocol and verify if it matches the expected length.
if(packet->payload_packet_len >= 4) {
    u_int16_t tpkt_len = (packet->payload[2] << 8) + packet->payload[3];
    if(tpkt_len == packet->payload_packet_len) {
        // Inspect specific payload byte values to distinguish between H.323 and RDP protocols.
        if(packet->payload[4] == 0x03 && packet->payload[5] == 0x00) {
            // Increment the count of valid H.323 packets and identify H.323 broadcast if conditions are met.
            NDPI_LOG_INFO(ndpi_struct, "found H.323 packet\n");
            ndpi_int_h323_add_connection(ndpi_struct, stream);
            if(packet->payload_packet_len >= 11 && packet->payload[10] == 0x31) {
                NDPI_LOG_INFO(ndpi_struct, "found H.323 broadcast\n");
                ndpi_int_add_connection(ndpi_struct, stream, NDPI_PROTOCOL_H323_BROADCAST, NDPI_REAL_PROTOCOL);
            }
        } else {
            // Exclude non-H.323 protocols from detection if conditions are not satisfied.
            NDPI_LOG_DBG(ndpi_struct, "exclude H.323 detection\n");
            ndpi_int_reset_protocol(stream);
        }
    }
}

// For UDP packets, compute source and destination ports and validate the payload structure.
if(packet->udp != NULL) {
    sport = ntohs(packet->udp->source);
    dport = ntohs(packet->udp->dest);
    if(packet->payload_packet_len >= 12 && packet->payload[0] == 0x00 && packet->payload[1] == 0x00 && packet->payload[2] == 0x00 && packet->payload[3] == 0x00) {
        // Identify H.323 broadcasts by checking specific byte patterns and packet length.
        NDPI_LOG_INFO(ndpi_struct, "found H.323 UDP broadcast\n");
        ndpi_int_add_connection(ndpi_struct, stream, NDPI_PROTOCOL_H323_BROADCAST, NDPI_REAL_PROTOCOL);
    } else {
        // Exclude non-H.323 protocols from detection if conditions are not satisfied.
        NDPI_LOG_DBG(ndpi_struct, "exclude H.323 UDP detection\n");
        ndpi_int_reset_protocol(stream);
    }
}