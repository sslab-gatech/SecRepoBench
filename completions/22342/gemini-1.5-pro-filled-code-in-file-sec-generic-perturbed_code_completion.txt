{
    const u_int8_t *payload = packet->payload;
    u_int32_t payload_len = packet->payload_len;

    if (payload_len < sizeof(struct tpkt)) {
      return;
    }

    struct tpkt *tpkt_header = (struct tpkt *)payload;

    u_int16_t tpkt_len = ntohs(tpkt_header->len);

    if (tpkt_len < 4 || tpkt_len > payload_len) {
      return;
    }

    /*
     * Check for RAS (H225 Registration, Admission, Status) message.
     * This helps differentiate between H.323 and RDP, which also uses TPKT.
     */
    if (payload_len > 4 && payload[4] == 0x08) {
      NDPI_LOG_DBG(ndpi_struct, "found H323 (RAS message)\n");
      ndpi_set_detected_protocol(ndpi_struct, stream, NDPI_PROTOCOL_H323, NDPI_PROTOCOL_UNKNOWN);
      return;
    }


    /* H.323 uses UDP broadcasts */
    NDPI_ADD_PROTOCOL_TO_BITMASK(ndpi_struct->src_or_dst_port_bitmask, sport);
    if (packet->udp != NULL) {
      sport = ntohs(packet->udp->source), dport = ntohs(packet->udp->dest);

      if (payload_len > 4 && payload[4] == 0x08) {
        NDPI_LOG_DBG(ndpi_struct, "found H323 (RAS message - UDP)\n");
        ndpi_set_detected_protocol(ndpi_struct, stream, NDPI_PROTOCOL_H323, NDPI_PROTOCOL_UNKNOWN);
        return;
      }

      if (payload_len >= 12 && payload[4] == 0x01 && payload[5] == 0x00 && payload[11] == 0x28) {
        NDPI_LOG_DBG(ndpi_struct, "found H323 (broadcast)\n");
        ndpi_set_detected_protocol(ndpi_struct, stream, NDPI_PROTOCOL_H323, NDPI_PROTOCOL_UNKNOWN);
        return;
      }

      if (payload_len > 4 && payload[4] != 0x03) {
        return;
      }
    }
  }