{
  if(packet->tcp != NULL) {
    /* Ensure the payload is at least large enough for a TPKT header (4 bytes) */
    if(packet->payload_packet_len < 4)
      return;

    /* Check the TPKT version (first byte must be 3) */
    if(packet->payload[0] != 3)
      return;

    /* Extract the total length from the TPKT header (bytes 2-3) */
    u_int16_t tpkt_length = ntohs(*(u_int16_t *)(packet->payload + 2));
    if(tpkt_length < 4 || tpkt_length > packet->payload_packet_len)
      return;

    /* Optional: Add further checks on specific payload bytes to distinguish H.323 from similar protocols */

    /* Mark the protocol as detected H.323 */
    ndpi_set_detected_protocol(ndpi_struct, stream, NDPI_PROTOCOL_H323, NDPI_PROTOCOL_UNKNOWN);
  }
  else if(packet->udp != NULL) {
    /* Safely extract UDP ports */
    sport = ntohs(packet->udp->source);
    dport = ntohs(packet->udp->dest);

    /* Ensure the UDP payload is large enough for basic H.323 verification */
    if(packet->payload_packet_len < 4)
      return;

    /* Optional: Check for H.323 specific signatures or patterns within the payload.
       Here we validate based on common H.323 UDP port numbers (1719 for Gatekeeper and 1720 for H.323 signaling) */
    if(dport != 1719 && dport != 1720 && sport != 1719 && sport != 1720)
      return;

    /* Mark the protocol as detected H.323 */
    ndpi_set_detected_protocol(ndpi_struct, stream, NDPI_PROTOCOL_H323, NDPI_PROTOCOL_UNKNOWN);
  }
}