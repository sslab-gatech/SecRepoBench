if((packet->tcp != NULL) && (packet->tcp->dest != ntohs(102))) {
    // Check if the packet is using TCP and perform initial validation of the payload.
    if(packet->payload != NULL && packet->payload_length >= 4) {
      u_char *payload = (u_char*)packet->payload;
      // Determine the length of the TPKT protocol and verify if it matches the expected length.
      if(payload[0] == 0x03 && (payload[1] & 0x80) && ((payload[1] & 0x7F) == (packet->payload_length - 4))) {
        // Inspect specific payload byte values to distinguish between H.323 and RDP protocols.
        if(payload[2] == 0x00 && payload[3] == 0x00) {
          // Increment the count of valid H.323 packets and identify H.323 broadcast if conditions are met.
          NDPI_LOG_DBG(ndpi_struct, "found H323\n");
          ndpi_set_detected_protocol(ndpi_struct, stream, NDPI_PROTOCOL_H323, NDPI_PROTOCOL_UNKNOWN);
        }
      }
    }
  } else if(packet->udp != NULL) {
    // For UDP packets, compute source and destination ports and validate the payload structure.
    sport = ntohs(packet->udp->source);
    dport = ntohs(packet->udp->dest);
    if(packet->payload != NULL && packet->payload_length >= 4) {
      u_char *payload = (u_char*)packet->payload;
      // Identify H.323 broadcasts by checking specific byte patterns and packet length.
      if(payload[0] == 0x00 && payload[1] == 0x01 && payload[2] == 0x00 && payload[3] == 0x01) {
        NDPI_LOG_DBG(ndpi_struct, "found H323\n");
        ndpi_set_detected_protocol(ndpi_struct, stream, NDPI_PROTOCOL_H323, NDPI_PROTOCOL_UNKNOWN);
      }
    }
  } else {
    // Exclude non-H.323 protocols from detection if conditions are not satisfied.
    NDPI_LOG_DBG(ndpi_struct, "exclude H323\n");
  }