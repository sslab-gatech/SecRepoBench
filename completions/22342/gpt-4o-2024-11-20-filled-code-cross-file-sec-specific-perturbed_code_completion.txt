{
    u_int16_t payload_len;
    const u_int8_t *payload = packet->payload;
    u_int32_t payload_size = packet->payload_packet_len;

    if(payload_size < 4) {
      NDPI_LOG_DBG(ndpi_struct, "Payload too small for H.323 detection\n");
      return;
    }

    // Check for TPKT header
    if(payload[0] == 0x03) { // TPKT version
      payload_len = (payload[2] << 8) | payload[3]; // Extract length from TPKT header

      if(payload_len != payload_size) {
        NDPI_LOG_DBG(ndpi_struct, "TPKT length mismatch\n");
        return;
      }

      // Check for H.323 specific payload patterns
      if(payload_size > 5 && payload[4] == 0x08) { // Example H.323 pattern
        NDPI_LOG_DBG(ndpi_struct, "H.323 detected via TPKT\n");
        ndpi_set_detected_protocol(ndpi_struct, stream, NDPI_PROTOCOL_H323);
        return;
      }
    }

    // For UDP packets, check for H.323 broadcast patterns
    if(packet->udp != NULL) {
      sport = ntohs(packet->udp->source);
      dport = ntohs(packet->udp->dest);

      if((sport == 1719 || dport == 1719) && payload_size > 10) { // H.323 RAS port
        if(payload[0] == 0x05 && payload[1] == 0x00) { // Example RAS pattern
          NDPI_LOG_DBG(ndpi_struct, "H.323 RAS detected\n");
          ndpi_set_detected_protocol(ndpi_struct, stream, NDPI_PROTOCOL_H323);
          return;
        }
      }
    }

    // If no H.323 patterns are detected, exclude the protocol
    NDPI_LOG_DBG(ndpi_struct, "Not H.323\n");
    NDPI_EXCLUDE_PROTOCOL(ndpi_struct, stream);
  }