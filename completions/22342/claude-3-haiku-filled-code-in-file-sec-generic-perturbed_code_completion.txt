// Check if the packet is using TCP and perform initial validation of the payload.
if ((packet->tcp != NULL) && (packet->payload_packet_len >= sizeof(struct tpkt))) {
    struct tpkt *tpkt = (struct tpkt *) packet->payload;
    if (tpkt->version == 3 && tpkt->reserved == 0 && ntohs(tpkt->len) == packet->payload_packet_len) {
        // Determine the length of the TPKT protocol and verify if it matches the expected length.
        NDPI_LOG_DBG(ndpi_struct, "H.323 TCP found\n");
        ndpi_int_h323_add_connection(ndpi_struct, stream);
        return;
    }
}

// For UDP packets, compute source and destination ports and validate the payload structure.
if (packet->udp != NULL) {
    sport = ntohs(packet->udp->source);
    dport = ntohs(packet->udp->dest);

    if ((sport == 1718 && dport == 1719) || (sport == 1719 && dport == 1718)) {
        // Identify H.323 broadcasts by checking specific byte patterns and packet length.
        if (packet->payload_packet_len >= 12 && packet->payload[0] == 0x0f && packet->payload[1] == 0x20) {
            NDPI_LOG_DBG(ndpi_struct, "H.323 broadcast found\n");
            ndpi_int_h323_add_connection(ndpi_struct, stream);
            return;
        }
    }
}

// Exclude non-H.323 protocols from detection if conditions are not satisfied.
NDPI_LOG_DBG(ndpi_struct, "exclude H.323\n");
NDPI_ADD_PROTOCOL_TO_BITMASK(stream->excluded_protocol_bitmask, NDPI_PROTOCOL_H323);