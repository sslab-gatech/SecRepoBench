if((packet->tcp!= NULL) && (packet->tcp->dest!= ntohs(102))) 
{
  // Check if the packet is using TCP and perform initial validation of the payload.
  if(packet->tcp->payload_len >= 4)
  {
    // Determine the length of the TPKT protocol and verify if it matches the expected length.
    if(packet->tcp->payload_len >= 4 && ntohs(*(u_int16_t*)(packet->tcp->payload)) == 0x0305)
    {
      // Inspect specific payload byte values to distinguish between H.323 and RDP protocols.
      if(ntohs(*(u_int16_t*)(packet->tcp->payload + 4)) == 0x0000)
      {
        // Increment the count of valid H.323 packets and identify H.323 broadcast if conditions are met.
        ndpi_struct->h323_packets++;
        if(ntohl(*(u_int32_t*)(packet->tcp->payload + 8)) == 0x00000000)
        {
          ndpi_struct->h323_broadcast++;
        }
      }
    }
  }
  // For UDP packets, compute source and destination ports and validate the payload structure.
  else if(packet->udp!= NULL)
  {
    dport = ntohs(packet->udp->dest);
    sport = ntohs(packet->udp->source);
    if(dport == 1720 || sport == 1720)
    {
      // Identify H.323 broadcasts by checking specific byte patterns and packet length.
      if(packet->udp->payload_len >= 4 && ntohs(*(u_int16_t*)(packet->udp->payload)) == 0x0305)
      {
        ndpi_struct->h323_packets++;
        if(ntohl(*(u_int32_t*)(packet->udp->payload + 8)) == 0x00000000)
        {
          ndpi_struct->h323_broadcast++;
        }
      }
    }
  }
  // Exclude non-H.323 protocols from detection if conditions are not satisfied.
  else
  {
    // <MASK>
  }
}