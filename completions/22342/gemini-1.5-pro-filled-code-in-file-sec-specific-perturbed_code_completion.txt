{
    const u_int8_t *payload = packet->payload;
    u_int32_t payload_len = packet->payload_len;

    if (payload_len < sizeof(struct tpkt)) {
      return;
    }

    struct tpkt *tpkt_header = (struct tpkt *)payload;
    u_int16_t tpkt_len = ntohs(tpkt_header->len);

    if (tpkt_len < sizeof(struct tpkt) || tpkt_len > payload_len) {
      return;
    }

    if (tpkt_header->version != 3) {
      return;
    }

    /*
     * Check to avoid misidentification with RDP traffic.
     * RDP's TPKT header is followed by a 3 byte header
     * starting with 0x03 0x00 0x00.
     */
    if (tpkt_len > 4 && payload[4] == 0x03 && payload[5] == 0x00 && payload[6] == 0x00) {
      return;
    }

    NDPI_LOG_DBG(ndpi_struct, "found H323\n");
    ndpi_set_detected_protocol(ndpi_struct, stream, NDPI_PROTOCOL_H323, NDPI_PROTOCOL_UNKNOWN);

    if (payload[sizeof(struct tpkt)] == 0x08 && tpkt_len == 8) {
      NDPI_LOG_DBG(ndpi_struct, "found H323 broadcast\n");
    }

    return;
  } else if(packet->udp != NULL) {
    const u_int8_t *payload = packet->payload;
    u_int32_t payload_len = packet->payload_len;

    sport = ntohs(packet->udp->source), dport = ntohs(packet->udp->dest);

    if (payload_len < sizeof(struct tpkt)) {
      return;
    }

    struct tpkt *tpkt_header = (struct tpkt *)payload;
    u_int16_t tpkt_len = ntohs(tpkt_header->len);

    if (tpkt_len < sizeof(struct tpkt) || tpkt_len > payload_len) {
      return;
    }

    if (tpkt_header->version != 3) {
      return;
    }

    NDPI_LOG_DBG(ndpi_struct, "found H323\n");
    ndpi_set_detected_protocol(ndpi_struct, stream, NDPI_PROTOCOL_H323, NDPI_PROTOCOL_UNKNOWN);

    if (payload[sizeof(struct tpkt)] == 0x08 && tpkt_len == 8) {
      NDPI_LOG_DBG(ndpi_struct, "found H323 broadcast\n");
    }

    return;
  } else {
    NDPI_LOG_DBG(ndpi_struct, "exclude H323\n");
    NDPI_ADD_PROTOCOL_TO_BITMASK(ndpi_struct, stream->excluded_protocol_bitmask, NDPI_PROTOCOL_H323);
  }