if((packet->tcp != NULL) && (packet->tcp->dest == ntohs(102))) {
    u_int8_t *packet_data = packet->payload;
    u_int16_t packet_len = packet->payload_packet_len;

    // Check if the packet is using TCP and the destination port is 102
    if (packet_len >= sizeof(struct tpkt) && packet_data[0] == 0x03 && packet_data[1] == 0x00) {
      struct tpkt *tpkt_header = (struct tpkt *)packet_data;

      // Check if the TPKT header is valid
      if (tpkt_header->version == 0x03 && tpkt_header->reserved == 0x00) {
        u_int16_t tpkt_len = ntohs(tpkt_header->len);

        // Check if the TPKT length is valid
        if (tpkt_len >= sizeof(struct tpkt) && tpkt_len <= packet_len) {
          // Inspect specific payload byte values to distinguish between H.323 and RDP protocols
          if (packet_data[4] == 0x00 && packet_data[5] == 0x00) {
            // Increment the count of valid H.323 packets
            stream->valid_protocol_detected = NDPI_PROTOCOL_H323;
            NDPI_LOG_INFO(ndpi_struct, "Detected H.323\n");
          }
        }
      }
    }
  } else if (packet->udp != NULL) {
    u_int8_t *packet_data = packet->payload;
    u_int16_t packet_len = packet->payload_packet_len;

    // Check if the packet is using UDP
    if (packet_len >= 4) {
      // Compute source and destination ports
      sport = ntohs(packet->udp->source);
      dport = ntohs(packet->udp->dest);

      // Validate the payload structure
      if (packet_len >= 4 && packet_data[0] == 0x00 && packet_data[1] == 0x00 && packet_data[2] == 0x00 && packet_data[3] == 0x00) {
        // Identify H.323 broadcasts by checking specific byte patterns and packet length
        if (packet_len > 4 && packet_data[4] == 0x00 && packet_data[5] == 0x00) {
          stream->valid_protocol_detected = NDPI_PROTOCOL_H323;
          NDPI_LOG_INFO(ndpi_struct, "Detected H.323 broadcast\n");
        }
      }
    }
  }
}