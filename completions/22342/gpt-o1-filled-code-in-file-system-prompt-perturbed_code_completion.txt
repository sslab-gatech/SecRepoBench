{
  if(packet->tcp != NULL) {
    /* Ensure we have enough data for TPKT header */
    if(packet->payload_packet_len < sizeof(struct tpkt)) return;

    struct tpkt *t = (struct tpkt *)packet->payload;

    /* Validate TPKT version and length */
    if(t->version != 3) return;
    if(ntohs(t->len) != packet->payload_packet_len) return;

    /* Exclude potential RDP by checking common RDP payload signature */
    if(packet->payload[4] == 0xE0) return;

    /*
      Check if payload after TPKT header matches typical Q.931 codes
      used by H.323. Increment H.323 packet counter and set protocol
      if a threshold is met.
    */
    if((packet->payload[4] == 0x08) || (packet->payload[4] == 0x05)) {
      stream->h323_stage++;
      if(stream->h323_stage > 1) {
        ndpi_set_detected_protocol(ndpi_struct, stream, NDPI_PROTOCOL_H323);
        return;
      }
    }
  } else if(packet->udp != NULL) {
    sport = ntohs(packet->udp->source);
    dport = ntohs(packet->udp->dest);

    /*
      For UDP, check known H.323 ports (1719 - RAS, 1720 - Q.931).
      Inspect payload for basic H.225/H.323 formatting. If recognized,
      mark the flow as H.323.
    */
    if(((sport == 1719) || (dport == 1719) || (sport == 1720) || (dport == 1720)) &&
       (packet->payload_packet_len > 4)) {

      /* Basic payload check for H.225/H.323 signaling */
      if((packet->payload[0] == 0x03) || (packet->payload[0] == 0x08)) {
        stream->h323_stage++;
        if(stream->h323_stage > 1) {
          ndpi_set_detected_protocol(ndpi_struct, stream, NDPI_PROTOCOL_H323);
          return;
        }
      }
    }
  }
}