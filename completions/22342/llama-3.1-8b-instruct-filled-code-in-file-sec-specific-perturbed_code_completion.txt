// Check if the packet is using TCP and perform initial validation of the payload.
if (packet->tcp!= NULL) {
  // Determine the length of the TPKT protocol and verify if it matches the expected length.
  struct tpkt *tpkt_header = (struct tpkt *) packet->payload;
  if (packet->payload_len >= sizeof(struct tpkt)) {
    if (ntohs(tpkt_header->len) == packet->payload_len) {
      // Inspect specific payload byte values to distinguish between H.323 and RDP protocols.
      if (packet->payload_len >= 4) {
        u_int32_t magic_number = ntohl(*(u_int32_t *) (packet->payload + 2));
        if (magic_number == 0x01020304) {
          // Increment the count of valid H.323 packets and identify H.323 broadcast if conditions are met.
          ndpi_struct->detection_bitmask[H323_BITMASK] = 1;
          if (packet->payload_len >= 8 && (ntohl(*(u_int32_t *) (packet->payload + 6)) & 0x80000000) == 0x80000000) {
            ndpi_struct->detection_bitmask[H323_BROADCAST_BITMASK] = 1;
          }
        }
      }
    }
  }
}

// For UDP packets, compute source and destination ports and validate the payload structure.
if (packet->udp!= NULL) {
  dport = ntohs(packet->udp->dest);
  sport = ntohs(packet->udp->source);
  // Identify H.323 broadcasts by checking specific byte patterns and packet length.
  if (dport == 1718 || dport == 1719 || dport == 1720) {
    struct tpkt *tpkt_header = (struct tpkt *) packet->payload;
    if (packet->payload_len >= sizeof(struct tpkt)) {
      if (ntohs(tpkt_header->len) == packet->payload_len) {
        if (packet->payload_len >= 4) {
          u_int32_t magic_number = ntohl(*(u_int32_t *) (packet->payload + 2));
          if (magic_number == 0x01020304) {
            // Exclude non-H.323 protocols from detection if conditions are not satisfied.
            ndpi_struct->detection_bitmask[H323_BITMASK] = 1;
            if (packet->payload_len >= 8 && (ntohl(*(u_int32_t *) (packet->payload + 6)) & 0x80000000) == 0x80000000) {
              ndpi_struct->detection_bitmask[H323_BROADCAST_BITMASK] = 1;
            }
          }
        }
      }
    }
  }
}