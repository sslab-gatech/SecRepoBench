{
    u_int16_t len;

    if(packet->payload_packet_len < 4) {
      NDPI_EXCLUDE_PROTO(ndpi_struct, stream);
      return;
    }

    // Check for TPKT header
    if(packet->payload[0] == 0x03) { // TPKT version
      len = (packet->payload[2] << 8) + packet->payload[3];
      if(len != packet->payload_packet_len) {
        NDPI_EXCLUDE_PROTO(ndpi_struct, stream);
        return;
      }

      // Check for H.323 specific payload
      if(packet->payload[4] == 0x08 || packet->payload[4] == 0x15) {
        NDPI_LOG_INFO(ndpi_struct, "Found H.323 over TPKT\n");
        ndpi_set_detected_protocol(ndpi_struct, stream, NDPI_PROTOCOL_H323);
        return;
      }
    }

    // For UDP packets, check for H.323 broadcast
    if(packet->udp != NULL) {
      sport = ntohs(packet->udp->source);
      dport = ntohs(packet->udp->dest);

      if((packet->payload_packet_len >= 8) &&
         (packet->payload[0] == 0x00) &&
         (packet->payload[1] == 0x01) &&
         (packet->payload[2] == 0x00) &&
         (packet->payload[3] == 0x01)) {
        NDPI_LOG_INFO(ndpi_struct, "Found H.323 broadcast\n");
        ndpi_set_detected_protocol(ndpi_struct, stream, NDPI_PROTOCOL_H323);
        return;
      }
    }

    // Exclude non-H.323 protocols
    NDPI_EXCLUDE_PROTO(ndpi_struct, stream);
  }