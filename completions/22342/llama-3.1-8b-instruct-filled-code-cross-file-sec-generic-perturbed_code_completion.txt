// Check if the packet is using TCP and perform initial validation of the payload.
if ((packet->tcp!= NULL) && (packet->tcp->dest!= ntohs(102))) {
  // Determine the length of the TPKT protocol and verify if it matches the expected length.
  if (packet->tcp->payload_len >= 4) {
    u_int32_t tpkt_len = *(u_int32_t *)packet->tcp->payload;
    if (tpkt_len >= 4 && tpkt_len <= 1024) {
      // Inspect specific payload byte values to distinguish between H.323 and RDP protocols.
      if (packet->tcp->payload_len >= tpkt_len + 4) {
        u_int8_t *payload = (u_int8_t *)packet->tcp->payload + 4;
        if (payload[0] == 0x00 && payload[1] == 0x01 && payload[2] == 0x00 && payload[3] == 0x01) {
          // Increment the count of valid H.323 packets and identify H.323 broadcast if conditions are met.
          ndpi_struct->detection_bitmask[NDPI_PROTOCOL_H323] = 1;
          if (packet->ip->src == INADDR_BROADCAST) {
            ndpi_struct->detection_bitmask[NDPI_PROTOCOL_H323_BROADCAST] = 1;
          }
        } else if (payload[0] == 0x00 && payload[1] == 0x01 && payload[2] == 0x00 && payload[3] == 0x02) {
          // For UDP packets, compute source and destination ports and validate the payload structure.
          if (packet->udp!= NULL) {
            dport = ntohs(packet->udp->dest);
            sport = ntohs(packet->udp->src);
            if (dport == 1720 && sport == 1720) {
              // Identify H.323 broadcasts by checking specific byte patterns and packet length.
              if (packet->ip->src == INADDR_BROADCAST) {
                ndpi_struct->detection_bitmask[NDPI_PROTOCOL_H323_BROADCAST] = 1;
              }
            }
          }
        }
      }
    }
  }
}