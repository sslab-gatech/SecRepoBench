// Check if the packet is using TCP and perform initial validation of the payload.
if(packet->tcp!= NULL) {
  struct tpkt *tpkt = (struct tpkt *)packet->payload;
  u_int16_t tpkt_len = ntohs(tpkt->len);

  // Determine the length of the TPKT protocol and verify if it matches the expected length.
  if(packet->payload_packet_len >= sizeof(struct tpkt) && tpkt_len == packet->payload_packet_len - sizeof(struct tpkt)) {
    // Inspect specific payload byte values to distinguish between H.323 and RDP protocols.
    if(tpkt->version == 3 && tpkt->reserved == 0) {
      // Increment the count of valid H.323 packets and identify H.323 broadcast if conditions are met.
      NDPI_ADD_PROTOCOL_TO_BITMASK(detection_bitmask, NDPI_PROTOCOL_H323);
      if(packet->payload_packet_len == 12 && tpkt->len == htons(8)) {
        // H.323 broadcast
        NDPI_ADD_PROTOCOL_TO_BITMASK(detection_bitmask, NDPI_PROTOCOL_H323_BROADCAST);
      }
    }
  }
} else if(packet->udp!= NULL) {
  // Compute source and destination ports and validate the payload structure.
  sport = ntohs(packet->udp->source);
  dport = ntohs(packet->udp->dest);
  if(packet->payload_packet_len >= sizeof(struct tpkt)) {
    struct tpkt *tpkt = (struct tpkt *)packet->payload;
    u_int16_t tpkt_len = ntohs(tpkt->len);

    // Identify H.323 broadcasts by checking specific byte patterns and packet length.
    if(packet->payload_packet_len == 12 && tpkt->len == htons(8) && tpkt->version == 3 && tpkt->reserved == 0) {
      // H.323 broadcast
      NDPI_ADD_PROTOCOL_TO_BITMASK(detection_bitmask, NDPI_PROTOCOL_H323_BROADCAST);
    }
  }
}