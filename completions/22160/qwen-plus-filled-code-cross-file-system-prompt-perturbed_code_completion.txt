// Read and skip bytes from the current offset to the specified image offset.
if (offset < (MagickOffsetType) dpx.file.image_offset)
{
    ssize_t remaining = (ssize_t) (dpx.file.image_offset - offset);
    while (remaining > 0)
    {
        unsigned char buffer[4096];
        size_t bytes_to_read = (size_t) MagickMin(remaining, 4096);
        count = ReadBlob(image, bytes_to_read, buffer);
        if (count != (ssize_t) bytes_to_read || EOF == count)
            ThrowReaderException(CorruptImageError, "UnexpectedEndOfFile");
        remaining -= count;
    }
}

// If an unexpected end of file is encountered, throw an exception.
if (EOFBlob(image) != MagickFalse)
    ThrowReaderException(CorruptImageError, "UnexpectedEndOfFile");

// If the 'ping' option is enabled in the image info, close the image blob
// and return the first image in the list without further processing.
if (image_info->ping != MagickFalse)
{
    (void) CloseBlob(image);
    return GetFirstImageInList(image);
}

// Set the image extent to the defined number of columns and rows.
image->extent = image->columns * image->rows;