// Ensure the offset is valid and skip to the image data offset
  if (dpx.file.image_offset > offset)
  {
    MagickOffsetType skip_bytes = dpx.file.image_offset - offset;
    while (skip_bytes > 0)
    {
      ssize_t bytes_to_read = (ssize_t) MagickMin(skip_bytes, MagickPathExtent);
      unsigned char buffer[MagickPathExtent];
      count = ReadBlob(image, bytes_to_read, buffer);
      if (count <= 0)
        ThrowReaderException(CorruptImageError, "UnexpectedEndOfFile");
      skip_bytes -= count;
      offset += count;
    }
  }
  else if (dpx.file.image_offset < offset)
  {
    ThrowReaderException(CorruptImageError, "InvalidImageOffset");
  }

  // If the 'ping' option is enabled, return the first image without further processing
  if (image_info->ping != MagickFalse)
  {
    (void) CloseBlob(image);
    return GetFirstImageInList(image);
  }

  // Set the image extent to the defined number of columns and rows
  if ((image->columns == 0) || (image->rows == 0))
    ThrowReaderException(CorruptImageError, "ImproperImageHeader");
  if (SetImageExtent(image, image->columns, image->rows, exception) == MagickFalse)
    return DestroyImageList(image);