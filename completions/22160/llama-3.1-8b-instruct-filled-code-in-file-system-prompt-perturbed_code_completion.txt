// <MASK>
  // Read and skip bytes from the current offset to the specified image offset.
  // If an unexpected end of file is encountered, throw an exception.
  // If the 'ping' option is enabled in the image info, close the image blob
  // and return the first image in the list without further processing.
  // Set the image extent to the defined number of columns and rows.
  offset=(MagickOffsetType) dpx.file.image_offset;
  if (EOFBlob(image)!= MagickFalse)
    ThrowFileException(exception,CorruptImageError,"UnexpectedEndOfFile",
      image->filename);
  if ((image_info->ping!= MagickFalse) && (offset!= 0))
    {
      (void) CloseBlob(image);
      return(GetFirstImageInList(image));
    }
  if (offset!= 0)
    {
      for ( ; offset < GetBlobSize(image); offset++)
        if (ReadBlobByte(image) == EOF)
          break;
      if (offset!= GetBlobSize(image))
        ThrowFileException(exception,CorruptImageError,"UnexpectedEndOfFile",
          image->filename);
    }
  image->columns=dpx.image.pixels_per_line;
  image->rows=dpx.image.lines_per_element;
  if ((image->columns!= (unsigned int) image->columns) ||
      (image->rows!= (unsigned int) image->rows))
    ThrowWriterException(ImageError,"WidthOrHeightExceedsLimit");
  if ((horizontal_factor!= 1) && (horizontal_factor!= 2) &&
      (horizontal_factor!= 4) && (vertical_factor!= 1) &&
      (vertical_factor!= 2) && (vertical_factor!= 4))
    ThrowWriterException(CorruptImageError,"UnexpectedSamplingFactor");
  if ((image->colorspace == YCbCrColorspace) &&
      ((horizontal_factor == 2) || (vertical_factor == 2)))
    if ((image->columns % 2)!= 0)
      image->columns++;
  // <MASK>