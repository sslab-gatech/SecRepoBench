);
  offset+=WriteBlobLong(image,(unsigned int) cin.film.frame_position);
  cin.film.sequence_extent=0UL;
  value=GetCINProperty(image_info,image,"dpx:film.sequence_extent",exception);
  if (value != (const char *) NULL)
    cin.film.sequence_extent=StringToUnsignedLong(value);
  offset+=WriteBlobLong(image,(unsigned int) cin.film.sequence_extent);
  cin.film.held_count=0UL;
  value=GetCINProperty(image_info,image,"dpx:film.held_count",exception);
  if (value != (const char *) NULL)
    cin.film.held_count=StringToUnsignedLong(value);
  offset+=WriteBlobLong(image,(unsigned int) cin.film.held_count);
  cin.film.frame_rate=0.0f;
  value=GetCINProperty(image_info,image,"dpx:film.frame_rate",exception);
  if (value != (const char *) NULL)
    cin.film.frame_rate=StringToDouble(value,(char **) NULL);
  offset+=WriteBlobFloat(image,cin.film.frame_rate);
  cin.film.shutter_angle=0.0f;
  value=GetCINProperty(image_info,image,"dpx:film.shutter_angle",exception);
  if (value != (const char *) NULL)
    cin.film.shutter_angle=StringToDouble(value,(char **) NULL);
  offset+=WriteBlobFloat(image,cin.film.shutter_angle);
  value=GetCINProperty(image_info,image,"dpx:film.slate",exception);
  if (value != (const char *) NULL)
    (void) CopyMagickString(cin.film.slate,value,sizeof(cin.film.slate));
  offset+=WriteBlob(image,sizeof(cin.film.slate),(unsigned char *)
    cin.film.slate);
  offset+=WriteBlob(image,sizeof(cin.film.reserve),(unsigned char *)
    cin.film.reserve);
  /*
    Image television information.
  */
  cin.television.time_code=0UL;
  value=GetCINProperty(image_info,image,"dpx:television.time.code",exception);
  if (value != (const char *) NULL)
    cin.television.time_code=StringToTimeCode(value);
  offset+=WriteBlobLong(image,(unsigned int) cin.television.time_code);
  cin.television.user_bits=0UL;
  value=GetCINProperty(image_info,image,"dpx:television.user.bits",exception);
  if (value != (const char *) NULL)
    cin.television.user_bits=StringToTimeCode(value);
  offset+=WriteBlobLong(image,(unsigned int) cin.television.user_bits);
  cin.television.interlace=0;
  value=GetCINProperty(image_info,image,"dpx:television.interlace",exception);
  if (value != (const char *) NULL)
    cin.television.interlace=(char) StringToLong(value);
  offset+=WriteBlobByte(image,(unsigned char) cin.television.interlace);
  cin.television.field_number=0;
  value=GetCINProperty(image_info,image,"dpx:television.field_number",exception);
  if (value != (const char *) NULL)
    cin.television.field_number=(char) StringToLong(value);
  offset+=WriteBlobByte(image,(unsigned char) cin.television.field_number);
  cin.television.video_signal=0;
  value=GetCINProperty(image_info,image,"dpx:television.video_signal",exception);
  if (value != (const char *) NULL)
    cin.television.video_signal=(char) StringToLong(value);
  offset+=WriteBlobByte(image,(unsigned char) cin.television.video_signal);
  cin.television.padding=0;
  value=GetCINProperty(image_info,image,"dpx:television.padding",exception);
  if (value != (const char *) NULL)
    cin.television.padding=(char) StringToLong(value);
  offset+=WriteBlobByte(image,(unsigned char) cin.television.padding);
  cin.television.horizontal_sample_rate=0.0f;
  value=GetCINProperty(image_info,image,"dpx:television.horizontal_sample_rate",
    exception);
  if (value != (const char *) NULL)
    cin.television.horizontal_sample_rate=StringToDouble(value,(char **) NULL);
  offset+=WriteBlobFloat(image,cin.television.horizontal_sample_rate);
  cin.television.vertical_sample_rate=0.0f;
  value=GetCINProperty(image_info,image,"dpx:television.vertical_sample_rate",
    exception);
  if (value != (const char *) NULL)
    cin.television.vertical_sample_rate=StringToDouble(value,(char **) NULL);
  offset+=WriteBlobFloat(image,cin.television.vertical_sample_rate);
  cin.television.frame_rate=0.0f;
  value=GetCINProperty(image_info,image,"dpx:television.frame_rate",exception);
  if (value != (const char *) NULL)
    cin.television.frame_rate=StringToDouble(value,(char **) NULL);
  offset+=WriteBlobFloat(image,cin.television.frame_rate);
  cin.television.time_offset=0.0f;
  value=GetCINProperty(image_info,image,"dpx:television.time_offset",exception);
  if (value != (const char *) NULL)
    cin.television.time_offset=StringToDouble(value,(char **) NULL);
  offset+=WriteBlobFloat(image,cin.television.time_offset);
  cin.television.gamma=0.0f;
  value=GetCINProperty(image_info,image,"dpx:television.gamma",exception);
  if (value != (const char *) NULL)
    cin.television.gamma=StringToDouble(value,(char **) NULL);
  offset+=WriteBlobFloat(image,cin.television.gamma);
  cin.television.black_level=0.0f;
  value=GetCINProperty(image_info,image,"dpx:television.black_level",exception);
  if (value != (const char *) NULL)
    cin.television.black_level=StringToDouble(value,(char **) NULL);
  offset+=WriteBlobFloat(image,cin.television.black_level);
  cin.television.black_gain=0.0f;
  value=GetCINProperty(image_info,image,"dpx:television.black_gain",exception);
  if (value != (const char *) NULL)
    cin.television.black_gain=StringToDouble(value,(char **) NULL);
  offset+=WriteBlobFloat(image,cin.television.black_gain);
  cin.television.break_point=0.0f;
  value=GetCINProperty(image_info,image,"dpx:television.break_point",exception);
  if (value != (const char *) NULL)
    cin.television.break_point=StringToDouble(value,(char **) NULL);
  offset+=WriteBlobFloat(image,cin.television.break_point);
  cin.television.white_level=0.0f;
  value=GetCINProperty(image_info,image,"dpx:television.white_level",exception);
  if (value != (const char *) NULL)
    cin.television.white_level=StringToDouble(value,(char **) NULL);
  offset+=WriteBlobFloat(image,cin.television.white_level);
  cin.television.integration_times=0.0f;
  value=GetCINProperty(image_info,image,"dpx:television.integration_times",
    exception);
  if (value != (const char *) NULL)
    cin.television.integration_times=StringToDouble(value,(char **) NULL);
  offset+=WriteBlobFloat(image,cin.television.integration_times);
  offset+=WriteBlob(image,sizeof(cin.television.reserve),(unsigned char *)
    cin.television.reserve);
  /*
    Write user information.
  */
  value=GetCINProperty(image_info,image,"dpx:user.id",exception);
  if (value != (const char *) NULL)
    (void) CopyMagickString(cin.user.id,value,sizeof(cin.user.id));
  offset+=WriteBlob(image,sizeof(cin.user.id),(unsigned char *) cin.user.id);
  if (profile != (StringInfo *) NULL)
    offset+=WriteBlob(image,GetStringInfoLength(profile),
      GetStringInfoDatum(profile));
  while (offset < (MagickOffsetType) cin.file.image_offset)
  {
    count=WriteBlobByte(image,0x00);
    if (count != 1)
      {
        ThrowFileException(exception,FileOpenError,"UnableToWriteFile",
          image->filename);
        break;
      }
    offset+=count;
  }
  /*
    Convert pixel packets to CIN raster image.
  */
  quantum_info=AcquireQuantumInfo(image_info,image);
  if (quantum_info == (QuantumInfo *) NULL)
    ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
  SetQuantumQuantum(quantum_info,32);
  SetQuantumPack(quantum_info,cin.data_format.packing == 0 ?
    MagickTrue : MagickFalse);
  quantum_type=RGBQuantum;
  if (image->alpha_trait != UndefinedPixelTrait)
    quantum_type=RGBAQuantum;
  if (image->colorspace == YCbCrColorspace)
    {
      quantum_type=CbYCrQuantum;
      if (image->alpha_trait != UndefinedPixelTrait)
        quantum_type=CbYCrAQuantum;
    }
  length=GetBytesPerRow(image->columns,3UL,image->depth,
    cin.data_format.packing == 0 ? MagickFalse : MagickTrue);
  pixels=(unsigned char *) GetQuantumPixels(quantum_info);
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    p=GetVirtualPixels(image,0,y,image->columns,1,exception);
    if (p == (const Quantum *) NULL)
      break;
    length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,
      quantum_type,pixels,exception);
    if (length == 0)
      break;
    count=WriteBlob(image,length,pixels);
    if (count != (ssize_t) length)
      break;
    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
      image->rows);
    if (status == MagickFalse)
      break;
  }
  quantum_info=DestroyQuantumInfo(quantum_info);
  if (y < (ssize_t) image->rows)
    ThrowWriterException(CorruptImageError,"UnableToWriteImageData");
  (void) CloseBlob(image);
  return(status);
}

// the below code fragment can be found in:
// coders/cin.c
static Image *ReadCINImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  char
    magick[4],
    value[MagickPathExtent];

  CINInfo
    cin;

  Image
    *image;

  MagickBooleanType
    operationsuccess;

  MagickOffsetType
    offset;

  QuantumInfo
    *quantum_info;

  QuantumType
    quantum_type;

  register ssize_t
    i;

  size_t
    extent,
    samples_per_pixel;

  ssize_t
    count,
    n,
    row,
    y;

  unsigned char
    component_type;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  operationsuccess=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (operationsuccess == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Read CIN file header.
  */
  offset=0;
  count=ReadBlob(image,4,(unsigned char *) magick);
  offset+=count;
  if ((count != 4) || (LocaleNCompare(magick,"CIN ",4) != 0))
    ThrowReaderException(CorruptImageError,"ImproperImageHeader");
  cin.file.image_offset=ReadBlobLong(image);
  offset+=4;
  cin.file.generic_length=ReadBlobLong(image);
  offset+=4;
  cin.file.industry_length=ReadBlobLong(image);
  offset+=4;
  cin.file.user_length=ReadBlobLong(image);
  offset+=4;
  cin.file.file_size=ReadBlobLong(image);
  offset+=4;
  (void) ReadBlob(image,8,(unsigned char *) cin.file.version);
  offset+=8;
  (void) ReadBlob(image,sizeof(cin.file.filename),(unsigned char *)
    cin.file.filename);
  (void) FormatImageProperty(image,"dpx:file.filename","%.100s",
    cin.file.filename);
  (void) FormatImageProperty(image,"document","%.100s",cin.file.filename);
  offset+=ReadBlob(image,sizeof(cin.file.filename),(unsigned char *)
    cin.file.filename);
  (void) ReadBlob(image,sizeof(cin.file.create_date),(unsigned char *)
    cin.file.create_date);
  if (*cin.file.create_date != '\0')
    (void) FormatImageProperty(image,"dpx:file.create_date","%.11s",
      cin.file.create_date);
  (void) ReadBlob(image,sizeof(cin.file.create_time),(unsigned char *)
    cin.file.create_time);
  if (*cin.file.create_time != '\0')
    (void) FormatImageProperty(image,"dpx:file.create_time","%.11s",
      cin.file.create_time);
  offset+=ReadBlob(image,sizeof(cin.file.reserve),(unsigned char *)
    cin.file.reserve);
  /*
    Read CIN image header.
  */
  cin.image.orientation=ReadBlobByte(image);
  offset++;
  if (cin.image.orientation > 7)
    ThrowReaderException(CorruptImageError,"ImproperImageHeader");
  switch (cin.image.orientation)
  {
    default:
    case 0: image->orientation=TopLeftOrientation; break;
    case 1: image->orientation=TopRightOrientation; break;
    case 2: image->orientation=BottomLeftOrientation; break;
    case 3: image->orientation=BottomRightOrientation; break;
    case 4: image->orientation=LeftTopOrientation; break;
    case 5: image->orientation=RightTopOrientation; break;
    case 6: image->orientation