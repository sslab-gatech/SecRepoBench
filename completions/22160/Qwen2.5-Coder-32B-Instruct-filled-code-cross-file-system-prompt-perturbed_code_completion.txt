=StringToUnsignedLong(value);
  offset+=WriteBlobLong(image,(unsigned int) cin.film.frame_position);
  cin.film.sequence_extent=0UL;
  value=GetCINProperty(image_info,image,"dpx:film.sequence_extent",exception);
  if (value != (const char *) NULL)
    cin.film.sequence_extent=StringToUnsignedLong(value);
  offset+=WriteBlobLong(image,(unsigned int) cin.film.sequence_extent);
  cin.film.held_count=0UL;
  value=GetCINProperty(image_info,image,"dpx:film.held_count",exception);
  if (value != (const char *) NULL)
    cin.film.held_count=StringToUnsignedLong(value);
  offset+=WriteBlobLong(image,(unsigned int) cin.film.held_count);
  cin.film.frame_rate=0.0f;
  value=GetCINProperty(image_info,image,"dpx:film.frame_rate",exception);
  if (value != (const char *) NULL)
    cin.film.frame_rate=StringToDouble(value,(char **) NULL);
  offset+=WriteBlobFloat(image,cin.film.frame_rate);
  cin.film.shutter_angle=0.0f;
  value=GetCINProperty(image_info,image,"dpx:film.shutter_angle",exception);
  if (value != (const char *) NULL)
    cin.film.shutter_angle=StringToDouble(value,(char **) NULL);
  offset+=WriteBlobFloat(image,cin.film.shutter_angle);
  (void) memset(cin.film.frame_id,0,sizeof(cin.film.frame_id));
  value=GetCINProperty(image_info,image,"dpx:film.frame_id",exception);
  if (value != (const char *) NULL)
    (void) CopyMagickString(cin.film.frame_id,value,sizeof(cin.film.frame_id));
  offset+=WriteBlob(image,sizeof(cin.film.frame_id),(unsigned char *)
    cin.film.frame_id);
  (void) memset(cin.film.slate,0,sizeof(cin.film.slate));
  value=GetCINProperty(image_info,image,"dpx:film.slate",exception);
  if (value != (const char *) NULL)
    (void) CopyMagickString(cin.film.slate,value,sizeof(cin.film.slate));
  offset+=WriteBlob(image,sizeof(cin.film.slate),(unsigned char *)
    cin.film.slate);
  offset+=WriteBlob(image,sizeof(cin.film.reserve),(unsigned char *)
    cin.film.reserve);
  /*
    Write user information.
  */
  value=GetCINProperty(image_info,image,"dpx:user.id",exception);
  if (value != (const char *) NULL)
    (void) CopyMagickString(cin.user.id,value,sizeof(cin.user.id));
  offset+=WriteBlob(image,sizeof(cin.user.id),(unsigned char *) cin.user.id);
  if (profile != (StringInfo *) NULL)
    offset+=WriteBlob(image,GetStringInfoLength(profile),
      GetStringInfoDatum(profile));
  while (offset < (MagickOffsetType) cin.file.image_offset)
  {
    count=WriteBlobByte(image,0x00);
    if (count != 1)
      {
        ThrowFileException(exception,FileOpenError,"UnableToWriteFile",
          image->filename);
        break;
      }
      offset+=count;
  }
  /*
    Convert pixel packets to CIN raster pixels.
  */
  quantum_info=AcquireQuantumInfo(image_info,image);
  if (quantum_info == (QuantumInfo *) NULL)
    ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
  SetQuantumDepth(image,quantum_info,image->depth);
  SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);
  quantum_type=RGBQuantum;
  length=GetBytesPerRow(image->columns,3,image->depth,MagickTrue);
  pixels=(unsigned char *) GetQuantumPixels(quantum_info);
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    p=GetVirtualPixels(image,0,y,image->columns,1,exception);
    if (p == (const Quantum *) NULL)
      break;
    length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,
      quantum_type,pixels,exception);
    if (length == 0)
      break;
    count=WriteBlob(image,length,pixels);
    if (count != (ssize_t) length)
      break;
    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
      image->rows);
    if (status == MagickFalse)
      break;
  }
  quantum_info=DestroyQuantumInfo(quantum_info);
  if (y < (ssize_t) image->rows)
    ThrowWriterException(CorruptImageError,"UnableToWriteImageData");
  (void) CloseBlob(image);
  return(status);
}

// the below code fragment can be found in:
// coders/cin.c
static MagickBooleanType ReadCINImage(const ImageInfo *image_info,Image *image,
  ExceptionInfo *exception)
{
  char
    timestamp[MagickPathExtent];

  CINInfo
    cin;

  const char
    *value;

  MagickBooleanType
    status;

  MagickOffsetType
    offset;

  QuantumInfo
    *quantum_info;

  QuantumType
    quantum_type;

  register ssize_t
    i;

  size_t
    extent;

  ssize_t
    count,
    y;

  struct tm
    utc_time;

  time_t
    seconds;

  unsigned char
    *pixels;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    return(status);
  /*
    Read image header.
  */
  offset=0;
  count=ReadBlob(image,4,(unsigned char *) &cin.file.magic);
  offset+=count;
  if ((count != 4) || (cin.file.magic != 0x802A5FD7UL))
    ThrowReaderException(CorruptImageError,"ImproperImageHeader");
  cin.file.image_offset=ReadBlobLong(image);
  offset+=4;
  cin.file.generic_length=ReadBlobLong(image);
  offset+=4;
  cin.file.industry_length=ReadBlobLong(image);
  offset+=4;
  cin.file.user_length=ReadBlobLong(image);
  offset+=4;
  cin.file.file_size=ReadBlobLong(image);
  offset+=4;
  count=ReadBlob(image,sizeof(cin.file.version),(unsigned char *)
    cin.file.version);
  offset+=count;
  cin.file.version[sizeof(cin.file.version)-1]='\0';
  if (LocaleCompare(cin.file.version,"V4.5") != 0)
    ThrowReaderException(CorruptImageError,"ImproperImageHeader");
  count=ReadBlob(image,sizeof(cin.file.filename),(unsigned char *)
    cin.file.filename);
  offset+=count;
  cin.file.filename[sizeof(cin.file.filename)-1]='\0';
  (void) FormatImageProperty(image,"dpx:file.filename","%.100s",
    cin.file.filename);
  (void) FormatImageProperty(image,"document","%.100s",cin.file.filename);
  count=ReadBlob(image,sizeof(cin.file.create_date),(unsigned char *)
    cin.file.create_date);
  offset+=count;
  cin.file.create_date[sizeof(cin.file.create_date)-1]='\0';
  count=ReadBlob(image,sizeof(cin.file.create_time),(unsigned char *)
    cin.file.create_time);
  offset+=count;
  cin.file.create_time[sizeof(cin.file.create_time)-1]='\0';
  (void) FormatLocaleString(timestamp,MagickPathExtent,"%s:%s",
    cin.file.create_date,cin.file.create_time);
  seconds=ParseDateTime(timestamp,&utc_time);
  if (seconds != (time_t) (-1))
    image->modification_time=seconds;
  offset+=ReadBlob(image,sizeof(cin.file.reserve),(unsigned char *)
    cin.file.reserve);
  cin.image.orientation=ReadBlobByte(image);
  offset++;
  cin.image.number_channels=ReadBlobByte(image);
  offset++;
  if (cin.image.number_channels != 3)
    ThrowReaderException(CorruptImageError,"ImproperImageHeader");
  offset+=ReadBlob(image,sizeof(cin.image.reserve1),(unsigned char *)
    cin.image.reserve1);
  for (i=0; i < 8; i++)
  {
    char
      property[MagickPathExtent];

    cin.image.channel[i].designator[0]=ReadBlobByte(image);
    offset++;
    cin.image.channel[i].designator[1]=ReadBlobByte(image);
    offset++;
    cin.image.channel[i].bits_per_pixel=ReadBlobByte(image);
    offset++;
    offset++;
    cin.image.channel[i].pixels_per_line=ReadBlobLong(image);
    offset+=4;
    cin.image.channel[i].lines_per_image=ReadBlobLong(image);
    offset+=4;
    cin.image.channel[i].min_data=ReadBlobFloat(image);
    offset+=4;
    cin.image.channel[i].min_quantity=ReadBlobFloat(image);
    offset+=4;
    cin.image.channel[i].max_data=ReadBlobFloat(image);
    offset+=4;
    cin.image.channel[i].max_quantity=ReadBlobFloat(image);
    offset+=4;
    (void) FormatLocaleString(property,MagickPathExtent,
      "dpx:image.channel[%lu].min-data",(long) i);
    (void) FormatImageProperty(image,property,"%g",cin.image.channel[i].min_data);
    (void) FormatLocaleString(property,MagickPathExtent,
      "dpx:image.channel[%lu].min-quantity",(long) i);
    (void) FormatImageProperty(image,property,"%g",
      cin.image.channel[i].min_quantity);
    (void) FormatLocaleString(property,MagickPathExtent,
      "dpx:image.channel[%lu].max-data",(long) i);
    (void) FormatImageProperty(image,property,"%g",cin.image.channel[i].max_data);
    (void) FormatLocaleString(property,MagickPathExtent,
      "dpx:image.channel[%lu].max-quantity",(long) i);
    (void) FormatImageProperty(image,property,"%g",
      cin.image.channel[i].max_quantity);
  }
  image->chromaticity.white_point.x=ReadBlobFloat(image);
  image->chromaticity.white_point.y=ReadBlobFloat(image);
  image->chromaticity.red_primary.x=ReadBlobFloat(image);
  image->chromaticity.red_primary.y=ReadBlobFloat(image);
  image->chromaticity.green_primary.x=ReadBlobFloat(image);
  image->chromaticity.green_primary.y=ReadBlobFloat(image);
  image->chromaticity.blue_primary.x=ReadBlobFloat(image);
  image->chromaticity.blue_primary.y=ReadBlobFloat(image);
  offset+=24;
  count=ReadBlob(image,sizeof(cin.image.label),(unsigned char *)
    cin.image.label);
  offset+=count;
  cin.image.label[sizeof(cin.image.label)-1]='\0';
  (void) FormatImageProperty(image,"dpx:image.label","%.200s",cin.image.label);
  offset+=ReadBlob(image,sizeof(cin.image.reserve),(unsigned char *)
    cin.image.reserve);
  /*
    Read data format information.
  */
  cin.data_format.interleave=ReadBlobByte(image);
  offset++;
  cin.data_format.packing=ReadBlobByte(image);
  offset++;
  cin.data_format.sign=ReadBlobByte(image);
  offset++;
  cin.data_format.sense=ReadBlobByte(image);
  offset++;
  cin.data_format.line_pad=ReadBlobLong(image);
  offset+=4;
  cin.data_format.channel_pad=ReadBlobLong(image);
  offset+=4;
  offset+=ReadBlob(image,sizeof(cin.data_format.reserve),(unsigned char *)
    cin.data_format.reserve);
  /*
    Read origination information.
  */
  cin.origination.x_offset=ReadBlobLong(image);
  offset+=4;
  cin.origination.y_offset=ReadBlobLong(image);
  offset+=4;
  count=ReadBlob(image,sizeof(cin.origination.filename),(unsigned char *)
    cin.origination.filename);
  offset+=count;
  cin.origination.filename[sizeof(cin.origination.filename)-1]='\0';
  (void) FormatImageProperty(image,"dpx:origination.filename","%.100s",
    cin.origination.filename);
  count=ReadBlob(image,sizeof(cin.origination.create_date),(unsigned char *)
    cin.origination.create_date);
  offset+=count;
  cin.origination.create_date[sizeof(cin.origination.create_date)-1]='\0';
  count=ReadBlob(image,sizeof(cin.origination.create_time),(unsigned char *)
    cin.origination.create_time);
  offset+=count;
  cin.origination.create_time[sizeof(cin.origination.create_time)-1]='\0';
  (void) FormatLocaleString(timestamp,MagickPathExtent,"%s:%s",
    cin.origination.create_date,cin.origination.create_time);
  seconds=ParseDateTime(timestamp,&utc_time);
  if (seconds != (time_t) (-1))
    image->modification_time=seconds;
  count=ReadBlob(image,sizeof(cin.origination.device),(unsigned char *)
    cin.origination.device);
  offset+=count;
  cin.origination.device[sizeof(cin.origination.device)-1]='\0';
  (void) FormatImageProperty(image,"dpx:origination.device","%.32s",
    cin.origination.device);
  count=ReadBlob(image,sizeof(cin.origination.model),(unsigned char *)
    cin.origination.model);
  offset+=count;
  cin.origination.model[sizeof(cin.origination.model)-1]='\0';
  (void) FormatImageProperty(image,"dpx:origination.model","%.32s",
    cin.origination.model);
  count=ReadBlob(image,sizeof(cin.origination.serial),(unsigned char *)
    cin.origination.serial);
  offset+=count;
  cin.origination.serial[sizeof(cin.origination.serial)-1]='\0';
  (void) FormatImageProperty(image,"dpx:origination.serial","%.32s",