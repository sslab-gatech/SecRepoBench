switch (tag)
		{
			case ID_SCE:
			case ID_LFE:
				// mono or LFE channel
				elementInstanceTag = BitBufferReadSmall (bits, 4) ;
				p->mActiveElements++ ;	// increment the active element count

				// read the 12-bit header
				headerByte = BitBufferReadSmall (bits, 8) ;
				unusedHeader = headerByte << 4 ;
				extraBits = headerByte >> 4 ;
				unusedHeader |= BitBufferReadSmall (bits, 4) ;

				// check for compressed frames
				if ((unusedHeader & 0x800) != 0)
				{
					// compressed frame, read header parameters
					partialFrame = (unusedHeader >> 11) & 1 ;
					bytesShifted = (unusedHeader >> 7) & 0xF ;
					shift = bytesShifted * 8 ;
					chanBits = p->mBitDepth - shift + extraBits ;
					modeU = 0 ;
					denShiftU = DENSHIFT_DEFAULT ;
					pbFactorU = (unusedHeader >> 4) & 0x7 ;
					numU = unusedHeader & 0xF ;

					if (partialFrame)
						numSamples = BitBufferRead (bits, 32) ;

					// ensure numU is within valid range
					numU = numU < 32 ? numU : 31;

					// read predictor coefficients
					for (i = 0; i < numU; ++i)
						coefsU[i] = (int16_t)BitBufferReadSigned(bits, 16);

					// read shifted values if applicable
					if (bytesShifted != 0)
					{
						shiftBits = *bits;
						for (i = 0; i < numSamples; ++i)
						{
							val = BitBufferRead (&shiftBits, shift);
							p->mShiftBuffer[i] = (uint8_t)(val >> 8);
						}
						*bits = shiftBits;
					}

					// decompress data and apply prediction
					out32 = sampleBuffer + channelIndex;
					status = decompress_frame(p, bits, out32, numSamples, numChannels, coefsU, numU, chanBits,
											  denShiftU, pbFactorU, modeU, bytesShifted);
				}
				else
				{
					// uncompressed frame, read samples directly
					if (partialFrame)
						numSamples = BitBufferRead (bits, 32) ;

					out32 = sampleBuffer + channelIndex ;
					for (i = 0 ; i < numSamples ; i++)
					{
						val = BitBufferReadSigned (bits, p->mBitDepth) ;
						*out32 = val ;
						out32 += numChannels ;
					}
				}

				channelIndex++ ;
				if (channelIndex == numChannels)
					goto NoMoreChannels ;		// we're done with this frame

				break ;

			case ID_CPE:
				// stereo channel pair
				RequireAction (channelIndex < numChannels - 1, status = kALAC_ParamError ; goto Exit ;) ;

				elementInstanceTag = BitBufferReadSmall (bits, 4) ;
				p->mActiveElements++ ;	// increment the active element count

				// read header and process channels
				// ... (similar to mono channel processing)

				channelIndex += 2 ;
				if (channelIndex == numChannels)
					goto NoMoreChannels ;		// we're done with this frame

				break ;

			case ID_CCE:
			case ID_PCE:
			case ID_DSE:
				// unsupported element types
				status = kALAC_UnsupportedFormat ;
				goto Exit ;

			case ID_END:
				// frame end, byte-align and exit
				BitBufferByteAlign (bits, true) ;
				goto Exit ;

			case ID_FIL:
				// fill element, ignore
				elementInstanceTag = BitBufferReadSmall (bits, 4) ;
				break ;

			default:
				// invalid tag
				status = kALAC_InvalidTag ;
				goto Exit ;
		}