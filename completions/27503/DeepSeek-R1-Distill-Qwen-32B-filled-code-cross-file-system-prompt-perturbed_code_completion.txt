switch (tag)
	{
		case ID_SCE:
		case ID_LFE:
		{
			// Read header parameters for mono or LFE element
			elementInstanceTag = BitBufferReadSmall (bits, 4) ;
			agParams.mb0 = p->mConfig.mb ;
			agParams.kb = p->mConfig.kb ;
			agParams.wb = p->mConfig.wb ;
			agParams.maxRun = p->mConfig.maxRun ;
			agParams.numSamples = numSamples ;
			agParams.sampleCount = numSamples ;

			// Decompress audio data
			status = dyn_decomp (&agParams, bits, sampleBuffer + channelIndex, numSamples, 0, &extraBits) ;
			RequireAction (status == ALAC_noErr, break ;) ;

			// Handle partial frames
			if (partialFrame)
			{
				// Read remaining samples
				// (Add code here to handle partial frame decoding)
			}

			channelIndex++ ;
			break ;
		}

		case ID_CPE:
		{
			// Ensure we don't exceed channel limit
			if (channelIndex + 1 >= numChannels)
			{
				status = kALAC_ChannelCountError ;
				break ;
			}

			// Read header parameters for stereo element
			elementInstanceTag = BitBufferReadSmall (bits, 4) ;
			agParams.mb0 = p->mConfig.mb ;
			agParams.kb = p->mConfig.kb ;
			agParams.wb = p->mConfig.wb ;
			agParams.maxRun = p->mConfig.maxRun ;
			agParams.numSamples = numSamples ;
			agParams.sampleCount = numSamples ;

			// Decompress left channel
			status = dyn_decomp (&agParams, bits, sampleBuffer + channelIndex, numSamples, 0, &extraBits) ;
			RequireAction (status == ALAC_noErr, break ;) ;

			// Decompress right channel
			status = dyn_decomp (&agParams, bits, sampleBuffer + channelIndex + 1, numSamples, 0, &extraBits) ;
			RequireAction (status == ALAC_noErr, break ;) ;

			channelIndex += 2 ;
			break ;
		}

		default:
		{
			// Unsupported element type
			printf ("Unsupported element type: %u\n", tag) ;
			status = kALAC_UnsupportedOperation ;
			break ;
		}
	}

	// Align bitstream to byte boundary
	BitBufferByteAlign (bits, true) ;

	// Move to next element
	goto NoMoreChannels ;