switch (tag)
{
    case ID_SCE:
    case ID_LFE:
        // Mono or LFE element
        elementInstanceTag = BitBufferReadSmall(bits, 4);
        p->mActiveElements |= (1 << elementInstanceTag);

        // Read and process header parameters
        headerByte = (uint8_t)BitBufferRead(bits, 8);
        mixBits = headerByte & 0xf;
        mixResiduals = (headerByte >> 4) & 0x1;
        numU = (headerByte >> 5) & 0x7;
        escapeFlag = (headerByte >> 5) & 0x1;
        shift = BitBufferRead(bits, 4);
        unusedHeader = (uint16_t)BitBufferRead(bits, 12);

        if (escapeFlag)
        {
            for (i = 0; i < numSamples; i++)
            {
                val = (int32_t)BitBufferRead(bits, p->mBitDepth);
                sampleBuffer[i * numChannels + channelIndex] = val;
            }
        }
        else
        {
            // Read prediction coefficients
            for (i = 0; i < numU; i++)
                coefsU[i] = (int16_t)BitBufferRead(bits, 16);

            // Decompress and reconstruct audio samples
            status = dyn_decomp(&agParams, bits, p->mMixBufferU, numSamples, p->mBitDepth, &extraBits);
            RequireNoErr(status, goto Exit;);

            // Apply prediction and mixing
            for (i = 0; i < numSamples; i++)
            {
                val = p->mMixBufferU[i];
                if (mixResiduals)
                    val += (p->mMixBufferV[i] >> mixBits);
                sampleBuffer[i * numChannels + channelIndex] = val << shift;
            }
        }

        channelIndex++;
        break;

    case ID_CPE:
        // Stereo element
        elementInstanceTag = BitBufferReadSmall(bits, 4);
        p->mActiveElements |= (1 << elementInstanceTag);

        RequireAction(channelIndex + 2 <= numChannels, status = kALAC_ChannelCountError; goto Exit;);

        // Process left and right channels
        for (j = 0; j < 2; j++)
        {
            // Read and process header parameters (similar to mono case)
            headerByte = (uint8_t)BitBufferRead(bits, 8);
            mixBits = headerByte & 0xf;
            mixResiduals = (headerByte >> 4) & 0x1;
            numU = (headerByte >> 5) & 0x7;
            escapeFlag = (headerByte >> 5) & 0x1;
            shift = BitBufferRead(bits, 4);
            unusedHeader = (uint16_t)BitBufferRead(bits, 12);

            if (escapeFlag)
            {
                for (i = 0; i < numSamples; i++)
                {
                    val = (int32_t)BitBufferRead(bits, p->mBitDepth);
                    sampleBuffer[i * numChannels + channelIndex + j] = val;
                }
            }
            else
            {
                // Read prediction coefficients
                for (i = 0; i < numU; i++)
                    coefsU[i] = (int16_t)BitBufferRead(bits, 16);

                // Decompress and reconstruct audio samples
                status = dyn_decomp(&agParams, bits, j == 0 ? p->mMixBufferU : p->mMixBufferV, numSamples, p->mBitDepth, &extraBits);
                RequireNoErr(status, goto Exit;);
            }
        }

        // Apply prediction and mixing for both channels
        for (i = 0; i < numSamples; i++)
        {
            int32_t leftSample = p->mMixBufferU[i];
            int32_t rightSample = p->mMixBufferV[i];

            if (mixResiduals)
            {
                int32_t mix = (leftSample - rightSample) >> mixBits;
                leftSample = mix + rightSample;
                rightSample = mix - rightSample;
            }

            sampleBuffer[i * numChannels + channelIndex] = leftSample << shift;
            sampleBuffer[i * numChannels + channelIndex + 1] = rightSample << shift;
        }

        channelIndex += 2;
        break;

    case ID_END:
        goto NoMoreChannels;

    case ID_FIL:
        // Skip fill element
        BitBufferAdvance(bits, 4);
        break;

    default:
        status = kALAC_UnsupportedElement;
        goto Exit;
}

BitBufferByteAlign(bits);