// Decode audio data from the bitstream based on the element type specified by the tag.
switch (tag)
{
    case 0: // mono or low-frequency element
    {
        // read and process header parameters
        elementInstanceTag = BitBufferReadSmall (bits, 4) ;
        unusedHeader = BitBufferReadSmall (bits, 4) ;
        escapeFlag = BitBufferReadOne (bits) ;
        if (escapeFlag)
        {
            extraBits = BitBufferReadSmall (bits, 12) ;
        }
        else
        {
            extraBits = 0 ;
        }

        // handle compressed and uncompressed frames
        if (BitBufferReadOne (bits))
        {
            // compressed frame
            alac_fill_element (bits) ;
            mixBits = BitBufferReadSmall (bits, 4) ;
            mixResiduals = (int8_t) BitBufferReadSmall (bits, 3) ;
            headerByte = BitBufferReadSmall (bits, 8) ;
            modeU = (headerByte >> 4) & 0x0F ;
            modeV = headerByte & 0x0F ;
            denShiftU = (modeU < 8) ? modeU : 8 ;
            denShiftV = (modeV < 8) ? modeV : 8 ;
            pbFactorU = (uint16_t) (1 << (pb - denShiftU)) ;
            pbFactorV = (uint16_t) (1 << (pb - denShiftV)) ;

            // decompress data and apply prediction
            alac_data_stream_element (bits) ;
            chanBits = BitBufferReadSmall (bits, 20) ;
            bytesShifted = BitBufferReadSmall (bits, 4) ;
            shift = (uint32_t) bytesShifted * 8 ;
            shiftBits.cur = bits->cur ;
            shiftBits.end = bits->end ;
            BitBufferAdvance (&shiftBits, shift) ;
            alac_fill_element (&shiftBits) ;
            out32 = sampleBuffer + channelIndex ;
            for (i = 0; i < numSamples; i++)
            {
                val = BitBufferReadLarge (&shiftBits, (uint32_t) p->mConfig.bitDepth) ;
                *out32 = val ;
                out32 += numChannels ;
            }
        }
        else
        {
            // uncompressed frame
            partialFrame = BitBufferReadOne (bits) ;
            chanBits = BitBufferReadSmall (bits, 20) ;
            out32 = sampleBuffer + channelIndex ;
            for (i = 0; i < numSamples; i++)
            {
                val = BitBufferReadLarge (bits, (uint32_t) p->mConfig.bitDepth) ;
                *out32 = val ;
                out32 += numChannels ;
            }
        }
        break;
    }
    case 1: // stereo channel pair element
    {
        // ensure channel limit is not exceeded and process each channel separately
        if (channelIndex + 2 > numChannels)
        {
            status = kALAC_TooManyChannels ;
            goto NoMoreChannels ;
        }

        // read and process header parameters for each channel
        for (j = 0; j < 2; j++)
        {
            elementInstanceTag = BitBufferReadSmall (bits, 4) ;
            unusedHeader = BitBufferReadSmall (bits, 4) ;
            escapeFlag = BitBufferReadOne (bits) ;
            if (escapeFlag)
            {
                extraBits = BitBufferReadSmall (bits, 12) ;
            }
            else
            {
                extraBits = 0 ;
            }

            // handle compressed and uncompressed frames for each channel
            if (BitBufferReadOne (bits))
            {
                // compressed frame
                alac_fill_element (bits) ;
                mixBits = BitBufferReadSmall (bits, 4) ;
                mixResiduals = (int8_t) BitBufferReadSmall (bits, 3) ;
                headerByte = BitBufferReadSmall (bits, 8) ;
                modeU = (headerByte >> 4) & 0x0F ;
                modeV = headerByte & 0x0F ;
                denShiftU = (modeU < 8) ? modeU : 8 ;
                denShiftV = (modeV < 8) ? modeV : 8 ;
                pbFactorU = (uint16_t) (1 << (pb - denShiftU)) ;
                pbFactorV = (uint16_t) (1 << (pb - denShiftV)) ;

                // decompress data and apply prediction
                alac_data_stream_element (bits) ;
                chanBits = BitBufferReadSmall (bits, 20) ;
                bytesShifted = BitBufferReadSmall (bits, 4) ;
                shift = (uint32_t) bytesShifted * 8 ;
                shiftBits.cur = bits->cur ;
                shiftBits.end = bits->end ;
                BitBufferAdvance (&shiftBits, shift) ;
                alac_fill_element (&shiftBits) ;
                out32 = sampleBuffer + channelIndex + j ;
                for (i = 0; i < numSamples; i++)
                {
                    val = BitBufferReadLarge (&shiftBits, (uint32_t) p->mConfig.bitDepth) ;
                    *out32 = val ;
                    out32 += numChannels ;
                }
            }
            else
            {
                // uncompressed frame
                partialFrame = BitBufferReadOne (bits) ;
                chanBits = BitBufferReadSmall (bits, 20) ;
                out32 = sampleBuffer + channelIndex + j ;
                for (i = 0; i < numSamples; i++)
                {
                    val = BitBufferReadLarge (bits, (uint32_t) p->mConfig.bitDepth) ;
                    *out32 = val ;
                    out32 += numChannels ;
                }
            }
        }
        channelIndex += 2 ;
        break;
    }
    case 2: // data stream element
    {
        alac_data_stream_element (bits) ;
        break;
    }
    case 3: // fill element
    {
        alac_fill_element (bits) ;
        break;
    }
    default:
    {
        status = kALAC_UnsupportedElementType ;
        goto Exit ;
    }
}