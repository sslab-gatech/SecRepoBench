// <MASK>
while (status == ALAC_noErr)
{
	// bail if we ran off the end of the buffer
	RequireAction (bits->cur < bits->end, status = kALAC_ParamError ; goto Exit ;) ;

	// copy global decode params for this element
	pb = p->mConfig.pb ;

	// read element tag
	tag = BitBufferReadSmall (bits, 3) ;

	switch (tag)
	{
		case ID_SCE:
			// mono
			// Decode audio data from the bitstream based on the element type specified by the tag.
			// For mono or low-frequency elements, read and process header parameters, handling both compressed and uncompressed frames.
			// For compressed frames, decompress data and apply prediction to reconstruct the audio samples.
			// For unsupported elements, set the status to indicate unsupported operations and ignore any fill elements.
			// Finally, align the bitstream to byte boundaries and exit once all channels are processed or the frame end is reached.
			status = DecodeMono (p, bits, sampleBuffer, numSamples, outNumSamples) ;
			break ;

		case ID_CPE:
			// stereo
			// Decode audio data from the bitstream based on the element type specified by the tag.
			// For mono or low-frequency elements, read and process header parameters, handling both compressed and uncompressed frames.
			// For compressed frames, decompress data and apply prediction to reconstruct the audio samples.
			// For unsupported elements, set the status to indicate unsupported operations and ignore any fill elements.
			// Finally, align the bitstream to byte boundaries and exit once all channels are processed or the frame end is reached.
			status = DecodeStereo (p, bits, sampleBuffer, numSamples, outNumSamples) ;
			break ;

		case ID_LFE:
			// LFE channel (subwoofer)
			// Decode audio data from the bitstream based on the element type specified by the tag.
			// For mono or low-frequency elements, read and process header parameters, handling both compressed and uncompressed frames.
			// For compressed frames, decompress data and apply prediction to reconstruct the audio samples.
			// For unsupported elements, set the status to indicate unsupported operations and ignore any fill elements.
			// Finally, align the bitstream to byte boundaries and exit once all channels are processed or the frame end is reached.
			status = DecodeMono (p, bits, sampleBuffer, numSamples, outNumSamples) ;
			break ;

		default:
			// unsupported element
			// set status to indicate unsupported operations and ignore any fill elements
			status = kALAC_UnsupportedElement ;
			break ;
	}

	RequireNoErr (status, goto Exit ;) ;
}

NoMoreChannels:

// if we get here and haven't decoded all of the requested channels, fill the remaining channels with zeros
for ( ; channelIndex < numChannels ; channelIndex++)
{
	int32_t *	fill32 = sampleBuffer + channelIndex ;
	Zero32 (fill32, numSamples, numChannels) ;
}

Exit:
return status ;