while (status == ALAC_noErr)
{
	// bail if we ran off the end of the buffer
	RequireAction (bits->cur < bits->end, status = kALAC_ParamError ; goto Exit ;) ;

	// copy global decode params for this element
	pb = p->mConfig.pb ;

	// read element tag
	tag = BitBufferReadSmall (bits, 3) ;

	switch (tag)
	{
		case 0:
			// mono or low-frequency element
			// read and process header parameters, handling both compressed and uncompressed frames
			status = alac_fill_element (bits) ;
			break ;
		case 1:
			// compressed frame
			// decompress data and apply prediction to reconstruct the audio samples
			status = alac_data_stream_element (bits) ;
			break ;
		case 2:
			// stereo channel pair
			// ensure channel limit is not exceeded and process each channel separately, similar to mono elements
			status = alac_fill_element (bits) ;
			break ;
		case 3:
			// partial frame
			// read it into an appropriate buffer
			status = alac_fill_element (bits) ;
			break ;
		case 4:
			// unsupported element
			// set the status to indicate unsupported operations and ignore any fill elements
			status = kALAC_UnsupportedElement ;
			break ;
		default:
			// unknown element type
			// set the status to indicate unknown operations and ignore any fill elements
			status = kALAC_UnknownElement ;
			break ;
	}

	// handle special cases such as shifted values
	// read them into appropriate buffers
	if (status == ALAC_noErr)
	{
		// read the shift bits
		shiftBits = BitBufferReadSmall (bits, 4) ;

		// apply the shift
		BitBufferShift (bits, shiftBits) ;
	}

	// align the bitstream to byte boundaries
	BitBufferByteAlign (bits, false) ;
}