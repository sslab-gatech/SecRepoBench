elementInstanceTag = BitBufferReadSmall(bits, 4);

if (tag == ID_END)
    break;

if (tag == ID_SCE || tag == ID_CPE) {
    uint32_t numChans = (tag == ID_CPE) ? 2 : 1;
    RequireAction(channelIndex + numChans <= numChannels, status = kALAC_UnsupportedElement; break;);

    headerByte = BitBufferReadSmall(bits, 4);
    partialFrame = (headerByte >> 3) & 0x1;
    bytesShifted = (headerByte >> 1) & 0x3;
    escapeFlag = headerByte & 0x1;

    if (partialFrame)
        numSamples = BitBufferReadSmall(bits, 32);

    if (escapeFlag == 0) {
        mixBits = BitBufferReadSmall(bits, 8);
        mixRes = (int8_t)BitBufferReadSmall(bits, 8);
        
        uint32_t header = BitBufferReadSmall(bits, 8);
        modeU = (header >> 4) & 0xF;
        denShiftU = header & 0xF;
        header = BitBufferReadSmall(bits, 8);
        pbFactorU = (header >> 5) & 0x7;
        numU = header & 0x1F;
        
        for (i = 0; i < numU; i++)
            coefsU[i] = (int16_t)BitBufferReadSmall(bits, 16);

        if (tag == ID_CPE) {
            header = BitBufferReadSmall(bits, 8);
            modeV = (header >> 4) & 0xF;
            denShiftV = header & 0xF;
            header = BitBufferReadSmall(bits, 8);
            pbFactorV = (header >> 5) & 0x7;
            numV = header & 0x1F;
            
            for (i = 0; i < numV; i++)
                coefsV[i] = (int16_t)BitBufferReadSmall(bits, 16);
        }

        if (bytesShifted != 0) {
            shift = bytesShifted * 8;
            BitBufferRead(&shiftBits, bits, (numSamples * 2) * shift);
        }

        for (uint32_t chan = 0; chan < numChans; chan++) {
            int16_t *coefs = chan ? coefsV : coefsU;
            uint32_t num = chan ? numV : numU;
            uint32_t denShift = chan ? denShiftV : denShiftU;
            uint32_t pbFactor = chan ? pbFactorV : pbFactorU;

            set_ag_params(&agParams, p->mConfig.mb0, (pbFactor * pb) / 4, p->mConfig.kb0, numSamples, numSamples, MAX_RUN_DEFAULT);
            status = dyn_decomp(&agParams, bits, p->mPredictor, numSamples, p->mConfig.bitDepth, &extraBits);
            RequireNoErr(status, goto Exit;);

            pc_block(p->mPredictor, p->mMixBuffer, numSamples, coefs, num, p->mConfig.bitDepth - (bytesShifted * 8) + 1, denShift);

            if (bytesShifted != 0) {
                shift = bytesShifted * 8;
                for (i = 0; i < numSamples; i++)
                    p->mMixBuffer[i] = (p->mMixBuffer[i] << shift) | BitBufferReadSmall(&shiftBits, shift);
            }

            out32 = sampleBuffer + channelIndex + chan;
            for (i = 0, j = 0; i < numSamples; i++, j += numChannels)
                out32[j] = p->mMixBuffer[i];
        }
        channelIndex += numChans;
    } else {
        for (uint32_t chan = 0; chan < numChans; chan++) {
            out32 = sampleBuffer + channelIndex + chan;
            for (i = 0, j = 0; i < numSamples; i++, j += numChannels)
                out32[j] = (int32_t)BitBufferReadSmall(bits, p->mConfig.bitDepth) << 16;
        }
        channelIndex += numChans;
    }
} else if (tag == ID_LFE) {
    // Handle LFE channel similarly to SCE
} else {
    status = kALAC_UnsupportedElement;
    break;
}

BitBufferByteAlign(bits, false);
if (channelIndex >= numChannels)
    goto NoMoreChannels;