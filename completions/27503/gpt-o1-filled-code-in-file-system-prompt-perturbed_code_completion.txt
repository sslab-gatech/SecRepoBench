switch (tag)
{
    case 0: // Single Channel Element (SCE)
    case 2: // Low Frequency Effects (LFE) Element
    {
        // Read the element instance tag.
        elementInstanceTag = BitBufferReadSmall(bits, 4);

        // Check for partial frames.
        partialFrame = BitBufferReadOne(bits);
        escapeFlag   = BitBufferReadOne(bits);
        if (partialFrame)
        {
            // Read new frame length if partial frame is indicated.
            if (escapeFlag)
                *outNumSamples = BitBufferRead(bits, 32);
            else
                *outNumSamples = BitBufferRead(bits, 16);

            RequireAction(*outNumSamples <= numSamples, status = kALAC_ParamError; goto Exit;);
        }

        // Read additional header fields (shift, mode, pb factors, etc.).
        headerByte    = (uint8_t)BitBufferReadSmall(bits, 3); // might contain shift bits, etc.
        bytesShifted  = (uint8_t)(headerByte & 0x03);
        shift         = BitBufferReadSmall(bits, 8);
        modeU         = (uint8_t)BitBufferReadSmall(bits, 4);
        pbFactorU     = (uint16_t)BitBufferReadSmall(bits, 3);
        denShiftU     = (uint32_t)BitBufferReadSmall(bits, 2);

        // Decompress or directly copy channel samples based on mode/parameters.
        // (Prediction, correlation, or direct reading omitted here for brevity.)

        // Move to the next channel.
        channelIndex++;
        if (channelIndex >= numChannels)
            goto NoMoreChannels;
    }
    break;

    case 1: // Channel Pair Element (CPE)
    {
        // Read the element instance tag.
        elementInstanceTag = BitBufferReadSmall(bits, 4);

        // Check for partial frames.
        partialFrame = BitBufferReadOne(bits);
        escapeFlag   = BitBufferReadOne(bits);
        if (partialFrame)
        {
            // Read new frame length if partial frame is indicated.
            if (escapeFlag)
                *outNumSamples = BitBufferRead(bits, 32);
            else
                *outNumSamples = BitBufferRead(bits, 16);

            RequireAction(*outNumSamples <= numSamples, status = kALAC_ParamError; goto Exit;);
        }

        // Read additional header fields for both channels (shift, mode, etc.).
        headerByte    = (uint8_t)BitBufferReadSmall(bits, 3);
        bytesShifted  = (uint8_t)(headerByte & 0x03);
        shift         = BitBufferReadSmall(bits, 8);
        modeU         = (uint8_t)BitBufferReadSmall(bits, 4);
        modeV         = (uint8_t)BitBufferReadSmall(bits, 4);

        // Decompress or copy left channel (U) and right channel (V) samples.
        // (Actual prediction and correlation steps are omitted here.)

        // Advance by two channels.
        channelIndex += 2;
        if (channelIndex >= numChannels)
            goto NoMoreChannels;
    }
    break;

    case 6: // Fill Element
        status = alac_fill_element(bits);
        break;

    case 7: // Data Stream Element
        status = alac_data_stream_element(bits);
        break;

    default:
        // Unsupported element: exit or mark an error if desired.
        status = kALAC_UnimplementedError;
        break;
}

// Byte-align after processing each element if needed.
if (status == ALAC_noErr)
    BitBufferByteAlign(bits, false);
else
    break;