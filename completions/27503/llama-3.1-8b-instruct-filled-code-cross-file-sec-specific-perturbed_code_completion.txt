// <MASK>
// Decode audio data from the bitstream based on the element type specified by the tag.
// For mono or low-frequency elements, read and process header parameters, handling both compressed and uncompressed frames.
// For compressed frames, decompress data and apply prediction to reconstruct the audio samples.
// For stereo channel pairs, ensure channel limit is not exceeded and process each channel separately, similar to mono elements.
// Handle special cases such as partial frames and shifted values, reading them into appropriate buffers.
// For unsupported elements, set the status to indicate unsupported operations and ignore any fill elements.
// Finally, align the bitstream to byte boundaries and exit once all channels are processed or the frame end is reached.
if (tag == ID_SCE)
{
	// mono
	BitBufferReadSmall (bits, 4) ;	// read element instance tag
	agParams = p->mConfig ;
	agParams.numSamples = numSamples ;
	agParams.numChannels = 1 ;
	agParams.frameLength = p->mConfig.frameLength ;
	agParams.bitDepth = p->mConfig.bitDepth ;
	agParams.pb = p->mConfig.pb ;
	agParams.kb = p->mConfig.kb ;
	agParams.mb = p->mConfig.mb ;
	agParams.maxRun = p->mConfig.maxRun ;
	agParams.maxFrameBytes = p->mConfig.maxFrameBytes ;
	agParams.avgBitRate = p->mConfig.avgBitRate ;
	agParams.sampleRate = p->mConfig.sampleRate ;
	status = dyn_decomp (&agParams, bits, coefsU, numSamples, 32, &bits1) ;
	RequireNoErr (status, goto Exit ;) ;
}
else if (tag == ID_CPE)
{
	// stereo
	BitBufferReadSmall (bits, 4) ;	// read element instance tag
	agParams = p->mConfig ;
	agParams.numSamples = numSamples ;
	agParams.numChannels = 2 ;
	agParams.frameLength = p->mConfig.frameLength ;
	agParams.bitDepth = p->mConfig.bitDepth ;
	agParams.pb = p->mConfig.pb ;
	agParams.kb = p->mConfig.kb ;
	agParams.mb = p->mConfig.mb ;
	agParams.maxRun = p->mConfig.maxRun ;
	agParams.maxFrameBytes = p->mConfig.maxFrameBytes ;
	agParams.avgBitRate = p->mConfig.avgBitRate ;
	agParams.sampleRate = p->mConfig.sampleRate ;
	status = dyn_decomp (&agParams, bits, coefsU, numSamples, 32, &bits1) ;
	RequireNoErr (status, goto Exit ;) ;
	status = dyn_decomp (&agParams, bits, coefsV, numSamples, 32, &bits2) ;
	RequireNoErr (status, goto Exit ;) ;
}
else if (tag == ID_LFE)
{
	// LFE channel (subwoofer)
	BitBufferReadSmall (bits, 4) ;	// read element instance tag
	agParams = p->mConfig ;
	agParams.numSamples = numSamples ;
	agParams.numChannels = 1 ;
	agParams.frameLength = p->mConfig.frameLength ;
	agParams.bitDepth = p->mConfig.bitDepth ;
	agParams.pb = p->mConfig.pb ;
	agParams.kb = p->mConfig.kb ;
	agParams.mb = p->mConfig.mb ;
	agParams.maxRun = p->mConfig.maxRun ;
	agParams.maxFrameBytes = p->mConfig.maxFrameBytes ;
	agParams.avgBitRate = p->mConfig.avgBitRate ;
	agParams.sampleRate = p->mConfig.sampleRate ;
	status = dyn_decomp (&agParams, bits, coefsU, numSamples, 32, &bits1) ;
	RequireNoErr (status, goto Exit ;) ;
}
else
{
	// unsupported element
	status = kALAC_ParamError ;
}