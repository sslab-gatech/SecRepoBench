switch (tag)
{
	case 0x0:	// mono or low-frequency element
	case 0x1:
	{
		// read header parameters
		headerByte = BitBufferReadSmall (bits, 8) ;
		partialFrame = headerByte & 0x80 ;
		extraBits = headerByte & 0x7F ;
		if (partialFrame)
		{
			// read partial frame parameters
			unusedHeader = BitBufferReadSmall (bits, 16) ;
			shift = BitBufferReadSmall (bits, 8) ;
			bytesShifted = BitBufferReadSmall (bits, 8) ;
			chanBits = BitBufferReadSmall (bits, 8) ;
			escapeFlag = BitBufferReadOne (bits) ;
			if (escapeFlag)
			{
				// read escape parameters
				denShiftU = BitBufferReadSmall (bits, 8) ;
				denShiftV = BitBufferReadSmall (bits, 8) ;
				pbFactorU = BitBufferReadSmall (bits, 16) ;
				pbFactorV = BitBufferReadSmall (bits, 16) ;
			}
		}

		// read and process compressed or uncompressed frame
		if (extraBits > 0)
		{
			// read compressed frame
			val = BitBufferReadSmall (bits, extraBits) ;
			// decompress data
			// apply prediction to reconstruct audio samples
			//...
		}
		else
		{
			// read uncompressed frame
			//...
		}

		// align bitstream to byte boundaries
		BitBufferByteAlign (bits, false) ;
		break ;
	}
	case 0x2:	// stereo channel pair
	{
		// ensure channel limit is not exceeded
		RequireAction (channelIndex + 2 <= numChannels, status = kALAC_ParamError ; goto Exit ;) ;

		// process each channel separately
		for (i = 0 ; i < 2 ; i++)
		{
			// read header parameters
			headerByte = BitBufferReadSmall (bits, 8) ;
			partialFrame = headerByte & 0x80 ;
			extraBits = headerByte & 0x7F ;
			if (partialFrame)
			{
				// read partial frame parameters
				unusedHeader = BitBufferReadSmall (bits, 16) ;
				shift = BitBufferReadSmall (bits, 8) ;
				bytesShifted = BitBufferReadSmall (bits, 8) ;
				chanBits = BitBufferReadSmall (bits, 8) ;
				escapeFlag = BitBufferReadOne (bits) ;
				if (escapeFlag)
				{
					// read escape parameters
					denShiftU = BitBufferReadSmall (bits, 8) ;
					denShiftV = BitBufferReadSmall (bits, 8) ;
					pbFactorU = BitBufferReadSmall (bits, 16) ;
					pbFactorV = BitBufferReadSmall (bits, 16) ;
				}
			}

			// read and process compressed or uncompressed frame
			if (extraBits > 0)
			{
				// read compressed frame
				val = BitBufferReadSmall (bits, extraBits) ;
				// decompress data
				// apply prediction to reconstruct audio samples
				//...
			}
			else
			{
				// read uncompressed frame
				//...
			}

			// align bitstream to byte boundaries
			BitBufferByteAlign (bits, false) ;
		}

		channelIndex += 2 ;
		break ;
	}
	case 0x3:	// fill element
	{
		status = alac_fill_element (bits) ;
		break ;
	}
	case 0x4:	// data stream element
	{
		status = alac_data_stream_element (bits) ;
		break ;
	}
	case 0x5:	// unsupported element
	default:
	{
		status = kALAC_UnsupportedOperation ;
		break ;
	}
}

// exit once all channels are processed or the frame end is reached
if (channelIndex >= numChannels || status!= ALAC_noErr)
	break ;