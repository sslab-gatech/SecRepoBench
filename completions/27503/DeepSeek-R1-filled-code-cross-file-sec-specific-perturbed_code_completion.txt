elementInstanceTag = BitBufferReadSmall(bits, 4);
switch (tag)
{
    case ID_SCE:
    case ID_LFE:
        // Mono or LFE channel
        RequireAction(channelIndex >= numChannels, status = kALAC_UnsupportedElement; goto Exit;);
        
        headerByte = BitBufferReadSmall(bits, 8);
        partialFrame = (headerByte >> 3) & 0x1;
        bytesShifted = (headerByte >> 1) & 0x3;
        escapeFlag = headerByte & 0x1;
        
        if (partialFrame)
            unusedHeader = BitBufferReadSmall(bits, 16);
        
        if (escapeFlag == 0)
        {
            // Compressed frame
            mixBits = BitBufferReadSmall(bits, 8);
            mixRes = (int8_t)BitBufferReadSmall(bits, 8);
            
            headerByte = BitBufferReadSmall(bits, 8);
            modeU = (headerByte >> 4) & 0xF;
            denShiftU = headerByte & 0xF;
            
            headerByte = BitBufferReadSmall(bits, 8);
            pbFactorU = (headerByte >> 5) & 0x7;
            numU = headerByte & 0x1F;
            
            for (i = 0; i < numU; i++)
                coefsU[i] = (int16_t)BitBufferReadSmall(bits, 16);
            
            if (bytesShifted != 0)
            {
                shift = bytesShifted * 8;
                for (i = 0; i < numSamples; i++)
                    p->mShiftBufferUV[i] = (uint16_t)BitBufferReadSmall(bits, shift);
            }
            
            // Decode the mono stream
            status = dyn_decomp(&agParams, bits, sampleBuffer + channelIndex, numSamples, numChannels, &bits1);
            RequireNoErr(status, goto Exit;);
        }
        else
        {
            // Uncompressed frame
            uint32_t shift = (32 - p->mBitDepth) & 0x1F;
            for (i = 0; i < numSamples; i++)
            {
                val = (int32_t)BitBufferReadSmall(bits, p->mBitDepth) << shift;
                sampleBuffer[channelIndex + i * numChannels] = val >> shift;
            }
        }
        
        channelIndex++;
        break;

    case ID_CPE:
        // Stereo channel pair
        RequireAction(channelIndex + 1 >= numChannels, status = kALAC_UnsupportedElement; goto Exit;);
        
        // Process both channels
        for (j = 0; j < 2; j++)
        {
            headerByte = BitBufferReadSmall(bits, 8);
            partialFrame = (headerByte >> 3) & 0x1;
            bytesShifted = (headerByte >> 1) & 0x3;
            escapeFlag = headerByte & 0x1;
            
            if (partialFrame)
                unusedHeader = BitBufferReadSmall(bits, 16);
            
            if (escapeFlag == 0)
            {
                mixBits = BitBufferReadSmall(bits, 8);
                mixRes = (int8_t)BitBufferReadSmall(bits, 8);
                
                headerByte = BitBufferReadSmall(bits, 8);
                modeU = (headerByte >> 4) & 0xF;
                denShiftU = headerByte & 0xF;
                
                headerByte = BitBufferReadSmall(bits, 8);
                pbFactorU = (headerByte >> 5) & 0x7;
                numU = headerByte & 0x1F;
                
                for (i = 0; i < numU; i++)
                    coefsU[i] = (int16_t)BitBufferReadSmall(bits, 16);
                
                if (bytesShifted != 0)
                {
                    shift = bytesShifted * 8;
                    for (i = 0; i < numSamples * 2; i += 2)
                        p->mShiftBufferUV[i + j] = (uint16_t)BitBufferReadSmall(bits, shift);
                }
                
                // Decode stereo channel
                status = dyn_decomp(&agParams, bits, sampleBuffer + channelIndex + j, numSamples, numChannels, &bits1);
                RequireNoErr(status, goto Exit;);
            }
            else
            {
                uint32_t shift = (32 - p->mBitDepth) & 0x1F;
                for (i = 0; i < numSamples; i++)
                {
                    val = (int32_t)BitBufferReadSmall(bits, p->mBitDepth) << shift;
                    sampleBuffer[channelIndex + j + i * numChannels] = val >> shift;
                }
            }
        }
        channelIndex += 2;
        break;

    case ID_END:
        // Frame end
        goto NoMoreChannels;

    default:
        // Unsupported element
        status = kALAC_UnsupportedElement;
        goto Exit;
}

// Align bitstream to next byte boundary
BitBufferByteAlign(bits, false);