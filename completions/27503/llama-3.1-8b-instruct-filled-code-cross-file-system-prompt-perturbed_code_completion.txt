// <MASK>
{
	// decode audio data from the bitstream based on the element type specified by the tag
	switch (tag)
	{
		case ID_SCE:
			// mono
			// read and process header parameters, handling both compressed and uncompressed frames
			// for compressed frames, decompress data and apply prediction to reconstruct the audio samples
			// for uncompressed frames, just copy the input data to the output buffer
			status = DecodeMono (p, bits, sampleBuffer, channelIndex, numSamples, outNumSamples) ;
			break ;

		case ID_CPE:
			// stereo
			// ensure channel limit is not exceeded and process each channel separately, similar to mono elements
			// handle special cases such as partial frames and shifted values, reading them into appropriate buffers
			// for compressed frames, decompress data and apply prediction to reconstruct the audio samples
			// for uncompressed frames, just copy the input data to the output buffer
			status = DecodeStereo (p, bits, sampleBuffer, channelIndex, numSamples, outNumSamples) ;
			break ;

		case ID_LFE:
			// LFE channel (subwoofer)
			// read and process header parameters, handling both compressed and uncompressed frames
			// for compressed frames, decompress data and apply prediction to reconstruct the audio samples
			// for uncompressed frames, just copy the input data to the output buffer
			status = DecodeMono (p, bits, sampleBuffer, channelIndex, numSamples, outNumSamples) ;
			break ;

		default:
			// unsupported element, set the status to indicate unsupported operations and ignore any fill elements
			status = kALAC_UnsupportedElement ;
			break ;
	}

	// align the bitstream to byte boundaries
	BitBufferByteAlign (bits, true) ;

	// exit once all channels are processed or the frame end is reached
	RequireAction (status == ALAC_noErr, status = kALAC_ParamError ; goto Exit ;) ;
}