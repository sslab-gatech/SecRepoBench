switch (tag)
{
    case ID_SCE:
    case ID_LFE:
        // mono or LFE channel
        elementInstanceTag = BitBufferReadSmall(bits, 4);
        p->mActiveElements |= (1 << elementInstanceTag);

        // read the 12 unused header bits
        unusedHeader = (uint16_t) BitBufferRead(bits, 12);
        RequireAction(unusedHeader == 0, status = kALAC_ParamError; goto Exit;);

        // read the 1-bit "partial frame" flag, 2-bit "shift-off" flag, and 1-bit "escape" flag
        headerByte = (uint8_t) BitBufferRead(bits, 4);

        partialFrame = headerByte >> 3;
        bytesShifted = (headerByte >> 1) & 3;
        escapeFlag = headerByte & 1;

        if (escapeFlag == 0)
        {
            shift = bytesShifted * 8;
            chanBits = p->mConfig.bitDepth - shift;
        }
        else
        {
            shift = BitBufferRead(bits, 16);
            chanBits = BitBufferRead(bits, 16);
        }

        if (partialFrame)
            numSamples = BitBufferRead(bits, 16);

        BitBufferReadSmall(bits, 4);
        modeU = BitBufferReadSmall(bits, 4);

        denShiftU = BitBufferRead(bits, 4);
        pbFactorU = (uint16_t) BitBufferRead(bits, 4);

        numU = BitBufferRead(bits, 8);
        for (i = 0; i < numU; i++)
            coefsU[i] = (int16_t) BitBufferRead(bits, 16);

        if ((channelIndex + 1) > numChannels)
        {
            status = kALAC_TooManyChannels;
            goto NoMoreChannels;
        }

        if (escapeFlag == 0)
        {
            if (bytesShifted == 0)
                status = dyn_decomp(&p->mDynP, bits, &agParams, p->u.mPredictor, numSamples, chanBits, &bits1);
            else
                status = dyn_decomp(&p->mDynP, bits, &agParams, p->mMixBufferU, numSamples, chanBits, &bits1);

            if (status != ALAC_noErr)
                goto Exit;

            if (bytesShifted != 0)
            {
                shift_buffer(modeU, p->u.mPredictor, p->mMixBufferU, numSamples, p->mMixBufferV, chanBits, shift);
            }
        }
        else
        {
            // handle escape case
            memcpy(p->u.mPredictor, bits->cur, numSamples * sizeof(int32_t));
            bits->cur += (numSamples * sizeof(int32_t));
            status = ALAC_noErr;
        }

        if (bytesShifted == 0)
            unpc_block(p->u.mPredictor, numSamples, &agParams, coefsU, numU, chanBits, denShiftU, pbFactorU, modeU, &p->mConfig);

        // deinterleave and output samples
        out32 = sampleBuffer + channelIndex;
        for (i = 0; i < numSamples; i++)
        {
            val = p->u.mPredictor[i];
            if (shift != 0)
                val = (val << shift);
            *out32 = val;
            out32 += numChannels;
        }

        channelIndex++;
        break;

    case ID_CPE:
        // if we get here we're decoding a stereo pair
        elementInstanceTag = BitBufferReadSmall(bits, 4);
        p->mActiveElements |= (1 << elementInstanceTag);

        // read the 12 unused header bits
        unusedHeader = (uint16_t) BitBufferRead(bits, 12);
        RequireAction(unusedHeader == 0, status = kALAC_ParamError; goto Exit;);

        // read the 1-bit "partial frame" flag, 2-bit "shift-off" flag, and 1-bit "escape" flag
        headerByte = (uint8_t) BitBufferRead(bits, 4);

        partialFrame = headerByte >> 3;
        bytesShifted = (headerByte >> 1) & 3;
        escapeFlag = headerByte & 1;

        if (escapeFlag == 0)
        {
            shift = bytesShifted * 8;
            chanBits = p->mConfig.bitDepth - shift;
        }
        else
        {
            shift = BitBufferRead(bits, 16);
            chanBits = BitBufferRead(bits, 16);
        }

        if (partialFrame)
            numSamples = BitBufferRead(bits, 16);

        // read the 4-bit "mix" flag and 4-bit "mixbits" field
        headerByte = (uint8_t) BitBufferRead(bits, 8);
        mixBits = headerByte & 0x0f;
        mixResiduals = (headerByte >> 4) & 0x0f;

        // read the two sets of LP coefficients
        for (i = 0; i < 2; i++)
        {
            uint8_t * fits = (i == 0) ? &modeU : &modeV;
            uint32_t * denShift = (i == 0) ? &denShiftU : &denShiftV;
            uint16_t * pbFactor = (i == 0) ? &pbFactorU : &pbFactorV;
            uint8_t * numCoefs = (i == 0) ? &numU : &numV;
            int16_t * coefs = (i == 0) ? coefsU : coefsV;

            *fits = BitBufferReadSmall(bits, 4);
            *denShift = BitBufferRead(bits, 4);
            *pbFactor = (uint16_t) BitBufferRead(bits, 4);

            *numCoefs = BitBufferRead(bits, 8);
            for (j = 0; j < *numCoefs; j++)
                coefs[j] = (int16_t) BitBufferRead(bits, 16);
        }

        if ((channelIndex + 2) > numChannels)
        {
            status = kALAC_TooManyChannels;
            goto NoMoreChannels;
        }

        // decompress and run predictor for "left" channel
        if (escapeFlag == 0)
        {
            if (bytesShifted == 0)
                status = dyn_decomp(&p->mDynP, bits, &agParams, p->u.mPredictor, numSamples, chanBits, &bits1);
            else
                status = dyn_decomp(&p->mDynP, bits, &agParams, p->mMixBufferU, numSamples, chanBits, &bits1);

            if (status != ALAC_noErr)
                goto Exit;

            if (bytesShifted != 0)
            {
                shift_buffer(modeU, p->u.mPredictor, p->mMixBufferU, numSamples, p->mMixBufferV, chanBits, shift);
            }

            unpc_block(p->u.mPredictor, numSamples, &agParams, coefsU, numU, chanBits, denShiftU, pbFactorU, modeU, &p->mConfig);
        }
        else
        {
            // handle escape case
            memcpy(p->u.mPredictor, bits->cur, numSamples * sizeof(int32_t));
            bits->cur += (numSamples * sizeof(int32_t));
        }

        // decompress and run predictor for "right" channel
        if (escapeFlag == 0)
        {
            if (bytesShifted == 0)
                status = dyn_decomp(&p->mDynP, bits, &agParams, p->mMixBufferU, numSamples, chanBits, &bits2);
            else
                status = dyn_decomp(&p->mDynP, bits, &agParams, p->mMixBufferV, numSamples, chanBits, &bits2);

            if (status != ALAC_noErr)
                goto Exit;

            if (bytesShifted != 0)
            {
                shift_buffer(modeV, p->mMixBufferU, p->mMixBufferV, numSamples, p->mMixBufferV, chanBits, shift);
            }

            unpc_block(p->mMixBufferU, numSamples, &agParams, coefsV, numV, chanBits, denShiftV, pbFactorV, modeV, &p->mConfig);
        }
        else
        {
            // handle escape case
            memcpy(p->mMixBufferU, bits->cur, numSamples * sizeof(int32_t));
            bits->cur += (numSamples * sizeof(int32_t));
        }

        // handle mixing
        unmix_stereo(p->u.mPredictor, p->mMixBufferU, numSamples, mixBits, mixResiduals);

        // deinterleave and output samples
        out32 = sampleBuffer + channelIndex;
        for (i = 0; i < numSamples; i++)
        {
            int32_t val1 = p->u.mPredictor[i];
            int32_t val2 = p->mMixBufferU[i];

            if (shift != 0)
            {
                val1 = (val1 << shift);
                val2 = (val2 << shift);
            }

            out32[0] = val1;
            out32[1] = val2;
            out32 += numChannels;
        }

        channelIndex += 2;
        break;

    case ID_CCE:
    case ID_PCE:
    case ID_DSE:
    case ID_FIL:
    case ID_END:
        status = kALAC_UnsupportedElement;
        break;
}

if (tag == ID_END)
{
    status = ALAC_noErr;
    goto NoMoreChannels;
}

BitBufferByteAlign(bits, false);

if (channelIndex >= numChannels)
    break;