switch (tag)
		{
			case ID_SCE:	// mono channel
			{
				RequireAction ((channelIndex < numChannels), status = kALAC_ParamError ; goto Exit ;) ;

				elementInstanceTag = BitBufferReadSmall (bits, 4) ;
				p->mActiveElements |= (1 << channelIndex) ;

				// read header
				headerByte = BitBufferReadSmall (bits, 8) ;
				partialFrame = (headerByte >> 3) & 0x01 ;
				bytesShifted = (headerByte >> 1) & 0x03 ;
				escapeFlag = headerByte & 0x01 ;

				if (partialFrame)
				{
					numSamples = BitBufferRead (bits, 32) ;
					RequireAction ((numSamples <= *outNumSamples), status = kALAC_ParamError ; goto Exit ;) ;
					*outNumSamples = numSamples ;
				}

				chanBits = p->mConfig.bitDepth - (bytesShifted * 8) + 1 ;

				if (escapeFlag)
				{
					// uncompressed frame
					out32 = sampleBuffer + channelIndex ;
					for (i = 0 ; i < numSamples ; i++)
					{
						val = BitBufferRead (bits, p->mConfig.bitDepth) ;
						*out32 = val << 32 - p->mConfig.bitDepth ;
						out32 += numChannels ;
					}
				}
				else
				{
					// compressed frame
					mixBits = BitBufferReadSmall (bits, 8) ;
					mixResiduals = BitBufferReadSmall (bits, 8) ;
					unusedHeader = BitBufferReadSmall (bits, 16) ;

					modeU = (unusedHeader >> 4) & 0x0f ;
					denShiftU = unusedHeader & 0x0f ;
					pbFactorU = BitBufferReadSmall (bits, 8) ;
					numU = pbFactorU & 0x1f ;
					pbFactorU = pbFactorU >> 5 ;

					for (i = 0 ; i < numU ; i++)
						coefsU [i] = BitBufferRead (bits, 16) ;

					// decompress
					set_ag_params (&agParams, MB0, (pbFactorU * pb) / 4, KB0, numSamples, numSamples, MAX_RUN_DEFAULT) ;
					status = dyn_decomp (&agParams, bits, p->mPredictorU, numSamples, chanBits, &bits1) ;
					RequireNoErr (status, goto Exit ;) ;

					// run the dynamic predictor
					pc_block_inverse (p->mPredictorU, sampleBuffer + channelIndex, numSamples, coefsU, numU, chanBits, denShiftU, numChannels) ;

					// if shift active, read the shift buffer
					if (bytesShifted != 0)
					{
						out32 = sampleBuffer + channelIndex ;
						for (i = 0 ; i < numSamples ; i++)
						{
							extraBits = BitBufferRead (bits, bytesShifted * 8) ;
							*out32 += extraBits << (32 - p->mConfig.bitDepth + bytesShifted * 8) ;
							out32 += numChannels ;
						}
					}
				}

				channelIndex++ ;
				break ;
			}

			case ID_CPE:	// channel pair
			{
				RequireAction ((channelIndex + 1 < numChannels), status = kALAC_ParamError ; goto Exit ;) ;

				elementInstanceTag = BitBufferReadSmall (bits, 4) ;
				p->mActiveElements |= (1 << channelIndex) | (1 << (channelIndex + 1)) ;

				// read header
				headerByte = BitBufferReadSmall (bits, 8) ;
				partialFrame = (headerByte >> 3) & 0x01 ;
				bytesShifted = (headerByte >> 1) & 0x03 ;
				escapeFlag = headerByte & 0x01 ;

				if (partialFrame)
				{
					numSamples = BitBufferRead (bits, 32) ;
					RequireAction ((numSamples <= *outNumSamples), status = kALAC_ParamError ; goto Exit ;) ;
					*outNumSamples = numSamples ;
				}

				chanBits = p->mConfig.bitDepth - (bytesShifted * 8) + 1 ;

				if (escapeFlag)
				{
					// uncompressed frame
					for (j = 0 ; j < 2 ; j++)
					{
						out32 = sampleBuffer + channelIndex + j ;
						for (i = 0 ; i < numSamples ; i++)
						{
							val = BitBufferRead (bits, p->mConfig.bitDepth) ;
							*out32 = val << 32 - p->mConfig.bitDepth ;
							out32 += numChannels ;
						}
					}
				}
				else
				{
					// compressed frame
					mixBits = BitBufferReadSmall (bits, 8) ;
					mixResiduals = BitBufferReadSmall (bits, 8) ;

					modeU = BitBufferReadSmall (bits, 8) ;
					pbFactorU = BitBufferReadSmall (bits, 8) ;
					numU = pbFactorU & 0x1f ;
					pbFactorU = pbFactorU >> 5 ;
					denShiftU = modeU & 0x0f ;
					modeU = (modeU >> 4) & 0x0f ;

					for (i = 0 ; i < numU ; i++)
						coefsU [i] = BitBufferRead (bits, 16) ;

					modeV = BitBufferReadSmall (bits, 8) ;
					pbFactorV = BitBufferReadSmall (bits, 8) ;
					numV = pbFactorV & 0x1f ;
					pbFactorV = pbFactorV >> 5 ;
					denShiftV = modeV & 0x0f ;
					modeV = (modeV >> 4) & 0x0f ;

					for (i = 0 ; i < numV ; i++)
						coefsV [i] = BitBufferRead (bits, 16) ;

					// decompress channel U
					set_ag_params (&agParams, MB0, (pbFactorU * pb) / 4, KB0, numSamples, numSamples, MAX_RUN_DEFAULT) ;
					status = dyn_decomp (&agParams, bits, p->mPredictorU, numSamples, chanBits, &bits1) ;
					RequireNoErr (status, goto Exit ;) ;

					// decompress channel V
					set_ag_params (&agParams, MB0, (pbFactorV * pb) / 4, KB0, numSamples, numSamples, MAX_RUN_DEFAULT) ;
					status = dyn_decomp (&agParams, bits, p->mPredictorV, numSamples, chanBits, &bits2) ;
					RequireNoErr (status, goto Exit ;) ;

					// run the dynamic predictor for channel U
					pc_block_inverse (p->mPredictorU, sampleBuffer + channelIndex + 0, numSamples, coefsU, numU, chanBits, denShiftU, numChannels) ;

					// run the dynamic predictor for channel V
					pc_block_inverse (p->mPredictorV, sampleBuffer + channelIndex + 1, numSamples, coefsV, numV, chanBits, denShiftV, numChannels) ;

					// if shift active, read the shift buffer
					if (bytesShifted != 0)
					{
						for (j = 0 ; j < 2 ; j++)
						{
							out32 = sampleBuffer + channelIndex + j ;
							for (i = 0 ; i < numSamples ; i++)
							{
								extraBits = BitBufferRead (bits, bytesShifted * 8) ;
								*out32 += extraBits << (32 - p->mConfig.bitDepth + bytesShifted * 8) ;
								out32 += numChannels ;
							}
						}
					}
				}

				channelIndex += 2 ;
				break ;
			}

			case ID_LFE:	// LFE channel
			{
				RequireAction ((channelIndex < numChannels), status = kALAC_ParamError ; goto Exit ;) ;

				elementInstanceTag = BitBufferReadSmall (bits, 4) ;
				p->mActiveElements |= (1 << channelIndex) ;

				// read header
				headerByte = BitBufferReadSmall (bits, 8) ;
				partialFrame = (headerByte >> 3) & 0x01 ;
				bytesShifted = (headerByte >> 1) & 0x03 ;
				escapeFlag = headerByte & 0x01 ;

				if (partialFrame)
				{
					numSamples = BitBufferRead (bits, 32) ;
					RequireAction ((numSamples <= *outNumSamples), status = kALAC_ParamError ; goto Exit ;) ;
					*outNumSamples = numSamples ;
				}

				chanBits = p->mConfig.bitDepth - (bytesShifted * 8) + 1 ;

				if (escapeFlag)
				{
					// uncompressed frame
					out32 = sampleBuffer + channelIndex ;
					for (i = 0 ; i < numSamples ; i++)
					{
						val = BitBufferRead (bits, p->mConfig.bitDepth) ;
						*out32 = val << 32 - p->mConfig.bitDepth ;
						out32 += numChannels ;
					}
				}
				else
				{
					// compressed frame
					mixBits = BitBufferReadSmall (bits, 8) ;
					mixResiduals = BitBufferReadSmall (bits, 8) ;
					unusedHeader = BitBufferReadSmall (bits, 16) ;

					modeU = (unusedHeader >> 4) & 0x0f ;
					denShiftU = unusedHeader & 0x0f ;
					pbFactorU = BitBufferReadSmall (bits, 8) ;
					numU = pbFactorU & 0x1f ;
					pbFactorU = pbFactorU >> 5 ;

					for (i = 0 ; i < numU ; i++)
						coefsU [i] = BitBufferRead (bits, 16) ;

					// decompress
					set_ag_params (&agParams, MB0, (pbFactorU * pb) / 4, KB0, numSamples, numSamples, MAX_RUN_DEFAULT) ;
					status = dyn_decomp (&agParams, bits, p->mPredictorU, numSamples, chanBits, &bits1) ;
					RequireNoErr (status, goto Exit ;) ;

					// run the dynamic predictor
					pc_block_inverse (p->mPredictorU, sampleBuffer + channelIndex, numSamples, coefsU, numU, chanBits, denShiftU, numChannels) ;

					// if shift active, read the shift buffer
					if (bytesShifted != 0)
					{
						out32 = sampleBuffer + channelIndex ;
						for (i = 0 ; i < numSamples ; i++)
						{
							extraBits = BitBufferRead (bits, bytesShifted * 8) ;
							*out32 += extraBits << (32 - p->mConfig.bitDepth + bytesShifted * 8) ;
							out32 += numChannels ;
						}
					}
				}

				channelIndex++ ;
				break ;
			}

			case ID_END:	// end of frame
			{
				goto NoMoreChannels ;
			}

			case ID_FILL:	// fill element
			{
				// just ignore fill elements
				break ;
			}

			default:
			{
				status = kALAC_UnimplementedError ;
				goto Exit ;
			}
		}