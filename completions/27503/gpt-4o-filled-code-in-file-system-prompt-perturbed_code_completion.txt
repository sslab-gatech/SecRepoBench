switch (tag)
		{
			case 0:		// element type: SCE (single channel element)
			case 1:		// element type: CPE (channel pair element)
			case 2:		// element type: LFE (low frequency element)
				// read the element instance tag
				elementInstanceTag = BitBufferReadSmall(bits, 4);

				// read the header
				headerByte = BitBufferReadSmall(bits, 8);
				partialFrame = (headerByte >> 7) & 0x01;
				escapeFlag = (headerByte >> 6) & 0x01;
				chanBits = (headerByte & 0x3F) + 1;

				// read the number of samples
				if (partialFrame)
				{
					numSamples = BitBufferReadSmall(bits, 16);
					*outNumSamples = numSamples;
				}

				// read the prediction parameters
				modeU = BitBufferReadSmall(bits, 4);
				modeV = BitBufferReadSmall(bits, 4);
				denShiftU = BitBufferReadSmall(bits, 4);
				denShiftV = BitBufferReadSmall(bits, 4);
				pbFactorU = BitBufferReadSmall(bits, 16);
				pbFactorV = BitBufferReadSmall(bits, 16);

				// read the coefficients
				numU = BitBufferReadSmall(bits, 5);
				numV = BitBufferReadSmall(bits, 5);
				for (i = 0; i < numU; i++)
					coefsU[i] = BitBufferReadSmall(bits, 16);
				for (i = 0; i < numV; i++)
					coefsV[i] = BitBufferReadSmall(bits, 16);

				// read the mix parameters
				mixBits = BitBufferReadSmall(bits, 8);
				mixResiduals = BitBufferReadSmall(bits, 8);

				// decode the samples
				for (i = 0; i < numSamples; i++)
				{
					val = BitBufferReadSmall(bits, chanBits);
					sampleBuffer[channelIndex + i * numChannels] = val;
				}

				channelIndex++;
				if (tag == 1) // CPE
				{
					for (i = 0; i < numSamples; i++)
					{
						val = BitBufferReadSmall(bits, chanBits);
						sampleBuffer[channelIndex + i * numChannels] = val;
					}
					channelIndex++;
				}
				break;

			case 3:		// element type: CCE (coupling channel element)
			case 4:		// element type: DSE (data stream element)
			case 5:		// element type: PCE (program config element)
			case 6:		// element type: FIL (fill element)
			case 7:		// element type: END (end element)
			default:
				status = kALAC_UnsupportedElement;
				goto NoMoreChannels;
		}

		// align to byte boundary
		BitBufferByteAlign(bits, false);