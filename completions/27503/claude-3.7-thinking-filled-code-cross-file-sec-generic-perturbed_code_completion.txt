if (tag == ID_SCE || tag == ID_LFE) /* mono or LFE channel */
{
    elementInstanceTag = BitBufferReadSmall(bits, 4);
    
    if (channelIndex >= numChannels)
        goto NoMoreChannels;
    
    // Read header byte containing compression type
    headerByte = BitBufferReadSmall(bits, 8);
    partialFrame = (headerByte >> 3) & 0x1;
    bytesShifted = (headerByte >> 1) & 0x3;
    escapeFlag = headerByte & 0x1;
    
    if (partialFrame)
    {
        // If it's a partial frame, read the actual number of samples
        numSamples = BitBufferRead(bits, 32);
        *outNumSamples = numSamples;
    }
    
    if (escapeFlag == 0)  // compressed frame
    {
        // Read element-specific parameters
        mixBits = BitBufferReadSmall(bits, 8);
        mixResiduals = (int8_t)BitBufferReadSmall(bits, 8);
        
        // Read prediction type, quantization, coefficients
        headerByte = BitBufferReadSmall(bits, 8);
        modeU = headerByte >> 4;
        denShiftU = headerByte & 0xF;
        
        headerByte = BitBufferReadSmall(bits, 8);
        pbFactorU = (headerByte >> 5) & 0x7;
        numU = headerByte & 0x1F;
        
        for (i = 0; i < numU; i++)
            coefsU[i] = (int16_t)BitBufferRead(bits, 16);
        
        // Handle shifted values if any
        if (bytesShifted)
        {
            shift = bytesShifted * 8;
            for (i = 0; i < numSamples; i++)
            {
                val = (int32_t)BitBufferRead(bits, shift);
                p->mShiftBuffer[i] = val;
            }
        }
        
        // Set up parameters for decompression
        chanBits = p->mBitDepth - (bytesShifted * 8);
        
        // Setup agParams
        agParams.mb = p->mConfig.mb;
        agParams.pb = pb;
        agParams.kb = p->mConfig.kb;
        agParams.wb = 0;  // not used for mono
        agParams.mb0 = p->mConfig.mb;
        
        // Decompress
        status = dyn_decomp(&agParams, bits, p->mPredictor, numSamples, chanBits, &bits1);
        if (status != ALAC_noErr)
            goto Exit;
        
        // Apply prediction filter
        pc_block(p->mPredictor, p->mWorkBuffer, numSamples, coefsU, numU, chanBits, denShiftU);
        
        // Output samples
        out32 = sampleBuffer + channelIndex;
        
        if (bytesShifted == 0)
        {
            // Copy directly to output
            for (i = 0; i < numSamples; i++)
            {
                *out32 = p->mWorkBuffer[i];
                out32 += numChannels;
            }
        }
        else
        {
            // Apply shift values
            for (i = 0; i < numSamples; i++)
            {
                *out32 = (p->mWorkBuffer[i] << (bytesShifted * 8)) | p->mShiftBuffer[i];
                out32 += numChannels;
            }
        }
    }
    else  // uncompressed frame
    {
        out32 = sampleBuffer + channelIndex;
        
        for (i = 0; i < numSamples; i++)
        {
            val = (int32_t)BitBufferRead(bits, p->mBitDepth);
            *out32 = val;
            out32 += numChannels;
        }
    }
    
    channelIndex++;
    p->mActiveElements |= (1 << elementInstanceTag);
}
else if (tag == ID_CPE)  // stereo pair
{
    elementInstanceTag = BitBufferReadSmall(bits, 4);
    
    if (channelIndex + 1 >= numChannels)
        goto NoMoreChannels;
    
    // Read header byte containing compression type
    headerByte = BitBufferReadSmall(bits, 8);
    partialFrame = (headerByte >> 3) & 0x1;
    bytesShifted = (headerByte >> 1) & 0x3;
    escapeFlag = headerByte & 0x1;
    
    if (partialFrame)
    {
        // If it's a partial frame, read the actual number of samples
        numSamples = BitBufferRead(bits, 32);
        *outNumSamples = numSamples;
    }
    
    if (escapeFlag == 0)  // compressed frame
    {
        // Read mixing parameters
        mixBits = BitBufferReadSmall(bits, 8);
        mixResiduals = (int8_t)BitBufferReadSmall(bits, 8);
        
        // Read prediction params for the 'left' channel
        headerByte = BitBufferReadSmall(bits, 8);
        modeU = headerByte >> 4;
        denShiftU = headerByte & 0xF;
        
        headerByte = BitBufferReadSmall(bits, 8);
        pbFactorU = (headerByte >> 5) & 0x7;
        numU = headerByte & 0x1F;
        
        for (i = 0; i < numU; i++)
            coefsU[i] = (in