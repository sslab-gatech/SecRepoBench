// <MASK>
switch (tag)
{
    case 0: // mono or low-frequency element
    {
        // read header parameters
        elementInstanceTag = BitBufferReadSmall (bits, 4) ;
        headerByte = BitBufferReadSmall (bits, 8) ;
        partialFrame = (headerByte >> 7) & 1 ;
        mixBits = (headerByte >> 4) & 0x7 ;
        mixResiduals = (headerByte >> 1) & 0x7 ;
        escapeFlag = headerByte & 1 ;

        // read and process the audio data
        if (partialFrame)
        {
            // read the number of extra bits
            extraBits = BitBufferReadSmall (bits, 3) ;
            // read the audio data with the extra bits
            for (i = 0; i < numSamples; i++)
            {
                val = BitBufferReadSmall (bits, mixBits + extraBits) ;
                sampleBuffer[channelIndex + i * numChannels] = val << (32 - (mixBits + extraBits));
            }
        }
        else
        {
            // read the audio data without extra bits
            for (i = 0; i < numSamples; i++)
            {
                val = BitBufferReadSmall (bits, mixBits) ;
                sampleBuffer[channelIndex + i * numChannels] = val << (32 - mixBits);
            }
        }

        // update the channel index
        channelIndex++;
        break;
    }
    case 1: // stereo channel pair element
    {
        // read header parameters
        elementInstanceTag = BitBufferReadSmall (bits, 4) ;
        headerByte = BitBufferReadSmall (bits, 8) ;
        partialFrame = (headerByte >> 7) & 1 ;
        mixBits = (headerByte >> 4) & 0x7 ;
        mixResiduals = (headerByte >> 1) & 0x7 ;
        escapeFlag = headerByte & 1 ;

        // read and process the audio data for the U channel
        if (partialFrame)
        {
            // read the number of extra bits
            extraBits = BitBufferReadSmall (bits, 3) ;
            // read the audio data with the extra bits
            for (i = 0; i < numSamples; i++)
            {
                val = BitBufferReadSmall (bits, mixBits + extraBits) ;
                sampleBuffer[channelIndex + i * numChannels] = val << (32 - (mixBits + extraBits));
            }
        }
        else
        {
            // read the audio data without extra bits
            for (i = 0; i < numSamples; i++)
            {
                val = BitBufferReadSmall (bits, mixBits) ;
                sampleBuffer[channelIndex + i * numChannels] = val << (32 - mixBits);
            }
        }

        // update the channel index
        channelIndex++;

        // read and process the audio data for the V channel
        if (partialFrame)
        {
            // read the number of extra bits
            extraBits = BitBufferReadSmall (bits, 3) ;
            // read the audio data with the extra bits
            for (i = 0; i < numSamples; i++)
            {
                val = BitBufferReadSmall (bits, mixBits + extraBits) ;
                sampleBuffer[channelIndex + i * numChannels] = val << (32 - (mixBits + extraBits));
            }
        }
        else
        {
            // read the audio data without extra bits
            for (i = 0; i < numSamples; i++)
            {
                val = BitBufferReadSmall (bits, mixBits) ;
                sampleBuffer[channelIndex + i * numChannels] = val << (32 - mixBits);
            }
        }

        // update the channel index
        channelIndex++;
        break;
    }
    case 2: // fill element
    {
        status = alac_fill_element (bits);
        break;
    }
    case 3: // data stream element
    {
        status = alac_data_stream_element (bits);
        break;
    }
    default:
    {
        // unsupported element type
        status = kALAC_UnsupportedElementType;
        goto Exit;
    }
}

// align the bitstream to byte boundaries
BitBufferByteAlign (bits, false);

// increment the active elements count
p->mActiveElements++;

// check if we've processed all the requested channels
if (channelIndex >= numChannels)
    goto NoMoreChannels;