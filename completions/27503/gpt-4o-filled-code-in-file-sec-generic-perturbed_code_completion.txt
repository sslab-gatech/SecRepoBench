switch (tag)
		{
			case 0: // ID_SCE (Single Channel Element)
			case 1: // ID_CPE (Channel Pair Element)
			case 2: // ID_CCE (Coupling Channel Element)
			case 3: // ID_LFE (Low Frequency Element)
				// Read header parameters
				headerByte = BitBufferReadSmall(bits, 8);
				partialFrame = (headerByte >> 7) & 0x01;
				bytesShifted = (headerByte >> 3) & 0x0F;
				escapeFlag = (headerByte >> 2) & 0x01;
				chanBits = (headerByte & 0x03) + 1;

				// Read the number of samples
				if (partialFrame)
				{
					extraBits = BitBufferReadSmall(bits, 8);
					numSamples = (extraBits << 8) | BitBufferReadSmall(bits, 8);
				}

				// Read the audio data
				for (i = 0; i < numSamples; i++)
				{
					val = BitBufferReadSmall(bits, chanBits);
					sampleBuffer[channelIndex + i * numChannels] = val << bytesShifted;
				}

				channelIndex++;
				if (tag == 1) // ID_CPE
					channelIndex++; // Increment for stereo pair

				break;

			case 4: // ID_DSE (Data Stream Element)
				status = alac_data_stream_element(bits);
				break;

			case 5: // ID_PCE (Program Config Element)
				// Not supported, skip
				status = kALAC_UnsupportedElement;
				break;

			case 6: // ID_FIL (Fill Element)
				status = alac_fill_element(bits);
				break;

			case 7: // ID_END (End of Stream)
				goto NoMoreChannels;

			default:
				status = kALAC_UnsupportedElement;
				break;
		}

		// Align to byte boundary
		BitBufferByteAlign(bits, false);