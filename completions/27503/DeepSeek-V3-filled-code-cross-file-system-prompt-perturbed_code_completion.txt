switch (tag)
{
    case ID_SCE:
    case ID_LFE:
        // mono/LFE channel
        elementInstanceTag = BitBufferReadSmall(bits, 4);
        headerByte = BitBufferReadSmall(bits, 8);
        if (headerByte >> 4 == 0xF) // compressed frame
        {
            escapeFlag = BitBufferReadOne(bits);
            if (escapeFlag == 0)
            {
                // compressed frame
                mixBits = BitBufferReadSmall(bits, 8);
                mixRes = (int8_t)BitBufferReadSmall(bits, 8);
                
                headerByte = BitBufferReadSmall(bits, 8);
                modeU = headerByte >> 4;
                denShiftU = headerByte & 0xFu;
                
                headerByte = BitBufferReadSmall(bits, 8);
                pbFactorU = headerByte >> 5;
                numU = headerByte & 0x1Fu;
                
                for (i = 0; i < numU; i++)
                    coefsU[i] = (int16_t)BitBufferReadSmall(bits, 16);
                
                // read the channel
                out32 = sampleBuffer + channelIndex;
                set_ag_params(&agParams, p->mConfig.mb, (pbFactorU * pb) / 4, p->mConfig.kb, numSamples, numSamples, p->mConfig.maxRun);
                status = dyn_decomp(&agParams, bits, out32, numSamples, p->mBitDepth, &bits1);
                if (status != ALAC_noErr) break;
                
                if (mixRes != 0)
                {
                    // matrixed stereo
                    mix32(out32, 1, out32, NULL, numSamples, 0, mixRes, NULL, 0);
                }
            }
            else
            {
                // uncompressed frame
                shift = 32 - p->mBitDepth;
                if (p->mBitDepth <= 16)
                {
                    for (i = 0; i < numSamples; i++)
                    {
                        val = (int32_t)BitBufferReadSmall(bits, 16);
                        val = (val << 16) >> shift;
                        sampleBuffer[channelIndex + i * numChannels] = val;
                    }
                }
                else
                {
                    for (i = 0; i < numSamples; i++)
                    {
                        val = BitBufferReadSmall(bits, p->mBitDepth);
                        val = (val << (32 - p->mBitDepth)) >> shift;
                        sampleBuffer[channelIndex + i * numChannels] = val;
                    }
                }
            }
        }
        else
        {
            // uncompressed frame (old header)
            shift = 32 - p->mBitDepth;
            for (i = 0; i < numSamples; i++)
            {
                val = (int32_t)BitBufferReadSmall(bits, 16);
                val = (val << 16) >> shift;
                sampleBuffer[channelIndex + i * numChannels] = val;
            }
        }
        channelIndex++;
        break;
        
    case ID_CPE:
        // stereo channel pair
        elementInstanceTag = BitBufferReadSmall(bits, 4);
        headerByte = BitBufferReadSmall(bits, 8);
        if (headerByte >> 4 == 0xF) // compressed frame
        {
            escapeFlag = BitBufferReadOne(bits);
            if (escapeFlag == 0)
            {
                // compressed frame
                mixBits = BitBufferReadSmall(bits, 8);
                mixRes = (int8_t)BitBufferReadSmall(bits, 8);
                
                // read first channel
                headerByte = BitBufferReadSmall(bits, 8);
                modeU = headerByte >> 4;
                denShiftU = headerByte & 0xFu;
                
                headerByte = BitBufferReadSmall(bits, 8);
                pbFactorU = headerByte >> 5;
                numU = headerByte & 0x1Fu;
                
                for (i = 0; i < numU; i++)
                    coefsU[i] = (int16_t)BitBufferReadSmall(bits, 16);
                
                // read second channel
                headerByte = BitBufferReadSmall(bits, 8);
                modeV = headerByte >> 4;
                denShiftV = headerByte & 0xFu;
                
                headerByte = BitBufferReadSmall(bits, 8);
                pbFactorV = headerByte >> 5;
                numV = headerByte & 0x1Fu;
                
                for (i = 0; i < numV; i++)
                    coefsV[i] = (int16_t)BitBufferReadSmall(bits, 16);
                
                // decode both channels
                out32 = sampleBuffer + channelIndex;
                set_ag_params(&agParams, p->mConfig.mb, (pbFactorU * pb) / 4, p->mConfig.kb, numSamples, numSamples, p->mConfig.maxRun);
                status = dyn_decomp(&agParams, bits, out32, numSamples, p->mBitDepth, &bits1);
                if (status != ALAC_noErr) break;
                
                out32 = sampleBuffer + channelIndex + 1;
                set_ag_params(&agParams, p->mConfig.mb, (pbFactorV * pb) / 4, p->mConfig.kb, numSamples, numSamples, p->mConfig.maxRun);
                status = dyn_decomp(&agParams, bits, out32, numSamples, p->mBitDepth, &bits2);
                if (status != ALAC_noErr) break;
                
                if (mixRes != 0)
                {
                    // matrixed stereo
                    mix32(sampleBuffer + channelIndex, numChannels, sampleBuffer + channelIndex, sampleBuffer + channelIndex + 1, numSamples, mixBits, mixRes, NULL, 0);
                }
            }
            else
            {
                // uncompressed frame
                shift = 32 - p->mBitDepth;
                if (p->mBitDepth <= 16)
                {
                    for (i = 0; i < numSamples; i++)
                    {
                        val = (int32_t)BitBufferReadSmall(bits, 16);
                        val = (val << 16) >> shift;
                        sampleBuffer[channelIndex + i * numChannels] = val;
                        
                        val = (int32_t)BitBufferReadSmall(bits, 16);
                        val = (val << 16) >> shift;
                        sampleBuffer[channelIndex + 1 + i * numChannels] = val;
                    }
                }
                else
                {
                    for (i = 0; i < numSamples; i++)
                    {
                        val = BitBufferReadSmall(bits, p->mBitDepth);
                        val = (val << (32 - p->mBitDepth)) >> shift;
                        sampleBuffer[channelIndex + i * numChannels] = val;
                        
                        val = BitBufferReadSmall(bits, p->mBitDepth);
                        val = (val << (32 - p->mBitDepth)) >> shift;
                        sampleBuffer[channelIndex + 1 + i * numChannels] = val;
                    }
                }
            }
        }
        else
        {
            // uncompressed frame (old header)
            shift = 32 - p->mBitDepth;
            for (i = 0; i < numSamples; i++)
            {
                val = (int32_t)BitBufferReadSmall(bits, 16);
                val = (val << 16) >> shift;
                sampleBuffer[channelIndex + i * numChannels] = val;
                
                val = (int32_t)BitBufferReadSmall(bits, 16);
                val = (val << 16) >> shift;
                sampleBuffer[channelIndex + 1 + i * numChannels] = val;
            }
        }
        channelIndex += 2;
        break;
        
    case ID_END:
        // frame end
        goto NoMoreChannels;
        
    default:
        // unsupported element
        status = kALAC_UnsupportedElement;
        break;
}