switch (tag)
		{
			case ID_SCE:
			case ID_LFE:
				// mono or LFE channel
				elementInstanceTag = BitBufferReadSmall (bits, 4) ;
				// check for valid combinations of element instance tag and channel index
				switch (p->mNumChannels)
				{
					case 1:
						RequireAction (elementInstanceTag == 0, status = kALAC_ParamError ; goto Exit ;) ;
						break ;
					case 2:
						RequireAction (elementInstanceTag <= 1, status = kALAC_ParamError ; goto Exit ;) ;
						break ;
					case 3:
						RequireAction (elementInstanceTag <= 2, status = kALAC_ParamError ; goto Exit ;) ;
						break ;
					case 4:
						RequireAction (elementInstanceTag <= 3, status = kALAC_ParamError ; goto Exit ;) ;
						break ;
					case 5:
						RequireAction (elementInstanceTag <= 4, status = kALAC_ParamError ; goto Exit ;) ;
						break ;
					case 6:
						RequireAction (elementInstanceTag <= 5, status = kALAC_ParamError ; goto Exit ;) ;
						break ;
					default:
						// fall through and fail
						break ;
				}

				RequireAction (channelIndex < numChannels, status = kALAC_ParamError ; goto Exit ;) ;

				p->mActiveElements++ ;

				// read the header bytes
				status = ReadMonoHeaderBytes (p, bits, &agParams, &headerByte, &unusedHeader, &escapeFlag, &partialFrame, &numSamples, &extraBits) ;
				RequireNoErr (status, goto Exit ;) ;

				// if this is an escape frame, copy data and go to next channel
				if (escapeFlag == 1)
				{
					out32 = sampleBuffer + channelIndex ;

					status = ReadEscapeFrame (p, bits, out32, numSamples, numChannels) ;
					RequireNoErr (status, goto Exit ;) ;
				}
				else
				{
					shiftBits = *bits ;

					bytesShifted = headerByte & 0x1f ;
					shift = bytesShifted * 8 ;

					// if shift active, read the shifted values into the shift buffer
					if (bytesShifted != 0)
					{
						status = ReadShiftedValues (p, &shiftBits, p->mShiftBuffer, numSamples) ;
						RequireNoErr (status, goto Exit ;) ;
					}

					// read the compressed frame into the predictor buffer
					status = dyn_decomp (&agParams, &shiftBits, p->mPredictor, numSamples, p->mMaxRun, &chanBits) ;
					RequireNoErr (status, goto Exit ;) ;

					// now read the number of bytes actually used and update the main bit buffer
					chanBits = BitBufferGetPosition (&shiftBits) - BitBufferGetPosition (bits) ;
					BitBufferAdvance (bits, chanBits) ;

					// byte align the bit buffer, but don't increment
					BitBufferByteAlign (bits, false) ;

					// add extra bits to the total bits used
					chanBits += extraBits ;

					// inverse predict
					if (bytesShifted != 0)
					{
						//Assert (shift <= 32) ;

						out32 = sampleBuffer + channelIndex ;
						ReconstructMonoShift (out32, p->mShiftBuffer, p->mPredictor, numSamples, numChannels, bytesShifted * 8) ;
					}
					else
					{
						out32 = sampleBuffer + channelIndex ;
						ReconstructMono (out32, p->mPredictor, numSamples, numChannels) ;
					}
				}

				channelIndex++ ;
				break ;

			case ID_CPE:
				// stereo channel pair
				elementInstanceTag = BitBufferReadSmall (bits, 4) ;

				RequireAction (channelIndex + 1 < numChannels, status = kALAC_ParamError ; goto Exit ;) ;
				RequireAction (elementInstanceTag == 0, status = kALAC_ParamError ; goto Exit ;) ;

				p->mActiveElements++ ;

				// read the header bytes
				status = ReadStereoHeaderBytes (p, bits, &agParams, &mixBits, &mixResiduals, &headerByte, &unusedHeader, &escapeFlag, &partialFrame, &numSamples, &extraBits) ;
				RequireNoErr (status, goto Exit ;) ;

				// if this is an escape frame, copy data and go to next channel
				if (escapeFlag == 1)
				{
					out32 = sampleBuffer + channelIndex ;

					status = ReadEscapeFrame (p, bits, out32, numSamples, numChannels) ;
					RequireNoErr (status, goto Exit ;) ;
				}
				else
				{
					shiftBits = *bits ;

					bytesShifted = headerByte & 0x1f ;
					shift = bytesShifted * 8 ;

					// if shift active, read the shifted values into the shift buffers
					if (bytesShifted != 0)
					{
						status = ReadShiftedValues (p, &shiftBits, p->mShiftBufferUV, numSamples) ;
						RequireNoErr (status, goto Exit ;) ;
					}

					// read the compressed frame into the predictor buffers
					numU = (headerByte >> 5) & 0x1f ;
					for (i = 0; i < numU; i++)
					{
						val = BitBufferReadSigned (bits, 16) ;
						coefsU[numU - 1 - i] = (int16_t) val;
					}
					modeU = headerByte >> 7;
					denShiftU = headerByte & 0xF;
					pbFactorU = headerByte >> 5 & 0x3;

					numV = (headerByte >> 5) & 0x1f ;
					for (i = 0; i < numV; i++)
					{
						val = BitBufferReadSigned (bits, 16) ;
						coefsV[numV - 1 - i] = (int16_t) val;
					}
					modeV = headerByte >> 7;
					denShiftV = headerByte & 0xF;
					pbFactorV = headerByte >> 5 & 0x3;

					status = dyn_decomp (&agParams, &shiftBits, p->mPredictorU, numSamples, p->mMaxRun, &chanBits) ;
					RequireNoErr (status, goto Exit ;) ;
					status = dyn_decomp (&agParams, &shiftBits, p->mPredictorV, numSamples, p->mMaxRun, &chanBits) ;
					RequireNoErr (status, goto Exit ;) ;

					// now read the number of bytes actually used and update the main bit buffer
					chanBits = BitBufferGetPosition (&shiftBits) - BitBufferGetPosition (bits) ;
					BitBufferAdvance (bits, chanBits) ;

					// byte align the bit buffer, but don't increment
					BitBufferByteAlign (bits, false) ;

					// add extra bits to the total bits used
					chanBits += extraBits ;

					if (bytesShifted != 0)
					{
						out32 = sampleBuffer + channelIndex ;
						ReconstructStereoShift (out32, p->mShiftBufferUV, p->mPredictorU, p->mPredictorV, numSamples, numChannels, bytesShifted * 8) ;
					}
					else
					{
						out32 = sampleBuffer + channelIndex ;
						ReconstructStereo (out32, p->mPredictorU, p->mPredictorV, numSamples, numChannels) ;
					}
				}

				channelIndex += 2 ;
				break ;

			case ID_END:
				// frame end - check for overruns and exit
				RequireAction (channelIndex == numChannels, status = kALAC_ParamError ; goto Exit ;) ;

				// byte align the bit buffer
				BitBufferByteAlign (bits, false) ;

				goto NoMoreChannels ;

			default:
				// unsupported element - should never happen unless the bitstream is corrupt
				status = kALAC_UnsupportedElement ;
				goto Exit ;
		}

		// check for overrun, after the fact
		RequireAction ((bits->cur <= bits->end) && (bits->bitIndex <= (bits->byteSize * 8)), status = kALAC_ParamError ; goto Exit ;) ;