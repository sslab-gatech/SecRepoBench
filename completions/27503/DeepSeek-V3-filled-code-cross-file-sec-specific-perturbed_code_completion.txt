switch (tag)
		{
			case ID_SCE:
			case ID_LFE:
			{
				// mono/LFE channel
				elementInstanceTag = BitBufferReadSmall (bits, 4) ;
				headerByte = BitBufferReadSmall (bits, 8) ;
				bytesShifted = (headerByte >> 1) & 0x7u ;
				
				// check for partial frame to override requested numSamples
				if (headerByte & 0x8u)
				{
					// partial frame
					uint32_t numPartial = BitBufferReadSmall (bits, 16) << 16 ;
					numPartial |= BitBufferReadSmall (bits, 16) ;
					RequireAction (numPartial <= numSamples, status = kALAC_ParamError ; goto Exit ;) ;
					numSamples = numPartial ;
				}
				
				if (headerByte & 0x1u)
				{
					// uncompressed
					shift = bytesShifted * 8 ;
					
					for (i = 0 ; i < numSamples ; i++)
					{
						val = BitBufferReadSmall (bits, 16) ;
						val = (val << 16) >> shift ;
						sampleBuffer [channelIndex] = val ;
						channelIndex += numChannels ;
					}
				}
				else
				{
					// compressed
					mixBits = BitBufferReadSmall (bits, 8) ;
					mixRes = (int8_t) BitBufferReadSmall (bits, 8) ;
					
					headerByte = BitBufferReadSmall (bits, 8) ;
					modeU = (headerByte >> 4) & 0xfu ;
					denShiftU = headerByte & 0xfu ;
					
					headerByte = BitBufferReadSmall (bits, 8) ;
					pbFactorU = (headerByte >> 5) & 0x7u ;
					numU = headerByte & 0x1fu ;
					
					for (i = 0 ; i < numU ; i++)
						coefsU [i] = (int16_t) BitBufferReadSmall (bits, 16) ;
					
					// if shift active, read the interleaved shift buffer
					if (bytesShifted != 0)
					{
						uint32_t shiftBits = bytesShifted * 8 ;
						uint32_t mask = (1ul << shiftBits) - 1 ;
						
						for (i = 0 ; i < numSamples ; i++)
						{
							val = BitBufferReadSmall (bits, shiftBits) ;
							sampleBuffer [channelIndex] = (val & mask) << (32 - shiftBits) ;
							channelIndex += numChannels ;
						}
					}
					
					// decode the mono stream
					set_ag_params (&agParams, p->mConfig.mb0, pbFactorU, p->mConfig.kb0, numSamples, numSamples, p->mConfig.maxRun) ;
					status = dyn_decomp (&agParams, bits, sampleBuffer + channelIndex, numSamples, numChannels, &bits1) ;
					RequireNoErr (status, goto Exit ;) ;
					
					channelIndex += numChannels * numSamples ;
				}
				
				break ;
			}
			
			case ID_CPE:
			{
				// channel pair
				elementInstanceTag = BitBufferReadSmall (bits, 4) ;
				headerByte = BitBufferReadSmall (bits, 8) ;
				bytesShifted = (headerByte >> 1) & 0x7u ;
				
				// check for partial frame to override requested numSamples
				if (headerByte & 0x8u)
				{
					// partial frame
					uint32_t numPartial = BitBufferReadSmall (bits, 16) << 16 ;
					numPartial |= BitBufferReadSmall (bits, 16) ;
					RequireAction (numPartial <= numSamples, status = kALAC_ParamError ; goto Exit ;) ;
					numSamples = numPartial ;
				}
				
				if (headerByte & 0x1u)
				{
					// uncompressed
					shift = bytesShifted * 8 ;
					
					for (i = 0 ; i < numSamples ; i++)
					{
						val = BitBufferReadSmall (bits, 16) ;
						val = (val << 16) >> shift ;
						sampleBuffer [channelIndex] = val ;
						channelIndex += numChannels ;
						
						val = BitBufferReadSmall (bits, 16) ;
						val = (val << 16) >> shift ;
						sampleBuffer [channelIndex] = val ;
						channelIndex += numChannels ;
					}
				}
				else
				{
					// compressed
					mixBits = BitBufferReadSmall (bits, 8) ;
					mixRes = (int8_t) BitBufferReadSmall (bits, 8) ;
					
					headerByte = BitBufferReadSmall (bits, 8) ;
					modeU = (headerByte >> 4) & 0xfu ;
					denShiftU = headerByte & 0xfu ;
					
					headerByte = BitBufferReadSmall (bits, 8) ;
					pbFactorU = (headerByte >> 5) & 0x7u ;
					numU = headerByte & 0x1fu ;
					
					for (i = 0 ; i < numU ; i++)
						coefsU [i] = (int16_t) BitBufferReadSmall (bits, 16) ;
					
					headerByte = BitBufferReadSmall (bits, 8) ;
					modeV = (headerByte >> 4) & 0xfu ;
					denShiftV = headerByte & 0xfu ;
					
					headerByte = BitBufferReadSmall (bits, 8) ;
					pbFactorV = (headerByte >> 5) & 0x7u ;
					numV = headerByte & 0x1fu ;
					
					for (i = 0 ; i < numV ; i++)
						coefsV [i] = (int16_t) BitBufferReadSmall (bits, 16) ;
					
					// if shift active, read the interleaved shift buffer
					if (bytesShifted != 0)
					{
						uint32_t shiftBits = bytesShifted * 8 ;
						uint32_t mask = (1ul << shiftBits) - 1 ;
						
						for (i = 0 ; i < numSamples ; i++)
						{
							val = BitBufferReadSmall (bits, shiftBits) ;
							sampleBuffer [channelIndex] = (val & mask) << (32 - shiftBits) ;
							channelIndex += numChannels ;
							
							val = BitBufferReadSmall (bits, shiftBits) ;
							sampleBuffer [channelIndex] = (val & mask) << (32 - shiftBits) ;
							channelIndex += numChannels ;
						}
					}
					
					// decode the left and right channels
					set_ag_params (&agParams, p->mConfig.mb0, pbFactorU, p->mConfig.kb0, numSamples, numSamples, p->mConfig.maxRun) ;
					status = dyn_decomp (&agParams, bits, sampleBuffer + channelIndex, numSamples, numChannels, &bits1) ;
					RequireNoErr (status, goto Exit ;) ;
					
					set_ag_params (&agParams, p->mConfig.mb0, pbFactorV, p->mConfig.kb0, numSamples, numSamples, p->mConfig.maxRun) ;
					status = dyn_decomp (&agParams, bits, sampleBuffer + channelIndex + 1, numSamples, numChannels, &bits2) ;
					RequireNoErr (status, goto Exit ;) ;
					
					channelIndex += numChannels * numSamples ;
				}
				
				break ;
			}
			
			case ID_END:
				// frame end
				goto NoMoreChannels ;
			
			default:
				// unsupported element
				status = kALAC_UnsupportedElement ;
				break ;
		}