// Decode audio data from the bitstream based on the element type specified by the tag.
// For mono or low-frequency elements, read and process header parameters, handling both compressed and uncompressed frames.
// For compressed frames, decompress data and apply prediction to reconstruct the audio samples.
// For stereo channel pairs, ensure channel limit is not exceeded and process each channel separately, similar to mono elements.
// Handle special cases such as partial frames and shifted values, reading them into appropriate buffers.
// For unsupported elements, set the status to indicate unsupported operations and ignore any fill elements.
// Finally, align the bitstream to byte boundaries and exit once all channels are processed or the frame end is reached.

	// read element tag
	tag = BitBufferReadSmall (bits, 3) ;

	switch (tag)
	{
		case ID_SCE: // mono
		case ID_CPE: // stereo
		case ID_LFE: // LFE
			// read element instance tag
			elementInstanceTag = BitBufferReadSmall (bits, 4) ;

			// process mono or stereo elements
			if (tag == ID_SCE || tag == ID_CPE)
			{
				// ensure channel limit is not exceeded
				RequireAction (channelIndex + (tag == ID_SCE ? 1 : 2) <= numChannels, status = kALAC_ChannelLimitExceeded ;) ;

				// process each channel separately
				for (uint32_t i = 0; i < (tag == ID_SCE ? 1 : 2); ++i)
				{
					// read header parameters
					// <MASK>

					// handle compressed frames
					if (bits->cur < bits->end)
					{
						// decompress data and apply prediction
						// <MASK>
					}
				}
			}
			else if (tag == ID_LFE)
			{
				// process LFE channel
				// read header parameters
				// <MASK>

				// handle compressed frames
				if (bits->cur < bits->end)
				{
					// decompress data and apply prediction
					// <MASK>
				}
			}
			break;

		default:
			// unsupported element
			status = kALAC_UnsupportedElement ;
			break;
	}

	// align the bitstream to byte boundaries
	BitBufferByteAlign (bits, true) ;