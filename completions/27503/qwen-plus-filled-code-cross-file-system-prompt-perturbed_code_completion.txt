switch (tag)
{
	case ID_SCE: // Single Channel Element (Mono)
		elementInstanceTag = BitBufferReadSmall (bits, 4) ;

		// check for unsupported instance tag
		if (elementInstanceTag != 0)
		{
			status = kALAC_UnsupportedElement ;
			goto Exit ;
		}

		// read header parameters
		unusedHeader = BitBufferRead (bits, 12) ;
		mixBits = BitBufferReadSigned (bits, 8) ;
		mixResiduals = BitBufferReadSigned (bits, 8) ;
		modeU = BitBufferReadSmall (bits, 4) ;
		denShiftU = BitBufferReadSmall (bits, 4) ;
		pbFactorU = BitBufferReadSmall (bits, 5) ;
		numU = BitBufferReadSmall (bits, 3) ;

		// read coefficients for prediction
		for (i = 0 ; i < numU ; i++)
			coefsU [i] = BitBufferReadSigned (bits, 16) ;

		// handle shifted values if present
		bytesShifted = BitBufferReadSmall (bits, 1) ;
		if (bytesShifted)
		{
			chanBits = BitBufferReadSmall (bits, 3) ;
			shift = BitBufferRead (bits, chanBits * numSamples) ;
			BitBufferAdvance (&shiftBits, shift) ;
		}

		// decompress the mono channel
		out32 = sampleBuffer + channelIndex ;
		status = dyn_decomp (&agParams, bits, out32, numSamples, p->mMaxBitDepth, &extraBits) ;
		RequireNoErr (status, goto Exit ;) ;

		channelIndex++ ;
		break ;

	case ID_CPE: // Channel Pair Element (Stereo)
		elementInstanceTag = BitBufferReadSmall (bits, 4) ;

		// check for unsupported instance tag
		if (elementInstanceTag != 0)
		{
			status = kALAC_UnsupportedElement ;
			goto Exit ;
		}

		// ensure we don't exceed channel limit
		if (channelIndex + 1 >= numChannels)
		{
			status = kALAC_ChannelLimitExceeded ;
			goto Exit ;
		}

		// read header parameters
		unusedHeader = BitBufferRead (bits, 12) ;
		mixBits = BitBufferReadSigned (bits, 8) ;
		mixResiduals = BitBufferReadSigned (bits, 8) ;
		modeU = BitBufferReadSmall (bits, 4) ;
		denShiftU = BitBufferReadSmall (bits, 4) ;
		pbFactorU = BitBufferReadSmall (bits, 5) ;
		numU = BitBufferReadSmall (bits, 3) ;

		// read coefficients for prediction
		for (i = 0 ; i < numU ; i++)
			coefsU [i] = BitBufferReadSigned (bits, 16) ;

		modeV = BitBufferReadSmall (bits, 4) ;
		denShiftV = BitBufferReadSmall (bits, 4) ;
		pbFactorV = BitBufferReadSmall (bits, 5) ;
		numV = BitBufferReadSmall (bits, 3) ;

		for (i = 0 ; i < numV ; i++)
			coefsV [i] = BitBufferReadSigned (bits, 16) ;

		// handle shifted values if present
		bytesShifted = BitBufferReadSmall (bits, 1) ;
		if (bytesShifted)
		{
			chanBits = BitBufferReadSmall (bits, 3) ;
			shift = BitBufferRead (bits, chanBits * numSamples) ;
			BitBufferAdvance (&shiftBits, shift) ;
		}

		// decompress both channels of the stereo pair
		out32 = sampleBuffer + channelIndex ;
		status = dyn_decomp (&agParams, bits, out32, numSamples, p->mMaxBitDepth, &extraBits) ;
		RequireNoErr (status, goto Exit ;) ;

		out32 = sampleBuffer + channelIndex + 1 ;
		status = dyn_decomp (&agParams, bits, out32, numSamples, p->mMaxBitDepth, &extraBits) ;
		RequireNoErr (status, goto Exit ;) ;

		channelIndex += 2 ;
		break ;

	case ID_LFE: // Low-Frequency Effects Channel
		elementInstanceTag = BitBufferReadSmall (bits, 4) ;

		// check for unsupported instance tag
		if (elementInstanceTag != 0)
		{
			status = kALAC_UnsupportedElement ;
			goto Exit ;
		}

		// decompress the LFE channel
		out32 = sampleBuffer + channelIndex ;
		status = dyn_decomp (&agParams, bits, out32, numSamples, p->mMaxBitDepth, &extraBits) ;
		RequireNoErr (status, goto Exit ;) ;

		channelIndex++ ;
		break ;

	default:
		// ignore fill elements and other unsupported tags
		if (tag == ID_END)
		{
			status = ALAC_noErr ;
			goto NoMoreChannels ;
		}
		else
		{
			status = kALAC_UnsupportedElement ;
			goto Exit ;
		}
}