switch (tag)
{
	case ID_SCE:
	{
		elementInstanceTag = BitBufferReadSmall (bits, 4);
		RequireAction (channelIndex < numChannels, status = kALAC_ParamError ; goto Exit ;);

		// Read and process header parameters (partialFrame, shift, etc.).
		// If frame is uncompressed, read raw samples directly into sampleBuffer;
		// otherwise read coefficients, any shifted data, and run dyn_decomp
		// to reconstruct the samples based on predictive coding.

		channelIndex++;
		break;
	}

	case ID_CPE:
	{
		elementInstanceTag = BitBufferReadSmall (bits, 4);
		RequireAction ((channelIndex + 1) < numChannels, status = kALAC_ParamError ; goto Exit ;);

		// Read header parameters, including mix bits and residuals.
		// Check partialFrame and shift settings. If uncompressed, read raw data;
		// otherwise perform dyn_decomp for each channel in the pair using the
		// stored coefficients and any shifted bytes.

		channelIndex += 2;
		break;
	}

	case ID_LFE:
	{
		elementInstanceTag = BitBufferReadSmall (bits, 4);
		RequireAction (channelIndex < numChannels, status = kALAC_ParamError ; goto Exit ;);

		// Similar to mono decode with potential differences for low-frequency
		// extension channels. Read header block; if compressed, apply dyn_decomp;
		// otherwise read samples as raw data.

		channelIndex++;
		break;
	}

	case ID_END:
	{
		// End of frame data
		goto NoMoreChannels;
	}

	default:
	{
		// Unsupported or filler element; set status to indicate ignoring it
		status = kALAC_UnsupportedElement;
		break;
	}
}

// Align the bitstream to a byte boundary
BitBufferByteAlign (bits, false);

// Exit if we've decoded all channels
if (channelIndex >= numChannels)
	goto NoMoreChannels;