switch (tag)
{
    case ID_SCE: // mono/single channel element
    case ID_LFE: // low frequency element
        // read element instance tag
        elementInstanceTag = BitBufferReadSmall(bits, 4);
        
        // verify we have enough output channel space
        RequireAction(channelIndex < numChannels, status = kALAC_TooManyChannels; goto NoMoreChannels;);
        
        // read the 12 unused header bits
        unusedHeader = (uint16_t)BitBufferReadSmall(bits, 12);
        
        // read the 1-bit "partial frame" flag and the 2-bit "shift" flag
        headerByte = BitBufferReadSmall(bits, 4);
        partialFrame = headerByte >> 3;
        bytesShifted = (headerByte >> 1) & 0x3;
        
        if (partialFrame)
        {
            // read the number of samples in the partial frame
            numSamples = BitBufferRead(bits, 32);
            
            // make sure we have enough space
            RequireAction(numSamples <= *outNumSamples, status = kALAC_BadBufferSize; goto NoMoreChannels;);
            
            *outNumSamples = numSamples;
        }
        
        // check for 'not compressed' flag
        escapeFlag = headerByte & 0x1;
        if (escapeFlag)
        {
            // handle uncompressed data
            if (bytesShifted == 0)
            {
                // no shift, so just read data in directly
                out32 = sampleBuffer + channelIndex;
                for (i = 0; i < numSamples; i++)
                {
                    val = (int32_t)BitBufferRead(bits, p->mConfig.bitDepth);
                    
                    // sign extend if needed
                    if ((p->mConfig.bitDepth < 32) && (val & (1 << (p->mConfig.bitDepth - 1))))
                        val |= ~0u << p->mConfig.bitDepth;
                    
                    *out32 = val;
                    out32 += numChannels;
                }
            }
            else
            {
                // handle shifted data
                shift = bytesShifted * 8;
                out32 = sampleBuffer + channelIndex;
                
                for (i = 0; i < numSamples; i++)
                {
                    val = (int32_t)BitBufferRead(bits, p->mConfig.bitDepth - shift);
                    val = val << shift;
                    
                    // sign extend if needed
                    if ((p->mConfig.bitDepth < 32) && (val & (1 << (p->mConfig.bitDepth - 1))))
                        val |= ~0u << p->mConfig.bitDepth;
                    
                    *out32 = val;
                    out32 += numChannels;
                }
            }
            
            channelIndex++;
        }
        else
        {
            // compressed frame, so decode it
            
            // read mixing parameters
            mixBits = BitBufferReadSmall(bits, 8);
            mixResiduals = (int8_t)BitBufferReadSmall(bits, 8);
            
            // read predictor coef count
            headerByte = BitBufferReadSmall(bits, 8);
            modeU = headerByte >> 4;
            denShiftU = headerByte & 0xf;
            
            headerByte = BitBufferReadSmall(bits, 8);
            pbFactorU = headerByte >> 5;
            numU = headerByte & 0x1f;
            
            // validate coef count
            RequireAction(numU <= 32, status = kALAC_ParamError; goto NoMoreChannels;);
            
            // read the coefs
            for (i = 0; i < numU; i++)
                coefsU[i] = (int16_t)BitBufferRead(bits, 16);
            
            // handle shifted data if needed
            if (bytesShifted != 0)
            {
                // set up the buffer pointers
                shiftBits = *bits;
                
                // read the shifted values into the shift buffer
                for (i = 0; i < numSamples; i++)
                {
                    shift = bytesShifted * 8;
                    RequireAction(shiftBits.cur < shiftBits.end, status = kALAC_ParamError; goto NoMoreChannels;);
                    
                    val = (int32_t)BitBufferRead(&shiftBits, shift);
                    
                    // store to shift buffer
                    p->mShiftBuffer[i] = (uint16_t)val;
                }
            }
            
            // set up params for decompression
            chanBits = p->mConfig.bitDepth - (bytesShifted * 8);
            set_ag_params(&agParams, p->mConfig.mb, pb, p->mConfig.kb, numSamples, numSamples, p->mConfig.maxRun);
            status = dyn_decomp(&agParams, bits, p->mPredictor, numSamples, chanBits, &bits1);
            RequireAction(status == ALAC_noErr, goto NoMoreChannels;);
            
            // unpcm
            if (modeU == 0)
            {
                // standard prediction mode
                pc_block(p->mPredictor, p->mMixBuffer, numSamples, coefsU, numU, chanBits, denShiftU);
            }
            else
            {
                // custom prediction mode not supported
                status = kALAC_ParamError;
                goto NoMoreChannels;
            }
            
            // unmix - copy data to the output buffer
            out32 = sampleBuffer + channelIndex;
            if (bytesShifted == 0)
            {
                for (i = 0; i < numSamples; i++)
                {
                    *out32 = p->mMixBuffer[i];
                    out32 += numChannels;
                }
            }
            else
            {
                // mix with the shift buffer
                for (i = 0; i < numSamples; i++)
                {
                    *out32 = (p->mMixBuffer[i] << (bytesShifted * 8)) | (uint32_t)p->mShiftBuffer[i];
                    out32 += numChannels;
                }
            }
            
            channelIndex++;
        }
        break;
    
    case ID_CPE: // channel pair element (stereo)
        // read element instance tag
        elementInstanceTag = BitBufferReadSmall(bits, 4);
        
        // verify we have enough output channel space
        RequireAction(channelIndex + 1 < numChannels, status = kALAC_TooManyChannels; goto NoMoreChannels;);
        
        // read the 12 unused header bits
        unusedHeader = (uint16_t)BitBufferReadSmall(bits, 12);
        
        // read the 1-bit "partial frame" flag and the 2-bit "shift" flag
        headerByte = BitBufferReadSmall(bits, 4);
        partialFrame = headerByte >> 3;
        bytesShifted = (headerByte >> 1) & 0x3;
        
        if (partialFrame)
        {
            // read the number of samples in the partial frame
            numSamples = BitBufferRead(bits, 32);
            
            // make sure we have enough space
            RequireAction(numSamples <= *outNumSamples, status = kALAC_BadBufferSize; goto NoMoreChannels;);
            
            *outNumSamples = numSamples;
        }
        
        // check for 'not compressed' flag
        escapeFlag = headerByte & 0x1;
        if (escapeFlag)
        {
            // handle uncompressed data
            if (bytesShifted == 0)
            {
                // left channel
                out32 = sampleBuffer + channelIndex;
                for (i = 0; i < numSamples; i++)
                {
                    val = (int32_t)BitBufferRead(bits, p->mConfig.bitDepth);
                    
                    // sign extend if needed
                    if ((p->mConfig.bitDepth < 32) && (val & (1 << (p->mConfig.bitDepth - 1))))
                        val |= ~0u << p->mConfig.bitDepth;
                    
                    *out32 = val;
                    out32 += numChannels;
                }
                
                // right channel
                out32 = sampleBuffer + channelIndex + 1;
                for (i = 0; i < numSamples; i++)
                {
                    val = (int32_t)BitBufferRead(bits, p->mConfig.bitDepth);
                    
                    // sign extend if needed
                    if ((p->mConfig.bitDepth < 32) && (val & (1 << (p->mConfig.bitDepth - 1))))
                        val |= ~0u << p->mConfig.bitDepth;
                    
                    *out32 = val;
                    out32 += numChannels;
                }
            }
            else
            {
                // handle shifted data
                shift = bytesShifted * 8;
                
                // left channel
                out32 = sampleBuffer + channelIndex;
                for (i = 0; i < numSamples; i++)
                {
                    val = (int32_t)BitBufferRead(bits, p->mConfig.bitDepth - shift);
                    val = val << shift;
                    
                    // sign extend if needed
                    if ((p->mConfig.bitDepth < 32) && (val & (1 << (p->mConfig.bitDepth - 1))))
                        val |= ~0u << p->mConfig.bitDepth;
                    
                    *out32 = val;
                    out32 += numChannels;
                }
                
                // right channel
                out32 = sampleBuffer + channelIndex + 1;
                for (i = 0; i < numSamples; i++)
                {
                    val = (int32_t)BitBufferRead(bits, p->mConfig.bitDepth - shift);
                    val = val << shift;
                    
                    // sign extend if needed
                    if ((p->mConfig.bitDepth < 32) && (val & (1 << (p->mConfig.bitDepth - 1))))
                        val |= ~0u << p->mConfig.bitDepth;
                    
                    *out32 = val;
                    out32 += numChannels;
                }
            }
            
            channelIndex += 2;
        }
        else
        {
            // compressed frame, so decode it
            
            // read mixing parameters
            mixBits = BitBufferReadSmall(bits, 8);
            mixResiduals = (int8_t)BitBufferReadSmall(bits, 8);
            
            // read predictor coef count for "left" channel
            headerByte = BitBufferReadSmall(bits, 8);
            modeU = headerByte >> 4;
            denShiftU = headerByte & 0xf;
            
            headerByte = BitBufferReadSmall(bits, 8);
            pbFactorU = headerByte >> 5;
            numU = headerByte & 0x1f;
            
            // validate coef count
            RequireAction(numU <= 32, status = kALAC_ParamError; goto NoMoreChannels;);
            
            // read the coefs
            for (i = 0; i < numU; i++)
                coefsU[i] = (int16_t)BitBufferRead(bits, 16);
            
            // read predictor coef count for "right" channel
            headerByte = BitBufferReadSmall(bits, 8);
            modeV = headerByte >> 4;
            denShiftV = headerByte & 0xf;
            
            headerByte = BitBufferReadSmall(bits, 8);
            pbFactorV = headerByte >> 5;
            numV = headerByte & 0x1f;
            
            // validate coef count
            RequireAction(numV <= 32, status = kALAC_ParamError; goto NoMoreChannels;);
            
            // read the coefs
            for (i = 0; i < numV; i++)
                coefsV[i] = (int16_t)BitBufferRead(bits, 16);
            
            // handle shifted data if needed
            if (bytesShifted != 0)
            {
                // set up the buffer pointers
                shiftBits = *bits;
                
                // read the shifted values into the shift buffer
                for (i = 0; i < numSamples; i++)
                {
                    shift = bytesShifted * 8;
                    RequireAction(shiftBits.cur < shiftBits.end, status = kALAC_ParamError; goto NoMoreChannels;);
                    
                    val = (int32_t)BitBufferRead(&shiftBits, shift * 2);
                    
                    // store to shift buffer
                    p->mShiftBufferUV[i*2] = (uint16_t)(val >> shift);
                    p->mShiftBufferUV[i*2+1] = (uint16_t)(val & ((1 << shift) - 1));
                }
            }
            
            // set up params for decompression
            chanBits = p->mConfig.bitDepth - (bytesShifted * 8) + 1;
            
            // decompress the "left" channel
            set_ag_params(&agParams, p->mConfig.mb, pb, p->mConfig.kb, numSamples, numSamples, p->mConfig.maxRun);
            status = dyn_decomp(&agParams, bits, p->mPredictor, numSamples, chanBits, &bits1);
            RequireAction(status == ALAC_noErr, goto NoMoreChannels;);
            
            // unpcm the "left" channel
            if (modeU == 0)
            {
                // standard prediction mode
                pc_block(p->mPredictor, p->mMixBufferU, numSamples, coefsU, numU, chanBits, denShiftU);
            }
            else
            {
                // custom prediction mode not supported
                status = kALAC_ParamError;
                goto NoMoreChannels;
            }
            
            // decompress the "right" channel
            set_ag_params(&agParams, p->mConfig.mb, pb, p->mConfig.kb, numSamples, numSamples, p->mConfig.maxRun);
            status = dyn_decomp(&agParams, bits, p->mPredictor, numSamples, chanBits, &bits2);
            RequireAction(status == ALAC_noErr, goto NoMoreChannels;);
            
            // unpcm the "right" channel
            if (modeV == 0)
            {
                // standard prediction mode
                pc_block(p->mPredictor, p->mMixBufferV, numSamples, coefsV, numV, chanBits, denShiftV);
            }
            else
            {
                // custom prediction mode not supported
                status = kALAC_ParamError;
                goto NoMoreChannels;
            }
            
            // unmix stereo
            if (bytesShifted == 0)
            {
                // left channel
                out32 = sampleBuffer + channelIndex;
                for (i = 0; i < numSamples; i++)
                {
                    *out32 = p->mMixBufferU[i];
                    out32 += numChannels;
                }
                
                // right channel
                out32 = sampleBuffer + channelIndex + 1;
                for (i = 0; i < numSamples; i++)
                {
                    *out32 = p->mMixBufferV[i];
                    out32 += numChannels;
                }
            }
            else
            {
                // mix with the shift buffer
                out32 = sampleBuffer + channelIndex;
                for (i = 0; i < numSamples; i++)
                {
                    *out32 = (p->mMixBufferU[i] << (bytesShifted * 8)) | (uint32_t)p->mShiftBufferUV[i*2];
                    out32 += numChannels;
                }
                
                out32 = sampleBuffer + channelIndex + 1;
                for (i = 0; i < numSamples; i++)
                {
                    *out32 = (p->mMixBufferV[i] << (bytesShifted * 8)) | (uint32_t)p->mShiftBufferUV[i*2+1];
                    out32 += numChannels;
                }
            }
            
            channelIndex += 2;
        }
        break;

    case ID_END:
        // we're done
        goto NoMoreChannels;
    
    case ID_FIL:
        // just skip these bytes
        extraBits = BitBufferReadSmall(bits, 4) << 8;
        extraBits += BitBufferReadSmall(bits, 8);
        
        // skip 'extraBits' bits
        BitBufferAdvance(bits, extraBits * 8);
        break;
    
    default:
        // unsupported element tag
        status = kALAC_UnsupportedElement;
        goto NoMoreChannels;
}