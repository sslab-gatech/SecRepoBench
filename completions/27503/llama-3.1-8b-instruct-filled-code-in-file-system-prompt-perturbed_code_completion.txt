while (status == ALAC_noErr)
{
	// bail if we ran off the end of the buffer
	RequireAction (bits->cur < bits->end, status = kALAC_ParamError ; goto Exit ;) ;

	// copy global decode params for this element
	pb = p->mConfig.pb ;

	// read element tag
	tag = BitBufferReadSmall (bits, 3) ;

	switch (tag)
	{
		case 0:
			// mono or low-frequency element
			// read and process header parameters, handling both compressed and uncompressed frames
			status = alac_fill_element (bits) ;
			break ;
		case 1:
			// compressed frame
			// decompress data and apply prediction to reconstruct the audio samples
			status = alac_data_stream_element (bits) ;
			break ;
		case 2:
			// stereo channel pair
			// ensure channel limit is not exceeded and process each channel separately, similar to mono elements
			status = alac_fill_element (bits) ;
			break ;
		case 3:
			// partial frame
			// read it into an appropriate buffer
			partialFrame = BitBufferReadSmall (bits, 4) ;
			BitBufferAdvance (bits, partialFrame * 8) ;
			break ;
		case 4:
			// shifted value
			// read it into an appropriate buffer
			bytesShifted = BitBufferReadSmall (bits, 4) ;
			shift = BitBufferReadSmall (bits, 4) ;
			BitBufferAdvance (bits, bytesShifted * 8) ;
			break ;
		case 5:
			// unsupported element
			// set the status to indicate unsupported operations and ignore any fill elements
			status = kALAC_UnsupportedElement ;
			break ;
		default:
			// unknown element
			// set the status to indicate unknown operations and ignore any fill elements
			status = kALAC_UnknownElement ;
			break ;
	}

	// align the bitstream to byte boundaries
	BitBufferByteAlign (bits, false) ;

	// exit once all channels are processed or the frame end is reached
	if (bits->cur >= bits->end)
		break ;
}