// <MASK>
// Decode audio data from the bitstream based on the element type specified by the tag.
// For mono or low-frequency elements, read and process header parameters, handling both compressed and uncompressed frames.
// For compressed frames, decompress data and apply prediction to reconstruct the audio samples.
// For stereo channel pairs, ensure channel limit is not exceeded and process each channel separately, similar to mono elements.
// Handle special cases such as partial frames and shifted values, reading them into appropriate buffers.
// For unsupported elements, set the status to indicate unsupported operations and ignore any fill elements.
// Finally, align the bitstream to byte boundaries and exit once all channels are processed or the frame end is reached.
if (tag == ID_SCE)
{
	// mono
	BitBufferReadSmall (bits, 4) ;	// read element instance tag
	agParams = GetMonoParams (bits, pb) ;
	*outNumSamples = agParams.numSamples ;
	if (agParams.numSamples > numSamples)
	{
		*outNumSamples = numSamples ;
	}
	numChannels = 1 ;
}
else if (tag == ID_CPE)
{
	// stereo
	BitBufferReadSmall (bits, 4) ;	// read element instance tag
	agParams = GetStereoParams (bits, pb) ;
	numChannels = 2 ;
}
else if (tag == ID_LFE)
{
	// LFE channel (subwoofer)
	BitBufferReadSmall (bits, 4) ;	// read element instance tag
	agParams = GetMonoParams (bits, pb) ;
	numChannels = 1 ;
}
else
{
	// unsupported element
	status = kALAC_UnsupportedElement ;
	goto Exit ;
}

// read header parameters
if (agParams.numSamples > numSamples)
{
	agParams.numSamples = numSamples ;
}

// read compressed data
if (agParams.compressed)
{
	// decompress data
	BitBufferReadSmall (bits, 8) ;	// read mixBits
	BitBufferReadSmall (bits, 8) ;	// read mixResiduals
	BitBufferReadSmall (bits, 8) ;	// read numU
	BitBufferReadSmall (bits, 8) ;	// read numV
	BitBufferReadSmall (bits, 8) ;	// read modeU
	BitBufferReadSmall (bits, 8) ;	// read modeV
	BitBufferReadSmall (bits, 8) ;	// read denShiftU
	BitBufferReadSmall (bits, 8) ;	// read denShiftV
	BitBufferReadSmall (bits, 8) ;	// read pbFactorU
	BitBufferReadSmall (bits, 8) ;	// read pbFactorV
	BitBufferReadSmall (bits, 8) ;	// read pb
	BitBufferReadSmall (bits, 8) ;	// read kb
	BitBufferReadSmall (bits, 8) ;	// read mb
	BitBufferReadSmall (bits, 8) ;	// read maxRun
	BitBufferReadSmall (bits, 8) ;	// read maxFrameBytes
	BitBufferReadSmall (bits, 8) ;	// read avgBitRate
	BitBufferReadSmall (bits, 8) ;	// read sampleRate

	// decompress data
	for (i = 0 ; i < numChannels ; i++)
	{
		// read predictor
		BitBufferReadSmall (bits, 8) ;	// read predictor

		// read coefficients
		for (j = 0 ; j < agParams.numCoeffs ; j++)
		{
			BitBufferReadSmall (bits, 16) ;	// read coefficient
		}

		// apply prediction
		for (j = 0 ; j < agParams.numSamples ; j++)
		{
			// read sample
			BitBufferReadSmall (bits, 16) ;	// read sample

			// apply prediction
			val = agParams.predictor * agParams.coeffs [j] ;
			sampleBuffer [i * agParams.numSamples + j] = val ;
		}
	}
}
else
{
	// read uncompressed data
	for (i = 0 ; i < numChannels ; i++)
	{
		for (j = 0 ; j < agParams.numSamples ; j++)
		{
			// read sample
			BitBufferReadSmall (bits, 16) ;	// read sample

			sampleBuffer [i * agParams.numSamples + j] = val ;
		}
	}
}

// align bitstream to byte boundaries
BitBufferByteAlign (bits, true) ;

// exit
Exit:
return status ;