// <MASK>
switch (tag)
{
    case 0: // mono or low-frequency element
    {
        // read header parameters
        elementInstanceTag = BitBufferReadSmall (bits, 4) ;
        unusedHeader = BitBufferReadSmall (bits, 8) ;
        escapeFlag = BitBufferReadOne (bits) ;
        mixBits = BitBufferReadSmall (bits, 3) ;
        mixResiduals = (int8_t) BitBufferReadSmall (bits, 2) ;

        // read compressed or uncompressed frame data
        if (escapeFlag)
        {
            // uncompressed frame
            chanBits = p->mConfig.bitDepth ;
            bytesShifted = 0 ;
            shift = 0 ;
        }
        else
        {
            // compressed frame
            chanBits = BitBufferReadSmall (bits, 4) + 1 ;
            bytesShifted = BitBufferReadSmall (bits, 3) ;
            shift = (uint32_t) BitBufferReadSmall (bits, 5) ;
        }

        // decode and reconstruct samples
        out32 = sampleBuffer + channelIndex ;
        for (i = 0; i < numSamples; i++)
        {
            val = BitBufferReadLarge (bits, chanBits) ;
            if (shift)
                val = ShiftLeft32 (val, shift) ;
            *out32 = val ;
            out32 += numChannels ;
        }

        // update channel index
        channelIndex++;
        break;
    }

    case 1: // stereo channel pair element
    {
        // read header parameters
        elementInstanceTag = BitBufferReadSmall (bits, 4) ;
        unusedHeader = BitBufferReadSmall (bits, 8) ;
        escapeFlag = BitBufferReadOne (bits) ;
        mixBits = BitBufferReadSmall (bits, 3) ;
        mixResiduals = (int8_t) BitBufferReadSmall (bits, 2) ;

        // read compressed or uncompressed frame data for each channel
        for (j = 0; j < 2; j++)
        {
            if (escapeFlag)
            {
                // uncompressed frame
                chanBits = p->mConfig.bitDepth ;
                bytesShifted = 0 ;
                shift = 0 ;
            }
            else
            {
                // compressed frame
                chanBits = BitBufferReadSmall (bits, 4) + 1 ;
                bytesShifted = BitBufferReadSmall (bits, 3) ;
                shift = (uint32_t) BitBufferReadSmall (bits, 5) ;
            }

            // decode and reconstruct samples
            out32 = sampleBuffer + channelIndex + j ;
            for (i = 0; i < numSamples; i++)
            {
                val = BitBufferReadLarge (bits, chanBits) ;
                if (shift)
                    val = ShiftLeft32 (val, shift) ;
                *out32 = val ;
                out32 += numChannels ;
            }
        }

        // update channel index
        channelIndex += 2;
        break;
    }

    case 2: // fill element
        status = alac_fill_element (bits);
        break;

    case 3: // data stream element
        status = alac_data_stream_element (bits);
        break;

    default:
        status = kALAC_UnsupportedElementType;
        goto NoMoreChannels;
}