// Check if the payload length is sufficient
  if (packet->payload_packet_len < 8) {
    return;
  }

  // Adjust payload pointer for TCP
  if (packet->tcp != NULL) {
    ovpn_payload += 2; // Skip the first two bytes (TCP length prefix)
  }

  // Extract operation code
  operationcode = ovpn_payload[0];

  // Check for UDP-specific conditions
  if (packet->udp != NULL) {
    if (flow->packet_counter == 0) {
      // First packet in the flow
      if (packet->payload_packet_len == 8 && operationcode == 0x38) {
        ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_OPENVPN, NDPI_PROTOCOL_UNKNOWN);
        return;
      }
    } else {
      // Check OpenVPN counter and operation code
      if (flow->openvpn_stage < 3 && operationcode == 0x40) {
        // Client reset, extract session ID
        alen = ovpn_payload[1];
        if (alen == 8) {
          session_remote = &ovpn_payload[2];
          memcpy(flow->openvpn_session_id, session_remote, 8);
          flow->openvpn_stage = 1;
        }
      } else if (flow->openvpn_stage == 1 && operationcode == 0x41) {
        // Server reset, verify session ID
        alen = ovpn_payload[1];
        if (alen == 8) {
          session_remote = &ovpn_payload[2];
          if (memcmp(flow->openvpn_session_id, session_remote, 8) == 0) {
            ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_OPENVPN, NDPI_PROTOCOL_UNKNOWN);
            return;
          } else {
            failed = 1;
          }
        }
      }
    }
  }

  // Increment OpenVPN counter
  flow->openvpn_stage++;

  // If detection failed, exclude OpenVPN from possible protocols
  if (failed) {
    NDPI_EXCLUDE_PROTO(ndpi_struct, flow, NDPI_PROTOCOL_OPENVPN);
  }