// <MASK>
  if(packet->payload_packet_len >= 12) {
    if(packet->tcp_retransmission == 0) {
      hmac_size = check_pkid_and_detect_hmac_size(ovpn_payload);
      if(hmac_size >= 0) {
        operationcode = (ovpn_payload[0] & P_OPCODE_MASK);
        if(packet->udp) {
          if(flow->protos.openvpn.session_id[0] == 0) {
            if((operationcode == P_CONTROL_HARD_RESET_CLIENT_V1) || (operationcode == P_CONTROL_HARD_RESET_CLIENT_V2)) {
              alen = ovpn_payload[P_PACKET_ID_ARRAY_LEN_OFFSET(hmac_size)];
              if(alen == P_HARD_RESET_CLIENT_MAX_COUNT) {
                session_remote = &ovpn_payload[9];
                memcpy(flow->protos.openvpn.session_id, session_remote, 8);
                NDPI_LOG_INFO(ndpi_struct, "OpenVPN: UDP session ID detected");
              }
            }
          } else {
            if((operationcode == P_CONTROL_HARD_RESET_SERVER_V1) || (operationcode == P_CONTROL_HARD_RESET_SERVER_V2)) {
              session_remote = &ovpn_payload[9];
              if(memcmp(flow->protos.openvpn.session_id, session_remote, 8) == 0) {
                NDPI_LOG_INFO(ndpi_struct, "OpenVPN: UDP session ID verified");
                ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_OPENVPN, NDPI_PROTOCOL_UNKNOWN);
              } else {
                failed = 1;
              }
            }
          }
        } else {
          // TCP handling
        }
      }
    }
    flow->protos.openvpn.counter++;
  }
  if(failed) {
    NDPI_ADD_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, NDPI_PROTOCOL_OPENVPN);
  }
// </MASK>