// <MASK>
if(packet->payload_packet_len >= 8) {
  if(packet->tcp != NULL) {
    ovpn_payload = packet->payload + 4;
  }

  operationcode = ovpn_payload[0];
  alen = ovpn_payload[1];

  if(packet->udp != NULL) {
    if(flow->ovpn_counter == 0 && operationcode == 0x38 && alen == 0x10) {
      NDPI_LOG_INFO(ndpi_struct, "Found OpenVPN over UDP");
      ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_OPENVPN, NDPI_PROTOCOL_UNKNOWN);
    } else if(flow->ovpn_counter < 5 && operationcode == 0x0f) {
      session_remote = &ovpn_payload[2];
      memcpy(flow->protos.openvpn.session_id, session_remote, sizeof(flow->protos.openvpn.session_id));
    } else if(flow->ovpn_counter >= 5 && flow->ovpn_counter < 10 && operationcode == 0x0e) {
      if(memcmp(flow->protos.openvpn.session_id, &ovpn_payload[2], sizeof(flow->protos.openvpn.session_id)) == 0) {
        NDPI_LOG_INFO(ndpi_struct, "Found OpenVPN over UDP");
        ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_OPENVPN, NDPI_PROTOCOL_UNKNOWN);
      } else {
        failed = 1;
      }
    }
  } else {
    hmac_size = (operationcode == 0x01 || operationcode == 0x03) ? 20 : 0;
    if(packet->payload_packet_len >= (2 + alen + hmac_size)) {
      NDPI_LOG_INFO(ndpi_struct, "Found OpenVPN over TCP");
      ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_OPENVPN, NDPI_PROTOCOL_UNKNOWN);
    }
  }

  flow->ovpn_counter++;
}

if(failed) {
  NDPI_ADD_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, NDPI_PROTOCOL_OPENVPN);
}