// Analyze the packet payload to determine if it might be an OpenVPN packet.
  // If the payload length is sufficient, adjust the payload pointer if it's over TCP.
  // Extract the operation code from the payload and, if it's over UDP, perform additional checks:
  //   - If the first packet in the flow matches specific length and operation code criteria, identify it as OpenVPN.
  //   - Otherwise, check if the flow's OpenVPN counter is below a threshold and the operation code indicates a client reset.
  //     - If so, attempt to extract and store the session ID from the payload.
  //   - If the counter is within a range and the operation code indicates a server reset, verify the session ID matches.
  //     - If a match is found, identify the protocol as OpenVPN; otherwise, mark the attempt as failed.
  // Increment the flow's OpenVPN counter after processing.
  // If the detection attempt fails, exclude the protocol from the flow's possible protocols.

  if (packet->payload_packet_len >= 4 &&
      (packet->payload[0] == 0x17 &&
       packet->payload[1] == 0x01 &&
       packet->payload[2] == 0x00 &&
       packet->payload[3] == 0x00)) {
    // This is a good query 17010000
    NDPI_LOG_INFO(ndpi_struct, "found OpenVPN\n");
    ndpi_int_openvpn_add_connection(ndpi_struct, flow);
    return;
  } else if (packet->payload_packet_len >= 5 &&
             (packet->payload[0] == 0x17 &&
              packet->payload[1] == 0x03 &&
              packet->payload[2] == 0x03 &&
              packet->payload[3] == 0x00 &&
              packet->payload[4] == 0x3A)) {
    // TLS signature of OpenVPN 0X170303003A
    NDPI_LOG_INFO(ndpi_struct, "found OpenVPN\n");
    ndpi_int_openvpn_add_connection(ndpi_struct, flow);
    return;
  } else if (packet->payload_packet_len >= 5 &&
             (packet->payload[0] == 0x17 &&
              packet->payload[1] == 0x03 &&
              packet->payload[2] == 0x03 &&
              packet->payload[3] == 0x00 &&
              packet->payload[4] == 0x69)) {
    // TCP signature of OpenVPN 0X1703030069
    NDPI_LOG_INFO(ndpi_struct, "found OpenVPN\n");
    ndpi_int_openvpn_add_connection(ndpi_struct, flow);
    return;
  } else if (packet->payload_packet_len >= 4 &&
             (packet->payload[0] == 0xfe &&
              packet->payload[1] == 0x57 &&
              packet->payload[2] == 0x7e &&
              packet->payload[3] == 0x2b)) {
    // This is a good query fe577e2b
    NDPI_LOG_INFO(ndpi_struct, "found OpenVPN\n");
    ndpi_int_openvpn_add_connection(ndpi_struct, flow);
    return;
  } else if (packet->payload_packet_len >= 5 &&
             (packet->payload[0] == 0x17 &&
              packet->payload[1] == 0x01 &&
              packet->payload[2] == 0x00 &&
              packet->payload[3] == 0x00 &&
              packet->payload[4] == 0x01)) {
    NDPI_LOG_INFO(ndpi_struct, "found OpenVPN\n");
    ndpi_int_openvpn_add_connection(ndpi_struct, flow);
    return;
  }

  // If none of the OpenVPN-specific patterns are found, exclude the protocol from the flow's possible protocols.
  NDPI_EXCLUDE_PROTO(ndpi_struct, flow);