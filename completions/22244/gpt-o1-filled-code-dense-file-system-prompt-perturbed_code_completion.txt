/* Example OpenVPN detection logic */
if (packet->payload_packet_len < 1) {
  NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
  return;
}

/* If TCP, ensure we skip the TCP header and still have enough data */
if (packet->tcp != NULL) {
  u_int16_t tcp_header_len = packet->tcp->doff << 2;
  if (packet->payload_packet_len <= tcp_header_len) {
    NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
    return;
  }
  ovpn_payload += tcp_header_len;
}

/* Extract operation code (e.g. for P_CONTROL_HARD_RESET_*_V2) */
operationcode = ovpn_payload[0];

/* Check the first packet for a quick match */
if ((flow->packets_parsed == 0) &&
    (packet->payload_packet_len >= 8) &&
    (operationcode == 0x38 || operationcode == 0x40)) {
  /* Matches client/server hard reset on first packet */
  NDPI_LOG_INFO(ndpi_struct, "found openVPN\n");
  ndpi_int_openvpn_add_connection(ndpi_struct, flow);
  return;
} else {
  /* Otherwise, use flow->protos.openvpn.counter to track the handshake state */
  if ((flow->protos.openvpn.counter < 2) &&
      (operationcode == 0x38) &&
      (packet->payload_packet_len >= 8)) {
    /* Possibly store session ID for client reset */
    session_remote = &ovpn_payload[4];
    NDPI_LOG_DBG2(ndpi_struct, "storing openVPN client session ID\n");
    /* Store in flow->protos.openvpn.session_id, for example */
  } else if ((flow->protos.openvpn.counter >= 2) &&
             (flow->protos.openvpn.counter < 4) &&
             (operationcode == 0x40) &&
             (packet->payload_packet_len >= 8)) {
    /* Check session ID for server reset */
    session_remote = &ovpn_payload[4];
    /* Compare to previously stored session_id. If it matches, confirm detection */
    if (/* match stored session_id */) {
      NDPI_LOG_INFO(ndpi_struct, "found openVPN\n");
      ndpi_int_openvpn_add_connection(ndpi_struct, flow);
      return;
    } else {
      failed = 1;
    }
  } else {
    failed = 1;
  }

  /* Increase the OpenVPN handshake counter; exclude if check failed */
  flow->protos.openvpn.counter++;
  if (failed) {
    NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
  }
}