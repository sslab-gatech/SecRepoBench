// Check if the payload length is sufficient
  if(packet->payload_packet_len < 8) {
    return;
  }

  // Adjust payload pointer if over TCP
  if(packet->tcp != NULL) {
    ovpn_payload += 2; // Skip the first two bytes for TCP
  }

  // Extract operation code
  operationcode = ovpn_payload[0];

  // Check if the packet is over UDP
  if(packet->udp != NULL) {
    // Check for specific length and operation code criteria
    if(packet->payload_packet_len == 14 && operationcode == 0x38) {
      flow->detected_protocol = NDPI_PROTOCOL_OPENVPN;
      return;
    }

    // Check OpenVPN counter and operation code for client reset
    if(flow->openvpn_counter < 3 && operationcode == 0x0F) {
      session_remote = &ovpn_payload[1];
      // Store session ID
      memcpy(flow->openvpn_session_id, session_remote, 8);
    }

    // Check OpenVPN counter and operation code for server reset
    if(flow->openvpn_counter >= 3 && flow->openvpn_counter < 10 && operationcode == 0x10) {
      session_remote = &ovpn_payload[1];
      // Verify session ID
      if(memcmp(flow->openvpn_session_id, session_remote, 8) == 0) {
        flow->detected_protocol = NDPI_PROTOCOL_OPENVPN;
        return;
      } else {
        failed = 1;
      }
    }
  }

  // Increment OpenVPN counter
  flow->openvpn_counter++;

  // If detection failed, exclude OpenVPN from possible protocols
  if(failed) {
    NDPI_EXCLUDE_PROTO(ndpi_struct, flow, NDPI_PROTOCOL_OPENVPN);
  }