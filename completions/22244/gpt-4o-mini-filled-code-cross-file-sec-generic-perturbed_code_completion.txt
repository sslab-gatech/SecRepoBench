if (packet->payload_length < MIN_OPENVPN_PAYLOAD_LENGTH) {
    return; // Not enough data to analyze
  }

  if (packet->tcp != NULL) {
    ovpn_payload += TCP_HEADER_SIZE; // Adjust for TCP header
  }

  operationcode = ovpn_payload[0];
  if (packet->udp != NULL) {
    if (flow->openvpn_counter == 0 && operationcode == OPENVPN_CLIENT_HELLO) {
      // First packet, check for specific length and operation code
      if (packet->payload_length == EXPECTED_OPENVPN_LENGTH) {
        flow->detected_protocol_stack[0] = NDPI_PROTOCOL_OPENVPN;
        flow->openvpn_counter++;
        return;
      }
    } else if (flow->openvpn_counter < MAX_OPENVPN_COUNTER && operationcode == OPENVPN_CLIENT_RESET) {
      // Attempt to extract session ID
      session_remote = ovpn_payload + SESSION_ID_OFFSET;
      // Store session ID securely
      memcpy(flow->session_id, session_remote, SESSION_ID_SIZE);
      flow->openvpn_counter++;
      return;
    } else if (flow->openvpn_counter >= MIN_OPENVPN_COUNTER && operationcode == OPENVPN_SERVER_RESET) {
      // Verify session ID
      if (memcmp(flow->session_id, ovpn_payload + SESSION_ID_OFFSET, SESSION_ID_SIZE) == 0) {
        flow->detected_protocol_stack[0] = NDPI_PROTOCOL_OPENVPN;
        return;
      }
    }
  }

  failed = 1; // Mark detection attempt as failed
  flow->detected_protocol_stack[0] = NDPI_PROTOCOL_UNKNOWN; // Exclude from possible protocols