if (packet->payload_packet_len < 10) {
  NDPI_EXCLUDE_PROTOCOL(ndpi_struct, flow);
  return;
}

if (packet->tcp != NULL) {
  ovpn_payload += 10; // Adjust payload pointer for TCP.
}

operationcode = *ovpn_payload;

if (packet->udp != NULL) {
  if ((packet->payload_packet_len == 24 || packet->payload_packet_len == 64) && operationcode == 17) {
    ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_OPENVPN, NDPI_PROTOCOL_UNKNOWN, NDPI_CONFIDENCE_DPI);
    return;
  }

  if (flow->openvpn_counter < 5 && operationcode == 18 /* Client Reset */) {
    session_remote = ovpn_payload + 1;
    alen = *session_remote;
    hmac_size = *(session_remote + 1);

    if (alen > 0 && hmac_size >= 0) {
      flow->openvpn_session_id_length = alen;
      flow->openvpn_session_id = malloc(alen); // Secure heap allocation.

      if (flow->openvpn_session_id != NULL) {
        memcpy(flow->openvpn_session_id, session_remote + 2, alen);
      } else {
        failed = 1;
      }
    } else {
      failed = 1;
    }
  } else if (flow->openvpn_counter >= 5 && flow->openvpn_counter <= 10 && operationcode == 19 /* Server Reset */) {
    session_remote = ovpn_payload + 1;

    if (flow->openvpn_session_id != NULL && flow->openvpn_session_id_length > 0 &&
        memcmp(flow->openvpn_session_id, session_remote, flow->openvpn_session_id_length) == 0) {
      ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_OPENVPN, NDPI_PROTOCOL_UNKNOWN, NDPI_CONFIDENCE_DPI);
      return;
    } else {
      failed = 1;
    }
  }
}

if (failed) {
  NDPI_EXCLUDE_PROTOCOL(ndpi_struct, flow);
}

flow->openvpn_counter++;