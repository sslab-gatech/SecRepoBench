int32_t hdr_dummy;
  int64_t frame_len, nbytes;
  int32_t chunksize, nchunks, typesize;
  int ret = get_header_info(frame, &hdr_dummy, &frame_len, &nbytes, &cbytes, &chunksize,
                            &nchunks, NULL, NULL, NULL, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get header info from frame.");
    return ret;
  }
  if (nchunk < 0 || nchunk >= nchunks) {
    BLOSC_TRACE_ERROR("nchunk (%d) out of bounds (nchunks = %d).", nchunk, nchunks);
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  int32_t coffsets_cbytes = 0;
  uint8_t* coffsets = get_coffsets(frame, headerlength, cbytes, &coffsets_cbytes);
  if (coffsets == NULL) {
    BLOSC_TRACE_ERROR("Cannot get the offsets for the frame.");
    return BLOSC2_ERROR_DATA;
  }

  size_t expected_size = (size_t)nchunks * sizeof(int64_t);
  int64_t *offs = (int64_t *) malloc(expected_size);
  if (offs == NULL) {
    BLOSC_TRACE_ERROR("Memory allocation error.");
    return BLOSC2_ERROR_MEMORY_ALLOC;
  }

  blosc2_dparams off_dparams = BLOSC2_DPARAMS_DEFAULTS;
  blosc2_context *dctx = blosc2_create_dctx(off_dparams);
  int32_t decomp_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes, (uint8_t*)offs, expected_size);
  blosc2_free_ctx(dctx);
  if (decomp_nbytes != (int32_t)expected_size) {
    BLOSC_TRACE_ERROR("Cannot decompress the offsets chunk.");
    free(offs);
    return BLOSC2_ERROR_DATA;
  }

  *offset = offs[nchunk];
  free(offs);
  return 0;