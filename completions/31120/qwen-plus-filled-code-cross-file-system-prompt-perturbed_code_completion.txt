int32_t coffsets_cbytes = 0;
uint8_t* coffsets = get_coffsets(frame, headerlength, cbytes, &coffsets_cbytes);
if (coffsets == NULL) {
  BLOSC_TRACE_ERROR("Unable to retrieve offsets for the frame.");
  return BLOSC2_ERROR_DATA;
}
if (coffsets_cbytes == 0) {
  coffsets_cbytes = cbytes;
}

// Decompress offsets
blosc2_dparams off_dparams = BLOSC2_DPARAMS_DEFAULTS;
blosc2_context *dctx = blosc2_create_dctx(off_dparams);
int64_t *offsets = malloc((size_t)frame->nchunks * sizeof(int64_t));
int32_t prev_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes, offsets,
                                            frame->nchunks * sizeof(int64_t));
blosc2_free_ctx(dctx);
if (prev_nbytes < 0) {
  free(offsets);
  BLOSC_TRACE_ERROR("Cannot decompress the offsets chunk.");
  return BLOSC2_ERROR_DECOMPRESSION;
}

// Obtain the offset for the specified chunk index
if (nchunk >= frame->nchunks) {
  BLOSC_TRACE_ERROR("Invalid chunk index '%d' exceeds the number of chunks ('%d') in frame.",
                    nchunk, frame->nchunks);
  free(offsets);
  return BLOSC2_ERROR_INVALID_PARAM;
}
*offset = offsets[nchunk];

free(offsets);
return 0;