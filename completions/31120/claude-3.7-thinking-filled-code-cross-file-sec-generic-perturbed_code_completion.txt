int get_coffset(blosc2_frame_s* frame, int32_t headerlength, int64_t cbytes, int32_t nchunk, int64_t *offset) {
  // Get the offsets for all chunks
  int32_t coffsets_cbytes = 0;
  uint8_t *coffsets = get_coffsets(frame, headerlength, cbytes, &coffsets_cbytes);
  if (coffsets == NULL) {
    BLOSC_TRACE_ERROR("Cannot get the offsets for the frame.");
    return BLOSC2_ERROR_DATA;
  }
  if (coffsets_cbytes == 0) {
    coffsets_cbytes = cbytes;
  }

  // Determine the size of the decompressed offsets
  blosc2_dparams off_dparams = BLOSC2_DPARAMS_DEFAULTS;
  blosc2_context *dctx = blosc2_create_dctx(off_dparams);
  // Get uncompressed offsets size
  int32_t off_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes, NULL, 0);
  if (off_nbytes < 0) {
    blosc2_free_ctx(dctx);
    BLOSC_TRACE_ERROR("Cannot determine the size of offsets.");
    return off_nbytes;
  }

  int32_t nchunks = off_nbytes / sizeof(int64_t);
  if (nchunk >= nchunks) {
    blosc2_free_ctx(dctx);
    BLOSC_TRACE_ERROR("nchunk (%d) exceeds the number of chunks (%d) in frame.", nchunk, nchunks);
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  // Allocate memory for the offsets
  int64_t* offsets = malloc((size_t)off_nbytes);
  if (offsets == NULL) {
    blosc2_free_ctx(dctx);
    BLOSC_TRACE_ERROR("Cannot allocate memory for offsets.");
    return BLOSC2_ERROR_MEMORY_ALLOC;
  }

  // Decompress the offsets
  int32_t ret = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes, offsets, off_nbytes);
  blosc2_free_ctx(dctx);
  if (ret < 0) {
    free(offsets);
    BLOSC_TRACE_ERROR("Cannot decompress the offsets.");
    return ret;
  }

  // Extract the offset for the specific chunk
  *offset = offsets[nchunk];
  free(offsets);

  return 0;
}