int get_coffset(blosc2_frame_s* frame, int32_t headerlength, int64_t cbytes, int32_t nchunk, int64_t *offset) {
  // Get the offsets for all chunks in the frame using helper function.
  int32_t coffsets_cbytes;
  uint8_t *coffsets = get_coffsets(frame, headerlength, cbytes, &coffsets_cbytes);
  if (coffsets == NULL) {
    BLOSC_TRACE_ERROR("Unable to retrieve offsets for the frame.");
    return BLOSC2_ERROR_DATA;
  }

  // Decompress offsets
  blosc2_dparams off_dparams = BLOSC2_DPARAMS_DEFAULTS;
  blosc2_context *dctx = blosc2_create_dctx(off_dparams);
  int32_t nchunks = cbytes / *(int64_t *)(frame->cframe + headerlength); // Assuming this logic from elsewhere
  int64_t* offsets = (int64_t *) malloc(nchunks * sizeof(int64_t));
  int32_t prev_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes, offsets, nchunks * sizeof(int64_t));
  blosc2_free_ctx(dctx);
  if (prev_nbytes < 0) {
    free(offsets);
    BLOSC_TRACE_ERROR("Cannot decompress the offsets chunk.");
    return BLOSC2_ERROR_DECOMPRESSION;
  }

  // Obtain the offset for the specified chunk index within the offsets data.
  if (nchunk >= nchunks) {
    free(offsets);
    BLOSC_TRACE_ERROR("The chunk index exceeds the number of chunks in the frame.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }
  *offset = offsets[nchunk];
  free(offsets);

  return 0; // Success code
}