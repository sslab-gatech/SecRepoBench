{
  int32_t coffsets_cbytes = 0;
  uint8_t *coffsets = get_coffsets(frame, headerlength, cbytes, &coffsets_cbytes);
  if (coffsets == NULL) {
    BLOSC_TRACE_ERROR("Cannot get the offsets for the frame.");
    return BLOSC2_ERROR_DATA;
  }
  if (coffsets_cbytes == 0) {
    coffsets_cbytes = (int32_t)cbytes;
  }

  /* We need to decompress at least (nchunk + 1) offsets (each of 8 bytes) */
  int32_t expected_nbytes = (nchunk + 1) * sizeof(int64_t);
  int64_t* offsets = malloc(expected_nbytes);
  if (offsets == NULL) {
    BLOSC_TRACE_ERROR("Memory allocation error in get_coffset.");
    return BLOSC2_ERROR_MEMORY_ALLOC;
  }

  blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
  blosc2_context *dctx = blosc2_create_dctx(dparams);
  int32_t decompressed_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes,
                                                       offsets, expected_nbytes);
  blosc2_free_ctx(dctx);
  if (decompressed_nbytes < 0) {
    free(offsets);
    BLOSC_TRACE_ERROR("Error decompressing chunk offsets.");
    return decompressed_nbytes;
  }
  if (decompressed_nbytes < expected_nbytes) {
    free(offsets);
    BLOSC_TRACE_ERROR("Not enough offsets available for chunk index %d.", nchunk);
    return BLOSC2_ERROR_DATA;
  }

  *offset = offsets[nchunk];
  free(offsets);
  return 0;
}