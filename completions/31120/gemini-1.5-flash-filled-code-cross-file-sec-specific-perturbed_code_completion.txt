int64_t* offsets = NULL;
  int rcode = 0;
  if (frame->coffsets != NULL) {
    offsets = frame->coffsets;
  } else {
    int32_t header_len_ = headerlength;
    int64_t cbytes_ = cbytes;
    int32_t nchunks_ = 0;
    int32_t typesize_ = 0;
    int64_t nbytes_ = 0;
    int32_t chunksize_ = 0;
    rcode = get_header_info(frame, &header_len_, NULL, &nbytes_, &cbytes_, &chunksize_, &nchunks_, &typesize_, NULL, NULL, NULL, NULL);
    if (rcode < 0) {
      BLOSC_TRACE_ERROR("Unable to get meta info from frame.");
      return rcode;
    }
    int32_t coffsets_cbytes = 0;
    uint8_t* coffsets = get_coffsets(frame, header_len_, cbytes_, &coffsets_cbytes);
    if (coffsets == NULL) {
      BLOSC_TRACE_ERROR("Unable to get offsets from frame.");
      return BLOSC2_ERROR_DATA;
    }
    if (coffsets_cbytes == 0) {
      coffsets_cbytes = cbytes_;
    }
    offsets = (int64_t*)malloc(nchunks_ * sizeof(int64_t));
    if (offsets == NULL) {
      BLOSC_TRACE_ERROR("Unable to allocate memory for offsets.");
      return BLOSC2_ERROR_MEMORY_ALLOC;
    }
    blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
    blosc2_context* dctx = blosc2_create_dctx(dparams);
    int32_t nbytes_read = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes, offsets, nchunks_ * sizeof(int64_t));
    blosc2_free_ctx(dctx);
    free(coffsets);
    if (nbytes_read < 0) {
      BLOSC_TRACE_ERROR("Unable to decompress offsets.");
      free(offsets);
      return BLOSC2_ERROR_DECOMPRESS;
    }
    frame->coffsets = offsets;
  }
  if (nchunk >= 0 && nchunk < (int32_t)(sizeof(offsets) / sizeof(offsets[0]))) {
    *offset = offsets[nchunk];
    return 0;
  } else {
    BLOSC_TRACE_ERROR("nchunk out of bounds.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }
}