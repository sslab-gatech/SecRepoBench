}
    metalayer->content_len = content_len;

    // Finally, read the content
    trailer_pos += content_len;
    if (trailer_len < trailer_pos) {
      return BLOSC2_ERROR_READ_BUFFER;
    }
    char* content = malloc((size_t)content_len);
    memcpy(content, content_marker + 1 + 4, (size_t)content_len);
    metalayer->content = (uint8_t*)content;
  }

  return 1;
}

int frame_get_vlmetalayers(blosc2_frame_s* frame, blosc2_schunk* schunk) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int32_t chunksize;
  int32_t nchunks;
  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
    return ret;
  }

  // Get the trailer
  uint8_t* trailer = NULL;
  if (frame->cframe != NULL) {
    trailer = frame->cframe + frame_len - FRAME_TRAILER_MINLEN;
  } else {
    size_t rbytes = 0;
    trailer = malloc(FRAME_TRAILER_MINLEN);
    FILE* fp = NULL;
    if (frame->sframe) {
      fp = sframe_open_index(frame->urlpath, "rb");
    }
    else {
      fp = fopen(frame->urlpath, "rb");
    }
    if (fp != NULL) {
      rbytes = fread(trailer, 1, FRAME_TRAILER_MINLEN, fp);
      fclose(fp);
    }
    if (rbytes != (size_t) FRAME_TRAILER_MINLEN) {
      BLOSC_TRACE_ERROR("Cannot access the trailer out of the frame.");
      free(trailer);
      return BLOSC2_ERROR_FILE_READ;
    }
  }

  ret = get_vlmeta_from_trailer(frame, schunk, trailer, FRAME_TRAILER_MINLEN);

  if (frame->cframe == NULL) {
    free(trailer);
  }

  return ret;
}


int frame_get_data(blosc2_frame_s* frame, blosc2_schunk* schunk, int32_t chunk, uint8_t** data) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int32_t chunksize;
  int32_t nchunks;
  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
    return ret;
  }

  if (chunk < 0 || chunk >= nchunks) {
    BLOSC_TRACE_ERROR("Invalid chunk index.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  int64_t chunk_offset = (int64_t)chunk * chunksize;
  if (chunk_offset + chunksize > nbytes) {
    BLOSC_TRACE_ERROR("Chunk offset exceeds the frame size.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  uint8_t* coffsets = get_coffsets(frame, header_len, cbytes, NULL);
  if (coffsets == NULL) {
    return BLOSC2_ERROR_DATA;
  }

  int64_t chunk_start = *(int64_t*)(coffsets + chunk * sizeof(int64_t));
  int64_t chunk_end = *(int64_t*)(coffsets + (chunk + 1) * sizeof(int64_t));

  if (chunk_start < 0 || chunk_end < 0 || chunk_start >= chunk_end || chunk_end > cbytes) {
    BLOSC_TRACE_ERROR("Invalid chunk offsets.");
    free(coffsets);
    return BLOSC2_ERROR_DATA;
  }

  *data = malloc((size_t) (chunk_end - chunk_start));
  if (*data == NULL) {
    free(coffsets);
    return BLOSC2_ERROR_MEMORY_ALLOC;
  }

  FILE* fp = NULL;
  if (frame->sframe) {
    fp = sframe_open_index(frame->urlpath, "rb");
  }
  else {
    fp = fopen(frame->urlpath, "rb");
  }
  if (fp == NULL) {
    free(coffsets);
    free(*data);
    return BLOSC2_ERROR_FILE_OPEN;
  }

  fseek(fp, header_len + chunk_start, SEEK_SET);
  size_t rbytes = fread(*data, 1, (size_t) (chunk_end - chunk_start), fp);
  fclose(fp);

  if (rbytes != (size_t) (chunk_end - chunk_start)) {
    free(coffsets);
    free(*data);
    return BLOSC2_ERROR_FILE_READ;
  }

  free(coffsets);
  return 1;
}


int frame_put_data(blosc2_frame_s* frame, blosc2_schunk* schunk, int32_t chunk, uint8_t* data, int32_t data_len) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int32_t chunksize;
  int32_t nchunks;
  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
    return ret;
  }

  if (chunk < 0 || chunk >= nchunks) {
    BLOSC_TRACE_ERROR("Invalid chunk index.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  if (data_len < 0 || data_len > chunksize) {
    BLOSC_TRACE_ERROR("Invalid data length.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  int64_t chunk_offset = (int64_t)chunk * chunksize;
  if (chunk_offset + data_len > nbytes) {
    BLOSC_TRACE_ERROR("Chunk offset exceeds the frame size.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  uint8_t* coffsets = get_coffsets(frame, header_len, cbytes, NULL);
  if (coffsets == NULL) {
    return BLOSC2_ERROR_DATA;
  }

  int64_t chunk_start = *(int64_t*)(coffsets + chunk * sizeof(int64_t));
  int64_t chunk_end = *(int64_t*)(coffsets + (chunk + 1) * sizeof(int64_t));

  if (chunk_start < 0 || chunk_end < 0 || chunk_start >= chunk_end || chunk_end > cbytes) {
    BLOSC_TRACE_ERROR("Invalid chunk offsets.");
    free(coffsets);
    return BLOSC2_ERROR_DATA;
  }

  FILE* fp = NULL;
  if (frame->sframe) {
    fp = sframe_open_index(frame->urlpath, "rb+");
  }
  else {
    fp = fopen(frame->urlpath, "rb+");
  }
  if (fp == NULL) {
    free(coffsets);
    return BLOSC2_ERROR_FILE_OPEN;
  }

  fseek(fp, header_len + chunk_start, SEEK_SET);
  size_t wbytes = fwrite(data, 1, (size_t) data_len, fp);
  fclose(fp);

  if (wbytes != (size_t) data_len) {
    free(coffsets);
    return BLOSC2_ERROR_FILE_WRITE;
  }

  free(coffsets);
  return 1;
}


int frame_delete_data(blosc2_frame_s* frame, blosc2_schunk* schunk, int32_t chunk) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int32_t chunksize;
  int32_t nchunks;
  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
    return ret;
  }

  if (chunk < 0 || chunk >= nchunks) {
    BLOSC_TRACE_ERROR("Invalid chunk index.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  int64_t chunk_offset = (int64_t)chunk * chunksize;
  if (chunk_offset + chunksize > nbytes) {
    BLOSC_TRACE_ERROR("Chunk offset exceeds the frame size.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  uint8_t* coffsets = get_coffsets(frame, header_len, cbytes, NULL);
  if (coffsets == NULL) {
    return BLOSC2_ERROR_DATA;
  }

  int64_t chunk_start = *(int64_t*)(coffsets + chunk * sizeof(int64_t));
  int64_t chunk_end = *(int64_t*)(coffsets + (chunk + 1) * sizeof(int64_t));

  if (chunk_start < 0 || chunk_end < 0 || chunk_start >= chunk_end || chunk_end > cbytes) {
    BLOSC_TRACE_ERROR("Invalid chunk offsets.");
    free(coffsets);
    return BLOSC2_ERROR_DATA;
  }

  FILE* fp = NULL;
  if (frame->sframe) {
    fp = sframe_open_index(frame->urlpath, "rb+");
  }
  else {
    fp = fopen(frame->urlpath, "rb+");
  }
  if (fp == NULL) {
    free(coffsets);
    return BLOSC2_ERROR_FILE_OPEN;
  }

  // Fill the chunk with zeros
  uint8_t* zeros = calloc(1, chunksize);
  fseek(fp, header_len + chunk_start, SEEK_SET);
  size_t wbytes = fwrite(zeros, 1, (size_t) chunksize, fp);
  free(zeros);
  fclose(fp);

  if (wbytes != (size_t) chunksize) {
    free(coffsets);
    return BLOSC2_ERROR_FILE_WRITE;
  }

  free(coffsets);
  return 1;
}


int frame_get_chunk(blosc2_frame_s* frame, int32_t chunk, uint8_t** data) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int32_t chunksize;
  int32_t nchunks;
  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &