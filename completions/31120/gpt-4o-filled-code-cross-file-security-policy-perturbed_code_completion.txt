int32_t coffsets_cbytes = 0;
  uint8_t *coffsets = get_coffsets(frame, headerlength, cbytes, &coffsets_cbytes);
  if (coffsets == NULL) {
    BLOSC_TRACE_ERROR("Cannot get the offsets for the frame.");
    return BLOSC2_ERROR_DATA;
  }

  // Decompress offsets
  int64_t* offsets = (int64_t*)malloc((size_t)(nchunk + 1) * sizeof(int64_t));
  if (offsets == NULL) {
    BLOSC_TRACE_ERROR("Cannot allocate memory for offsets.");
    free(coffsets);
    return BLOSC2_ERROR_MEMORY_ALLOC;
  }

  blosc2_dparams off_dparams = BLOSC2_DPARAMS_DEFAULTS;
  blosc2_context *dctx = blosc2_create_dctx(off_dparams);
  int32_t prev_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes, offsets, (nchunk + 1) * sizeof(int64_t));
  blosc2_free_ctx(dctx);
  free(coffsets);

  if (prev_nbytes < 0) {
    free(offsets);
    BLOSC_TRACE_ERROR("Cannot decompress the offsets chunk.");
    return prev_nbytes;
  }

  // Obtain the offset for the specified chunk index
  if (nchunk >= 0 && nchunk < prev_nbytes / sizeof(int64_t)) {
    *offset = offsets[nchunk];
    free(offsets);
    return 0;  // Success
  } else {
    free(offsets);
    BLOSC_TRACE_ERROR("Invalid chunk index.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }