if (frame == NULL) {
    BLOSC_TRACE_ERROR("Invalid frame pointer.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  if (nchunk < 0) {
    BLOSC_TRACE_ERROR("Chunk index cannot be negative.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  if (frame->coffsets == NULL) {
    // Offsets not cached, read them from the frame
    int32_t coffsets_cbytes;
    uint8_t *coffsets = get_coffsets(frame, headerlength, cbytes, &coffsets_cbytes);
    if (coffsets == NULL) {
      BLOSC_TRACE_ERROR("Cannot get the offsets for the frame.");
      return BLOSC2_ERROR_DATA;
    }

    if (coffsets_cbytes == 0) {
      coffsets_cbytes = (int32_t)cbytes;
    }

    // Allocate memory for the offsets
    frame->coffsets_nchunks = frame->nchunks;
    frame->coffsets = malloc((size_t)frame->coffsets_nchunks * sizeof(int64_t));
    if (frame->coffsets == NULL) {
      BLOSC_TRACE_ERROR("Cannot allocate memory for the offsets.");
      return BLOSC2_ERROR_MEMORY_ALLOC;
    }

    // Decompress offsets
    blosc2_dparams off_dparams = BLOSC2_DPARAMS_DEFAULTS;
    blosc2_context *dctx = blosc2_create_dctx(off_dparams);
    int32_t prev_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes,
                                                frame->coffsets, frame->coffsets_nchunks * sizeof(int64_t));
    blosc2_free_ctx(dctx);
    if (prev_nbytes < 0) {
      free(frame->coffsets);
      frame->coffsets = NULL;
      BLOSC_TRACE_ERROR("Cannot decompress the offsets chunk.");
      return prev_nbytes;
    }
  }

  if (nchunk >= frame->coffsets_nchunks) {
    BLOSC_TRACE_ERROR("Chunk index exceeds the number of chunks in frame.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  *offset = frame->coffsets[nchunk];

  return 0;