_t content_len;
    trailer_pos += sizeof(content_len);
    if (trailer_len < trailer_pos) {
      return BLOSC2_ERROR_READ_BUFFER;
    }
    big_store(&content_len, content_marker + 1, sizeof(content_len));
    if (content_len < 0) {
      return BLOSC2_ERROR_DATA;
    }
    metalayer->content_len = content_len;

    // Finally, read the content
    trailer_pos += content_len;
    if (trailer_len < trailer_pos) {
      return BLOSC2_ERROR_READ_BUFFER;
    }
    char* content = malloc((size_t)content_len);
    memcpy(content, content_marker + 1 + 4, (size_t)content_len);
    metalayer->content = (uint8_t*)content;
  }

  return 1;
}

int frame_get_vlmetalayers(blosc2_frame_s* frame, blosc2_schunk* schunk) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int32_t chunksize;
  int32_t nchunks;
  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
    return ret;
  }

  // Get the trailer
  uint8_t* trailer = NULL;
  if (frame->cframe != NULL) {
    trailer = frame->cframe + frame_len - FRAME_TRAILER_MINLEN;
  } else {
    size_t rbytes = 0;
    trailer = malloc(FRAME_TRAILER_MINLEN);
    FILE* fp = NULL;
    if (frame->sframe) {
      fp = sframe_open_index(frame->urlpath, "rb");
    }
    else {
      fp = fopen(frame->urlpath, "rb");
    }
    if (fp != NULL) {
      fseek(fp, frame_len - FRAME_TRAILER_MINLEN, SEEK_SET);
      rbytes = fread(trailer, 1, FRAME_TRAILER_MINLEN, fp);
      fclose(fp);
    }
    if (rbytes != FRAME_TRAILER_MINLEN) {
      BLOSC_TRACE_ERROR("Cannot access the trailer out of the frame.");
      free(trailer);
      return BLOSC2_ERROR_FILE_READ;
    }
  }

  ret = get_vlmeta_from_trailer(frame, schunk, trailer, FRAME_TRAILER_MINLEN);

  if (frame->cframe == NULL) {
    free(trailer);
  }

  return ret;
}


int frame_get_filters(blosc2_frame_s* frame, blosc2_schunk* schunk) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int32_t chunksize;
  int32_t nchunks;
  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
    return ret;
  }

  // Get the header
  uint8_t* header = NULL;
  if (frame->cframe != NULL) {
    header = frame->cframe;
  } else {
    size_t rbytes = 0;
    header = malloc(header_len);
    FILE* fp = NULL;
    if (frame->sframe) {
      fp = sframe_open_index(frame->urlpath, "rb");
    }
    else {
      fp = fopen(frame->urlpath, "rb");
    }
    if (fp != NULL) {
      rbytes = fread(header, 1, header_len, fp);
      fclose(fp);
    }
    if (rbytes != (size_t) header_len) {
      BLOSC_TRACE_ERROR("Cannot access the header out of the frame.");
      free(header);
      return BLOSC2_ERROR_FILE_READ;
    }
  }

  uint8_t* filter_pipeline = header + FRAME_FILTER_PIPELINE + 1;
  int nfilters = frame->cframe == NULL ? 0 : frame->cframe[FRAME_FILTER_PIPELINE];
  if (nfilters > BLOSC2_MAX_FILTERS) {
    BLOSC_TRACE_ERROR("The number of filters in frame header are too large for Blosc2.");
    if (frame->cframe == NULL) {
      free(header);
    }
    return BLOSC2_ERROR_INVALID_HEADER;
  }
  for (int i = 0; i < nfilters; i++) {
    schunk->filters[i] = filter_pipeline[i];
  }
  filter_pipeline += FRAME_FILTER_PIPELINE_MAX;
  for (int i = 0; i < nfilters; i++) {
    schunk->filters_meta[i] = filter_pipeline[i];
  }

  if (frame->cframe == NULL) {
    free(header);
  }

  return 1;
}


int frame_get_chunk(blosc2_frame_s* frame, int32_t index, uint8_t** data, bool* needs_free) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int32_t chunksize;
  int32_t nchunks;
  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
    return ret;
  }

  if (index < 0 || index >= nchunks) {
    BLOSC_TRACE_ERROR("Invalid chunk index.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  uint8_t* coffsets = get_coffsets(frame, header_len, cbytes, NULL);
  if (coffsets == NULL) {
    BLOSC_TRACE_ERROR("Cannot get the chunk offsets.");
    return BLOSC2_ERROR_READ_BUFFER;
  }

  int64_t chunk_offset = coffsets[index * sizeof(int64_t)];
  int64_t chunk_cbytes = index == nchunks - 1 ? cbytes - chunk_offset : coffsets[(index + 1) * sizeof(int64_t)] - chunk_offset;

  if (frame->cframe != NULL) {
    *data = frame->cframe + chunk_offset;
    if (needs_free != NULL) {
      *needs_free = false;
    }
  } else {
    FILE* fp = NULL;
    if (frame->sframe) {
      fp = sframe_open_index(frame->urlpath, "rb");
    }
    else {
      fp = fopen(frame->urlpath, "rb");
    }
    if (fp == NULL) {
      BLOSC_TRACE_ERROR("Cannot open the file.");
      return BLOSC2_ERROR_FILE_OPEN;
    }
    *data = malloc((size_t)chunk_cbytes);
    fseek(fp, header_len + chunk_offset, SEEK_SET);
    size_t rbytes = fread(*data, 1, (size_t)chunk_cbytes, fp);
    fclose(fp);
    if (rbytes != (size_t)chunk_cbytes) {
      BLOSC_TRACE_ERROR("Cannot read the chunk from file.");
      free(*data);
      *data = NULL;
      return BLOSC2_ERROR_FILE_READ;
    }
    if (needs_free != NULL) {
      *needs_free = true;
    }
  }

  return 1;
}


int frame_get_chunk_cbytes(blosc2_frame_s* frame, int32_t index, int64_t* cbytes) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes_;
  int32_t chunksize;
  int32_t nchunks;
  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes_, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
    return ret;
  }

  if (index < 0 || index >= nchunks) {
    BLOSC_TRACE_ERROR("Invalid chunk index.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  uint8_t* coffsets = get_coffsets(frame, header_len, cbytes_, NULL);
  if (coffsets == NULL) {
    BLOSC_TRACE_ERROR("Cannot get the chunk offsets.");
    return BLOSC2_ERROR_READ_BUFFER;
  }

  *cbytes = index == nchunks - 1 ? cbytes_ - coffsets[index * sizeof(int64_t)] : coffsets[(index + 1) * sizeof(int64_t)] - coffsets[index * sizeof(int64_t)];

  return 1;
}


int frame_get_chunk_nbytes(blosc2_frame_s* frame, int32_t index, int64_t* nbytes) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes_;
  int64_t cbytes;
  int32_t chunksize;
  int32_t nchunks;
  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes_, &cbytes, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
    return ret;
  }

  if (index < 0 || index >= nchunks) {
    BLOSC_TRACE_ERROR("Invalid chunk index.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  uint8_t* coffsets = get_coffsets(frame, header_len, cbytes, NULL);
  if (coffsets == NULL) {
    BLOSC_TRACE_ERROR("Cannot get the chunk offsets.");
    return BLOSC2_ERROR_READ_BUFFER;
  }

  *nbytes = index == nchunks - 1 ? nbytes_ - coffsets[index * sizeof(int64_t)] : coffsets[(index + 1) * sizeof(int64_t)] - coffsets[index * sizeof(int64_t)];

  return 1;
}


int frame_get_chunk_cbytes_at(blosc2_frame_s* frame, int64_t offset, int64_t* cbytes) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes_;
  int32_t chunksize;
  int32_t nchunks;
  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes_, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get the header info from frame