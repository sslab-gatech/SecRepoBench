content_len < 0) {
      return BLOSC2_ERROR_DATA;
    }
    metalayer->content_len = content_len;

    // Finally, read the content
    trailer_pos += content_len;
    if (trailer_len < trailer_pos) {
      return BLOSC2_ERROR_READ_BUFFER;
    }
    char* content = malloc((size_t)content_len);
    memcpy(content, content_marker + 1 + 4, (size_t)content_len);
    metalayer->content = (uint8_t*)content;
  }

  return 1;
}

int frame_get_vlmetalayers(blosc2_frame_s* frame, blosc2_schunk* schunk) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int32_t chunksize;
  int32_t nchunks;
  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
    return ret;
  }

  // Get the trailer
  uint8_t* trailer = NULL;
  if (frame->cframe != NULL) {
    trailer = frame->cframe + frame_len - FRAME_TRAILER_MINLEN;
  } else {
    size_t rbytes = 0;
    trailer = malloc(FRAME_TRAILER_MINLEN);
    FILE* fp = NULL;
    if (frame->sframe) {
      fp = sframe_open_index(frame->urlpath, "rb");
    }
    else {
      fp = fopen(frame->urlpath, "rb");
    }
    if (fp != NULL) {
      rbytes = fread(trailer, 1, FRAME_TRAILER_MINLEN, fp);
      fclose(fp);
    }
    if (rbytes != (size_t) FRAME_TRAILER_MINLEN) {
      BLOSC_TRACE_ERROR("Cannot access the trailer out of the frame.");
      free(trailer);
      return BLOSC2_ERROR_FILE_READ;
    }
  }

  ret = get_vlmeta_from_trailer(frame, schunk, trailer, FRAME_TRAILER_MINLEN);

  if (frame->cframe == NULL) {
    free(trailer);
  }

  return ret;
}


int frame_get_filters(blosc2_frame_s* frame, blosc2_schunk* schunk) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int32_t chunksize;
  int32_t nchunks;
  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
    return ret;
  }

  // Get the header
  uint8_t* header = NULL;
  if (frame->cframe != NULL) {
    header = frame->cframe;
  } else {
    size_t rbytes = 0;
    header = malloc(header_len);
    FILE* fp = NULL;
    if (frame->sframe) {
      fp = sframe_open_index(frame->urlpath, "rb");
    }
    else {
      fp = fopen(frame->urlpath, "rb");
    }
    if (fp != NULL) {
      rbytes = fread(header, 1, header_len, fp);
      fclose(fp);
    }
    if (rbytes != (size_t) header_len) {
      BLOSC_TRACE_ERROR("Cannot access the header out of the frame.");
      free(header);
      return BLOSC2_ERROR_FILE_READ;
    }
  }

  uint8_t* filter_pipeline = header + FRAME_FILTER_PIPELINE + 1;
  uint8_t nfilters = header[FRAME_FILTER_PIPELINE];
  if (nfilters > BLOSC2_MAX_FILTERS) {
    BLOSC_TRACE_ERROR("The number of filters in frame header are too large for Blosc2.");
    if (frame->cframe == NULL) {
      free(header);
    }
    return BLOSC2_ERROR_INVALID_HEADER;
  }
  for (int i = 0; i < nfilters; i++) {
    schunk->filters[i] = filter_pipeline[i];
  }
  if (frame->cframe == NULL) {
    free(header);
  }
  return 1;
}


int frame_get_filter_meta(blosc2_frame_s* frame, blosc2_schunk* schunk) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int32_t chunksize;
  int32_t nchunks;
  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
    return ret;
  }

  // Get the header
  uint8_t* header = NULL;
  if (frame->cframe != NULL) {
    header = frame->cframe;
  } else {
    size_t rbytes = 0;
    header = malloc(header_len);
    FILE* fp = NULL;
    if (frame->sframe) {
      fp = sframe_open_index(frame->urlpath, "rb");
    }
    else {
      fp = fopen(frame->urlpath, "rb");
    }
    if (fp != NULL) {
      rbytes = fread(header, 1, header_len, fp);
      fclose(fp);
    }
    if (rbytes != (size_t) header_len) {
      BLOSC_TRACE_ERROR("Cannot access the header out of the frame.");
      free(header);
      return BLOSC2_ERROR_FILE_READ;
    }
  }

  uint8_t* filter_meta = header + FRAME_FILTER_PIPELINE + 1 + FRAME_FILTER_PIPELINE_MAX;
  uint8_t nfilters = header[FRAME_FILTER_PIPELINE];
  if (nfilters > BLOSC2_MAX_FILTERS) {
    BLOSC_TRACE_ERROR("The number of filters in frame header are too large for Blosc2.");
    if (frame->cframe == NULL) {
      free(header);
    }
    return BLOSC2_ERROR_INVALID_HEADER;
  }
  for (int i = 0; i < nfilters; i++) {
    schunk->filters_meta[i] = filter_meta[i];
  }
  if (frame->cframe == NULL) {
    free(header);
  }
  return 1;
}


int frame_get_data(blosc2_frame_s* frame, blosc2_schunk* schunk, int32_t chunk_index, uint8_t** data) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int32_t chunksize;
  int32_t nchunks;
  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
    return ret;
  }

  if (chunk_index < 0 || chunk_index >= nchunks) {
    BLOSC_TRACE_ERROR("Invalid chunk index.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  uint8_t* coffsets = get_coffsets(frame, header_len, cbytes, NULL);
  if (coffsets == NULL) {
    return BLOSC2_ERROR_READ_BUFFER;
  }

  int64_t chunk_offset = coffsets[chunk_index * sizeof(int64_t)];
  int64_t chunk_cbytes = chunksize;
  if (chunk_offset < 0 || chunk_offset + chunk_cbytes > cbytes) {
    BLOSC_TRACE_ERROR("Invalid chunk offset or size.");
    free(coffsets);
    return BLOSC2_ERROR_READ_BUFFER;
  }

  if (frame->cframe != NULL) {
    *data = frame->cframe + chunk_offset;
  } else {
    FILE* fp = NULL;
    if (frame->sframe) {
      fp = sframe_open_index(frame->urlpath, "rb");
    }
    else {
      fp = fopen(frame->urlpath, "rb");
    }
    if (fp == NULL) {
      BLOSC_TRACE_ERROR("Cannot open file for reading.");
      free(coffsets);
      return BLOSC2_ERROR_FILE_READ;
    }
    fseek(fp, header_len + chunk_offset, SEEK_SET);
    *data = malloc(chunk_cbytes);
    size_t rbytes = fread(*data, 1, chunk_cbytes, fp);
    fclose(fp);
    if (rbytes != chunk_cbytes) {
      BLOSC_TRACE_ERROR("Cannot read the chunk data from the frame.");
      free(*data);
      *data = NULL;
      free(coffsets);
      return BLOSC2_ERROR_FILE_READ;
    }
  }
  free(coffsets);
  return 1;
}


int frame_get_chunk(blosc2_frame_s* frame, int32_t chunk_index, uint8_t** data) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int32_t chunksize;
  int32_t nchunks;
  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
    return ret;
  }

  if (chunk_index < 0 || chunk_index >= nchunks) {
    BLOSC_TRACE_ERROR("Invalid chunk index.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  uint8_t* coffsets = get_coffsets(frame, header_len, cbytes, NULL);
  if (coffsets == NULL) {
    return BLOSC2_ERROR_READ_BUFFER;
  }

  int64_t chunk_offset = coffsets[chunk_index * sizeof(int64_t)];
  int64_t chunk_cbytes = chunksize;
  if (chunk_offset < 0 || chunk_offset + chunk_cbytes > cbytes) {
    BLOSC_TRACE_ERROR("Invalid chunk offset or size.");
    free(coffsets);
    return BLOSC2_ERROR_READ_BUFFER;
  }

  if (frame->cframe != NULL) {
    *data = frame->cframe + chunk_offset;
  } else {
    FILE* fp = NULL;
    if (frame->sframe) {
      fp = sframe_open_index(frame->urlpath, "rb");
    }
    else {
      fp = fopen(frame->urlpath, "rb");
    }
    if (fp == NULL) {
      BLOSC_TRACE