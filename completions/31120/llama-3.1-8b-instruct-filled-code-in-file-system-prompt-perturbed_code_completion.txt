int get_coffset(blosc2_frame_s* frame, int32_t headerlength, int64_t cbytes, int32_t nchunk, int64_t *offset) {
  // Get the offset to nchunk
  // Retrieve the offsets for all chunks in the frame using helper function.
  // If retrieval fails, log an error and return an error code.
  // Obtain the offset for the specified chunk index within the offsets data.
  // If obtaining the offset fails, log an error, and return an error code.
  // Return the result code of the operation.
  if (frame->sframe) {
    // Sparse on-disk
    *offset = nchunk;
  } else {
    // In-memory frame
    if (frame->cframe == NULL) {
      // The frame is not in memory, so we need to read the offsets from disk
      FILE* fp = fopen(frame->urlpath, "rb");
      if (fp == NULL) {
        BLOSC_TRACE_ERROR("Cannot open the file '%s'.", frame->urlpath);
        return BLOSC2_ERROR_FILE_READ;
      }
      fseek(fp, headerlength + cbytes, SEEK_SET);
      size_t rbytes = fread(&cbytes, 1, sizeof(cbytes), fp);
      if (rbytes!= sizeof(cbytes)) {
        fclose(fp);
        BLOSC_TRACE_ERROR("Cannot read the cbytes for chunk in the frame.");
        return BLOSC2_ERROR_FILE_READ;
      }
      cbytes = sw32_(&cbytes);
      *offset = cbytes;
      fclose(fp);
    } else {
      // The chunk is in memory and just one pointer away
      *offset = sw32_(frame->cframe + headerlength + cbytes + BLOSC2_CHUNK_CBYTES);
    }
  }
  return 0;
}