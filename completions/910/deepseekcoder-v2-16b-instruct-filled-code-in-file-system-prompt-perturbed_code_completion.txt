, (cmsTagSignature) Type);
        _cmsTagSignature2String(SigString,  sig);

        cmsSignalError(Icc ->ContextID, cmsERROR_UNKNOWN_EXTENSION, "No handler for type '%s' for tag '%s'", TypeString, SigString);
        goto Error;
    }

    // Save the type handler
    Icc ->TagTypeHandlers[i] = TypeHandler;

    // Write the type base
    LocalTypeHandler = *TypeHandler;
    LocalTypeHandler.ContextID  = Icc ->ContextID;
    LocalTypeHandler.ICCVersion = Icc ->Version;

    if (!LocalTypeHandler.WritePtr(&LocalTypeHandler, NULL, (void*) data, TagDescriptor ->ElemCount)) {

        _cmsTagSignature2String(TypeString, (cmsTagSignature) Type);
        _cmsTagSignature2String(SigString,  sig);

        cmsSignalError(Icc ->ContextID, cmsERROR_WRITE, "Couldn't write type '%s' for tag '%s'", TypeString, SigString);
        goto Error;
    }

    // Save the data
    Icc ->TagPtrs[i] = (void*) data;

    _cmsUnlockMutex(Icc->ContextID, Icc ->UsrMutex);
    return TRUE;

Error:
    _cmsUnlockMutex(Icc->ContextID, Icc ->UsrMutex);
    return FALSE;
}


// Write a single tag. This just keeps track of the tag into a list of "to be written". If the tag is already
// in that list, the previous version is deleted.
cmsBool CMSEXPORT cmsWriteTagMemory(cmsHPROFILE hProfile, cmsTagSignature sig, const void* data, cmsUInt32Number size)
{
    _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;
    cmsTagTypeHandler* TypeHandler = NULL;
    cmsTagTypeHandler LocalTypeHandler;
    cmsTagDescriptor* TagDescriptor = NULL;
    cmsTagTypeSignature Type;
    int i;
    cmsFloat64Number Version;
    char TypeString[5], SigString[5];

    if (!_cmsLockMutex(Icc->ContextID, Icc ->UsrMutex)) return FALSE;

    if (!_cmsNewTag(Icc, sig, &i)) goto Error;

    // This is raw
    Icc ->TagSaveAsRaw[i] = TRUE;

    // This is not a link
    Icc ->TagLinked[i] = (cmsTagSignature) 0;

    // Get information about the TAG.
    TagDescriptor = _cmsGetTagDescriptor(Icc-> ContextID, sig);
    if (TagDescriptor == NULL){
         cmsSignalError(Icc ->ContextID, cmsERROR_UNKNOWN_EXTENSION, "Unsupported tag '%x'", sig);
        goto Error;
    }

    // Now we need to know which type to use. It depends on the version.
    Version = cmsGetProfileVersion(hProfile);

    if (TagDescriptor ->DecideType != NULL) {

        // Let the tag descriptor to decide the type base on depending on
        // the data. This is useful for example on parametric curves, where
        // curves specified by a table cannot be saved as parametric and needs
        // to be casted to single v2-curves, even on v4 profiles.

        Type = TagDescriptor ->DecideType(Version, data);
    }
    else {

        Type = TagDescriptor ->SupportedTypes[0];
    }

    // Does the tag support this type?
    if (!IsTypeSupported(TagDescriptor, Type)) {

        _cmsTagSignature2String(TypeString, (cmsTagSignature) Type);
        _cmsTagSignature2String(SigString,  sig);

        cmsSignalError(Icc ->ContextID, cmsERROR_UNKNOWN_EXTENSION, "Unsupported type '%s' for tag '%s'", TypeString, SigString);
        goto Error;
    }

    // Does we have a handler for this type?
    TypeHandler =  _cmsGetTagTypeHandler(Icc->ContextID, Type);
    if (TypeHandler == NULL) {

        _cmsTagSignature2String(TypeString, (cmsTagSignature) Type);
        _cmsTagSignature2String(SigString,  sig);

        cmsSignalError(Icc ->ContextID, cmsERROR_UNKNOWN_EXTENSION, "No handler for type '%s' for tag '%s'", TypeString, SigString);
        goto Error;
    }

    // Save the type handler
    Icc ->TagTypeHandlers[i] = TypeHandler;

    // Write the type base
    LocalTypeHandler = *TypeHandler;
    LocalTypeHandler.ContextID  = Icc ->ContextID;
    LocalTypeHandler.ICCVersion = Icc ->Version;

    if (!LocalTypeHandler.WritePtr(&LocalTypeHandler, NULL, (void*) data, TagDescriptor ->ElemCount)) {

        _cmsTagSignature2String(TypeString, (cmsTagSignature) Type);
        _cmsTagSignature2String(SigString,  sig);

        cmsSignalError(Icc ->ContextID, cmsERROR_WRITE, "Couldn't write type '%s' for tag '%s'", TypeString, SigString);
        goto Error;
    }

    // Save the data
    Icc ->TagPtrs[i] = (void*) data;

    _cmsUnlockMutex(Icc->ContextID, Icc ->UsrMutex);
    return TRUE;

Error:
    _cmsUnlockMutex(Icc->ContextID, Icc ->UsrMutex);
    return FALSE;
}


// Link a tag to another. This is useful for ICC v2 profiles, where some tags are linked
// to other tags.
cmsBool CMSEXPORT cmsLinkTag(cmsHPROFILE hProfile, cmsTagSignature sig, cmsTagSignature linkedSig)
{
    _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;
    int i;

    if (!_cmsLockMutex(Icc->ContextID, Icc ->UsrMutex)) return FALSE;

    i = _cmsSearchTag(Icc, sig, FALSE);
    if (i < 0) goto Error;

    Icc ->TagLinked[i] = linkedSig;

    _cmsUnlockMutex(Icc->ContextID, Icc ->UsrMutex);
    return TRUE;

Error:
    _cmsUnlockMutex(Icc->ContextID, Icc ->UsrMutex);
    return FALSE;
}


// Unlink a tag. This is useful for ICC v2 profiles, where some tags are linked
// to other tags.
cmsBool CMSEXPORT cmsUnlinkTag(cmsHPROFILE hProfile, cmsTagSignature sig)
{
    _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;
    int i;

    if (!_cmsLockMutex(Icc->ContextID, Icc ->UsrMutex)) return FALSE;

    i = _cmsSearchTag(Icc, sig, FALSE);
    if (i < 0) goto Error;

    Icc ->TagLinked[i] = (cmsTagSignature) 0;

    _cmsUnlockMutex(Icc->ContextID, Icc ->UsrMutex);
    return TRUE;

Error:
    _cmsUnlockMutex(Icc->ContextID, Icc ->UsrMutex);
    return FALSE;
}


// -------------------------------------------------------------------------------------------------------------------


// Create a new profile
cmsHPROFILE CMSEXPORT cmsCreateProfileTHR(cmsContext ContextID, cmsProfileClassSignature DeviceClass,
    cmsColorSpaceSignature ColorSpace, cmsColorSpaceSignature PCS, cmsUInt32Number Version)
{
    _cmsICCPROFILE* NewIcc;
    time_t now = time(NULL);

    NewIcc = (_cmsICCPROFILE*) _cmsMallocZero(ContextID, sizeof(_cmsICCPROFILE));
    if (NewIcc == NULL) return NULL;

    NewIcc ->ContextID = ContextID;
    NewIcc ->DeviceClass = DeviceClass;
    NewIcc ->ColorSpace = ColorSpace;
    NewIcc ->PCS = PCS;
    NewIcc ->Version = Version;
    NewIcc ->flags = 0;
    NewIcc ->RenderingIntent = INTENT_PERCEPTUAL;
    NewIcc ->manufacturer = 0;
    NewIcc ->model = 0;
    NewIcc ->creator = 0;
    _cmsAdjustEndianess64(&NewIcc ->attributes, &_cmsAttributes_sRGB);

    // Set creation date/time
    memmove(&NewIcc ->Created, gmtime(&now), sizeof(NewIcc ->Created));

    // Create a mutex if the user provided proper plugin. NULL otherwise
    NewIcc ->UsrMutex = _cmsCreateMutex(ContextID);

    // Return the handle
    return (cmsHPROFILE) NewIcc;
}

cmsHPROFILE CMSEXPORT cmsCreateProfile(cmsContext ContextID, cmsProfileClassSignature DeviceClass,
    cmsColorSpaceSignature ColorSpace, cmsColorSpaceSignature PCS, cmsUInt32Number Version)
{
    return cmsCreateProfileTHR(ContextID, DeviceClass, ColorSpace, PCS, Version);
}


// Create a new profile from an existing one
cmsHPROFILE CMSEXPORT cmsCreateProfileFromIOhandlerTHR(cmsContext ContextID, cmsIOHANDLER* io)
{
    _cmsICCPROFILE* NewIcc;
    cmsHPROFILE hEmpty = cmsCreateProfilePlaceholder(ContextID);

    if (hEmpty == NULL) return NULL;

    NewIcc = (_cmsICCPROFILE*) hEmpty;

    NewIcc ->IOhandler = io;
    if (!_cmsReadHeader(NewIcc)) goto Error;
    return hEmpty;

Error:
    cmsCloseProfile(hEmpty);
    return NULL;
}

cmsHPROFILE CMSEXPORT cmsCreateProfileFromIOhandler2THR(cmsContext ContextID, cmsIOHANDLER* io, cmsBool write)
{
    _cmsICCPROFILE* NewIcc;
    cmsHPROFILE hEmpty = cmsCreateProfilePlaceholder(ContextID);

    if (hEmpty == NULL) return NULL;

    NewIcc = (_cmsICCPROFILE*) hEmpty;

    NewIcc ->IOhandler = io;
    if (write) {

        NewIcc -> IsWrite = TRUE;
        return hEmpty;
    }

    if (!_cmsReadHeader(NewIcc)) goto Error;
    return hEmpty;

Error:
    cmsCloseProfile(hEmpty);
    return NULL;
}


cmsHPROFILE CMSEXPORT cmsCreateProfileFromFileTHR(cmsContext ContextID, const char *lpFileName, const char *sAccess)
{
    _cmsICCPROFILE* NewIcc;
    cmsHPROFILE hEmpty = cmsCreateProfilePlaceholder(ContextID);

    if (hEmpty == NULL) return NULL;

    NewIcc = (_cmsICCPROFILE*) hEmpty;

    NewIcc ->IOhandler = cmsOpenIOhandlerFromFile(ContextID, lpFileName, sAccess);
    if (NewIcc ->IOhandler == NULL) goto Error;

    if (*sAccess == 'W' || *sAccess == 'w') {

        NewIcc -> IsWrite = TRUE;

        return hEmpty;
    }

    if (!_cmsReadHeader(NewIcc)) goto Error;
    return hEmpty;

Error:
    cmsCloseProfile(hEmpty);
    return NULL;
}

cmsHPROFILE CMSEXPORT cmsCreateProfileFromFile(const char *ICCProfile, const char *sAccess)
{
    return cmsCreateProfileFromFileTHR(NULL, ICCProfile, sAccess);
}


cmsHPROFILE  CMSEXPORT cmsCreateProfileFromStreamTHR(cmsContext ContextID, FILE* ICCProfile, const char *sAccess)
{
    _cmsICCPROFILE* NewIcc;
    cmsHPROFILE hEmpty = cmsCreateProfilePlaceholder(ContextID);

    if (hEmpty == NULL) return NULL;

    NewIcc = (_cmsICCPROFILE*) hEmpty;

    NewIcc ->IOhandler = cmsOpenIOhandlerFromStream(ContextID, ICCProfile);
    if (NewIcc ->IOhandler == NULL) goto Error;

    if (*sAccess == 'w') {

        NewIcc -> IsWrite = TRUE;
        return hEmpty;
    }

    if (!_cmsReadHeader(NewIcc)) goto Error;
    return hEmpty;

Error:
    cmsCloseProfile(hEmpty);
    return NULL;
}

cmsHPROFILE  CMSEXPORT cmsCreateProfileFromStream