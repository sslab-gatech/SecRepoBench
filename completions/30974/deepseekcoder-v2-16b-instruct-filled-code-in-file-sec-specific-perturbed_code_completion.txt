->content = (uint8_t*)content;
  }

  return 1;
}

int frame_get_vlmetalayers(blosc2_frame_s* frame, blosc2_schunk* schunk) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int32_t chunksize;
  int32_t nchunks;
  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
    return ret;
  }

  // Get the trailer
  uint8_t* trailer = NULL;
  if (frame->cframe != NULL) {
    trailer = frame->cframe + frame_len - FRAME_TRAILER_MINLEN;
  } else {
    size_t rbytes = 0;
    trailer = malloc(FRAME_TRAILER_MINLEN);
    FILE* fp = NULL;
    if (frame->sframe) {
      fp = sframe_open_index(frame->urlpath, "rb");
    }
    else {
      fp = fopen(frame->urlpath, "rb");
    }
    if (fp != NULL) {
      rbytes = fread(trailer, 1, FRAME_TRAILER_MINLEN, fp);
      fclose(fp);
    }
    if (rbytes != (size_t) FRAME_TRAILER_MINLEN) {
      BLOSC_TRACE_ERROR("Cannot access the trailer out of the frame.");
      free(trailer);
      return BLOSC2_ERROR_FILE_READ;
    }
  }

  ret = get_vlmeta_from_trailer(frame, schunk, trailer, FRAME_TRAILER_MINLEN);

  if (frame->cframe == NULL) {
    free(trailer);
  }

  return ret;
}


int frame_get_chunk(blosc2_frame_s* frame, int32_t index, uint8_t** data, bool* needs_free) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int32_t chunksize;
  int32_t nchunks;
  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
    return ret;
  }

  if (index < 0 || index >= nchunks) {
    BLOSC_TRACE_ERROR("Invalid chunk index.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  uint8_t* coffsets = get_coffsets(frame, header_len, cbytes, NULL);
  if (coffsets == NULL) {
    return BLOSC2_ERROR_READ_BUFFER;
  }

  int64_t chunk_offset = 0;
  for (int i = 0; i < index; i++) {
    chunk_offset += sw64_(coffsets + BLOSC2_CHUNK_CBYTES + i * sizeof(int64_t));
  }
  int64_t chunk_cbytes = sw64_(coffsets + BLOSC2_CHUNK_CBYTES + index * sizeof(int64_t)) - chunk_offset;

  if (frame->cframe != NULL) {
    *data = frame->cframe + header_len + chunk_offset;
    *needs_free = false;
  } else {
    FILE* fp = NULL;
    if (frame->sframe) {
      fp = sframe_open_index(frame->urlpath, "rb");
    }
    else {
      fp = fopen(frame->urlpath, "rb");
    }
    if (fp == NULL) {
      BLOSC_TRACE_ERROR("Cannot open the frame file.");
      return BLOSC2_ERROR_FILE_OPEN;
    }
    *data = malloc((size_t)chunk_cbytes);
    fseek(fp, header_len + chunk_offset, SEEK_SET);
    size_t rbytes = fread(*data, 1, (size_t)chunk_cbytes, fp);
    fclose(fp);
    if (rbytes != (size_t)chunk_cbytes) {
      BLOSC_TRACE_ERROR("Cannot read the chunk from the frame.");
      free(*data);
      *data = NULL;
      return BLOSC2_ERROR_FILE_READ;
    }
    *needs_free = true;
  }

  return 0;
}


int frame_put_chunk(blosc2_frame_s* frame, int32_t index, uint8_t* data, int32_t data_len, bool* needs_free) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int32_t chunksize;
  int32_t nchunks;
  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
    return ret;
  }

  if (index < 0 || index >= nchunks) {
    BLOSC_TRACE_ERROR("Invalid chunk index.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  uint8_t* coffsets = get_coffsets(frame, header_len, cbytes, NULL);
  if (coffsets == NULL) {
    return BLOSC2_ERROR_READ_BUFFER;
  }

  int64_t chunk_offset = 0;
  for (int i = 0; i < index; i++) {
    chunk_offset += sw64_(coffsets + BLOSC2_CHUNK_CBYTES + i * sizeof(int64_t));
  }
  int64_t chunk_cbytes = sw64_(coffsets + BLOSC2_CHUNK_CBYTES + index * sizeof(int64_t)) - chunk_offset;

  if (frame->cframe != NULL) {
    memcpy(frame->cframe + header_len + chunk_offset, data, (size_t)data_len);
    *needs_free = false;
  } else {
    FILE* fp = NULL;
    if (frame->sframe) {
      fp = sframe_open_index(frame->urlpath, "rb+");
    }
    else {
      fp = fopen(frame->urlpath, "rb+");
    }
    if (fp == NULL) {
      BLOSC_TRACE_ERROR("Cannot open the frame file.");
      return BLOSC2_ERROR_FILE_OPEN;
    }
    fseek(fp, header_len + chunk_offset, SEEK_SET);
    size_t wbytes = fwrite(data, 1, (size_t)data_len, fp);
    fclose(fp);
    if (wbytes != (size_t)data_len) {
      BLOSC_TRACE_ERROR("Cannot write the chunk to the frame.");
      return BLOSC2_ERROR_FILE_WRITE;
    }
    *needs_free = false;
  }

  return 0;
}


int frame_delete_chunk(blosc2_frame_s* frame, int32_t index) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int32_t chunksize;
  int32_t nchunks;
  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
    return ret;
  }

  if (index < 0 || index >= nchunks) {
    BLOSC_TRACE_ERROR("Invalid chunk index.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  uint8_t* coffsets = get_coffsets(frame, header_len, cbytes, NULL);
  if (coffsets == NULL) {
    return BLOSC2_ERROR_READ_BUFFER;
  }

  int64_t chunk_offset = 0;
  for (int i = 0; i < index; i++) {
    chunk_offset += sw64_(coffsets + BLOSC2_CHUNK_CBYTES + i * sizeof(int64_t));
  }
  int64_t chunk_cbytes = sw64_(coffsets + BLOSC2_CHUNK_CBYTES + index * sizeof(int64_t)) - chunk_offset;

  if (frame->cframe != NULL) {
    memmove(frame->cframe + header_len + chunk_offset, frame->cframe + header_len + chunk_offset + chunk_cbytes,
            (size_t)(frame->len - header_len - chunk_offset - chunk_cbytes));
  } else {
    FILE* fp = NULL;
    if (frame->sframe) {
      fp = sframe_open_index(frame->urlpath, "rb+");
    }
    else {
      fp = fopen(frame->urlpath, "rb+");
    }
    if (fp == NULL) {
      BLOSC_TRACE_ERROR("Cannot open the frame file.");
      return BLOSC2_ERROR_FILE_OPEN;
    }
    fseek(fp, header_len + chunk_offset + chunk_cbytes, SEEK_SET);
    int64_t remaining_len = frame->len - header_len - chunk_offset - chunk_cbytes;
    while (remaining_len > 0) {
      size_t wbytes = fwrite("", 1, (size_t)remaining_len, fp);
      if (wbytes != remaining_len) {
        BLOSC_TRACE_ERROR("Cannot delete the chunk from the frame.");
        fclose(fp);
        return BLOSC2_ERROR_FILE_WRITE;
      }
      remaining_len = 0;
    }
    fclose(fp);
  }

  // Update the offsets
  for (int i = index; i < nchunks - 1; i++) {
    int64_t offset = sw64_(coffsets + BLOSC2_CHUNK_CBYTES + i * sizeof(int64_t));
    big_store(coffsets + BLOSC2_CHUNK_CBYTES + i * sizeof(int64_t), &offset, sizeof(int64_t));
  }

  // Update the frame length
  int64_t new_frame_len = frame->len - chunk_cbytes;
  if (frame->cframe == NULL) {
    FILE* fp = NULL;
    if (frame->sframe) {
      fp = sframe_open_index(frame->urlpath, "rb+");
    }
    else {
      fp = fopen(frame->urlpath, "rb+");
    }
    if (fp == NULL) {
      BLOSC_TRACE_ERROR("Cannot open the frame file.");
      return BLOSC2_ERROR_FILE_OPEN;
    }
    ftruncate(fileno(fp), new_frame_len);
    fclose(fp);
  }
  else {
    frame->cframe = realloc(frame->cframe, new_frame_len);
  }
  frame->len = new_frame_len;

  // Update the trailer
  ret = frame_update_trailer(frame, NULL);
  if (ret < 0) {
    return ret;
  }

  return 0;
}


int frame_append_chunk(blosc2_frame_s* frame