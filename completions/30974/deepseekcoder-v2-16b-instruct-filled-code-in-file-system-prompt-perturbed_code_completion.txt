2_schunk* schunk) {
  int64_t trailer_offset = get_trailer_offset(frame, 0, true);
  if (trailer_offset < BLOSC_EXTENDED_HEADER_LENGTH || trailer_offset + FRAME_TRAILER_MINLEN > frame->len) {
    BLOSC_TRACE_ERROR("Cannot read the trailer out of the frame.");
    return BLOSC2_ERROR_READ_BUFFER;
  }

  uint8_t* trailer = frame->cframe + trailer_offset;
  int32_t trailer_len = frame->trailer_len;

  return get_vlmeta_from_trailer(frame, schunk, trailer, trailer_len);
}


int frame_get_chunk(blosc2_frame_s* frame, int32_t index, uint8_t** data, bool* needs_free) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int32_t chunksize;
  int32_t nchunks;
  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
    return ret;
  }

  if (index < 0 || index >= nchunks) {
    BLOSC_TRACE_ERROR("Invalid chunk index.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  uint8_t* data_chunk = NULL;
  if (frame->cframe != NULL) {
    int64_t chunk_offset = header_len + (int64_t)index * chunksize;
    if (chunk_offset + chunksize > frame->len) {
      BLOSC_TRACE_ERROR("Chunk offset exceeds frame length.");
      return BLOSC2_ERROR_READ_BUFFER;
    }
    data_chunk = frame->cframe + chunk_offset;
    *needs_free = false;
  } else {
    FILE* fp = NULL;
    if (frame->sframe) {
      fp = sframe_open_index(frame->urlpath, "rb");
    } else {
      fp = fopen(frame->urlpath, "rb");
    }
    if (fp == NULL) {
      BLOSC_TRACE_ERROR("Cannot open frame file.");
      return BLOSC2_ERROR_FILE_OPEN;
    }

    int64_t chunk_offset = header_len + (int64_t)index * chunksize;
    if (fseek(fp, chunk_offset, SEEK_SET) != 0) {
      BLOSC_TRACE_ERROR("Cannot seek to chunk offset.");
      fclose(fp);
      return BLOSC2_ERROR_FILE_SEEK;
    }

    data_chunk = malloc(chunksize);
    size_t bytes_read = fread(data_chunk, 1, chunksize, fp);
    if (bytes_read != chunksize) {
      BLOSC_TRACE_ERROR("Cannot read chunk data.");
      free(data_chunk);
      data_chunk = NULL;
    }
    fclose(fp);
    *needs_free = true;
  }

  *data = data_chunk;
  return 0;
}


int frame_put_chunk(blosc2_frame_s* frame, int32_t index, uint8_t* data, int32_t data_len, bool* needs_free) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int32_t chunksize;
  int32_t nchunks;
  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
    return ret;
  }

  if (index < 0 || index >= nchunks) {
    BLOSC_TRACE_ERROR("Invalid chunk index.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  if (data_len != chunksize) {
    BLOSC_TRACE_ERROR("Data length does not match chunk size.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  if (frame->cframe != NULL) {
    int64_t chunk_offset = header_len + (int64_t)index * chunksize;
    if (chunk_offset + chunksize > frame->len) {
      BLOSC_TRACE_ERROR("Chunk offset exceeds frame length.");
      return BLOSC2_ERROR_WRITE_BUFFER;
    }
    memcpy(frame->cframe + chunk_offset, data, chunksize);
  } else {
    FILE* fp = NULL;
    if (frame->sframe) {
      fp = sframe_open_index(frame->urlpath, "rb+");
    } else {
      fp = fopen(frame->urlpath, "rb+");
    }
    if (fp == NULL) {
      BLOSC_TRACE_ERROR("Cannot open frame file.");
      return BLOSC2_ERROR_FILE_OPEN;
    }

    int64_t chunk_offset = header_len + (int64_t)index * chunksize;
    if (fseek(fp, chunk_offset, SEEK_SET) != 0) {
      BLOSC_TRACE_ERROR("Cannot seek to chunk offset.");
      fclose(fp);
      return BLOSC2_ERROR_FILE_SEEK;
    }

    size_t bytes_written = fwrite(data, 1, data_len, fp);
    if (bytes_written != data_len) {
      BLOSC_TRACE_ERROR("Cannot write chunk data.");
      fclose(fp);
      return BLOSC2_ERROR_FILE_WRITE;
    }
    fclose(fp);
  }

  *needs_free = false;
  return 0;
}


int frame_delete_chunk(blosc2_frame_s* frame, int32_t index) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int32_t chunksize;
  int32_t nchunks;
  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
    return ret;
  }

  if (index < 0 || index >= nchunks) {
    BLOSC_TRACE_ERROR("Invalid chunk index.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  if (frame->cframe != NULL) {
    // Shift chunks to the left
    int64_t chunk_offset = header_len + (int64_t)index * chunksize;
    memmove(frame->cframe + chunk_offset, frame->cframe + chunk_offset + chunksize,
            (nchunks - index - 1) * chunksize);
  } else {
    FILE* fp = NULL;
    if (frame->sframe) {
      fp = sframe_open_index(frame->urlpath, "rb+");
    } else {
      fp = fopen(frame->urlpath, "rb+");
    }
    if (fp == NULL) {
      BLOSC_TRACE_ERROR("Cannot open frame file.");
      return BLOSC2_ERROR_FILE_OPEN;
    }

    int64_t chunk_offset = header_len + (int64_t)index * chunksize;
    if (fseek(fp, chunk_offset, SEEK_SET) != 0) {
      BLOSC_TRACE_ERROR("Cannot seek to chunk offset.");
      fclose(fp);
      return BLOSC2_ERROR_FILE_SEEK;
    }

    // Shift chunks to the left
    uint8_t* buffer = malloc(chunksize);
    while (fread(buffer, 1, chunksize, fp) == chunksize) {
      fseek(fp, -chunksize, SEEK_CUR);
      fwrite(buffer, 1, chunksize, fp);
    }
    free(buffer);

    // Truncate the file to remove the last chunk
    if (TRUNCATE(fileno(fp), chunk_offset) != 0) {
      BLOSC_TRACE_ERROR("Cannot truncate the frame.");
      fclose(fp);
      return BLOSC2_ERROR_FILE_TRUNCATE;
    }
    fclose(fp);
  }

  // Update the frame length and trailer
  ret = update_frame_len(frame, frame_len - chunksize);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Cannot update frame length.");
    return ret;
  }
  ret = frame_update_trailer(frame, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Cannot update frame trailer.");
    return ret;
  }

  return 0;
}


int frame_append_chunk(blosc2_frame_s* frame, uint8_t* data, int32_t data_len, bool* needs_free) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int32_t chunksize;
  int32_t nchunks;
  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
  if (ret < 0) {
    BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
    return ret;
  }

  if (data_len != chunksize) {
    BLOSC_TRACE_ERROR("Data length does not match chunk size.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  if (frame->cframe != NULL) {
    frame->cframe = realloc(frame->cframe, frame_len + chunksize);
    memcpy(frame->cframe + frame_len, data, chunksize);
  } else {
    FILE* fp = NULL;
    if (frame->sframe) {
      fp = sframe_open_index(frame->urlpath, "rb+");
    } else {
      fp = fopen(frame->urlpath, "rb+");
    }
    if (fp == NULL) {
      BLOSC_TRACE_ERROR("Cannot open frame file.");
      return BLOSC2_ERROR_FILE_OPEN;
    }

    if (fseek(fp, frame_len, SEEK_SET) != 0) {
      BLOSC_TRACE_ERROR("Cannot seek to end of frame.");
      fclose(fp);
      return BLOSC2_ERROR_FILE_SEEK;
    }

    size_t bytes_written = fwrite(data, 1, data_len, fp);
    if (bytes_written != data_len) {
      BLOSC_TRACE_ERROR("Cannot write chunk data.");
      fclose(fp);
      return BLOSC2_ERROR_FILE_WRITE;
    }
    fclose(fp);
  }

  *needs_free = false;
  return 0;
}


int frame_get_chunk_data(blosc2_frame_s* frame, int32_t index, uint8_t** data, int32_t* data_len, bool* needs_free) {
  int32_t header_len;
  int64_t frame_len;
  int64_t nbytes;
  int64_t cbytes;
  int32_t chunksize;
  int32_t nchunks;
  int ret = get_header_info(frame, &header_len, &frame_len, &