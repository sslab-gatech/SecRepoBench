case 0x07: /* Open Connection Request 2 */
  if (packet->payload_packet_len < 34) {
    NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
    return;
  }
  
  {
    u_int16_t mtu_size = ntohs(get_u_int16_t(packet->payload, 26));
    if (mtu_size > 1500 /* Max. supported MTU */) {
      NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
      return;
    }
  }
  
  required_packets = 6;
  break;

case 0x08: /* Open Connection Reply 2 */
  if (packet->payload_packet_len < 30) {
    NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
    return;
  }
  
  {
    ip_addr_offset = 25; /* Start after op + magic + GUID */
    int ip_length = raknet_dissect_ip(packet, ip_addr_offset);
    
    /* Validate IP dissection */
    if (ip_length <= 0 || (ip_addr_offset + ip_length + 2) >= packet->payload_packet_len) {
      NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
      return;
    }
    
    ip_addr_offset += ip_length + 2; /* Skip IP and port */
    
    /* Check if we can safely read MTU */
    if (ip_addr_offset + 2 > packet->payload_packet_len) {
      NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
      return;
    }
    
    u_int16_t mtu_size = ntohs(get_u_int16_t(packet->payload, ip_addr_offset));
    if (mtu_size > 1500 /* Max. supported MTU */) {
      NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
      return;
    }
    
    ip_addr_offset += 2; /* Skip MTU */
    
    /* Validate we have exactly one more byte (for security flag) */
    if (ip_addr_offset + 1 != packet->payload_packet_len) {
      NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
      return;
    }
  }
  
  required_packets = 4;
  break;