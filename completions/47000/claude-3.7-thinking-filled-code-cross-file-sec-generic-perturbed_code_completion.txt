case 0x07: /* Open Connection Request 2 */
  {
    if (packet->payload_packet_len < 30) {
      NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
      return;
    }
    
    // Skip offline message data ID (16 bytes)
    ip_addr_offset = 16;
    // Process client IP address
    ip_addr_offset += raknet_dissect_ip(packet, ip_addr_offset);
    
    // Check MTU size (2 bytes)
    if (ip_addr_offset + 2 > packet->payload_packet_len) {
      NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
      return;
    }
    
    u_int16_t mtu_size = ntohs(get_u_int16_t(packet->payload, ip_addr_offset));
    ip_addr_offset += 2;
    
    if (mtu_size > 1500 /* Max. supported MTU */) {
      NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
      return;
    }
    
    // Skip client GUID (8 bytes)
    if (ip_addr_offset + 8 != packet->payload_packet_len) {
      NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
      return;
    }
  }
  required_packets = 6;
  break;

case 0x08: /* Open Connection Reply 2 */
  {
    if (packet->payload_packet_len < 30) {
      NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
      return;
    }
    
    // Skip offline message data ID (16 bytes) and server GUID (8 bytes)
    ip_addr_offset = 24;
    // Process client IP address
    ip_addr_offset += raknet_dissect_ip(packet, ip_addr_offset);
    
    // Check MTU size (2 bytes)
    if (ip_addr_offset + 2 > packet->payload_packet_len) {
      NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
      return;
    }
    
    u_int16_t mtu_size = ntohs(get_u_int16_t(packet->payload, ip_addr_offset));
    ip_addr_offset += 2;
    
    if (mtu_size > 1500 /* Max. supported MTU */) {
      NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
      return;
    }
    
    // Check encryption flag
    if (ip_addr_offset >= packet->payload_packet_len || 
        packet->payload[ip_addr_offset] > 0x01 /* connection uses encryption: bool -> 0x00 or 0x01 */) {
      NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
      return;
    }
  }
  required_packets = 4;
  break;