case 0x07: /* Open Connection Request 2 */
    {
      if (packet->payload_packet_len < 34) {
        NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
        return;
      }
      /* Skip the packet ID (1 byte) + RakNet Magic (16 bytes) */
      ip_addr_offset = 1 + 16;
      /* Extract the target address */
      ip_addr_offset += raknet_dissect_ip(packet, ip_addr_offset);
      /* Skip the target port (2 bytes) */
      ip_addr_offset += 2;
      /* Check remaining space for MTU + protocol version */
      if (ip_addr_offset + 3 > packet->payload_packet_len) {
        NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
        return;
      }
      {
        u_int16_t max_mtu_size = ntohs(get_u_int16_t(packet->payload, ip_addr_offset));
        ip_addr_offset += 2;
        if (max_mtu_size > 1500) {
          NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
          return;
        }
      }
      /* Check protocol version */
      if (packet->payload[ip_addr_offset] > 10) {
        NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
        return;
      }
      ip_addr_offset += 1;
      /* Ensure we've consumed the entire payload */
      if (ip_addr_offset != packet->payload_packet_len) {
        NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
        return;
      }
      required_packets = 6;
      break;
    }

    case 0x08: /* Open Connection Reply 2 */
    {
      /* This packet is typically larger than the "Open Connection Reply 1" */
      if (packet->payload_packet_len < 36) {
        NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
        return;
      }
      /* Skip the packet ID (1 byte) + RakNet Magic (16 bytes) */
      ip_addr_offset = 1 + 16;
      /* Extract the target address */
      ip_addr_offset += raknet_dissect_ip(packet, ip_addr_offset);
      /* Skip the target port (2 bytes) */
      ip_addr_offset += 2;
      /* Check space for encryption flag + MTU + protocol version */
      if (ip_addr_offset + 4 > packet->payload_packet_len) {
        NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
        return;
      }
      /* Encryption flag: must be 0x00 or 0x01 */
      if (packet->payload[ip_addr_offset] > 0x01) {
        NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
        return;
      }
      ip_addr_offset += 1;
      {
        u_int16_t max_mtu_size = ntohs(get_u_int16_t(packet->payload, ip_addr_offset));
        ip_addr_offset += 2;
        if (max_mtu_size > 1500) {
          NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
          return;
        }
      }
      /* Protocol version */
      if (packet->payload[ip_addr_offset] > 10) {
        NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
        return;
      }
      ip_addr_offset += 1;
      /* Ensure we've consumed the entire payload */
      if (ip_addr_offset != packet->payload_packet_len) {
        NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
        return;
      }
      required_packets = 4;
      break;
    }