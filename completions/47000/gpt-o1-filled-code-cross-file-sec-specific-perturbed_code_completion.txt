case 0x07: /* Open Connection Request 2 */
    {
      /* Basic length check to ensure we can safely access needed fields */
      if (packet->payload_packet_len < 34) {
        NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
        return;
      }

      /* Skip:
       * - 1 byte (op code)
       * - 8 bytes (client GUID)
       * - 16 bytes (security data)
       */
      ip_addr_offset = 25;

      /* Extract and validate IP address */
      if (ip_addr_offset >= packet->payload_packet_len) {
        NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
        return;
      }
      ip_addr_offset += raknet_dissect_ip(packet, ip_addr_offset);

      /* Check for port + MTU size fields (4 bytes total). */
      if (ip_addr_offset + 4 > packet->payload_packet_len) {
        NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
        return;
      }
      ip_addr_offset += 2; /* skip port */

      {
        u_int16_t max_mtu_size = ntohs(get_u_int16_t(packet->payload, ip_addr_offset));
        if (max_mtu_size > 1500) {
          NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
          return;
        }
        ip_addr_offset += 2;
      }

      /* Verify no extra data is present. */
      if (ip_addr_offset != packet->payload_packet_len) {
        NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
        return;
      }

      required_packets = 4;
      break;
    }

    case 0x08: /* Open Connection Reply 2 */
    {
      if (packet->payload_packet_len < 30) {
        NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
        return;
      }

      /* Check if encryption flag is valid at offset 25 */
      if (packet->payload[25] > 0x01) {
        NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
        return;
      }

      /* Verify MTU size at offset 26 */
      {
        u_int16_t max_mtu_size = ntohs(get_u_int16_t(packet->payload, 26));
        if (max_mtu_size > 1500) {
          NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
          return;
        }
      }

      ip_addr_offset = 28;
      if (ip_addr_offset >= packet->payload_packet_len) {
        NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
        return;
      }

      /* Extract and validate IP address */
      ip_addr_offset += raknet_dissect_ip(packet, ip_addr_offset);

      /* Next 2 bytes should contain the port */
      if (ip_addr_offset + 2 > packet->payload_packet_len) {
        NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
        return;
      }
      ip_addr_offset += 2;

      /* Verify that we've reached the end of the packet data */
      if (ip_addr_offset != packet->payload_packet_len) {
        NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
        return;
      }

      required_packets = 4;
      break;
    }