Below is the content of a C/C++ file where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
static const char *ctxload_probe_data(const u8 *probe_data, u32 size, GF_FilterProbeScore *score)
{
	const char *mime_type = NULL;
	char *dst = NULL;
	GF_Err e;
	u32 probe_size=size;
	char *res=NULL;

	/* check gzip magic header */
	if ((size>2) && (probe_data[0] == 0x1f) && (probe_data[1] == 0x8b)) {
		*score = GF_FPROBE_EXT_MATCH;
		return "btz|bt.gz|xmt.gz|xmtz|wrl.gz|x3dv.gz|x3dvz|x3d.gz|x3dz";
	}

	e = gf_utf_get_string_from_bom(probe_data, size, &dst, &res, &probe_size);
	if (e) return NULL;
	probe_data = res;

	//strip all spaces and \r\n
	// Strip leading whitespace and newline characters from the probe_data buffer.
	// This loop iterates over the probe_data, advancing the pointer past any
	// whitespace characters such as spaces, tabs, carriage returns, and newlines.
	// <MASK>

	//for XML, strip doctype, <?xml and comments
	while (1) {
		char *search=NULL;
		if (!strncmp(probe_data, "<!DOCTYPE", 9)) {
			search = ">";
		}
		//for XML, strip xml header
		else if (!strncmp(probe_data, "<?xml", 5)) {
			search = "?>";
		}
		else if (!strncmp(probe_data, "<!--", 4)) {
			search = "-->";
		} else {
			break;
		}
		const char *res = my_strstr(probe_data, search, probe_size);
		if (!res) goto exit;
		res += strlen(search);
		probe_size -= (u32) (res - (char*)probe_data);
		probe_data = res;
		while (probe_size && probe_data[0] && strchr("\n\r\t ", (char) probe_data[0])) {
			probe_data ++;
			probe_size--;
		}
	}
	//probe_data is now the first element of the document, if XML
	//we should refine by getting the xmlns attribute value rather than searching for its value...

	if (my_strstr(probe_data, "http://www.w3.org/1999/XSL/Transform", probe_size)
	) {
	} else if (!strncmp(probe_data, "<XMT-A", strlen("<XMT-A"))
		|| my_strstr(probe_data, "urn:mpeg:mpeg4:xmta:schema:2002", probe_size)
	) {
		mime_type = "application/x-xmt";
	} else if (my_strstr(probe_data, "<X3D", probe_size)
		|| my_strstr(probe_data, "http://www.web3d.org/specifications/x3d-3.0.xsd", probe_size)
	) {
		mime_type = "model/x3d+xml";
	} else if (my_strstr(probe_data, "<saf", probe_size)
		|| my_strstr(probe_data, "urn:mpeg:mpeg4:SAF:2005", probe_size)
		|| my_strstr(probe_data, "urn:mpeg:mpeg4:LASeR:2005", probe_size)
	) {
		mime_type = "application/x-LASeR+xml";
	} else if (!strncmp(probe_data, "<DIMSStream", strlen("<DIMSStream") ) ) {
		mime_type = "application/dims";
	} else if (!strncmp(probe_data, "<svg", 4) || my_strstr(probe_data, "http://www.w3.org/2000/svg", probe_size) ) {
		mime_type = "image/svg+xml";
	} else if (!strncmp(probe_data, "<widget", strlen("<widget") ) ) {
		mime_type = "application/widget";
	} else if (!strncmp(probe_data, "<NHNTStream", strlen("<NHNTStream") ) ) {
		mime_type = "application/x-nhml";
	} else if (!strncmp(probe_data, "<TextStream", strlen("<TextStream") ) ) {
		mime_type = "text/ttxt";
	} else if (!strncmp(probe_data, "<text3GTrack", strlen("<text3GTrack") ) ) {
		mime_type = "quicktime/text";
	}
	//BT/VRML with no doc header
	else {
		//get first keyword
		while (1) {
			//strip all spaces and \r\n
			while (probe_size && probe_data[0] && strchr("\n\r\t ", (char) probe_data[0])) {
				probe_data ++;
				probe_size--;
			}
			if (!probe_size) goto exit;

			//VRML / XRDV files
			if (!strncmp(probe_data, "#VRML V2.0", strlen("#VRML V2.0"))) {
				mime_type = "model/vrml";
				goto exit;
			}
			if (!strncmp(probe_data, "#X3D V3.0", strlen("#X3D V3.0"))) {
				mime_type = "model/x3d+vrml";
				goto exit;
			}

			//skip comment lines and some specific X3D keyword (we want to fetch a group
			if ((probe_data[0] != '#')
				&& strncmp(probe_data, "PROFILE", strlen("PROFILE"))
				&& strncmp(probe_data, "COMPONENT", strlen("COMPONENT"))
				&& strncmp(probe_data, "META", strlen("META"))
				&& strncmp(probe_data, "IMPORT", strlen("IMPORT"))
				&& strncmp(probe_data, "EXPORT", strlen("EXPORT"))
			) {
				break;
			}
			//skip line and go one
			const char *next = my_strstr(probe_data, "\n", probe_size);
			if (!next) goto exit;
			probe_size -= (u32) (next - (char*)probe_data);
			probe_data = next;
		}
		
		if (!strncmp(probe_data, "InitialObjectDescriptor", strlen("InitialObjectDescriptor"))
			|| !strncmp(probe_data, "EXTERNPROTO", strlen("EXTERNPROTO"))
			|| !strncmp(probe_data, "PROTO", strlen("PROTO"))
			|| !strncmp(probe_data, "Group", strlen("Group"))
			|| !strncmp(probe_data, "OrderedGroup", strlen("OrderedGroup"))
			|| !strncmp(probe_data, "Layer2D", strlen("Layer2D"))
			|| !strncmp(probe_data, "Layer3D", strlen("Layer3D"))
		) {
			if (my_strstr(probe_data, "children", probe_size))
				mime_type = "application/x-bt";
		}
	}

exit:

	if (dst) gf_free(dst);
	if (mime_type) {
		*score = GF_FPROBE_MAYBE_SUPPORTED;
		return mime_type;
	}

	*score = GF_FPROBE_NOT_SUPPORTED;
	return NULL;
}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/filter_core/filter.c
// GF_EXPORT
// const char *gf_filter_probe_data(GF_Filter *filter, u8 *data, u32 size, GF_FilterProbeScore *pscore)
// {
// 	u32 i, count;
// 	GF_FilterProbeScore score, max_score = GF_FPROBE_NOT_SUPPORTED;
// 	const char *probe_mime = NULL;
// 	if (pscore) *pscore = GF_FPROBE_NOT_SUPPORTED;
// 	if (!size) return NULL;
// 	gf_mx_p(filter->session->filters_mx);
// 	count = gf_list_count(filter->session->registry);
// 	for (i=0; i<count; i++) {
// 		const char *a_mime;
// 		const GF_FilterRegister *freg = gf_list_get(filter->session->registry, i);
// 		if (!freg || !freg->probe_data) continue;
// 		score = GF_FPROBE_NOT_SUPPORTED;
// 		a_mime = freg->probe_data(data, size, &score);
// 		if (score==GF_FPROBE_NOT_SUPPORTED) {
// 		} else if (score==GF_FPROBE_EXT_MATCH) {
// //			probe_mime = NULL;
// 		} else {
// 			if (a_mime && (score > max_score)) {
// 				probe_mime = a_mime;
// 				max_score = score;
// 			}
// 		}
// 	}
// 	gf_mx_v(filter->session->filters_mx);
// 	if (pscore) *pscore = max_score;
// 	return probe_mime;
// }

// the below code fragment can be found in:
// src/filter_core/filter.c
// static Bool gf_filter_get_arg_internal(GF_Filter *filter, const char *arg_name, GF_PropertyValue *prop, const char **min_max_enum)
// {
// 	u32 i=0;
// 	if (!filter || !arg_name) return GF_FALSE;
// 
// 	while (1) {
// 		GF_PropertyValue p;
// 		const GF_FilterArgs *arg = &filter->freg->args[i];
// 		if (!arg || !arg->arg_name) break;
// 		i++;
// 
// 		if (strcmp(arg->arg_name, arg_name)) continue;
// 		if (arg->offset_in_private < 0) continue;
// 
// 		p.type = arg->arg_type;
// 		switch (arg->arg_type) {
// 		case GF_PROP_BOOL:
// 			p.value.boolean = * (Bool *) ((char *)filter->filter_udta + arg->offset_in_private);
// 			break;
// 		case GF_PROP_UINT:
// 		case GF_PROP_4CC:
// 			p.value.uint = * (u32 *) ((char *)filter->filter_udta + arg->offset_in_private);
// 			break;
// 		case GF_PROP_SINT:
// 			p.value.sint = * (s32 *) ((char *)filter->filter_udta + arg->offset_in_private);
// 			break;
// 		case GF_PROP_LUINT:
// 			p.value.longuint = * (u64 *) ((char *)filter->filter_udta + arg->offset_in_private);
// 			break;
// 		case GF_PROP_LSINT:
// 			p.value.longsint = * (s64 *) ((char *)filter->filter_udta + arg->offset_in_private);
// 			break;
// 		case GF_PROP_FLOAT:
// 			p.value.fnumber = * (Fixed *) ((char *)filter->filter_udta + arg->offset_in_private);
// 			break;
// 		case GF_PROP_DOUBLE:
// 			p.value.number = * (Double *) ((char *)filter->filter_udta + arg->offset_in_private);
// 			break;
// 		case GF_PROP_VEC2I:
// 			p.value.vec2i = * (GF_PropVec2i *) ((char *)filter->filter_udta + arg->offset_in_private);
// 			break;
// 		case GF_PROP_VEC2:
// 			p.value.vec2 = * (GF_PropVec2 *) ((char *)filter->filter_udta + arg->offset_in_private);
// 			break;
// 		case GF_PROP_VEC3I:
// 			p.value.vec3i = * (GF_PropVec3i *) ((char *)filter->filter_udta + arg->offset_in_private);
// 			break;
// 		case GF_PROP_VEC4I:
// 			p.value.vec4i = * (GF_PropVec4i *) ((char *)filter->filter_udta + arg->offset_in_private);
// 			break;
// 		case GF_PROP_FRACTION:
// 			p.value.frac = * (GF_Fraction *) ((char *)filter->filter_udta + arg->offset_in_private);
// 			break;
// 		case GF_PROP_FRACTION64:
// 			p.value.lfrac = * (GF_Fraction64 *) ((char *)filter->filter_udta + arg->offset_in_private);
// 			break;
// 		case GF_PROP_DATA:
// 		case GF_PROP_DATA_NO_COPY:
// 		case GF_PROP_CONST_DATA:
// 			p.value.data = * (GF_PropData *) ((char *)filter->filter_udta + arg->offset_in_private);
// 			break;
// 		case GF_PROP_POINTER:
// 			p.value.ptr = * (void **) ((char *)filter->filter_udta + arg->offset_in_private);
// 			break;
// 		case GF_PROP_STRING_NO_COPY:
// 		case GF_PROP_STRING:
// 		case GF_PROP_NAME:
// 			p.value.ptr = * (char **) ((char *)filter->filter_udta + arg->offset_in_private);
// 			break;
// 		//use uint_list as base type for lists
// 		case GF_PROP_STRING_LIST:
// 		case GF_PROP_UINT_LIST:
// 		case GF_PROP_4CC_LIST:
// 		case GF_PROP_SINT_LIST:
// 		case GF_PROP_VEC2I_LIST:
// 			p.value.uint_list = * (GF_PropUIntList *) ((char *)filter->filter_udta + arg->offset_in_private);
// 			break;
// 		default:
// 			if (gf_props_type_is_enum(arg->arg_type)) {
// 				p.value.uint = * (u32 *) ((char *)filter->filter_udta + arg->offset_in_private);
// 				break;
// 			}
// 			return GF_FALSE;
// 		}
// 		if (min_max_enum) *min_max_enum = arg->min_max_enum;
// 		*prop = p;
// 		return GF_TRUE;
// 	}
// 	return GF_FALSE;
// }

// the below code fragment can be found in:
// src/filters/reframe_rawpcm.c
// static const char *pcmreframe_probe_data(const u8 *data, u32 size, GF_FilterProbeScore *score)
// {
// 	if (size<20) return NULL;
// 
// 	GF_BitStream *bs = gf_bs_new(data, size, GF_BITSTREAM_READ);
// 	u32 code = gf_bs_read_u32(bs);
// 	if (code == GF_4CC('R', 'I', 'F', 'F')) {
// 		gf_bs_read_u32(bs);
// 		code = gf_bs_read_u32(bs);
// 		if (code == GF_4CC('W', 'A', 'V', 'E')) {
// 			*score = GF_FPROBE_SUPPORTED;
// 			gf_bs_del(bs);
// 			return "audio/wav";
// 		}
// 	}
// 	gf_bs_del(bs);
// 	*score = GF_FPROBE_EXT_MATCH;
// 	return gf_audio_fmt_all_shortnames();
// }

// the below code fragment can be found in:
// src/filters/reframe_rawpcm.c
// const GF_FilterRegister *rfpcm_register(GF_FilterSession *session)
// {
// 	PCMReframeArgs[1].min_max_enum = gf_audio_fmt_all_names();
// 	PCMReframeCaps[1].val.value.string = (char *) gf_audio_fmt_all_shortnames();
// 	return &PCMReframeRegister;
// }

// the below code fragment can be found in:
// src/filters/load_text.c
// const GF_FilterRegister *txtin_register(GF_FilterSession *session)
// {
// 	return &TXTInRegister;
// }
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).