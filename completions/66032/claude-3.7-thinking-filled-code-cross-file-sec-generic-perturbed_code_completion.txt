// Strip leading whitespace and newline characters
while (probelength && strchr("\n\r\t ", (char) probe_data[0])) {
    probe_data++;
    probelength--;
}

// Handle XML header <?xml ... ?>
if (probelength > 5 && !strncmp((const char *)probe_data, "<?xml", 5)) {
    const char *xml_end = my_strstr(probe_data, "?>", probelength);
    if (xml_end) {
        u32 skip_len = (u32)((xml_end + 2) - (const char *)probe_data);
        if (skip_len < probelength) {
            probe_data += skip_len;
            probelength -= skip_len;
            
            // Skip whitespace again
            while (probelength && strchr("\n\r\t ", (char) probe_data[0])) {
                probe_data++;
                probelength--;
            }
        }
    }
}

// Handle DOCTYPE declaration
if (probelength > 9 && !strncmp((const char *)probe_data, "<!DOCTYPE", 9)) {
    const char *doctype_end = NULL;
    char in_quotes = 0;
    u32 i = 9;
    
    // Scan for the closing >
    while (i < probelength) {
        // Handle quoted strings
        if (probe_data[i] == '"' || probe_data[i] == '\'') {
            if (!in_quotes) {
                in_quotes = probe_data[i]; // Start quote tracking
            } else if (in_quotes == probe_data[i]) {
                in_quotes = 0; // End quote
            }
        } 
        // Only look for > when not in quotes
        else if (!in_quotes && probe_data[i] == '>') {
            doctype_end = (const char *)&probe_data[i];
            break;
        }
        i++;
    }
    
    if (doctype_end) {
        u32 skip_len = (u32)((doctype_end + 1) - (const char *)probe_data);
        if (skip_len < probelength) {
            probe_data += skip_len;
            probelength -= skip_len;
            
            // Skip whitespace again
            while (probelength && strchr("\n\r\t ", (char) probe_data[0])) {
                probe_data++;
                probelength--;
            }
        }
    }
}

// Handle XML comments
while (probelength > 4 && !strncmp((const char *)probe_data, "<!--", 4)) {
    const char *comment_end = my_strstr(probe_data, "-->", probelength);
    if (!comment_end) break; // Malformed comment
    
    u32 skip_len = (u32)((comment_end + 3) - (const char *)probe_data);
    if (skip_len >= probelength) break; // Comment runs to end
    
    probe_data += skip_len;
    probelength -= skip_len;
    
    // Skip whitespace after comments
    while (probelength && strchr("\n\r\t ", (char) probe_data[0])) {
        probe_data++;
        probelength--;
    }
}