/* Strip leading whitespace and newline characters from the probe_data */
    while (probelength && (probe_data[0] == ' ' || probe_data[0] == '\t' || probe_data[0] == '\r' || probe_data[0] == '\n')) {
        probe_data++;
        probelength--;
    }

    /* Remove XML-specific components like comments, doctype, and XML declarations */
    while (probelength) {
        /* Skip XML comments <!-- ... --> */
        if (!strncmp((const char *)probe_data, "<!--", 4)) {
            const char *end = my_strstr((const char *)probe_data + 4, "-->", probelength - 4);
            if (!end) break; /* malformed comment, stop */
            probelength -= (u32)((end + 3) - (char *)probe_data);
            probe_data    = (const u8 *)(end + 3);
        }
        /* Skip DOCTYPE <!DOCTYPE ...> or other <! ...> declarations */
        else if (!strncmp((const char *)probe_data, "<!", 2)) {
            const char *end = my_strstr((const char *)probe_data + 2, ">", probelength - 2);
            if (!end) break; /* malformed declaration, stop */
            probelength -= (u32)((end + 1) - (char *)probe_data);
            probe_data    = (const u8 *)(end + 1);
        }
        /* Skip XML declaration <?xml ...?> */
        else if (!strncmp((const char *)probe_data, "<?xml", 5)) {
            const char *end = my_strstr((const char *)probe_data + 5, "?>", probelength - 5);
            if (!end) break; /* malformed declaration, stop */
            probelength -= (u32)((end + 2) - (char *)probe_data);
            probe_data    = (const u8 *)(end + 2);
        } else {
            /* Re-check for leading whitespace after skipping tags */
            while (probelength && (probe_data[0] == ' ' || probe_data[0] == '\t' || probe_data[0] == '\r' || probe_data[0] == '\n')) {
                probe_data++;
                probelength--;
            }
            /* Stop if no more known patterns found */
            break;
        }
    }