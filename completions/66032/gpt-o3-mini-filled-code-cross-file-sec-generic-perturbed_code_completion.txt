{
    const char *p = (const char *)probe_data;
    u32 len = probelength;
    // Strip leading whitespace and newlines
    while (len && *p && strchr(" \n\r\t", *p))
    {
        p++;
        len--;
    }
    // Remove XML declaration header if present
    if (len >= 5 && !strncmp(p, "<?xml", 5))
    {
        const char *end_decl = my_strstr(p, "?>", len);
        if (end_decl) {
            u32 header_len = (u32)(end_decl - p) + 2; // include "?>"
            p += header_len;
            len -= header_len;
            while (len && *p && strchr(" \n\r\t", *p))
            {
                p++;
                len--;
            }
        }
    }
    // Remove DOCTYPE declaration if present
    if (len >= 9 && !strncmp(p, "<!DOCTYPE", 9))
    {
        const char *end_doctype = my_strstr(p, ">", len);
        if (end_doctype) {
            u32 doctype_len = (u32)(end_doctype - p) + 1; // include ">"
            p += doctype_len;
            len -= doctype_len;
            while (len && *p && strchr(" \n\r\t", *p))
            {
                p++;
                len--;
            }
        }
    }
    // Remove XML comments if present
    while (len >= 4 && !strncmp(p, "<!--", 4))
    {
        const char *end_comment = my_strstr(p, "-->", len);
        if (end_comment) {
            u32 comment_len = (u32)(end_comment - p) + 3; // include "-->"
            p += comment_len;
            len -= comment_len;
            while (len && *p && strchr(" \n\r\t", *p))
            {
                p++;
                len--;
            }
        } else {
            break;
        }
    }
    // Update probe_data and probelength to point to the first XML element
    probe_data = (const u8 *)p;
    probelength = len;
}