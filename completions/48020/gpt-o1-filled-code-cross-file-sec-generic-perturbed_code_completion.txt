} else if(is_ndpi_proto(flow_info, NDPI_PROTOCOL_SSH)) {
  flow_info->info_type = INFO_SSH;
  /* Copy SSH client/server signatures and hashes if available */
  if(flow_info->ndpi_flow->protos.ssh.client_signature[0] != '\0') {
    flow_info->ssh.client_signature = ndpi_strdup(flow_info->ndpi_flow->protos.ssh.client_signature);
  }
  if(flow_info->ndpi_flow->protos.ssh.server_signature[0] != '\0') {
    flow_info->ssh.server_signature = ndpi_strdup(flow_info->ndpi_flow->protos.ssh.server_signature);
  }
  if(flow_info->ndpi_flow->protos.ssh.client_hash[0] != '\0') {
    flow_info->ssh.client_hash = ndpi_strdup(flow_info->ndpi_flow->protos.ssh.client_hash);
  }
  if(flow_info->ndpi_flow->protos.ssh.server_hash[0] != '\0') {
    flow_info->ssh.server_hash = ndpi_strdup(flow_info->ndpi_flow->protos.ssh.server_hash);
  }

} else if(is_ndpi_proto(flow_info, NDPI_PROTOCOL_QUIC)) {
  is_quic = 1;
  /* Mark QUIC info type for consistency */
  flow_info->info_type = INFO_TLS; /* or INFO_QUIC if desired */

  /* If there are specific QUIC fields, copy them here */
  if(flow_info->ndpi_flow->protos.quic.alpn[0] != '\0') {
    flow_info->tls.alpn = ndpi_strdup(flow_info->ndpi_flow->protos.quic.alpn);
  }
  if(flow_info->ndpi_flow->protos.quic.supported_versions[0] != '\0') {
    flow_info->tls.supported_versions = ndpi_strdup(flow_info->ndpi_flow->protos.quic.supported_versions);
  }
  /* Other QUIC-related information can be added as needed */

} else if(is_ndpi_proto(flow_info, NDPI_PROTOCOL_TLS) ||
          is_ndpi_proto(flow_info, NDPI_PROTOCOL_SSL) ||
          is_quic) {
  /* Decide final info type (TLS vs QUIC) */
  flow_info->info_type = is_quic ? INFO_TLS : INFO_TLS; /* or INFO_QUIC if preferred for QUIC */

  /* Copy TLS/SSL or QUIC data, including certificates, JA3, ALPN, etc. */
  if(flow_info->ndpi_flow->protos.ssl.ja3_client[0] != '\0') {
    flow_info->tls.ja3_client = ndpi_strdup(flow_info->ndpi_flow->protos.ssl.ja3_client);
  }
  if(flow_info->ndpi_flow->protos.ssl.ja3_server[0] != '\0') {
    flow_info->tls.ja3_server = ndpi_strdup(flow_info->ndpi_flow->protos.ssl.ja3_server);
  }
  if(flow_info->ndpi_flow->protos.ssl.alpn[0] != '\0') {
    flow_info->tls.alpn = ndpi_strdup(flow_info->ndpi_flow->protos.ssl.alpn);
  }
  if(flow_info->ndpi_flow->protos.ssl.supported_versions[0] != '\0') {
    flow_info->tls.supported_versions = ndpi_strdup(flow_info->ndpi_flow->protos.ssl.supported_versions);
  }
  if(flow_info->ndpi_flow->protos.ssl.cert_issuer[0] != '\0') {
    flow_info->tls.cert_issuer = ndpi_strdup(flow_info->ndpi_flow->protos.ssl.cert_issuer);
  }
  if(flow_info->ndpi_flow->protos.ssl.cert_subject[0] != '\0') {
    flow_info->tls.cert_subject = ndpi_strdup(flow_info->ndpi_flow->protos.ssl.cert_subject);
  }
  /* If needed, reset or update any payload length distribution based on TLS block sizes here */
}