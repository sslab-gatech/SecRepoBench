// Check if the flow corresponds to the SSH protocol.
// If so, copy SSH-related information, such as client and server signatures,
// and client/server hash data to the flow structure.
if(is_ndpi_proto(flow_info, NDPI_PROTOCOL_SSH)) {
    if(flow_info->ndpi_flow->protos.ssh.client_signature[0] != '\0')
        flow_info->ssh.client_signature = ndpi_strdup(flow_info->ndpi_flow->protos.ssh.client_signature);
    if(flow_info->ndpi_flow->protos.ssh.server_signature[0] != '\0')
        flow_info->ssh.server_signature = ndpi_strdup(flow_info->ndpi_flow->protos.ssh.server_signature);
    if(flow_info->ndpi_flow->protos.ssh.client_hash[0] != '\0')
        flow_info->ssh.client_hash = ndpi_strdup(flow_info->ndpi_flow->protos.ssh.client_hash);
    if(flow_info->ndpi_flow->protos.ssh.server_hash[0] != '\0')
        flow_info->ssh.server_hash = ndpi_strdup(flow_info->ndpi_flow->protos.ssh.server_hash);
}
// Check if the flow corresponds to the TLS protocol or related protocols.
// If the protocol matches, update the flow structure with relevant TLS/QUIC information.
// This includes SSL version, server names, certificate validity dates, and JA3 fingerprints.
else if(is_ndpi_proto(flow_info, NDPI_PROTOCOL_TLS) || is_ndpi_proto(flow_info, NDPI_PROTOCOL_QUIC)) {
    flow_info->tls.ssl_version = flow_info->ndpi_flow->protos.tls.ssl_version;
    if(flow_info->ndpi_flow->protos.tls.server_names[0] != '\0')
        flow_info->tls.server_names = ndpi_strdup(flow_info->ndpi_flow->protos.tls.server_names);
    if(flow_info->ndpi_flow->protos.tls.notBefore != 0)
        flow_info->tls.notBefore = flow_info->ndpi_flow->protos.tls.notBefore;
    if(flow_info->ndpi_flow->protos.tls.notAfter != 0)
        flow_info->tls.notAfter = flow_info->ndpi_flow->protos.tls.notAfter;
    if(flow_info->ndpi_flow->protos.tls.ja3_client[0] != '\0')
        flow_info->tls.ja3_client = ndpi_strdup(flow_info->ndpi_flow->protos.tls.ja3_client);
    if(flow_info->ndpi_flow->protos.tls.ja3_server[0] != '\0')
        flow_info->tls.ja3_server = ndpi_strdup(flow_info->ndpi_flow->protos.tls.ja3_server);
    if(flow_info->ndpi_flow->protos.tls.alpn[0] != '\0')
        flow_info->tls.alpn = ndpi_strdup(flow_info->ndpi_flow->protos.tls.alpn);
    if(flow_info->ndpi_flow->protos.tls.supported_versions[0] != '\0')
        flow_info->tls.supported_versions = ndpi_strdup(flow_info->ndpi_flow->protos.tls.supported_versions);
    flow_info->info_type = INFO_TLS;
    is_quic = is_ndpi_proto(flow_info, NDPI_PROTOCOL_QUIC);
}
// If ALPN and supported versions are present, store them and set the appropriate info type.
// Optionally, reset and update the payload length distribution based on TLS block lengths.
if(flow_info->tls.alpn != NULL && flow_info->tls.supported_versions != NULL) {
    flow_info->info_type = INFO_TLS_ALPN;
    if(is_quic) {
        flow_info->info_type = INFO_QUIC;
        // Reset and update the payload length distribution based on QUIC block lengths
        memset(flow_info->packet_len_distrib, 0, sizeof(flow_info->packet_len_distrib));
        for(i = 0; i < sizeof(flow_info->ndpi_flow->protos.quic.payload_lengths)/sizeof(flow_info->ndpi_flow->protos.quic.payload_lengths[0]); i++) {
            if(flow_info->ndpi_flow->protos.quic.payload_lengths[i] > 0)
                flow_info->packet_len_distrib[flow_info->ndpi_flow->protos.quic.payload_lengths[i]]++;
        }
    } else {
        // Reset and update the payload length distribution based on TLS block lengths
        memset(flow_info->packet_len_distrib, 0, sizeof(flow_info->packet_len_distrib));
        for(i = 0; i < sizeof(flow_info->ndpi_flow->protos.tls.encrypted_sni_len)/sizeof(flow_info->ndpi_flow->protos.tls.encrypted_sni_len[0]); i++) {
            if(flow_info->ndpi_flow->protos.tls.encrypted_sni_len[i] > 0)
                flow_info->packet_len_distrib[flow_info->ndpi_flow->protos.tls.encrypted_sni_len[i]]++;
        }
    }
}