// Check if the flow corresponds to the SSH protocol.
// If so, copy SSH-related information, such as client and server signatures,
// and client/server hash data to the flow structure.
// Check if the flow corresponds to the TLS protocol or related protocols.
// If the protocol matches, update the flow structure with relevant TLS/QUIC information.
// This includes SSL version, server names, certificate validity dates, and JA3 fingerprints.
// Extract and store SSL/TLS version, server names, and certificate information.
// Copy various TLS/QUIC attributes, including ALPN and fingerprint data, to the flow.
// If ALPN and supported versions are present, store them and set the appropriate info type.
// Optionally, reset and update the payload length distribution based on TLS block lengths.
if(is_ndpi_proto(flow_info, NDPI_PROTOCOL_SSH)) {
  if(flow_info->ndpi_flow->protos.ssh.client_signature[0] != '\0')
    flow_info->ssh.client_signature = ndpi_strdup(flow_info->ndpi_flow->protos.ssh.client_signature);
  if(flow_info->ndpi_flow->protos.ssh.server_signature[0] != '\0')
    flow_info->ssh.server_signature = ndpi_strdup(flow_info->ndpi_flow->protos.ssh.server_signature);
  if(flow_info->ndpi_flow->protos.ssh.client_hash[0] != '\0')
    flow_info->ssh.client_hash = ndpi_strdup(flow_info->ndpi_flow->protos.ssh.client_hash);
  if(flow_info->ndpi_flow->protos.ssh.server_hash[0] != '\0')
    flow_info->ssh.server_hash = ndpi_strdup(flow_info->ndpi_flow->protos.ssh.server_hash);
}

if(is_ndpi_proto(flow_info, NDPI_PROTOCOL_TLS) || is_ndpi_proto(flow_info, NDPI_PROTOCOL_QUIC)) {
  flow_info->info_type = INFO_TLS_QUIC;
  ndpi_snprintf(flow_info->tls_quic.version, sizeof(flow_info->tls_quic.version), "%s",
		flow_info->ndpi_flow->protos.tls_quic.version);
  ndpi_snprintf(flow_info->tls_quic.server_name, sizeof(flow_info->tls_quic.server_name), "%s",
		flow_info->ndpi_flow->protos.tls_quic.server_name);
  ndpi_snprintf(flow_info->tls_quic.certificate_validity_start, sizeof(flow_info->tls_quic.certificate_validity_start), "%s",
		flow_info->ndpi_flow->protos.tls_quic.certificate_validity_start);
  ndpi_snprintf(flow_info->tls_quic.certificate_validity_end, sizeof(flow_info->tls_quic.certificate_validity_end), "%s",
		flow_info->ndpi_flow->protos.tls_quic.certificate_validity_end);
  ndpi_snprintf(flow_info->tls_quic.ja3_fingerprint, sizeof(flow_info->tls_quic.ja3_fingerprint), "%s",
		flow_info->ndpi_flow->protos.tls_quic.ja3_fingerprint);

  if(flow_info->ndpi_flow->protos.tls_quic.alpn[0] != '\0') {
    flow_info->tls_quic.alpn = ndpi_strdup(flow_info->ndpi_flow->protos.tls_quic.alpn);
    flow_info->info_type = INFO_TLS_QUIC_ALPN;
  }

  if(flow_info->ndpi_flow->protos.tls_quic.supported_versions[0] != '\0') {
    flow_info->tls_quic.supported_versions = ndpi_strdup(flow_info->ndpi_flow->protos.tls_quic.supported_versions);
    flow_info->info_type = INFO_TLS_QUIC_VERSIONS;
  }

  if(flow_info->ndpi_flow->protos.tls_quic.reset_payload_length_distribution) {
    flow_info->reset_payload_length_distribution = 1;
    flow_info->tls_quic.reset_payload_length_distribution = ndpi_strdup(flow_info->ndpi_flow->protos.tls_quic.reset_payload_length_distribution);
  }
}