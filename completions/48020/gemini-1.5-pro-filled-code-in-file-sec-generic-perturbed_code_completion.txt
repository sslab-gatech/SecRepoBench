if(is_ndpi_proto(flow_info, NDPI_PROTOCOL_SSH)) {
    flow_info->info_type = INFO_SSH;

    ndpi_snprintf(flow_info->ssh.client_signature, sizeof(flow_info->ssh.client_signature), "%s", flow_info->ndpi_flow->protos.ssh.client.signature);
    ndpi_snprintf(flow_info->ssh.server_signature, sizeof(flow_info->ssh.server_signature), "%s", flow_info->ndpi_flow->protos.ssh.server.signature);

    for(i = 0; i < sizeof(flow_info->ssh.client_hash); i++) {
      flow_info->ssh.client_hash[i] = flow_info->ndpi_flow->protos.ssh.client.hash[i];
    }

    for (i = 0; i < sizeof(flow_info->ssh.server_hash); i++) {
      flow_info->ssh.server_hash[i] = flow_info->ndpi_flow->protos.ssh.server.hash[i];
    }
  } else if(is_ndpi_proto(flow_info, NDPI_PROTOCOL_TLS) ||
	    (flow_info->detected_protocol.master_protocol == NDPI_PROTOCOL_TLS) ||
            is_ndpi_proto(flow_info, NDPI_PROTOCOL_QUIC) ||
            (flow_info->detected_protocol.master_protocol == NDPI_PROTOCOL_QUIC)) {
    flow_info->info_type = INFO_TLS;
    is_quic = is_ndpi_proto(flow_info, NDPI_PROTOCOL_QUIC);

    flow_info->tls.tls_version = flow_info->ndpi_flow->protos.tls.version;

    ndpi_snprintf(flow_info->tls.server_names,
                  sizeof(flow_info->tls.server_names), "%s", flow_info->ndpi_flow->protos.tls.server_names);

    flow_info->tls.not_before = flow_info->ndpi_flow->protos.tls.not_before;
    flow_info->tls.not_after = flow_info->ndpi_flow->protos.tls.not_after;

    ndpi_snprintf(flow_info->tls.ja3_fingerprint,
		  sizeof(flow_info->tls.ja3_fingerprint), "%s", flow_info->ndpi_flow->protos.tls.ja3_fingerprint);

    ndpi_snprintf(flow_info->tls.sni, sizeof(flow_info->tls.sni), "%s", flow_info->ndpi_flow->protos.tls.sni);

    ndpi_snprintf(flow_info->tls.subject, sizeof(flow_info->tls.subject), "%s", flow_info->ndpi_flow->protos.tls.subject);
    ndpi_snprintf(flow_info->tls.issuer, sizeof(flow_info->tls.issuer), "%s", flow_info->ndpi_flow->protos.tls.issuer);

    flow_info->tls.client_cert_not_before = flow_info->ndpi_flow->protos.tls.client_cert_not_before;
    flow_info->tls.client_cert_not_after = flow_info->ndpi_flow->protos.tls.client_cert_not_after;

    ndpi_snprintf(flow_info->tls.client_subject, sizeof(flow_info->tls.client_subject), "%s", flow_info->ndpi_flow->protos.tls.client_subject);
    ndpi_snprintf(flow_info->tls.client_issuer, sizeof(flow_info->tls.client_issuer), "%s", flow_info->ndpi_flow->protos.tls.client_issuer);


    if(flow_info->ndpi_flow->protos.tls.tls_alpn != NULL) {
      flow_info->tls.alpn = ndpi_strdup(flow_info->ndpi_flow->protos.tls.tls_alpn);
    }

    if(flow_info->ndpi_flow->protos.tls.tls_supported_versions != NULL) {
      flow_info->tls.supported_versions = ndpi_strdup(flow_info->ndpi_flow->protos.tls.tls_supported_versions);
    }

    if(flow_info->ndpi_flow->protos.tls.tls_issuerDN != NULL) {
      flow_info->tls.issuerDN = ndpi_strdup(flow_info->ndpi_flow->protos.tls.tls_issuerDN);
    }

    if(flow_info->ndpi_flow->protos.tls.tls_subjectDN != NULL) {
      flow_info->tls.subjectDN = ndpi_strdup(flow_info->ndpi_flow->protos.tls.tls_subjectDN);
    }

    if(flow_info->ndpi_flow->protos.tls.encrypted_sni.esni != NULL) {
      flow_info->tls.esni = ndpi_strdup(flow_info->ndpi_flow->protos.tls.encrypted_sni.esni);
    }

    if(flow_info->tls.alpn || flow_info->tls.supported_versions) {
      flow_info->info_type = INFO_TLS_ALPN;
    }

#ifdef HAVE_NDPI_RESET_PAYLOAD_LENGTH_DISTRIBUTION
    if(!is_quic) {
      ndpi_reset_payload_length_distribution(flow_info->ndpi_flow);
      for(i=0; i<flow_info->ndpi_flow->tls_num_blocks; i++) {
	ndpi_update_payload_length_distribution(flow_info->ndpi_flow, flow_info->ndpi_flow->tls_block_length[i]);
      }
    }
#endif
  }