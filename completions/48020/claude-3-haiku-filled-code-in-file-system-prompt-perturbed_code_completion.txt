/* Check if the flow corresponds to the SSH protocol.
 * If so, copy SSH-related information, such as client and server signatures,
 * and client/server hash data to the flow structure.
 */
if(is_ndpi_proto(flow, NDPI_PROTOCOL_SSH) || (flow->detected_protocol.master_protocol == NDPI_PROTOCOL_SSH)) {
    if(flow->ssh_tls.server_names == NULL && flow->ndpi_flow->protos.ssh.server_info[0] != '\0') {
        flow->ssh_tls.server_names = ndpi_strdup(flow->ndpi_flow->protos.ssh.server_info);
    }
    if(flow->ssh_tls.tls_alpn == NULL && flow->ndpi_flow->protos.ssh.client_signature[0] != '\0') {
        flow->ssh_tls.tls_alpn = ndpi_strdup(flow->ndpi_flow->protos.ssh.client_signature);
    }
    if(flow->ssh_tls.tls_supported_versions == NULL && flow->ndpi_flow->protos.ssh.server_signature[0] != '\0') {
        flow->ssh_tls.tls_supported_versions = ndpi_strdup(flow->ndpi_flow->protos.ssh.server_signature);
    }
}

/* Check if the flow corresponds to the TLS protocol or related protocols.
 * If the protocol matches, update the flow structure with relevant TLS/QUIC information.
 * This includes SSL version, server names, certificate validity dates, and JA3 fingerprints.
 */
if(is_ndpi_proto(flow, NDPI_PROTOCOL_TLS) || (flow->detected_protocol.master_protocol == NDPI_PROTOCOL_TLS) ||
   is_ndpi_proto(flow, NDPI_PROTOCOL_QUIC) || (flow->detected_protocol.master_protocol == NDPI_PROTOCOL_QUIC)) {
    if(flow->ssh_tls.tls_version == 0) {
        flow->ssh_tls.tls_version = flow->ndpi_flow->protos.tls.ssl_version;
    }
    if(flow->ssh_tls.server_names == NULL && flow->ndpi_flow->protos.tls.server_names[0] != '\0') {
        flow->ssh_tls.server_names = ndpi_strdup(flow->ndpi_flow->protos.tls.server_names);
    }
    if(flow->ssh_tls.tls_issuerDN == NULL && flow->ndpi_flow->protos.tls.issuerDN[0] != '\0') {
        flow->ssh_tls.tls_issuerDN = ndpi_strdup(flow->ndpi_flow->protos.tls.issuerDN);
    }
    if(flow->ssh_tls.tls_subjectDN == NULL && flow->ndpi_flow->protos.tls.subjectDN[0] != '\0') {
        flow->ssh_tls.tls_subjectDN = ndpi_strdup(flow->ndpi_flow->protos.tls.subjectDN);
    }
    if(flow->ssh_tls.tls_fingerprint == NULL && flow->ndpi_flow->protos.tls.ja3_client[0] != '\0') {
        flow->ssh_tls.tls_fingerprint = ndpi_strdup(flow->ndpi_flow->protos.tls.ja3_client);
    }
    if(flow->ssh_tls.tls_alpn == NULL && flow->ndpi_flow->protos.tls.alpn[0] != '\0') {
        flow->ssh_tls.tls_alpn = ndpi_strdup(flow->ndpi_flow->protos.tls.alpn);
    }
    if(flow->ssh_tls.tls_supported_versions == NULL && flow->ndpi_flow->protos.tls.tls_supported_versions[0] != '\0') {
        flow->ssh_tls.tls_supported_versions = ndpi_strdup(flow->ndpi_flow->protos.tls.tls_supported_versions);
    }
    if(flow->ssh_tls.encrypted_sni.esni != NULL && flow->ndpi_flow->protos.tls.encrypted_sni.esni[0] != '\0') {
        flow->ssh_tls.encrypted_sni.esni = ndpi_strdup(flow->ndpi_flow->protos.tls.encrypted_sni.esni);
    }

    /* If ALPN and supported versions are present, store them and set the appropriate info type. */
    if(flow->ssh_tls.tls_alpn != NULL || flow->ssh_tls.tls_supported_versions != NULL) {
        flow->info_type = INFO_TLS;
    }

    /* Optionally, reset and update the payload length distribution based on TLS block lengths. */
    if(enable_flow_stats) {
#ifdef DIRECTION_BINS
        ndpi_reset_bin(&flow->payload_len_bin_src2dst);
        ndpi_reset_bin(&flow->payload_len_bin_dst2src);
#else
        ndpi_reset_bin(&flow->payload_len_bin);
#endif
        ndpi_update_payload_length_distribution(flow, flow->ndpi_flow->protos.tls.encrypted_sni.encrypted_len);
    }
}