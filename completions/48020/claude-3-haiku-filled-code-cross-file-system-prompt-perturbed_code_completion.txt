// Check if the flow corresponds to the SSH protocol.
// If so, copy SSH-related information, such as client and server signatures,
// and client/server hash data to the flow structure.
if(is_ndpi_proto(flow_info, NDPI_PROTOCOL_SSH)) {
  if(flow_info->ndpi_flow->protos.ssh.client_signature[0] != '\0')
    flow_info->ssh.client_signature = ndpi_strdup(flow_info->ndpi_flow->protos.ssh.client_signature);
  if(flow_info->ndpi_flow->protos.ssh.server_signature[0] != '\0')
    flow_info->ssh.server_signature = ndpi_strdup(flow_info->ndpi_flow->protos.ssh.server_signature);
  if(flow_info->ndpi_flow->protos.ssh.client_hash[0] != '\0')
    flow_info->ssh.client_hash = ndpi_strdup(flow_info->ndpi_flow->protos.ssh.client_hash);
  if(flow_info->ndpi_flow->protos.ssh.server_hash[0] != '\0')
    flow_info->ssh.server_hash = ndpi_strdup(flow_info->ndpi_flow->protos.ssh.server_hash);
}
// Check if the flow corresponds to the TLS protocol or related protocols.
// If the protocol matches, update the flow structure with relevant TLS/QUIC information.
// This includes SSL version, server names, certificate validity dates, and JA3 fingerprints.
else if(is_ndpi_proto(flow_info, NDPI_PROTOCOL_TLS) ||
        is_ndpi_proto(flow_info, NDPI_PROTOCOL_QUIC) ||
        is_ndpi_proto(flow_info, NDPI_PROTOCOL_DTLS)) {
  flow_info->tls.ssl_version = flow_info->ndpi_flow->protos.tls.ssl_version;
  if(flow_info->ndpi_flow->protos.tls.server_names[0] != '\0')
    flow_info->tls.server_names = ndpi_strdup(flow_info->ndpi_flow->protos.tls.server_names);
  if(flow_info->ndpi_flow->protos.tls.alpn[0] != '\0')
    flow_info->tls.alpn = ndpi_strdup(flow_info->ndpi_flow->protos.tls.alpn);
  if(flow_info->ndpi_flow->protos.tls.ja3_client[0] != '\0')
    flow_info->tls.ja3_client = ndpi_strdup(flow_info->ndpi_flow->protos.tls.ja3_client);
  if(flow_info->ndpi_flow->protos.tls.ja3_server[0] != '\0')
    flow_info->tls.ja3_server = ndpi_strdup(flow_info->ndpi_flow->protos.tls.ja3_server);
  if(flow_info->ndpi_flow->protos.tls.client_requested_server_name[0] != '\0')
    flow_info->tls.client_requested_server_name = ndpi_strdup(flow_info->ndpi_flow->protos.tls.client_requested_server_name);
  if(flow_info->ndpi_flow->protos.tls.server_certificate_validity.not_before != 0)
    flow_info->tls.server_certificate_validity.not_before = flow_info->ndpi_flow->protos.tls.server_certificate_validity.not_before;
  if(flow_info->ndpi_flow->protos.tls.server_certificate_validity.not_after != 0)
    flow_info->tls.server_certificate_validity.not_after = flow_info->ndpi_flow->protos.tls.server_certificate_validity.not_after;
  if(flow_info->ndpi_flow->protos.tls.cipher_suite[0] != '\0')
    flow_info->tls.cipher_suite = ndpi_strdup(flow_info->ndpi_flow->protos.tls.cipher_suite);
  if(flow_info->ndpi_flow->protos.tls.client_hello_info[0] != '\0')
    flow_info->tls.client_hello_info = ndpi_strdup(flow_info->ndpi_flow->protos.tls.client_hello_info);
  if(flow_info->ndpi_flow->protos.tls.server_info[0] != '\0')
    flow_info->tls.server_info = ndpi_strdup(flow_info->ndpi_flow->protos.tls.server_info);
  if(flow_info->ndpi_flow->protos.tls.issuerDN[0] != '\0')
    flow_info->tls.issuerDN = ndpi_strdup(flow_info->ndpi_flow->protos.tls.issuerDN);
  if(flow_info->ndpi_flow->protos.tls.subjectDN[0] != '\0')
    flow_info->tls.subjectDN = ndpi_strdup(flow_info->ndpi_flow->protos.tls.subjectDN);
  if(flow_info->ndpi_flow->protos.tls.notBefore != 0)
    flow_info->tls.notBefore = flow_info->ndpi_flow->protos.tls.notBefore;
  if(flow_info->ndpi_flow->protos.tls.notAfter != 0)
    flow_info->tls.notAfter = flow_info->ndpi_flow->protos.tls.notAfter;
  if(flow_info->ndpi_flow->protos.tls.fingerprint[0] != '\0')
    flow_info->tls.fingerprint = ndpi_strdup(flow_info->ndpi_flow->protos.tls.fingerprint);
  if(flow_info->ndpi_flow->protos.tls.encrypted_sni.length > 0)
    flow_info->tls.encrypted_sni = ndpi_malloc(flow_info->ndpi_flow->protos.tls.encrypted_sni.length + 1);
    memcpy(flow_info->tls.encrypted_sni, flow_info->ndpi_flow->protos.tls.encrypted_sni.value, flow_info->ndpi_flow->protos.tls.encrypted_sni.length);
    flow_info->tls.encrypted_sni[flow_info->ndpi_flow->protos.tls.encrypted_sni.length] = '\0';
}

// If ALPN and supported versions are present, store them and set the appropriate info type.
if(flow_info->tls.alpn != NULL) {
  flow_info->info_type = INFO_TLS;
}

// Optionally, reset and update the payload length distribution based on TLS block lengths.
if(enable_payload_analyzer) {
  reset_payload_analyzer(flow_info);
  update_payload_analyzer(flow_info, flow_info->ndpi_flow->packet_payload_len);
}