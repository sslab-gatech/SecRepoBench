// Check if the flow corresponds to the SSH protocol.
  // If so, copy SSH-related information, such as client and server signatures,
  // and client/server hash data to the flow structure.
  else if(is_ndpi_proto(flow_info, NDPI_PROTOCOL_SSH)) {
    flow_info->info_type = INFO_SSH;
    if(flow_info->ndpi_flow->protos.ssh.client_signature[0] != '\0')
      flow_info->ssh.client_signature = ndpi_strdup(flow_info->ndpi_flow->protos.ssh.client_signature);
    if(flow_info->ndpi_flow->protos.ssh.server_signature[0] != '\0')
      flow_info->ssh.server_signature = ndpi_strdup(flow_info->ndpi_flow->protos.ssh.server_signature);
    if(flow_info->ndpi_flow->protos.ssh.client_kex[0] != '\0')
      flow_info->ssh.client_kex = ndpi_strdup(flow_info->ndpi_flow->protos.ssh.client_kex);
    if(flow_info->ndpi_flow->protos.ssh.server_kex[0] != '\0')
      flow_info->ssh.server_kex = ndpi_strdup(flow_info->ndpi_flow->protos.ssh.server_kex);
  }
  // Check if the flow corresponds to the TLS protocol or related protocols.
  // If the protocol matches, update the flow structure with relevant TLS/QUIC information.
  // This includes SSL version, server names, certificate validity dates, and JA3 fingerprints.
  // Extract and store SSL/TLS version, server names, and certificate information.
  // Copy various TLS/QUIC attributes, including ALPN and fingerprint data, to the flow.
  // If ALPN and supported versions are present, store them and set the appropriate info type.
  // Optionally, reset and update the payload length distribution based on TLS block lengths.
  else if(is_ndpi_proto(flow_info, NDPI_PROTOCOL_TLS) ||
          is_ndpi_proto(flow_info, NDPI_PROTOCOL_QUIC)) {
    u_int16_t ja3_len;

    flow_info->info_type = INFO_TLS;
    if(flow_info->ndpi_flow->protos.tls.ssl_version != 0) {
      flow_info->tls.ssl_version = flow_info->ndpi_flow->protos.tls.ssl_version;
      flow_info->tls.server_name = ndpi_strdup(flow_info->ndpi_flow->host_server_name);
      if(flow_info->ndpi_flow->protos.tls.certificate) {
        flow_info->tls.certificate = ndpi_strdup(flow_info->ndpi_flow->protos.tls.certificate);
        flow_info->tls.issuer = ndpi_strdup(flow_info->ndpi_flow->protos.tls.issuer);
        flow_info->tls.subject = ndpi_strdup(flow_info->ndpi_flow->protos.tls.subject);
      }
      if(flow_info->ndpi_flow->protos.tls.ja3[0] != '\0') {
        ja3_len = strlen(flow_info->ndpi_flow->protos.tls.ja3) / 2;
        flow_info->tls.ja3 = ndpi_malloc(ja3_len + 1);
        memcpy(flow_info->tls.ja3, flow_info->ndpi_flow->protos.tls.ja3, ja3_len);
        flow_info->tls.ja3[ja3_len] = '\0';
      }
      if(flow_info->ndpi_flow->protos.tls.alpn[0] != '\0')
        flow_info->tls.alpn = ndpi_strdup(flow_info->ndpi_flow->protos.tls.alpn);
    }
  }