if(is_ndpi_proto(flow_info, NDPI_PROTOCOL_SSH)) {
  // Extract SSH information
  if(flow_info->ndpi_flow->protos.ssh.client_signature)
    flow_info->ssh.client_signature = ndpi_strdup(flow_info->ndpi_flow->protos.ssh.client_signature);
  if(flow_info->ndpi_flow->protos.ssh.server_signature)
    flow_info->ssh.server_signature = ndpi_strdup(flow_info->ndpi_flow->protos.ssh.server_signature);
  
  if(flow_info->ndpi_flow->protos.ssh.hassh_client[0] != '\0')
    flow_info->ssh.hassh_client = ndpi_strdup(flow_info->ndpi_flow->protos.ssh.hassh_client);
  if(flow_info->ndpi_flow->protos.ssh.hassh_server[0] != '\0')
    flow_info->ssh.hassh_server = ndpi_strdup(flow_info->ndpi_flow->protos.ssh.hassh_server);
} else if(is_ndpi_proto(flow_info, NDPI_PROTOCOL_TLS) ||
          is_ndpi_proto(flow_info, NDPI_PROTOCOL_QUIC) ||
          flow_info->detected_protocol.master_protocol == NDPI_PROTOCOL_TLS ||
          flow_info->detected_protocol.app_protocol == NDPI_PROTOCOL_QUIC) {
  // Extract TLS/QUIC information
  
  if(is_ndpi_proto(flow_info, NDPI_PROTOCOL_QUIC)) {
    is_quic = 1;
  }

  // Store SSL/TLS version
  flow_info->ssh_tls.ssl_version = flow_info->ndpi_flow->protos.tls_quic.ssl_version;
  
  // Store server names
  if(flow_info->ndpi_flow->protos.tls_quic.server_names)
    flow_info->ssh_tls.server_names = ndpi_strdup(flow_info->ndpi_flow->protos.tls_quic.server_names);
  
  // Store SSL certificate
  if(flow_info->ndpi_flow->protos.tls_quic.server_certificate)
    flow_info->ssh_tls.server_certificate = ndpi_strdup(flow_info->ndpi_flow->protos.tls_quic.server_certificate);
  
  // Extract issuer
  if(flow_info->ndpi_flow->protos.tls_quic.issuerDN)
    flow_info->ssh_tls.issuerDN = ndpi_strdup(flow_info->ndpi_flow->protos.tls_quic.issuerDN);
  
  // Extract subject
  if(flow_info->ndpi_flow->protos.tls_quic.subjectDN)
    flow_info->ssh_tls.subjectDN = ndpi_strdup(flow_info->ndpi_flow->protos.tls_quic.subjectDN);
  
  // Store certificate validity dates
  if(flow_info->ndpi_flow->protos.tls_quic.notBefore)
    flow_info->ssh_tls.notBefore = ndpi_strdup(flow_info->ndpi_flow->protos.tls_quic.notBefore);
  if(flow_info->ndpi_flow->protos.tls_quic.notAfter)
    flow_info->ssh_tls.notAfter = ndpi_strdup(flow_info->ndpi_flow->protos.tls_quic.notAfter);
  
  // Store JA3 fingerprints
  if(flow_info->ndpi_flow->protos.tls_quic.ja3_client)
    flow_info->ssh_tls.ja3_client = ndpi_strdup(flow_info->ndpi_flow->protos.tls_quic.ja3_client);
  if(flow_info->ndpi_flow->protos.tls_quic.ja3_server)
    flow_info->ssh_tls.ja3_server = ndpi_strdup(flow_info->ndpi_flow->protos.tls_quic.ja3_server);
  
  // Store ALPN info
  if(flow_info->ndpi_flow->protos.tls_quic.alpn)
    flow_info->ssh_tls.alpn = ndpi_strdup(flow_info->ndpi_flow->protos.tls_quic.alpn);
  
  // Store TLS supported versions
  if(flow_info->ndpi_flow->protos.tls_quic.tls_supported_versions)
    flow_info->ssh_tls.tls_supported_versions = ndpi_strdup(flow_info->ndpi_flow->protos.tls_quic.tls_supported_versions);
  
  // Set info type
  if(flow_info->ndpi_flow->protos.tls_quic.alpn || flow_info->ndpi_flow->protos.tls_quic.tls_supported_versions)
    flow_info->info_type = INFO_TLS_QUIC;
  
  // Reset block length distribution
  for(i = 0; i < TLS_BLOCKS_HISTOGRAM_NUM_BINS && i < sizeof(flow_info->flow_tls_blocks_histogram)/sizeof(flow_info->flow_tls_blocks_histogram[0]); i++) {
    flow_info->flow_tls_blocks_histogram[i] = flow_info->ndpi_flow->flow_tls_blocks_histogram[i];
  }
}