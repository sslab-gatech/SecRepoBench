else if(is_ndpi_proto(flow_info, NDPI_PROTOCOL_SSH)) {
  if(flow_info->ndpi_flow->protos.ssh.client_signature != NULL)
    flow_info->ssh.client_signature = ndpi_strdup(flow_info->ndpi_flow->protos.ssh.client_signature);
  if(flow_info->ndpi_flow->protos.ssh.server_signature != NULL)
    flow_info->ssh.server_signature = ndpi_strdup(flow_info->ndpi_flow->protos.ssh.server_signature);
  if(flow_info->ndpi_flow->protos.ssh.client_hash != NULL)
    flow_info->ssh.client_hash = ndpi_strdup(flow_info->ndpi_flow->protos.ssh.client_hash);
  if(flow_info->ndpi_flow->protos.ssh.server_hash != NULL)
    flow_info->ssh.server_hash = ndpi_strdup(flow_info->ndpi_flow->protos.ssh.server_hash);
} else if(is_ndpi_proto(flow_info, NDPI_PROTOCOL_TLS) ||
          is_ndpi_proto(flow_info, NDPI_PROTOCOL_DTLS) ||
          is_ndpi_proto(flow_info, NDPI_PROTOCOL_MAIL_POPS) ||
          is_ndpi_proto(flow_info, NDPI_PROTOCOL_MAIL_SMTPS) ||
          is_ndpi_proto(flow_info, NDPI_PROTOCOL_MAIL_IMAPS) ||
          is_ndpi_proto(flow_info, NDPI_PROTOCOL_QUIC)) {
  is_quic = is_ndpi_proto(flow_info, NDPI_PROTOCOL_QUIC);

  ndpi_snprintf(flow_info->ssl_tls.client_requested_server_name,
                 sizeof(flow_info->ssl_tls.client_requested_server_name),
                 "%s", flow_info->ndpi_flow->protos.tls_quic.client_requested_server_name);

  ndpi_snprintf(flow_info->ssl_tls.server_names,
                 sizeof(flow_info->ssl_tls.server_names),
                 "%s", flow_info->ndpi_flow->protos.tls_quic.server_names);

  ndpi_snprintf(flow_info->ssl_tls.issuerDN,
                 sizeof(flow_info->ssl_tls.issuerDN),
                 "%s", flow_info->ndpi_flow->protos.tls_quic.issuerDN);

  ndpi_snprintf(flow_info->ssl_tls.subjectDN,
                 sizeof(flow_info->ssl_tls.subjectDN),
                 "%s", flow_info->ndpi_flow->protos.tls_quic.subjectDN);

  flow_info->ssl_tls.ssl_version = flow_info->ndpi_flow->protos.tls_quic.ssl_version,
  flow_info->ssl_tls.notBefore = flow_info->ndpi_flow->protos.tls_quic.notBefore,
  flow_info->ssl_tls.notAfter = flow_info->ndpi_flow->protos.tls_quic.notAfter,

  flow_info->ssl_tls.ja3_client = ndpi_strdup(flow_info->ndpi_flow->protos.tls_quic.ja3_client);
  flow_info->ssl_tls.ja3_server = ndpi_strdup(flow_info->ndpi_flow->protos.tls_quic.ja3_server);

  if(is_quic) {
    flow_info->quic.version = flow_info->ndpi_flow->protos.tls_quic.quic.version;
    memcpy(&flow_info->quic.server_crypto_data,
            &flow_info->ndpi_flow->protos.tls_quic.quic.server_crypto_data,
            sizeof(flow_info->quic.server_crypto_data));
  }

  if(flow_info->ndpi_flow->protos.tls_quic.advertised_alpns != NULL)
    flow_info->ssl_tls.advertised_alpns = ndpi_strdup(flow_info->ndpi_flow->protos.tls_quic.advertised_alpns);
  if(flow_info->ndpi_flow->protos.tls_quic.negotiated_alpn != NULL)
    flow_info->ssl_tls.negotiated_alpn = ndpi_strdup(flow_info->ndpi_flow->protos.tls_quic.negotiated_alpn);
  if(flow_info->ndpi_flow->protos.tls_quic.supported_versions != NULL)
    flow_info->ssl_tls.supported_versions = ndpi_strdup(flow_info->ndpi_flow->protos.tls_quic.supported_versions);

  if(flow_info->ssl_tls.advertised_alpns != NULL && flow_info->ssl_tls.supported_versions != NULL) {
    flow_info->info_type = INFO_TLS;
  }

#ifdef DIRECTION_BINS
  if(flow_info->payload_len_bins[0] == NULL) {
    int i;
    u_int16_t bin_length = ndpi_bin_length(flow_info->ndpi_flow->l4.tcp.tls_blocks_len);

    flow_info->payload_len_bins[0] = ndpi_malloc(bin_length);
    flow_info->payload_len_bins[1] = ndpi_malloc(bin_length);

    if(flow_info->payload_len_bins[0] && flow_info->payload_len_bins[1]) {
      ndpi_init_bin(flow_info->payload_len_bins[0], ndpi_bin_family8, bin_length, NULL);
      ndpi_init_bin(flow_info->payload_len_bins[1], ndpi_bin_family8, bin_length, NULL);

      for(i = 0; i < ndpi_bin_len(flow_info->ndpi_flow->l4.tcp.tls_blocks_len); i++) {
        u_int8_t l = flow_info->ndpi_flow->l4.tcp.tls_blocks_len->u8_array[i];

        ndpi_inc_bin(flow_info->payload_len_bins[l & 0x1], l);
      }
    }
  }
#endif
}