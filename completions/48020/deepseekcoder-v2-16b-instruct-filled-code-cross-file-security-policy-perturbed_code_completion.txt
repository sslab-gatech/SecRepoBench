// Check if the flow corresponds to the SSH protocol.
  // If so, copy SSH-related information, such as client and server signatures,
  // and client/server hash data to the flow structure.
  // 
  // Check if the flow corresponds to the TLS protocol or related protocols.
  // If the protocol matches, update the flow structure with relevant TLS/QUIC information.
  // This includes SSL version, server names, certificate validity dates, and JA3 fingerprints.
  // Extract and store SSL/TLS version, server names, and certificate information.
  // Copy various TLS/QUIC attributes, including ALPN and fingerprint data, to the flow.
  // 
  // If ALPN and supported versions are present, store them and set the appropriate info type.
  // Optionally, reset and update the payload length distribution based on TLS block lengths.

  if(is_ndpi_proto(flow_info, NDPI_PROTOCOL_SSH)) {
    ndpi_snprintf(flow_info->ssh.client_signature, sizeof(flow_info->ssh.client_signature), "%s", flow_info->ndpi_flow->protos.ssh.client_signature);
    ndpi_snprintf(flow_info->ssh.server_signature, sizeof(flow_info->ssh.server_signature), "%s", flow_info->ndpi_flow->protos.ssh.server_signature);
    ndpi_snprintf(flow_info->ssh.client_hash, sizeof(flow_info->ssh.client_hash), "%s", flow_info->ndpi_flow->protos.ssh.client_hash);
    ndpi_snprintf(flow_info->ssh.server_hash, sizeof(flow_info->ssh.server_hash), "%s", flow_info->ndpi_flow->protos.ssh.server_hash);
  } else if(is_ndpi_proto(flow_info, NDPI_PROTOCOL_TLS) || is_ndpi_proto(flow_info, NDPI_PROTOCOL_QUIC)) {
    ndpi_snprintf(flow_info->tls.version, sizeof(flow_info->tls.version), "%s", flow_info->ndpi_flow->tls.version);
    ndpi_snprintf(flow_info->tls.server_name, sizeof(flow_info->tls.server_name), "%s", flow_info->ndpi_flow->tls.server_name);
    ndpi_snprintf(flow_info->tls.certificate_validity, sizeof(flow_info->tls.certificate_validity), "%s", flow_info->ndpi_flow->tls.certificate_validity);
    ndpi_snprintf(flow_info->tls.ja3_fingerprint, sizeof(flow_info->tls.ja3_fingerprint), "%s", flow_info->ndpi_flow->tls.ja3_fingerprint);

    if(flow_info->ndpi_flow->tls.alpn != NULL) {
      ndpi_snprintf(flow_info->tls.alpn, sizeof(flow_info->tls.alpn), "%s", flow_info->ndpi_flow->tls.alpn);
    }

    if(flow_info->ndpi_flow->tls.supported_versions != NULL) {
      ndpi_snprintf(flow_info->tls.supported_versions, sizeof(flow_info->tls.supported_versions), "%s", flow_info->ndpi_flow->tls.supported_versions);
    }

    // Reset and update the payload length distribution based on TLS block lengths.
    // This is a placeholder for the actual implementation.
    // flow_info->payload_length_distribution = update_payload_length_distribution(flow_info->ndpi_flow->tls.payload_lengths);

    flow_info->info_type = INFO_TLS;
  } else if(is_ndpi_proto(flow_info, NDPI_PROTOCOL_ALPN)) {
    if(flow_info->ndpi_flow->alpn != NULL) {
      ndpi_snprintf(flow_info->alpn.protocols, sizeof(flow_info->alpn.protocols), "%s", flow_info->ndpi_flow->alpn);
    }

    flow_info->info_type = INFO_ALPN;
  }