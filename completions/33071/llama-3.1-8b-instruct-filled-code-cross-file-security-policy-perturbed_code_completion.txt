// Validate the content marker at the specified offset.
// Read the length of the content from the specified position.
// Store the content length in the metalayer structure.
// Advance the position to read the actual content of the metalayer.
// Copy the content data into a newly allocated memory and assign it to the metalayer.
uint32_t content_len;
trailer_pos += 1;
if (trailer_len < trailer_pos) {
  return BLOSC2_ERROR_READ_BUFFER;
}
if ((*idxp & 0xffu)!= 0xd2u) {   // sanity check
  return BLOSC2_ERROR_DATA;
}
idxp += 1;
from_big(&content_len, idxp, sizeof(content_len));
idxp += 4;
if (content_len < 0 || content_len > trailer_len - trailer_pos) {
  // Content length is less than zero or exceeds trailer length
  return BLOSC2_ERROR_DATA;
}
// Go to offset and see if we have the correct marker
uint8_t* content_marker = trailer + offset;
// Validate the content marker at the specified offset.
if (memcmp(content_marker, BLOSC2_CONTENT_MARKER, BLOSC2_CONTENT_MARKER_LEN)!= 0) {
  return BLOSC2_ERROR_DATA;
}
// Read the length of the content from the specified position.
// Store the content length in the metalayer structure.
layer_metadata->content_len = content_len;
// Advance the position to read the actual content of the metalayer.
// Copy the content data into a newly allocated memory and assign it to the metalayer.
char* content = malloc((size_t)content_len);
memcpy(content, content_marker + 1 + 4, (size_t)content_len);
layer_metadata->content = (uint8_t*)content;