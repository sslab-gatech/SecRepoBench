// Validate the content marker at the specified offset.
  if (content_marker[0] != 0xde) {   // sanity check
    return BLOSC2_ERROR_DATA;
  }

  // Read the length of the content from the specified position.
  uint32_t content_len;
  trailer_pos += sizeof(content_len);
  if (trailer_len < trailer_pos) {
    return BLOSC2_ERROR_READ_BUFFER;
  }
  from_big(&content_len, content_marker + 1, sizeof(content_len));

  // Store the content length in the metalayer structure.
  layer_metadata->content_len = content_len;

  // Advance the position to read the actual content of the metalayer.
  uint8_t* content_marker_end = content_marker + 1 + 4 + content_len;

  // Copy the content data into a newly allocated memory and assign it to the metalayer.
  char* content = malloc((size_t)content_len);
  memcpy(content, content_marker + 1 + 4, (size_t)content_len);
  layer_metadata->content = (uint8_t*)content;