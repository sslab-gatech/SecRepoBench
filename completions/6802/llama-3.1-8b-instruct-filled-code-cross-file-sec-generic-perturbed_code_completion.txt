if ((*p == 'p') && (isalpha((int) ((unsigned char) *(p+1))) == 0))
  {
    // Extract a subexpression enclosed in curly braces '{}' or square brackets '[]' from the input expression.
    // Evaluate the subexpression using FxEvaluateSubexpression and assign its result to point.x and point.y.
    // Update the expression pointer 'p' to continue processing the rest of the expression.
    // <MASK>
    {
      const char
        *q;

      ssize_t
        depth,
        level;

      level=0;
      q=p;
      for (p++; *p!= '\0'; p++)
        {
          if (*p == '[')
            level++;
          else
            if (*p == ']')
              {
                level--;
                if (level == 0)
                  break;
              }
        }
      *p='\0';
      depth=0;
      alpha=FxEvaluateSubexpression(fx_info,pixchannel,x,y,q,&depth,&beta,exception);
      point.x=(double) alpha;
      point.y=(double) beta;
      p++;
    }
  }