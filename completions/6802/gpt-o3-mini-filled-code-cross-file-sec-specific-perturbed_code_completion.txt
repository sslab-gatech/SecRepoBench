{
  p++;  /* Skip the 'p' character */
  if ((*p != '{') && (*p != '['))
  {
    /* Not a recognized delimiter, so bail out. */
    (void) ThrowMagickException(exception, GetMagickModule(), OptionError,
      "SyntaxError", "Expected '{' or '[' after 'p' in expression");
    return(0.0);
  }
  const char start_delimiter = *p;
  const char end_delimiter = (start_delimiter == '{') ? '}' : ']';
  p++;  /* Skip the opening delimiter */
  q = subexpression;
  level = 1;
  while ((*p != '\0') && (level > 0))
  {
    if ((size_t)(q - subexpression) >= (MagickPathExtent - 1))
    {
      /* Prevent buffer overflow by terminating the subexpression */
      break;
    }
    if (*p == start_delimiter)
      level++;
    else if (*p == end_delimiter)
    {
      level--;
      if (level == 0)
      {
        p++;  /* Skip the closing delimiter */
        break;
      }
    }
    if (level > 0)
      *q++ = *p++;
  }
  *q = '\0';
  alpha = FxEvaluateSubexpression(fx_info, pixchannel, x, y, subexpression,
    &depth, &beta, exception);
  point.x = alpha;
  point.y = beta;
}