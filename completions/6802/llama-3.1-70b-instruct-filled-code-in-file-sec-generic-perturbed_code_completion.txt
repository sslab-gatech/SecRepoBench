// Extract a subexpression enclosed in curly braces '{}' or square brackets '[]' from the input expression.
// Evaluate the subexpression using FxEvaluateSubexpression and assign its result to point.x and point.y.
// Update the expression pointer 'p' to continue processing the rest of the expression.
if ((*p == 'p') && (isalpha((int) ((unsigned char) *(p+1))) == 0))
{
    const char
        *subexpression;

    register ssize_t
        level;

    level=0;
    subexpression=++p;
    while ((*subexpression!= '\0') &&
           ((level!= 1) || (strchr("}",(int) *subexpression) == (char *) NULL) ||
            (strchr("]",(int) *subexpression) == (char *) NULL)))
    {
        if (strchr("{[",(int) *subexpression)!= (char *) NULL)
            level++;
        else
            if (strchr("}]",(int) *subexpression)!= (char *) NULL)
                level--;
        subexpression++;
    }
    if (*subexpression == '\0')
    {
        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            "UnbalancedParenthesis","`%s'",expression);
        return(0.0);
    }
    point.x=FxEvaluateSubexpression(fx_info,pixchannel,x,y,subexpression,&depth,&point.y,exception);
    p=subexpression;
}