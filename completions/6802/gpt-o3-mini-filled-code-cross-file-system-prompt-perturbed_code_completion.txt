{
  char subexpr[MagickPathExtent];
  size_t inner_level = 0;
  char open, close;
  /* Advance past the 'p' */
  p++;
  /* Determine the type of delimiter */
  if (*p == '{')
  {
    open = '{';
    close = '}';
  }
  else if (*p == '[')
  {
    open = '[';
    close = ']';
  }
  else
  {
    /* If no valid delimiter is found, simply return 0.0 */
    (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
      "MissingSubexpressionDelimiter","`%s'",p);
    return(0.0);
  }
  inner_level = 1;
  q = subexpr;
  p++;  /* Skip the opening delimiter */
  while ((*p != '\0') && (inner_level != 0))
  {
    if (*p == open)
      inner_level++;
    else if (*p == close)
      inner_level--;
    if (inner_level != 0)
      *q++ = *p++;
  }
  *q = '\0';
  if (*p == close)
    p++;  /* Skip the closing delimiter */
  /* Evaluate the subexpression and assign the two returned values to point.x and point.y */
  alpha = FxEvaluateSubexpression(fx_info, pixchannel, x, y, subexpr,
                                  &depth, &beta, exception);
  point.x = alpha;
  point.y = beta;
}