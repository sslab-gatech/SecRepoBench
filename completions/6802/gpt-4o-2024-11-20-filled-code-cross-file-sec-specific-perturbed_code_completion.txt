if (*p == '{' || *p == '[')
          {
            char *sub_ptr = subexpression;
            char open_char = *p;
            char close_char = (open_char == '{') ? '}' : ']';
            level = 1;
            p++; // Move past the opening character

            while (*p != '\0' && level > 0)
            {
              if (*p == open_char)
                level++;
              else if (*p == close_char)
                level--;

              if (level > 0)
              {
                if ((size_t)(sub_ptr - subexpression) >= MagickPathExtent - 1)
                {
                  (void) ThrowMagickException(exception, GetMagickModule(),
                    OptionError, "SubexpressionTooLarge", "`%s'", expression);
                  return 0.0;
                }
                *sub_ptr++ = *p;
              }
              p++;
            }

            *sub_ptr = '\0'; // Null-terminate the subexpression

            if (level != 0)
            {
              (void) ThrowMagickException(exception, GetMagickModule(),
                OptionError, "UnbalancedBrackets", "`%s'", expression);
              return 0.0;
            }

            alpha = FxEvaluateSubexpression(fx_info, pixchannel, x, y, subexpression,
              &depth, &beta, exception);
            point.x = alpha;
            point.y = beta;
          }