if (*p == '{' || *p == '[')
          {
            char *start = p;
            level = (*p == '{') ? 1 : 0; // Initialize level based on the opening bracket type
            q = subexpression;

            // Extract the subexpression
            for (p++; *p != '\0'; p++)
            {
              if (*p == '{' || *p == '[')
                level++;
              else if (*p == '}' || *p == ']')
              {
                level--;
                if (level == 0)
                  break;
              }
              *q++ = *p;
            }
            *q = '\0'; // Null-terminate the subexpression

            // Ensure we do not overflow the subexpression buffer
            if (q - subexpression >= MagickPathExtent)
            {
              (void) ThrowMagickException(exception, GetMagickModule(), OptionError,
                "SubexpressionTooLong", "`%s'", start);
              return 0.0;
            }

            // Evaluate the subexpression
            alpha = FxEvaluateSubexpression(fx_info, pixchannel, x, y, subexpression, &depth, &beta, exception);
            point.x = alpha; // Assign evaluated x value
            point.y = beta;  // Assign evaluated y value
            p++; // Move past the closing bracket
          }