{
  char delimiter_open, delimiter_close;
  p++;  /* skip the 'p' */
  if (*p == '{')
  {
    delimiter_open = '{';
    delimiter_close = '}';
  }
  else if (*p == '[')
  {
    delimiter_open = '[';
    delimiter_close = ']';
  }
  else
  {
    /* If no valid delimiter is found, leave point unchanged. */
    p++;
    break;
  }
  p++;  /* move past the opening delimiter */
  level = 1;
  q = subexpression;
  while ((*p != '\0') && (level > 0))
  {
    if (*p == delimiter_open)
      level++;
    else if (*p == delimiter_close)
    {
      level--;
      if (level == 0)
      {
        p++;  /* skip the closing delimiter */
        break;
      }
    }
    /* Prevent buffer overflow */
    if ((size_t)(q - subexpression) < (MagickPathExtent - 1))
      *q++ = *p++;
    else
      break;
  }
  *q = '\0';
  alpha = FxEvaluateSubexpression(fx_info, pixchannel, x, y, subexpression,
                                  &depth, &beta, exception);
  point.x = alpha;
  point.y = beta;
}