if ((*p == 'p') && (isalpha((int) ((unsigned char) *(p+1))) == 0))
  {
    // Extract a subexpression enclosed in curly braces '{}' or square brackets '[]' from the input expression.
    // Evaluate the subexpression using FxEvaluateSubexpression and assign its result to point.x and point.y.
    // Update the expression pointer 'p' to continue processing the rest of the expression.
    // <MASK>
    {
      ssize_t
        length;

      const char
        *q;

      length=GetImageListLength(fx_info->images);
      while (i < 0)
        i+=(ssize_t) length;
      if (length!= 0)
        i%=length;
      image=GetImageFromList(fx_info->images,i);
      if (image == (Image *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            "NoSuchImage","`%s'",expression);
          return(0.0);
        }
      point.x=(double) x;
      point.y=(double) y;
      q=expression;
      while (*q!= '\0')
        {
          if (*q == '{')
            {
              q++;
              while (*q!= '\0')
                {
                  if (*q == '}')
                    break;
                  if (*q == ',')
                    {
                      q++;
                      break;
                    }
                  q++;
                }
              if (*q == '\0')
                break;
              p=q;
              alpha=FxEvaluateSubexpression(fx_info,pixchannel,x,y,p,
                &depth,&beta,exception);
              point.x=alpha;
              q=p;
            }
          else
            if (*q == '[')
              {
                q++;
                while (*q!= '\0')
                  {
                    if (*q == ']')
                      break;
                    if (*q == ',')
                      {
                        q++;
                        break;
                      }
                    q++;
                  }
                if (*q == '\0')
                  break;
                p=q;
                alpha=FxEvaluateSubexpression(fx_info,pixchannel,x,y,p,
                  &depth,&beta,exception);
                point.y=alpha;
                q=p;
              }
          q++;
        }
    }
  }