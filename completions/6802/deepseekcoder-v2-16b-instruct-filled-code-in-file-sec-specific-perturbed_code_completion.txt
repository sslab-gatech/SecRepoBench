FxPrecedence
    precedence;

  precedence=UndefinedPrecedence;
  while (*expression != '\0')
  {
    switch (*expression)
    {
      case '!':
        if (precedence == UndefinedPrecedence)
          precedence=BitwiseComplementPrecedence;
        break;
      case '^':
        if (precedence == UndefinedPrecedence)
          precedence=ExponentPrecedence;
        break;
      case 'E':
        if (precedence == UndefinedPrecedence)
          precedence=ExponentialNotationPrecedence;
        break;
      case '*':
      case '/':
      case '%':
        if (precedence == UndefinedPrecedence)
          precedence=MultiplyPrecedence;
        break;
      case '+':
      case '-':
        if (precedence == UndefinedPrecedence)
          precedence=AdditionPrecedence;
        break;
      case '<':
      case '>':
        if (precedence == UndefinedPrecedence)
          precedence=RelationalPrecedence;
        break;
      case '=':
        if (precedence == UndefinedPrecedence)
          precedence=EquivalencyPrecedence;
        break;
      case '&':
        if (precedence == UndefinedPrecedence)
          precedence=BitwiseAndPrecedence;
        break;
      case '|':
        if (precedence == UndefinedPrecedence)
          precedence=BitwiseOrPrecedence;
        break;
      case '~':
        if (precedence == UndefinedPrecedence)
          precedence=LogicalAndPrecedence;
        break;
      case '?':
        if (precedence == UndefinedPrecedence)
          precedence=TernaryPrecedence;
        break;
      case ':':
        if (precedence == TernaryPrecedence)
          precedence=TernaryPrecedence;
        break;
      case ',':
        if (precedence == UndefinedPrecedence)
          precedence=CommaPrecedence;
        break;
      case ';':
      case '\n':
      case '\r':
      case '\t':
      case ' ':
        if (precedence == UndefinedPrecedence)
          precedence=SeparatorPrecedence;
        break;
      case '(':
        if (precedence == UndefinedPrecedence)
          precedence=NullPrecedence;
        break;
      case ')':
        if (precedence == NullPrecedence)
          precedence=UndefinedPrecedence;
        break;
      case '[':
      case ']':
        if (precedence == NullPrecedence)
          precedence=UndefinedPrecedence;
        break;
      case '{':
      case '}':
        if (precedence == NullPrecedence)
          precedence=UndefinedPrecedence;
        break;
      case '<':
      case '>':
        if (precedence == RelationalPrecedence)
          precedence=ShiftPrecedence;
        break;
      default:
        if (isalpha((int) ((unsigned char) *expression)) != 0)
          {
            char
              symbol[MagickPathExtent];

            register ssize_t
              i;

            for (i=0; isalnum((int) ((unsigned char) expression[i])) != 0; i++) ;
            if (i == 0)
              (void) ThrowMagickException(exception,GetMagickModule(),
                OptionError,"InvalidSymbol","`%s'",expression);
            (void) CopyMagickString(symbol,expression,i);
            symbol[i]='\0';
            if (LocaleCompare(symbol,"and") == 0)
              precedence=LogicalAndPrecedence;
            else
              if (LocaleCompare(symbol,"or") == 0)
                precedence=LogicalOrPrecedence;
              else
                if (LocaleCompare(symbol,"not") == 0)
                  precedence=BitwiseComplementPrecedence;
                else
                  if (LocaleCompare(symbol,"xor") == 0)
                    precedence=BitwiseOrPrecedence;
                  else
                    if (LocaleCompare(symbol,"shl") == 0)
                      precedence=ShiftPrecedence;
                    else
                      if (LocaleCompare(symbol,"shr") == 0)
                        precedence=ShiftPrecedence;
                      else
                        if (LocaleCompare(symbol,"mod") == 0)
                          precedence=MultiplyPrecedence;
                        else
                          if (LocaleCompare(symbol,"div") == 0)
                            precedence=MultiplyPrecedence;
                          else
                            precedence=UndefinedPrecedence;
            expression+=i;
            continue;
          }
        break;
    }
    expression++;
  }
  return(expression);
}

static double FxEvaluateSubexpression(FxInfo *fx_info,const PixelChannel pixchannel,
  const ssize_t x,const ssize_t y,const char *expression,size_t *depth,
  double *alpha,ExceptionInfo *exception)
{
  char
    *p,
    *q,
    subexpression[MagickPathExtent];

  double
    beta,
    value;

  size_t
    level;

  level=0;
  p=subexpression;
  while ((*expression != '\0') &&
         ((level != 1) || (strchr(")",(int) *expression) == (char *) NULL)))
  {
    if (strchr("(",(int) *expression) != (char *) NULL)
      level++;
    else
      if (strchr(")",(int) *expression) != (char *) NULL)
        level--;
    *p++=(*expression++);
  }
  *p='\0';
  if (*expression == '\0')
    (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
      "UnbalancedParenthesis","`%s'",subexpression);
  expression++;
  value=FxEvaluateExpression(fx_info,alpha,exception);
  if (LocaleCompare(subexpression,"-") == 0)
    return(-value);
  if (LocaleCompare(subexpression,"+") == 0)
    return(value);
  if (LocaleCompare(subexpression,"!") == 0)
    return(!(value != 0));
  if (LocaleCompare(subexpression,"~") == 0)
    return(~((MagickOffsetType) value));
  if (LocaleCompare(subexpression,"^") == 0)
    {
      beta=FxEvaluateExpression(fx_info,alpha,exception);
      return(pow(value,beta));
    }
  if (LocaleCompare(subexpression,"**") == 0)
    {
      beta=FxEvaluateExpression(fx_info,alpha,exception);
      return(pow(value,beta));
    }
  if (LocaleCompare(subexpression,"*") == 0)
    {
      beta=FxEvaluateExpression(fx_info,alpha,exception);
      return(value*beta);
    }
  if (LocaleCompare(subexpression,"/") == 0)
    {
      beta=FxEvaluateExpression(fx_info,alpha,exception);
      if (beta == 0.0)
        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
          "DivideByZeroError","`%s'",subexpression);
      return(value/beta);
    }
  if (LocaleCompare(subexpression,"%") == 0)
    {
      beta=FxEvaluateExpression(fx_info,alpha,exception);
      if (beta == 0.0)
        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
          "DivideByZeroError","`%s'",subexpression);
      return(fmod(value,beta));
    }
  if (LocaleCompare(subexpression,"+") == 0)
    {
      beta=FxEvaluateExpression(fx_info,alpha,exception);
      return(value+beta);
    }
  if (LocaleCompare(subexpression,"-") == 0)
    {
      beta=FxEvaluateExpression(fx_info,alpha,exception);
      return(value-beta);
    }
  if (LocaleCompare(subexpression,"<<") == 0)
    {
      beta=FxEvaluateExpression(fx_info,alpha,exception);
      return((MagickOffsetType) value << (MagickOffsetType) beta);
    }
  if (LocaleCompare(subexpression,">>") == 0)
    {
      beta=FxEvaluateExpression(fx_info,alpha,exception);
      return((MagickOffsetType) value >> (MagickOffsetType) beta);
    }
  if (LocaleCompare(subexpression,"<") == 0)
    {
      beta=FxEvaluateExpression(fx_info,alpha,exception);
      return(value < beta);
    }
  if (LocaleCompare(subexpression,">") == 0)
    {
      beta=FxEvaluateExpression(fx_info,alpha,exception);
      return(value > beta);
    }
  if (LocaleCompare(subexpression,"<=") == 0)
    {
      beta=FxEvaluateExpression(fx_info,alpha,exception);
      return(value <= beta);
    }
  if (LocaleCompare(subexpression,">=") == 0)
    {
      beta=FxEvaluateExpression(fx_info,alpha,exception);
      return(value >= beta);
    }
  if (LocaleCompare(subexpression,"==") == 0)
    {
      beta=FxEvaluateExpression(fx_info,alpha,exception);
      return(value == beta);
    }
  if (LocaleCompare(subexpression,"!=") == 0)
    {
      beta=FxEvaluateExpression(fx_info,alpha,exception);
      return(value != beta);
    }
  if (LocaleCompare(subexpression,"&&") == 0)
    {
      beta=FxEvaluateExpression(fx_info,alpha,exception);
      return(value && beta);
    }
  if (LocaleCompare(subexpression,"||") == 0)
    {
      beta=FxEvaluateExpression(fx_info,alpha,exception);
      return(value || beta);
    }
  if (LocaleCompare(subexpression,"?") == 0)
    {
      beta=FxEvaluateExpression(fx_info,alpha,exception);
      if (value != 0.0)
        return(beta);
      q=expression;
      while ((*q != '\0') && (*q != ':'))
        q++;
      if (*q == '\0')
        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
          "UnbalancedConditional","`%s'",subexpression);
      expression=q+1;
      q=expression;
      while ((*q != '\0') && (*q != ':'))
        q++;
      if (*q == '\0')
        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
          "UnbalancedConditional","`%s'",subexpression);
      *q='\0';
      q++;
      return(FxEvaluateSubexpression(fx_info,pixchannel,x,y,expression,depth,
        alpha,exception));
    }
  if (LocaleCompare(subexpression,":") == 0)
    {
      beta=FxEvaluateExpression(fx_info,alpha,exception);
      if (value != 0.0)
        return(beta);
      return(value);
    }
  if (LocaleCompare(subexpression,",") == 0)
    {
      beta=FxEvaluateExpression(fx_info,alpha,exception);
      return(beta);
    }
  if (LocaleCompare(subexpression,";") == 0)
    {
      beta=FxEvaluateExpression(fx_info,alpha,exception);
      return(beta);
    }
  if (LocaleCompare(subexpression,"[") == 0)
    {
      q=expression;
      while ((*q != '\0') && (*q != ']'))
        q++;
      if (*q == '\0')
        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
          "UnbalancedBrackets","`%s'",subexpression);
      *q='\0';
      q++;
      value=FxEvaluateSubexpression(fx_info,pixchannel,x,y,expression,depth,
        alpha,exception);
      expression=q;
      beta=FxEvaluateSubexpression(fx_info,pixchannel,x,y,expression,depth,
        alpha,exception);
      return(value);
    }
  if (LocaleCompare(subexpression,"{") == 0)
    {
      q=expression;
      while ((*q != '\0') && (*q != '}'))
        q++;
      if (*q == '\0')
        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,