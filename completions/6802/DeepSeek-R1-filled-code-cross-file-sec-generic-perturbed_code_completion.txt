if (*(p+1) == '{' || *(p+1) == '[')
  {
    char
      start_delimiter,
      end_delimiter;

    start_delimiter=*(p+1);
    end_delimiter=(start_delimiter == '{') ? '}' : ']';
    p+=2;
    level=1;
    q=subexpression;
    while ((*p != '\0') && (level > 0))
    {
      if (*p == start_delimiter)
        level++;
      else
        if (*p == end_delimiter)
          {
            level--;
            if (level == 0)
              break;
          }
      if (level > 0)
        *q++=(*p);
      p++;
    }
    *q='\0';
    p++;
    if (*p == '.')
      p++;
    {
      char
        *comma;

      comma=strchr(subexpression,',');
      if (comma != (char *) NULL)
        {
          *comma='\0';
          alpha=FxEvaluateSubexpression(fx_info,pixchannel,x,y,subexpression,
            &depth,&beta,exception);
          point.x=alpha;
          alpha=FxEvaluateSubexpression(fx_info,pixchannel,x,y,comma+1,
            &depth,&beta,exception);
          point.y=alpha;
        }
      else
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            "InvalidPointExpression","`%s'",expression);
          return(0.0);
        }
    }
  }