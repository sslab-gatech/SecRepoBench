{
  /*
    Parse subexpression for p{...} or p[...]
  */
  p++;
  if ((*p == '{') || (*p == '['))
    {
      int
        sublevel = 1;

      char
        *subq = subexpression;

      char
        open_ch = *p,
        close_ch = (*p == '{') ? '}' : ']';

      p++; /* skip '{' or '[' */
      while ((*p != '\0') && (sublevel > 0))
      {
        if (*p == open_ch)
          sublevel++;
        else if (*p == close_ch)
          sublevel--;
        if (sublevel > 0)
          *subq++ = *p;
        p++;
      }
      *subq = '\0';
      /*
        Evaluate subexpression for point.x and point.y
      */
      {
        char *comma = strchr(subexpression, ',');
        if (comma != (char *) NULL)
        {
          *comma = '\0';
          point.x = FxEvaluateSubexpression(fx_info, pixchannel, x, y, subexpression, &depth, &beta, exception);
          point.y = FxEvaluateSubexpression(fx_info, pixchannel, x, y, comma+1, &depth, &beta, exception);
        }
        else
        {
          point.x = FxEvaluateSubexpression(fx_info, pixchannel, x, y, subexpression, &depth, &beta, exception);
          point.y = (double) y;
        }
      }
    }
  else
    {
      point.x = (double) x;
      point.y = (double) y;
    }
}