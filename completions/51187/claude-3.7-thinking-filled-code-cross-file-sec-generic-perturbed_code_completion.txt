const std::string* word = &in_word;
  const std::string* desc = inputdesc;
  std::string* word_copy = nullptr;
  std::string* desc_copy = nullptr;
  
  // Handle ignored characters or complex prefixes
  if ((!ignorechars.empty() && in_word.find_first_of(ignorechars) != std::string::npos) || complexprefixes) {
    word_copy = new std::string(in_word);
    
    // Remove ignored characters if necessary
    if (!ignorechars.empty() && word_copy->find_first_of(ignorechars) != std::string::npos) {
      std::string temp;
      temp.reserve(word_copy->size());
      for (size_t i = 0; i < word_copy->size(); ++i) {
        if (ignorechars.find((*word_copy)[i]) == std::string::npos) {
          temp.push_back((*word_copy)[i]);
        }
      }
      *word_copy = temp;
    }
    
    // Reverse the word if complex prefixes are enabled
    if (complexprefixes) {
      std::reverse(word_copy->begin(), word_copy->end());
    }
    
    word = word_copy;
  }
  
  // Handle description if provided and aliasing is not used
  if (inputdesc && aliasm.empty()) {
    desc_copy = new std::string(*inputdesc);
    
    // Reverse the description if complex prefixes are enabled
    if (complexprefixes) {
      std::reverse(desc_copy->begin(), desc_copy->end());
    }
    
    desc = desc_copy;
  }