// If the word contains ignored characters or complex prefixes are being handled:
//   - Create a new copy of the word and remove ignored characters if necessary.
//   - Reverse the word if complex prefixes are enabled.
//   - If a description is provided and aliasing is not used, create a copy and reverse it if complex prefixes are enabled.
// Update the word and description pointers to point to the new copies.
std::string* word_copy = NULL;
std::string* desc_copy = NULL;
if (ignorechars_utf16.size() > 0 || complexprefixes) {
  std::string new_word(in_word);
  if (ignorechars_utf16.size() > 0) {
    if (utf8) {
      std::vector<w_char> w;
      u8_u16(w, new_word);
      for (size_t i = 0; i < w.size(); ++i) {
        bool found = false;
        for (size_t j = 0; j < ignorechars_utf16.size(); ++j) {
          if (w[i] == ignorechars_utf16[j]) {
            found = true;
            break;
          }
        }
        if (!found)
          new_word += (char)w[i];
      }
    } else {
      for (size_t i = 0; i < new_word.size(); ++i) {
        bool found = false;
        for (size_t j = 0; j < ignorechars.size(); ++j) {
          if (new_word[i] == ignorechars[j]) {
            found = true;
            break;
          }
        }
        if (!found)
          new_word += new_word[i];
      }
    }
  }
  if (complexprefixes) {
    if (utf8)
      reverseword_utf(new_word);
    else
      reverseword(new_word);
  }
  word_copy = new std::string(new_word);
  if (inputdesc && aliasm.empty()) {
    std::string new_desc(*inputdesc);
    if (complexprefixes) {
      if (utf8)
        reverseword_utf(new_desc);
      else
        reverseword(new_desc);
    }
    desc_copy = new std::string(new_desc);
  }
}