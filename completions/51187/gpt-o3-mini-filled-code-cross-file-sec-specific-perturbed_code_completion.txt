std::string* word = nullptr;
std::string* word_copy = nullptr;
std::string* desc = nullptr;
std::string* desc_copy = nullptr;

// Determine if complex prefix handling is enabled.
// (In practice this might be set from a configuration flag or member variable.)
bool complexPrefixesEnabled = false;
#ifdef COMPLEX_PREFIXES_ENABLED
complexPrefixesEnabled = true;
#endif

// Create a modifiable copy of the input word.
std::string modified_word = in_word;
// Remove any ignored characters if the ignore pattern is set.
if (!this->ignore_chars.empty()) {
    modified_word.erase(
        std::remove_if(modified_word.begin(), modified_word.end(),
                       [this](char c) { return this->ignore_chars.find(c) != std::string::npos; }),
        modified_word.end());
}
// If complex prefixes are enabled, reverse the word.
if (complexPrefixesEnabled) {
    std::reverse(modified_word.begin(), modified_word.end());
}
// Allocate a new copy for the word.
word_copy = new std::string(modified_word);
word = word_copy;

// Process the description pointer, if provided.
if (inputdesc) {
    // If aliasing is not used, make a copy and reverse if necessary.
    if (aliasm.empty()) {
        std::string modified_desc = *inputdesc;
        if (complexPrefixesEnabled) {
            std::reverse(modified_desc.begin(), modified_desc.end());
        }
        desc_copy = new std::string(modified_desc);
        desc = desc_copy;
    } else {
        // When aliasing is used, use the original description.
        desc = const_cast<std::string*>(inputdesc);
    }
}