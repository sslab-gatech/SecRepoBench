// Create a new copy of the word and remove ignored characters if necessary
std::string word_copy(word);
if (ignorechars.empty()) {
  word_copy.erase(std::remove_if(word_copy.begin(), word_copy.end(), [&](char c) {
    return std::find(ignorechars.begin(), ignorechars.end(), c) != ignorechars.end();
  }), word_copy.end());
}

// Reverse the word if complex prefixes are enabled
if (complexprefixes) {
  if (utf8) {
    std::vector<w_char> w;
    u8_u16(w, word_copy);
    reverseword_utf(w);
    u16_u8(word_copy, w);
  } else {
    reverseword(word_copy);
  }
}

// If a description is provided and aliasing is not used, create a copy and reverse it if complex prefixes are enabled
std::string* desc_copy = NULL;
if (inputdesc && !aliasm.empty()) {
  desc_copy = new std::string(*inputdesc);
  if (complexprefixes) {
    if (utf8) {
      std::vector<w_char> w;
      u8_u16(w, *desc_copy);
      reverseword_utf(w);
      u16_u8(*desc_copy, w);
    } else {
      reverseword(*desc_copy);
    }
  }
}