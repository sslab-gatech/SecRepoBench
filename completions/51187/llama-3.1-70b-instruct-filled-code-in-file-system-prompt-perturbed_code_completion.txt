// If the word contains ignored characters or complex prefixes are being handled:
//   - Create a new copy of the word and remove ignored characters if necessary.
//   - Reverse the word if complex prefixes are enabled.
//   - If a description is provided and aliasing is not used, create a copy and reverse it if complex prefixes are enabled.
// Update the word and description pointers to point to the new copies.
std::string* word_copy = NULL;
std::string* desc_copy = NULL;
if (ignorechars_utf16.size() > 0 || complexprefixes) {
  std::string st;
  std::vector<w_char> w;
  if (utf8) {
    u8_u16(w, in_word);
    if (ignorechars_utf16.size() > 0) {
      for (size_t i = 0; i < w.size(); ++i) {
        bool found = false;
        for (size_t j = 0; j < ignorechars_utf16.size(); ++j) {
          if (w[i] == ignorechars_utf16[j]) {
            found = true;
            break;
          }
        }
        if (!found)
          st.push_back((char)w[i]);
      }
    } else
      u16_u8(st, w);
  } else {
    if (ignorechars.size() > 0) {
      for (size_t i = 0; i < in_word.size(); ++i) {
        bool found = false;
        for (size_t j = 0; j < ignorechars.size(); ++j) {
          if (in_word[i] == ignorechars[j]) {
            found = true;
            break;
          }
        }
        if (!found)
          st.push_back(in_word[i]);
      }
    } else
      st = in_word;
  }
  if (complexprefixes) {
    if (utf8)
      reverseword_utf(st);
    else
      reverseword(st);
  }
  word_copy = new std::string(st);
  if (inputdesc && aliasm.empty()) {
    st = *inputdesc;
    if (complexprefixes) {
      if (utf8)
        reverseword_utf(st);
      else
        reverseword(st);
    }
    desc_copy = new std::string(st);
  }
}