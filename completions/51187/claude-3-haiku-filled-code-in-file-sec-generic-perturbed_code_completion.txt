// If the word contains ignored characters or complex prefixes are being handled:
//   - Create a new copy of the word and remove ignored characters if necessary.
//   - Reverse the word if complex prefixes are enabled.
//   - If a description is provided and aliasing is not used, create a copy and reverse it if complex prefixes are enabled.
// Update the word and description pointers to point to the new copies.
std::string* word_copy = nullptr;
std::string* desc_copy = nullptr;
if (!ignorechars.empty() || complexprefixes) {
    word_copy = new std::string(*word);
    if (!ignorechars.empty()) {
        std::string::iterator it = std::remove_if(word_copy->begin(), word_copy->end(),
                                                 [this](char c) {
                                                     return std::find(ignorechars.begin(), ignorechars.end(), c) != ignorechars.end() ||
                                                            (utf8 && std::find(ignorechars_utf16.begin(), ignorechars_utf16.end(), c) != ignorechars_utf16.end());
                                                 });
        word_copy->erase(it, word_copy->end());
    }
    if (complexprefixes) {
        if (utf8)
            reverseword_utf(*word_copy);
        else
            reverseword(*word_copy);
    }
    if (desc && aliasm.empty()) {
        desc_copy = new std::string(*desc);
        if (complexprefixes) {
            if (utf8)
                reverseword_utf(*desc_copy);
            else
                reverseword(*desc_copy);
        }
    }
    word = word_copy;
    if (desc_copy)
        desc = desc_copy;
}