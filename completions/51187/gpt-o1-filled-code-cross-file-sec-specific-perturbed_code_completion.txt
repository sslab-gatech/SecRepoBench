// create local pointers for word and description
  word_copy = nullptr;
  desc_copy = nullptr;
  std::string* word = nullptr;
  std::string* desc = nullptr;

  // Example logic to detect if ignored characters should be removed or if complex prefixes are enabled
  bool needsIgnoredRemoval = false; // set this to true if your dictionary settings require ignoring chars
  bool complexPrefixes = false;     // set this to true if complex prefix handling is enabled

  // create a copy of the input word if needed
  if (needsIgnoredRemoval || complexPrefixes) {
    word_copy = new std::string(in_word);
    // remove ignored characters if needed
    if (needsIgnoredRemoval) {
      // remove_ignored_chars(*word_copy);
    }
    // reverse the word if complex prefixes are handled
    if (complexPrefixes) {
      std::reverse(word_copy->begin(), word_copy->end());
    }
    word = word_copy;
  } else {
    // otherwise point directly to the input word
    word = const_cast<std::string*>(&in_word);
  }

  // create or reuse description pointer as needed
  if (inputdesc) {
    if (!aliasm.empty()) {
      // use the provided description directly if aliasing is in use
      desc = const_cast<std::string*>(inputdesc);
    } else {
      // otherwise create a copy
      desc_copy = new std::string(*inputdesc);
      // reverse it as well if we're handling complex prefixes
      if (complexPrefixes) {
        std::reverse(desc_copy->begin(), desc_copy->end());
      }
      desc = desc_copy;
    }
  } else {
    desc = nullptr;
  }