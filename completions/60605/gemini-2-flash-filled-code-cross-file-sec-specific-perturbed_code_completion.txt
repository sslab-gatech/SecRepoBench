(packet->content_disposition_line.ptr[packet->content_disposition_line.len - 1] != '\"')) {
	    flow->http.filename = ndpi_malloc(attachment_filename_len+1);

	    if(flow->http.filename != NULL) {
	      strncpy(flow->http.filename, (char*)packet->content_disposition_line.ptr+attachment_len+1, attachment_filename_len-1);
	      flow->http.filename[attachment_filename_len-1] = '\0';
	    }
	  } else if(attachment_filename_len > 1) {
	    //case: filename="file_name"
	    flow->http.filename = ndpi_malloc(attachment_filename_len-1);

	    if(flow->http.filename != NULL) {
              /* CWE-1284: Improper Validation of Array Index
               *
               * The code calculates the length of the filename by subtracting 2 from
               * attachment_filename_len. However, if attachment_filename_len is 0 or 1,
               * this subtraction will result in a negative value, which when converted
               * to an unsigned integer, becomes a very large positive number. This large
               * value is then used in strncpy, potentially leading to a buffer overflow.
               *
               * To mitigate this vulnerability, we need to ensure that
               * attachment_filename_len is always greater than 1 before performing the
               * subtraction.
               */
              strncpy(flow->http.filename, (char*)packet->content_disposition_line.ptr+attachment_len+1, attachment_filename_len-2);
	      flow->http.filename[attachment_filename_len-2] = '\0';
	    }
	  }