if(packet->content_disposition_line.ptr[packet->content_disposition_line.len - 1] == '\"') {
  if(packet->content_disposition_line.len - attachment_len - 2 > ATTACHMENT_LEN) {
    for(i = 0; binary_file_ext[i]!= NULL; i++) {
      /* Use memcmp in case content-disposition contains binary data */
      if(memcmp(&packet->content_disposition_line.ptr[attachment_len + 1],
                binary_file_ext[i], ATTACHMENT_LEN) == 0) {
        char str[64];

        snprintf(str, sizeof(str), "Found file extn %s", binary_file_ext[i]);
        flow->guessed_category = flow->category = NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT;
        ndpi_set_binary_application_transfer(ndpi_struct, flow, str);
        NDPI_LOG_INFO(ndpi_struct, "found executable HTTP transfer");
        return(flow->category);
      }
    }
  }
} else {
  if(packet->content_disposition_line.len - attachment_len - 1 > ATTACHMENT_LEN) {
    for(i = 0; binary_file_ext[i]!= NULL; i++) {
      /* Use memcmp in case content-disposition contains binary data */
      if(memcmp(&packet->content_disposition_line.ptr[attachment_len + 1],
                binary_file_ext[i], ATTACHMENT_LEN) == 0) {
        char str[64];

        snprintf(str, sizeof(str), "Found file extn %s", binary_file_ext[i]);
        flow->guessed_category = flow->category = NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT;
        ndpi_set_binary_application_transfer(ndpi_struct, flow, str);
        NDPI_LOG_INFO(ndpi_struct, "found executable HTTP transfer");
        return(flow->category);
      }
    }
  }
}

flow->http.filename = ndpi_malloc(attachment_filename_len+1);

if(flow->http.filename!= NULL) {
  if(packet->content_disposition_line.ptr[packet->content_disposition_line.len - 1] == '\"') {
    strncpy(flow->http.filename, (char*)packet->content_disposition_line.ptr+attachment_len+1, attachment_filename_len-1);
  } else {
    strncpy(flow->http.filename, (char*)packet->content_disposition_line.ptr+attachment_len+1, attachment_filename_len);
  }
  flow->http.filename[attachment_filename_len] = '\0';
}