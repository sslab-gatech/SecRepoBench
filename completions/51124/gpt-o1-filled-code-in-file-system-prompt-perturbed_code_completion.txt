if (cond[cond_index] != ']') {
  // If not a bracket expression, characters must match exactly
  if (cond[cond_index] != strip[i]) {
    HUNSPELL_WARNING(stderr,
                     "warning: line %d: incompatible stripping characters and condition\n",
                     linenum);
    return 0;
  }
} else {
  // Found a bracket expression, so find its matching '['
  int close_br = cond_index;
  int open_br = close_br;
  while (open_br >= 0 && cond[open_br] != '[') {
    open_br--;
  }
  if (open_br < 0) {
    // No matching '['
    HUNSPELL_WARNING(stderr,
                     "error: line %d: missing [ in condition:\n%s\n",
                     linenum, cond.c_str());
    return 0;
  }

  // Check if the bracket expression is negated (has '^' after '[')
  neg = 0;
  if ((open_br + 1 < condl) && (cond[open_br + 1] == '^')) {
    neg = 1;
  }

  // Determine whether strip[i] is in the bracketed set
  in = 0;
  for (int c = open_br + 1 + neg; c < close_br; c++) {
    if (cond[c] == ']') {
      // Should not go beyond the bracket
      break;
    }
    if (cond[c] == strip[i]) {
      in = 1;
      break;
    }
  }

  // If membership doesn't match negation status, it's incompatible
  if ((!neg && !in) || (neg && in)) {
    HUNSPELL_WARNING(stderr,
                     "warning: line %d: incompatible stripping characters and condition\n",
                     linenum);
    return 0;
  }

  // Skip the entire bracket expression in the pattern.
  // The for loop will do an additional 'cond_index--',
  // so setting cond_index = open_br repositions just before '[' on next iteration.
  cond_index = open_br;
}