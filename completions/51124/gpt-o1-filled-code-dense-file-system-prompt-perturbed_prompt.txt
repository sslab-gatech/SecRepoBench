Below is the content of a C/C++ function where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
int AffixMgr::redundant_condition(char ft,
                                  const std::string& strip,
                                  const std::string& cond,
                                  int linenum) {
  int stripl = strip.size(), condl = cond.size();
  int i, cond_index;
  int neg;
  int in;
  if (ft == 'P') {  // prefix
    if (strip.compare(0, condl, cond) == 0)
      return 1;
    if (utf8) {
    } else {
      for (i = 0, cond_index = 0; (i < stripl) && (cond_index < condl); i++, cond_index++) {
        if (cond[cond_index] != '[') {
          if (cond[cond_index] != strip[i]) {
            HUNSPELL_WARNING(stderr,
                             "warning: line %d: incompatible stripping "
                             "characters and condition\n",
                             linenum);
            return 0;
          }
        } else {
          neg = (cond[cond_index + 1] == '^') ? 1 : 0;
          in = 0;
          do {
            cond_index++;
            if (strip[i] == cond[cond_index])
              in = 1;
          } while ((cond_index < (condl - 1)) && (cond[cond_index] != ']'));
          if (cond_index == (condl - 1) && (cond[cond_index] != ']')) {
            HUNSPELL_WARNING(stderr,
                             "error: line %d: missing ] in condition:\n%s\n",
                             linenum, cond.c_str());
            return 0;
          }
          if ((!neg && !in) || (neg && in)) {
            HUNSPELL_WARNING(stderr,
                             "warning: line %d: incompatible stripping "
                             "characters and condition\n",
                             linenum);
            return 0;
          }
        }
      }
      if (cond_index >= condl)
        return 1;
    }
  } else {  // suffix
    if ((stripl >= condl) && strip.compare(stripl - condl, std::string::npos, cond) == 0)
      return 1;
    if (utf8) {
    } else {
      for (i = stripl - 1, cond_index = condl - 1; (i >= 0) && (cond_index >= 0); i--, cond_index--) {
        // Check if the current character in the condition is a ']'.
        // If it's not, compare the current characters of the strip and condition.
        // If they differ, output a warning and return 0.
        // If it is a ']', check if the strip character is within the character set defined in the condition.
        // Iterate backwards to find the matching '[' for the ']'.
        // If the corresponding '[' is not found, output an error and return 0.
        // Determine if the character set is negated by checking if the next character after '[' is '^'.
        // Check if the strip character's presence in the set matches the negation status.
        // If not, output a warning and return 0.
        // <MASK>
      }
      if (cond_index < 0)
        return 1;
    }
  }
  return 0;
}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/hunspell/affentry.cxx
inline int PfxEntry::test_condition(const std::string& s) {
  size_t st = 0;
  size_t pos = std::string::npos;  // group with pos input position
  bool neg = false;        // complementer
  bool ingroup = false;    // character in the group
  if (numconds == 0)
    return 1;
  char* p = c.conds;
  while (1) {
    switch (*p) {
      case '\0':
        return 1;
      case '[': {
        neg = false;
        ingroup = false;
        p = nextchar(p);
        pos = st;
        break;
      }
      case '^': {
        p = nextchar(p);
        neg = true;
        break;
      }
      case ']': {
        if (bool(neg) == bool(ingroup))
          return 0;
        pos = std::string::npos;
        p = nextchar(p);
        // skip the next character
        if (!ingroup && st < s.size()) {
          ++st;
          while ((opts & aeUTF8) && st < s.size() && (s[st] & 0xc0) == 0x80)
            ++st;
        }
        if (st == s.size() && p)
          return 0;  // word <= condition
        break;
      }
      case '.':
        if (pos == std::string::npos) {  // dots are not metacharacters in groups: [.]
          p = nextchar(p);
          // skip the next character
          ++st;
          while ((opts & aeUTF8) && st < s.size() && (s[st] & 0xc0) == 0x80)
            ++st;
          if (st == s.size() && p)
            return 0;  // word <= condition
          break;
        }
      /* FALLTHROUGH */
      default: {
        if (s[st] == *p) {
          ++st;
          p = nextchar(p);
          if ((opts & aeUTF8) && (s[st - 1] & 0x80)) {  // multibyte
            while (p && (*p & 0xc0) == 0x80) {          // character
              if (*p != s[st]) {
                if (pos == std::string::npos)
                  return 0;
                st = pos;
                break;
              }
              p = nextchar(p);
              ++st;
            }
            if (pos != std::string::npos && st != pos) {
              ingroup = true;
              while (p && *p != ']' && ((p = nextchar(p)) != NULL)) {
              }
            }
          } else if (pos != std::string::npos) {
            ingroup = true;
            while (p && *p != ']' && ((p = nextchar(p)) != NULL)) {
            }
          }
        } else if (pos != std::string::npos) {  // group
          p = nextchar(p);
        } else
          return 0;
      }
    }
    if (!p)
      return 1;
  }
}

// the below code fragment can be found in:
// src/hunspell/affixmgr.cxx
int AffixMgr::condlen(const std::string& s) {
  int l = 0;
  bool group = false;
  std::string::const_iterator st = s.begin();
  std::string::const_iterator end = s.end();
  while (st != end) {
    if (*st == '[') {
      group = true;
      l++;
    } else if (*st == ']')
      group = false;
    else if (!group && (!utf8 || (!(*st & 0x80) || ((*st & 0xc0) == 0x80))))
      l++;
    ++st;
  }
  return l;
}

// the below code fragment can be found in:
// src/hunspell/affentry.cxx
inline int SfxEntry::test_condition(const char* st, const char* beg) {
  const char* pos = NULL;  // group with pos input position
  bool neg = false;        // complementer
  bool ingroup = false;    // character in the group
  if (numconds == 0)
    return 1;
  char* p = c.conds;
  st--;
  int i = 1;
  while (1) {
    switch (*p) {
      case '\0':
        return 1;
      case '[':
        p = nextchar(p);
        pos = st;
        break;
      case '^':
        p = nextchar(p);
        neg = true;
        break;
      case ']':
        if (!neg && !ingroup)
          return 0;
        i++;
        // skip the next character
        if (!ingroup) {
          for (; (opts & aeUTF8) && (st >= beg) && (*st & 0xc0) == 0x80; st--)
            ;
          st--;
        }
        pos = NULL;
        neg = false;
        ingroup = false;
        p = nextchar(p);
        if (st < beg && p)
          return 0;  // word <= condition
        break;
      case '.':
        if (!pos) {
          // dots are not metacharacters in groups: [.]
          p = nextchar(p);
          // skip the next character
          for (st--; (opts & aeUTF8) && (st >= beg) && (*st & 0xc0) == 0x80;
               st--)
            ;
          if (st < beg) {  // word <= condition
            if (p)
              return 0;
            else
              return 1;
          }
          if ((opts & aeUTF8) && (*st & 0x80)) {  // head of the UTF-8 character
            st--;
            if (st < beg) {  // word <= condition
              if (p)
                return 0;
              else
                return 1;
            }
          }
          break;
        }
      /* FALLTHROUGH */
      default: {
        if (*st == *p) {
          p = nextchar(p);
          if ((opts & aeUTF8) && (*st & 0x80)) {
            st--;
            while (p && (st >= beg)) {
              if (*p != *st) {
                if (!pos)
                  return 0;
                st = pos;
                break;
              }
              // first byte of the UTF-8 multibyte character
              if ((*p & 0xc0) != 0x80)
                break;
              p = nextchar(p);
              st--;
            }
            if (pos && st != pos) {
              if (neg)
                return 0;
              else if (i == numconds)
                return 1;
              ingroup = true;
              while (p && *p != ']' && ((p = nextchar(p)) != NULL)) {
              }
              st--;
            }
            if (p && *p != ']')
              p = nextchar(p);
          } else if (pos) {
            if (neg)
              return 0;
            else if (i == numconds)
              return 1;
            ingroup = true;
            while (p && *p != ']' && ((p = nextchar(p)) != NULL)) {
            }
            //			if (p && *p != ']') p = nextchar(p);
            st--;
          }
          if (!pos) {
            i++;
            st--;
          }
          if (st < beg && p && *p != ']')
            return 0;      // word <= condition
        } else if (pos) {  // group
          p = nextchar(p);
        } else
          return 0;
      }
    }
    if (!p)
      return 1;
  }
}

// the below code fragment can be found in:
// src/hunspell/affixmgr.cxx
struct hentry* AffixMgr::suffix_check(const std::string& word,
                                      int start,
                                      int len,
                                      int sfxopts,
                                      PfxEntry* ppfx,
                                      const FLAG cclass,
                                      const FLAG needflag,
                                      char in_compound) {
  struct hentry* rv = NULL;
  PfxEntry* ep = ppfx;

  // first handle the special case of 0 length suffixes
  SfxEntry* se = sStart[0];

  while (se) {
    if (!cclass || se->getCont()) {
      // suffixes are not allowed in beginning of compounds
      if ((((in_compound != IN_CPD_BEGIN)) ||  // && !cclass
           // except when signed with compoundpermitflag flag
           (se->getCont() && compoundpermitflag &&
            TESTAFF(se->getCont(), compoundpermitflag, se->getContLen()))) &&
          (!circumfix ||
           // no circumfix flag in prefix and suffix
           ((!ppfx || !(ep->getCont()) ||
             !TESTAFF(ep->getCont(), circumfix, ep->getContLen())) &&
            (!se->getCont() ||
             !(TESTAFF(se->getCont(), circumfix, se->getContLen())))) ||
           // circumfix flag in prefix AND suffix
           ((ppfx && (ep->getCont()) &&
             TESTAFF(ep->getCont(), circumfix, ep->getContLen())) &&
            (se->getCont() &&
             (TESTAFF(se->getCont(), circumfix, se->getContLen()))))) &&
          // fogemorpheme
          (in_compound ||
           !(se->getCont() &&
             (TESTAFF(se->getCont(), onlyincompound, se->getContLen())))) &&
          // needaffix on prefix or first suffix
          (cclass ||
           !(se->getCont() &&
             TESTAFF(se->getCont(), needaffix, se->getContLen())) ||
           (ppfx &&
            !((ep->getCont()) &&
              TESTAFF(ep->getCont(), needaffix, ep->getContLen()))))) {
        rv = se->checkword(word, start, len, sfxopts, ppfx,
                           (FLAG)cclass, needflag,
                           (in_compound ? 0 : onlyincompound));
        if (rv) {
          sfx = se;  // BUG: sfx not stateless
          return rv;
        }
      }
    }
    se = se->getNext();
  }

  // now handle the general case
  if (len == 0)
    return NULL;  // FULLSTRIP
  unsigned char sp = word[start + len - 1];
  SfxEntry* sptr = sStart[sp];

  while (sptr) {
    if (isRevSubset(sptr->getKey(), word.c_str() + start + len - 1, len)) {
      // suffixes are not allowed in beginning of compounds
      if ((((in_compound != IN_CPD_BEGIN)) ||  // && !cclass
           // except when signed with compoundpermitflag flag
           (sptr->getCont() && compoundpermitflag &&
            TESTAFF(sptr->getCont(), compoundpermitflag,
                    sptr->getContLen()))) &&
          (!circumfix ||
           // no circumfix flag in prefix and suffix
           ((!ppfx || !(ep->getCont()) ||
             !TESTAFF(ep->getCont(), circumfix, ep->getContLen())) &&
            (!sptr->getCont() ||
             !(TESTAFF(sptr->getCont(), circumfix, sptr->getContLen())))) ||
           // circumfix flag in prefix AND suffix
           ((ppfx && (ep->getCont()) &&
             TESTAFF(ep->getCont(), circumfix, ep->getContLen())) &&
            (sptr->getCont() &&
             (TESTAFF(sptr->getCont(), circumfix, sptr->getContLen()))))) &&
          // fogemorpheme
          (in_compound ||
           !((sptr->getCont() && (TESTAFF(sptr->getCont(), onlyincompound,
                                          sptr->getContLen()))))) &&
          // needaffix on prefix or first suffix
          (cclass ||
           !(sptr->getCont() &&
             TESTAFF(sptr->getCont(), needaffix, sptr->getContLen())) ||
           (ppfx &&
            !((ep->getCont()) &&
              TESTAFF(ep->getCont(), needaffix, ep->getContLen())))))
        if (in_compound != IN_CPD_END || ppfx ||
            !(sptr->getCont() &&
              TESTAFF(sptr->getCont(), onlyincompound, sptr->getContLen()))) {
          rv = sptr->checkword(word, start, len, sfxopts, ppfx,
                               cclass, needflag,
                               (in_compound ? 0 : onlyincompound));
          if (rv) {
            sfx = sptr;                 // BUG: sfx not stateless
            sfxflag = sptr->getFlag();  // BUG: sfxflag not stateless
            if (!sptr->getCont())
              sfxappnd = sptr->getKey();  // BUG: sfxappnd not stateless
            // LANG_hu section: spec. Hungarian rule
            else if (langnum == LANG_hu && sptr->getKeyLen() &&
                     sptr->getKey()[0] == 'i' && sptr->getKey()[1] != 'y' &&
                     sptr->getKey()[1] != 't') {
              sfxextra = 1;
            }
            // END of LANG_hu section
            return rv;
          }
        }
      sptr = sptr->getNextEQ();
    } else {
      sptr = sptr->getNextNE();
    }
  }

  return NULL;
}

// the below code fragment can be found in:
// src/hunspell/affixmgr.cxx
void AffixMgr::reverse_condition(std::string& piece) {
  if (piece.empty())
      return;

  int neg = 0;
  for (std::string::reverse_iterator k = piece.rbegin(); k != piece.rend(); ++k) {
    switch (*k) {
      case '[': {
        if (neg)
          *(k - 1) = '[';
        else
          *k = ']';
        break;
      }
      case ']': {
        *k = '[';
        if (neg)
          *(k - 1) = '^';
        neg = 0;
        break;
      }
      case '^': {
        if (*(k - 1) == ']')
          neg = 1;
        else if (neg)
          *(k - 1) = *k;
        break;
      }
      default: {
        if (neg)
          *(k - 1) = *k;
      }
    }
  }
}
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).