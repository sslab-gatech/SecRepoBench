Below is the content of a C/C++ function where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
int AffixMgr::redundant_condition(char ft,
                                  const std::string& strip,
                                  const std::string& cond,
                                  int linenum) {
  int stripl = strip.size(), condl = cond.size();
  int i, cond_index;
  int neg;
  int in;
  if (ft == 'P') {  // prefix
    if (strip.compare(0, condl, cond) == 0)
      return 1;
    if (utf8) {
    } else {
      for (i = 0, cond_index = 0; (i < stripl) && (cond_index < condl); i++, cond_index++) {
        if (cond[cond_index] != '[') {
          if (cond[cond_index] != strip[i]) {
            HUNSPELL_WARNING(stderr,
                             "warning: line %d: incompatible stripping "
                             "characters and condition\n",
                             linenum);
            return 0;
          }
        } else {
          neg = (cond[cond_index + 1] == '^') ? 1 : 0;
          in = 0;
          do {
            cond_index++;
            if (strip[i] == cond[cond_index])
              in = 1;
          } while ((cond_index < (condl - 1)) && (cond[cond_index] != ']'));
          if (cond_index == (condl - 1) && (cond[cond_index] != ']')) {
            HUNSPELL_WARNING(stderr,
                             "error: line %d: missing ] in condition:\n%s\n",
                             linenum, cond.c_str());
            return 0;
          }
          if ((!neg && !in) || (neg && in)) {
            HUNSPELL_WARNING(stderr,
                             "warning: line %d: incompatible stripping "
                             "characters and condition\n",
                             linenum);
            return 0;
          }
        }
      }
      if (cond_index >= condl)
        return 1;
    }
  } else {  // suffix
    if ((stripl >= condl) && strip.compare(stripl - condl, std::string::npos, cond) == 0)
      return 1;
    if (utf8) {
    } else {
      for (i = stripl - 1, cond_index = condl - 1; (i >= 0) && (cond_index >= 0); i--, cond_index--) {
        // Check if the current character in the condition is a ']'.
        // If it's not, compare the current characters of the strip and condition.
        // If they differ, output a warning and return 0.
        // If it is a ']', check if the strip character is within the character set defined in the condition.
        // Iterate backwards to find the matching '[' for the ']'.
        // If the corresponding '[' is not found, output an error and return 0.
        // Determine if the character set is negated by checking if the next character after '[' is '^'.
        // Check if the strip character's presence in the set matches the negation status.
        // If not, output a warning and return 0.
        // <MASK>
      }
      if (cond_index < 0)
        return 1;
    }
  }
  return 0;
}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/tools/unmunch.cxx
int expand_rootword(const char* ts, int wl, const char* ap) {
  int i;
  int nh = 0;

  for (i = 0; i < numsfx; i++) {
    if (strchr(ap, (stable[i].aep)->achar)) {
      suf_add(ts, wl, stable[i].aep, stable[i].num);
    }
  }

  nh = numwords;

  if (nh > 1) {
    for (int j = 1; j < nh; j++) {
      if (wlist[j].pallow) {
        for (i = 0; i < numpfx; i++) {
          if (strchr(ap, (ptable[i].aep)->achar)) {
            if ((ptable[i].aep)->xpflg & XPRODUCT) {
              int nwl = strlen(wlist[j].word);
              pfx_add(wlist[j].word, nwl, ptable[i].aep, ptable[i].num);
            }
          }
        }
      }
    }
  }

  for (i = 0; i < numpfx; i++) {
    if (strchr(ap, (ptable[i].aep)->achar)) {
      pfx_add(ts, wl, ptable[i].aep, ptable[i].num);
    }
  }
  return 0;
}

// the below code fragment can be found in:
// src/tools/unmunch.cxx
void suf_add(const char* word, int len, struct affent* ep, int num) {
  struct affent* aent;
  int cond;
  unsigned char* cp;
  int i;

  for (aent = ep, i = num; i > 0; aent++, i--) {
    /* if conditions hold on root word
     * then strip off strip string and add suffix
     */

    if ((len + fullstrip > aent->stripl) && (len >= aent->numconds) &&
        ((aent->stripl == 0) ||
         (strcmp(aent->strip, word + len - aent->stripl) == 0))) {
      cp = (unsigned char*)(word + len);
      for (cond = aent->numconds; --cond >= 0;) {
        if ((aent->conds[*--cp] & (1 << cond)) == 0)
          break;
      }
      if (cond < 0) {
        /* we have a matching condition */
        std::string tword(word);
        tword.resize(len - aent->stripl);
        tword.append(aent->appnd);

        if (numwords < MAX_WORDS) {
          wlist[numwords].word = mystrdup(tword.c_str());
          wlist[numwords].pallow = (aent->xpflg & XPRODUCT);
          numwords++;
        }
      }
    }
  }
}

// the below code fragment can be found in:
// src/tools/munch.cxx
void suf_chk(const char* word,
             int len,
             struct affent* ep,
             int num,
             struct affent* pfxent,
             int cpflag) {
  struct affent* aent;
  int cond;
  struct hentry* hent;
  int i;

  for (aent = ep, i = num; i > 0; aent++, i--) {
    if ((cpflag & XPRODUCT) != 0 && (aent->xpflg & XPRODUCT) == 0)
      continue;

    int tlen = len - aent->appndl;
    if (tlen > 0 &&
        (aent->appndl == 0 || strcmp(aent->appnd, (word + tlen)) == 0) &&
        tlen + aent->stripl >= aent->numconds) {
      std::string tword(word);
      tword.resize(tlen);
      tword.append(aent->strip);
      unsigned char* cp = (unsigned char*)(tword.c_str() + tword.size());

      for (cond = aent->numconds; --cond >= 0;) {
        if ((aent->conds[*--cp] & (1 << cond)) == 0)
          break;
      }
      if (cond < 0) {
        if ((hent = lookup(tword.c_str())) != NULL) {
          if (numroots < MAX_ROOTS) {
            roots[numroots].hashent = hent;
            roots[numroots].prefix = pfxent;
            roots[numroots].suffix = aent;
            numroots++;
          }
        }
      }
    }
  }
}

// the below code fragment can be found in:
// src/tools/munch.cxx
void aff_chk(const char* word, int len) {
  int i;
  int nh = 0;

  if (len < 4)
    return;

  for (i = 0; i < numpfx; i++) {
    pfx_chk(word, len, ptable[i].aep, ptable[i].num);
  }

  nh = numroots;

  if (nh > 0) {
    for (int j = 0; j < nh; j++) {
      if (roots[j].prefix->xpflg & XPRODUCT) {
        char* nword = mystrdup((roots[j].hashent)->word);
        int nwl = strlen(nword);
        for (i = 0; i < numsfx; i++) {
          suf_chk(nword, nwl, stable[i].aep, stable[i].num, roots[j].prefix,
                  XPRODUCT);
        }
        free(nword);
      }
    }
  }
  for (i = 0; i < numsfx; i++) {
    suf_chk(word, len, stable[i].aep, stable[i].num, NULL, 0);
  }
}

// the below code fragment can be found in:
// src/tools/munch.cxx
void encodeit(struct affent* ptr, char* cs) {
  int nc;
  int neg;
  int grp;
  int n;
  int ec;
  int nm;
  int i, j, k;
  unsigned char mbr[MAX_WD_LEN];

  /* now clear the conditions array */
  for (i = 0; i < SET_SIZE; i++)
    ptr->conds[i] = (unsigned char)0;

  /* now parse the string to create the conds array */
  nc = strlen(cs);
  neg = 0; /* complement indicator */
  grp = 0; /* group indicator */
  n = 0;   /* number of conditions */
  ec = 0;  /* end condition indicator */
  nm = 0;  /* number of member in group */
  i = 0;
  if (strcmp(cs, ".") == 0) {
    ptr->numconds = 0;
    return;
  }
  while (i < nc) {
    unsigned char c = *((unsigned char*)(cs + i));
    if (c == '[') {
      grp = 1;
      c = 0;
    }
    if ((grp == 1) && (c == '^')) {
      neg = 1;
      c = 0;
    }
    if (c == ']') {
      ec = 1;
      c = 0;
    }
    if ((grp == 1) && (c != 0)) {
      *(mbr + nm) = c;
      nm++;
      c = 0;
    }
    if (c != 0) {
      ec = 1;
    }
    if (ec) {
      if (grp == 1) {
        if (neg == 0) {
          for (j = 0; j < nm; j++) {
            k = (unsigned int)mbr[j];
            ptr->conds[k] = ptr->conds[k] | (1 << n);
          }
        } else {
          for (j = 0; j < SET_SIZE; j++)
            ptr->conds[j] = ptr->conds[j] | (1 << n);
          for (j = 0; j < nm; j++) {
            k = (unsigned int)mbr[j];
            ptr->conds[k] = ptr->conds[k] & ~(1 << n);
          }
        }
        neg = 0;
        grp = 0;
        nm = 0;
      } else {
        /* not a group so just set the proper bit for this char */
        /* but first handle special case of . inside condition */
        if (c == '.') {
          /* wild card character so set them all */
          for (j = 0; j < SET_SIZE; j++)
            ptr->conds[j] = ptr->conds[j] | (1 << n);
        } else {
          ptr->conds[(unsigned int)c] = ptr->conds[(unsigned int)c] | (1 << n);
        }
      }
      n++;
      ec = 0;
    }
    i++;
  }
  ptr->numconds = n;
  return;
}
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).