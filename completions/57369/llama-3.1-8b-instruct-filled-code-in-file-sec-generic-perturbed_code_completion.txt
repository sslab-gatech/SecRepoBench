static bool ndpi_is_valid_vxlan(const struct pcap_pkthdr *header, const u_char *packet, u_int16_t iphdroffset, u_int16_t ip_len){
  // Validate the packet size.
  // Define the expected VXLAN UDP port (4789).
  // Get the UDP header and header offset.
  struct ndpi_udphdr *udp = (struct ndpi_udphdr *) &packet[iphdroffset + ip_len];
  u_int16_t sport = ntohs(udp->source), dport = ntohs(udp->dest);

  if((sport == 4789 || dport == 4789) &&
    (packet[iphdroffset + ip_len + 2] == 0x8) &&
    (packet[iphdroffset + ip_len + 3] == 0x0) &&
    (packet[iphdroffset + ip_len + 4] == 0x0) &&
    (packet[iphdroffset + ip_len + 5] == 0x0) &&
    (packet[iphdroffset + ip_len + 7] ==  0x0)) {
    return true;
  }
  return false;
}

static inline u_int ndpi_skip_vxlan(u_int16_t ip_offset, u_int16_t ip_len){
  return ip_offset + ip_len + sizeof(struct ndpi_udphdr) + sizeof(struct ndpi_vxlanhdr);
}