// Validate the packet size
  if (header->caplen < iphdroffset + ip_len + sizeof(struct ndpi_udphdr) + sizeof(struct ndpi_vxlanhdr)) {
    return false;
  }

  // Define the expected VXLAN UDP port (4789)
  const uint16_t vxlan_dst_port = htons(4789);

  // Get the UDP header and header offset
  struct ndpi_udphdr *udp = (struct ndpi_udphdr *)&packet[iphdroffset + ip_len];
  uint16_t offset = iphdroffset + ip_len + sizeof(struct ndpi_udphdr);

  // Check if the packet is a valid VXLAN packet
  if ((udp->dest == vxlan_dst_port || udp->source == vxlan_dst_port) &&
      (packet[offset] == 0x8) &&
      (packet[offset + 1] == 0x0) &&
      (packet[offset + 2] == 0x0) &&
      (packet[offset + 3] == 0x0) &&
      (packet[offset + 7] == 0x0)) {
    return true;
  }

  return false;