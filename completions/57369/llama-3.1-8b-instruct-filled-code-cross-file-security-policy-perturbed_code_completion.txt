// <MASK>
u_int16_t offset = iphdroffset + sizeof(struct udphdr);
struct udphdr *udp = (struct udphdr *)(packet + offset);
if (offset + sizeof(struct udphdr) + sizeof(struct vxlanhdr) <= header->len) {
  // Check if the packet size is sufficient to accommodate both headers
  if((udp->dest == vxlan_dst_port || udp->source == vxlan_dst_port) &&
    (packet[offset] == 0x8) &&
    (packet[offset + 1] == 0x0) &&
    (packet[offset + 2] == 0x0) &&
    (packet[offset + 3] == 0x0) &&
    (packet[offset + 7] ==  0x0)) {
    return true;
  }
}
return false;