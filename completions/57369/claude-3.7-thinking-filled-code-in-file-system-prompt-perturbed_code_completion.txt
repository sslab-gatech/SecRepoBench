// Check if we have enough data for both UDP and VXLAN headers
  if (header->caplen < iphdroffset + ip_len + sizeof(struct ndpi_udphdr) + 8)
    return false;
  
  struct ndpi_udphdr *udp = (struct ndpi_udphdr *)&packet[iphdroffset+ip_len];
  u_int16_t offset = iphdroffset + ip_len + sizeof(struct ndpi_udphdr);
  u_int16_t vxlan_dst_port = 4789; // Standard VXLAN port
  
  // Check for VXLAN port and valid VXLAN header format
  if((udp->dest == vxlan_dst_port || udp->source == vxlan_dst_port) &&
    (packet[offset] == 0x8) &&
    (packet[offset + 1] == 0x0) &&
    (packet[offset + 2] == 0x0) &&
    (packet[offset + 3] == 0x0) &&
    (packet[offset + 7] ==  0x0)) {
    return true;
    }
  return false;