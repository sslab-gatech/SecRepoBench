if(header->caplen < iphdroffset + ip_len)
    return false;

u_int8_t ip_version = packet[iphdroffset] >> 4;
u_int16_t ip_header_len = 0;
if(ip_version == 4) {
    ip_header_len = (packet[iphdroffset] & 0x0F) * 4;
} else if(ip_version == 6) {
    ip_header_len = 40; // Fixed length for IPv6 header
} else {
    return false;
}

if(ip_len < ip_header_len + sizeof(struct udphdr) + 8)
    return false;
if(header->caplen < iphdroffset + ip_header_len + sizeof(struct udphdr) + 8)
    return false;

const struct udphdr *udp = (const struct udphdr *)(packet + iphdroffset + ip_header_len);
u_int16_t offset = iphdroffset + ip_header_len + sizeof(struct udphdr);