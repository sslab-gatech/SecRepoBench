{
  // Define the VXLAN port (in network byte order).
  uint16_t vxlan_dst_port = htons(4789);

  // Ensure we have enough data for IP header + UDP header (8 bytes) + VxLAN header (8 bytes).
  // ip_len is the total length of the IP packet (starting at iphdroffset).
  // header->len is the total length of the entire captured frame.
  if(ip_len < 28) {
    return false;
  }

  // Parse the IP header to compute IP header length in bytes.
  const struct ip *iph = (const struct ip *)&packet[iphdroffset];
  uint16_t ip_hdr_len = iph->ip_hl * 4;

  // Check total IP packet length against minimum needed.
  if(ip_len < (ip_hdr_len + 8 + 8)) {
    return false;
  }

  // Compute the offset to the start of the UDP header.
  uint16_t udp_offset = iphdroffset + ip_hdr_len;
  if((udp_offset + 8) > header->len) {
    return false;
  }

  // Get the UDP header.
  const struct udphdr *udp = (const struct udphdr *)&packet[udp_offset];

  // Compute the offset to the start of the VXLAN header.
  uint16_t offset = udp_offset + 8;
  if((offset + 8) > header->len) {
    return false;
  }
}