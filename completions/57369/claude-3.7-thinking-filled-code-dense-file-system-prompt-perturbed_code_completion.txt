// Check if the packet is large enough to contain the IP header and UDP header
  if (header->caplen < iphdroffset + ip_len) {
    return false;
  }

  // Define the expected VXLAN UDP port (4789)
  u_int16_t vxlan_dst_port = ntohs(4789);

  // Get the UDP header
  struct ndpi_udphdr *udp = (struct ndpi_udphdr *)(packet + iphdroffset);

  // Calculate the offset to the VXLAN header (after UDP header)
  u_int16_t offset = iphdroffset + sizeof(struct ndpi_udphdr);

  // Make sure we have enough data for the VXLAN header (8 bytes)
  if (header->caplen < offset + 8) {
    return false;
  }