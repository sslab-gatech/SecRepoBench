static double
mrb_str_len_to_dbl(mrb_state *mrb, const char *s, size_t len, mrb_bool badcheck)
{
  // Parse a string to a double value, handling various string formats.
  // 1. Trim leading whitespace from the input string.
  // 2. Check for and handle hexadecimal prefixes "0x" or "0X".
  // 3. Prepare a buffer to store cleaned input by removing underscores between digits.
  // 4. Iterate over the string, copying valid characters to the buffer.
  // 5. Handle null byte termination, and check for formatting errors when 'badcheck' is true.
  // 6. Convert the cleaned string in the buffer to a double using a library function.
  // 7. Return the parsed double value.
  char buf[len + 1];
  char *p = buf;
  char *pend = p + len;
  char *n = pend;
  double d = 0.0;

  // Trim leading whitespace
  while (len > 0 && ISSPACE(s[len - 1])) {
    len--;
  }

  // Check for hexadecimal prefixes
  if (len > 2 && (s[0] == '0' || s[0] == '0') && (s[1] == 'x' || s[1] == 'X')) {
    // Remove the prefix
    len -= 2;
    memmove(s, s + 2, len);
  }

  // Prepare the buffer
  while (p < pend) {
    if (*s == '_') {
      s++;
      len--;
      continue;
    }
    *p++ = *s++;
    len--;
  }
  *n = '\0';

  // Check for null byte termination
  if (badcheck && *n == '\0') {
    mrb_raisef(mrb, E_ARGUMENT_ERROR, "string contains null byte");
  }

  // Convert the cleaned string to a double
  d = mrb_float_read(buf, &n);

  return d;
}