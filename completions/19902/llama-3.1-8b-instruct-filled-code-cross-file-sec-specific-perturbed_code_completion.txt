// <MASK>
  // 1. Trim leading whitespace from the input string.
  while (p < end && ISSPACE(*p)) p++;
  if (p == end) {
    if (badcheck) {
      mrb_raisef(mrb, E_ARGUMENT_ERROR, "invalid string for float(%!s)", char_buffer);
      /* not reached */
    }
    return d;
  }

  // 2. Check for and handle hexadecimal prefixes "0x" or "0X".
  if (p[0] == '0' && (p[1] == 'x' || p[1] == 'X')) {
    p += 2;
    if (p == end) {
      if (badcheck) {
        mrb_raisef(mrb, E_ARGUMENT_ERROR, "invalid string for float(%!s)", char_buffer);
        /* not reached */
      }
      return d;
    }
  }

  // 3. Prepare a buffer to store cleaned input by removing underscores between digits.
  //    We will use a temporary buffer to store the cleaned string.
  char temp_buf[end - p + 1];
  char *temp_p = temp_buf;
  char *temp_end = temp_p + (end - p);

  // 4. Iterate over the string, copying valid characters to the temporary buffer.
  while (p < end) {
    if (ISDIGIT(*p) || (*p == '_')) {
      *temp_p++ = *p++;
    } else {
      break;
    }
  }
  *temp_p = '\0';

  // 5. Handle null byte termination, and check for formatting errors when 'badcheck' is true.
  if (temp_p == temp_end) {
    if (badcheck) {
      mrb_raisef(mrb, E_ARGUMENT_ERROR, "invalid string for float(%!s)", char_buffer);
      /* not reached */
    }
    return d;
  }

  // 6. Convert the cleaned string in the temporary buffer to a double using a library function.
  d = mrb_float_read(temp_buf, &temp_end);
  if (temp_p!= temp_end) {
    if (badcheck) {
      mrb_raisef(mrb, E_ARGUMENT_ERROR, "invalid string for float(%!s)", char_buffer);
      /* not reached */
    }
    return d;
  }

  // 7. Return the parsed double value.
  return d;