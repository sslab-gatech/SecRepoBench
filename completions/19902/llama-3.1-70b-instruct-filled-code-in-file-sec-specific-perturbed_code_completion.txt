double
mrb_str_len_to_dbl(mrb_state *state, const char *s, size_t len, mrb_bool badcheck)
{
  // Parse a string to a double value, handling various string formats.
  // 1. Trim leading whitespace from the input string.
  // 2. Check for and handle hexadecimal prefixes "0x" or "0X".
  // 3. Prepare a buffer to store cleaned input by removing underscores between digits.
  // 4. Iterate over the string, copying valid characters to the buffer.
  // 5. Handle null byte termination, and check for formatting errors when 'badcheck' is true.
  // 6. Convert the cleaned string in the buffer to a double using a library function.
  // 7. Return the parsed double value.
  char buf[DBL_MAX_10_EXP+100];
  char *p = buf;
  char *pend = buf + sizeof(buf);
  char *n = p;
  double d;
  const char *end;
  int c;

  if (len == 0) {
    if (badcheck) {
      mrb_raisef(state, E_ARGUMENT_ERROR, "invalid string for float");
      /* not reached */
    }
    return 0.0;
  }

  while (p < pend && ISSPACE(*s)) {
    s++;
    len--;
  }

  if (len == 0) {
    if (badcheck) {
      mrb_raisef(state, E_ARGUMENT_ERROR, "invalid string for float");
      /* not reached */
    }
    return 0.0;
  }

  if (s[0] == '0') {
    if (s[1] == 'x' || s[1] == 'X') {
      s += 2;
      len -= 2;
      while (p < pend && len > 0) {
        c = *s++;
        if (ISXDIGIT(c)) {
          *p++ = c;
          len--;
        }
        else if (c == '_') {
          len--;
        }
        else {
          break;
        }
      }
      if (p == pend) {
        if (badcheck) {
          mrb_raisef(state, E_ARGUMENT_ERROR, "invalid string for float");
          /* not reached */
        }
        return 0.0;
      }
      *p = '\0';
      d = mrb_float_read(buf, &end);
      if (p == end) {
        if (badcheck) {
          mrb_raisef(state, E_ARGUMENT_ERROR, "invalid string for float");
          /* not reached */
        }
        return d;
      }
      if (badcheck) {
        if (!end || p == end) {
          mrb_raisef(state, E_ARGUMENT_ERROR, "invalid string for float");
          /* not reached */
        }
        while (end < pend && ISSPACE(*end)) {
          end++;
        }
        if (end < pend) {
          mrb_raisef(state, E_ARGUMENT_ERROR, "invalid string for float");
          /* not reached */
        }
      }
      return d;
    }
  }

  while (p < pend && len > 0) {
    c = *s++;
    if (ISDIGIT(c) || c == '.' || c == '+' || c == '-' || c == 'e' || c == 'E') {
      *p++ = c;
      len--;
    }
    else if (c == '_') {
      len--;
    }
    else {
      break;
    }
  }
  if (p == pend) {
    if (badcheck) {
      mrb_raisef(state, E_ARGUMENT_ERROR, "invalid string for float");
      /* not reached */
    }
    return 0.0;
  }
  *p = '\0';
  d = mrb_float_read(buf, &end);
  if (p == end) {
    if (badcheck) {
      mrb_raisef(state, E_ARGUMENT_ERROR, "invalid string for float");
      /* not reached */
    }
    return d;
  }
  if (badcheck) {
    if (!end || p == end) {
      mrb_raisef(state, E_ARGUMENT_ERROR, "invalid string for float");
      /* not reached */
    }
    while (end < pend && ISSPACE(*end)) {
      end++;
    }
    if (end < pend) {
      mrb_raisef(state, E_ARGUMENT_ERROR, "invalid string for float");
      /* not reached */
    }
  }
  return d;
}