*
 *     "hello".capitalize   #=> "Hello"
 *     "HELLO".capitalize   #=> "Hello"
 *     "123ABC".capitalize  #=> "123abc"
 */
static mrb_value
mrb_str_capitalize(mrb_state *mrb, mrb_value str)
{
  struct RString *s = str_new(mrb, 0, 0);

  str_with_class(s, str);
  mrb_str_capitalize_bang(mrb, str_replace(mrb, s, mrb_str_ptr(str)));
  return mrb_obj_value(s);
}

/* 15.2.10.5.9  */
/*
 *  call-seq:
 *     str.downcase!   => str or nil
 *
 *  Converts <i>str</i> to lowercase, returning <code>nil</code> if no changes
 *  are made.
 *
 *     a = "HELLO"
 *     a.downcase!   #=> "hello"
 *     a             #=> "hello"
 *     a.downcase!   #=> nil
 */
static mrb_value
mrb_str_downcase_bang(mrb_state *mrb, mrb_value str)
{
  char *p, *pend;
  mrb_bool modify = FALSE;
  struct RString *s = mrb_str_ptr(str);

  mrb_str_modify_keep_ascii(mrb, s);
  if (RSTR_LEN(s) == 0 || !RSTR_PTR(s)) return mrb_nil_value();
  p = RSTR_PTR(s); pend = RSTR_PTR(s) + RSTR_LEN(s);
  while (p < pend) {
    if (ISUPPER(*p)) {
      *p = TOLOWER(*p);
      modify = TRUE;
    }
    p++;
  }
  if (modify) return str;
  return mrb_nil_value();
}

/* 15.2.10.5.10 */
/*
 *  call-seq:
 *     str.downcase   => new_str
 *
 *  Returns a copy of <i>str</i> with all uppercase letters replaced with their
 *  lowercase counterparts. The operation is locale insensitive.
 *
 *     "HELLO".downcase   #=> "hello"
 *     "LOVELY".downcase  #=> "lovely"
 */
static mrb_value
mrb_str_downcase(mrb_state *mrb, mrb_value str)
{
  struct RString *s = str_new(mrb, 0, 0);

  str_with_class(s, str);
  mrb_str_downcase_bang(mrb, str_replace(mrb, s, mrb_str_ptr(str)));
  return mrb_obj_value(s);
}

/* 15.2.10.5.11 */
/*
 *  call-seq:
 *     str.upcase!   => str or nil
 *
 *  Converts <i>str</i> to uppercase, returning <code>nil</code> if no changes
 *  are made.
 *
 *     a = "hello"
 *     a.upcase!   #=> "HELLO"
 *     a           #=> "HELLO"
 *     a.upcase!   #=> nil
 */
static mrb_value
mrb_str_upcase_bang(mrb_state *mrb, mrb_value str)
{
  char *p, *pend;
  mrb_bool modify = FALSE;
  struct RString *s = mrb_str_ptr(str);

  mrb_str_modify_keep_ascii(mrb, s);
  if (RSTR_LEN(s) == 0 || !RSTR_PTR(s)) return mrb_nil_value();
  p = RSTR_PTR(s); pend = RSTR_PTR(s) + RSTR_LEN(s);
  while (p < pend) {
    if (ISLOWER(*p)) {
      *p = TOUPPER(*p);
      modify = TRUE;
    }
    p++;
  }
  if (modify) return str;
  return mrb_nil_value();
}

/* 15.2.10.5.12 */
/*
 *  call-seq:
 *     str.upcase   => new_str
 *
 *  Returns a copy of <i>str</i> with all lowercase letters replaced with their
 *  uppercase counterparts. The operation is locale insensitive.
 *
 *     "hello".upcase   #=> "HELLO"
 *     "LOVELY".upcase  #=> "LOVELY"
 */
static mrb_value
mrb_str_upcase(mrb_state *mrb, mrb_value str)
{
  struct RString *s = str_new(mrb, 0, 0);

  str_with_class(s, str);
  mrb_str_upcase_bang(mrb, str_replace(mrb, s, mrb_str_ptr(str)));
  return mrb_obj_value(s);
}

/* 15.2.10.5.13 */
/*
 *  call-seq:
 *     str.swapcase!   => str or nil
 *
 *  Converts uppercase characters to lowercase and lowercase characters to
 *  uppercase. Returns <code>nil</code> if no changes are made.
 *
 *     a = "Hello"
 *     a.swapcase!   #=> "hELLO"
 *     a             #=> "hELLO"
 *     a.swapcase!   #=> nil
 */
static mrb_value
mrb_str_swapcase_bang(mrb_state *mrb, mrb_value str)
{
  char *p, *pend;
  mrb_bool modify = FALSE;
  struct RString *s = mrb_str_ptr(str);

  mrb_str_modify_keep_ascii(mrb, s);
  if (RSTR_LEN(s) == 0 || !RSTR_PTR(s)) return mrb_nil_value();
  p = RSTR_PTR(s); pend = RSTR_PTR(s) + RSTR_LEN(s);
  while (p < pend) {
    if (ISLOWER(*p)) {
      *p = TOUPPER(*p);
      modify = TRUE;
    }
    else if (ISUPPER(*p)) {
      *p = TOLOWER(*p);
      modify = TRUE;
    }
    p++;
  }
  if (modify) return str;
  return mrb_nil_value();
}

/* 15.2.10.5.14 */
/*
 *  call-seq:
 *     str.swapcase   => new_str
 *
 *  Returns a new string with all uppercase letters converted to lowercase and
 *  vice versa. Note that it does not change the string in place.
 *
 *     "Hello".swapcase   #=> "hELLO"
 *     "cYbEr_PuNk11".swapcase   #=> "CyBeR_pUnK11"
 */
static mrb_value
mrb_str_swapcase(mrb_state *mrb, mrb_value str)
{
  struct RString *s = str_new(mrb, 0, 0);

  str_with_class(s, str);
  mrb_str_swapcase_bang(mrb, str_replace(mrb, s, mrb_str_ptr(str)));
  return mrb_obj_value(s);
}

/* 15.2.10.5.15 */
/*
 *  call-seq:
 *     str.each_char { |c| block }   => str
 *
 *  Passes each character in <i>str</i> to the given block, or returns an
 *  enumerator if no block is given.
 *
 *     "hello".each_char { |c| print c, ' ' }
 *
 *  <em>produces:</em>
 *
 *     h e l l o
 */
static mrb_value
mrb_str_each_char(mrb_state *mrb, mrb_value str)
{
  mrb_value ary = mrb_ary_new(mrb);
  const char *p, *pend;

  p = RSTRING_PTR(str); pend = RSTRING_END(str);
  while (p < pend) {
    mrb_value c = mrb_str_new_cstr(mrb, p);
    mrb_ary_push(mrb, ary, c);
    p += utf8len(p, pend);
  }
  if (mrb->proc) {
    mrb_yield(mrb, ary);
    return str;
  }
  return ary;
}

/* 15.2.10.5.16 */
/*
 *  call-seq:
 *     str.each_byte { |byte| block }   => str
 *
 *  Passes each byte in <i>str</i> to the given block, or returns an enumerator
 *  if no block is given.
 *
 *     "hello".each_byte { |c| print c, ' ' }
 *
 *  <em>produces:</em>
 *
 *     104 101 108 108 111
 */
static mrb_value
mrb_str_each_byte(mrb_state *mrb, mrb_value str)
{
  mrb_value ary = mrb_ary_new(mrb);
  const char *p, *pend;

  p = RSTRING_PTR(str); pend = RSTRING_END(str);
  while (p < pend) {
    mrb_value c = mrb_fixnum_value(*p);
    mrb_ary_push(mrb, ary, c);
    p++;
  }
  if (mrb->proc) {
    mrb_yield(mrb, ary);
    return str;
  }
  return ary;
}

/* 15.2.10.5.17 */
/*
 *  call-seq:
 *     str.each_line(separator=$/) { |s| block }   => str
 *
 *  Passes each line in <i>str</i> to the given block, or returns an enumerator
 *  if no block is given. Lines are separated by <i>separator</i>.
 *
 *     "hello\nworld".each_line { |line| puts line }
 *
 *  <em>produces:</em>
 *
 *     hello
 *     world
 */
static mrb_value
mrb_str_each_line(mrb_state *mrb, mrb_value str)
{
  mrb_value ary = mrb_ary_new(mrb);
  const char *p, *pend;
  char *s, *send;
  mrb_int len;

  p = RSTRING_PTR(str); pend = RSTRING_END(str);
  len = RSTRING_LEN(str);
  s = (char *)p; send = s + len;
  while (s < send) {
    char *eol = strchr(s, '\n');
    if (!eol) eol = send;
    mrb_value line = mrb_str_new(mrb, s, eol - s);
    mrb_ary_push(mrb, ary, line);
    s = eol + 1;
  }
  if (mrb->proc) {
    mrb_yield(mrb, ary);
    return str;
  }
  return ary;
}

/* 15.2.10.5.18 */
/*
 *  call-seq:
 *     str.chars   => array
 *
 *  Returns an array of the characters in <i>str</i>.
 *
 *     "hello".chars   #=> ["h", "e", "l", "l", "o"]
 */
static mrb_value
mrb_str_chars(mrb_state *mrb, mrb_value str)
{
  mrb_value ary = mrb_ary_new(mrb);
  const char *p, *pend;

  p = RSTRING_PTR(str); pend = RSTRING_END(str);
  while (p < pend) {
    m