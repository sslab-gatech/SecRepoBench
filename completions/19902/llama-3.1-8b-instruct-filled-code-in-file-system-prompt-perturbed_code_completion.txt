#ifndef MRB_WITHOUT_FLOAT
double
mrb_str_len_to_dbl(mrb_state *state, const char *s, size_t len, mrb_bool badcheck)
{
  // Parse a string to a double value, handling various string formats.
  // 1. Trim leading whitespace from the input string.
  // 2. Check for and handle hexadecimal prefixes "0x" or "0X".
  // 3. Prepare a buffer to store cleaned input by removing underscores between digits.
  // 4. Iterate over the string, copying valid characters to the buffer.
  // 5. Handle null byte termination, and check for formatting errors when 'badcheck' is true.
  // 6. Convert the cleaned string in the buffer to a double using a library function.
  // 7. Return the parsed double value.
  // <MASK>
  char buf[1024];
  char *p = buf;
  char *pend = buf + sizeof(buf);
  char *n = pend;
  double d;

  while (p < pend) {
    if (*p == '_') {
      p++;
      if (p == pend) {
        if (badcheck) {
          mrb_raisef(state, E_ARGUMENT_ERROR, "invalid string for float(%!s)", s);
          /* not reached */
        }
        return 0.0;
      }
      if (*p == '_') {
        if (badcheck) {
          mrb_raisef(state, E_ARGUMENT_ERROR, "invalid string for float(%!s)", s);
          /* not reached */
        }
        break;
      }
    }
    if (badcheck && *p == '\0') {
      mrb_raisef(state, E_ARGUMENT_ERROR, "string contains null byte");
      /* not reached */
    }
    if (ISDIGIT(*p) || ISSPACE(*p)) {
      *n++ = *p++;
    }
    else if (ISLOWER(*p) || ISUPPER(*p)) {
      *n++ = *p++;
    }
    else if (*p == '0' && (p[1] == 'x' || p[1] == 'X')) {
      p += 2;
      while (p < pend && ISDIGIT(*p)) {
        *n++ = *p++;
      }
    }
    else if (*p == '0' && (p[1] == 'b' || p[1] == 'B')) {
      p += 2;
      while (p < pend && ISDIGIT(*p)) {
        *n++ = *p++;
      }
    }
    else if (*p == '0' && (p[1] == 'o' || p[1] == 'O')) {
      p += 2;
      while (p < pend && ISDIGIT(*p)) {
        *n++ = *p++;
      }
    }
    else if (*p == '0' && (p[1] == 'd' || p[1] == 'D')) {
      p += 2;
      while (p < pend && ISDIGIT(*p)) {
        *n++ = *p++;
      }
    }
    else if (*p == '0' && (p[1] == 'x' || p[1] == 'X')) {
      p += 2;
      while (p < pend && ISDIGIT(*p)) {
        *n++ = *p++;
      }
    }
    else {
      break;
    }
  }
  *n = '\0';
  d = mrb_float_read(p, &end);
  if (p == end) {
    if (badcheck) {
bad:
      mrb_raisef(state, E_ARGUMENT_ERROR, "invalid string for float(%!s)", s);
      /* not reached */
    }
    return d;
  }
  if (badcheck) {
    if (!end || p == end) goto bad;
    while (end < pend && ISSPACE(*end)) end++;
    if (end < pend) goto bad;
  }
  return d;
}

MRB_API double
mrb_cstr_to_dbl(mrb_state *mrb, const char *s, mrb_bool badcheck)
{
  return mrb_str_len_to_dbl(mrb, s, strlen(s), badcheck);
}

MRB_API double
mrb_str_to_dbl(mrb_state *mrb, mrb_value str, mrb_bool badcheck)
{
  return mrb_str_len_to_dbl(mrb, RSTRING_PTR(str), RSTRING_LEN(str), badcheck);
}

/* 15.2.10.5.39 */
/*
 *  call-seq:
 *     str.to_f   => float
 *
 *  Returns the result of interpreting leading characters in <i>str</i> as a
 *  floating point number. Extraneous characters past the end of a valid number
 *  are ignored. If there is not a valid number at the start of <i>str</i>,
 *  <code>0.0</code> is returned. This method never raises an exception.
 *
 *     "123.45e1".to_f        #=> 1234.5
 *     "45.67 degrees".to_f   #=> 45.67
 *     "thx1138".to_f         #=> 0.0
 */
static mrb_value
mrb_str_to_f(mrb_state *mrb, mrb_value self)
{
  return mrb_float_value(mrb, mrb_str_to_dbl(mrb, self, FALSE));
}
#endif