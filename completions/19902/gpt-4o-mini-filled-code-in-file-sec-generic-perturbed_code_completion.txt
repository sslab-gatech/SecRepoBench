char buf[128]; // Buffer to hold the cleaned input string
  char *p = buf; // Pointer to the current position in the buffer
  const char *pend = s + len; // Pointer to the end of the input string
  const char *n = s; // Pointer to traverse the input string
  double d; // Variable to hold the parsed double value

  // Trim leading whitespace
  while (n < pend && isspace((unsigned char)*n)) {
    n++;
  }

  // Check for hexadecimal prefix
  if (n + 1 < pend && n[0] == '0' && (n[1] == 'x' || n[1] == 'X')) {
    n += 2; // Move past the "0x" prefix
  }

  // Copy valid characters to the buffer
  while (n < pend) {
    if (isdigit((unsigned char)*n) || *n == '.' || *n == 'e' || *n == 'E' || *n == '-' || *n == '+') {
      *p++ = *n; // Copy valid character
    } else if (*n == '_') {
      // Ignore underscores
    } else {
      break; // Stop on invalid character
    }
    n++;
  }

  // Null-terminate the buffer
  *p = '\0';

  // Convert the cleaned string in the buffer to a double
  d = strtod(buf, NULL);
  
  // Handle bad check
  if (badcheck && (n != pend)) {
    mrb_raisef(state, E_ARGUMENT_ERROR, "invalid string for float(%!s)", s);
  }

  return d; // Return the parsed double value