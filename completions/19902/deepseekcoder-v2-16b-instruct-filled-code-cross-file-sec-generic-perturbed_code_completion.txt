char buf[1024];
  char *p, *pend, *n;
  size_t i;
  const char *end;
  double d;

  // Trim leading whitespace
  while (len > 0 && isspace((unsigned char)*char_buffer)) {
    char_buffer++;
    len--;
  }

  // Check for and handle hexadecimal prefixes "0x" or "0X"
  if (len >= 2 && char_buffer[0] == '0' && (char_buffer[1] == 'x' || char_buffer[1] == 'X')) {
    char_buffer += 2;
    len -= 2;
  }

  // Prepare a buffer to store cleaned input by removing underscores between digits
  n = buf;
  p = buf;
  pend = buf + sizeof(buf);

  // Iterate over the string, copying valid characters to the buffer
  for (i = 0; i < len; i++) {
    if (char_buffer[i] == '_') {
      continue;
    }
    if (p < pend) {
      *p++ = char_buffer[i];
    }
  }

  // Handle null byte termination
  *p = '\0';

  // Convert the cleaned string in the buffer to a double using a library function
  end = p;
  d = mrb_float_read(buf, &end);

  // Check for formatting errors when 'badcheck' is true
  if (badcheck) {
    if (buf == end || end < pend) {
      goto bad;
    }
    while (end < pend && ISSPACE(*end)) end++;
    if (end < pend) {
      goto bad;
    }
  }

  return d;

bad:
  mrb_raisef(mrb, E_ARGUMENT_ERROR, "invalid string for float(%!s)", char_buffer);
  /* not reached */