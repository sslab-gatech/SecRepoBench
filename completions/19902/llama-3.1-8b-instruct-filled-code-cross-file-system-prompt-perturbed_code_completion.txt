double
mrb_str_len_to_dbl(mrb_state *mrb, const char *char_buffer, size_t len, mrb_bool badcheck)
{
  // Parse a string to a double value, handling various string formats.
  // 1. Trim leading whitespace from the input string.
  // 2. Check for and handle hexadecimal prefixes "0x" or "0X".
  // 3. Prepare a buffer to store cleaned input by removing underscores between digits.
  // 4. Iterate over the string, copying valid characters to the buffer.
  // 5. Handle null byte termination, and check for formatting errors when 'badcheck' is true.
  // 6. Convert the cleaned string in the buffer to a double using a library function.
  // 7. Return the parsed double value.
  char buf[len + 1];
  char *p = buf;
  char *pend = buf + len;
  char *n = buf + len;
  double d;
  const char *end;

  // Trim leading whitespace
  while (p < pend && ISSPACE(*p)) p++;

  // Check for hexadecimal prefixes
  if (p < pend && (p[0] == '0' || p[0] == '0') && (p[1] == 'x' || p[1] == 'X')) {
    p += 2;
  }

  // Prepare buffer to store cleaned input
  while (p < pend && ISSPACE(*p)) p++;
  while (p < pend && *p!= '\0') {
    if (*p == '_') {
      p++;
    } else {
      *n++ = *p++;
    }
  }
  *n = '\0';

  // Iterate over the string, copying valid characters to the buffer
  p = buf;
  pend = n;
nocopy:
  d = mrb_float_read(p, &end);
  if (p == end) {
    if (badcheck) {
bad:
      mrb_raisef(mrb, E_ARGUMENT_ERROR, "invalid string for float(%!s)", char_buffer);
      /* not reached */
    }
    return d;
  }
  if (badcheck) {
    if (!end || p == end) goto bad;
    while (end<pend && ISSPACE(*end)) end++;
    if (end<pend) goto bad;
  }
  return d;
}