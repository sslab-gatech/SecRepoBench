double
mrb_str_len_to_dbl(mrb_state *state, const char *s, size_t len, mrb_bool badcheck)
{
  // Parse a string to a double value, handling various string formats.
  // 1. Trim leading whitespace from the input string.
  // 2. Check for and handle hexadecimal prefixes "0x" or "0X".
  // 3. Prepare a buffer to store cleaned input by removing underscores between digits.
  // 4. Iterate over the string, copying valid characters to the buffer.
  // 5. Handle null byte termination, and check for formatting errors when 'badcheck' is true.
  // 6. Convert the cleaned string in the buffer to a double using a library function.
  // 7. Return the parsed double value.
  char buf[len + 1];
  char *p = buf;
  char *pend = buf + len;
  char *n = buf + len;
  double d;
  const char *end;

  // Trim leading whitespace from the input string.
  while (len > 0 && ISSPACE(s[len - 1])) {
    len--;
  }

  // Check for and handle hexadecimal prefixes "0x" or "0X".
  if (len >= 2 && (s[0] == '0' && (s[1] == 'x' || s[1] == 'X'))) {
    len -= 2;
    p += 2;
    pend -= 2;
  }

  // Prepare a buffer to store cleaned input by removing underscores between digits.
  *n = '\0';
  p = buf;
  pend = n;
  while (len > 0) {
    if (ISDIGIT(s[len - 1]) || s[len - 1] == '_') {
      *p++ = s[len - 1];
      len--;
    } else {
      break;
    }
  }
  *p = '\0';

  // Iterate over the string, copying valid characters to the buffer.
  while (len > 0) {
    if (ISDIGIT(s[len - 1])) {
      *p++ = s[len - 1];
      len--;
    } else if (s[len - 1] == '_') {
      len--;
    } else {
      break;
    }
  }
  *p = '\0';

  // Handle null byte termination, and check for formatting errors when 'badcheck' is true.
  if (badcheck) {
    if (p == pend) {
      mrb_raisef(state, E_ARGUMENT_ERROR, "invalid string for float(%!s)", s);
      return 0.0;
    }
    while (pend > p && ISSPACE(*pend)) pend--;
    if (pend > p) {
      mrb_raisef(state, E_ARGUMENT_ERROR, "invalid string for float(%!s)", s);
      return 0.0;
    }
  }

  // Convert the cleaned string in the buffer to a double using a library function.
  d = mrb_float_read(p, &end);
  if (p == end) {
    if (badcheck) {
      mrb_raisef(state, E_ARGUMENT_ERROR, "invalid string for float(%!s)", s);
      return 0.0;
    }
    return d;
  }

  return d;
}