:
 *     str.capitalize   => new_str
 *
 *  Returns a copy of <i>str</i> with the first character converted to uppercase
 *  and the remainder to lowercase.
 *
 *     "hello".capitalize   #=> "Hello"
 *     "HELLO".capitalize   #=> "Hello"
 *     "123ABC".capitalize  #=> "123abc"
 */
static mrb_value
mrb_str_capitalize(mrb_state *mrb, mrb_value str)
{
  struct RString *s = str_new(mrb, 0, 0);

  str_with_class(s, str);
  if (RSTR_LEN(str) == 0 || !RSTR_PTR(str)) return mrb_obj_value(s);
  if (ISLOWER(RSTR_PTR(str)[0])) {
    s->as.heap.ptr[0] = TOUPPER(s->as.heap.ptr[0]);
  }
  memcpy(s->as.heap.ptr + 1, RSTR_PTR(str) + 1, RSTR_LEN(str));
  RSTR_SET_LEN(s, RSTR_LEN(str));
  {
    char *p = s->as.heap.ptr;
    char *pend = s->as.heap.ptr + RSTR_LEN(s);
    while (p < pend) {
      if (ISUPPER(*p)) {
        *p = TOLOWER(*p);
      }
      p++;
    }
  }
  return mrb_obj_value(s);
}

/* 15.2.10.5.9  */
/*
 *  call-seq:
 *     str.casecmp(other_str)   => -1, 0, 1
 *
 *  Case-insensitive version of <code>String#<=></code>.
 *
 *     "abcdef".casecmp("abcde")     #=> 1
 *     "aBcDeF".casecmp("abcdef")    #=> 0
 *     "abcdef".casecmp("abcdefg")   #=> -1
 *     "abcdef".casecmp("ABCDEF")    #=> 0
 */
static mrb_value
mrb_str_casecmp(mrb_state *mrb, mrb_value str1)
{
  mrb_value str2;
  mrb_int result;

  mrb_get_args(mrb, "S", &str2);
  result = mrb_str_cmp(mrb, str1, str2);
  if (result == 0) return INT2FIX(-1);
  if (result < 0) return INT2FIX(-1);
  return INT2FIX(1);
}

/* 15.2.10.5.10 */
/*
 *  call-seq:
 *     str.center(width, padstr=' ')   => new_str
 *
 *  Centers <i>str</i> in <i>width</i>.  If <i>width</i> is greater than the
 *  length of <i>str</i>, pads with <i>padstr</i>; otherwise, returns <i>str</i>
 *  untouched.
 *
 *     "hello".center(4)         #=> "hello"
 *     "hello".center(20)        #=> "       hello        "
 *     "hello".center(20, '123') #=> "1231231hello12312312"
 */
static mrb_value
mrb_str_center(mrb_state *mrb, mrb_value str, mrb_value width, mrb_value padstr)
{
  mrb_int w, plen;
  const char *pstr;
  struct RString *s, *pad;

  w = mrb_int(mrb, width);
  if (w <= RSTRING_LEN(str)) {
    return str;
  }
  if (mrb_nil_p(padstr)) {
    padstr = mrb_str_new_cstr(mrb, " ");
  }
  pad = mrb_str_ptr(padstr);
  plen = RSTRING_LEN(pad);
  s = str_new(mrb, 0, w);
  str_with_class(s, str);
  memcpy(RSTR_PTR(s) + (w - RSTRING_LEN(str)) / 2, RSTR_PTR(str), RSTRING_LEN(str));
  if (plen > 0) {
    mrb_int i, n;

    n = (w - RSTRING_LEN(str)) / plen;
    for (i = 0; i < n; i++) {
      memcpy(RSTR_PTR(s) + RSTRING_LEN(s), RSTR_PTR(pad), plen);
      RSTR_SET_LEN(s, RSTRING_LEN(s) + plen);
    }
    n = (w - RSTRING_LEN(str)) % plen;
    if (n > 0) {
      memcpy(RSTR_PTR(s) + RSTRING_LEN(s), RSTR_PTR(pad), n);
      RSTR_SET_LEN(s, RSTRING_LEN(s) + n);
    }
  }
  return mrb_obj_value(s);
}

/* 15.2.10.5.11 */
/*
 *  call-seq:
 *     str.chars   => array
 *
 *  Returns an array of the characters in <i>str</i>.
 *
 *     "hello".chars   #=> ["h", "e", "l", "l", "o"]
 */
static mrb_value
mrb_str_chars(mrb_state *mrb, mrb_value str)
{
  mrb_int i, len;
  struct RString *s = mrb_str_ptr(str);
  mrb_value ary = mrb_ary_new(mrb);

  len = RSTRING_LEN(s);
  for (i = 0; i < len; i++) {
    mrb_value c = mrb_str_new(mrb, s->as.heap.ptr + i, 1);
    mrb_ary_push(mrb, ary, c);
  }
  return ary;
}

/* 15.2.10.5.12 */
/*
 *  call-seq:
 *     str.chomp([separator=$/])   => new_str
 *
 *  Returns a new <code>String</code> with the given record separator removed
 *  from the end of <i>str</i> (if present). If <code>$/</code> has not been
 *  changed from the default, then it removes carriage return followed by
 *  newline (`\r\n`) from the end of the string.
 *
 *     "hello".chomp         #=> "hello"
 *     "hello\n".chomp       #=> "hello"
 *     "hello\r\n".chomp     #=> "hello"
 *     "hello\n\r".chomp     #=> "hello\n"
 *     "hello\r".chomp       #=> "hello"
 *     "hello \n there".chomp #=> "hello \n there"
 *
 *  If <i>separator</i> is given and is not a newline character, then it will
 *  remove occurrences of the <i>separator</i> from the end of the string.
 *
 *     "hello".chomp("llo")  #=> "he"
 */
static mrb_value
mrb_str_chomp(mrb_state *mrb, mrb_value str, mrb_value sep)
{
  const char *p, *pend, *sepstr;
  struct RString *s;
  mrb_int seplen;

  if (mrb_nil_p(sep)) {
    sep = mrb_default_rs(mrb);
  }
  sepstr = RSTRING_PTR(sep);
  seplen = RSTRING_LEN(sep);
  s = mrb_str_ptr(str);
  p = RSTRING_PTR(s);
  pend = p + RSTRING_LEN(s);

  if (seplen == 0) {
    return str;
  }

  if (pend >= p + seplen && strncmp(pend - seplen, sepstr, seplen) == 0) {
    pend -= seplen;
  }
  return mrb_str_new(mrb, p, pend - p);
}

/* 15.2.10.5.13 */
/*
 *  call-seq:
 *     str.chomp!(separator=$/)   => str or nil
 *
 *  Modifies <i>str</i> in place as described for <code>String#chomp</code>,
 *  returning <i>str</i>, or <code>nil</code> if no modifications were made.
 */
static mrb_value
mrb_str_chomp_bang(mrb_state *mrb, mrb_value str, mrb_value sep)
{
  const char *p, *pend, *sepstr;
  struct RString *s;
  mrb_int seplen;

  if (mrb_nil_p(sep)) {
    sep = mrb_default_rs(mrb);
  }
  sepstr = RSTRING_PTR(sep);
  seplen = RSTRING_LEN(sep);
  s = mrb_str_ptr(str);
  p = RSTRING_PTR(s);
  pend = p + RSTRING_LEN(s);

  if (seplen == 0) {
    return str;
  }

  if (pend >= p + seplen && strncmp(pend - seplen, sepstr, seplen) == 0) {
    RSTR_SET_LEN(s, pend - p - seplen);
    return str;
  }
  return mrb_nil_value();
}

/* 15.2.10.5.14 */
/*
 *  call-seq:
 *     str.chop   => new_str
 *
 *  Returns a new <code>String</code> with the last character removed.  If the
 *  string ends with <code>\r\n</code>, both characters are removed. Applying
 *  <code>chop</code> to an empty string returns an empty string.
 *
 *     "string\r\n".chop   #=> "string"
 *     "string\n\r".chop   #=> "string\n"
 *     "string\n".chop     #=> "string"
 *     "string".chop       #=> "strin"
 *     "x".chop            #=> ""
 *     "".chop             #=> ""
 */
static mrb_value
mrb_str_chop(mrb_state *mrb, mrb_value str)
{
  struct RString *s = mrb_str_ptr(str);
  mrb_int len = RSTRING_LEN(s);

  if (len == 0) {
    return mrb_str_new(mrb, "", 0);
  }
  if (len > 1 && s->as.heap.ptr[len - 1] == '\n' && s->as.heap.ptr[len - 2] == '\r') {
    return mrb_str_new(mrb, s->as.heap.ptr, len - 2);
  }
  if (len > 0 && (s->as.heap.ptr[len - 1] == '\n' || s->as.heap.ptr[len - 1] == '\r')) {
    return mrb_str_new(mrb, s->as.heap.ptr, len - 1);
  }
  return mrb_str_new(mrb, s->as.heap.ptr, len - 1);
}

/* 15.2.10.5.15 */
/*
 *  call-seq:
 *     str.chop!   => str or nil
 *
 *  Removes the last character of <i>str</i> if <i>str</i> ends with
 *  <code>\r\n</code>, <code>\n</code>, or <code>\r</code>.  Returns
 *  <code>nil</code> if no modifications were made.
 */
static mrb_value
mrb_str_chop_bang(mrb_state *mrb, mrb_value str)
{
  struct RString *s = mrb_str_ptr(str);
  mrb_int len = RSTRING_LEN(s);