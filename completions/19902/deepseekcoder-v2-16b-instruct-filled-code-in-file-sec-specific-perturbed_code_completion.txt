rb_nil_value();
}

/* 15.2.10.5.9  */
/*
 *  call-seq:
 *     str.capitalize   => new_str
 *
 *  Returns a copy of <i>str</i> with the first character converted to
 *  uppercase and the remainder to lowercase.
 *
 *     "hello".capitalize   #=> "Hello"
 *     "HELLO".capitalize   #=> "Hello"
 *     "123ABC".capitalize  #=> "123abc"
 */
static mrb_value
mrb_str_capitalize(mrb_state *mrb, mrb_value str)
{
  struct RString *s = str_new(mrb, 0, 0);

  str_with_class(s, str);
  if (RSTR_LEN(str) == 0 || !RSTR_PTR(str)) return mrb_obj_value(s);
  if (ISLOWER(RSTR_PTR(str)[0])) {
    s->as.heap.ptr[0] = TOUPPER(s->as.heap.ptr[0]);
  }
  memcpy(s->as.heap.ptr + 1, RSTR_PTR(str) + 1, RSTR_LEN(str));
  s->as.heap.len = RSTR_LEN(str);
  s->as.heap.aux.capa = RSTR_LEN(str);
  RSTR_UNSET_TYPE_FLAG(s);
  if (ISUPPER(s->as.heap.ptr[0])) {
    char *p = s->as.heap.ptr + 1;
    char *pend = s->as.heap.ptr + s->as.heap.len;

    while (p < pend) {
      if (ISUPPER(*p)) {
        *p = TOLOWER(*p);
      }
      p++;
    }
  }
  return mrb_obj_value(s);
}

/* 15.2.10.5.10 */
/*
 *  call-seq:
 *     str.casecmp(other_str)   => -1, 0, 1
 *
 *  Case-insensitive comparison of <i>str</i> with <i>other_str</i>.
 *
 *  If <i>str</i> <code><=></code> <i>other_str</i> is less than 0, returns -1.
 *  If <i>str</i> <code><=></code> <i>other_str</i> is greater than 0, returns 1.
 *  If they are equal, returns 0.
 *
 *     "abcdef".casecmp("abcde")     #=> 1
 *     "aBcDeF".casecmp("abcdef")    #=> 0
 *     "abcdef".casecmp("abcdefg")   #=> -1
 *     "abcdef".casecmp("ABCDEF")    #=> 0
 */
static mrb_value
mrb_str_casecmp(mrb_state *mrb, mrb_value str1, mrb_value str2)
{
  mrb_int result;

  str1 = mrb_str_to_str(mrb, str1);
  str2 = mrb_str_to_str(mrb, str2);
  result = strncasecmp(RSTRING_PTR(str1), RSTRING_PTR(str2), RSTRING_LEN(str1));
  if (result < 0) return mrb_fixnum_value(-1);
  if (result > 0) return mrb_fixnum_value(1);
  return mrb_fixnum_value(0);
}

/* 15.2.10.5.11 */
/*
 *  call-seq:
 *     str.center(integer, padstr)   => new_str
 *
 *  If <i>integer</i> is greater than the length of <i>str</i>, returns a new
 *  <code>String</code>, which is <i>str</i> centered in a field of width
 *  <i>integer</i>. Padding is done using the specified <i>padstr</i>; the
 *  default is a single space. The <i>padstr</i> should be at least one
 *  character in length, otherwise it is ignored.
 *
 *     "hello".center(4)         #=> "hello"
 *     "hello".center(20)        #=> "       hello        "
 *     "hello".center(20, "=")   #=> "=========hello========"
 */
static mrb_value
mrb_str_center(mrb_state *mrb, mrb_value str, mrb_int argc, mrb_value *argv)
{
  mrb_int len, padlen;
  const char *padstr;
  struct RString *s;
  char *p;

  if (argc == 0) {
    padstr = " ";
    padlen = 1;
  }
  else {
    padstr = RSTRING_PTR(argv[0]);
    padlen = RSTRING_LEN(argv[0]);
  }

  len = RSTRING_LEN(str);
  if (len >= argc) {
    return mrb_str_dup(mrb, str);
  }
  if (padlen < 1) {
    padlen = 1;
  }
  s = str_new(mrb, 0, len + 2 * padlen);
  p = RSTR_PTR(s);
  {
    const char *src = RSTRING_PTR(str);
    mrb_int srclen = RSTRING_LEN(str);
    mrb_int i;

    for (i = 0; i < padlen; i++) {
      *p++ = padstr[i % padlen];
    }
    for (i = 0; i < srclen; i++) {
      *p++ = src[i];
    }
    for (i = 0; i < padlen; i++) {
      *p++ = padstr[i % padlen];
    }
  }
  RSTR_SET_LEN(s, len + 2 * padlen);
  return mrb_obj_value(s);
}

/* 15.2.10.5.12 */
/*
 *  call-seq:
 *     str.chomp([separator])   => new_str
 *
 *  Returns a new <code>String</code> with the given record separator removed
 *  from the end of <i>str</i> (if present). If <i>separator</i> is not
 *  specified, it removes carriage return (0x0D) under Unix or carriage return
 *  and line feed (0x0D, 0x0A) under Windows.
 *
 *     "hello".chomp            #=> "hello"
 *     "hello\n".chomp          #=> "hello"
 *     "hello\r\n".chomp        #=> "hello"
 *     "hello\n\r".chomp        #=> "hello\n"
 *     "hello\r".chomp          #=> "hello"
 *     "hello \n there".chomp   #=> "hello \n there"
 *
 *     "hello".chomp("llo")     #=> "he"
 */
static mrb_value
mrb_str_chomp(mrb_state *mrb, mrb_value str, mrb_int argc, mrb_value *argv)
{
  const char *sep;
  mrb_int seplen;
  struct RString *s = mrb_str_ptr(str);
  const char *p = RSTRING_PTR(s) + RSTRING_LEN(s) - 1;

  if (argc == 0) {
    sep = "\n";
    seplen = 1;
  }
  else {
    sep = RSTRING_PTR(argv[0]);
    seplen = RSTRING_LEN(argv[0]);
  }

  if (RSTRING_LEN(s) >= seplen &&
      memcmp(p - seplen + 1, sep, seplen) == 0) {
    struct RString *s2 = str_new(mrb, 0, RSTRING_LEN(s) - seplen);

    memcpy(RSTR_PTR(s2), RSTR_PTR(s), RSTRING_LEN(s) - seplen);
    RSTR_SET_LEN(s2, RSTRING_LEN(s) - seplen);
    return mrb_obj_value(s2);
  }
  return mrb_str_dup(mrb, str);
}

/* 15.2.10.5.13 */
/*
 *  call-seq:
 *     str.chomp!(separator=$/)   => str or nil
 *
 *  Modifies <i>str</i> in place as described for <code>String#chomp</code>,
 *  returning <i>str</i>, or <code>nil</code> if no modifications were made.
 */
static mrb_value
mrb_str_chomp_bang(mrb_state *mrb, mrb_value str, mrb_int argc, mrb_value *argv)
{
  mrb_value result;

  result = mrb_str_chomp(mrb, str, argc, argv);
  if (mrb_str_equal(mrb, str, result)) {
    return mrb_nil_value();
  }
  return str;
}

/* 15.2.10.5.14 */
/*
 *  call-seq:
 *     str.chop   => new_str
 *
 *  Returns a new <code>String</code> with the last character removed.  If the
 *  string ends with <code>\r\n</code>, both characters are removed. Applying
 *  <code>chop</code> to an empty string returns an empty string.
 *
 *     "string\r\n".chop       #=> "string"
 *     "string\n\r".chop       #=> "string\n"
 *     "string\n".chop         #=> "string"
 *     "string".chop           #=> "strin"
 *     "x".chop                #=> ""
 *     "".chop                 #=> ""
 */
static mrb_value
mrb_str_chop(mrb_state *mrb, mrb_value str)
{
  struct RString *s = mrb_str_ptr(str);
  mrb_int len = RSTRING_LEN(s);

  if (len == 0) {
    return mrb_str_new_lit(mrb, "");
  }
  if (len > 1 && s->as.heap.ptr[len - 1] == '\n' && s->as.heap.ptr[len - 2] == '\r') {
    struct RString *s2 = str_new(mrb, 0, len - 2);

    memcpy(RSTR_PTR(s2), RSTR_PTR(s), len - 2);
    RSTR_SET_LEN(s2, len - 2);
    return mrb_obj_value(s2);
  }
  if (len > 0 && (s->as.heap.ptr[len - 1] == '\n' || s->as.heap.ptr[len - 1] == '\r')) {
    struct RString *s2 = str_new(mrb, 0, len - 1);

    memcpy(RSTR_PTR(s2), RSTR_PTR(s), len - 1);
    RSTR_SET_LEN(s2, len - 1);
    return mrb_obj_value(s2);
  }
  struct RString *s2 = str_new(mrb, 0, len - 1);

  memcpy(RSTR_PTR(s2), RSTR_PTR(s), len - 1);
  RSTR_SET_LEN(s2, len - 1);
  return mrb_obj_value(s2);
}

/* 15.2.10.5.15 */
/*
 *  call-seq:
 *     str.chop!   => str or nil
 *
 *  Removes the last character of <i>str</i> if <i>str</i> ends with
 *  <code>\r\n</code>, <code>\n</code>, or <code>\r</code>.  Returns
 *  <code>nil</code> if no modifications were made.
 */
static mrb_value
mrb_str_chop_bang(mrb_state *mrb, mrb