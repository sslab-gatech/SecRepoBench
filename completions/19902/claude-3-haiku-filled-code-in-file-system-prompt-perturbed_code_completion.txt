static double
mrb_str_len_to_dbl(mrb_state *state, const char *s, size_t len, mrb_bool badcheck)
{
  char buf[DBL_DIG + 10], *p, *pend;
  double d;

  p = buf;
  pend = buf + sizeof(buf) - 1;

  // 1. Trim leading whitespace from the input string.
  while (len > 0 && ISSPACE(*s)) {
    s++;
    len--;
  }

  // 2. Check for and handle hexadecimal prefixes "0x" or "0X".
  if (len >= 2 && s[0] == '0' && (s[1] == 'x' || s[1] == 'X')) {
    s += 2;
    len -= 2;
    // Handle hexadecimal conversion here
  }

  // 3. Prepare a buffer to store cleaned input by removing underscores between digits.
  while (len > 0 && p < pend) {
    if (*s == '_' && p > buf && isdigit(*(p-1))) {
      s++;
      len--;
      continue;
    }
    *p++ = *s++;
    len--;
  }
  *p = '\0';

nocopy:
  // 4. Convert the cleaned string in the buffer to a double using a library function.
  d = mrb_float_read(buf, &p);

  // 5. Handle null byte termination, and check for formatting errors when 'badcheck' is true.
  if (p == buf) {
    if (badcheck) {
bad:
      mrb_raisef(state, E_ARGUMENT_ERROR, "invalid string for float(%!s)", s);
      /* not reached */
    }
    return d;
  }
  if (badcheck) {
    if (!p || p == buf) goto bad;
    while (p < buf + sizeof(buf) - 1 && ISSPACE(*p)) p++;
    if (p < buf + sizeof(buf) - 1 && *p != '\0') goto bad;
  }
  return d;
}