char buf[1024];
  const char *p, *pend, *n;
  double d;

  /* 1. Trim leading whitespace from the input string. */
  while (len && ISSPACE(*char_buffer)) {
    char_buffer++;
    len--;
  }
  p = char_buffer;

  /* 2. Check for and handle hexadecimal prefixes "0x" or "0X". */
  if (len >= 2 && *p == '0' && (p[1] == 'x' || p[1] == 'X')) {
    buf[0] = '0';
    buf[1] = 'x';
    n = buf + 2;
    p += 2;
    len -= 2;
  }
  else {
    n = buf;
  }

  /* 3. Prepare a buffer to store cleaned input by removing underscores between digits. */
  pend = buf + sizeof(buf) - 1;

  /* 4. Iterate over the string, copying valid characters to the buffer. */
  while (len--) {
    if (ISDIGIT(*p) || *p == '.') {
      if (n < pend) *n++ = *p;
    }
    else if (*p == '_') {
      if (n > buf && ISDIGIT(n[-1])) {
        *n++ = *p;
      }
    }
    p++;
  }

  /* 5. Handle null byte termination, and check for formatting errors when 'badcheck' is true. */
  *n = '\0';
  p = buf;
  pend = n;
nocopy:
  d = mrb_float_read(p, &end);
  if (p == end) {
    if (badcheck) {
bad:
      mrb_raisef(mrb, E_ARGUMENT_ERROR, "invalid string for float(%!s)", char_buffer);
      /* not reached */
    }
    return d;
  }
  if (badcheck) {
    if (!end || p == end) goto bad;
    while (end<pend && ISSPACE(*end)) end++;
    if (end<pend) goto bad;
  }
  return d;