// <MASK>
  // 1. Trim leading whitespace from the input string.
  while (p < pend && ISSPACE(*p)) p++;
  if (p == pend) {
    if (badcheck) {
      mrb_raisef(mrb, E_ARGUMENT_ERROR, "invalid string for float(%!s)", char_buffer);
      /* not reached */
    }
    return d;
  }

  // 2. Check for and handle hexadecimal prefixes "0x" or "0X".
  if (p[0] == '0' && (p[1] == 'x' || p[1] == 'X')) {
    p += 2;
    if (p == pend) {
      if (badcheck) {
        mrb_raisef(mrb, E_ARGUMENT_ERROR, "invalid string for float(%!s)", char_buffer);
        /* not reached */
      }
      return d;
    }
  }

  // 3. Prepare a buffer to store cleaned input by removing underscores between digits.
  //    We will use a temporary buffer to store the cleaned string.
  char temp_buf[pend - p + 1];
  size_t temp_len = pend - p;
  size_t temp_idx = 0;
  for (size_t i = 0; i < temp_len; i++) {
    if (temp_buf[i]!= '_') {
      temp_buf[temp_idx++] = temp_buf[i];
    }
  }
  temp_buf[temp_idx] = '\0';

  // 4. Iterate over the string, copying valid characters to the buffer.
  //    We will use the `str_index_str_by_char_search` function to find the first occurrence of a non-digit character.
  const char *next_digit = char_backtrack(p, pend);
  if (next_digit == pend) {
    if (badcheck) {
      mrb_raisef(mrb, E_ARGUMENT_ERROR, "invalid string for float(%!s)", char_buffer);
      /* not reached */
    }
    return d;
  }
  p = next_digit;
  pend = n;
  *n = '\0';
  p = buf;
  pend = n;
  while (p < pend) {
    if (ISSPACE(*p)) break;
    if (ISDIGIT(*p)) {
      *p++ = *next_digit++;
      if (p == pend) break;
    } else {
      break;
    }
  }
  *p = '\0';

  // 5. Handle null byte termination, and check for formatting errors when 'badcheck' is true.
  if (p == pend) {
    if (badcheck) {
      mrb_raisef(mrb, E_ARGUMENT_ERROR, "invalid string for float(%!s)", char_buffer);
      /* not reached */
    }
    return d;
  }

  // 6. Convert the cleaned string in the buffer to a double using a library function.
  d = mrb_float_read(buf, &pend);
  if (p!= pend) {
    if (badcheck) {
      mrb_raisef(mrb, E_ARGUMENT_ERROR, "invalid string for float(%!s)", char_buffer);
      /* not reached */
    }
    return d;
  }

  // 7. Return the parsed double value.
  return d;