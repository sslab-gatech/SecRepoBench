char buf[1024]; // Adjust the size as needed to accommodate the input string
  char *p, *pend, *n;
  size_t i;

  // Step 1: Trim leading whitespace
  while (len > 0 && isspace((unsigned char)*char_buffer)) {
    char_buffer++;
    len--;
  }

  // Step 2: Check for and handle hexadecimal prefixes "0x" or "0X"
  if (len >= 2 && char_buffer[0] == '0' && (char_buffer[1] == 'x' || char_buffer[1] == 'X')) {
    char_buffer += 2;
    len -= 2;
  }

  // Step 3: Prepare a buffer to store cleaned input by removing underscores between digits
  n = buf;
  for (i = 0; i < len; i++) {
    if (char_buffer[i] != '_') {
      *n++ = char_buffer[i];
    }
  }
  *n = '\0';

  // Step 4: Handle null byte termination
  pend = buf + (n - buf);

  // Step 5: Convert the cleaned string in the buffer to a double using a library function
  p = buf;

  // Step 6: Check for formatting errors when 'badcheck' is true
  if (badcheck) {
    while (p < pend && ISSPACE(*p)) p++;
    if (p == pend) goto bad;
  }

  // Step 7: Return the parsed double value
  d = mrb_float_read(p, &end);
  if (p == end) {
    if (badcheck) {
      goto bad;
    }
    return d;
  }

  if (badcheck) {
    if (!end || p == end) goto bad;
    while (end < pend && ISSPACE(*end)) end++;
    if (end < pend) goto bad;
  }

  return d;

bad:
  mrb_raisef(mrb, E_ARGUMENT_ERROR, "invalid string for float(%!s)", char_buffer);
  /* not reached */