const char *p = s;
  const char *end = s + len;

  while (p < end && ISSPACE(*p)) p++;

  if (p >= end) {
    if (badcheck) {
      mrb_raisef(state, E_ARGUMENT_ERROR, "invalid string for float(%!s)", s);
    }
    return 0.0;
  }

  size_t buf_size = (end - p) + 1;
  char *buf = mrb_malloc(state, buf_size);
  char *n = buf;

  if (*p == '+' || *p == '-') {
    *n++ = *p++;
  }

  mrb_bool is_hex = FALSE;
  if (p + 1 < end && *p == '0' && (p[1] == 'x' || p[1] == 'X')) {
    is_hex = TRUE;
    *n++ = *p++;
    *n++ = *p++;
  }

  mrb_bool prev_was_digit = FALSE;

  for (; p < end; p++) {
    char c = *p;

    if (c == '_') {
      if (prev_was_digit && p + 1 < end) {
        char next_c = p[1];
        mrb_bool next_is_digit = is_hex ? isxdigit(next_c) : isdigit(next_c);
        if (next_is_digit) {
          continue;
        }
      }

      if (badcheck) {
        mrb_free(state, buf);
        goto bad;
      }

      *n++ = c;
      prev_was_digit = FALSE;
    } else {
      mrb_bool valid;
      if (is_hex) {
        valid = isxdigit(c) || c == '.' || c == 'p' || c == 'P' || c == '+' || c == '-';
      } else {
        valid = isdigit(c) || c == '.' || c == 'e' || c == 'E' || c == '+' || c == '-';
      }

      if (!valid) {
        if (badcheck) {
          mrb_free(state, buf);
          goto bad;
        }
        *n++ = c;
        prev_was_digit = FALSE;
      } else {
        *n++ = c;
        prev_was_digit = is_hex ? isxdigit(c) : isdigit(c);
      }
    }
  }

  *n = '\0';