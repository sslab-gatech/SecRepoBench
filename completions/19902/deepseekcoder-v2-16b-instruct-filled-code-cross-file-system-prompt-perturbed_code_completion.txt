// Parse a string to a double value, handling various string formats.
  // 1. Trim leading whitespace from the input string.
  // 2. Check for and handle hexadecimal prefixes "0x" or "0X".
  // 3. Prepare a buffer to store cleaned input by removing underscores between digits.
  // 4. Iterate over the string, copying valid characters to the buffer.
  // 5. Handle null byte termination, and check for formatting errors when 'badcheck' is true.
  // 6. Convert the cleaned string in the buffer to a double using a library function.
  // 7. Return the parsed double value.

  char buf[256];
  char *p, *pend, *n;
  const char *end;
  double d;

  // Copy valid characters to the buffer, removing underscores
  p = buf;
  pend = buf + sizeof(buf) - 1;
  const char *src = s;
  while (src < s + len && ISSPACE(*src)) src++;
  if (src < s + len && (*src == '0' && (src[1] == 'x' || src[1] == 'X'))) {
    src += 2;
    while (src < s + len && isxdigit((unsigned char)*src)) {
      *p++ = *src++;
    }
  } else {
    while (src < s + len && isdigit((unsigned char)*src)) {
      *p++ = *src++;
    }
  }
  while (src < s + len && *src == '_') src++;
  if (src < s + len && isdigit((unsigned char)*src)) {
    *p++ = *src++;
  }
  *p = '\0';

  // Handle null byte termination
  n = buf;
  while (*n != '\0') n++;
  if (n >= buf && n < buf + sizeof(buf) - 1) {
    *n = '\0';
  } else {
    *n = '\0';
    goto nocopy;
  }

  // Convert the cleaned string in the buffer to a double using a library function
  d = mrb_float_read(buf, &end);
  if (badcheck && (end == buf || end > n)) {
    goto bad;
  }

  // Return the parsed double value
  return d;