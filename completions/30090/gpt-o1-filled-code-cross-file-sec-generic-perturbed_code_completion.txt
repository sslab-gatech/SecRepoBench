/* If we didn't find the time_key, skip will remain map_size. Otherwise,
     * skip will be set to the index of the matching key if time_keep is false,
     * or to -1 if time_keep is true (so we keep the key). In either case,
     * we attempt to parse the associated value as a time string. */
    if (skip < map_size || skip == -1) {
        int idx;

        /* Determine the index of the time field we found */
        if (skip == -1) {
            idx = index; /* time_keep is true */
        }
        else {
            idx = skip;  /* time_keep is false */
        }

        /* Validate index bounds */
        if (idx >= 0 && idx < (int) map_size) {
            msgpack_object *time_val = &map.via.map.ptr[idx].val;

            /* Only attempt to parse if the value is a string */
            if (time_val->type == MSGPACK_OBJECT_STR) {
                size_t len = time_val->via.str.size;

                /* Ensure we don't overrun the tmp buffer */
                if (len >= sizeof(tmp)) {
                    flb_warn("[parser] time field is too long, setting to 0");
                    time_lookup = 0;
                    tmfrac = 0.0;
                }
                else {
                    memcpy(tmp, time_val->via.str.ptr, len);
                    tmp[len] = '\0';

                    /* Attempt to parse time using the provided format */
                    ret = flb_parser_time_to_epoch(parser->time_fmt,
                                                   parser->time_zone,
                                                   tmp, &tm, &tmfrac,
                                                   &time_lookup);
                    if (ret < 0) {
                        flb_warn("[parser] failed to parse time string '%s', setting to 0", tmp);
                        time_lookup = 0;
                        tmfrac      = 0.0;
                    }
                }
            }
            else {
                /* Value is not a string, cannot parse time */
                flb_warn("[parser] time field is not a string, setting to 0");
                time_lookup = 0;
                tmfrac = 0.0;
            }
        }
    }
    else {
        /* We did not find any matching time_key */
        time_lookup = 0;
        tmfrac = 0.0;
    }