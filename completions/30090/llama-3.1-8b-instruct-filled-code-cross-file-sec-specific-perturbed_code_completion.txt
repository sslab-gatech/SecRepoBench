// <MASK>
if (k->type!= MSGPACK_OBJECT_STR || v.type!= MSGPACK_OBJECT_STR) {
    flb_free(mp_buf);
    *out_buf = NULL;
    msgpack_unpacked_destroy(&result);
    return -1;
}

/* Check if a valid key-value pair exists in the map at the specified index. */
if (index == skip) {
    continue;
}

/* Attempt to parse the value as a time string. */
if (msgpack_unpack_str(&result, v.via.str.ptr, v.via.str.size, &time_lookup, &tmfrac) == MSGPACK_UNPACK_SUCCESS) {
    /* Convert the parsed time to a timestamp. */
    t = out_time;
    t->tm.tv_sec  = time_lookup;
    t->tm.tv_nsec = (tmfrac * 1000000000);
}
else {
    /* Log a warning and set the timestamp to zero if the time parsing fails. */
    flb_warning("Failed to parse time string: %.*s", (int)v.via.str.size, v.via.str.ptr);
    t = out_time;
    t->tm.tv_sec  = 0;
    t->tm.tv_nsec = 0;
}

/* Compose a new map without the time_key field */
msgpack_sbuffer_init(&mp_sbuf);
msgpack_packer_init(&mp_pck, &mp_sbuf, msgpack_sbuffer_write);

if (parser->time_keep == FLB_FALSE) {
    msgpack_pack_map(&mp_pck, map_size - 1);
}
else {
    msgpack_pack_map(&mp_pck, map_size);
}

for (index = 0; index < map_size; index++) {
    if (index == skip) {
        continue;
    }
    msgpack_pack_object(&mp_pck, map.via.map.ptr[index].key);
    msgpack_pack_object(&mp_pck, map.via.map.ptr[index].val);
}

/* Export the proper buffer */
flb_free(tmp_out_buf);
*out_buf = mp_sbuf.data;
*out_size = mp_sbuf.size;