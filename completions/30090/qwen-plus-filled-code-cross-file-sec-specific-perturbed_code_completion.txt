if (skip >= 0 && skip < map_size) {
    k = &map.via.map.ptr[skip].key;
    v = &map.via.map.ptr[skip].val;

    if (k->type == MSGPACK_OBJECT_STR && v->type == MSGPACK_OBJECT_STR) {
        char *time_str = v->via.str.ptr;
        size_t time_str_len = v->via.str.size;

        if (time_str != NULL && time_str_len > 0) {
            // Attempt to parse the value as a time string
            struct tm parsed_tm = {0};
            if (strptime(time_str, parser->time_fmt, &parsed_tm) != NULL) {
                time_lookup = mktime(&parsed_tm);
                tmfrac = modf(difftime(time_lookup, mktime(&tm)), NULL);
            } else {
                flb_warn("[parser] Failed to parse time with format '%s'", parser->time_fmt);
                time_lookup = 0;
            }
        } else {
            flb_warn("[parser] Time key value is null or empty");
            time_lookup = 0;
        }
    } else {
        flb_warn("[parser] Time key or value is not a string");
        time_lookup = 0;
    }
} else {
    flb_warn("[parser] No valid time_key field found in the map");
    time_lookup = 0;
}