if (k == NULL || v == NULL) {
    msgpack_unpacked_destroy(&result);
    return *out_size;
}

/* Time key lookup */
if (v->type != MSGPACK_OBJECT_STR) {
    flb_warn("[parser:json] skip time parsing, value is not a string (type=%d)",
             v->type);
    time_lookup = 0;
    tmfrac = 0;
    /* We need to reset skip so we don't delete the field from the output map */
    skip = -1;
}
else {
    /* Convert string to a unix timestamp */
    ret = flb_parser_time_parse(v->via.str.ptr, v->via.str.size,
                               &tm, &tmfrac, parser);
    if (ret == -1) {
        flb_warn("[parser:json] time parsing error '%.*s'",
                 (int) v->via.str.size, v->via.str.ptr);
        time_lookup = 0;
        tmfrac = 0;
    }
    else {
        /* Convert time struct to unix timestamp */
        time_lookup = mktime(&tm);
    }
}