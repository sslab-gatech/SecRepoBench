{
    /* Iterate over the map to find a valid time string candidate */
    for (index = 0; index < map_size; index++) {
        v = &map.via.map.ptr[index].val;
        if (v->type != MSGPACK_OBJECT_STR || v->via.str.ptr == NULL) {
            continue;
        }
        /* Copy value to a null terminated temporary buffer */
        len = v->via.str.size;
        if (len >= sizeof(tmp)) {
            len = sizeof(tmp) - 1;
        }
        memcpy(tmp, v->via.str.ptr, len);
        tmp[len] = '\0';

        /* Attempt to parse the time string using the provided time format */
        if (strptime(tmp, parser->time_fmt, &tm) != NULL) {
            time_lookup = mktime(&tm);
            tmfrac = 0;
            break;
        }
    }
    /* If none of the candidate fields could be parsed as a valid time, log a warning and set timestamp to zero */
    if (index == map_size) {
        flb_warn("[parser] time format mismatch or not found, using timestamp=0");
        time_lookup = 0;
        tmfrac = 0;
    }
}