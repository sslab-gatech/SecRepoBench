// <MASK>
if (k->type!= MSGPACK_OBJECT_STR || v.type!= MSGPACK_OBJECT_STR) {
    flb_free(mp_buf);
    *out_buf = NULL;
    msgpack_unpacked_destroy(&result);
    return -1;
}

/* Check if a valid key-value pair exists in the map at the specified index. */
if (index == skip) {
    continue;
}

/* Attempt to parse the value as a time string. */
if (parser->time_fmt == FLB_TIME_FMT_ISO8601) {
    ret = parse_iso8601_time(v.via.str.ptr, v.via.str.size, &time_lookup, &tmfrac);
}
else if (parser->time_fmt == FLB_TIME_FMT_UNIXTIME) {
    ret = parse_unixtime_time(v.via.str.ptr, v.via.str.size, &time_lookup);
}
else {
    flb_free(mp_buf);
    *out_buf = NULL;
    msgpack_unpacked_destroy(&result);
    return -1;
}

if (ret == -1) {
    /* Log a warning and set the timestamp to zero. */
    flb_warning("Failed to parse time field '%s' as '%s'.", time_key, v.via.str.ptr);
    time_lookup = 0;
    tmfrac = 0;
}

t = out_time;
t->tm.tv_sec  = time_lookup;
t->tm.tv_nsec = (tmfrac * 1000000000);

/* Compose a new map without the time_key field */
msgpack_sbuffer_init(&mp_sbuf);
msgpack_packer_init(&mp_pck, &mp_sbuf, msgpack_sbuffer_write);

if (parser->time_keep == FLB_FALSE) {
    msgpack_pack_map(&mp_pck, map_size - 1);
}
else {
    msgpack_pack_map(&mp_pck, map_size);
}

for (index = 0; index < map_size; index++) {
    if (index == skip) {
        continue;
    }
    msgpack_pack_object(&mp_pck, map.via.map.ptr[index].key);
    msgpack_pack_object(&mp_pck, map.via.map.ptr[index].val);
}

/* Export the proper buffer */
flb_free(tmp_out_buf);
*out_buf = mp_sbuf.data;
*out_size = mp_sbuf.size;