/* No time_key field found */
/* Check if a valid key-value pair exists in the map at the specified index.
 * If a valid pair is found, attempt to parse the value as a time string.
 * Convert the parsed time to a timestamp. If the time parsing fails, log a warning and set the timestamp to zero.
 */
k = &map.via.map.ptr[skip].key;
v = &map.via.map.ptr[skip].val;

if (k->type != MSGPACK_OBJECT_STR || v->type != MSGPACK_OBJECT_STR) {
    msgpack_unpacked_destroy(&result);
    return -1;
}

char *time_str = flb_sds_copy(NULL, v->via.str.ptr, v->via.str.size);
if (!time_str) {
    msgpack_unpacked_destroy(&result);
    return -1;
}

struct tm tm_tmp = {0};
time_t parsed_time = 0;
char *end_ptr;

tm_tmp.tm_year = -1; // Mark as uninitialized
parsed_time = strptime(time_str, parser->time_fmt, &tm_tmp);
if (parsed_time == 0 && tm_tmp.tm_year == -1) {
    flb_error("Failed to parse time string using format '%s'", parser->time_fmt);
} else if (parsed_time == 0) {
    parsed_time = mktime(&tm_tmp);
}

flb_free(time_str);

if (parsed_time == (time_t)-1) {
    flb_error("Invalid time string");
    parsed_time = 0;
}

time_lookup = parsed_time;