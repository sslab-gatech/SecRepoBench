/* Lookup time field */
    map_size = map.via.map.size;
    skip = map_size;
    for (index = 0; index < map_size; index++) {
        k = &map.via.map.ptr[index].key;
        v = &map.via.map.ptr[index].val;

        if (k->via.str.size != slen) {
            continue;
        }

        /* Ensure the pointer we are about to read is not NULL */
        if (k->via.str.ptr == NULL) {
            flb_free(mp_buf);
            *out_buf = NULL;
            msgpack_unpacked_destroy(&result);
            return -1;
        }

        if (strncmp(k->via.str.ptr, time_key, k->via.str.size) == 0) {
            /* We found the key, break the loop and keep the index */
            if (parser->time_keep == FLB_FALSE) {
                skip = index;
                break;
            }
            else {
                skip = -1;
            }
            break;
        }

        k = NULL;
        v = NULL;
    }

    /* No time_key field found */
    if (skip == map_size) {
        flb_free(mp_buf);
        *out_buf = NULL;
        msgpack_unpacked_destroy(&result);
        return -1;
    }

    /* Parse the time string and convert it to a timestamp */
    if (v->type != MSGPACK_OBJECT_STR) {
        flb_warn("[flb_parser_json_do] time_key value is not a string");
        time_lookup = 0;
    }
    else {
        char *end;
        time_lookup = strtol(v->via.str.ptr, &end, 10);
        if (*end != '\0') {
            flb_warn("[flb_parser_json_do] time_key value is not a valid integer");
            time_lookup = 0;
        }
    }

    /* Set the timestamp in the output time structure */
    t = out_time;
    t->tm.tv_sec  = time_lookup;
    t->tm.tv_nsec = (tmfrac * 1000000000);