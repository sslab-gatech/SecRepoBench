/* Check if a valid key-value pair exists in the map at the specified index.
 * If a valid pair is found, attempt to parse the value as a time string.
 * Convert the parsed time to a timestamp. If the time parsing fails, log a warning and set the timestamp to zero.
 */
if (index!= skip) {
    k = map.via.map.ptr[index].key;
    v = map.via.map.ptr[index].val;

    if (k.type!= MSGPACK_OBJECT_STR || v.type!= MSGPACK_OBJECT_STR) {
        continue;
    }

    if (strncmp(k.via.str.ptr, time_key, k.via.str.size) == 0) {
        /* We found the key, break the loop and keep the index */
        if (parser->time_keep == FLB_FALSE) {
            skip = index;
            break;
        }
        else {
            skip = -1;
        }
        break;
    }

    /* Attempt to parse the value as a time string */
    if (parser->time_fmt == FLB_TIME_FMT_ISO8601) {
        struct tm tm = {0};
        time_t time_lookup;
        char *time_str = NULL;
        size_t time_str_len = 0;

        time_str = flb_sds_cstr(v.via.str.ptr, v.via.str.size);
        if (time_str == NULL) {
            flb_errno();
            continue;
        }

        time_str_len = strlen(time_str);
        if (time_str_len == 0) {
            flb_free(time_str);
            continue;
        }

        if (strptime(time_str, parser->time_fmt, &tm) == NULL) {
            flb_warning("Failed to parse time string: %s", time_str);
            flb_free(time_str);
            continue;
        }

        time_lookup = mktime(&tm);
        tmfrac = tm.tm_sec + tm.tm_min / 60.0 + tm.tm_hour / 3600.0;
        flb_free(time_str);
    }
    else if (parser->time_fmt == FLB_TIME_FMT_UNIX) {
        time_lookup = (time_t) v.via.str.ptr;
        tmfrac = 0;
    }
    else {
        flb_warning("Unsupported time format: %s", parser->time_fmt);
        continue;
    }

    t = out_time;
    t->tm.tv_sec  = time_lookup;
    t->tm.tv_nsec = (tmfrac * 1000000000);
}