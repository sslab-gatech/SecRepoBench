/* No time_key field found */
/* Check if a valid key-value pair exists in the map at the specified index.
 * If a valid pair is found, attempt to parse the value as a time string.
 * Convert the parsed time to a timestamp. If the time parsing fails, log a warning and set the timestamp to zero.
 */
k = &map.via.map.ptr[skip].key;
v = &map.via.map.ptr[skip].val;

if (k->type != MSGPACK_OBJECT_STR || v->type != MSGPACK_OBJECT_STR) {
    msgpack_unpacked_destroy(&result);
    return -1;
}

/* Parse the time string */
char *time_str = flb_malloc(k->via.str.size + 1);
if (!time_str) {
    msgpack_unpacked_destroy(&result);
    return -1;
}
memcpy(time_str, k->via.str.ptr, k->via.str.size);
time_str[k->via.str.size] = '\0';

struct tm tm = {0};
time_t time_parsed;
char *endptr;

time_parsed = strptime(time_str, parser->time_fmt, &tm);
if (time_parsed == NULL) {
    flb_warn("Failed to parse time string '%s' with format '%s'", time_str, parser->time_fmt);
    time_parsed = 0;
}

flb_free(time_str);

/* Set the parsed time to the output time structure */
time_lookup = mktime(&tm);
if (time_lookup == -1) {
    time_lookup = 0;
}