if (skip >= 0 && skip < map_size) {
    k = &map.via.map.ptr[skip].key;
    v = &map.via.map.ptr[skip].val;

    if (k->type == MSGPACK_OBJECT_STR &&
        v->type == MSGPACK_OBJECT_STR) {

        len = v->via.str.size;
        if (len > 0) {
            char *time_str = flb_malloc(len + 1);
            if (!time_str) {
                msgpack_unpacked_destroy(&result);
                return -1;
            }
            memcpy(time_str, v->via.str.ptr, len);
            time_str[len] = '\0';

            /* Attempt to parse the string into a timestamp */
            ret = parser->time_parser(time_str, &time_lookup, &tmfrac);
            flb_free(time_str);

            if (ret == -1) {
                flb_warn("[parser] could not parse time_key='%s' with format='%s'",
                         parser->time_key, parser->time_fmt);
                time_lookup = 0;
                tmfrac = 0.0;
            }
        }
        else {
            flb_warn("[parser] empty value found for time_key='%s'",
                     parser->time_key);
            time_lookup = 0;
            tmfrac = 0.0;
        }
    }
    else {
        flb_warn("[parser] invalid type for time_key='%s', expected string",
                 parser->time_key);
        time_lookup = 0;
        tmfrac = 0.0;
    }
}
else {
    flb_warn("[parser] no valid time_key='%s' field found in record",
             parser->time_key);
    time_lookup = 0;
    tmfrac = 0.0;
}