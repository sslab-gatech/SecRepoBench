{
    int found_time = 0;
    for (index = 0; index < map_size; index++) {
        /* Skip the entry if it's already been removed via time_key setting */
        if (index == skip) {
            continue;
        }
        v = &map.via.map.ptr[index].val;
        if (v->type == MSGPACK_OBJECT_STR && v->via.str.ptr) {
            char buf[v->via.str.size + 1];
            memcpy(buf, v->via.str.ptr, v->via.str.size);
            buf[v->via.str.size] = '\0';
            memset(&tm, 0, sizeof(tm));
            if (strptime(buf, parser->time_fmt, &tm) != NULL) {
                time_lookup = mktime(&tm);
                found_time = 1;
                break;
            }
        }
        else if (v->type == MSGPACK_OBJECT_POSITIVE_INTEGER ||
                 v->type == MSGPACK_OBJECT_NEGATIVE_INTEGER) {
            time_lookup = v->via.i64;
            found_time = 1;
            break;
        }
    }
    if (!found_time) {
        flb_warn("[parser] time field not found or parsing failed, using epoch 0");
        time_lookup = 0;
        tmfrac = 0;
    }
}