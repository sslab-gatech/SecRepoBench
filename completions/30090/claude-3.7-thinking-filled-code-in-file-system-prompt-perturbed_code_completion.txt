if (k == NULL || v == NULL) {
    /* No time key field found */
    flb_warn("[parser:%s] time_key='%s' not found in record", 
             parser->name, time_key);
    time_lookup = 0;
    return *out_size;
}

/* Convert time value to unix timestamp */
switch (v->type) {
    case MSGPACK_OBJECT_STR:
        len = v->via.str.size;
        if (len > sizeof(tmp) - 1) {
            len = sizeof(tmp) - 1;
        }
        memcpy(tmp, v->via.str.ptr, len);
        tmp[len] = '\0';

        if (parser->time_fmt_year == FLB_PARSER_FMT_YEAR_ISO) {
            ret = flb_parser_time_iso8601_to_unix_timestamp(tmp, len, &time_lookup, &tmfrac);
        }
        else if (parser->time_fmt_year == FLB_PARSER_FMT_YEAR_MSSQL) {
            ret = flb_parser_time_mssql_to_unix_timestamp(tmp, len, &time_lookup, &tmfrac);
        }
        else {
            ret = flb_parser_time_format_to_unix_timestamp(tmp, len, parser->time_fmt, &time_lookup, &tmfrac);
        }
        
        if (ret == -1) {
            flb_warn("[parser:%s] invalid time format for '%s'", parser->name, tmp);
            time_lookup = 0;
            tmfrac = 0;
        }
        break;
    case MSGPACK_OBJECT_MAP:
        /* Time may come in the map as a map */
        ret = flb_parser_time_subparsing(parser, v, &time_lookup, &tmfrac);
        if (ret == -1) {
            time_lookup = 0;
            tmfrac = 0;
        }
        break;
    case MSGPACK_OBJECT_POSITIVE_INTEGER:
        time_lookup = v->via.u64;
        break;
    case MSGPACK_OBJECT_FLOAT:
        time_lookup = v->via.f64;
        break;
    default:
        flb_warn("[parser:%s] time provided invalid type=%i", parser->name, v->type);
        time_lookup = 0;
        tmfrac = 0;
        break;
}