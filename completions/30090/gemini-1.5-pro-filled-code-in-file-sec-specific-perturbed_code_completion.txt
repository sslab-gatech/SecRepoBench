if (k != NULL && v != NULL) {
    if (v->type == MSGPACK_OBJECT_POSITIVE_INTEGER) {
        len = snprintf(tmp, sizeof(tmp) - 1, "%" PRIu64, v->via.u64);
    }
    else if (v->type == MSGPACK_OBJECT_FLOAT) {
        len = snprintf(tmp, sizeof(tmp) - 1, "%f", v->via.f64);
    }
    else if (v->type == MSGPACK_OBJECT_STRING) {
        len = v->via.str.size;
        if (len >= sizeof(tmp)) {
            len = sizeof(tmp) - 1;
        }
        memcpy(tmp, v->via.str.ptr, len);
    }
    else {
        flb_plg_warn(parser->p,
                     "parser_json: time lookup key has an invalid type: %i",
                     v->type);
        time_lookup = 0;
        goto compose;
    }

    if (len >= sizeof(tmp)) {
        flb_plg_warn(parser->p,
                     "parser_json: time lookup value exceeds buffer size: %zu",
                     sizeof(tmp));
        time_lookup = 0;
        goto compose;
    }

    tmp[len] = '\0';
    ret = flb_parser_time_lookup(tmp, len, &tm, &tmfrac, parser);
    if (ret == -1) {
        flb_plg_warn(parser->p,
                     "parser_json: time lookup value parse error: %s", tmp);
        time_lookup = 0;
    }
    else {
        time_lookup = mktime(&tm); /* Convert to UTC */
    }
}
else {
    time_lookup = 0;
}

compose:;