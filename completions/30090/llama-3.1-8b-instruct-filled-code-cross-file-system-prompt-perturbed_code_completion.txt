/* Check if a valid key-value pair exists in the map at the specified index.
 * If a valid pair is found, attempt to parse the value as a time string.
 * Convert the parsed time to a timestamp. If the time parsing fails, log a warning and set the timestamp to zero.
 */
if (index!= skip) {
    k = map.via.map.ptr[index].key;
    v = map.via.map.ptr[index].val;

    if (k.type!= MSGPACK_OBJECT_STR || v.type!= MSGPACK_OBJECT_STR) {
        continue;
    }

    if (strncmp(k.via.str.ptr, time_key, k.via.str.size) == 0) {
        /* We found the key, break the loop and keep the index */
        if (parser->time_keep == FLB_FALSE) {
            skip = index;
            break;
        }
        else {
            skip = -1;
        }
        break;
    }

    /* Attempt to parse the value as a time string */
    tmfrac = 0;
    time_lookup = 0;
    ret = flb_parse_time(v.via.str.ptr, v.via.str.size, &time_lookup, &tmfrac);
    if (ret == 0) {
        t = out_time;
        t->tm.tv_sec  = time_lookup;
        t->tm.tv_nsec = (tmfrac * 1000000000);
    }
    else {
        flb_warning("Failed to parse time string: %s", v.via.str.ptr);
        t->tm.tv_sec  = 0;
        t->tm.tv_nsec = 0;
    }
}