if (k != NULL && v != NULL) {
    if (v->type == MSGPACK_OBJECT_POSITIVE_INTEGER) {
        len = snprintf(tmp, sizeof(tmp) - 1, "%" PRIu64, v->via.u64);
        if (len > sizeof(tmp) - 1) {
            len = sizeof(tmp) - 1;
        }
    }
    else if (v->type == MSGPACK_OBJECT_FLOAT) {
        len = snprintf(tmp, sizeof(tmp) - 1, "%f", v->via.f64);
        if (len > sizeof(tmp) - 1) {
            len = sizeof(tmp) - 1;
        }
    }
    else if (v->type == MSGPACK_OBJECT_STRING) {
        len = v->via.str.size;
        if (len > sizeof(tmp) -1) {
            len = sizeof(tmp) -1;
        }
        memcpy(tmp, v->via.str.ptr, len);
    }
    else {
        flb_plg_warn(parser->p,
                     "parser_json: unsupported time value type=%i",
                     v->type);
        time_lookup = 0;
        goto compose;
    }

    tmp[len] = '\0';
    ret = flb_parser_time_lookup(tmp, len, parser->time_fmt, &tm, &tmfrac);
    if (ret == -1) {
        flb_plg_warn(parser->p,
                     "parser_json: could not parse time string: %s", tmp);
        time_lookup = 0;
    }
    else {
        time_lookup = mktime(&tm); /* Convert to UTC */
    }
}
else {
    time_lookup = 0;
}

compose:;