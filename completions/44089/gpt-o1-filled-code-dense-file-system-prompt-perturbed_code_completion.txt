char number_buf[str_len + 1];
memcpy(number_buf, str_val, str_len);
number_buf[str_len] = '\0';

errno = 0;
double dval = strtod(number_buf, &endp);
if ((endp == number_buf) || (*endp != '\0') || errno == ERANGE) {
    PLIST_JSON_ERR("%s: invalid numeric value '%.*s'\n", __func__, (int)str_len, str_val);
} else {
    /* check whether the parsed double is actually an integer and non-negative */
    if ((floor(dval) == dval) && (dval >= 0.0)) {
        parsed_value = plist_new_uint((uint64_t)dval);
    } else {
        parsed_value = plist_new_real(dval);
    }
}