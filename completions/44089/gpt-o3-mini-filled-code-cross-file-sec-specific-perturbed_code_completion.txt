char* num_str = (char*)malloc(str_len + 1);
    if (!num_str) {
        PLIST_JSON_ERR("%s: Out of memory\n", __func__);
        return NULL;
    }
    memcpy(num_str, str_val, str_len);
    num_str[str_len] = '\0';
    
    errno = 0;
    int is_float = 0;
    for (size_t i = 0; i < str_len; i++) {
        if (num_str[i] == '.' || num_str[i] == 'e' || num_str[i] == 'E') {
            is_float = 1;
            break;
        }
    }
    
    if (!is_float) {
        long long int_val = strtoll(num_str, &endp, 10);
        if (endp != num_str + str_len || errno == ERANGE) {
            PLIST_JSON_ERR("%s: invalid integer value '%s' encountered\n", __func__, num_str);
            free(num_str);
            return NULL;
        }
        parsed_value = plist_new_uint((uint64_t)int_val);
    } else {
        double dbl_val = strtod(num_str, &endp);
        if (endp != num_str + str_len || errno == ERANGE) {
            PLIST_JSON_ERR("%s: invalid real value '%s' encountered\n", __func__, num_str);
            free(num_str);
            return NULL;
        }
        parsed_value = plist_new_real(dbl_val);
    }
    free(num_str);