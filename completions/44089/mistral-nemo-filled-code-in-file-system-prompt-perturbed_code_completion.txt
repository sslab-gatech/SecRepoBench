// <MASK>
    if (str_val[0] == '-' || isdigit(str_val[0])) {
        char* endp = NULL;
        // Parse a numerical value from the JSON string, starting from the current token.
        // If the value is an integer, create a new unsigned integer plist node.
        // If the value is a floating-point number, create a new real plist node.
        // If the value contains invalid characters for a number, log an error message.
        char* val = strndup(js + ti->tokens[*index].start, ti->tokens[*index].end - ti->tokens[*index].start);
        double realval = strtod(val, &endp);
        if (endp == val + ti->tokens[*index].end - ti->tokens[*index].start) {
            // The entire string is a valid floating-point number.
            plist_t node = plist_new_real(realval);
            (*index)++;
            free(val);
            return node;
        } else if (*endp == '\0') {
            // The entire string is a valid integer.
            uint64_t uintval = strtoull(val, NULL, 10);
            if (uintval <= INT64_MAX) {
                plist_t node = plist_new_uint(uintval);
                (*index)++;
                free(val);
                return node;
            } else {
                PLIST_JSON_ERR("%s: integer value '%s' too large\n", __func__, val);
                free(val);
                return NULL;
            }
        } else {
            PLIST_JSON_ERR("%s: invalid numerical value '%s' encountered\n", __func__, val);
            free(val);
            return NULL;
        }
    }