for (i=0; i < Icc -> TagCount; i++) {

    if (Icc ->TagNames[i] == (cmsTagSignature) 0) continue;   // It is just a placeholder

    // Read the tag signature
    if (!io -> Read(io, &TagEntry.sig, sizeof(cmsTagSignature), 1)) return FALSE;

    // Read the tag offset
    if (!_cmsReadUInt32Number(io, &TagEntry.offset)) return FALSE;

    // Read the tag size
    if (!_cmsReadUInt32Number(io, &TagEntry.size)) return FALSE;

    // Check for valid tag
    if (TagEntry.size < 8) {
        cmsSignalError(Icc ->ContextID, cmsERROR_CORRUPTION_DETECTED, "Corrupted tag entry");
        return FALSE;
    }

    // Check for valid tag signature
    if (TagEntry.sig == (cmsTagSignature) 0) {
        cmsSignalError(Icc ->ContextID, cmsERROR_CORRUPTION_DETECTED, "Corrupted tag entry");
        return FALSE;
    }

    // Check for valid tag offset
    if (TagEntry.offset + TagEntry.size > Icc ->IOhandler ->ReportedSize) {
        cmsSignalError(Icc ->ContextID, cmsERROR_CORRUPTION_DETECTED, "Corrupted tag entry");
        return FALSE;
    }

    // Store the tag signature, offset, and size in the Icc structure
    Icc -> TagNames[i] = TagEntry.sig;
    Icc -> TagOffsets[i] = TagEntry.offset;
    Icc -> TagSizes[i] = TagEntry.size;

    // Search for linked tags
    int j;
    for (j=0; j < i; j++) {
        if (Icc -> TagOffsets[j] == TagEntry.offset && Icc -> TagSizes[j] == TagEntry.size) {
            Icc -> TagLinked[i] = Icc -> TagNames[j];
            break;
        }
    }

    if (j == i) {
        Icc -> TagLinked[i] = (cmsTagSignature) 0;
    }
}