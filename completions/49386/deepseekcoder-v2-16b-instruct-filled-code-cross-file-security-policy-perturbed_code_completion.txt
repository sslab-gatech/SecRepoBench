// <MASK>
    Icc -> TagCount = TagCount;
    Icc -> TagOffsets = (cmsUInt32Number*) _cmsMalloc(Icc ->ContextID, sizeof(cmsUInt32Number) * TagCount);
    Icc -> TagSizes = (cmsUInt32Number*) _cmsMalloc(Icc ->ContextID, sizeof(cmsUInt32Number) * TagCount);
    Icc -> TagLinked = (cmsTagSignature*) _cmsMalloc(Icc ->ContextID, sizeof(cmsTagSignature) * TagCount);

    if (Icc -> TagOffsets == NULL || Icc -> TagSizes == NULL || Icc -> TagLinked == NULL) {
        cmsSignalError(Icc ->ContextID, cmsERROR_NO_MEMORY, "Not enough memory to read tags");
        return FALSE;
    }

    for (i = 0; i < TagCount; i++) {
        if (!_cmsReadUInt32Number(io, &TagEntry.sig)) return FALSE;
        if (!_cmsReadUInt32Number(io, &TagEntry.offset)) return FALSE;
        if (!_cmsReadUInt32Number(io, &TagEntry.size)) return FALSE;

        if (TagEntry.offset >= HeaderSize || TagEntry.offset + TagEntry.size > HeaderSize) {
            cmsSignalError(Icc ->ContextID, cmsERROR_RANGE, "Tag out of bounds, offset: %u, size: %u", TagEntry.offset, TagEntry.size);
            return FALSE;
        }

        Icc -> TagOffsets[Icc -> TagCount] = TagEntry.offset;
        Icc -> TagSizes[Icc -> TagCount] = TagEntry.size;
        Icc -> TagLinked[Icc -> TagCount] = 0; // Initialize the link to NULL
        Icc -> TagCount++;

        // Check for linked tags
        for (j = 0; j < Icc -> TagCount; j++) {
            if (Icc -> TagOffsets[j] == TagEntry.offset && Icc -> TagSizes[j] == TagEntry.size) {
                Icc -> TagLinked[Icc -> TagCount - 1] = Icc -> TagLinked[j];
                Icc -> TagLinked[j] = TagEntry.sig;
                break;
            }
        }
    }

    // Set links after reading all tags
    if (!SetLinks(Icc)) return FALSE;

    return TRUE;