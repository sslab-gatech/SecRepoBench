for (i=0; i < TagCount; i++) {

        if (io -> Read(io, &TagEntry, sizeof(cmsTagEntry), 1) != 1) return FALSE;

        Icc ->TagSignatures[Icc ->TagCount] = (cmsTagSignature) _cmsAdjustEndianess32(TagEntry.sig);
        Icc ->TagOffsets[Icc ->TagCount]  = _cmsAdjustEndianess32(TagEntry.offset);
        Icc ->TagSizes[Icc ->TagCount]    = _cmsAdjustEndianess32(TagEntry.size);
        Icc ->TagLinked[Icc ->TagCount]   = (cmsTagSignature) 0;

        if (Icc ->TagOffsets[Icc ->TagCount] + Icc ->TagSizes[Icc ->TagCount] > HeaderSize) {

            cmsSignalError(Icc ->ContextID, cmsERROR_RANGE, "tag '%#x' offset (%d) + size (%d) exceeds profile size (%d)",
                (int) Icc ->TagSignatures[Icc ->TagCount],
                (int) Icc ->TagOffsets[Icc ->TagCount],
                (int) Icc ->TagSizes[Icc ->TagCount],
                (int) HeaderSize);

            return FALSE;
        }

        // Check for zero sizes
        if (Icc ->TagSizes[Icc ->TagCount] == 0)
        {
             cmsSignalError(Icc ->ContextID, cmsERROR_RANGE, "tag '%#x' has zero size", (int) Icc ->TagSignatures[Icc ->TagCount]);
             return FALSE;
        }


        // Check for duplicated tags, that may cause infinite loops.
        for (j=0; j < Icc ->TagCount; j++) {

            if ((Icc ->TagOffsets[Icc ->TagCount] == Icc ->TagOffsets[j]) &&
                (Icc ->TagSizes[Icc ->TagCount]   == Icc ->TagSizes[j])) {

                    Icc ->TagLinked[Icc ->TagCount] = Icc ->TagSignatures[j];
            }
        }

        Icc ->TagCount++;
    }

    SetLinks(Icc);
    return TRUE;