for (i = 0; i < TagCount; i++) {
        // Read tag signature
        if (!_cmsReadUInt32Number(io, &TagEntry.Tag)) return FALSE;

        // Read tag offset
        if (!_cmsReadUInt32Number(io, &TagEntry.Offset)) return FALSE;

        // Read tag size
        if (!_cmsReadUInt32Number(io, &TagEntry.Size)) return FALSE;

        // Perform basic sanity checks
        if (TagEntry.Offset + TagEntry.Size > HeaderSize) {
            cmsSignalError(Icc->ContextID, cmsERROR_CORRUPTION_DETECTED,
                           "Tag %d (%x) is out of file bounds", i, TagEntry.Tag);
            return FALSE;
        }

        // Check for duplicate tags
        for (j = 0; j < Icc->TagCount; j++) {
            if (Icc->TagOffsets[j] == TagEntry.Offset && Icc->TagSizes[j] == TagEntry.Size) {
                Icc->TagLinked[j] = TagEntry.Tag;
                break;
            }
        }

        // If not a duplicate, add the tag to the profile
        if (j == Icc->TagCount) {
            if (Icc->TagCount >= MAX_TABLE_TAG) {
                cmsSignalError(Icc->ContextID, cmsERROR_RANGE, "Too many tags");
                return FALSE;
            }

            Icc->TagNames[Icc->TagCount] = TagEntry.Tag;
            Icc->TagOffsets[Icc->TagCount] = TagEntry.Offset;
            Icc->TagSizes[Icc->TagCount] = TagEntry.Size;
            Icc->TagLinked[Icc->TagCount] = 0; // No link by default
            Icc->TagCount++;
        }
    }

    // Set up links between tags
    if (!SetLinks(Icc)) {
        cmsSignalError(Icc->ContextID, cmsERROR_CORRUPTION_DETECTED, "Failed to set tag links");
        return FALSE;
    }

    return TRUE;