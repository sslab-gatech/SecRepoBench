for (i = 0; i < TagCount; i++) {
    if (!_cmsReadTagEntry(io, &TagEntry)) return FALSE;

    // Basic check: tags can't be zero
    if (TagEntry.sig == 0 || TagEntry.offset == 0 || TagEntry.size == 0) {
        cmsSignalError(Icc->ContextID, cmsERROR_CORRUPT_FILE, "Zero tag found at index %u", i);
        return FALSE;
    }

    // Check if tag is within the file
    if (TagEntry.offset > Icc->IOhandler->ReportedSize || 
        TagEntry.size > Icc->IOhandler->ReportedSize || 
        TagEntry.offset + TagEntry.size > Icc->IOhandler->ReportedSize) {
        cmsSignalError(Icc->ContextID, cmsERROR_CORRUPT_FILE, "Tag at index %u extends past end of file", i);
        return FALSE;
    }

    // Is tag already present?
    if (_cmsSearchTag(Icc, TagEntry.sig, FALSE) >= 0) {
        cmsSignalError(Icc->ContextID, cmsERROR_DUPLICATE_TAG, "Duplicate tag %s found at index %u", 
                       _cmsTagSignatureToString(TagEntry.sig), i);
        // Not a fatal error, so continue processing
    }

    // Record tag
    Icc->TagEntries[Icc->TagCount] = TagEntry;
    Icc->TagCount++;

    // Check for links
    for (j = 0; j < Icc->TagCount - 1; j++) {
        if (Icc->TagEntries[j].offset == TagEntry.offset && 
            Icc->TagEntries[j].size == TagEntry.size) {
            Icc->TagLinked[Icc->TagCount - 1] = Icc->TagEntries[j].sig;
            Icc->TagLinked[j] = TagEntry.sig;
        }
    }
}

if (!SetLinks(Icc)) return FALSE;

return TRUE;