for (i = 0; i < TagCount; i++) {
        cmsTagSignature sig;
        cmsUInt32Number offset, size;

        if (!_cmsReadUInt32Number(io, &sig) ||
            !_cmsReadUInt32Number(io, &offset) ||
            !_cmsReadUInt32Number(io, &size)) {
            return FALSE;
        }

        // Check for tag overflow
        if (offset + size > HeaderSize) {
            cmsSignalError(Icc->ContextID, cmsERROR_RANGE, "Tag offset (%u) + size (%u) exceeds header size (%u)", offset, size, HeaderSize);
            return FALSE;
        }

        // Check for duplicate tags
        for (j = 0; j < Icc->TagCount; j++) {
            if (Icc->TagSignatures[j] == sig) {
                cmsSignalError(Icc->ContextID, cmsERROR_DUPLICATE_TAG, "Duplicate tag signature: 0x%x", sig);
                return FALSE;
            }
        }

        Icc->TagSignatures[Icc->TagCount] = sig;
        Icc->TagOffsets[Icc->TagCount] = offset;
        Icc->TagSizes[Icc->TagCount] = size;
        Icc->TagLinked[Icc->TagCount] = 0;
        Icc->TagCount++;
    }

    // Set links between tags
    if (!SetLinks(Icc)) return FALSE;

    return TRUE;