for (i = 0; i < TagCount; i++) {
        if (io->Read(io, &TagEntry, sizeof(cmsTagEntry), 1) != 1) {
            return FALSE;
        }

        // Adjust endianness
        TagEntry.sig    = _cmsAdjustEndianess32(TagEntry.sig);
        TagEntry.offset = _cmsAdjustEndianess32(TagEntry.offset);
        TagEntry.size   = _cmsAdjustEndianess32(TagEntry.size);

        // Basic sanity checks
        if (TagEntry.size == 0 || TagEntry.offset == 0) {
            continue; // Skip invalid entries
        }

        if (TagEntry.offset + TagEntry.size > HeaderSize) {
            cmsSignalError(Icc->ContextID, cmsERROR_RANGE, "Tag %d out of bounds", i);
            return FALSE;
        }

        // Check if we have space to store the tag
        if (Icc->TagCount >= MAX_TABLE_TAG) {
            cmsSignalError(Icc->ContextID, cmsERROR_RANGE, "Too many tags");
            return FALSE;
        }

        // Store the tag
        Icc->TagNames[Icc->TagCount] = TagEntry.sig;
        Icc->TagOffsets[Icc->TagCount] = TagEntry.offset;
        Icc->TagSizes[Icc->TagCount] = TagEntry.size;

        // Check for linked tags
        for (j = 0; j < Icc->TagCount; j++) {
            if (Icc->TagOffsets[j] == TagEntry.offset && Icc->TagSizes[j] == TagEntry.size) {
                Icc->TagLinked[Icc->TagCount] = Icc->TagNames[j];
                break;
            }
        }

        Icc->TagCount++;
    }

    return TRUE;