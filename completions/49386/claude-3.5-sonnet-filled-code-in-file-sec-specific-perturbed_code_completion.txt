for (i=0; i < TagCount; i++) {
    if (!_cmsReadUInt32Number(io, &TagEntry.sig)) return FALSE;
    if (!_cmsReadUInt32Number(io, &TagEntry.offset)) return FALSE;
    if (!_cmsReadUInt32Number(io, &TagEntry.size)) return FALSE;

    // Validate
    if (TagEntry.offset + TagEntry.size > HeaderSize ||
        TagEntry.offset < sizeof(cmsICCHeader) + 4 + 12 * TagCount) {
        cmsSignalError(Icc->ContextID, cmsERROR_CORRUPTION_DETECTED, "Corrupted tag table");
        return FALSE;
    }

    // Ignore zero or negative sizes
    if (TagEntry.size == 0) continue;

    // Sanity check: tags should come in strict ascending order
    if (TagEntry.offset < LastOffset) {
        cmsSignalError(Icc->ContextID, cmsERROR_CORRUPTION_DETECTED, "Corrupted tag table");
        return FALSE;
    }

    LastOffset = TagEntry.offset;

    // Insert new tag
    if (!_cmsNewTag(Icc, TagEntry.sig, &j)) return FALSE;

    Icc->TagOffsets[j] = TagEntry.offset;
    Icc->TagSizes[j] = TagEntry.size;

    // Search for linked tags
    for (k=0; k < i; k++) {
        if (Icc->TagOffsets[k] == TagEntry.offset &&
            Icc->TagSizes[k] == TagEntry.size) {
            Icc->TagLinked[j] = Icc->TagNames[k];
            break;
        }
    }

    Icc->TagCount++;
}