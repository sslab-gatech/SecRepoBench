for (i = 0; i < TagCount; i++) {

    cmsTagEntry entry;

    if (io->Read(io, &entry, sizeof(cmsTagEntry), 1) != 1) {
        cmsSignalError(Icc->ContextID, cmsERROR_READ, "Cannot read tag entry");
        return FALSE;
    }

    cmsTagSignature sig     = (cmsTagSignature)_cmsAdjustEndianess32(entry.sig);
    cmsUInt32Number tagOff    = _cmsAdjustEndianess32(entry.offset);
    cmsUInt32Number tagSize   = _cmsAdjustEndianess32(entry.size);

    // Check that the tag data falls within the file boundary
    if (tagOff + tagSize > Icc->IOhandler->ReportedSize) {
        cmsSignalError(Icc->ContextID, cmsERROR_RANGE, "tag entry out of file bounds");
        return FALSE;
    }

    // Determine if this tag entry is linked to a previously read tag (same offset and size)
    cmsTagSignature linked = 0;
    for (j = 0; j < Icc->TagCount; j++) {
        if (Icc->TagOffsets[j] == tagOff && Icc->TagSizes[j] == tagSize) {
            linked = Icc->TagSignatures[j];
            break;
        }
    }

    Icc->TagSignatures[Icc->TagCount] = sig;
    Icc->TagOffsets[Icc->TagCount]      = tagOff;
    Icc->TagSizes[Icc->TagCount]        = tagSize;
    Icc->TagLinked[Icc->TagCount]       = linked;

    Icc->TagCount++;
}

return TRUE;