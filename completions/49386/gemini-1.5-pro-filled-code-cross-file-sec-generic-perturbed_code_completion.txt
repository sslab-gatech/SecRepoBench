for (i = 0; i < TagCount; i++) {

        if (!io -> Read(io, &TagEntry, sizeof(cmsTagEntry), 1)) return FALSE;

        // Adjust endianness
        TagEntry.sig   = _cmsAdjustEndianess32(TagEntry.sig);
        TagEntry.offset = _cmsAdjustEndianess32(TagEntry.offset);
        TagEntry.size   = _cmsAdjustEndianess32(TagEntry.size);

        // Basic sanity checks
        if (TagEntry.offset + TagEntry.size > HeaderSize || TagEntry.offset < sizeof(cmsICCHeader) + 4 + 12 * TagCount) {

            char String[5];
            _cmsTagSignature2String(String, TagEntry.sig);
            cmsSignalError(Icc ->ContextID, cmsERROR_BAD_TAG, "Tag '%s' inconsistent offset/size", String);
            return FALSE;
        }

        if (TagEntry.size == 0 && TagEntry.sig != cmsSigNamedColor2Tag) {
            char String[5];
            _cmsTagSignature2String(String, TagEntry.sig);
            cmsSignalError(Icc ->ContextID, cmsERROR_BAD_TAG, "Tag '%s' size is zero", String);
            return FALSE;
        }

        Icc -> TagSignatures[Icc -> TagCount] = TagEntry.sig;
        Icc -> TagOffsets[Icc -> TagCount]   = TagEntry.offset;
        Icc -> TagSizes[Icc -> TagCount]     = TagEntry.size;

        // Check for links
        for (j = 0; j < Icc->TagCount; j++) {
            if (Icc->TagOffsets[j] == TagEntry.offset &&
                Icc->TagSizes[j] == TagEntry.size &&
                Icc->TagSignatures[j] != TagEntry.sig) {

                Icc->TagLinked[Icc->TagCount] = Icc->TagSignatures[j];
                break;
            }
        }

        Icc -> TagCount++;
    }

    return SetLinks(Icc);