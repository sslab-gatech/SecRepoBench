for (i = 0; i < TagCount; i++) {

        if (io -> Read(io, &TagEntry, sizeof(cmsTagEntry), 1) != 1) return FALSE;

        cmsTagSignature sig    = (cmsTagSignature)   _cmsAdjustEndianess32(TagEntry.sig);
        cmsUInt32Number offset = _cmsAdjustEndianess32(TagEntry.offset);
        cmsUInt32Number size   = _cmsAdjustEndianess32(TagEntry.size);

        // Basic sanity check
        if (offset > HeaderSize) {
            cmsSignalError(Icc ->ContextID, cmsERROR_RANGE, "Tag %x offset (%x) is beyond file size (%x)", (unsigned int) sig, (unsigned int) offset, (unsigned int) HeaderSize);
            continue;
        }

        if ((offset + size) < offset) {
            cmsSignalError(Icc->ContextID, cmsERROR_RANGE, "Integer overflow detected in tag size calculation for tag %x", (unsigned int)sig);
            continue;
        }
        
        if ((offset + size) > HeaderSize) {
            cmsSignalError(Icc ->ContextID, cmsERROR_RANGE, "Tag %x size (%x + %x) is beyond file size (%x)", (unsigned int) sig, (unsigned int) offset, (unsigned int) size, (unsigned int) HeaderSize);
            continue;
        }

        // Store the tag
        Icc ->TagSignatures[Icc ->TagCount] = sig;
        Icc ->TagOffsets[Icc ->TagCount]    = offset;
        Icc ->TagSizes[Icc ->TagCount]      = size;
        Icc ->TagLinked[Icc ->TagCount]     = (cmsTagSignature) 0;

        // Check for links
        for (j=0; j<Icc ->TagCount; j++) {

            if (Icc ->TagOffsets[j] == offset && Icc ->TagSizes[j] == size) {

                Icc ->TagLinked[Icc ->TagCount] = Icc ->TagSignatures[j];
                break;
            }
        }

        Icc ->TagCount++;
    }

    SetLinks(Icc);
    return TRUE;