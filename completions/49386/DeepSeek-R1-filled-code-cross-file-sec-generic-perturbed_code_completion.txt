for (i = 0; i < TagCount; i++) {

    if (!_cmsReadUInt32Number(io, (cmsUInt32Number*)&TagEntry.sig) ||
        !_cmsReadUInt32Number(io, &TagEntry.offset) ||
        !_cmsReadUInt32Number(io, &TagEntry.size))
        return FALSE;

    TagEntry.sig = _cmsAdjustEndianess32(TagEntry.sig);
    TagEntry.offset = _cmsAdjustEndianess32(TagEntry.offset);
    TagEntry.size = _cmsAdjustEndianess32(TagEntry.size);

    cmsUInt32Number TagDirectoryEnd = sizeof(cmsICCHeader) + 4 + TagCount * 12;

    if (TagEntry.offset < TagDirectoryEnd ||
        TagEntry.size == 0 ||
        (TagEntry.offset + TagEntry.size) < TagEntry.offset ||  // Overflow check
        (TagEntry.offset + TagEntry.size) > HeaderSize)
        continue;

    for (j = 0; j < Icc->TagCount; j++) {
        if (Icc->TagOffsets[j] == TagEntry.offset && Icc->TagSizes[j] == TagEntry.size) {
            Icc->TagLinked[Icc->TagCount] = Icc->TagNames[j];
            break;
        }
    }

    Icc->TagNames[Icc->TagCount] = TagEntry.sig;
    Icc->TagOffsets[Icc->TagCount] = TagEntry.offset;
    Icc->TagSizes[Icc->TagCount] = TagEntry.size;
    Icc->TagCount++;
}

if (!SetLinks(Icc))
    return FALSE;

return TRUE;