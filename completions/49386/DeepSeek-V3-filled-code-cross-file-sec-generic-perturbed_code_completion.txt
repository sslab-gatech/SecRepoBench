for (i = 0; i < TagCount; i++) {

        if (!_cmsReadUInt32Number(io, &TagEntry.sig)) return FALSE;
        if (!_cmsReadUInt32Number(io, &TagEntry.offset)) return FALSE;
        if (!_cmsReadUInt32Number(io, &TagEntry.size)) return FALSE;

        // Basic sanity checks
        if (TagEntry.offset > HeaderSize || TagEntry.size > HeaderSize ||
            TagEntry.offset + TagEntry.size > HeaderSize) {
            cmsSignalError(Icc ->ContextID, cmsERROR_CORRUPTION_DETECTED, "Corrupted tag in profile");
            return FALSE;
        }

        // Store tag info
        Icc ->TagNames[Icc ->TagCount] = (cmsTagSignature) _cmsAdjustEndianess32(TagEntry.sig);
        Icc ->TagOffsets[Icc ->TagCount] = _cmsAdjustEndianess32(TagEntry.offset);
        Icc ->TagSizes[Icc ->TagCount] = _cmsAdjustEndianess32(TagEntry.size);
        Icc ->TagLinked[Icc ->TagCount] = (cmsTagSignature) 0;

        // Check for duplicate tags
        for (j = 0; j < Icc ->TagCount; j++) {
            if (Icc ->TagNames[j] == Icc ->TagNames[Icc ->TagCount]) {
                cmsSignalError(Icc ->ContextID, cmsERROR_CORRUPTION_DETECTED, "Duplicate tag in profile");
                return FALSE;
            }
        }

        // Check for linked tags (same offset and size)
        for (j = 0; j < Icc ->TagCount; j++) {
            if (Icc ->TagOffsets[j] == Icc ->TagOffsets[Icc ->TagCount] &&
                Icc ->TagSizes[j] == Icc ->TagSizes[Icc ->TagCount]) {
                Icc ->TagLinked[Icc ->TagCount] = Icc ->TagNames[j];
                break;
            }
        }

        Icc ->TagCount++;
    }

    if (!SetLinks(Icc)) return FALSE;

    return TRUE;