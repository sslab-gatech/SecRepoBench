for (i = 0; i < TagCount; i++) {
    
    // Read the tag entry from the profile
    if (!io->Read(io, &TagEntry, sizeof(cmsTagEntry), 1)) return FALSE;
    
    // Adjust endianness
    TagEntry.sig    = (cmsTagSignature) _cmsAdjustEndianess32((cmsUInt32Number) TagEntry.sig);
    TagEntry.offset = _cmsAdjustEndianess32(TagEntry.offset);
    TagEntry.size   = _cmsAdjustEndianess32(TagEntry.size);
    
    // Sanity check - don't allow corrupted profiles
    if (TagEntry.offset + TagEntry.size > HeaderSize) {
        cmsSignalError(Icc->ContextID, cmsERROR_RANGE, "Corrupted tag, offset %u size %u goes beyond profile size %u",
                      TagEntry.offset, TagEntry.size, HeaderSize);
        continue;  // Skip this tag but try to read others
    }
    
    // Check for reasonable size (4 is minimum size)
    if (TagEntry.size < 4) {
        cmsSignalError(Icc->ContextID, cmsERROR_RANGE, "Corrupted tag of size less than 4 bytes");
        continue;  // Skip this tag but try to read others
    }
    
    // We can't handle more tags
    if (Icc->TagCount >= MAX_TABLE_TAG) {
        cmsSignalError(Icc->ContextID, cmsERROR_RANGE, "Too many tags");
        continue;  // Skip this tag but try to read others
    }
    
    // Store the tag in the structure
    Icc->TagNames[Icc->TagCount]   = TagEntry.sig;
    Icc->TagOffsets[Icc->TagCount] = TagEntry.offset;
    Icc->TagSizes[Icc->TagCount]   = TagEntry.size;
    
    // Initially no linked tags
    Icc->TagLinked[Icc->TagCount] = (cmsTagSignature) 0;
    Icc->TagSaveAsRaw[Icc->TagCount] = FALSE;
    
    // Initially no type handler
    Icc->TagTypeHandlers[Icc->TagCount] = NULL;
    Icc->TagPtrs[Icc->TagCount] = NULL;
    
    // Look for linked tags (tags that share same offset)
    for (j = 0; j < Icc->TagCount; j++) {
        if (Icc->TagOffsets[j] == TagEntry.offset) {
            Icc->TagLinked[Icc->TagCount] = Icc->TagNames[j];
            break;
        }
    }
    
    // One more tag
    Icc->TagCount++;
}

return TRUE;