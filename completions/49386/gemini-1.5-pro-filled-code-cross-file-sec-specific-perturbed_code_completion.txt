for (i = 0; i < TagCount; i++) {

        if (!io -> Read(io, &TagEntry, sizeof(cmsTagEntry), 1)) return FALSE;

        // Adjust endianness
        TagEntry.sig    = _cmsAdjustEndianess32(TagEntry.sig);
        TagEntry.offset = _cmsAdjustEndianess32(TagEntry.offset);
        TagEntry.size   = _cmsAdjustEndianess32(TagEntry.size);

        // Basic sanity checks
        if (TagEntry.offset + TagEntry.size > HeaderSize || TagEntry.offset < sizeof(cmsICCHeader) + 4 + 12 * TagCount) {

            char String[5];
            _cmsTagSignature2String(String, TagEntry.sig);
            cmsSignalError(Icc ->ContextID, cmsERROR_BAD_TAG, "Tag '%s' inconsistent offset/size", String);
            return FALSE;
        }

        if (TagEntry.size == 0) {
            char String[5];
            _cmsTagSignature2String(String, TagEntry.sig);
            cmsSignalError(Icc ->ContextID, cmsERROR_BAD_TAG, "Tag '%s' size is zero", String);
            return FALSE;
        }

        Icc -> TagSigs[Icc ->TagCount] = TagEntry.sig;
        Icc -> TagOffsets[Icc ->TagCount] = TagEntry.offset;
        Icc -> TagSizes[Icc ->TagCount] = TagEntry.size;

        // Check for links
        for (j = 0; j < i; j++) {
            if (Icc -> TagOffsets[j] == TagEntry.offset &&
                Icc -> TagSizes[j] == TagEntry.size) {

                Icc ->TagLinked[Icc ->TagCount] = Icc ->TagSigs[j];
                break;
            }
        }

        Icc ->TagCount++;
    }

    return TRUE;