{
    for (i = 0; i < TagCount; i++) {

        if (io->Read(io, &TagEntry, sizeof(cmsTagEntry), 1) != 1) {
            cmsSignalError(Icc->ContextID, cmsERROR_READ, "Failed to read tag directory entry %d", i);
            return FALSE;
        }

        // Adjust endianness of the tag entry fields
        TagEntry.signature = _cmsAdjustEndianess32(TagEntry.signature);
        TagEntry.offset    = _cmsAdjustEndianess32(TagEntry.offset);
        TagEntry.size      = _cmsAdjustEndianess32(TagEntry.size);

        // Sanity check: tag must lie within the reported profile file size and not overlap the header area
        if ((TagEntry.offset + TagEntry.size) > io->ReportedSize || TagEntry.offset < HeaderSize) {
            cmsSignalError(Icc->ContextID, cmsERROR_RANGE, "Tag entry %d out of bounds", i);
            return FALSE;
        }

        // Initialize link as zero (no link)
        Icc->TagLinked[Icc->TagCount] = 0;

        // Search for a previously encountered tag having the same offset and size, indicating a link
        for (j = 0; j < Icc->TagCount; j++) {
            if (Icc->TagOffsets[j] == TagEntry.offset &&
                Icc->TagSizes[j]   == TagEntry.size) {
                Icc->TagLinked[Icc->TagCount] = Icc->TagSignatures[j];
                break;
            }
        }

        // Record the tag entry information into the ICC structure arrays
        Icc->TagSignatures[Icc->TagCount] = TagEntry.signature;
        Icc->TagOffsets[Icc->TagCount]     = TagEntry.offset;
        Icc->TagSizes[Icc->TagCount]       = TagEntry.size;

        Icc->TagCount++;
    }

    return TRUE;
}