// Normalize the path by removing redundant elements (e.g., "." and "..")
int end_slash = 0;
if (len > 0 && pathuri[len - 1] == '/') {
    end_slash = 1;
}

flb_sds_t out = flb_sds_create_size(len);
if (!out) {
    return NULL;
}

struct mk_list *split;
struct mk_list *head, *tmp;
struct flb_split_entry *entry;
char *p;
struct flb_split_entry *prev;

// Normalize the path by removing redundant elements (e.g., "." and "..")
split = flb_utils_split(out, '/', -1);
if (!split) {
    flb_sds_destroy(out);
    return NULL;
}

p = out;
*p++ = '/';

mk_list_foreach_safe(head, tmp, split) {
    entry = mk_list_entry(head, struct flb_split_entry, _head);
    if (entry->len == 1 && *entry->value == '.') {
        flb_utils_split_free_entry(entry);
    }
    else if (entry->len == 2 && memcmp(entry->value, "..", 2) == 0) {
        prev = head->prev;
        if (prev != split) {
            entry = mk_list_entry(prev, struct flb_split_entry, _head);
            flb_utils_split_free_entry(entry);
        }
        entry = mk_list_entry(head, struct flb_split_entry, _head);
        flb_utils_split_free_entry(entry);
    }
    else {
        memcpy(p, entry->value, entry->len);
        p += entry->len;
        if (head->next != split) {
            *p++ = '/';
        }
    }
}

len = (p - out);
if (end_slash == 1 && out[len - 1] != '/') {
    *p++ = '/';
}

flb_utils_split_free(split);

flb_sds_len_set(out, p - out);
out[p - out] = '\0';

return out;