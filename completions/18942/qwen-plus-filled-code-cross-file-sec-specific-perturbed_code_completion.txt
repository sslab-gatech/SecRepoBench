// Handle error recovery for loops by cleaning up loop variables
// and resetting the loop depth to zero. If an error occurs while
// parsing an inner loop, the cleanup will propagate to the outer
// loops. This ensures that all resources associated with loop
// variables are properly released before handling the error.
// Additionally, initialize the frame for local variables in the
// current loop context, setting up necessary variables and ensuring
// that loop nesting limits are respected.

int i;
for (i = compiler->loop_depth; i >= 0; --i)
{
  loop_vars_cleanup(i);
}

compiler->loop_depth = 0;

if (compiler->loop_for_of_var_index != -1)
{
  // Reset any active 'for of' index if present.
  compiler->loop_for_of_var_index = -1;
}

int var_frame = _yr_compiler_get_var_frame(compiler);

// Initialize the variable frame for the new loop context.
memset(&compiler->loop[compiler->loop_depth], 0, sizeof(YR_LOOP_CONTEXT));

// Ensure that we do not exceed the maximum allowed loop nesting depth.
if (compiler->loop_depth >= YR_MAX_LOOP_NESTING)
{
  fail_if_error(ERROR_LOOP_NESTING_LIMIT_EXCEEDED);
}