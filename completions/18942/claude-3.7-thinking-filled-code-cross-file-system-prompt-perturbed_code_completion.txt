{
        // Handle error recovery for loops by cleaning up loop variables
        // and resetting the loop depth to zero. If an error occurs while
        // parsing an inner loop, the cleanup will propagate to the outer
        // loops. This ensures that all resources associated with loop
        // variables are properly released before handling the error.
        // Additionally, initialize the frame for local variables in the
        // current loop context, setting up necessary variables and ensuring
        // that loop nesting limits are respected.
        
        compiler->loop_depth = 0;
        compiler->loop_for_of_var_index = -1;

        // Clean up any loop variables
        for (int i = 0; i < YR_MAX_LOOP_NESTING; i++)
        {
          for (int j = 0; j < compiler->loop[i].vars_count; j++)
          {
            if (compiler->loop[i].vars[j].identifier != NULL)
            {
              yr_free(compiler->loop[i].vars[j].identifier);
              compiler->loop[i].vars[j].identifier = NULL;
            }
          }
          compiler->loop[i].vars_count = 0;
          compiler->loop[i].vars_internal_count = 0;
        }
      }