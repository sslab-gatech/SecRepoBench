{
        loop_vars_cleanup(compiler->loop_depth);

        compiler->loop_depth = 0;
      }
#line 1293 "grammar.y"
    {
        int parseresult = ERROR_SUCCESS;
        int var_frame = _yr_compiler_get_var_frame(compiler);

        if (compiler->loop_depth == YR_MAX_LOOP_NESTING)
          parseresult = ERROR_LOOP_NESTING_LIMIT_EXCEEDED;

        fail_if_error(parseresult);

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, var_frame + 0, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, var_frame + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, var_frame + 2, NULL, NULL);

        fail_if_error(yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, (yyvsp[-3].integer), NULL, NULL));

        fail_if_error(yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, (yyvsp[-1].integer), NULL, NULL));

        compiler->loop[compiler->loop_depth].vars_internal_count = 3;
        compiler->loop[compiler->loop_depth].vars_count = 0;
      }
#line 1301 "grammar.y"
    {
        YR_LOOP_CONTEXT* loop_ctx = &compiler->loop[compiler->loop_depth];
        YR_FIXUP* fixup;

        uint8_t* loop_start_addr;
        void* jmp_arg_addr;

        int var_frame = _yr_compiler_get_var_frame(compiler);

        fail_if_error(yr_parser_emit(
            yyscanner, OP_ITER_NEXT, &loop_start_addr));

        // For each variable generate an instruction that pops the value from
        // the stack and store it into one memory slot starting at var_frame + 3
        // because the first 3 slots in the frame are for the internal variables.

        for (int i = 0; i < loop_ctx->vars_count; i++)
        {
          fail_if_error(yr_parser_emit_with_arg(
              yyscanner, OP_POP_M, var_frame + 3 + i, NULL, NULL));
        }

        fail_if_error(yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JTRUE_P,
            0,
            NULL,
            &jmp_arg_addr));

        // Push a new fixup entry in the fixup stack so that the jump
        // destination is set once we know it.

        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));

        if (fixup == NULL)
          fail_if_error(ERROR_INSUFFICIENT_MEMORY);

        fixup->address = jmp_arg_addr;
        fixup->next = compiler->fixup_stack_head;
        compiler->fixup_stack_head = fixup;

        loop_ctx->addr = loop_start_addr;
        compiler->loop_depth++;
      }
#line 1352 "grammar.y"
    {
        YR_FIXUP* fixup;
        uint8_t* pop_addr;
        int var_frame;

        compiler->loop_depth--;

        loop_vars_cleanup(compiler->loop_depth);

        var_frame = _yr_compiler_get_var_frame(compiler);

        fail_if_error(yr_parser_emit_with_arg(
            yyscanner, OP_ADD_M, var_frame + 0, NULL, NULL));

        fail_if_error(yr_parser_emit_with_arg(
            yyscanner, OP_INCR_M, var_frame + 1, NULL, NULL));

        fail_if_error(yr_parser_emit_with_arg(
            yyscanner, OP_PUSH_M, var_frame + 2, NULL, NULL));

        fail_if_error(yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JUNDEF_P,
            compiler->loop[compiler->loop_depth].addr,
            NULL,
            NULL));

        fail_if_error(yr_parser_emit_with_arg(
            yyscanner, OP_PUSH_M, var_frame + 0, NULL, NULL));

        fail_if_error(yr_parser_emit_with_arg(
            yyscanner, OP_PUSH_M, var_frame + 2, NULL, NULL));

        fail_if_error(yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JL_P,
            compiler->loop[compiler->loop_depth].addr,
            NULL,
            NULL));

        fail_if_error(yr_parser_emit(
            yyscanner, OP_POP, &pop_addr));

        // Pop from the stack the fixup entry containing the jump's address
        // that needs to be fixed.

        fixup = compiler->fixup_stack_head;
        compiler->fixup_stack_head = fixup->next;

        // Fix the jump's target address.
        *(void**)(fixup->address) = (void*)(pop_addr);

        yr_free(fixup);

        fail_if_error(yr_parser_emit_with_arg(
            yyscanner, OP_PUSH_M, var_frame + 0, NULL, NULL));

        fail_if_error(yr_parser_emit_with_arg(
            yyscanner, OP_PUSH_M, var_frame + 2, NULL, NULL));

        fail_if_error(yr_parser_emit_with_arg(
            yyscanner, OP_SWAPUNDEF, var_frame + 1, NULL, NULL));

        fail_if_error(yr_parser_emit(
            yyscanner, OP_INT_GE, NULL));
      }
#line 1419 "grammar.y"
    {
        int parseresult = ERROR_SUCCESS;
        int var_frame = _yr_compiler_get_var_frame(compiler);;
        uint8_t* addr;

        if (compiler->loop_depth == YR_MAX_LOOP_NESTING)
          parseresult = ERROR_LOOP_NESTING_LIMIT_EXCEEDED;

        if (compiler->loop_for_of_var_index != -1)
          parseresult = ERROR_NESTED_FOR_OF_LOOP;

        fail_if_error(parseresult);

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, var_frame + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, var_frame + 2, NULL, NULL);

        // Pop the first string.
        yr_parser_emit_with_arg(
            yyscanner, OP_POP_M, var_frame, &addr, NULL);

        compiler->loop_for_of_var_index = var_frame;
        compiler->loop[compiler->loop_depth].vars_internal_count = 3;
        compiler->loop[compiler->loop_depth].vars_count = 0;
        compiler->loop[compiler->loop_depth].addr = addr;
        compiler->loop_depth++;
      }
#line 1449 "grammar.y"
    {
        int var_frame = 0;

        compiler->loop_depth--;
        compiler->loop_for_of_var_index = -1;

        loop_vars_cleanup(compiler->loop_depth);

        var_frame = _yr_compiler_get_var_frame(compiler);

        // Increment counter by the value returned by the
        // boolean expression (0 or 1). If the boolean expression
        // returned UNDEFINED the OP_ADD_M won't do anything.

        yr_parser_emit_with_arg(
            yyscanner, OP_ADD_M, var_frame + 1, NULL, NULL);

        // Increment iterations counter.
        yr_parser_emit_with_arg(
            yyscanner, OP_INCR_M, var_frame + 2, NULL, NULL);

        // If next string is not undefined, go back to the
        // beginning of the loop.
        yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JNUNDEF,
            compiler->loop[compiler->loop_depth].addr,
            NULL,
            NULL);

        // Pop end-of-list marker.
        yr_parser_emit(yyscanner, OP_POP, NULL);

        // At this point the loop quantifier (any, all, 1, 2,..)
        // is at top of the stack. Check if the quantifier is
        // undefined (meaning "all") and replace it with the
        // iterations counter in that case.
        yr_parser_emit_with_arg(
            yyscanner, OP_SWAPUNDEF, var_frame + 2, NULL, NULL);

        // Compare the loop quantifier with the number of
        // expressions evaluating to true.
        yr_parser_emit_with_arg(
            yyscanner, OP_PUSH_M, var_frame + 1, NULL, NULL);

        yr_parser_emit(yyscanner, OP_INT_LE, NULL);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }