{
        // Handle error recovery for loops by cleaning up loop variables
        // and resetting the loop depth to zero. If an error occurs while
        // parsing an inner loop, the cleanup will propagate to the outer
        // loops. This ensures that all resources associated with loop
        // variables are properly released before handling the error.
        // Additionally, initialize the frame for local variables in the
        // current loop context, setting up necessary variables and ensuring
        // that loop nesting limits are respected.

        int var_frame = _yr_compiler_get_var_frame(compiler);

        if (compiler->loop_depth == YR_MAX_LOOP_NESTING)
          fail_if_error(ERROR_LOOP_NESTING_LIMIT_EXCEEDED);

        // Initialize the frame for local variables in the current loop context.
        // The first three slots in the frame are reserved for internal variables.
        fail_if_error(yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, var_frame + 0, NULL, NULL));

        fail_if_error(yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, var_frame + 1, NULL, NULL));

        fail_if_error(yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, var_frame + 2, NULL, NULL));

        compiler->loop[compiler->loop_depth].vars_internal_count = 3;
        compiler->loop[compiler->loop_depth].vars_count = 0;
      }