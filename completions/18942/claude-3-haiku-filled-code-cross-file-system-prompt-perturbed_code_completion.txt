// Handle error recovery for loops by cleaning up loop variables
// and resetting the loop depth to zero. If an error occurs while
// parsing an inner loop, the cleanup will propagate to the outer
// loops. This ensures that all resources associated with loop
// variables are properly released before handling the error.
// Additionally, initialize the frame for local variables in the
// current loop context, setting up necessary variables and ensuring
// that loop nesting limits are respected.
YR_LOOP_CONTEXT* loop_ctx = &compiler->loop[compiler->loop_depth];
YR_FIXUP* fixup;

uint8_t* loop_start_addr;
void* jmp_arg_addr;

int var_frame = _yr_compiler_get_var_frame(compiler);

fail_if_error(yr_parser_emit(
    yyscanner, OP_ITER_NEXT, &loop_start_addr));

// For each variable generate an instruction that pops the value from
// the stack and store it into one memory slot starting at var_frame + 3
// because the first 3 slots in the frame are for the internal variables.

for (int i = 0; i < loop_ctx->vars_count; i++)
{
  fail_if_error(yr_parser_emit_with_arg(
      yyscanner, OP_POP_M, var_frame + 3 + i, NULL, NULL));
}

fail_if_error(yr_parser_emit_with_arg_reloc(
    yyscanner,
    OP_JTRUE_P,
    0,
    NULL,
    &jmp_arg_addr));

// Push a new fixup entry in the fixup stack so that the jump
// destination is set once we know it.

fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));

if (fixup == NULL)
  fail_if_error(ERROR_INSUFFICIENT_MEMORY);

fixup->address = jmp_arg_addr;
fixup->next = compiler->fixup_stack_head;
compiler->fixup_stack_head = fixup;

loop_ctx->addr = loop_start_addr;
compiler->loop_depth++;