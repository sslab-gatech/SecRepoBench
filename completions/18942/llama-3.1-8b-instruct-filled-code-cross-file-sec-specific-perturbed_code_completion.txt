// <MASK>
// Handle error recovery for loops by cleaning up loop variables
// and resetting the loop depth to zero. If an error occurs while
// parsing an inner loop, the cleanup will propagate to the outer
// loops. This ensures that all resources associated with loop
// variables are properly released before handling the error.
// Additionally, initialize the frame for local variables in the
// current loop context, setting up necessary variables and ensuring
// that loop nesting limits are respected.
void
loop_vars_cleanup(int loop_depth)
{
  YR_LOOP_CONTEXT* loop_ctx = &compiler->loop[loop_depth];

  for (int i = 0; i < loop_ctx->vars_count; i++)
  {
    yr_compiler_free_var_frame(compiler, loop_ctx->vars[i].var_frame);
  }

  loop_ctx->vars_count = 0;
  loop_ctx->vars_internal_count = 0;
  loop_ctx->addr = NULL;
  loop_ctx->vars = NULL;
}
// </MASK>