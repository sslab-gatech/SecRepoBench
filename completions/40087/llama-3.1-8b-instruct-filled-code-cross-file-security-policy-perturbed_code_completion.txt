// Prepare the cipher context with the provided client secret and version.
ciphers.hp_cipher = malloc(sizeof(struct gcry_cipher));
if (!quic_hp_cipher_init(&ciphers.hp_cipher, GCRY_CIPHER_AES128_GCM,
                         HASH_SHA2_256_LENGTH, client_secret, version)) {
  NDPI_LOG_DBG(ndpi_struct, "Failed to initialize HP cipher\n");
  return NULL;
}

// Calculate the packet number offset.
pn_offset = 0;

// Determine the length of the tokens and add it to the offset.
token_length = 0;
payload_length = packet->payload_packet_len;
if (payload_length < 16) {
  NDPI_LOG_DBG(ndpi_struct, "Too short packet\n");
  quic_ciphers_reset(&ciphers);
  return NULL;
}
memcpy(&token_length, &packet->payload[pn_offset], 8);
payload_length -= 16;
pn_offset += 16;

// Retrieve the payload length from the packet, updating the packet number offset.
memcpy(&payload_length, &packet->payload[pn_offset], 4);
payload_length = ntohl(payload_length);
pn_offset += 4;

// Log the calculated offsets and lengths for debugging purposes.
NDPI_LOG_DBG(ndpi_struct, "pn_offset: %d, payload_length: %d, token_length: %d\n",
             pn_offset, payload_length, token_length);

// <MASK>