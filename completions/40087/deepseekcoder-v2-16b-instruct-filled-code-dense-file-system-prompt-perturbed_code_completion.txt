// Prepare the cipher context with the provided client secret and version.
  // Calculate the packet number offset.
  // Determine the length of the tokens and add it to the offset.
  // Retrieve the payload length from the packet, updating the packet number offset.
  // Log the calculated offsets and lengths for debugging purposes.
  uint8_t first_byte;
  uint32_t pkn32, pn_offset, pkn_len, offset;
  quic_ciphers ciphers; /* Client initial ciphers */
  quic_decrypt_result_t decryption = { 0, 0};
  uint8_t client_secret[HASH_SHA2_256_LENGTH];

  memset(&ciphers, '\0', sizeof(ciphers));
  if(quic_derive_initial_secrets(version, dest_conn_id, dest_conn_id_len,
				 client_secret) != 0) {
    NDPI_LOG_DBG(ndpi_struct, "Error quic_derive_initial_secrets\n");
    return NULL;
  }

  // Packet numbers are protected with AES128-CTR,
  // Initial packets are protected with AEAD_AES_128_GCM.
  // Prepare the cipher context with the provided client secret and version.
  // Calculate the packet number offset.
  // Determine the length of the tokens and add it to the offset.
  // Retrieve the payload length from the packet, updating the packet number offset.
  // Log the calculated offsets and lengths for debugging purposes.
  uint8_t first_byte;
  uint32_t pkn32, pn_offset, pkn_len, offset;
  quic_ciphers ciphers; /* Client initial ciphers */
  quic_decrypt_result_t decryption = { 0, 0};
  uint8_t client_secret[HASH_SHA2_256_LENGTH];

  memset(&ciphers, '\0', sizeof(ciphers));
  if(quic_derive_initial_secrets(version, dest_conn_id, dest_conn_id_len,
				 client_secret) != 0) {
    NDPI_LOG_DBG(ndpi_struct, "Error quic_derive_initial_secrets\n");
    return NULL;
  }

  // Prepare the cipher context with the provided client secret and version.
  // Calculate the packet number offset.
  // Determine the length of the tokens and add it to the offset.
  // Retrieve the payload length from the packet, updating the packet number offset.
  // Log the calculated offsets and lengths for debugging purposes.
  uint8_t first_byte;
  uint32_t pkn32, pn_offset, pkn_len, offset;
  quic_ciphers ciphers; /* Client initial ciphers */
  quic_decrypt_result_t decryption = { 0, 0};
  uint8_t client_secret[HASH_SHA2_256_LENGTH];

  memset(&ciphers, '\0', sizeof(ciphers));
  if(quic_derive_initial_secrets(version, dest_conn_id, dest_conn_id_len,
				 client_secret) != 0) {
    NDPI_LOG_DBG(ndpi_struct, "Error quic_derive_initial_secrets\n");
    return NULL;
  }

  // Prepare the cipher context with the provided client secret and version.
  // Calculate the packet number offset.
  // Determine the length of the tokens and add it to the offset.
  // Retrieve the payload length from the packet, updating the packet number offset.
  // Log the calculated offsets and lengths for debugging purposes.
  uint8_t first_byte;
  uint32_t pkn32, pn_offset, pkn_len, offset;
  quic_ciphers ciphers; /* Client initial ciphers */
  quic_decrypt_result_t decryption = { 0, 0};
  uint8_t client_secret[HASH_SHA2_256_LENGTH];

  memset(&ciphers, '\0', sizeof(ciphers));
  if(quic_derive_initial_secrets(version, dest_conn_id, dest_conn_id_len,
				 client_secret) != 0) {
    NDPI_LOG_DBG(ndpi_struct, "Error quic_derive_initial_secrets\n");
    return NULL;
  }

  // Prepare the cipher context with the provided client secret and version.
  // Calculate the packet number offset.
  // Determine the length of the tokens and add it to the offset.
  // Retrieve the payload length from the packet, updating the packet number offset.
  // Log the calculated offsets and lengths for debugging purposes.
  uint8_t first_byte;
  uint32_t pkn32, pn_offset, pkn_len, offset;
  quic_ciphers ciphers; /* Client initial ciphers */
  quic_decrypt_result_t decryption = { 0, 0};
  uint8_t client_secret[HASH_SHA2_256_LENGTH];

  memset(&ciphers, '\0', sizeof(ciphers));
  if(quic_derive_initial_secrets(version, dest_conn_id, dest_conn_id_len,
				 client_secret) != 0) {
    NDPI_LOG_DBG(ndpi_struct, "Error quic_derive_initial_secrets\n");
    return NULL;
  }

  // Prepare the cipher context with the provided client secret and version.
  // Calculate the packet number offset.
  // Determine the length of the tokens and add it to the offset.
  // Retrieve the payload length from the packet, updating the packet number offset.
  // Log the calculated offsets and lengths for debugging purposes.
  uint8_t first_byte;
  uint32_t pkn32, pn_offset, pkn_len, offset;
  quic_ciphers ciphers; /* Client initial ciphers */
  quic_decrypt_result_t decryption = { 0, 0};
  uint8_t client_secret[HASH_SHA2_256_LENGTH];

  memset(&ciphers, '\0', sizeof(ciphers));
  if(quic_derive_initial_secrets(version, dest_conn_id, dest_conn_id_len,
				 client_secret) != 0) {
    NDPI_LOG_DBG(ndpi_struct, "Error quic_derive_initial_secrets\n");
    return NULL;
  }

  // Prepare the cipher context with the provided client secret and version.
  // Calculate the packet number offset.
  // Determine the length of the tokens and add it to the offset.
  // Retrieve the payload length from the packet, updating the packet number offset.
  // Log the calculated offsets and lengths for debugging purposes.
  uint8_t first_byte;
  uint32_t pkn32, pn_offset, pkn_len, offset;
  quic_ciphers ciphers; /* Client initial ciphers */
  quic_decrypt_result_t decryption = { 0, 0};
  uint8_t client_secret[HASH_SHA2_256_LENGTH];

  memset(&ciphers, '\0', sizeof(ciphers));
  if(quic_derive_initial_secrets(version, dest_conn_id, dest_conn_id_len,
				 client_secret) != 0) {
    NDPI_LOG_DBG(ndpi_struct, "Error quic_derive_initial_secrets\n");
    return NULL;
  }

  // Prepare the cipher context with the provided client secret and version.
  // Calculate the packet number offset.
  // Determine the length of the tokens and add it to the offset.
  // Retrieve the payload length from the packet, updating the packet number offset.
  // Log the calculated offsets and lengths for debugging purposes.
  uint8_t first_byte;
  uint32_t pkn32, pn_offset, pkn_len, offset;
  quic_ciphers ciphers; /* Client initial ciphers */
  quic_decrypt_result_t decryption = { 0, 0};
  uint8_t client_secret[HASH_SHA2_256_LENGTH];

  memset(&ciphers, '\0', sizeof(ciphers));
  if(quic_derive_initial_secrets(version, dest_conn_id, dest_conn_id_len,
				 client_secret) != 0) {
    NDPI_LOG_DBG(ndpi_struct, "Error quic_derive_initial_secrets\n");
    return NULL;
  }

  // Prepare the cipher context with the provided client secret and version.
  // Calculate the packet number offset.
  // Determine the length of the tokens and add it to the offset.
  // Retrieve the payload length from the packet, updating the packet number offset.
  // Log the calculated offsets and lengths for debugging purposes.
  uint8_t first_byte;
  uint32_t pkn32, pn_offset, pkn_len, offset;
  quic_ciphers ciphers; /* Client initial ciphers */
  quic_decrypt_result_t decryption = { 0, 0};
  uint8_t client_secret[HASH_SHA2_256_LENGTH];

  memset(&ciphers, '\0', sizeof(ciphers));
  if(quic_derive_initial_secrets(version, dest_conn_id, dest_conn_id_len,
				 client_secret) != 0) {
    NDPI_LOG_DBG(ndpi_struct, "Error quic_derive_initial_secrets\n");
    return NULL;
  }

  // Prepare the cipher context with the provided client secret and version.
  // Calculate the packet number offset.
  // Determine the length of the tokens and add it to the offset.
  // Retrieve the payload length from the packet, updating the packet number offset.
  // Log the calculated offsets and lengths for debugging purposes.
  uint8_t first_byte;
  uint32_t pkn32, pn_offset, pkn_len, offset;
  quic_ciphers ciphers; /* Client initial ciphers */
  quic_decrypt_result_t decryption = { 0, 0};
  uint8_t client_secret[HASH_SHA2_256_LENGTH];

  memset(&ciphers, '\0', sizeof(ciphers));
  if(quic_derive_initial_secrets(version, dest_conn_id, dest_conn_id_len,
				 client_secret) != 0) {
    NDPI_LOG_DBG(ndpi_struct, "Error quic_derive_initial_secrets\n");
    return NULL;
  }

  // Prepare the cipher context with the provided client secret and version.
  // Calculate the packet number offset.
  // Determine the length of the tokens and add it to the offset.
  // Retrieve the payload length from the packet, updating the packet number offset.
  // Log the calculated offsets and lengths for debugging purposes.
  uint8_t first_byte;
  uint32_t pkn32, pn_offset, pkn_len, offset;
  quic_ciphers ciphers; /* Client initial ciphers */
  quic_decrypt_result_t decryption = { 0, 0};
  uint8_t client_secret[HASH_SHA2_256_LENGTH];

  memset(&ciphers, '\0', sizeof(ciphers));
  if(quic_derive_initial_secrets(version, dest_conn_id, dest_conn_id_len,
				 client_secret) != 0) {
    NDPI_LOG_DBG(ndpi_struct, "Error quic_derive_initial_secrets\n");
    return NULL;
  }

  // Prepare the cipher context with the provided client secret and version.
  // Calculate the packet number offset.
  // Determine the length of the tokens and add it to the offset.
  // Retrieve the payload length from the packet, updating the packet number offset.
  // Log the calculated offsets and lengths for debugging purposes.
  uint8_t first_byte;
  uint32_t pkn32, pn_offset, pkn_len, offset;
  quic_ciphers ciphers; /* Client initial ciphers */
  quic_decrypt_result_t decryption = { 0, 0};
  uint8_t client_secret[HASH_SHA2_256_LENGTH];

  memset(&ciphers, '\0', sizeof(ciphers));
  if(quic_derive_initial_secrets(version, dest_conn_id, dest_conn_id_len,
				 client_secret) != 0) {
    NDPI_LOG_DBG(ndpi_struct, "Error quic_derive_initial_secrets\n");
    return NULL;
  }

  // Prepare the cipher context with the provided client secret and version.
  // Calculate the packet number offse