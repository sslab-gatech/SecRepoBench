if (gcry_cipher_open(&ciphers.hp_cipher, GCRY_CIPHER_AES128, GCRY_CIPHER_MODE_ECB, 0) ||
    gcry_cipher_setkey(ciphers.hp_cipher, client_secret, HASH_SHA2_256_LENGTH) ||
    gcry_cipher_open(&ciphers.pp_cipher, GCRY_CIPHER_AES128, GCRY_CIPHER_MODE_GCM, 0) ||
    gcry_cipher_setkey(ciphers.pp_cipher, client_secret, HASH_SHA2_256_LENGTH)) {
  NDPI_LOG_DBG(ndpi_struct, "Error initializing ciphers\n");
  quic_ciphers_reset(&ciphers);
  return NULL;
}

/* Calculate packet number offset */
pn_offset = 5;  /* 1 byte header + 4 bytes version */
pn_offset += 1 + dest_conn_id_len;  /* DCID len + DCID */
pn_offset += 1 + src_conn_id_len;   /* SCID len + SCID */

/* Parse token length and skip token */
if (pn_offset >= packet->payload_packet_len) {
  NDPI_LOG_DBG(ndpi_struct, "Packet too short for token length\n");
  quic_ciphers_reset(&ciphers);
  return NULL;
}
token_length = packet->payload[pn_offset++];
pn_offset += token_length;  /* Skip the token bytes */

/* Parse payload length */
if (pn_offset >= packet->payload_packet_len) {
  NDPI_LOG_DBG(ndpi_struct, "Packet too short for payload length\n");
  quic_ciphers_reset(&ciphers);
  return NULL;
}
payload_length = packet->payload[pn_offset++];

NDPI_LOG_DBG2(ndpi_struct, "PN offset %u token length %lu payload length %lu\n", 
              pn_offset, (unsigned long)token_length, (unsigned long)payload_length);