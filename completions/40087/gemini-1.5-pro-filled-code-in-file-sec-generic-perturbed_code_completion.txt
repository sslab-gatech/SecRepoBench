if (!quic_ciphers_prepare(&ciphers, GCRY_MD_SHA256, GCRY_CIPHER_AES128, GCRY_CIPHER_MODE_GCM, client_secret, version)) {
    NDPI_LOG_DBG(ndpi_struct, "Error quic_ciphers_prepare\n");
    return NULL;
  }

  pn_offset = 1 + 4 + ((version == V_Q046 || version == V_Q050) ? 4 : 0);
  if(is_version_with_ietf_long_header(version)) {
    dest_conn_id_len = packet->payload[5];
    pn_offset += 1 + dest_conn_id_len;
    source_conn_id_len = packet->payload[pn_offset];
    pn_offset += 1 + source_conn_id_len;
    if (version != V_1 && is_quic_ver_less_than(version, 32)) {
      if (packet->payload[pn_offset] & 0x40) {
        quic_len(&packet->payload[pn_offset + 1], &token_length);
        pn_offset += 1 + token_length;
      } else {
        pn_offset += 1;
      }
    }
  }
  if (is_version_with_var_int_transport_params(version)) {
    if (pn_offset + 8 > packet->payload_packet_len) {
      NDPI_LOG_DBG(ndpi_struct, "Invalid length %u %u\n", pn_offset + 8, packet->payload_packet_len);
      quic_ciphers_reset(&ciphers);
      return NULL;
    }
    pn_offset += quic_len(&packet->payload[pn_offset], &payload_length);
  } else {
    payload_length = ntohl(*(uint32_t *)&packet->payload[pn_offset]);
    pn_offset += 4;
  }

  NDPI_LOG_DBG2(ndpi_struct, "pn_offset %u payload_length %lu\n", pn_offset, payload_length);