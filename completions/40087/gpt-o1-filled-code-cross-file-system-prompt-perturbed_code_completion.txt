/* Prepare AEAD cipher context with the client secret */
  if(gcry_cipher_open(&ciphers.pp_cipher.pp_cipher, GCRY_CIPHER_AES128, GCRY_CIPHER_MODE_GCM, 0)) {
    NDPI_LOG_DBG(ndpi_struct, "Failed to open AEAD (pp_cipher) cipher context\n");
    return NULL;
  }
  {
    uint8_t aead_key[16];
    const char *aead_label = is_version_with_v1_labels(version) ? "quic key" : "quicv2 key";

    if(!quic_hkdf_expand_label(GCRY_MD_SHA256, client_secret, HASH_SHA2_256_LENGTH,
                               aead_label, aead_key, sizeof(aead_key))) {
      NDPI_LOG_DBG(ndpi_struct, "Failed to expand AEAD key\n");
      gcry_cipher_close(ciphers.pp_cipher.pp_cipher);
      return NULL;
    }
    if(gcry_cipher_setkey(ciphers.pp_cipher.pp_cipher, aead_key, sizeof(aead_key))) {
      NDPI_LOG_DBG(ndpi_struct, "Failed to set AEAD key\n");
      gcry_cipher_close(ciphers.pp_cipher.pp_cipher);
      return NULL;
    }
  }

  {
    const char *iv_label = is_version_with_v1_labels(version) ? "quic iv" : "quicv2 iv";
    if(!quic_hkdf_expand_label(GCRY_MD_SHA256, client_secret, HASH_SHA2_256_LENGTH,
                               iv_label, ciphers.pp_cipher.pp_iv, TLS13_AEAD_NONCE_LENGTH)) {
      NDPI_LOG_DBG(ndpi_struct, "Failed to expand AEAD IV\n");
      gcry_cipher_close(ciphers.pp_cipher.pp_cipher);
      return NULL;
    }
  }

  /* Prepare Header Protection (HP) cipher */
  if(gcry_cipher_open(&ciphers.hp_cipher.hp_cipher, GCRY_CIPHER_AES128, GCRY_CIPHER_MODE_ECB, 0)) {
    NDPI_LOG_DBG(ndpi_struct, "Failed to open HP cipher context\n");
    gcry_cipher_close(ciphers.pp_cipher.pp_cipher);
    return NULL;
  }
  if(!quic_hp_cipher_init(&ciphers.hp_cipher, GCRY_MD_SHA256, 16, client_secret, version)) {
    NDPI_LOG_DBG(ndpi_struct, "Failed to init HP cipher\n");
    gcry_cipher_close(ciphers.pp_cipher.pp_cipher);
    gcry_cipher_close(ciphers.hp_cipher.hp_cipher);
    return NULL;
  }

  /* Calculate offsets for token and payload lengths */
  pn_offset = 5 + dest_conn_id_len + src_conn_id_len;

  /* Retrieve token length from the packet (in varint format) and adjust offset */
  {
    /* Example assumes existence of auxiliary functions quic_varint_length and quic_varint_value */
    uint32_t token_len_bytes = quic_varint_length(&packet->payload[pn_offset],
                                                  packet->payload_packet_len - pn_offset);
    token_length = quic_varint_value(&packet->payload[pn_offset],
                                     packet->payload_packet_len - pn_offset);
    pn_offset += token_len_bytes + token_length;
  }

  /* Retrieve the payload length from the packet (in varint format) and update offset */
  {
    uint32_t length_len_bytes = quic_varint_length(&packet->payload[pn_offset],
                                                   packet->payload_packet_len - pn_offset);
    payload_length = quic_varint_value(&packet->payload[pn_offset],
                                       packet->payload_packet_len - pn_offset);
    pn_offset += length_len_bytes;
  }

  NDPI_LOG_DBG2(ndpi_struct, "Parsed pn_offset=%u, token_length=%llu, payload_length=%llu\n",
                pn_offset,
                (unsigned long long)token_length,
                (unsigned long long)payload_length);