// Prepare the cipher context with the provided client secret and version.
  // Calculate the packet number offset.
  // Determine the length of the tokens and add it to the offset.
  // Retrieve the payload length from the packet, updating the packet number offset.
  // Log the calculated offsets and lengths for debugging purposes.
  uint8_t hp_key[256/8]; /* Maximum key size is for AES256 cipher. */
  uint32_t hash_len = gcry_md_get_algo_dlen(GCRY_MD_SHA256);
  char *label = is_version_with_v1_labels(version) ? "quic hp" : "quicv2 hp";

  if(!quic_hkdf_expand_label(GCRY_MD_SHA256, client_secret, hash_len, label, hp_key, key_length)) {
    return 0;
  }

  gcry_cipher_setkey(hp_cipher->hp_cipher, hp_key, key_length) == 0;

  // Calculate the packet number offset.
  packet_number = pkn32;
  offset = pn_offset + pkn_len;

  // Determine the length of the tokens and add it to the offset.
  // Retrieve the payload length from the packet, updating the packet number offset.
  // Log the calculated offsets and lengths for debugging purposes.
  memcpy(nonce, pp_cipher->pp_iv, TLS13_AEAD_NONCE_LENGTH);
  /* Packet number is left-padded with zeroes and XORed with write_iv */
  phton64(nonce + sizeof(nonce) - 8, pntoh64(nonce + sizeof(nonce) - 8) ^ packet_number);

  gcry_cipher_reset(pp_cipher->pp_cipher);
  err = gcry_cipher_setiv(pp_cipher->pp_cipher, nonce, TLS13_AEAD_NONCE_LENGTH);
  if(err) {
    printf("Decryption (setiv) failed: %s\n", __gcry_err(err, buferr, sizeof(buferr)));
    ndpi_free(header);
    ndpi_free(buffer);
    return;
  }

  /* associated data (A) is the contents of QUIC header */
  err = gcry_cipher_authenticate(pp_cipher->pp_cipher, header, header_length);
  if(err) {
    printf("Decryption (authenticate) failed: %s\n", __gcry_err(err, buferr, sizeof(buferr)));
    ndpi_free(header);
    ndpi_free(buffer);
    return;
  }

  ndpi_free(header);

  /* Output ciphertext (C) */
  err = gcry_cipher_decrypt(pp_cipher->pp_cipher, buffer, buffer_length, NULL, 0);
  if(err) {
    printf("Decryption (decrypt) failed: %s\n", __gcry_err(err, buferr, sizeof(buferr)));
    ndpi_free(buffer);
    return;
  }

  err = gcry_cipher_checktag(pp_cipher->pp_cipher, atag, 16);
  if(err) {
    printf("Decryption (checktag) failed: %s\n", __gcry_err(err, buferr, sizeof(buferr)));
    ndpi_free(buffer);
    return;
  }

  result->data = buffer;
  result->data_len = buffer_length;