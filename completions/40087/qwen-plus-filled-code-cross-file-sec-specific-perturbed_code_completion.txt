/* Prepare the cipher context with the provided client secret and version. */
  if (!quic_hp_cipher_init(&ciphers.hp_cipher, GCRY_MD_SHA256, 16, client_secret, version)) {
    NDPI_LOG_DBG(ndpi_struct, "Error initializing HP cipher\n");
    quic_ciphers_reset(&ciphers);
    return NULL;
  }

  if (!quic_pp_cipher_init(&ciphers.pp_cipher, GCRY_CIPHER_AES128, GCRY_MD_SHA256, client_secret, version)) {
    NDPI_LOG_DBG(ndpi_struct, "Error initializing PP cipher\n");
    quic_ciphers_reset(&ciphers);
    return NULL;
  }

  /* Calculate the packet number offset. */
  first_byte = packet->payload[0];
  pn_offset = 1 + dest_conn_id_len + src_conn_id_len;

  /* Determine the length of the tokens and add it to the offset. */
  token_length = (first_byte >> 4) & 0x3;
  pn_offset += token_length;

  /* Retrieve the payload length from the packet, updating the packet number offset. */
  if (packet->payload_packet_len < pn_offset + 2) {
    NDPI_LOG_DBG(ndpi_struct, "Too short to extract payload length\n");
    quic_ciphers_reset(&ciphers);
    return NULL;
  }
  payload_length = ((uint16_t)packet->payload[pn_offset] << 8) | packet->payload[pn_offset + 1];
  pn_offset += 2;

  /* Log the calculated offsets and lengths for debugging purposes. */
  NDPI_LOG_DBG2(ndpi_struct, "pn_offset: %u, payload_length: %" PRIu64 "\n", pn_offset, payload_length);