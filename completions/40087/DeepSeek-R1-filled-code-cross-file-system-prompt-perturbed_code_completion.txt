if (!quic_hp_cipher_init(&ciphers.hp_cipher, GCRY_MD_SHA256, 16, client_secret, version)) {
    NDPI_LOG_DBG(ndpi_struct, "Failed to initialize HP cipher\n");
    quic_ciphers_reset(&ciphers);
    return NULL;
}

offset = 1 + dest_conn_id_len + src_conn_id_len;

if (offset >= packet->payload_packet_len) {
    NDPI_LOG_DBG(ndpi_struct, "Invalid offset for token length\n");
    quic_ciphers_reset(&ciphers);
    return NULL;
}
uint8_t first_byte_token = packet->payload[offset];
uint8_t varint_octets_token = 0;
token_length = 0;

if ((first_byte_token & 0xC0) == 0xC0) {
    varint_octets_token = 8;
    if (offset + 8 > packet->payload_packet_len) {
        NDPI_LOG_DBG(ndpi_struct, "Token length exceeds packet (8 bytes)\n");
        quic_ciphers_reset(&ciphers);
        return NULL;
    }
    token_length = ((uint64_t)(first_byte_token & 0x3F) << 56) |
                   ((uint64_t)packet->payload[offset + 1] << 48) |
                   ((uint64_t)packet->payload[offset + 2] << 40) |
                   ((uint64_t)packet->payload[offset + 3] << 32) |
                   ((uint64_t)packet->payload[offset + 4] << 24) |
                   ((uint64_t)packet->payload[offset + 5] << 16) |
                   ((uint64_t)packet->payload[offset + 6] << 8) |
                   (uint64_t)packet->payload[offset + 7];
} else if ((first_byte_token & 0x80) == 0x80) {
    varint_octets_token = 4;
    if (offset + 4 > packet->payload_packet_len) {
        NDPI_LOG_DBG(ndpi_struct, "Token length exceeds packet (4 bytes)\n");
        quic_ciphers_reset(&ciphers);
        return NULL;
    }
    token_length = ((uint32_t)(first_byte_token & 0x3F) << 24) |
                   ((uint32_t)packet->payload[offset + 1] << 16) |
                   ((uint32_t)packet->payload[offset + 2] << 8) |
                   (uint32_t)packet->payload[offset + 3];
} else if ((first_byte_token & 0x40) == 0x40) {
    varint_octets_token = 2;
    if (offset + 2 > packet->payload_packet_len) {
        NDPI_LOG_DBG(ndpi_struct, "Token length exceeds packet (2 bytes)\n");
        quic_ciphers_reset(&ciphers);
        return NULL;
    }
    token_length = ((uint16_t)(first_byte_token & 0x3F) << 8) |
                   (uint16_t)packet->payload[offset + 1];
} else {
    varint_octets_token = 1;
    token_length = first_byte_token & 0x3F;
}

offset += varint_octets_token;

if (offset + token_length > packet->payload_packet_len) {
    NDPI_LOG_DBG(ndpi_struct, "Token exceeds packet length\n");
    quic_ciphers_reset(&ciphers);
    return NULL;
}
offset += token_length;

if (offset >= packet->payload_packet_len) {
    NDPI_LOG_DBG(ndpi_struct, "Invalid offset for payload length\n");
    quic_ciphers_reset(&ciphers);
    return NULL;
}
uint8_t first_byte_payload = packet->payload[offset];
uint8_t varint_octets_payload = 0;
payload_length = 0;

if ((first_byte_payload & 0xC0) == 0xC0) {
    varint_octets_payload = 8;
    if (offset + 8 > packet->payload_packet_len) {
        NDPI_LOG_DBG(ndpi_struct, "Payload length exceeds packet (8 bytes)\n");
        quic_ciphers_reset(&ciphers);
        return NULL;
    }
    payload_length = ((uint64_t)(first_byte_payload & 0x3F) << 56) |
                     ((uint64_t)packet->payload[offset + 1] << 48) |
                     ((uint64_t)packet->payload[offset + 2] << 40) |
                     ((uint64_t)packet->payload[offset + 3] << 32) |
                     ((uint64_t)packet->payload[offset + 4] << 24) |
                     ((uint64_t)packet->payload[offset + 5] << 16) |
                     ((uint64_t)packet->payload[offset + 6] << 8) |
                     (uint64_t)packet->payload[offset + 7];
} else if ((first_byte_payload & 0x80) == 0x80) {
    varint_octets_payload = 4;
    if (offset + 4 > packet->payload_packet_len) {
        NDPI_LOG_DBG(ndpi_struct, "Payload length exceeds packet (4 bytes)\n");
        quic_ciphers_reset(&ciphers);
        return NULL;
    }
    payload_length = ((uint32_t)(first_byte_payload & 0x3F) << 24) |
                     ((uint32_t)packet->payload[offset + 1] << 16) |
                     ((uint32_t)packet->payload[offset + 2] << 8) |
                     (uint32_t)packet->payload[offset + 3];
} else if ((first_byte_payload & 0x40) == 0x40) {
    varint_octets_payload = 2;
    if (offset + 2 > packet->payload_packet_len) {
        NDPI_LOG_DBG(ndpi_struct, "Payload length exceeds packet (2 bytes)\n");
        quic_ciphers_reset(&ciphers);
        return NULL;
    }
    payload_length = ((uint16_t)(first_byte_payload & 0x3F) << 8) |
                     (uint16_t)packet->payload[offset + 1];
} else {
    varint_octets_payload = 1;
    payload_length = first_byte_payload & 0x3F;
}

offset += varint_octets_payload;
pn_offset = offset;

NDPI_LOG_DBG2(ndpi_struct, "pn_offset=%u, payload_length=%lu\n", pn_offset, payload_length);