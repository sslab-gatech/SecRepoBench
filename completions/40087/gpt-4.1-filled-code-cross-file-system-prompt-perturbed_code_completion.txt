// Prepare the cipher context with the provided client secret and version.
  if(!quic_ciphers_init(&ciphers, client_secret, version)) {
    NDPI_LOG_DBG(ndpi_struct, "Error initializing ciphers\n");
    return NULL;
  }

  // Calculate the packet number offset.
  // QUIC Initial header: 1 byte (flags) + 4 bytes (version) + dest_conn_id_len + 1 (len) + src_conn_id_len + 1 (len)
  pn_offset = 1 + 4 + 1 + dest_conn_id_len + 1 + src_conn_id_len;

  // Determine the length of the token and add it to the offset.
  token_length = 0;
  if(packet->payload[pn_offset] < 0xfd) {
    token_length = packet->payload[pn_offset];
    pn_offset += 1;
  } else if(packet->payload[pn_offset] == 0xfd) {
    token_length = ((uint64_t)packet->payload[pn_offset+1] << 8) | packet->payload[pn_offset+2];
    pn_offset += 3;
  } else if(packet->payload[pn_offset] == 0xfe) {
    token_length = ((uint64_t)packet->payload[pn_offset+1] << 24) |
                  ((uint64_t)packet->payload[pn_offset+2] << 16) |
                  ((uint64_t)packet->payload[pn_offset+3] << 8) |
                  packet->payload[pn_offset+4];
    pn_offset += 5;
  } else {
    // 0xff: 8 bytes
    token_length = ((uint64_t)packet->payload[pn_offset+1] << 56) |
                  ((uint64_t)packet->payload[pn_offset+2] << 48) |
                  ((uint64_t)packet->payload[pn_offset+3] << 40) |
                  ((uint64_t)packet->payload[pn_offset+4] << 32) |
                  ((uint64_t)packet->payload[pn_offset+5] << 24) |
                  ((uint64_t)packet->payload[pn_offset+6] << 16) |
                  ((uint64_t)packet->payload[pn_offset+7] << 8) |
                  packet->payload[pn_offset+8];
    pn_offset += 9;
  }
  pn_offset += token_length;

  // Retrieve the payload length from the packet, updating the packet number offset.
  // The payload length is a QUIC varint.
  if(packet->payload[pn_offset] < 0xfd) {
    payload_length = packet->payload[pn_offset];
    pn_offset += 1;
  } else if(packet->payload[pn_offset] == 0xfd) {
    payload_length = ((uint64_t)packet->payload[pn_offset+1] << 8) | packet->payload[pn_offset+2];
    pn_offset += 3;
  } else if(packet->payload[pn_offset] == 0xfe) {
    payload_length = ((uint64_t)packet->payload[pn_offset+1] << 24) |
                     ((uint64_t)packet->payload[pn_offset+2] << 16) |
                     ((uint64_t)packet->payload[pn_offset+3] << 8) |
                     packet->payload[pn_offset+4];
    pn_offset += 5;
  } else {
    payload_length = ((uint64_t)packet->payload[pn_offset+1] << 56) |
                     ((uint64_t)packet->payload[pn_offset+2] << 48) |
                     ((uint64_t)packet->payload[pn_offset+3] << 40) |
                     ((uint64_t)packet->payload[pn_offset+4] << 32) |
                     ((uint64_t)packet->payload[pn_offset+5] << 24) |
                     ((uint64_t)packet->payload[pn_offset+6] << 16) |
                     ((uint64_t)packet->payload[pn_offset+7] << 8) |
                     packet->payload[pn_offset+8];
    pn_offset += 9;
  }

  // Log the calculated offsets and lengths for debugging purposes.
  NDPI_LOG_DBG2(ndpi_struct, "pn_offset=%u, token_length=%llu, payload_length=%llu\n",
                pn_offset, (unsigned long long)token_length, (unsigned long long)payload_length);