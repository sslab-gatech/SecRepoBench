// Initialize the header protection cipher
  if (!quic_hp_cipher_init(&ciphers.hp_cipher, GCRY_MD_SHA256, 16, client_secret, version)) {
    NDPI_LOG_DBG(ndpi_struct, "Error initializing header protection cipher\n");
    return NULL;
  }

  // Initialize the payload protection cipher
  if (!quic_pp_cipher_init(&ciphers.pp_cipher, GCRY_MD_SHA256, 16, client_secret, version)) {
    NDPI_LOG_DBG(ndpi_struct, "Error initializing payload protection cipher\n");
    quic_ciphers_reset(&ciphers);
    return NULL;
  }

  // Calculate the packet number offset
  pn_offset = 5 + src_conn_id_len; // 5 bytes for fixed header + source connection ID length

  // Determine token length and add it to the offset
  token_length = ndpi_quic_varint_decode(packet->payload, packet->payload_packet_len, &pn_offset);
  if (token_length == 0 || pn_offset + token_length > packet->payload_packet_len) {
    NDPI_LOG_DBG(ndpi_struct, "Invalid token length\n");
    quic_ciphers_reset(&ciphers);
    return NULL;
  }
  pn_offset += token_length;

  // Retrieve the payload length
  payload_length = ndpi_quic_varint_decode(packet->payload, packet->payload_packet_len, &pn_offset);
  if (payload_length == 0 || pn_offset + payload_length > packet->payload_packet_len) {
    NDPI_LOG_DBG(ndpi_struct, "Invalid payload length\n");
    quic_ciphers_reset(&ciphers);
    return NULL;
  }

  NDPI_LOG_DBG2(ndpi_struct, "pn_offset: %u, token_length: %lu, payload_length: %lu\n",
                pn_offset, token_length, payload_length);