/* Initialize the header protection cipher */
  if(!quic_hp_cipher_init(&ciphers.hp_cipher, GCRY_MD_SHA256, 16, client_secret, version)) {
    NDPI_LOG_DBG(ndpi_struct, "Error initializing header protection cipher\n");
    return NULL;
  }

  /* Calculate packet number offset */
  pn_offset = 1;  /* Skip first byte */
  
  /* Skip destination connection ID */
  if(pn_offset + 1 + dest_conn_id_len > packet->payload_packet_len) {
    NDPI_LOG_DBG(ndpi_struct, "Packet too short for destination connection ID\n");
    quic_ciphers_reset(&ciphers);
    return NULL;
  }
  pn_offset += 1 + dest_conn_id_len;  /* DCID length byte + DCID */
  
  /* Skip source connection ID */
  if(pn_offset + 1 + src_conn_id_len > packet->payload_packet_len) {
    NDPI_LOG_DBG(ndpi_struct, "Packet too short for source connection ID\n");
    quic_ciphers_reset(&ciphers);
    return NULL;
  }
  pn_offset += 1 + src_conn_id_len;  /* SCID length byte + SCID */
  
  /* Parse token length (variable-length integer) */
  if(pn_offset >= packet->payload_packet_len) {
    NDPI_LOG_DBG(ndpi_struct, "Packet too short for token length\n");
    quic_ciphers_reset(&ciphers);
    return NULL;
  }
  
  /* Read token length as variable-length integer */
  uint8_t first_token_byte = packet->payload[pn_offset];
  uint8_t vlen_prefix = first_token_byte >> 6;
  uint8_t vlen_size;
  
  switch(vlen_prefix) {
    case 0: vlen_size = 1; break;
    case 1: vlen_size = 2; break;
    case 2: case 3: vlen_size = 4 + ((vlen_prefix & 1) * 4); break; /* 4 or 8 bytes */
    default: vlen_size = 1; /* can't happen but avoids compiler warning */
  }
  
  if(pn_offset + vlen_size > packet->payload_packet_len) {
    NDPI_LOG_DBG(ndpi_struct, "Packet too short for token length field\n");
    quic_ciphers_reset(&ciphers);
    return NULL;
  }
  
  /* Decode token length based on prefix */
  if(vlen_size == 1) {
    token_length = first_token_byte;
  } else if(vlen_size == 2) {
    token_length = ((first_token_byte & 0x3F) << 8) | packet->payload[pn_offset + 1];
  } else if(vlen_size == 4) {
    token_length = ((uint64_t)(first_token_byte & 0x3F) << 24) |
                  ((uint64_t)packet->payload[pn_offset + 1] << 16) |
                  ((uint64_t)packet->payload[pn_offset + 2] << 8) |
                  packet->payload[pn_offset + 3];
  } else { /* vlen_size == 8 */
    token_length = ((uint64_t)(first_token_byte & 0x3F) << 56) |
                  ((uint64_t)packet->payload[pn_offset + 1] << 48) |
                  ((uint64_t)packet->payload[pn_offset + 2] << 40) |
                  ((uint64_t)packet->payload[pn_offset + 3] << 32) |
                  ((uint64_t)packet->payload[pn_offset + 4] << 24) |
                  ((uint64_t)packet->payload[pn_offset + 5] << 16) |
                  ((uint64_t)packet->payload[pn_offset + 6] << 8) |
                  packet->payload[pn_offset + 7];
  }
  
  pn_offset += vlen_size;
  
  /* Skip token */
  if(pn_offset + token_length > packet->payload_packet_len) {
    NDPI_LOG_DBG(ndpi_struct, "Packet too short for token\n");
    quic_ciphers_reset(&ciphers);
    return NULL;
  }
  pn_offset += token_length;
  
  /* Parse length (variable-length integer) */
  if(pn_offset >= packet->payload_packet_len) {
    NDPI_LOG_DBG(ndpi_struct, "Packet too short for length field\n");
    quic_ciphers_reset(&ciphers);
    return NULL;
  }
  
  /* Read payload length as variable-length integer */
  uint8_t first_length_byte = packet->payload[pn_offset];
  vlen_prefix = first_length_byte >> 6;
  
  switch(vlen_prefix) {
    case 0: vlen_size = 1; break;
    case 1: vlen_size = 2; break;
    case 2: case 3: vlen_size = 4 + ((vlen_prefix & 1) * 4); break; /* 4 or 8 bytes */
    default: vlen_size = 1; /* can't happen but avoids compiler warning */
  }
  
  if(pn_offset + vlen_size > packet->payload_packet_len) {
    NDPI_LOG_DBG(ndpi_struct, "Packet too short for payload length field\n");
    quic_ciphers_reset(&ciphers);
    return NULL;
  }
  
  /* Decode payload length based on prefix */
  if(vlen_size == 1) {
    payload_length = first_length_byte;
  } else if(vlen_size == 2) {
    payload_length = ((first_length_byte & 0x3F) << 8) | packet->payload[pn_offset + 1];
  } else if(vlen_size == 4) {
    payload_length = ((uint64_t)(first_length_byte & 0x3F) << 24) |
                    ((uint64_t)packet->payload[pn_offset + 1] << 16) |
                    ((uint64_t)packe