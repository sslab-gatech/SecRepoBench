// Prepare the cipher context with the provided client secret and version.
// Calculate the packet number offset.
// Determine the length of the tokens and add it to the offset.
// Retrieve the payload length from the packet, updating the packet number offset.
// Log the calculated offsets and lengths for debugging purposes.
// <MASK>

uint32_t packet_number_offset = 0;
uint32_t token_length = 0;
uint32_t payload_length = 0;

if (version == V_Q046) {
    packet_number_offset = 4;
    token_length = 4;
} else {
    packet_number_offset = 8;
    token_length = 8;
}

payload_length = packet->payload_packet_len - packet_number_offset - token_length;

NDPI_LOG_DBG(ndpi_struct, "packet_number_offset: %u, token_length: %u, payload_length: %u\n",
             packet_number_offset, token_length, payload_length);

if (payload_length > packet->payload_packet_len) {
    NDPI_LOG_DBG(ndpi_struct, "Too short %u %u\n", payload_length, packet->payload_packet_len);
    quic_ciphers_reset(&ciphers);
    return NULL;
}