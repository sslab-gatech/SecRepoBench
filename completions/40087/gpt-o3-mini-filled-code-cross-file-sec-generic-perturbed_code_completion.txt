{
    /* Initialize header protection cipher */
    if (!quic_hp_cipher_init(&ciphers.hp_cipher, GCRY_MD_SHA256, 16, client_secret, version)) {
        NDPI_LOG_DBG(ndpi_struct, "Failed to initialize header protection cipher\n");
        return NULL;
    }
    /* Initialize packet protection cipher (using AEAD_AES_128_GCM for Initial packets).
       It is assumed that a similar initialization function exists.
    */
    if (!quic_pp_cipher_init(&ciphers.pp_cipher, GCRY_CIPHER_AES128, client_secret, version)) {
        NDPI_LOG_DBG(ndpi_struct, "Failed to initialize packet protection cipher\n");
        quic_ciphers_reset(&ciphers);
        return NULL;
    }

    /* Calculate the offset after fixed header fields.
       QUIC Initial packet long header contains:
         1 byte   : first_byte
         4 bytes  : version
         1 byte   : dest_conn_id length (implicit, already provided as dest_conn_id_len)
         dest_conn_id_len bytes : destination connection ID
         1 byte   : src_conn_id length (provided as src_conn_id_len)
         src_conn_id_len bytes : source connection ID
    */
    uint32_t pos = 1 + 4 + 1 + dest_conn_id_len + 1 + src_conn_id_len;
    if (pos > packet->payload_packet_len) {
        NDPI_LOG_DBG(ndpi_struct, "Packet too short for fixed header fields\n");
        quic_ciphers_reset(&ciphers);
        return NULL;
    }

    /* Decode Token Length (a QUIC variable‐length integer) */
    if (pos >= packet->payload_packet_len) {
        NDPI_LOG_DBG(ndpi_struct, "No space for Token Length field\n");
        quic_ciphers_reset(&ciphers);
        return NULL;
    }
    uint8_t token_len_field = packet->payload[pos];
    uint8_t token_len_size;
    switch(token_len_field >> 6) {
        case 0:
            token_len_size = 1;
            break;
        case 1:
            token_len_size = 2;
            break;
        case 2:
            token_len_size = 4;
            break;
        case 3:
            token_len_size = 8;
            break;
        default:
            token_len_size = 1;
            break;
    }
    if (pos + token_len_size > packet->payload_packet_len) {
        NDPI_LOG_DBG(ndpi_struct, "Packet too short for complete Token Length\n");
        quic_ciphers_reset(&ciphers);
        return NULL;
    }
    token_length = 0;
    if (token_len_size == 1) {
        token_length = token_len_field & 0x3F;
    } else if (token_len_size == 2) {
        token_length = ((uint64_t)(token_len_field & 0x3F) << 8) | packet->payload[pos + 1];
    } else if (token_len_size == 4) {
        token_length = ((uint64_t)(token_len_field & 0x3F) << 24) |
                       (packet->payload[pos + 1] << 16) |
                       (packet->payload[pos + 2] << 8) |
                       packet->payload[pos + 3];
    } else if (token_len_size == 8) {
        token_length = ((uint64_t)(token_len_field & 0x3F) << 56) |
                       ((uint64_t)packet->payload[pos + 1] << 48) |
                       ((uint64_t)packet->payload[pos + 2] << 40) |
                       ((uint64_t)packet->payload[pos + 3] << 32) |
                       (packet->payload[pos + 4] << 24) |
                       (packet->payload[pos + 5] << 16) |
                       (packet->payload[pos + 6] << 8) |
                       packet->payload[pos + 7];
    }
    pos += token_len_size;
    if (pos + token_length > packet->payload_packet_len) {
        NDPI_LOG_DBG(ndpi_struct, "Packet too short for Token\n");
        quic_ciphers_reset(&ciphers);
        return NULL;
    }
    /* Skip over the Token field */
    pos += token_length;

    /* Decode Payload Length (a QUIC variable‐length integer) */
    if (pos >= packet->payload_packet_len) {
        NDPI_LOG_DBG(ndpi_struct, "No space for Payload Length field\n");
        quic_ciphers_reset(&ciphers);
        return NULL;
    }
    uint8_t payload_len_field = packet->payload[pos];
    uint8_t payload_len_size;
    switch(payload_len_field >> 6) {
        case 0:
            payload_len_size = 1;
            break;
        case 1:
            payload_len_size = 2;
            break;
        case 2:
            payload_len_size = 4;
            break;
        case 3:
            payload_len_size = 8;
            break;
        default:
            payload_len_size = 1;
            break;
    }
    if (pos + payload_len_size > packet->payload_packet_len) {
        NDPI_LOG_DBG(ndpi_struct, "Packet too short for complete Payload Length\n");
        quic_ciphers_reset(&ciphers);
        return NULL;
    }
    payload_length = 0;
    if (payload_len_size == 1) {
        payload_length = payload_len_field & 0x3F;
    } else if (payload_len_size == 2) {
        payload_length = ((uint64_t)(payload_len_field & 0x3F) << 8) | packet->payload[pos + 1];
    } else if (payload_len_size == 4) {
        payload_length = ((uint64_t)(payload_len_field & 0x3F) << 24) |
                         (packet->payload[pos + 1] << 16) |
                         (packet->payload[pos + 2] << 8) |
                         packet->payload[pos + 3];
    } else if (payload_len_size == 8) {
        payload_length = ((uint64_t)(payload_len_field & 0x3F) << 56) |
                         ((uint64_t)packet->payload[pos + 1] << 48) |
                         ((uint64_t)packet->payload[pos + 2] << 40) |
                         ((uint64_t)packet->payload[pos + 3] << 32) |
                         (packet->payload[pos + 4] << 24) |
                         (packet->payload[pos + 5] << 16) |
                         (packet->payload[pos + 6] << 8) |
                         packet->payload[pos + 7];
    }
    pos += payload_len_size;
    pn_offset = pos;

    NDPI_LOG_DBG2(ndpi_struct, "Initial Packet: token_length=%llu, payload_length=%llu, pn_offset=%u\n",
                  token_length, payload_length, pn_offset);
}