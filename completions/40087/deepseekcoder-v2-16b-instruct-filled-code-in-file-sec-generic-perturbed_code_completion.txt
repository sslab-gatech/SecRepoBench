",
                       (unsigned long)frag_len, counter, clear_payload_len, version);
          return NULL;
        }
        crypto_data = get_reassembled_crypto_data(ndpi_struct, flow,
                                                  &clear_payload[counter],
                                                  frag_offset, frag_len,
                                                  crypto_data_len);
        if(!crypto_data)
          return NULL;
        counter += frag_len;
        break;
      case 0x07:
        NDPI_LOG_DBG2(ndpi_struct, "ACK frame\n");
        counter += 1;
        break;
      case 0x08:
        NDPI_LOG_DBG2(ndpi_struct, "RESET_STREAM frame\n");
        counter += 1;
        break;
      case 0x09:
        NDPI_LOG_DBG2(ndpi_struct, "STOP_SENDING frame\n");
        counter += 1;
        break;
      case 0x0A:
        NDPI_LOG_DBG2(ndpi_struct, "CRYPTO frame\n");
        counter += 1;
        if(counter > clear_payload_len ||
           counter + quic_len_buffer_still_required(clear_payload[counter]) > clear_payload_len)
          return NULL;
        counter += quic_len(&clear_payload[counter], &frag_offset);
        if(counter > clear_payload_len ||
           counter + quic_len_buffer_still_required(clear_payload[counter]) > clear_payload_len)
          return NULL;
        counter += quic_len(&clear_payload[counter], &frag_len);
        if(frag_len + counter > clear_payload_len) {
          NDPI_LOG_DBG(ndpi_struct, "Invalid crypto frag length %lu + %d > %d version 0x%x\n",
                       (unsigned long)frag_len, counter, clear_payload_len, version);
          return NULL;
        }
        crypto_data = get_reassembled_crypto_data(ndpi_struct, flow,
                                                  &clear_payload[counter],
                                                  frag_offset, frag_len,
                                                  crypto_data_len);
        if(!crypto_data)
          return NULL;
        counter += frag_len;
        break;
      case 0x0B:
        NDPI_LOG_DBG2(ndpi_struct, "NEW_TOKEN frame\n");
        counter += 1;
        break;
      case 0x0C:
        NDPI_LOG_DBG2(ndpi_struct, "STREAM frame\n");
        counter += 1;
        break;
      case 0x0D:
        NDPI_LOG_DBG2(ndpi_struct, "MAX_DATA frame\n");
        counter += 1;
        break;
      case 0x0E:
        NDPI_LOG_DBG2(ndpi_struct, "MAX_STREAM_DATA frame\n");
        counter += 1;
        break;
      case 0x0F:
        NDPI_LOG_DBG2(ndpi_struct, "MAX_STREAMS frame\n");
        counter += 1;
        break;
      case 0x10:
        NDPI_LOG_DBG2(ndpi_struct, "DATA_BLOCKED frame\n");
        counter += 1;
        break;
      case 0x11:
        NDPI_LOG_DBG2(ndpi_struct, "STREAM_DATA_BLOCKED frame\n");
        counter += 1;
        break;
      case 0x12:
        NDPI_LOG_DBG2(ndpi_struct, "STREAMS_BLOCKED frame\n");
        counter += 1;
        break;
      case 0x13:
        NDPI_LOG_DBG2(ndpi_struct, "NEW_CONNECTION_ID frame\n");
        counter += 1;
        break;
      case 0x14:
        NDPI_LOG_DBG2(ndpi_struct, "RETIRE_CONNECTION_ID frame\n");
        counter += 1;
        break;
      case 0x15:
        NDPI_LOG_DBG2(ndpi_struct, "PATH_CHALLENGE frame\n");
        counter += 1;
        break;
      case 0x16:
        NDPI_LOG_DBG2(ndpi_struct, "PATH_RESPONSE frame\n");
        counter += 1;
        break;
      case 0x17:
        NDPI_LOG_DBG2(ndpi_struct, "GOAWAY frame\n");
        counter += 1;
        break;
      default:
        NDPI_LOG_DBG(ndpi_struct, "Unknown frame type 0x%x\n", frame_type);
        return NULL;
      }
    }
  }

  return crypto_data;
}

int processClientServerHello(struct ndpi_detection_module_struct *ndpi_struct,
                             struct ndpi_flow_struct *flow, uint32_t quic_version)
{
  uint32_t version = ntohl(quic_version);
  const u_int8_t *payload;
  uint32_t payload_len;
  uint64_t crypto_data_len;
  const u_int8_t *crypto_data;
  int rc;

  if(!is_version_with_tls(version))
    return 0;

  payload = ndpi_packet_get_payload(ndpi_struct, &payload_len);
  if(!payload)
    return 0;

  crypto_data = get_crypto_data(ndpi_struct, flow, version, payload, payload_len, &crypto_data_len);
  if(!crypto_data)
    return 0;

  if(is_gquic_ver_less_than(version, 46)) {
    rc = processClientServerHello_gquic(ndpi_struct, flow, crypto_data, crypto_data_len);
  } else {
    rc = processClientServerHello_quic(ndpi_struct, flow, crypto_data, crypto_data_len);
  }

  return rc;
}

int processClientServerHello_gquic(struct ndpi_detection_module_struct *ndpi_struct,
                                   struct ndpi_flow_struct *flow,
                                   const u_int8_t *crypto_data, uint64_t crypto_data_len)
{
  uint32_t msg_len;
  const u_int8_t *msg;
  uint32_t msg_offset;

  if(crypto_data_len < 4)
    return 0;
  msg_len = (crypto_data[1] << 16) + (crypto_data[2] << 8) + crypto_data[3];
  if(msg_len + 4 > crypto_data_len)
    return 0;
  msg = &crypto_data[4];
  msg_offset = 4 + msg_len;

  if(msg_len >= 4 && msg[0] == 0x02 && msg[1] == 0x2F && msg[2] == 0x00 && msg[3] == 0x00) {
    NDPI_LOG_INFO(ndpi_struct, "Found ClientHello in GQUIC crypto data\n");
    processClientHello(ndpi_struct, flow, msg, msg_len);
    return 1;
  } else if(msg_len >= 4 && msg[0] == 0x02 && msg[1] == 0x32 && msg[2] == 0x00 && msg[3] == 0x00) {
    NDPI_LOG_INFO(ndpi_struct, "Found ServerHello in GQUIC crypto data\n");
    processServerHello(ndpi_struct, flow, msg, msg_len);
    return 1;
  }

  return 0;
}

int processClientServerHello_quic(struct ndpi_detection_module_struct *ndpi_struct,
                                  struct ndpi_flow_struct *flow,
                                  const u_int8_t *crypto_data, uint64_t crypto_data_len)
{
  uint32_t msg_len;
  const u_int8_t *msg;
  uint32_t msg_offset;

  if(crypto_data_len < 4)
    return 0;
  msg_len = (crypto_data[1] << 16) + (crypto_data[2] << 8) + crypto_data[3];
  if(msg_len + 4 > crypto_data_len)
    return 0;
  msg = &crypto_data[4];
  msg_offset = 4 + msg_len;

  if(msg_len >= 4 && msg[0] == 0x02 && msg[1] == 0x2F && msg[2] == 0x00 && msg[3] == 0x00) {
    NDPI_LOG_INFO(ndpi_struct, "Found ClientHello in QUIC crypto data\n");
    processClientHello(ndpi_struct, flow, msg, msg_len);
    return 1;
  } else if(msg_len >= 4 && msg[0] == 0x02 && msg[1] == 0x32 && msg[2] == 0x00 && msg[3] == 0x00) {
    NDPI_LOG_INFO(ndpi_struct, "Found ServerHello in QUIC crypto data\n");
    processServerHello(ndpi_struct, flow, msg, msg_len);
    return 1;
  }

  return 0;
}

void processClientHello(struct ndpi_detection_module_struct *ndpi_struct,
                        struct ndpi_flow_struct *flow,
                        const u_int8_t *msg, uint32_t msg_len)
{
  uint32_t offset = 0;
  uint32_t payload_len;
  const u_int8_t *payload;

  payload = ndpi_packet_get_payload(ndpi_struct, &payload_len);
  if(!payload)
    return;

  while(offset < payload_len) {
    uint8_t frame_type = payload[offset];
    uint32_t frame_len;

    switch(frame_type) {
    case 0x00:
      NDPI_LOG_INFO(ndpi_struct, "Found PADDING frame\n");
      offset += 1 + (payload[offset + 1] & 0x3F);
      break;
    case 0x01:
      NDPI_LOG_INFO(ndpi_struct, "Found PING frame\n");
      offset += 1 + 8;
      break;
    case 0x06:
      NDPI_LOG_INFO(ndpi_struct, "Found CRYPTO frame\n");
      offset += 1 + quic_len(&payload[offset + 1], &frame_len);
      break;
    case 0x07:
      NDPI_LOG_INFO(ndpi_struct, "Found ACK frame\n");
      offset += 1 + 8 + 8;
      break;
    case 0x08:
      NDPI_LOG_INFO(ndpi_struct, "Found RESET_STREAM frame\n");
      offset += 1 + 4 + 4;
      break;
    case 0x09:
      NDPI_LOG_INFO(ndpi_struct, "Found STOP_SENDING frame\n");
      offset += 1 + 4 + 4;
      break;
    case 0x0A:
      NDPI_LOG_INFO(ndpi_struct, "Found CRYPTO frame\n");
      offset += 1 + quic_len(&payload[offset + 1], &frame_len);
      break;
    case 0x0B:
      NDPI_LOG_INFO(ndpi_struct, "Found NEW_TOKEN frame\n");
      offset += 1 + 1 + (payload[offset + 1] & 0x3F);
      break;
    case 0x0C:
      NDPI_LOG_INFO(ndpi_struct, "Found STREAM frame\n");
      offset += 1 + 4 + 4 + 2 + 2;
      break;
    case 0x0D:
      NDPI_LOG_INFO(ndpi_struct, "Found MAX_DATA frame\n");
      offset +=