if (packet_number_offset + payload_length > packet->payload_packet_len) {
    NDPI_LOG_DBG(ndpi_struct, "Too short %d %d\n", packet_number_offset + payload_length,
                 packet->payload_packet_len);
    quic_ciphers_reset(&ciphers);
    return NULL;
}

if(!quic_decrypt_header(&packet->payload[0], packet_number_offset, &ciphers.hp_cipher,
			  GCRY_CIPHER_AES128, &first_byte, &pkn32, 0)) {
    quic_ciphers_reset(&ciphers);
    return NULL;
}
NDPI_LOG_DBG2(ndpi_struct, "first_byte 0x%x pkn32 0x%x\n", first_byte, pkn32);

pkn_len = (first_byte & 3) + 1;
/* TODO: is it always true in Initial Packets? */
packet_number = pkn32;

offset = packet_number_offset + pkn_len;
if (!(packet_number_offset + payload_length >= offset + 16)) {
    NDPI_LOG_DBG(ndpi_struct, "No room for Auth Tag %d %d",
                 packet_number_offset + payload_length, offset);
    quic_ciphers_reset(&ciphers);
    return NULL;
}
quic_decrypt_message(&ciphers.pp_cipher, &packet->payload[0], packet_number_offset + payload_length,
                     offset, first_byte, pkn_len, packet_number, &decryption);

quic_ciphers_reset(&ciphers);

if(decryption.data_len) {
    *clear_payload_len = decryption.data_len;
    return decryption.data;
}
return NULL;