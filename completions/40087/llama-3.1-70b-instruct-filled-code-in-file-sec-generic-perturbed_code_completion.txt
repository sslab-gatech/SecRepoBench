/* Prepare the cipher context with the provided client secret and version. */
if(!quic_ciphers_prepare(&ciphers, GCRY_MD_SHA256, GCRY_CIPHER_AES128, GCRY_CIPHER_MODE_GCM, client_secret, version)) {
  NDPI_LOG_DBG(ndpi_struct, "Error quic_ciphers_prepare\n");
  return NULL;
}

/* Calculate the packet number offset. */
pn_offset = 1 + 4 + dest_conn_id_len + 1 + source_conn_id_len;

/* Determine the length of the tokens and add it to the offset. */
uint64_t token_length;
if(quic_len(&packet->payload[pn_offset], &token_length) == 0) {
  NDPI_LOG_DBG(ndpi_struct, "Error quic_len\n");
  return NULL;
}
pn_offset += quic_len_buffer_still_required(packet->payload[pn_offset]);
pn_offset += token_length;

/* Retrieve the payload length from the packet, updating the packet number offset. */
if(quic_len(&packet->payload[pn_offset], &payload_length) == 0) {
  NDPI_LOG_DBG(ndpi_struct, "Error quic_len\n");
  return NULL;
}
pn_offset += quic_len_buffer_still_required(packet->payload[pn_offset]);

/* Log the calculated offsets and lengths for debugging purposes. */
NDPI_LOG_DBG2(ndpi_struct, "pn_offset %d payload_length %lu\n", pn_offset, payload_length);