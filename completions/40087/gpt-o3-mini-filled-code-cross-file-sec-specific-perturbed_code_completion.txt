if (!quic_hp_cipher_init(&ciphers.hp_cipher, GCRY_MD_SHA256, 16, client_secret, version)) {
  NDPI_LOG_DBG(ndpi_struct, "Error initializing header protection cipher\n");
  return NULL;
}
uint32_t offset_local = 0;
const uint8_t *p_payload = packet->payload;
uint32_t p_len = packet->payload_packet_len;
/* Ensure there is at least one byte for first_byte and 4 for version */
if (p_len < 5) {
  NDPI_LOG_DBG(ndpi_struct, "Packet too short for initial header\n");
  quic_ciphers_reset(&ciphers);
  return NULL;
}
offset_local++; /* Skip first byte (already read into first_byte) */
offset_local += 4; /* Skip version field */
/* Destination Connection ID length */
if (p_len < offset_local + 1) {
  NDPI_LOG_DBG(ndpi_struct, "Packet too short to read destination CID length\n");
  quic_ciphers_reset(&ciphers);
  return NULL;
}
uint8_t dcid_len_field = p_payload[offset_local];
if (dcid_len_field != dest_conn_id_len) {
  NDPI_LOG_DBG(ndpi_struct, "Destination CID length mismatch: expected %d, got %d\n",
               dest_conn_id_len, dcid_len_field);
  quic_ciphers_reset(&ciphers);
  return NULL;
}
offset_local++;
if (p_len < offset_local + dcid_len_field) {
  NDPI_LOG_DBG(ndpi_struct, "Packet too short for destination CID\n");
  quic_ciphers_reset(&ciphers);
  return NULL;
}
offset_local += dcid_len_field;
/* Source Connection ID length */
if (p_len < offset_local + 1) {
  NDPI_LOG_DBG(ndpi_struct, "Packet too short to read source CID length\n");
  quic_ciphers_reset(&ciphers);
  return NULL;
}
uint8_t scid_len_field = p_payload[offset_local];
if (scid_len_field != src_conn_id_len) {
  NDPI_LOG_DBG(ndpi_struct, "Source CID length mismatch: expected %d, got %d\n",
               src_conn_id_len, scid_len_field);
  quic_ciphers_reset(&ciphers);
  return NULL;
}
offset_local++;
if (p_len < offset_local + scid_len_field) {
  NDPI_LOG_DBG(ndpi_struct, "Packet too short for source CID\n");
  quic_ciphers_reset(&ciphers);
  return NULL;
}
offset_local += scid_len_field;
/* Read Token Length (QUIC variable-length integer) */
if (p_len < offset_local + 1) {
  NDPI_LOG_DBG(ndpi_struct, "Packet too short for token length\n");
  quic_ciphers_reset(&ciphers);
  return NULL;
}
uint8_t token_first_byte = p_payload[offset_local];
uint8_t token_len_bytes = 1 << (token_first_byte >> 6);  /* 1,2,4, or 8 bytes */
if (p_len < offset_local + token_len_bytes) {
  NDPI_LOG_DBG(ndpi_struct, "Packet too short for complete token length field\n");
  quic_ciphers_reset(&ciphers);
  return NULL;
}
token_length = 0;
for (uint8_t i = 0; i < token_len_bytes; i++) {
  token_length = (token_length << 8) | p_payload[offset_local + i];
}
offset_local += token_len_bytes;
if (p_len < offset_local + token_length) {
  NDPI_LOG_DBG(ndpi_struct, "Packet too short for token data\n");
  quic_ciphers_reset(&ciphers);
  return NULL;
}
offset_local += token_length;
/* Read Payload Length (QUIC variable-length integer) */
if (p_len < offset_local + 1) {
  NDPI_LOG_DBG(ndpi_struct, "Packet too short for payload length\n");
  quic_ciphers_reset(&ciphers);
  return NULL;
}
uint8_t payload_first_byte = p_payload[offset_local];
uint8_t payload_len_bytes = 1 << (payload_first_byte >> 6);
if (p_len < offset_local + payload_len_bytes) {
  NDPI_LOG_DBG(ndpi_struct, "Packet too short for complete payload length field\n");
  quic_ciphers_reset(&ciphers);
  return NULL;
}
payload_length = 0;
for (uint8_t i = 0; i < payload_len_bytes; i++) {
  payload_length = (payload_length << 8) | p_payload[offset_local + i];
}
offset_local += payload_len_bytes;
/* Set packet number offset for further processing */
pn_offset = offset_local;
NDPI_LOG_DBG2(ndpi_struct, "Header parsed: pn_offset=%u, token_length=%llu, payload_length=%llu\n",
              pn_offset, token_length, payload_length);