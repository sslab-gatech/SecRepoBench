if(handshake_type == 0x02 /* Server Hello */) {
  /* Parse the TLS handshake message from the packet to determine whether it is a Client Hello or Server Hello.
     Depending on the type of handshake message, extract relevant information such as cipher suites and TLS extensions.
     For a Server Hello, adjust offsets based on the session ID length and extract the server's cipher suite.
     For a Client Hello, parse the cipher suites and extensions, skipping GREASE values, and extract supported versions and other extension information.
     Construct a JA3 string based on extracted details, including TLS version, cipher suites, and extensions for fingerprinting purposes.
     Compute an MD5 hash of the JA3 string for both Client and Server handshakes to create a unique JA3 fingerprint.
     Store the computed JA3 hash in the flow structure for later analysis or comparison.
     Return a specific code to indicate the type of handshake processed, or zero if parsing was unsuccessful.
  */
  u_int16_t offset = 38, extension_len, j;
  u_int8_t  session_id_len =  packet->tcp? packet->payload[offset] : packet->payload[46];
  u_int16_t server_hello_offset = offset + session_id_len + 2;

  if(packet->tcp) {
    extension_len = packet->payload[server_hello_offset];
    offset += extension_len + 2;
  } else {
    extension_len = packet->payload[server_hello_offset + 1];
    offset += extension_len + 2;
  }

  u_int16_t cipher_suite_len = ntohs(*((u_int16_t*)&packet->payload[offset]));
  offset += 2;

  for(j = 0; j < cipher_suite_len; j++) {
    u_int16_t cipher_suite = ntohs(*((u_int16_t*)&packet->payload[offset]));
    if(cipher_suite!= 0x0000) {
      ja3.cipher_suite[j] = cipher_suite;
    }
    offset += 2;
  }

  ja3_str_len = 0;
  for(j = 0; j < extension_len; j++) {
    u_int16_t extension_type = ntohs(*((u_int16_t*)&packet->payload[offset]));
    u_int16_t extension_len = ntohs(*((u_int16_t*)&packet->payload[offset + 2]));
    offset += 4;

    if(extension_type == 0x00 || extension_type == 0x01 || extension_type == 0x03 || extension_type == 0x04) {
      ja3_str_len += 2;
      ja3_str[ja3_str_len] = extension_type;
      ja3_str[ja3_str_len + 1] = extension_len;
    } else if(extension_type == 0x05) {
      u_int16_t extension_data_len = ntohs(*((u_int16_t*)&packet->payload[offset]));
      offset += 2;
      ja3_str_len += extension_data_len;
      memcpy(ja3_str + ja3_str_len, packet->payload + offset, extension_data_len);
      offset += extension_data_len;
    }
  }

  ja3_str_len += 2;
  ja3_str[ja3_str_len] = 0x00;
  ja3_str[ja3_str_len + 1] = 0x00;

  MD5Init(&ctx);
  MD5Update(&ctx, (u_char*)ja3_str, ja3_str_len);
  MD5Final(md5_hash, &ctx);

  for(i = 0; i < 16; i++) {
    sprintf(buffer + i * 2, "%02X", md5_hash[i]);
  }

  flow->l4.tcp.tls.ja3_hash = strdup(buffer);

  return 1; /* Server Hello */
} else if(handshake_type == 0x01 /* Client Hello */) {
  /* Parse the TLS handshake message from the packet to determine whether it is a Client Hello or Server Hello.
     Depending on the type of handshake message, extract relevant information such as cipher suites and TLS extensions.
     For a Server Hello, adjust offsets based on the session ID length and extract the server's cipher suite.
     For a Client Hello, parse the cipher suites and extensions, skipping GREASE values, and extract supported versions and other extension information.
     Construct a JA3 string based on extracted details, including TLS version, cipher suites, and extensions for fingerprinting purposes.
     Compute an MD5 hash of the JA3 string for both Client and Server handshakes to create a unique JA3 fingerprint.
     Store the computed JA3 hash in the flow structure for later analysis or comparison.
     Return a specific code to indicate the type of handshake processed, or zero if parsing was unsuccessful.
  */
  u_int16_t offset = 38, extension_len, j;
  u_int8_t  session_id_len =  packet->tcp? packet->payload[offset] : packet->payload[46];
  u_int16_t client_hello_offset = offset + session_id_len + 2;

  if(packet->tcp) {
    extension_len = packet->payload[client_hello_offset];
    offset += extension_len + 2;
  } else {
    extension_len = packet->payload[client_hello_offset + 1];
    offset += extension_len + 2;
  }

  u_int16_t cipher_suite_len = ntohs(*((u_int16_t*)&packet->payload[offset]));
  offset += 2;

  for(j = 0; j < cipher_suite_len; j++) {
    u_int16_t cipher_suite = ntohs(*((u_int16_t*)&packet->payload[offset]));
    if(cipher_suite!= 0x0000) {
      ja3.cipher_suite[j] = cipher_suite;
    }
    offset += 2;
  }

  ja3_str_len = 0;
  for(j = 0; j < extension_len; j++) {
    u_int16_t extension_type = ntohs(*((u_int16_t*)&packet->payload[offset]));
    u_int16_t extension_len = ntohs(*((u_int16_t*)&packet->payload[offset + 2]));
    offset += 4;

    if(extension_type == 0x00 || extension_type == 0x01 || extension_type == 0x03 || extension_type == 0x04) {
      ja3_str_len += 2;
      ja3_str[ja3_str_len] = extension_type;
      ja3_str[ja3_str_len + 1] = extension_len;
    } else if(extension_type == 0x05) {
      u_int16_t extension_data_len = ntohs(*((u_int16_t*)&packet->payload[offset]));
      offset += 2;
      ja3_str_len += extension_data_len;
      memcpy(ja3_str + ja3_str_len, packet->payload + offset, extension_data_len);
      offset += extension_data_len;
    }
  }

  ja3_str_len += 2;
  ja3_str[ja3_str_len] = 0x00;
  ja3_str[ja3_str_len + 1] = 0x00;

  MD5Init(&ctx);
  MD5Update(&ctx, (u_char*)ja3_str, ja3_str_len);
  MD5Final(md5_hash, &ctx);

  for(i = 0; i < 16; i++) {
    sprintf(buffer + i * 2, "%02X", md5_hash[i]);
  }

  flow->l4.tcp.tls.ja3_hash = strdup(buffer);

  return 1; /* Client Hello */
} else {
  return 0; /* Not a Client or Server Hello */
}