{
      offset = packet->tcp ? (38 + 1) : (46 + 1);

      if((offset + session_id_len) > total_len)
        return(0);

      ja3.server_cipher_suite = ntohs(*((u_int16_t*)&packet->payload[offset + session_id_len]));

#ifdef DEBUG_TLS
      printf("SSL Server Hello [session_id_len: %u][cipher: %04X]\n",
             session_id_len, ja3.server_cipher_suite);
#endif

      /* JA3 string */
      ja3_str_len = snprintf(ja3_str, sizeof(ja3_str), "%u,%u,,",
                             ja3.tls_handshake_version,
                             ja3.server_cipher_suite);

      if((ja3_str_len <= 0) || (ja3_str_len >= sizeof(ja3_str))) {
        jainvalid = 1;
      }
    } else if(handshake_type == 0x01 /* Client Hello */) {
      u_int16_t cipher_suites_length, supported_versions_len = 0;
      u_int32_t extensions_length;

      offset = packet->tcp ? 36 : 44;
      cipher_suites_length = ntohs(*((u_int16_t*)&packet->payload[offset]));
      offset += 2;

      if((offset + cipher_suites_length) > total_len)
        return(0);

      for(i = 0, j = 0; i < cipher_suites_length; i += 2) {
        u_int16_t cipher_suite = ntohs(*((u_int16_t*)&packet->payload[offset + i]));

        /* Skip GREASE ciphers */
        if((cipher_suite & 0x0F0F) == 0x0A0A)
          continue;

        if(j < (sizeof(ja3.cipher_suites) / sizeof(ja3.cipher_suites[0])))
          ja3.cipher_suites[j++] = cipher_suite;
      }

      offset += cipher_suites_length;
      offset += 1; /* compression_methods_length */
      offset += packet->payload[offset]; /* compression_methods */

      if(offset > (total_len - 6))
        return(0);

      extensions_length = ntohs(*((u_int16_t*)&packet->payload[offset]));
      offset += 2;

      if((offset + extensions_length) > total_len)
        return(0);

      for(i = 0; i < extensions_length;) {
        u_int16_t extension_type = ntohs(*((u_int16_t*)&packet->payload[offset + i]));
        u_int16_t extension_data_len = ntohs(*((u_int16_t*)&packet->payload[offset + i + 2]));

        if((i + 4 + extension_data_len) > extensions_length)
          break;

        /* Skip GREASE extensions */
        if((extension_type & 0x0F0F) == 0x0A0A) {
          i += 4 + extension_data_len;
          continue;
        }

        switch(extension_type) {
        case 0x0005: /* status_request */
          ja3.status_request = 1;
          break;
        case 0x000a: /* supported_groups */
          ja3.supported_groups = 1;
          break;
        case 0x000b: /* ec_point_formats */
          ja3.ec_point_formats = 1;
          break;
        case 0x0010: /* application_layer_protocol_negotiation */
          ja3.alpn = 1;
          break;
        case 0x0016: /* encrypted_server_name */
          ja3.sni = 1;
          break;
        case 0x0017: /* extended_master_secret */
          ja3.extended_master_secret = 1;
          break;
        case 0x0023: /* session ticket */
          ja3.session_ticket = 1;
          break;
        case 0x0029: /* supported_versions */
          if(extension_data_len >= 2)
            supported_versions_len = ntohs(*((u_int16_t*)&packet->payload[offset + i + 4]));
          break;
        case 0xff01: /* renegotiation_info */
          ja3.renegotiation_info = 1;
          break;
        default:
          break;
        }

        i += 4 + extension_data_len;
      }

      /* JA3 string */
      ja3_str_len = snprintf(ja3_str, sizeof(ja3_str), "%u,", ja3.tls_handshake_version);

      if((ja3_str_len > 0) && (ja3_str_len < sizeof(ja3_str))) {
        for(i = 0; i < (sizeof(ja3.cipher_suites) / sizeof(ja3.cipher_suites[0])); i++) {
          if(ja3.cipher_suites[i] != 0) {
            int ret = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str) - ja3_str_len,
                           "%s%u", (i > 0) ? "-" : "", ja3.cipher_suites[i]);

            if((ret > 0) && ((ja3_str_len + ret) < sizeof(ja3_str)))
              ja3_str_len += ret;
            else {
              jainvalid = 1;
              break;
            }
          } else
            break;
        }

        if(!jainvalid && (ja3_str_len < sizeof(ja3_str))) {
          int ret = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str) - ja3_str_len, ",%u-%u-%u-%u-%u-%u-%u-%u,%u",
                         ja3.sni, ja3.status_request, ja3.supported_groups,
                         ja3.ec_point_formats, ja3.alpn, ja3.session_ticket,
                         ja3.extended_master_secret, ja3.renegotiation_info,
                         supported_versions_len);

          if((ret > 0) && ((ja3_str_len + ret) < sizeof(ja3_str)))
            ja3_str_len += ret;
          else
            jainvalid = 1;
        }
      } else
        jainvalid = 1;
    } else
      return(0);

    if(!jainvalid) {
      ndpi_md5_init(&ctx);
      ndpi_md5_update(&ctx, (const unsigned char*)ja3_str, ja3_str_len);
      ndpi_md5_final(md5_hash, &ctx);

      memcpy(flow->l4.tcp.tls.ja3_hash, md5_hash, 16);
      flow->l4.tcp.tls.ja3_valid = 1;

      for(i = 0; i < 16; i++)
        snprintf(&buffer[i * 2], sizeof(buffer) - i * 2, "%02x", flow->l4.tcp.tls.ja3_hash[i]);

#ifdef DEBUG_TLS
      printf("SSL JA3 Hash: %s\n", buffer);
#endif

      if(handshake_type == 0x01)
        return(1);
      else
        return(2);
    }