{
      /* Server Hello */
      offset += 1 + session_id_len; /* Skip session ID length and session ID */
      if (offset + 2 > total_len) return 0; /* Ensure we don't read out of bounds */

      ja3.cipher = ntohs(*((u_int16_t*)&packet->payload[offset]));
      offset += 2; /* Skip cipher suite */

      if (offset + 1 > total_len) return 0; /* Ensure we don't read out of bounds */
      ja3.compression = packet->payload[offset];
      offset += 1; /* Skip compression method */

      if (offset + 2 > total_len) return 0; /* Ensure we don't read out of bounds */
      extension_len = ntohs(*((u_int16_t*)&packet->payload[offset]));
      offset += 2; /* Skip extensions length */

      if (offset + extension_len > total_len) return 0; /* Ensure we don't read out of bounds */

      for (j = 0; j < extension_len;) {
        if (offset + 4 > total_len) return 0; /* Ensure we don't read out of bounds */
        u_int16_t ext_type = ntohs(*((u_int16_t*)&packet->payload[offset]));
        u_int16_t ext_len = ntohs(*((u_int16_t*)&packet->payload[offset + 2]));

        if (offset + 4 + ext_len > total_len) return 0; /* Ensure we don't read out of bounds */

        if (ext_type != 0x0a && ext_type != 0x2b && ext_type != 0x33 && ext_type != 0x39) {
          /* Skip GREASE values */
          snprintf(buffer, sizeof(buffer), "%s%u-", buffer, ext_type);
        }

        offset += 4 + ext_len; /* Move to the next extension */
        j += 4 + ext_len;
      }

      snprintf(ja3_str, sizeof(ja3_str), "%u,%u,%s", ja3.tls_handshake_version, ja3.cipher, buffer);

      ndpi_MD5_Init(&ctx);
      ndpi_MD5_Update(&ctx, (unsigned char*)ja3_str, strlen(ja3_str));
      ndpi_MD5_Final(md5_hash, &ctx);

      memcpy(flow->protos.stun_ssl.ssl.server_ja3_hash, md5_hash, sizeof(md5_hash));
      flow->protos.stun_ssl.ssl.server_ja3_hash_set = 1;

      return 1; /* Server Hello processed */
    }