{
      offset += session_id_len + 4;
      ja3_str_len = 0;

      /* Extract cipher suites */
      for (j = 0; j < ntohs(*((u_int16_t*)&packet->payload[offset])); j += 2) {
	u_int16_t cipher_suite = ntohs(*((u_int16_t*)&packet->payload[offset + j + 2]));
	ja3_str_len += sprintf(&ja3_str[ja3_str_len], "%u,", cipher_suite);
      }

      /* Extract extensions */
      offset += 2 + (ntohs(*((u_int16_t*)&packet->payload[offset])) * 2);
      extension_len = ntohs(*((u_int16_t*)&packet->payload[offset]));

      for (j = 0; j < extension_len; j += 2) {
	u_int16_t extension_type = ntohs(*((u_int16_t*)&packet->payload[offset + j + 2]));
	u_int16_t extension_len = ntohs(*((u_int16_t*)&packet->payload[offset + j + 4]));

	switch (extension_type) {
	case 0x000a: /* Signature Algorithms */
	  ja3_str_len += sprintf(&ja3_str[ja3_str_len], "%u,", extension_type);
	  break;
	case 0x0005: /* Supported Groups */
	  ja3_str_len += sprintf(&ja3_str[ja3_str_len], "%u,", extension_type);
	  break;
	case 0x000d: /* Supported Versions */
	  ja3_str_len += sprintf(&ja3_str[ja3_str_len], "%u,", extension_type);
	  break;
	case 0x0010: /* Extended Master Secret */
	  ja3_str_len += sprintf(&ja3_str[ja3_str_len], "%u,", extension_type);
	  break;
	case 0x0017: /* Renegotiation Info */
	  ja3_str_len += sprintf(&ja3_str[ja3_str_len], "%u,", extension_type);
	  break;
	case 0x0023: /* Padding */
	  ja3_str_len += sprintf(&ja3_str[ja3_str_len], "%u,", extension_type);
	  break;
	case 0x002b: /* Early Data */
	  ja3_str_len += sprintf(&ja3_str[ja3_str_len], "%u,", extension_type);
	  break;
	case 0x0033: /* Key Share */
	  ja3_str_len += sprintf(&ja3_str[ja3_str_len], "%u,", extension_type);
	  break;
	case 0x0035: /* PSK Key Exchange Modes */
	  ja3_str_len += sprintf(&ja3_str[ja3_str_len], "%u,", extension_type);
	  break;
	case 0x0036: /* Pre-Shared Key */
	  ja3_str_len += sprintf(&ja3_str[ja3_str_len], "%u,", extension_type);
	  break;
	case 0x0037: /* Session Tickets */
	  ja3_str_len += sprintf(&ja3_str[ja3_str_len], "%u,", extension_type);
	  break;
	case 0x0038: /* Certificate Request */
	  ja3_str_len += sprintf(&ja3_str[ja3_str_len], "%u,", extension_type);
	  break;
	case 0x0039: /* Certificate Status Request */
	  ja3_str_len += sprintf(&ja3_str[ja3_str_len], "%u,", extension_type);
	  break;
	case 0x0041: /* Server Name Indication */
	  ja3_str_len += sprintf(&ja3_str[ja3_str_len], "%u,", extension_type);
	  break;
	case 0x0043: /* OCSP Stapling */
	  ja3_str_len += sprintf(&ja3_str[ja3_str_len], "%u,", extension_type);
	  break;
	case 0x0045: /* SCT */
	  ja3_str_len += sprintf(&ja3_str[ja3_str_len], "%u,", extension_type);
	  break;
	case 0x0051: /* Session Ticket TLS */
	  ja3_str_len += sprintf(&ja3_str[ja3_str_len], "%u,", extension_type);
	  break;
	default:
	  break;
	}
	offset += 4 + extension_len;
      }

      ja3_str[ja3_str_len - 1] = '\0'; /* Remove trailing comma */
      NDPI_MD5Init(&ctx);
      NDPI_MD5Update(&ctx, ja3_str, strlen(ja3_str));
      NDPI_MD5Final(md5_hash, &ctx);

      for (i = 0; i < 16; i++) {
	sprintf(&buffer[i * 2], "%02X", md5_hash[i]);
      }

      flow->ja3_hash = strtoul(buffer, NULL, 16);
      flow->protos.stun_ssl.ssl.ja3_hash = flow->ja3_hash;
    }
    return(1);
  }