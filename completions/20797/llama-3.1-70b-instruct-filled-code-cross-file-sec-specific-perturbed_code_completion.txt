// Parse the TLS handshake message from the packet to determine whether it is a Client Hello or Server Hello.
if (handshake_type == 0x02 /* Server Hello */) {
  // Adjust offsets based on the session ID length and extract the server's cipher suite.
  offset += session_id_len + 1;
  u_int16_t cipher_suite_len = (packet->payload[offset] << 8) + packet->payload[offset + 1];
  offset += 2;
  ja3.server_cipher_suite = ntohs(*((u_int16_t*)&packet->payload[offset]));

  // Extract TLS extensions.
  u_int16_t extensions_len = (packet->payload[offset + 2] << 8) + packet->payload[offset + 3];
  offset += 4;
  while (extensions_len > 0) {
    u_int16_t extension_type = (packet->payload[offset] << 8) + packet->payload[offset + 1];
    u_int16_t extension_len = (packet->payload[offset + 2] << 8) + packet->payload[offset + 3];
    offset += 4;

    // Process extension based on type.
    switch (extension_type) {
      case 0x0000: // server_name
        // Extract server name.
        ja3.server_name = ntohs(*((u_int16_t*)&packet->payload[offset]));
        break;
      case 0x0005: // status_request
        // Extract status request.
        ja3.status_request = ntohs(*((u_int16_t*)&packet->payload[offset]));
        break;
      // Add more cases for other extension types as needed.
      default:
        break;
    }

    offset += extension_len;
    extensions_len -= extension_len + 4;
  }

  // Construct a JA3 string based on extracted details.
  ja3_str_len = snprintf(ja3_str, JA3_STR_LEN, "%04X,%04X,%04X", ja3.tls_handshake_version, ja3.server_cipher_suite, ja3.server_name);

  // Compute an MD5 hash of the JA3 string for both Client and Server handshakes to create a unique JA3 fingerprint.
  ndpi_MD5Init(&ctx);
  ndpi_MD5Update(&ctx, (const unsigned char*)ja3_str, ja3_str_len);
  ndpi_MD5Final(md5_hash, &ctx);

  // Store the computed JA3 hash in the flow structure for later analysis or comparison.
  memcpy(flow->ja3_hash, md5_hash, 16);

  return 1; // Server Hello processed successfully.
}