{
  u_int16_t cipher_suite_len, extension_offset;
  u_int8_t compression_method_len;

  offset += 1 + 2; // Skip handshake type and length
  offset += 2; // Skip version
  offset += 32; // Skip random
  offset += 1 + session_id_len; // Skip session ID length and session ID

  if (handshake_type == 0x01 /* Client Hello */) {
    cipher_suite_len = ntohs(*((u_int16_t*)&packet->payload[offset]));
    offset += 2 + cipher_suite_len; // Skip cipher suites

    compression_method_len = packet->payload[offset];
    offset += 1 + compression_method_len; // Skip compression methods

    if (offset + 2 <= total_len) {
      extension_len = ntohs(*((u_int16_t*)&packet->payload[offset]));
      offset += 2;

      snprintf(buffer, sizeof(buffer), "%u-", tls_version);
      ja3_str_len = strlen(buffer);

      for (j = 0; j < cipher_suite_len; j += 2) {
        u_int16_t cipher_suite = ntohs(*((u_int16_t*)&packet->payload[offset - cipher_suite_len + j]));
        if (cipher_suite != 0x0a0a && cipher_suite != 0x1a1a) { // Skip GREASE values
          int len = snprintf(ja3_str + ja3_str_len, sizeof(ja3_str) - ja3_str_len, "%s%u", (ja3_str_len > 0) ? "-" : "", cipher_suite);
          if (len < 0 || ja3_str_len + len >= sizeof(ja3_str)) {
            jainvalid = 1;
            break;
          }
          ja3_str_len += len;
        }
      }

      if (!jainvalid) {
        // Process extensions
        extension_offset = offset;
        while (extension_offset < offset + extension_len) {
          u_int16_t ext_type = ntohs(*((u_int16_t*)&packet->payload[extension_offset]));
          u_int16_t ext_len = ntohs(*((u_int16_t*)&packet->payload[extension_offset + 2]));
          extension_offset += 4 + ext_len;

          if (ext_type != 0x0a0a && ext_type != 0x1a1a) { // Skip GREASE values
            int len = snprintf(ja3_str + ja3_str_len, sizeof(ja3_str) - ja3_str_len, "%s%u", (ja3_str_len > 0) ? "-" : "", ext_type);
            if (len < 0 || ja3_str_len + len >= sizeof(ja3_str)) {
              jainvalid = 1;
              break;
            }
            ja3_str_len += len;
          }
        }
      }
    }
  } else if (handshake_type == 0x02 /* Server Hello */) {
    offset += 2; // Skip cipher suite
    offset += 1; // Skip compression method

    if (offset + 2 <= total_len) {
      extension_len = ntohs(*((u_int16_t*)&packet->payload[offset]));
      offset += 2;

      snprintf(buffer, sizeof(buffer), "%u-", tls_version);
      ja3_str_len = strlen(buffer);

      // Process extensions
      extension_offset = offset;
      while (extension_offset < offset + extension_len) {
        u_int16_t ext_type = ntohs(*((u_int16_t*)&packet->payload[extension_offset]));
        u_int16_t ext_len = ntohs(*((u_int16_t*)&packet->payload[extension_offset + 2]));
        extension_offset += 4 + ext_len;

        if (ext_type != 0x0a0a && ext_type != 0x1a1a) { // Skip GREASE values
          int len = snprintf(ja3_str + ja3_str_len, sizeof(ja3_str) - ja3_str_len, "%s%u", (ja3_str_len > 0) ? "-" : "", ext_type);
          if (len < 0 || ja3_str_len + len >= sizeof(ja3_str)) {
            jainvalid = 1;
            break;
          }
          ja3_str_len += len;
        }
      }
    }
  }

  if (!jainvalid) {
    ndpi_MD5_Init(&ctx);
    ndpi_MD5_Update(&ctx, (unsigned char*)ja3_str, ja3_str_len);
    ndpi_MD5_Final(md5_hash, &ctx);

    memcpy(flow->protos.stun_ssl.ssl.ja3_hash, md5_hash, sizeof(md5_hash));
    return (handshake_type == 0x01) ? 1 : 2; // 1 for Client Hello, 2 for Server Hello
  }
}