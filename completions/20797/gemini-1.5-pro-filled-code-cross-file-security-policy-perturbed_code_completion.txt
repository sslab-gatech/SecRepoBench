{
      u_int16_t cipher_offset = packet->tcp ? 44 + session_id_len : 52 + session_id_len;
      u_int16_t cipher_len = (packet->payload[cipher_offset] << 8) + packet->payload[cipher_offset + 1];

      ja3.cipher = ntohs(*((u_int16_t*)&packet->payload[cipher_offset + 2]));

      offset = cipher_offset + 4 + cipher_len;

      ja3_str_len = snprintf(ja3_str, JA3_STR_LEN, "%u,%u,", tls_version, ja3.cipher);
      if (ja3_str_len < 0 || ja3_str_len >= JA3_STR_LEN) {
        jainvalid = 1;
        goto end;
      }


      if (packet->payload_packet_len > offset + 1) {
          extension_len = (packet->payload[offset] << 8) + packet->payload[offset + 1];
          offset += 2;

          for (j = 0; j < extension_len;) {
              u_int16_t type = (packet->payload[offset + j] << 8) + packet->payload[offset + j + 1];
              u_int16_t len  = (packet->payload[offset + j + 2] << 8) + packet->payload[offset + j + 3];

              if ((offset + j + 4 + len) > packet->payload_packet_len) {
                  jainvalid = 1;
                  goto end;
              }

              j += 4 + len;
          }

          if (j != extension_len) {
              jainvalid = 1;
              goto end;
          }
      }
    } else {
      /* Client Hello */
      // ... (Implementation for Client Hello parsing)
    }

end:
    if (!jainvalid) {
      ndpi_MD5Init(&ctx);
      ndpi_MD5Update(&ctx, (const unsigned char *)ja3_str, ja3_str_len);
      ndpi_MD5Final(md5_hash, &ctx);

      for (i = 0; i < 16; i++) {
        snprintf(buffer, sizeof(buffer), "%02x", md5_hash[i]);
        // Check if snprintf output was truncated to prevent buffer overflow
        if (strlen(buffer) >= sizeof(buffer)) {
          jainvalid = 1;
          break;
        }
        strcat(flow->protos.stun_ssl.ssl.ja3, buffer);
      }
    }

    if (jainvalid) {
      return 0;
    }

    if (handshake_type == 0x01)
      return 1;
    else if (handshake_type == 0x02)
      return 2;
}