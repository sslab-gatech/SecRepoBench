{
      offset += session_id_len+1;

      if(handshake_type == 0x02) { /* Server Hello */
        u_int16_t cipher_suite = ntohs(*((u_int16_t*)&packet->payload[offset]));
        
        flow->protos.stun_ssl.ssl.server_cipher = cipher_suite;
        offset += 2;
      } else if(handshake_type == 0x01) { /* Client Hello */
        u_int16_t cipher_len = ntohs(*((u_int16_t*)&packet->payload[offset]));
        offset += 2 + cipher_len;

        u_int16_t compression_len = packet->payload[offset];
        offset += 1 + compression_len;

        u_int16_t extensions_len = ntohs(*((u_int16_t*)&packet->payload[offset]));
        offset += 2;

        if((extensions_len > 0) && (offset + extensions_len < total_len)) {
          u_int16_t extension_offset = 0;

          while(extension_offset < extensions_len) {
            u_int16_t extension_id, extension_len;

            extension_id = ntohs(*((u_int16_t*)&packet->payload[offset+extension_offset]));
            extension_offset += 2;

            extension_len = ntohs(*((u_int16_t*)&packet->payload[offset+extension_offset]));
            extension_offset += 2;

            if(extension_id == 0 || (extension_id >= 0x1000 && extension_id <= 0xFFFF))
              continue; /* Skip GREASE values */

            if(ja3.num_tls_extensions < MAX_NUM_JA3)
              ja3.tls_extensions[ja3.num_tls_extensions++] = extension_id;

            if(extension_id == 43) {
              u_int16_t supported_versions_offset = 0;
              while(supported_versions_offset < extension_len) {
                u_int16_t version = ntohs(*((u_int16_t*)&packet->payload[offset+extension_offset+supported_versions_offset]));
                supported_versions_offset += 2;
                if(version != 0x0304) /* Skip TLS 1.3 */
                  ja3.tls_handshake_version = version;
              }
            }

            extension_offset += extension_len;
          }
        }
      }

      ja3_str_len = snprintf(ja3_str, JA3_STR_LEN, "%u,", ja3.tls_handshake_version);

      for(i=0; i<ja3.num_cipher_suites; i++) {
        int rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, "%s%u", (i > 0) ? "-" : "", ja3.cipher_suites[i]);

        if(rc <= 0) break; else ja3_str_len += rc;
      }

      ja3_str_len += snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, ",");

      for(i=0; i<ja3.num_tls_extensions; i++) {
        int rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, "%s%u", (i > 0) ? "-" : "", ja3.tls_extensions[i]);

        if(rc <= 0) break; else ja3_str_len += rc;
      }

      ndpi_MD5Init(&ctx);
      ndpi_MD5Update(&ctx, (const unsigned char *)ja3_str, strlen(ja3_str));
      ndpi_MD5Final(md5_hash, &ctx);

      for(i=0; i<16; i++) {
        int rc = snprintf(&flow->protos.stun_ssl.ssl.ja3_client[i*2], 3, "%02x", md5_hash[i]);
        if(rc != 2) break;
      }

      flow->protos.stun_ssl.ssl.ja3_client[32] = '\0';

      if(handshake_type == 0x01) /* Client Hello */
        return 1;
      else if(handshake_type == 0x02) /* Server Hello */
        return 2;
    }