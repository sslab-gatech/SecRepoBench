if(handshake_type == 0x02 /* Server Hello */) {
  /* Parse the TLS handshake message from the packet to determine whether it is a Client Hello or Server Hello.
     Depending on the type of handshake message, extract relevant information such as cipher suites and TLS extensions.
     For a Server Hello, adjust offsets based on the session ID length and extract the server's cipher suite.
     For a Client Hello, parse the cipher suites and extensions, skipping GREASE values, and extract supported versions and other extension information.
     Construct a JA3 string based on extracted details, including TLS version, cipher suites, and extensions for fingerprinting purposes.
     Compute an MD5 hash of the JA3 string for both Client and Server handshakes to create a unique JA3 fingerprint.
     Store the computed JA3 hash in the flow structure for later analysis or comparison.
     Return a specific code to indicate the type of handshake processed, or zero if parsing was unsuccessful.
  */
  u_int16_t offset = 38, extension_len, j;
  u_int8_t  session_id_len =  packet->tcp? packet->payload[offset] : packet->payload[46];
  u_int16_t extension_offset = packet->tcp? 42 : 50;

  if(packet->tcp) {
    offset += 2 + session_id_len;
  } else {
    offset += 2;
  }

  if(packet->tcp) {
    extension_offset += 2 + session_id_len;
  } else {
    extension_offset += 2;
  }

  if(packet->tcp) {
    extension_len = packet->payload[offset];
  } else {
    extension_len = packet->payload[extension_offset];
  }

  if(extension_len > 0) {
    for(j = 0; j < extension_len; j++) {
      if(packet->tcp) {
        offset++;
      } else {
        extension_offset++;
      }

      if(packet->payload[offset] == 0x00) {
        break;
      }
    }
  }

  if(packet->tcp) {
    offset += 2;
  } else {
    extension_offset += 2;
  }

  if(packet->tcp) {
    tls_version = ntohs(*((u_int16_t*)&packet->payload[offset]));
  } else {
    tls_version = ntohs(*((u_int16_t*)&packet->payload[extension_offset]));
  }

  flow->protos.stun_ssl.ssl.ssl_version = ja3.tls_handshake_version = tls_version;

  if(packet->tcp) {
    offset += 2;
  } else {
    extension_offset += 2;
  }

  if(packet->tcp) {
    extension_len = packet->payload[offset];
  } else {
    extension_len = packet->payload[extension_offset];
  }

  if(extension_len > 0) {
    for(j = 0; j < extension_len; j++) {
      if(packet->tcp) {
        offset++;
      } else {
        extension_offset++;
      }

      if(packet->payload[offset] == 0x00) {
        break;
      }
    }
  }

  if(packet->tcp) {
    offset += 2;
  } else {
    extension_offset += 2;
  }

  if(packet->tcp) {
    extension_len = packet->payload[offset];
  } else {
    extension_len = packet->payload[extension_offset];
  }

  if(extension_len > 0) {
    for(j = 0; j < extension_len; j++) {
      if(packet->tcp) {
        offset++;
      } else {
        extension_offset++;
      }

      if(packet->payload[offset] == 0x00) {
        break;
      }
    }
  }

  if(packet->tcp) {
    offset += 2;
  } else {
    extension_offset += 2;
  }

  if(packet->tcp) {
    extension_len = packet->payload[offset];
  } else {
    extension_len = packet->payload[extension_offset];
  }

  if(extension_len > 0) {
    for(j = 0; j < extension_len; j++) {
      if(packet->tcp) {
        offset++;
      } else {
        extension_offset++;
      }

      if(packet->payload[offset] == 0x00) {
        break;
      }
    }
  }

  if(packet->tcp) {
    offset += 2;
  } else {
    extension_offset += 2;
  }

  if(packet->tcp) {
    extension_len = packet->payload[offset];
  } else {
    extension_len = packet->payload[extension_offset];
  }

  if(extension_len > 0) {
    for(j = 0; j < extension_len; j++) {
      if(packet->tcp) {
        offset++;
      } else {
        extension_offset++;
      }

      if(packet->payload[offset] == 0x00) {
        break;
      }
    }
  }

  if(packet->tcp) {
    offset += 2;
  } else {
    extension_offset += 2;
  }

  if(packet->tcp) {
    extension_len = packet->payload[offset];
  } else {
    extension_len = packet->payload[extension_offset];
  }

  if(extension_len > 0) {
    for(j = 0; j < extension_len; j++) {
      if(packet->tcp) {
        offset++;
      } else {
        extension_offset++;
      }

      if(packet->payload[offset] == 0x00) {
        break;
      }
    }
  }

  if(packet->tcp) {
    offset += 2;
  } else {
    extension_offset += 2;
  }

  if(packet->tcp) {
    extension_len = packet->payload[offset];
  } else {
    extension_len = packet->payload[extension_offset];
  }

  if(extension_len > 0) {
    for(j = 0; j < extension_len; j++) {
      if(packet->tcp) {
        offset++;
      } else {
        extension_offset++;
      }

      if(packet->payload[offset] == 0x00) {
        break;
      }
    }
  }

  if(packet->tcp) {
    offset += 2;
  } else {
    extension_offset += 2;
  }

  if(packet->tcp) {
    extension_len = packet->payload[offset];
  } else {
    extension_len = packet->payload[extension_offset];
  }

  if(extension_len > 0) {
    for(j = 0; j < extension_len; j++) {
      if(packet->tcp) {
        offset++;
      } else {
        extension_offset++;
      }

      if(packet->payload[offset] == 0x00) {
        break;
      }
    }
  }

  if(packet->tcp) {
    offset += 2;
  } else {
    extension_offset += 2;
  }

  if(packet->tcp) {
    extension_len = packet->payload[offset];
  } else {
    extension_len = packet->payload[extension_offset];
  }

  if(extension_len > 0) {
    for(j = 0; j < extension_len; j++) {
      if(packet->tcp) {
        offset++;
      } else {
        extension_offset++;
      }

      if(packet->payload[offset] == 0x00) {
        break;
      }
    }
  }

  if(packet->tcp) {
    offset += 2;
  } else {
    extension_offset += 2;
  }

  if(packet->tcp) {
    extension_len = packet->payload[offset];
  } else {
    extension_len = packet->payload[extension_offset];
  }

  if(extension_len > 0) {
    for(j = 0; j < extension_len; j++) {
      if(packet->tcp) {
        offset++;
      } else {
        extension_offset++;
      }

      if(packet->payload[offset] == 0x00) {
        break;
      }
    }
  }

  if(packet->tcp) {
    offset += 2;
  } else {
    extension_offset += 2;
  }

  if(packet->tcp) {
    extension_len = packet->payload[offset];
  } else {
    extension_len = packet->payload[extension_offset];
  }

  if(extension_len > 0) {
    for(j = 0; j < extension_len; j++) {
      if(packet->tcp) {
        offset++;
      } else {
        extension_offset++;
      }

      if(packet->payload[offset] == 0x00) {
        break;
      }
    }
  }

  if(packet->tcp) {
    offset += 2;
  } else {
    extension_offset += 2;
  }

  if(packet->tcp) {
    extension_len = packet->payload[offset];
  } else {
    extension_len = packet->payload[extension_offset];
  }

  if(extension_len > 0) {
    for(j = 0; j < extension_len; j++) {
      if(packet->tcp) {
        offset++;
      } else {
        extension_offset++;
      }

      if(packet->payload[offset] == 0x00) {
        break;
      }
    }
  }

  if(packet->tcp) {
    offset += 2;
  } else {
    extension_offset += 2;
  }

  if(packet->tcp) {
    extension_len = packet->payload[offset];
  } else {
    extension_len = packet->payload[extension_offset];
  }

  if(extension_len > 0) {
    for(j = 0; j < extension_len; j++) {
      if(packet->tcp) {
        offset++;
      } else {
        extension_offset++;
      }

      if(packet->payload[offset] == 0x00) {
        break;
      }
    }
  }

  if(packet->tcp) {
    offset += 2;
  } else {
    extension_offset += 2;
  }

  if(packet->tcp) {
    extension_len = packet->payload[offset];
  } else {
    extension_len = packet->payload[extension_offset];
  }

  if(extension_len > 0) {
    for(j = 0; j < extension_len; j++) {
      if(packet->tcp) {
        offset++;
      } else {
        extension_offset++;
      }

      if(packet->payload[offset] == 0x00) {
        break;
      }
    }
  }

  if(packet->tcp) {
    offset += 2;
  } else {
    extension_offset += 2;
  }

  if(packet->tcp) {
    extension_len = packet->payload[offset];
  } else {
    extension_len = packet->payload[extension_offset];
  }

  if(extension_len > 0) {
    for(j = 0; j < extension_len; j++) {
      if(packet->tcp) {
        offset++;
      } else {
        extension_offset++;
      }

      if(packet->payload[offset] == 0x00) {
        break;
      }
    }
  }

  if(packet->tcp) {
    offset += 2;
  } else {
    extension_offset += 2;
  }

  if(packet->tcp) {
    extension_len = packet->payload[offset];
  } else {
    extension_len = packet->payload[extension_offset];
  }

  if(extension_len > 0) {
    for(j = 0; j < extension_len; j++) {
      if(packet->tcp) {
        offset++;
      } else {
        extension_offset++;
      }

      if(packet->payload[offset] == 0x00) {
        break;
      }
    }
  }

  if(packet->tcp) {
    offset += 2;
  } else {
    extension_offset += 2;
  }

  if(packet->tcp) {
    extension_len = packet->payload[offset];
  } else {
    extension_len = packet->payload[extension_offset];
  }

  if(extension_len > 0) {
    for(j = 0; j < extension_len; j++) {
      if(packet->tcp) {
        offset++;
      } else {
        extension_offset++;
      }

      if(packet->payload[offset] == 0x00) {
        break;
      }
    }
  }

  if(packet->tcp) {
    offset += 2;
  } else {
    extension_offset += 2;
  }

  if(packet->tcp) {
    extension_len = packet->payload[offset];
  } else {
    extension_len = packet->payload[extension_offset];
  }

  if(extension_len > 0) {
    for(j = 0; j < extension_len; j++) {
      if(packet->tcp) {
        offset++;
      } else {
        extension_offset++;
      }

      if(packet->payload[offset] == 0x00) {
        break;
      }
    }
  }

  if(packet->tcp) {
    offset += 2;
  } else {
    extension_offset += 2;
  }

  if(packet->tcp) {
    extension_len = packet->payload[offset];
  } else {
    extension_len = packet->payload[extension_offset];
  }

  if(extension_len > 0) {
    for(j = 0; j < extension_len; j++) {
      if(packet->tcp) {
        offset++;
      } else {
        extension_offset++;
      }

      if(packet->payload[offset] == 0x00) {
        break;
      }
    }
  }

  if(packet->tcp) {
    offset += 2;
  } else {
    extension_offset += 2;
  }

  if(packet->tcp) {
    extension_len = packet->payload[offset];
  } else {
    extension_len = packet->payload[extension_offset];
  }

  if(extension_len > 0) {
    for(j = 0; j < extension_len; j++) {
      if(packet->tcp) {
        offset++;
      } else {
        extension_offset++;
      }

      if(packet->payload[offset] == 0x00) {
        break;
      }
    }
  }

  if(packet->tcp) {
    offset += 2;
  } else {
    extension_offset += 2;
  }

  if(packet->tcp) {
    extension_len = packet->payload[offset];
  } else {
    extension_len = packet->payload[extension_offset];
  }

  if(extension_len > 0) {
    for(j = 0; j < extension_len; j++) {
      if(packet->tcp) {
        offset++;
      } else {
        extension_offset++;
      }

      if(packet->payload[offset] == 0x00) {
        break;
      }
    }
  }

  if(packet->tcp) {
    offset += 2;
  } else {
    extension_offset += 2;
  }

  if(packet->tcp) {
    extensio