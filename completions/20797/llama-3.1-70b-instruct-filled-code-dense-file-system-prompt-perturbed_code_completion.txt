if(handshake_type == 0x02 /* Server Hello */) {
  offset += 2 + session_id_len + 2; /* Skip session id and cipher suite length */

  if(offset >= packet->payload_packet_len) {
    return(0); /* Not found */
  }

  ja3.tls_handshake_server_cipher_suite = ntohs(*((u_int16_t*)&packet->payload[offset]));

  offset += 2; /* Skip cipher suite */

  if(offset >= packet->payload_packet_len) {
    return(0); /* Not found */
  }

  extension_len = (packet->payload[offset] << 8) + packet->payload[offset+1];
  offset += 2; /* Skip extension length */

  if(offset + extension_len > packet->payload_packet_len) {
    return(0); /* Not found */
  }

  for(j = 0; j < extension_len; j++) {
    if(packet->payload[offset+j] == 0x00 /* Supported versions */) {
      ja3.tls_handshake_supported_version = packet->payload[offset+j+2];
      break;
    }
  }

  ja3_str_len = snprintf(ja3_str, JA3_STR_LEN, "%u,%u,", ja3.tls_handshake_version, ja3.tls_handshake_server_cipher_suite);
  ja3_str_len += snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN - ja3_str_len, "%u,", ja3.tls_handshake_supported_version);

  for(j = 0; j < extension_len; j++) {
    if(packet->payload[offset+j] == 0x00 /* Supported versions */) {
      j += 4; /* Skip supported versions extension */
    } else if(packet->payload[offset+j] == 0x10 /* Supported groups */) {
      j += 2; /* Skip supported groups extension length */
      while(j < offset + extension_len) {
	u_int16_t group_id = ntohs(*((u_int16_t*)&packet->payload[offset+j]));
	ja3_str_len += snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN - ja3_str_len, "%u,", group_id);
	j += 2; /* Skip group id */
      }
    } else if(packet->payload[offset+j] == 0x0d /* Signature algorithms */) {
      j += 2; /* Skip signature algorithms extension length */
      while(j < offset + extension_len) {
	u_int16_t sig_alg = ntohs(*((u_int16_t*)&packet->payload[offset+j]));
	ja3_str_len += snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN - ja3_str_len, "%u,", sig_alg);
	j += 2; /* Skip signature algorithm */
      }
    } else if(packet->payload[offset+j] == 0x33 /* Key share */) {
      j += 2; /* Skip key share extension length */
      while(j < offset + extension_len) {
	u_int16_t group_id = ntohs(*((u_int16_t*)&packet->payload[offset+j]));
	ja3_str_len += snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN - ja3_str_len, "%u,", group_id);
	j += 2; /* Skip group id */
      }
    } else {
      j += 2; /* Skip extension length */
    }
  }

  ja3_str[ja3_str_len-1] = '\0'; /* Remove trailing comma */

  ndpi_MD5Init(&ctx);
  ndpi_MD5Update(&ctx, (const unsigned char*)ja3_str, ja3_str_len);
  ndpi_MD5Final(md5_hash, &ctx);

  for(i = 0; i < 16; i++) {
    snprintf(&buffer[i*2], 3, "%02X", md5_hash[i]);
  }

  flow->protos.stun_ssl.ssl.ja3_hash = ndpi_strdup(buffer);
  flow->protos.stun_ssl.ssl.ja3_hash_len = strlen(buffer);

  return(1); /* Server Hello */
} else if(handshake_type == 0x01 /* Client Hello */) {
  offset += 34; /* Skip protocol version, random, and session id length */

  if(offset >= packet->payload_packet_len) {
    return(0); /* Not found */
  }

  extension_len = (packet->payload[offset] << 8) + packet->payload[offset+1];
  offset += 2; /* Skip extension length */

  if(offset + extension_len > packet->payload_packet_len) {
    return(0); /* Not found */
  }

  ja3.tls_handshake_supported_version = packet->payload[offset+1];

  ja3_str_len = snprintf(ja3_str, JA3_STR_LEN, "%u,", ja3.tls_handshake_version);
  ja3_str_len += snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN - ja3_str_len, "%u,", ja3.tls_handshake_supported_version);

  for(j = 0; j < extension_len; j++) {
    if(packet->payload[offset+j] == 0x00 /* Supported versions */) {
      j += 4; /* Skip supported versions extension */
    } else if(packet->payload[offset+j] == 0x10 /* Supported groups */) {
      j += 2; /* Skip supported groups extension length */
      while(j < offset + extension_len) {
	u_int16_t group_id = ntohs(*((u_int16_t*)&packet->payload[offset+j]));
	ja3_str_len += snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN - ja3_str_len, "%u,", group_id);
	j += 2; /* Skip group id */
      }
    } else if(packet->payload[offset+j] == 0x0d /* Signature algorithms */) {
      j += 2; /* Skip signature algorithms extension length */
      while(j < offset + extension_len) {
	u_int16_t sig_alg = ntohs(*((u_int16_t*)&packet->payload[offset+j]));
	ja3_str_len += snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN - ja3_str_len, "%u,", sig_alg);
	j += 2; /* Skip signature algorithm */
      }
    } else if(packet->payload[offset+j] == 0x33 /* Key share */) {
      j += 2; /* Skip key share extension length */
      while(j < offset + extension_len) {
	u_int16_t group_id = ntohs(*((u_int16_t*)&packet->payload[offset+j]));
	ja3_str_len += snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN - ja3_str_len, "%u,", group_id);
	j += 2; /* Skip group id */
      }
    } else {
      j += 2; /* Skip extension length */
    }
  }

  ja3_str[ja3_str_len-1] = '\0'; /* Remove trailing comma */

  ndpi_MD5Init(&ctx);
  ndpi_MD5Update(&ctx, (const unsigned char*)ja3_str, ja3_str_len);
  ndpi_MD5Final(md5_hash, &ctx);

  for(i = 0; i < 16; i++) {
    snprintf(&buffer[i*2], 3, "%02X", md5_hash[i]);
  }

  flow->protos.stun_ssl.ssl.ja3_hash = ndpi_strdup(buffer);
  flow->protos.stun_ssl.ssl.ja3_hash_len = strlen(buffer);

  return(2); /* Client Hello */
}