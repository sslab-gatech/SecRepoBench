{
      u_int16_t cipher_suite_len = packet->payload[offset + session_id_len + 1];
      u_int16_t cipher_offset = offset + session_id_len + 2 + cipher_suite_len;

      // Ensure we do not read beyond the payload length
      if (cipher_offset + 2 > total_len) {
        return 0; // Not enough data
      }

      // Extract cipher suites
      for (j = 0; j < cipher_suite_len / 2; j++) {
        ja3.cipher[j] = (packet->payload[cipher_offset + j * 2] << 8) | packet->payload[cipher_offset + j * 2 + 1];
      }
      ja3.num_cipher = cipher_suite_len / 2;

      // Extract extensions
      offset += session_id_len + 2 + cipher_suite_len;
      while (offset < total_len) {
        extension_len = (packet->payload[offset + 1] << 8) + packet->payload[offset + 2];

        if (offset + 3 + extension_len > total_len) {
          break; // Not enough data
        }

        ja3.tls_extension[ja3.num_tls_extension++] = (packet->payload[offset] << 8) | packet->payload[offset + 1];
        offset += 3 + extension_len;
      }

      // Create JA3 string
      ja3_str_len = snprintf(ja3_str, JA3_STR_LEN, "%u,", ja3.tls_handshake_version);
      for (i = 0; i < ja3.num_cipher; i++) {
        ja3_str_len += snprintf(ja3_str + ja3_str_len, JA3_STR_LEN - ja3_str_len, "%u,", ja3.cipher[i]);
      }
      for (i = 0; i < ja3.num_tls_extension; i++) {
        ja3_str_len += snprintf(ja3_str + ja3_str_len, JA3_STR_LEN - ja3_str_len, "%u,", ja3.tls_extension[i]);
      }

      // Hash the JA3 string
      md5_hash[0] = 0; // Initialize MD5 hash
      ndpi_MD5Init(&ctx);
      ndpi_MD5Update(&ctx, (u_char *)ja3_str, ja3_str_len);
      ndpi_MD5Final(md5_hash, &ctx);

      // Store the JA3 hash in the flow structure
      memcpy(flow->protos.stun_ssl.ssl.ja3_hash, md5_hash, sizeof(md5_hash));
      flow->protos.stun_ssl.ssl.ja3_hash_set = 1;

      return 1; // Successfully processed
    }