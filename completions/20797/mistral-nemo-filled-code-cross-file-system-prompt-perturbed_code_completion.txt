if(handshake_type == 0x02 /* Server Hello */) {
    u_int16_t cipher_suite_offset = offset + session_id_len + 2;
    u_int16_t cipher_suite_len = ntohs(*((u_int16_t*)&packet->payload[cipher_suite_offset]));
    u_int16_t extensions_offset = cipher_suite_offset + cipher_suite_len + 2;
    u_int16_t extensions_len = ntohs(*((u_int16_t*)&packet->payload[extensions_offset]));

    /* Extract the server's cipher suite */
    u_int16_t server_cipher_suite = ntohs(*((u_int16_t*)&packet->payload[cipher_suite_offset + 2]));

    /* Construct the JA3 string for the Server Hello */
    snprintf(ja3_str, JA3_STR_LEN, "TLS_%u|%u|%u", tls_version, server_cipher_suite, extensions_len);

    /* Compute the MD5 hash of the JA3 string for the Server Hello */
    ndpi_MD5_Init(&ctx);
    ndpi_MD5_Update(&ctx, ja3_str, strlen(ja3_str));
    ndpi_MD5_Final(md5_hash, &ctx);

    /* Store the computed JA3 hash in the flow structure */
    flow->protos.stun_ssl.ssl.ssl_ja3_hash = md5_hash;

    return(1); /* Server Hello processed */
  } else if(handshake_type == 0x01 /* Client Hello */) {
    u_int16_t cipher_suites_offset = offset + 4;
    u_int16_t cipher_suites_len = ntohs(*((u_int16_t*)&packet->payload[cipher_suites_offset]));
    u_int16_t extensions_offset = cipher_suites_offset + cipher_suites_len + 2;
    u_int16_t extensions_len = ntohs(*((u_int16_t*)&packet->payload[extensions_offset]));

    /* Parse the cipher suites and extensions, skipping GREASE values */
    u_int16_t *cipher_suites = (u_int16_t*)&packet->payload[cipher_suites_offset + 2];
    u_int16_t *extensions = (u_int16_t*)&packet->payload[extensions_offset + 2];
    u_int16_t num_cipher_suites = cipher_suites_len / 2;
    u_int16_t num_extensions = extensions_len / 2;

    /* Extract supported versions and other extension information */
    u_int16_t supported_versions = 0;
    u_int16_t supported_groups = 0;
    u_int16_t ec_point_formats = 0;
    u_int16_t signature_algorithms = 0;
    u_int16_t key_share = 0;
    u_int16_t pre_shared_key = 0;

    for(u_int16_t i = 0; i < num_cipher_suites; i++) {
      if(cipher_suites[i] != 0xffff) { /* Skip GREASE values */
	/* Extract cipher suite information */
	/* ... */
      }
    }

    for(u_int16_t i = 0; i < num_extensions; i++) {
      u_int16_t extension_type = extensions[i];
      u_int16_t extension_len = ntohs(*((u_int16_t*)&packet->payload[extensions_offset + i * 4 + 4]));

      switch(extension_type) {
	case 0x000a: /* Supported Groups */
	  supported_groups = ntohs(*((u_int16_t*)&packet->payload[extensions_offset + i * 4 + 6]));
	  break;
	case 0x000b: /* EC Point Formats */
	  ec_point_formats = ntohs(*((u_int16_t*)&packet->payload[extensions_offset + i * 4 + 6]));
	  break;
	case 0x000d: /* Signature Algorithms */
	  signature_algorithms = ntohs(*((u_int16_t*)&packet->payload[extensions_offset + i * 4 + 6]));
	  break;
	case 0x0010: /* Key Share */
	  key_share = ntohs(*((u_int16_t*)&packet->payload[extensions_offset + i * 4 + 6]));
	  break;
	case 0x0012: /* Pre-Shared Key */
	  pre_shared_key = ntohs(*((u_int16_t*)&packet->payload[extensions_offset + i * 4 + 6]));
	  break;
	/* ... */
      }
    }

    /* Construct the JA3 string for the Client Hello */
    snprintf(ja3_str, JA3_STR_LEN, "TLS_%u|%u|%u|%u|%u|%u|%u|%u|%u", tls_version, num_cipher_suites, supported_versions, supported_groups, ec_point_formats, signature_algorithms, key_share, pre_shared_key);

    /* Compute the MD5 hash of the JA3 string for the Client Hello */
    ndpi_MD5_Init(&ctx);
    ndpi_MD5_Update(&ctx, ja3_str, strlen(ja3_str));
    ndpi_MD5_Final(md5_hash, &ctx);

    /* Store the computed JA3 hash in the flow structure */
    flow->protos.stun_ssl.ssl.ssl_ja3_hash = md5_hash;

    return(2); /* Client Hello processed */
  }

  return(0); /* Unknown handshake type */
}