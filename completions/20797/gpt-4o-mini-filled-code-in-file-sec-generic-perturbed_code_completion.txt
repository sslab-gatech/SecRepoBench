{
      u_int16_t cipher_suite_offset = offset + 1 + session_id_len;
      u_int16_t cipher_suite_len = (packet->tcp ? 2 : 2);
      u_int16_t extension_offset = cipher_suite_offset + cipher_suite_len;

      // Extract cipher suites
      for (j = 0; j < cipher_suite_len / 2; j++) {
        ja3.cipher[ja3.num_cipher++] = ntohs(*((u_int16_t*)&packet->payload[cipher_suite_offset + j * 2]));
      }

      // Extract extensions
      while (extension_offset < total_len) {
        extension_len = (packet->payload[extension_offset + 1] << 8) + packet->payload[extension_offset + 2];
        ja3.tls_extension[ja3.num_tls_extension++] = ntohs(*((u_int16_t*)&packet->payload[extension_offset]));

        extension_offset += 2 + extension_len; // Move to the next extension
      }

      // Construct JA3 string
      ja3_str_len = snprintf(ja3_str, JA3_STR_LEN, "%u,", ja3.tls_handshake_version);
      for (i = 0; i < ja3.num_cipher; i++) {
        ja3_str_len += snprintf(ja3_str + ja3_str_len, JA3_STR_LEN - ja3_str_len, "%u,", ja3.cipher[i]);
      }
      for (i = 0; i < ja3.num_tls_extension; i++) {
        ja3_str_len += snprintf(ja3_str + ja3_str_len, JA3_STR_LEN - ja3_str_len, "%u,", ja3.tls_extension[i]);
      }

      // Remove the last comma
      if (ja3_str_len > 0) {
        ja3_str[ja3_str_len - 1] = '\0';
      }

      // Compute MD5 hash of the JA3 string
      ndpi_MD5Init(&ctx);
      ndpi_MD5Update(&ctx, (const u_char *)ja3_str, strlen(ja3_str));
      ndpi_MD5Final(md5_hash, &ctx);

      // Store the JA3 hash in the flow structure
      memcpy(flow->protos.stun_ssl.ssl.ja3_hash, md5_hash, sizeof(md5_hash));
      flow->protos.stun_ssl.ssl.ja3_hash_set = 1;

      return 1; // Indicate successful processing
    }