if(handshake_type == 0x01 /* Client Hello */) {
  /* Safely parse the Client Hello */
  u_int16_t offset = base_offset;
  u_int16_t ciphers_len, ex_len, ex_offset, curve_list_len, point_fmt_list_len;
  int str_pos = 0;

  /* Ensure there's room for random (32 bytes) plus session_id_len byte */
  if((offset + 33) > total_len) return(0);
  offset += 32; /* Skip random */

  /* Read session ID length again in case it wasn't set correctly above */
  session_id_len = packet->payload[offset++];
  if((offset + session_id_len + 2) > total_len) return(0);
  offset += session_id_len;

  /* Read Cipher Suites length */
  ciphers_len = (packet->payload[offset] << 8) + packet->payload[offset+1];
  offset += 2;
  if((offset + ciphers_len + 2) > total_len) return(0);

  /* Build partial JA3 string: version + ciphers */
  snprintf(ja3_str, sizeof(ja3_str), "%u,", ja3.tls_handshake_version);
  str_pos = strlen(ja3_str);

  /* Parse ciphers (skip GREASE) */
  {
    u_int16_t cpos = 0;
    while(cpos < ciphers_len && str_pos < (int)(sizeof(ja3_str) - 6)) {
      u_int16_t cipher_val = (packet->payload[offset + cpos] << 8) + packet->payload[offset + cpos + 1];
      cpos += 2;
      /* Skip known GREASE values (0x0A0A, 0x1A1A, 0x2A2A, etc.) */
      if((cipher_val & 0x0F0F) == 0x0A0A) continue;
      if(str_pos > 0 && ja3_str[str_pos-1] != ',') {
        ja3_str[str_pos++] = '-'; /* delimiter inside cipher list */
      }
      str_pos += snprintf(&ja3_str[str_pos], sizeof(ja3_str) - str_pos, "%u", cipher_val);
    }
    offset += ciphers_len;
  }

  /* Read Extensions length */
  ex_len = (packet->payload[offset] << 8) + packet->payload[offset+1];
  offset += 2;
  if((offset + ex_len) > total_len || str_pos >= (int)(sizeof(ja3_str) - 2)) return(0);
  ja3_str[str_pos++] = ',';

  /* Parse extensions (skip GREASE) */
  ex_offset = 0;
  while(ex_offset + 4 <= ex_len && str_pos < (int)(sizeof(ja3_str) - 6)) {
    u_int16_t ext_type = (packet->payload[offset + ex_offset] << 8) + packet->payload[offset + ex_offset + 1];
    u_int16_t ext_size = (packet->payload[offset + ex_offset + 2] << 8) + packet->payload[offset + ex_offset + 3];
    if((ex_offset + 4 + ext_size) > ex_len) break;

    /* Skip known GREASE extension types */
    if((ext_type & 0x0F0F) != 0x0A0A) {
      if(ja3_str[str_pos-1] != ',') ja3_str[str_pos++] = '-';
      str_pos += snprintf(&ja3_str[str_pos], sizeof(ja3_str) - str_pos, "%u", ext_type);
    }

    /* For elliptic_curves or ec_point_formats, build them into JA3 as well */
    if(ext_type == 10 && ext_size >= 2) {
      /* elliptic curves */
      curve_list_len = (packet->payload[offset + ex_offset + 4] << 8)
                       + packet->payload[offset + ex_offset + 5];
      /* We won't drill down further here, just note presence. */
    } else if(ext_type == 11 && ext_size >= 1) {
      /* ec_point_formats */
      point_fmt_list_len = packet->payload[offset + ex_offset + 4];
      /* We won't drill down further here, just note presence. */
    }

    ex_offset += (4 + ext_size);
  }
  offset += ex_len;

  /* Null-terminate JA3 string safely */
  if(str_pos >= (int)sizeof(ja3_str)) str_pos = (int)sizeof(ja3_str) - 1;
  ja3_str[str_pos] = '\0';

  /* Compute MD5 of JA3 */
  ndpi_MD5_Init(&ctx);
  ndpi_MD5_Update(&ctx, (unsigned char*)ja3_str, (unsigned int)strlen(ja3_str));
  ndpi_MD5_Final(md5_hash, &ctx);

  /* Copy fingerprint to flow structure */
  memcpy(flow->protos.stun_ssl.ssl.ja3_hash, md5_hash, 16);

  return(1);

} else if(handshake_type == 0x02 /* Server Hello */) {
  /* Safely parse the Server Hello */
  u_int16_t offset = base_offset;
  u_int16_t ex_len, ex_offset;
  int str_pos = 0;

  /* Skip random (32 bytes), check bounds */
  if((offset + 33) > total_len) return(0);
  offset += 32; /* skip random */

  /* Re-check session_id_len in case not aligned */
  session_id_len = packet->payload[offset++];
  if((offset + session_id_len + 3) > total_len) return(0);
  offset += session_id_len;

  /* Parse server cipher suite */
  {
    u_int16_t srv_cipher;
    srv_cipher = (packet->payload[offset] << 8) + packet->payload[offset+1];
    offset += 2;
    if(offset + 1 > total_len) return(0); /* compression */
    offset++;

    /* Build JA3 string with version + cipher */
    snprintf(ja3_str, sizeof(ja3_str), "%u,%u", ja3.tls_handshake_version, srv_cipher);
    str_pos = strlen(ja3_str);
  }

  /* Parse extensions */
  if((offset + 2) > total_len) return(0);
  ex_len = (packet->payload[offset] << 8) + packet->payload[offset+1];
  offset += 2;
  if((offset + ex_len) > total_len || str_pos >= (int)(sizeof(ja3_str) - 2)) return(0);

  ja3_str[str_pos++] = ',';
  ex_offset = 0;
  while(ex_offset + 4 <= ex_len && str_pos < (int)(sizeof(ja3_str) - 6)) {
    u_int16_t ext_type = (packet->payload[offset + ex_offset] << 8) + packet->payload[offset + ex_offset + 1];
    u_int16_t ext_size = (packet->payload[offset + ex_offset + 2] << 8) + packet->payload[offset + ex_offset + 3];
    if((ex_offset + 4 + ext_size) > ex_len) break;
    /* Skip GREASE */
    if((ext_type & 0x0F0F) != 0x0A0A) {
      if(ja3_str[str_pos-1] != ',') ja3_str[str_pos++] = '-';
      str_pos += snprintf(&ja3_str[str_pos], sizeof(ja3_str) - str_pos, "%u", ext_type);
    }
    ex_offset += (4 + ext_size);
  }
  offset += ex_len;

  /* Null-terminate JA3 string safely */
  if(str_pos >= (int)sizeof(ja3_str)) str_pos = (int)sizeof(ja3_str) - 1;
  ja3_str[str_pos] = '\0';

  /* Compute MD5 of JA3 */
  ndpi_MD5_Init(&ctx);
  ndpi_MD5_Update(&ctx, (unsigned char*)ja3_str, (unsigned int)strlen(ja3_str));
  ndpi_MD5_Final(md5_hash, &ctx);

  /* Copy fingerprint to flow structure */
  memcpy(flow->protos.stun_ssl.ssl.ja3_hash, md5_hash, 16);

  return(2);

} else {
  /* Unknown handshake type */
  return(0);
}