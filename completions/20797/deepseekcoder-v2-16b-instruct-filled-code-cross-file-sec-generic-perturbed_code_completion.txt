if (handshake_type == 0x02 /* Server Hello */) {
        u_int16_t session_id_len = packet->tcp ? packet->payload[offset] : packet->payload[46];
        offset += session_id_len + 4; // Skip session ID and cipher suites

        // Extract extensions
        while (offset < packet->payload_packet_len) {
            u_int16_t extension_type = ntohs(*((u_int16_t*)&packet->payload[offset]));
            u_int16_t extension_length = ntohs(*((u_int16_t*)&packet->payload[offset + 2]));
            offset += 4; // Skip extension type and length

            if (extension_type == 0x0000 || extension_type == 0x0001) {
                // Skip unsupported extensions
                offset += extension_length;
                continue;
            }

            // Extract extension information
            // This is a simplified example, actual extraction logic may vary
            if (extension_type == 0x0002) { // Supported Versions
                // Extract supported TLS versions
                u_int16_t supported_versions = ntohs(*((u_int16_t*)&packet->payload[offset]));
                ja3.supported_versions = supported_versions;
                offset += 2;
            } else if (extension_type == 0x000d) { // Renegotiation Info
                // Extract renegotiation info
                // This is a simplified example, actual extraction logic may vary
                ja3.renegotiation_info = 1;
            }

            offset += extension_length;
        }

        // Construct JA3 string
        snprintf(ja3_str, JA3_STR_LEN, "TLSv%u", ja3.tls_handshake_version);
        ja3_str_len = strlen(ja3_str);

        // Compute MD5 hash of JA3 string
        memset(&ctx, 0, sizeof(ctx));
        MD5Init(&ctx);
        MD5Update(&ctx, (u_char*)ja3_str, ja3_str_len);
        MD5Final(md5_hash, &ctx);

        // Store JA3 hash in flow structure
        memcpy(flow->l4.tcp.tls.ja3_fingerprint, md5_hash, 16);

        // Return specific code to indicate Server Hello processed
        return 1;
    }