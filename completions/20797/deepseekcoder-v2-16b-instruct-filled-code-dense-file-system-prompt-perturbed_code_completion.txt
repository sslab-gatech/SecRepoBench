if(handshake_type == 0x02 /* Server Hello */) {
      // Parse the TLS handshake message from the packet to determine whether it is a Client Hello or Server Hello.
      // Depending on the type of handshake message, extract relevant information such as cipher suites and TLS extensions.
      // For a Server Hello, adjust offsets based on the session ID length and extract the server's cipher suite.
      // For a Client Hello, parse the cipher suites and extensions, skipping GREASE values, and extract supported versions and other extension information.
      // Construct a JA3 string based on extracted details, including TLS version, cipher suites, and extensions for fingerprinting purposes.
      // Compute an MD5 hash of the JA3 string for both Client and Server handshakes to create a unique JA3 fingerprint.
      // Store the computed JA3 hash in the flow structure for later analysis or comparison.
      // Return a specific code to indicate the type of handshake processed, or zero if parsing was unsuccessful.

      // Extract cipher suites and TLS extensions
      u_int16_t cipher_suites_offset = packet->tcp ? 4 : 12;
      u_int16_t extensions_offset = packet->tcp ? 4 : 12;
      u_int16_t cipher_suites_len = packet->tcp ? packet->payload[cipher_suites_offset] : packet->payload[46];
      u_int16_t extensions_len = packet->tcp ? packet->payload[extensions_offset] : packet->payload[46];

      // Extract cipher suites
      for (i = 0; i < cipher_suites_len; i++) {
        ja3.cipher_suites[i] = ntohs(*((u_int16_t*)&packet->payload[cipher_suites_offset + i * 2]));
      }

      // Extract extensions
      for (i = 0; i < extensions_len; i++) {
        u_int16_t extension_type = ntohs(*((u_int16_t*)&packet->payload[extensions_offset + i * 4]));
        u_int16_t extension_len = ntohs(*((u_int16_t*)&packet->payload[extensions_offset + i * 4 + 2]));

        // Store extension type and length
        ja3.extensions[extension_type] = extension_len;

        // Extract extension data
        if (extension_type == 0x000a) { // Server Name Indication
          u_int8_t server_name_len = packet->payload[extensions_offset + i * 4 + 4];
          char server_name[256];
          strncpy(server_name, (char*)&packet->payload[extensions_offset + i * 4 + 5], server_name_len);
          server_name[server_name_len] = '\0';
          strncpy(ja3.server_name, server_name, sizeof(ja3.server_name) - 1);
        }
      }

      // Construct JA3 string
      snprintf(ja3_str, JA3_STR_LEN, "TLSv%u", tls_version);
      for (i = 0; i < cipher_suites_len; i++) {
        snprintf(ja3_str, JA3_STR_LEN, "%s%04X", ja3_str, ja3.cipher_suites[i]);
      }
      for (i = 0; i < sizeof(ja3.extensions) / sizeof(ja3.extensions[0]); i++) {
        if (ja3.extensions[i] != 0) {
          snprintf(ja3_str, JA3_STR_LEN, "%s%04X%04X", ja3_str, i, ja3.extensions[i]);
        }
      }

      // Compute MD5 hash of JA3 string
      memset(&ctx, 0, sizeof(ctx));
      MD5Init(&ctx);
      MD5Update(&ctx, (u_char*)ja3_str, strlen(ja3_str));
      MD5Final(md5_hash, &ctx);

      // Store JA3 hash in flow structure
      for (i = 0; i < 16; i++) {
        flow->protos.stun_ssl.ssl.ja3_hash[i] = md5_hash[i];
      }

      // Return specific code to indicate Server Hello processed
      return 1;
    }