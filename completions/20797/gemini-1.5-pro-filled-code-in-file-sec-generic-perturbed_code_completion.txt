{
	  offset += session_id_len + 2 + 2; /* cipher + compression method */

	  if(offset+2 > total_len) { jainvalid = 1; goto ja3_end; }

	  extension_len = ntohs(*((u_int16_t*)&packet->payload[offset]));

	  offset += 2;

	  if((offset+extension_len) > total_len) { jainvalid = 1; goto ja3_end; }

	  for(j=0; j<extension_len;) {
	    u_int16_t type = ntohs(*((u_int16_t*)&packet->payload[offset+j]));
	    u_int16_t len  = ntohs(*((u_int16_t*)&packet->payload[offset+j+2]));

	    if(type != 0x0a /* Supported Groups */) {
	      if(ja3.num_tls_extension < MAX_NUM_JA3)
		ja3.tls_extension[ja3.num_tls_extension++] = type;
	    } else {
	      u_int k=0;
	      for(k=0; k<len; k+=2) {
		u_int16_t curve = ntohs(*((u_int16_t*)&packet->payload[offset+j+4+k]));
		if(ja3.num_elliptic_curve < MAX_NUM_JA3)
		  ja3.elliptic_curve[ja3.num_elliptic_curve++] = curve;
	      }

	      if((offset+j+4+len+2) <= total_len) {
		u_int8_t point_format_len = packet->payload[offset+j+4+len];

		for(k=0; k<point_format_len; k++) {
		  if(ja3.num_elliptic_curve_point_format < MAX_NUM_JA3)
		    ja3.elliptic_curve_point_format[ja3.num_elliptic_curve_point_format++] = packet->payload[offset+j+4+len+1+k];
		}
	      }
	    }

	    j += 4+len;
	  }

	  ja3.cipher[ja3.num_cipher++] = ntohs(*((u_int16_t*)&packet->payload[base_offset]));
	} else {
	  u_int16_t cipher_len = ntohs(*((u_int16_t*)&packet->payload[offset]));
	  offset += 2;

	  if((offset+cipher_len) > total_len) { jainvalid = 1; goto ja3_end; }

	  for(i=0; i<cipher_len; i+=2) {
	    u_int16_t cipher = ntohs(*((u_int16_t*)&packet->payload[offset+i]));

	    /* Skip GREASE values (https://tools.ietf.org/html/draft-davidben-tls-grease-01) */
	    if(((cipher & 0x0f0f) == 0x0a0a) && ((cipher >> 8) == (cipher & 0xff)))
	      continue;

	    if(ja3.num_cipher < MAX_NUM_JA3)
	      ja3.cipher[ja3.num_cipher++] = cipher;
	  }

	  offset += cipher_len + 1; /* compression method */

	  if(offset+2 > total_len) { jainvalid = 1; goto ja3_end; }

	  extension_len = ntohs(*((u_int16_t*)&packet->payload[offset]));
	  offset += 2;

	  if((offset+extension_len) > total_len) { jainvalid = 1; goto ja3_end; }

	  for(i=0; i<extension_len;) {
	    u_int16_t type = ntohs(*((u_int16_t*)&packet->payload[offset+i]));
	    u_int16_t len  = ntohs(*((u_int16_t*)&packet->payload[offset+i+2]));

	    /* Skip GREASE values */
	    if(((type & 0x0f0f) == 0x0a0a) && ((type >> 8) == (type & 0xff))) {
	      i += 4+len;
	      continue;
	    }

	    if(type != 0x0a /* Supported Groups */) {
	      if(ja3.num_tls_extension < MAX_NUM_JA3)
		ja3.tls_extension[ja3.num_tls_extension++] = type;
	    } else {
	      for(j=0; j<len; j+=2) {
		u_int16_t curve = ntohs(*((u_int16_t*)&packet->payload[offset+i+4+j]));

		/* Skip GREASE values */
		if(((curve & 0x0f0f) == 0x0a0a) && ((curve >> 8) == (curve & 0xff)))
		  continue;

		if(ja3.num_elliptic_curve < MAX_NUM_JA3)
		  ja3.elliptic_curve[ja3.num_elliptic_curve++] = curve;
	      }

	      if((offset+i+4+len+2) <= total_len) {
		u_int8_t point_format_len = packet->payload[offset+i+4+len];

		for(j=0; j<point_format_len; j++) {
		  if(ja3.num_elliptic_curve_point_format < MAX_NUM_JA3)
		    ja3.elliptic_curve_point_format[ja3.num_elliptic_curve_point_format++] = packet->payload[offset+i+4+len+1+j];
		}
	      }
	    }

	    if(type == 0x33) { /* Supported Versions */
	      u_int k;
	      for(k=0; k<len; k+=2) {
		u_int16_t version = ntohs(*((u_int16_t*)&packet->payload[offset+i+4+k]));
		if(version > flow->protos.stun_ssl.ssl.ssl_version)
		  flow->protos.stun_ssl.ssl.ssl_version = version;
	      }
	    } else if(type == 0xff01) { /* Record Size Limit */
	      flow->protos.stun_ssl.ssl.record_size_limit = ntohs(*((u_int16_t*)&packet->payload[offset+i+4]));
	    }

	    i += 4+len;
	  }
	}
      }

    ja3_end:

      if(!jainvalid) {
	ja3_str_len = snprintf(ja3_str, JA3_STR_LEN, "%u,%u",
			       ja3.tls_handshake_version, ja3.num_cipher);

	for(i=0; i<ja3.num_cipher; i++)
	  ja3_str_len += snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN - ja3_str_len, "%s%u",
				 (i > 0) ? "-" : "", ja3.cipher[i]);

	ja3_str_len += snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN - ja3_str_len, ",%u", ja3.num_tls_extension);

	for(i=0; i<ja3.num_tls_extension; i++)
	  ja3_str_len += snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN - ja3_str_len, "%s%u",
				 (i > 0) ? "-" : "", ja3.tls_extension[i]);

	ja3_str_len += snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN - ja3_str_len, ",%u", ja3.num_elliptic_curve);

	for(i=0; i<ja3.num_elliptic_curve; i++)
	  ja3_str_len += snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN - ja3_str_len, "%s%u",
				 (i > 0) ? "-" : "", ja3.elliptic_curve[i]);

	ja3_str_len += snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN - ja3_str_len, ",%u", ja3.num_elliptic_curve_point_format);

	for(i=0; i<ja3.num_elliptic_curve_point_format; i++)
	  ja3_str_len += snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN - ja3_str_len, "%s%u",
				 (i > 0) ? "-" : "", ja3.elliptic_curve_point_format[i]);


	ndpi_MD5Init(&ctx);
	ndpi_MD5Update(&ctx, ja3_str, ja3_str_len);
	ndpi_MD5Final(md5_hash, &ctx);

	for(i=0; i<16; i++)
	  snprintf(&buffer[i*2], sizeof(buffer)-i*2, "%02x", (unsigned char)md5_hash[i]);

	if(handshake_type == 0x01)
	  snprintf(flow->protos.stun_ssl.ssl.ja3_client_fingerprint,
		   sizeof(flow->protos.stun_ssl.ssl.ja3_client_fingerprint), "%s", buffer);
	else
	  snprintf(flow->protos.stun_ssl.ssl.ja3_server_fingerprint,
		   sizeof(flow->protos.stun_ssl.ssl.ja3_server_fingerprint), "%s", buffer);

#ifdef DEBUG_TLS
	printf("JA3 %s fingerprint: %s\n",
	       (handshake_type == 0x01) ? "client" : "server", buffer);
#endif