offset += session_id_len + 4;
    ja3_str_len = snprintf(ja3_str, JA3_STR_LEN, "%u", tls_version);
    if (ja3_str_len >= JA3_STR_LEN) {
        return 0; // Handle potential overflow
    }

    for (j = 0; j < 2; j++) {
      u_int16_t cipher_suite = ntohs(*((u_int16_t*)&packet->payload[offset]));
      ja3_str_len += snprintf(ja3_str + ja3_str_len, JA3_STR_LEN - ja3_str_len, "-%u", cipher_suite);
      if (ja3_str_len >= JA3_STR_LEN) {
          return 0; // Handle potential overflow
      }
      offset += 2;
    }

    extension_len = ntohs(*((u_int16_t*)&packet->payload[offset]));
    offset += 2;

    for (j = 0; j < extension_len; j += 4) {
      u_int16_t extension_type = ntohs(*((u_int16_t*)&packet->payload[offset]));
      u_int16_t extension_data_len = ntohs(*((u_int16_t*)&packet->payload[offset + 2]));
      ja3_str_len += snprintf(ja3_str + ja3_str_len, JA3_STR_LEN - ja3_str_len, "-%u-%u", extension_type, extension_data_len);
      if (ja3_str_len >= JA3_STR_LEN) {
          return 0; // Handle potential overflow
      }
      offset += 4 + extension_data_len;
    }

    ndpi_MD5Init(&ctx);
    ndpi_MD5Update(&ctx, ja3_str, strlen(ja3_str));
    ndpi_MD5Final(md5_hash, &ctx);

    for (i = 0; i < 16; i++) {
      snprintf(buffer, sizeof(buffer), "%02X", md5_hash[i]);
      if (strlen(buffer) >= sizeof(buffer)) {
          return 0; // Handle potential overflow
      }
      strcat(flow->ja3_hash, buffer);
    }

    flow->ja3_hash_len = strlen(flow->ja3_hash);
    return(1);