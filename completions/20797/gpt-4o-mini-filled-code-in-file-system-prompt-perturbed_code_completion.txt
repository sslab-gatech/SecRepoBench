{
      u_int16_t cipher_suite_offset = base_offset + 1 + session_id_len;
      u_int16_t num_ciphers = (packet->tcp ? (packet->payload[cipher_suite_offset - 1] - 1) : (packet->payload[cipher_suite_offset - 1]));
      u_int16_t cipher_offset = cipher_suite_offset + 2; // Skip the length field

      for (j = 0; j < num_ciphers; j++) {
        ja3.cipher[j] = (packet->payload[cipher_offset] << 8) | packet->payload[cipher_offset + 1];
        cipher_offset += 2;
      }
      ja3.num_cipher = num_ciphers;

      // Parse extensions
      u_int16_t extension_offset = cipher_offset;
      while (extension_offset < total_len) {
        extension_len = (packet->payload[extension_offset + 1] << 8) + packet->payload[extension_offset + 2];
        ja3.tls_extension[ja3.num_tls_extension++] = (packet->payload[extension_offset] << 8) | packet->payload[extension_offset + 1];
        extension_offset += 2 + extension_len; // Move to the next extension
      }

      // Construct JA3 string
      ja3_str_len = snprintf(ja3_str, JA3_STR_LEN, "%u,", ja3.tls_handshake_version);
      for (i = 0; i < ja3.num_cipher; i++) {
        ja3_str_len += snprintf(ja3_str + ja3_str_len, JA3_STR_LEN - ja3_str_len, "%u,", ja3.cipher[i]);
      }
      for (i = 0; i < ja3.num_tls_extension; i++) {
        ja3_str_len += snprintf(ja3_str + ja3_str_len, JA3_STR_LEN - ja3_str_len, "%u,", ja3.tls_extension[i]);
      }

      // Remove the last comma
      if (ja3_str_len > 0) {
        ja3_str[ja3_str_len - 1] = '\0';
      }

      // Compute MD5 hash of the JA3 string
      ndpi_MD5Init(&ctx);
      ndpi_MD5Update(&ctx, (u_char *)ja3_str, strlen(ja3_str));
      ndpi_MD5Final(md5_hash, &ctx);

      // Store the JA3 hash in the flow structure
      memcpy(flow->protos.stun_ssl.ssl.ja3_hash, md5_hash, sizeof(md5_hash));
      flow->protos.stun_ssl.ssl.ja3_hash_set = 1;

      return 1; // Indicate successful processing
    }