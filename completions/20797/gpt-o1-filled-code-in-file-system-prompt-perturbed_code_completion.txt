if(handshake_type == 0x01 /* Client Hello */) {
      /*
       * Parse Client Hello
       * ------------------
       *  1. Skip past the random bytes (32) and session ID length+data.
       *  2. Read cipher_suites length, parse ciphers (skip GREASE).
       *  3. Read compression length, skip compression methods.
       *  4. Read extensions length, parse extensions (skip GREASE),
       *     including supported_versions, elliptic_curves, and point_formats.
       *  5. Build a JA3 string from TLS version, cipher_suites, extensions,
       *     elliptic_curves, and point_formats.
       *  6. MD5-hash the JA3 string and store it.
       */
      offset += 1 /* skip session_id_len */ + session_id_len; 
      /* Read cipher_suites */
      {
        u_int16_t cs_len = (packet->payload[offset] << 8) + packet->payload[offset+1];
        offset += 2;
        for(j=0; j<cs_len; j+=2) {
          u_int16_t cs = (packet->payload[offset] << 8) + packet->payload[offset+1];
          offset += 2;
          /* Skip GREASE values 0x0a0a, 0x1a1a, etc. */
          if((cs & 0x0f0f) == 0x0a0a) continue;
          if(ja3.num_cipher < MAX_NUM_JA3) ja3.cipher[ja3.num_cipher++] = cs;
        }
      }
      /* Skip compression methods */
      {
        u_int8_t comp_len = packet->payload[offset];
        offset += (1 + comp_len);
      }
      /* Read and parse extensions */
      if((offset+2) <= total_len) {
        extension_len = (packet->payload[offset] << 8) + packet->payload[offset+1];
        offset += 2;
        while((extension_len >= 4) && ((offset+4) <= total_len)) {
          u_int16_t ext_type = (packet->payload[offset]   << 8) + packet->payload[offset+1];
          u_int16_t ext_size = (packet->payload[offset+2] << 8) + packet->payload[offset+3];
          offset += 4;
          extension_len -= 4;
          if((offset+ext_size) > total_len) break; /* truncated */
          if((ext_type & 0x0f0f) == 0x0a0a) {
            /* Skip GREASE extension */
            offset += ext_size;
            extension_len -= ext_size;
            continue;
          }
          /* Collect the extension ID for JA3 */
          if(ja3.num_tls_extension < MAX_NUM_JA3) {
            ja3.tls_extension[ja3.num_tls_extension++] = ext_type;
          }
          /* If this is the supported_groups extension (0x000a), parse curves. */
          if(ext_type == 0x000a && ext_size >= 6) {
            u_int16_t ec_list_len = (packet->payload[offset+2] << 8) + packet->payload[offset+3];
            u_int16_t ec_off = offset + 4, ec_parsed = 0;
            while(ec_parsed+1 < ec_list_len && (ec_off+1) < (offset+ext_size)) {
              u_int16_t curve = (packet->payload[ec_off] << 8) + packet->payload[ec_off+1];
              /* Skip GREASE curve */
              if((curve & 0x0f0f) != 0x0a0a && ja3.num_elliptic_curve < MAX_NUM_JA3) {
                ja3.elliptic_curve[ja3.num_elliptic_curve++] = curve;
              }
              ec_off   += 2;
              ec_parsed += 2;
            }
          }
          /* If this is the ec_point_formats extension (0x000b), parse point formats. */
          else if(ext_type == 0x000b && ext_size >= 2) {
            u_int8_t ecpf_len = packet->payload[offset+1];
            u_int8_t ecpf_off = offset + 2, k;
            for(k=0; k<ecpf_len && (ecpf_off < offset+ext_size); k++) {
              u_int8_t pf = packet->payload[ecpf_off++];
              ja3.elliptic_curve_point_format[ja3.num_elliptic_curve_point_format++] = pf;
            }
          }
          offset += ext_size;
          extension_len -= ext_size;
        }
      }
      /* Build JA3 string (e.g. version,ciphers,extensions,elliptic_curves,point_formats) */
      ja3_str_len = snprintf(ja3_str, sizeof(ja3_str), "%u,", ja3.tls_handshake_version);
      /* Append all cipher IDs */
      for(i=0; i<ja3.num_cipher && ja3_str_len < (JA3_STR_LEN-6); i++) {
        ja3_str_len += snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len,
                                (i==0)?"%u":"-%u", ja3.cipher[i]);
      }
      ja3_str_len += snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, ",");
      /* Append all extensions */
      for(i=0; i<ja3.num_tls_extension && ja3_str_len < (JA3_STR_LEN-6); i++) {
        ja3_str_len += snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len,
                                (i==0)?"%u":"-%u", ja3.tls_extension[i]);
      }
      ja3_str_len += snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, ",");
      /* Append all elliptic_curves */
      for(i=0; i<ja3.num_elliptic_curve && ja3_str_len < (JA3_STR_LEN-6); i++) {
        ja3_str_len += snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len,
                                (i==0)?"%u":"-%u", ja3.elliptic_curve[i]);
      }
      ja3_str_len += snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, ",");
      /* Append point_formats */
      for(i=0; i<ja3.num_elliptic_curve_point_format && ja3_str_len < (JA3_STR_LEN-6); i++) {
        ja3_str_len += snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len,
                                (i==0)?"%u":"-%u", ja3.elliptic_curve_point_format[i]);
      }
      ndpi_MD5_Init(&ctx);
      ndpi_MD5_Update(&ctx, (unsigned char*)ja3_str, ja3_str_len);
      ndpi_MD5_Final(md5_hash, &ctx);
      /* Store MD5 of ClientHello JA3 (example) */
      memcpy(flow->protos.stun_ssl.ssl.client_ja3_hash, md5_hash, sizeof(md5_hash));
      return(1);

    } else if(handshake_type == 0x02 /* Server Hello */) {
      /*
       * Parse Server Hello
       * ------------------
       *  1. Skip past the random bytes (32) and session ID length+data.
       *  2. Read server's cipher_suite (skip GREASE).
       *  3. Read compression method.
       *  4. Read and parse extensions (skip GREASE).
       *  5. Build a JA3S string from TLS version, cipher_suite, extensions.
       *  6. MD5-hash the JA3S string and store it.
       */
      offset += 1 /* skip session_id_len */ + session_id_len;
      if((offset+2) <= total_len) {
        /* Server cipher suite */
        u_int16_t scs = (packet->payload[offset] << 8) + packet->payload[offset+1];
        offset += 2;
        if((scs & 0x0f0f) != 0x0a0a && ja3.num_cipher < MAX_NUM_JA3) {
          ja3.cipher[ja3.num_cipher++] = scs;
        }
      }
      if((offset+1) <= total_len) {
        /* Compression */
        offset += 1;
      }
      /* Read and parse extensions for ServerHello */
      if((offset+2) <= total_len) {
        extension_len = (packet->payload[offset] << 8) + packet->payload[offset+1];
        offset += 2;
        while((extension_len >= 4) && ((offset+4) <= total_len)) {
          u_int16_t ext_type = (packet->payload[offset]   << 8) + packet->payload[offset+1];
          u_int16_t ext_size = (packet->payload[offset+2] << 8) + packet->payload[offset+3];
          offset += 4;
          extension_len -= 4;
          if((offset+ext_size) > total_len) break; /* truncated */
          if((ext_type & 0x0f0f) == 0x0a0a) {
            /* Skip GREASE extension */
            offset += ext_size;
            extension_len -= ext_size;
            continue;
          }
          /* Collect ext_type for JA3S */
          if(ja3.num_tls_extension < MAX_NUM_JA3) {
            ja3.tls_extension[ja3.num_tls_extension++] = ext_type;
          }
          offset += ext_size;
          extension_len -= ext_size;
        }
      }
      /* Build JA3S string (version,cipher,extensions) */
      ja3_str_len = snprintf(ja3_str, sizeof(ja3_str), "%u,", ja3.tls_handshake_version);
      /* There's only one cipher in normal ServerHello, so just append if present */
      if(ja3.num_cipher > 0) {
        ja3_str_len += snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, "%u,", ja3.cipher[0]);
      } else {
        ja3_str_len += snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, ",");
      }
      /* Append all extensions */
      for(i=0; i<ja3.num_tls_extension && ja3_str_len < (JA3_STR_LEN-6); i++) {
        ja3_str_len += snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len,
                                (i==0)?"%u":"-%u", ja3.tls_extension[i]);
      }
      ndpi_MD5_Init(&ctx);
      ndpi_MD5_Update(&ctx, (unsigned char*)ja3_str, ja3_str_len);
      ndpi_MD5_Final(md5_hash, &ctx);
      /* Store MD5 of ServerHello JA3S (example) */
      memcpy(flow->protos.stun_ssl.ssl.server_ja3_hash, md5_hash, sizeof(md5_hash));
      return(2);
    }