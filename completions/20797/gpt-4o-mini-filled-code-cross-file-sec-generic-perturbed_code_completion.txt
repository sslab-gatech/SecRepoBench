{
        // Extract cipher suites and extensions based on handshake type
        if (handshake_type == 0x02) { // Server Hello
            // Adjust offset based on session ID length
            offset += 1 + session_id_len; // Skip session ID
            u_int16_t cipher_suite = (packet->payload[offset] << 8) + packet->payload[offset + 1];
            ja3.cipher_suites[0] = cipher_suite; // Store the first cipher suite
            ja3.cipher_suite_count = 1; // Update count

            // Move to extensions
            offset += 2; // Move past cipher suite
            while (offset < total_len) {
                extension_len = (packet->payload[offset + 1] << 8) + packet->payload[offset + 2];
                // Process extensions as needed
                offset += 2 + extension_len; // Move past the extension
            }
        } else if (handshake_type == 0x01) { // Client Hello
            // Similar logic for Client Hello
            offset += 1 + session_id_len; // Skip session ID
            while (offset < total_len) {
                u_int16_t cipher_suite = (packet->payload[offset] << 8) + packet->payload[offset + 1];
                if (cipher_suite != 0x00) { // Skip GREASE values
                    ja3.cipher_suites[ja3.cipher_suite_count++] = cipher_suite; // Store cipher suite
                }
                offset += 2; // Move to next cipher suite
            }
        }

        // Construct JA3 string
        snprintf(ja3_str, sizeof(ja3_str), "%u,%s", ja3.tls_handshake_version, ja3.cipher_suites);
        ja3_str_len = strlen(ja3_str);

        // Compute MD5 hash of the JA3 string
        ndpi_MD5_Init(&ctx);
        ndpi_MD5_Update(&ctx, (u_char *)ja3_str, ja3_str_len);
        ndpi_MD5_Final(md5_hash, &ctx);

        // Store the computed JA3 hash in the flow structure
        memcpy(flow->l4.tcp.tls.ja3_hash, md5_hash, sizeof(md5_hash));

        return (handshake_type == 0x02) ? 1 : 2; // Return 1 for Server Hello, 2 for Client Hello
    }