{
      if(handshake_type == 0x02) { /* Server Hello */
        offset += (1 + session_id_len);

        ja3.server_cipher_suite = ntohs(*((u_int16_t*)&packet->payload[offset]));
        flow->protos.stun_ssl.ssl.cipher_suite = ja3.server_cipher_suite;

#ifdef DEBUG_TLS
        printf("SSL Server Hello [session_id_len: %u][cipher: %04X]\n", session_id_len, ja3.server_cipher_suite);
#endif
      } else { /* Client Hello */
        u_int16_t cipher_suites_length = ntohs(*((u_int16_t*)&packet->payload[offset]));
        offset += 2;

        if((offset + cipher_suites_length) > total_len) {
#ifdef DEBUG_TLS
          printf("SSL Client Hello invalid cipher_suites_length\n");
#endif
          return(0);
        }

        for(j = 0; j < cipher_suites_length; j += 2) {
          u_int16_t cipher_suite = ntohs(*((u_int16_t*)&packet->payload[offset + j]));

          /* Skip GREASE ciphers */
          if((cipher_suite & 0x0F0F) == 0x0A0A)
            continue;

          if(ja3.cipher_suites_len >= (JA3_MAX_CIPHERS - 1))
            break;

          snprintf(&ja3.cipher_suites[ja3.cipher_suites_len], sizeof(ja3.cipher_suites) - ja3.cipher_suites_len,
                   "%s%u", (ja3.cipher_suites_len > 0) ? "," : "", cipher_suite);
          ja3.cipher_suites_len = strlen(ja3.cipher_suites);
        }

        offset += cipher_suites_length;

        /* Extensions */
        if(offset < total_len) {
          u_int16_t extensions_length = ntohs(*((u_int16_t*)&packet->payload[offset]));
          offset += 2;

          if((offset + extensions_length) > total_len) {
#ifdef DEBUG_TLS
            printf("SSL Client Hello invalid extensions_length\n");
#endif
            return(0);
          }

          extension_len = offset + extensions_length;

          while(offset < extension_len) {
            u_int16_t extension_type = ntohs(*((u_int16_t*)&packet->payload[offset]));
            u_int16_t extension_data_length;

            offset += 2;

            if(offset >= extension_len)
              break;

            extension_data_length = ntohs(*((u_int16_t*)&packet->payload[offset]));
            offset += 2;

            if((offset + extension_data_length) > extension_len) {
#ifdef DEBUG_TLS
              printf("SSL Client Hello invalid extension_data_length\n");
#endif
              break;
            }

            /* Skip GREASE extensions */
            if((extension_type & 0x0F0F) == 0x0A0A) {
              offset += extension_data_length;
              continue;
            }

            if(ja3.extensions_len >= (JA3_MAX_EXTENSIONS - 1))
              break;

            snprintf(&ja3.extensions[ja3.extensions_len], sizeof(ja3.extensions) - ja3.extensions_len,
                     "%s%u", (ja3.extensions_len > 0) ? "," : "", extension_type);
            ja3.extensions_len = strlen(ja3.extensions);

            if(extension_type == 0x002b) { /* supported_versions */
              u_int16_t versions_len = packet->payload[offset];
              u_int16_t k;

              offset++;

              for(k = 0; k < versions_len; k += 2) {
                u_int16_t version = ntohs(*((u_int16_t*)&packet->payload[offset + k]));

                if(ja3.supported_versions_len >= (JA3_MAX_VERSIONS - 1))
                  break;

                snprintf(&ja3.supported_versions[ja3.supported_versions_len], sizeof(ja3.supported_versions) - ja3.supported_versions_len,
                         "%s%u", (ja3.supported_versions_len > 0) ? "," : "", version);
                ja3.supported_versions_len = strlen(ja3.supported_versions);
              }
            }

            offset += extension_data_length;
          }
        }
      }

      ja3_str_len = snprintf(ja3_str, sizeof(ja3_str), "%u,%s,%s,%s",
                             ja3.tls_handshake_version, ja3.cipher_suites, ja3.extensions, ja3.supported_versions);

      if(ja3_str_len >= sizeof(ja3_str)) {
        jainvalid = 1;
#ifdef DEBUG_TLS
        printf("String truncated!\n");
#endif
      }

#ifdef DEBUG_TLS
      printf("SSL JA3 string: %s\n", ja3_str);
#endif

      ndpi_MD5Init(&ctx);
      ndpi_MD5Update(&ctx, (const unsigned char*)ja3_str, strlen(ja3_str));
      ndpi_MD5Final(md5_hash, &ctx);

      memcpy(flow->l4.tcp.tls.ja3_hash, md5_hash, 16);
      flow->l4.tcp.tls.ja3_valid = !jainvalid;

#ifdef DEBUG_TLS
      printf("SSL JA3 hash: ");
      for(i = 0; i < 16; i++)
        printf("%02x", md5_hash[i]);
      printf("\n");
#endif

      if(handshake_type == 0x02)
        return(2);
      else
        return(1);
    }