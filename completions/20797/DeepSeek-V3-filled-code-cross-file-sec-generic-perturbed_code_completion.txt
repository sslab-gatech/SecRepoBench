{
      offset += 1 + session_id_len; /* Skip session ID */
      ja3.cipher_suite = ntohs(*((u_int16_t*)&packet->payload[offset]));
      offset += 2;

      /* Skip compression methods */
      u_int8_t compression_methods_len = packet->payload[offset];
      offset += 1 + compression_methods_len;

      /* Parse extensions */
      if(offset + 2 <= total_len) {
        extension_len = ntohs(*((u_int16_t*)&packet->payload[offset]));
        offset += 2;

        for(j = 0; j < extension_len && offset + 4 <= total_len; ) {
          u_int16_t ext_type = ntohs(*((u_int16_t*)&packet->payload[offset]));
          u_int16_t ext_len = ntohs(*((u_int16_t*)&packet->payload[offset+2]));

          offset += 4;
          j += 4;

          if(ext_type != 0x0A && ext_type != 0x1B && ext_type != 0x23) { /* Skip GREASE values */
            ja3.extensions[ja3.num_extensions++] = ext_type;
          }

          if(ext_len > 0) {
            offset += ext_len;
            j += ext_len;
          }
        }
      }

      /* Generate JA3 string */
      snprintf(ja3_str, sizeof(ja3_str), "%d,", ja3.tls_handshake_version);
      snprintf(buffer, sizeof(buffer), "%d", ja3.cipher_suite);
      strncat(ja3_str, buffer, sizeof(ja3_str) - strlen(ja3_str) - 1);

      for(i = 0; i < ja3.num_extensions; i++) {
        snprintf(buffer, sizeof(buffer), "-%d", ja3.extensions[i]);
        strncat(ja3_str, buffer, sizeof(ja3_str) - strlen(ja3_str) - 1);
      }

      /* Compute MD5 hash */
      ja3_str_len = strlen(ja3_str);
      ndpi_MD5Init(&ctx);
      ndpi_MD5Update(&ctx, (unsigned char*)ja3_str, ja3_str_len);
      ndpi_MD5Final(md5_hash, &ctx);

      memcpy(flow->protos.stun_ssl.ssl.ja3_hash, md5_hash, sizeof(md5_hash));
      flow->protos.stun_ssl.ssl.ja3_computed = 1;

      return(1); /* Found */
    }