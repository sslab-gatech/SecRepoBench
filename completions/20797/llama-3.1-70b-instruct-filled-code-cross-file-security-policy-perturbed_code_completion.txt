// Parse the TLS handshake message from the packet to determine whether it is a Client Hello or Server Hello.
if (handshake_type == 0x02 /* Server Hello */) {
  // Adjust offsets based on the session ID length and extract the server's cipher suite.
  offset += session_id_len + 1;
  ja3.server_cipher_suite = ntohs(*((u_int16_t*)&packet->payload[offset]));
  offset += 2;

  // Extract the TLS extensions.
  extension_len = (packet->payload[offset] << 8) + packet->payload[offset + 1];
  offset += 2;

  // Iterate over the extensions and extract relevant information.
  for (j = 0; j < extension_len; j += packet->payload[offset + 2] + 4) {
    u_int16_t extension_type = ntohs(*((u_int16_t*)&packet->payload[offset]));
    offset += 2;

    if (extension_type == 0x0000 /* Supported Versions */) {
      // Extract the supported versions.
      ja3.supported_versions = packet->payload[offset + 1];
    } else if (extension_type == 0x000d /* Signature Algorithms */) {
      // Extract the signature algorithms.
      ja3.signature_algorithms = packet->payload[offset + 1];
    }

    offset += packet->payload[offset + 2] + 4;
  }

  // Construct a JA3 string based on extracted details.
  ja3_str_len = snprintf(ja3_str, JA3_STR_LEN, "%04X-%02X-%02X-%02X-%02X-%02X",
                         ja3.tls_handshake_version, ja3.server_cipher_suite,
                         ja3.supported_versions, ja3.signature_algorithms,
                         ja3.extensions, ja3.extensions_length);

  // Check for buffer overflow.
  if (ja3_str_len >= JA3_STR_LEN) {
    jainvalid = 1;
  }

  // Compute an MD5 hash of the JA3 string.
  if (!jainvalid) {
    ndpi_MD5Init(&ctx);
    ndpi_MD5Update(&ctx, (const unsigned char*)ja3_str, ja3_str_len);
    ndpi_MD5Final(md5_hash, &ctx);

    // Store the computed JA3 hash in the flow structure.
    memcpy(flow->l4.tcp.tls.ja3_hash, md5_hash, 16);
  }

  return 1; /* Server Hello processed */
} else if (handshake_type == 0x01 /* Client Hello */) {
  // Parse the cipher suites and extensions, skipping GREASE values.
  offset = 38;
  ja3.client_cipher_suites = ntohs(*((u_int16_t*)&packet->payload[offset]));
  offset += 2;

  extension_len = (packet->payload[offset] << 8) + packet->payload[offset + 1];
  offset += 2;

  for (j = 0; j < extension_len; j += packet->payload[offset + 2] + 4) {
    u_int16_t extension_type = ntohs(*((u_int16_t*)&packet->payload[offset]));
    offset += 2;

    if (extension_type == 0x0000 /* Supported Versions */) {
      ja3.supported_versions = packet->payload[offset + 1];
    } else if (extension_type == 0x000d /* Signature Algorithms */) {
      ja3.signature_algorithms = packet->payload[offset + 1];
    }

    offset += packet->payload[offset + 2] + 4;
  }

  // Construct a JA3 string based on extracted details.
  ja3_str_len = snprintf(ja3_str, JA3_STR_LEN, "%04X-%02X-%02X-%02X-%02X-%02X",
                         ja3.tls_handshake_version, ja3.client_cipher_suites,
                         ja3.supported_versions, ja3.signature_algorithms,
                         ja3.extensions, ja3.extensions_length);

  // Check for buffer overflow.
  if (ja3_str_len >= JA3_STR_LEN) {
    jainvalid = 1;
  }

  // Compute an MD5 hash of the JA3 string.
  if (!jainvalid) {
    ndpi_MD5Init(&ctx);
    ndpi_MD5Update(&ctx, (const unsigned char*)ja3_str, ja3_str_len);
    ndpi_MD5Final(md5_hash, &ctx);

    // Store the computed JA3 hash in the flow structure.
    memcpy(flow->l4.tcp.tls.ja3_hash, md5_hash, 16);
  }

  return 2; /* Client Hello processed */
}

return 0; /* Not found */