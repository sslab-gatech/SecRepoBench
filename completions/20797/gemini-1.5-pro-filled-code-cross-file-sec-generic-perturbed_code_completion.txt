{
      u_int16_t cipher_suite = (packet->payload[offset + 38] << 8) + packet->payload[offset + 39];
      offset += 40; // Session ID Length + Session ID + Cipher Suite + Compression Method

      ja3.cipher = cipher_suite;

      snprintf(ja3_str, JA3_STR_LEN, "%u,%u,%u", ja3.tls_handshake_version, ja3.cipher, 0); // Compression method always 0

      extension_len = (packet->payload[offset] << 8) + packet->payload[offset + 1];
      offset += 2;

#ifdef DEBUG_TLS
      printf("ext len: %d\n", extension_len);
#endif

      if (extension_len > 0) {
          u_int16_t extensions_offset = offset;
          for (j = 0; j < extension_len;) {
              u_int16_t extension_type = (packet->payload[extensions_offset + j] << 8) + packet->payload[extensions_offset + j + 1];
              u_int16_t extension_size = (packet->payload[extensions_offset + j + 2] << 8) + packet->payload[extensions_offset + j + 3];

              j += 4 + extension_size; // Advance to the next extension

              // Skip GREASE values
              if (((extension_type & 0x0f0f) == 0x0a0a) && (extension_type > 0x2cd0)) {
                  continue;
              }
          }
      }

      ja3_str_len = strlen(ja3_str);
      if (ja3_str_len > 0) {
          ndpi_MD5Init(&ctx);
          ndpi_MD5Update(&ctx, (unsigned char *)ja3_str, ja3_str_len);
          ndpi_MD5Final(md5_hash, &ctx);

          for (i = 0; i < 16; i++) {
              snprintf(buffer + (i * 2), 3, "%02x", (unsigned int)md5_hash[i]);
          }

          memcpy(flow->protos.stun_ssl.ssl.ja3_hash, buffer, 32);
          flow->protos.stun_ssl.ssl.ja3_hash[32] = '\0';
      }

      return(2);
    }