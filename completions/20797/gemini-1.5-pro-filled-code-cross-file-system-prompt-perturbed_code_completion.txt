{
      u_int16_t cipher_suite;
      offset += 38 + session_id_len + 2; // Cipher Suite offset = 38 + Session ID Length + 2

      cipher_suite = ntohs(*((u_int16_t*)&packet->payload[offset]));
      offset += 2; // Next offset

#ifdef DEBUG_TLS
      printf("SSL [SERVER HELLO][cipher suite: %02X]\n", cipher_suite);
#endif

      snprintf(ja3_str, JA3_STR_LEN - 1, "%u,%u,%u",
	       tls_version, cipher_suite, 0);

      ja3_str_len = strlen(ja3_str);

      ndpi_MD5Init(&ctx);
      ndpi_MD5Update(&ctx, ja3_str, ja3_str_len);
      ndpi_MD5Final(md5_hash, &ctx);

      for(i=0; i<16; i++) {
	snprintf(buffer+(i*2), sizeof(buffer)-(i*2)-1, "%02x", md5_hash[i]);
      }

#ifdef DEBUG_TLS
      printf("JA3 Server: %s\n", buffer);
#endif

      memcpy(flow->protos.stun_ssl.ssl.ja3_hash, buffer, JA3_HASH_LEN);
      flow->protos.stun_ssl.ssl.ja3_hash[JA3_HASH_LEN-1] = '\0';

      return(2);
    } else if(handshake_type == 0x01 /* Client Hello */) {
      u_int16_t cipher_suites_len, cipher_suites_offset, extensions_len, extensions_offset, k;

      offset = 38; // Client Hello
      session_id_len = packet->payload[offset];
      offset += session_id_len + 1 + 2; // Cipher suites offset = 38 + Session ID Length + 1 + 2
      cipher_suites_len = ntohs(*((u_int16_t*)&packet->payload[offset]));
      cipher_suites_offset = offset + 2;

      snprintf(ja3_str, JA3_STR_LEN - 1, "%u", tls_version);

      for (j = 0; j < cipher_suites_len; j += 2) {
	u_int16_t cipher = ntohs(*((u_int16_t*)&packet->payload[cipher_suites_offset + j]));

	if (!isGreaseValue(cipher)) {
	  char cipher_str[8];
	  snprintf(cipher_str, sizeof(cipher_str) - 1, ",%u", cipher);
	  strncat(ja3_str, cipher_str, JA3_STR_LEN - strlen(ja3_str) - 1);
	}
      }

      extensions_len = ntohs(*((u_int16_t*)&packet->payload[cipher_suites_offset + cipher_suites_len]));
      extensions_offset = cipher_suites_offset + cipher_suites_len + 2;

      strncat(ja3_str, ",", JA3_STR_LEN - strlen(ja3_str) -1);

      for (j = 0; j < extensions_len;) {
	u_int16_t extension_type = ntohs(*((u_int16_t*)&packet->payload[extensions_offset + j]));
	u_int16_t extension_data_len = ntohs(*((u_int16_t*)&packet->payload[extensions_offset + j + 2]));

	if (!isGreaseValue(extension_type)) {
	  char extension_str[8];
	  snprintf(extension_str, sizeof(extension_str) - 1, "%u", extension_type);

	  if(strlen(ja3_str) + strlen(extension_str) < JA3_STR_LEN - 1) {
	    strncat(ja3_str, extension_str, JA3_STR_LEN - strlen(ja3_str) - 1);
	  } else {
	    jainvalid = 1;
	    break;
	  }

	  if (extension_type == 0 /* Supported Groups */) {
	    u_int16_t supported_groups_len = ntohs(*((u_int16_t*)&packet->payload[extensions_offset + j + 4]));
	    for (k = 0; k < supported_groups_len; k += 2) {
	      u_int16_t group = ntohs(*((u_int16_t*)&packet->payload[extensions_offset + j + 6 + k]));
	      if (!isGreaseValue(group)) {
		char group_str[8];
		snprintf(group_str, sizeof(group_str) - 1, "-%u", group);
		strncat(ja3_str, group_str, JA3_STR_LEN - strlen(ja3_str) - 1);
	      }
	    }
	  } else if (extension_type == 11 /* EC Point Formats */) {
	    // Add logic for ECPointFormats extension if needed.
	  } else if (extension_type == 10 /* Supported Versions */) {
	    u_int8_t supported_versions_len = packet->payload[extensions_offset + j + 4];
	    for (k = 0; k < supported_versions_len; k += 2) {
	      u_int16_t version = ntohs(*((u_int16_t*)&packet->payload[extensions_offset + j + 5 + k]));
	      char version_str[8];
	      snprintf(version_str, sizeof(version_str) - 1, "-%u", version);
	      strncat(ja3_str, version_str, JA3_STR_LEN - strlen(ja3_str) - 1);
	    }
	  } else if (extension_type == 43 /* Supported Signature Algorithms */) {
	    // Add logic for SupportedSignatureAlgorithms extension if needed.
	  } else if (extension_type == 5 /* Status Request */) {
	    // Add logic for StatusRequest extension if needed.
	  }
	  strncat(ja3_str, ",", JA3_STR_LEN - strlen(ja3_str) - 1);
	}

	j += 4 + extension_data_len;
      }

      if(!jainvalid) {
	ja3_str_len = strlen(ja3_str);

	ndpi_MD5Init(&ctx);
	ndpi_MD5Update(&ctx, ja3_str, ja3_str_len);
	ndpi_MD5Final(md5_hash, &ctx);

	for(i=0; i<16; i++) {
	  snprintf(buffer+(i*2), sizeof(buffer)-(i*2)-1, "%02x", md5_hash[i]);
	}

#ifdef DEBUG_TLS
	printf("JA3 Client: %s\n", buffer);
#endif

	memcpy(flow->protos.stun_ssl.ssl.ja3_hash, buffer, JA3_HASH_LEN);
	flow->protos.stun_ssl.ssl.ja3_hash[JA3_HASH_LEN-1] = '\0';

	return(1);
      }
    }