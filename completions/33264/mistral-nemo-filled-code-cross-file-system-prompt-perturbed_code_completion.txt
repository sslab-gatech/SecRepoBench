// Regular decompression.  Put results in tmp2.
  // If the block is aligned and the worst case fits in destination, let's avoid a copy
  bool get_single_block = ((startb == 0) && (bsize == nitems * hdr->typesize));
  uint8_t* tmp2 = get_single_block ? dest : scontext->tmp2;

  // If memcpyed we don't have a bstarts section (because it is not needed)
  int32_t src_offset = memcpyed ?
    context->header_overhead + j * bsize : sw32_(context->bstarts + j);

  int cbytes = blosc_d(context->serial_context, bsize, leftoverblock, memcpyed,
                       src, srcsize, src_offset, j,
                       tmp2, 0, scontext->tmp, scontext->tmp3);
  if (cbytes < 0) {
    ntbytes = cbytes;
    break;
  }
  if (!get_single_block) {
    /* Copy to destination */
    memcpy((uint8_t *) dest + ntbytes, tmp2 + startb, (unsigned int) bsize2);
  }
  ntbytes += bsize2;