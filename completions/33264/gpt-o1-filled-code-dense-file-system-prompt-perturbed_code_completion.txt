int32_t j, leftoverblock, bsize, bsize2, startb, stopb;
  int32_t ntbytes = 0;
  int32_t stop = start + nitems;

  /* If there are no items requested, return immediately */
  if (nitems <= 0) {
    return 0;
  }

  /* Check that the destination buffer can hold all requested items */
  if ((int64_t)nitems * hdr->typesize > destsize) {
    return BLOSC2_ERROR_WRITE_BUFFER;
  }

  /* Clamp the start and stop positions to the valid range */
  int32_t total_items = (int32_t)(hdr->nbytes / hdr->typesize);
  if (start < 0) {
    start = 0;
  }
  if (stop > total_items) {
    stop = total_items;
  }
  /* If our new range is invalid or zero-length, return */
  if (start >= stop) {
    return 0;
  }

  /* Determine if the chunk data is memcpyed */
  bool memcpyed = ((context->header_flags & (uint8_t)BLOSC_MEMCPYED) != 0);
  if (!context->do_compress && context->special_type) {
    memcpyed = true;
  }