// Initialize variables for tracking uncompressed bytes, block sizes, and index positions.
int32_t ntbytes = 0;
int32_t bsize;
int32_t leftoverblock;
int32_t startb;
int32_t stopb;
int32_t bsize2;
int32_t ebsize = hdr->blocksize + hdr->typesize * (signed)sizeof(int32_t);
struct thread_context* scontext = context->serial_context;
/* Resize the temporaries in serial context if needed */
if (hdr->blocksize > scontext->tmp_blocksize) {
  my_free(scontext->tmp);
  scontext->tmp_nbytes = (size_t)4 * ebsize;
  scontext->tmp = my_malloc(scontext->tmp_nbytes);
  BLOSC_ERROR_NULL(scontext->tmp, BLOSC2_ERROR_MEMORY_ALLOC);
  scontext->tmp2 = scontext->tmp + ebsize;
  scontext->tmp3 = scontext->tmp2 + ebsize;
  scontext->tmp4 = scontext->tmp3 + ebsize;
  scontext->tmp_blocksize = (int32_t)hdr->blocksize;
}

// Calculate the stopping position based on the start position and number of items.
int32_t stop = start + nitems;
// Check if there are no items to process and return early if so.
if (nitems == 0) {
  return 0;
}
// Validate that the destination buffer is large enough for the decompressed data.
if (destsize < nitems * hdr->typesize) {
  BLOSC_TRACE_ERROR("Destination buffer is too small for decompressed data.");
  return BLOSC2_ERROR_WRITE_BUFFER;
}
// Set up block start positions based on the source buffer and context.
int32_t j;
int32_t nblocks = context->nblocks;
int32_t leftover = context->leftover;
int32_t* bstarts = context->bstarts;
const uint8_t* src = context->src;
int32_t srcsize = context->srcsize;
// Verify that the start and stop positions are within valid bounds for the data.
if (start < 0 || stop > hdr->nbytes / hdr->typesize) {
  BLOSC_TRACE_ERROR("Start or stop position is out of bounds.");
  return BLOSC2_ERROR_DATA;
}
// Determine if the data should be treated as memcpyed based on header flags or context type.
bool memcpyed = (context->header_flags & (uint8_t)BLOSC_MEMCPYED);
if (!context->do_compress && context->special_type) {
  // Fake a runlen as if its a memcpyed chunk
  memcpyed = true;
}
// Handle special cases for data that is memcpyed or has specific characteristics.
if (memcpyed) {
  // If memcpyed, we can directly copy the data from the source buffer to the destination buffer.
  memcpy(dest, src + context->header_overhead + start * hdr->typesize, (unsigned int)nitems * hdr->typesize);
  return nitems * hdr->typesize;
}