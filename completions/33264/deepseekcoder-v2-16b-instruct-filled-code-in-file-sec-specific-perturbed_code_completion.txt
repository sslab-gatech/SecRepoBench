}
    memcpy(_dest, src, bsize_);
    if (context->postfilter != NULL) {
      // Apply postfilter
      blosc2_postfilter_params postparams;
      memcpy(&postparams, context->postparams, sizeof(postparams));
      postparams.in = _dest;
      postparams.out = dest + dest_offset;
      postparams.size = bsize_;
      postparams.typesize = typesize;
      postparams.offset = nblock * context->blocksize;
      postparams.tid = thread_context->tid;
      postparams.ttmp = thread_context->tmp;
      postparams.ttmp_nbytes = thread_context->tmp_nbytes;
      postparams.ctx = context;
      if (context->postfilter(&postparams) != 0) {
        BLOSC_TRACE_ERROR("Execution of postfilter function failed");
        return BLOSC2_ERROR_POSTFILTER;
      }
    }
    return bsize_;
  }

  // The number of compressed data streams for this block
  if (!dont_split && !leftoverblock) {
    nstreams = (int32_t)typesize;
  }
  else {
    nstreams = 1;
  }
  neblock = bsize / nstreams;
  for (int j = 0; j < nstreams; j++) {
    if (ntbytes + neblock > bsize) {
      /* avoid buffer overrun */
      neblock = bsize - ntbytes;
    }
    if (chunk_cbytes < context->header_overhead + (nblock * context->blocksize) + ntbytes + neblock) {
      /* Not enough input to decompress block */
      return BLOSC2_ERROR_READ_BUFFER;
    }
    if (is_lazy) {
      src += context->header_overhead + nblock * context->blocksize + ntbytes;
    }
    _dest = dest + dest_offset + j * neblock;
    if (context->postfilter != NULL) {
      // We are making use of a postfilter, so use a temp for destination
      _dest = tmp;
    }
    if (context->compcode == BLOSC_BLOSCLZ) {
      cbytes = blosclz_decompress(neblock, _dest, src);
    }
  #if defined(HAVE_LZ4)
    else if (context->compcode == BLOSC_LZ4) {
      cbytes = lz4_wrap_decompress((char*)src, chunk_cbytes - (int)(src - context->src),
                                   (char*)_dest, (size_t)neblock);
    }
    else if (context->compcode == BLOSC_LZ4HC) {
      cbytes = lz4hc_wrap_decompress((char*)src, chunk_cbytes - (int)(src - context->src),
                                     (char*)_dest, (size_t)neblock);
    }
  #endif /* HAVE_LZ4 */
  #if defined(HAVE_SNAPPY)
    else if (context->compcode == BLOSC_SNAPPY) {
      cbytes = snappy_wrap_decompress((char*)src, chunk_cbytes - (int)(src - context->src),
                                      (char*)_dest, (size_t)neblock);
    }
  #endif /* HAVE_SNAPPY */
  #if defined(HAVE_ZLIB)
    else if (context->compcode == BLOSC_ZLIB) {
      cbytes = zlib_wrap_decompress((char*)src, chunk_cbytes - (int)(src - context->src),
                                    (char*)_dest, (size_t)neblock);
    }
  #endif /* HAVE_ZLIB */
  #if defined(HAVE_ZSTD)
    else if (context->compcode == BLOSC_ZSTD) {
      cbytes = zstd_wrap_decompress(thread_context,
                                    (char*)src, chunk_cbytes - (int)(src - context->src),
                                    (char*)_dest, (size_t)neblock);
    }
  #endif /* HAVE_ZSTD */
    else {
      blosc_compcode_to_compname(context->compcode, &compname);
      BLOSC_TRACE_ERROR("Blosc has not been compiled with '%s' compression support."
                        "Please use one having it.", compname);
      return BLOSC2_ERROR_CODEC_SUPPORT;
    }

    if (cbytes < 0) {
      return BLOSC2_ERROR_DATA;
    }
    if (cbytes == 0 || cbytes == neblock) {
      /* The compressor has been unable to compress data at all. */
      memcpy(_dest, src, (unsigned int)neblock);
      cbytes = neblock;
    }
    ntbytes += cbytes;
    ctbytes += cbytes;
  }  /* Closes j < nstreams */

  //printf("d%d", ntbytes);
  return ntbytes;
}


int blosc2_init(blosc2_context* context, int32_t typesize, int32_t blocksize,
                int clevel, int compcode, int nthreads) {
  int rc;

  if (typesize <= 0 || typesize > BLOSC_MAX_TYPESIZE) {
    BLOSC_TRACE_ERROR("Invalid typesize.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }
  if (blocksize <= 0 || blocksize > BLOSC2_MAXBLOCKSIZE) {
    BLOSC_TRACE_ERROR("Invalid blocksize.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }
  if (clevel < 0 || clevel > BLOSC_MAXCLEVEL) {
    BLOSC_TRACE_ERROR("Invalid compression level.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }
  if (compcode < 0 || compcode > BLOSC_MAX_COMPCODES) {
    BLOSC_TRACE_ERROR("Invalid compressor code.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }
  if (nthreads < 1 || nthreads > BLOSC_MAX_THREADS) {
    BLOSC_TRACE_ERROR("Invalid number of threads.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  context->typesize = typesize;
  context->blocksize = blocksize;
  context->clevel = clevel;
  context->compcode = compcode;
  context->nthreads = nthreads;

  context->compname = NULL;
  context->compname = clibcode_to_clibname(compcode);
  if (context->compname == NULL) {
    BLOSC_TRACE_ERROR("Invalid compressor code.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  context->compcode = compname_to_compcode(context->compname);
  if (context->compcode == BLOSC2_ERROR_NOT_FOUND) {
    BLOSC_TRACE_ERROR("Invalid compressor name.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  context->compformat = compcode_to_compformat(context->compcode);
  context->compversion = compcode_to_compversion(context->compcode);

  context->src = NULL;
  context->srcsize = 0;
  context->cbytes = 0;
  context->blocksize = blocksize;
  context->nbytes = 0;
  context->header_flags = 0;
  context->header_overhead = 0;
  context->filter_flags = 0;
  context->special_type = 0;
  context->use_dict = 0;
  context->dict_cdict = NULL;
  context->dict_ddict = NULL;

  context->prefilter = NULL;
  context->postfilter = NULL;
  context->preparams = NULL;
  context->postparams = NULL;

  context->filters[0] = BLOSC_NOFILTER;
  context->filters_meta[0] = 0;

  context->count_threads = 0;
  context->count_threads_mutex = (pthread_mutex_t)PTHREAD_MUTEX_INITIALIZER;
  context->count_threads_cv = (pthread_cond_t)PTHREAD_COND_INITIALIZER;

  context->dref_not_init = 1;
  context->delta_mutex = (pthread_mutex_t)PTHREAD_MUTEX_INITIALIZER;
  context->delta_cv = (pthread_cond_t)PTHREAD_COND_INITIALIZER;

  context->block_maskout = NULL;

  rc = pthread_mutex_init(&global_comp_mutex, NULL);
  if (rc != 0) {
    BLOSC_TRACE_ERROR("Could not initialize global mutex.");
    return BLOSC2_ERROR_THREADS;
  }

  return 0;
}


int blosc2_destroy(blosc2_context* context) {
  int rc;

  if (context == NULL) {
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  if (context->src != NULL) {
    free(context->src);
    context->src = NULL;
  }

  if (context->block_maskout != NULL) {
    free(context->block_maskout);
    context->block_maskout = NULL;
  }

  if (context->prefilter != NULL) {
    free(context->prefilter);
    context->prefilter = NULL;
  }

  if (context->postfilter != NULL) {
    free(context->postfilter);
    context->postfilter = NULL;
  }

  if (context->preparams != NULL) {
    free(context->preparams);
    context->preparams = NULL;
  }

  if (context->postparams != NULL) {
    free(context->postparams);
    context->postparams = NULL;
  }

  rc = pthread_mutex_destroy(&context->count_threads_mutex);
  if (rc != 0) {
    BLOSC_TRACE_ERROR("Could not destroy count_threads_mutex.");
    return BLOSC2_ERROR_THREADS;
  }

  rc = pthread_cond_destroy(&context->count_threads_cv);
  if (rc != 0) {
    BLOSC_TRACE_ERROR("Could not destroy count_threads_cv.");
    return BLOSC2_ERROR_THREADS;
  }

  rc = pthread_mutex_destroy(&context->delta_mutex);
  if (rc != 0) {
    BLOSC_TRACE_ERROR("Could not destroy delta_mutex.");
    return BLOSC2_ERROR_THREADS;
  }

  rc = pthread_cond_destroy(&context->delta_cv);
  if (rc != 0) {
    BLOSC_TRACE_ERROR("Could not destroy delta_cv.");
    return BLOSC2_ERROR_THREADS;
  }

  rc = pthread_mutex_destroy(&global_comp_mutex);
  if (rc != 0) {
    BLOSC_TRACE_ERROR("Could not destroy global_comp_mutex.");
    return BLOSC2_ERROR_THREADS;
  }

  return 0;
}


int blosc2_compress(blosc2_context* context, const void* src, void* dest, size_t destsize) {
  int32_t bsize = context->blocksize;
  int32_t leftoverblock = (int32_t)(context->srcsize % bsize);
  int32_t nblock = (int32_t)(context->srcsize / bsize);
  int32_t dest_offset = 0;
  int32_t src_offset = 0;
  int32_t ntbytes = 0;
  int32_t ctbytes = 0;
  int32_t cbytes = 0;
  uint8_t* tmp = NULL;
  uint8_t* tmp2 = NULL;
  uint8_t* tmp3 = NULL;
  int errcode = 0;
  int rc;

  if (context == NULL || src == NULL || dest == NULL || destsize == 0) {
    BLOSC_TRACE_ERROR("Invalid parameters.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  if (context->src == NULL) {
    context->src = (uint8_t*)src;
    context->srcsize = destsize;
  }
  else {
    if (