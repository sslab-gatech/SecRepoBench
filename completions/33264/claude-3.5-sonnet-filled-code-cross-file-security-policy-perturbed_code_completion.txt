int32_t j, bsize, leftoverblock;
int32_t startb, stopb, bsize2;
int32_t ntbytes = 0;
int32_t stop = start + nitems;
bool memcpyed = (hdr->flags & BLOSC_MEMCPYED) || (context->special_type != 0);

if (hdr->nbytes > hdr->blocksize * context->nblocks) {
  BLOSC_TRACE_ERROR("The data is corrupted.");
  return BLOSC2_ERROR_CORRUPT_CHUNK;
}

if (nitems == 0) {
  return 0;
}

if ((size_t)nitems * hdr->typesize > (size_t)destsize) {
  BLOSC_TRACE_ERROR("Destination buffer is not large enough.");
  return BLOSC2_ERROR_WRITE_BUFFER;
}

if (start < 0 || start >= hdr->nbytes / hdr->typesize) {
  BLOSC_TRACE_ERROR("Start position is out of bounds.");
  return BLOSC2_ERROR_INVALID_PARAM;
}

if (stop > hdr->nbytes / hdr->typesize) {
  BLOSC_TRACE_ERROR("Stop position is out of bounds.");
  return BLOSC2_ERROR_INVALID_PARAM;
}

if (memcpyed) {
  ntbytes = (int32_t)((size_t)(stop - start) * hdr->typesize);
  memcpy(dest, (uint8_t *)src + context->header_overhead + (size_t)start * hdr->typesize, ntbytes);
  return ntbytes;
}