// <MASK>
// Initialize variables for tracking uncompressed bytes, block sizes, and index positions.
// Calculate the stopping position based on the start position and number of items.
// Check if there are no items to process and return early if so.
// Validate that the destination buffer is large enough for the decompressed data.
// Set up block start positions based on the source buffer and context.
// Verify that the start and stop positions are within valid bounds for the data.
// Determine if the data should be treated as memcpyed based on header flags or context type.
// Handle special cases for data that is memcpyed or has specific characteristics.
// Check if the data is compressed or decompressed
if (context->do_compress) {
  // Compression
  // Check if the data is memcpyed
  bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;
  if (memcpyed) {
    // memcpyed data
    // Calculate the number of blocks
    int32_t nblocks = (int32_t)context->srcsize / context->blocksize;
    // Check if there are any blocks
    if (nblocks > 0) {
      // Calculate the stopping position
      int32_t stop = start + nitems;
      // Check if the stopping position is within valid bounds
      if (stop > context->srcsize) {
        stop = context->srcsize;
      }
      // Set up block start positions
      int32_t* bstarts = context->bstarts;
      for (int32_t j = 0; j < nblocks; j++) {
        bstarts[j] = j * context->blocksize;
      }
    }
  } else {
    // Not memcpyed data
    // Calculate the number of blocks
    int32_t nblocks = (int32_t)context->srcsize / context->blocksize;
    // Check if there are any blocks
    if (nblocks > 0) {
      // Calculate the stopping position
      int32_t stop = start + nitems;
      // Check if the stopping position is within valid bounds
      if (stop > context->srcsize) {
        stop = context->srcsize;
      }
      // Set up block start positions
      int32_t* bstarts = context->bstarts;
      for (int32_t j = 0; j < nblocks; j++) {
        bstarts[j] = j * context->blocksize;
      }
    }
  }
} else {
  // Decompression
  // Check if the data is memcpyed
  bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;
  if (memcpyed) {
    // memcpyed data
    // Calculate the number of blocks
    int32_t nblocks = (int32_t)context->srcsize / context->blocksize;
    // Check if there are any blocks
    if (nblocks > 0) {
      // Calculate the stopping position
      int32_t stop = start + nitems;
      // Check if the stopping position is within valid bounds
      if (stop > context->srcsize) {
        stop = context->srcsize;
      }
      // Set up block start positions
      int32_t* bstarts = context->bstarts;
      for (int32_t j = 0; j < nblocks; j++) {
        bstarts[j] = j * context->blocksize;
      }
    }
  } else {
    // Not memcpyed data
    // Calculate the number of blocks
    int32_t nblocks = (int32_t)context->srcsize / context->blocksize;
    // Check if there are any blocks
    if (nblocks > 0) {
      // Calculate the stopping position
      int32_t stop = start + nitems;
      // Check if the stopping position is within valid bounds
      if (stop > context->srcsize) {
        stop = context->srcsize;
      }
      // Set up block start positions
      int32_t* bstarts = context->bstarts;
      for (int32_t j = 0; j < nblocks; j++) {
        bstarts[j] = j * context->blocksize;
      }
    }
  }
}