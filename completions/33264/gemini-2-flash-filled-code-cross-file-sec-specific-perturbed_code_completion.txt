int32_t j, bsize, bsize2, startb, stopb, leftoverblock;
  int32_t ntbytes = 0;
  int32_t ebsize;
  int stop = start + nitems;
  bool memcpyed = hdr->flags & (uint8_t)BLOSC_MEMCPYED;

  if (nitems == 0) {
    return 0;
  }

  if ((int64_t)nitems * (int64_t)hdr->typesize > (int64_t)destsize) {
    return BLOSC2_ERROR_DEST_NOT_ENOUGH_SPACE;
  }

  if (context->bstarts == NULL) {
    context->bstarts = (int32_t*)(_src + context->header_overhead);
  }

  if (start < 0 || stop * hdr->typesize > (int)context->nbytes) {
    return BLOSC2_ERROR_INVALID_ARGS;
  }

  if (!context->do_compress && context->special_type) {
    // Fake a runlen as if its a memcpyed chunk
    memcpyed = true;
  }

  if (memcpyed) {
    /* Special case for memcpyed.  */
    if (start == 0 && nitems * hdr->typesize == (int)context->nbytes) {
      /* We can do a quick copy */
      memcpy(dest, src + context->header_overhead, (unsigned int)destsize);
      return (int)context->nbytes;
    }
  }