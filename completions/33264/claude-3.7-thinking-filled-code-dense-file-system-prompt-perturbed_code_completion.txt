int32_t ntbytes = 0;
int32_t bsize, bsize2, leftoverblock, startb, stopb, j;
int stop = start + nitems;
bool memcpyed;

/* Return early if there are no items to extract */
if (nitems == 0) {
  return 0;
}

/* Check that we have enough space for the decompressed data */
if (destsize < (int32_t)(nitems * hdr->typesize)) {
  return BLOSC2_ERROR_WRITE_BUFFER;
}

/* Initialize bstarts */
context->bstarts = (int32_t*)(_src + context->header_overhead);

/* Check bounds for start and stop */
if (start < 0 || start >= (int)hdr->nbytes / hdr->typesize) {
  return BLOSC2_ERROR_INDEX_OUT_OF_BOUNDS;
}

if (stop > (int)hdr->nbytes / hdr->typesize) {
  return BLOSC2_ERROR_INDEX_OUT_OF_BOUNDS;
}

/* Check whether we have an initialized context */
if (context->nblocks == 0) {
  return BLOSC2_ERROR_INVALID_HEADER;
}

/* Check whether it's a memcpyed buffer */
memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;
if (!memcpyed && context->special_type) {
  /* Fake a memcpyed chunk */
  memcpyed = true;
}

/* Handle special values */
if (context->special_type == BLOSC2_SPECIAL_VALUE) {
  uint8_t* data_ptr = (uint8_t *)src + context->header_overhead;
  switch (hdr->typesize) {
    case 1:
      memset(dest, data_ptr[0], nitems);
      break;
    case 2:
      for (j = 0; j < nitems; j++) {
        ((uint16_t*)dest)[j] = ((uint16_t*)data_ptr)[0];
      }
      break;
    case 4:
      for (j = 0; j < nitems; j++) {
        ((uint32_t*)dest)[j] = ((uint32_t*)data_ptr)[0];
      }
      break;
    case 8:
      for (j = 0; j < nitems; j++) {
        ((uint64_t*)dest)[j] = ((uint64_t*)data_ptr)[0];
      }
      break;
    default:
      for (j = 0; j < nitems; j++) {
        memcpy((uint8_t *)dest + j * hdr->typesize, data_ptr, hdr->typesize);
      }
  }
  return nitems * hdr->typesize;
}

/* Handle special zeros */
if (context->special_type == BLOSC2_SPECIAL_ZERO) {
  memset(dest, 0, nitems * hdr->typesize);
  return nitems * hdr->typesize;
}

/* Handle special NaN */
if (context->special_type == BLOSC2_SPECIAL_NAN) {
  uint8_t* data_ptr = (uint8_t *)src + context->header_overhead;
  switch (hdr->typesize) {
    case 4:
      for (j = 0; j < nitems; j++) {
        ((float*)dest)[j] = *(float*)data_ptr;
      }
      break;
    case 8:
      for (j = 0; j < nitems; j++) {
        ((double*)dest)[j] = *(double*)data_ptr;
      }
      break;
    default:
      return BLOSC2_ERROR_DATA_FORMAT;
  }
  return nitems * hdr->typesize;
}