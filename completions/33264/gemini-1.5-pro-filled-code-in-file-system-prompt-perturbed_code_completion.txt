uint8_t* _src = (uint8_t*)src;
  int32_t bsize, bsize2, leftoverblock, ntbytes = 0, ebsize;
  int32_t j, startb, stopb, stop = start + nitems;
  bool memcpyed = (hdr->flags & BLOSC_MEMCPYED) || context->special_type;

  if (nitems == 0) return 0;      /* nothing to do */

  if ((int32_t)destsize < nitems * hdr->typesize) {
    /* Not enough space for decompressing */
    return BLOSC2_ERROR_WRITE_BUFFER;
  }

  /* Check the limits for start and stop */
  if (start < 0 || start >= hdr->nbytes) {
    return BLOSC2_ERROR_INVALID_PARAM;
  }
  if (stop < 0 || stop > hdr->nbytes) {
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  context->bstarts = (int32_t*)(_src + context->header_overhead);

  if (memcpyed) {
    int32_t start_offset = start * hdr->typesize;
    int32_t stop_offset = stop * hdr->typesize;
    int32_t nbytes = stop_offset - start_offset;
    switch (context->special_type) {
      case BLOSC2_SPECIAL_VALUE:
        // All repeated values
        result = set_values(context->typesize, context->src, dest, nbytes);
        if (result < 0) {
          BLOSC_TRACE_ERROR("set_values failed");
          return BLOSC2_ERROR_DATA;
        }
        break;
      case BLOSC2_SPECIAL_NAN:
        result = set_nans(context->typesize, dest, nbytes);
        if (result < 0) {
          BLOSC_TRACE_ERROR("set_nans failed");
          return BLOSC2_ERROR_DATA;
        }
        break;
      case BLOSC2_SPECIAL_ZERO:
        memset(dest, 0, nbytes);
        break;
      case BLOSC2_SPECIAL_UNINIT:
        // We do nothing here
        break;
      default:
        memcpy(dest, _src + context->header_overhead + start_offset, (unsigned int)nbytes);
    }
    return nbytes;
  }