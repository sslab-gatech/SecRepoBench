if (nitems <= 0) {
        return 0;  // No items to process
    }
    if (destsize < nitems * typesize) {
        return BLOSC2_ERROR_WRITE_BUFFER;  // Not enough space in destination
    }

    // Initialize the destination buffer to zero
    memset(dest, 0, nitems * typesize);

    // Decompress the data into the destination buffer
    for (int j = 0; j < context->nblocks; j++) {
        int32_t blocksize = context->blocksize;
        if (j == context->nblocks - 1 && context->leftover > 0) {
            blocksize = context->leftover;  // Handle the last block
        }

        // Calculate the source offset for the current block
        int32_t src_offset = memcpyed ? context->header_overhead + j * blocksize : sw32_(context->bstarts + j);
        
        // Decompress the block
        int cbytes = blosc_d(context->serial_context, blocksize, 0, memcpyed, src, srcsize, src_offset, j, tmp, 0, tmp2, tmp3);
        if (cbytes < 0) {
            return cbytes;  // Error during decompression
        }

        // Copy the relevant portion of the decompressed block to the destination
        memcpy((uint8_t*)dest + j * blocksize, tmp, cbytes);
    }

    return nitems;  // Return the number of items processed