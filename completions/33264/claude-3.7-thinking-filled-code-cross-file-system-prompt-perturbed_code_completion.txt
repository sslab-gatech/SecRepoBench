int32_t j, bsize, leftoverblock;
int32_t cbytes;
int32_t ntbytes = 0;
int32_t startb, stopb;
int32_t bsize2;
int32_t ebsize;
int32_t stop = start + nitems;

/* Check if no items are requested */
if (nitems <= 0) {
  return 0;
}

/* Check that we have enough space for the decompressed data */
if ((size_t)nitems * hdr->typesize > (size_t)destsize) {
  return BLOSC2_ERROR_BUFFER_OVERFLOW;
}

/* Get the strides */
bool memcpyed = hdr->flags & (uint8_t)BLOSC_MEMCPYED;
if (!context->do_compress && context->special_type) {
  /* Fake a runlen as if it's a memcpyed chunk */
  memcpyed = true;
}

/* Check that the start and stop positions are valid */
if ((start < 0) || (start > hdr->nbytes / hdr->typesize)) {
  return BLOSC2_ERROR_INVALID_PARAM;
}
if (stop > hdr->nbytes / hdr->typesize) {
  return BLOSC2_ERROR_INVALID_PARAM;
}

/* Handle memcpyed data */
if (memcpyed) {
  uint8_t* startd = (uint8_t*)dest;
  uint8_t* starts = (uint8_t*)_src + context->header_overhead + start * hdr->typesize;
  memcpy(startd, starts, (unsigned int)(nitems * hdr->typesize));
  return nitems * hdr->typesize;
}