int32_t ntbytes = 0;                /* Number of uncompressed bytes */
  int32_t bsize2, bsize, leftoverblock, ebsize;
  int32_t j, startb, stopb;
  int stop = start + nitems;
  bool memcpyed = (hdr->flags & (uint8_t)BLOSC_MEMCPYED) || context->special_type;

  if (nitems == 0) {
    return 0;                    /* nothing to do */
  }

  if ((int32_t)(nitems * hdr->typesize) > destsize) {
    return BLOSC2_ERROR_WRITE_BUFFER;
  }

  if (!memcpyed) {
    context->bstarts = (int32_t *) (_src + context->header_overhead);
  }

  if (start < 0 || start >= (hdr->nbytes / hdr->typesize) ||
      stop < 0 || stop > (hdr->nbytes / hdr->typesize)) {
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  if (memcpyed && context->special_type) {
    uint8_t* _dest = (uint8_t*)dest;
    int rc = 0;
    switch (context->special_type) {
      case BLOSC2_SPECIAL_VALUE:
        // All repeated values
        rc = set_values(context->typesize, context->src, _dest, nitems * hdr->typesize);
        if (rc < 0) {
          BLOSC_TRACE_ERROR("set_values failed");
          return BLOSC2_ERROR_DATA;
        }
        break;
      case BLOSC2_SPECIAL_NAN:
        rc = set_nans(context->typesize, _dest, nitems * hdr->typesize);
        if (rc < 0) {
          BLOSC_TRACE_ERROR("set_nans failed");
          return BLOSC2_ERROR_DATA;
        }
        break;
      case BLOSC2_SPECIAL_ZERO:
        memset(_dest, 0, nitems * hdr->typesize);
        break;
      case BLOSC2_SPECIAL_UNINIT:
        // We do nothing here
        break;
      default:
        return BLOSC2_ERROR_DATA;
    }
    return nitems * hdr->typesize;
  }

  if (memcpyed) {
    int32_t start_offset = context->header_overhead + start * hdr->typesize;
    int32_t end_offset = context->header_overhead + stop * hdr->typesize;
    if (end_offset > hdr->cbytes) {
      return BLOSC2_ERROR_READ_BUFFER;
    }
    memcpy(dest, _src + start_offset, (unsigned int)(end_offset - start_offset));
    return end_offset - start_offset;
  }