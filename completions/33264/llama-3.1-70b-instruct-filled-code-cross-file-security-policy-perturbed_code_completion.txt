// Initialize variables for tracking uncompressed bytes, block sizes, and index positions.
int32_t ntbytes = 0;
int32_t bsize, leftoverblock, startb, stopb, bsize2;
int32_t ebsize;

// Calculate the stopping position based on the start position and number of items.
int32_t stop = start + nitems;

// Check if there are no items to process and return early if so.
if (nitems == 0) {
    return 0;
}

// Validate that the destination buffer is large enough for the decompressed data.
if (destsize < (stop * hdr->typesize)) {
    return BLOSC2_ERROR_DECODE;
}

// Set up block start positions based on the source buffer and context.
int32_t j;
int32_t nblocks = context->nblocks;

// Verify that the start and stop positions are within valid bounds for the data.
if (start < 0 || stop > (context->typesize * context->nblocks)) {
    return BLOSC2_ERROR_DECODE;
}

// Determine if the data should be treated as memcpyed based on header flags or context type.
bool memcpyed = (hdr->flags & (uint8_t)BLOSC_MEMCPYED) || (context->header_flags & (uint8_t)BLOSC_MEMCPYED);

// Handle special cases for data that is memcpyed or has specific characteristics.
if (memcpyed) {
    // If memcpyed, we can directly copy the data from the source to the destination.
    memcpy(dest, _src + start * hdr->typesize, (unsigned int)(nitems * hdr->typesize));
    return nitems * hdr->typesize;
}