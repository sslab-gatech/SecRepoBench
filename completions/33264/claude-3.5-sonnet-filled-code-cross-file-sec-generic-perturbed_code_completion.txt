int32_t j, bsize, leftoverblock;
int32_t startb, stopb, bsize2;
int32_t ntbytes = 0;
int32_t stop = start + nitems;
int32_t ebsize;
bool memcpyed = (hdr->flags & BLOSC_MEMCPYED) || (context->header_flags & BLOSC_MEMCPYED);

if (nitems == 0) {
  return 0;
}

if (destsize < (int32_t)hdr->typesize * nitems) {
  BLOSC_TRACE_ERROR("Destination buffer is too small");
  return BLOSC2_ERROR_WRITE_BUFFER;
}

if ((start < 0) || (start * hdr->typesize > hdr->nbytes)) {
  BLOSC_TRACE_ERROR("Start position is out of bounds");
  return BLOSC2_ERROR_INVALID_PARAM;
}

if ((stop < 0) || (stop * hdr->typesize > hdr->nbytes)) {
  BLOSC_TRACE_ERROR("Stop position is out of bounds");
  return BLOSC2_ERROR_INVALID_PARAM;
}

if (memcpyed) {
  ntbytes = (int32_t)hdr->typesize * nitems;
  memcpy(dest, (uint8_t *)src + context->header_overhead + (int32_t)hdr->typesize * start, ntbytes);
  return ntbytes;
}

if (hdr->blocksize == 0) {
  BLOSC_TRACE_ERROR("Invalid block size in header");
  return BLOSC2_ERROR_INVALID_HEADER;
}