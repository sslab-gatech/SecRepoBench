// Initialize variables for tracking uncompressed bytes, block sizes, and index positions.
int32_t ntbytes = 0;
int32_t bsize;
int32_t leftoverblock;
int32_t startb;
int32_t stopb;
int32_t bsize2;
int32_t ebsize = hdr->blocksize + hdr->typesize * (signed)sizeof(int32_t);
struct thread_context* scontext = context->serial_context;
/* Resize the temporaries in serial context if needed */
if (hdr->blocksize > scontext->tmp_blocksize) {
  my_free(scontext->tmp);
  scontext->tmp_nbytes = (size_t)4 * ebsize;
  scontext->tmp = my_malloc(scontext->tmp_nbytes);
  BLOSC_ERROR_NULL(scontext->tmp, BLOSC2_ERROR_MEMORY_ALLOC);
  scontext->tmp2 = scontext->tmp + ebsize;
  scontext->tmp3 = scontext->tmp2 + ebsize;
  scontext->tmp4 = scontext->tmp3 + ebsize;
  scontext->tmp_blocksize = (int32_t)hdr->blocksize;
}

// Calculate the stopping position based on the start position and number of items.
int32_t j;
int32_t nblocks = context->nblocks;
int32_t leftover = context->leftover;
int32_t typesize = context->typesize;
int32_t nitems = nitems;
int32_t stop = start + nitems;
if (stop > (nblocks * hdr->blocksize) / typesize) {
  stop = (nblocks * hdr->blocksize) / typesize;
}

// Check if there are no items to process and return early if so.
if (nitems == 0) {
  return 0;
}

// Validate that the destination buffer is large enough for the decompressed data.
if (destsize < nitems * typesize) {
  BLOSC_TRACE_ERROR("Destination buffer is not large enough for decompressed data.");
  return BLOSC2_ERROR_WRITE_BUFFER;
}

// Set up block start positions based on the source buffer and context.
int32_t* bstarts = context->bstarts;
bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;

// Verify that the start and stop positions are within valid bounds for the data.
if (start < 0 || stop > (nblocks * hdr->blocksize) / typesize) {
  BLOSC_TRACE_ERROR("Start or stop position is out of bounds.");
  return BLOSC2_ERROR_DATA;
}

// Determine if the data should be treated as memcpyed based on header flags or context type.
if (memcpyed) {
  // Handle special cases for data that is memcpyed or has specific characteristics.
  if (context->special_type == BLOSC2_SPECIAL_VALUE) {
    // All repeated values
    int32_t value = ((int32_t*)(context->src + BLOSC_EXTENDED_HEADER_LENGTH))[0];
    memset(dest, value, nitems * typesize);
    return nitems * typesize;
  }
  else if (context->special_type == BLOSC2_SPECIAL_NAN) {
    // All NaNs
    int32_t nitems_ = set_nans(typesize, dest, nitems * typesize);
    if (nitems_ < 0) {
      BLOSC_TRACE_ERROR("set_nans failed");
      return BLOSC2_ERROR_DATA;
    }
    return nitems * typesize;
  }
  else if (context->special_type == BLOSC2_SPECIAL_ZERO) {
    // All zeros
    memset(dest, 0, nitems * typesize);
    return nitems * typesize;
  }
  else if (context->special_type == BLOSC2_SPECIAL_UNINIT) {
    // Uninitialized values
    return nitems * typesize;
  }
  else {
    BLOSC_TRACE_ERROR("Unknown special values ID (%d) ",
                      context->special_type);
    return BLOSC2_ERROR_DATA;
  }
}

// Loop over blocks
for (j = 0; j < context->nblocks; j++) {
  bsize = hdr->blocksize;
  leftoverblock = 0;
  if ((j == context->nblocks - 1) && (leftover > 0)) {
    bsize = leftover;
    leftoverblock = 1;
  }

  /* Compute start & stop for each block */
  startb = start * typesize - j * hdr->blocksize;
  stopb = stop * typesize - j * hdr->blocksize;
  if (stopb <= 0) {
    // We can exit as soon as this block is beyond stop
    break;
  }
  if (startb >= hdr->blocksize) {
    continue;
  }
  if (startb < 0) {
    startb = 0;
  }
  if (stopb > hdr->blocksize) {
    stopb = hdr->blocksize;
  }
  bsize2 = stopb - startb;

  /* Do the actual data copy */
  // Regular decompression.  Put results in tmp2.
  // If the block is aligned and the worst case fits in destination, let's avoid a copy
  bool get_single_block = ((startb == 0) && (bsize == nitems * hdr->typesize));
  uint8_t* tmp2 = get_single_block? dest : scontext->tmp2;

  // If memcpyed we don't have a bstarts section (because it is not needed)
  int32_t src_offset = memcpyed?
      context->header_overhead + j * bsize : sw32_(bstarts + j);

  int cbytes = blosc_d(context->serial_context, bsize, leftoverblock, memcpyed,
                       src, srcsize, src_offset, j,
                       tmp2, 0, scontext->tmp, scontext->tmp3);
  if (cbytes < 0) {
    ntbytes = cbytes;
    break;
  }
  if (!get_single_block) {
    /* Copy to destination */
    memcpy((uint8_t *) dest + ntbytes, tmp2 + startb, (unsigned int) bsize2);
  }
  ntbytes += bsize2;
}

return ntbytes;