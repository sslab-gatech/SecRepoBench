if (destsize < ntbytes) {
    return BLOSC2_ERROR_DESTSIZE;  // Ensure destination buffer is large enough
}

// Initialize the number of bytes to be written
ntbytes = 0;

// Process each block of data
for (j = 0; j < context->nblocks; j++) {
    // Calculate the size of the current block
    bsize = hdr->blocksize;
    if ((j == context->nblocks - 1) && (context->leftover > 0)) {
        bsize = context->leftover;
    }

    // Check if the block is within the valid range
    if (start >= bsize) {
        continue;  // Skip if start is beyond the block size
    }

    // Calculate the number of bytes to copy
    int32_t bytes_to_copy = (bsize - start < nitems * hdr->typesize) ? bsize - start : nitems * hdr->typesize;

    // Ensure we do not exceed the destination buffer size
    if (ntbytes + bytes_to_copy > destsize) {
        return BLOSC2_ERROR_DESTSIZE;  // Destination buffer overflow risk
    }

    // Copy the data to the destination buffer
    memcpy((uint8_t *)dest + ntbytes, _src + start, bytes_to_copy);
    ntbytes += bytes_to_copy;
}