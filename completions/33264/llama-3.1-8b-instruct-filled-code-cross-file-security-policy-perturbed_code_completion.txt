// <MASK>
// Initialize variables for tracking uncompressed bytes, block sizes, and index positions.
// Calculate the stopping position based on the start position and number of items.
// Check if there are no items to process and return early if so.
// Validate that the destination buffer is large enough for the decompressed data.
// Set up block start positions based on the source buffer and context.
// Verify that the start and stop positions are within valid bounds for the data.
// Determine if the data should be treated as memcpyed based on header flags or context type.
// Handle special cases for data that is memcpyed or has specific characteristics.
if (context->do_compress) {
  // Compression mode
  if (memcpyed) {
    // memcpyed data
    if (context->header_flags & (uint8_t)BLOSC_MEMCPYED) {
      // memcpyed data with header flags
      for (j = 0; j < context->nblocks; j++) {
        bsize = context->blocksize;
        leftoverblock = 0;
        if ((j == context->nblocks - 1) && (context->leftover > 0)) {
          bsize = context->leftover;
          leftoverblock = 1;
        }
        if (context->header_flags & (uint8_t)BLOSC_MEMCPYED) {
          // memcpyed data with header flags
          memcpy(context->dest + context->header_overhead + j * context->blocksize,
                 context->src + j * context->blocksize, (unsigned int)bsize);
          cbytes = (int32_t)bsize;
        } else {
          // memcpyed data without header flags
          cbytes = blosc_c(thread_context, bsize, leftoverblock, ntbytes,
                           context->destsize, context->src, j * context->blocksize,
                           context->dest + ntbytes, tmp, tmp2);
        }
        if (cbytes == 0) {
          ntbytes = 0;              /* uncompressible data */
          break;
        }
        ntbytes += cbytes;
      }
    } else {
      // memcpyed data without header flags
      for (j = 0; j < context->nblocks; j++) {
        bsize = context->blocksize;
        leftoverblock = 0;
        if ((j == context->nblocks - 1) && (context->leftover > 0)) {
          bsize = context->leftover;
          leftoverblock = 1;
        }
        cbytes = blosc_c(thread_context, bsize, leftoverblock, ntbytes,
                         context->destsize, context->src, j * context->blocksize,
                         context->dest + ntbytes, tmp, tmp2);
        if (cbytes == 0) {
          ntbytes = 0;              /* uncompressible data */
          break;
        }
        ntbytes += cbytes;
      }
    }
  } else {
    // non-memcpyed data
    for (j = 0; j < context->nblocks; j++) {
      bsize = context->blocksize;
      leftoverblock = 0;
      if ((j == context->nblocks - 1) && (context->leftover > 0)) {
        bsize = context->leftover;
        leftoverblock = 1;
      }
      cbytes = blosc_c(thread_context, bsize, leftoverblock, ntbytes,
                       context->destsize, context->src, j * context->blocksize,
                       context->dest + ntbytes, tmp, tmp2);
      if (cbytes == 0) {
        ntbytes = 0;              /* uncompressible data */
        break;
      }
      ntbytes += cbytes;
    }
  }
} else {
  // Decompression mode
  for (j = 0; j < context->nblocks; j++) {
    bsize = context->blocksize;
    leftoverblock = 0;
    if ((j == context->nblocks - 1) && (context->leftover > 0)) {
      bsize = context->leftover;
      leftoverblock = 1;
    }
    if (memcpyed) {
      // memcpyed data
      int32_t src_offset = memcpyed?
          context->header_overhead + j * context->blocksize : sw32_(context->bstarts + j);
      cbytes = blosc_d(thread_context, bsize, leftoverblock, memcpyed,
                       context->src, context->srcsize, src_offset, j,
                       context->dest, j * context->blocksize, tmp, tmp2);
    } else {
      // non-memcpyed data
      int32_t src_offset = sw32_(context->bstarts + j);
      cbytes = blosc_d(thread_context, bsize, leftoverblock, memcpyed,
                       context->src, context->srcsize, src_offset, j,
                       context->dest, j * context->blocksize, tmp, tmp2);
    }
    if (cbytes < 0) {
      ntbytes = cbytes;         /* error in blosc_c or blosc_d */
      break;
    }
    ntbytes += cbytes;
  }
}