int32_t ntbytes = 0;          // Counter for total bytes processed
int j;                        // Block counter
int32_t startb = 0;           // Start for each block
int32_t stopb = 0;            // Stop for each block
int32_t bsize, bsize2;        // Block size and adjusted block size
int leftoverblock;            // Flag for the last block potentially being smaller
int32_t ebsize;               // Extended block size
int32_t stop = start + nitems;// Stopping position

// Check if there are items to extract
if (nitems == 0) {
  return 0;
}

// Check that we are not asking for items outside the bounds
if ((start < 0) || (start * hdr->typesize >= hdr->nbytes)) {
  BLOSC_TRACE_ERROR("Start position is beyond data bounds");
  return BLOSC2_ERROR_INVALID_PARAM;
}

// Check that we have enough destination space for decompressing
if (destsize < nitems * hdr->typesize) {
  BLOSC_TRACE_ERROR("Destination buffer size is too small");
  return BLOSC2_ERROR_BUFFER_SMALL;
}

// Some checks for nitems
if ((nitems < 0) || (nitems * hdr->typesize > hdr->nbytes) ||
    (stop * hdr->typesize > hdr->nbytes)) {
  BLOSC_TRACE_ERROR("Number of items causes access beyond data bounds");
  return BLOSC2_ERROR_INVALID_PARAM;
}

// Set the context based on the header info
context->bstarts = (int32_t*)(_src + context->header_overhead);
context->nblocks = hdr->nblocks;
context->leftover = hdr->leftover;
context->blocksize = hdr->blocksize;
context->typesize = hdr->typesize;
context->srcsize = srcsize;
context->header_flags = hdr->flags;

// Check if the chunk is memcpyed
bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;