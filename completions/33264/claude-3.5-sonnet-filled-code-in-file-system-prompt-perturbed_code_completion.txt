uint8_t* _src = (uint8_t*)(src);  /* current pos for source buffer */
uint8_t* _tmp = tmp;
uint8_t* _tmp2 = tmp2;
uint8_t* _tmp3 = thread_context->tmp4;
int32_t ntbytes = 0;              /* number of uncompressed bytes in block */
int32_t j;
int32_t bsize, leftoverblock;
int32_t ebsize;
int32_t startb, stopb;
int32_t bstarts_end;
int32_t nstreams;
int32_t bsize2;

ebsize = hdr->blocksize + hdr->typesize * (signed)sizeof(int32_t);
struct thread_context* scontext = context->serial_context;
/* Resize the temporaries in serial context if needed */
if (hdr->blocksize > scontext->tmp_blocksize) {
  my_free(scontext->tmp);
  scontext->tmp_nbytes = (size_t)4 * ebsize;
  scontext->tmp = my_malloc(scontext->tmp_nbytes);
  BLOSC_ERROR_NULL(scontext->tmp, BLOSC2_ERROR_MEMORY_ALLOC);
  scontext->tmp2 = scontext->tmp + ebsize;
  scontext->tmp3 = scontext->tmp2 + ebsize;
  scontext->tmp4 = scontext->tmp3 + ebsize;
  scontext->tmp_blocksize = (int32_t)hdr->blocksize;
}

for (j = 0; j < context->nblocks; j++) {
  bsize = hdr->blocksize;
  leftoverblock = 0;
  if ((j == context->nblocks - 1) && (context->leftover > 0)) {
    bsize = context->leftover;
    leftoverblock = 1;
  }

  /* Compute start & stop for each block */
  startb = start * hdr->typesize - j * hdr->blocksize;
  stopb = stop * hdr->typesize - j * hdr->blocksize;
  if (stopb <= 0) {
    break;
  }
  if (startb >= hdr->blocksize) {
    continue;
  }
  if (startb < 0) {
    startb = 0;
  }
  if (stopb > hdr->blocksize) {
    stopb = hdr->blocksize;
  }
  bsize2 = stopb - startb;