// Initialize variables for tracking uncompressed bytes, block sizes, and index positions.
int32_t ntbytes = 0;
int32_t startb, stopb, bsize2;
int j;

// Calculate the stopping position based on the start position and number of items.
int stop = start + nitems;

// Check if there are no items to process and return early if so.
if (nitems <= 0) {
  return 0;
}

// Validate that the destination buffer is large enough for the decompressed data.
if ((size_t)destsize < (size_t)nitems * hdr->typesize) {
  BLOSC_TRACE_ERROR("Destination buffer too small for decompressed data.");
  return BLOSC2_ERROR_MEMORY_ALLOC;
}

// Set up block start positions based on the source buffer and context.
int32_t block_start = context->header_overhead;

// Verify that the start and stop positions are within valid bounds for the data.
if (start >= context->nitems || stop > context->nitems) {
  BLOSC_TRACE_ERROR("Start or stop position out of bounds.");
  return BLOSC2_ERROR_INVALID_PARAM;
}

// Determine if the data should be treated as memcpyed based on header flags or context type.
bool memcpyed = context->header_flags & BLOSC_MEMCPYED;

// Handle special cases for data that is memcpyed or has specific characteristics.
if (memcpyed && !context->prefilter) {
  // Directly copy the data if it's marked as memcpyed and no prefilter is needed.
  memcpy(dest, _src + start * hdr->typesize, (unsigned int)(nitems * hdr->typesize));
  return nitems * hdr->typesize;
}