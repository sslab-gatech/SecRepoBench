// Calculate the stopping position based on the start position and number of items.
  int stop = start + nitems;
  if (nitems == 0) {
    return 0;  // No items to process
  }

  // Validate that the destination buffer is large enough for the decompressed data.
  if (destsize < nitems * hdr->typesize) {
    return BLOSC2_ERROR_WRITE_BUFFER;  // Destination buffer is too small
  }

  // Verify that the start and stop positions are within valid bounds for the data.
  if (start < 0 || stop > hdr->nitems) {
    return BLOSC2_ERROR_INVALID_PARAM;  // Invalid start or stop positions
  }

  // Determine if the data should be treated as memcpyed based on header flags or context type.
  bool memcpyed = (hdr->flags & BLOSC_MEMCPYED) != 0;
  if (!context->do_compress && context->special_type) {
    // Fake a runlen as if it's a memcpyed chunk
    memcpyed = true;
  }