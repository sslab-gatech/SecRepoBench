int32_t j, bsize, bsize2, startb, stopb, leftoverblock;
  int32_t ntbytes = 0;
  int32_t ebsize;
  int32_t stop = start + nitems;
  int32_t* bstarts = context->bstarts;
  bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;
  if (!context->do_compress && context->special_type) {
    // Fake a runlen as if its a memcpyed chunk
    memcpyed = true;
  }

  if (nitems == 0) {
    return 0;
  }

  if (destsize < nitems * hdr->typesize) {
    return BLOSC2_ERROR_DEST_NOT_ENOUGH;
  }

  /* Set up block start positions */
  _src += context->header_overhead;

  /* Check start & stop conditions */
  if (start < 0 || stop > (int32_t)hdr->nitems) {
    return BLOSC2_ERROR_INVALID_ARGS;
  }

  /* Special case for memcpyed data */
  if (memcpyed) {
    /* We want to memcpy only */
    memcpy(dest, _src + start * hdr->typesize, (unsigned int)(nitems * hdr->typesize));
    return nitems * hdr->typesize;
  }