int32_t j, bsize, leftoverblock, startb, stopb, bsize2;
  int32_t ntbytes = 0;                    /* number of uncompressed bytes */
  int32_t ebsize;
  int memcpyed = (hdr->flags & (uint8_t)BLOSC_MEMCPYED);
  int start_ = start;
  int stop = start + nitems;

  if (nitems <= 0) {
    return 0;
  }

  if (destsize < nitems * hdr->typesize) {
    return BLOSC2_ERROR_WRITE_BUFFER;
  }

  if (context->bstarts == NULL) {
    memcpyed = 1;
  }

  if (memcpyed && (hdr->cbytes != hdr->nbytes + context->header_overhead)) {
    BLOSC_TRACE_ERROR("Wrong header info for this memcpyed chunk");
    return BLOSC2_ERROR_INVALID_HEADER;
  }

  if ((hdr->nbytes == 0) && (hdr->cbytes == context->header_overhead) &&
      !context->special_type) {
    // A compressed buffer with only a header can only contain a zero-length buffer
    return 0;
  }