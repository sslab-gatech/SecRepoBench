int32_t ebsize;
int32_t j;
int32_t bsize, bsize2;
int32_t leftoverblock;
int32_t startb, stopb;
int32_t ntbytes = 0;
int stop = start + nitems;
bool memcpyed;

/* Check if there are items to extract */
if (nitems == 0) {
  return 0;
}

/* Check that we have enough dest buffer */
if (destsize < nitems * hdr->typesize) {
  BLOSC_TRACE_ERROR("Not enough dest buffer in blosc_getitem()");
  return BLOSC2_ERROR_WRITE_BUFFER;
}

/* Check that we're not requesting items out of bounds */
if (start < 0 || start * hdr->typesize >= hdr->nbytes) {
  return 0;  // Start position is out of bounds
}

/* Check if stop goes beyond the end of the array and adjust if necessary */
if (stop * hdr->typesize > hdr->nbytes) {
  stop = (int)(hdr->nbytes / hdr->typesize);
  if (start >= stop) {
    return 0;  // No items to extract
  }
  nitems = stop - start;  // Update the number of items to extract
}

/* Set the necessary context fields for decompression */
context->nblocks = hdr->nblocks;
context->blocksize = hdr->blocksize;
context->leftover = hdr->leftover;
context->bstarts = (int32_t*)(_src + hdr->header_overhead);
context->src = _src;
context->srcsize = srcsize;
context->destsize = destsize;
context->header_flags = hdr->header_flags;
context->special_type = hdr->special_type;

/* Get the memcpyed bit */
memcpyed = hdr->header_flags & (uint8_t)BLOSC_MEMCPYED;
/* Check if the data is a special type that should be treated as memcpyed */
if (!memcpyed && hdr->special_type) {
  memcpyed = true;  // Treat this as memcpyed
}