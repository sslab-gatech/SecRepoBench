int32_t j, bsize, leftoverblock;
int32_t startb, stopb, bsize2;
int32_t ntbytes = 0;
int32_t stop = start + nitems;
int32_t ebsize;
bool memcpyed = (hdr->flags & BLOSC_MEMCPYED) || (context->special_type != 0);

if (nitems == 0) {
  return 0;
}

if (destsize < (int32_t)hdr->typesize * nitems) {
  BLOSC_TRACE_ERROR("Destination buffer size is too small");
  return BLOSC2_ERROR_WRITE_BUFFER;
}

if ((start < 0) || (start > hdr->nbytes / hdr->typesize) ||
    (stop > hdr->nbytes / hdr->typesize)) {
  BLOSC_TRACE_ERROR("Start or stop are out of bounds");
  return BLOSC2_ERROR_INVALID_PARAM;
}

if (memcpyed) {
  if (hdr->nbytes > srcsize) {
    return BLOSC2_ERROR_READ_BUFFER;
  }
  memcpy((uint8_t *)dest, (uint8_t *)src + context->header_overhead + start * hdr->typesize,
         (unsigned int)(hdr->typesize * nitems));
  return (int32_t)(hdr->typesize * nitems);
}