uint8_t* _src = (uint8_t*)(src);  /* current pos for source buffer */
  int32_t j;
  int32_t bsize, bsize2, leftoverblock;
  int32_t startb, stopb;
  int32_t stop = start + nitems;
  int32_t ntbytes = 0;
  int32_t ebsize;
  bool memcpyed = hdr->flags & (uint8_t)BLOSC_MEMCPYED;

  /* Check if we need to extract anything */
  if ((nitems == 0) || (hdr->nbytes == 0)) {
    return 0;
  }

  /* Check whether the parameters are valid */
  if ((start < 0) || (nitems < 0) || 
      ((start + nitems) > (int)(hdr->nbytes / hdr->typesize))) {
    BLOSC_TRACE_ERROR("Invalid start/nitems or chunk parameters.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  /* Check if the destination buffer is large enough */
  if (destsize < (int32_t)(nitems * hdr->typesize)) {
    BLOSC_TRACE_ERROR("Not enough space in destination buffer.");
    return BLOSC2_ERROR_WRITE_BUFFER;
  }

  /* Check if we are in a special type */
  if (context->special_type != 0) {
    memcpyed = true;  // treat special values as memcpyed
  }