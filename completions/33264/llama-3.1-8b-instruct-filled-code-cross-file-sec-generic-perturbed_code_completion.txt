// <MASK>
// Initialize variables for tracking uncompressed bytes, block sizes, and index positions.
// Calculate the stopping position based on the start position and number of items.
// Check if there are no items to process and return early if so.
// Validate that the destination buffer is large enough for the decompressed data.
// Set up block start positions based on the source buffer and context.
// Verify that the start and stop positions are within valid bounds for the data.
// Determine if the data should be treated as memcpyed based on header flags or context type.
// Handle special cases for data that is memcpyed or has specific characteristics.
if (context->do_compress) {
  // Compression mode
  if (memcpyed) {
    // memcpyed data
    for (j = 0; j < context->nblocks; j++) {
      bsize = context->blocksize;
      leftoverblock = 0;
      if ((j == context->nblocks - 1) && (context->leftover > 0)) {
        bsize = context->leftover;
        leftoverblock = 1;
      }
      // Calculate start and stop positions for this block
      startb = start * context->typesize - j * context->blocksize;
      stopb = stop * context->typesize - j * context->blocksize;
      if (stopb <= 0) {
        // We can exit as soon as this block is beyond stop
        break;
      }
      if (startb >= context->blocksize) {
        continue;
      }
      if (startb < 0) {
        startb = 0;
      }
      if (stopb > context->blocksize) {
        stopb = context->blocksize;
      }
      bsize2 = stopb - startb;
      // Copy memcpyed data to destination
      memcpy(context->dest + context->header_overhead + j * context->blocksize,
             context->src + j * context->blocksize, (unsigned int)bsize);
      cbytes = (int32_t)bsize;
    }
  } else {
    // Regular compression
    for (j = 0; j < context->nblocks; j++) {
      bsize = context->blocksize;
      leftoverblock = 0;
      if ((j == context->nblocks - 1) && (context->leftover > 0)) {
        bsize = context->leftover;
        leftoverblock = 1;
      }
      // Calculate start and stop positions for this block
      startb = start * context->typesize - j * context->blocksize;
      stopb = stop * context->typesize - j * context->blocksize;
      if (stopb <= 0) {
        // We can exit as soon as this block is beyond stop
        break;
      }
      if (startb >= context->blocksize) {
        continue;
      }
      if (startb < 0) {
        startb = 0;
      }
      if (stopb > context->blocksize) {
        stopb = context->blocksize;
      }
      bsize2 = stopb - startb;
      // Regular compression
      cbytes = blosc_c(context->serial_context, bsize, leftoverblock, ntbytes,
                       context->destsize, context->src, j * context->blocksize,
                       context->dest + ntbytes, tmp, tmp2);
      if (cbytes == 0) {
        ntbytes = 0;              /* uncompressible data */
        break;
      }
      ntbytes += cbytes;
    }
  }
} else {
  // Decompression mode
  for (j = 0; j < context->nblocks; j++) {
    bsize = context->blocksize;
    leftoverblock = 0;
    if ((j == context->nblocks - 1) && (context->leftover > 0)) {
      bsize = context->leftover;
      leftoverblock = 1;
    }
    // Calculate start and stop positions for this block
    startb = start * context->typesize - j * context->blocksize;
    stopb = stop * context->typesize - j * context->blocksize;
    if (stopb <= 0) {
      // We can exit as soon as this block is beyond stop
      break;
    }
    if (startb >= context->blocksize) {
      continue;
    }
    if (startb < 0) {
      startb = 0;
    }
    if (stopb > context->blocksize) {
      stopb = context->blocksize;
    }
    bsize2 = stopb - startb;
    // Regular decompression
    int32_t src_offset = memcpyed?
      context->header_overhead + j * context->blocksize : sw32_(context->bstarts + j);
    cbytes = blosc_d(context->serial_context, bsize, leftoverblock, memcpyed,
                     context->src, context->srcsize, src_offset, j,
                     context->dest, j * context->blocksize, tmp, tmp2);
    if (cbytes < 0) {
      ntbytes = cbytes;         /* error in blosc_c or blosc_d */
      break;
    }
    ntbytes += cbytes;
  }
}