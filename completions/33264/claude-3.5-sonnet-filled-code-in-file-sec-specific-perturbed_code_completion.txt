uint8_t* _src = (uint8_t*)src;
int32_t nbytes = 0;
int32_t cbytes = 0;
int32_t blocksize = 0;
int32_t j, bsize, leftoverblock;
int32_t nblocks;
int32_t leftover = 0;
int32_t nblocks_;
int32_t bstarts;
int32_t ebsize;
int32_t ntbytes = 0;

// Initialize variables
nbytes = sw32_(_src + BLOSC2_CHUNK_NBYTES);
cbytes = sw32_(_src + BLOSC2_CHUNK_CBYTES);
blocksize = sw32_(_src + BLOSC2_CHUNK_BLOCKSIZE);
if (nbytes > destsize) {
  return BLOSC2_ERROR_WRITE_BUFFER;
}

// Calculate nblocks and leftover
nblocks = nbytes / blocksize;
leftover = nbytes % blocksize;
nblocks_ = nblocks;

// Handle special cases
if (context->special_type != 0) {
  return nbytes;
}

// Set up bstarts
bstarts = context->header_overhead;
if (sizeof(void*) == 8) {
  ebsize = blocksize + sizeof(int64_t);
} else {
  ebsize = blocksize + sizeof(int32_t);
}

// Validate start and stop positions
if (start < 0 || start > nbytes) {
  return BLOSC2_ERROR_INVALID_PARAM;
}
if ((start + nitems) > nbytes) {
  return BLOSC2_ERROR_INVALID_PARAM;
}

// Determine if data is memcpyed
bool memcpyed = (context->header_flags & (uint8_t)BLOSC_MEMCPYED) &&
                (cbytes == nbytes + context->header_overhead);