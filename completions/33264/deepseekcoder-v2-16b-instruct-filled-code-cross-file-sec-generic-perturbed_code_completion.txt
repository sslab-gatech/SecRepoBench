// Calculate the stopping position based on the start position and number of items.
  int32_t stop = start + nitems;

  // Check if there are no items to process and return early if so.
  if (nitems <= 0 || start < 0 || stop > context->nblocks) {
    return -1; // Invalid start or stop position
  }

  // Validate that the destination buffer is large enough for the decompressed data.
  if (destsize < nitems * hdr->typesize) {
    return -1; // Destination buffer too small
  }

  // Set up block start positions based on the source buffer and context.
  int32_t* bstarts = context->bstarts;
  int32_t bsize, startb, stopb, bsize2;
  int32_t ebsize = hdr->blocksize + hdr->typesize * (signed)sizeof(int32_t);
  uint8_t* tmp2 = scontext->tmp2;
  int32_t src_offset;
  int32_t cbytes;
  int32_t ntbytes = 0;
  bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;
  bool dict_training = context->use_dict && (context->dict_cdict == NULL);
  bool get_single_block;

  for (j = 0; j < context->nblocks; j++) {
    bsize = hdr->blocksize;
    int leftoverblock = 0;
    if ((j == context->nblocks - 1) && (context->leftover > 0)) {
      bsize = context->leftover;
      leftoverblock = 1;
    }

    // Compute start & stop for each block
    startb = start * hdr->typesize - j * hdr->blocksize;
    stopb = stop * hdr->typesize - j * hdr->blocksize;
    if (stopb <= 0) {
      break; // We can exit as soon as this block is beyond stop
    }
    if (startb < 0) {
      startb = 0;
    }
    if (stopb > hdr->blocksize) {
      stopb = hdr->blocksize;
    }
    bsize2 = stopb - startb;

    // Do the actual data copy
    get_single_block = ((startb == 0) && (bsize == nitems * hdr->typesize));
    uint8_t* tmp2 = get_single_block ? dest : scontext->tmp2;

    // If memcpyed we don't have a bstarts section (because it is not needed)
    src_offset = memcpyed ?
      context->header_overhead + j * bsize : sw32_(context->bstarts + j);

    cbytes = blosc_d(context->serial_context, bsize, leftoverblock, memcpyed,
                     src, srcsize, src_offset, j,
                     tmp2, 0, scontext->tmp, scontext->tmp3);
    if (cbytes < 0) {
      ntbytes = cbytes;
      break;
    }
    if (!get_single_block) {
      // Copy to destination
      memcpy((uint8_t *) dest + ntbytes, tmp2 + startb, (unsigned int) bsize2);
    }
    ntbytes += bsize2;
  }

  return ntbytes;