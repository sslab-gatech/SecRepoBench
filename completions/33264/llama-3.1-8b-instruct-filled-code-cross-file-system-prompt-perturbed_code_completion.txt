// <MASK>
if (context->nthreads == 1) {
  /* Serial mode */
  ntbytes = serial_blosc(thread_context);
}
else {
  /* Parallel mode */
  int32_t cbytes;
  int32_t ntbytes = 0;
  for (j = 0; j < context->nblocks; j++) {
    bsize = hdr->blocksize;
    leftoverblock = 0;
    if ((j == context->nblocks - 1) && (context->leftover > 0)) {
      bsize = context->leftover;
      leftoverblock = 1;
    }

    /* Compute start & stop for each block */
    startb = start * hdr->typesize - j * hdr->blocksize;
    stopb = stop * hdr->typesize - j * hdr->blocksize;
    if (stopb <= 0) {
      // We can exit as soon as this block is beyond stop
      break;
    }
    if (startb >= hdr->blocksize) {
      continue;
    }
    if (startb < 0) {
      startb = 0;
    }
    if (stopb > hdr->blocksize) {
      stopb = hdr->blocksize;
    }
    bsize2 = stopb - startb;

    /* Do the actual data copy */
    // Regular decompression.  Put results in tmp2.
    // If the block is aligned and the worst case fits in destination, let's avoid a copy
    bool get_single_block = ((startb == 0) && (bsize == nitems * hdr->typesize));
    uint8_t* tmp2 = get_single_block? dest : scontext->tmp2;

    // If memcpyed we don't have a bstarts section (because it is not needed)
    int32_t src_offset = memcpyed?
      context->header_overhead + j * bsize : sw32_(context->bstarts + j);

    cbytes = pipeline_d(thread_context, bsize, tmp2, startb, _src, scontext->tmp, scontext->tmp2,
                         context->last_filter_index, j);
    if (cbytes < 0) {
      ntbytes = cbytes;
      break;
    }
    if (!get_single_block) {
      /* Copy to destination */
      memcpy((uint8_t *) dest + ntbytes, tmp2 + startb, (unsigned int) bsize2);
    }
    ntbytes += bsize2;
  }
}