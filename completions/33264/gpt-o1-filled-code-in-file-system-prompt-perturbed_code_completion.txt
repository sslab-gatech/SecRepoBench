int stop = start + nitems;
  int ntbytes = 0;
  bool memcpyed;

  /* If requested no items, return early */
  if (nitems == 0) {
    return 0;
  }

  /* Check for enough space in dest */
  if ((int64_t)destsize < (int64_t)hdr->typesize * nitems) {
    BLOSC_TRACE_ERROR("Not enough space in 'dest': need %lld bytes but have %d",
                      (long long)((int64_t)hdr->typesize * nitems), destsize);
    return BLOSC2_ERROR_WRITE_BUFFER;
  }

  /* Check that start and stop positions are valid */
  if (start < 0 || nitems < 0) {
    BLOSC_TRACE_ERROR("'start' and 'nitems' must be >= 0.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }
  if (((int64_t)stop * hdr->typesize) > hdr->nbytes) {
    BLOSC_TRACE_ERROR("Requested range goes beyond the buffer size.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  /* Check whether data is memcpy'ed or special */
  memcpyed = ((hdr->flags & BLOSC_MEMCPYED) != 0) || (context->special_type != BLOSC2_NO_SPECIAL);

  /* Compute absolute stop in bytes */
  int64_t start_bytes = (int64_t)start * hdr->typesize;
  int64_t stop_bytes = (int64_t)stop * hdr->typesize;

  /* Traverse all blocks and decompress/copy only the sub-range we need */
  int j;
  for (j = 0; j < context->nblocks; j++) {
    int32_t bsize = hdr->blocksize;
    int leftoverblock = 0;
    if ((j == context->nblocks - 1) && (context->leftover > 0)) {
      bsize = context->leftover;
      leftoverblock = 1;
    }

    /* Compute start & stop byte offsets for this block */
    int64_t block_start = (int64_t)j * hdr->blocksize;
    int64_t block_stop  = block_start + bsize;
    /* Check if the [start_bytes, stop_bytes) range intersects with this block */
    if (block_stop <= start_bytes) {
      /* Data needed starts after this block ends, skip this block */
      continue;
    }
    if (block_start >= stop_bytes) {
      /* Data needed ends before this block starts, we can stop now */
      break;
    }

    /* Determine subrange within this block */
    int64_t sub_start = (start_bytes > block_start) ? (start_bytes - block_start) : 0;
    int64_t sub_stop  = (stop_bytes < block_stop) ? (stop_bytes - block_start) : bsize;
    int32_t chunk_bytes = (int32_t)(sub_stop - sub_start);

    /* Decompress the entire block into a tmp buffer or direct if possible */
    bool get_whole_block = ((sub_start == 0) && (chunk_bytes == bsize));
    uint8_t* tmp2 = get_whole_block ? (uint8_t*)dest + ntbytes : scontext->tmp2;

    /* Compute the compressed offset in src */
    int32_t src_offset;
    if (memcpyed) {
      /* For memcpyed data, blocks are just stored in linear order (no bstarts) */
      src_offset = context->header_overhead + j * hdr->blocksize;
    }
    else {
      /* Otherwise, read block offset from bstarts area */
      src_offset = sw32_(context->bstarts + j);
    }

    /* Decompress (or memcpy) block */
    int cbytes = blosc_d(scontext, bsize, leftoverblock, memcpyed,
                         src, srcsize, src_offset, j,
                         tmp2, 0, scontext->tmp, scontext->tmp3);
    if (cbytes < 0) {
      /* Decompression error */
      return cbytes;
    }

    /* If we have to copy just a subrange into dest */
    if (!get_whole_block) {
      memcpy((uint8_t*)dest + ntbytes, tmp2 + sub_start, (size_t)chunk_bytes);
    }

    ntbytes += chunk_bytes;
    if (ntbytes > (int64_t)destsize) {
      BLOSC_TRACE_ERROR("Destination buffer overrun.");
      return BLOSC2_ERROR_WRITE_BUFFER;
    }

    /* If we've copied all requested data, stop */
    if (ntbytes >= (nitems * (int)hdr->typesize)) {
      break;
    }
  }

  return ntbytes;