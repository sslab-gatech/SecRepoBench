typesize, src, _dest, bsize_);
        break;
      case BLOSC2_SPECIAL_NANS:
        // All NaNs
        rc = set_nans(typesize, src, bsize_);
        break;
      default:
        memcpy(_dest, src, bsize_);
    }
    if (rc < 0) {
      return rc;
    }
    if (context->postfilter != NULL) {
      // Apply postfilter
      blosc2_postfilter_params postparams;
      memcpy(&postparams, context->postparams, sizeof(postparams));
      postparams.in = _dest;
      postparams.out = dest + dest_offset;
      postparams.size = bsize;
      postparams.typesize = typesize;
      postparams.offset = nblock * context->blocksize;
      postparams.tid = thread_context->tid;
      postparams.ttmp = thread_context->tmp;
      postparams.ttmp_nbytes = thread_context->tmp_nbytes;
      postparams.ctx = context;

      if (context->postfilter(&postparams) != 0) {
        BLOSC_TRACE_ERROR("Execution of postfilter function failed");
        return BLOSC2_ERROR_POSTFILTER;
      }
    }
    return bsize_;
  }

  // Calculate the number of streams
  if (!dont_split && !leftoverblock) {
    nstreams = (int32_t)typesize;
  }
  else {
    nstreams = 1;
  }
  neblock = bsize / nstreams;

  // Process the filter pipeline
  _dest = dest + dest_offset;
  if (context->postfilter != NULL) {
    // We are making use of a postfilter, so use a temp for destination
    _dest = tmp;
  }
  int last_filter_index = last_filter(filters, 'd');
  int errcode = pipeline_d(thread_context, bsize, _dest, dest_offset, src, tmp, tmp2, last_filter_index, nblock);
  if (errcode < 0) {
    return errcode;
  }

  // If we have a postfilter, we need to copy the result to the final destination
  if (context->postfilter != NULL) {
    memcpy(dest + dest_offset, _dest, bsize);
  }

  return bsize;
}


/* Compress a single block */
static int blosc_compress_block(blosc2_context* context, int32_t bsize,
                                int32_t leftoverblock, uint8_t* dest, uint8_t* tmp,
                                uint8_t* tmp2, uint8_t* tmp3, int32_t nblock) {
  int32_t destsize = context->destsize;
  int32_t ntbytes = 0;
  int32_t ctbytes = 0;
  int32_t typesize = context->typesize;
  const uint8_t* src = context->src;
  int32_t srcsize = context->srcsize;
  int32_t src_offset = 0;
  int32_t dest_offset = nblock * context->blocksize;

  if (context->block_maskin != NULL && !context->block_maskin[nblock]) {
    // Do not compress, but act as if we successfully compressed everything
    return bsize;
  }

  if (context->use_dict && context->dict_cdict != NULL) {
    // Use dictionary compression
    int32_t cbytes = 0;
    if (context->compcode == BLOSC_ZSTD) {
      cbytes = ZSTD_compress_usingCDict(context->dict_cdict, dest, destsize,
                                         src + src_offset, bsize);
    }
    if (cbytes == 0) {
      // No compression, just copy the data
      memcpy(dest, src + src_offset, bsize);
      return bsize;
    }
    if (cbytes < 0) {
      return BLOSC2_ERROR_DATA;
    }
    _sw32(dest - 4, cbytes);
    return cbytes;
  }

  // Compress the block
  ctbytes = blosc_c(context, bsize, leftoverblock, ntbytes, destsize, src, src_offset, dest, tmp, tmp2);
  if (ctbytes < 0) {
    return ctbytes;
  }

  // Write the compressed data to the destination buffer
  if (ctbytes == 0) {
    // No compression, just copy the data
    memcpy(dest, src + src_offset, bsize);
    return bsize;
  }

  // Write the compressed size to the destination buffer
  _sw32(dest - 4, ctbytes);

  return ctbytes;
}


/* Decompress a single block */
static int blosc_decompress_block(blosc2_context* context, int32_t bsize,
                                  uint8_t* dest, uint8_t* tmp, uint8_t* tmp2,
                                  int32_t nblock) {
  int32_t destsize = context->destsize;
  int32_t srcsize = context->srcsize;
  int32_t src_offset = 0;
  int32_t dest_offset = nblock * context->blocksize;
  const uint8_t* src = context->src;

  if (context->block_maskin != NULL && !context->block_maskin[nblock]) {
    // Do not decompress, but act as if we successfully decompressed everything
    return bsize;
  }

  // Decompress the block
  int32_t dbytes = blosc_d(context, bsize, 0, false, src, srcsize, src_offset, nblock, dest, dest_offset, tmp, tmp2);
  if (dbytes < 0) {
    return dbytes;
  }

  return dbytes;
}


/* Compress a chunk */
static int blosc_compress_chunk(blosc2_context* context, int32_t nchunks,
                                uint8_t* dest, uint8_t* tmp, uint8_t* tmp2,
                                uint8_t* tmp3) {
  int32_t destsize = context->destsize;
  int32_t typesize = context->typesize;
  int32_t blocksize = context->blocksize;
  int32_t nblocks = context->nblocks;
  int32_t leftoverblock = context->leftover;
  int32_t ntbytes = 0;
  int32_t ctbytes = 0;
  int32_t src_offset = 0;
  int32_t dest_offset = 0;
  const uint8_t* src = context->src;

  for (int32_t nblock = 0; nblock < nblocks; nblock++) {
    int32_t bsize = (nblock == nblocks - 1) ? leftoverblock : blocksize;
    ctbytes = blosc_compress_block(context, bsize, (nblock == nblocks - 1), dest, tmp, tmp2, tmp3, nblock);
    if (ctbytes < 0) {
      return ctbytes;
    }
    ntbytes += bsize;
    dest_offset += ctbytes;
  }

  return ntbytes;
}


/* Decompress a chunk */
static int blosc_decompress_chunk(blosc2_context* context, int32_t nchunks,
                                  uint8_t* dest, uint8_t* tmp, uint8_t* tmp2) {
  int32_t destsize = context->destsize;
  int32_t blocksize = context->blocksize;
  int32_t nblocks = context->nblocks;
  int32_t leftoverblock = context->leftover;
  int32_t ntbytes = 0;
  int32_t dbytes = 0;
  int32_t src_offset = 0;
  int32_t dest_offset = 0;
  uint8_t* src = context->src;

  for (int32_t nblock = 0; nblock < nblocks; nblock++) {
    int32_t bsize = (nblock == nblocks - 1) ? leftoverblock : blocksize;
    dbytes = blosc_decompress_block(context, bsize, dest, tmp, tmp2, nblock);
    if (dbytes < 0) {
      return dbytes;
    }
    ntbytes += bsize;
    dest_offset += bsize;
  }

  return ntbytes;
}


/* Compress a super-chunk */
static int blosc_compress_schunk(blosc2_context* context, uint8_t* dest,
                                  uint8_t* tmp, uint8_t* tmp2, uint8_t* tmp3) {
  int32_t destsize = context->destsize;
  int32_t typesize = context->typesize;
  int32_t blocksize = context->blocksize;
  int32_t nchunks = context->nchunks;
  int32_t ntbytes = 0;
  int32_t ctbytes = 0;
  int32_t src_offset = 0;
  int32_t dest_offset = 0;
  const uint8_t* src = context->src;

  for (int32_t nchunk = 0; nchunk < nchunks; nchunk++) {
    int32_t csize = (nchunk == nchunks - 1) ? context->chunksize : blocksize;
    ctbytes = blosc_compress_chunk(context, nchunk, dest, tmp, tmp2, tmp3);
    if (ctbytes < 0) {
      return ctbytes;
    }
    ntbytes += csize;
    dest_offset += ctbytes;
  }

  return ntbytes;
}


/* Decompress a super-chunk */
static int blosc_decompress_schunk(blosc2_context* context, uint8_t* dest,
                                   uint8_t* tmp, uint8_t* tmp2) {
  int32_t destsize = context->destsize;
  int32_t blocksize = context->blocksize;
  int32_t nchunks = context->nchunks;
  int32_t ntbytes = 0;
  int32_t dbytes = 0;
  int32_t src_offset = 0;
  int32_t dest_offset = 0;
  uint8_t* src = context->src;

  for (int32_t nchunk = 0; nchunk < nchunks; nchunk++) {
    int32_t csize = (nchunk == nchunks - 1) ? context->chunksize : blocksize;
    dbytes = blosc_decompress_chunk(context, nchunk, dest, tmp, tmp2);
    if (dbytes < 0) {
      return dbytes;
    }
    ntbytes += csize;
    dest_offset += csize;
  }

  return ntbytes;
}


/* Initialize the context for compression */
static int blosc_init_compress(blosc2_context* context) {
  int rc;

  if (context->src == NULL) {
    BLOSC_TRACE_ERROR("No input data to compress.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  if (context->dest == NULL) {
    BLOSC_TRACE_ERROR("No output buffer to store compressed data.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  if (context->srcsize <= 0) {
    BLOSC_TRACE_ERROR("Invalid input size.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  if (context->destsize <= 0) {
    BLOSC_TRACE_ERROR("Invalid output buffer size.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  if (context->blocksize <= 0) {
    BLOSC_TRACE_ERROR("Invalid blocksize.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  if (context->typesize <= 0) {
    BLOSC_TRACE_ERROR("Invalid typesize.");
    return BLOSC2_ERROR_INVALID_PARAM