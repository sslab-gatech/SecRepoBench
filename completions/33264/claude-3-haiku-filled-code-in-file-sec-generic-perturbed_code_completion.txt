int32_t start, stop, startb, stopb, bsize2, ntbytes = 0;
bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;

// Calculate the stopping position based on the start position and number of items
stop = start + nitems;

// Check if there are no items to process and return early if so
if (start >= context->sourcesize / context->typesize || start >= stop) {
    return 0;
}

// Validate that the destination buffer is large enough for the decompressed data
if (destsize < context->sourcesize) {
    BLOSC_TRACE_ERROR("Destination buffer is not large enough to hold decompressed data.");
    return BLOSC2_ERROR_WRITE_BUFFER;
}

// Set up block start positions based on the source buffer and context
if (!memcpyed && context->special_type != BLOSC2_SPECIAL_VALUE && context->special_type != BLOSC2_SPECIAL_NAN) {
    context->bstarts = (int32_t *) (context->src + context->header_overhead);
}

// Verify that the start and stop positions are within valid bounds for the data
if (start < 0 || stop > context->sourcesize / context->typesize) {
    BLOSC_TRACE_ERROR("Start or stop position is out of bounds for the data.");
    return BLOSC2_ERROR_DATA;
}

// Determine if the data should be treated as memcpyed based on header flags or context type
if (memcpyed || context->special_type != BLOSC2_NO_SPECIAL) {
    // Handle special cases for data that is memcpyed or has specific characteristics
    if (context->special_type == BLOSC2_SPECIAL_VALUE) {
        int32_t nitems_to_set = (stop - start) * context->typesize;
        int32_t set_items = set_values(context->typesize, context->src, dest + start * context->typesize, nitems_to_set);
        if (set_items < 0) {
            BLOSC_TRACE_ERROR("set_values failed");
            return BLOSC2_ERROR_DATA;
        }
        return set_items;
    }
    else if (context->special_type == BLOSC2_SPECIAL_NAN) {
        int32_t nitems_to_set = (stop - start) * context->typesize;
        int32_t set_items = set_nans(context->typesize, dest + start * context->typesize, nitems_to_set);
        if (set_items < 0) {
            BLOSC_TRACE_ERROR("set_nans failed");
            return BLOSC2_ERROR_DATA;
        }
        return set_items;
    }
    else {
        // Memcpy the data
        memcpy(dest + start * context->typesize, context->src + context->header_overhead + start * context->typesize,
               (size_t)((stop - start) * context->typesize));
        return (stop - start) * context->typesize;
    }
}