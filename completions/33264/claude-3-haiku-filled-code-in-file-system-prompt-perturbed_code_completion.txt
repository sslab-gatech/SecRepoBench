int32_t start, stop;
int32_t ntbytes = 0;
int32_t j;
int32_t bsize, leftoverblock;
bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;

// Compute start & stop for each block
start = start * header->typesize;
stop = stop * header->typesize;

for (j = 0; j < context->nblocks; j++) {
    bsize = header->blocksize;
    leftoverblock = 0;
    if ((j == context->nblocks - 1) && (context->leftover > 0)) {
        bsize = context->leftover;
        leftoverblock = 1;
    }

    if (start >= bsize) {
        // We can exit as soon as this block is beyond start
        start -= bsize;
        stop -= bsize;
        continue;
    }
    if (stop <= 0) {
        // We can exit as soon as this block is beyond stop
        break;
    }

    int32_t startb = start;
    int32_t stopb = stop;
    if (startb < 0) {
        startb = 0;
    }
    if (stopb > bsize) {
        stopb = bsize;
    }
    int32_t bsize2 = stopb - startb;

    // Do the actual data copy
    uint8_t* tmp2 = (startb == 0 && bsize2 == nitems * header->typesize) ? dest : scontext->tmp2;
    int cbytes = blosc_d(scontext, bsize, leftoverblock, memcpyed,
                        src, srcsize, src_offset, j,
                        tmp2, 0, scontext->tmp, scontext->tmp3);
    if (cbytes < 0) {
        ntbytes = cbytes;
        break;
    }
    if (tmp2 != dest) {
        memcpy((uint8_t*)dest + ntbytes, tmp2 + startb, (unsigned int)bsize2);
    }
    ntbytes += bsize2;

    start -= bsize;
    stop -= bsize;
}

return ntbytes;