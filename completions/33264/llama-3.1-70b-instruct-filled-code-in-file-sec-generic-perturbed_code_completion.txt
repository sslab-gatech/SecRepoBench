// Initialize variables for tracking uncompressed bytes, block sizes, and index positions.
int32_t ntbytes = 0;
int32_t bsize;
int32_t leftoverblock;
int32_t startb;
int32_t stopb;
int32_t bsize2;
int32_t ebsize = hdr->blocksize + hdr->typesize * (signed)sizeof(int32_t);
struct thread_context* scontext = context->serial_context;
/* Resize the temporaries in serial context if needed */
if (hdr->blocksize > scontext->tmp_blocksize) {
  my_free(scontext->tmp);
  scontext->tmp_nbytes = (size_t)4 * ebsize;
  scontext->tmp = my_malloc(scontext->tmp_nbytes);
  BLOSC_ERROR_NULL(scontext->tmp, BLOSC2_ERROR_MEMORY_ALLOC);
  scontext->tmp2 = scontext->tmp + ebsize;
  scontext->tmp3 = scontext->tmp2 + ebsize;
  scontext->tmp4 = scontext->tmp3 + ebsize;
  scontext->tmp_blocksize = (int32_t)hdr->blocksize;
}

// Calculate the stopping position based on the start position and number of items.
int32_t j;
int32_t nblocks = context->nblocks;
int32_t leftover = context->leftover;
int32_t blocksize = context->blocksize;
int32_t typesize = context->typesize;
int32_t start = start;
int32_t nitems = nitems;
int32_t stop = start + nitems;
if (stop > (nblocks * blocksize + leftover) / typesize) {
  stop = (nblocks * blocksize + leftover) / typesize;
}

// Check if there are no items to process and return early if so.
if (nitems == 0) {
  return 0;
}

// Validate that the destination buffer is large enough for the decompressed data.
if (destsize < nitems * typesize) {
  BLOSC_TRACE_ERROR("Destination buffer is too small for decompressed data.");
  return BLOSC2_ERROR_WRITE_BUFFER;
}

// Set up block start positions based on the source buffer and context.
int32_t* bstarts = context->bstarts;
const uint8_t* src = context->src;
int32_t srcsize = context->srcsize;

// Verify that the start and stop positions are within valid bounds for the data.
if (start < 0 || stop > (nblocks * blocksize + leftover) / typesize) {
  BLOSC_TRACE_ERROR("Start or stop position is out of bounds.");
  return BLOSC2_ERROR_DATA;
}

// Determine if the data should be treated as memcpyed based on header flags or context type.
bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;
if (!context->do_compress && context->special_type) {
  // Fake a runlen as if its a memcpyed chunk
  memcpyed = true;
}

// Handle special cases for data that is memcpyed or has specific characteristics.
if (memcpyed) {
  // If memcpyed, we can directly copy the data from the source buffer to the destination buffer.
  int32_t src_offset = context->header_overhead + start * typesize;
  if (srcsize < src_offset + nitems * typesize) {
    BLOSC_TRACE_ERROR("Not enough input to read block.");
    return BLOSC2_ERROR_READ_BUFFER;
  }
  memcpy(dest, src + src_offset, (unsigned int)nitems * typesize);
  return nitems * typesize;
}

// Regular decompression.
for (j = 0; j < context->nblocks; j++) {
  bsize = blocksize;
  leftoverblock = 0;
  if ((j == context->nblocks - 1) && (leftover > 0)) {
    bsize = leftover;
    leftoverblock = 1;
  }

  // Compute start & stop for each block
  startb = start * typesize - j * blocksize;
  stopb = stop * typesize - j * blocksize;
  if (stopb <= 0) {
    // We can exit as soon as this block is beyond stop
    break;
  }
  if (startb >= blocksize) {
    continue;
  }
  if (startb < 0) {
    startb = 0;
  }
  if (stopb > blocksize) {
    stopb = blocksize;
  }
  bsize2 = stopb - startb;

  // Do the actual data copy
  // Regular decompression.  Put results in tmp2.
  // If the block is aligned and the worst case fits in destination, let's avoid a copy
  bool get_single_block = ((startb == 0) && (bsize == nitems * typesize));
  uint8_t* tmp2 = get_single_block? dest : scontext->tmp2;

  // If memcpyed we don't have a bstarts section (because it is not needed)
  int32_t src_offset = memcpyed?
      context->header_overhead + j * bsize : sw32_(bstarts + j);

  int cbytes = blosc_d(context->serial_context, bsize, leftoverblock, memcpyed,
                       src, srcsize, src_offset, j,
                       tmp2, 0, scontext->tmp, scontext->tmp3);
  if (cbytes < 0) {
    ntbytes = cbytes;
    break;
  }
  if (!get_single_block) {
    // Copy to destination
    memcpy((uint8_t *) dest + ntbytes, tmp2 + startb, (unsigned int) bsize2);
  }
  ntbytes += bsize2;
}

return ntbytes;