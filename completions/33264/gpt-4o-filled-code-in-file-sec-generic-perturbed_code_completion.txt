int32_t ntbytes = 0;  // Initialize the number of uncompressed bytes
  int32_t bsize, bsize2;  // Block size and adjusted block size
  int32_t startb, stopb;  // Start and stop positions within a block
  int32_t j;  // Block index

  int32_t stop = start + nitems;  // Calculate the stopping position

  if (nitems == 0) {
    return 0;  // No items to process
  }

  if (destsize < nitems * hdr->typesize) {
    return BLOSC2_ERROR_WRITE_BUFFER;  // Destination buffer is too small
  }

  context->bstarts = (int32_t*)(_src + context->header_overhead);

  if (start < 0 || stop > hdr->nbytes / hdr->typesize) {
    return BLOSC2_ERROR_INVALID_PARAM;  // Invalid start or stop positions
  }

  bool memcpyed = (hdr->flags & BLOSC_MEMCPYED) || (hdr->blosc2_flags & BLOSC2_SPECIAL_MASK);

  if (memcpyed) {
    if (hdr->blosc2_flags & BLOSC2_SPECIAL_VALUE) {
      return set_values(hdr->typesize, _src, dest, nitems * hdr->typesize);
    }
    else if (hdr->blosc2_flags & BLOSC2_SPECIAL_NAN) {
      return set_nans(hdr->typesize, dest, nitems * hdr->typesize);
    }
    else if (hdr->blosc2_flags & BLOSC2_SPECIAL_ZERO) {
      memset(dest, 0, nitems * hdr->typesize);
      return nitems * hdr->typesize;
    }
    else if (hdr->blosc2_flags & BLOSC2_SPECIAL_UNINIT) {
      return nitems * hdr->typesize;
    }
  }