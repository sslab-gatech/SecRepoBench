int32_t stop = start + nitems;
  if (nitems <= 0) {
    return 0;
  }
  if (destsize < (size_t)(stop - start) * hdr->typesize) {
    BLOSC_TRACE_ERROR("Destination buffer is too small for decompressed data.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  uint8_t* block_start_positions = (uint8_t*)my_malloc(context->nblocks * sizeof(uint32_t));
  if (!block_start_positions) {
    BLOSC_TRACE_ERROR("Failed to allocate memory for block start positions.");
    return BLOSC2_ERROR_MEMORY_ALLOC;
  }

  for (int32_t i = 0; i < context->nblocks; ++i) {
    block_start_positions[i] = context->header_overhead + i * hdr->blocksize;
  }

  if (start < 0 || stop > context->nblocks * hdr->blocksize / hdr->typesize) {
    my_free(block_start_positions);
    BLOSC_TRACE_ERROR("Start or stop positions are out of bounds.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  bool memcpyed = hdr->flags & BLOSC_MEMCPYED;
  if (context->special_type && !context->do_compress) {
    memcpyed = true;
  }

  if (memcpyed) {
    memcpy(dest, _src + start * hdr->typesize, (unsigned int)((stop - start) * hdr->typesize));
    my_free(block_start_positions);
    return (stop - start) * hdr->typesize;
  }