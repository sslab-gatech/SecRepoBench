int32_t ntbytes = 0;                /* Number of transferred bytes */
  int32_t bsize, bsize2, leftoverblock;  /* Current, transferred and leftover block sizes */
  int32_t ebsize;                      /* effective block size */
  int j, startb, stopb;               /* block counters */
  bool memcpyed = hdr->flags & BLOSC_MEMCPYED;
  int stop = start + nitems;

  if (nitems == 0) {
    return 0;                          /* nothing to do */
  }

  if (destsize < nitems * hdr->typesize) {
    BLOSC_TRACE_ERROR("Destination buffer size too small.");
    return BLOSC2_ERROR_OUTPUT_BUFFER_TOO_SMALL;
  }

  /* Check region boundaries */
  if ((start < 0) || (start * hdr->typesize > context->totalsize)) {
    BLOSC_TRACE_ERROR("Start value is not within valid bounds.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }
  if ((stop < 0) || (stop * hdr->typesize > context->totalsize)) {
    BLOSC_TRACE_ERROR("Stop value is not within valid bounds.");
    return BLOSC2_ERROR_INVALID_PARAM;
  }


  if (memcpyed || context->special_type) {
    if (context->nthreads > 1) {
      BLOSC_TRACE_ERROR("Multithreading not supported for memcpyed or special types.");
      return BLOSC2_ERROR_NOT_SUPPORTED;
    }
    memcpy(dest, _src + start * hdr->typesize, (unsigned int)nitems * hdr->typesize);
    return nitems * hdr->typesize;
  }