int32_t ntbytes = 0;                /* Number of transferred bytes */
  int32_t bsize, bsize2, leftoverblock;  /* Current and remaining block size */
  int32_t ebsize;                      /* effective block size */
  int j, startb, stopb;             /* block counters */
  int stop = start + nitems;        /* stopping position */
  bool memcpyed = false;
  if ((hdr->flags & BLOSC_MEMCPYED) || (context->type == BLOSC_MEMCPYED)) {
    memcpyed = true;
  }

  if (nitems == 0) {
    return 0;                    /* nothing to do */
  }

  if (start < 0 || start + nitems > hdr->nitems) {
    BLOSC_TRACE_ERROR("start or nitems out of bounds");
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  if (destsize < nitems * hdr->typesize) {
    BLOSC_TRACE_ERROR("not enough space for destination buffer");
    return BLOSC2_ERROR_INVALID_PARAM;
  }


  if (memcpyed && (hdr->flags & BLOSC_DOSHUFFLE)) {
    /* We are here because of a shuffle+memcpy combination.  This is
       weird, but it can happen.  In this case, just unshuffle the
       requested elements. */
    uint8_t* tmp = my_malloc(hdr->blocksize);
    BLOSC_ERROR_NULL(tmp, BLOSC2_ERROR_MEMORY_ALLOC);
    int32_t src_offset = context->header_overhead;
    unshuffle(hdr->typesize, hdr->blocksize, _src + src_offset, tmp);
    memcpy(dest, tmp + start * hdr->typesize, nitems * hdr->typesize);
    my_free(tmp);
    return nitems * hdr->typesize;
  }
  else if (memcpyed || context->special_type) {
    /* We are here when data is memcpyed or special.  In this case,
       just copy the requested elements. */
    int32_t src_offset = context->header_overhead + start * hdr->typesize;
    memcpy(dest, _src + src_offset, nitems * hdr->typesize);
    return nitems * hdr->typesize;
  }