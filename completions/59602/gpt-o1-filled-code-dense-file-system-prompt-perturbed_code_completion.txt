case DW_OP_const_type:           /* DWARF5 */
case DW_OP_GNU_const_type: {
    /* First read the CU-relative DIE offset (uses offset_size). */
    READ_UNALIGNED_CK(dbg, operand1, Dwarf_Unsigned, loc_ptr,
        offset_size, error_ptr, section_end);
    loc_ptr  += offset_size;
    offset   += offset_size;

    /* Next read a ULEB block size. */
    DECODE_LEB128_UWORD_LEN_CK(loc_ptr, operand2, leb128_length,
        dbg, error_ptr, section_end);
    offset += leb128_length;

    /* operand3 is a pointer to the data block. */
    operand3 = (Dwarf_Unsigned)(uintptr_t)loc_ptr;
    if ((loc_ptr + operand2) > section_end) {
        _dwarf_error(dbg,error_ptr,DW_DLE_LOCEXPR_OFF_SECTION_END);
        return DW_DLV_ERROR;
    }
    loc_ptr += operand2;
    offset  += operand2;
    }
    break;

case DW_OP_regval_type:           /* DWARF5 */
case DW_OP_GNU_regval_type: {
    /* Two ULEB operands: register number and CU-relative DIE offset. */
    DECODE_LEB128_UWORD_LEN_CK(loc_ptr, operand1, leb128_length,
        dbg, error_ptr, section_end);
    offset += leb128_length;

    DECODE_LEB128_UWORD_LEN_CK(loc_ptr, operand2, leb128_length,
        dbg, error_ptr, section_end);
    offset += leb128_length;
    }
    break;

case DW_OP_convert:        /* DWARF5 */
case DW_OP_reinterpret:    /* DWARF5 */
case DW_OP_GNU_convert:
case DW_OP_GNU_reinterpret: {
    /* A single ULEB for the type DIE offset (or zero). */
    DECODE_LEB128_UWORD_LEN_CK(loc_ptr, operand1, leb128_length,
        dbg, error_ptr, section_end);
    offset += leb128_length;
    }
    break;

case DW_OP_GNU_parameter_ref: {
    /* A 4-byte unsigned integer per the GNU extension. */
    if ((loc_ptr + 4) > section_end) {
        _dwarf_error(dbg,error_ptr,DW_DLE_LOCEXPR_OFF_SECTION_END);
        return DW_DLV_ERROR;
    }
    READ_UNALIGNED_CK(dbg, operand1, Dwarf_Unsigned,
        loc_ptr, 4, error_ptr, section_end);
    loc_ptr += 4;
    offset  += 4;
    }
    break;