case DW_OP_GNU_const_type:           /* DWARF5 */
    // Handle DW_OP_GNU_const_type operation by decoding a CU-relative DIE offset
    // and a subsequent data block size, then obtain the data block based on the
    // size, adjusting the location pointer and offset accordingly.
    //
    // Handle DW_OP_regval_type (and DW_OP_GNU_regval_type) by decoding two
    // unsigned LEB128 values: one representing a register number and the other
    // a CU-relative DIE offset.
    //
    // Handle DW_OP_convert and DW_OP_reinterpret (and their GNU counterparts)
    // by decoding an unsigned LEB128 value representing a DIE offset or zero.
    //
    // Handle DW_OP_GNU_parameter_ref by reading a 4-byte unsigned integer,
    // adjusting the location pointer and offset after reading.
    DECODE_LEB128_UWORD_LEN_CK(loc_ptr, operand1,leb128_length,
        dbg,error_ptr,section_end);
    offset = offset + leb128_length;

    DECODE_LEB128_UWORD_LEN_CK(loc_ptr, operand2,leb128_length,
        dbg,error_ptr,section_end);
    offset = offset + leb128_length;

    // Obtain the data block based on the size
    operand3 = (Dwarf_Unsigned)(uintptr_t)loc_ptr;
    offset = offset + operand2;
    loc_ptr = loc_ptr + operand2;
    if (loc_ptr > section_end) {
        _dwarf_error(dbg,error_ptr,DW_DLE_LOCEXPR_OFF_SECTION_END);
        return DW_DLV_ERROR;
    }

    break;

case DW_OP_regval_type:           /* DWARF5 */
    // Handle DW_OP_regval_type operation by decoding two unsigned LEB128 values:
    // one representing a register number and the other a CU-relative DIE offset.
    DECODE_LEB128_UWORD_LEN_CK(loc_ptr, operand1,leb128_length,
        dbg,error_ptr,section_end);
    offset = offset + leb128_length;

    DECODE_LEB128_UWORD_LEN_CK(loc_ptr, operand2,leb128_length,
        dbg,error_ptr,section_end);
    offset = offset + leb128_length;

    break;

case DW_OP_convert:           /* DWARF5 */
case DW_OP_convertx:           /* DWARF5 */
case DW_OP_convert2:           /* DWARF5 */
case DW_OP_convert4:           /* DWARF5 */
case DW_OP_convert8:           /* DWARF5 */
case DW_OP_convertu:           /* DWARF5 */
case DW_OP_convertxu:           /* DWARF5 */
case DW_OP_convert2u:           /* DWARF5 */
case DW_OP_convert4u:           /* DWARF5 */
case DW_OP_convert8u:           /* DWARF5 */
case DW_OP_convert_s:           /* DWARF5 */
case DW_OP_convertx_s:           /* DWARF5 */
case DW_OP_convert2_s:           /* DWARF5 */
case DW_OP_convert4_s:           /* DWARF5 */
case DW_OP_convert8_s:           /* DWARF5 */
case DW_OP_convertu_s:           /* DWARF5 */
case DW_OP_convertxu_s:           /* DWARF5 */
case DW_OP_convert2u_s:           /* DWARF5 */
case DW_OP_convert4u_s:           /* DWARF5 */
case DW_OP_convert8u_s:           /* DWARF5 */
    // Handle DW_OP_convert and DW_OP_reinterpret operations by decoding an unsigned
    // LEB128 value representing a DIE offset or zero.
    DECODE_LEB128_UWORD_LEN_CK(loc_ptr, operand1,leb128_length,
        dbg,error_ptr,section_end);
    offset = offset + leb128_length;

    break;

case DW_OP_reinterpret:           /* DWARF5 */
case DW_OP_reinterpretx:           /* DWARF5 */
case DW_OP_reinterpret2:           /* DWARF5 */
case DW_OP_reinterpret4:           /* DWARF5 */
case DW_OP_reinterpret8:           /* DWARF5 */
case DW_OP_reinterpretu:           /* DWARF5 */
case DW_OP_reinterpretxu:           /* DWARF5 */
case DW_OP_reinterpret2u:           /* DWARF5 */
case DW_OP_reinterpret4u:           /* DWARF5 */
case DW_OP_reinterpret8u:           /* DWARF5 */
case DW_OP_reinterpret_s:           /* DWARF5 */
case DW_OP_reinterpretx_s:           /* DWARF5 */
case DW_OP_reinterpret2_s:           /* DWARF5 */
case DW_OP_reinterpret4_s:           /* DWARF5 */
case DW_OP_reinterpret8_s:           /* DWARF5 */
case DW_OP_reinterpretu_s:           /* DWARF5 */
case DW_OP_reinterpretxu_s:           /* DWARF5 */
case DW_OP_reinterpret2u_s:           /* DWARF5 */
case DW_OP_reinterpret4u_s:           /* DWARF5 */
case DW_OP_reinterpret8u_s:           /* DWARF5 */
    // Handle DW_OP_convert and DW_OP_reinterpret operations by decoding an unsigned
    // LEB128 value representing a DIE offset or zero.
    DECODE_LEB128_UWORD_LEN_CK(loc_ptr, operand1,leb128_length,
        dbg,error_ptr,section_end);
    offset = offset + leb128_length;

    break;

case DW_OP_GNU_parameter_ref: /* DWARF5 */
    // Handle DW_OP_GNU_parameter_ref operation by reading a 4-byte unsigned integer,
    // adjusting the location pointer and offset after reading.
    READ_UNALIGNED_CK(dbg, operand1, Dwarf_Unsigned, loc_ptr, 4,
        error_ptr,section_end);
    loc_ptr = loc_ptr + 4;
    offset = offset + 4;
    break;