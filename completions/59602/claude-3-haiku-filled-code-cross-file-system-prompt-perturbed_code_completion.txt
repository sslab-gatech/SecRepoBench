case DW_OP_const_type:
    // Decode a CU-relative DIE offset and a subsequent data block size,
    // then obtain the data block based on the size, adjusting the location
    // pointer and offset accordingly.
    DECODE_LEB128_UWORD_LEN_CK(loc_ptr, operand1, leb128_length,
        dbg, error_ptr, section_end);
    offset = offset + leb128_length;

    // Obtain the data block based on the size
    operand2 = (Dwarf_Unsigned)(uintptr_t)loc_ptr;
    offset = offset + operand1;
    loc_ptr = loc_ptr + operand1;
    if (loc_ptr > section_end) {
        _dwarf_error(dbg, error_ptr, DW_DLE_LOCEXPR_OFF_SECTION_END);
        return DW_DLV_ERROR;
    }
    break;

case DW_OP_regval_type:
case DW_OP_GNU_regval_type:
    // Decode a register number and a CU-relative DIE offset
    DECODE_LEB128_UWORD_LEN_CK(loc_ptr, operand1, leb128_length,
        dbg, error_ptr, section_end);
    offset = offset + leb128_length;

    DECODE_LEB128_UWORD_LEN_CK(loc_ptr, operand2, leb128_length,
        dbg, error_ptr, section_end);
    offset = offset + leb128_length;
    break;

case DW_OP_convert:
case DW_OP_GNU_convert:
case DW_OP_reinterpret:
case DW_OP_GNU_reinterpret:
    // Decode a CU-relative DIE offset or zero
    DECODE_LEB128_UWORD_LEN_CK(loc_ptr, operand1, leb128_length,
        dbg, error_ptr, section_end);
    offset = offset + leb128_length;
    break;

case DW_OP_GNU_parameter_ref:
    // Read a 4-byte unsigned integer
    READ_UNALIGNED_CK(dbg, operand1, Dwarf_Unsigned, loc_ptr, 4,
        error_ptr, section_end);
    loc_ptr = loc_ptr + 4;
    if (loc_ptr > section_end) {
        _dwarf_error_string(dbg, error_ptr, DW_DLE_LOCEXPR_OFF_SECTION_END,
            "DW_DLE_LOCEXPR_OFF_SECTION_END: Error reading "
            "DW_OP_GNU_parameter_ref.");
        return DW_DLV_ERROR;
    }
    offset = offset + 4;
    break;