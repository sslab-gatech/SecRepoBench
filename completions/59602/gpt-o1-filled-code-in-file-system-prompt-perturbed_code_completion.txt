case DW_OP_const_type:           /* DWARF5 */
    case DW_OP_GNU_const_type: {
        /* Decode a CU-relative DIE offset (operand1) and a subsequent data
           block size (operand2). Then read the block (operand3) accordingly. */
        DECODE_LEB128_UWORD_LEN_CK(loc_ptr, operand1, leb128_length,
            dbg, error_ptr, section_end);
        offset += leb128_length;
        if (loc_ptr > section_end) {
            _dwarf_error(dbg,error_ptr,DW_DLE_LOCEXPR_OFF_SECTION_END);
            return DW_DLV_ERROR;
        }
        DECODE_LEB128_UWORD_LEN_CK(loc_ptr, operand2, leb128_length,
            dbg, error_ptr, section_end);
        offset += leb128_length;
        if (loc_ptr + operand2 > section_end) {
            _dwarf_error(dbg,error_ptr,DW_DLE_LOCEXPR_OFF_SECTION_END);
            return DW_DLV_ERROR;
        }
        operand3 = (Dwarf_Unsigned)(uintptr_t)loc_ptr;
        loc_ptr += operand2;
        offset += operand2;
        break;
    }

    case DW_OP_regval_type:
    case DW_OP_GNU_regval_type: {
        /* Decode two unsigned LEB128 operands: the register number (operand1)
           and a CU-relative DIE offset (operand2). */
        DECODE_LEB128_UWORD_LEN_CK(loc_ptr, operand1, leb128_length,
            dbg, error_ptr, section_end);
        offset += leb128_length;
        if (loc_ptr > section_end) {
            _dwarf_error(dbg,error_ptr,DW_DLE_LOCEXPR_OFF_SECTION_END);
            return DW_DLV_ERROR;
        }
        DECODE_LEB128_UWORD_LEN_CK(loc_ptr, operand2, leb128_length,
            dbg, error_ptr, section_end);
        offset += leb128_length;
        if (loc_ptr > section_end) {
            _dwarf_error(dbg,error_ptr,DW_DLE_LOCEXPR_OFF_SECTION_END);
            return DW_DLV_ERROR;
        }
        break;
    }

    case DW_OP_convert:
    case DW_OP_reinterpret:
    case DW_OP_GNU_convert:
    case DW_OP_GNU_reinterpret: {
        /* Decode a single unsigned LEB128 offset. A value of 0 means "no type". */
        DECODE_LEB128_UWORD_LEN_CK(loc_ptr, operand1, leb128_length,
            dbg, error_ptr, section_end);
        offset += leb128_length;
        if (loc_ptr > section_end) {
            _dwarf_error(dbg,error_ptr,DW_DLE_LOCEXPR_OFF_SECTION_END);
            return DW_DLV_ERROR;
        }
        break;
    }

    case DW_OP_GNU_parameter_ref: {
        /* Read a 4-byte unsigned integer representing a parameter reference. */
        READ_UNALIGNED_CK(dbg, operand1, Dwarf_Unsigned, loc_ptr,
            4, error_ptr, section_end);
        loc_ptr += 4;
        offset += 4;
        if (loc_ptr > section_end) {
            _dwarf_error(dbg,error_ptr,DW_DLE_LOCEXPR_OFF_SECTION_END);
            return DW_DLV_ERROR;
        }
        break;
    }