case DW_OP_GNU_const_type: {
        // Handle DW_OP_GNU_const_type operation by decoding a CU-relative DIE offset
        // and a subsequent data block size, then obtain the data block based on the
        // size, adjusting the location pointer and offset accordingly.
        //
        // Handle DW_OP_regval_type (and DW_OP_GNU_regval_type) by decoding two
        // unsigned LEB128 values: one representing a register number and the other
        // a CU-relative DIE offset.
        //
        // Handle DW_OP_convert and DW_OP_reinterpret (and their GNU counterparts)
        // by decoding an unsigned LEB128 value representing a DIE offset or zero.
        //
        // Handle DW_OP_GNU_parameter_ref by reading a 4-byte unsigned integer,
        // adjusting the location pointer and offset after reading.
        DECODE_LEB128_UWORD_LEN_CK(loc_ptr, operand1, leb128_length, dbg, error_ptr, section_end);
        offset = offset + leb128_length;

        // Second operand is block of 'operand1' bytes of stuff.
        // This using the second operand as a pointer is quite ugly.
        // This gets an ugly compiler warning. Sorry.
        operand2 = (Dwarf_Unsigned)(uintptr_t)loc_ptr;
        offset = offset + operand1;
        loc_ptr = loc_ptr + operand1;
        if (loc_ptr > section_end) {
            _dwarf_error(dbg, error_ptr, DW_DLE_LOCEXPR_OFF_SECTION_END);
            return DW_DLV_ERROR;
        }
    }