case DW_OP_GNU_const_type:      /* 0xf5 */
    /* DIE offset as uleb. */
    DECODE_LEB128_UWORD_LEN_CK(loc_ptr, operand1,leb128_length,
        dbg,error_ptr,section_end);
    offset = offset + leb128_length;

    /* Size of following data block */
    if (loc_ptr >= section_end) {
        _dwarf_error(dbg,error_ptr,DW_DLE_LOCEXPR_OFF_SECTION_END);
        return DW_DLV_ERROR;
    }
    operand2 = *(Dwarf_Small *) loc_ptr;
    loc_ptr = loc_ptr + 1;
    if (loc_ptr > section_end) {
        _dwarf_error(dbg,error_ptr,DW_DLE_LOCEXPR_OFF_SECTION_END);
        return DW_DLV_ERROR;
    }
    offset = offset + 1;

    /* now get the data block */
    /*  This using the third operand as a pointer
        is quite ugly. */
    operand3 = (Dwarf_Unsigned)(uintptr_t)loc_ptr;
    loc_ptr = loc_ptr + operand2;
    if (loc_ptr > section_end) {
        _dwarf_error(dbg,error_ptr,DW_DLE_LOCEXPR_OFF_SECTION_END);
        return DW_DLV_ERROR;
    }
    offset = offset + operand2;
    break;

case DW_OP_regval_type:      /* DWARF5 */
case DW_OP_GNU_regval_type: /* 0xf7 */
    /* uleb reg num. */
    DECODE_LEB128_UWORD_LEN_CK(loc_ptr, operand1,leb128_length,
        dbg,error_ptr,section_end);
    offset = offset + leb128_length;

    /* uleb DIE offset. */
    DECODE_LEB128_UWORD_LEN_CK(loc_ptr, operand2,leb128_length,
        dbg,error_ptr,section_end);
    offset = offset + leb128_length;
    break;

case DW_OP_convert:          /* DWARF5 */
case DW_OP_GNU_convert:     /* 0xf8 */
case DW_OP_reinterpret:      /* DWARF5 */
case DW_OP_GNU_reinterpret: /* 0xf9 */
    /*  DIE offset (for a base type) as uleb. Zero is
        special: means 'use the generic type of
        the current location description'. */
    DECODE_LEB128_UWORD_LEN_CK(loc_ptr, operand1,leb128_length,
        dbg,error_ptr,section_end);
    offset = offset + leb128_length;
    break;

case DW_OP_GNU_parameter_ref: /* 0xfa */
    /*  Jakub Jelinek: A reference to an earlier
        formal parameter as a 4 byte unsigned offset
        from the DW_TAG_compile_unit or DW_TAG_partial_unit
        DIE offset that contains the associated
        DW_TAG_formal_parameter being referenced. */
    READ_UNALIGNED_CK(dbg, operand1, Dwarf_Unsigned, loc_ptr, 4,
        error_ptr,section_end);
    loc_ptr = loc_ptr + 4;
    if (loc_ptr > section_end) {
        _dwarf_error(dbg,error_ptr,DW_DLE_LOCEXPR_OFF_SECTION_END);
        return DW_DLV_ERROR;
    }
    offset = offset + 4;
    break;