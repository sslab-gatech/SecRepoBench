case DW_OP_const_type:           /* DWARF5 */
case DW_OP_GNU_const_type:       /* GNU extension */
    /* First operand is a CU-relative DIE offset (ULEB). */
    DECODE_LEB128_UWORD_LEN_CK(loc_ptr, operand1, leb128_length,
        dbg,error_ptr,section_end);
    offset += leb128_length;

    /* Second operand is the size of the data block (ULEB). */
    DECODE_LEB128_UWORD_LEN_CK(loc_ptr, operand2, leb128_length,
        dbg,error_ptr,section_end);
    offset += leb128_length;

    /* Third operand is a pointer to the data block. */
    operand3 = (Dwarf_Unsigned)(uintptr_t)loc_ptr;
    loc_ptr += operand2;
    offset += operand2;
    if (loc_ptr > section_end) {
        _dwarf_error(dbg,error_ptr,DW_DLE_LOCEXPR_OFF_SECTION_END);
        return DW_DLV_ERROR;
    }
    break;

case DW_OP_regval_type:          /* DWARF5 */
case DW_OP_GNU_regval_type:      /* GNU extension */
    /* First operand is a register number (ULEB). */
    DECODE_LEB128_UWORD_LEN_CK(loc_ptr, operand1, leb128_length,
        dbg,error_ptr,section_end);
    offset += leb128_length;

    /* Second operand is the CU-relative DIE offset (ULEB). */
    DECODE_LEB128_UWORD_LEN_CK(loc_ptr, operand2, leb128_length,
        dbg,error_ptr,section_end);
    offset += leb128_length;
    break;

case DW_OP_convert:              /* DWARF5 */
case DW_OP_reinterpret:          /* DWARF5 */
case DW_OP_GNU_convert:          /* GNU extension */
case DW_OP_GNU_reinterpret:      /* GNU extension */
    /* Single operand is a DIE offset (ULEB) or zero. */
    DECODE_LEB128_UWORD_LEN_CK(loc_ptr, operand1, leb128_length,
        dbg,error_ptr,section_end);
    offset += leb128_length;
    break;

case DW_OP_GNU_parameter_ref:    /* GNU extension */
    /* Read a 4-byte unsigned integer. */
    READ_UNALIGNED_CK(dbg, operand1, Dwarf_Unsigned, loc_ptr, 4,
        error_ptr,section_end);
    loc_ptr += 4;
    offset += 4;
    break;