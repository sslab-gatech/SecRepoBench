case DW_OP_GNU_const_type: /* 0xf5 */
case DW_OP_const_type:     /* DWARF5 */
    /* CU relative DIE offset (uleb128). */
    DECODE_LEB128_UWORD_LEN_CK(loc_ptr, operand1, leb128_length,
        dbg, error_ptr, section_end);
    offset = offset + leb128_length;

    /* Size of the block in bytes (1 byte). */
    if (loc_ptr >= section_end) {
        _dwarf_error(dbg, error_ptr, DW_DLE_LOCEXPR_OFF_SECTION_END);
        return DW_DLV_ERROR;
    }
    operand2 = *(Dwarf_Small *)loc_ptr;
    loc_ptr++;
    offset++;
    if (loc_ptr > section_end) {
        _dwarf_error(dbg, error_ptr, DW_DLE_LOCEXPR_OFF_SECTION_END);
        return DW_DLV_ERROR;
    }

    /* Block of data. */
    operand3 = (Dwarf_Unsigned)(uintptr_t)loc_ptr;
    loc_ptr += operand2;
    offset += operand2;
    if (loc_ptr > section_end) {
        _dwarf_error(dbg, error_ptr, DW_DLE_LOCEXPR_OFF_SECTION_END);
        return DW_DLV_ERROR;
    }
    break;

case DW_OP_GNU_regval_type: /* 0xf7 */
case DW_OP_regval_type:     /* DWARF5 */
    /* Register number (uleb128). */
    DECODE_LEB128_UWORD_LEN_CK(loc_ptr, operand1, leb128_length,
        dbg, error_ptr, section_end);
    offset = offset + leb128_length;

    /* CU relative DIE offset (uleb128). */
    DECODE_LEB128_UWORD_LEN_CK(loc_ptr, operand2, leb128_length,
        dbg, error_ptr, section_end);
    offset = offset + leb128_length;
    break;

case DW_OP_GNU_convert: /* 0xf8 */
case DW_OP_convert:     /* DWARF5 */
case DW_OP_GNU_reinterpret: /* 0xf9 */
case DW_OP_reinterpret:     /* DWARF5 */
    /* CU relative DIE offset or zero (uleb128). */
    DECODE_LEB128_UWORD_LEN_CK(loc_ptr, operand1, leb128_length,
        dbg, error_ptr, section_end);
    offset = offset + leb128_length;
    break;

case DW_OP_GNU_parameter_ref: /* 0xfa */
    /* 4 byte unsigned integer. */
    READ_UNALIGNED_CK(dbg, operand1, Dwarf_Unsigned, loc_ptr, 4,
        error_ptr, section_end);
    loc_ptr += 4;
    offset += 4;
    break;